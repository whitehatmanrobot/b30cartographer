------

BOOL
AllLinksAreModems(
    IN PBENTRY* pEntry )

    // Returns true if all links associated with the entry are modem links
    // (MXS or Unimodem), false otherwise.
    //
{
    DTLNODE* pNode;

    if (pEntry->pdtllistLinks)
    {
        for (pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
             pNode;
             pNode = DtlGetNextNode( pNode ))
        {
            PBLINK* pLink = (PBLINK* )DtlGetData( pNode );

            if (pLink->pbport.pbdevicetype != PBDT_Modem)
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}

BOOL 
AllowDccWizard(
    IN HANDLE hConnection)

    // Finds out if there are any dcc devices installed on the local
    // machine or if there are any available com ports.  If neither
    // condition is satisfied, then we return FALSE, otherwise TRUE.
{
    DWORD dwErr, dwUsedCount = 0;
    COUNT_FREE_COM_PORTS_DATA CountFreeComPortsData,
                              *pCfcpd = &CountFreeComPortsData;
    DTLNODE* pNodeP, *pNodeL, *pNode;
    BOOL bRet = FALSE;

    // Initialize
    ZeroMemory(pCfcpd, sizeof(COUNT_FREE_COM_PORTS_DATA));

    do 
    {
        // Load ras if it wasn't already loaded
        dwErr = LoadRas( g_hinstDll, NULL );
        if (dwErr != 0)
        {
            return FALSE;
        }
    
        // Load in all of the ports and count the number of 
        // dcc devices
        dwErr = LoadPortsList2(
                    hConnection, 
                    &(pCfcpd->pListPortsInUse),
                    FALSE);
        if (dwErr != NO_ERROR)
        {
            bRet = FALSE;
            break;
        }

        // Count the dcc devices
        for (pNodeL = DtlGetFirstNode( pCfcpd->pListPortsInUse );
             pNodeL;
             pNodeL = DtlGetNextNode( pNodeL ))
        {
            PBLINK* pLink = (PBLINK* )DtlGetData( pNodeL );
            if (pLink->pbport.dwType == RASET_Direct)
            {
                bRet = TRUE;
                break;
            }
        }
        if (bRet == TRUE)
        {
            break;
        }

        // pmay: 249346
        //
        // Only merge the com ports if the user is an admin since
        // admin privilege is required to install a null modem.
        //
        if (FIsUserAdminOrPowerUser())
        {
            // Count the number of available com ports
            dwErr = MdmEnumComPorts (
                        CountFreeComPorts, 
                        (HANDLE)pCfcpd);
            if (dwErr != NO_ERROR)
            {
                bRet = FALSE;
                break;
            }

            bRet = (pCfcpd->dwCount > 0) ? TRUE : FALSE;
        }

    } while (FALSE);

    // Cleanup
    {
        if ( pCfcpd->pListPortsInUse )
        {
            DtlDestroyList(pCfcpd->pListPortsInUse, DestroyPortNode);
        }
    }

    return bRet;
}


DWORD
AuthRestrictionsFromTypicalAuth(
    IN DWORD dwTypicalAuth )

    // Return the AR_F_* flag corresponding to the TA_* value 'dwTypicalAuth',
    // i.e. convert a typical authentication selection to a bitmask of
    // authentication protocols.
    //
{
    if (dwTypicalAuth == TA_Secure)
    {
        return AR_F_TypicalSecure;
    }
    else if (dwTypicalAuth == TA_CardOrCert)
    {
        return AR_F_TypicalCardOrCert;
    }
    else
    {
        return AR_F_TypicalUnsecure;
    }
}


ULONG
CallbacksActive(
    INT nSetTerminateAsap,
    BOOL* pfTerminateAsap )

    // If 'fSetTerminateAsap' >= 0, sets 'g_fTerminateAsap' flag to 'nSetTerminateAsap'.
    // If non-NULL, caller's '*pfTerminateAsap' is filled with the current value of
    // 'g_fTerminateAsap'.
    //
    // Returns the number of Rasdial callback threads active.
    //
{
    ULONG ul;

    TRACE1( "CallbacksActive(%d)", nSetTerminateAsap );

    ul = 0;
    if (WaitForSingleObject( g_hmutexCallbacks, INFINITE ) == WAIT_OBJECT_0)
    {
        if (pfTerminateAsap)
        {
            *pfTerminateAsap = g_fTerminateAsap;
        }

        if (nSetTerminateAsap >= 0)
        {
            g_fTerminateAsap = (BOOL )nSetTerminateAsap;
        }

        ul = g_ulCallbacksActive;

        ReleaseMutex( g_hmutexCallbacks );
    }

    TRACE1( "CallbacksActive=%d", ul );

    return ul;
}


VOID
ContextHelp(
    IN const DWORD* padwMap,
    IN HWND   hwndDlg,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam)
{
    ContextHelpX( padwMap, hwndDlg, unMsg, wparam, lparam, FALSE );
}


VOID
ContextHelpX(
    IN const DWORD* padwMap,
    IN HWND   hwndDlg,
    IN UINT   unMsg,
    IN WPARAM wparam,
    IN LPARAM lparam,
    IN BOOL   fRouter)

    // Calls WinHelp to popup context sensitive help.  'PadwMap' is an array
    // of control-ID help-ID pairs terminated with a 0,0 pair.  'UnMsg' is
    // WM_HELP or WM_CONTEXTMENU indicating the message received requesting
    // help.  'Wparam' and 'lparam' are the parameters of the message received
    // requesting help.
    //
{
    HWND hwnd;
    UINT unType;
    TCHAR* pszHelpFile;

    ASSERT( unMsg==WM_HELP || unMsg==WM_CONTEXTMENU );

    // Don't try to do help if it won't work.  See common\uiutil\ui.c.
    //
    {
        extern BOOL g_fNoWinHelp;
        if (g_fNoWinHelp)
        {
            return;
        }
    }

    if (unMsg == WM_HELP)
    {
        LPHELPINFO p = (LPHELPINFO )lparam;;

        TRACE3( "ContextHelp(WM_HELP,t=%d,id=%d,h=$%08x)",
            p->iContextType, p->iCtrlId,p->hItemHandle );

        if (p->iContextType != HELPINFO_WINDOW)
        {
            return;
        }

        hwnd = p->hItemHandle;
        ASSERT( hwnd );
        unType = HELP_WM_HELP;
    }
    else
    {
        // Standard Win95 method that produces a one-item "What's This?" menu
        // that user must click to get help.
        //
        TRACE1( "ContextHelp(WM_CONTEXTMENU,h=$%08x)", wparam );

        hwnd = (HWND )wparam;
        unType = HELP_CONTEXTMENU;
    };

    if (fRouter)
    {
        pszHelpFile = g_pszRouterHelpFile;
    }
    else
    {
        pszHelpFile = g_pszHelpFile;
    }

    TRACE1( "WinHelp(%s)", pszHelpFile );
    WinHelp( hwnd, pszHelpFile, unType, (ULONG_PTR ) padwMap );
}


VOID
CopyLinkPhoneNumberInfo(
    OUT DTLNODE* pDstLinkNode,
    IN DTLNODE* pSrcLinkNode )

    // Copies the source link's phone number information to the destination
    // link.  Any existing destination information is properly destroyed.  The
    // arguments are DTLNODEs containing PBLINKs.
    //
{
    PBLINK* pSrcLink;
    PBLINK* pDstLink;
    DTLLIST* pDstList;

    pSrcLink = (PBLINK* )DtlGetData( pSrcLinkNode );
    pDstLink = (PBLINK* )DtlGetData( pDstLinkNode );

    pDstList =
         DtlDuplicateList(
             pSrcLink->pdtllistPhones, DuplicatePhoneNode, DestroyPhoneNode );

    if (pDstList)
    {
        DtlDestroyList( pDstLink->pdtllistPhones, DestroyPhoneNode );
        pDstLink->pdtllistPhones = pDstList;

        pDstLink->fPromoteAlternates = pSrcLink->fPromoteAlternates;
        pDstLink->fTryNextAlternateOnFail = pSrcLink->fTryNextAlternateOnFail;
    }
}


VOID
CopyPszListToPhoneList(
    IN OUT PBLINK* pLink,
    IN DTLLIST* pListPhoneNumbers )

    // Converts the phone number list of 'pLink' to be list created using the
    // the list of Psz phone numbers 'pListPhoneNumbers' for phone numbers.
    //
{
    DTLNODE* pNodeP;
    DTLNODE* pNodeZ;

    // Empty the existing list of PBPHONE nodes.
    //
    while (pNodeP = DtlGetFirstNode( pLink->pdtllistPhones ))
    {
        DtlRemoveNode( pLink->pdtllistPhones, pNodeP );
        DestroyPhoneNode( pNodeP );
    }

    // Recreate the list of PBPHONE nodes from the list of PSZ nodes.
    //
    for (pNodeZ = DtlGetFirstNode( pListPhoneNumbers );
         pNodeZ;
         pNodeZ = DtlGetNextNode( pNodeZ ))
    {
        PBPHONE* pPhone;

        pNodeP = CreatePhoneNode();
        if (!pNodeP)
        {
            continue;
        }

        pPhone = (PBPHONE* )DtlGetData( pNodeP );
        ASSERT( pPhone );

        Free0( pPhone->pszPhoneNumber );
        pPhone->pszPhoneNumber =
            StrDup( (TCHAR* )DtlGetData( pNodeZ ) );

        DtlAddNodeLast( pLink->pdtllistPhones, pNodeP );
    }
}

BOOL 
CountFreeComPorts(
    IN PWCHAR pszPort,
    IN HANDLE hData)

    // Com port enumeration function that counts the list of
    // free com ports.  Returns TRUE to stop enumeration (see 
    // MdmEnumComPorts)
{
    COUNT_FREE_COM_PORTS_DATA* pfcpData = (COUNT_FREE_COM_PORTS_DATA*)hData;
    DTLLIST* pListUsed = pfcpData->pListPortsInUse;
    DTLNODE* pNodeP, *pNodeL, *pNode;

    // If the given port is in the used list, then return 
    // so that it is not added to the list of free ports and
    // so that enumeration continues.
    for (pNodeL = DtlGetFirstNode( pListUsed );
         pNodeL;
         pNodeL = DtlGetNextNode( pNodeL ))
    {
        PBLINK* pLink = (PBLINK* )DtlGetData( pNodeL );
        ASSERT( pLink->pbport.pszPort );

        // The port already appears in a link in the list.
        if (lstrcmp( pLink->pbport.pszPort, pszPort ) == 0)
            return FALSE;
    }

    // The port is not in use.  Increment the count.
    pfcpData->dwCount += 1;

    return FALSE;
}


HWND
CreateWizardBitmap(
    IN HWND hwndDlg,
    IN BOOL fPage )

    // Create a static control that displays the RAS wizard bitmap at the
    // standard place on dialog 'hwndDlg'.  'FPage' is set if the bitmap is
    // being placed on a property page, false for the equivalent placement on
    // a dialog.
    //
    // Returns the bitmap window handle or NULL or error.
    //
{
    HWND hwnd;
    INT x;
    INT y;

    if (fPage)
    {
        x = y = 0;
    }
    else
    {
        x = y = 10;
    }

    hwnd =
        CreateWindowEx(
            0,
            TEXT("static"),
            NULL,
            WS_VISIBLE | WS_CHILD | SS_SUNKEN | SS_BITMAP,
            x, y, 80, 140,
            hwndDlg,
            (HMENU )CID_BM_Wizard,
            g_hinstDll,
            NULL );

    if (hwnd)
    {
        if (!g_hbmWizard)
        {
            g_hbmWizard = LoadBitmap(
                g_hinstDll, MAKEINTRESOURCE( BID_Wizard ) );
        }

        SendMessage( hwnd, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM )g_hbmWizard );
    }

    return hwnd;
}

TCHAR*
DisplayPszFromDeviceAndPort(
    IN TCHAR* pszDevice,
    IN TCHAR* pszPort )

    // Returns address of heap block psz containing the MXS modem list display
    // form, i.e. the device name 'pszDevice' followed by the port name
    // 'pszPort'.  It's caller's responsibility to Free the returned string.
    //
{
    TCHAR* pszResult;
    TCHAR* pszD;

    if (pszDevice)
    {
        pszD = NULL;
    }
    else
    {
        pszD = pszDevice = PszFromId( g_hinstDll, SID_UnknownDevice );
    }

    pszResult = PszFromDeviceAndPort( pszDevice, pszPort );
    Free0( pszD );

    return pszResult;
}


TCHAR*
DisplayPszFromPpbport(
    IN PBPORT* pPort,
    OUT DWORD* pdwDeviceIcon )

    // Returns address of heap block psz containing the device display form of
    // the 'pPort', e.g. "Modem - KTel 28.8 Fax Plus" It's caller's
    // responsibility to Free the returned string.  If non-NULL,
    // '*pdwDeviceIcon' is set to the DI_* device icon code corresponding to
    // the device.  DI_* codes are used with the RAS ListView extensions to
    // show the correct item icon.
    //
{
    TCHAR* pszFormat;
    TCHAR* pszD;
    TCHAR* pszDT;
    TCHAR* pszDevice;
    TCHAR* pszDeviceType;
    TCHAR* pszResult;
    DWORD dwDeviceIcon;
    LPCTSTR pszChannel = NULL;

    // These are set if a resource string is read that must be Freed later.
    //
    pszDT = NULL;
    pszD = NULL;

    if (pPort->pszDevice)
    {
        pszDevice = pPort->pszDevice;
    }
    else
    {
        pszDevice = PszFromId( g_hinstDll, SID_UnknownDevice );

        if(NULL == pszDevice)
        {
            return NULL;
        }
        
        pszD = pszDevice;
    }

    // Set default format and device icon, though they may be changed below.
    //
    pszFormat = TEXT("%s - %s (%s)");
    dwDeviceIcon = DI_Adapter;

    if (pPort->pbdevicetype == PBDT_Modem
        && !(pPort->dwFlags & PBP_F_NullModem))
    {
        pszDeviceType = PszFromId( g_hinstDll, SID_Modem );
        pszDT = pszDeviceType;
        dwDeviceIcon = DI_Modem;
    }
    else if (pPort->pbdevicetype == PBDT_Isdn)
    {
        pszDeviceType = PszFromId( g_hinstDll, SID_Isdn );
        pszDT = pszDeviceType;
        pszFormat = TEXT("%s %s - %s");
    }
    else if (pPort->pbdevicetype == PBDT_X25)
    {
        pszDeviceType = PszFromId( g_hinstDll, SID_X25 );
        pszDT = pszDeviceType;
    }
    else if (pPort->pbdevicetype == PBDT_Pad)
    {
        pszDeviceType = PszFromId( g_hinstDll, SID_X25Pad );
        pszDT = pszDeviceType;
    }
    else
    {
        // Don't know the device type, so just bag the device descriptive word
        // and let the device name stand alone.
        //
        pszDeviceType = TEXT("");
        pszFormat = TEXT("%s%s (%s)");
    }

    if(NULL == pszDeviceType)
    {   
        pszDeviceType = TEXT("");
    }

    if(pPort->pbdevicetype != PBDT_Isdn)
    {
        pszResult = Malloc(
            (lstrlen( pszFormat ) + lstrlen( pszDeviceType ) + lstrlen( pszDevice ) + lstrlen( pPort->pszPort ))
                * sizeof(TCHAR) );
    }
    else
    {

        pszChannel = PszLoadString( g_hinstDll, SID_Channel );

        if(NULL == pszChannel)
        {
            pszChannel = TEXT("");
        }

        // For isdn use the following format
        // "Isdn channel - <DeviceName>
        // Talk to steve falcon about this if you have issues
        // with special casing isdn.
        //
        pszResult = Malloc(
            (lstrlen( pszFormat ) + lstrlen( pszDeviceType ) + lstrlen(pszChannel) + lstrlen( pszDevice ))
                * sizeof(TCHAR));
    }
    

    if (pszResult)
    {
        if(pPort->pbdevicetype != PBDT_Isdn)
        {
            wsprintf( pszResult, pszFormat, pszDeviceType, pszDevice, pPort->pszPort);
        }
        else
        {
            ASSERT(NULL != pszChannel);
            wsprintf( pszResult, pszFormat, pszDeviceType, pszChannel, pszDevice);
        }
    }

    if (pdwDeviceIcon)
    {
#if 1
        // Per SteveFal.  Wants "modem" icon for all if Device-Manager-style
        // physically descriptive icons cannot be used.
        //
        dwDeviceIcon = DI_Modem;
#endif
        *pdwDeviceIcon = dwDeviceIcon;
    }

    Free0( pszD );
    Free0( pszDT );

    return pszResult;
}


VOID
EnableCbWithRestore(
    IN HWND hwndCb,
    IN BOOL fEnable,
    IN BOOL fDisabledCheck,
    IN OUT BOOL* pfRestore )

    // Enable/disable the checkbox 'hwndCb' based on the 'fEnable' flag
    // including stashing and restoring a cached value '*pfRestore' when
    // disabled.  When disabling, the check value is set to 'fDisabledCheck'.
    //
{
    if (fEnable)
    {
        if (!IsWindowEnabled( hwndCb ))
        {
            // Toggling to enabled.  Restore the stashed check value.
            //
            Button_SetCheck( hwndCb, *pfRestore );
            EnableWindow( hwndCb, TRUE );
        }
    }
    else
    {
        if (IsWindowEnabled( hwndCb ))
        {
            // Toggling to disabled.  Stashed the current check value.
            //
            *pfRestore = Button_GetCheck( hwndCb );
            Button_SetCheck( hwndCb, fDisabledCheck );
            EnableWindow( hwndCb, FALSE );
        }
    }
}


VOID
EnableLbWithRestore(
    IN HWND hwndLb,
    IN BOOL fEnable,
    IN OUT INT* piRestore )

    // Enable/disable the combobox 'hwndLb' based on the 'fEnable' flag.  If
    // disabling, '*piRestore' is loaded with the stashed selection index and
    // a blank item is added to the front of the list and selected.  This is
    // undone if enabling.
    //
{
    if (fEnable)
    {
        if (!IsWindowEnabled( hwndLb ))
        {
            // Toggling to enabled.  Restore the stashed selection.
            //
            ComboBox_DeleteString( hwndLb, 0 );
            ComboBox_SetCurSelNotify( hwndLb, *piRestore );
            EnableWindow( hwndLb, TRUE );
        }
    }
    else
    {
        if (IsWindowEnabled( hwndLb ))
        {
            // Toggling to disabled.  Stash the selection index.
            //
            *piRestore = ComboBox_GetCurSel( hwndLb );
            ComboBox_InsertString( hwndLb, 0, TEXT("") );
            ComboBox_SetItemData( hwndLb, 0, NULL );
            ComboBox_SetCurSelNotify( hwndLb, 0 );
            EnableWindow( hwndLb, FALSE );
        }
    }
}


DTLNODE*
FirstPhoneNodeFromPhoneList(
    IN DTLLIST* pListPhones )

    // Return the first PBPHONE node in list of PBPHONEs 'pListPhones' or a
    // default node if none.  Returns NULL if out of memory.
    //
{
    DTLNODE* pFirstNode;
    DTLNODE* pNode;

    pFirstNode = DtlGetFirstNode( pListPhones );
    if (pFirstNode)
    {
        pNode = DuplicatePhoneNode( pFirstNode );
    }
    else
    {
        pNode = CreatePhoneNode();
    }

    return pNode;
}


VOID
FirstPhoneNodeToPhoneList(
    IN DTLLIST* pListPhones,
    IN DTLNODE* pNewNode )

    // Replace the first PBPHONE node in list of PBPHONEs 'pListPhones' with
    // 'pNewNode', deleting any existing first node.  Caller's actual
    // 'pNewNode', not a copy, is linked.
    //
{
    DTLNODE* pFirstNode;
    DTLNODE* pNode;

    pFirstNode = DtlGetFirstNode( pListPhones );
    if (pFirstNode)
    {
        DtlRemoveNode( pListPhones, pFirstNode );
        DestroyPhoneNode( pFirstNode );
    }

    DtlAddNodeFirst( pListPhones, pNewNode );
}


#if 0 //!!!
TCHAR*
FirstPhoneNumberFromEntry(
    IN PBENTRY* pEntry )

    // Returns the first phone number of the first link of entry 'pEntry' or
    // an empty string if none.  The returned address is into the list of
    // phone numbers and should be copied if it needs to be stored.
    //
{
    TCHAR* pszPhoneNumber;
    DTLNODE* pNode;
    PBLINK*  pLink;

    TRACE( "FirstPhoneNumberFromEntry" );

    ASSERT( pEntry->pdtllistLinks );
    pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
    ASSERT( pNode );
    pLink = (PBLINK* )DtlGetData( pNode );
    ASSERT( pLink );

    return FirstPszFromList( pLink->pdtllistPhoneNumbers );
}
#endif


TCHAR*
FirstPszFromList(
    IN DTLLIST* pPszList )

    // Returns the first string from the first node of 'pPszList' or an empty
    // string if none.  The returned address is into the list and should be
    // copied if it needs to be stored.
    //
{
    TCHAR* psz;
    DTLNODE* pNode;

    TRACE( "FirstPszFromList" );

    if (DtlGetNodes( pPszList ) > 0)
    {
        pNode = DtlGetFirstNode( pPszList );
        ASSERT( pNode );
        psz = (TCHAR* )DtlGetData( pNode );
        ASSERT( psz );
    }
    else
    {
        psz = TEXT("");
    }

    return psz;
}


#if 0 //!!!
DWORD
FirstPhoneNumberToEntry(
    IN PBENTRY* pEntry,
    IN TCHAR* pszPhoneNumber )

    // Sets the first phone number of the first link of entry 'pEntry' to
    // 'pszPhoneNumber'.
    //
    // Returns 0 if successful, or an error code.
    //
{
    DTLNODE* pNode;
    PBLINK* pLink;
    TCHAR* pszNew;

    TRACE( "FirstPhoneNumberToEntry" );

    ASSERT( pEntry->pdtllistLinks );
    pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
    ASSERT( pNode );
    pLink = (PBLINK* )DtlGetData( pNode );
    ASSERT( pLink );
    ASSERT( pLink->pdtllistPhoneNumbers );

    return FirstPszToList( pLink->pdtllistPhoneNumbers, pszPhoneNumber );
}
#endif


DWORD
FirstPszToList(
    IN DTLLIST* pPszList,
    IN TCHAR* psz )

    // Sets the string of the first node of the list 'pPszList' to a copy of
    // 'psz'.  If 'psz' is "" the first node is deleted.
    //
    // Returns 0 if successful, or an error code.
    //
{
    DTLNODE* pNode;
    TCHAR* pszNew;

    ASSERT( pPszList );

    // Delete the existing first node, if any.
    //
    if (DtlGetNodes( pPszList ) > 0)
    {
        pNode = DtlGetFirstNode( pPszList );
        DtlRemoveNode( pPszList, pNode );
        DestroyPszNode( pNode );
    }

    // Create a new first node and link it.  An empty string is not added.
    //
    if (*psz == TEXT('\0'))
        return 0;

    pszNew = StrDup( psz );
    pNode = DtlCreateNode( pszNew, 0 );
    if (!pszNew || !pNode)
    {
        Free0( pszNew );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    DtlAddNodeFirst( pPszList, pNode );
    return 0;
}

//
// Function:    GetBoldWindowFont
//
// Purpose:     Generate bold or large bold fonts based on the font of the
//              window specified
//
// Parameters:  hwnd       [IN] - Handle of window to base font on
//              fLargeFont [IN] - If TRUE, generate a 12 point bold font for
//                                use in the wizard "welcome" page.
//              pBoldFont [OUT] - The newly generated font, NULL if the
//
// Returns:     nothing
//
VOID 
GetBoldWindowFont(
    IN  HWND hwnd, 
    IN  BOOL fLargeFont, 
    OUT HFONT * pBoldFont)
{
    LOGFONT BoldLogFont;
    HFONT   hFont;
    TCHAR   FontSizeString[MAX_PATH];
    INT     FontSize;
    HDC     hdc;
    
    *pBoldFont = NULL;

    // Get the font used by the specified window
    //
    hFont = (HFONT)SendMessage(hwnd, WM_GETFONT, 0, 0L);
    if (NULL == hFont)
    {
        // If not found then the control is using the system font
        //
        hFont = (HFONT)GetStockObject(SYSTEM_FONT);
    }

    if (hFont)
    {
        // Get the font info so we can generate the BOLD version
        //
        if (GetObject(hFont, sizeof(BoldLogFont), &BoldLogFont))
        {
            // Create the Bold Font
            //
            BoldLogFont.lfWeight   = FW_BOLD;

            hdc = GetDC(hwnd);
            if (hdc)
            {
                // Large (tall) font is an option
                //
                if (fLargeFont)
                {
                    // Load size and name from resources, 
                    // since these may change
                    // from locale to locale based on the 
                    // size of the system font, etc.
                    //
                    UINT nLen;
                    PWCHAR pszFontName = NULL, pszFontSize = NULL;

                    pszFontName = (PWCHAR)PszLoadString(
                                        g_hinstDll, 
                                        SID_LargeFontName);
                    pszFontSize = (PWCHAR)PszLoadString(
                                        g_hinstDll, 
                                        SID_LargeFontSize);
                    if (pszFontName != NULL)
                    {
                        lstrcpyn(
                            BoldLogFont.lfFaceName, 
                            pszFontName, 
                            sizeof(BoldLogFont.lfFaceName) / sizeof(TCHAR));
                    }

                    FontSize = 12;
                    nLen = lstrlen(pszFontName);
                    if (pszFontSize)
                    {
                        lstrcpyn(
                            FontSizeString, 
                            pszFontSize,
                            sizeof(FontSizeString) / sizeof(TCHAR));
                        FontSize = wcstoul((const TCHAR*)FontSizeString, NULL, 10);
                    }

                    BoldLogFont.lfHeight = 
                        0 - (GetDeviceCaps(hdc,LOGPIXELSY) * FontSize / 72);

                    //Free0(pszFontName);
                    //Free0(pszFontSize);
                }

                *pBoldFont = CreateFontIndirect(&BoldLogFont);
                ReleaseDC(hwnd, hdc);
            }
        }
    }
}

DWORD
GetDefaultEntryName(
    IN  PBFILE* pFile,
    IN  DWORD dwType,
    IN  BOOL fRouter,
    OUT TCHAR** ppszName )

    // Loads a default entry name into '*ppszName' that is unique within open
    // phonebook 'pFile', or if NULL, in all default phonebooks.  'FRouter' is
    // set if a router-style name should be chosen rather than a client-style
    // name.  It is caller's responsibility to Free the returned string.
    //
    // Returns 0 if successful or an error code.
    //
{
    DWORD dwErr;
    TCHAR szBuf[ RAS_MaxEntryName + 1 ];
    UINT unSid;
    LPCTSTR pszDefault;
    DWORD dwDefaultLen;
    LONG lNum;
    PBFILE file;
    DTLNODE* pNode;

    *ppszName = NULL;

    if (fRouter)
    {
        unSid = SID_DefaultRouterEntryName;
    }
    else
    {
        unSid = SID_DefaultEntryName;

        if (RASET_Vpn == dwType)
        {
            unSid = SID_DefaultVpnEntryName;
        }

        else if (RASET_Direct == dwType)
        {
            unSid = SID_DefaultDccEntryName;
        }

        else if (RASET_Broadband == dwType)
        {
            unSid = SID_DefaultBbEntryName;
        }
    }

    pszDefault = PszLoadString( g_hinstDll, unSid );
    lstrcpyn( szBuf, pszDefault, sizeof(szBuf) / sizeof(TCHAR) );
    dwDefaultLen = lstrlen( pszDefault ) + 1;   // +1 for extra space below
    lNum = 2;

    for (;;)
    {
        if (pFile)
        {
            if (!EntryNodeFromName( pFile->pdtllistEntries, szBuf ))
            {
                break;
            }
        }
        else
        {
            if (GetPbkAndEntryName(
                    NULL, szBuf, RPBF_NoCreate, &file, &pNode ) == 0)
            {
                ClosePhonebookFile( &file );
            }
            else
            {
                break;
            }
        }

        // Duplicate entry found so increment the default name and try the
        // next one.
        //
        lstrcpyn( szBuf, pszDefault, sizeof(szBuf) / sizeof(TCHAR) );
        lstrcat( szBuf, TEXT(" "));
        LToT( lNum, szBuf + dwDefaultLen, 10 );
        ++lNum;
    }

    *ppszName = StrDup( szBuf );
    if (!*ppszName)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    return ERROR_SUCCESS;
}

BOOL
IsLocalPad(
    IN PBENTRY* pEntry )

    // Returns true if 'pEntry' is a local PAD device, i.e. the first link of
    // the entry has device type "pad", false otherwise.
    //
{
    PBLINK* pLink;
    DTLNODE* pNode;

    if (!pEntry)
    {
        return FALSE;
    }

    ASSERT( pEntry->pdtllistLinks );
    pNode = DtlGetFirstNode( pEntry->pdtllistLinks );
    ASSERT( pNode );
    pLink = (PBLINK* )DtlGetData( pNode );
    ASSERT( pLink );

    return (pLink->pbport.pbdevicetype == PBDT_Pad);
}

#if 0
//----------------------------------------------------------------------------
// Function:    IsNt40Machine
//
// Returns whether the given machine is running nt40
//----------------------------------------------------------------------------

DWORD
IsNt40Machine (
    IN      PWCHAR      pszServer,
    OUT     PBOOL       pbIsNt40)
{

    DWORD dwErr, dwType = REG_SZ, dwLength;
    HKEY hkMachine, hkVersion;
    WCHAR pszBuildNumber[64];
    PWCHAR pszMachine = NULL;

    //
    // Validate and initialize
    //

    if (!pbIsNt40) 
    { 
        return ERROR_INVALID_PARAMETER; 
    }
    *pbIsNt40 = FALSE;

    do 
    {
        // Format the machine name
        if ( (pszServer) && (wcslen(pszServer) > 0) ) 
        {
            dwLength = wcslen( pszServer ) + 3;
            pszMachine = (PWCHAR) Malloc ( dwLength * sizeof( WCHAR ) );
            if (pszMachine == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
            if ( *pszMachine == L'\\' )
            {
                wcscpy( pszMachine, pszServer );
            }
            else
            {
                wcscpy( pszMachine, L"\\\\" );
                wcscat( pszMachine, pszServer );
            }
        }
        else
        {
            pszMachine = NULL;
        }
    
        //
        // Connect to the remote server
        //
        dwErr = RegConnectRegistry(
                    pszMachine,
                    HKEY_LOCAL_MACHINE,
                    &hkMachine);
        if ( dwErr != ERROR_SUCCESS )        
        {
            break;
        }

        //
        // Open the windows version key
        //

        dwErr = RegOpenKeyEx(
                    hkMachine, 
                    c_szWinVersionPath, 
                    0, 
                    KEY_ALL_ACCESS, 
                    &hkVersion
                    );

        if ( dwErr != NO_ERROR ) 
        { 
            break; 
        }

        //
        // Read in the current version key
        //
        dwLength = sizeof(pszBuildNumber);
        dwErr = RegQueryValueEx (
                    hkVersion, 
                    c_szCurrentBuildNumber, 
                    NULL, 
                    &dwType,
                    (BYTE*)pszBuildNumber, 
                    &dwLength
                    );
        
        if (dwErr != NO_ERROR) 
        { 
            break; 
        }

        if (lstrcmp (pszBuildNumber, c_szNt40BuildNumber) == 0) 
        {
            *pbIsNt40 = TRUE;
        }
        
    } while (FALSE);


    // Cleanup
    {
        if ( hkVersion )
        {
            RegCloseKey( hkVersion );
        }
        if ( hkMachine )
        {
            RegCloseKey( hkMachine );
        }
        Free0( pszMachine );            
    }

    return dwErr;
}    

#endif

BOOL
PhoneNodeIsBlank(
    IN DTLNODE* pNode )

    // Returns true if the phone number in PBPHONE node 'pNode' is "blank",
    // i.e. it contains no area code, phone number, or comment strings.
    //
{
    PBPHONE* pPhone;

    pPhone = (PBPHONE* )DtlGetData( pNode );
    ASSERT( pPhone );

    if ((!pPhone->pszAreaCode || IsAllWhite( pPhone->pszAreaCode ))
        && (!pPhone->pszPhoneNumber || IsAllWhite( pPhone->pszPhoneNumber ))
        && (!pPhone->pszComment || IsAllWhite( pPhone->pszComment )))
    {
        return TRUE;
    }

    return FALSE;
}


BOOL
PhoneNumberDlg(
    IN HWND hwndOwner,
    IN BOOL fRouter,
    IN OUT DTLLIST* pList,
    IN OUT BOOL* pfCheck )

    // Popup the phone number list dialog.  'HwndOwner' is the owner of the
    // created dialog.  'FRouter' indicates router-style labels should be used
    // rather than client-style.  'PList' is a list of Psz nodes containing
    // the phone numbers.  'PfCheck' is the address that contains the initial
    // "promote number" checkbox setting and which receives the value set by
    // user.
    //
    // Returns true if user presses OK and succeeds, false if he presses
    // Cancel or encounters an error.
    //
{
    DWORD sidHuntTitle;
    DWORD sidHuntItemLabel;
    DWORD sidHuntListLabel;
    DWORD sidHuntCheckLabel;

    //For whistler bug 227538
    TCHAR *pszTitle = NULL, *pszItem = NULL, *pszList = NULL, *pszCheck = NULL;
    DWORD dwErr = NO_ERROR;

    TRACE( "PhoneNumberDlg" );

    if (fRouter)
    {
        sidHuntTitle = SID_RouterHuntTitle;
        sidHuntItemLabel = SID_RouterHuntItemLabel;
        sidHuntListLabel = SID_RouterHuntListLabel;
        sidHuntCheckLabel = SID_RouterHuntCheckLabel;
    }
    else
    {
        sidHuntTitle = SID_HuntTitle;
        sidHuntItemLabel = SID_HuntItemLabel;
        sidHuntListLabel = SID_HuntListLabel;
        sidHuntCheckLabel = SID_HuntCheckLabel;
    }

    pszTitle = PszFromId( g_hinstDll, sidHuntTitle );
    pszItem  = PszFromId( g_hinstDll, sidHuntItemLabel );
    pszList  = PszFromId( g_hinstDll, sidHuntListLabel );
    pszCheck = PszFromId( g_hinstDll, sidHuntCheckLabel );

    dwErr=ListEditorDlg(
            hwndOwner,
            pList,
            pfCheck,
            RAS_MaxPhoneNumber,
            pszTitle, 
            pszItem,
            pszList,
            pszCheck,
            NULL,
            0,
            g_adwPnHelp,
            0,
            NULL );

     Free0( pszTitle );
     Free0( pszItem );
     Free0( pszList );
     Free0( pszCheck );

     return dwErr;
}


VOID
PositionDlg(
    IN HWND hwndDlg,
    IN BOOL fPosition,
    IN LONG xDlg,
    IN LONG yDlg )

    // Positions the dialog 'hwndDlg' based on caller's API settings, where
    // 'fPosition' is the RASxxFLAG_PositionDlg flag and 'xDlg' and 'yDlg' are
    // the coordinates.
    //
{
    if (fPosition)
    {
        // Move it to caller's coordinates.
        //
        SetWindowPos( hwndDlg, NULL, xDlg, yDlg, 0, 0,
            SWP_NOZORDER + SWP_NOSIZE );
        UnclipWindow( hwndDlg );
    }
    else
    {
        // Center it on the owner window, or on the screen if none.
        //
        CenterWindow( hwndDlg, GetParent( hwndDlg ) );
    }
}


LRESULT CALLBACK
PositionDlgStdCallWndProc(
    int code,
    WPARAM wparam,
    LPARAM lparam )

    // Standard Win32 CallWndProc hook callback that positions the next dialog
    // to start in this thread at our standard offset relative to owner.
    //
{
    // Arrive here when any window procedure associated with our thread is
    // called.
    //
    if (!wparam)
    {
        CWPSTRUCT* p = (CWPSTRUCT* )lparam;

        // The message is from outside our process.  Look for the MessageBox
        // dialog initialization message and take that opportunity to position
        // the dialog at the standard place relative to the calling dialog.
        //
        if (p->message == WM_INITDIALOG)
        {
            RECT rect;
            HWND hwndOwner;

            hwndOwner = GetParent( p->hwnd );
            GetWindowRect( hwndOwner, &rect );
            SetWindowPos( p->hwnd, NULL,
                rect.left + DXSHEET, rect.top + DYSHEET,
                0, 0, SWP_NOZORDER + SWP_NOSIZE );
            UnclipWindow( p->hwnd );
        }
    }

    return 0;
}


TCHAR*
PszFromPhoneNumberList(
    IN DTLLIST* pList )

    // Returns the phone numbers in phone number list 'pList' in a comma
    // string or NULL on error.  It is caller's responsiblity to Free the
    // returned string.
    //
{
    TCHAR* pszResult, *pszTemp;
    DTLNODE* pNode;
    DWORD cb;

    const TCHAR* pszSeparator = TEXT(", ");

    cb = (DtlGetNodes( pList ) *
             (RAS_MaxPhoneNumber + lstrlen( pszSeparator )) + 1)
             * sizeof(TCHAR);
    pszResult = Malloc( cb );
    if (!pszResult)
    {
        return NULL;
    }

    *pszResult = TEXT('\0');

    for (pNode = DtlGetFirstNode( pList );
         pNode;
         pNode = DtlGetNextNode( pNode ))
    {
        TCHAR* psz = (TCHAR* )DtlGetData( pNode );
        ASSERT( psz );

        if (*pszResult)
            lstrcat( pszResult, pszSeparator );
        lstrcat( pszResult, psz );
    }

    pszTemp = Realloc( pszResult,
        (lstrlen( pszResult ) + 1) * sizeof(TCHAR) );
    ASSERT( pszTemp );
    if (pszTemp)
    {
        pszResult = pszTemp;
    }

    return pszResult;
}


#if 0
LRESULT CALLBACK
SelectDesktopCallWndRetProc(
    int    code,
    WPARAM wparam,
    LPARAM lparam )

    // Standard Win32 CallWndRetProc hook callback that makes "Desktop" the
    // initial selection of the FileOpen "Look in" combo-box.
    //
{
    // Arrive here when any window procedure associated with our thread is
    // called.
    //
    if (!wparam)
    {
        CWPRETSTRUCT* p = (CWPRETSTRUCT* )lparam;

        // The message is from outside our process.  Look for the MessageBox
        // dialog initialization message and take that opportunity to set the
        // "Look in:" combo box to the first item, i.e. "Desktop".  FileOpen
        // keys off CBN_CLOSEUP rather than CBN_SELCHANGE to update the
        // "contents" listbox.
        //
        if (p->message == WM_INITDIALOG)
        {
            HWND hwndLbLookIn;

            hwndLbLookIn = GetDlgItem( p->hwnd, cmb2 );
            ComboBox_SetCurSel( hwndLbLookIn, 0 );
            SendMessage( p->hwnd, WM_COMMAND,
                MAKELONG( cmb2, CBN_CLOSEUP ), (LPARAM )hwndLbLookIn );
        }
    }

    return 0;
}
#endif

//We want to get rid of the Icon resources from rasdlg, they take too much
//memory resource. instead, we retrieve them from netman.dll, if failed, we
//use the default one IID_Broadband         gangz
//Also, for whistler bug 372078 364763 364876
//

HICON
GetCurrentIconEntryType(
    IN DWORD dwType,
    IN BOOL  fSmall)
{
    HICON hIcon = NULL;
    DWORD dwSize, dwConnectionIcon;
    HRESULT hr = E_FAIL;
    NETCON_MEDIATYPE ncm;
    HMODULE hNetshell = NULL;

    HRESULT (WINAPI * pHrGetIconFromMediaType) (DWORD ,
                                                NETCON_MEDIATYPE ,
                                                NETCON_SUBMEDIATYPE ,
                                                DWORD ,
                                                DWORD ,
                                                HICON *);

    dwSize = fSmall ? 16 : 32;

    switch (dwType)
    {
        case RASET_Direct:
        {
            ncm = NCM_DIRECT;
            break;
        }

        case RASET_Vpn:
        {
            ncm = NCM_TUNNEL;
            break;
        }

        case RASET_Broadband:
        {
            ncm = NCM_PPPOE;
            break;
        }

        case RASET_Phone:
        default:
        {
            ncm = NCM_PHONE;
            break;
        }
    }

    hNetshell = LoadLibrary(TEXT("netshell.dll"));

    if( hNetshell )
    {
        pHrGetIconFromMediaType =(HRESULT (WINAPI*)(
                           DWORD ,
                           NETCON_MEDIATYPE ,
                           NETCON_SUBMEDIATYPE ,
                           DWORD ,
                           DWORD ,
                           HICON *) )GetProcAddress(
                                        hNetshell,
                                        "HrGetIconFromMediaType");

        if ( NULL != pHrGetIconFromMediaType )
        {
            /*******************************************************************
            **  dwConnectionIcon - (This is the little Computer part of the icon):
            **  0 - no connection overlay 
            **  4 - Connection Icon with both lights off (Disabled status)
            **  5 - Connection Icon with left light on (Transmitting Data)
            **  6 - Connection Icon with right light on (Receiving Data)
            **  7 - Connection Icon with both lights on (Enabled status)
            *********************************************************************/

            dwConnectionIcon = 7;
            hr = pHrGetIconFromMediaType(dwSize,
                                ncm,
                                NCSM_NONE,
                                7,
                                0,
                                &hIcon);
            
        }
        FreeLibrary( hNetshell );
    }

    if ( !SUCCEEDED(hr) || !hIcon)
    {
        ICONINFO iInfo;
        HICON hTemp;
        hTemp = LoadIcon( g_hinstDll, MAKEINTRESOURCE( IID_Broadband ) );

        if(hTemp)
        {
            if( GetIconInfo(hTemp, &iInfo) )
            {
                hIcon = CreateIconIndirect(&iInfo);
            }
        }
    }

    return hIcon;
}
    

VOID
SetIconFromEntryType(
    IN HWND hwndIcon,
    IN DWORD dwType,
    IN BOOL fSmall)

    // Set the icon image of icon control 'dwType' to the image corresponding
    // to the entry type 'dwType'.
    //
{
    HICON hIcon = NULL;

    hIcon = GetCurrentIconEntryType( dwType, fSmall );
    
    if (hIcon)
    {
        Static_SetIcon( hwndIcon, hIcon );
    }
}


VOID
TweakTitleBar(
    IN HWND hwndDlg )

    // Adjust the title bar to include an icon if unowned and the modal frame
    // if not.  'HwndDlg' is the dialog window.
    //
{
    if (GetParent( hwndDlg ))
    {
        LONG lStyle;
        LONG lStyleAdd;

        // Drop the system menu and go for the dialog look.
        //
        lStyleAdd = WS_EX_DLGMODALFRAME | WS_EX_WINDOWEDGE;;

        lStyle = GetWindowLong( hwndDlg, GWL_EXSTYLE );
        if (lStyle)
            SetWindowLong( hwndDlg, GWL_EXSTYLE, lStyle | lStyleAdd );
    }
    else
    {
        // Stick a DUN1 icon in the upper left of the dialog, and more
        // importantly on the task bar
        //
        // Whistler bug: 343455 RAS: Connection dialogs need to use new icons
        //
        //For whistler bug 381099 372078        gangz
        //
        HICON hIcon = NULL;

      SendMessage( hwndDlg, WM_SETICON, ICON_SMALL,
            (LPARAM )LoadIcon( g_hinstDll, MAKEINTRESOURCE( IID_Dun1 ) ) );
 	
        /*
       //Use small Icon         gangz   
       //Icon returned from GetCurrentIconEntryType() has to be destroyed after use
       //In the future, Deonb will return a Icon for IID_Dun1 or dun1.ico for us.
       
       hIcon = GetCurrentIconEntryType(RASET_Broadband , TRUE); 

        ASSERT(hIcon);
        if(hIcon)
        {
            SendMessage( hwndDlg, WM_SETICON, ICON_SMALL, (LPARAM)(hIcon) );
            SetProp( hwndDlg, TEXT("TweakTitleBar_Icon"), hIcon);
        }
        */
    }
}


int CALLBACK
UnHelpCallbackFunc(
    IN HWND   hwndDlg,
    IN UINT   unMsg,
    IN LPARAM lparam )

    // A standard Win32 commctrl PropSheetProc.  See MSDN documentation.
    //
    // Returns 0 always.
    //
{
    TRACE2( "UnHelpCallbackFunc(m=%d,l=%08x)",unMsg, lparam );

    if (unMsg == PSCB_PRECREATE)
    {
        extern BOOL g_fNoWinHelp;

        // Turn off context help button if WinHelp won't work.  See
        // common\uiutil\ui.c.
        //
        if (g_fNoWinHelp)
        {
            DLGTEMPLATE* pDlg = (DLGTEMPLATE* )lparam;
            pDlg->style &= ~(DS_CONTEXTHELP);
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasphone\rasphone.c ===
/* Copyright (c) 1995-1996, Microsoft Corporation, all rights reserved
**
** rasphone.c
** Remote Access Phonebook
** Main routines
**
** 05/31/95 Steve Cobb
*/

#include <windows.h>     // Win32 core
#include <stdlib.h>      // __argc and __argv
#include <rasdlg.h>      // RAS common dialog APIs
#include <raserror.h>    // RAS error constants
#include <debug.h>       // Trace/Assert
#include <nouiutil.h>    // No-HWND utilities
#include <uiutil.h>      // HWND utilities
#include <rnk.h>         // Dial-up shortcut file
#include <rasphone.rch>  // Our resource constants
#include <lmsname.h>     // for SERVICE_NETLOGON definition
#include <commctrl.h>    // added to be "Fusionized"
#include <shfusion.h>    // added to be "Fusionized"


/*----------------------------------------------------------------------------
** Datatypes
**----------------------------------------------------------------------------
*/

/* Identifies a running mode of the application.  The non-default entries
** indicate some alternate behavior has been specified on the command line,
** e.g. command line delete entry.
*/
#define RUNMODE enum tagRUNMODE
RUNMODE
{
    RM_None,
    RM_AddEntry,
    RM_EditEntry,
    RM_CloneEntry,
    RM_RemoveEntry,
    RM_DialEntry,
    RM_HangUpEntry,
};


/*----------------------------------------------------------------------------
** Globals
**----------------------------------------------------------------------------
*/

HINSTANCE g_hinst = NULL;
RUNMODE   g_mode = RM_None;
BOOL      g_fNoRename = FALSE;
TCHAR*    g_pszAppName = NULL;
TCHAR*    g_pszPhonebookPath = NULL;
TCHAR*    g_pszEntryName = NULL;
TCHAR*    g_pszShortcutPath = NULL;


/*-----------------------------------------------------------------------------
** Local prototypes
**-----------------------------------------------------------------------------
*/

DWORD
HangUpEntry(
    void );

DWORD
ParseCmdLineArgs(
    void );

DWORD
RemoveEntry(
    void );

DWORD
Run(
    void );

DWORD
StringArgFollows(
    IN     UINT     argc,
    IN     CHAR**   argv,
    IN OUT UINT*    piCurArg,
    OUT    TCHAR**  ppszOut );

INT WINAPI
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR     pszCmdLine,
    int       nCmdShow );


/*-----------------------------------------------------------------------------
** Routines
**-----------------------------------------------------------------------------
*/

INT WINAPI
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR     pszCmdLine,
    int       nCmdShow )

    /* Standard Win32 application entry point.
    */
{
    DWORD dwErr;

    DEBUGINIT("RASPHONE");
    TRACE("WinMain");

    g_hinst = hInstance;

    /* Whistler bug 293751 rasphone.exe / rasautou.exe need to be "Fusionized"
    ** for UI conistency w/Connections Folder
    */
    SHFusionInitializeFromModule( g_hinst );

    dwErr = ParseCmdLineArgs();
    if (dwErr == 0)
    {
        /* Execute based on command line arguments.
        */
        dwErr = Run();
    }
    else
    {
        MSGARGS msgargs;

        /* Popup a "usage" message.
        */
        ZeroMemory( &msgargs, sizeof(msgargs) );
        msgargs.apszArgs[ 0 ] = g_pszAppName;
        msgargs.apszArgs[ 1 ] = PszFromId( g_hinst, SID_Usage2 );
        msgargs.apszArgs[ 2 ] = PszFromId( g_hinst, SID_Usage3 );
        msgargs.apszArgs[ 3 ] = PszFromId( g_hinst, SID_Usage4 );
        msgargs.apszArgs[ 4 ] = PszFromId( g_hinst, SID_Usage5 );
        msgargs.apszArgs[ 5 ] = PszFromId( g_hinst, SID_Usage6 );
        MsgDlgUtil( NULL, SID_Usage, &msgargs, g_hinst, SID_UsageTitle );
        Free0( msgargs.apszArgs[ 1 ] );
        Free0( msgargs.apszArgs[ 2 ] );
        Free0( msgargs.apszArgs[ 3 ] );
        Free0( msgargs.apszArgs[ 4 ] );
        Free0( msgargs.apszArgs[ 5 ] );
    }

    Free0( g_pszAppName );
    Free0( g_pszPhonebookPath );
    Free0( g_pszEntryName );

    /* Whistler bug 293751 rasphone.exe / rasautou.exe need to be "Fusionized"
    ** for UI conistency w/Connections Folder
    */
    SHFusionUninitialize();

    TRACE1("WinMain=%d",dwErr);
    DEBUGTERM();

    return (INT )dwErr;
}


BOOL
FIsRasInstalled ()
{
    static const TCHAR c_szRegKeyRasman[] =
            TEXT("SYSTEM\\CurrentControlSet\\Services\\Rasman");

    BOOL fIsRasInstalled = FALSE;

    HKEY hkey;
    if (RegOpenKey( HKEY_LOCAL_MACHINE, c_szRegKeyRasman, &hkey ) == 0)
    {
        fIsRasInstalled = TRUE;
        RegCloseKey( hkey );
    }

    return fIsRasInstalled;
}


DWORD
HangUpEntry(
    void )

    /* Hang up the entry specified on the command line.
    **
    ** Returns 0 if successful, or an error code.
    */
{
    DWORD    dwErr;
    HRASCONN hrasconn;

    TRACE("HangUpEntry");

    if (!g_pszEntryName)
        return ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;

    dwErr = LoadRasapi32Dll();
    if (dwErr != 0)
        return dwErr;

    /* Currently, if user does not specify a phonebook path on the command
    ** line we look for any entry with the name he selected disregarding what
    ** phonebook it comes from.  Should probably map it specifically to the
    ** default phonebook as the other options do, but that would mean linking
    ** in all of PBK.LIB.  Seems like overkill for this little quibble.  Maybe
    ** we need a RasGetDefaultPhonebookName API.
    */
    hrasconn = HrasconnFromEntry( g_pszPhonebookPath, g_pszEntryName );
    if (hrasconn)
    {
        ASSERT(g_pRasHangUp);
        TRACE("RasHangUp");
        dwErr = g_pRasHangUp( hrasconn );
        TRACE1("RasHangUp=%d",dwErr);
    }

    UnloadRasapi32Dll();

    return dwErr;
}


DWORD
ParseCmdLineArgs(
    void )

    /* Parse command line arguments, filling in global settings accordingly.
    **
    ** Returns 0 if successful, or a non-0 error code.
    */
{
    DWORD  dwErr;
    UINT   argc;
    CHAR** argv;
    UINT   i;

    /* Usage: appname [-v] [-f file] [-e|-c|-d|-h|-r entry]
    **        appname [-v] [-f file] -a [entry]
    **        appname [-v] -lx link
    **        appname -s
    **
    **    '-a'    Popup new entry dialogs
    **    '-e'    Popup edit entry dialogs
    **    '-d'    Popup dial entry dialogs
    **    '-h'    Quietly hang up the entry
    **    '-r'    Quietly delete the entry
    **    '-lx'   Execute command 'x' on dial-up shortcut file
    **    'x'     Any of the commands e, v, c, r, d, h, or a
    **    'entry' The entry name to which the operation applies
    **    'file'  The full path to the dial-up phonebook file (.pbk)
    **    'link'  The full path to the dial-up shortcut file (.rnk)
    **
    **    'entry' without a preceding flag starts the phone list dialog with
    **    the entry selected.
    */

    argc = __argc;
    argv = __argv;
    dwErr = 0;

    {
        CHAR* pStart = argv[ 0 ];
        CHAR* p;

        for (p = pStart + lstrlenA( pStart ) - 1; p >= pStart; --p)
        {
            if (*p == '\\' || *p == ':')
                break;
        }

        g_pszAppName = StrDupTFromA( p + 1 );
    }

    for (i = 1; i < argc && dwErr == 0; ++i)
    {
        CHAR* pszArg = argv[ i ];

        if (*pszArg == '-' || *pszArg == '/')
        {
            switch (pszArg[ 1 ])
            {
                case 'a':
                case 'A':
                    g_mode = RM_AddEntry;
                    StringArgFollows( argc, argv, &i, &g_pszEntryName );
                    break;

                case 'e':
                case 'E':
                    g_mode = RM_EditEntry;
                    dwErr = StringArgFollows( argc, argv, &i, &g_pszEntryName );
                    break;
                    
                case 'r':
                case 'R':
                    g_mode = RM_RemoveEntry;
                    dwErr = StringArgFollows( argc, argv, &i, &g_pszEntryName );
                    break;

                case 'd':
                case 'D':
                case 't':
                case 'T':
                    g_mode = RM_DialEntry;
                    dwErr = StringArgFollows( argc, argv, &i, &g_pszEntryName );
                    break;
                    
                case 'h':
                case 'H':
                    g_mode = RM_HangUpEntry;
                    dwErr = StringArgFollows( argc, argv, &i, &g_pszEntryName );
                    break;

                case 'f':
                case 'F':
                    dwErr = StringArgFollows(
                        argc, argv, &i, &g_pszPhonebookPath );
                    break;

                case 'l':
                case 'L':
                    switch (pszArg[ 2 ])
                    {
                        case 'a':
                        case 'A':
                            g_mode = RM_AddEntry;
                            StringArgFollows( argc, argv, &i, &g_pszEntryName );
                            break;

                        case 'e':
                        case 'E':
                            g_mode = RM_EditEntry;
                            break;

                        case 'c':
                        case 'C':
                            g_mode = RM_CloneEntry;
                            break;

                        case 'v':
                        case 'V':
                            g_fNoRename = TRUE;
                            break;

                        case 'r':
                        case 'R':
                            g_mode = RM_RemoveEntry;
                            break;

                        case 'd':
                        case 'D':
                        case 't':
                        case 'T':
                            g_mode = RM_DialEntry;
                            break;

                        case 'h':
                        case 'H':
                            g_mode = RM_HangUpEntry;
                            break;

                        default:
                            dwErr = ERROR_INVALID_PARAMETER;
                            break;
                    }

                    if (dwErr == 0)
                    {
                        dwErr = StringArgFollows(
                            argc, argv, &i, &g_pszShortcutPath );
                    }
                    break;

                default:
                    dwErr = ERROR_INVALID_PARAMETER;
                    break;
            }
        }
        else if (i == 1)
        {
            --i;
            dwErr = StringArgFollows( argc, argv, &i, &g_pszEntryName );
            break;
        }
        else
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }
    }

    if (dwErr == 0 && g_pszShortcutPath)
    {
        RNKINFO* pInfo;

        /* Read the phonebook and entry from the dial-up shortcut file.
        */
        pInfo = ReadShortcutFile( g_pszShortcutPath );
        if (!pInfo)
            dwErr = ERROR_OPEN_FAILED;
        else
        {
            g_pszPhonebookPath = StrDup( pInfo->pszPhonebook );
            if (g_mode != RM_AddEntry)
                g_pszEntryName = StrDup( pInfo->pszEntry );

            FreeRnkInfo( pInfo );
        }
    }

    TRACE2("CmdLine: m=%d,v=%d",g_mode,g_fNoRename);
    TRACEW1("CmdLine: e=%s",(g_pszEntryName)?g_pszEntryName:TEXT(""));
    TRACEW1("CmdLine: f=%s",(g_pszPhonebookPath)?g_pszPhonebookPath:TEXT(""));
    TRACEW1("CmdLine: l=%s",(g_pszShortcutPath)?g_pszShortcutPath:TEXT(""));

    return dwErr;
}


DWORD
RemoveEntry(
    void )

    /* Remove the entry specified on the command line.
    **
    ** Returns 0 if successful, or an error code.
    */
{
    DWORD dwErr;
    HRASCONN hrasconn = NULL;

    TRACE("RemoveEntry");

    dwErr = LoadRasapi32Dll();
    if (dwErr != 0)
        return dwErr;

    //If this entry is currently connected, we wont delete it
    //for whislter bug 311846       gangz
    //
    hrasconn = HrasconnFromEntry( g_pszPhonebookPath, g_pszEntryName );
    if (hrasconn)
    {
        TRACE("RemoveEntry: Connection is Active, wont delete it");
        dwErr = ERROR_CAN_NOT_COMPLETE;
    }
    else
    {
        ASSERT(g_pRasDeleteEntry);
        TRACE("RasDeleteEntry");
        dwErr = g_pRasDeleteEntry( g_pszPhonebookPath, g_pszEntryName );
        TRACE1("RasDeleteEntry=%d",dwErr);
    }

    UnloadRasapi32Dll();

    return dwErr;
}


DWORD
Run(
    void )

    /* Execute the command line instructions.
    **
    ** Returns 0 if successful, or an error code.
    */
{
    DWORD  dwErr;
    BOOL   fStatus;
    TCHAR* pszEntry;

    TRACE("Run");

    if (g_mode == RM_HangUpEntry)
        return HangUpEntry();
    else if (g_mode == RM_RemoveEntry)
        return RemoveEntry();

    dwErr = LoadRasdlgDll();
    if (dwErr != 0)
        return dwErr;

    switch (g_mode)
    {
        case RM_DialEntry:
        {
            RASDIALDLG info;

            ZeroMemory( &info, sizeof(info) );
            info.dwSize = sizeof(info);
            pszEntry = g_pszEntryName;

            ASSERT(g_pRasDialDlg);
            TRACE("RasDialDlg");
            fStatus = g_pRasDialDlg(
                g_pszPhonebookPath, g_pszEntryName, NULL, &info );
            TRACE2("RasDialDlg=%d,e=%d",fStatus,info.dwError);

            dwErr = info.dwError;
            break;
        }

        case RM_None:
        {
            RASPBDLG info;
            DWORD    dwGupErr;
            PBUSER   user;

            ZeroMemory( &info, sizeof(info) );
            info.dwSize = sizeof(info);
            info.dwFlags = RASPBDFLAG_UpdateDefaults;

            dwGupErr = GetUserPreferences( NULL, &user, FALSE );
            if (dwGupErr == 0)
            {
                if (user.dwXPhonebook != 0x7FFFFFFF)
                {
                    info.dwFlags |= RASPBDFLAG_PositionDlg;
                    info.xDlg = user.dwXPhonebook;
                    info.yDlg = user.dwYPhonebook;
                }

                pszEntry = user.pszDefaultEntry;
            }
            else
                pszEntry = NULL;

            if (g_pszEntryName)
                pszEntry = g_pszEntryName;

            ASSERT(g_pRasPhonebookDlg);
            TRACE("RasPhonebookDlg...");
            fStatus = g_pRasPhonebookDlg( g_pszPhonebookPath, pszEntry, &info );
            TRACE2("RasPhonebookDlg=%d,e=%d",fStatus,info.dwError);

            if (dwGupErr == 0)
                DestroyUserPreferences( &user );

            dwErr = info.dwError;
            break;
        }

        case RM_AddEntry:
        case RM_EditEntry:
        case RM_CloneEntry:
        {
            RASENTRYDLG info;

            ZeroMemory( &info, sizeof(info) );
            info.dwSize = sizeof(info);

            if (g_mode == RM_AddEntry)
                info.dwFlags |= RASEDFLAG_NewEntry;
            else if (g_mode == RM_CloneEntry)
                info.dwFlags |= RASEDFLAG_CloneEntry;

            if (g_fNoRename)
                info.dwFlags |= RASEDFLAG_NoRename;

#if 0
            ASSERT(g_pRouterEntryDlg);
            TRACE("RouterEntryDlg");
            fStatus = g_pRouterEntryDlg(
                TEXT("stevec5"), TEXT("\\\\stevec5\\admin$\\system32\\ras\\router.pbk"), g_pszEntryName, &info );
            TRACE2("RouterEntryDlg=%f,e=%d",fStatus,info.dwError);
#else
            ASSERT(g_pRasEntryDlg);
            TRACE("RasEntryDlg");
            fStatus = g_pRasEntryDlg(
                g_pszPhonebookPath, g_pszEntryName, &info );
            TRACE2("RasEntryDlg=%f,e=%d",fStatus,info.dwError);
#endif

            dwErr = info.dwError;
            break;
        }

        default:
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }
    }

    UnloadRasdlgDll();

    TRACE1("Run=%d",dwErr);
    return dwErr;
}


DWORD
StringArgFollows(
    IN     UINT     argc,
    IN     CHAR**   argv,
    IN OUT UINT*    piCurArg,
    OUT    TCHAR**  ppszOut )

    /* Loads a copy of the next argument into callers '*ppszOut'.
    **
    ** Returns 0 if successful, or a non-0 error code.  If successful, it is
    ** caller's responsibility to Free the returned '*ppszOut'.
    */
{
    TCHAR* psz;

    if (++(*piCurArg) >= argc)
        return ERROR_INVALID_PARAMETER;

    psz = StrDupTFromAUsingAnsiEncoding( argv[ *piCurArg ] );
    if (!psz)
        return ERROR_NOT_ENOUGH_MEMORY;

    *ppszOut = psz;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasscrpt\ast.h ===
//
// Copyright (c) Microsoft Corporation 1995
//
// ast.h
//
// Header file for the abstract syntax tree.
//
// History:
//  05-20-95 ScottH     Created
//

#ifndef __AST_H__
#define __AST_H__

typedef struct tagASTEXEC * PASTEXEC;


//
// AST 
//

typedef enum 
    {
    AT_BASE,
    
    AT_MODULE_DECL,
    AT_PROC_DECL,

    AT_ENTER_STMT,
    AT_LEAVE_STMT,    
    AT_ASSIGN_STMT,
    AT_HALT_STMT,
    AT_LABEL_STMT,
    AT_GOTO_STMT,
    AT_TRANSMIT_STMT,
    AT_WAITFOR_STMT,
    AT_DELAY_STMT,
    AT_SET_STMT,
    AT_WHILE_STMT,
    AT_IF_STMT,
    
    AT_INT_EXPR,
    AT_STRING_EXPR,
    AT_VAR_EXPR,
    AT_BOOL_EXPR,
    AT_UNOP_EXPR,
    AT_BINOP_EXPR,
    AT_GETIP_EXPR,
    } ASTTYPE;


// Basic AST 

typedef struct tagAST
    {
    DWORD   cbSize;
    ASTTYPE asttype;
    DWORD   iLine;
    } AST;                            // Basic AST
DECLARE_STANDARD_TYPES(AST);

#define Ast_GetSize(p)      (((PAST)(p))->cbSize)
#define Ast_GetType(p)      (((PAST)(p))->asttype)
#define Ast_GetLine(p)      (((PAST)(p))->iLine)

#define Ast_SetSize(p, s)   (((PAST)(p))->cbSize = (s))
#define Ast_SetType(p, t)   (((PAST)(p))->asttype = (t))
#define Ast_SetLine(p, v)   (((PAST)(p))->iLine = (v))

RES     PUBLIC Ast_New(LPVOID * ppv, ASTTYPE asttype, DWORD cbSize, DWORD iLine);
void    PUBLIC Ast_Delete(PAST this);
RES     PUBLIC Ast_Dup(PAST this, PAST * ppast);

#ifdef DEBUG
void    PUBLIC Ast_Dump(PAST this);
#else
#define Ast_Dump(past)    
#endif

// Decl

typedef struct tagDECL
    {
    AST     ast;
    PSYMTAB pst;        // symbol table
    } DECL;
DECLARE_STANDARD_TYPES(DECL);

RES     PUBLIC Decl_Delete(PDECL this);
void    CALLBACK Decl_DeletePAPtr(LPVOID pv, LPARAM lparam);

// Proc Declaration 

typedef struct tagPROCDECL
    {
    DECL    decl;
    LPSTR   pszIdent;
    HPA     hpaStmts;
    PSYMTAB pst;
    } PROCDECL;
DECLARE_STANDARD_TYPES(PROCDECL);

RES     PUBLIC ProcDecl_New(PDECL * ppdecl, LPCSTR pszIdent, HPA hpa, PSYMTAB pst, DWORD iLine);

#define ProcDecl_GetIdent(p)        (((PPROCDECL)(p))->pszIdent)
#define ProcDecl_GetSymtab(p)       (((PPROCDECL)(p))->pst)


// Module Declaration 

typedef struct tagMODULEDECL
    {
    DECL    decl;
    HPA     hpaProcs;
    PSYMTAB pst;
    } MODULEDECL;
DECLARE_STANDARD_TYPES(MODULEDECL);

RES     PUBLIC ModuleDecl_New(PDECL * ppdecl, HPA hpa, PSYMTAB pst, DWORD iLine);
RES     PUBLIC ModuleDecl_Parse(PMODULEDECL * ppmoduledecl, PSCANNER pscanner, PSYMTAB pst);
RES     PUBLIC ModuleDecl_Typecheck(PMODULEDECL this, HSA hsaStxerr);
RES     PUBLIC ModuleDecl_Codegen(PMODULEDECL this, PASTEXEC pastexec);

#define ModuleDecl_GetSymtab(p)     (((PMODULEDECL)(p))->pst)


// Expressions

typedef struct tagEXPR
    {
    AST     ast;
    DATATYPE dt;
    DWORD   dwFlags;        // EF_*
    EVALRES er;             // Used when evaluated at runtime
    } EXPR;
DECLARE_STANDARD_TYPES(EXPR);

// Expression flags
#define EF_DEFAULT      0x0000
#define EF_DONE         0X0001
#define EF_ALLOCATED    0x0002

RES     PUBLIC Expr_Eval(PEXPR this, PASTEXEC pastexec);
RES     PUBLIC Expr_Delete(PEXPR this);
void    CALLBACK Expr_DeletePAPtr(LPVOID pv, LPARAM lparam);

#define Expr_GetDataType(p)         (((PEXPR)(p))->dt)
#define Expr_GetRes(p)              (&((PEXPR)(p))->er)

#define Expr_SetDataType(p, x)      (((PEXPR)(p))->dt = (x))
#define Expr_SetDone(p)             SetFlag(((PEXPR)(p))->dwFlags, EF_DONE)
#define Expr_SetRes(p, x)           (Expr_SetDone(p),((PEXPR)(p))->er.dw = (ULONG_PTR)(x))


// Integer Expression

typedef struct tagINTEXPR
    {
    EXPR    expr;
    int     nVal;       // signed value by design
    } INTEXPR;
DECLARE_STANDARD_TYPES(INTEXPR);

RES     PUBLIC IntExpr_New(PEXPR * ppexpr, int nVal, DWORD iLine);

#define IntExpr_GetVal(p)           (((PINTEXPR)(p))->nVal)

#define IntExpr_SetVal(p, n)        (((PINTEXPR)(p))->nVal = (n))


// String Expression

typedef struct tagSTREXPR
    {
    EXPR    expr;
    LPSTR   psz;
    } STREXPR;
DECLARE_STANDARD_TYPES(STREXPR);

RES     PUBLIC StrExpr_New(PEXPR * ppexpr, LPCSTR psz, DWORD iLine);

#define StrExpr_GetStr(p)           (((PSTREXPR)(p))->psz)

#define StrExpr_SetStr(p, n)        (((PINTEXPR)(p))->nVal = (n))


// Bool Expression

typedef struct tagBOOLEXPR
    {
    EXPR    expr;
    BOOL    bVal;
    } BOOLEXPR;
DECLARE_STANDARD_TYPES(BOOLEXPR);

RES     PUBLIC BoolExpr_New(PEXPR * ppexpr, BOOL bVal, DWORD iLine);

#define BoolExpr_GetVal(p)          (((PBOOLEXPR)(p))->bVal)

#define BoolExpr_SetVal(p, b)       (((PBOOLEXPR)(p))->bVal = (b))


// Variable Expression

typedef struct tagVAREXPR
    {
    EXPR    expr;
    LPSTR   pszIdent;
    } VAREXPR;
DECLARE_STANDARD_TYPES(VAREXPR);

RES     PUBLIC VarExpr_New(PEXPR * ppexpr, LPCSTR pszIdent, DWORD iLine);

#define VarExpr_GetIdent(p)         (((PVAREXPR)(p))->pszIdent)


// Binary Operation Expression

typedef enum
    {
    // WARNING: These types must match the order of their 
    // corresponding SYM and OP values.

    BOT_OR,
    BOT_AND,

    BOT_LEQ,        
    BOT_LT,         
    BOT_GEQ,        
    BOT_GT,         
    BOT_NEQ,
    BOT_EQ,

    BOT_PLUS,
    BOT_MINUS,
    BOT_MULT,
    BOT_DIV,

    } BINOPTYPE;

typedef struct tagBINOPEXPR
    {
    EXPR    expr;
    BINOPTYPE binoptype;
    PEXPR   pexpr1;
    PEXPR   pexpr2;
    } BINOPEXPR;
DECLARE_STANDARD_TYPES(BINOPEXPR);

RES     PUBLIC BinOpExpr_New(PEXPR * ppexpr, BINOPTYPE binoptype, PEXPR pexpr1, PEXPR pexpr2, DWORD iLine);

#define BinOpExpr_GetType(p)        (((PBINOPEXPR)(p))->binoptype)
#define BinOpExpr_GetExpr1(p)       (((PBINOPEXPR)(p))->pexpr1)
#define BinOpExpr_GetExpr2(p)       (((PBINOPEXPR)(p))->pexpr2)

#define BinOpExpr_SetType(p, t)     (((PBINOPEXPR)(p))->binoptype = (t))
#define BinOpExpr_SetRes(p, x)      (((PBINOPEXPR)(p))->er.dw = (DWORD)(x))


// Unary Operation Expression

typedef enum
    {
    UOT_NEG,
    UOT_NOT,
    UOT_GETIP,
    } UNOPTYPE;

typedef struct tagUNOPEXPR
    {
    EXPR    expr;
    UNOPTYPE unoptype;
    PEXPR   pexpr;
    EVALRES er;         // Used for UOT_GETIP on strings
    } UNOPEXPR;
DECLARE_STANDARD_TYPES(UNOPEXPR);

RES     PUBLIC UnOpExpr_New(PEXPR * ppexpr, UNOPTYPE unoptype, PEXPR pexpr, DWORD iLine);

#define UnOpExpr_GetType(p)         (((PUNOPEXPR)(p))->unoptype)
#define UnOpExpr_GetExpr(p)         (((PUNOPEXPR)(p))->pexpr)

#define UnOpExpr_SetType(p, t)      (((PUNOPEXPR)(p))->unoptype = (t))
#define UnOpExpr_SetRes(p, x)       (((PUNOPEXPR)(p))->er.dw = (DWORD)(x))


// Statements

typedef struct tagSTMT
    {
    AST     ast;
    } STMT;
DECLARE_STANDARD_TYPES(STMT);

RES     PUBLIC Stmt_Delete(PSTMT this);
void    CALLBACK Stmt_DeletePAPtr(LPVOID pv, LPARAM lparam);

RES     PUBLIC Stmt_Exec(PSTMT this, PASTEXEC pastexec);


// Enter Statement

typedef struct tagENTERSTMT
    {
    STMT    stmt;
    PSYMTAB pst;
    } ENTERSTMT;
DECLARE_STANDARD_TYPES(ENTERSTMT);

RES     PUBLIC EnterStmt_New(PSTMT * ppstmt, PSYMTAB pst, DWORD iLine);

#define EnterStmt_GetSymtab(p)      (((PENTERSTMT)(p))->pst)


// Leave Statement

typedef struct tagLEAVESTMT
    {
    STMT    stmt;
    } LEAVESTMT;
DECLARE_STANDARD_TYPES(LEAVESTMT);

RES     PUBLIC LeaveStmt_New(PSTMT * ppstmt, DWORD iLine);


// Halt Statement

typedef struct tagHALTSTMT
    {
    STMT    stmt;
    } HALTSTMT;
DECLARE_STANDARD_TYPES(HALTSTMT);

RES     PUBLIC HaltStmt_New(PSTMT * ppstmt, DWORD iLine);


// Assignment Statement

typedef struct tagASSIGNSTMT
    {
    STMT    stmt;
    LPSTR   pszIdent;
    PEXPR   pexpr;
    } ASSIGNSTMT;
DECLARE_STANDARD_TYPES(ASSIGNSTMT);

RES     PUBLIC AssignStmt_New(PSTMT * ppstmt, LPCSTR pszIdent, PEXPR pexpr, DWORD iLine);

#define AssignStmt_GetIdent(p)          (((PASSIGNSTMT)(p))->pszIdent)
#define AssignStmt_GetExpr(p)           (((PASSIGNSTMT)(p))->pexpr)


// While Statement

typedef struct tagWHILESTMT
    {
    STMT    stmt;
    PEXPR   pexpr;
    HPA     hpaStmts;
    char    szTopLabel[MAX_BUF_KEYWORD];
    char    szEndLabel[MAX_BUF_KEYWORD];
    } WHILESTMT;
DECLARE_STANDARD_TYPES(WHILESTMT);

RES     PUBLIC WhileStmt_New(PSTMT * ppstmt, PEXPR pexpr, HPA hpaStmts, LPCSTR pszTopLabel, LPCSTR pszEndLabel, DWORD iLine);

#define WhileStmt_GetExpr(p)            (((PWHILESTMT)(p))->pexpr)
#define WhileStmt_GetStmtBlock(p)       (((PWHILESTMT)(p))->hpaStmts)
#define WhileStmt_GetTopLabel(p)        (((PWHILESTMT)(p))->szTopLabel)
#define WhileStmt_GetEndLabel(p)        (((PWHILESTMT)(p))->szEndLabel)

// If Statement

typedef struct tagIFSTMT
    {
    STMT    stmt;
    PEXPR   pexpr;
    HPA     hpaStmts;
    char    szElseLabel[MAX_BUF_KEYWORD];
    char    szEndLabel[MAX_BUF_KEYWORD];
    } IFSTMT;
DECLARE_STANDARD_TYPES(IFSTMT);

RES     PUBLIC IfStmt_New(PSTMT * ppstmt, PEXPR pexpr, HPA hpaStmts, LPCSTR pszElseLabel, LPCSTR pszEndLabel, DWORD iLine);

#define IfStmt_GetExpr(p)               (((PIFSTMT)(p))->pexpr)
#define IfStmt_GetStmtBlock(p)          (((PIFSTMT)(p))->hpaStmts)
#define IfStmt_GetElseLabel(p)          (((PIFSTMT)(p))->szElseLabel)
#define IfStmt_GetEndLabel(p)           (((PIFSTMT)(p))->szEndLabel)

// Label Statement

typedef struct tagLABELSTMT
    {
    STMT    stmt;
    LPSTR   psz;
    } LABELSTMT;
DECLARE_STANDARD_TYPES(LABELSTMT);

RES     PUBLIC LabelStmt_New(PSTMT * ppstmt, LPCSTR psz, DWORD iLine);

#define LabelStmt_GetIdent(p)       (((PLABELSTMT)(p))->psz)


// Goto Statement

typedef struct tagGOTOSTMT
    {
    STMT    stmt;
    LPSTR   psz;
    } GOTOSTMT;
DECLARE_STANDARD_TYPES(GOTOSTMT);

RES     PUBLIC GotoStmt_New(PSTMT * ppstmt, LPCSTR psz, DWORD iLine);

#define GotoStmt_GetIdent(p)        (((PGOTOSTMT)(p))->psz)


// Delay Statement

typedef struct tagDELAYSTMT
    {
    STMT    stmt;
    PEXPR   pexprSecs;
    } DELAYSTMT;
DECLARE_STANDARD_TYPES(DELAYSTMT);

RES     PUBLIC DelayStmt_New(PSTMT * ppstmt, PEXPR pexprSecs, DWORD iLine);

#define DelayStmt_GetExpr(p)        (((PDELAYSTMT)(p))->pexprSecs)


// WaitFor Statement

typedef struct tagWAITCASE
    {
    PEXPR   pexpr;
    LPSTR   pszIdent;           // label to jump to; may be NULL
    DWORD   dwFlags;            // WCF_*
    } WAITCASE;
DECLARE_STANDARD_TYPES(WAITCASE);

// Flags for WaitforStmt
#define WCF_DEFAULT     0x0000
#define WCF_MATCHCASE   0x0001

RES     PUBLIC Waitcase_Create(PHSA phsa);
RES     PUBLIC Waitcase_Add(HSA hsa, PEXPR pexpr, LPCSTR pszIdent, DWORD dwFlags);
RES     PUBLIC Waitcase_Destroy(HSA hsa);

typedef struct tagWAITFORSTMT
    {
    STMT    stmt;
    HSA     hsa;                // List of strings to wait for
    PEXPR   pexprUntil;         // Optional; may be NULL
    } WAITFORSTMT;
DECLARE_STANDARD_TYPES(WAITFORSTMT);

RES     PUBLIC WaitforStmt_New(PSTMT * ppstmt, HSA hsa, PEXPR pexprUntil, DWORD iLine);

#define WaitforStmt_GetCaseList(p)  (((PWAITFORSTMT)(p))->hsa)
#define WaitforStmt_GetUntilExpr(p) (((PWAITFORSTMT)(p))->pexprUntil)


// Transmit Statement

typedef struct tagTRANSMITSTMT
    {
    STMT    stmt;
    PEXPR   pexpr;
    DWORD   dwFlags;        // TSF_*
    } TRANSMITSTMT;
DECLARE_STANDARD_TYPES(TRANSMITSTMT);

// Flags for TransmitStmt
#define TSF_DEFAULT     0x0000
#define TSF_RAW         0x0001

RES     PUBLIC TransmitStmt_New(PSTMT * ppstmt, PEXPR pexpr, DWORD dwFlags, DWORD iLine);

#define TransmitStmt_GetExpr(p)     (((PTRANSMITSTMT)(p))->pexpr)
#define TransmitStmt_GetFlags(p)    (((PTRANSMITSTMT)(p))->dwFlags)


// Set Statement

typedef enum
    {
    ST_IPADDR,
    ST_PORT,
    ST_SCREEN,
    } SETTYPE;

typedef struct tagSETSTMT
    {
    STMT    stmt;
    SETTYPE settype;
    } SETSTMT;
DECLARE_STANDARD_TYPES(SETSTMT);

#define SetStmt_GetType(p)          (((PSETSTMT)(p))->settype)

#define SetStmt_SetType(p, t)       (((PSETSTMT)(p))->settype = (t))


// Set IP Statement

typedef struct tagSETIPSTMT
    {
    SETSTMT setstmt;
    PEXPR   pexpr;
    } SETIPSTMT;
DECLARE_STANDARD_TYPES(SETIPSTMT);

RES     PUBLIC SetIPStmt_New(PSTMT * ppstmt, PEXPR pexpr, DWORD iLine);

#define SetIPStmt_GetExpr(p)        (((PSETIPSTMT)(p))->pexpr)


// Set Port Statement

typedef struct tagPORTSTATE
    {
    DWORD   dwFlags;        // SPF_*
    BYTE    nDatabits;
    BYTE    nParity;        // 0-4: none, odd, even, mark, space
    BYTE    nStopbits;      // 0,1,2: 1 bit, 1.5 bits, 2 bits
    } PORTSTATE;
DECLARE_STANDARD_TYPES(PORTSTATE);

// Flags for PortState
#define SPF_DATABITS    0x0001
#define SPF_PARITY      0x0002
#define SPF_STOPBITS    0x0004

typedef struct tagSETPORTSTMT
    {
    SETSTMT setstmt;
    PORTSTATE portstate;
    } SETPORTSTMT;
DECLARE_STANDARD_TYPES(SETPORTSTMT);

RES     PUBLIC SetPortStmt_New(PSTMT * ppstmt, PPORTSTATE pstate, DWORD iLine);

#define SetPortStmt_GetFlags(p)     (((PSETPORTSTMT)(p))->portstate.dwFlags)
#define SetPortStmt_GetDatabits(p)  (((PSETPORTSTMT)(p))->portstate.nDatabits)
#define SetPortStmt_GetStopbits(p)  (((PSETPORTSTMT)(p))->portstate.nStopbits)
#define SetPortStmt_GetParity(p)    (((PSETPORTSTMT)(p))->portstate.nParity)


// Set Screen Statement

typedef struct tagSCREENSET
    {
    DWORD   dwFlags;        // SPF_*
    BOOL    fKBOn;          // TRUE/FALSE: on, off
    } SCREENSET;
DECLARE_STANDARD_TYPES(SCREENSET);

// Flags for Screen settings
#define SPF_KEYBRD      0x0001

typedef struct tagSETSCREENSTMT
    {
    SETSTMT setstmt;
    SCREENSET screenset;
    } SETSCREENSTMT;
DECLARE_STANDARD_TYPES(SETSCREENSTMT);

RES     PUBLIC SetScreenStmt_New(PSTMT * ppstmt, PSCREENSET pstate, DWORD iLine);

#define SetScreenStmt_GetFlags(p)   (((PSETSCREENSTMT)(p))->screenset.dwFlags)
#define SetScreenStmt_GetKeybrd(p)  (((PSETSCREENSTMT)(p))->screenset.fKBOn)



//
// AST execute block
//

#define MAX_BUF_IP  (3+1+3+1+3+1+3 + 1)

typedef struct tagASTEXEC
    {
    DWORD   dwFlags;
    HWND    hwnd;

    HANDLE  hport;
    PSESS_CONFIGURATION_INFO psci;
    HANDLE  hFindFmt;
    PSYMTAB pstSystem;      // Allocated: system symbol table

    HPA     hpaPcode;
    DWORD   ipaCur;         // current statement executing
    PSYMTAB pstCur;         // symbol table for current frame
    PSTMT   pstmtPending;   // pending statement 
    int     cProcDepth;     // call depth

    HSA     hsaStxerr;

    char    szIP[MAX_BUF_IP];
    int     nIter;          // scratch iterative value
    } ASTEXEC;
DECLARE_STANDARD_TYPES(ASTEXEC);

RES     PUBLIC Astexec_Init(PASTEXEC this, HANDLE hport, PSESS_CONFIGURATION_INFO psci, HSA hsaStxerr);
RES     PUBLIC Astexec_Destroy(PASTEXEC this);
RES     PUBLIC Astexec_Add(PASTEXEC this, PSTMT pstmt);
RES     PUBLIC Astexec_InsertLabel(PASTEXEC this, LPCSTR pszIdent, PSYMTAB pst);
RES     PUBLIC Astexec_JumpToLabel(PASTEXEC this, LPCSTR pszIdent);
void    PUBLIC Astexec_SetError(PASTEXEC this, BOOL bSuccess, BOOL bFailure);

RES     PUBLIC Astexec_Next(PASTEXEC this);
DWORD   PUBLIC Astexec_GetCurLine(PASTEXEC this);
void    PUBLIC Astexec_SendString(PASTEXEC this, LPCSTR pszSend, BOOL bRaw);
RES     PUBLIC Astexec_SetIPAddr(PASTEXEC this, LPCSTR psz);
RES     PUBLIC Astexec_FindFormat(PASTEXEC this, LPDWORD piFound);
RES     PUBLIC Astexec_DestroyFindFormat(PASTEXEC this);

// Flags for Astexec
#define AEF_DONE            0x0001
#define AEF_PAUSED          0x0002
#define AEF_HALT            0x0004
#define AEF_WAITUNTIL       0x0010
#define AEF_STOPWAITING     0x0020

#define Astexec_IsDone(this)            IsFlagSet((this)->dwFlags, AEF_DONE)
#define Astexec_IsReadPending(this)     (NULL != (this)->pstmtPending)
#define Astexec_IsPaused(this)          IsFlagSet((this)->dwFlags, AEF_PAUSED)
#define Astexec_IsHalted(this)          IsFlagSet((this)->dwFlags, AEF_HALT)
#define Astexec_IsWaitUntil(this)       IsFlagSet((this)->dwFlags, AEF_WAITUNTIL)

#define Astexec_GetIPAddr(this)         ((this)->szIP)
#define Astexec_GetPending(this)        ((this)->pstmtPending)

#define Astexec_ClearPause(this)        ClearFlag((this)->dwFlags, AEF_PAUSED)
#define Astexec_ClearWaitUntil(this)    ClearFlag((this)->dwFlags, AEF_WAITUNTIL)
#define Astexec_SetStopWaiting(this)    SetFlag((this)->dwFlags, AEF_STOPWAITING)

#define Astexec_SetIP(this, ipa)        ((this)->ipaCur = (ipa))
#define Astexec_SetHwnd(this, hwndT)    ((this)->hwnd = hwndT)
#define Astexec_SetPending(this, pstmt) ((this)->pstmtPending = (pstmt))

#endif // __AST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasscrpt\codegen.c ===
//
// Copyright (c) Microsoft Corporation 1995
//
// codegen.c
//
// This file contains the code-generating functions.
//
// The "code" is actually just an intermediate representation.
// Currently this is an array of ASTs.
//
// History:
//  06-18-95 ScottH     Created
//


#include "proj.h"
#include "rcids.h"

RES     PRIVATE Stmt_Codegen(PSTMT this, PASTEXEC pastexec, PSYMTAB pst);


/*----------------------------------------------------------
Purpose: Generate code for the 'while' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE WhileStmt_Codegen(
    PSTMT this,
    PASTEXEC pastexec,
    PSYMTAB pst)
    {
    RES res;
    LPSTR pszTop;
    LPSTR pszEnd;

    ASSERT(this);
    ASSERT(pastexec);
    ASSERT(AT_WHILE_STMT == Ast_GetType(this));

    pszTop = WhileStmt_GetTopLabel(this);
    pszEnd = WhileStmt_GetEndLabel(this);

    res = Astexec_InsertLabel(pastexec, pszTop, pst);
    if (RSUCCEEDED(res))
        {
        // add the 'while' statement for the test expression
        res = Astexec_Add(pastexec, this);
        if (RSUCCEEDED(res))
            {
            // add the statements in the statement block
            DWORD i;
            DWORD cstmts;
            HPA hpaStmts = WhileStmt_GetStmtBlock(this);

            res = RES_OK;

            cstmts = PAGetCount(hpaStmts);

            // Add each statement
            for (i = 0; i < cstmts; i++)
                {
                PSTMT pstmt = PAFastGetPtr(hpaStmts, i);

                res = Stmt_Codegen(pstmt, pastexec, pst);
                if (RFAILED(res))
                    break;
                }

            if (RSUCCEEDED(res))
                {
                // add the end label
                res = Astexec_InsertLabel(pastexec, pszEnd, pst);
                }
            }
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Generate code for the 'if' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE IfStmt_Codegen(
    PSTMT this,
    PASTEXEC pastexec,
    PSYMTAB pst)
    {
    RES res;
    LPSTR pszElse;
    LPSTR pszEnd;

    ASSERT(this);
    ASSERT(pastexec);
    ASSERT(AT_IF_STMT == Ast_GetType(this));

    pszElse = IfStmt_GetElseLabel(this);
    pszEnd = IfStmt_GetEndLabel(this);

    // add the 'if' statement for the test expression
    res = Astexec_Add(pastexec, this);
    if (RSUCCEEDED(res))
        {
        // add the statements in the 'then' statement block
        DWORD i;
        DWORD cstmts;
        HPA hpaStmts = IfStmt_GetStmtBlock(this);

        res = RES_OK;

        cstmts = PAGetCount(hpaStmts);

        // Add each statement
        for (i = 0; i < cstmts; i++)
            {
            PSTMT pstmt = PAFastGetPtr(hpaStmts, i);

            res = Stmt_Codegen(pstmt, pastexec, pst);
            if (RFAILED(res))
                break;
            }

        if (RSUCCEEDED(res))
            {
            // add the else label
            res = Astexec_InsertLabel(pastexec, pszElse, pst);
            }
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Generate code for the label statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE LabelStmt_Codegen(
    PSTMT this,
    PASTEXEC pastexec,
    PSYMTAB pst)
    {
    LPSTR pszIdent;

    ASSERT(this);
    ASSERT(pastexec);
    ASSERT(AT_LABEL_STMT == Ast_GetType(this));

    pszIdent = LabelStmt_GetIdent(this);

    return Astexec_InsertLabel(pastexec, pszIdent, pst);
    }


/*----------------------------------------------------------
Purpose: Generate code for the 'set' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE SetStmt_Codegen(
    PSTMT this,
    PASTEXEC pastexec,
    PSYMTAB pst)
    {
    RES res = RES_OK;

    ASSERT(this);
    ASSERT(pastexec);
    ASSERT(AT_SET_STMT == Ast_GetType(this));

    switch (SetStmt_GetType(this))
        {
    case ST_IPADDR:
    case ST_PORT:
    case ST_SCREEN:
        res = Astexec_Add(pastexec, this);
        break;

    default:
        ASSERT(0);
        res = RES_E_INVALIDPARAM;
        break;
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Generate code for a statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE Stmt_Codegen(
    PSTMT this,
    PASTEXEC pastexec,
    PSYMTAB pst)
    {
    RES res;

    ASSERT(this);
    ASSERT(pastexec);

    switch (Ast_GetType(this))
        {
    case AT_ENTER_STMT:
    case AT_LEAVE_STMT:
    case AT_HALT_STMT:
    case AT_TRANSMIT_STMT:
    case AT_WAITFOR_STMT:
    case AT_DELAY_STMT:
    case AT_GOTO_STMT:
    case AT_ASSIGN_STMT:
        res = Astexec_Add(pastexec, this);
        break;

    case AT_WHILE_STMT:
        res = WhileStmt_Codegen(this, pastexec, pst);
        break;

    case AT_IF_STMT:
        res = IfStmt_Codegen(this, pastexec, pst);
        break;

    case AT_SET_STMT:
        res = SetStmt_Codegen(this, pastexec, pst);
        break;

    case AT_LABEL_STMT:
        res = LabelStmt_Codegen(this, pastexec, pst);
        break;

    default:
        ASSERT(0);
        res = RES_E_INVALIDPARAM;
        break;
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Generate code for a procedure declaration.

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE ProcDecl_Codegen(
    PPROCDECL this,
    PASTEXEC pastexec)
    {
    RES res = RES_OK;
    DWORD i;
    DWORD cstmts;

    ASSERT(this);
    ASSERT(pastexec);

    cstmts = PAGetCount(this->hpaStmts);

    // Generate for each statement
    for (i = 0; i < cstmts; i++)
        {
        PSTMT pstmt = PAFastGetPtr(this->hpaStmts, i);

        res = Stmt_Codegen(pstmt, pastexec, this->pst);
        if (RFAILED(res))
            break;
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Find the proc decl that has the given identifier.

Returns: TRUE (if found)

Cond:    --
*/
BOOL PRIVATE FindProc(
    PMODULEDECL pmd,
    LPCSTR pszIdent,
    PPROCDECL * ppprocdecl)
    {
    DWORD i;
    DWORD cprocs = PAGetCount(pmd->hpaProcs);

    *ppprocdecl = NULL;

    for (i = 0; i < cprocs; i++)
        {
        PPROCDECL pprocdecl = PAFastGetPtr(pmd->hpaProcs, i);

        if (IsSzEqualC(ProcDecl_GetIdent(pprocdecl), pszIdent))
            {
            *ppprocdecl = pprocdecl;
            break;
            }
        }

    return NULL != *ppprocdecl;
    }


/*----------------------------------------------------------
Purpose: Generate code for the module declaration.

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PUBLIC ModuleDecl_Codegen(
    PMODULEDECL this,
    PASTEXEC pastexec)
    {
    RES res = RES_OK;
    DWORD i;
    DWORD cprocs;
    PPROCDECL ppdMain;

    ASSERT(this);
    ASSERT(pastexec);

    TRACE_MSG(TF_GENERAL, "Generating code...");

    cprocs = PAGetCount(this->hpaProcs);

    // Generate code for the main proc first.
    if (FindProc(this, "main", &ppdMain))
        {
        res = ProcDecl_Codegen(ppdMain, pastexec);
        if (RSUCCEEDED(res))
            {
            // Generate code for the rest of the procs
            for (i = 0; i < cprocs; i++)
                {
                PPROCDECL pprocdecl = PAFastGetPtr(this->hpaProcs, i);

                if (pprocdecl != ppdMain)
                    {
                    res = ProcDecl_Codegen(pprocdecl, pastexec);
                    if (RFAILED(res))
                        break;
                    }
                }
            }
        }
    else
        {
        // Typechecking should have guaranteed that the main
        // proc was here
        ASSERT(0);
        res = RES_E_FAIL;
        }

    return res;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasscrpt\common.c ===
//
// Copyright (c) Microsoft Corporation 1993-1995
//
// common.c
//
// This files contains common utility and helper functions.
//
// History:
//  08-06-93 ScottH     Transferred from twin code
//  04-26-95 ScottH     Transferred and expanded from Briefcase code
//


#include "proj.h"
#include "common.h"


#ifdef NORTL

// Some of these are replacements for the C runtime routines.
//  This is so we don't have to link to the CRT libs.
//

/*----------------------------------------------------------
Purpose: memset

         Swiped from the C 7.0 runtime sources.

Returns: 
Cond:    
*/
LPSTR PUBLIC lmemset(
    LPSTR dst,
    char val,
    UINT count)
    {
    LPSTR start = dst;
    
    while (count--)
        *dst++ = val;
    return(start);
    }


/*----------------------------------------------------------
Purpose: memmove

         Swiped from the C 7.0 runtime sources.

Returns: 
Cond:    
*/
LPSTR PUBLIC lmemmove(
    LPSTR dst, 
    LPCSTR src, 
    int count)
    {
    LPSTR ret = dst;
    
    if (dst <= src || dst >= (src + count)) {
        /*
         * Non-Overlapping Buffers
         * copy from lower addresses to higher addresses
         */
        while (count--)
            *dst++ = *src++;
        }
    else {
        /*
         * Overlapping Buffers
         * copy from higher addresses to lower addresses
         */
        dst += count - 1;
        src += count - 1;
        
        while (count--)
            *dst-- = *src--;
        }
    
    return(ret);
    }


#endif // NORTL


#ifndef NOSTRING
// WARNING: all of these APIs do not setup DS, so you can not access
// any data in the default data seg of this DLL.
//
// do not create any global variables... talk to chrisg if you don't
// understand this

#define FASTCALL _fastcall


/*----------------------------------------------------------
Purpose: Case sensitive character comparison for DBCS

Returns: FALSE if they match, TRUE if no match
Cond:    --
*/
BOOL PRIVATE ChrCmp(
    WORD w1, 
    WORD wMatch)
    {
    /* Most of the time this won't match, so test it first for speed.
    */
    if (LOBYTE(w1) == LOBYTE(wMatch))
        {
        if (IsDBCSLeadByte(LOBYTE(w1)))
            {
            return(w1 != wMatch);
            }
        return FALSE;
        }
    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Case insensitive character comparison for DBCS

Returns: FALSE if match, TRUE if not
Cond:    --
*/
BOOL PRIVATE ChrCmpI(
    WORD w1, 
    WORD wMatch)
    {
    char sz1[3], sz2[3];

    if (IsDBCSLeadByte(sz1[0] = LOBYTE(w1)))
        {
        sz1[1] = HIBYTE(w1);
        sz1[2] = '\0';
        }
    else
        sz1[1] = '\0';

    *(WORD FAR *)sz2 = wMatch;
    sz2[2] = '\0';
    return lstrcmpi(sz1, sz2);
    }


/*----------------------------------------------------------
Purpose: strnicmp

         Swiped from the C 7.0 runtime sources.

Returns: 
Cond:    
*/
int PUBLIC lstrnicmp(
    LPCSTR psz1,
    LPCSTR psz2,
    UINT count)
    {
    int ch1;
    int ch2;
    int result = 0;
    LPCSTR pszTmp;
    
    if (count) 
        {
        do      
            {
            pszTmp = CharLower((LPSTR)LongToPtr(MAKELONG(*psz1, 0)));
            ch1 = *pszTmp;
            pszTmp = CharLower((LPSTR)LongToPtr(MAKELONG(*psz2, 0)));
            ch2 = *pszTmp;
            psz1 = AnsiNext(psz1);
            psz2 = AnsiNext(psz2);
            } while (--count && ch1 && ch2 && !ChrCmp((WORD)ch1, (WORD)ch2));
        result = ch1 - ch2;
        }
    return(result);
    }


/*----------------------------------------------------------
Purpose: My verion of atoi.  Supports hexadecimal too.
Returns: integer
Cond:    --
*/
int PUBLIC AnsiToInt(
    LPCSTR pszString)
    {
    #define IS_DIGIT(ch)    InRange(ch, '0', '9')

    int n;
    BOOL bNeg = FALSE;
    LPCSTR psz;
    LPCSTR pszAdj;

    // Skip leading whitespace
    //
    for (psz = pszString; *psz == ' ' || *psz == '\n' || *psz == '\t'; psz = AnsiNext(psz))
        ;
      
    // Determine possible explicit signage
    //  
    if (*psz == '+' || *psz == '-')
        {
        bNeg = (*psz == '+') ? FALSE : TRUE;
        psz = AnsiNext(psz);
        }

    // Or is this hexadecimal?
    //
    pszAdj = AnsiNext(psz);
    if (*psz == '0' && (*pszAdj == 'x' || *pszAdj == 'X'))
        {
        bNeg = FALSE;   // Never allow negative sign with hexadecimal numbers
        psz = AnsiNext(pszAdj);

        // Do the conversion
        //
        for (n = 0; ; psz = AnsiNext(psz))
            {
            if (IS_DIGIT(*psz))
                n = 0x10 * n + *psz - '0';
            else
                {
                char ch = *psz;
                int n2;

                if (ch >= 'a')
                    ch -= 'a' - 'A';

                n2 = ch - 'A' + 0xA;
                if (n2 >= 0xA && n2 <= 0xF)
                    n = 0x10 * n + n2;
                else
                    break;
                }
            }
        }
    else
        {
        for (n = 0; IS_DIGIT(*psz); psz = AnsiNext(psz))
            n = 10 * n + *psz - '0';
        }

    return bNeg ? -n : n;
    }    


/*----------------------------------------------------------
Purpose: Find first occurrence of character in string

Returns: Pointer to the first occurrence of ch in 
Cond:    --
*/
LPSTR PUBLIC AnsiChr(
    LPCSTR psz, 
    WORD wMatch)
    {
    for ( ; *psz; psz = AnsiNext(psz))
        {
        if (!ChrCmp(*(WORD FAR *)psz, wMatch))
            return (LPSTR)psz;
        }
    return NULL;
    }

#endif // NOSTRING


#ifndef NODIALOGHELPER

/*----------------------------------------------------------
Purpose: General front end to invoke dialog boxes
Returns: result from EndDialog
Cond:    --
*/
int PUBLIC DoModal(
    HWND hwndParent,            // owner of dialog
    DLGPROC lpfnDlgProc,        // dialog proc
    UINT uID,                   // dialog template ID
    LPARAM lParam)              // extra parm to pass to dialog (may be NULL)
    {
    int nResult = -1;

    nResult = DialogBoxParam(g_hinst, MAKEINTRESOURCE(uID), hwndParent,
        lpfnDlgProc, lParam);

    return nResult;
    }


/*----------------------------------------------------------
Purpose: Sets the rectangle with the bounding extent of the given string.
Returns: Rectangle
Cond:    --
*/
void PUBLIC SetRectFromExtent(
    HDC hdc,
    LPRECT lprect,
    LPCSTR lpcsz)
    {
    SIZE size;

    GetTextExtentPoint(hdc, lpcsz, lstrlen(lpcsz), &size);
    SetRect(lprect, 0, 0, size.cx, size.cy);
    }

#endif // NODIALOGHELPER


#ifndef NODRAWTEXT

#pragma data_seg(DATASEG_READONLY)

char const FAR c_szEllipses[] = "...";

#pragma data_seg()

// Global variables
int g_cxLabelMargin = 0;
int g_cxBorder = 0;
int g_cyBorder = 0;

COLORREF g_clrHighlightText = 0;
COLORREF g_clrHighlight = 0;
COLORREF g_clrWindowText = 0;
COLORREF g_clrWindow = 0;

HBRUSH g_hbrHighlight = 0;
HBRUSH g_hbrWindow = 0;


/*----------------------------------------------------------
Purpose: Get the system metrics we need
Returns: --
Cond:    --
*/
void PUBLIC GetCommonMetrics(
    WPARAM wParam)      // wParam from WM_WININICHANGE
    {
    if ((wParam == 0) || (wParam == SPI_SETNONCLIENTMETRICS))
        {
        g_cxBorder = GetSystemMetrics(SM_CXBORDER);
        g_cyBorder = GetSystemMetrics(SM_CYBORDER);

        g_cxLabelMargin = (g_cxBorder * 2);
        }
    }


/*----------------------------------------------------------
Purpose: Sees whether the entire string will fit in *prc.
         If not, compute the numbder of chars that will fit
         (including ellipses).  Returns length of string in
         *pcchDraw.

         Taken from COMMCTRL.

Returns: TRUE if the string needed ellipses
Cond:    --
*/
BOOL PRIVATE NeedsEllipses(
    HDC hdc, 
    LPCSTR pszText, 
    RECT * prc, 
    int * pcchDraw, 
    int cxEllipses)
    {
    int cchText;
    int cxRect;
    int ichMin, ichMax, ichMid;
    SIZE siz;

    cxRect = prc->right - prc->left;

    cchText = lstrlen(pszText);

    if (cchText == 0)
        {
        *pcchDraw = cchText;
        return FALSE;
        }

    GetTextExtentPoint(hdc, pszText, cchText, &siz);

    if (siz.cx <= cxRect)
        {
        *pcchDraw = cchText;
        return FALSE;
        }

    cxRect -= cxEllipses;

    // If no room for ellipses, always show first character.
    //
    ichMax = 1;
    if (cxRect > 0)
        {
        // Binary search to find character that will fit
        ichMin = 0;
        ichMax = cchText;
        while (ichMin < ichMax)
            {
            // Be sure to round up, to make sure we make progress in
            // the loop if ichMax == ichMin + 1.
            //
            ichMid = (ichMin + ichMax + 1) / 2;

            GetTextExtentPoint(hdc, &pszText[ichMin], ichMid - ichMin, &siz);

            if (siz.cx < cxRect)
                {
                ichMin = ichMid;
                cxRect -= siz.cx;
                }
            else if (siz.cx > cxRect)
                {
                ichMax = ichMid - 1;
                }
            else
                {
                // Exact match up up to ichMid: just exit.
                //
                ichMax = ichMid;
                break;
                }
            }

        // Make sure we always show at least the first character...
        //
        if (ichMax < 1)
            ichMax = 1;
        }

    *pcchDraw = ichMax;
    return TRUE;
    }


#define CCHELLIPSES     3
#define DT_LVWRAP       (DT_CENTER | DT_WORDBREAK | DT_NOPREFIX | DT_EDITCONTROL)

/*----------------------------------------------------------
Purpose: Draws text the shell's way.  

         Taken from COMMCTRL.

Returns: --

Cond:    This function requires TRANSPARENT background mode
         and a properly selected font.
*/
void PUBLIC MyDrawText(
    HDC hdc, 
    LPCSTR pszText, 
    RECT FAR* prc, 
    UINT flags, 
    int cyChar, 
    int cxEllipses, 
    COLORREF clrText, 
    COLORREF clrTextBk)
    {
    int cchText;
    COLORREF clrSave;
    COLORREF clrSaveBk;
    UINT uETOFlags = 0;
    RECT rc;
    char ach[MAX_PATH + CCHELLIPSES];

    // REVIEW: Performance idea:
    // We could cache the currently selected text color
    // so we don't have to set and restore it each time
    // when the color is the same.
    //
    if (!pszText)
        return;

    rc = *prc;

    // If needed, add in a little extra margin...
    //
    if (IsFlagSet(flags, MDT_EXTRAMARGIN))
        {
        rc.left  += g_cxLabelMargin * 3;
        rc.right -= g_cxLabelMargin * 3;
        }
    else
        {
        rc.left  += g_cxLabelMargin;
        rc.right -= g_cxLabelMargin;
        }

    if (IsFlagSet(flags, MDT_ELLIPSES) &&
        NeedsEllipses(hdc, pszText, &rc, &cchText, cxEllipses))
        {
        hmemcpy(ach, pszText, cchText);
        lstrcpy(ach + cchText, c_szEllipses);

        pszText = ach;

        // Left-justify, in case there's no room for all of ellipses
        //
        ClearFlag(flags, (MDT_RIGHT | MDT_CENTER));
        SetFlag(flags, MDT_LEFT);

        cchText += CCHELLIPSES;
        }
    else
        {
        cchText = lstrlen(pszText);
        }

    if (IsFlagSet(flags, MDT_TRANSPARENT))
        {
        clrSave = SetTextColor(hdc, 0x000000);
        }
    else
        {
        uETOFlags |= ETO_OPAQUE;

        if (IsFlagSet(flags, MDT_SELECTED))
            {
            clrSave = SetTextColor(hdc, g_clrHighlightText);
            clrSaveBk = SetBkColor(hdc, g_clrHighlight);

            if (IsFlagSet(flags, MDT_DRAWTEXT))
                {
                FillRect(hdc, prc, g_hbrHighlight);
                }
            }
        else 
            {
            if (clrText == CLR_DEFAULT && clrTextBk == CLR_DEFAULT)
                {
                clrSave = SetTextColor(hdc, g_clrWindowText);
                clrSaveBk = SetBkColor(hdc, g_clrWindow);

                if (IsFlagSet(flags, MDT_DRAWTEXT | MDT_DESELECTED))
                    {
                    FillRect(hdc, prc, g_hbrWindow);
                    }
                }
            else
                {
                HBRUSH hbr;

                if (clrText == CLR_DEFAULT)
                    clrText = g_clrWindowText;

                if (clrTextBk == CLR_DEFAULT)
                    clrTextBk = g_clrWindow;

                clrSave = SetTextColor(hdc, clrText);
                clrSaveBk = SetBkColor(hdc, clrTextBk);

                if (IsFlagSet(flags, MDT_DRAWTEXT | MDT_DESELECTED))
                    {
                    hbr = CreateSolidBrush(GetNearestColor(hdc, clrTextBk));
                    if (hbr)
                        {
                        FillRect(hdc, prc, hbr);
                        DeleteObject(hbr);
                        }
                    else
                        FillRect(hdc, prc, GetStockObject(WHITE_BRUSH));
                    }
                }
            }
        }

    // If we want the item to display as if it was depressed, we will
    // offset the text rectangle down and to the left
    if (IsFlagSet(flags, MDT_DEPRESSED))
        OffsetRect(&rc, g_cxBorder, g_cyBorder);

    if (IsFlagSet(flags, MDT_DRAWTEXT))
        {
        UINT uDTFlags = DT_LVWRAP;

        if (IsFlagClear(flags, MDT_CLIPPED))
            uDTFlags |= DT_NOCLIP;

        DrawText(hdc, pszText, cchText, &rc, uDTFlags);
        }
    else
        {
        if (IsFlagClear(flags, MDT_LEFT))
            {
            SIZE siz;

            GetTextExtentPoint(hdc, pszText, cchText, &siz);

            if (IsFlagSet(flags, MDT_CENTER))
                rc.left = (rc.left + rc.right - siz.cx) / 2;
            else    
                {
                ASSERT(IsFlagSet(flags, MDT_RIGHT));
                rc.left = rc.right - siz.cx;
                }
            }

        if (IsFlagSet(flags, MDT_VCENTER))
            {
            // Center vertically
            rc.top += (rc.bottom - rc.top - cyChar) / 2;
            }

        if (IsFlagSet(flags, MDT_CLIPPED))
            uETOFlags |= ETO_CLIPPED;

        ExtTextOut(hdc, rc.left, rc.top, uETOFlags, prc, pszText, cchText, NULL);
        }

    if (flags & (MDT_SELECTED | MDT_DESELECTED | MDT_TRANSPARENT))
        {
        SetTextColor(hdc, clrSave);
        if (IsFlagClear(flags, MDT_TRANSPARENT))
            SetBkColor(hdc, clrSaveBk);
        }
    }
#endif // NODRAWTEXT


#ifndef NOFILEINFO

/*----------------------------------------------------------
Purpose: Takes a DWORD value and converts it to a string, adding
         commas on the way.

         This was taken from the shell.

Returns: Pointer to buffer

Cond:    --
*/
LPSTR PRIVATE AddCommas(
    DWORD dw, 
    LPSTR pszBuffer,
    UINT cbBuffer)
    {
    char  szTemp[30];
    char  szSep[5];
    NUMBERFMT nfmt;

    nfmt.NumDigits=0;
    nfmt.LeadingZero=0;
    GetLocaleInfoA(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szSep, sizeof(szSep));
    nfmt.Grouping = AnsiToInt(szSep);
    GetLocaleInfoA(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szSep, sizeof(szSep));
    nfmt.lpDecimalSep = nfmt.lpThousandSep = szSep;
    nfmt.NegativeOrder= 0;

    wsprintf(szTemp, "%lu", dw);

    GetNumberFormatA(LOCALE_USER_DEFAULT, 0, szTemp, &nfmt, pszBuffer, cbBuffer);
    return pszBuffer;
    }


const short s_rgidsOrders[] = {IDS_BYTES, IDS_ORDERKB, IDS_ORDERMB, IDS_ORDERGB, IDS_ORDERTB};

/*----------------------------------------------------------
Purpose: Converts a number into a short, string format.

         This code was taken from the shell.

            532     -> 523 bytes
            1340    -> 1.3KB
            23506   -> 23.5KB
                    -> 2.4MB
                    -> 5.2GB

Returns: pointer to buffer
Cond:    --
*/
LPSTR PRIVATE ShortSizeFormat64(
    __int64 dw64, 
    LPSTR szBuf)
    {
    int i;
    UINT wInt, wLen, wDec;
    char szTemp[10], szOrder[20], szFormat[5];

    if (dw64 < 1000) 
        {
        wsprintf(szTemp, "%d", LODWORD(dw64));
        i = 0;
        goto AddOrder;
        }

    for (i = 1; i < ARRAY_ELEMENTS(s_rgidsOrders)-1 && dw64 >= 1000L * 1024L; dw64 >>= 10, i++);
        /* do nothing */

    wInt = LODWORD(dw64 >> 10);
    AddCommas(wInt, szTemp, sizeof(szTemp));
    wLen = lstrlen(szTemp);
    if (wLen < 3)
        {
        wDec = LODWORD(dw64 - (__int64)wInt * 1024L) * 1000 / 1024;
        // At this point, wDec should be between 0 and 1000
        // we want get the top one (or two) digits.
        wDec /= 10;
        if (wLen == 2)
            wDec /= 10;

        // Note that we need to set the format before getting the
        // intl char.
        lstrcpy(szFormat, "%02d");

        szFormat[2] = '0' + 3 - wLen;
        GetLocaleInfoA(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL,
                szTemp+wLen, sizeof(szTemp)-wLen);
        wLen = lstrlen(szTemp);
        wLen += wsprintf(szTemp+wLen, szFormat, wDec);
        }

AddOrder:
    LoadString(g_hinst, s_rgidsOrders[i], szOrder, sizeof(szOrder));
    wsprintf(szBuf, szOrder, (LPSTR)szTemp);

    return szBuf;
    }



/*----------------------------------------------------------
Purpose: Converts a number into a short, string format.

         This code was taken from the shell.

            532     -> 523 bytes
            1340    -> 1.3KB
            23506   -> 23.5KB
                    -> 2.4MB
                    -> 5.2GB

Returns: pointer to buffer
Cond:    --
*/
LPSTR PRIVATE ShortSizeFormat(DWORD dw, LPSTR szBuf)
    {
    return(ShortSizeFormat64((__int64)dw, szBuf));
    }


/*----------------------------------------------------------
Purpose: Gets the file info given a path.  If the path refers
         to a directory, then simply the path field is filled.

         If himl != NULL, then the function will add the file's
         image to the provided image list and set the image index
         field in the *ppfi.

Returns: standard hresult
Cond:    --
*/
HRESULT PUBLIC FICreate(
    LPCSTR pszPath,
    FileInfo ** ppfi,
    UINT uFlags)
    {
    HRESULT hres = ResultFromScode(E_OUTOFMEMORY);
    int cchPath;
    SHFILEINFO sfi;
    UINT uInfoFlags = SHGFI_DISPLAYNAME | SHGFI_ATTRIBUTES;
    DWORD dwAttr;

    ASSERT(pszPath);
    ASSERT(ppfi);

    // Get shell file info 
    if (IsFlagSet(uFlags, FIF_ICON))
        uInfoFlags |= SHGFI_ICON;
    if (IsFlagSet(uFlags, FIF_DONTTOUCH))
        {
        uInfoFlags |= SHGFI_USEFILEATTRIBUTES;

        // Today, FICreate is not called for folders, so this is ifdef'd out
#ifdef SUPPORT_FOLDERS
        dwAttr = IsFlagSet(uFlags, FIF_FOLDER) ? FILE_ATTRIBUTE_DIRECTORY : 0;
#else
        dwAttr = 0;
#endif
        }
    else
        dwAttr = 0;

    if (SHGetFileInfo(pszPath, dwAttr, &sfi, sizeof(sfi), uInfoFlags))
        {
        // Allocate enough for the structure, plus buffer for the fully qualified
        // path and buffer for the display name (and extra null terminator).
        cchPath = lstrlen(pszPath);

        *ppfi = GAlloc(sizeof(FileInfo)+cchPath+1-sizeof((*ppfi)->szPath)+lstrlen(sfi.szDisplayName)+1);
        if (*ppfi)
            {
            FileInfo * pfi = *ppfi;

            pfi->pszDisplayName = pfi->szPath+cchPath+1;
            lstrcpy(pfi->pszDisplayName, sfi.szDisplayName);

            if (IsFlagSet(uFlags, FIF_ICON))
                pfi->hicon = sfi.hIcon;

            pfi->dwAttributes = sfi.dwAttributes;

            // Does the path refer to a directory?
            if (FIIsFolder(pfi))
                {
                // Yes; just fill in the path field
                lstrcpy(pfi->szPath, pszPath);
                hres = NOERROR;
                }
            else
                {
                // No; assume the file exists?
                if (IsFlagClear(uFlags, FIF_DONTTOUCH))
                    {
                    // Yes; get the time, date and size of the file
                    HANDLE hfile = CreateFile(pszPath, GENERIC_READ, 
                                FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                                NULL);

                    if (hfile == INVALID_HANDLE_VALUE)
                        {
                        GFree(*ppfi);
                        *ppfi = NULL;
                        hres = ResultFromScode(E_HANDLE);
                        }
                    else
                        {
                        hres = NOERROR;

                        lstrcpy(pfi->szPath, pszPath);
                        pfi->dwSize = GetFileSize(hfile, NULL);
                        GetFileTime(hfile, NULL, NULL, &pfi->ftMod);
                        CloseHandle(hfile);
                        }
                    }
                else
                    {
                    // No; use what we have
                    hres = NOERROR;
                    lstrcpy(pfi->szPath, pszPath);
                    }
                }
            }
        }
    else if (!WPPathExists(pszPath))
        {
        // Differentiate between out of memory and file not found
        hres = E_FAIL;
        }

    return hres;
    }


/*----------------------------------------------------------
Purpose: Get some file info of the given path.
         The returned string is of the format "# bytes <date>"

         If the path is a folder, the string is empty.

Returns: FALSE if path is not found
Cond:    --
*/
BOOL PUBLIC FIGetInfoString(
    FileInfo * pfi,
    LPSTR pszBuf,
    int cchBuf)
    {
    BOOL bRet;

    ASSERT(pfi);
    ASSERT(pszBuf);

    *pszBuf = NULL_CHAR;

    if (pfi)
        {
        // Is this a file?
        if ( !FIIsFolder(pfi) )
            {
            // Yes
            char szSize[MAX_BUF_MED];
            char szDate[MAX_BUF_MED];
            char szTime[MAX_BUF_MED];
            LPSTR pszMsg;
            SYSTEMTIME st;
            FILETIME ftLocal;

            // Construct the string
            FileTimeToLocalFileTime(&pfi->ftMod, &ftLocal);
            FileTimeToSystemTime(&ftLocal, &st);
            GetDateFormatA(LOCALE_USER_DEFAULT, DATE_LONGDATE, &st, NULL, szDate, sizeof(szDate));
            GetTimeFormatA(LOCALE_USER_DEFAULT, 0, &st, NULL, szTime, sizeof(szTime));

            if (ConstructMessage(&pszMsg, g_hinst, MAKEINTRESOURCE(IDS_DATESIZELINE),
                ShortSizeFormat(FIGetSize(pfi), szSize), szDate, szTime))
                {
                lstrcpy(pszBuf, pszMsg);
                GFree(pszMsg);
                }
            else
                *pszBuf = 0;

            bRet = TRUE;
            }
        else
            bRet = FALSE;
        }
    else
        bRet = FALSE;

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Set the path entry.  This can move the pfi.

Returns: FALSE on out of memory
Cond:    --
*/
BOOL PUBLIC FISetPath(
    FileInfo ** ppfi,
    LPCSTR pszPathNew,
    UINT uFlags)
    {
    ASSERT(ppfi);
    ASSERT(pszPathNew);

    FIFree(*ppfi);

    return SUCCEEDED(FICreate(pszPathNew, ppfi, uFlags));
    }


/*----------------------------------------------------------
Purpose: Free our file info struct
Returns: --
Cond:    --
*/
void PUBLIC FIFree(
    FileInfo * pfi)
    {
    if (pfi)
        {
        if (pfi->hicon)
            DestroyIcon(pfi->hicon);

        GFree(pfi);     // This macro already checks for NULL pfi condition
        }
    }


/*----------------------------------------------------------
Purpose: Convert FILETIME struct to a readable string

Returns: String 
Cond:    --
*/
void PUBLIC FileTimeToDateTimeString(
    LPFILETIME pft, 
    LPSTR pszBuf,
    int cchBuf)
    {
    SYSTEMTIME st;
    FILETIME ftLocal;

    FileTimeToLocalFileTime(pft, &ftLocal);
    FileTimeToSystemTime(&ftLocal, &st);
    GetDateFormatA(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &st, NULL, pszBuf, cchBuf/2);
    pszBuf += lstrlen(pszBuf);
    *pszBuf++ = ' ';
    GetTimeFormatA(LOCALE_USER_DEFAULT, TIME_NOSECONDS, &st, NULL, pszBuf, cchBuf/2);
    }

#endif // NOFILEINFO


#ifndef NOSYNC
CRITICAL_SECTION g_csCommon = { 0 };
DEBUG_CODE( UINT g_cRefCommonCS = 0; )

/*----------------------------------------------------------
Purpose: Waits for on object to signal.  This function "does 
         the right thing" to prevent deadlocks which can occur
         because the calculation thread calls SendMessage.

Returns: value of MsgWaitForMultipleObjects
Cond:    --
*/
DWORD PUBLIC MsgWaitObjectsSendMessage(
    DWORD cObjects,
    LPHANDLE phObjects,
    DWORD dwTimeout)
    {
    DWORD dwRet;

    while (TRUE)
        {
        dwRet = MsgWaitForMultipleObjects(cObjects, phObjects, FALSE,
                                        dwTimeout, QS_SENDMESSAGE);

        // If it is not a message, return
        if ((WAIT_OBJECT_0 + cObjects) != dwRet)
            {
            return dwRet;
            }
        else
            {
            // Process all the sent messages
            MSG msg;
            PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);
            }
        }
    }


/*----------------------------------------------------------
Purpose: Initialize the critical section.

Returns: --

Cond:    Note that critical sections differ between Win95
         and NT.  On Win95, critical sections synchronize
         across processes.  On NT, they are per-process.
*/
void PUBLIC Common_InitExclusive(void)
    {
    ReinitializeCriticalSection(&g_csCommon);
    ASSERT(0 != *((LPDWORD)&g_csCommon));

#ifdef DEBUG
    g_cRefCommonCS = 0;
#endif
    }


/*----------------------------------------------------------
Purpose: Enter a critical section
Returns: --

Cond:    Note that critical sections differ between Win95
         and NT.  On Win95, critical sections synchronize
         across processes.  On NT, they are per-process.
*/
void PUBLIC Common_EnterExclusive(void)
    {
    EnterCriticalSection(&g_csCommon);
#ifdef DEBUG
    g_cRefCommonCS++;
#endif
    }


/*----------------------------------------------------------
Purpose: Leave a critical section
Returns: --

Cond:    Note that critical sections differ between Win95
         and NT.  On Win95, critical sections synchronize
         across processes.  On NT, they are per-process.
*/
void PUBLIC Common_LeaveExclusive(void)
    {
#ifdef DEBUG
    g_cRefCommonCS--;
#endif
    LeaveCriticalSection(&g_csCommon);
    }

#endif // NOSYNC


#ifndef NOMESSAGESTRING

/*----------------------------------------------------------
Purpose: Load the string (if necessary) and format the string
         properly.

Returns: A pointer to the allocated string containing the formatted
         message or
         NULL if out of memory

Cond:    free pointer with LocalFree()
*/
LPSTR PUBLIC ConstructVMessageString(
    HINSTANCE hinst, 
    LPCSTR pszMsg, 
    va_list *ArgList)
    {
    char szTemp[MAX_BUF];
    LPSTR pszRet;
    LPSTR pszRes;

    if (HIWORD(pszMsg))
        pszRes = (LPSTR)pszMsg;
    else if (LOWORD(pszMsg) && LoadString(hinst, LOWORD(pszMsg), szTemp, sizeof(szTemp)))
        pszRes = szTemp;
    else
        pszRes = NULL;

    if (pszRes)
        {
        if (!FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                           pszRes, 0, 0, (LPTSTR)&pszRet, 0, ArgList)) 
            {
            pszRet = NULL;
            }
        }
    else
        {
        // Bad parameter
        pszRet = NULL;
        }

    return pszRet;      // free with LocalFree()
    }


/*----------------------------------------------------------
Purpose: Constructs a formatted string.  The returned string 
         must be freed using GFree().

Returns: TRUE on success

Cond:    Free pointer with GFree()
*/
BOOL PUBLIC ConstructMessage(
    LPSTR * ppsz,
    HINSTANCE hinst, 
    LPCSTR pszMsg, ...)
    {
    BOOL bRet;
    LPSTR pszRet;
    va_list ArgList;

    va_start(ArgList, pszMsg);

    pszRet = ConstructVMessageString(hinst, pszMsg, &ArgList);

    va_end(ArgList);

    *ppsz = NULL;

    if (pszRet)
        {
        bRet = GSetString(ppsz, pszRet);
        LocalFree(pszRet);
        }
    else
        bRet = FALSE;

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Invoke a message box.

Returns: ID of button that terminated the dialog
Cond:    --
*/
int PUBLIC MsgBox(
    HINSTANCE hinst,
    HWND hwndOwner,
    LPCSTR pszText,
    LPCSTR pszCaption,
    HICON hicon,            // May be NULL
    DWORD dwStyle, ...)
    {
    int iRet = -1;
    int ids;
    char szCaption[MAX_BUF];
    LPSTR pszRet;
    va_list ArgList;

    va_start(ArgList, dwStyle);
    
    pszRet = ConstructVMessageString(hinst, pszText, &ArgList);

    va_end(ArgList);

    if (pszRet)
        {
        // Is pszCaption a resource ID?
        if (0 == HIWORD(pszCaption))
            {
            // Yes; load it
            ids = LOWORD(pszCaption);
            SzFromIDS(hinst, ids, szCaption, sizeof(szCaption));
            pszCaption = szCaption;
            }

        // Invoke dialog
        if (pszCaption)
            {
            MSGBOXPARAMS mbp;

            mbp.cbSize = sizeof(mbp);
            mbp.hwndOwner = hwndOwner;
            mbp.hInstance = hinst;
            mbp.lpszText = pszRet;
            mbp.lpszCaption = pszCaption;
            mbp.dwStyle = dwStyle | MB_SETFOREGROUND;
            mbp.lpszIcon = MAKEINTRESOURCE(hicon);
            mbp.lpfnMsgBoxCallback = NULL;
            mbp.dwLanguageId = LANG_NEUTRAL;

            iRet = MessageBoxIndirect(&mbp);
            }
        LocalFree(pszRet);
        }

    return iRet;
    }

#endif // NOMESSAGESTRING


#ifndef NODEBUGHELP

#ifdef DEBUG

// Globals
DWORD g_dwBreakFlags = 0;
DWORD g_dwDumpFlags = 0;
DWORD g_dwTraceFlags = 0;


#pragma data_seg(DATASEG_READONLY)

char const FAR c_szNewline[] = "\r\n";
char const FAR c_szTrace[] = "t " SZ_MODULE "  ";
char const FAR c_szDbg[] = SZ_MODULE "  ";
char const FAR c_szAssertFailed[] = SZ_MODULE "  Assertion failed in %s on line %d\r\n";

#ifdef WANT_OLE_SUPPORT
struct _RIIDMAP
    {
    REFIID  riid;
    LPCSTR  psz;
    } const c_rgriidmap[] = {
        { &IID_IUnknown,        "IID_IUnknown" },
        { &IID_IBriefcaseStg,   "IID_IBriefcaseStg" },
        { &IID_IEnumUnknown,    "IID_IEnumUnknown" },
        { &IID_IShellBrowser,   "IID_IShellBrowser" },
        { &IID_IShellView,      "IID_IShellView" },
        { &IID_IContextMenu,    "IID_IContextMenu" },
        { &IID_IShellFolder,    "IID_IShellFolder" },
        { &IID_IShellExtInit,   "IID_IShellExtInit" },
        { &IID_IShellPropSheetExt, "IID_IShellPropSheetExt" },
        { &IID_IPersistFolder,  "IID_IPersistFolder" },
        { &IID_IExtractIcon,    "IID_IExtractIcon" },
        { &IID_IShellDetails,   "IID_IShellDetails" },
        { &IID_IDelayedRelease, "IID_IDelayedRelease" },
        { &IID_IShellLink,      "IID_IShellLink" },
        };
#endif // WANT_OLE_SUPPORT

struct _SCODEMAP
    {
    SCODE  sc;
    LPCSTR psz;
    } const c_rgscodemap[] = {
        { S_OK,             "S_OK" },
        { S_FALSE,          "S_FALSE" },
        { E_UNEXPECTED,     "E_UNEXPECTED" },
        { E_NOTIMPL,        "E_NOTIMPL" },
        { E_OUTOFMEMORY,    "E_OUTOFMEMORY" },
        { E_INVALIDARG,     "E_INVALIDARG" },
        { E_NOINTERFACE,    "E_NOINTERFACE" },
        { E_POINTER,        "E_POINTER" },
        { E_HANDLE,         "E_HANDLE" },
        { E_ABORT,          "E_ABORT" },
        { E_FAIL,           "E_FAIL" },
        { E_ACCESSDENIED,   "E_ACCESSDENIED" },
        };

#pragma data_seg()

/*----------------------------------------------------------
Purpose: Return English reason for the debug break
Returns: String
Cond:    --
*/
LPCSTR PRIVATE GetReasonString(
    DWORD flag)      // One of BF_ flags
    {
    LPCSTR psz;

    if (IsFlagSet(flag, BF_ONOPEN))
        psz = "BREAK ON OPEN\r\n";

    else if (IsFlagSet(flag, BF_ONCLOSE))
        psz = "BREAK ON CLOSE\r\n";

    else if (IsFlagSet(flag, BF_ONVALIDATE))
        psz = "BREAK ON VALIDATION FAILURE\r\n";

    else if (IsFlagSet(flag, BF_ONTHREADATT))
        psz = "BREAK ON THREAD ATTACH\r\n";

    else if (IsFlagSet(flag, BF_ONTHREADDET))
        psz = "BREAK ON THREAD DETACH\r\n";

    else if (IsFlagSet(flag, BF_ONPROCESSATT))
        psz = "BREAK ON PROCESS ATTACH\r\n";

    else if (IsFlagSet(flag, BF_ONPROCESSDET))
        psz = "BREAK ON PROCESS DETACH\r\n";

    else
        psz = c_szNewline;

    return psz;
    }


/*----------------------------------------------------------
Purpose: Perform a debug break based on the flag
Returns: --
Cond:    --
*/
void PUBLIC CommonDebugBreak(
    DWORD flag)      // One of BF_ flags
    {
    if (IsFlagSet(g_dwBreakFlags, flag))
        {
        TRACE_MSG(TF_ALWAYS, GetReasonString(flag));
        DebugBreak();
        }
    }


/*----------------------------------------------------------
Purpose: Assert failed
Returns: --
Cond:    --
*/
void PUBLIC CommonAssertFailed(
    LPCSTR pszFile, 
    int line)
    {
    LPCSTR psz;
    char ach[256];

    // Strip off path info from filename string, if present.
    //
    for (psz = pszFile + lstrlen(pszFile); psz != pszFile; psz=AnsiPrev(pszFile, psz))
        {
#ifdef  DBCS
        if ((AnsiPrev(pszFile, psz) != (psz-2)) && *(psz - 1) == '\\')
#else
        if (*(psz - 1) == '\\')
#endif
            break;
        }
    wsprintf(ach, c_szAssertFailed, psz, line);
    OutputDebugString(ach);
    
    if (IsFlagSet(g_dwBreakFlags, BF_ONVALIDATE))
        DebugBreak();
    }


/*----------------------------------------------------------
Purpose: Assert failed message only
Returns: --
Cond:    --
*/
void CPUBLIC CommonAssertMsg(
    BOOL f, 
    LPCSTR pszMsg, ...)
    {
    char ach[MAX_PATH+40];    // Largest path plus extra

    if (!f)
        {
        lstrcpy(ach, c_szTrace);
        wvsprintf(&ach[sizeof(c_szTrace)-1], pszMsg, (va_list)(&pszMsg + 1));
        OutputDebugString(ach);
        OutputDebugString(c_szNewline);
        }
    }


/*----------------------------------------------------------
Purpose: Debug spew
Returns: --
Cond:    --
*/
void CPUBLIC CommonDebugMsg(
    DWORD flag,
    LPCSTR pszMsg, ...)
    {
    char ach[MAX_PATH+40];    // Largest path plus extra

    if (TF_ALWAYS == flag || IsFlagSet(g_dwTraceFlags, flag))
        {
        lstrcpy(ach, c_szTrace);
        wvsprintf(&ach[sizeof(c_szTrace)-1], pszMsg, (va_list)(&pszMsg + 1));
        OutputDebugString(ach);
        OutputDebugString(c_szNewline);
        }
    }


#ifdef WANT_OLE_SUPPORT
/*----------------------------------------------------------
Purpose: Returns the string form of an known interface ID.

Returns: String ptr
Cond:    --
*/
LPCSTR PUBLIC Dbg_GetRiidName(
    REFIID riid)
    {
    int i;

    for (i = 0; i < ARRAY_ELEMENTS(c_rgriidmap); i++)
        {
        if (IsEqualIID(riid, c_rgriidmap[i].riid))
            return c_rgriidmap[i].psz;
        }
    return "Unknown riid";
    }
#endif


/*----------------------------------------------------------
Purpose: Returns the string form of an scode given an hresult.

Returns: String ptr
Cond:    --
*/
LPCSTR PUBLIC Dbg_GetScode(
    HRESULT hres)
    {
    int i;
    SCODE sc;

    sc = GetScode(hres);
    for (i = 0; i < ARRAY_ELEMENTS(c_rgscodemap); i++)
        {
        if (sc == c_rgscodemap[i].sc)
            return c_rgscodemap[i].psz;
        }
    return "Unknown scode";
    }


/*----------------------------------------------------------
Purpose: Returns a string safe enough to print...and I don't
         mean swear words.

Returns: String ptr
Cond:    --
*/
LPCSTR PUBLIC Dbg_SafeStr(
    LPCSTR psz)
    {
    if (psz)
        return psz;
    else
        return "NULL";
    }

#endif // DEBUG

#endif // NODEBUGHELP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasscrpt\ast.c ===
//
// Copyright (c) Microsoft Corporation 1995
//
// ast.c
//
// This file contains the abstract syntax tree functions.
//
// History:
//  05-20-95 ScottH     Created
//


#include "proj.h"
#include "rcids.h"

#define RetInt(ppv, x)      (*((LPINT)*(ppv)) = (x))
#define RetStr(ppv, x)      (*((LPSTR)*(ppv)) = (x))
#define RetBool(ppv, x)     (*((LPBOOL)*(ppv)) = (x))


// 
// Wait case functions
//


#ifdef DEBUG

/*----------------------------------------------------------
Purpose: Dump a waitcase structure

Returns: --
Cond:    --
*/
void PRIVATE Waitcase_Dump(
    PWAITCASE this)
    {
    Ast_Dump((PAST)this->pexpr);
    if (this->pszIdent)
        {
        TRACE_MSG(TF_ALWAYS, "      then %s", this->pszIdent);
        }
    }

#endif

/*----------------------------------------------------------
Purpose: Create a wait-case list.

Returns: RES_OK
         RES_E_OUTOFMEMORY

Cond:    --
*/
RES PUBLIC Waitcase_Create(
    PHSA phsa)
    {
    RES res = RES_OK;

    if ( !SACreate(phsa, sizeof(WAITCASE), 8) )
        res = RES_E_OUTOFMEMORY;

    return res;
    }


/*----------------------------------------------------------
Purpose: Add a case to the given wait-case list.

Returns: RES_OK

Cond:    --
*/
RES PUBLIC Waitcase_Add(
    HSA hsa,
    PEXPR pexpr,
    LPCSTR pszIdent,        // This may be NULL
    DWORD dwFlags)
    {
    RES res = RES_OK;       // assume success
    WAITCASE wc;

    ASSERT(hsa);
    ASSERT(pexpr);

    wc.pexpr = pexpr;
    wc.dwFlags = dwFlags;
    wc.pszIdent = NULL;

    // Copy pszIdent since the parameter is freed by the caller.
    if ( pszIdent && !GSetString(&wc.pszIdent, pszIdent) )
        res = RES_E_OUTOFMEMORY;

    else if ( !SAInsertItem(hsa, SA_APPEND, &wc) )
        res = RES_E_OUTOFMEMORY;

    return res;
    }


/*----------------------------------------------------------
Purpose: Free the contents of the given pointer.

Returns: --

Cond:    Don't free the pointer itself!
*/
void CALLBACK Waitcase_FreeSA(
    PVOID pv,
    LPARAM lparam)
    {
    PWAITCASE pwc = (PWAITCASE)pv;

    if (pwc->pexpr)
        Expr_Delete(pwc->pexpr);

    if (pwc->pszIdent)
        GSetString(&pwc->pszIdent, NULL);       // free
    }


/*----------------------------------------------------------
Purpose: Destroy the wait case list.

Returns: RES_OK

Cond:    --
*/
RES PUBLIC Waitcase_Destroy(
    HSA hsa)
    {
    ASSERT(hsa);

    SADestroyEx(hsa, Waitcase_FreeSA, 0);
    return RES_OK;
    }


//
// Base level AST functions
//


#ifdef DEBUG

/*----------------------------------------------------------
Purpose: Dump the AST
Returns: --
Cond:    --
*/
void PUBLIC Ast_Dump(
    PAST this)
    {
    ASSERT(this);

    if (IsFlagSet(g_dwDumpFlags, DF_AST))
        {
        switch (this->asttype)
            {
        case AT_BASE:
            TRACE_MSG(TF_ALWAYS, "Unknown AST");
            break;

        case AT_MODULE_DECL: {
            PMODULEDECL pmd = (PMODULEDECL)this;
            DWORD i;
            DWORD cprocs = PAGetCount(pmd->hpaProcs);

            TRACE_MSG(TF_ALWAYS, "module");

            for (i = 0; i < cprocs; i++)
                Ast_Dump(PAFastGetPtr(pmd->hpaProcs, i));
            }
            break;

        case AT_PROC_DECL: {
            PPROCDECL ppd = (PPROCDECL)this;
            DWORD i;
            DWORD cstmts = PAGetCount(ppd->hpaStmts);

            TRACE_MSG(TF_ALWAYS, "proc %s", ProcDecl_GetIdent(ppd));

            for (i = 0; i < cstmts; i++)
                Ast_Dump(PAFastGetPtr(ppd->hpaStmts, i));

            TRACE_MSG(TF_ALWAYS, "endproc");
            }
            break;

        case AT_ENTER_STMT:
            TRACE_MSG(TF_ALWAYS, "enter");
            break;

        case AT_LEAVE_STMT:
            TRACE_MSG(TF_ALWAYS, "leave");
            break;

        case AT_HALT_STMT:
            TRACE_MSG(TF_ALWAYS, "halt");
            break;

        case AT_ASSIGN_STMT:
            TRACE_MSG(TF_ALWAYS, "%s = ", AssignStmt_GetIdent(this));
            Ast_Dump((PAST)AssignStmt_GetExpr(this));
            break;

        case AT_LABEL_STMT:
            TRACE_MSG(TF_ALWAYS, "%s:", LabelStmt_GetIdent(this));
            break;

        case AT_GOTO_STMT:
            TRACE_MSG(TF_ALWAYS, "goto %s", GotoStmt_GetIdent(this));
            break;

        case AT_WHILE_STMT:
            TRACE_MSG(TF_ALWAYS, "while ");
            TRACE_MSG(TF_ALWAYS, "  do ");
            TRACE_MSG(TF_ALWAYS, "endwhile ");
            break;

        case AT_IF_STMT:
            TRACE_MSG(TF_ALWAYS, "if ");
            TRACE_MSG(TF_ALWAYS, "  then ");
            TRACE_MSG(TF_ALWAYS, "endif ");
            break;

        case AT_DELAY_STMT:
            TRACE_MSG(TF_ALWAYS, "delay");
            Ast_Dump((PAST)DelayStmt_GetExpr(this));
            break;

        case AT_WAITFOR_STMT: {
            PWAITFORSTMT pws = (PWAITFORSTMT)this;
            DWORD ccase = SAGetCount(pws->hsa);
            DWORD i;

            TRACE_MSG(TF_ALWAYS, "waitfor");

            for (i = 0; i < ccase; i++)
                {
                PVOID pv;
                SAGetItemPtr(pws->hsa, i, &pv);
                Waitcase_Dump(pv);
                }

            if (WaitforStmt_GetUntilExpr(this))
                {
                TRACE_MSG(TF_ALWAYS, "until");
                Ast_Dump((PAST)WaitforStmt_GetUntilExpr(this));
                }
            }
            break;

        case AT_TRANSMIT_STMT:
            TRACE_MSG(TF_ALWAYS, "transmit");
            Ast_Dump((PAST)TransmitStmt_GetExpr(this));
            break;

        case AT_SET_STMT:
            switch (SetStmt_GetType(this))
                {
            case ST_IPADDR:
                TRACE_MSG(TF_ALWAYS, "set ipaddr getip");
                Ast_Dump((PAST)SetIPStmt_GetExpr(this));
                break;

            case ST_PORT:
                if (IsFlagSet(SetPortStmt_GetFlags(this), SPF_DATABITS))
                    TRACE_MSG(TF_ALWAYS, "set port databits %u", SetPortStmt_GetDatabits(this));

                if (IsFlagSet(SetPortStmt_GetFlags(this), SPF_STOPBITS))
                    TRACE_MSG(TF_ALWAYS, "set port stopbits %u", SetPortStmt_GetStopbits(this));

                if (IsFlagSet(SetPortStmt_GetFlags(this), SPF_PARITY))
                    TRACE_MSG(TF_ALWAYS, "set port parity %u", SetPortStmt_GetParity(this));
                break;

            case ST_SCREEN:
                if (IsFlagSet(SetScreenStmt_GetFlags(this), SPF_KEYBRD))
                    TRACE_MSG(TF_ALWAYS, "set screen keyboard %s", SetScreenStmt_GetKeybrd(this) ? "on" : "off");
                break;

            default:
                ASSERT(0);
                break;
                }
            break;

        case AT_INT_EXPR:
            TRACE_MSG(TF_ALWAYS, "  %d", IntExpr_GetVal(this));
            break;

        case AT_STRING_EXPR:
            TRACE_MSG(TF_ALWAYS, "  %s", StrExpr_GetStr(this));
            break;

        case AT_BOOL_EXPR:
            TRACE_MSG(TF_ALWAYS, "  %s", BoolExpr_GetVal(this) ? (LPSTR)"TRUE" : (LPSTR)"FALSE");
            break;

        case AT_VAR_EXPR:
            TRACE_MSG(TF_ALWAYS, "  %s", VarExpr_GetIdent(this));
            break;

        case AT_BINOP_EXPR: {
            PBINOPEXPR pbo = (PBINOPEXPR)this;

            Ast_Dump((PAST)pbo->pexpr1);

            switch (BinOpExpr_GetType(this))
                {
            case BOT_OR:
                TRACE_MSG(TF_ALWAYS, "    or");
                break;

            case BOT_AND:
                TRACE_MSG(TF_ALWAYS, "    and");
                break;

            case BOT_LT:
                TRACE_MSG(TF_ALWAYS, "    <");
                break;

            case BOT_LEQ:
                TRACE_MSG(TF_ALWAYS, "    <=");
                break;

            case BOT_GT:
                TRACE_MSG(TF_ALWAYS, "    >");
                break;

            case BOT_GEQ:
                TRACE_MSG(TF_ALWAYS, "    >=");
                break;

            case BOT_EQ:
                TRACE_MSG(TF_ALWAYS, "    ==");
                break;

            case BOT_NEQ:
                TRACE_MSG(TF_ALWAYS, "    !=");
                break;

            case BOT_PLUS:
                TRACE_MSG(TF_ALWAYS, "    +");
                break;

            case BOT_MINUS:
                TRACE_MSG(TF_ALWAYS, "    -");
                break;

            case BOT_MULT:
                TRACE_MSG(TF_ALWAYS, "    *");
                break;

            case BOT_DIV:
                TRACE_MSG(TF_ALWAYS, "    /");
                break;

            default:
                ASSERT(0);
                break;
                }

            Ast_Dump((PAST)pbo->pexpr2);
            }
            break;

        case AT_UNOP_EXPR: {
            PUNOPEXPR puo = (PUNOPEXPR)this;

            switch (UnOpExpr_GetType(this))
                {
            case UOT_NEG:
                TRACE_MSG(TF_ALWAYS, "  -");
                break;

            case UOT_NOT:
                TRACE_MSG(TF_ALWAYS, "  !");
                break;

            case UOT_GETIP:
                TRACE_MSG(TF_ALWAYS, "  getip");
                break;

            default:
                ASSERT(0);
                break;
                }

            Ast_Dump((PAST)puo->pexpr);
            }
            break;

        default:
            ASSERT(0);
            break;
            }
        }
    }

#endif // DEBUG


/*----------------------------------------------------------
Purpose: Creates a new AST 

Returns: RES_OK

         RES_E_OUTOFMEMORY

Cond:    --
*/
RES PUBLIC Ast_New(
    LPVOID * ppv,
    ASTTYPE asttype,
    DWORD cbSize,
    DWORD iLine)
    {
    PAST past;

    ASSERT(ppv);

    past = GAlloc(cbSize);
    if (past)
        {
        Ast_SetSize(past, cbSize);
        Ast_SetType(past, asttype);
        Ast_SetLine(past, iLine);
        }
    *ppv = past;

    return NULL != past ? RES_OK : RES_E_OUTOFMEMORY;
    }


/*----------------------------------------------------------
Purpose: Destroys the given AST.
Returns: 
Cond:    --
*/
void PUBLIC Ast_Delete(
    PAST this)
    {
    GFree(this);
    }


/*----------------------------------------------------------
Purpose: Duplicate the given AST.

Returns: RES_OK

         RES_E_OUTOFMEMORY

Cond:    --
*/
RES PUBLIC Ast_Dup(
    PAST this,
    PAST * ppast)
    {
    PAST past;
    DWORD cbSize;

    ASSERT(this);
    ASSERT(ppast);

    cbSize = Ast_GetSize(this);

    past = GAlloc(cbSize);
    if (past)
        {
        BltByte(past, this, cbSize);
        }
    *ppast = past;

    return NULL != past ? RES_OK : RES_E_OUTOFMEMORY;
    }


// 
// Expressions
//

/*----------------------------------------------------------
Purpose: Callback for PADestroyEx.

Returns: --
Cond:    --
*/
void CALLBACK Expr_DeletePAPtr(
    LPVOID pv,
    LPARAM lparam)
    {
    Expr_Delete(pv);
    }              


/*----------------------------------------------------------
Purpose: Destroys an Expr.

Returns: RES_OK

         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC Expr_Delete(
    PEXPR this)
    {
    RES res;

    DBG_ENTER(Expr_Delete);

    if (this)
        {
        res = RES_OK;

        switch (this->ast.asttype)
            {
        case AT_INT_EXPR:
        case AT_BOOL_EXPR:
            // (Nothing to free inside)
            break;

        case AT_STRING_EXPR: {
            PSTREXPR ps = (PSTREXPR)this;

            if (ps->psz)
                GSetString(&ps->psz, NULL);     // free
            }
            break;

        case AT_VAR_EXPR: {
            PVAREXPR ps = (PVAREXPR)this;

            if (ps->pszIdent)
                GSetString(&ps->pszIdent, NULL);     // free
            }
            break;

        case AT_BINOP_EXPR: {
            PBINOPEXPR pbo = (PBINOPEXPR)this;

            if (pbo->pexpr1)
                Expr_Delete(pbo->pexpr1);

            if (pbo->pexpr2)
                Expr_Delete(pbo->pexpr2);

            }
            break;

        case AT_UNOP_EXPR: {
            PUNOPEXPR puo = (PUNOPEXPR)this;

            if (puo->pexpr)
                Expr_Delete(puo->pexpr);
            }
            break;

        default:
            ASSERT(0);
            res = RES_E_INVALIDPARAM;
            break;
            }

        if (RSUCCEEDED(res))
            {
            // Most of the time when the evaluated result 
            // is a string, it is just a copy of the pointer
            // in the specific class structure.  In these
            // cases it does not need to be freed again,
            // because it was freed above.

            if (this->er.psz && IsFlagSet(this->dwFlags, EF_ALLOCATED))
                {
                ASSERT(DATA_STRING == Expr_GetDataType(this));

                GSetString(&this->er.psz, NULL);    // free
                }

            Ast_Delete((PAST)this);
            }
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(Expr_Delete, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates a IntExpr object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC IntExpr_New(
    PEXPR * ppexpr,
    int nVal,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(IntExpr_New);

    ASSERT(ppexpr);

    if (ppexpr)
        {
        PINTEXPR this;

        res = Ast_New(&this, AT_INT_EXPR, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            IntExpr_SetVal(this, nVal);
            }

        *ppexpr = (PEXPR)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(IntExpr_New, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates a StrExpr object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC StrExpr_New(
    PEXPR * ppexpr,
    LPCSTR psz,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(StrExpr_New);

    ASSERT(ppexpr);
    ASSERT(psz);

    if (ppexpr)
        {
        PSTREXPR this;

        res = Ast_New(&this, AT_STRING_EXPR, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            res = RES_OK;

            if (!GSetString(&this->psz, psz))
                res = RES_E_OUTOFMEMORY;

            if (RFAILED(res))
                {
                Ast_Delete((PAST)this);
                this = NULL;
                }
            }

        *ppexpr = (PEXPR)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(StrExpr_New, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates a BoolExpr object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC BoolExpr_New(
    PEXPR * ppexpr,
    BOOL bVal,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(BoolExpr_New);

    ASSERT(ppexpr);

    if (ppexpr)
        {
        PBOOLEXPR this;

        res = Ast_New(&this, AT_BOOL_EXPR, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            BoolExpr_SetVal(this, bVal);
            }

        *ppexpr = (PEXPR)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(BoolExpr_New, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates a VarExpr object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC VarExpr_New(
    PEXPR * ppexpr,
    LPCSTR pszIdent,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(VarExpr_New);

    ASSERT(ppexpr);
    ASSERT(pszIdent);

    if (ppexpr)
        {
        PVAREXPR this;

        res = Ast_New(&this, AT_VAR_EXPR, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            res = RES_OK;

            if (!GSetString(&this->pszIdent, pszIdent))
                res = RES_E_OUTOFMEMORY;

            if (RFAILED(res))
                {
                Ast_Delete((PAST)this);
                this = NULL;
                }
            }

        *ppexpr = (PEXPR)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(VarExpr_New, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates a BinOpExpr object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC BinOpExpr_New(
    PEXPR * ppexpr,
    BINOPTYPE binoptype,
    PEXPR pexpr1,
    PEXPR pexpr2,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(BinOpExpr_New);

    ASSERT(ppexpr);
    ASSERT(pexpr1);
    ASSERT(pexpr2);

    if (ppexpr)
        {
        PBINOPEXPR this;

        res = Ast_New(&this, AT_BINOP_EXPR, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            res = RES_OK;

            BinOpExpr_SetType(this, binoptype);

            this->pexpr1 = pexpr1;
            this->pexpr2 = pexpr2;
            }

        *ppexpr = (PEXPR)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(BinOpExpr_New, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates a UnOpExpr object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC UnOpExpr_New(
    PEXPR * ppexpr,
    UNOPTYPE unoptype,
    PEXPR pexpr,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(UnOpExpr_New);

    ASSERT(ppexpr);
    ASSERT(pexpr);

    if (ppexpr)
        {
        PUNOPEXPR this;

        res = Ast_New(&this, AT_UNOP_EXPR, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            UnOpExpr_SetType(this, unoptype);

            this->pexpr = pexpr;
            }

        *ppexpr = (PEXPR)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(UnOpExpr_New, res);

    return res;
    }


// 
// Stmt
//

/*----------------------------------------------------------
Purpose: Callback for PADestroyEx.

Returns: --
Cond:    --
*/
void CALLBACK Stmt_DeletePAPtr(
    LPVOID pv,
    LPARAM lparam)
    {
    Stmt_Delete(pv);
    }              


/*----------------------------------------------------------
Purpose: Destroys a Stmt.

Returns: RES_OK

         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC Stmt_Delete(
    PSTMT this)
    {
    RES res;

    DBG_ENTER(Stmt_Delete);

    if (this)
        {
        PEXPR pexpr;
        HSA hsa;

        res = RES_OK;

        switch (this->ast.asttype)
            {
        case AT_ENTER_STMT:
            // (don't free pst -- it belongs to the decl structs)
        case AT_LEAVE_STMT:
        case AT_HALT_STMT:
            break;

        case AT_ASSIGN_STMT: {
            PASSIGNSTMT pls = (PASSIGNSTMT)this;

            if (pls->pszIdent)
                GSetString(&pls->pszIdent, NULL);        // free

            pexpr = AssignStmt_GetExpr(this);

            if (pexpr)
                Expr_Delete(pexpr);
            }
            break;

        case AT_WHILE_STMT: {
            PWHILESTMT pls = (PWHILESTMT)this;

            pexpr = WhileStmt_GetExpr(this);

            if (pexpr)
                Expr_Delete(pexpr);

            if (pls->hpaStmts)
                PADestroyEx(pls->hpaStmts, Stmt_DeletePAPtr, 0);
            }
            break;

        case AT_IF_STMT: {
            PIFSTMT pls = (PIFSTMT)this;

            pexpr = IfStmt_GetExpr(this);

            if (pexpr)
                Expr_Delete(pexpr);

            if (pls->hpaStmts)
                PADestroyEx(pls->hpaStmts, Stmt_DeletePAPtr, 0);
            }
            break;

        case AT_LABEL_STMT: {
            PLABELSTMT pls = (PLABELSTMT)this;

            if (pls->psz)
                GSetString(&pls->psz, NULL);        // free
            }
            break;

        case AT_GOTO_STMT: {
            PGOTOSTMT pgs = (PGOTOSTMT)this;

            if (pgs->psz)
                GSetString(&pgs->psz, NULL);        // free
            }
            break;

        case AT_DELAY_STMT:
            pexpr = DelayStmt_GetExpr(this);

            if (pexpr)
                Expr_Delete(pexpr);
            break;

        case AT_TRANSMIT_STMT:
            pexpr = TransmitStmt_GetExpr(this);

            if (pexpr)
                Expr_Delete(pexpr);
            break;

        case AT_WAITFOR_STMT:
            
            hsa = WaitforStmt_GetCaseList(this);
            if (hsa)
                Waitcase_Destroy(hsa);

            pexpr = WaitforStmt_GetUntilExpr(this);
            if (pexpr)
                Expr_Delete(pexpr);
            break;

        case AT_SET_STMT:
            switch (SetStmt_GetType(this))
                {
            case ST_IPADDR:
                pexpr = SetIPStmt_GetExpr(this);

                if (pexpr)
                    Expr_Delete(pexpr);
                break;

            case ST_PORT:
            case ST_SCREEN:
                break;

            default:
                ASSERT(0);
                res = RES_E_INVALIDPARAM;
                break;
                }
            break;

        default:
            ASSERT(0);
            res = RES_E_INVALIDPARAM;
            break;
            }

        if (RSUCCEEDED(res))
            Ast_Delete((PAST)this);
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(Stmt_Delete, res);

    return res;
    }


// 
// Statements
//


/*----------------------------------------------------------
Purpose: Creates a WaitforStmt object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC WaitforStmt_New(
    PSTMT * ppstmt,
    HSA hsa,
    PEXPR pexprUntil,           // May be NULL
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(WaitforStmt_New);

    ASSERT(ppstmt);
    ASSERT(hsa);

    if (ppstmt)
        {
        PWAITFORSTMT this;

        res = Ast_New(&this, AT_WAITFOR_STMT, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            res = RES_OK;           // assume success

            this->hsa = hsa;
            this->pexprUntil = pexprUntil;
            }

        *ppstmt = (PSTMT)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(WaitforStmt_New, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates a TransmitStmt object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC TransmitStmt_New(
    PSTMT * ppstmt,
    PEXPR pexpr,
    DWORD dwFlags,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(TransmitStmt_New);

    ASSERT(ppstmt);
    ASSERT(pexpr);

    if (ppstmt)
        {
        PTRANSMITSTMT this;

        res = Ast_New(&this, AT_TRANSMIT_STMT, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            res = RES_OK;           // assume success

            this->pexpr = pexpr;
            this->dwFlags = dwFlags;
            }

        *ppstmt = (PSTMT)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(TransmitStmt_New, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates a DelayStmt object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC DelayStmt_New(
    PSTMT * ppstmt,
    PEXPR pexpr,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(DelayStmt_New);

    ASSERT(ppstmt);
    ASSERT(pexpr);

    if (ppstmt)
        {
        PDELAYSTMT this;

        res = Ast_New(&this, AT_DELAY_STMT, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            this->pexprSecs = pexpr;

            res = RES_OK;
            }

        *ppstmt = (PSTMT)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(DelayStmt_New, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates a HaltStmt object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC HaltStmt_New(
    PSTMT * ppstmt,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(HaltStmt_New);

    ASSERT(ppstmt);

    if (ppstmt)
        {
        PHALTSTMT this;

        res = Ast_New(&this, AT_HALT_STMT, sizeof(*this), iLine);

        *ppstmt = (PSTMT)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(HaltStmt_New, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates an EnterStmt object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC EnterStmt_New(
    PSTMT * ppstmt,
    PSYMTAB pst,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(EnterStmt_New);

    ASSERT(ppstmt);

    if (ppstmt)
        {
        PENTERSTMT this;

        res = Ast_New(&this, AT_ENTER_STMT, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            this->pst = pst;
            }

        *ppstmt = (PSTMT)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(EnterStmt_New, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates an LeaveStmt object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC LeaveStmt_New(
    PSTMT * ppstmt,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(LeaveStmt_New);

    ASSERT(ppstmt);

    if (ppstmt)
        {
        PLEAVESTMT this;

        res = Ast_New(&this, AT_LEAVE_STMT, sizeof(*this), iLine);

        *ppstmt = (PSTMT)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(LeaveStmt_New, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates an AssignStmt object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC AssignStmt_New(
    PSTMT * ppstmt,
    LPCSTR pszIdent,
    PEXPR pexpr,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(AssignStmt_New);

    ASSERT(ppstmt);
    ASSERT(pszIdent);
    ASSERT(pexpr);

    if (ppstmt)
        {
        PASSIGNSTMT this;

        res = Ast_New(&this, AT_ASSIGN_STMT, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            res = RES_OK;   // assume success

            if (!GSetString(&this->pszIdent, pszIdent))
                res = RES_E_OUTOFMEMORY;
            else
                this->pexpr = pexpr;

            if (RFAILED(res))
                {
                Ast_Delete((PAST)this);
                this = NULL;
                }
            }

        *ppstmt = (PSTMT)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(AssignStmt_New, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates a LabelStmt object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC LabelStmt_New(
    PSTMT * ppstmt,
    LPCSTR psz,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(LabelStmt_New);

    ASSERT(ppstmt);
    ASSERT(psz);

    if (ppstmt)
        {
        PLABELSTMT this;

        res = Ast_New(&this, AT_LABEL_STMT, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            res = RES_OK;   // assume success

            if (!GSetString(&this->psz, psz))
                {
                res = RES_E_OUTOFMEMORY;
                Ast_Delete((PAST)this);
                this = NULL;
                }
            }

        *ppstmt = (PSTMT)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(LabelStmt_New, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates a GotoStmt object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC GotoStmt_New(
    PSTMT * ppstmt,
    LPCSTR psz,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(GotoStmt_New);

    ASSERT(ppstmt);
    ASSERT(psz);

    if (ppstmt)
        {
        PGOTOSTMT this;

        res = Ast_New(&this, AT_GOTO_STMT, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            res = RES_OK;   // assume success

            if (!GSetString(&this->psz, psz))
                {
                res = RES_E_OUTOFMEMORY;
                Ast_Delete((PAST)this);
                this = NULL;
                }
            }

        *ppstmt = (PSTMT)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(GotoStmt_New, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates a WhileStmt object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC WhileStmt_New(
    PSTMT * ppstmt,
    PEXPR pexpr,
    HPA hpa,
    LPCSTR pszTopLabel,
    LPCSTR pszEndLabel,
    DWORD iLine)
    {
    RES res;

    ASSERT(ppstmt);
    ASSERT(hpa);
    ASSERT(pexpr);
    ASSERT(pszTopLabel);
    ASSERT(pszEndLabel);

    if (ppstmt)
        {
        PWHILESTMT this;

        res = Ast_New(&this, AT_WHILE_STMT, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            res = RES_OK;           // assume success

            this->pexpr = pexpr;
            this->hpaStmts = hpa;
            lstrcpyn(this->szTopLabel, pszTopLabel, sizeof(this->szTopLabel));
            lstrcpyn(this->szEndLabel, pszEndLabel, sizeof(this->szEndLabel));
            }

        *ppstmt = (PSTMT)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates an IfStmt object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC IfStmt_New(
    PSTMT * ppstmt,
    PEXPR pexpr,
    HPA hpa,
    LPCSTR pszElseLabel,
    LPCSTR pszEndLabel,
    DWORD iLine)
    {
    RES res;

    ASSERT(ppstmt);
    ASSERT(hpa);
    ASSERT(pexpr);
    ASSERT(pszElseLabel);
    ASSERT(pszEndLabel);

    if (ppstmt)
        {
        PIFSTMT this;

        res = Ast_New(&this, AT_IF_STMT, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            res = RES_OK;           // assume success

            this->pexpr = pexpr;
            this->hpaStmts = hpa;
            lstrcpyn(this->szElseLabel, pszElseLabel, sizeof(this->szElseLabel));
            lstrcpyn(this->szEndLabel, pszEndLabel, sizeof(this->szEndLabel));
            }

        *ppstmt = (PSTMT)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates a SetStmt object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PRIVATE SetStmt_New(
    PVOID * ppv,
    SETTYPE settype,
    DWORD cbSize,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(SetStmt_New);

    ASSERT(ppv);
    ASSERT(sizeof(SETSTMT) <= cbSize);

    if (ppv)
        {
        PSETSTMT this;

        res = Ast_New(&this, AT_SET_STMT, cbSize, iLine);
        if (RSUCCEEDED(res))
            {
            SetStmt_SetType(this, settype);

            res = RES_OK;           
            }

        *ppv = this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(SetStmt_New, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates a SetIPStmt object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC SetIPStmt_New(
    PSTMT * ppstmt,
    PEXPR pexpr,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(SetIPStmt_New);

    ASSERT(ppstmt);
    ASSERT(pexpr);

    if (ppstmt)
        {
        PSETIPSTMT this;

        res = SetStmt_New(&this, ST_IPADDR, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            res = RES_OK;           // assume success

            this->pexpr = pexpr;
            }

        *ppstmt = (PSTMT)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(SetIPStmt_New, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates a SetPortStmt object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC SetPortStmt_New(
    PSTMT * ppstmt,
    PPORTSTATE pstate,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(SetPortStmt_New);

    ASSERT(ppstmt);
    ASSERT(pstate);

    if (ppstmt && pstate)
        {
        PSETPORTSTMT this;

        res = SetStmt_New(&this, ST_PORT, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            DWORD dwFlags = pstate->dwFlags;

            res = RES_OK;           // assume success

            this->portstate.dwFlags = dwFlags;

            if (IsFlagSet(dwFlags, SPF_DATABITS))
                this->portstate.nDatabits = pstate->nDatabits;

            if (IsFlagSet(dwFlags, SPF_STOPBITS))
                this->portstate.nStopbits = pstate->nStopbits;

            if (IsFlagSet(dwFlags, SPF_PARITY))
                this->portstate.nParity = pstate->nParity;
            }

        *ppstmt = (PSTMT)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(SetPortStmt_New, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Creates a SetScreenStmt object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC SetScreenStmt_New(
    PSTMT * ppstmt,
    PSCREENSET pstate,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(SetScreenStmt_New);

    ASSERT(ppstmt);
    ASSERT(pstate);

    if (ppstmt && pstate)
        {
        PSETSCREENSTMT this;

        res = SetStmt_New(&this, ST_SCREEN, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            DWORD dwFlags = pstate->dwFlags;

            res = RES_OK;           // assume success

            this->screenset.dwFlags = dwFlags;

            if (IsFlagSet(dwFlags, SPF_KEYBRD))
                this->screenset.fKBOn = pstate->fKBOn;
            }

        *ppstmt = (PSTMT)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(SetScreenStmt_New, res);

    return res;
    }


// 
// Decl
//


/*----------------------------------------------------------
Purpose: Callback for PADestroyEx.

Returns: --
Cond:    --
*/
void CALLBACK Decl_DeletePAPtr(
    LPVOID pv,
    LPARAM lparam)
    {
    Decl_Delete(pv);
    }              


/*----------------------------------------------------------
Purpose: Destroys a Decl.

Returns: RES_OK

         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC Decl_Delete(
    PDECL this)
    {
    RES res;

    DBG_ENTER(Decl_Delete);

    if (this)
        {
        res = RES_OK;

        switch (this->ast.asttype)
            {
        case AT_MODULE_DECL: {
            PMODULEDECL pmd = (PMODULEDECL)this;

            if (pmd->hpaProcs)
                PADestroyEx(pmd->hpaProcs, Decl_DeletePAPtr, 0);

            if (pmd->pst)
                Symtab_Destroy(pmd->pst);
            }
            break;

        case AT_PROC_DECL: {
            PPROCDECL ppd = (PPROCDECL)this;

            if (ppd->hpaStmts)
                PADestroyEx(ppd->hpaStmts, Stmt_DeletePAPtr, 0);

            if (ppd->pst)
                Symtab_Destroy(ppd->pst);

            if (ppd->pszIdent)
                GSetString(&ppd->pszIdent, NULL);      // free
            }
            break;

        default:
            ASSERT(0);
            res = RES_E_INVALIDPARAM;
            break;
            }

        if (RSUCCEEDED(res))
            Ast_Delete((PAST)this);
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(Decl_Delete, res);

    return res;
    }


// 
// ProcDecl
//


/*----------------------------------------------------------
Purpose: Creates a ProcDecl object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC ProcDecl_New(
    PDECL * ppdecl,
    LPCSTR pszIdent,
    HPA hpa,
    PSYMTAB pst,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(ProcDecl_New);

    ASSERT(ppdecl);
    ASSERT(hpa);
    ASSERT(pst);

    if (ppdecl)
        {
        PPROCDECL this;

        res = Ast_New(&this, AT_PROC_DECL, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            res = RES_OK;           // assume success

            if (!GSetString(&this->pszIdent, pszIdent))
                res = RES_E_OUTOFMEMORY;

            else
                {
                this->hpaStmts = hpa;
                this->pst = pst;
                }
        
            if (RFAILED(res))
                {
                Decl_Delete((PDECL)this);
                this = NULL;
                }
            }

        *ppdecl = (PDECL)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(ProcDecl_New, res);

    return res;
    }


// 
// ModuleDecl
//


/*----------------------------------------------------------
Purpose: Creates a ModuleDecl object.

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC ModuleDecl_New(
    PDECL * ppdecl,
    HPA hpa,
    PSYMTAB pst,
    DWORD iLine)
    {
    RES res;

    DBG_ENTER(ModuleDecl_New);

    ASSERT(ppdecl);
    ASSERT(hpa);
    ASSERT(pst);

    if (ppdecl)
        {
        PMODULEDECL this;

        res = Ast_New(&this, AT_MODULE_DECL, sizeof(*this), iLine);
        if (RSUCCEEDED(res))
            {
            res = RES_OK;       // assume success

            this->hpaProcs = NULL;
            if ( !PAClone(&this->hpaProcs, hpa) )
                res = RES_E_OUTOFMEMORY;

            else
                {
                this->pst = pst;
                }
                
            if (RFAILED(res))
                {
                Decl_Delete((PDECL)this);
                this = NULL;
                }
            }

        *ppdecl = (PDECL)this;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(ModuleDecl_New, res);

    return res;
    }


//
// AST Exec block
//

#define SZ_SUCCESS      "$SUCCESS"
#define SZ_FAILURE      "$FAILURE"


/*----------------------------------------------------------
Purpose: Initialize the AST exec block.

Returns: RES_OK

Cond:    --
*/
RES PUBLIC Astexec_Init(
    PASTEXEC this,
    HANDLE hport,
    PSESS_CONFIGURATION_INFO psci,
    HSA hsaStxerr)
    {
    RES res;

    ASSERT(this);
    ASSERT(psci);
    ASSERT(hsaStxerr);

    // For this first version, we only support one module and one
    // main procedure, so set the starting point on the first 
    // statement in that procedure.
    if (this)
        {
        ZeroInit(this, ASTEXEC);

        this->hport = hport;
        this->psci = psci;
        // Don't free hsaStxerr -- it belongs to the caller
        this->hsaStxerr = hsaStxerr;

        if ( !PACreate(&this->hpaPcode, 8) )
            res = RES_E_OUTOFMEMORY;
        else
            {
            res = Symtab_Create(&this->pstSystem, NULL);
            if (RSUCCEEDED(res))
                {
                // Add the system variables
                PSTE pste;
                struct 
                    {
                    LPCSTR pszIdent;
                    DATATYPE dt;
                    EVALRES er;
                    } s_rgvars[] = 
                        {
                        { "$USERID", DATA_STRING, psci->szUserName },
                        { "$PASSWORD", DATA_STRING, psci->szPassword },
                        { SZ_SUCCESS, DATA_BOOL, (LPSTR)TRUE },
                        { SZ_FAILURE, DATA_BOOL, (LPSTR)FALSE },
                        };
                int i;

                for (i = 0; i < ARRAY_ELEMENTS(s_rgvars); i++)
                    {
                    res = STE_Create(&pste, s_rgvars[i].pszIdent, s_rgvars[i].dt);
                    if (RFAILED(res))
                        break;

                    pste->er.dw = s_rgvars[i].er.dw;

                    res = Symtab_InsertEntry(this->pstSystem, pste);
                    if (RFAILED(res))
                        break;
                    }

                }
            }

        // Did something fail above?
        if (RFAILED(res))
            {
            // Yes; clean up
            Astexec_Destroy(this);
            }
        }
    else
        res = RES_E_INVALIDPARAM;

    return res;
    }


/*----------------------------------------------------------
Purpose: Destroys the AST exec block.

Returns: RES_OK

Cond:    --
*/
RES PUBLIC Astexec_Destroy(
    PASTEXEC this)
    {
    RES res;

    if (this)
        {
        if (this->hpaPcode)
            {
            PADestroy(this->hpaPcode);
            this->hpaPcode = NULL;
            }
    
        if (this->pstSystem)
            {
            Symtab_Destroy(this->pstSystem);
            this->pstSystem = NULL;
            }

        // ('this' was not allocated.  Do not free it.)
        // (hsaStxerr is not owned by this class.  Do not free it.)
                
        res = RES_OK;
        }
    else
        res = RES_E_INVALIDPARAM;

    return res;
    }


/*----------------------------------------------------------
Purpose: Sets the success/failure code

Returns: --
Cond:    --
*/
void PUBLIC Astexec_SetError(
    PASTEXEC this,
    BOOL bSuccess,              // TRUE: success
    BOOL bFailure)
    {
    PSTE pste;

    ASSERT(this);

    if (RES_OK == Symtab_FindEntry(this->pstSystem, SZ_SUCCESS, STFF_DEFAULT, &pste, NULL))
        {
        // Set the code for success
        pste->er.bVal = bSuccess;

        if (RES_OK == Symtab_FindEntry(this->pstSystem, SZ_FAILURE, STFF_DEFAULT, &pste, NULL))
            {
            // Set the code for failure
            pste->er.bVal = bFailure;
            }
        else
            ASSERT(0);
        }
    else
        ASSERT(0);
    }


/*----------------------------------------------------------
Purpose: Adds the statement to the executable list.

Returns: RES_OK
         RES_E_OUTOFMEMORY

Cond:    --
*/
RES PUBLIC Astexec_Add(
    PASTEXEC this,
    PSTMT pstmt)
    {
    RES res;

    ASSERT(this);
    ASSERT(pstmt);

    if (PAInsertPtr(this->hpaPcode, PA_APPEND, pstmt))
        res = RES_OK;
    else
        res = RES_E_OUTOFMEMORY;

    return res;
    }


/*----------------------------------------------------------
Purpose: Inserts a label into the executable list by recording
         the current ipaCur into the label entry in the 
         symbol table.

Returns: RES_OK

Cond:    --
*/
RES PUBLIC Astexec_InsertLabel(
    PASTEXEC this,
    LPCSTR pszIdent,
    PSYMTAB pst)
    {
    RES res;
    DWORD ipa;
    PSTE pste;

    ASSERT(this);
    ASSERT(pszIdent);
    ASSERT(pst);

    ipa = PAGetCount(this->hpaPcode);
    if (RES_OK == Symtab_FindEntry(pst, pszIdent, STFF_DEFAULT, &pste, NULL))
        {
        // Set the current code location in the symbol table
        pste->er.dw = ipa;
        res = RES_OK;
        }
    else
        {
        ASSERT(0);
        res = RES_E_FAIL;
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Jumps to the given label.

Returns: RES_OK
Cond:    --
*/
RES PUBLIC Astexec_JumpToLabel(
    PASTEXEC this,
    LPCSTR pszIdent)
    {
    RES res;
    PSTE pste;

    ASSERT(pszIdent);
    ASSERT(this);
    ASSERT(this->pstCur);

    if (RES_OK == Symtab_FindEntry(this->pstCur, pszIdent, STFF_DEFAULT, &pste, NULL))
        {
        EVALRES er;

        STE_GetValue(pste, &er);

        // Set instruction pointer
        Astexec_SetIP(this, (DWORD) er.dw);
        res = RES_OK;
        }
    else
        {
        // The label should have been in the symbol table!
        ASSERT(0);
        res = RES_E_FAIL;
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Sends psz to the port (via hwnd)

Returns: --
Cond:    --
*/
void PUBLIC Astexec_SendString(
    PASTEXEC this,
    LPCSTR pszSend,
    BOOL bRaw)          // TRUE: send unformatted
    {
    // Send string
    LPCSTR psz;
    char ch;
    HWND hwnd = this->hwnd;

    // Send unformatted?
    if (bRaw)
        {
        // Yes
        for (psz = pszSend; *psz; )
            {
            ch = *psz;

            psz++;

            SendByte(hwnd, ch);
            }
        }
    else
        {
        // No
        DWORD dwFlags = 0;

        for (psz = pszSend; *psz; )
            {
            psz = MyNextChar(psz, &ch, &dwFlags);

            SendByte(hwnd, ch);
            }
        }
    }


/*----------------------------------------------------------
Purpose: Destroy the find format handle

Returns: RES_OK

Cond:    --
*/
RES PUBLIC Astexec_DestroyFindFormat(
    PASTEXEC this)
    {
    // Reset the pending statement so we can handle multiple 
    // expressions that can pend in a single evaluation.
    Astexec_SetPending(this, NULL);

    DestroyFindFormat(this->hFindFmt);
    this->hFindFmt = NULL;

    return RES_OK;
    }


/*----------------------------------------------------------
Purpose: Make another pass at finding a string.

Returns: RES_OK (if string was found)
         RES_FALSE (if the string was not found yet)

Cond:    --
*/
RES PUBLIC Astexec_FindFormat(
    PASTEXEC this,
    LPDWORD piFound)
    {
    RES res;

    ASSERT(piFound);

    while (TRUE)
        {
        // Did we get the IP address?
        res = FindFormat(this->hwnd, this->hFindFmt, piFound);
        if (RES_OK == res)
            {
            // Yes
            this->nIter--;
            ASSERT(0 <= this->nIter);

            // Is this the right one?
            if (0 >= this->nIter)
                {
                // Yes; reset the pending statement so we
                // can handle multiple pending expressions
                // in a single evaluation.
                Astexec_DestroyFindFormat(this);
                break;
                }
            }
        else
            {
            // No; return read-pending RES_FALSE
            if (RES_E_MOREDATA == res)
                {
                TRACE_MSG(TF_GENERAL, "Buffer to FindFormat is too small");
                res = RES_OK;       // don't blow up
                }
            break;
            }
        }

    ASSERT(RSUCCEEDED(res));

    return res;
    }


/*----------------------------------------------------------
Purpose: Sets the IP address.

Returns: RES_OK
         RES_E_FAIL (if IP address cannot be set)

Cond:    --
*/
RES PUBLIC Astexec_SetIPAddr(
    PASTEXEC this,
    LPCSTR psz)
    {
    DWORD dwRet;

    ASSERT(this);
    ASSERT(psz);

    TRACE_MSG(TF_GENERAL, "Setting IP address to {%s}", psz);

#ifndef WINNT_RAS
//
// On NT, the IP address is set by calling RxSetIPAddress,
// which writes a new value to the phonebook if the connection uses SLIP.
//

    dwRet = TerminalSetIP(this->hwnd, psz);

#else // !WINNT_RAS

    dwRet = RxSetIPAddress(((SCRIPTDATA*)this->hwnd)->hscript, psz);

#endif // !WINNT_RAS
    return ERROR_SUCCESS == dwRet ? RES_OK : RES_E_FAIL;
    }


#define Astexec_Validate(this)      ((this)->hpaPcode && (this)->psci)

/*----------------------------------------------------------
Purpose: Returns the source line number of the current
         command that is executing.

Returns: see above
Cond:    --
*/
DWORD PUBLIC Astexec_GetCurLine(
    PASTEXEC this)
    {
    DWORD iLine;

    if (Astexec_Validate(this) &&
        (this->ipaCur < PAGetCount(this->hpaPcode)))
        {
        PSTMT pstmt = PAFastGetPtr(this->hpaPcode, this->ipaCur);
        iLine = Ast_GetLine(pstmt);
        }
    else
        iLine = 0;

    return iLine;
    }


/*----------------------------------------------------------
Purpose: Execute a statement and process the results.

Returns: RES_OK
         other error values

Cond:    --
*/
RES PRIVATE Astexec_ProcessStmt(
    PASTEXEC this,
    PSTMT pstmt)
    {
    RES res;

    ASSERT(this);
    ASSERT(pstmt);

    // (Re-)Execute the (possibly pending) statement
    res = Stmt_Exec(pstmt, this);

    // Set the pending statement based on the return value
    if (RES_OK == res)
        Astexec_SetPending(this, NULL);
    else if (RES_FALSE == res)
        {
        // (Re-set the current pending statement since
        // it could have been reset in Stmt_Exec.  For
        // example, the evaluation of an expression could 
        // have continued on to the next sub-expression
        // that caused another pending read.)

        Astexec_SetPending(this, pstmt);
        res = RES_OK;
        }
    else if (RFAILED(res))
        {
        Stxerr_ShowErrors(this->hsaStxerr, this->hwnd);

        // Halt script
        SetFlag(this->dwFlags, AEF_HALT);
        }
    
    return res;
    }


/*----------------------------------------------------------
Purpose: Executes the next command in the AST.

Returns: RES_OK
         RES_FALSE (if at end of script)
         RES_HALT (if at end of script)

         RES_E_FAIL (invalid command -- should never happen)
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC Astexec_Next(
    PASTEXEC this)
    {
    RES res;

    DBG_ENTER(Astexec_Next);

    if (this)
        {
        if (!Astexec_Validate(this))
            {
            // No script
            res = RES_E_FAIL;
            }
        else if (Astexec_IsDone(this) || Astexec_IsHalted(this))
            {
            res = RES_HALT;
            }
        else if (Astexec_IsReadPending(this))
            {
            PSTMT pstmt = Astexec_GetPending(this);

            // ("Read pending" and "Paused" are mutually exclusive)
            ASSERT( !Astexec_IsPaused(this) );

            res = Astexec_ProcessStmt(this, pstmt);
            }
        else if (Astexec_IsPaused(this))
            {
            // ("Read pending" and "Paused" are mutually exclusive)
            ASSERT( !Astexec_IsReadPending(this) );

            // Do nothing while we're paused
            res = RES_OK;
            }
        else if (this->ipaCur < PAGetCount(this->hpaPcode))
            {
            PSTMT pstmt = PAFastGetPtr(this->hpaPcode, this->ipaCur++);

            res = Astexec_ProcessStmt(this, pstmt);
            }
        else
            {
            // We reach here if there is an error in the script.
            TRACE_MSG(TF_ASTEXEC, "Exec: (reached end of script)");

            SetFlag(this->dwFlags, AEF_DONE);
            res = RES_HALT;
            }
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(Astexec_Next, res);

    return res;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasscrpt\mem.c ===
//
// Copyright (c) Microsoft Corporation 1993-1995
//
// mem.c
//
// This file contains memory management and dynamic 
// array functions.
//
// History:
//  09-27-94 ScottH     Taken from commctrl
//  04-29-95 ScottH     Taken from briefcase and cleaned up
//  


#include "proj.h"
#include "common.h"

#ifndef NOMEM

//////////////////////////////////////////////////////////////////

#ifndef WIN32
//
// Subsegment Allocation for 16-bit
//

#define MAX_WORD    0xffff

DECLARE_HANDLE(HHEAP);

typedef struct 
    {        //  maps to the bottom of a 16bit DS
    WORD reserved[8];
    WORD cAlloc;
    WORD cbAllocFailed;
    HHEAP hhpFirst;
    HHEAP hhpNext;
    } HEAP;

#define PHEAP(hhp)          ((HEAP FAR*)MAKELP(hhp, 0))
#define MAKEHP(sel, off)    ((void _huge*)MAKELP((sel), (off)))

#define CBSUBALLOCMAX   0x0000f000L

HHEAP g_hhpFirst = NULL;

BOOL NEAR DestroyHeap(HHEAP hhp);

void Mem_Terminate()
{
    while (g_hhpFirst)
        DestroyHeap(g_hhpFirst);
}

BOOL NEAR CreateHeap(WORD cbInitial)
{
    HHEAP hhp;

    if (cbInitial < 1024)
        cbInitial = 1024;

    hhp = (HHEAP)GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_SHARE, cbInitial);

    if (!hhp)
        return FALSE;

    if (!LocalInit((WORD)hhp, sizeof(HEAP), cbInitial - 1))
    {
        GlobalFree(hhp);
        return FALSE;
    }

    PHEAP(hhp)->cAlloc = 0;
    PHEAP(hhp)->cbAllocFailed = MAX_WORD;
    PHEAP(hhp)->hhpNext = g_hhpFirst;
    g_hhpFirst = hhp;

    DebugMsg(DM_TRACE, "CreateHeap: added new local heap %x", hhp);

    return TRUE;
}

#pragma optimize("o", off)		// linked list removals don't optimize correctly
BOOL NEAR DestroyHeap(HHEAP hhp)
{
    ASSERT(hhp);
    ASSERT(g_hhpFirst);

    if (g_hhpFirst == hhp)
    {
        g_hhpFirst = PHEAP(hhp)->hhpNext;
    }
    else
    {
        HHEAP hhpT = g_hhpFirst;

        while (PHEAP(hhpT)->hhpNext != hhp)
        {
            hhpT = PHEAP(hhpT)->hhpNext;
            if (!hhpT)
                return FALSE;
        }

        PHEAP(hhpT)->hhpNext = PHEAP(hhp)->hhpNext;
    }
    if (GlobalFree((HGLOBAL)hhp) != NULL)
        return FALSE;

    return TRUE;
}
#pragma optimize("", on)	// back to default optimizations

#pragma optimize("lge", off) // Suppress warnings associated with use of _asm...
void NEAR* NEAR HeapAlloc(HHEAP hhp, WORD cb)
{
    void NEAR* pb;

    _asm {
        push    ds
        mov     ds,hhp
    }

    pb = (void NEAR*)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cb);

    if (pb)
        ((HEAP NEAR*)0)->cAlloc++;

    _asm {
        pop     ds
    }

    return pb;
}
#pragma optimize("o", off)		// linked list removals don't optimize correctly

void _huge* WINAPI SharedAlloc(long cb)
{
    void NEAR* pb;
    HHEAP hhp;
    HHEAP hhpPrev;

    // If this is a big allocation, just do a global alloc.
    //
    if (cb > CBSUBALLOCMAX)
    {
        void FAR* lpb = MAKEHP(GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_SHARE, cb), 0);
        if (!lpb)
            DebugMsg(DM_ERROR, "Alloc: out of memory");
        return lpb;
    }

    hhp = g_hhpFirst;

    while (TRUE)
    {
        if (hhp == NULL)
        {
            if (!CreateHeap(0))
            {
                DebugMsg(DM_ERROR, "Alloc: out of memory");
                return NULL;
            }

            hhp = g_hhpFirst;
        }

        pb = HeapAlloc(hhp, (WORD)cb);
        if (pb)
            return MAKEHP(hhp, pb);

        // Record the size of the allocation that failed.
        // Later attempts to allocate more than this amount
        // will not succeed.  This gets reset anytime anything
        // is freed in the heap.
        //
        PHEAP(hhp)->cbAllocFailed = (WORD)cb;

        // First heap is full... see if there's room in any other heap...
        //
        for (hhpPrev = hhp; hhp = PHEAP(hhp)->hhpNext; hhpPrev = hhp)
        {
            // If the last allocation to fail in this heap
            // is not larger than cb, don't even try an allocation.
            //
            if ((WORD)cb >= PHEAP(hhp)->cbAllocFailed)
                continue;

            pb = HeapAlloc(hhp, (WORD)cb);
            if (pb)
            {
                // This heap had room: move it to the front...
                //
                PHEAP(hhpPrev)->hhpNext = PHEAP(hhp)->hhpNext;
                PHEAP(hhp)->hhpNext = g_hhpFirst;
                g_hhpFirst = hhp;

                return MAKEHP(hhp, pb);
            }
            else
            {
                // The alloc failed.  Set cbAllocFailed...
                //
                PHEAP(hhp)->cbAllocFailed = (WORD)cb;
            }
        }
    }
}
#pragma optimize("", on)	// back to default optimizations

#pragma optimize("lge", off) // Suppress warnings associated with use of _asm...

void _huge* WINAPI SharedReAlloc(void _huge* pb, long cb)
{
    void NEAR* pbNew;
    void _huge* lpbNew;
    UINT cbOld;

    // does not work with cb > 64k
    if (!pb)
        return SharedAlloc(cb);

    if (OFFSETOF(pb) == 0)
        return MAKEHP(GlobalReAlloc((HGLOBAL)SELECTOROF(pb), cb, GMEM_MOVEABLE | GMEM_ZEROINIT), 0);

    _asm {
        push    ds
        mov     ds,word ptr [pb+2]
    }

    pbNew = (void NEAR*)LocalReAlloc((HLOCAL)OFFSETOF(pb), (int)cb, LMEM_MOVEABLE | LMEM_ZEROINIT);
    if (!pbNew)
        cbOld = LocalSize((HLOCAL)OFFSETOF(pb));

    _asm {
        pop     ds
    }

    if (pbNew)
        return MAKEHP(SELECTOROF(pb), pbNew);

    lpbNew = SharedAlloc(cb);
    if (lpbNew)
    {
        hmemcpy((void FAR*)lpbNew, (void FAR*)pb, cbOld);
        Free(pb);
    }
    else
    {
        DebugMsg(DM_ERROR, "ReAlloc: out of memory");
    }
    return lpbNew;
}

BOOL WINAPI SharedFree(void _huge* FAR * ppb)
{
    BOOL fSuccess;
    UINT cAlloc;
    void _huge * pb = *ppb;

    if (!pb)
        return FALSE;

    *ppb = 0;

    if (OFFSETOF(pb) == 0)
        return (GlobalFree((HGLOBAL)SELECTOROF(pb)) == NULL);

    _asm {
        push    ds
        mov     ds,word ptr [pb+2]
    }

    fSuccess = (LocalFree((HLOCAL)OFFSETOF(pb)) ? FALSE : TRUE);

    cAlloc = 1;
    if (fSuccess)
    {
        cAlloc = --((HEAP NEAR*)0)->cAlloc;
        ((HEAP NEAR*)0)->cbAllocFailed = MAX_WORD;
    }

    _asm {
        pop     ds
    }

    if (cAlloc == 0)
        DestroyHeap((HHEAP)SELECTOROF(pb));

    return fSuccess;
}


DWORD WINAPI SharedGetSize(void _huge* pb)
{
    WORD wSize;

    if (OFFSETOF(pb) == 0)
        return GlobalSize((HGLOBAL)SELECTOROF(pb));

    _asm {
        push    ds
        mov     ds,word ptr [pb+2]
    }

    wSize = LocalSize((HLOCAL)OFFSETOF(pb));

    _asm {
        pop     ds
    }

    return (DWORD)wSize;
}

#pragma optimize("", on)

//////////////////////////////////////////////////////////////////

#else // WIN32
//
// Win32 memory management wrappers
//

// Define a Global Shared Heap that we use to allocate memory 
// out of that we need to share between multiple instances.
//
static HANDLE g_hSharedHeap = NULL;

#define MAXHEAPSIZE     2097152
#define HEAP_SHARED     0x04000000      /* put heap in shared memory */


/*----------------------------------------------------------
Purpose: Clean up heap.  This function should be called at
         the program's termination.

Returns: --
Cond:    --
*/
void PUBLIC Mem_Terminate()
    {
    // Assuming that everything else has exited
    //
    if (g_hSharedHeap != NULL)
        HeapDestroy(g_hSharedHeap);
    g_hSharedHeap = NULL;
    }


/*----------------------------------------------------------
Purpose: Copies psz into *ppszBuf.  Will alloc or realloc *ppszBuf
         accordingly.

         If psz is NULL, this function frees *ppszBuf.  This is
         the preferred method of freeing the allocated buffer.

Returns: TRUE on success
Cond:    --
*/
BOOL PUBLIC GSetString(
    LPSTR * ppszBuf,
    LPCSTR psz)             // NULL to free *ppszBuf
    {
    BOOL bRet = FALSE;

    ASSERT(ppszBuf);

    // Free the buffer?
    if (!psz)
        {
        // Yes
        if (ppszBuf)
            {
            GFree(*ppszBuf);
            *ppszBuf = NULL;
            }
        bRet = TRUE;
        }
    else
        {
        // No; (re)allocate and set buffer
        DWORD cb = CbFromCch(lstrlen(psz)+CCH_NUL);

        if (*ppszBuf)
            {
            // Need to reallocate?
            if (cb > GGetSize(*ppszBuf))
                {
                // Yes
                LPSTR pszT = GReAlloc(*ppszBuf, cb);
                if (pszT)
                    {
                    *ppszBuf = pszT;
                    bRet = TRUE;
                    }
                }
            else
                {
                // No
                bRet = TRUE;
                }
            }
        else
            {
            *ppszBuf = (LPSTR)GAlloc(cb);
            if (*ppszBuf)
                {
                bRet = TRUE;
                }
            }

        if (bRet)
            {
            ASSERT(*ppszBuf);
            lstrcpy(*ppszBuf, psz);
            }
        }
    return bRet;
    }


/*----------------------------------------------------------
Purpose: Concatenates psz onto *ppszBuf.  Will alloc or 
         realloc *ppszBuf accordingly.

Returns: TRUE on success
Cond:    --
*/
BOOL PUBLIC GCatString(
    LPSTR * ppszBuf,
    LPCSTR psz)
    {
    BOOL bRet = FALSE;
    DWORD cb;

    ASSERT(ppszBuf);
    ASSERT(psz);

    cb = CbFromCch(lstrlen(psz)+CCH_NUL);

    if (*ppszBuf)
        {
        // (Don't need to count nul because it is already counted in cb)
        DWORD cbExisting = CbFromCch(lstrlen(*ppszBuf));  

        // Need to reallocate?
        if ((cb+cbExisting) > GGetSize(*ppszBuf))
            {
            // Yes; realloc at least MAX_BUF to cut down on the amount
            // of calls in the future
            LPSTR pszT = GReAlloc(*ppszBuf, cbExisting+max(cb, MAX_BUF));
            if (pszT)
                {
                *ppszBuf = pszT;
                bRet = TRUE;
                }
            }
        else
            {
            // No
            bRet = TRUE;
            }
        }
    else
        {
        *ppszBuf = (LPSTR)GAlloc(max(cb, MAX_BUF));
        if (*ppszBuf)
            {
            bRet = TRUE;
            }
        }

    if (bRet)
        {
        ASSERT(*ppszBuf);
        lstrcat(*ppszBuf, psz);
        }
    return bRet;
    }


//
// Shared heap memory management
//
#ifndef NOSHAREDHEAP

/*----------------------------------------------------------
Purpose: Allocate out of shared heap

Returns: Pointer to allocate memory
Cond:    --
*/
void * PUBLIC SharedAlloc(
    DWORD cb)
    {
    // I will assume that this is the only one that needs the checks to
    // see if the heap has been previously created or not

    if (g_hSharedHeap == NULL)
        {
        ENTER_EXCLUSIVE()
            {
            if (g_hSharedHeap == NULL)
                {
                g_hSharedHeap = HeapCreate(HEAP_SHARED, 1, MAXHEAPSIZE);
                }
            }
        LEAVE_EXCLUSIVE()

        // If still NULL we have problems!
        if (g_hSharedHeap == NULL)
            return(NULL);
        }

    return HeapAlloc(g_hSharedHeap, HEAP_ZERO_MEMORY, cb);
    }


/*----------------------------------------------------------
Purpose: Realloc out of shared heap.

Returns: Possibly new pointer to resized block
Cond:    --
*/
void * PUBLIC SharedReAlloc(
    PVOID pv, 
    DWORD cb)
    {
    if (NULL == pv)
        {
        return SharedAlloc(cb);
        }
    return HeapReAlloc(g_hSharedHeap, HEAP_ZERO_MEMORY, pv, cb);
    }


/*----------------------------------------------------------
Purpose: Free shared memory

Returns: --
Cond:    --
*/
void PUBLIC _SharedFree(
    PVOID pv)
    {
    ASSERT(pv);

    if (pv)
        {
        HeapFree(g_hSharedHeap, 0, pv);
        }
    }


/*----------------------------------------------------------
Purpose: Returns the allocated size of a block

Returns: see above
Cond:    --
*/
DWORD PUBLIC SharedGetSize(
    PVOID pv)
    {
    return HeapSize(g_hSharedHeap, 0, pv);
    }


/*----------------------------------------------------------
Purpose: Copies psz into *ppszBuf.  Will alloc or realloc *ppszBuf
         accordingly.

         If psz is NULL, this function frees *ppszBuf.  This is
         the preferred method of freeing the allocated buffer.

Returns: TRUE on success
Cond:    --
*/
BOOL PUBLIC SharedSetString(
    LPSTR * ppszBuf,
    LPCSTR psz)             // NULL to free *ppszBuf
    {
    BOOL bRet;

    ASSERT(ppszBuf);

    // Free the buffer?
    if (!psz)
        {
        // Yes
        if (ppszBuf)
            {
            SharedFree(*ppszBuf);
            *ppszBuf = NULL;
            }
        bRet = TRUE;
        }
    else
        {
        // No; (re)allocate and set buffer
        DWORD cb = CbFromCch(lstrlen(psz)+CCH_NUL);

        LPSTR pszT = SharedReAlloc(*ppszBuf, cb);
        if (pszT)
            {
            *ppszBuf = pszT;
            lstrcpy(*ppszBuf, psz);
            bRet = TRUE;
            }
        else
            bRet = FALSE;
        }
    return bRet;
    }
#endif // NOSHAREDHEAP


//
// Memory tracking functions
//

#ifdef DEBUG

typedef struct _HEAPTRACE
{
    DWORD   cAlloc;
    DWORD   cFailure;
    DWORD   cReAlloc;
    DWORD   cbMaxTotal;
    DWORD   cCurAlloc;
    DWORD   cbCurTotal;
} HEAPTRACE;

HEAPTRACE g_htSync = {0};      // Start of zero...

#endif // DEBUG


/*----------------------------------------------------------
Purpose: Allocate from a heap.

Returns: pointer to block of memory
         NULL (if out of memory)

Cond:    --
*/
LPVOID PUBLIC MemAlloc(
    HANDLE hheap, 
    DWORD cb)
    {
    LPVOID lp;

    if (hheap)
        {
        lp = HeapAlloc(hheap, HEAP_ZERO_MEMORY, cb);
        }
    else
        {
        lp = GAlloc(cb);
        }

    if (lp == NULL)
        {
        DEBUG_CODE( g_htSync.cFailure++; )
        return NULL;
        }

#ifdef DEBUG

    // Update counts.
    g_htSync.cAlloc++;
    g_htSync.cCurAlloc++;
    g_htSync.cbCurTotal += cb;
    if (g_htSync.cbCurTotal > g_htSync.cbMaxTotal)
        g_htSync.cbMaxTotal = g_htSync.cbCurTotal;

#endif

    return lp;
    }


/*----------------------------------------------------------
Purpose: Reallocate a block of memory in a given heap.

Returns: Pointer to reallocated block
         NULL (if out of memory)

Cond:    --
*/
LPVOID PUBLIC MemReAlloc(
    HANDLE hheap, 
    LPVOID pb, 
    DWORD cb)
    {
    LPVOID lp;
    DEBUG_CODE( DWORD cbOld; )

    if (hheap)
        {
        DEBUG_CODE( cbOld = HeapSize(hheap, 0, pb); )

        lp = HeapReAlloc(hheap, HEAP_ZERO_MEMORY, pb, cb);
        }
    else
        {
        if (pb)
            {
            DEBUG_CODE( cbOld = GGetSize(pb); )

            lp = GReAlloc(pb, cb);
            }
        else
            {
            DEBUG_CODE( cbOld = 0; )

            lp = GAlloc(cb);
            }
        }

    if (lp == NULL)
        {
        DEBUG_CODE( g_htSync.cFailure++; )
        return NULL;
        }

#ifdef DEBUG

    // Update counts.
    g_htSync.cReAlloc++;
    g_htSync.cbCurTotal += cb - cbOld;
    if (g_htSync.cbCurTotal > g_htSync.cbMaxTotal)
        g_htSync.cbMaxTotal = g_htSync.cbCurTotal;

#endif

    return lp;
    }


/*----------------------------------------------------------
Purpose: Free block of memory in heap.

Returns: TRUE 
         FALSE (if failure)

Cond:    --
*/
BOOL PUBLIC MemFree(
    HANDLE hheap, 
    LPVOID pb)
    {
    BOOL fRet;
    DEBUG_CODE( DWORD cbOld; )

    if (hheap)
        {
        DEBUG_CODE( cbOld = HeapSize(hheap, 0, pb); )

        fRet = HeapFree(hheap, 0, pb);
        }
    else
        {
        DEBUG_CODE( cbOld = GGetSize(pb); )

        GFree(pb);
        fRet = TRUE;
        }

#ifdef DEBUG

    if (fRet)
        {
        // Update counts.
        g_htSync.cCurAlloc--;
        g_htSync.cbCurTotal -= cbOld;
        }

#endif

    return fRet;
    }


/*----------------------------------------------------------
Purpose: Returns the size of the given block.

Returns: size in bytes
Cond:    --
*/
DWORD PUBLIC MemSize(
    HANDLE hheap, 
    LPVOID pb)
    {
    if (hheap)
        return (DWORD)HeapSize(hheap, 0, pb);
    else
        return (DWORD)GGetSize(pb);
    }

#endif // WIN32


//////////////////////////////////////////////////////////////////


#ifndef NODA

/*----------------------------------------------------------
Purpose: Private alloc for pointer array functions.

Returns: pointer to block of memory
         NULL (if out of memory)

Cond:    --
*/
LPVOID PRIVATE PrvAlloc(
    DWORD dwFlags,          // PAF_* flags
    HANDLE hheap, 
    DWORD cb)
    {
    LPVOID lp;

    ASSERT(PAF_SHARED == SAF_SHARED);

    if (IsFlagSet(dwFlags, PAF_SHARED))
        {
        lp = SharedAlloc(cb);
        }
    else
        {
        lp = MemAlloc(hheap, cb);
        }

    return lp;
    }


// Heapsort is a bit slower, but it doesn't use any stack or memory...
// Mergesort takes a bit of memory (O(n)) and stack (O(log(n)), but very fast...
//
#ifdef WIN32
#define MERGESORT
#else
#define USEHEAPSORT
#endif

#ifdef DEBUG
#define SA_MAGIC   ('S' | ('A' << 256))
#define IsSA(psa) ((psa) && (psa)->magic == SA_MAGIC)
#define PA_MAGIC   ('P' | ('A' << 256))
#define IsPA(ppa) ((ppa) && (ppa)->magic == PA_MAGIC)
#else
#define IsSA(psa)
#define IsPA(ppa)
#endif


typedef struct 
    {
    PVOID * pp;
    PFNPACOMPARE pfnCmp;
    LPARAM lParam;
    int cp;
#ifdef MERGESORT
    PVOID * ppT;
#endif
    } SORTPARAMS;


//
// Structure Array
//

typedef struct _SA 
    {
    // NOTE: The following field MUST be defined at the beginning of the
    // structure in order for SAGetCount() to work.
    DWORD cItem;          // number of elements in sa

    PVOID aItem;          // memory for elements
    DWORD cItemAlloc;     // number items which fit in aItem
    DWORD cbItem;         // size of each item
    DWORD cItemGrow;      // number items to grow cItemAlloc by
    DWORD dwFlags;
    HANDLE hheap;

#ifdef DEBUG
    UINT  magic;
#endif
    } SA;

#define SA_PITEM(psa, index)    ((PVOID)(((char FAR*)(psa)->aItem) + ((index) * (psa)->cbItem)))


/*----------------------------------------------------------
Purpose: Create a structure array.

Returns: TRUE 
         FALSE (if out of memory or invalid parameters)
Cond:    --
*/
BOOL PUBLIC SACreateEx(
    PHSA phsa,
    DWORD cbItem, 
    DWORD cItemGrow,
    HANDLE hheap,           // Must be non-NULL if SAF_HEAP set
    DWORD dwFlags)
    {
    HSA psa;

    ASSERT(phsa);
    ASSERT(0 < cbItem);

    psa = PrvAlloc(dwFlags, hheap, sizeof(SA));

    if (IsFlagSet(dwFlags, PAF_SHARED))
        hheap = g_hSharedHeap;

    if (psa)
        {
        psa->cItem = 0;
        psa->cItemAlloc = 0;
        psa->cbItem = cbItem;
        psa->cItemGrow = (0 == cItemGrow ? 1 : cItemGrow);
        psa->aItem = NULL;
        psa->dwFlags = dwFlags;
        psa->hheap = hheap;

#ifdef DEBUG
        psa->magic = SA_MAGIC;
#endif
        }

    *phsa = psa;

    return NULL != psa;
    }


/*----------------------------------------------------------
Purpose: Destroys a structure array.

Returns: 
Cond:    --
*/
BOOL PUBLIC SADestroyEx(
    HSA psa,
    PFNSAFREE pfnFree,
    LPARAM lParam)
    {
    ASSERT(IsSA(psa));

    if (psa == NULL)       // allow NULL for low memory cases, still assert
        return TRUE;

    if (psa->aItem)
        {
        if (pfnFree)
            {
            DWORD i = SAGetCount(psa);

            while (0 < i)
                {
                i--;

                // Caller should not free the actual pointer being
                // passed, only the contents!
                pfnFree(SA_PITEM(psa, i), lParam);
                }
            }
        
        if (!MemFree(psa->hheap, psa->aItem))
            return FALSE;
        }

#ifdef DEBUG
    psa->cItem = 0;
    psa->cItemAlloc = 0;
    psa->cbItem = 0;
    psa->magic = 0;
#endif

    return MemFree(psa->hheap, psa);
    }


/*----------------------------------------------------------
Purpose: Copy structure at index into buffer.

Returns: TRUE
         FALSE
Cond:    --
*/
BOOL PUBLIC SAGetItem(
    HSA psa, 
    DWORD index, 
    PVOID pitem)
    {
    ASSERT(IsSA(psa));
    ASSERT(pitem);

    if (SA_ERR == index || index >= psa->cItem)
        {
        TRACE_MSG(TF_ERROR, "SA: Invalid index: %lu", index);
        return FALSE;
        }

    hmemcpy(pitem, SA_PITEM(psa, index), psa->cbItem);
    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Get pointer to structure in array

Returns: TRUE (if the index is within range)

Cond:    --
*/
BOOL PUBLIC SAGetItemPtr(
    HSA psa, 
    DWORD index,
    LPVOID * ppv)
    {
    BOOL bRet;

    ASSERT(IsSA(psa));
    ASSERT(ppv);

    bRet = !(SA_ERR == index || index >= psa->cItem);

    if (bRet)
        {
        *ppv = SA_PITEM(psa, index);
        }
    else
        {
        TRACE_MSG(TF_ERROR, "SA: Invalid index: %lu", index);
        *ppv = NULL;
        }
        
    return bRet;
    }


/*----------------------------------------------------------
Purpose: Set item

Returns: 
Cond:    --
*/
BOOL PUBLIC SASetItem(
    HSA psa, 
    DWORD index, 
    PVOID pitem)
    {
    ASSERT(pitem);
    ASSERT(IsSA(psa));

    if (SA_ERR == index)
        {
        TRACE_MSG(TF_ERROR, "SA: Invalid index: %lu", index);
        return FALSE;
        }

    if (index >= psa->cItem)
        {
        if (index + 1 > psa->cItemAlloc)
            {
            int cItemAlloc = (((index + 1) + psa->cItemGrow - 1) / psa->cItemGrow) * psa->cItemGrow;

            PVOID aItemNew = MemReAlloc(psa->hheap, psa->aItem, cItemAlloc * psa->cbItem);
            if (!aItemNew)
                return FALSE;

            psa->aItem = aItemNew;
            psa->cItemAlloc = cItemAlloc;
            }
        psa->cItem = index + 1;
        }

    hmemcpy(SA_PITEM(psa, index), pitem, psa->cbItem);

    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Inserts the given item.  If *piIndex is greater than
         the current size of the array, the item is appended
         to the end.  Otherwise, the item is inserted at 
         *piIndex.

         If piIndex is NULL, the item is appended to the end.

         Use SASetItem to place an item at a specified index,
         regardless of the array size.

         When this function completes successfully, it sets
         *piIndex to the index that the item really gets 
         inserted at.  Otherwise, it sets *piIndex to SA_ERR.

Returns: TRUE (on successful insertion)
         FALSE 
Cond:    --
*/
BOOL PUBLIC SAInsertItem(
    HSA psa, 
    LPDWORD pindex,         // May be NULL
    PVOID pitem)
    {
    BOOL bRet = TRUE;       // assume success

    ASSERT(pitem);
    ASSERT(IsSA(psa));

    if (pindex && SA_ERR == *pindex)
        {
        TRACE_MSG(TF_ERROR, "SA: Invalid index: %lu", *pindex);
        bRet = FALSE;
        }
    else
        {
        DWORD index;

        if (NULL == pindex || *pindex > psa->cItem)
            index = psa->cItem;
        else
            index = *pindex;

        if (psa->cItem + 1 > psa->cItemAlloc)
            {
            PVOID aItemNew = MemReAlloc(psa->hheap, psa->aItem,
                    (psa->cItemAlloc + psa->cItemGrow) * psa->cbItem);
            if (!aItemNew)
                bRet = FALSE;
            else
                {
                psa->aItem = aItemNew;
                psa->cItemAlloc += psa->cItemGrow;
                }
            }

        if (bRet)
            {
            // If we are inserting, we need to slide everybody up
            if (index < psa->cItem)
                {
                hmemcpy(SA_PITEM(psa, index + 1), SA_PITEM(psa, index),
                    (psa->cItem - index) * psa->cbItem);
                }
            psa->cItem++;
            hmemcpy(SA_PITEM(psa, index), pitem, psa->cbItem);

            if (pindex)
                *pindex = index;
            }
        else if (pindex)
            {
            *pindex = SA_ERR;
            }
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: 
Returns: 
Cond:    --
*/
BOOL PUBLIC SADeleteItem(
    HSA psa, 
    DWORD index)
    {
    ASSERT(IsSA(psa));

    if (SA_ERR == index || index >= psa->cItem)
        {
        TRACE_MSG(TF_ERROR, "SA: Invalid index: %lu", index);
        return FALSE;
        }

    if (index < psa->cItem - 1)
        {
        hmemcpy(SA_PITEM(psa, index), SA_PITEM(psa, index + 1),
            (psa->cItem - (index + 1)) * psa->cbItem);
        }
    psa->cItem--;

    if (psa->cItemAlloc - psa->cItem > psa->cItemGrow)
        {
        PVOID aItemNew = MemReAlloc(psa->hheap, psa->aItem,
                (psa->cItemAlloc - psa->cItemGrow) * psa->cbItem);

        ASSERT(aItemNew);
        psa->aItem = aItemNew;
        psa->cItemAlloc -= psa->cItemGrow;
        }
    return TRUE;
    }


/*----------------------------------------------------------
Purpose: 
Returns: 
Cond:    --
*/
BOOL PUBLIC SADeleteAllItems(
    HSA psa)
    {
    ASSERT(IsSA(psa));

    if (psa->aItem)
        {
        MemFree(psa->hheap, psa->aItem);
        }

    psa->aItem = NULL;
    psa->cItem = psa->cItemAlloc = 0;
    return TRUE;
    }


//================== Dynamic pointer array implementation ===========

typedef struct _PA {
// NOTE: The following two fields MUST be defined in this order, at
// the beginning of the structure in order for the macro APIs to work.
//
    DWORD   cp;
    DWORD   dwAlignPad;
    PVOID * pp;

    HANDLE  hheap;        // Heap to allocate from if NULL use shared

    DWORD   cpAlloc;
    DWORD   cpGrow;
    DWORD   dwFlags;

#ifdef DEBUG
    UINT magic;
#endif
} PA;



/*----------------------------------------------------------
Purpose: Creates a pointer array.

Returns: TRUE
         FALSE (if out of memory)

Cond:    --
*/
BOOL PUBLIC PACreateEx(
    PHPA phpa,
    DWORD cpGrow,
    HANDLE hheap,           // Must be non-null if PAF_HEAP set
    DWORD dwFlags)          // PAF_*
    {
    HPA ppa;

    ASSERT(phpa);

    ppa = PrvAlloc(dwFlags, hheap, sizeof(PA));

    if (IsFlagSet(dwFlags, PAF_SHARED))
        hheap = g_hSharedHeap;
        
    if (ppa)
        {
        ppa->dwFlags = dwFlags;
        ppa->cp = 0;
        ppa->cpAlloc = 0;
        ppa->cpGrow = (cpGrow < 8 ? 8 : cpGrow);
        ppa->pp = NULL;

#ifdef WIN32
        ppa->hheap = hheap;
#else
        ppa->hheap = NULL;       
#endif

#ifdef DEBUG
        ppa->magic = PA_MAGIC;
#endif
        }

    *phpa = ppa;

    return NULL != ppa;
    }


/*----------------------------------------------------------
Purpose: Destroy a pointer array, and call the given pfnFree
         function for each element in the array.

Returns: TRUE
         FALSE (on failure)

Cond:    --
*/
BOOL PUBLIC PADestroyEx(
    HPA ppa,
    PFNPAFREE pfnFree,
    LPARAM lParam)
    {
    ASSERT(IsPA(ppa));

    if (ppa == NULL)       // allow NULL for low memory cases, still assert
        return TRUE;

    if (ppa->pp)
        {
        if (pfnFree)
            {
            DWORD i = PAGetCount(ppa);

            while (0 < i)
                {
                i--;
                pfnFree(PAFastGetPtr(ppa, i), lParam);
                }
            }
        
        if (!MemFree(ppa->hheap, ppa->pp))
            return FALSE;
        }

#ifdef DEBUG
    ppa->cp = 0;
    ppa->cpAlloc = 0;
    ppa->magic = 0;
#endif

    return MemFree(ppa->hheap, ppa);
    }


/*----------------------------------------------------------
Purpose: Clone a pointer array.  If *phpa was previously 
         allocated, this function simply grows the array
         to the appropriate size before copying the contents
         of the array.

Returns: TRUE
         FALSE (if out of memory)

Cond:    --
*/
BOOL PUBLIC PAClone(
    PHPA phpa,
    HPA ppa)
    {
    BOOL bRet;
    HPA ppaNew;

    ASSERT(phpa);

    if (NULL == *phpa)
        {
        bRet = PACreateEx(&ppaNew, ppa->cpGrow, ppa->hheap, ppa->dwFlags);
        }
    else
        {
        ppaNew = *phpa;
        bRet = TRUE;
        }

    if (bRet)
        {
        bRet = PAGrow(ppaNew, ppa->cpAlloc);
        if (!bRet)
            {
            if (NULL == *phpa)
                PADestroy(ppaNew);
            }
        else
            {
            ppaNew->cp = ppa->cp;
            hmemcpy(ppaNew->pp, ppa->pp, ppa->cp * sizeof(PVOID));
            *phpa = ppaNew;
            }
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Get a pointer stored in index

Returns: TRUE
         FALSE (if index out of range)

Cond:    --
*/
BOOL PUBLIC PAGetPtr(
    HPA ppa, 
    DWORD index,
    LPVOID * ppv)
    {
    BOOL bRet;

    ASSERT(IsPA(ppa));
    ASSERT(ppv);

    bRet = !(PA_ERR == index || index >= ppa->cp);

    if (bRet)
        {
        *ppv = ppa->pp[index];
        }
    else
        {
        *ppv = NULL;
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Gets the index that pointer p is stored at

Returns: index
Cond:    --
*/
BOOL PUBLIC PAGetPtrIndex(
    HPA ppa, 
    PVOID p,
    LPDWORD pindex)
    {
    BOOL bRet = FALSE;
    PVOID * pp;
    PVOID * ppMax;

    ASSERT(IsPA(ppa));
    ASSERT(pindex);

    if (ppa->pp)
        {
        pp = ppa->pp;
        ppMax = pp + ppa->cp;
        for ( ; pp < ppMax; pp++)
            {
            if (*pp == p)
                {
                *pindex = (DWORD)(pp - ppa->pp);
                bRet = TRUE;
                break;
                }
            }
        }

    if (!bRet)
        *pindex = PA_ERR;

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Grow the pointer array

Returns: 
Cond:    --
*/
BOOL PUBLIC PAGrow(
    HPA ppa, 
    DWORD cpAlloc)
    {
    ASSERT(IsPA(ppa));

    if (cpAlloc > ppa->cpAlloc)
        {
        PVOID * ppNew;

        cpAlloc = ((cpAlloc + ppa->cpGrow - 1) / ppa->cpGrow) * ppa->cpGrow;

        if (ppa->pp)
            ppNew = (PVOID *)MemReAlloc(ppa->hheap, ppa->pp, cpAlloc * sizeof(PVOID));
        else
            ppNew = (PVOID *)PrvAlloc(ppa->dwFlags, ppa->hheap, cpAlloc * sizeof(PVOID));
        if (!ppNew)
            return FALSE;

        ppa->pp = ppNew;
        ppa->cpAlloc = cpAlloc;
        }
    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Store a pointer at index.  Grows the array accordingly.

Returns: TRUE
         FALSE (if out of memory)
Cond:    --
*/
BOOL PUBLIC PASetPtr(
    HPA ppa, 
    DWORD index, 
    PVOID p)
    {
    ASSERT(IsPA(ppa));

    if (PA_ERR == index)
        {
        TRACE_MSG(TF_ERROR, "PA: Invalid index: %lu", index);
        return FALSE;
        }

    if (index >= ppa->cp)
        {
        if (!PAGrow(ppa, index + 1))
            return FALSE;
        ppa->cp = index + 1;
        }

    ppa->pp[index] = p;

    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Inserts the given item.  If *piIndex is greater than
         the current size of the array, the item is appended
         to the end.  Otherwise, the item is inserted at 
         *piIndex.

         If piIndex is NULL, the item is appended to the end.

         Use SASetItem to place an item at a specified index,
         regardless of the array size.

         When this function completes successfully, it sets
         *piIndex to the index that the item really gets 
         inserted at.  Otherwise, it sets *piIndex to SA_ERR.

Returns: TRUE (on successful insertion)
         FALSE 
Cond:    --
*/
BOOL PUBLIC PAInsertPtr(
    HPA ppa, 
    LPDWORD pindex,         // May be NULL
    PVOID p)
    {
    BOOL bRet;

    ASSERT(IsPA(ppa));

    if (pindex && PA_ERR == *pindex)
        {
        TRACE_MSG(TF_ERROR, "PA: Invalid index: %lu", *pindex);
        bRet = FALSE;
        }
    else
        {
        DWORD index;

        bRet = TRUE;        // assume success

        if (NULL == pindex || *pindex > ppa->cp)
            index = ppa->cp;
        else
            index = *pindex;

        // Make sure we have room for one more item
        //
        if (ppa->cp + 1 > ppa->cpAlloc)
            {
            bRet = PAGrow(ppa, ppa->cp + 1);
            }

        if (bRet)
            {
            // If we are inserting, we need to slide everybody up
            if (index < ppa->cp)
                {
                hmemcpy(&ppa->pp[index + 1], &ppa->pp[index],
                    (ppa->cp - index) * sizeof(PVOID));
                }

            ppa->pp[index] = p;
            ppa->cp++;

            if (pindex)
                *pindex = index;
            }
        else if (pindex)
            {
            *pindex = PA_ERR;
            }
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Delete a pointer from index.

Returns: the deleted pointer
         NULL (if index is out of range)

Cond:    --
*/
PVOID PUBLIC PADeletePtr(
    HPA ppa, 
    DWORD index)
    {
    PVOID p;

    ASSERT(IsPA(ppa));

    if (PA_ERR == index || index >= ppa->cp)
        {
        TRACE_MSG(TF_ERROR, "PA: Invalid index: %lu", index);
        return NULL;
        }

    p = ppa->pp[index];

    if (index < ppa->cp - 1)
        {
        hmemcpy(&ppa->pp[index], &ppa->pp[index + 1],
            (ppa->cp - (index + 1)) * sizeof(PVOID));
        }
    ppa->cp--;

    if (ppa->cpAlloc - ppa->cp > ppa->cpGrow)
        {
        PVOID * ppNew;
        ppNew = MemReAlloc(ppa->hheap, ppa->pp, (ppa->cpAlloc - ppa->cpGrow) * sizeof(PVOID));

        ASSERT(ppNew);
        ppa->pp = ppNew;
        ppa->cpAlloc -= ppa->cpGrow;
        }
    return p;
    }


/*----------------------------------------------------------
Purpose: Delete all the pointers in the array.  If pfnFree
         is non-NULL, this function will free each of the
         pointer elements in this array using pfnFree.

Returns: TRUE
         FALSE

Cond:    --
*/
BOOL PUBLIC PADeleteAllPtrsEx(
    HPA ppa,
    PFNPAFREE pfnFree,
    LPARAM lParam)
    {
    ASSERT(IsPA(ppa));

    if (ppa->pp)
        {
        if (pfnFree)
            {
            int i = PAGetCount(ppa);

            while (0 < i)
                {
                i--;
                pfnFree(PAFastGetPtr(ppa, i), lParam);
                }
            }

        if (!MemFree(ppa->hheap, ppa->pp))
            return FALSE;
        }
        
    ppa->pp = NULL;
    ppa->cp = ppa->cpAlloc = 0;
    return TRUE;
    }


#ifdef USEQUICKSORT
BOOL NEAR PAQuickSort2(
    DWORD i, 
    DWORD j, 
    SORTPARAMS FAR* psp)
    {
    PVOID * pp = psp->pp;
    LPARAM lParam = psp->lParam;
    PFNPACOMPARE pfnCmp = psp->pfnCmp;

    DWORD iPivot;
    PVOID pFirst;
    DWORD k;
    int result;

    iPivot = PA_ERR;
    pFirst = pp[i];
    for (k = i + 1; k <= j; k++)
        {
        result = (*pfnCmp)(pp[k], pFirst, lParam);

        if (result > 0)
            {
            iPivot = k;
            break;
            }
        else if (result < 0)
            {
            iPivot = i;
            break;
            }
        }

    if (iPivot != PA_ERR)
        {
        DWORD l = i;
        DWORD r = j;
        PVOID pivot = pp[iPivot];

        do
            {
            PVOID p;

            p = pp[l];
            pp[l] = pp[r];
            pp[r] = p;

            while ((*pfnCmp)(pp[l], pivot, lParam) < 0)
                l++;
            while ((*pfnCmp)(pp[r], pivot, lParam) >= 0)
                r--;
            } 
            while (l <= r);

        if (l - 1 > i)
            PAQuickSort2(i, l - 1, psp);
        if (j > l)
            PAQuickSort2(l, j, psp);
        }
    return TRUE;
    }


BOOL NEAR PAQuickSort(
    SORTPARAMS FAR* psp)
    {
    return PAQuickSort2(0, psp->cp - 1, psp);
    }
#endif  // USEQUICKSORT

#ifdef USEHEAPSORT

void NEAR PAHeapSortPushDown(
    DWORD first, 
    DWORD last, 
    SORTPARAMS FAR* psp)
    {
    PVOID * pp = psp->pp;
    LPARAM lParam = psp->lParam;
    PFNPACOMPARE pfnCmp = psp->pfnCmp;
    DWORD r;
    DWORD r2;

    r = first;
    while (r <= last / 2)
        {
        int wRTo2R;
        r2 = r * 2;

        wRTo2R = (*pfnCmp)(pp[r-1], pp[r2-1], lParam);

        if (r2 == last)
            {
            if (wRTo2R < 0)
                {
                Swap(pp[r-1], pp[r2-1]);
                }
            break;
            }
        else
            {
            int wR2toR21 = (*pfnCmp)(pp[r2-1], pp[r2+1-1], lParam);

            if (wRTo2R < 0 && wR2toR21 >= 0)
                {
                Swap(pp[r-1], pp[r2-1]);
                r = r2;
                }
            else if ((*pfnCmp)(pp[r-1], pp[r2+1-1], lParam) < 0 && wR2toR21 < 0)
                {
                Swap(pp[r-1], pp[r2+1-1]);
                r = r2 + 1;
                }
            else
                {
                break;
                }
            }
        }
    }


BOOL NEAR PAHeapSort(SORTPARAMS FAR* psp)
    {
    PVOID * pp = psp->pp;
    DWORD c = psp->cp;
    DWORD i;

    for (i = c / 2; i >= 1; i--)
        PAHeapSortPushDown(i, c, psp);

    for (i = c; i >= 2; i--)
        {
        Swap(pp[0], pp[i-1]);

        PAHeapSortPushDown(1, i - 1, psp);
        }
    return TRUE;
    }
#endif  // USEHEAPSORT

#if defined(MERGESORT) && defined(WIN32)

#define SortCompare(psp, pp1, i1, pp2, i2) \
    (psp->pfnCmp(pp1[i1], pp2[i2], psp->lParam))

//
//  This function merges two sorted lists and makes one sorted list.
//   psp->pp[iFirst, iFirst+cItes/2-1], psp->pp[iFirst+cItems/2, iFirst+cItems-1]
//
void NEAR PAMergeThem(
    SORTPARAMS FAR* psp, 
    DWORD iFirst, 
    DWORD cItems)
    {
    //
    // Notes:
    //  This function is separated from PAMergeSort2() to avoid comsuming
    // stack variables. Never inline this.
    //
    DWORD cHalf = cItems/2;
    DWORD iIn1, iIn2, iOut;
    LPVOID * ppvSrc = &psp->pp[iFirst];

    // Copy the first part to temp storage so we can write directly into
    // the final buffer.  Note that this takes at most psp->cp/2 DWORD's
    hmemcpy(psp->ppT, ppvSrc, cHalf*sizeof(LPVOID));

    for (iIn1=0, iIn2=cHalf, iOut=0;;)
        {
        if (SortCompare(psp, psp->ppT, iIn1, ppvSrc, iIn2) <= 0) 
            {
            ppvSrc[iOut++] = psp->ppT[iIn1++];

            if (iIn1==cHalf) 
                {
                // We used up the first half; the rest of the second half
                // should already be in place
                break;
                }
            } 
        else 
            {
            ppvSrc[iOut++] = ppvSrc[iIn2++];
            if (iIn2==cItems) 
                {
                // We used up the second half; copy the rest of the first half
                // into place
                hmemcpy(&ppvSrc[iOut], &psp->ppT[iIn1], (cItems-iOut)*sizeof(LPVOID));
                break;
                }
            }
        }
    }

//
//  This function sorts a give list (psp->pp[iFirst,iFirst-cItems-1]).
//
void NEAR PAMergeSort2(
    SORTPARAMS FAR* psp, 
    DWORD iFirst, 
    DWORD cItems)
    {
    //
    // Notes:
    //   This function is recursively called. Therefore, we should minimize
    //  the number of local variables and parameters. At this point, we
    //  use one local variable and three parameters.
    //
    DWORD cHalf;

    switch(cItems)
        {
    case 1:
        return;

    case 2:
        // Swap them, if they are out of order.
        if (SortCompare(psp, psp->pp, iFirst, psp->pp, iFirst+1) > 0)
            {
            psp->ppT[0] = psp->pp[iFirst];
            psp->pp[iFirst] = psp->pp[iFirst+1];
            psp->pp[iFirst+1] = psp->ppT[0];
            }
        break;

    default:
        cHalf = cItems/2;

        // Sort each half
        PAMergeSort2(psp, iFirst, cHalf);
        PAMergeSort2(psp, iFirst+cHalf, cItems-cHalf);

        // Then, merge them.
        PAMergeThem(psp, iFirst, cItems);
        break;
        }
    }


BOOL NEAR PAMergeSort(
    SORTPARAMS FAR* psp)
    {
    if (psp->cp == 0)
        return TRUE;

    // Note that we divide by 2 below; we want to round down
    psp->ppT = GAlloc(psp->cp/2 * sizeof(LPVOID));
    if (!psp->ppT)
        return FALSE;

    PAMergeSort2(psp, 0, psp->cp);
    GFree(psp->ppT);
    return TRUE;
    }
#endif // MERGESORT

/*----------------------------------------------------------
Purpose: Sort the array.

Returns: 
Cond:    --
*/
BOOL PUBLIC PASort(
    HPA ppa, 
    PFNPACOMPARE pfnCmp, 
    LPARAM lParam)
    {
    SORTPARAMS sp;

    sp.cp = ppa->cp;
    sp.pp = ppa->pp;
    sp.pfnCmp = pfnCmp;
    sp.lParam = lParam;

#ifdef USEQUICKSORT
    return PAQuickSort(&sp);
#endif
#ifdef USEHEAPSORT
    return PAHeapSort(&sp);
#endif
#ifdef MERGESORT
    return PAMergeSort(&sp);
#endif
    }


/*----------------------------------------------------------
Purpose: Search for pFind in array.

Returns: 
Cond:    --
*/
DWORD PUBLIC PASearch(
    HPA ppa, 
    PVOID pFind, 
    DWORD iStart,
    PFNPACOMPARE pfnCompare, 
    LPARAM lParam, 
    UINT options)
    {
    DWORD cp = PAGetCount(ppa);

    ASSERT(pfnCompare);
    ASSERT(PA_ERR != iStart);

    // Only allow these wierd flags if the list is sorted
    ASSERT((options & PAS_SORTED) || !(options & (PAS_INSERTBEFORE | PAS_INSERTAFTER)));

    if (!(options & PAS_SORTED))
        {
        // Not sorted: do linear search.
        DWORD i;

        for (i = iStart; i < cp; i++)
            {
            if (0 == pfnCompare(pFind, PAFastGetPtr(ppa, i), lParam))
                return i;
          }
        return PA_ERR;
        }
    else
        {
        // Search the array using binary search.  If several adjacent 
        // elements match the target element, the index of the first
        // matching element is returned.

        DWORD iRet = PA_ERR;      // assume no match
        BOOL bFound = FALSE;
        int nCmp = 0;
        DWORD iLow = 0;       // Don't bother using iStart for binary search
        DWORD iMid = 0;

        if (0 < cp)
            {
            DWORD iHigh = cp - 1;

            // (OK for cp == 0)
            while (iLow <= iHigh)
                {
                iMid = (iLow + iHigh) / 2;

                nCmp = pfnCompare(pFind, PAFastGetPtr(ppa, iMid), lParam);

                if (0 > nCmp)
                    {
                    // Account for the fact we are working with
                    // unsigned values
                    if (0 == iMid)
                        break;
                    iHigh = iMid - 1;       // First is smaller
                    }
                else if (0 < nCmp)
                    iLow = iMid + 1;        // First is larger
                else
                    {
                    // Match; search back for first match
                    bFound = TRUE;
                    while (0 < iMid)
                        {
                        if (0 != pfnCompare(pFind, PAFastGetPtr(ppa, iMid-1), lParam))
                            break;
                        else
                            iMid--;
                        }
                    break;
                    }
                }
            }

        if (bFound)
            {
            ASSERT(0 <= iMid);
            iRet = iMid;
            }

        // Did the search fail AND
        // is one of the strange search flags set?
        if (!bFound && (options & (PAS_INSERTAFTER | PAS_INSERTBEFORE)))
            {
            // Yes; return the index where the target should be inserted
            // if not found
            if (0 < nCmp)       // First is larger
                iRet = iLow;
            else
                iRet = iMid;
            // (We don't distinguish between the two flags anymore)
            }
        else if ( !(options & (PAS_INSERTAFTER | PAS_INSERTBEFORE)) )
            {
            // Sanity check with linear search
            ASSERT(PASearch(ppa, pFind, iStart, pfnCompare, lParam, options & ~PAS_SORTED) == iRet);
            }
        return iRet;
        }
    }

#endif // NODA

#endif // NOMEM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasscrpt\nthdr1.h ===
//============================================================================
// Copyright (c) 1996, Microsoft Corporation
//
// File:    nthdr1.h
//
// History:
//  Abolade-Gbadegesin  04-02-96    Created.
//
// This file contains macros to hide differences in implementation
// of the scripting between Win9x and Windows NT
//============================================================================

#ifndef _NTHDR1_H_
#define _NTHDR1_H_


//
// declare data-type for return codes
//

#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
typedef LONG HRESULT;
#endif //!_HRESULT_DEFINED


//
// undefine registry-string redefined by rnap.h
//

#ifdef REGSTR_VAL_MODE
#undef REGSTR_VAL_MODE
#endif


//
// define critical-section initialization function needed by common.c
//

#define ReinitializeCriticalSection     InitializeCriticalSection


//
// provide dummy definiton of ContextHelp for terminal.c
//

#define ContextHelp(a,b,c,d)


//
// macros used for CRT-style Unicode<->ANSI conversion
//
#define WCSTOMBS(a,b) \
        WideCharToMultiByte( \
            CP_ACP, 0, (b), -1, (a), lstrlenW(b) + 1, NULL, NULL \
            )
#define MBSTOWCS(a, b) \
        MultiByteToWideChar( \
            CP_ACP, 0, (b), -1, (a), (lstrlenW(b) + 1) * sizeof(WCHAR) \
            )



//
// constants used for RASMAN I/O
//

#define SIZE_RecvBuffer     1024
#define SIZE_ReceiveBuf     SIZE_RecvBuffer
#define SIZE_SendBuffer     1
#define SIZE_SendBuf        SIZE_SendBuffer
#define SECS_RecvTimeout    1



//----------------------------------------------------------------------------
// Function:    RxLogErrors
//
// Logs script-syntax-errors to a file.
//----------------------------------------------------------------------------

DWORD
RxLogErrors(
    IN      HANDLE      hscript,
    IN      VOID*       hsaStxerr
    );



//----------------------------------------------------------------------------
// Function:    RxReadFile
//
// Transfers data out of a RASMAN buffer into the circular buffer
// used by the Win9x scripting code
//----------------------------------------------------------------------------

BOOL
RxReadFile(
    IN      HANDLE      hscript,
    IN      BYTE*       pBuffer,
    IN      DWORD       dwBufferSize,
    OUT     DWORD*      pdwBytesRead
    );



//----------------------------------------------------------------------------
// Function:    RxSetIPAddress
//
// Sets the IP address for the script's RAS entry
//----------------------------------------------------------------------------

DWORD
RxSetIPAddress(
    IN      HANDLE      hscript,
    IN      LPCSTR      lpszAddress
    );



//----------------------------------------------------------------------------
// Function:    RxSetKeyboard
//
// Signals the script-owner to enable or disable keyboard input.
//----------------------------------------------------------------------------

DWORD
RxSetKeyboard(
    IN      HANDLE      hscript,
    IN      BOOL        bEnable
    );


//----------------------------------------------------------------------------
// Function:    RxSendCreds
//
// Sends users password over the wire.
//----------------------------------------------------------------------------
DWORD
RxSendCreds(
    IN HANDLE hscript,
    IN CHAR controlchar
    );


//----------------------------------------------------------------------------
// Function:    RxSetPortData
//
// Changes settings for the COM port.
//----------------------------------------------------------------------------

DWORD
RxSetPortData(
    IN      HANDLE      hscript,
    IN      VOID*       pStatement
    );



//----------------------------------------------------------------------------
// Function:    RxWriteFile
//
// Transmits the given buffer thru RASMAN on a port
//----------------------------------------------------------------------------

VOID
RxWriteFile(
    IN      HANDLE      hscript,
    IN      BYTE*       pBuffer,
    IN      DWORD       dwBufferSize,
    OUT     DWORD*      pdwBytesWritten
    );


#endif // _NTHDR1_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasscrpt\eval.c ===
//
// Copyright (c) Microsoft Corporation 1995
//
// eval.c
//
// This file contains the evaluation functions for the
// abstract syntax tree.
//
// History:
//  06-15-95 ScottH     Created
//

#include "proj.h"
#include "rcids.h"
#include "debug.h"

#define MSECS_FROM_SECS(s)  ((s)*1000)
#define RAS_DUMMY_PASSWORD "****************"

//
// Clean expressions
//


/*----------------------------------------------------------
Purpose: Clean expressions.

Returns: --
Cond:    --
*/
void PRIVATE Expr_Clean(
    PEXPR this)
    {
    ASSERT(this);

    switch (Ast_GetType(this))
        {
    case AT_INT_EXPR:
    case AT_BOOL_EXPR:
    case AT_STRING_EXPR:
    case AT_VAR_EXPR:
        ClearFlag(this->dwFlags, EF_DONE);
        break;

    case AT_UNOP_EXPR:
        ClearFlag(this->dwFlags, EF_DONE);
        Expr_Clean(UnOpExpr_GetExpr(this));
        break;

    case AT_BINOP_EXPR:
        ClearFlag(this->dwFlags, EF_DONE);
        Expr_Clean(BinOpExpr_GetExpr1(this));
        Expr_Clean(BinOpExpr_GetExpr2(this));
        break;

    default:
        ASSERT(0);
        break;
        }
    }


/*----------------------------------------------------------
Purpose: Clean the expressions in the 'waitfor' statement.

Returns: --
Cond:    --
*/
void PRIVATE WaitforStmt_Clean(
    PSTMT this)
    {
    PEXPR pexpr;
    HSA hsa = WaitforStmt_GetCaseList(this);
    DWORD ccase = SAGetCount(hsa);
    DWORD i;

    pexpr = WaitforStmt_GetUntilExpr(this);
    if (pexpr)
        Expr_Clean(pexpr);

    for (i = 0; i < ccase; i++)
        {
        PWAITCASE pwc;

        SAGetItemPtr(hsa, i, &pwc);
        ASSERT(pwc);

        Expr_Clean(pwc->pexpr);
        }
    }


/*----------------------------------------------------------
Purpose: Clean the expressions in the statement

Returns: --
Cond:    --
*/
void PRIVATE Stmt_Clean(
    PSTMT this)
    {
    PEXPR pexpr;

    ASSERT(this);

    switch (Ast_GetType(this))
        {
    case AT_ENTER_STMT:
    case AT_LEAVE_STMT:
    case AT_HALT_STMT:
    case AT_LABEL_STMT:
    case AT_GOTO_STMT:
        break;

    case AT_WHILE_STMT:
        pexpr = WhileStmt_GetExpr(this);
        Expr_Clean(pexpr);
        break;

    case AT_IF_STMT:
        pexpr = IfStmt_GetExpr(this);
        Expr_Clean(pexpr);
        break;

    case AT_ASSIGN_STMT:
        pexpr = AssignStmt_GetExpr(this);
        Expr_Clean(pexpr);
        break;

    case AT_TRANSMIT_STMT:
        pexpr = TransmitStmt_GetExpr(this);
        Expr_Clean(pexpr);
        break;

    case AT_WAITFOR_STMT:
        WaitforStmt_Clean(this);
        break;

    case AT_DELAY_STMT:
        pexpr = DelayStmt_GetExpr(this);
        Expr_Clean(pexpr);
        break;

    case AT_SET_STMT:
        switch (SetStmt_GetType(this))
            {
        case ST_IPADDR:
            pexpr = SetIPStmt_GetExpr(this);
            Expr_Clean(pexpr);
            break;

        case ST_PORT:
        case ST_SCREEN:
            break;

        default:
            ASSERT(0);
            break;
            }
        break;

    default:
        ASSERT(0);
        break;
        }
    }


//
// Evaluate expressions
//


/*----------------------------------------------------------
Purpose: Evaluates the expression and returns an integer.

Returns: RES_OK

Cond:    --
*/
RES PRIVATE IntExpr_Eval(
    PEXPR this)
    {
    ASSERT(this);
    ASSERT(AT_INT_EXPR == Ast_GetType(this));
    ASSERT(DATA_INT == Expr_GetDataType(this));

    Expr_SetRes(this, IntExpr_GetVal(this));

    return RES_OK;
    }


/*----------------------------------------------------------
Purpose: Evaluates the expression and returns a string.

         The returned string should not be freed.

Returns: RES_OK

Cond:    --
*/
RES PRIVATE StrExpr_Eval(
    PEXPR this)
    {
    ASSERT(this);
    ASSERT(AT_STRING_EXPR == Ast_GetType(this));
    ASSERT(DATA_STRING == Expr_GetDataType(this));

    Expr_SetRes(this, (ULONG_PTR) StrExpr_GetStr(this));

    return RES_OK;
    }


/*----------------------------------------------------------
Purpose: Evaluates the expression and returns a boolean

Returns: RES_OK

Cond:    --
*/
RES PRIVATE BoolExpr_Eval(
    PEXPR this)
    {
    ASSERT(this);
    ASSERT(AT_BOOL_EXPR == Ast_GetType(this));
    ASSERT(DATA_BOOL == Expr_GetDataType(this));

    Expr_SetRes(this, BoolExpr_GetVal(this));

    return RES_OK;
    }


/*----------------------------------------------------------
Purpose: Returns the value of the variable.

Returns: RES_OK

Cond:    --
*/
RES PRIVATE VarExpr_Eval(
    PEXPR this,
    PASTEXEC pastexec)
    {
    RES res;
    PSTE pste;
    LPSTR pszIdent;

    ASSERT(this);
    ASSERT(AT_VAR_EXPR == Ast_GetType(this));

    pszIdent = VarExpr_GetIdent(this);
    if (RES_OK == Symtab_FindEntry(pastexec->pstCur, pszIdent, STFF_DEFAULT, &pste, NULL))
        {
        EVALRES er;

        STE_GetValue(pste, &er);
        Expr_SetRes(this, er.dw);
        res = RES_OK;
        }
    else
        {
        ASSERT(0);
        res = RES_E_FAIL;
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Evaluates the expression..

         The returned string should not be freed.

Returns: RES_OK

Cond:    --
*/
RES PRIVATE BinOpExpr_Eval(
    PEXPR this,
    PASTEXEC pastexec)
    {
    RES res;
    PEXPR pexpr1;
    PEXPR pexpr2;

    ASSERT(this);
    ASSERT(AT_BINOP_EXPR == Ast_GetType(this));

    pexpr1 = BinOpExpr_GetExpr1(this);
    res = Expr_Eval(pexpr1, pastexec);
    if (RES_OK == res)
        {
        pexpr2 = BinOpExpr_GetExpr2(this);
        res = Expr_Eval(pexpr2, pastexec);
        if (RES_OK == res)
            {
            PEVALRES per1 = Expr_GetRes(pexpr1);
            PEVALRES per2 = Expr_GetRes(pexpr2);
            DATATYPE dt = Expr_GetDataType(pexpr1);

            // Data types must be the same.  This was checked
            // during the typechecking phase.
            ASSERT(Expr_GetDataType(pexpr1) == Expr_GetDataType(pexpr2));

            switch (BinOpExpr_GetType(this))
                {
            case BOT_OR:
                ASSERT(DATA_BOOL == dt);

                Expr_SetRes(this, per1->bVal || per2->bVal);
                break;

            case BOT_AND:
                ASSERT(DATA_BOOL == dt);

                Expr_SetRes(this, per1->bVal && per2->bVal);
                break;

            case BOT_LEQ:
                ASSERT(DATA_INT == dt);

                Expr_SetRes(this, per1->nVal <= per2->nVal);
                break;

            case BOT_LT:
                ASSERT(DATA_INT == dt);

                Expr_SetRes(this, per1->nVal < per2->nVal);
                break;

            case BOT_GEQ:
                ASSERT(DATA_INT == dt);

                Expr_SetRes(this, per1->nVal >= per2->nVal);
                break;

            case BOT_GT:
                ASSERT(DATA_INT == dt);

                Expr_SetRes(this, per1->nVal > per2->nVal);
                break;

            case BOT_NEQ:
                switch (dt)
                    {
                case DATA_INT:
                    Expr_SetRes(this, per1->nVal != per2->nVal);
                    break;

                case DATA_STRING:
                    Expr_SetRes(this, !IsSzEqualC(per1->psz, per2->psz));
                    break;

                case DATA_BOOL:
                    Expr_SetRes(this, per1->bVal != per2->bVal);
                    break;

                default:
                    ASSERT(0);
                    break;
                    }
                break;

            case BOT_EQ:
                switch (dt)
                    {
                case DATA_INT:
                    Expr_SetRes(this, per1->nVal == per2->nVal);
                    break;

                case DATA_STRING:
                    Expr_SetRes(this, IsSzEqualC(per1->psz, per2->psz));
                    break;

                case DATA_BOOL:
                    Expr_SetRes(this, per1->bVal == per2->bVal);
                    break;

                default:
                    ASSERT(0);
                    break;
                    }
                break;

            case BOT_PLUS:
                switch (dt)
                    {
                case DATA_INT:
                    // Add two integers
                    Expr_SetRes(this, per1->nVal + per2->nVal);
                    break;

                case DATA_STRING: {
                    LPSTR psz = NULL;

                    // Concatenate strings
                    if ( !GSetString(&psz, per1->psz) ||
                         !GCatString(&psz, per2->psz))
                        {
                        // Free whatever was allocated
                        GSetString(&psz, NULL);

                        res = Stxerr_Add(pastexec->hsaStxerr, NULL, Ast_GetLine(this), RES_E_OUTOFMEMORY);
                        }

                    Expr_SetRes(this, (ULONG_PTR) psz);
                    SetFlag(this->dwFlags, EF_ALLOCATED);
                    }
                    break;

                default:
                    ASSERT(0);
                    break;
                    }
                break;

            case BOT_MINUS:
                ASSERT(DATA_INT == dt);

                Expr_SetRes(this, per1->nVal - per2->nVal);
                break;

            case BOT_MULT:
                ASSERT(DATA_INT == dt);
                
                Expr_SetRes(this, per1->nVal * per2->nVal);
                break;

            case BOT_DIV:
                ASSERT(DATA_INT == dt);
            
                if (0 == per2->nVal)    
                    res = Stxerr_Add(pastexec->hsaStxerr, NULL, Ast_GetLine(this), RES_E_DIVBYZERO);
                else
                    Expr_SetRes(this, per1->nVal / per2->nVal);
                break;

            default:
                ASSERT(0);
                res = RES_E_INVALIDPARAM;
                break;
                }
            }
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Evaluate 'getip'.

Returns: RES_OK
         RES_FALSE (if the IP address was not read yet)

Cond:    --
*/
RES PRIVATE GetIPExpr_Eval(
    PEXPR this,
    PASTEXEC pastexec,
    int nIter)
    {
    RES res;
    DWORD iDummy;

    ASSERT(this);
    ASSERT(pastexec);
    ASSERT(0 < nIter);

    TRACE_MSG(TF_ASTEXEC, "Exec: getip %d", nIter);

    // Is this function getting re-called due to a pending read?
    if ( !Astexec_IsReadPending(pastexec) )
        {
        // No; prepare to extract the nth IP address
        ClearFlag(this->dwFlags, EF_DONE);

        ASSERT(NULL == pastexec->hFindFmt);

        res = CreateFindFormat(&pastexec->hFindFmt);
        if (RSUCCEEDED(res))
            {
            res = AddFindFormat(pastexec->hFindFmt, "%u.%u.%u.%u", FFF_DEFAULT,
                               pastexec->szIP, sizeof(pastexec->szIP));
            if (RSUCCEEDED(res))
                {
                // Extract the nth IP address.
                pastexec->nIter = nIter;
                ASSERT(0 < pastexec->nIter);
                }
            }
        }

    if(NULL != pastexec->hFindFmt)
        {
        res = Astexec_FindFormat(pastexec, &iDummy);
        if (RES_OK == res)
            {
            // Allocate or resize the pointer we already have
            LPSTR psz = Expr_GetRes(this)->psz;

            if ( !GSetString(&psz, Astexec_GetIPAddr(pastexec)) )
                res = Stxerr_Add(pastexec->hsaStxerr, NULL, 
                        Ast_GetLine(this), RES_E_OUTOFMEMORY);
            else
                {
                Expr_SetRes(this, (ULONG_PTR) psz);
                SetFlag(this->dwFlags, EF_ALLOCATED);
                }
            }
        }        
    else
        {
        res = RES_E_FAIL;
        }
    
    return res;
    }    


/*----------------------------------------------------------
Purpose: Evaluates the expression and returns an integer.

Returns: RES_OK

Cond:    --
*/
RES PRIVATE UnOpExpr_Eval(
    PEXPR this,
    PASTEXEC pastexec)
    {
    RES res = RES_OK;
    PEVALRES per;
    PEXPR pexpr;
    DATATYPE dt;

    ASSERT(this);
    ASSERT(AT_UNOP_EXPR == Ast_GetType(this));

    pexpr = UnOpExpr_GetExpr(this);
    res = Expr_Eval(pexpr, pastexec);
    if (RES_OK == res)
        {
        per = Expr_GetRes(pexpr);
        dt = Expr_GetDataType(pexpr);

        switch (UnOpExpr_GetType(this))
            {
        case UOT_NEG:
            ASSERT(DATA_INT == dt);

            Expr_SetRes(this, -per->nVal);
            break;

        case UOT_NOT:
            ASSERT(DATA_BOOL == dt);

            Expr_SetRes(this, !per->bVal);
            break;

        case UOT_GETIP:
            ASSERT(DATA_INT == dt);

            if (0 < per->nVal)
                res = GetIPExpr_Eval(this, pastexec, per->nVal);
            else
                res = Stxerr_Add(pastexec->hsaStxerr, "'getip' parameter", Ast_GetLine(pexpr), RES_E_INVALIDRANGE);
            break;

        default:
            ASSERT(0);
            break;
            }
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Evaluates the expression and returns a value.

Returns: RES_OK

Cond:    --
*/
RES PUBLIC Expr_Eval(
    PEXPR this,
    PASTEXEC pastexec)
    {
    RES res;

    ASSERT(this);
    ASSERT(pastexec);

    // Has this expression already been evaluated?
    if (IsFlagSet(this->dwFlags, EF_DONE))
        {
        // Yes; just return
        res = RES_OK;
        }
    else
        {
        // No; evaluate it
        switch (Ast_GetType(this))
            {
        case AT_INT_EXPR:
            res = IntExpr_Eval(this);
            break;

        case AT_BOOL_EXPR:
            res = BoolExpr_Eval(this);
            break;

        case AT_STRING_EXPR:
            res = StrExpr_Eval(this);
            break;

        case AT_VAR_EXPR:
            res = VarExpr_Eval(this, pastexec);
            break;

        case AT_UNOP_EXPR:
            res = UnOpExpr_Eval(this, pastexec);
            break;

        case AT_BINOP_EXPR:
            res = BinOpExpr_Eval(this, pastexec);
            break;

        default:
            ASSERT(0);
            res = RES_E_INVALIDPARAM;
            break;
            }
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Execute the prolog

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE EnterStmt_Exec(
    PSTMT this,
    PASTEXEC pastexec)
    {
    ASSERT(this);
    ASSERT(pastexec);

    TRACE_MSG(TF_ASTEXEC, "Exec: enter");

    pastexec->cProcDepth++;
    pastexec->pstCur = EnterStmt_GetSymtab(this);
    ASSERT(pastexec->pstCur);

    return RES_OK;
    }


/*----------------------------------------------------------
Purpose: Execute the epilog

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE LeaveStmt_Exec(
    PSTMT this,
    PASTEXEC pastexec)
    {
    RES res;

    ASSERT(this);
    ASSERT(pastexec);

    TRACE_MSG(TF_ASTEXEC, "Exec: leave");

    ASSERT(0 < pastexec->cProcDepth);
    pastexec->cProcDepth--;
    
    pastexec->pstCur = Symtab_GetNext(pastexec->pstCur);
    ASSERT(pastexec->pstCur);

    // Leaving main procedure?
    if (0 == pastexec->cProcDepth)
        {
        // Yes
        SetFlag(pastexec->dwFlags, AEF_DONE);
        res = RES_HALT;
        }
    else
        res = RES_OK;
        
    return res;
    }


/*----------------------------------------------------------
Purpose: Execute the assignment statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE AssignStmt_Exec(
    PSTMT this,
    PASTEXEC pastexec)
    {
    RES res;
    LPSTR pszIdent;
    PSTE pste;

    ASSERT(this);
    ASSERT(pastexec);

    pszIdent = AssignStmt_GetIdent(this);
    if (RES_OK == Symtab_FindEntry(pastexec->pstCur, pszIdent, STFF_DEFAULT, &pste, NULL))
        {
        PEXPR pexpr;

        pexpr = AssignStmt_GetExpr(this);
        res = Expr_Eval(pexpr, pastexec);
        if (RES_OK == res)
            {
            PEVALRES per = Expr_GetRes(pexpr);
            DEBUG_CODE( DATATYPE dt; )

#ifdef DEBUG
            dt = Expr_GetDataType(pexpr);
            switch (dt)
                {
            case DATA_STRING:
                TRACE_MSG(TF_ASTEXEC, "Exec: %s = \"%s\"", pszIdent, per->psz);
                break;

            case DATA_INT:
                TRACE_MSG(TF_ASTEXEC, "Exec: %s = %d", pszIdent, per->nVal);
                break;

            case DATA_BOOL:
                TRACE_MSG(TF_ASTEXEC, "Exec: %s = %s", pszIdent, per->bVal ? (LPSTR)"TRUE" : (LPSTR)"FALSE");
                break;

            default:
                ASSERT(0);
                break;
                }
#endif

            pste->er.dw = per->dw;
            }
        }
    else
        {
        // The identifier should have been in the symbol table!
        ASSERT(0);
        res = RES_E_FAIL;
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Execute the 'while' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE WhileStmt_Exec(
    PSTMT this,
    PASTEXEC pastexec)
    {
    RES res;
    PEXPR pexpr;

    ASSERT(this);
    ASSERT(pastexec);

    pexpr = WhileStmt_GetExpr(this);
    res = Expr_Eval(pexpr, pastexec);
    if (RES_OK == res)
        {
        PEVALRES per = Expr_GetRes(pexpr);

        if (!per->bVal)
            {
            res = Astexec_JumpToLabel(pastexec, WhileStmt_GetEndLabel(this));
            }
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Execute the 'if' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE IfStmt_Exec(
    PSTMT this,
    PASTEXEC pastexec)
    {
    RES res;
    PEXPR pexpr;

    ASSERT(this);
    ASSERT(pastexec);

    pexpr = IfStmt_GetExpr(this);
    res = Expr_Eval(pexpr, pastexec);
    if (RES_OK == res)
        {
        PEVALRES per = Expr_GetRes(pexpr);

        if (!per->bVal)
            {
            res = Astexec_JumpToLabel(pastexec, IfStmt_GetElseLabel(this));
            }
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Execute the 'halt' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE HaltStmt_Exec(
    PSTMT this,
    PASTEXEC pastexec)
    {
    ASSERT(this);
    ASSERT(pastexec);

    TRACE_MSG(TF_ASTEXEC, "Exec: halt");

    SetFlag(pastexec->dwFlags, AEF_HALT);
    return RES_HALT;
    }


/*----------------------------------------------------------
Purpose: Execute the 'goto' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE GotoStmt_Exec(
    PSTMT this,
    PASTEXEC pastexec)
    {
    LPSTR pszIdent;

    ASSERT(this);
    ASSERT(pastexec);

    pszIdent = GotoStmt_GetIdent(this);

    TRACE_MSG(TF_ASTEXEC, "Exec: goto %s", pszIdent);

    return Astexec_JumpToLabel(pastexec, pszIdent);
    }


/*----------------------------------------------------------
Purpose: Execute the 'transmit' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE TransmitStmt_Exec(
    PSTMT this,
    PASTEXEC pastexec)
    {
    RES res;
    PEXPR pexpr;

    ASSERT(this);
    ASSERT(pastexec);

    pexpr = TransmitStmt_GetExpr(this);
    res = Expr_Eval(pexpr, pastexec);
    if (RES_OK == res)
        {
        PEVALRES per = Expr_GetRes(pexpr);
        DWORD dwFlags = TransmitStmt_GetFlags(this);
        CHAR *pszPassword;

        TRACE_MSG(TF_ASTEXEC, "Exec: transmit \"%s\"", per->psz);

#ifdef WINNT_RAS        
        //
        // JEFFSI WHISTLER
        //
        // RASSCRPT_TRACE1("Exec: transmit \"%s\"", per->psz);

        if (pszPassword = strstr(per->psz, RAS_DUMMY_PASSWORD))
            {
            CHAR *psz;
            CHAR controlchar = '\0';

            #define IS_CARET(ch)            ('^' == (ch))

            if(per->psz != pszPassword)
            {
                CHAR *pszT, *pszPrefix = LocalAlloc(LPTR, strlen(per->psz));
                if(NULL == pszPrefix)
                {
                    res = E_OUTOFMEMORY;
                    return res;
                }

                psz = per->psz;
                pszT = pszPrefix;
                while(psz != pszPassword)
                {
                    *pszT++ = *psz++;
                }

                Astexec_SendString(pastexec, pszPrefix, 
                        IsFlagSet(dwFlags, TSF_RAW));

                RASSCRPT_TRACE1("Exec: transmi \"%s\"", pszPrefix);

                LocalFree(pszPrefix);
            }
            
            //
            // Check to see if we need to send a control char
            // at the end.
            //
            psz = pszPassword + lstrlen(RAS_DUMMY_PASSWORD);

            if(IS_CARET(*psz))
            {
                psz++;
                if(!*psz)
                {
                ;
                }
                if (InRange(*psz, '@', '_'))
                    {
                    controlchar = *psz - '@';
                    }
                else if (InRange(*psz, 'a', 'z'))
                    {
                    controlchar = *psz - 'a' + 1;
                    }
            }
            
            (VOID) RxSendCreds(((SCRIPTDATA*)pastexec->hwnd)->hscript,
                               controlchar);
            }
        else
            {
            Astexec_SendString(pastexec, per->psz, IsFlagSet(dwFlags, TSF_RAW));
            }
#else
            Astexec_SendString(pastexec, per->psz, IsFlagSet(dwFlags, TSF_RAW));
#endif
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Evaluates each of the wait-case expressions.

Returns: RES_OK

Cond:    --
*/
RES PRIVATE WaitforStmt_EvalCaseList(
    PSTMT this,
    PASTEXEC pastexec)
    {
    RES res = RES_E_FAIL;
    HSA hsa = WaitforStmt_GetCaseList(this);
    DWORD i;
    DWORD ccase = SAGetCount(hsa);
    PWAITCASE pwc;

    ASSERT(0 < ccase);

    for (i = 0; i < ccase; i++)
        {
        SAGetItemPtr(hsa, i, &pwc);
        ASSERT(pwc);

        res = Expr_Eval(pwc->pexpr, pastexec);
        if (RES_OK != res)
            break;
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Packages each of the evaluated wait-case expressions
         into an array of strings to search for.

Returns: RES_OK

Cond:    --
*/
RES PRIVATE WaitforStmt_WrapEmUp(
    PSTMT this,
    HANDLE hFindFmt)
    {
    RES res = RES_OK;
    HSA hsa = WaitforStmt_GetCaseList(this);
    DWORD i;
    DWORD ccase = SAGetCount(hsa);
    PWAITCASE pwc;
    PEVALRES per;

    ASSERT(0 < ccase);

    for (i = 0; i < ccase; i++)
        {
        DWORD dwFlags = FFF_DEFAULT;

        SAGetItemPtr(hsa, i, &pwc);
        ASSERT(pwc);

        if (IsFlagSet(pwc->dwFlags, WCF_MATCHCASE))
            SetFlag(dwFlags, FFF_MATCHCASE);

        per = Expr_GetRes(pwc->pexpr);
        res = AddFindFormat(hFindFmt, per->psz, dwFlags, NULL, 0);
        if (RFAILED(res))
            break;
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Execute the then clause based upon the given case 
         index.

Returns: RES_OK

Cond:    --
*/
RES PRIVATE WaitforStmt_ExecThen(
    PSTMT this,
    DWORD isa,
    PASTEXEC pastexec)
    {
    RES res = RES_OK;
    HSA hsa = WaitforStmt_GetCaseList(this);
    PWAITCASE pwc;

    if (SAGetItemPtr(hsa, isa, &pwc))
        {
        ASSERT(pwc);

        // If there is a label, jump to it
        if (pwc->pszIdent)
            res = Astexec_JumpToLabel(pastexec, pwc->pszIdent);
        }
    else
        {
        ASSERT(0);
        res = RES_E_FAIL;
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Execute the 'waitfor' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE WaitforStmt_Exec(
    PSTMT this,
    PASTEXEC pastexec)
    {
    RES res = RES_OK;
    PEXPR pexpr;
    int nTimeoutSecs = -1;

    ASSERT(this);
    ASSERT(pastexec);

    // First evaluate the optional 'until' time
    pexpr = WaitforStmt_GetUntilExpr(this);
    if (pexpr)
        {
        res = Expr_Eval(pexpr, pastexec);
        if (RES_OK == res)
            {
            PEVALRES per = Expr_GetRes(pexpr);
            nTimeoutSecs = per->nVal;
            if (0 >= nTimeoutSecs)
                res = Stxerr_Add(pastexec->hsaStxerr, "'until' parameter", Ast_GetLine(this), RES_E_INVALIDRANGE);
            }
        }

    if (RES_OK == res)
        {
        // Evaluate the waitfor string
        res = WaitforStmt_EvalCaseList(this, pastexec);
        if (RES_OK == res)
            {
            if (-1 == nTimeoutSecs)
                TRACE_MSG(TF_ASTEXEC, "Exec: waitfor ...");
            else
                TRACE_MSG(TF_ASTEXEC, "Exec: waitfor ... until %d", nTimeoutSecs);

            // Is this function getting re-called due to a pending read?
            if ( !Astexec_IsReadPending(pastexec) )
                {
                // No; prepare to wait for the string(s)
                ASSERT(NULL == pastexec->hFindFmt);

                res = CreateFindFormat(&pastexec->hFindFmt);
                if (RSUCCEEDED(res))
                    {
                    res = WaitforStmt_WrapEmUp(this, pastexec->hFindFmt);
                    if (RSUCCEEDED(res))
                        {
                        ASSERT(IsFlagClear(pastexec->dwFlags, AEF_WAITUNTIL));
                        ASSERT(IsFlagClear(pastexec->dwFlags, AEF_STOPWAITING));
                        ASSERT(IsFlagClear(pastexec->dwFlags, AEF_PAUSED));

                        pastexec->nIter = 1;

                        if (-1 != nTimeoutSecs)
                            {
#ifndef WINNT_RAS
//
// On NT, timeouts are handled by setting dwTimeout in the SCRIPTDATA struct
// for the current script.
//

                            if (0 != SetTimer(pastexec->hwnd, TIMER_DELAY, MSECS_FROM_SECS(nTimeoutSecs), NULL))

#else // WINNT_RAS

                            ((SCRIPTDATA *)pastexec->hwnd)->dwTimeout = MSECS_FROM_SECS(nTimeoutSecs);

#endif // WINNT_RAS
                                {
                                SetFlag(pastexec->dwFlags, AEF_WAITUNTIL);
                                }
#ifndef WINNT_RAS                                
                            else
                                {
                                res = Stxerr_Add(pastexec->hsaStxerr, "waitfor", Ast_GetLine(this), RES_E_FAIL);
                                }
#endif                                
                            }
                        }
                    }
                }

            // Have we timed out yet?
            if (IsFlagSet(pastexec->dwFlags, AEF_STOPWAITING))
                {
                // Yes; don't wait for string anymore
                ClearFlag(pastexec->dwFlags, AEF_STOPWAITING);

                Astexec_SetError(pastexec, FALSE, FALSE);

                res = Astexec_DestroyFindFormat(pastexec);
                }
            else
                {
                // No; did we find a matching string?
                DWORD isa = 0;

                res = Astexec_FindFormat(pastexec, &isa);
                if (RES_OK == res)
                    {
                    // Yes; determine the next action
                    ClearFlag(pastexec->dwFlags, AEF_WAITUNTIL);

                    Astexec_SetError(pastexec, TRUE, FALSE);

                    res = WaitforStmt_ExecThen(this, isa, pastexec);
                    }
                }
            }
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Execute the 'delay' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE DelayStmt_Exec(
    PSTMT this,
    PASTEXEC pastexec)
    {
    RES res;
    PEXPR pexpr;

    ASSERT(this);
    ASSERT(pastexec);

    pexpr = DelayStmt_GetExpr(this);
    res = Expr_Eval(pexpr, pastexec);
    if (RES_OK == res)
        {
        PEVALRES per = Expr_GetRes(pexpr);

        if (0 >= per->nVal)
            res = Stxerr_Add(pastexec->hsaStxerr, "'delay' parameter", Ast_GetLine(this), RES_E_INVALIDRANGE);
        else
            {
            TRACE_MSG(TF_ASTEXEC, "Exec: delay %ld", per->nVal);

#ifndef WINNT_RAS
//
// On NT, timeouts are handled by setting dwTimeout in the SCRIPTDATA struct
// for the current script.
//

            if (0 != SetTimer(pastexec->hwnd, TIMER_DELAY, MSECS_FROM_SECS(per->nVal), NULL))

#else // WINNT_RAS

            ((SCRIPTDATA *)pastexec->hwnd)->dwTimeout = MSECS_FROM_SECS(per->nVal);

#endif // WINNT_RAS
                {
                // Success
                SetFlag(pastexec->dwFlags, AEF_PAUSED);
                }
#ifndef WINNT_RAS                
            else
                res = Stxerr_Add(pastexec->hsaStxerr, "delay", Ast_GetLine(this), RES_E_FAIL);
#endif                
            }
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Execute the 'set ipaddr' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE IPAddrData_Exec(
    PSTMT this,
    PASTEXEC pastexec)
    {
    RES res;
    PEXPR pexpr;

    ASSERT(this);
    ASSERT(pastexec);

    pexpr = SetIPStmt_GetExpr(this);
    res = Expr_Eval(pexpr, pastexec);
    if (RES_OK == res)
        {
        PEVALRES per = Expr_GetRes(pexpr);

        ASSERT(per->psz);

        TRACE_MSG(TF_ASTEXEC, "Exec: set ipaddr \"%s\"", per->psz);

        Astexec_SetIPAddr(pastexec, per->psz);
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Execute the 'set port' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE PortData_Exec(
    PSTMT this,
    PASTEXEC pastexec)
    {
    RES res = RES_OK;
    DCB dcb;
    DWORD dwFlags = SetPortStmt_GetFlags(this);

    ASSERT(this);
    ASSERT(pastexec);

#ifdef DEBUG

    if (IsFlagSet(dwFlags, SPF_DATABITS))
        TRACE_MSG(TF_ASTEXEC, "Exec: set port databits %u", SetPortStmt_GetDatabits(this));

    if (IsFlagSet(dwFlags, SPF_STOPBITS))
        TRACE_MSG(TF_ASTEXEC, "Exec: set port stopbits %u", SetPortStmt_GetStopbits(this));

    if (IsFlagSet(dwFlags, SPF_PARITY))
        TRACE_MSG(TF_ASTEXEC, "Exec: set port parity %u", SetPortStmt_GetParity(this));

#endif


#ifndef WINNT_RAS
//
// On NT, changes to port settings are done through the RasPortSetInfo API.
//

    if (GetCommState(pastexec->hport, &dcb))
        {
        if (IsFlagSet(dwFlags, SPF_DATABITS))
            dcb.ByteSize = SetPortStmt_GetDatabits(this);

        if (IsFlagSet(dwFlags, SPF_STOPBITS))
            dcb.StopBits = SetPortStmt_GetStopbits(this);

        if (IsFlagSet(dwFlags, SPF_PARITY))
            dcb.Parity = SetPortStmt_GetParity(this);

        if (!SetCommState(pastexec->hport, &dcb))
            res = Stxerr_Add(pastexec->hsaStxerr, "set port", Ast_GetLine(this), RES_E_FAIL);
        }
    else
        res = Stxerr_Add(pastexec->hsaStxerr, "set port", Ast_GetLine(this), RES_E_FAIL);

#else // WINNT_RAS

    res = (RES)RxSetPortData(
                ((SCRIPTDATA*)pastexec->hwnd)->hscript, this
                );

#endif // WINNT_RAS

    return res;
    }


/*----------------------------------------------------------
Purpose: Execute the 'set screen' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE Screen_Exec(
    PSTMT this,
    PASTEXEC pastexec)
    {
    RES res;
    DWORD dwFlags = SetScreenStmt_GetFlags(this);

    ASSERT(this);
    ASSERT(pastexec);

#ifdef DEBUG

    if (IsFlagSet(dwFlags, SPF_KEYBRD))
        TRACE_MSG(TF_ASTEXEC, "Exec: set screen keyboard %s", SetScreenStmt_GetKeybrd(this) ? "on" : "off");

#endif

    if (IsFlagSet(dwFlags, SPF_KEYBRD))
        {
#ifndef WINNT_RAS
//
// On NT, we change the keyboard state by calling RxSetKeyboard
// which will signal an event-code telling whoever started this script
// that the keyboard should be disabled.
//

        TerminalSetInput(pastexec->hwnd, SetScreenStmt_GetKeybrd(this));

#else // !WINNT_RAS

        RxSetKeyboard(
            ((SCRIPTDATA*)pastexec->hwnd)->hscript,
            SetScreenStmt_GetKeybrd(this)
            );

#endif // !WINNT_RAS
        res = RES_OK;
        }
    else
        {
        ASSERT(0);
        res = RES_E_FAIL;
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Execute the 'set' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE SetStmt_Exec(
    PSTMT this,
    PASTEXEC pastexec)
    {
    RES res;

    ASSERT(this);
    ASSERT(pastexec);

    switch (SetStmt_GetType(this))
        {
    case ST_IPADDR:
        res = IPAddrData_Exec(this, pastexec);
        break;

    case ST_PORT:
        res = PortData_Exec(this, pastexec);
        break;

    case ST_SCREEN:
        res = Screen_Exec(this, pastexec);
        break;

    default:
        ASSERT(0);
        res = RES_E_INVALIDPARAM;
        break;
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Execute a statement.  This function should not be
         called to execute a pending statement or expression.
         Ast_ExecPending should be used for that purpose.

         statements are executed--expressions are evaluated
         by the statement execs.

         The one exception is when an expression is being
         evaluated and it must wait for pending events 
         (such as more data from the port).  In this case it
         is put on the pending queue and re-executed here.

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PUBLIC Stmt_Exec(
    PSTMT this,
    PASTEXEC pastexec)
    {
    RES res;

    ASSERT(this);
    ASSERT(pastexec);

    switch (Ast_GetType(this))
        {
    case AT_ENTER_STMT:
        res = EnterStmt_Exec(this, pastexec);
        break;
        
    case AT_LEAVE_STMT:
        res = LeaveStmt_Exec(this, pastexec);
        break;

    case AT_WHILE_STMT:
        res = WhileStmt_Exec(this, pastexec);
        break;

    case AT_IF_STMT:
        res = IfStmt_Exec(this, pastexec);
        break;

    case AT_ASSIGN_STMT:
        res = AssignStmt_Exec(this, pastexec);
        break;

    case AT_HALT_STMT:
        res = HaltStmt_Exec(this, pastexec);
        break;

    case AT_TRANSMIT_STMT:
        res = TransmitStmt_Exec(this, pastexec);
        break;

    case AT_WAITFOR_STMT:
        res = WaitforStmt_Exec(this, pastexec);
        break;

    case AT_DELAY_STMT:
        res = DelayStmt_Exec(this, pastexec);
        break;

    case AT_LABEL_STMT:
        ASSERT(0);          // shouldn't really get here
        res = RES_E_FAIL;
        break;

    case AT_GOTO_STMT:
        res = GotoStmt_Exec(this, pastexec);
        break;

    case AT_SET_STMT:
        res = SetStmt_Exec(this, pastexec);
        break;

    default:
        ASSERT(0);
        res = RES_E_INVALIDPARAM;
        break;
        }

    // Was the statement completed?
    if (RES_OK == res)
        {
        // Yes; mark all the expressions in the statement as "not done"
        // so they will be evaluated from scratch if this statement
        // is executed again.
        Stmt_Clean(this);
        }

    return res;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasscrpt\ipaddr.c ===
//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//
// Copyright  1993-1995  Microsoft Corporation.  All Rights Reserved.
//
//      MODULE:         ipaddr.c
//
//      PURPOSE:        IP address handler
//
//	PLATFORMS:	Windows 95
//
//      FUNCTIONS:
//              CheckAddress()
//              ParseIPAddress()
//              ConvertIPAddress()
//              AssignIPAddress()
//
//	SPECIAL INSTRUCTIONS: N/A
//

#include "proj.h"    // includes common header files and global declarations
#include <rnap.h>

#define MAXNUMBER       80
#define MAX_IP_FIELDS   4
#define MIN_FIELD1	1	// min allowed value for field 1
#define MAX_FIELD1	223	// max allowed value for field 1
#define MIN_FIELD2	0	// min for field 2
#define MAX_FIELD2	255	// max for field 2
#define MIN_FIELD3	0	// min for field 3
#define MAX_FIELD3	254	// max for field 3
#define MIN_FIELD4      1       // 0 is reserved for broadcast
#define MIN_IP_VALUE    0       /* default minimum allowable field value */
#define MAX_IP_VALUE    255     /* default maximum allowable field value */

typedef struct tagIPaddr {
    DWORD cField;
    BYTE  bIP[MAX_IP_FIELDS];
} IPADDR, *PIPADDR;

static int atoi (LPCSTR szBuf)
{
  int   iRet = 0;

  // Find the first nonspace
  //
  while ((*szBuf == ' ') || (*szBuf == '\t'))
    szBuf++;

  while ((*szBuf >= '0') && (*szBuf <= '9'))
  {
    iRet = (iRet*10)+(int)(*szBuf-'0');
    szBuf++;
  };
  return iRet;
}

//
//
//   FUNCTION: CheckAddress (DWORD)
//
//   PURPOSE: Check an address to see if its valid.
//
//   RETURN: The first field that has an invalid value,
//           or (WORD)-1 if the address is okay.
//

DWORD CheckAddress(DWORD ip)
{
    BYTE b;

    b = HIBYTE(HIWORD(ip));
    if (b < MIN_FIELD1 || b > MAX_FIELD1 || b == 127)    return 0;
    b = LOBYTE(LOWORD(ip));
    if (b > MAX_FIELD3)    return 3;
    return (DWORD)-1;
}

//
//
//   FUNCTION: ParseIPAddress (PIPADDR, LPCSTR)
//
//   PURPOSE: parse the IP address string
//

DWORD NEAR PASCAL ParseIPAddress (PIPADDR pIPAddr, LPCSTR szIPAddress)
{
  LPCSTR szNextIP, szNext;
  char  szNumber[MAXNUMBER+1];
  int   cField, cb, iValue;

  szNext = szNextIP = szIPAddress;
  cField = 0;
  while ((*szNext) && (cField < MAX_IP_FIELDS))
  {
    // Check address separator
    //
    if (*szNext == '.')
    {
      // We have a new number
      //
      cb = (DWORD)(szNext-szNextIP);
      if ((cb > 0) && (cb <= MAXNUMBER))
      {
        lstrcpyn(szNumber, szNextIP, cb+1);
        iValue = atoi(szNumber);
        if ((iValue >= MIN_IP_VALUE) && (iValue <= MAX_IP_VALUE))
        {
          pIPAddr->bIP[cField] = (UCHAR)iValue;
          cField++;
        };
      };
      szNextIP = szNext+1;
    };
    szNext++;
  };

  // Get the last number
  //
  if (cField < MAX_IP_FIELDS)
  {
    cb = (int) (szNext-szNextIP);
    if ((cb > 0) && (cb <= MAXNUMBER))
    {
      lstrcpyn(szNumber, szNextIP, cb+1);
      iValue = atoi(szNumber);
      if ((iValue >= MIN_IP_VALUE) && (iValue <= MAX_IP_VALUE))
      {
        pIPAddr->bIP[cField] = (UCHAR) iValue;
        cField++;
      };
    };
  }
  else
  {
    // Not a valid IP address
    //
    return ERROR_INVALID_ADDRESS;
  };

  pIPAddr->cField = cField;
  return ERROR_SUCCESS;
}

//
//
//   FUNCTION: ConvertIPAddress (LPDWORD, LPCSTR)
//
//   PURPOSE: convert the IP address string to a number
//

DWORD NEAR PASCAL ConvertIPAddress (LPDWORD lpdwAddr, LPCSTR szIPAddress)
{
  IPADDR ipAddr;
  DWORD  dwIPAddr;
  DWORD  dwRet;
  DWORD  i;

  // Parse the IP address string
  //
  if ((dwRet = ParseIPAddress(&ipAddr, szIPAddress)) == ERROR_SUCCESS)
  {
    // Validate the number fields
    //
    if (ipAddr.cField == MAX_IP_FIELDS)
    {
      // Conver the IP address into one number
      //
      dwIPAddr = 0;
      for (i = 0; i < ipAddr.cField; i++)
      {
        dwIPAddr = (dwIPAddr << 8) + ipAddr.bIP[i];
      };

      // Validate the address
      //
      if (CheckAddress(dwIPAddr) > MAX_IP_FIELDS)
      {
        *lpdwAddr = dwIPAddr;
        dwRet = ERROR_SUCCESS;
      }
      else
      {
        dwRet = ERROR_INVALID_ADDRESS;
      };
    }
    else
    {
      dwRet = ERROR_INVALID_ADDRESS;
    };
  };

  return dwRet;
}

//
//
//   FUNCTION: AssignIPAddress (LPCSTR, LPCSTR)
//
//   PURPOSE: assign an IP address to the connection
//

DWORD NEAR PASCAL AssignIPAddress (LPCSTR szEntryName, LPCSTR szIPAddress)
{
  IPDATA    ipData;
  DWORD     dwIPAddr;
  DWORD     dwRet;

  // Validate and convert IP address string into a number
  //
  if ((dwRet = ConvertIPAddress(&dwIPAddr, szIPAddress))
       == ERROR_SUCCESS)
  {
    // Get the current IP settings for the connection
    //
    ipData.dwSize = sizeof(ipData);

#ifndef WINNT_RAS
//
// WINNT_RAS: the functions RnaGetIPInfo and RnaSetIPInfo don't exist on NT
//

    if ((dwRet = RnaGetIPInfo((LPSTR)szEntryName, &ipData, FALSE)) == ERROR_SUCCESS)
    {
      // We want to specify the IP address
      //
      ipData.fdwTCPIP |= IPF_IP_SPECIFIED;

      // Set the IP address
      //
      ipData.dwIPAddr = dwIPAddr;

      // Set the IP settings for the connection
      //
      dwRet = RnaSetIPInfo((LPSTR)szEntryName, &ipData);
    };
#endif // WINNT_RAS
  };

  return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasscrpt\nthdr2.h ===
//============================================================================
// Copyright (c) 1996, Microsoft Corporation
//
// File:    nthdr2.h
//
// History:
//  Abolade-Gbadegesin  04-02-96    Created.
//
// This file contains macros to hide differences in implementation
// of the scripting between Win9x and Windows NT
//============================================================================

#ifndef _NTHDR2_H_
#define _NTHDR2_H_


//----------------------------------------------------------------------------
// Struct:      SCRIPTDATA
//
// The following structure is designed to be a subset of the TERMDLG struct
// in terminal.c.
//
// The structure has fields whose names are the same as corresponding fields
// in the TERMDLG struct. The only fields reproduced here are those which
// pertain to the Win9x script-processing.
//
// This is done in order to minimize changes to the Win9x code, since
// we can then pass the structure below to ReadIntoBuffer() and FindFormat(),
// thankfully eliminating the need to edit the code for either function.
//----------------------------------------------------------------------------

#define SCRIPTDATA  struct tagSCRIPTDATA
SCRIPTDATA {

    //
    // Handle to script for this SCRIPTDATA,
    // and current timeout, if any
    //
    HANDLE          hscript;
    DWORD           dwTimeout;


    //
    // Send and receive buffers
    //
    BYTE            pbReceiveBuf[SIZE_RecvBuffer];
    BYTE            pbSendBuf[SIZE_SendBuffer];


    //
    // Current search position index
    // 
    UINT            ibCurFind;


    //
    // Pointer to tail of buffer (into which new data will be read)
    //
    UINT            ibCurRead;


    //
    // Count of total bytes received since the session began
    //
    UINT            cbReceiveMax;


    //
    // Variables containing the script-processing control information;
    //  the scanner which reads the script file,
    //  the parsed module-declaration containing the "main" procedure,
    //  the script-execution handler control block,
    //  and the script information (including the path)
    //
    SCANNER*        pscanner;
    MODULEDECL*     pmoduledecl;
    ASTEXEC*        pastexec;
    SCRIPT          script;
};



BOOL
PRIVATE
ReadIntoBuffer(
    IN  SCRIPTDATA* pdata,
    OUT PDWORD      pibStart,
    OUT PDWORD      pcbRead
    );


#endif // _NTHDR2_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasscrpt\parser.c ===
//
// Copyright (c) Microsoft Corporation 1995
//
// parser.c
//
// This file contains the parsing functions.
//
// Conventions:
//
//   <Foo>      where Foo is a non-terminal
//   { Bar }    where there are 0 or more occurrences of Bar
//   "x"        where x is the literal character/string
//   CAPS       where CAPS is a token type
//
// The grammar is as follows:
//
//  <ModuleDecl>    ::= { <ProcDecl> }
//  <ProcDecl>      ::= proc IDENT { <VarDecl> } <StmtBlock> endproc
//  <VarDecl>       ::= <VarType> IDENT [ = <Expr> ]
//  <VarType>       ::= integer | string | boolean
//
//  <StmtBlock>     ::= { <Stmt> }
//  <Stmt>          ::= <HaltStmt> | <WaitforStmt> | <TransmitStmt> |
//                      <DelayStmt> | <SetStmt> | <LabelStmt> |
//                      <GotoStmt> | <AssignStmt> | <WhileStmt> |
//                      <IfStmt>
//
//  <HaltStmt>      ::= halt
//  <WaitforStmt>   ::= waitfor <Expr> [ , matchcase ]
//                       [ then IDENT 
//                          { , <Expr> [ , matchcase ] then IDENT } ]
//                       [ until <Expr> ]
//  <TransmitStmt>  ::= transmit <Expr> [ , raw ]
//  <DelayStmt>     ::= delay <Expr>
//  <SetStmt>       ::= set <SetParam>
//  <AssignStmt>    ::= IDENT = <Expr>
//  <LabelStmt>     ::= IDENT :
//  <GotoStmt>      ::= goto IDENT
//  <WhileStmt>     ::= while <Expr> do <StmtBlock> endwhile
//  <IfStmt>        ::= if <Expr> then <StmtBlock> endif
//
//  <SetParam>      ::= ipaddr <Expr> | port <PortData> |
//                      screen <ScreenSet>
//  <PortData>      ::= databits <DataBitsExpr> | parity <ParityExpr> |
//                      stopbits <StopBitsExpr>
//  <ScreenSet>     ::= keyboard <KeybrdExpr>
//
//  <ExprList>      ::= <Expr> { , <Expr> }
//  <Expr>          ::= <ConjExpr> { or <ConjExpr> }
//  <ConjExpr>      ::= <TestExpr> { and <TestExpr> }
//  <TestExpr>      ::= <Sum> <RelOp> <Sum> | <Sum>
//  <RelOp>         ::= <= | != | < | >= | > | ==
//  <Sum>           ::= <Term> { (+|-) <Term> }
//  <Term>          ::= <Factor> { (*|/) <Factor> }
//  <Factor>        ::= - <Factor> | INT | "(" <Expr> ")" | IDENT |
//                      STRING | <GetIPExpr> | "TRUE" | "FALSE" |
//                      ! <Factor>
//  <GetIPExpr>     ::= getip [ <Expr> ]
//
//  <DataBitsExpr>  ::= 5 | 6 | 7 | 8
//  <ParityExpr>    ::= none | odd | even | mark | space
//  <StopBitsExpr>  ::= 1 | 2
//  <KeybrdExpr>    ::= on | off
//
//
// History:
//  05-20-95 ScottH     Created
//


#include "proj.h"
#include "rcids.h"

RES     PRIVATE StmtBlock_Parse(HPA hpa, PSCANNER pscanner, PSYMTAB pstProc, SYM symEnd);


/*----------------------------------------------------------
Purpose: Parses the next token as an identifier.  If the 
         token is an identifier, it is returned in *pptok
         and the function returns RES_OK.

         Otherwise, *pptok is NULL and an error is returned.

Returns: RES_OK
         RES_E_IDENTMISSING

Cond:    The caller must destroy *pptok if RES_OK is returned.

*/
RES PRIVATE Ident_Parse(
    PSCANNER pscanner,
    PTOK * pptok)
    {
    RES res;
    PTOK ptok;

    *pptok = NULL;

    res = Scanner_GetToken(pscanner, &ptok);
    if (RSUCCEEDED(res))
        {
        if (SYM_IDENT == Tok_GetSym(ptok))
            {
            res = RES_OK;
            *pptok = ptok;
            }
        else
            {
            res = Scanner_AddError(pscanner, NULL, RES_E_IDENTMISSING);
            Tok_Delete(ptok);
            }
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Adds an identifier to the symbol table.  If the 
         identifier has already been defined in this scope,
         this function adds the error to the error list,
         and returns the error value.

Returns: RES_OK

         RES_E_REDEFINED
         RES_E_OUTOFMEMORY

Cond:    --
*/
RES PRIVATE Ident_Add(
    LPCSTR pszIdent,
    DATATYPE dt,
    PTOK ptok,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;

    // Is this identifier unique?
    if (RES_OK == Symtab_FindEntry(pst, pszIdent, STFF_DEFAULT, NULL, NULL))
        {
        // No; we have a redefinition
        res = Scanner_AddError(pscanner, ptok, RES_E_REDEFINED);
        }
    else
        {
        // Yes; add to symbol table
        PSTE pste;

        res = STE_Create(&pste, pszIdent, dt);
        if (RSUCCEEDED(res))
            {
            res = Symtab_InsertEntry(pst, pste);
            }
        }

    return res;
    }


           

//
// Exprs
//

RES PRIVATE Expr_Parse(PEXPR * ppexpr, PSCANNER pscanner, PSYMTAB pst);


/*----------------------------------------------------------
Purpose: Look ahead to see if the next token indicates an
         expression of some kind.

Returns: TRUE if the next token is a leader to an expression

Cond:    --
*/
BOOL PRIVATE IsExprSneakPeek(
    PSCANNER pscanner)
    {
    BOOL bRet;
    SYM sym;

    Scanner_Peek(pscanner, &sym);
    switch (sym)
        {
    case SYM_MINUS:
    case SYM_NOT:
    case SYM_INT_LITERAL:
    case SYM_LPAREN:
    case SYM_STRING_LITERAL:
    case SYM_GETIP:
    case SYM_IDENT:
    case SYM_TRUE:
    case SYM_FALSE:
        bRet = TRUE;
        break;

    default:
        bRet = FALSE;
        break;
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Parses a factor expression.

         Grammar is:

                <Factor>        ::= - <Factor> | INT | "(" <Expr> ")" | IDENT |
                                    STRING | <GetIPExpr> | TRUE | FALSE |
                                    ! <Factor>
                <GetIPExpr>     ::= getip [ <Expr> ]

Returns: RES_OK

Cond:    --
*/
RES PRIVATE FactorExpr_Parse(
    PEXPR * ppexpr,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    PEXPR pexpr;
    PTOK ptok;
    DWORD iLine = Scanner_GetLine(pscanner);

    DBG_ENTER(FactorExpr_Parse);

    ASSERT(ppexpr);
    ASSERT(pscanner);

    *ppexpr = NULL;

    if (RES_OK == Scanner_CondReadToken(pscanner, SYM_MINUS, NULL))
        {
        // Negation
        res = FactorExpr_Parse(&pexpr, pscanner, pst);
        if (RSUCCEEDED(res))
            {
            res = UnOpExpr_New(ppexpr, UOT_NEG, pexpr, iLine);

            if (RFAILED(res))
                Expr_Delete(pexpr);
            }
        }
    else if (RES_OK == Scanner_CondReadToken(pscanner, SYM_NOT, NULL))
        {
        // One's complement
        res = FactorExpr_Parse(&pexpr, pscanner, pst);
        if (RSUCCEEDED(res))
            {
            res = UnOpExpr_New(ppexpr, UOT_NOT, pexpr, iLine);

            if (RFAILED(res))
                Expr_Delete(pexpr);
            }
        }
    else if (RES_OK == Scanner_CondReadToken(pscanner, SYM_LPAREN, NULL))
        {
        // "("
        res = Expr_Parse(ppexpr, pscanner, pst);
        if (RSUCCEEDED(res))
            {
            if (RES_OK != Scanner_ReadToken(pscanner, SYM_RPAREN))
                {
                Expr_Delete(*ppexpr);

                res = Scanner_AddError(pscanner, NULL, RES_E_RPARENMISSING);
                }
            }
        }
    else if (RES_OK == Scanner_CondReadToken(pscanner, SYM_INT_LITERAL, &ptok))
        {
        // Integer literal
        res = IntExpr_New(ppexpr, TokInt_GetVal(ptok), iLine);

        Tok_Delete(ptok);
        }
    else if (RES_OK == Scanner_CondReadToken(pscanner, SYM_STRING_LITERAL, &ptok))
        {
        res = StrExpr_New(ppexpr, TokSz_GetSz(ptok), iLine);

        Tok_Delete(ptok);
        }
    else if (RES_OK == Scanner_CondReadToken(pscanner, SYM_TRUE, &ptok))
        {
        res = BoolExpr_New(ppexpr, TRUE, iLine);

        Tok_Delete(ptok);
        }
    else if (RES_OK == Scanner_CondReadToken(pscanner, SYM_FALSE, &ptok))
        {
        res = BoolExpr_New(ppexpr, FALSE, iLine);

        Tok_Delete(ptok);
        }
    else if (RES_OK == Scanner_CondReadToken(pscanner, SYM_IDENT, &ptok))
        {
        res = VarExpr_New(ppexpr, Tok_GetLexeme(ptok), iLine);

        Tok_Delete(ptok);
        }
    else if (RES_OK == Scanner_CondReadToken(pscanner, SYM_GETIP, NULL))
        {
        // 'getip'

        // Parse optional nth parameter
        if (IsExprSneakPeek(pscanner))
            {
            res = Expr_Parse(&pexpr, pscanner, pst);
            if (RSUCCEEDED(res))
                {
                res = UnOpExpr_New(ppexpr, UOT_GETIP, pexpr, iLine);
                }
            }
        else
            {
            // Default to 1st IP address
            res = IntExpr_New(&pexpr, 1, iLine);
            if (RSUCCEEDED(res))
                res = UnOpExpr_New(ppexpr, UOT_GETIP, pexpr, iLine);
            }
        }
    else
        res = Scanner_AddError(pscanner, NULL, RES_E_SYNTAXERROR);

    DBG_EXIT_RES(FactorExpr_Parse, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Parses a term expression.

         Grammar is:

                <Term>          ::= <Factor> { (*|/) <Factor> }

Returns: RES_OK

Cond:    --
*/
RES PRIVATE TermExpr_Parse(
    PEXPR * ppexpr,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    PEXPR pexpr1;

    DBG_ENTER(TermExpr_Parse);

    ASSERT(ppexpr);
    ASSERT(pscanner);

    *ppexpr = NULL;

    // Parse factor expression
    res = FactorExpr_Parse(&pexpr1, pscanner, pst);
    if (RSUCCEEDED(res))
        {
        DWORD iLine = Scanner_GetLine(pscanner);
        PEXPR pexprTerm = pexpr1;
        SYM sym;

        // Parse optional factor operator
        Scanner_Peek(pscanner, &sym);

        while (SYM_MULT == sym || SYM_DIV == sym)
            {
            PEXPR pexpr2;

            Scanner_ReadToken(pscanner, sym);

            res = FactorExpr_Parse(&pexpr2, pscanner, pst);
            if (RSUCCEEDED(res))
                {
                BINOPTYPE binoptype = sym - SYM_PLUS + BOT_PLUS;

                res = BinOpExpr_New(&pexprTerm, binoptype, pexpr1, pexpr2, iLine);

                if (RFAILED(res))
                    {
                    Expr_Delete(pexpr2);
                    break;
                    }
                }
            else
                break;

            pexpr1 = pexprTerm;
            Scanner_Peek(pscanner, &sym);
            }

        if (RFAILED(res))
            {
            Expr_Delete(pexpr1);            // pexpr1 by design
            pexprTerm = NULL;               // pexprTerm by design
            }

        *ppexpr = pexprTerm;
        }

    DBG_EXIT_RES(TermExpr_Parse, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Parses a sum expression.

         Grammar is:

                <Sum>           ::= <Term> { (+|-) <Term> }

Returns: RES_OK

Cond:    --
*/
RES PRIVATE SumExpr_Parse(
    PEXPR * ppexpr,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    PEXPR pexpr1;

    DBG_ENTER(SumExpr_Parse);

    ASSERT(ppexpr);
    ASSERT(pscanner);

    *ppexpr = NULL;

    // Parse term expression
    res = TermExpr_Parse(&pexpr1, pscanner, pst);
    if (RSUCCEEDED(res))
        {
        DWORD iLine = Scanner_GetLine(pscanner);
        PEXPR pexprSum = pexpr1;
        SYM sym;

        // Parse optional sum operator
        Scanner_Peek(pscanner, &sym);

        while (SYM_PLUS == sym || SYM_MINUS == sym)
            {
            PEXPR pexpr2;

            Scanner_ReadToken(pscanner, sym);

            res = TermExpr_Parse(&pexpr2, pscanner, pst);
            if (RSUCCEEDED(res))
                {
                BINOPTYPE binoptype = sym - SYM_PLUS + BOT_PLUS;

                res = BinOpExpr_New(&pexprSum, binoptype, pexpr1, pexpr2, iLine);

                if (RFAILED(res))
                    {
                    Expr_Delete(pexpr2);
                    break;
                    }
                }
            else
                break;

            pexpr1 = pexprSum;
            Scanner_Peek(pscanner, &sym);
            }

        if (RFAILED(res))
            {
            Expr_Delete(pexpr1);
            pexprSum = NULL;
            }

        *ppexpr = pexprSum;
        }

    DBG_EXIT_RES(SumExpr_Parse, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Parses a test expression.

         Grammar is:

                <TestExpr>      ::= <Sum> <RelOp> <Sum> | <Sum>
                <RelOp>         ::= <= | != | < | >= | > | ==

Returns: RES_OK

Cond:    --
*/
RES PRIVATE TestExpr_Parse(
    PEXPR * ppexpr,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    PEXPR pexpr;

    DBG_ENTER(TestExpr_Parse);

    ASSERT(ppexpr);
    ASSERT(pscanner);

    *ppexpr = NULL;

    // Parse sum expression
    res = SumExpr_Parse(&pexpr, pscanner, pst);
    if (RSUCCEEDED(res))
        {
        DWORD iLine = Scanner_GetLine(pscanner);
        PEXPR pexpr2;
        SYM sym;

        // Parse optional relational operator
        Scanner_Peek(pscanner, &sym);
        switch (sym)
            {
        case SYM_LEQ:
        case SYM_NEQ:
        case SYM_LT:
        case SYM_GEQ:
        case SYM_GT:
        case SYM_EQ:
            Scanner_ReadToken(pscanner, sym);

            res = SumExpr_Parse(&pexpr2, pscanner, pst);
            if (RSUCCEEDED(res))
                {
                BINOPTYPE binoptype = sym - SYM_LEQ + BOT_LEQ;

                res = BinOpExpr_New(ppexpr, binoptype, pexpr, pexpr2, iLine);

                if (RFAILED(res))
                    Expr_Delete(pexpr2);
                }
            break;

        default:
            *ppexpr = pexpr;
            break;
            }

        if (RFAILED(res))
            Expr_Delete(pexpr);
        }

    DBG_EXIT_RES(TestExpr_Parse, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Parses a conjunction expression.

         Grammar is:

            <ConjExpr>      ::= <TestExpr> { and <TestExpr> }

Returns: RES_OK

Cond:    --
*/
RES PRIVATE ConjExpr_Parse(
    PEXPR * ppexpr,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    PEXPR pexpr1;

    DBG_ENTER(ConjExpr_Parse);

    ASSERT(ppexpr);
    ASSERT(pscanner);

    *ppexpr = NULL;

    // Parse test expression
    res = TestExpr_Parse(&pexpr1, pscanner, pst);
    if (RSUCCEEDED(res))
        {
        DWORD iLine = Scanner_GetLine(pscanner);
        PEXPR pexprConj = pexpr1;
        SYM sym;

        Scanner_Peek(pscanner, &sym);

        while (SYM_AND == sym)
            {
            PEXPR pexpr2;

            Scanner_ReadToken(pscanner, sym);

            res = TestExpr_Parse(&pexpr2, pscanner, pst);
            if (RSUCCEEDED(res))
                {
                res = BinOpExpr_New(&pexprConj, BOT_AND, pexpr1, pexpr2, iLine);

                if (RFAILED(res))
                    {
                    Expr_Delete(pexpr2);
                    break;
                    }
                }
            else
                break;

            pexpr1 = pexprConj;
            Scanner_Peek(pscanner, &sym);
            }

        if (RFAILED(res))
            {
            Expr_Delete(pexpr1);
            pexprConj = NULL;
            }

        *ppexpr = pexprConj;
        }

    DBG_EXIT_RES(ConjExpr_Parse, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Parses an expression.

         Grammar is:

            <Expr>          ::= <ConjExpr> { or <ConjExpr> }

Returns: RES_OK

Cond:    --
*/
RES PRIVATE Expr_Parse(
    PEXPR * ppexpr,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    PEXPR pexpr1;

    DBG_ENTER(Expr_Parse);

    ASSERT(ppexpr);
    ASSERT(pscanner);

    *ppexpr = NULL;

    // Parse conjunction expression
    res = ConjExpr_Parse(&pexpr1, pscanner, pst);
    if (RSUCCEEDED(res))
        {
        DWORD iLine = Scanner_GetLine(pscanner);
        PEXPR pexprDisj = pexpr1;
        SYM sym;

        // Parse optional 'or'
        Scanner_Peek(pscanner, &sym);

        while (SYM_OR == sym)
            {
            PEXPR pexpr2;

            Scanner_ReadToken(pscanner, sym);

            res = ConjExpr_Parse(&pexpr2, pscanner, pst);
            if (RSUCCEEDED(res))
                {
                res = BinOpExpr_New(&pexprDisj, BOT_OR, pexpr1, pexpr2, iLine);

                if (RFAILED(res))
                    {
                    Expr_Delete(pexpr2);
                    break;
                    }
                }
            else
                break;

            pexpr1 = pexprDisj;
            Scanner_Peek(pscanner, &sym);
            }

        if (RFAILED(res))
            {
            Expr_Delete(pexpr1);
            pexprDisj = NULL;
            }

        *ppexpr = pexprDisj;
        }

    DBG_EXIT_RES(Expr_Parse, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Parses the 'set port' statement

         Grammar is:

            <PortData>      ::= databits <DataBitsExpr> | parity <ParityExpr> |
                                stopbits <StopBitsExpr>

            <DataBitsExpr>  ::= 5 | 6 | 7 | 8
            <ParityExpr>    ::= none | odd | even | mark | space
            <StopBitsExpr>  ::= 1 | 2

Returns: RES_OK

Cond:    --
*/
RES PRIVATE PortData_Parse(
    PSTMT * ppstmt,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    DWORD iLine = Scanner_GetLine(pscanner);
    PORTSTATE ps;
    PTOK ptok;

    DBG_ENTER(PortData_Parse);

    ASSERT(ppstmt);
    ASSERT(pscanner);

    // Parse 'databits'
    if (RES_OK == Scanner_CondReadToken(pscanner, SYM_DATABITS, NULL))
        {
        ps.dwFlags = SPF_DATABITS;

        // Parse 5 | 6 | 7 | 8

        res = Scanner_GetToken(pscanner, &ptok);
        if (RSUCCEEDED(res))
            {
            if (TT_INT == Tok_GetType(ptok))
                {
                DWORD dwVal = TokInt_GetVal(ptok);

                if (InRange(dwVal, 5, 8))
                    {
                    // Create object
                    ps.nDatabits = LOBYTE(LOWORD(dwVal));

                    res = SetPortStmt_New(ppstmt, &ps, iLine);
                    }
                else
                    res = Scanner_AddError(pscanner, ptok, RES_E_INVALIDRANGE);
                }
            else
                res = Scanner_AddError(pscanner, ptok, RES_E_SYNTAXERROR);

            Tok_Delete(ptok);
            }
        else
            res = Scanner_AddError(pscanner, ptok, RES_E_INTMISSING);
        }

    // Parse 'parity'
    else if (RES_OK == Scanner_CondReadToken(pscanner, SYM_PARITY, NULL))
        {
        SYM sym;

        ps.dwFlags = SPF_PARITY;

        res = RES_OK;       // assume success

        Scanner_Peek(pscanner, &sym);
        switch (sym)
            {
        case SYM_NONE:
            ps.nParity = NOPARITY;
            break;

        case SYM_ODD:
            ps.nParity = ODDPARITY;
            break;

        case SYM_EVEN:
            ps.nParity = EVENPARITY;
            break;

        case SYM_MARK:
            ps.nParity = MARKPARITY;
            break;

        case SYM_SPACE:
            ps.nParity = SPACEPARITY;
            break;

        default:
            res = Scanner_AddError(pscanner, NULL, RES_E_SYNTAXERROR);
            break;
            }

        if (RES_OK == res)
            {
            res = SetPortStmt_New(ppstmt, &ps, iLine);

            // eat token
            Scanner_GetToken(pscanner, &ptok);
            Tok_Delete(ptok);
            }
        }

    else if (RES_OK == Scanner_CondReadToken(pscanner, SYM_STOPBITS, NULL))
        {
        PTOK ptok;

        ps.dwFlags = SPF_STOPBITS;

        // Parse 1 | 2

        res = Scanner_GetToken(pscanner, &ptok);
        if (RSUCCEEDED(res))
            {
            if (TT_INT == Tok_GetType(ptok))
                {
                DWORD dwVal = TokInt_GetVal(ptok);

                if (InRange(dwVal, 1, 2))
                    {
                    // Create object
                    ps.nStopbits = LOBYTE(LOWORD(dwVal));

                    res = SetPortStmt_New(ppstmt, &ps, iLine);
                    }
                else
                    res = Scanner_AddError(pscanner, ptok, RES_E_INVALIDRANGE);
                }
            else
                res = Scanner_AddError(pscanner, ptok, RES_E_SYNTAXERROR);

            Tok_Delete(ptok);
            }
        else
            res = Scanner_AddError(pscanner, ptok, RES_E_INTMISSING);
        }

    else
        res = Scanner_AddError(pscanner, NULL, RES_E_INVALIDPORTPARAM);

    DBG_EXIT_RES(PortData_Parse, res);

    return res;
    }

/*----------------------------------------------------------
Purpose: Parses the 'set screen' statement

         Grammar is:

            <ScreenSet>     ::= keyboard <KeybrdExpr>

            <KeybrdExpr>    ::= on | off

Returns: RES_OK

Cond:    --
*/
RES PRIVATE ScreenSet_Parse(
    PSTMT * ppstmt,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    DWORD iLine = Scanner_GetLine(pscanner);
    SCREENSET ss;
    PTOK ptok;

    DBG_ENTER(ScreenSet_Parse);

    ASSERT(ppstmt);
    ASSERT(pscanner);

    // Parse 'keyboard'
    if (RES_OK == Scanner_CondReadToken(pscanner, SYM_KEYBRD, NULL))
        {
        SYM sym;

        ss.dwFlags = SPF_KEYBRD;

        res = RES_OK;       // assume success

        Scanner_Peek(pscanner, &sym);
        switch (sym)
            {
        case SYM_ON:
            ss.fKBOn = TRUE;
            break;

        case SYM_OFF:
            ss.fKBOn = FALSE;
            break;

        default:
            res = Scanner_AddError(pscanner, NULL, RES_E_SYNTAXERROR);
            break;
            }

        if (RES_OK == res)
            {
            res = SetScreenStmt_New(ppstmt, &ss, iLine);

            // eat token
            Scanner_GetToken(pscanner, &ptok);
            Tok_Delete(ptok);
            }
        }
    else
        res = Scanner_AddError(pscanner, NULL, RES_E_INVALIDSCRNPARAM);

    DBG_EXIT_RES(ScreenSet_Parse, res);

    return res;
    }


// 
// Stmt
//


/*----------------------------------------------------------
Purpose: Parse the case-portion of the 'waitfor' statement.
         This portion is:

                 <Expr> [ , matchcase ] [ then IDENT ]

         and:

                 <Expr> [ , matchcase ] then IDENT

         Set bThenOptional to TRUE to parse the first case,
         FALSE to parse the second case.

Returns: RES_OK
         RES_FALSE (if bThenOptional and "[ then IDENT ]" was not parsed)

Cond:    --
*/
RES PUBLIC WaitforStmt_ParseCase(
    HSA hsa,
    PSCANNER pscanner,
    PSYMTAB pst,
    BOOL bThenOptional)
    {
    RES res;
    PEXPR pexpr;

    // Parse string expression
    res = Expr_Parse(&pexpr, pscanner, pst);
    if (RSUCCEEDED(res))
        {
        BOOL bParseThen;
        DWORD dwFlags = WCF_DEFAULT;

        // Parse optional ", matchcase"
        if (RES_OK == Scanner_CondReadToken(pscanner, SYM_COMMA, NULL))
            {
            if (RES_OK == Scanner_ReadToken(pscanner, SYM_MATCHCASE))
                SetFlag(dwFlags, WCF_MATCHCASE);
            else
                res = Scanner_AddError(pscanner, NULL, RES_E_SYNTAXERROR);
            }

        // Is 'then IDENT' optional?
        if (bThenOptional)
            {
            // Yes; determine whether to parse it
            SYM sym;

            Scanner_Peek(pscanner, &sym);
            bParseThen = (SYM_THEN == sym);
            if (!bParseThen)
                res = RES_FALSE;
            }
        else
            {
            // No; we don't have a choice, parse it
            bParseThen = TRUE;
            }

        if (bParseThen)
            {
            res = Scanner_ReadToken(pscanner, SYM_THEN);
            if (RSUCCEEDED(res))
                {
                PTOK ptok;

                // Parse identifier
                res = Ident_Parse(pscanner, &ptok);
                if (RSUCCEEDED(res))
                    {
                    // (Wait until typechecking phase to check for 
                    // existence of identifier)
                    LPSTR pszIdent = Tok_GetLexeme(ptok);

                    // Add this case to the list
                    res = Waitcase_Add(hsa, pexpr, pszIdent, dwFlags);

                    Tok_Delete(ptok);
                    }   
                }
            else
                res = Scanner_AddError(pscanner, NULL, RES_E_SYNTAXERROR);
            }
        else
            {
            // Add this case to the list
            res = Waitcase_Add(hsa, pexpr, NULL, dwFlags);
            }
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Parses the 'waitfor' statement

         Grammar is:

            <WaitforStmt>   ::= waitfor <Expr> [ , matchcase ]
                                 [ then IDENT 
                                    { , <Expr> [ , matchcase ] then IDENT } ]
                                 [ until <Expr> ]

Returns: RES_OK

Cond:    --
*/
RES PRIVATE WaitforStmt_Parse(
    PSTMT * ppstmt,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    DWORD iLine;
    HSA hsa;

    DBG_ENTER(WaitforStmt_Parse);

    ASSERT(ppstmt);
    ASSERT(pscanner);
    ASSERT(pst);

    iLine = Scanner_GetLine(pscanner);
    *ppstmt = NULL;

    // Parse 'waitfor'
    res = Scanner_ReadToken(pscanner, SYM_WAITFOR);
    ASSERT(RES_OK == res);

    res = Waitcase_Create(&hsa);
    if (RSUCCEEDED(res))
        {
        // Parse <Expr> [ , matchcase ] [ then IDENT { , <Expr> [ , matchcase ] then IDENT } ]

        // (Note we explicitly check for RES_OK only)
        res = WaitforStmt_ParseCase(hsa, pscanner, pst, TRUE);
        if (RES_OK == res)
            {
            // Parse { , <Expr> then IDENT }
            while (RES_OK == Scanner_CondReadToken(pscanner, SYM_COMMA, NULL))
                {
                res = WaitforStmt_ParseCase(hsa, pscanner, pst, FALSE);
                if (RFAILED(res))
                    break;
                }
            }

        if (RSUCCEEDED(res))
            {
            PEXPR pexprUntil = NULL;

            // Parse optional 'until <Expr>'
            if (RES_OK == Scanner_CondReadToken(pscanner, SYM_UNTIL, NULL))
                {
                res = Expr_Parse(&pexprUntil, pscanner, pst);
                }

            if (RSUCCEEDED(res))
                {
                // Create object
                res = WaitforStmt_New(ppstmt, hsa, pexprUntil, iLine);
                }
            }

        if (RFAILED(res))
            Waitcase_Destroy(hsa);
        }

    DBG_EXIT_RES(WaitforStmt_Parse, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Parses the 'transmit' statement

         Grammar is:

            <TransmitStmt>  ::= transmit <Expr> [ , raw ]

Returns: RES_OK

Cond:    --
*/
RES PRIVATE TransmitStmt_Parse(
    PSTMT * ppstmt,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    PEXPR pexpr;
    DWORD iLine;
    DWORD dwFlags = TSF_DEFAULT;

    DBG_ENTER(TransmitStmt_Parse);

    ASSERT(ppstmt);
    ASSERT(pscanner);
    ASSERT(pst);

    iLine = Scanner_GetLine(pscanner);
    *ppstmt = NULL;

    // Parse 'transmit'
    res = Scanner_ReadToken(pscanner, SYM_TRANSMIT);
    ASSERT(RES_OK == res);

    // Parse string expression
    res = Expr_Parse(&pexpr, pscanner, pst);
    if (RSUCCEEDED(res))
        {
        // Parse optional ", raw" parameter
        if (RES_OK == Scanner_CondReadToken(pscanner, SYM_COMMA, NULL))
            {
            if (RSUCCEEDED(Scanner_ReadToken(pscanner, SYM_RAW)))
                SetFlag(dwFlags, TSF_RAW);
            else
                res = Scanner_AddError(pscanner, NULL, RES_E_SYNTAXERROR);
            }

        if (RSUCCEEDED(res))
            {
            // Create object
            res = TransmitStmt_New(ppstmt, pexpr, dwFlags, iLine);
            }
        }
    else
        res = Scanner_AddError(pscanner, NULL, RES_E_STRINGMISSING);

    DBG_EXIT_RES(TransmitStmt_Parse, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Parses the 'delay' statement

         Grammar is:

            <DelayStmt>     ::= delay <Expr>

Returns: RES_OK

Cond:    --
*/
RES PRIVATE DelayStmt_Parse(
    PSTMT * ppstmt,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    PEXPR pexpr;
    DWORD iLine = Scanner_GetLine(pscanner);

    DBG_ENTER(DelayStmt_Parse);

    ASSERT(ppstmt);
    ASSERT(pscanner);
    ASSERT(pst);

    *ppstmt = NULL;

    // Parse 'delay'
    res = Scanner_ReadToken(pscanner, SYM_DELAY);
    ASSERT(RES_OK == res);

    // Parse expression
    res = Expr_Parse(&pexpr, pscanner, pst);
    if (RSUCCEEDED(res))
        {
        res = DelayStmt_New(ppstmt, pexpr, iLine);
        }

    DBG_EXIT_RES(DelayStmt_Parse, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Parses the 'while' statement

         Grammar is:

            <WhileStmt>     ::= while <Expr> do <StmtBlock> endwhile

Returns: RES_OK

Cond:    --
*/
RES PRIVATE WhileStmt_Parse(
    PSTMT * ppstmt,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    PEXPR pexpr;
    DWORD iLine;
    HPA hpa;

    DBG_ENTER(WhileStmt_Parse);

    ASSERT(ppstmt);
    ASSERT(pscanner);
    ASSERT(pst);

    iLine = Scanner_GetLine(pscanner);
    *ppstmt = NULL;

    if (PACreate(&hpa, 8))
        {
        // Parse 'while'
        res = Scanner_ReadToken(pscanner, SYM_WHILE);
        ASSERT(RES_OK == res);

        // Parse <Expr>
        res = Expr_Parse(&pexpr, pscanner, pst);
        if (RSUCCEEDED(res))
            {
            // Parse 'do'
            res = Scanner_ReadToken(pscanner, SYM_DO);
            if (RSUCCEEDED(res))
                {
                char szTop[MAX_BUF_KEYWORD];
                char szEnd[MAX_BUF_KEYWORD];

                // Generate unique label names
                res = Symtab_NewLabel(pst, szTop);
                if (RSUCCEEDED(res))
                    {
                    res = Symtab_NewLabel(pst, szEnd);
                    if (RSUCCEEDED(res))
                        {
                        // Parse statement block
                        res = StmtBlock_Parse(hpa, pscanner, pst, SYM_ENDWHILE);

                        if (RSUCCEEDED(res))
                            {
                            PSTMT pstmtT;

                            // Add a goto statement to loop to the top again
                            res = GotoStmt_New(&pstmtT, szTop, Scanner_GetLine(pscanner));
                            if (RSUCCEEDED(res))
                                {
                                if (!PAInsertPtr(hpa, PA_APPEND, pstmtT))
                                    res = RES_E_OUTOFMEMORY;
                                else
                                    {
                                    // Create object
                                    res = WhileStmt_New(ppstmt, pexpr, hpa, szTop, szEnd, iLine);
                                    }
                                }
                            }
                        }
                    }
                }
            else
                res = Scanner_AddError(pscanner, NULL, RES_E_SYNTAXERROR);
            }
        }
    else
        res = RES_E_OUTOFMEMORY;


    DBG_EXIT_RES(WhileStmt_Parse, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Parses the 'if' statement

         Grammar is:

            <IfStmt>        ::= if <Expr> then <StmtBlock> endif

Returns: RES_OK

Cond:    --
*/
RES PRIVATE IfStmt_Parse(
    PSTMT * ppstmt,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    PEXPR pexpr;
    DWORD iLine;
    HPA hpa;

    DBG_ENTER(IfStmt_Parse);

    ASSERT(ppstmt);
    ASSERT(pscanner);
    ASSERT(pst);

    iLine = Scanner_GetLine(pscanner);
    *ppstmt = NULL;

    if (PACreate(&hpa, 8))
        {
        // Parse 'if'
        res = Scanner_ReadToken(pscanner, SYM_IF);
        ASSERT(RES_OK == res);

        // Parse <Expr>
        res = Expr_Parse(&pexpr, pscanner, pst);
        if (RSUCCEEDED(res))
            {
            // Parse 'then'
            res = Scanner_ReadToken(pscanner, SYM_THEN);
            if (RFAILED(res))
                res = Scanner_AddError(pscanner, NULL, RES_E_SYNTAXERROR);
            }
        }
    else
        res = RES_E_OUTOFMEMORY;


    if (RSUCCEEDED(res))
        {
        char szElse[MAX_BUF_KEYWORD];
        char szEnd[MAX_BUF_KEYWORD];

        // Generate unique label names
        res = Symtab_NewLabel(pst, szElse);
        if (RSUCCEEDED(res))
            {
            res = Symtab_NewLabel(pst, szEnd);
            if (RSUCCEEDED(res))
                {
                // Parse statement block for the 'then' block
                res = StmtBlock_Parse(hpa, pscanner, pst, SYM_ENDIF);
                if (RSUCCEEDED(res))
                    {
                    // Create object
                    res = IfStmt_New(ppstmt, pexpr, hpa, szElse, szEnd, iLine);
                    }
                }
            }
        }

    DBG_EXIT_RES(IfStmt_Parse, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Parses the 'halt' statement

         Grammar is:

            <HaltStmt>      ::= halt

Returns: RES_OK

Cond:    --
*/
RES PRIVATE HaltStmt_Parse(
    PSTMT * ppstmt,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    DWORD iLine = Scanner_GetLine(pscanner);

    DBG_ENTER(HaltStmt_Parse);

    ASSERT(ppstmt);
    ASSERT(pscanner);
    ASSERT(pst);

    *ppstmt = NULL;

    // Parse 'halt'
    res = Scanner_ReadToken(pscanner, SYM_HALT);
    ASSERT(RES_OK == res);

    // Create object
    res = HaltStmt_New(ppstmt, iLine);

    DBG_EXIT_RES(HaltStmt_Parse, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Parses the assignment statement

         Grammar is:

            <AssignStmt>    ::= IDENT = <Expr>

Returns: RES_OK

Cond:    --
*/
RES PRIVATE AssignStmt_Parse(
    PSTMT * ppstmt,
    PTOK ptok,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    DWORD iLine;
    PEXPR pexpr;

    DBG_ENTER(AssignStmt_Parse);

    ASSERT(ppstmt);
    ASSERT(ptok);
    ASSERT(pscanner);
    ASSERT(pst);

    iLine = Scanner_GetLine(pscanner);

    // (We already have the IDENT in the ptok passed in.  We
    // also already parsed the '='.  Skip parsing these.)

    // Parse <Expr>
    res = Expr_Parse(&pexpr, pscanner, pst);
    if (RSUCCEEDED(res))
        {
        // (Wait until typechecking phase to check for existence
        // of identifier)
        LPSTR pszIdent = Tok_GetLexeme(ptok);

        // Create object
        res = AssignStmt_New(ppstmt, pszIdent, pexpr, iLine);
        }

    DBG_EXIT_RES(AssignStmt_Parse, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Parses the label statement

         Grammar is:

            <LabelStmt>     ::= IDENT :

Returns: RES_OK

Cond:    --
*/
RES PRIVATE LabelStmt_Parse(
    PSTMT * ppstmt,
    PTOK ptok,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    DWORD iLine;
    LPSTR pszIdent;

    DBG_ENTER(LabelStmt_Parse);

    ASSERT(ppstmt);
    ASSERT(ptok);
    ASSERT(pscanner);
    ASSERT(pst);

    iLine = Scanner_GetLine(pscanner);

    pszIdent = Tok_GetLexeme(ptok);

    res = Ident_Add(pszIdent, DATA_LABEL, ptok, pscanner, pst);
    if (RSUCCEEDED(res))
        {
        // Create label object
        res = LabelStmt_New(ppstmt, pszIdent, iLine);
        }
        
    DBG_EXIT_RES(LabelStmt_Parse, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Parses the 'goto' statement

         Grammar is:

            <GotoStmt>      ::= goto IDENT

Returns: RES_OK

Cond:    --
*/
RES PRIVATE GotoStmt_Parse(
    PSTMT * ppstmt,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    DWORD iLine = Scanner_GetLine(pscanner);
    PTOK ptok;

    DBG_ENTER(GotoStmt_Parse);

    ASSERT(ppstmt);
    ASSERT(pscanner);
    ASSERT(pst);

    // Parse 'goto'
    res = Scanner_ReadToken(pscanner, SYM_GOTO);
    ASSERT(RES_OK == res);

    // Parse identifier
    res = Ident_Parse(pscanner, &ptok);
    if (RSUCCEEDED(res))
        {
        // (Wait until typechecking phase to check for existence
        // of identifier)
        LPSTR pszIdent = Tok_GetLexeme(ptok);

        // Create object
        res = GotoStmt_New(ppstmt, pszIdent, iLine);

        Tok_Delete(ptok);
        }

    DBG_EXIT_RES(GotoStmt_Parse, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Parses the 'set' statement

         Grammar is:

            <SetStmt>       ::= set <SetParam>
            <SetParam>      ::= ipaddr <Expr> | port <PortData> |
                                screen <ScreenSet>

Returns: RES_OK

Cond:    --
*/
RES PRIVATE SetStmt_Parse(
    PSTMT * ppstmt,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;

    DBG_ENTER(SetStmt_Parse);

    ASSERT(ppstmt);
    ASSERT(pscanner);
    ASSERT(pst);

    *ppstmt = NULL;

    // Parse 'set'
    res = Scanner_ReadToken(pscanner, SYM_SET);
    ASSERT(RES_OK == res);

    // Parse set parameter
    if (RES_OK == Scanner_CondReadToken(pscanner, SYM_IPADDR, NULL))
        {
        // Parse <Expr>
        PEXPR pexpr;
        DWORD iLine = Scanner_GetLine(pscanner);

        res = Expr_Parse(&pexpr, pscanner, pst);
        if (RSUCCEEDED(res))
            {
            res = SetIPStmt_New(ppstmt, pexpr, iLine);
            }
        }
    else if (RES_OK == Scanner_CondReadToken(pscanner, SYM_PORT, NULL))
        {
        res = PortData_Parse(ppstmt, pscanner, pst);
        }
    else if (RES_OK == Scanner_CondReadToken(pscanner, SYM_SCREEN, NULL))
        {
        res = ScreenSet_Parse(ppstmt, pscanner, pst);
        }
    else
        {
        res = Scanner_AddError(pscanner, NULL, RES_E_INVALIDSETPARAM);
        }

    DBG_EXIT_RES(SetStmt_Parse, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Parses a statement.

         Grammar is:

            <Stmt>          ::= <HaltStmt> | <WaitforStmt> | <TransmitStmt> |
                                <DelayStmt> | <SetStmt> | <LabelStmt> |
                                <GotoStmt> | <AssignStmt> | <WhileStmt> |
                                <IfStmt>

Returns: RES_OK

Cond:    --
*/
RES PRIVATE Stmt_Parse(
    PSTMT * ppstmt,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    SYM sym;
    PTOK ptok;

    DBG_ENTER(Stmt_Parse);

    ASSERT(ppstmt);
    ASSERT(pscanner);
    ASSERT(pst);

    *ppstmt = NULL;

    Scanner_Peek(pscanner, &sym);
    switch (sym)
        {
    case SYM_WHILE:
        res = WhileStmt_Parse(ppstmt, pscanner, pst);
        break;

    case SYM_IF:
        res = IfStmt_Parse(ppstmt, pscanner, pst);
        break;

    case SYM_WAITFOR:
        res = WaitforStmt_Parse(ppstmt, pscanner, pst);
        break;

    case SYM_TRANSMIT:
        res = TransmitStmt_Parse(ppstmt, pscanner, pst);
        break;

    case SYM_DELAY:
        res = DelayStmt_Parse(ppstmt, pscanner, pst);
        break;

    case SYM_HALT:
        res = HaltStmt_Parse(ppstmt, pscanner, pst);
        break;

    case SYM_SET:
        res = SetStmt_Parse(ppstmt, pscanner, pst);
        break;

    case SYM_IDENT:
        // This can be a label or an assignment
        res = Scanner_GetToken(pscanner, &ptok);
        ASSERT(RES_OK == res);

        if (RSUCCEEDED(res))
            {
            // Is this a label?
            if (RES_OK == Scanner_CondReadToken(pscanner, SYM_COLON, NULL))
                {
                // Yes
                res = LabelStmt_Parse(ppstmt, ptok, pscanner, pst);
                }
            // Is this an assignment?
            else if (RES_OK == Scanner_CondReadToken(pscanner, SYM_ASSIGN, NULL))
                {
                // Yes
                res = AssignStmt_Parse(ppstmt, ptok, pscanner, pst);
                }
            else
                {
                res = Scanner_AddError(pscanner, NULL, RES_E_SYNTAXERROR);
                }
            Tok_Delete(ptok);
            }
        break;

    case SYM_GOTO:
        res = GotoStmt_Parse(ppstmt, pscanner, pst);
        break;

    case SYM_EOF:
        res = Scanner_AddError(pscanner, NULL, RES_E_EOFUNEXPECTED);
        break;

    default:
        res = Scanner_AddError(pscanner, NULL, RES_E_SYNTAXERROR);
        break;
        }
    
    DBG_EXIT_RES(Stmt_Parse, res);

    return res;
    }


// 
// ProcDecl
//


/*----------------------------------------------------------
Purpose: Parse the variable declarations for the proc decl.

         Grammar is:

            <VarDecl>       ::= <VarType> IDENT [ = <Expr> ]
            <VarType>       ::= integer | string | boolean

Returns: RES_OK
Cond:    --
*/
RES PRIVATE ProcDecl_ParseVarDecl(
    HPA hpa,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res = RES_OK;
    PTOK ptok;
    DATATYPE dt;

    // Parse the variable decl block
    while (RES_OK == res)
        {
        SYM sym;

        Scanner_Peek(pscanner, &sym);
        switch (sym)
            {
        case SYM_BOOLEAN:
        case SYM_STRING:
        case SYM_INTEGER:
            if (RES_OK == Scanner_CondReadToken(pscanner, SYM_INTEGER, NULL))
                dt = DATA_INT;
            else if (RES_OK == Scanner_CondReadToken(pscanner, SYM_STRING, NULL))
                dt = DATA_STRING;
            else if (RES_OK == Scanner_CondReadToken(pscanner, SYM_BOOLEAN, NULL))
                dt = DATA_BOOL;
            else
                ASSERT(0);

            res = Ident_Parse(pscanner, &ptok);
            if (RSUCCEEDED(res))
                {
                LPSTR pszIdent = Tok_GetLexeme(ptok);

                res = Ident_Add(pszIdent, dt, ptok, pscanner, pst);

                // Parse optional '= <Expr>'
                if (RES_OK == Scanner_CondReadToken(pscanner, SYM_ASSIGN, NULL))
                    {
                    PEXPR pexpr;
                    PSTMT pstmt;
                    DWORD iLine = Scanner_GetLine(pscanner);

                    res = Expr_Parse(&pexpr, pscanner, pst);
                    if (RSUCCEEDED(res))
                        {
                        res = AssignStmt_New(&pstmt, pszIdent, pexpr, iLine);
                        if (RSUCCEEDED(res))
                            {
                            if (!PAInsertPtr(hpa, PA_APPEND, pstmt))
                                res = RES_E_OUTOFMEMORY;
                            }
                        }
                    }

                Tok_Delete(ptok);
                }
            break;

        default:
            // Continue on with further parsing
            res = RES_FALSE;
            break;
            }
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Parse a statement block

Returns: RES_OK
Cond:    --
*/
RES PRIVATE StmtBlock_Parse(
    HPA hpa,
    PSCANNER pscanner,
    PSYMTAB pstProc,
    SYM symEnd)
    {
    RES res = RES_OK;

    // Parse the statement block
    while (RES_OK == res)
        {
        SYM sym;
        PSTMT pstmt;

        Scanner_Peek(pscanner, &sym);
        switch (sym)
            {
        case SYM_EOF:
            res = Scanner_AddError(pscanner, NULL, RES_E_EOFUNEXPECTED);
            break;

        default:
            // Is this the end of the block?
            if (symEnd == sym)
                {
                // Yes
                Scanner_ReadToken(pscanner, symEnd);
                res = RES_FALSE;
                }
            else
                {
                // No
                res = Stmt_Parse(&pstmt, pscanner, pstProc);
                if (RSUCCEEDED(res))
                    {
                    if (!PAInsertPtr(hpa, PA_APPEND, pstmt))
                        res = RES_E_OUTOFMEMORY;
                    }
                }
            break;
            }
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Work function that parses the proc declaration.

Returns: RES_OK

Cond:    --
*/
RES PRIVATE ProcDecl_PrivParse(
    PPROCDECL * ppprocdecl,
    PSCANNER pscanner,
    HPA hpa,
    PSYMTAB pstProc,
    PSYMTAB pst)
    {
    RES res;
    PTOK ptok;
    DWORD iLine = Scanner_GetLine(pscanner);

    // Parse 'proc'
    res = Scanner_ReadToken(pscanner, SYM_PROC);
    ASSERT(RES_OK == res);

    // Parse the proc name 
    res = Scanner_GetToken(pscanner, &ptok);
    if (RSUCCEEDED(res))
        {
        if (SYM_IDENT == Tok_GetSym(ptok))
            {
            LPCSTR pszIdent = Tok_GetLexeme(ptok);

            // Add the identifier to the symbol table
            res = Ident_Add(pszIdent, DATA_PROC, ptok, pscanner, pst);
           
            // Parse the variable declaration block
            if (RSUCCEEDED(res))
                res = ProcDecl_ParseVarDecl(hpa, pscanner, pstProc);

            // Parse the statement block
            if (RSUCCEEDED(res))
                res = StmtBlock_Parse(hpa, pscanner, pstProc, SYM_ENDPROC);

            if (RSUCCEEDED(res))
                {
                // Create object
                PDECL pdecl;

                res = ProcDecl_New(&pdecl, pszIdent, hpa, pstProc, iLine);

                *ppprocdecl = (PPROCDECL)pdecl;
                }
            }
        else
            res = Scanner_AddError(pscanner, ptok, RES_E_IDENTMISSING);

        Tok_Delete(ptok);
        }
    else
        res = Scanner_AddError(pscanner, NULL, RES_E_IDENTMISSING);

    return res;
    }


/*----------------------------------------------------------
Purpose: Parses the proc declaration

         Grammar is:

            <ProcDecl>      ::= proc IDENT { <VarDecl> } <StmtBlock> endproc
            <StmtBlock>     ::= {<Stmt>}*

Returns: RES_OK

Cond:    --
*/
RES PRIVATE ProcDecl_Parse(
    PPROCDECL * ppprocdecl,
    PSCANNER pscanner,
    PSYMTAB pst)
    {
    RES res;
    HPA hpa;
    PSYMTAB pstProc;

    DBG_ENTER(ProcDecl_Parse);

    ASSERT(ppprocdecl);
    ASSERT(pscanner);

    *ppprocdecl = NULL;

    if (PACreate(&hpa, 8))
        {
        res = Symtab_Create(&pstProc, pst);
        if (RSUCCEEDED(res))
            {
            PSTMT pstmtT;
            DWORD iLine = Scanner_GetLine(pscanner);

            // Add the prolog
            res = EnterStmt_New(&pstmtT, pstProc, iLine);
            if (RSUCCEEDED(res))
                {
                if (!PAInsertPtr(hpa, PA_APPEND, pstmtT))
                    {
                    res = RES_E_OUTOFMEMORY;
                    Stmt_Delete(pstmtT);
                    }
                else
                    {
                    res = ProcDecl_PrivParse(ppprocdecl, pscanner, hpa, pstProc, pst);
                    if (RSUCCEEDED(res))
                        {
                        // Add the epilog
                        res = LeaveStmt_New(&pstmtT, Scanner_GetLine(pscanner));
                        if (RSUCCEEDED(res))
                            {
                            if (!PAInsertPtr(hpa, PA_APPEND, pstmtT))
                                {
                                res = RES_E_OUTOFMEMORY;
                                Stmt_Delete(pstmtT);
                                }
                            }
                        }
                    }
                }

            // Did something fail up above?
            if (RFAILED(res))
                {
                // Yes; cleanup
                Symtab_Destroy(pstProc);
                }
            }

        // Clean up
        if (RFAILED(res))
            PADestroyEx(hpa, Stmt_DeletePAPtr, 0);
        }
    else
        res = RES_E_OUTOFMEMORY;
    
    DBG_EXIT_RES(ProcDecl_Parse, res);

    return res;
    }


// 
// ModuleDecl
//


/*----------------------------------------------------------
Purpose: Parses the script at the module level.

         Grammar is:

            <ModuleDecl>    ::= {<ProcDecl>}*

Returns: RES_OK

         RES_E_OUTOFMEMORY

Cond:    --
*/
RES PUBLIC ModuleDecl_Parse(
    PMODULEDECL * ppmoduledecl,
    PSCANNER pscanner,
    PSYMTAB pstSystem)          // May be NULL
    {
    RES res = RES_OK;
    HPA hpa;

    DBG_ENTER(ModuleDecl_Parse);

    ASSERT(ppmoduledecl);
    ASSERT(pscanner);

    TRACE_MSG(TF_GENERAL, "Parsing...");

    *ppmoduledecl = NULL;

    if (PACreate(&hpa, 8))
        {
        PSYMTAB pst;
        PDECL pdecl = NULL;

        res = Symtab_Create(&pst, pstSystem);
        if (RSUCCEEDED(res))
            {
            // Parse the module block
            while (RES_OK == res)
                {
                SYM sym;

                Scanner_Peek(pscanner, &sym);

                switch (sym)
                    {
                case SYM_EOF:
                    res = RES_FALSE;        // Time to stop
                    break;

                case SYM_PROC:
                    {
                    PPROCDECL pprocdecl;

                    res = ProcDecl_Parse(&pprocdecl, pscanner, pst);
                    if (RSUCCEEDED(res))
                        {
                        if (!PAInsertPtr(hpa, PA_APPEND, pprocdecl))
                            res = RES_E_OUTOFMEMORY;
                        }
                    }
                    break;

                default:
                    res = Scanner_AddError(pscanner, NULL, RES_E_SYNTAXERROR);
                    break;
                    }
                }

            if (RSUCCEEDED(res))
                {
                DWORD iLine = Scanner_GetLine(pscanner);

                res = ModuleDecl_New(&pdecl, hpa, pst, iLine);

#ifdef DEBUG
                if (RSUCCEEDED(res))
                    Ast_Dump((PAST)pdecl);
#endif
                }

            // Clean up after parsing
            if (RSUCCEEDED(res))
                PADestroy(hpa);     // keep pointer elements allocated for pdecl
            else
                {
                // Something failed

                PADestroyEx(hpa, Decl_DeletePAPtr, 0);
                
                Symtab_Destroy(pst);

                // Parse errors were added to the scanner's list
                // of errors already.  However, errors such as 
                // out of memory still need to be added.
                if (FACILITY_PARSE != RFACILITY(res))
                    Scanner_AddError(pscanner, NULL, res);
                }

            // Now typecheck the script
            if (pdecl)
                {
                res = ModuleDecl_Typecheck((PMODULEDECL)pdecl, Scanner_GetStxerrHandle(pscanner));
                if (RFAILED(res))
                    {
                    Decl_Delete(pdecl);
                    pdecl = NULL;
                    }
                }
            }

        *ppmoduledecl = (PMODULEDECL)pdecl;
        }
    else
        res = RES_E_OUTOFMEMORY;
    
    DBG_EXIT_RES(ModuleDecl_Parse, res);

    return res;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasscrpt\proj.h ===
//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//
// Copyright  1993-1995  Microsoft Corporation.  All Rights Reserved.
//
//      MODULE:         proj.h
//
//      PURPOSE:        Global header files, data types and function prototypes
//
//	PLATFORMS:	Windows 95
//
//      FUNCTIONS:      N/A
//
//	SPECIAL INSTRUCTIONS: N/A
//

#ifndef _SMMSCRIPT_PROJ_H_
#define _SMMSCRIPT_PROJ_H_


//****************************************************************************
// Global Include File
//****************************************************************************

#include <windows.h>            // also includes windowsx.h
#include <windowsx.h>
#include <regstr.h>

#include <ras.h>                // Dial-Up Networking Session API
#include <raserror.h>           // Dial-Up Networking Session API

#ifdef WINNT_RAS
//
// The following header is included before all the Win9x Dial-Up definitions,
// since it provides definitions used in the scripting headers.
//
#include "nthdr1.h"

#endif // WINNT_RAS


#include <rnaspi.h>             // Service Provider Interface

#include <rnap.h>

#define NORTL
#define NOFILEINFO
#define NOCOLOR
#define NODRAWTEXT
#define NODIALOGHELPER
#define NOPATH
#define NOSHAREDHEAP

#define SZ_MODULE       "SMMSCRPT"
#define SZ_DEBUGINI     "rover.ini"
#define SZ_DEBUGSECTION "SMM Script"

#include "common.h"

// 
// Error codes - we use HRESULT.  See winerror.h.
//  

#define RSUCCEEDED(res)         SUCCEEDED(res)
#define RFAILED(res)            FAILED(res)
#define RFACILITY(res)          HRESULT_FACILITY(res)

typedef HRESULT   RES;

#define RES_OK                  S_OK
#define RES_FALSE               S_FALSE
#define RES_HALT                0x00000002L

#define FACILITY_SCRIPT         0x70

#define RES_E_FAIL              E_FAIL
#define RES_E_OUTOFMEMORY       E_OUTOFMEMORY
#define RES_E_INVALIDPARAM      E_INVALIDARG
#define RES_E_EOF               0x80700000
#define RES_E_MOREDATA          0x80700001

#define FACILITY_PARSE          0x71

#define RES_E_SYNTAXERROR       0x80710000
#define RES_E_EOFUNEXPECTED     0x80710001
#define RES_E_REDEFINED         0x80710002
#define RES_E_UNDEFINED         0x80710003
#define RES_E_DIVBYZERO         0x80710004

#define RES_E_MAINMISSING       0x80710020
#define RES_E_IDENTMISSING      0x80710021
#define RES_E_STRINGMISSING     0x80710022
#define RES_E_INTMISSING        0x80710023
#define RES_E_RPARENMISSING     0x80710024

#define RES_E_INVALIDTYPE       0x80710040
#define RES_E_INVALIDIPPARAM    0x80710041
#define RES_E_INVALIDSETPARAM   0x80710042
#define RES_E_INVALIDPORTPARAM  0x80710043
#define RES_E_INVALIDRANGE      0x80710044
#define RES_E_INVALIDSCRNPARAM  0x80710045

#define RES_E_REQUIREINT        0x80710050
#define RES_E_REQUIRESTRING     0x80710051
#define RES_E_REQUIREBOOL       0x80710052
#define RES_E_REQUIREINTSTRING  0x80710053
#define RES_E_REQUIRELABEL      0x80710054
#define RES_E_REQUIREINTSTRBOOL 0x80710055

#define RES_E_TYPEMISMATCH      0x80710060


#include "scanner.h"
#include "symtab.h"
#include "ast.h"

//****************************************************************************
// Macros
//****************************************************************************

#define IS_DIGIT(ch)            InRange(ch, '0', '9')
#define IS_ESCAPE(ch)           ('%' == (ch))
#define IS_BACKSLASH(ch)        ('\\' == (ch))

#define ENTERCRITICALSECTION(x)         EnterCriticalSection(&x)
#define LEAVECRITICALSECTION(x)         LeaveCriticalSection(&x)

#define TIMER_DELAY         1

// Trace flags
#define TF_ASTEXEC          0x00010000
#define TF_BUFFER           0x00020000

#ifdef DEBUG
// DBG_EXIT_RES(fn, res)  -- Generates a function exit debug spew for
//                          functions that return a RES.
//
#define DBG_EXIT_RES(fn, res)       DBG_EXIT_TYPE(fn, res, Dbg_GetRes)

LPCSTR  PUBLIC Dbg_GetRes(RES res);

// Dump flags
#define DF_ATOMS            0x00000001
#define DF_STACK            0x00000002
#define DF_READBUFFER       0x00000004
#define DF_TOKEN            0x00000008
#define DF_AST              0x00000010
#define DF_PGM              0x00000020

#else

#define DBG_EXIT_RES(fn, res)

#endif 

//****************************************************************************
// Type definitions
//****************************************************************************

typedef struct tagSCRIPT
    {
    char szPath[MAX_PATH];
    UINT uMode;
    } SCRIPT;
DECLARE_STANDARD_TYPES(SCRIPT);

//****************************************************************************
// SMM error
//****************************************************************************

#define SESS_GETERROR_FUNC          "RnaSessGetErrorString"
typedef DWORD (WINAPI * SESSERRORPROC)(UINT, LPSTR, DWORD);

//****************************************************************************
// Global Parameters
//****************************************************************************

extern HANDLE    g_hinst;

//****************************************************************************
// Function Prototypes
//****************************************************************************

RES     PUBLIC CreateFindFormat(PHANDLE phFindFmt);
RES     PUBLIC AddFindFormat(HANDLE hFindFmt, LPCSTR pszFindFmt, DWORD dwFlags, LPSTR pszBuf, DWORD cbBuf);

// Flags for FINDFMT
#define FFF_DEFAULT         0x0000
#define FFF_MATCHEDONCE     0x0001      // (private)
#define FFF_MATCHCASE       0x0002

RES     PUBLIC DestroyFindFormat(HANDLE hFindFmt);
RES     PUBLIC FindFormat(HWND hwnd, HANDLE hFindFmt, LPDWORD piFound);


BOOL    PUBLIC FindStringInBuffer(HWND hwnd, LPCSTR pszFind);
RES     PUBLIC CopyToDelimiter(HWND hwnd, LPSTR pszBuf, UINT cbBuf, LPCSTR pszTok);
void    PUBLIC SendByte(HWND hwnd, BYTE byte);
DWORD   NEAR PASCAL TerminalSetIP(HWND hwnd, LPCSTR szIPAddr);
void    NEAR PASCAL TerminalSetInput(HWND hwnd, BOOL fEnable);

BOOL    PUBLIC GetScriptInfo(LPCSTR pszConnection, PSCRIPT pscriptBuf);
BOOL    PUBLIC GetSetTerminalPlacement(LPCSTR pszConnection,
                                       LPWINDOWPLACEMENT pwp, BOOL fGet);

LPCSTR  PUBLIC MyNextChar(LPCSTR psz, char * pch, DWORD * pdwFlags);

// Flags for MyNextChar
#define MNC_ISLEADBYTE  0x00000001
#define MNC_ISTAILBYTE  0x00000002

UINT    PUBLIC IdsFromRes(RES res);

BOOL    PUBLIC TransferData(HWND hwnd, HANDLE hComm, PSESS_CONFIGURATION_INFO psci);

DWORD   NEAR PASCAL AssignIPAddress (LPCSTR szEntryName, LPCSTR szIPAddress);



#ifdef WINNT_RAS
//
// The following header is included after the Win9x scripting definitions.
// It changes some definitions set up by the headers, and provides
// other definitions needed for the Win9x->NT port.
//
#include "nthdr2.h"

#endif // WINNT_RAS

#endif  //_SMMSCRIPT_PROJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasscrpt\profile.c ===
//
// Copyright (c) Microsoft Corporation 1993-1995
//
// profile.c
//
// This file contains profile (.ini) routines.
// Meant to be used in conjunction with common.c.
//
// History:
//  08-06-93 ScottH     Transferred from twin code
//  05-05-95 ScottH     Made generic from Briefcase code
//


#include "proj.h"
#include "common.h"

#ifndef NOPROFILE

#pragma data_seg(DATASEG_READONLY)

char const FAR c_szIniFile[] = SZ_DEBUGINI;
char const FAR c_szIniSecDebugUI[] = SZ_DEBUGSECTION;

char const FAR c_szZero[] = "0";
char const FAR c_szIniKeyBreakFlags[] = "BreakFlags";
char const FAR c_szIniKeyTraceFlags[] = "TraceFlags";
char const FAR c_szIniKeyDumpFlags[] = "DumpFlags";

#pragma data_seg()


// Some of the .ini processing code was pimped from the sync engine.
//

typedef struct _INIKEYHEADER
    {
    LPCSTR pszSectionName;
    LPCSTR pszKeyName;
    LPCSTR pszDefaultRHS;
    } INIKEYHEADER;

typedef struct _BOOLINIKEY
    {
    INIKEYHEADER ikh;
    LPUINT puStorage;
    DWORD dwFlag;
    } BOOLINIKEY;

typedef struct _INTINIKEY
    {
    INIKEYHEADER ikh;
    LPUINT puStorage;
    } INTINIKEY;


// Some of these macros taken from prefs.h in Pen project...
//
#define PutIniIntCmp(idsSection, idsKey, nNewValue, nSave) \
    if ((nNewValue) != (nSave)) PutIniInt(idsSection, idsKey, nNewValue)

#define WritePrivateProfileInt(szApp, szKey, i, lpFileName) \
    {char sz[7]; \
    WritePrivateProfileString(szApp, szKey, SzFromInt(sz, i), lpFileName);}


#ifdef SHARED_DLL
#pragma data_seg(DATASEG_PERINSTANCE)
#endif

// Array of keys with Integer RHSs to be processed by ProcessIniFile() 

static INTINIKEY s_rgiik[] = 
    {
        {
        { c_szIniSecDebugUI,    c_szIniKeyTraceFlags, c_szZero },
        &g_dwTraceFlags
        },

        {
        { c_szIniSecDebugUI,    c_szIniKeyDumpFlags, c_szZero },
        &g_dwDumpFlags
        },

        {
        { c_szIniSecDebugUI,    c_szIniKeyBreakFlags, c_szZero },
        &g_dwBreakFlags
        },

    };

// Array of keys with Boolean RHSs to be processed by ProcessIniFile() 

#if 0   // (use this as an example)
static BOOLINIKEY s_rgbik[] =
    {
        {
        { c_szIniSecDebugUI,    c_szIniKeyBreakOnOpen, c_szZero },
        &g_uBreakFlags,
        BF_ONOPEN
        },

    };
#endif

#ifdef SHARED_DLL
#pragma data_seg()
#endif


/* Boolean TRUE strings used by IsIniYes() (comparison is case-insensitive) */

static LPCSTR s_rgpszTrue[] =
    {
    "1",
    "On",
    "True",
    "Y",
    "Yes"
    };

/* Boolean FALSE strings used by IsIniYes() (comparison is case-insensitive) */

static LPCSTR s_rgpszFalse[] =
    {
    "0",
    "Off",
    "False",
    "N",
    "No"
    };




/*----------------------------------------------------------
Purpose: Determines whether a string corresponds to a boolean
          TRUE value.
Returns: The boolean value (TRUE or FALSE)
Cond:    --
*/
BOOL PRIVATE IsIniYes(
    LPCSTR psz)
    {
    int i;
    BOOL bNotFound = TRUE;
    BOOL bResult;

    ASSERT(psz); 

    /* Is the value TRUE? */

    for (i = 0; i < ARRAY_ELEMENTS(s_rgpszTrue); i++)
        {
        if (IsSzEqual(psz, s_rgpszTrue[i]))
            {
            bResult = TRUE;
            bNotFound = FALSE;
            break;
            }
        }

    /* Is the value FALSE? */

    if (bNotFound)
        {
        for (i = 0; i < ARRAY_ELEMENTS(s_rgpszFalse); i++)
            {
            if (IsSzEqual(psz, s_rgpszFalse[i]))
                {
                bResult = FALSE;
                bNotFound = FALSE;
                break;
                }
            }

        /* Is the value a known string? */

        if (bNotFound)
            {
            /* No.  Whine about it. */

            TRACE_MSG(TF_WARNING, "IsIniYes() called on unknown Boolean RHS '%s'.", psz);
            bResult = FALSE;
            }
        }

    return bResult;
    }


#if 0   // (use this as an example)
/*----------------------------------------------------------
Purpose: Process keys with boolean RHSs.
Returns: --
Cond:    --
*/
void PRIVATE ProcessBooleans(void)
    {
    int i;

    for (i = 0; i < ARRAY_ELEMENTS(s_rgbik); i++)
        {
        DWORD dwcbKeyLen;
        char szRHS[MAX_BUF];
        BOOLINIKEY * pbik = &(s_rgbik[i]);
        LPCSTR lpcszRHS;

        /* Look for key. */

        dwcbKeyLen = GetPrivateProfileString(pbik->ikh.pszSectionName,
                                   pbik->ikh.pszKeyName, "", szRHS,
                                   sizeof(szRHS), c_szIniFile);

        if (dwcbKeyLen)
            lpcszRHS = szRHS;
        else
            lpcszRHS = pbik->ikh.pszDefaultRHS;

        if (IsIniYes(lpcszRHS))
            {
            if (IsFlagClear(*(pbik->puStorage), pbik->dwFlag))
                TRACE_MSG(TF_GENERAL, "ProcessIniFile(): %s set in %s![%s].",
                         pbik->ikh.pszKeyName,
                         c_szIniFile,
                         pbik->ikh.pszSectionName);

            SetFlag(*(pbik->puStorage), pbik->dwFlag);
            }
        else
            {
            if (IsFlagSet(*(pbik->puStorage), pbik->dwFlag))
                TRACE_MSG(TF_GENERAL, "ProcessIniFile(): %s cleared in %s![%s].",
                         pbik->ikh.pszKeyName,
                         c_szIniFile,
                         pbik->ikh.pszSectionName);

            ClearFlag(*(pbik->puStorage), pbik->dwFlag);
            }
        }
    }
#endif


/*----------------------------------------------------------
Purpose: Process keys with integer RHSs.
Returns: --
Cond:    --
*/
void PRIVATE ProcessIntegers(void)
    {
    int i;

    for (i = 0; i < ARRAY_ELEMENTS(s_rgiik); i++)
        {
        DWORD dwcbKeyLen;
        char szRHS[MAX_BUF];
        INTINIKEY * piik = &(s_rgiik[i]);
        LPCSTR lpcszRHS;

        /* Look for key. */

        dwcbKeyLen = GetPrivateProfileString(piik->ikh.pszSectionName,
                                   piik->ikh.pszKeyName, "", szRHS,
                                   sizeof(szRHS), c_szIniFile);

        if (dwcbKeyLen)
            lpcszRHS = szRHS;
        else
            lpcszRHS = piik->ikh.pszDefaultRHS;

        *(piik->puStorage) = AnsiToInt(lpcszRHS);

        TRACE_MSG(TF_GENERAL, "ProcessIniFile(): %s set to %#04x.", 
                 piik->ikh.pszKeyName, *(piik->puStorage));
        }
    }


/*----------------------------------------------------------
Purpose: Process initialization file
Returns: TRUE if initialization is successful
Cond:    --
*/
BOOL PUBLIC ProcessIniFile(void)
    {
    BOOL bResult = TRUE;

    // Currently, all integer keys are for DEBUG use only.
    //
    ProcessIntegers();

    return bResult;
    }


#endif // NOPROFILE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasscrpt\rnaspi.h ===
/* Copyright (c) 1992-1995, Microsoft Corporation, all rights reserved
**
** ras.h
** Remote Access Session Management Service Provider Interface
** Public header for Session Management Provider Interface
*/

#ifndef _RNASPI_H_
#define _RNASPI_H_


//****************************************************************************
// RNA Session Management Module Service Provider Interface
//****************************************************************************

#define     RNA_MaxSMMType         32

// The type of RNA session
//
typedef enum {
    SESSTYPE_INITIATOR,
    SESSTYPE_RESPONDER
} SESSTYPE;

// Session configuration options
//
#define SMMCFG_SW_COMPRESSION       0x00000001  // Software compression is on
#define SMMCFG_PW_ENCRYPTED         0x00000002  // Encrypted password only
#define SMMCFG_NW_LOGON             0x00000004  // Logon to the network
#define SMMCFG_SW_ENCRYPTION        0x00000010  // SW encryption is okay

#define SMMCFG_ALL                  0x00000017  // All the user-specified options

// Negotiated protocols
//
#define SMMPROT_NB                  0x00000001  // NetBEUI
#define SMMPROT_IPX                 0x00000002  // IPX
#define SMMPROT_IP                  0x00000004  // TCP/IP

#define SMMPROT_ALL                 0x00000007  // all protocols negotiated

// Error codes that a MAC can return when posting disconnect message
//
#define MACERR_REMOTE_DISCONNECTING 0x00000001
#define MACERR_REMOTE_NO_RESPONSE   0x00000002


// The session confuration information
//
typedef struct tagSESS_CONFIGURATION_INFO
{
    DWORD           dwSize;
    char            szEntryName[RAS_MaxEntryName + 1];
    SESSTYPE        stSessType;
    DWORD           fdwSessOption;
    DWORD           fdwProtocols;
    BOOL            fUserSecurity;
    char            szUserName[UNLEN + 1];
    char            szPassword[PWLEN + 1];
    char            szDomainName[DNLEN + 1];
} SESS_CONFIGURATION_INFO, *PSESS_CONFIGURATION_INFO,
  FAR *LPSESS_CONFIGURATION_INFO;

// Session configuration start/stop functions
//
typedef DWORD (WINAPI * SESSSTARTPROC)(HANDLE, LPSESS_CONFIGURATION_INFO);
typedef DWORD (WINAPI * SESSSTOPPROC)(HANDLE);

// Session configuration entry point table
//
typedef struct tagRNA_FUNCS
{
    DWORD           dwSize;                    // The structure size
    SESSSTARTPROC   lpfnStart;                 // RnaSessStart Entry
    SESSSTOPPROC    lpfnStop;                  // RnaSessStop Entry
} RNA_FUNCS, *PRNA_FUNCS, FAR *LPRNA_FUNCS;

// Session Management Module initialization function
//
typedef DWORD (WINAPI * SESSINITIALIZEPROC)(LPSTR, LPRNA_FUNCS);

//****************************************************************************
// RNA Session Manager Service Interface
//****************************************************************************

typedef struct  tagRnaComplete_Info
{
    DWORD           dwSize;                     // The structure size
    DWORD           dwResult;                   // The returning error code
    UINT            idMsg;                      // SMM-specific error message ID
    BOOL            fUnload;                    // Unload the module on success?
    HANDLE          hThread;                    // Event to wait for unloading
} COMPLETE_INFO, *PCOMPLETE_INFO, FAR *LPCOMPLETE_INFO;

typedef struct  tagProjection_Info
{
    DWORD           dwSize;                     // The structure size
    RASPROJECTION   RasProjection;              // The projection type
    union {
        RASAMB      RasAMB;
        RASPPPNBF   RasPPPNBF;
        RASPPPIPX   RasPPPIPX;
        RASPPPIP    RasPPPIP;
    }               ProjInfo;
} PROJECTION_INFO, *PPROJECTION_INFO, FAR *LPPROJECTION_INFO;

//
// Responses to Session Management Request
//
DWORD WINAPI RnaComplete( HANDLE hConn, LPCOMPLETE_INFO lpci,
                          LPPROJECTION_INFO lppi, DWORD cEntries);
DWORD WINAPI RnaTerminate( HANDLE hConn, HANDLE hThread );

//
// MAC management services
//

#define IEEE_ADDRESS_LENGTH	6   // Token-ring and Ethernet address lengths

typedef struct tagMAC_FEATURES {
    DWORD           SendFeatureBits;	// A bit field of compression/features sendable
    DWORD           RecvFeatureBits;	// A bit field of compression/features receivable
    DWORD           MaxSendFrameSize;	// Maximum frame size that can be sent
                                        // must be less than or equal default
    DWORD           MaxRecvFrameSize;	// Maximum frame size that can be rcvd
                                        // must be less than or equal default
    DWORD           LinkSpeed;		// New RAW link speed in bits/sec
                                        // Ignored if 0
} MAC_FEATURES, *PMAC_FEATURES, FAR* LPMAC_FEATURES;

#ifdef _WIN64
#pragma pack(8)
#else
#pragma pack(4)
#endif
typedef struct tagMAC_OPEN {
    WORD            hRasEndpoint;        // unique for each endpoint assigned
    LPVOID          MacAdapter;          // Which binding to AsyMac to use
                                         // if NULL, will default to last binding
    DWORD           LinkSpeed;           // RAW link speed in bits per sec
    WORD            QualOfConnect;       // NdisAsyncRaw, NdisAsyncErrorControl, ...

    BYTE            IEEEAddress[IEEE_ADDRESS_LENGTH];	// The 802.5 or 802.3
    MAC_FEATURES    macFeatures;         // Readable configuration parameters
    enum {                               // All different types of device drivers
                    SERIAL_DEVICE,       // are listed here.  For instance
                    SNA_DEVICE,          // the serial driver requires diff.
                                         // irps than the SNA driver.
                    MINIPORT_DEVICE      // NDIS WAN Miniport Devices.

    }               DeviceType;

    union {                              // handles required for above device
                                         // driver types.
        LONG        FileHandle;          // the Win32 or Nt File Handle
        struct SNAHandle {
            LPVOID  ReadHandle;
            LPVOID  WriteHandle;
        };
    }               Handles;

    DWORD           hWndConn;            // Window handle for connection
    DWORD           wMsg;                // The msg to post when disconnecting
    DWORD           dwStatus;            // The status of the open call
} MAC_OPEN, *PMAC_OPEN, FAR* LPMAC_OPEN;
#pragma pack()

typedef struct tagDEVICE_PORT_INFO {
    DWORD   dwSize;
    HANDLE  hDevicePort;
    HANDLE  hLine;
    HANDLE  hCall;
    DWORD   dwAddressID;
    DWORD   dwLinkSpeed;
    char    szDeviceClass[RAS_MaxDeviceType+1];
} DEVICE_PORT_INFO, *PDEVICE_PORT_INFO, FAR* LPDEVICE_PORT_INFO;

DWORD WINAPI RnaGetDevicePort( HANDLE hConn, LPDEVICE_PORT_INFO lpdpi );
DWORD WINAPI RnaOpenMac( HANDLE hConn, HANDLE *lphMAC,
                         LPMAC_OPEN lpmo, DWORD dwSize, HANDLE hEvent );
DWORD WINAPI RnaCloseMac( HANDLE hConn );

//
// User Profile Services
//

typedef enum tagRNAACCESSTYPE { PCONLY, NETANDPC } RNAACCESSTYPE;

typedef struct tagUSER_PROFILE
{
    DWORD           dwSize;
    char            szUserName[UNLEN + 1];
    char            szPassword[PWLEN + 1];
    char            szDomainName[DNLEN + 1];
    BOOL            fUseCallbacks;
    RNAACCESSTYPE   accesstype;
    UINT            uTimeOut;
    
} USER_PROFILE, *PUSER_PROFILE, FAR *LPUSER_PROFILE;

DWORD WINAPI RnaGetUserProfile( HANDLE hConn, LPUSER_PROFILE lpUserProfile );

//
// Callback security services
//

// Callback security type
//
enum {
    CALLBACK_SECURE,
    CALLBACK_CONVENIENCE
};

DWORD WINAPI RnaGetCallbackList( DWORD * lpdwType,
                                 LPSTR lpszLocList, LPINT lpcbLoc,
                                 LPSTR lpszPhoneList, LPINT lpcbPhone,
                                 LPINT lpcEntries);
DWORD WINAPI RnaUICallbackDialog( HANDLE hConn, LPSTR lpszLocList,
                                  DWORD dwType, BOOL  fOptional,
                                  LPINT lpIndex,
                                  LPSTR lpszSelectLocation, UINT cbBuff);
DWORD WINAPI RnaStartCallback( HANDLE hConn, HANDLE hEvent);

// Miscellaneous services
//
DWORD WINAPI RnaUIUsernamePassword( HANDLE hConn,    LPSTR lpszUsername,
                                    UINT cbUsername, LPSTR lpszPassword,
                                    UINT cbPassword, LPSTR lpszDomain,
                                    UINT cbDomain);
DWORD WINAPI RnaUIChangePassword( HANDLE hConn,    LPSTR lpszUsername,
                                  UINT cbPassword);
DWORD WINAPI RnaGetOverlaidSMM ( LPSTR lpszSMMType, LPSTR lpszModuleName,
                                 LPBYTE lpBuf, DWORD dwSize);

#endif // _RNASPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasscrpt\scanner.h ===
//
// Copyright (c) Microsoft Corporation 1995
//
// scanner.h
//
// Header file for the scanner.
//
// History:
//  04-05-95 ScottH     Created
//

#ifndef __SCANNER_H__
#define __SCANNER_H__

//
// Symbols
//


typedef enum
    {
    SYM_EOF,            // end of file
    SYM_UNKNOWN,        // unknown lexeme

    SYM_COLON,          // ':'
    SYM_COMMA,          // ','

    SYM_IDENT,          // identifier
    SYM_STRING_LITERAL, // a string literal
    SYM_INT_LITERAL,    // an integer literal

    SYM_INTEGER,        // 'integer'
    SYM_STRING,         // 'string'
    SYM_BOOLEAN,        // 'boolean'

    SYM_WAITFOR,        // 'waitfor'
    SYM_THEN,           // 'then'
    SYM_UNTIL,          // 'until'
    SYM_TRANSMIT,       // 'transmit'
    SYM_PROC,           // 'proc'
    SYM_ENDPROC,        // 'endproc'
    SYM_DELAY,          // 'delay'
    SYM_HALT,           // 'halt'
    SYM_GETIP,          // 'getip'
    SYM_GOTO,           // 'goto'
    SYM_WHILE,          // 'while'
    SYM_DO,             // 'do'
    SYM_ENDWHILE,       // 'endwhile'
    SYM_IF,             // 'if'
    SYM_ENDIF,          // 'endif'

    SYM_RAW,            // 'raw'
    SYM_MATCHCASE,      // 'matchcase'

    SYM_SET,            // 'set'

    SYM_IPADDR,         // 'ipaddr'

    SYM_PORT,           // 'port'
    SYM_DATABITS,       // 'databits'

    SYM_STOPBITS,       // 'stopbits'

    SYM_PARITY,         // 'parity'
    SYM_NONE,           // 'none'
    SYM_ODD,            // 'odd'
    SYM_EVEN,           // 'even'
    SYM_MARK,           // 'mark'
    SYM_SPACE,          // 'space'

    SYM_SCREEN,         // 'screen'
    SYM_KEYBRD,         // 'keyboard'
    SYM_ON,             // 'on'
    SYM_OFF,            // 'off'

    SYM_LPAREN,         // '('
    SYM_RPAREN,         // ')'
    SYM_ASSIGN,         // = (assignment)
    SYM_TRUE,           // 'TRUE'
    SYM_FALSE,          // 'FALSE'
    SYM_NOT,            // '!'

    // WARNING: The types below must match the order of their 
    // corresponding BOT values.

    SYM_OR,             // 'or'
    SYM_AND,            // 'and'

    SYM_LEQ,            // '<='    
    SYM_LT,             // '<'     
    SYM_GEQ,            // '>='    
    SYM_GT,             // '>'     
    SYM_NEQ,            // '!='
    SYM_EQ,             // '=='

    SYM_PLUS,           // '+'
    SYM_MINUS,          // '-'
    SYM_MULT,           // '*'
    SYM_DIV,            // '/'
    } SYM;
DECLARE_STANDARD_TYPES(SYM);


//
// Tokens
//


#define MAX_BUF_KEYWORD     32

typedef enum
    {
    TT_BASE,
    TT_SZ,
    TT_INT,
    } TOKTYPE;


// Basic Token Type

typedef struct tagTOK
    {
    DWORD   cbSize;
    SYM     sym;
    TOKTYPE toktype;
    DWORD   iLine;
    char    szLexeme[MAX_BUF_KEYWORD];
    } TOK;                            // Basic token type
DECLARE_STANDARD_TYPES(TOK);

#define Tok_GetSize(p)      (((PTOK)(p))->cbSize)
#define Tok_GetSym(p)       (((PTOK)(p))->sym)
#define Tok_GetType(p)      (((PTOK)(p))->toktype)
#define Tok_GetLine(p)      (((PTOK)(p))->iLine)
#define Tok_GetLexeme(p)    (((PTOK)(p))->szLexeme)

#define Tok_SetSize(p, s)   (((PTOK)(p))->cbSize = (s))
#define Tok_SetSym(p, s)    (((PTOK)(p))->sym = (s))
#define Tok_SetType(p, tt)  (((PTOK)(p))->toktype = (tt))
#define Tok_SetLine(p, l)   (((PTOK)(p))->iLine = (l))
#define Tok_SetLexeme(p, s) lstrcpyn(((PTOK)(p))->szLexeme, s, sizeof(((PTOK)(p))->szLexeme))

RES     PUBLIC Tok_New(PTOK * pptok, SYM sym, LPCSTR pszLexeme, DWORD iLine);
void    PUBLIC Tok_Delete(PTOK this);


// String Token

typedef struct tagTOKSZ
    {
    TOK  tok;
    char sz[MAX_BUF];
    } TOKSZ;
DECLARE_STANDARD_TYPES(TOKSZ);

#define TokSz_GetSz(p)      (((PTOKSZ)(p))->sz)

#define TokSz_SetSz(p, s)   lstrcpyn(((PTOKSZ)(p))->sz, s, sizeof(((PTOKSZ)(p))->sz))

RES     PUBLIC TokSz_New(PTOK * pptok, SYM sym, LPCSTR pszLexeme, DWORD iLine, LPCSTR pszID);


// Integer Token

typedef struct tagTOKINT
    {
    TOK  tok;
    int  n;
    } TOKINT;
DECLARE_STANDARD_TYPES(TOKINT);

#define TokInt_GetVal(p)        (((PTOKINT)(p))->n)

#define TokInt_SetVal(p, v)     (((PTOKINT)(p))->n = (v))

RES     PUBLIC TokInt_New(PTOK * pptok, SYM sym, LPCSTR pszLexeme, DWORD iLine, int n);

//
// Syntax error object
//

typedef struct tagSTXERR
    {
    char    szLexeme[MAX_BUF_KEYWORD];
    DWORD   iLine;
    RES     res;
    } STXERR;
DECLARE_STANDARD_TYPES(STXERR);

#define Stxerr_GetLexeme(p)     ((p)->szLexeme)
#define Stxerr_GetLine(p)       ((p)->iLine)
#define Stxerr_GetRes(p)        ((p)->res)


//
// Scanner
//

typedef struct tagSCANNER
    {
    DWORD  dwFlags;         // SCF_*

    PSESS_CONFIGURATION_INFO psci;

    char   szScript[MAX_PATH];
    HANDLE hfile;
    LPBYTE pbBuffer;        // Read buffer
    LPBYTE pbCur;           // Current unread position in buffer
    DWORD  cbUnread;        // Count of unread bytes in buffer

    char   chCur;           // Current character, set by Scanner_GetChar()
    char   chTailByte;      // Tail byte for DBCS characters
    char   chUnget;         // Ungotten character

    PTOK   ptokCur;         // Current token, set by Scanner_GetToken()
    PTOK   ptokUnget;       // Ungotten token

    DWORD  iLine;           // The current line number

    HSA    hsaStxerr;       // List of errors
    DWORD  isaStxerr;       // Current error

    } SCANNER;
DECLARE_STANDARD_TYPES(SCANNER);

// Scanner flags
#define SCF_NOSCRIPT    0x0001

#define Scanner_GetStxerrHandle(this)       ((this)->hsaStxerr)

RES     PUBLIC Scanner_Create(PSCANNER * ppscanner, PSESS_CONFIGURATION_INFO psci);
RES     PUBLIC Scanner_Destroy(PSCANNER this);
RES     PUBLIC Scanner_OpenScript(PSCANNER this, LPCSTR pszPath);

RES     PUBLIC Scanner_GetToken(PSCANNER this, PTOK * pptok);
RES     PUBLIC Scanner_UngetToken(PSCANNER this);
RES     PUBLIC Scanner_Peek(PSCANNER this, PSYM psym);
RES     PUBLIC Scanner_ReadToken(PSCANNER this, SYM sym);
RES     PUBLIC Scanner_CondReadToken(PSCANNER this, SYM symExpect, PTOK * pptok);
DWORD   PUBLIC Scanner_GetLine(PSCANNER this);

RES     PUBLIC Scanner_AddError(PSCANNER this, PTOK ptok, RES resErr);

RES     PUBLIC Stxerr_ShowErrors(HSA hsaStxerr, HWND hwndOwner);
RES     PUBLIC Stxerr_Add(HSA hsaStxerr, LPCSTR pszLexeme, DWORD iLine, RES resErr);
RES     PUBLIC Stxerr_AddTok(HSA hsaStxerr, PTOK ptok, RES resErr);

#endif // __SCANNER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasscrpt\scanner.c ===
//
// Copyright (c) Microsoft Corporation 1995
//
// scanner.c
//
// This file contains the scanner functions.
//
// History:
//  05-04-95 ScottH     Created
//


#include "proj.h"
#include "rcids.h"

// This is a hack global string used by error messages.
// This should be removed when Stxerr encapsulates the script
// filename within itself.
static char g_szScript[MAX_PATH];

#define SCANNER_BUF_SIZE        1024

#define IS_WHITESPACE(ch)       (' ' == (ch) || '\t' == (ch) || '\n' == (ch) || '\r' == (ch))
#define IS_QUOTE(ch)            ('\"' == (ch))
#define IS_KEYWORD_LEAD(ch)     ('$' == (ch) || '_' == (ch) || IsCharAlpha(ch))
#define IS_KEYWORD(ch)          ('_' == (ch) || IsCharAlphaNumeric(ch))
#define IS_COMMENT_LEAD(ch)     (';' == (ch))
#define IS_EOL(ch)              ('\n' == (ch))

typedef BOOL (CALLBACK * SCANEVALPROC)(char ch, LPBOOL pbEatIt, LPARAM);

//
// Lexical mapping 
//
typedef struct tagLEX
    {
    LPSTR pszLexeme;
    SYM   sym;
    } LEX;
DECLARE_STANDARD_TYPES(LEX);


#pragma data_seg(DATASEG_READONLY)

// (The keywords are case-sensitive)
//
// This table is sorted alphabetically for binary search.
//
const LEX c_rglexKeywords[] = {
    { "FALSE",      SYM_FALSE },
    { "TRUE",       SYM_TRUE },
    { "and",        SYM_AND },
    { "boolean",    SYM_BOOLEAN },
    { "databits",   SYM_DATABITS },
    { "delay",      SYM_DELAY },
    { "do",         SYM_DO },
    { "endif",      SYM_ENDIF },
    { "endproc",    SYM_ENDPROC },
    { "endwhile",   SYM_ENDWHILE },
    { "even",       SYM_EVEN },
    { "getip",      SYM_GETIP },
    { "goto",       SYM_GOTO },
    { "halt",       SYM_HALT },
    { "if",         SYM_IF },
    { "integer",    SYM_INTEGER },
    { "ipaddr",     SYM_IPADDR },
    { "keyboard",   SYM_KEYBRD },
    { "mark",       SYM_MARK },
    { "matchcase",  SYM_MATCHCASE },
    { "none",       SYM_NONE },
    { "odd",        SYM_ODD },
    { "off",        SYM_OFF },
    { "on",         SYM_ON },
    { "or",         SYM_OR },
    { "parity",     SYM_PARITY },
    { "port",       SYM_PORT },
    { "proc",       SYM_PROC },
    { "raw",        SYM_RAW },
    { "screen",     SYM_SCREEN },
    { "set",        SYM_SET },
    { "space",      SYM_SPACE },
    { "stopbits",   SYM_STOPBITS },
    { "string",     SYM_STRING },
    { "then",       SYM_THEN },
    { "transmit",   SYM_TRANSMIT },
    { "until",      SYM_UNTIL },
    { "waitfor",    SYM_WAITFOR },
    { "while",      SYM_WHILE },
    };

#pragma data_seg()


//
// Tokens
//


#ifdef DEBUG

#pragma data_seg(DATASEG_READONLY)
struct tagSYMMAP
    {
    SYM sym;
    LPCSTR psz;
    } const c_rgsymmap[] = {
        DEBUG_STRING_MAP(SYM_EOF),
        DEBUG_STRING_MAP(SYM_IDENT),
        DEBUG_STRING_MAP(SYM_STRING_LITERAL),
        DEBUG_STRING_MAP(SYM_STRING),
        DEBUG_STRING_MAP(SYM_INTEGER),
        DEBUG_STRING_MAP(SYM_BOOLEAN),
        DEBUG_STRING_MAP(SYM_WAITFOR),
        DEBUG_STRING_MAP(SYM_WHILE),
        DEBUG_STRING_MAP(SYM_TRANSMIT),
        DEBUG_STRING_MAP(SYM_DELAY),
        DEBUG_STRING_MAP(SYM_THEN),
        DEBUG_STRING_MAP(SYM_INT_LITERAL),
        DEBUG_STRING_MAP(SYM_GETIP),
        DEBUG_STRING_MAP(SYM_IPADDR),
        DEBUG_STRING_MAP(SYM_ASSIGN),
        DEBUG_STRING_MAP(SYM_PROC),
        DEBUG_STRING_MAP(SYM_ENDPROC),
        DEBUG_STRING_MAP(SYM_HALT),
        DEBUG_STRING_MAP(SYM_IF),
        DEBUG_STRING_MAP(SYM_ENDIF),
        DEBUG_STRING_MAP(SYM_DO),
        DEBUG_STRING_MAP(SYM_RAW),
        DEBUG_STRING_MAP(SYM_MATCHCASE),
        DEBUG_STRING_MAP(SYM_SET),
        DEBUG_STRING_MAP(SYM_PORT),
        DEBUG_STRING_MAP(SYM_DATABITS),
        DEBUG_STRING_MAP(SYM_STOPBITS),
        DEBUG_STRING_MAP(SYM_PARITY),
        DEBUG_STRING_MAP(SYM_NONE),
        DEBUG_STRING_MAP(SYM_EVEN),
        DEBUG_STRING_MAP(SYM_MARK),
        DEBUG_STRING_MAP(SYM_SPACE),
        DEBUG_STRING_MAP(SYM_SCREEN),
        DEBUG_STRING_MAP(SYM_ON),
        DEBUG_STRING_MAP(SYM_OFF),
        DEBUG_STRING_MAP(SYM_NOT),
        DEBUG_STRING_MAP(SYM_OR),
        DEBUG_STRING_MAP(SYM_AND),
        DEBUG_STRING_MAP(SYM_LEQ),
        DEBUG_STRING_MAP(SYM_NEQ),
        DEBUG_STRING_MAP(SYM_LT),
        DEBUG_STRING_MAP(SYM_GT),
        DEBUG_STRING_MAP(SYM_GEQ),
        DEBUG_STRING_MAP(SYM_EQ),
        DEBUG_STRING_MAP(SYM_PLUS),
        DEBUG_STRING_MAP(SYM_MINUS),
        DEBUG_STRING_MAP(SYM_MULT),
        DEBUG_STRING_MAP(SYM_DIV),
        DEBUG_STRING_MAP(SYM_LPAREN),
        DEBUG_STRING_MAP(SYM_RPAREN),
        DEBUG_STRING_MAP(SYM_TRUE),
        DEBUG_STRING_MAP(SYM_FALSE),
        DEBUG_STRING_MAP(SYM_COLON),
        DEBUG_STRING_MAP(SYM_GOTO),
        DEBUG_STRING_MAP(SYM_COMMA),
        DEBUG_STRING_MAP(SYM_UNTIL),
        };
#pragma data_seg()

/*----------------------------------------------------------
Purpose: Returns the string form of a RES value.

Returns: String ptr
Cond:    --
*/
LPCSTR PRIVATE Dbg_GetSym(
    SYM sym)
    {
    int i;

    for (i = 0; i < ARRAY_ELEMENTS(c_rgsymmap); i++)
        {
        if (c_rgsymmap[i].sym == sym)
            return c_rgsymmap[i].psz;
        }
    return "Unknown SYM";
    }


/*----------------------------------------------------------
Purpose: Dump the token
Returns: --
Cond:    --
*/
void PRIVATE Tok_Dump(
    PTOK this)
    {
    ASSERT(this);

    if (IsFlagSet(g_dwDumpFlags, DF_TOKEN))
        {
        switch (this->toktype)
            {
        case TT_BASE:
            TRACE_MSG(TF_ALWAYS, "line %ld: %s, '%s'", Tok_GetLine(this),
                Dbg_GetSym(Tok_GetSym(this)), Tok_GetLexeme(this));
            break;

        case TT_SZ: {
            PTOKSZ ptoksz = (PTOKSZ)this;

            TRACE_MSG(TF_ALWAYS, "line %ld: %s, {%s}", Tok_GetLine(this),
                Dbg_GetSym(Tok_GetSym(this)), TokSz_GetSz(ptoksz));
            }
            break;

        case TT_INT: {
            PTOKINT ptokint = (PTOKINT)this;

            TRACE_MSG(TF_ALWAYS, "line %ld: %s, {%d}", Tok_GetLine(this),
                Dbg_GetSym(Tok_GetSym(this)), TokInt_GetVal(ptokint));
            }
            break;

        default:
            ASSERT(0);
            break;
            }
        }
    }


#else // DEBUG

#define Dbg_GetSym(sym)   ((LPSTR)"")
#define Tok_Dump(ptok)    

#endif // DEBUG


/*----------------------------------------------------------
Purpose: Creates a new token with the given symbol sym.

Returns: RES_OK
         RES_E_OUTOFMEMORY

Cond:    --
*/
RES PUBLIC Tok_New(
    PTOK * pptok,
    SYM sym,
    LPCSTR pszLexeme,
    DWORD iLine)
    {
    PTOK ptok;

    ASSERT(pptok);
    ASSERT(pszLexeme);

    ptok = GAllocType(TOK);
    if (ptok)
        {
        Tok_SetSize(ptok, sizeof(*ptok));
        Tok_SetSym(ptok, sym);
        Tok_SetType(ptok, TT_BASE);
        Tok_SetLine(ptok, iLine);
        Tok_SetLexeme(ptok, pszLexeme);
        }
    *pptok = ptok;

    return NULL != ptok ? RES_OK : RES_E_OUTOFMEMORY;
    }


/*----------------------------------------------------------
Purpose: Destroys the given token.
Returns: 
Cond:    --
*/
void PUBLIC Tok_Delete(
    PTOK this)
    {
    GFree(this);
    }


/*----------------------------------------------------------
Purpose: Duplicate the given token.

Returns: RES_OK
         RES_E_OUTOFMEMORY

Cond:    --
*/
RES PUBLIC Tok_Dup(
    PTOK this,
    PTOK * pptok)
    {
    PTOK ptok;
    DWORD cbSize;

    ASSERT(this);
    ASSERT(pptok);

    cbSize = Tok_GetSize(this);

    ptok = GAlloc(cbSize);
    if (ptok)
        {
        BltByte(ptok, this, cbSize);
        }
    *pptok = ptok;

    return NULL != ptok ? RES_OK : RES_E_OUTOFMEMORY;
    }


/*----------------------------------------------------------
Purpose: Creates a new string token with the given string.

Returns: RES_OK
         RES_E_OUTOFMEMORY

Cond:    --
*/
RES PUBLIC TokSz_New(
    PTOK * pptok,
    SYM sym,
    LPCSTR pszLexeme,
    DWORD iLine,
    LPCSTR psz)
    {
    PTOKSZ ptoksz;

    ASSERT(pptok);

    ptoksz = GAllocType(TOKSZ);
    if (ptoksz)
        {
        Tok_SetSize(ptoksz, sizeof(*ptoksz));
        Tok_SetSym(ptoksz, sym);
        Tok_SetType(ptoksz, TT_SZ);
        Tok_SetLine(ptoksz, iLine);
        Tok_SetLexeme(ptoksz, pszLexeme);
        if (psz)
            TokSz_SetSz(ptoksz, psz);
        else
            *ptoksz->sz = 0;
        }
    *pptok = (PTOK)ptoksz;

    return NULL != ptoksz ? RES_OK : RES_E_OUTOFMEMORY;
    }


/*----------------------------------------------------------
Purpose: Creates a new integer token with the given value.

Returns: RES_OK
         RES_E_OUTOFMEMORY

Cond:    --
*/
RES PUBLIC TokInt_New(
    PTOK * pptok,
    SYM sym,
    LPCSTR pszLexeme,
    DWORD iLine,
    int n)
    {
    PTOKINT ptokint;

    ASSERT(pptok);

    ptokint = GAllocType(TOKINT);
    if (ptokint)
        {
        Tok_SetSize(ptokint, sizeof(*ptokint));
        Tok_SetSym(ptokint, sym);
        Tok_SetType(ptokint, TT_INT);
        Tok_SetLine(ptokint, iLine);
        Tok_SetLexeme(ptokint, pszLexeme);
        TokInt_SetVal(ptokint, n);
        }
    *pptok = (PTOK)ptokint;

    return NULL != ptokint ? RES_OK : RES_E_OUTOFMEMORY;
    }


/*----------------------------------------------------------
Purpose: Compare two strings.  This function does not take
         localization into account, so the comparison of two
         strings will be based off the English code page.

         This is required because the lexical keyword table
         is hand-sorted to the English language.  Using the
         NLS lstrcmp would not produce the correct results.

Returns: strcmp standard
Cond:    --
*/
int PRIVATE strcmpraw(
    LPCSTR psz1,
    LPCSTR psz2)
    {
    for (; *psz1 == *psz2; 
        psz1 = CharNext(psz1), 
        psz2 = CharNext(psz2))
        {
        if (0 == *psz1)
            return 0;
        }
    return *psz1 - *psz2;
    }


#ifdef DEBUG
/*----------------------------------------------------------
Purpose: Returns the SYM value that matches the given lexeme.
         If the given lexeme is not found in the list of 
         keyword token values, then SYM_IDENT is returned.

         Performs a linear search.

Returns: see above
Cond:    --
*/
SYM PRIVATE SymFromKeywordLinear(
    LPCSTR pszLex)
    {
    int i;

    ASSERT(pszLex);

    for (i = 0; i < ARRAY_ELEMENTS(c_rglexKeywords); i++)
        {
        // Case-sensitive
        if (0 == strcmpraw(c_rglexKeywords[i].pszLexeme, pszLex))
            {
            return c_rglexKeywords[i].sym;
            }
        }
    return SYM_IDENT;
    }
#endif


/*----------------------------------------------------------
Purpose: Returns the SYM value that matches the given lexeme.
         If the given lexeme is not found in the list of 
         keyword token values, then SYM_IDENT is returned.

         Peforms a binary search.

Returns: see above
Cond:    --
*/
SYM PRIVATE SymFromKeyword(
    LPCSTR pszLex)
    {
    static const s_cel = ARRAY_ELEMENTS(c_rglexKeywords);

    SYM symRet = SYM_IDENT;    // assume no match
    int nCmp;
    int iLow = 0;
    int iMid;
    int iHigh = s_cel - 1;

    ASSERT(pszLex);

    // (OK for cp == 0.  Duplicate lexemes not allowed.)

    while (iLow <= iHigh)
        {
        iMid = (iLow + iHigh) / 2;

        nCmp = strcmpraw(pszLex, c_rglexKeywords[iMid].pszLexeme);

        if (0 > nCmp)
            iHigh = iMid - 1;       // First is smaller
        else if (0 < nCmp)
            iLow = iMid + 1;        // First is larger
        else
            {
            // Match
            symRet = c_rglexKeywords[iMid].sym;
            break;
            }
        }

    // Check if we get the same result with linear search
    ASSERT(SymFromKeywordLinear(pszLex) == symRet);

    return symRet;
    }


//
// Stxerr
//


/*----------------------------------------------------------
Purpose: Initializes a syntax error structure

Returns: --
Cond:    --
*/
void PUBLIC Stxerr_Init(
    PSTXERR this,
    LPCSTR pszLex,
    DWORD iLine,
    RES res)
    {
    ASSERT(this);
    ASSERT(pszLex);

    lstrcpyn(this->szLexeme, pszLex, sizeof(this->szLexeme));
    this->iLine = iLine;
    this->res = res;
    }


// 
// Scanner
//


/*----------------------------------------------------------
Purpose: Returns TRUE if the scanner structure is valid
         to read a file.

Returns: See above
Cond:    --
*/
BOOL PRIVATE Scanner_Validate(
    PSCANNER this)
    {
    return (this && 
            (IsFlagSet(this->dwFlags, SCF_NOSCRIPT) || 
                INVALID_HANDLE_VALUE != this->hfile) && 
            this->pbBuffer &&
            this->psci);
    }


/*----------------------------------------------------------
Purpose: Creates a scanner.

Returns: RES_OK
         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC Scanner_Create(
    PSCANNER * ppscanner,
    PSESS_CONFIGURATION_INFO psci)
    {
    RES res;

    DBG_ENTER(Scanner_Create);

    ASSERT(ppscanner);
    ASSERT(psci);

    if (ppscanner)
        {
        PSCANNER pscanner;

        res = RES_OK;       // assume success

        pscanner = GAllocType(SCANNER);
        if (!pscanner)
            res = RES_E_OUTOFMEMORY;
        else
            {
            pscanner->pbBuffer = GAlloc(SCANNER_BUF_SIZE);
            if (!pscanner->pbBuffer)
                res = RES_E_OUTOFMEMORY;
            else
                {
                if ( !SACreate(&pscanner->hsaStxerr, sizeof(STXERR), 8) )
                    res = RES_E_OUTOFMEMORY;
                else
                    {
                    pscanner->hfile = INVALID_HANDLE_VALUE;
                    pscanner->psci = psci;
                    SetFlag(pscanner->dwFlags, SCF_NOSCRIPT);
                    }
                }
            }
    
        if (RFAILED(res))
            {
            Scanner_Destroy(pscanner);
            pscanner = NULL;
            }

        *ppscanner = pscanner;    
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(Scanner_Create, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Destroys a scanner.

Returns: RES_OK
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC Scanner_Destroy(
    PSCANNER this)
    {
    RES res;

    DBG_ENTER(Scanner_Destroy);

    if (this)
        {
        if (INVALID_HANDLE_VALUE != this->hfile)
            {
            TRACE_MSG(TF_GENERAL, "Closing script");
            CloseHandle(this->hfile);
            }

        if (this->pbBuffer)
            {
            GFree(this->pbBuffer);
            }

        if (this->hsaStxerr)
            {
            SADestroy(this->hsaStxerr);
            }

        GFree(this);
        res = RES_OK;
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(Scanner_Destroy, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Opens a script file and associates it with this scanner.

Returns: RES_OK
         RES_E_FAIL (script cannot be opened)
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC Scanner_OpenScript(
    PSCANNER this,
    LPCSTR pszPath)
    {
    RES res;

    DBG_ENTER_SZ(Scanner_OpenScript, pszPath);

    if (this && pszPath)
        {
        DEBUG_BREAK(BF_ONOPEN);

        // (shouldn't have a file open already)
        ASSERT(INVALID_HANDLE_VALUE == this->hfile);    

        // Open script
        this->hfile = CreateFile(pszPath, GENERIC_READ, FILE_SHARE_READ,
            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

        if (INVALID_HANDLE_VALUE == this->hfile)
            {
            TRACE_MSG(TF_GENERAL, "Failed to open script \"%s\"", pszPath);

            res = RES_E_FAIL;
            }
        else
            {
            // Reset buffer fields
            TRACE_MSG(TF_GENERAL, "Opened script \"%s\"", pszPath);

            lstrcpyn(this->szScript, pszPath, sizeof(this->szScript));
            lstrcpyn(g_szScript, pszPath, sizeof(g_szScript));

            ClearFlag(this->dwFlags, SCF_NOSCRIPT);

            this->pbCur = this->pbBuffer;
            this->cbUnread = 0;
            this->chUnget = 0;
            this->chTailByte = 0;
            this->iLine = 1;
            res = RES_OK;
            }
        }
    else
        res = RES_E_INVALIDPARAM;

    DBG_EXIT_RES(Scanner_OpenScript, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Reads enough bytes from the file to fill the buffer.

Returns: RES_OK
         RES_E_FAIL (if ReadFile failed)
         RES_E_EOF

Cond:    --
*/
RES PRIVATE Scanner_Read(
    PSCANNER this)
    {
    RES res;
    BOOL bResult;
    LPBYTE pb;
    DWORD cb;
    DWORD cbUnread;

    DBG_ENTER(Scanner_Read);

    ASSERT(Scanner_Validate(this));

    // Move the unread bytes to the front of the buffer before reading
    // more bytes.  This function may get called when there are still 
    // some unread bytes in the buffer.  We do not want to lose those 
    // bytes.  

    // I'm too lazy to make this a circular buffer.
    BltByte(this->pbBuffer, this->pbCur, this->cbUnread);
    this->pbCur = this->pbBuffer;

    pb = this->pbBuffer + this->cbUnread;
    cb = (DWORD)(SCANNER_BUF_SIZE - (pb - this->pbBuffer));
    bResult = ReadFile(this->hfile, pb, cb, &cbUnread, NULL);
    if (!bResult)
        {
        res = RES_E_FAIL;
        }
    else
        {
        // End of file?
        if (0 == cbUnread)
            {
            // Yes
            res = RES_E_EOF;
            }
        else
            {
            // No
            this->cbUnread += cbUnread;

            res = RES_OK;
            }
        }

    DBG_EXIT_RES(Scanner_Read, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Gets the next character in the file (buffer).  This
         function will scan the file buffer using CharNext,
         and store the current byte in chCur.  
         
         Note for DBCS characters this means that only the 
         lead byte will be stored in chCur.  If chCur is a 
         lead byte, the trailing byte will be stored in 
         chTailByte.

Returns: RES_OK
         RES_E_EOF
Cond:    --
*/
RES PRIVATE Scanner_GetChar(
    PSCANNER this)
    {
    RES res = RES_OK;       // assume success

    ASSERT(Scanner_Validate(this));

    if (0 != this->chUnget)
        {
        this->chCur = this->chUnget;
        this->chUnget = 0;
        }
    else
        {
        // Time to read more into the buffer?
        if (0 == this->cbUnread)
            {
            // Yes
            res = Scanner_Read(this);
            }

        if (RSUCCEEDED(res))
            {
            LPBYTE pbCur = this->pbCur;
            LPBYTE pbNext = CharNext(pbCur);
            DWORD cb;
            BOOL bIsLeadByte;

            this->chCur = *pbCur;

            bIsLeadByte = IsDBCSLeadByte(this->chCur);

            // We might be at the end of the unread characters, where
            // a DBCS character is cut in half (ie, the trailing byte
            // is missing).  Are we in this case?
            if (bIsLeadByte && 1 == this->cbUnread)
                {
                // Yes; read more into the buffer, we don't care about
                // the return value
                Scanner_Read(this);

                // this->pbCur might have changed
                pbCur = this->pbCur;
                pbNext = CharNext(pbCur);
                }

            cb = (DWORD)(pbNext - pbCur);

            this->cbUnread -= cb;
            this->pbCur = pbNext;

            // Do we need to save away the whole DBCS character?
            if (bIsLeadByte)
                {
                // Yes
                ASSERT(2 == cb);        // We don't support MBCS
                this->chTailByte = pbCur[1];
                }

            if (IS_EOL(this->chCur))
                {
                this->iLine++;
                };
            }
        else
            this->chCur = 0;
        }
    return res;
    }


/*----------------------------------------------------------
Purpose: Ungets the current character back to the buffer.

Returns: RES_OK
         RES_E_FAIL (if a character was already ungotten since the last get)
Cond:    --
*/
RES PRIVATE Scanner_UngetChar(
    PSCANNER this)
    {
    RES res;

    ASSERT(Scanner_Validate(this));

    if (0 != this->chUnget)
        {
        res = RES_E_FAIL;
        }
    else
        {
        this->chUnget = this->chCur;
        this->chCur = 0;
        res = RES_OK;
        }
    return res;
    }


/*----------------------------------------------------------
Purpose: Skips white space

Returns: --
Cond:    --
*/
void PRIVATE Scanner_SkipBlanks(
    PSCANNER this)
    {
    ASSERT(Scanner_Validate(this));

    while (IS_WHITESPACE(this->chCur))
        {
        Scanner_GetChar(this);
        }
    }


/*----------------------------------------------------------
Purpose: Skips commented line

Returns: --
Cond:    --
*/
void PRIVATE Scanner_SkipComment(
    PSCANNER this)
    {
    RES res;
    char chSav = this->chCur;

    ASSERT(Scanner_Validate(this));
    ASSERT(IS_COMMENT_LEAD(this->chCur));

    // Scan to end of line
    do
        {
        res = Scanner_GetChar(this);
        } while (RES_OK == res && !IS_EOL(this->chCur));

    if (IS_EOL(this->chCur))
        Scanner_GetChar(this);
    }


/*----------------------------------------------------------
Purpose: Skips white space and comments

Returns: --
Cond:    --
*/
void PRIVATE Scanner_SkipBadlands(
    PSCANNER this)
    {
    ASSERT(Scanner_Validate(this));

    Scanner_GetChar(this);

    Scanner_SkipBlanks(this);
    while (IS_COMMENT_LEAD(this->chCur))
        {
        Scanner_SkipComment(this);
        Scanner_SkipBlanks(this);
        }
    }


/*----------------------------------------------------------
Purpose: This function scans and copies the characters that are
         scanned into pszBuf until the provided callback says to stop.

Returns: RES_OK
         RES_E_OUTOFMEMORY

Cond:    --
*/
RES PRIVATE Scanner_ScanForCharacters(
    PSCANNER this,
    LPSTR pszBuf,
    UINT cbBuf,
    SCANEVALPROC pfnEval,
    LPARAM lParam)
    {
    RES res = RES_E_MOREDATA;

    ASSERT(this);
    ASSERT(pszBuf);
    ASSERT(pfnEval);

    // Don't use CharNext because we are iterating on a single-byte
    // basis.
    for (; 0 < cbBuf; cbBuf--, pszBuf++)
        {
        res = Scanner_GetChar(this);
        if (RES_OK == res)
            {
            // Delimiter?
            BOOL bEatIt = FALSE;

            if (pfnEval(this->chCur, &bEatIt, lParam))
                {
                if (!bEatIt)
                    Scanner_UngetChar(this);
                break;  // done
                }

            // Save the whole DBCS character?
            if (IsDBCSLeadByte(this->chCur))
                {
                // Yes; is there enough room?
                if (2 <= cbBuf)
                    {
                    // Yes
                    *pszBuf = this->chCur;
                    pszBuf++;      // Increment by single byte
                    cbBuf--;
                    *pszBuf = this->chTailByte;
                    }
                else
                    {
                    // No; stop iterating
                    break;
                    }
                }
            else
                {
                // No; this is just a single byte
                *pszBuf = this->chCur;
                }
            }
        else
            break;
        }

    *pszBuf = 0;    // add terminator

    return res;
    }


/*----------------------------------------------------------
Purpose: Determines if the given character is a delimiter
         for a keyword.

Returns: TRUE (if the character is a delimiter)
         FALSE (otherwise)

Cond:    --
*/
BOOL CALLBACK EvalKeywordChar(
    char ch,            // Always the first byte of a DBCS character
    LPBOOL pbEatIt,     // Default is FALSE on entry
    LPARAM lparam)
    {
    return !IS_KEYWORD(ch);
    }


/*----------------------------------------------------------
Purpose: Scans for the keyword.  Returns a new token.

Returns: RES_OK
         RES_E_OUTOFMEMORY

Cond:    --
*/
RES PRIVATE Scanner_GetKeywordTok(
    PSCANNER this,
    PTOK * pptok)
    {
    char sz[MAX_BUF_KEYWORD];
    UINT cbBuf;
    SYM sym;

    ASSERT(this);
    ASSERT(pptok);

    *sz = this->chCur;
    cbBuf = sizeof(sz) - 1 - 1;     // reserve place for terminator

    Scanner_ScanForCharacters(this, &sz[1], cbBuf, EvalKeywordChar, 0);

    sym = SymFromKeyword(sz);
    return Tok_New(pptok, sym, sz, this->iLine);
    }


/*----------------------------------------------------------
Purpose: Determines if the given character is a delimiter
         for a string constant.

         *pbEatIt is set to TRUE if the character must be 
         eaten (not copied to the buffer).  Only used if
         this function returns TRUE.

Returns: TRUE (if the character is a delimiter)
         FALSE (otherwise)

Cond:    --
*/
BOOL CALLBACK EvalStringChar(
    char ch,            // Always the first byte of a DBCS character
    LPBOOL pbEatIt,     // Default is FALSE on entry
    LPARAM lparam)      
    {
    BOOL bRet;
    PBOOL pbEncounteredBS = (PBOOL)lparam;
    BOOL bBS = *pbEncounteredBS;

    *pbEncounteredBS = FALSE;

    if (IS_QUOTE(ch))
        {
        // Is this after
        if (bBS)
            bRet = FALSE;
        else
            {
            *pbEatIt = TRUE;
            bRet = TRUE;
            }
        }
    else if (IS_BACKSLASH(ch))
        {
        if (!bBS)
            *pbEncounteredBS = TRUE;
        bRet = FALSE;
        }
    else
        bRet = FALSE;

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Scans for the string constant.  Returns a new token.

Returns: RES_OK
         RES_E_OUTOFMEMORY

Cond:    --
*/
RES PRIVATE Scanner_GetStringTok(
    PSCANNER this,
    PTOK * pptok)
    {
    char sz[MAX_BUF];
    UINT cbBuf;
    BOOL bBS;

    ASSERT(this);
    ASSERT(pptok);

    *sz = 0;
    cbBuf = sizeof(sz) - 1;     // reserve place for terminator
    bBS = FALSE;

    Scanner_ScanForCharacters(this, sz, cbBuf, EvalStringChar, (LPARAM)&bBS);

    return TokSz_New(pptok, SYM_STRING_LITERAL, "\"", this->iLine, sz);
    }


/*----------------------------------------------------------
Purpose: Determines if the given character is a delimiter
         for a keyword.

Returns: TRUE (if the character is a delimiter)
         FALSE (otherwise)

Cond:    --
*/
BOOL CALLBACK EvalNumberChar(
    char ch,            // Always the first byte of a DBCS character
    LPBOOL pbEatIt,     // Default is FALSE on entry
    LPARAM lparam)
    {
    return !IS_DIGIT(ch);
    }


/*----------------------------------------------------------
Purpose: Scans for the number constant.  Returns a new token.

Returns: RES_OK
         RES_E_OUTOFMEMORY

Cond:    --
*/
RES PRIVATE Scanner_GetNumberTok(
    PSCANNER this,
    PTOK * pptok)
    {
    char sz[MAX_BUF];
    UINT cbBuf;
    int n;

    ASSERT(this);
    ASSERT(pptok);

    *sz = this->chCur;
    cbBuf = sizeof(sz) - 1 - 1;     // reserve place for terminator

    Scanner_ScanForCharacters(this, &sz[1], cbBuf, EvalNumberChar, 0);

    n = AnsiToInt(sz);
    return TokInt_New(pptok, SYM_INT_LITERAL, sz, this->iLine, n);
    }


/*----------------------------------------------------------
Purpose: Scans for the punctuation.  Returns a new token.

Returns: RES_OK
         RES_E_OUTOFMEMORY

Cond:    --
*/
RES PRIVATE Scanner_GetPuncTok(
    PSCANNER this,
    PTOK * pptok)
    {
    SYM sym;
    char rgch[3];
    char chT;

    ASSERT(this);
    ASSERT(pptok);

    chT = this->chCur;
    *rgch = this->chCur;
    rgch[1] = 0;

    switch (chT)
        {
    case '=':
    case '<':
    case '>':
        Scanner_GetChar(this);
        if ('=' == this->chCur)
            {
            switch (chT)
                {
            case '=':
                sym = SYM_EQ;
                break;

            case '<':
                sym = SYM_LEQ;
                break;

            case '>':
                sym = SYM_GEQ;
                break;

            default:
                // Should never get here
                ASSERT(0);
                break;
                }
            rgch[1] = this->chCur;
            rgch[2] = 0;
            }
        else
            {
            switch (chT)
                {
            case '=':
                sym = SYM_ASSIGN;
                break;

            case '<':
                sym = SYM_LT;
                break;

            case '>':
                sym = SYM_GT;
                break;

            default:
                // Should never get here
                ASSERT(0);
                break;
                }
            Scanner_UngetChar(this);
            }
        break;

    case '!':
        Scanner_GetChar(this);
        if ('=' == this->chCur)
            {
            sym = SYM_NEQ;
            rgch[1] = this->chCur;
            rgch[2] = 0;
            }
        else
            {
            sym = SYM_NOT;
            Scanner_UngetChar(this);
            }
        break;

    case '+':
        sym = SYM_PLUS;
        break;

    case '-':
        sym = SYM_MINUS;
        break;

    case '*':
        sym = SYM_MULT;
        break;

    case '/':
        sym = SYM_DIV;
        break;

    case '(':
        sym = SYM_LPAREN;
        break;

    case ')':
        sym = SYM_RPAREN;
        break;

    case ':':
        sym = SYM_COLON;
        break;

    case ',':
        sym = SYM_COMMA;
        break;

    default:
        if (0 == this->chCur)
            {
            *rgch = 0;
            sym = SYM_EOF;
            }
        else
            {
            sym = SYM_UNKNOWN;
            }
        break;
        }


    return Tok_New(pptok, sym, rgch, this->iLine);
    }


/*----------------------------------------------------------
Purpose: Scans for the next token.  The next token is created
         and returned in *pptok.

Returns: RES_OK
         RES_E_FAIL (unexpected character)

Cond:    --
*/
RES PUBLIC Scanner_GetToken(
    PSCANNER this,
    PTOK * pptok)
    {
    RES res;

    DBG_ENTER(Scanner_GetToken);

    ASSERT(Scanner_Validate(this));
    ASSERT(pptok);

    if (this->ptokUnget)
        {
        this->ptokCur = this->ptokUnget;
        *pptok = this->ptokCur;
        this->ptokUnget = NULL;
        res = RES_OK;
        }
    else
        {
        Scanner_SkipBadlands(this);
        
        // Is this a keyword?
        if (IS_KEYWORD_LEAD(this->chCur))
            {
            // Yes; or maybe an identifier
            res = Scanner_GetKeywordTok(this, pptok);
            }

        // Is this a string constant?
        else if (IS_QUOTE(this->chCur))
            {
            // Yes
            res = Scanner_GetStringTok(this, pptok);
            }

        // Is this a number?
        else if (IS_DIGIT(this->chCur))
            {
            // Yes
            res = Scanner_GetNumberTok(this, pptok);
            }

        // Is this punctuation or something else?
        else
            {
            res = Scanner_GetPuncTok(this, pptok);
            }

        this->ptokCur = *pptok;

#ifdef DEBUG
        if (RSUCCEEDED(res))
            {
            Tok_Dump(*pptok);
            }
#endif
        }

    DBG_EXIT_RES(Scanner_GetToken, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Ungets the current token.

Returns: RES_OK

         RES_E_FAIL (if a token was already ungotten since the
                   last get)

Cond:    --
*/
RES PUBLIC Scanner_UngetToken(
    PSCANNER this)
    {
    RES res;

    ASSERT(Scanner_Validate(this));

    if (this->ptokUnget)
        {
        ASSERT(0);
        res = RES_E_FAIL;
        }
    else
        {
        this->ptokUnget = this->ptokCur;
        this->ptokCur = NULL;
        res = RES_OK;
        }
    return res;
    }


/*----------------------------------------------------------
Purpose: Returns the line of the currently read token.

Returns: see above
Cond:    --
*/
DWORD PUBLIC Scanner_GetLine(
    PSCANNER this)
    {
    DWORD iLine;

    ASSERT(this);

    if (this->ptokUnget)
        {
        iLine = Tok_GetLine(this->ptokUnget);
        }
    else
        {
        iLine = this->iLine;
        }
    return iLine;
    }    

/*----------------------------------------------------------
Purpose: This function peeks at the next token and returns 
         the sym type.

Returns: RES_OK

         RES_E_FAIL
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC Scanner_Peek(
    PSCANNER this,
    PSYM psym)
    {
    RES res;
    PTOK ptok;

    ASSERT(this);
    ASSERT(psym);

    DBG_ENTER(Scanner_Peek);

    res = Scanner_GetToken(this, &ptok);
    if (RSUCCEEDED(res))
        {
        *psym = Tok_GetSym(ptok);
        Scanner_UngetToken(this);
        res = RES_OK;
        }

    DBG_EXIT_RES(Scanner_Peek, res);

    return res;
    }
    

/*----------------------------------------------------------
Purpose: This function expects that the next token that will
         be read from the scanner is of the given sym type.
         
         If the next token is of the expected type, the function
         eats the token and returns RES_OK.  Otherwise, the
         function fails.

Returns: RES_OK

         RES_E_FAIL
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC Scanner_ReadToken(
    PSCANNER this,
    SYM sym)
    {
    RES res;
    PTOK ptok;

    DBG_ENTER(Scanner_ReadToken);

    res = Scanner_GetToken(this, &ptok);
    if (RSUCCEEDED(res))
        {
        if (Tok_GetSym(ptok) == sym)
            {
            // Eat the token
            Tok_Delete(ptok);
            res = RES_OK;
            }
        else
            {
            Scanner_UngetToken(this);
            res = RES_E_FAIL;
            }
        }

    DBG_EXIT_RES(Scanner_ReadToken, res);

    return res;
    }
    

/*----------------------------------------------------------
Purpose: This function reads the next token only if it is of
         the given type.
         
         If the next token is of the expected type, the function
         eats the token and returns RES_OK.  Otherwise, the
         token is retained for the next read, and RES_FALSE is 
         returned.

         If pptok is non-NULL and RES_OK is returned, the 
         retrieved token is returned in *pptok.

Returns: RES_OK
         RES_FALSE (if the next token is not of the expected type)

         RES_E_FAIL
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC Scanner_CondReadToken(
    PSCANNER this,
    SYM symExpect,
    PTOK * pptok)       // May be NULL
    {
    RES res;
    PTOK ptok;

    DBG_ENTER(Scanner_CondReadToken);

    res = Scanner_GetToken(this, &ptok);
    if (RSUCCEEDED(res))
        {
        if (Tok_GetSym(ptok) == symExpect)
            {
            // Eat the token
            if (pptok)
                *pptok = ptok;
            else
                Tok_Delete(ptok);

            res = RES_OK;
            }
        else
            {
            if (pptok)
                *pptok = NULL;

            Scanner_UngetToken(this);

            res = RES_FALSE;        // not a failure
            }
        }

    DBG_EXIT_RES(Scanner_CondReadToken, res);

    return res;
    }


/*----------------------------------------------------------
Purpose: Wrapper to add an error for the scanner.

Returns: resErr 

Cond:    --
*/
RES PUBLIC Scanner_AddError(
    PSCANNER this,
    PTOK ptok,          // May be NULL
    RES resErr)
    {
    STXERR stxerr;

    ASSERT(this);
    ASSERT(this->hsaStxerr);

    // Initialize the structure

    if (NULL == ptok)
        {
        if (RSUCCEEDED(Scanner_GetToken(this, &ptok)))
            {
            Stxerr_Init(&stxerr, Tok_GetLexeme(ptok), Tok_GetLine(ptok), resErr);

            Tok_Delete(ptok);
            }
        else
            {
            Stxerr_Init(&stxerr, "", Scanner_GetLine(this), resErr);
            }
        }
    else
        {
        Stxerr_Init(&stxerr, Tok_GetLexeme(ptok), Tok_GetLine(ptok), resErr);
        }

    // Add to the list of errors
    SAInsertItem(this->hsaStxerr, SA_APPEND, &stxerr);

    return resErr;
    }


/*----------------------------------------------------------
Purpose: Adds an error to the list.

Returns: resErr
Cond:    --
*/
RES PUBLIC Stxerr_Add(
    HSA hsaStxerr,
    LPCSTR pszLexeme,
    DWORD iLine,
    RES resErr)
    {
    STXERR stxerr;
    LPCSTR psz;

    ASSERT(hsaStxerr);

    if (pszLexeme)
        psz = pszLexeme;
    else
        psz = "";

    // Add to the list of errors
    Stxerr_Init(&stxerr, psz, iLine, resErr);
    
    SAInsertItem(hsaStxerr, SA_APPEND, &stxerr);

    return resErr;
    }


/*----------------------------------------------------------
Purpose: Adds an error to the list.

Returns: resErr
Cond:    --
*/
RES PUBLIC Stxerr_AddTok(
    HSA hsaStxerr,
    PTOK ptok,
    RES resErr)
    {
    LPCSTR pszLexeme;
    DWORD iLine;

    ASSERT(hsaStxerr);

    if (ptok)
        {
        pszLexeme = Tok_GetLexeme(ptok);
        iLine = Tok_GetLine(ptok);
        }
    else
        {
        pszLexeme = NULL;
        iLine = 0;
        }
    
    return Stxerr_Add(hsaStxerr, pszLexeme, iLine, resErr);
    }


/*----------------------------------------------------------
Purpose: Shows a series of message boxes of all the errors 
         found in the script.

Returns: RES_OK

Cond:    --
*/
RES PUBLIC Stxerr_ShowErrors(
    HSA hsaStxerr,
    HWND hwndOwner)
    {
    DWORD cel;
    DWORD i;
    STXERR stxerr;

#ifndef WINNT_RAS
//
// On Win95, syntax-errors are reported using a series of message-boxes.
// On NT, syntax-error information is written to a file
// named %windir%\system32\ras\script.log.
//

    cel = SAGetCount(hsaStxerr);
    for (i = 0; i < cel; i++)
        {
        BOOL bRet = SAGetItem(hsaStxerr, i, &stxerr);
        ASSERT(bRet);

        if (bRet)
            {
            UINT ids = IdsFromRes(Stxerr_GetRes(&stxerr));
            if (0 != ids)
                {
                MsgBox(g_hinst,
                    hwndOwner,
                    MAKEINTRESOURCE(ids),
                    MAKEINTRESOURCE(IDS_CAP_Script),
                    NULL,
                    MB_ERROR,
                    g_szScript,
                    Stxerr_GetLine(&stxerr),
                    Stxerr_GetLexeme(&stxerr));
                }
            }
        }

#else // !WINNT_RAS

    RxLogErrors(((SCRIPTDATA*)hwndOwner)->hscript, (VOID*)hsaStxerr);

#endif // !WINNT_RAS
    return RES_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasscrpt\rnap.h ===
/*****************************************************************************\
*                                                                             *
* rnap.h -      Remote Network Access (RNA) private interface                 *
*                                                                             *
*               Version 1.00                                                  *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
******************************************************************************/

#ifndef _RNAP_H_
#define _RNAP_H_

#define RAS_MaxPortName     128
#define RAS_MaxComment      255
#define RAS_MaxCountry      3
#define RAS_MaxAreaCode     10
#define RAS_MaxLocal        36
#define RAS_MaxExtension    5
#define RAS_MaxSMMDesc      63
#define RAS_MaxProtocolDesc 63

/******************************************************************************
 Private RASCONNSTATE
******************************************************************************/

#define RASCS_PrivateStart  RASCS_Disconnected+1

#define RASCS_StartClosing  RASCS_PrivateStart
#define RASCS_LoggingOff    RASCS_PrivateStart+1
#define RASCS_Closing       RASCS_PrivateStart+2
#define RASCS_Closed        RASCS_PrivateStart+3
#define RASCS_Terminating   RASCS_PrivateStart+4

/******************************************************************************
 Registry key paths
******************************************************************************/

#define REGSTR_KEY_RNA        "RemoteAccess"
#define REGSTR_PATH_RNA       REGSTR_PATH_SERVICES"\\"REGSTR_KEY_RNA
#define REGSTR_VAL_IMPLICIT   "EnableImplicit"
#define REGSTR_VAL_DIALUI     "DialUI"

#define REGSTR_KEY_PROF       REGSTR_KEY_RNA"\\Profile"
#define REGSTR_VAL_USER       "User"
#define REGSTR_VAL_DOMAIN     "Domain"
#define REGSTR_VAL_NUMBER     "Number"
#define REGSTR_VAL_SCRIPT     "PPPScript"
#define REGSTR_VAL_MODE       "Mode"
#define REGSTR_VAL_TERM       "Terminal"
#define REGSTR_VAL_AUTODIALDLL "AutodialDllName"
#define REGSTR_VAL_AUTODIALFN  "AutodialFcnName"
#define REGSTR_VAL_ML          "MultiLink"

/******************************************************************************
 Related RNA module names and internal exported
******************************************************************************/

#define RNA_SERVER_MOD_NAME     "RNASERV.DLL"
#define CALLER_ACCESS_FUNC_NAME "CallerAccess"

#define RNADLL_MODULE_NAME      "RASAPI32.DLL"

#define RNASCRIPT_MODULE_NAME   "SMMSCRPT.DLL"
#define RUN_SCRIPT_FUNC_NAME    "RunRnaScript"

#define RNAUI_MODULE_NAME       "RNAUI.DLL"
#define CREATE_ENTRY_FUNC_NAME  "Remote_CreateEntry"
#define EDIT_ENTRY_FUNC_NAME    "Remote_EditEntry"
#define NOTIFY_FUNC_NAME        "Remote_Notify"

/******************************************************************************
 Asynchronous event notification from RNA engine via WM_RASDIALEVENT
******************************************************************************/

#define     RNA_ASYNCEVENT      0xFFFFFFFF  // wParam value

#define     RNA_ADD_DEVICE      0           // A new device was added
#define     RNA_DEL_DEVICE      1           // A new device was removed
#define     RNA_REINIT_DEVICE   2           // The device needs to be reintied
#define     RNA_SHUTDOWN        3           // The engine needs to shutdown
#define     RNA_TRANSLATECHANGE 4           // Translate address caps changed

/******************************************************************************
 Communication with RNA engine
******************************************************************************/

#define     CLIENT_CONNECTION   1           // Client connection
#define     SERVER_CONNECTION   2           // Server connection

#define     WM_RNAMSG       WM_USER+10

#define     RL_MINMSG       WM_RNAMSG
#define     RL_CREATE       RL_MINMSG       // create a connection
#define     RL_TERMINATE    RL_MINMSG+1     // terminate the connection
#define     RL_CONNECTED    RL_MINMSG+2     // a connection is active
#define     RL_DISCONNECTED RL_MINMSG+3     // a connection is not active
#define     RL_SUPRV        RL_MINMSG+4     // initialize supervisor
#define     RL_ACTIVATE     RL_MINMSG+5     // activate supervisor change
#define     RL_REINIT       RL_MINMSG+6     // Reinitialize the engine
#define     RL_REG_DEVCHG   RL_MINMSG+7     // Register device notification
#define     RL_GET_COUNT    RL_MINMSG+8     // Get the count
#define     RL_GW_NOTIFY    RL_MINMSG+9     // Gateway callback

/******************************************************************************
 Communication with Dial engine
******************************************************************************/

#define     DL_MINMSG       WM_RNAMSG
#define     DL_DIALEVENT    DL_MINMSG       // continue dial-up sequence
#define     DL_DISCONNECTED DL_MINMSG+1     // a connection is not active
#define     DL_AUTHENTICATE DL_MINMSG+2     // auth module sent a message
#define     DL_CONNECTED    DL_MINMSG+3     // a new connection is active
#define     DL_CLOSE        DL_MINMSG+4     // Terminate the connection window
#define     DL_MAC_MSG      DL_MINMSG+5     // MAC requests disconnection
#define     DL_RECONNECT    DL_MINMSG+6     // a connection needs reconnect
#define     DL_NOTIFYICON   DL_MINMSG+7     // tray icon notification
#define     DL_SHOW_STAT    DL_MINMSG+8     // display the status dialog

//****************************************************************************
// Communication with gateway manager
//****************************************************************************

#define     GW_MINMSG       WM_RNAMSG
#define     GW_DIALEVENT    DL_DIALEVENT    // !!WARNING!! shared message
#define     GW_CONNECTED    GW_MINMSG + 1
#define     GW_DISCONNECTED GW_MINMSG + 2
#define     GW_LOG          GW_MINMSG + 3
#define     GW_CLOSE        DL_CLOSE        // !!WARNING!! shared message
#define     GW_MAC_MSG      DL_MAC_MSG      // MAC requests disconnection

#define MAX_AUTODISCONNECT  60000       // server autodisconnect sec.

//
// Gateway to Supervisor Communication
//
LRESULT WINAPI DialInMessage(HWND, UINT, WPARAM, LPARAM);

/******************************************************************************
 Request for services from RNADLL
******************************************************************************/

DWORD WINAPI RnaEngineRequest  (UINT uCommand, DWORD dwParam);
DWORD WINAPI DialEngineRequest (UINT uCommand, DWORD dwParam1, DWORD dwParam2);
DWORD WINAPI SuprvRequest      (UINT uCommand, DWORD dwParam1, DWORD dwParam2);

#define     RA_MINCMD       0
#define     RA_LOAD         RA_MINCMD       // Notify Rna process is a loader
#define	    RA_INIT         RA_MINCMD+1	    // Initialize the rna engine
#define     RA_TERMINATE    RA_MINCMD+2     // rna engine terminated
#define     RA_REG_DEVCHG   RA_MINCMD+3     // register dev change notification
#define     RA_DEREG_DEVCHG RA_MINCMD+4     // deregister dev change notification
#define	    RA_REINIT       RA_MINCMD+5	    // Reinitialize the rna engine
#define     RA_ADD_DEVICE   RA_MINCMD+6     // Device added
#define     RA_DEL_DEVICE   RA_MINCMD+7     // Device removed
#define     RA_GET_PROP     RA_MINCMD+8     // Get property page
#define     RA_MAXCMD       RA_MINCMD+50

#define     GA_MINCMD       RA_MAXCMD+1
#define     GA_INIT_SUPRV   GA_MINCMD       // Initialize supervisor
#define     GA_ACTIVE_SUPRV GA_MINCMD+1     // Activate supervisor
#define     GA_SHUTDOWN     RA_MINCMD+2     // Shutdown the system
#define     GA_LOG_SUPRV    GA_MINCMD+3     // Register log event
#define     GA_LOGON_INFO   GA_MINCMD+4     // Logon session information
#define     GA_DISCONNECT   GA_MINCMD+5     // Terminate logon session
#define     GA_START_SUPRV  GA_MINCMD+6     // Start the host
#define     GA_STOP_SUPRV   GA_MINCMD+7     // Stop the host
#define     GA_DEV_CHANGE   GA_MINCMD+8     // A device changed
#define     GA_GET_STATS    GA_MINCMD+9     // Get the server information
#define     GA_COUNT_ACTIVE GA_MINCMD+10    // Count the active connection
#define     GA_MAXCMD       GA_MINCMD+50

#define     DA_MINCMD       GA_MAXCMD+1
#define     DA_CONNINFO     DA_MINCMD       // connection information
#define     DA_DISCONNECT   DA_MINCMD+1     // disconnect an active connection
#define     DA_RECONNECT    DA_MINCMD+2     // reconnect a dropped connection
#define	    DA_NEWCONN      DA_MINCMD+3	    // a new connection is added
#define     DA_SHUTDOWN     DA_MINCMD+4     // Shutdown the system
#define     DA_NEWEVENT     DA_MINCMD+5     // Notify a new event
#define     DA_COMPASYN     DA_MINCMD+6     // Notify a async operation completion
#define     DA_DEV_CHANGE   DA_MINCMD+7     // A device changed
#define     DA_GET_UI_WND   DA_MINCMD+8     // Get the UI window
#define     DA_SET_WND_POS  DA_MINCMD+9     // Set the status window position
#define     DA_GETSTATS     DL_MINMSG+10    // a connection needs stats
#define     DA_GET_CONNSTAT DL_MINMSG+11    // Get current connection status
#define     DA_GET_SUBENTRY DL_MINMSG+12    // Get sub-entry information
#define     DA_DIAL_SUBENTRY DL_MINMSG+13   // Dial a sub-entry
#define     DA_MAXCMD       DA_MINCMD+50

typedef struct  tagConnInfo {
    char        szEntryName[RAS_MaxEntryName+1];
    DWORD       dwRate;
    char        szSMMDesc[RAS_MaxSMMDesc+1];
    DWORD       fdwProtocols;
    char        szDeviceType[RAS_MaxDeviceType+1];
    char        szDeviceName[RAS_MaxDeviceName+1];
} CONNINFO, *PCONNINFO, FAR* LPCONNINFO;

typedef struct  tagMLInfo {
    BOOL        fEnabled;
    DWORD       cSubEntries;
} MLINFO, *PMLINFO, FAR* LPMLINFO;

typedef struct  tagSubConnInfo {
    DWORD       iSubEntry;
    MLINFO      mli;
} SUBCONNINFO, *PSUBCONNINFO, FAR* LPSUBCONNINFO;

#define PARENT_ENTRY_ID 0xFFFFFFFF

// Flags for protocols in fdwProtocols
//
#define PROTOCOL_AMB            0x00000001
#define PROTOCOL_PPPNBF         0x00000002
#define PROTOCOL_PPPIPX         0x00000004
#define PROTOCOL_PPPIP          0x00000008

//****************************************************************************
// RNAAPP Command line interface
//****************************************************************************

#define RNAAPP_EXE_NAME             "rnaapp"
#define LOAD_REQ                    "-l"      // RnaDll loads Rnaapp

//****************************************************************************
// RNAUI Private Interface
//****************************************************************************

#define DT_NULLMODEM    "null"
#define DT_MODEM        "modem"
#define DT_ISDN         "isdn"
#define DT_UNKNOWN      "unknown"

#define DIRECTCC        "Direct Cable Connection Host Logon"

typedef HICON   FAR* LPHICON;

// SMM Usage type flags
//
#define CLIENT_SMM          0x00000001
#define SERVER_SMM          0x00000002

typedef struct  tagSMMCFG  {
    DWORD       dwSize;
    DWORD       fdwOptions;
    DWORD       fdwProtocols;
}   SMMCFG, *PSMMCFG, FAR* LPSMMCFG;

typedef struct  tagSMMINFO  {
    char        szSMMType[RNA_MaxSMMType+1];
    SMMCFG      SMMConfig;
}   SMMINFO, *PSMMINFO, FAR* LPSMMINFO;

typedef struct tagIPData   {
    DWORD     dwSize;
    DWORD     fdwTCPIP;
    DWORD     dwIPAddr;
    DWORD     dwDNSAddr;
    DWORD     dwDNSAddrAlt;
    DWORD     dwWINSAddr;
    DWORD     dwWINSAddrAlt;
}   IPDATA, *PIPDATA, FAR *LPIPDATA;

typedef struct tagSMMData   {
    struct    tagSMMData *pNext;
    SMMINFO   smmi;
    DWORD     fdwOptAllow;
    DWORD     fdwProtAllow;
    IPDATA    ipData;
}   SMMDATA, *PSMMDATA, FAR *LPSMMDATA;

// Flags for the fdwTCPIP field
//

#define IPF_IP_SPECIFIED    0x00000001
#define IPF_NAME_SPECIFIED  0x00000002
#define IPF_NO_COMPRESS     0x00000004
#define IPF_NO_WAN_PRI      0x00000008

typedef struct  tagDEVICEINFO  {
    DWORD       dwVersion;
    UINT        uSize;
    char        szDeviceName[RAS_MaxDeviceName+1];
    char        szDeviceType[RAS_MaxDeviceType+1];
}   DEVICEINFO, *PDEVICEINFO, FAR* LPDEVICEINFO;

typedef struct  tagDevConfig    {
    HICON       hIcon;
    SMMINFO     smmi;
    DEVICEINFO  di;
}   DEVCONFIG, *PDEVCONFIG, FAR* LPDEVCONFIG;

typedef struct tagPhoneNum  {
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    char        szAreaCode[RAS_MaxAreaCode+1];
    char        szLocal[RAS_MaxLocal+1];
    char        szExtension[RAS_MaxExtension+1];
} PHONENUM, *PPHONENUM, FAR *LPPHONENUM;

typedef struct  tagCountryInfo {
    DWORD       dwCountryID;
    DWORD       dwNextCountryID;
    DWORD       dwCountryCode;
    DWORD       dwCountryNameOffset;
}   COUNTRYINFO, *PCOUNTRYINFO, FAR* LPCOUNTRYINFO;

typedef struct  tagConnEntry    {
    PSTR        pszEntry;
    PHONENUM    pn;
    PDEVCONFIG  pDevConfig;
    DWORD       dwFlags;
    DWORD       cSubEntry;
}   CONNENTRY, *PCONNENTRY, FAR* LPCONNENTRY;

#define CESZENTRY(pCE)         ((PSTR)(((PBYTE)pCE)+sizeof(CONNENTRY)))

#define DEVCONFIGSIZE(diSize)  (diSize+(sizeof(DEVCONFIG)-sizeof(DEVICEINFO)))

typedef struct  tagSubConnEntry    {
    DWORD       dwSize;
    DWORD       dwFlags;
    char        szDeviceType[RAS_MaxDeviceType+1];
    char        szDeviceName[RAS_MaxDeviceName+1];
    char        szLocal[RAS_MaxPhoneNumber+1];
}   SUBCONNENTRY, *PSUBCONNENTRY, FAR* LPSUBCONNENTRY;

typedef struct tagConnEntDlg    {
    PCONNENTRY  pConnEntry;
    PDEVCONFIG  pDevConfig;
    PSMMDATA    pSMMList;
    PSMMDATA    pSMMType;
    PMLINFO     pmli;
    DWORD       cmlChannel;
} CONNENTDLG, *PCONNENTDLG, FAR *LPCONNENTDLG;

typedef struct tagRNAPropPage {
    UINT      idPage;
    HMODULE   hModule;
    UINT      idRes;
    DLGPROC   pfn;
} RNAPROPPAGE, *PRNAPROPPAGE, FAR *LPRNAPROPPAGE;

#define SRV_TYPE_PAGE       0   // Server Type page id

DWORD      WINAPI RnaEnumConnEntries(LPSTR lpBuf, UINT cb, LPDWORD lpcEntries);
PCONNENTRY WINAPI RnaGetConnEntry(LPSTR szEntry, BOOL bNeedIcon, BOOL fDevice);
BOOL       WINAPI RnaFreeConnEntry(PCONNENTRY);
DWORD      WINAPI RnaSaveConnEntry(PCONNENTRY lpConnEntry);
BOOL       WINAPI RnaDeleteConnEntry(LPSTR szEntry);
DWORD      WINAPI RnaRenameConnEntry(LPSTR szOldEntry, LPSTR szNewEntry);
DWORD      WINAPI RnaValidateEntryName (LPSTR szEntry, BOOL fNew);

DWORD      WINAPI RnaEnumCountryInfo (LPCOUNTRYINFO, LPDWORD);
DWORD      WINAPI RnaGetAreaCodeList (LPSTR, LPDWORD);
DWORD      WINAPI RnaGetCurrentCountry (LPDWORD);

DWORD      WINAPI RnaEnumDevices (LPBYTE lpBuff, LPDWORD lpcbSize,
                                  LPDWORD lpcEntries);
PDEVCONFIG WINAPI RnaGetDefaultDevConfig (LPSTR szDeviceName);
DWORD      WINAPI RnaGetDeviceInfo(LPSTR szDeviceName, LPDEVICEINFO lpdi);
DWORD      WINAPI RnaGetDeviceChannel (LPSTR szDeviceName);
PDEVCONFIG WINAPI RnaBuildDevConfig (PDEVCONFIG pDevConfig, HICON hIcon, BOOL bNeedIcon);
DWORD      WINAPI RnaDevConfigDlg(HWND hWnd, PDEVCONFIG pDevConfig);
BOOL       WINAPI RnaFreeDevConfig(PDEVCONFIG pDevConfig);

DWORD      WINAPI RnaSMMInfoDialog(HWND hWnd, LPSTR szEntryName,
                                   LPSTR szDeviceName,
                                   LPSMMINFO lpsmmi, DWORD dwUsage);
DWORD      WINAPI RnaEnumerateMacNames (LPSTR szDeviceName, LPBYTE lpBuff,
                                        LPDWORD lpcb);
DWORD      WINAPI RnaEnumerateSMMNames (LPSTR szDeviceName, LPBYTE lpBuff,
                                        LPDWORD lpcb,   DWORD dwType);
DWORD      WINAPI RnaGetDefaultSMMInfo(LPSTR szDeviceName, LPSMMINFO lpsmmi,
                                       BOOL fClient);
DWORD      WINAPI RnaGetIPInfo(LPSTR szEntryName, PIPDATA pIpData,
                               BOOL fDefault);
DWORD      WINAPI RnaSetIPInfo(LPSTR szEntryName, PIPDATA pIpData);


DWORD      WINAPI RnaLogon(HWND);
DWORD      WINAPI RnaActivateEngine();
DWORD      WINAPI RnaDeactivateEngine();
DWORD      WINAPI RnaUIDial(HWND, LPSTR);
DWORD      WINAPI RnaImplicitDial(HWND, LPSTR);

DWORD      WINAPI RnaFindDriver(HWND hwnd, LPSTR lpszDriverList);
DWORD      WINAPI RnaInstallDriver (HWND hwnd, LPSTR lpszDriverList);

DWORD      WINAPI RnaExportEntry (LPSTR szEntryName, LPSTR szFileName);
DWORD      WINAPI RnaImportEntry (LPSTR szFileName, LPBYTE lpBuff, DWORD cb);
DWORD      WINAPI RnaValidateImportEntry (LPSTR szFileName);

DWORD      WINAPI RnaGetMultiLinkInfo (LPSTR, LPMLINFO);
DWORD      WINAPI RnaSetMultiLinkInfo (LPSTR, LPMLINFO);
DWORD      WINAPI RnaGetSubEntry (LPSTR, DWORD, PSUBCONNENTRY, LPDWORD);
DWORD      WINAPI RnaSetSubEntry (LPSTR, DWORD, PSUBCONNENTRY, DWORD);

#define    LOG_INACTIVE            0
#define    LOG_DISCONNECTION       1
#define    LOG_ACTIVE              2
#define    LOG_LISTEN              3
#define    LOG_AUTH_TIMEOUT        4
#define    LOG_CALLBACK            5
#define    LOG_ANSWERED            6
#define    LOG_ERROR               7
    
typedef struct tagLOGINFO {
    LPSTR   szPortName;
    HWND    hwnd;
    UINT    uLogEvent;
} LOGINFO, *PLOGINFO, FAR* LPLOGINFO;

typedef struct tagGWLOGONINFO {
    LPSTR   szPortName;
    char    szUserName[UNLEN+1];
    SYSTEMTIME sysTime;
} GWLOGONINFO, *PGWLOGONINFO, FAR* LPGWLOGONINFO;

typedef enum tagRNASECURITY { RNAPASSWORD, RNAPASSTHROUGH } RNASECURITY;

#define RNAADMIN_DIALIN 1

#define	USERTYPE_USER		0x00000001
#define USERTYPE_GROUP		0x00000002
#define	USERTYPE_WORLD		0x00000004

typedef struct tagUSER_ACCESS {
        RNAACCESSTYPE accesstype;
        BOOL        fUseCallbacks;
        DWORD       dwUsertype;
} USERACCESS, *PUSERACCESS, FAR *LPUSERACCESS;

typedef struct tagPORTSTATS
{
    char            szPortName[RAS_MaxPortName+1];
    char            szDeviceType[RAS_MaxDeviceType+1];
    BOOL            fAccessEnabled;
    UINT            TimeOut;
    SMMINFO         smmi;
    char            szComment[RAS_MaxComment+1];
    BOOL            AdminAccess;
    RNASECURITY     security;
    union {
      struct        tagPassthru {
        DWORD       cUsers;
        DWORD       dwOffsetUsers; }
                    Passthru;

      struct        tagPassword {
        USERACCESS  shareaccess;
        char        szPassword[PWLEN+1]; }
                    Password;
    };
} RNAPORTSTATS, *PRNAPORTSTATS, FAR *LPRNAPORTSTATS;

DWORD WINAPI SuprvEnumAccessInfo (LPBYTE, LPINT, LPINT);
DWORD WINAPI SuprvGetAccessInfo (LPSTR, LPRNAPORTSTATS, LPDWORD);
DWORD WINAPI SuprvSetAccessInfo (LPRNAPORTSTATS);
DWORD WINAPI SuprvInitialize (LPDWORD);
DWORD WINAPI SuprvDeInitialize();
DWORD WINAPI SuprvGetAdminConfig();

DWORD WINAPI RnaSetCallbackList (DWORD, LPSTR, LPSTR, int);

DWORD WINAPI RnaAllocateLana(HANDLE hConn, LPDWORD lpLana);
DWORD WINAPI RnaDeallocateLana(HANDLE hConn);

DWORD WINAPI RnaRunScript(HANDLE hConn, PSESS_CONFIGURATION_INFO lpSCI,
                          BOOL fForce);

typedef DWORD (WINAPI * LPFNCREATE)(HWND);
typedef DWORD (WINAPI * LPFNEDIT)(HWND, LPSTR);
typedef void  (WINAPI * LPFNUINOTIFY)(LPSTR);

DWORD WINAPI Remote_CreateEntry (HWND);
DWORD WINAPI Remote_EditEntry (HWND, LPSTR);
void  WINAPI Remote_Notify (LPSTR);

//***************************************************************************
// Dial global setting for redial and implicit connection
//***************************************************************************

#define MAX_REDIAL_COUNT        100
#define MIN_REDIAL_COUNT        1
#define MAX_REDIAL_MINUTE       119
#define MIN_REDIAL_MINUTE       0
#define MAX_REDIAL_SECOND       59
#define MIN_REDIAL_SECOND       0

typedef struct tagRnaSetting    {
    BOOL    fRedial;
    DWORD   cRetry;
    DWORD   dwMin;
    DWORD   dwSec;
    BOOL    fImplicit;
    DWORD   dwDialUI;
} RNASETTING, *PRNASETTING, FAR *LPRNASETTING;

#define DIALUI_NO_PROMPT        0x00000001  // Do not display connect prompt
#define DIALUI_NO_CONFIRM       0x00000002  // Do not display connect confirm
#define DIALUI_NO_TRAY          0x00000004  // No tray icon

DWORD WINAPI RnaGetDialSettings(LPRNASETTING);
DWORD WINAPI RnaSetDialSettings(LPRNASETTING);

//***************************************************************************
// The following are SMM Interface we cut from version 1.0
//***************************************************************************
#ifndef WINNT_RAS
//
// CALLBACKINFO conflicts with a structure defined in "pbuser.h",
// and RAS_STATISTICS conflicts with a structure in "rasman.h".
// The Win9x scripting code uses neither, so they have been commented out.
//

// Callback request information
//
typedef struct tagCALLBACKINFO
{
    DWORD            dwSize;
    BOOL             fUseCallbackDelay;
    DWORD            dwCallbackDelay;
    char             szPhoneNumber[RAS_MaxPhoneNumber+1];
} CALLBACKINFO, *PCALLBACKINFO, FAR* LPCALLBACKINFO;

DWORD WINAPI RnaSetCallbackInfo( HANDLE hConn, LPCALLBACKINFO lpcbinfo );

DWORD WINAPI RnaReportLinkSpeed( HANDLE hConn, DWORD dwLinkSpeed );
DWORD WINAPI RnaUIStatus( HANDLE hConn, LPSTR lpszStatusMsg );
DWORD WINAPI RnaLog( HANDLE hConn, LPSTR lpszLogMsg );

//***************************************************************************
// The following are connection statistics
//***************************************************************************

#define NUM_RAS_SERIAL_STATS    14

#define BYTES_XMITED            0       //Generic Stats
#define BYTES_RCVED             1
#define FRAMES_XMITED           2
#define FRAMES_RCVED            3

#define CRC_ERR                 4       //Serial Stats
#define TIMEOUT_ERR             5
#define ALIGNMENT_ERR           6
#define SERIAL_OVERRUN_ERR      7
#define FRAMING_ERR             8
#define BUFFER_OVERRUN_ERR      9

#define BYTES_XMITED_UNCOMP     10      //Compression Stats
#define BYTES_RCVED_UNCOMP      11
#define BYTES_XMITED_COMP       12
#define BYTES_RCVED_COMP        13

typedef struct  tagRAS_STATISTICS
{
    DWORD   S_NumOfStatistics ;
    DWORD   S_Statistics[NUM_RAS_SERIAL_STATS] ;
} RAS_STATISTICS, FAR* LPRAS_STATISTICS;
#endif // WINNT_RAS

//**************************************************************************
//  Script support
//**************************************************************************

// Script processing mode
//
#define NORMAL_MODE         0
#define TEST_MODE           1

typedef DWORD (WINAPI * PFN_RUN_SCRIPT)(HANDLE, LPSESS_CONFIGURATION_INFO);

#endif // _RNAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasscrpt\scrpthlp.h ===
//****************************************************************************
//
//  Module:     SMMSCRPT.DLL
//  File:       scrpthlp.h
//  Content:    This file contains the context-sensitive help header.
//
//  Copyright (c) Microsoft Corporation 1991-1994
//
//****************************************************************************

#ifndef WINNT_RAS
//
// We are not using the help supplied with the Win9x code,
// so the header below has been commented out. Note that there is 
// a header of the same name in this file's directory, so if the #include
// is uncommented below, the preprocessor will go into an infinite loop.
// This doesn't happen on Win9x because there is a header named scrpthlp.h
// in the compiler's include-file search-path.
//
#include <scrpthlp.h>

#endif // !WINNT_RAS

//****************************************************************************
// Context-sentive help/control mapping arrays
//****************************************************************************

extern DWORD gaTerminal[];
extern DWORD gaDebug[];

void NEAR PASCAL ContextHelp (LPDWORD aHelp, UINT uMsg, WPARAM wParam,
                              LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasscrpt\scriptp.h ===
//============================================================================
// Copyright (c) 1996, Microsoft Corporation
//
// File:    scriptp.h
//
// History:
//  Abolade-Gbadegesin  04-01-96    Created.
//
// Contains private declarations for dial-up scripting.
//
// Most of the code for script-processing is Win9x code.
// The port consisted of wiring the Win9x code to NT entry-points,
// in order to allow scripts to work without a terminal window.
// This DLL thus exports a function which can be called to run a script
// to completion (RasScriptExecute), as well as a set of functions
// which together provide a way for the caller to start script-processing
// and receive notification when data is received or when certain events
// occur during script execution. The notification may be event-based
// or message-based (i.e. via SetEvent or via SendNotifyMessage).
//
// The code is rewired at the upper level, by providing the functions
// defined in RASSCRPT.H as the interface to scripting, as well as
// at the lower level, by replacing Win9x's Win32 COMM calls with calls
// to RASMAN to send and receive data. The changes to the Win9x code
// can be found by searching for the string "WINNT_RAS" which is used
// in #ifdef statements to demarcate modifications.
// Generally, the upper-level functions have names like Rs*
// and the lower-level functions have names like Rx*.
//
// The Win9x code is heavily dependent on there being an HWND
// for messages to be sent to. This is not always the case on NT,
// and so code which uses an HWND on Win9x has been modified on NT
// to expect instead a pointer to a SCRIPTDATA structure; this structure
// contains enough information for the code to achieve whatever is needed.
//
// Script initialization produces a HANDLE which is actually a pointer
// to a SCRIPTCB. The SCRIPTCB contains all information needed to manage
// an interactive session over a connected RAS link, including the RASMAN port
// and the RASMAN buffers. If the connected link is associated with
// a phonebook entry, then the pdata field of the SCRIPTCB structure
// will be initialized with a SCRIPTDATA, which contains all information
// needed to execute the entry's script during the interactive session.
//
// This SCRIPTDATA contains the Win9x script-processing structures
// (scanner, parsed module, and abstract syntax tree; see NTHDR2.H).
// It also contains fields needed for the Win9x circular-buffer management,
// which is implemented to allow searching for strings across read-boundaries
// (see ReadIntoBuffer() in TERMINAL.C).
//
// Initialization also creates a thread which handles the script-processing.
// This thread runs until the script completes or halts, or until
// RasScriptTerm is called with the HANDLE supplied during initialization.
// (This allows a script to be cancelled while running.)
//
// The Win9x code is completely ANSI based. Rather than edit its code
// to use generic-text (TCHAR), this port uses ANSI as well.
// In certain places, this requires conversions from Unicode,
// which is used by the rest of the RAS UI.
// To find all instances of such conversions, search for UNICODEUI
// in the source code.
//============================================================================


#ifndef _SCRIPTP_H_
#define _SCRIPTP_H_

#include "proj.h"

#ifdef UNICODEUI
#define UNICODE
#undef LPTSTR
#define LPTSTR WCHAR*
#undef TCHAR
#define TCHAR WCHAR
#include <debug.h>
#include <nouiutil.h>
#include <pbk.h>
#undef TCHAR
#define TCHAR CHAR
#undef LPTSTR
#define LPTSTR CHAR*
#undef UNICODE
#endif // UNICODEUI

#include <rasscrpt.h>



//
// flags used in internally in the "dwFlags" field
// of the SCRIPTCB structure; these are in addition to the public flags,
// and start from the high-end of the flags DWORD
//
#define RASSCRIPT_ThreadCreated     0x80000000
#define RASSCRIPT_PbuserLoaded      0x40000000
#define RASSCRIPT_PbfileLoaded      0x20000000


//----------------------------------------------------------------------------
// struct:  SCRIPTCB
//
// control block containing data and state for a script.
//----------------------------------------------------------------------------

#define SCRIPTCB    struct tagSCRIPTCB
SCRIPTCB {


    //
    // connection handle, flags for script processing,
    // notification handle (event or HWND, depending on flags)
    //
    HRASCONN    hrasconn;
    DWORD       dwFlags;
    HANDLE      hNotifier;

    //
    // phonebook entry information
    //
    PBENTRY*    pEntry;
    CHAR*       pszIpAddress;


    //
    // port input/output variables:
    //  RASMAN port handle for data I/O
    //  RASMAN send buffer
    //  RASMAN receive buffer
    //  size of current contents of receive buffer
    //  size of contents read so far by script-interpreter
    //
    HPORT       hport;
    BYTE*       pSendBuffer;
    BYTE*       pRecvBuffer;
    DWORD       dwRecvSize;
    DWORD       dwRecvRead;


    //
    // thread control variables:
    //  event signalled by RASMAN when data is received
    //  event signalled by RasScriptReceive when data has been read
    //  event signalled to stop the thread
    //  event signalled to tell that the ip address changed     bug #75226
    //  event code to be read using RasScriptGetEventCode
    //
    HANDLE      hRecvRequest;
    HANDLE      hRecvComplete;
    HANDLE      hStopRequest;
    HANDLE      hStopComplete;
    DWORD       dwEventCode;


    //
    // script processing variables; the following will be NULL
    // if the entry has no associated script:
    //  Win9x-compatible script-processing structure;
    //  Win9x-compatible connection information
    //
    SCRIPTDATA* pdata;
    SESS_CONFIGURATION_INFO sci;
};



DWORD
RsDestroyData(
    IN      SCRIPTCB*   pscript
    );

DWORD
RsInitData(
    IN      SCRIPTCB*   pscript,
    IN      LPCSTR      pszScriptPath
    );

DWORD
RsThread(
    IN      PVOID       pParam
    );

DWORD
RsThreadProcess(
    IN      SCRIPTCB*   pscript
    );


#ifdef UNICODEUI
#define lstrlenUI               lstrlenW
#define lstrcmpiUI              lstrcmpiW
#define StrCpyAFromUI           WCSTOMBS
#define StrDupUIFromA           StrDupWFromA
#define GetFileAttributesUI     GetFileAttributesW
#else
#define lstrlenUI               lstrlenA
#define lstrcmpiUI              lstrcmpiA
#define StrCpyAFromUI           lstrcpyA
#define StrDupUIFromA           StrDup
#define GetFileAttributesUI     GetFileAttributesA
#endif


#endif // _SCRIPTP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasscrpt\symtab.h ===
//
// Copyright (c) Microsoft Corporation 1995
//
// symtab.h
//
// Header file for the symbol table.
//
// History:
//  04-30-95 ScottH     Created
//

#ifndef __SYMTAB_H__
#define __SYMTAB_H__

//
// DATATYPE
//

typedef enum
    {
    DATA_INT,           // Uses er.nVal
    DATA_BOOL,          // Uses er.bVal
    DATA_STRING,        // Uses er.psz
    DATA_LABEL,         // Uses er.dw as code address
    DATA_PROC,
    } DATATYPE;
DECLARE_STANDARD_TYPES(DATATYPE);


//
// EVALRES (evaluation result)
//

typedef struct tagEVALRES
    {
    union
        {
        LPSTR   psz;
        int     nVal;
        BOOL    bVal;
        ULONG_PTR   dw;
        };
    } EVALRES;
DECLARE_STANDARD_TYPES(EVALRES);

//
// Symbol Table Entry
//

typedef struct tagSTE
    {
    LPSTR   pszIdent;
    DATATYPE dt;
    EVALRES er;
    } STE;      // symbol table entry
DECLARE_STANDARD_TYPES(STE);

RES     PUBLIC STE_Create(PSTE * ppste, LPCSTR pszIdent, DATATYPE dt);
RES     PUBLIC STE_Destroy(PSTE this);
RES     PUBLIC STE_GetValue(PSTE this, PEVALRES per);

#define STE_GetIdent(pste)      ((pste)->pszIdent)
#define STE_GetDataType(pste)   ((pste)->dt)

//
// Symbol Table
//

typedef struct tagSYMTAB
    {
    HPA     hpaSTE;        // element points to STE
    struct tagSYMTAB * pstNext;
    } SYMTAB;
DECLARE_STANDARD_TYPES(SYMTAB);

#define Symtab_GetNext(pst)         ((pst)->pstNext)

RES     PUBLIC Symtab_Destroy(PSYMTAB this);
RES     PUBLIC Symtab_Create(PSYMTAB * ppst, PSYMTAB pstNext);

// Symtab_Find flags
#define STFF_DEFAULT        0x0000
#define STFF_IMMEDIATEONLY  0x0001

RES     PUBLIC Symtab_FindEntry(PSYMTAB this, LPCSTR pszIdent, DWORD dwFlags, PSTE * ppsteOut, PSYMTAB * ppstScope);
RES     PUBLIC Symtab_InsertEntry(PSYMTAB this, PSTE pste);

RES     PUBLIC Symtab_NewLabel(PSYMTAB this, LPSTR pszIdentBuf);


#endif // __SYMTAB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasscrpt\symtab.c ===
//
// Copyright (c) Microsoft Corporation 1995
//
// symtab.c
//
// This file contains the symbol table functions.
//
// History:
//  04-30-95 ScottH     Created
//


#include "proj.h"

#define SYMTAB_SIZE_GROW    10      // in elements

//
// Symbol table entry routines
//


/*----------------------------------------------------------
Purpose: Create a symbol table entry

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC STE_Create(
    PSTE * ppste,
    LPCSTR pszIdent,
    DATATYPE dt)
    {
    RES res;
    PSTE pste;

    ASSERT(ppste);
    ASSERT(pszIdent);

    pste = GAllocType(STE);
    if (pste)
        {
        res = RES_OK;       // assume success

        if ( !GSetString(&pste->pszIdent, pszIdent) )
            res = RES_E_OUTOFMEMORY;
        else
            {
            pste->dt = dt;
            }
        }
    else
        res = RES_E_OUTOFMEMORY;

    // Did anything above fail?
    if (RFAILED(res))
        {
        // Yes; clean up
        STE_Destroy(pste);
        pste = NULL;
        }
    *ppste = pste;

    return res;
    }


/*----------------------------------------------------------
Purpose: Destroy the STE element

Returns: --
Cond:    --
*/
void CALLBACK STE_DeletePAPtr(
    LPVOID pv,
    LPARAM lparam)
    {
    STE_Destroy(pv);
    }


/*----------------------------------------------------------
Purpose: Destroys symbol table entry

Returns: RES_OK
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC STE_Destroy(
    PSTE this)
    {
    RES res;

    if (this)
        {
        if (this->pszIdent)
            GSetString(&this->pszIdent, NULL);  // free

        // (The evalres field should not be freed.  It is
        // a copy from somewhere else.)

        GFree(this);

        res = RES_OK;
        }
    else
        res = RES_E_INVALIDPARAM;

    return res;
    }


/*----------------------------------------------------------
Purpose: Retrieves the symbol table entry value.  The type
         depends on the datatype.

Returns: RES_OK

         RES_E_FAIL (for a type that does not have a value)
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC STE_GetValue(
    PSTE this,
    PEVALRES per)
    {
    RES res;

    ASSERT(this);
    ASSERT(per);

    if (this && per)
        {
        res = RES_OK;       // assume success

        switch (this->dt)
            {
        case DATA_INT:
        case DATA_BOOL:
        case DATA_STRING:
        case DATA_LABEL:
        case DATA_PROC:
            per->dw = this->er.dw;
            break;

        default:
            ASSERT(0);
            res = RES_E_FAIL;
            break;
            }
        }
    else
        res = RES_E_INVALIDPARAM;

    return res;
    }


//
// Symbol Table functions
//

/*----------------------------------------------------------
Purpose: Creates a symbol table

Returns: RES_OK

         RES_E_OUTOFMEMORY
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC Symtab_Create(
    PSYMTAB * ppst,
    PSYMTAB pstNext)            // May be NULL
    {
    RES res;
    PSYMTAB pst;

    ASSERT(ppst);

    pst = GAllocType(SYMTAB);
    if (pst)
        {
        if (PACreate(&pst->hpaSTE, SYMTAB_SIZE_GROW))
            {
            pst->pstNext = pstNext;
            res = RES_OK;
            }
        else
            res = RES_E_OUTOFMEMORY;
        }
    else
        res = RES_E_INVALIDPARAM;

    // Did anything above fail?
    if (RFAILED(res) && pst)
        {
        // Yes; clean up
        Symtab_Destroy(pst);
        pst = NULL;
        }
    *ppst = pst;

    return res;
    }


/*----------------------------------------------------------
Purpose: Destroys a symbol table

Returns: RES_OK
         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC Symtab_Destroy(
    PSYMTAB this)
    {
    RES res;

    if (this)
        {
        if (this->hpaSTE)
            {
            PADestroyEx(this->hpaSTE, STE_DeletePAPtr, 0);
            }
        GFree(this);
        res = RES_OK;
        }
    else
        res = RES_E_INVALIDPARAM;

    return res;
    }


/*----------------------------------------------------------
Purpose: Compare symbol table entries by name.

Returns: 
Cond:    --
*/
int CALLBACK Symtab_Compare(
    LPVOID pv1,
    LPVOID pv2,
    LPARAM lParam)
    {
    PSTE pste1 = pv1;
    PSTE pste2 = pv2;

    return lstrcmpi(pste1->pszIdent, pste2->pszIdent);
    }


/*----------------------------------------------------------
Purpose: Looks for pszIdent in the symbol table entry.
         If STFF_IMMEDIATEONLY is not set, this function will
         look in successive scopes if the symbol is not found
         within this immediate scope.

         Symbol table entry is returned in *psteOut.

Returns: RES_OK (if found)
         RES_FALSE (if not found)

         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC Symtab_FindEntry(
    PSYMTAB this,
    LPCSTR pszIdent,
    DWORD dwFlags,
    PSTE * ppsteOut,        // May be NULL
    PSYMTAB * ppstScope)    // May be NULL
    {
    RES res;

    // Default return values to NULL 
    if (ppsteOut)
        *ppsteOut = NULL;
    if (ppstScope)
        *ppstScope = NULL;

    if (this && pszIdent)
        {
        DWORD iste;
        STE ste;

        // Peform a binary search.  Find a match?

        ste.pszIdent = (LPSTR)pszIdent;
        iste = PASearch(this->hpaSTE, &ste, 0, Symtab_Compare, (LPARAM)this, PAS_SORTED);
        if (PA_ERR != iste)
            {
            // Yes
            PSTE pste = PAFastGetPtr(this->hpaSTE, iste);

            if (ppsteOut)
                *ppsteOut = pste;

            if (ppstScope)
                *ppstScope = this;

            res = RES_OK;
            }
        // Check other scopes?
        else if (IsFlagClear(dwFlags, STFF_IMMEDIATEONLY) && this->pstNext)
            {
            // Yes
            res = Symtab_FindEntry(this->pstNext, pszIdent, dwFlags, ppsteOut, ppstScope);
            }
        else
            res = RES_FALSE;
        }
    else
        res = RES_E_INVALIDPARAM;

    return res;
    }


/*----------------------------------------------------------
Purpose: Insert the given symbol table entry into the symbol
         table.  This function does not prevent duplicate symbols.

Returns: RES_OK

         RES_E_OUTOFMEMORY

Cond:    --
*/
RES PUBLIC Symtab_InsertEntry(
    PSYMTAB this,
    PSTE pste)
    {
    RES res;

    ASSERT(this);
    ASSERT(pste);

    if (PAInsertPtr(this->hpaSTE, PA_APPEND, pste))
        {
        PASort(this->hpaSTE, Symtab_Compare, (LPARAM)this);
        res = RES_OK;
        }
    else
        res = RES_E_OUTOFMEMORY;
    
    return res;
    }



/*----------------------------------------------------------
Purpose: This function generates a unique label name.

Returns: RES_OK
         RES_INVALIDPARAM

Cond:    Caller must free *ppszIdent.

*/
RES PUBLIC Symtab_NewLabel(
    PSYMTAB this,
    LPSTR pszIdentBuf)          // must be size MAX_BUF_KEYWORD
    {
    static int s_nSeed = 0;

#pragma data_seg(DATASEG_READONLY)
    const static char c_szLabelPrefix[] = "__ssh%u";
#pragma data_seg()

    RES res;
    char sz[MAX_BUF_KEYWORD];
    PSTE pste;

    ASSERT(pszIdentBuf);

    do
        {
        // Generate name
        wsprintf(sz, c_szLabelPrefix, s_nSeed++);

        // Is this unique?
        res = Symtab_FindEntry(this, sz, STFF_DEFAULT, NULL, NULL);
        if (RES_FALSE == res)
            {
            // Yes
            res = STE_Create(&pste, sz, DATA_LABEL);
            if (RSUCCEEDED(res))
                {
                res = Symtab_InsertEntry(this, pste);
                if (RSUCCEEDED(res))
                    {
                    lstrcpyn(pszIdentBuf, sz, MAX_BUF_KEYWORD);
                    res = RES_FALSE;    // break out of this loop
                    }
                }
            }
        }
        while(RES_OK == res);

    if (RES_FALSE == res)
        res = RES_OK;

    return res;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\devicedb.c ===
/*
    File    devicedb.c

    Definition of the device database for the ras dialup server.

    Paul Mayfield, 10/2/97
*/

#include "rassrv.h"
#include "precomp.h"
//
// Definitions
//
#define DEV_FLAG_DEVICE      0x1
#define DEV_FLAG_NULL_MODEM  0x2
#define DEV_FLAG_PORT        0x4
#define DEV_FLAG_FILTERED    0x10
#define DEV_FLAG_DIRTY       0x20
#define DEV_FLAG_ENABLED     0x40

// ===================================
// Definitions of the database objects
// ===================================
typedef struct _RASSRV_DEVICE 
{
    PWCHAR pszName;       // Name of device
    DWORD dwType;         // Type of device
    DWORD dwId;           // Id of the item (for tapi properties)
    DWORD dwEndpoints;    // Number of enpoints item has
    DWORD dwFlags;        // see DEV_FLAG_XXX
    WCHAR pszPort[MAX_PORT_NAME + 1];
    struct _RASSRV_DEVICE * pModem; // Modem installed on a com port
                                    // only valid if DEV_FLAG_PORT set
} RASSRV_DEVICE;

typedef struct _RASSRV_DEVICEDB 
{
    DWORD dwDeviceCount;
    RASSRV_DEVICE ** pDeviceList;
    BOOL bFlushOnClose;
    BOOL bVpnEnabled;               // whether pptp or l2tp is enabled
    BOOL bVpnEnabledOrig;           // original value of vpn enabling
} RASSRV_DEVICEDB;

//
// Structure defines a node in a list of ports
//
typedef struct _RASSRV_PORT_NODE 
{
    PWCHAR pszName;
    WCHAR pszPort[MAX_PORT_NAME + 1];
    struct _RASSRV_DEVICE * pModem;     // modem installed on this port
    struct _RASSRV_PORT_NODE * pNext;
} RASSRV_PORT_NODE;

//
// Structure defines a list of ports
//
typedef struct _RASSRV_PORT_LIST 
{
    DWORD dwCount;
    RASSRV_PORT_NODE * pHead;
    WCHAR pszFormat[256];
    DWORD dwFmtLen;
} RASSRV_PORT_LIST;

// Reads device information from the system.
DWORD 
devGetSystemDeviceInfo(
    OUT RAS_DEVICE_INFO ** ppDevice, 
    OUT LPDWORD lpdwCount) 
{
    DWORD dwErr, dwSize, dwVer, dwCount;
    
    // Calculate the size required to enumerate the ras devices
    dwVer = RAS_VERSION;
    dwSize = 0;
    dwCount =0;
    dwErr = RasGetDeviceConfigInfo(NULL, &dwVer, &dwCount, &dwSize, NULL);
    if ((dwErr != ERROR_SUCCESS) && (dwErr != ERROR_BUFFER_TOO_SMALL)) 
    {
        DbgOutputTrace(
            "devGetSysDevInfo: 0x%08x from RasGetDevCfgInfo (1)", 
            dwErr);
        return dwErr;
    }
    *lpdwCount = dwCount;
    
    // If there is nothing to allocate, return with zero devices
    if (dwSize == 0) 
    {
        *lpdwCount = 0;
        return NO_ERROR;
    }
    
    // Allocate the buffer
    if ((*ppDevice = RassrvAlloc(dwSize, FALSE)) == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Enumerate the devices
    dwErr = RasGetDeviceConfigInfo(
                NULL,
                &dwVer, 
                lpdwCount, 
                &dwSize, 
                (LPBYTE)(*ppDevice));
    if (dwErr != ERROR_SUCCESS)
    {                                        
        DbgOutputTrace(
            "devGetSysDevInfo: 0x%08x from RasGetDevCfgInfo (2)", dwErr);
        return dwErr;
    }

    return NO_ERROR;
}

//
// Frees the buffer returned by devGetSystemDeviceInfo
//
DWORD 
devFreeSystemDeviceInfo(
    IN RAS_DEVICE_INFO * pDevice) 
{
    if (pDevice)
    {
        RassrvFree(pDevice);
    }
    
    return NO_ERROR;
}

//
// Returns whether the given device is a physical (i.e. not tunnel) device.
//
BOOL 
devIsPhysicalDevice(
    IN RAS_DEVICE_INFO * pDevice) 
{
    DWORD dwClass = RAS_DEVICE_CLASS (pDevice->eDeviceType);

    return ((dwClass & RDT_Direct)     || 
            (dwClass & RDT_Null_Modem) ||
            (dwClass == 0));
}

//
// Returns whether the given device is a tunneling device
//
BOOL 
devIsTunnelDevice(
    IN RAS_DEVICE_INFO * pDevice) 
{
    DWORD dwClass = RAS_DEVICE_CLASS (pDevice->eDeviceType);

    return (dwClass & RDT_Tunnel); 
}

//
// Finds the device information associated with the given device
// based on its tapi line id
//
DWORD 
devFindDevice(
    IN  RAS_DEVICE_INFO * pDevices, 
    IN  DWORD dwCount,
    OUT RAS_DEVICE_INFO ** ppDevice, 
    IN  DWORD dwTapiLineId) 
{
    DWORD i; 

    // Validate parameters
    if (!pDevices || !ppDevice)
        return ERROR_INVALID_PARAMETER;

    // Initialize
    *ppDevice = NULL;

    // Search the list
    for (i = 0; i < dwCount; i++) 
    {
        if (devIsPhysicalDevice(&pDevices[i])) 
        {
            if (pDevices[i].dwTapiLineId == dwTapiLineId) 
            {
                *ppDevice = &(pDevices[i]);
                break;
            }
        }
    }

    // See if a match was found;
    if (*ppDevice)
    {
        return NO_ERROR;
    }
    
    return ERROR_NOT_FOUND;
}

//
// Determine the type of the device in question
//
DWORD 
devDeviceType(
    IN RAS_DEVICE_INFO * pDevice) 
{
    DWORD dwClass = RAS_DEVICE_CLASS (pDevice->eDeviceType);
    DWORD dwType = RAS_DEVICE_TYPE (pDevice->eDeviceType);

    if ((dwClass & RDT_Direct)     || 
        (dwClass & RDT_Null_Modem) ||
        (dwType  == RDT_Irda)      ||
        (dwType == RDT_Parallel) )
    {
        return INCOMING_TYPE_DIRECT;
    }
    else if (dwClass == RDT_Tunnel)
    {
        return INCOMING_TYPE_VPN;
    }

    return INCOMING_TYPE_PHONE;
}

//
// Returns the flags of a given device
//
DWORD 
devInitFlags(
    IN RAS_DEVICE_INFO * pDevice) 
{
    DWORD dwClass = RAS_DEVICE_CLASS (pDevice->eDeviceType),
          dwRet = 0;

    // Set the device's enabling
    if (pDevice->fRasEnabled)
    {
        dwRet |= DEV_FLAG_ENABLED;
    }

    // Determine if it's a null modem or a device.  It 
    // can't be a port, since those are not reported 
    // through ras.
    if (dwClass & RDT_Null_Modem)
    {
        dwRet |= DEV_FLAG_NULL_MODEM;
    }
    else
    {
        dwRet |= DEV_FLAG_DEVICE;
    }

    // Since the filtered and dirty flags are to be
    // initialized to false, we're done.
    
    return dwRet;
}

//
// Generates the device name
//
PWCHAR 
devCopyDeviceName(
    IN RAS_DEVICE_INFO * pDevice, 
    IN DWORD dwType) 
{
    PWCHAR pszReturn;
    DWORD dwSize;
    PWCHAR pszDccFmt = (PWCHAR) 
        PszLoadString(Globals.hInstDll, SID_DEVICE_DccDeviceFormat);
    PWCHAR pszMultiFmt = (PWCHAR) 
        PszLoadString(Globals.hInstDll, SID_DEVICE_MultiEndpointDeviceFormat);
    WCHAR pszPort[MAX_PORT_NAME + 1];
    WCHAR pszDevice[MAX_DEVICE_NAME + 1];

    // Sanity check the resources
    //
    if (!pszDccFmt || !pszMultiFmt)
    {
        return NULL;
    }

    // Get the unicode versions of the port/device
    //
    pszPort[0] = L'\0';
    pszDevice[0] = L'\0';
    if (pDevice->szPortName)
    {
        StrCpyWFromAUsingAnsiEncoding(
            pszPort, 
            pDevice->szPortName,
            strlen(pDevice->szPortName) + 1);
    } 
    if (pDevice->szDeviceName)
    {
#if 0    
        StrCpyWFromAUsingAnsiEncoding(
            pszDevice, 
            pDevice->szDeviceName,
            strlen(pDevice->szDeviceName) + 1);
#endif

        wcsncpy(
            pszDevice,
            pDevice->wszDeviceName,
            MAX_DEVICE_NAME);

        pszDevice[MAX_DEVICE_NAME] = L'\0';            
    }

    // For direct connections, be sure to display the name of the com port
    // in addition to the name of the null modem.
    if (dwType == INCOMING_TYPE_DIRECT) 
    {
        // Calculate the size
        dwSize = wcslen(pszDevice) * sizeof(WCHAR)  + // device
                 wcslen(pszPort)   * sizeof(WCHAR)  + // com port
                 wcslen(pszDccFmt) * sizeof(WCHAR)  + // oth chars
                 sizeof(WCHAR);                       // null 

        // Allocate the new string
        if ((pszReturn = RassrvAlloc (dwSize, FALSE)) == NULL)   
        {
            return pszReturn;
        }

        wsprintfW(pszReturn, pszDccFmt, pszDevice, pszPort);
    }

    //
    // If it's a modem device with multilple end points (such as isdn) 
    // display the endpoints in parenthesis
    //
    else if ((dwType == INCOMING_TYPE_PHONE) &&
             (pDevice->dwNumEndPoints > 1))
    {
        // Calculate the size
        dwSize = wcslen(pszDevice)   * sizeof(WCHAR) + // device
                 wcslen(pszMultiFmt) * sizeof(WCHAR) + // channels
                 20 * sizeof (WCHAR)                 + // oth chars
                 sizeof(WCHAR);                        // null

        // Allocate the new string
        if ((pszReturn = RassrvAlloc(dwSize, FALSE)) == NULL)
        {
            return pszReturn;
        }

        wsprintfW(
            pszReturn, 
            pszMultiFmt, 
            pszDevice, 
            pDevice->dwNumEndPoints);        
    }

    // Otherwise, this is a modem device with one endpoint.  
    // All that needs to be done here is to copy in the name.
    //
    else 
    {
        // Calculate the size
        dwSize = (wcslen(pszDevice) + 1) * sizeof(WCHAR);
        
        // Allocate the new string
        if ((pszReturn = RassrvAlloc(dwSize, FALSE)) == NULL)
        {
            return pszReturn;
        }

        wcscpy(pszReturn, pszDevice);
    }

    return pszReturn;
}

//
// Commits changes to device configuration to the system.  The call 
// to RasSetDeviceConfigInfo might fail if the device is in the process 
// of being configured so we implement a retry 
// mechanism here.
//
DWORD 
devCommitDeviceInfo(
    IN RAS_DEVICE_INFO * pDevice) 
{
    DWORD dwErr, dwTimeout = 10;
    
    do {
        // Try to commit the information
        dwErr = RasSetDeviceConfigInfo(
                    NULL, 
                    1, 
                    sizeof(RAS_DEVICE_INFO), 
                    (LPBYTE)pDevice);    

        // If unable to complete, wait and try again
        if (dwErr == ERROR_CAN_NOT_COMPLETE) 
        {
            DbgOutputTrace(
                "devCommDevInfo: 0x%08x from RasSetDevCfgInfo (try again)", 
                dwErr);
            Sleep(300);
            dwTimeout--;
        }

        // If completed, return no error
        else if (dwErr == NO_ERROR)
        {
            break;
        }

        // Otherwise, return the error code.
        else 
        {
            DbgOutputTrace(
                "devCommDevInfo: can't commit %S, 0x%08x", 
                pDevice->szDeviceName, dwErr);
                
            break;
        }
        
    } while (dwTimeout);

    return dwErr;
}

//
// Opens a handle to the database of general tab values
//
DWORD 
devOpenDatabase(
    IN HANDLE * hDevDatabase) 
{
    RASSRV_DEVICEDB * This;
    DWORD dwErr, i;
    
    if (!hDevDatabase)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Allocate the database cache
    if ((This = RassrvAlloc(sizeof(RASSRV_DEVICEDB), TRUE)) == NULL) 
    {
        DbgOutputTrace("devOpenDatabase: can't allocate memory -- exiting");
        return ERROR_NOT_ENOUGH_MEMORY;
    }
        
    // Initialize the values from the system
    devReloadDatabase((HANDLE)This);

    // Return the handle
    *hDevDatabase = (HANDLE)This;
    This->bFlushOnClose = FALSE;

    return NO_ERROR;
}

//
// Closes the general database and flushes any changes 
// to the system when bFlushOnClose is TRUE
//
DWORD 
devCloseDatabase(
    IN HANDLE hDevDatabase) 
{
    RASSRV_DEVICEDB * This = (RASSRV_DEVICEDB*)hDevDatabase;
    DWORD i;
    
    // Flush if requested
    if (This->bFlushOnClose)
        devFlushDatabase(hDevDatabase);
    
    // Free all of the device names
    for (i = 0; i < This->dwDeviceCount; i++) 
    {
        if (This->pDeviceList[i]) 
        {
            if (This->pDeviceList[i]->pszName)
            {
                RassrvFree(This->pDeviceList[i]->pszName);
            }
            RassrvFree(This->pDeviceList[i]);
        }
    }

    // Free up the device list cache
    if (This->pDeviceList)
    {
        RassrvFree (This->pDeviceList);
    }

    // Free up the database cache
    RassrvFree(This);

    return NO_ERROR;
}

//
// Commits the changes made to a particular device
//
DWORD 
devCommitDevice (
    IN RASSRV_DEVICE * pDevice, 
    IN RAS_DEVICE_INFO * pDevices,
    IN DWORD dwCount)
{
    RAS_DEVICE_INFO *pDevInfo = NULL;
    
    devFindDevice(pDevices, dwCount, &pDevInfo, pDevice->dwId);
    if (pDevInfo) {
        pDevInfo->fWrite = TRUE;
        pDevInfo->fRasEnabled = !!(pDevice->dwFlags & DEV_FLAG_ENABLED);
        devCommitDeviceInfo(pDevInfo);
    }

    // Mark the device as not dirty
    pDevice->dwFlags &= ~DEV_FLAG_DIRTY;

    return NO_ERROR;
}


BOOL
devIsVpnEnableChanged(
    IN HANDLE hDevDatabase) 
{
    RASSRV_DEVICEDB * pDevDb = (RASSRV_DEVICEDB*)hDevDatabase;

    
    if ( pDevDb )
    {
        return ( pDevDb->bVpnEnabled != pDevDb->bVpnEnabledOrig? TRUE:FALSE );
    }

    return FALSE;

}//devIsVpnEnableChanged()

//
// Commits any changes made to the general tab values 
//
DWORD 
devFlushDatabase(
    IN HANDLE hDevDatabase) 
{
    RASSRV_DEVICEDB * This = (RASSRV_DEVICEDB*)hDevDatabase;
    DWORD dwErr = NO_ERROR, i, dwCount, dwTimeout;
    RAS_DEVICE_INFO * pDevices = NULL;
    RASSRV_DEVICE * pCur = NULL;

    // Validate
    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Get all of the system device information
    dwErr = devGetSystemDeviceInfo(&pDevices, &dwCount);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    // Flush all changed settings to the system
    for (i = 0; i < This->dwDeviceCount; i++) 
    {
        pCur = This->pDeviceList[i];
        
        // If this device needs to be flushed
        if (pCur->dwFlags & DEV_FLAG_DIRTY) 
        {
             // Reset the installed device's enabling if it still 
             // exists in the system
            if ((pCur->dwFlags & DEV_FLAG_DEVICE) ||
                (pCur->dwFlags & DEV_FLAG_NULL_MODEM))
            {                
                devCommitDevice(pCur, pDevices, dwCount);
            }                

            // If this is a com port, then we should enable that modem
            // installed on the port if it exists or install a null modem  
            // over it if not.
            else if (pCur->dwFlags & DEV_FLAG_PORT) 
            {
                // If this port is associated with an already installed
                // null modem, then set the enabling on this modem if 
                // it is different
                if (pCur->pModem != NULL)
                {                      
                    if ((pCur->dwFlags & DEV_FLAG_ENABLED) != 
                        (pCur->pModem->dwFlags & DEV_FLAG_ENABLED))
                    {
                        devCommitDevice (
                            pCur->pModem, 
                            pDevices, 
                            dwCount);
                    }
                }                 

                // Otherwise, (if there is no null modem associated with 
                // this port) install a null modem over this port if 
                // it is set to enabled.
                else if (pCur->dwFlags & DEV_FLAG_ENABLED)
                {
                    dwErr = MdmInstallNullModem (pCur->pszPort);
                }                                
            }
        }
    }

    // Flush all of the changed vpn settings
    if (This->bVpnEnabled != This->bVpnEnabledOrig) 
    {
        for (i = 0; i < dwCount; i++) 
        {
            if (devIsTunnelDevice(&pDevices[i])) 
            {
                pDevices[i].fWrite = TRUE;
                pDevices[i].fRasEnabled = This->bVpnEnabled;
                devCommitDeviceInfo(&pDevices[i]);    
            }
        }
        This->bVpnEnabledOrig = This->bVpnEnabled;
    }

    // Cleanup
    if (pDevices)
    {
        devFreeSystemDeviceInfo(pDevices);
    }        

    return dwErr;
}

//
// Rollsback any changes made to the general tab values
//
DWORD 
devRollbackDatabase(
    IN HANDLE hDevDatabase) 
{
    RASSRV_DEVICEDB * This = (RASSRV_DEVICEDB*)hDevDatabase;
    if (This == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    This->bFlushOnClose = FALSE; 
    return NO_ERROR;
}

//
// Reloads the device database
//
DWORD 
devReloadDatabase(
    IN HANDLE hDevDatabase) 
{
    RASSRV_DEVICEDB * This = (RASSRV_DEVICEDB*)hDevDatabase;
    DWORD dwErr = NO_ERROR, i, j = 0, dwSize;
    RAS_DEVICE_INFO * pRasDevices; 
    RASSRV_DEVICE * pTempList, *pDevice;

    // Validate
    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Initialize vpn status
    This->bVpnEnabled = FALSE;
    
    // Get the device information from rasman
    pRasDevices = NULL;
    dwErr = devGetSystemDeviceInfo(&pRasDevices, &This->dwDeviceCount);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }
    
    do
    {
        // Initialize the incoming ras capable devices list
        if (This->dwDeviceCount) 
        {
            dwSize = sizeof(RASSRV_DEVICE*) * This->dwDeviceCount;
            This->pDeviceList = RassrvAlloc(dwSize, TRUE);
            if (!This->pDeviceList)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            // Build the device array accordingly
            j = 0;
            for (i = 0; i < This->dwDeviceCount; i++) 
            {
                // If it's a physical device, fill in the appropriate 
                // fields.
                if (devIsPhysicalDevice(&pRasDevices[i])) 
                {
                    // Allocate the new device
                    pDevice = RassrvAlloc(sizeof(RASSRV_DEVICE), TRUE);
                    if (pDevice == NULL)
                    {
                        continue;
                    }

                    // Assign its values                        
                    pDevice->dwType      = devDeviceType(&pRasDevices[i]);
                    pDevice->dwId        = pRasDevices[i].dwTapiLineId;
                    pDevice->pszName     = devCopyDeviceName(
                                              &pRasDevices[i],
                                              pDevice->dwType);
                    pDevice->dwEndpoints = pRasDevices[i].dwNumEndPoints;
                    pDevice->dwFlags     = devInitFlags(&pRasDevices[i]);
                    StrCpyWFromA(
                        pDevice->pszPort, 
                        pRasDevices[i].szPortName,
                        MAX_PORT_NAME + 1);
                    This->pDeviceList[j] = pDevice;                              
                    j++;
                }

                // If any tunneling protocol is enabled, we consider all 
                // to be
                else if (devIsTunnelDevice(&pRasDevices[i])) 
                {
                    This->bVpnEnabled |= pRasDevices[i].fRasEnabled;
                    This->bVpnEnabledOrig = This->bVpnEnabled;
                }
            }

            // Set the actual size of phyiscal adapters buffer.
            This->dwDeviceCount = j;
        }

    } while (FALSE);
    
    // Cleanup 
    {
        devFreeSystemDeviceInfo(pRasDevices);
    }

    return dwErr;
}

//
// Filters out all devices in the database except those that
// meet the given type description (can be ||'d).
//
DWORD 
devFilterDevices(
    IN HANDLE hDevDatabase, 
    DWORD dwType) 
{
    RASSRV_DEVICEDB * This = (RASSRV_DEVICEDB*)hDevDatabase;
    RASSRV_DEVICE * pDevice;
    DWORD i;
    
    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Go through the list of marking out devices to be filtered
    for (i = 0; i < This->dwDeviceCount; i++) 
    {
        pDevice = This->pDeviceList[i];
        if (pDevice == NULL)
        {
            continue;
        }            
        if (pDevice->dwType & dwType)
        {
            pDevice->dwFlags &= ~DEV_FLAG_FILTERED;
        }
        else
        {
            pDevice->dwFlags |= DEV_FLAG_FILTERED;
        }
    }

    return NO_ERROR;
}

//
// Device enumeration function.  Returns TRUE to stop enumeration,
// FALSE to continue.
//
BOOL devAddPortToList (
        IN PWCHAR pszPort,
        IN HANDLE hData) 
{
    RASSRV_PORT_LIST * pList = (RASSRV_PORT_LIST*)hData;
    RASSRV_PORT_NODE * pNode = NULL;
    DWORD dwSize;

    // Create the new node
    pNode = (RASSRV_PORT_NODE *) RassrvAlloc(sizeof(RASSRV_PORT_NODE), TRUE);
    if (pNode == NULL)
    {
        return FALSE;
    }

    // Add it to the head
    pNode->pNext = pList->pHead;
    pList->pHead = pNode;
    pList->dwCount++;

    // Add the names of the port
    if (pszPort) 
    {
        dwSize = (wcslen(pszPort) + pList->dwFmtLen + 1) * sizeof(WCHAR);
        pNode->pszName = (PWCHAR) RassrvAlloc (dwSize, FALSE);
        if (pNode->pszName == NULL)
        {
            return TRUE;
        }
        wsprintfW (pNode->pszName, pList->pszFormat, pszPort);
        lstrcpynW(pNode->pszPort, pszPort, sizeof(pNode->pszPort) / sizeof(WCHAR));
    }            

    return FALSE;
}

//
// Cleans up the resources used in a device list
//
DWORD 
devCleanupPortList(
    IN RASSRV_PORT_LIST * pList) 
{
    RASSRV_PORT_NODE * pCur = NULL, * pNext = NULL;

    pCur = pList->pHead;
    while (pCur) 
    {
        pNext = pCur->pNext;
        RassrvFree(pCur);
        pCur = pNext;
    }

    return NO_ERROR;
}

// 
// Removes all ports from the list for which there are already
// devices installed in the database.
//
DWORD devFilterPortsInUse (
        IN RASSRV_DEVICEDB *This, 
        RASSRV_PORT_LIST *pList)
{
    RASSRV_PORT_LIST PortList, *pDelete = &PortList;
    RASSRV_PORT_NODE * pCur = NULL, * pPrev = NULL;
    RASSRV_DEVICE * pDevice;
    DWORD i;
    BOOL bDone;
    INT iCmp;

    // If the list is empty, return
    if (pList->dwCount == 0)
    {
        return NO_ERROR;
    }

    // Initailize
    ZeroMemory(pDelete, sizeof(RASSRV_PORT_LIST));
    
    // Compare all of the enumerated ports to the ports 
    // in use in the device list.
    for (i = 0; i < This->dwDeviceCount; i++) 
    {
        // Point to the current device
        pDevice = This->pDeviceList[i];
    
        // Initialize the current and previous and break if the
        // list is now empty
        pCur = pList->pHead;
        if (pCur == NULL)
        {
            break;
        }

        // Remove the head node until it doesn't match
        bDone = FALSE;
        while ((pList->pHead != NULL) && (bDone == FALSE)) 
        {
            iCmp = lstrcmpi (pDevice->pszPort,
                             pList->pHead->pszPort);
            // If a device is already using this com port
            // then remove the com port from the list since it
            // isn't available
            if ((pDevice->dwFlags & DEV_FLAG_DEVICE) && (iCmp == 0)) 
            {
                pCur = pList->pHead->pNext;
                RassrvFree(pList->pHead);
                pList->pHead = pCur;
                pList->dwCount -= 1;
            }
            else 
            {
                // If the device is a null modem, then we filter
                // it out of the list of available devices and we 
                // reference it in the com port so that we can 
                // enable/disable it later if we need to.
                if (iCmp == 0) 
                {
                   pDevice->dwFlags |= DEV_FLAG_FILTERED;
                   pList->pHead->pModem = pDevice;
                }
                bDone = TRUE;
            }
        }

        // If we've elimated everyone, return
        if (pList->dwCount == 0)
        {
            return NO_ERROR;
        }

        // Loop through all of the past the head removing those
        // that are in use by the current ras device.
        pPrev = pList->pHead;
        pCur = pPrev->pNext;
        while (pCur) 
        {
            iCmp = lstrcmpi (pDevice->pszPort,
                             pCur->pszPort);
            // If a device is already using this com port
            // that remove the com port from the list since it
            // isn't available
            if ((pDevice->dwFlags & DEV_FLAG_DEVICE) && (iCmp == 0)) 
            {
                pPrev->pNext = pCur->pNext;
                RassrvFree(pCur);
                pCur = pPrev->pNext;
                pList->dwCount -= 1;
            }
            else 
            {
                // If the device is a null modem, then we filter
                // it out of the list of available devices and we 
                // reference it in the com port so that we can 
                // enable/disable it later if we need to.
                if (iCmp == 0) 
                {
                    pDevice->dwFlags |= DEV_FLAG_FILTERED;
                    pCur->pModem = pDevice;
                }
                pCur = pCur->pNext;
                pPrev = pPrev->pNext;
            }                
        }            
    }

    return NO_ERROR;
}

//
// Adds com ports as uninstalled devices in the device database
//
DWORD 
devAddComPorts(
    IN HANDLE hDevDatabase) 
{
    RASSRV_DEVICEDB * This = (RASSRV_DEVICEDB*)hDevDatabase;
    RASSRV_PORT_LIST PortList, *pList = &PortList;
    RASSRV_PORT_NODE * pNode = NULL;
    RASSRV_DEVICE ** ppDevices;
    DWORD dwErr = NO_ERROR, i;
    
    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Initialize the port list
    //
    ZeroMemory (pList, sizeof(RASSRV_PORT_LIST));
    pList->dwFmtLen = LoadStringW (
                        Globals.hInstDll, 
                        SID_COMPORT_FORMAT,
                        pList->pszFormat,
                        sizeof(pList->pszFormat) / sizeof(WCHAR));

    do
    {
        // Create the list of com ports
        dwErr = MdmEnumComPorts(devAddPortToList, (HANDLE)pList);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // Remove any ports that are currently in use
        if ((dwErr = devFilterPortsInUse (This, pList)) != NO_ERROR)
        {
            break;
        }
        
        // If there aren't any ports, return
        if (pList->dwCount == 0)
        {
            break;
        }

        // Resize the list of ports to include the com ports
        ppDevices = RassrvAlloc(
                        sizeof(RASSRV_DEVICE*) * 
                         (This->dwDeviceCount + pList->dwCount),
                        TRUE);
        if (ppDevices == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Copy over the current device information
        CopyMemory( 
            ppDevices, 
            This->pDeviceList, 
            This->dwDeviceCount * sizeof(RASSRV_DEVICE*));

        // Delete the old device list and set to the new one
        RassrvFree(This->pDeviceList);
        This->pDeviceList = ppDevices;

        // Add the ports
        pNode = pList->pHead;
        i = This->dwDeviceCount;
        while (pNode) 
        {
            // Allocate the new device
            ppDevices[i] = RassrvAlloc(sizeof(RASSRV_DEVICE), TRUE);
            if (!ppDevices[i]) 
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }            
            
            // Set all the non-zero values
            ppDevices[i]->dwType    = INCOMING_TYPE_DIRECT;
            ppDevices[i]->pszName   = pNode->pszName;
            ppDevices[i]->pModem    = pNode->pModem;
            ppDevices[i]->dwFlags   = DEV_FLAG_PORT;
            lstrcpynW(
                ppDevices[i]->pszPort, 
                pNode->pszPort,
                sizeof(ppDevices[i]->pszPort) / sizeof(WCHAR));

            // Initialize the enabling of the com port
            if (ppDevices[i]->pModem) 
            {
                ppDevices[i]->dwFlags |= 
                    (ppDevices[i]->pModem->dwFlags & DEV_FLAG_ENABLED);
            }

            // Increment
            i++;
            pNode = pNode->pNext;
        }
        
        This->dwDeviceCount = i;
        
    } while (FALSE);

    // Cleanup
    {
        devCleanupPortList(pList);
    }

    return dwErr;
}

//
// Returns whether the given index lies within the bounds of the
// list of devices store in This.
//
BOOL 
devBoundsCheck(
    IN RASSRV_DEVICEDB * This, 
    IN DWORD dwIndex) 
{
    if (This->dwDeviceCount <= dwIndex) 
    {
        DbgOutputTrace("devBoundsCheck: failed for index %d", dwIndex);
        return FALSE;
    }
    
    return TRUE;
}

// Gets a handle to a device to be displayed in the general tab
DWORD devGetDeviceHandle(
        IN  HANDLE hDevDatabase, 
        IN  DWORD dwIndex, 
        OUT HANDLE * hDevice) 
{
    RASSRV_DEVICEDB * This = (RASSRV_DEVICEDB*)hDevDatabase;
    if (!This || !hDevice)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (!devBoundsCheck(This, dwIndex))
    {
        return ERROR_INVALID_INDEX;
    }

    // Return nothing if device is filtered
    if (This->pDeviceList[dwIndex]->dwFlags & DEV_FLAG_FILTERED) 
    {
        *hDevice = NULL;
        return ERROR_DEVICE_NOT_AVAILABLE;
    }

    // Otherwise, return the device
    else  
    {
        *hDevice = (HANDLE)(This->pDeviceList[dwIndex]);
    }
   
    return NO_ERROR;
}

//
// Returns a count of devices to be displayed in the general tab
//
DWORD devGetDeviceCount(
        IN  HANDLE hDevDatabase, 
        OUT LPDWORD lpdwCount) 
{
    RASSRV_DEVICEDB * This = (RASSRV_DEVICEDB*)hDevDatabase;
    if (!This || !lpdwCount)
    {
        return ERROR_INVALID_PARAMETER;
    }

    *lpdwCount = This->dwDeviceCount;
    
    return NO_ERROR;
}

//
// Returns the count of enabled devices
//
DWORD devGetEndpointEnableCount(
        IN  HANDLE hDevDatabase, 
        OUT LPDWORD lpdwCount) 
{
    RASSRV_DEVICEDB * This = (RASSRV_DEVICEDB*)hDevDatabase;
    DWORD i;
    
    if (!This || !lpdwCount)
    {
        return ERROR_INVALID_PARAMETER;
    }

    *lpdwCount = 0;

    for (i = 0; i < This->dwDeviceCount; i++) 
    {
        if (This->pDeviceList[i]->dwFlags & DEV_FLAG_ENABLED)
        {
            (*lpdwCount) += This->pDeviceList[i]->dwEndpoints;
        }
    }
    
    return NO_ERROR;
}

//
// Loads the vpn enable status
//
DWORD 
devGetVpnEnable(
    IN HANDLE hDevDatabase, 
    IN BOOL * pbEnabled) 
{
    RASSRV_DEVICEDB * This = (RASSRV_DEVICEDB*)hDevDatabase;

    if (!This || !pbEnabled)
    {
        return ERROR_INVALID_PARAMETER;
    }

    *pbEnabled = This->bVpnEnabled;
    
    return NO_ERROR;
}

//
// Saves the vpn enable status
//
DWORD 
devSetVpnEnable(
    IN HANDLE hDevDatabase, 
    IN BOOL bEnable) 
{
    RASSRV_DEVICEDB * This = (RASSRV_DEVICEDB*)hDevDatabase;

    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }        
    
    This->bVpnEnabled = bEnable;
    
    return NO_ERROR;
}

// Saves the vpn Original value enable status
//
DWORD 
devSetVpnOrigEnable(
    IN HANDLE hDevDatabase, 
    IN BOOL bEnable) 
{
    RASSRV_DEVICEDB * This = (RASSRV_DEVICEDB*)hDevDatabase;

    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }        
    
    This->bVpnEnabledOrig = bEnable;
    
    return NO_ERROR;
}

//
// Returns a pointer to the name of a device
//
DWORD 
devGetDeviceName(
    IN  HANDLE hDevice, 
    OUT PWCHAR * pszDeviceName) 
{
    RASSRV_DEVICE* This = (RASSRV_DEVICE*)hDevice;
    if (!This || !pszDeviceName)
    {
        return ERROR_INVALID_PARAMETER;
    }

    *pszDeviceName = This->pszName;

    return NO_ERROR;
}

//
// Returns the type of a device
//
DWORD 
devGetDeviceType(
    IN  HANDLE hDevice, 
    OUT LPDWORD lpdwType) 
{
    RASSRV_DEVICE* This = (RASSRV_DEVICE*)hDevice;
    if (!This || !lpdwType)
    {
        return ERROR_INVALID_PARAMETER;
    }

    *lpdwType = This->dwType;

    return NO_ERROR;
}

//
// Returns an identifier of the device that can be used in 
// tapi calls.
//
DWORD 
devGetDeviceId(
    IN  HANDLE hDevice, 
    OUT LPDWORD lpdwId) 
{
    RASSRV_DEVICE* This = (RASSRV_DEVICE*)hDevice;
    if (!This || !lpdwId)
    {
        return ERROR_INVALID_PARAMETER;
    }

    *lpdwId = This->dwId;

    //
    // If this is a com port referencing a null modem,
    // then return the tapi id of the null modem
    //
    if ((This->dwFlags & DEV_FLAG_PORT) && (This->pModem))
    {
        *lpdwId = This->pModem->dwId;
    }

    return NO_ERROR;
}

//
// Returns the enable status of a device for dialin
//
DWORD 
devGetDeviceEnable(
    IN  HANDLE hDevice, 
    OUT BOOL * pbEnabled) 
{
    RASSRV_DEVICE* This = (RASSRV_DEVICE*)hDevice;
    if (!This || !pbEnabled)
    {
        return ERROR_INVALID_PARAMETER;
    }

    *pbEnabled = !!(This->dwFlags & DEV_FLAG_ENABLED);

    return NO_ERROR;
}

//
// Sets the enable status of a device for dialin
//
DWORD 
devSetDeviceEnable(
    IN HANDLE hDevice, 
    IN BOOL bEnable) 
{
    RASSRV_DEVICE* This = (RASSRV_DEVICE*)hDevice;
    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Mark the enabling and mark the device as dirty
    if (bEnable)
    {
        This->dwFlags |= DEV_FLAG_ENABLED;
    }
    else
    {
        This->dwFlags &= ~DEV_FLAG_ENABLED;
    }
        
    This->dwFlags |= DEV_FLAG_DIRTY;

    return NO_ERROR;
}

//
// Returns whether the given device is a com port as added
// by devAddComPorts
//
DWORD 
devDeviceIsComPort(
    IN  HANDLE hDevice, 
    OUT PBOOL pbIsComPort)
{
    RASSRV_DEVICE* This = (RASSRV_DEVICE*)hDevice;
    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // This is a com port if it was added by 
    // devAddComPorts and if it has no null
    // modem associated with it.
    //
    if ((This->dwFlags & DEV_FLAG_PORT) &&
        (This->pModem == NULL)
       )
    {
        *pbIsComPort = TRUE;
    }
    else
    {
        *pbIsComPort = FALSE;
    }
        
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasscrpt\terminal.c ===
//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//
// Copyright  1993-1995  Microsoft Corporation.  All Rights Reserved.
//
//      MODULE:         terminal.c
//
//      PURPOSE:        Terminal screen simulation
//
//	PLATFORMS:	Windows 95
//
//      FUNCTIONS:
//              TransferData()
//              TerminalDlgWndProc()
//              TerminalScreenWndProc()
//              OnCommand()
//              InitTerminalDlg()
//              TerminateTerminal()
//              GetInput()
//              SendByte()
//              AdjustTerminal()
//              UpdateTerminalCaption()
//              TerminalThread()
//
//	SPECIAL INSTRUCTIONS: N/A
//

#include "proj.h"    // includes common header files and global declarations
#include "rcids.h"   // includes the resource definitions
#ifndef WINNT_RAS
//
// See scrpthlp.h for information on why this has been commented out.
//
#include "scrpthlp.h"// include context-sensitive help

#endif // WINNT_RAS

//****************************************************************************
// Constants Declaration
//****************************************************************************

#define MAXTITLE               32
#define MAXMESSAGE             256

#define WM_MODEMNOTIFY         (WM_USER + 998)
#define WM_EOLFROMDEVICE       (WM_USER + 999)
#define WM_PROCESSSCRIPT       (WM_USER + 1000)

#ifndef WINNT_RAS
//
// The definitions below are overriden in nthdr2.h, and have been removed here
// to avoid multiple definitions
//

#define SIZE_ReceiveBuf        1024
#define SIZE_SendBuf           1

#endif // !WINNT_RAS

#define Y_MARGIN               4
#define Y_SMALL_MARGIN         2
#define X_SPACING              2
#define MIN_X                  170
#define MIN_Y                  80

#define TERMINAL_BK_COLOR      (RGB( 0, 0, 0 ))
#define TERMINAL_FR_COLOR      (RGB( 255, 255, 255 ))
#define MAXTERMLINE            24

#define READ_EVENT             0
#define STOP_EVENT             1
#define MAX_EVENT              2

#define SENDTIMEOUT            50

#define CE_DELIM               256

#define TRACE_MARK             "->"
#define TRACE_UNMARK           "  "
#define INVALID_SCRIPT_LINE    0xFFFFFFFF

#define PROMPT_AT_COMPLETION   1

//****************************************************************************
// Type Definitions
//****************************************************************************

typedef struct tagFINDFMT 
  {
  LPSTR pszFindFmt;     // Allocated: formatted string to find
  LPSTR pszBuf;         // Optional pointer to buffer; may be NULL
  UINT  cbBuf;
  DWORD dwFlags;        // FFF_*
  } FINDFMT;
DECLARE_STANDARD_TYPES(FINDFMT);

typedef struct  tagTERMDLG {
    HANDLE   hport;
    HANDLE   hThread;
    HANDLE   hEvent[MAX_EVENT];
    HWND     hwnd;
    PBYTE    pbReceiveBuf;  // circular buffer
    PBYTE    pbSendBuf;
    UINT     ibCurFind;
    UINT     ibCurRead;
    UINT     cbReceiveMax;  // count of read bytes
    HBRUSH   hbrushScreenBackgroundE;
    HBRUSH   hbrushScreenBackgroundD;
    HFONT    hfontTerminal;
    PSCANNER pscanner;
    PMODULEDECL pmoduledecl;
    ASTEXEC  astexec;
    SCRIPT   script;
    WNDPROC  WndprocOldTerminalScreen;
    BOOL     fInputEnabled;
    BOOL     fStartRestored;
    BOOL     rgbDelim[CE_DELIM];

    // The following fields are strictly for test screen
    //
    BOOL     fContinue;
    HWND     hwndDbg;
    DWORD    iMarkLine;

}   TERMDLG, *PTERMDLG, FAR* LPTERMDLG;

#define IS_TEST_SCRIPT(ptd)     (ptd->script.uMode == TEST_MODE)

//****************************************************************************
// Function prototypes
//****************************************************************************

LRESULT FAR PASCAL TerminalDlgWndProc(HWND   hwnd,
                                      UINT   wMsg,
                                      WPARAM wParam,
                                      LPARAM lParam );
LRESULT FAR PASCAL TerminalScreenWndProc(HWND   hwnd,
                                         UINT   wMsg,
                                         WPARAM wParam,
                                         LPARAM lParam );
BOOL NEAR PASCAL OnCommand (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
LRESULT NEAR PASCAL InitTerminalDlg(HWND hwnd);
void NEAR PASCAL TerminateTerminal(HWND hwnd, UINT id);
BOOL NEAR PASCAL GetInput  (HWND hwnd);
VOID NEAR PASCAL AdjustTerminal (HWND hwnd, int wWidth, int wHeight);
void NEAR PASCAL UpdateTerminalCaption(PTERMDLG ptd, UINT ids);
void WINAPI      TerminalThread (PTERMDLG  pTerminaldialog);
void PRIVATE Terminal_NextCommand(PTERMDLG ptd, HWND hwnd);

// The following functions are used by test screen only
//
BOOL NEAR PASCAL DisplayScript (PTERMDLG ptd);
LRESULT FAR PASCAL DbgScriptDlgProc(HWND   hwnd,
                                    UINT   wMsg,
                                    WPARAM wParam,
                                    LPARAM lParam );
BOOL NEAR PASCAL InitDebugWindow (HWND hwnd);
void NEAR PASCAL TrackScriptLine(PTERMDLG ptd, DWORD iLine);

/*----------------------------------------------------------------------------
** Terminal dialog routines
**----------------------------------------------------------------------------
*/

BOOL PUBLIC TransferData(
    HWND   hwnd,
    HANDLE hComm,
    PSESS_CONFIGURATION_INFO psci)

    /* Executes the Terminal dialog including error handling.  'hwndOwner' is
    ** the handle of the parent window.  'hport' is the open RAS Manager port
    ** handle to talk on.  'msgidTitle' is the string ID for the Terminal window
    ** caption.
    **
    ** Returns true if successful, false otherwise.
    */
{
  PTERMDLG  ptd;
  COMMTIMEOUTS commtimeout;
  DWORD     id;
  int       i;
  int       iRet;

  // Allocate the terminal buffer
  //
  if ((ptd = (PTERMDLG)LocalAlloc(LPTR, sizeof(*ptd)))
      == NULL)
    return FALSE;

  if ((ptd->pbReceiveBuf = (PBYTE)LocalAlloc(LPTR,
                                           SIZE_ReceiveBuf+ SIZE_SendBuf))
      == NULL)
  {
    LocalFree((HLOCAL)ptd);
    return FALSE;
  };
  ptd->pbSendBuf = ptd->pbReceiveBuf + SIZE_ReceiveBuf;
  ptd->ibCurFind = 0;
  ptd->ibCurRead = 0;
  ptd->cbReceiveMax = 0;
  ptd->fInputEnabled= FALSE;
  ptd->fStartRestored = FALSE;
  ptd->iMarkLine = 0;

  // Initialize the terminal buffer
  //
  ptd->hport   = hComm;
  ptd->hbrushScreenBackgroundE = (HBRUSH)GetStockObject( BLACK_BRUSH );
  ptd->hbrushScreenBackgroundD = (HBRUSH)GetStockObject( WHITE_BRUSH );
  ptd->hfontTerminal = (HFONT)GetStockObject( SYSTEM_FIXED_FONT );
  
  // Create the scanner
  if (RFAILED(Scanner_Create(&ptd->pscanner, psci)))
  {
    LocalFree((HLOCAL)ptd->pbReceiveBuf);
    LocalFree((HLOCAL)ptd);
    return FALSE;
  };

  // Is there a script for this connection?
  if (GetScriptInfo(psci->szEntryName, &ptd->script))
    {
    // Yes; open the script file for scanning
    RES res = Scanner_OpenScript(ptd->pscanner, ptd->script.szPath);

    if (RES_E_FAIL == res)
        {
        MsgBox(g_hinst, 
            hwnd,
            MAKEINTRESOURCE(IDS_ERR_ScriptNotFound),
            MAKEINTRESOURCE(IDS_CAP_Script),
            NULL,
            MB_WARNING,
            ptd->script.szPath);

        ptd->fInputEnabled= TRUE;
        *ptd->script.szPath = '\0';
        ptd->script.uMode = NORMAL_MODE;
        }
    else if (RFAILED(res))
        {
        Scanner_Destroy(ptd->pscanner);
        LocalFree((HLOCAL)ptd->pbReceiveBuf);
        LocalFree((HLOCAL)ptd);
        return FALSE;
        }
    else
        {
        res = Astexec_Init(&ptd->astexec, hComm, psci, 
                           Scanner_GetStxerrHandle(ptd->pscanner));
        if (RSUCCEEDED(res))
            {
            // Parse the script
            res = ModuleDecl_Parse(&ptd->pmoduledecl, ptd->pscanner, ptd->astexec.pstSystem);
            if (RSUCCEEDED(res))
                {
                res = ModuleDecl_Codegen(ptd->pmoduledecl, &ptd->astexec);
                }

            if (RFAILED(res))
                {
                Stxerr_ShowErrors(Scanner_GetStxerrHandle(ptd->pscanner), hwnd);
                }
            }
        }
    }
  else
      {
      ptd->fInputEnabled= TRUE;
      ptd->script.uMode = NORMAL_MODE;
      ptd->fStartRestored = TRUE;
      };

  // Set comm timeout
  //
  commtimeout.ReadIntervalTimeout = MAXDWORD;
  commtimeout.ReadTotalTimeoutMultiplier = 0;
  commtimeout.ReadTotalTimeoutConstant   = 0;
  commtimeout.WriteTotalTimeoutMultiplier= SENDTIMEOUT;
  commtimeout.WriteTotalTimeoutConstant  = 0;
  SetCommTimeouts(hComm, &commtimeout);

  // Start receiving from the port
  //
  SetCommMask(hComm, EV_RXCHAR);

  // Create read thread and the synchronization objects
  for (i = 0; i < MAX_EVENT; i++)
  {
    ptd->hEvent[i] = CreateEvent(NULL, FALSE, FALSE, NULL);
  };

  ptd->hThread = CreateThread(NULL, 0,
                              (LPTHREAD_START_ROUTINE) TerminalThread,
                              ptd, 0, &id);


  // Create the terminal window
#ifdef MODAL_DIALOG
  iRet = DialogBoxParam(g_hinst,
                        MAKEINTRESOURCE(IDD_TERMINALDLG),
                        hwnd,
                        (DLGPROC)TerminalDlgWndProc,
                        (LPARAM)(LPTERMDLG)ptd);
#else
  if (CreateDialogParam(g_hinst,
                        MAKEINTRESOURCE(IDD_TERMINALDLG),
                        hwnd,
                        (DLGPROC)TerminalDlgWndProc,
                        (LPARAM)(LPTERMDLG)ptd))
  {
    MSG msg;

    while(GetMessage(&msg, NULL, 0, 0))
    {
      if ((!IsDialogMessage(ptd->hwnd, &msg)) &&
          ((ptd->hwndDbg == NULL) || !IsDialogMessage(ptd->hwndDbg, &msg)))
      {
        TranslateMessage(&msg);    /* Translates virtual key codes           */
        DispatchMessage(&msg);     /* Dispatches message to window           */
      };
    };
    iRet = (int)msg.wParam;
    DestroyWindow(ptd->hwnd);
  }
  else
  {
    iRet = IDCANCEL;
  };
#endif // MODAL_DIALOG

  // The terminal dialog was terminated, free resources
  //
  SetEvent(ptd->hEvent[STOP_EVENT]);
  SetCommMask(hComm, 0);

  DEBUG_MSG (TF_ALWAYS, "Set stop event and cleared comm mask.");
  WaitForSingleObject(ptd->hThread, INFINITE);
  DEBUG_MSG (TF_ALWAYS, "Read thread was terminated.");

  for (i = 0; i < MAX_EVENT; i++)
  {
    CloseHandle(ptd->hEvent[i]);
  };
  CloseHandle(ptd->hThread);

  Decl_Delete((PDECL)ptd->pmoduledecl);
  Astexec_Destroy(&ptd->astexec);
  Scanner_Destroy(ptd->pscanner);

  LocalFree((HLOCAL)ptd->pbReceiveBuf);
  LocalFree((HLOCAL)ptd);
  return (iRet == IDOK);
}


/*----------------------------------------------------------------------------
** Terminal Window Procedure
**----------------------------------------------------------------------------
*/

void PRIVATE PostProcessScript(
    HWND hwnd)
{
  MSG msg;

  if (!PeekMessage(&msg, hwnd, WM_PROCESSSCRIPT, WM_PROCESSSCRIPT,
                   PM_NOREMOVE))
  {
    PostMessage(hwnd, WM_PROCESSSCRIPT, 0, 0);
  }
}


/*----------------------------------------------------------
Purpose: Execute next command in the script

Returns: --
Cond:    --
*/
void PRIVATE Terminal_NextCommand(
  PTERMDLG ptd,
  HWND hwnd)
{
  if (RES_OK == Astexec_Next(&ptd->astexec))
  {
    if (!Astexec_IsReadPending(&ptd->astexec) &&
      !Astexec_IsPaused(&ptd->astexec))
    {
      HWND hwndNotify;

      if (IS_TEST_SCRIPT(ptd))
      {
        // Do not start processing the next one yet
        //
        ptd->fContinue = FALSE;
        hwndNotify = ptd->hwndDbg;
      }
      else
      {
        hwndNotify = hwnd;
      };

      // Process the next command
      //
      PostProcessScript(hwndNotify);
    };
  };
};


LRESULT FAR PASCAL TerminalDlgWndProc(HWND   hwnd,
                                      UINT   wMsg,
                                      WPARAM wParam,
                                      LPARAM lParam )
{
  PTERMDLG ptd;

  switch (wMsg)
  {
    case WM_INITDIALOG:

      ptd = (PTERMDLG)lParam;
      DEBUG_MSG (TF_ALWAYS, "ptd = %x", ptd);
      SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)lParam);
      ptd->hwnd = hwnd;

      Astexec_SetHwnd(&ptd->astexec, hwnd);

      return (InitTerminalDlg(hwnd));

    case WM_CTLCOLOREDIT:

      // Adjust the screen window only
      //
      if ((HWND)lParam == GetDlgItem(hwnd, CID_T_EB_SCREEN))
      {
        HBRUSH hBrush;
        COLORREF crColorBk, crColorTxt;

        ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);

        if (ptd->fInputEnabled)
        {
          hBrush = ptd->hbrushScreenBackgroundE;
          crColorBk = TERMINAL_BK_COLOR;
          crColorTxt = TERMINAL_FR_COLOR;
        }
        else
        {
          hBrush = ptd->hbrushScreenBackgroundD;
          crColorBk = TERMINAL_FR_COLOR;
          crColorTxt = TERMINAL_BK_COLOR;
        };

        /* Set terminal screen colors to TTY-ish green on black.
        */
        if (hBrush)
        {
          SetBkColor( (HDC)wParam,  crColorBk );
          SetTextColor((HDC)wParam, crColorTxt );

          return (LRESULT)hBrush;
        }
      };
      break;

    case WM_MODEMNOTIFY:
        ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);

        TRACE_MSG(TF_BUFFER, "Received WM_MODEMNOTIFY");

        GetInput(hwnd);

        // Kick the script processing
        //
        PostProcessScript(hwnd);
        return TRUE;

    case WM_PROCESSSCRIPT:
    {
        ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);

        TRACE_MSG(TF_BUFFER, "Received WM_PROCESSSCRIPT");

        if (!ptd->fContinue)
        {
          // We are not allowed to process a new command yet
          //
          return TRUE;
        };

        Terminal_NextCommand(ptd, hwnd);

        // If we are done or halt, show the status
        //
        if (Astexec_IsDone(&ptd->astexec) ||
            Astexec_IsHalted(&ptd->astexec))
        {
          BOOL bHalted = Astexec_IsHalted(&ptd->astexec);

          // Update the title
          //
          UpdateTerminalCaption(ptd, bHalted ? IDS_HALT : IDS_COMPLETE);

          // If the script completes successfully, continue the connection
          //
          if (!bHalted)
          {
            // Terminate the script successfully
            //
            TerminateTerminal(hwnd, IDOK);
          }
          else
          {
            // We are halted, need the user's attention.
            //
            if (IsIconic(hwnd))
            {
              ShowWindow(hwnd, SW_RESTORE);
            };
            SetForegroundWindow(hwnd);
          };

        };
        return TRUE;
    }

    case WM_TIMER: {
        HWND hwndNotify;

        ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);
        
        TRACE_MSG(TF_GENERAL, "Killing timer");

        Astexec_ClearPause(&ptd->astexec);
        KillTimer(hwnd, TIMER_DELAY);

        // Did we time out on a 'wait..until' statement?
        if (Astexec_IsWaitUntil(&ptd->astexec))
        {
          // Yes; we need to finish processing the 'wait' statement
          // before we step to the next command
          Astexec_SetStopWaiting(&ptd->astexec);
          Astexec_ClearWaitUntil(&ptd->astexec);
          hwndNotify = hwnd;

          ASSERT(TRUE == ptd->fContinue);
        }
        else
        {
          if (IS_TEST_SCRIPT(ptd))
          {
            // Do not start processing the next one yet
            //
            ptd->fContinue = FALSE;
            hwndNotify = ptd->hwndDbg;
          }
          else
          {
            hwndNotify = hwnd;
            ASSERT(TRUE == ptd->fContinue);
          }
        }
        PostProcessScript(hwndNotify);
        }
        return TRUE;

    case WM_COMMAND:

      // Handle the control activities
      //
      return OnCommand(hwnd, wMsg, wParam, lParam);

    case WM_DESTROY:
      ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);
      SetWindowLongPtr( GetDlgItem(hwnd, CID_T_EB_SCREEN), GWLP_WNDPROC,
                     (ULONG_PTR)ptd->WndprocOldTerminalScreen );
      break;

    case WM_SIZE:
      AdjustTerminal(hwnd, (int)LOWORD(lParam), (int)HIWORD(lParam));
      break;

    case WM_GETMINMAXINFO:
    {
      MINMAXINFO FAR* lpMinMaxInfo = (MINMAXINFO FAR*)lParam;
      DWORD           dwUnit = GetDialogBaseUnits();

      lpMinMaxInfo->ptMinTrackSize.x = (MIN_X*LOWORD(dwUnit))/4;
      lpMinMaxInfo->ptMinTrackSize.y = (MIN_Y*LOWORD(dwUnit))/4;
      break;
    };

    case WM_HELP:
    case WM_CONTEXTMENU:
      ContextHelp(gaTerminal, wMsg, wParam, lParam);
      break;
  };

  return 0;
}

/*----------------------------------------------------------------------------
** Terminal Screen Subclasses Window Procedure
**----------------------------------------------------------------------------
*/

LRESULT FAR PASCAL TerminalScreenWndProc(HWND   hwnd,
                                         UINT   wMsg,
                                         WPARAM wParam,
                                         LPARAM lParam )
{
  HWND     hwndParent;
  PTERMDLG pTerminaldialog;

  hwndParent      = GetParent(hwnd);
  pTerminaldialog = (PTERMDLG)GetWindowLongPtr(hwndParent, DWLP_USER);

  if (wMsg == WM_EOLFROMDEVICE)
  {
    /* Remove the first line if the next line exceeds the maximum line
    */
    if (SendMessage(hwnd, EM_GETLINECOUNT, 0, 0L) == MAXTERMLINE)
    {
      SendMessage(hwnd, EM_SETSEL, 0,
                  SendMessage(hwnd, EM_LINEINDEX, 1, 0L));
      SendMessage(hwnd, EM_REPLACESEL, 0, (LPARAM)(LPSTR)"");
      SendMessage(hwnd, EM_SETSEL, 32767, 32767);
      SendMessage(hwnd, EM_SCROLLCARET, 0, 0);
    };

    /* An end-of-line in the device input was received.  Send a linefeed
    ** character to the window.
    */
    wParam = '\n';
    wMsg = WM_CHAR;
  }
  else
  {
    BOOL fCtrlKeyDown = (GetKeyState( VK_CONTROL ) < 0);
    BOOL fShiftKeyDown = (GetKeyState( VK_SHIFT ) < 0);

    if (wMsg == WM_KEYDOWN)
    {
      /* The key was pressed by the user.
      */
      if (wParam == VK_RETURN && !fCtrlKeyDown && !fShiftKeyDown)
      {
        /* Enter key pressed without Shift or Ctrl is discarded.  This
        ** prevents Enter from being interpreted as "press default
        ** button" when pressed in the edit box.
        */
        return 0;
      }

      if (fCtrlKeyDown && wParam == VK_TAB)
      {
        /* Ctrl+Tab pressed.  Send a tab character to the device.
        ** Pass tab thru to let the edit box handle the visuals.
        ** Ctrl+Tab doesn't generate a WM_CHAR.
        */
        if (pTerminaldialog->fInputEnabled)
        {
          SendByte(hwndParent, (BYTE)VK_TAB);
        };
      }

      if (GetKeyState( VK_MENU ) < 0)
      {
        return (CallWindowProc(pTerminaldialog->WndprocOldTerminalScreen, hwnd, wMsg, wParam, lParam ));
      };
    }
    else if (wMsg == WM_CHAR)
    {
      /* The character was typed by the user.
      */
      if (wParam == VK_TAB)
      {
        /* Ignore tabs...Windows sends this message when Tab (leave
        ** field) is pressed but not when Ctrl+Tab (insert a TAB
        ** character) is pressed...weird.
        */
        return 0;
      }

      if (pTerminaldialog->fInputEnabled)
      {
        SendByte(hwndParent, (BYTE)wParam);
      };
      return 0;
    }
  }

  /* Call the previous window procedure for everything else.
  */
  return (CallWindowProc(pTerminaldialog->WndprocOldTerminalScreen, hwnd, wMsg, wParam, lParam ));
}

/*----------------------------------------------------------------------------
** Terminal Window's Control Handler
**----------------------------------------------------------------------------
*/

BOOL NEAR PASCAL OnCommand (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  switch (LOWORD(wParam))
  {
    case CID_T_EB_SCREEN:
    {
      switch (HIWORD(wParam))
      {
        case EN_SETFOCUS:
        {
          /* Turn off the default button whenever the terminal
          ** window has the focus.  Pressing [Return] in the
          ** terminal acts like a normal terminal.
          */
          SendDlgItemMessage(hwnd, CID_T_PB_ENTER, BM_SETSTYLE,
                             (WPARAM)BS_DEFPUSHBUTTON, TRUE);

          /* Don't select the entire string on entry.
          */
          SendDlgItemMessage(hwnd, CID_T_EB_SCREEN, EM_SETSEL,
                             32767, 32767);
          SendMessage(hwnd, EM_SCROLLCARET, 0, 0);
          break;
        };
      };

      break;
    };

    case CID_T_CB_INPUT:
    {
      PTERMDLG ptd;

      ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);

      ptd->fInputEnabled = IsDlgButtonChecked(hwnd, CID_T_CB_INPUT);
      InvalidateRect(hwnd, NULL, FALSE);
      SetFocus(GetDlgItem(hwnd, CID_T_EB_SCREEN));
      break;
    }

    case IDOK:
    case IDCANCEL:
      TerminateTerminal(hwnd, LOWORD(wParam));
      break;
  };
  return 0;
}

/*----------------------------------------------------------------------------
** Initialize Terminal window
**----------------------------------------------------------------------------
*/

LRESULT NEAR PASCAL InitTerminalDlg(HWND hwnd)
{
  HWND hwndScrn;
  RECT rect;
  PTERMDLG ptd;
  WINDOWPLACEMENT wp;
  BOOL fRet;

  ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);

  // Install subclassed WndProcs.
  //
  hwndScrn = GetDlgItem(hwnd, CID_T_EB_SCREEN);
  ptd->WndprocOldTerminalScreen =
      (WNDPROC)SetWindowLongPtr( hwndScrn, GWLP_WNDPROC,
                              (ULONG_PTR)TerminalScreenWndProc );

  // Set the terminal screen font
  //
  SendMessage(hwndScrn, WM_SETFONT, (WPARAM)ptd->hfontTerminal,
              0L);


  // Get the recorded window placement
  //
  if ((fRet = GetSetTerminalPlacement(ptd->pscanner->psci->szEntryName,
                                      &wp, TRUE)) &&
      (wp.length >= sizeof(wp)))
  {
    // We have one, set it
    //
    SetWindowPlacement(hwnd, &wp);
  }
  else
  {
    // If nothing was specified at all, default to minimized
    // otherwise use the state set by scripter
    //
    if (!fRet)
    {
      wp.showCmd = SW_SHOWMINNOACTIVE;
    };

    // Start with minimized window
    //
    ShowWindow(hwnd, wp.showCmd);
  };

  // Adjust the dimension
  //
  GetClientRect(hwnd, &rect);
  AdjustTerminal(hwnd, rect.right-rect.left, rect.bottom-rect.top);

  // Adjust window activation
  //
  if (!IsIconic(hwnd))
  {
    SetForegroundWindow(hwnd);
  }
  else
  {
    CheckDlgButton(hwnd, CID_T_CB_MIN, BST_CHECKED);

    // if we are in debug mode, just bring it up
    //
    if (IS_TEST_SCRIPT(ptd) || ptd->fStartRestored)
    {
      ShowWindow(hwnd, SW_NORMAL);
      SetForegroundWindow(hwnd);
    };
  };

  // Initialize the input enable
  //
  CheckDlgButton(hwnd, CID_T_CB_INPUT,
                 ptd->fInputEnabled ? BST_CHECKED : BST_UNCHECKED);

  // Set the window icon
  //
  SendMessage(hwnd, WM_SETICON, TRUE,
              (LPARAM)LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_SCRIPT)));

  // Set the input focus to the screen
  //
  UpdateTerminalCaption(ptd, IDS_RUN);

  // Display the script window
  //
  if (IS_TEST_SCRIPT(ptd))
  {
    // Do not start until the debug window says so
    //
    ptd->fContinue = FALSE;

    // Start the debug window
    //
    if (!DisplayScript(ptd))
    {
      // Cannot start the debug window, switch to normal mode
      //
      ptd->fContinue = TRUE;
      ptd->script.uMode = NORMAL_MODE;
    };
  }
  else
  {
    // Start immediately
    //
    ptd->fContinue = TRUE;
    ptd->hwndDbg   = NULL;
  };

  // Start receiving from the port
  //
  PostMessage(hwnd, WM_MODEMNOTIFY, 0, 0);

  return 0;
}

/*----------------------------------------------------------------------------
** Terminal window termination
**----------------------------------------------------------------------------
*/

void NEAR PASCAL TerminateTerminal(HWND hwnd, UINT id)
{
  PTERMDLG ptd;
  WINDOWPLACEMENT wp;

  ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);

  // Get the current window placement and record it
  //
  wp.length = sizeof(wp);
  if (GetWindowPlacement(hwnd, &wp))
  {
    // If user specifies start-minimized, remember it
    //
    if (IsDlgButtonChecked(hwnd, CID_T_CB_MIN) == BST_CHECKED)
    {
      wp.showCmd = SW_SHOWMINNOACTIVE;
    };

    // Recorded the window placement
    //
    GetSetTerminalPlacement(ptd->pscanner->psci->szEntryName, &wp, FALSE);
  };

  if (IS_TEST_SCRIPT(ptd))
  {
    // Destroy the script window here
    //
    DestroyWindow(ptd->hwndDbg);
  };

  // Terminate the window
  //
#ifdef MODAL_DIALOG
  EndDialog(hwnd, id);
#else
  PostQuitMessage(id);
#endif // MODAL_DIALOG
  return;
}

/*----------------------------------------------------------------------------
** Terminal Input Handler
**----------------------------------------------------------------------------
*/


#ifdef DEBUG

/*----------------------------------------------------------
Purpose: Dumps the read buffer
Returns: 
Cond:    --
*/
void PRIVATE DumpBuffer(
    PTERMDLG ptd)
    {
    #define IS_PRINTABLE(ch)    InRange(ch, 32, 126)

    if (IsFlagSet(g_dwDumpFlags, DF_READBUFFER))
        {
        UINT ib;
        UINT cb;
        UINT cbMax = ptd->cbReceiveMax;
        char szBuf[SIZE_ReceiveBuf+1];
        LPSTR psz = szBuf;

        ASSERT(ptd->ibCurRead >= ptd->ibCurFind);
        ASSERT(SIZE_ReceiveBuf > ptd->ibCurFind);
        ASSERT(SIZE_ReceiveBuf > ptd->ibCurRead);
        ASSERT(SIZE_ReceiveBuf >= cbMax);

        *szBuf = 0;

        for (ib = ptd->ibCurFind, cb = 0; 
            cb < cbMax; 
            ib = (ib + 1) % SIZE_ReceiveBuf, cb++)
            {
            char ch = ptd->pbReceiveBuf[ib];

            if (IS_PRINTABLE(ch))
                *psz++ = ch;
            else
                *psz++ = '.';
            }
        *psz = 0;   // add null terminator

        TRACE_MSG(TF_ALWAYS, "Read buffer: {%s}", (LPSTR)szBuf);
        }
    }

#endif // DEBUG
    

/*----------------------------------------------------------
Purpose: Creates a find format handle.  This function should
         be called to get a handle to use with FindFormat.

Returns: RES_OK
         RES_E_OUTOFMEMORY

Cond:    --
*/
RES PUBLIC CreateFindFormat(
  PHANDLE phFindFmt)
{
  RES res = RES_OK;
  HSA hsa;

  ASSERT(phFindFmt);

  if ( !SACreate(&hsa, sizeof(FINDFMT), 8) )
    res = RES_E_OUTOFMEMORY;

  *phFindFmt = (HANDLE)hsa;

  return res;
}


/*----------------------------------------------------------
Purpose: Adds a formatted search string to the list.

Returns: RES_OK

Cond:    --
*/
RES PUBLIC AddFindFormat(
  HANDLE hFindFmt,
  LPCSTR pszFindFmt,
  DWORD dwFlags,      // FFF_*
  LPSTR pszBuf,       // May be NULL
  DWORD cbBuf)
{
  RES res = RES_OK;
  FINDFMT ff;
  HSA hsa = (HSA)hFindFmt;

  ZeroInit(&ff, FINDFMT);

  if (GSetString(&ff.pszFindFmt, pszFindFmt))
    {
    ff.pszBuf = pszBuf;
    ff.cbBuf = cbBuf;
    ff.dwFlags = dwFlags;

    if ( !SAInsertItem(hsa, SA_APPEND, &ff) )
      res = RES_E_OUTOFMEMORY;
    }
  else
    res = RES_E_OUTOFMEMORY;

  return res;
}


/*----------------------------------------------------------
Purpose: Free a find format item

Returns: --
Cond:    --
*/
void CALLBACK FreeSAFindFormat(
  PVOID pv,
  LPARAM lParam)
  {
  PFINDFMT pff = (PFINDFMT)pv;

  if (pff->pszFindFmt)
    GSetString(&pff->pszFindFmt, NULL);   // free
  }


/*----------------------------------------------------------
Purpose: Destroys a find format handle.

Returns: RES_OK

         RES_E_INVALIDPARAM

Cond:    --
*/
RES PUBLIC DestroyFindFormat(
  HANDLE hFindFmt)
  {
  RES res;
  HSA hsa = (HSA)hFindFmt;

  if (hsa)
    {
    SADestroyEx(hsa, FreeSAFindFormat, 0);
    res = RES_OK;
    }
  else
    res = RES_E_INVALIDPARAM;
    
  return res;
  }


BOOL PRIVATE ChrCmp(WORD w1, WORD wMatch);
BOOL PRIVATE ChrCmpI(WORD w1, WORD wMatch);


/*----------------------------------------------------------
Purpose: Compares the given character with the current format
         string.  If the character matches the expected format,
         the function returns RES_OK.

         If the current character does not match the expected
         format, but the minimum sequence of characters for
         the format has been fulfilled, this function will 
         increment *ppszFind to the next appropriate character
         or escape sequence, and check for the next expected
         format match.

         If the end of the format string is reached, RES_HALT
         is returned.  

Returns: RES_OK (if the character compares)
         RES_HALT (to stop immediately)
         RES_FALSE (if the character does not compare)

Cond:    --
*/
RES PRIVATE CompareFormat(
  PFINDFMT pff,
  LPCSTR * ppszFind,
  char chRec)
  {
  RES res = RES_FALSE;
  LPCSTR pszFind = *ppszFind;
  LPCSTR pszNext;
  DWORD dwFlags = 0;
  char ch;
  char chNext;

  #define IS_ESCAPE(ch)            ('%' == (ch))

  pszNext = MyNextChar(pszFind, &ch, &dwFlags);

  // Is this a DBCS trailing byte?
  if (IsFlagSet(dwFlags, MNC_ISTAILBYTE))
    {
    // Yes; handle this normally
    goto CompareNormal;
    }
  else
    {
    // No; check for special formatting characters first
    switch (ch)
      {
    case '%':
      chNext = *pszNext;
      if ('u' == chNext)
        {
        // Look for unsigned digits
        if (IS_DIGIT(chRec))
          {
          res = RES_OK;
          SetFlag(pff->dwFlags, FFF_MATCHEDONCE);
          }
        else
          {
          // Have we already found some digits?
          if (IsFlagSet(pff->dwFlags, FFF_MATCHEDONCE))
            {
            // Yes; then move on to the next thing to find
            ClearFlag(pff->dwFlags, FFF_MATCHEDONCE);
            pszNext = CharNext(pszNext);
            res = CompareFormat(pff, &pszNext, chRec);

            if (RES_FALSE != res)
              *ppszFind = pszNext;
            }
          else
            {
            // No
            res = RES_FALSE;
            }
          }
        }
      else if (IS_ESCAPE(chNext))
        {
        // Looking for a single '%'
        res = (chNext == chRec) ? RES_OK : RES_FALSE;

        if (RES_OK == res)
          *ppszFind = CharNext(pszNext);
        }
      else
        {
        goto CompareNormal;
        }
      break;

    case 0:       // null terminator
      res = RES_HALT;
      break;

    default: {
      BOOL bMatch;

CompareNormal:
      // (The ChrCmp* functions return FALSE if they match)

      if (IsFlagSet(pff->dwFlags, FFF_MATCHCASE))
        bMatch = !ChrCmp(ch, chRec);
      else
        bMatch = !ChrCmpI(ch, chRec);

      if (bMatch)
        {
        res = RES_OK;
        *ppszFind = pszNext;
        }
      else
        res = RES_FALSE;
      }
      break;
      }
    }

  return res;
  }


/*----------------------------------------------------------
Purpose: Scans for the specific find format string.  

         The function returns two indexes and the count of
         matched bytes.  Both indexes refer to the read
         buffer.  *pibMark indexes the first character 
         of a substring candidate.  *pib indexes the 
         character that was compared last.

         If the sequence of characters completely match the 
         requested string, the function returns RES_OK.  The
         matching sequence of characters is copied into 
         the collection buffer (if one is given).

         If there is no complete match, the function returns
         RES_FALSE.  The caller should read in more data
         before calling this function with the same requested
         string.

         If some trailing string in the read buffer matches
         the requested string, 

         If the collection buffer becomes full before a 
         complete match is found, this function returns 
         RES_E_MOREDATA.

Returns: see above
Cond:    --
*/
RES PRIVATE ScanFormat(
  PFINDFMT pff,
  UINT ibCurFind,
  LPCSTR pszRecBuf,
  UINT cbRecMax,
  LPUINT pibMark,
  LPUINT pib,
  LPINT pcbMatched)
  {
  // The trick is keeping track of when we've found a partial
  // string across read boundaries.  Consider the search string
  // "ababc".  We need to find it in the following cases (the
  // character '|' indicates read boundary, '.' is an arbitrary
  // byte):
  //
  //   |...ababc..|
  //   |.abababc..|
  //   |......abab|c.........|
  //   |......abab|abc.......|
  //
  // This assumes the read buffer is larger than the search
  // string.  In order to do this, the read buffer must be
  // a circular buffer, always retaining that portion of the
  // possible string match from the last read.
  //
  //   1st read:  |...ababc..|  -> match found
  //
  //   1st read:  |.abababc..|  -> match found
  //
  //   1st read:  |......abab|  -> possible match (retain "abab")
  //   2nd read:  |ababc.....|  -> match found
  //
  //   1st read:  |......abab|  -> possible match (retain "abab")
  //   2nd read:  |abababc...|  -> match found
  //
  #define NOT_MARKED      ((UINT)-1)

  RES res = RES_FALSE;    // assume the string is not here
  LPSTR psz;
  LPSTR pszBuf;
  UINT ib;
  UINT ibMark = NOT_MARKED;
  UINT cb;
  int cbMatched = 0;
  int cbThrowAway = 0;
  UINT cbBuf;

  pszBuf = pff->pszBuf;
  if (pszBuf)
    {
    TRACE_MSG(TF_GENERAL, "FindFormat: current buffer is {%s}", pszBuf);

    cbBuf = pff->cbBuf;
    
    if (cbBuf == pff->cbBuf)
      {
      ASSERT(0 < cbBuf);
      cbBuf--;            // save space for null terminator (first time only)
      }
    }

  // Search for the (formatted) string in the receive
  // buffer.  Optionally store the matching received
  // characters in the findfmt buffer.

  for (psz = pff->pszFindFmt, ib = ibCurFind, cb = 0; 
    *psz && cb < cbRecMax;
    ib = (ib + 1) % SIZE_ReceiveBuf, cb++)
    {
    // Match?
    RES resT = CompareFormat(pff, &psz, pszRecBuf[ib]);
    if (RES_OK == resT)
      {
      // Yes
      if (NOT_MARKED == ibMark)
        {
        ibMark = ib;       // Mark starting position
        cbMatched = 0;
        }

      cbMatched++;

      if (pszBuf)
        {
        if (0 == cbBuf)
          {
          res = RES_E_MOREDATA;
          break;
          }
          
        *pszBuf++ = pszRecBuf[ib];  // Copy character to buffer
        cbBuf--;
        }
      }
    else if (RES_HALT == resT)
      {
      ASSERT(0 == *psz);
      res = RES_HALT;
      break;
      }
    else
      {
      // No; add this to our throw away count
      cbThrowAway++;

      // Are we in a partial find?
      if (NOT_MARKED != ibMark)
        {
        // Yes; go back to where we thought the string might
        // have started.  The loop will increment one 
        // position and then resume search.
        cb -= cbMatched;
        ib = ibMark;
        ibMark = NOT_MARKED;
        psz = pff->pszFindFmt;
        if (pszBuf)
          {
          pszBuf = pff->pszBuf;
          cbBuf += cbMatched;
          }
        }
      }
    }
  
  ASSERT(RES_FALSE == res || RES_HALT == res || RES_E_MOREDATA == res);

  if (0 == *psz)
    res = RES_OK;

  if (pszBuf)
    *pszBuf = 0;    // add null terminator

  ASSERT(RES_FALSE == res || RES_OK == res || RES_E_MOREDATA == res);

  *pib = ib;
  *pibMark = ibMark;
  *pcbMatched = cbMatched;

  if (RES_OK == res)
    {
    // Include any junk characters that preceded the matched string.
    *pcbMatched += cbThrowAway;
    }
  else if (RES_FALSE == res)
    {
    // Should be at the end of the read buffer.
    ASSERT(cb == cbRecMax);
    }

  return res;
  }


/*----------------------------------------------------------
Purpose: This function attempts to find a formatted string in
         the read buffer.  See description of ScanFormat.
         
Returns: RES_OK (if complete string is found)
         RES_FALSE (otherwise)

         RES_E_MOREDATA (if no string found and pszBuf is full)

Cond:    --
*/
RES PUBLIC FindFormat(
  HWND hwnd,
  HANDLE hFindFmt,
  LPDWORD piFound)
  {
  RES res;
#ifndef WINNT_RAS
//
// On NT, the 'hwnd' parameter is actually a pointer to the SCRIPTDATA
// for the current script, hence the #if-#else.
//

  PTERMDLG ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);

#else // !WINNT_RAS

  SCRIPTDATA* ptd = (SCRIPTDATA*)hwnd;

#endif // !WINNT_RAS

  HSA hsa = (HSA)hFindFmt;
  UINT ib;
  UINT ibMark;
  int cbMatched = -1;
  DWORD iff;
  DWORD cff;

  ASSERT(hsa);

  DBG_ENTER(FindFormat);

  DEBUG_CODE( DumpBuffer(ptd); )

  // Consider each of the requested strings separately.  If
  // there are multiple candidate matches, choose the one 
  // that has the most matched characters.

  cff = SAGetCount(hsa);
  for (iff = 0; iff < cff; iff++)
    {
    PFINDFMT pff;
    RES resT;
    UINT ibMarkT;
    UINT ibT;
    int cbMatchedT;

    SAGetItemPtr(hsa, iff, &pff);

    resT = ScanFormat(pff, ptd->ibCurFind, ptd->pbReceiveBuf,
                      ptd->cbReceiveMax, &ibMarkT, &ibT, &cbMatchedT);

    // Did this string match?
    switch (resT)
      {
    case RES_OK:
      // Yes; stop right now
      ibMark = ibMarkT;
      ib = ibT;
      cbMatched = cbMatchedT;
      *piFound = iff;
      
      // Fall thru

    case RES_E_MOREDATA:
      res = resT;
      goto GetOut;

    case RES_FALSE:
      if (cbMatchedT > cbMatched)
      {
        res = resT;
        ibMark = ibMarkT;
        ib = ibT;
        cbMatched = cbMatchedT;
      }
      break;

    default:
      ASSERT(0);
      break;
      }
    }

GetOut:

  // Update the read buffer pointers to preserve any trailing
  // substring that may have matched.  
  if (RES_OK == res)
    {
    // Found string!
    TRACE_MSG(TF_BUFFER, "Found string in buffer");

    // It is okay to have characters following the matched string
    // that have not been scanned yet.  However, it is not okay
    // to still think there are characters preceding the matched
    // string that need scanning.
    ASSERT((UINT)cbMatched == ptd->cbReceiveMax && ib == ptd->ibCurRead ||
           (UINT)cbMatched <= ptd->cbReceiveMax);

    ptd->ibCurFind = ib;
    ptd->cbReceiveMax -= cbMatched;
    }
  else if (RES_E_MOREDATA == res)
    {
    // Throw away whatever is in the receive buffer
    TRACE_MSG(TF_BUFFER, "String too long in buffer");
    ptd->ibCurFind = ptd->ibCurRead;
    ptd->cbReceiveMax = 0;
    }
  else 
    {
    ASSERT(RES_FALSE == res);

    // End of receive buffer; did we even find a potential substring?
    if (NOT_MARKED == ibMark)
      {
      // No; throw away whatever is in the receive buffer
      TRACE_MSG(TF_BUFFER, "String not found in buffer");
      ptd->ibCurFind = ptd->ibCurRead;
      ptd->cbReceiveMax = 0;
      }
    else
      {
      // Yes; keep the substring part
      TRACE_MSG(TF_BUFFER, "Partial string found in buffer");

      ASSERT(ibMark >= ptd->ibCurFind);
      ptd->ibCurFind = ibMark;
      ptd->cbReceiveMax = cbMatched;
      }
    }

  DBG_EXIT_RES(FindFormat, res);

  return res;
  }


#ifdef OLD_FINDFORMAT
/*----------------------------------------------------------
Purpose: This function attempts to find a formatted string in
         the read buffer.  If a sequence of characters match 
         the complete string, the function returns TRUE.  The
         matching sequence of characters is copied into pszBuf.

         If a portion of the string (ie, from the beginning
         of pszFindFmt to some middle of pszFindFmt) is found 
         in the buffer, the buffer is marked so the next read will
         not overwrite the possible substring match.  This 
         function then returns FALSE.  The caller should 
         read in more data before calling this function again.

         The formatted string may have the following characters:

           %u   - expect a number (to first non-digit)
           ^M   - expect a carriage-return
           <cr> - expect a carriage-return
           <lf> - expect a line-feed

         All other characters are taken literally.

         If pszBuf becomes full before a delimiter is 
         encountered, this function returns RES_E_MOREDATA.

Returns: RES_OK (if complete string is found)
         RES_FALSE (otherwise)

         RES_E_MOREDATA (if no delimiter encountered and pszBuf is full)

Cond:    --
*/
RES PUBLIC FindFormat(
  HWND hwnd,
  HANDLE hFindFmt)
  {
  // The trick is keeping track of when we've found a partial
  // string across read boundaries.  Consider the search string
  // "ababc".  We need to find it in the following cases (the
  // character '|' indicates read boundary, '.' is an arbitrary
  // byte):
  //
  //   |...ababc..|
  //   |.abababc..|
  //   |......abab|c.........|
  //   |......abab|abc.......|
  //
  // This assumes the read buffer is larger than the search
  // string.  In order to do this, the read buffer must be
  // a circular buffer, always retaining that portion of the
  // possible string match from the last read.
  //
  //   1st read:  |...ababc..|  -> match found
  //
  //   1st read:  |.abababc..|  -> match found
  //
  //   1st read:  |......abab|  -> possible match (retain "abab")
  //   2nd read:  |ababc.....|  -> match found
  //
  //   1st read:  |......abab|  -> possible match (retain "abab")
  //   2nd read:  |abababc...|  -> match found
  //
  #define NOT_MARKED      ((UINT)-1)

  RES res = RES_FALSE;
  PTERMDLG ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);
  PFINDFMT pff = (PFINDFMT)hFindFmt;
  LPCSTR psz;
  LPSTR pszBuf;
  LPSTR pszRecBuf = ptd->pbReceiveBuf;
  UINT ib;
  UINT ibMark = NOT_MARKED;
  UINT cb;
  UINT cbMatched = 0;
  UINT cbRecMax = ptd->cbReceiveMax;
  UINT cbBuf;

  ASSERT(pff);

  DBG_ENTER_SZ(FindFormat, pff->pszFindFmt);

  DEBUG_CODE( DumpBuffer(ptd); )

  pszBuf = pff->pszBuf;
  if (pszBuf)
    {
    TRACE_MSG(TF_GENERAL, "FindFormat: current buffer is {%s}", pff->pszBuf);

    cbBuf = pff->cbBuf;
    
    if (cbBuf == pff->cbBuf)
      {
      ASSERT(0 < cbBuf);
      cbBuf--;            // save space for null terminator (first time only)
      }
    }

  // Search for the (formatted) string in the receive
  // buffer.  Optionally store the matching received
  // characters in the findfmt buffer.

  for (psz = pff->pszFindFmt, ib = ptd->ibCurFind, cb = 0; 
    *psz && cb < cbRecMax;
    ib = (ib + 1) % SIZE_ReceiveBuf, cb++)
    {
    // Match?
    res = CompareFormat(pff, &psz, pszRecBuf[ib]);
    if (RES_OK == res)
      {
      // Yes
      if (NOT_MARKED == ibMark)
        {
        ibMark = ib;       // Mark starting position
        cbMatched = 0;
        }

      cbMatched++;

      if (pszBuf)
        {
        if (0 == cbBuf)
          {
          res = RES_E_MOREDATA;
          break;
          }
          
        *pszBuf++ = pszRecBuf[ib];  // Copy character to buffer
        cbBuf--;
        }
      }
    else if (RES_HALT == res)
      {
      ASSERT(0 == *psz);
      break;
      }
    else if (NOT_MARKED != ibMark)
      {
      // No; go back to where we thought the string might
      // have started.  The loop will increment one 
      // position and then resume search.
      cb -= cbMatched;
      ib = ibMark;
      ibMark = NOT_MARKED;
      psz = pff->pszFindFmt;
      if (pszBuf)
        {
        pszBuf = pff->pszBuf;
        cbBuf += cbMatched;
        }
      }
    }

  if (pszBuf)
    *pszBuf = 0;    // add null terminator

  if ( !*psz )
    {
    // Found string!
    TRACE_MSG(TF_BUFFER, "Found string in buffer");
    ASSERT(cbMatched <= ptd->cbReceiveMax);

    ptd->ibCurFind = ib;
    ptd->cbReceiveMax -= cbMatched;
    res = RES_OK;
    }
  else if (RES_E_MOREDATA == res)
    {
    // Throw away whatever is in the receive buffer
    TRACE_MSG(TF_BUFFER, "String too long in buffer");
    ptd->ibCurFind = ptd->ibCurRead;
    ptd->cbReceiveMax = 0;
    }
  else 
    {
    // End of receive buffer; did we even find a potential substring?
    ASSERT(cb == cbRecMax);

    if (NOT_MARKED == ibMark)
      {
      // No; throw away whatever is in the receive buffer
      TRACE_MSG(TF_BUFFER, "String not found in buffer");
      ptd->ibCurFind = ptd->ibCurRead;
      ptd->cbReceiveMax = 0;
      }
    else
      {
      // Yes; keep the substring part
      TRACE_MSG(TF_BUFFER, "Partial string found in buffer");

      ASSERT(ibMark >= ptd->ibCurFind);
      ptd->ibCurFind = ibMark;
      ptd->cbReceiveMax = cbMatched;
      }
        
    res = RES_FALSE;
    }

  DBG_EXIT_RES(FindFormat, res);

  return res;
  }
#endif

#ifdef COPYTODELIM
/*----------------------------------------------------------
Purpose: Sets or clears the list of delimiters

Returns: --
Cond:    --
*/
void PRIVATE SetDelimiters(
    PTERMDLG ptd,
    LPCSTR pszTok,
    BOOL bSet)
    {
    PBOOL rgbDelim = ptd->rgbDelim;
    LPCSTR psz;
    char ch;

    for (psz = pszTok; *psz; )
        {
        psz = MyNextChar(psz, &ch);

        ASSERT(InRange(ch, 0, CE_DELIM-1));
        rgbDelim[ch] = bSet;
        }
    }


/*----------------------------------------------------------
Purpose: This function reads to one of the given token 
         delimiters.  All characters in the read buffer (to
         the delimiter) are copied into pszBuf, not including
         the delimiter.
         
         Any token delimiters that are encountered before the
         first non-token delimiter are skipped, and the function
         starts at the first non-token delimiter.

         If a token delimiter is found, the function 
         returns RES_OK.

         If a token delimiter is not found in the current 
         read buffer, the function returns RES_FALSE and the
         characters that were read are still copied into 
         pszBuf.  The caller should read in more data before 
         calling this function again.

         If pszBuf becomes full before a delimiter is 
         encountered, this function returns RES_E_MOREDATA.

         The string returned in pszBuf is null terminated.

Returns: RES_OK 
         RES_FALSE (if no delimiter encountered this time)

         RES_E_MOREDATA (if no delimiter encountered and pszBuf is full)

Cond:    --
*/
RES PUBLIC CopyToDelimiter(
    HWND hwnd,
    LPSTR pszBuf,
    UINT cbBuf,
    LPCSTR pszTok)
    {
    RES res;
    PTERMDLG ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);
    PBOOL rgbDelim = ptd->rgbDelim;
    LPSTR pszReadBuf = ptd->pbReceiveBuf;
    LPSTR psz;
    UINT ib;
    UINT cb;
    UINT cbMax = ptd->cbReceiveMax;

    DBG_ENTER_SZ(CopyToDelimiter, pszTok);

    DEBUG_CODE( DumpBuffer(ptd); )

#ifdef DEBUG

    for (ib = 0; ib < CE_DELIM; ib++)
        ASSERT(FALSE == rgbDelim[ib]);

#endif

    // Initialize the delimiters
    SetDelimiters(ptd, pszTok, TRUE);

    cbBuf--;        // save space for terminator

    // Skip to the first non-delimiter
    for (ib = ptd->ibCurFind, cb = 0;     
        cb < cbMax;
        ib = (ib + 1) % SIZE_ReceiveBuf, cb++)
        {
        char ch = pszReadBuf[ib];

        ASSERT(InRange(ch, 0, CE_DELIM-1));

        // Is this one of the delimiters?
        if ( !rgbDelim[ch] )
            {
            // No; stop
            break;
            }
        }

    if (cb < cbMax || 0 == cbMax)
        res = RES_FALSE;    // assume no delimiter in this pass
    else
        res = RES_OK;

    // Copy to the first delimiter encountered 

    for (psz = pszBuf; 
        0 < cbBuf && cb < cbMax;
        psz++, ib = (ib + 1) % SIZE_ReceiveBuf, cb++, cbBuf--)
        {
        char ch = pszReadBuf[ib];

        ASSERT(InRange(ch, 0, CE_DELIM-1));

        // Is this one of the delimiters?
        if (rgbDelim[ch])
            {
            // Yes; we're done
            res = RES_OK;
            break;
            }
        else
            {
            // No; 
            *psz = ch;
            }
        }

    *psz = 0;       // add null terminator

    ptd->ibCurFind = ib;
    ptd->cbReceiveMax -= cb;

    if (RES_FALSE == res)
        {
        res = (0 == cbBuf) ? RES_E_MOREDATA : RES_FALSE;
        }
    else
        {
        TRACE_MSG(TF_BUFFER, "Copied to delimiter %#02x", pszReadBuf[ib]);
        }

    // Deinitialize the delimiters
    SetDelimiters(ptd, pszTok, FALSE);

    DBG_EXIT_RES(CopyToDelimiter, res);

    return res;
    }
#endif // COPYTODELIM


/*----------------------------------------------------------
Purpose: Reads from the comm port into the circular buffer.
         This functions sets *ppbBuf to the location of
         the first new character read.

         there is a potential but rare bug
         that can occur with Internet providers that send
         DBCS over the wire.  If the last character in the
         buffer is a DBCS lead-byte, and it is being thrown
         away, then the next byte might be matched with an
         existing character.  The entire string following 
         this must match for us to find a false match.  

Returns: TRUE (if a character was read successfully)
         FALSE (otherwise)

Cond:    --
*/
BOOL PRIVATE ReadIntoBuffer(
#ifndef WINNT_RAS
//
// On NT, we use a SCRIPTDATA pointer to access the circular-buffer.
//
    PTERMDLG ptd,
#else // !WINNT_RAS
    SCRIPTDATA *ptd,
#endif // !WINNT_RAS
    PDWORD pibStart,        // start of newly read characters
    PDWORD pcbRead)         // count of newly read characters
    {
    BOOL bRet;
    OVERLAPPED ov;
    DWORD cb;
    DWORD cbRead;
    DWORD ib;

    DBG_ENTER(ReadIntoBuffer);

    ASSERT(pibStart);
    ASSERT(pcbRead);

    ov.Internal     = 0;
    ov.InternalHigh = 0;
    ov.Offset       = 0;
    ov.OffsetHigh   = 0;
    ov.hEvent       = NULL;
    *pcbRead        = 0;

    // This is a circular buffer, so at most do two reads
    ASSERT(ptd->ibCurRead >= ptd->ibCurFind);
    ASSERT(SIZE_ReceiveBuf > ptd->ibCurFind);
    ASSERT(SIZE_ReceiveBuf > ptd->ibCurRead);

    *pcbRead = 0;
    *pibStart = ptd->ibCurRead;
    // (*pibStart can be different from ptd->ibCurFind)

    ib = ptd->ibCurRead;
    cb = SIZE_ReceiveBuf - ib;

    do 
        {
        DWORD ibNew;

        ASSERT(SIZE_ReceiveBuf > *pcbRead);

#ifndef WINNT_RAS
//
// In order to read data on NT, we go through RxReadFile
// which reads from the buffer which was filled by RASMAN.
//

        bRet = ReadFile(ptd->hport, &ptd->pbReceiveBuf[ib], cb, &cbRead, &ov);
        SetEvent(ptd->hEvent[READ_EVENT]);

#else // !WINNT_RAS

        bRet = RxReadFile(
                    ptd->hscript, &ptd->pbReceiveBuf[ib], cb, &cbRead
                    );

#endif // !WINNT_RAS

        ptd->cbReceiveMax += cbRead;
        *pcbRead += cbRead;

        // Is this going to wrap around?
        ibNew = (ib + cbRead) % SIZE_ReceiveBuf;
        if (ibNew > ib)
            cb -= cbRead;           // No
        else
            cb = ptd->ibCurFind;    // Yes

        ib = ibNew;

        } while (bRet && 0 != cbRead && SIZE_ReceiveBuf > *pcbRead);

    ptd->ibCurRead = (ptd->ibCurRead + *pcbRead) % SIZE_ReceiveBuf;

    DEBUG_CODE( DumpBuffer(ptd); )

    DBG_EXIT_BOOL(ReadIntoBuffer, bRet);

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Get input from the com port

Returns: TRUE
Cond:    --
*/
BOOL NEAR PASCAL GetInput(
    HWND hwnd)
    {
    BOOL bRet = TRUE;
    PTERMDLG ptd;
    DWORD cbRead;
    DWORD ibStart;

    DBG_ENTER(GetInput);

    ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);

#ifndef WINNT_RAS
//
// On NT, the information for the script is stored in a SCRIPTDATA.
// The code below exists only to allow this file to compile;
// "GetInput" is not called at all on NT.
//

    if (ReadIntoBuffer(ptd, &ibStart, &cbRead) && 0 < cbRead)

#else // !WINNT_RAS

    if (ReadIntoBuffer((SCRIPTDATA *)ptd, &ibStart, &cbRead) && 0 < cbRead)

#endif // !WINNT_RAS
        {
        char  szBuf[SIZE_ReceiveBuf + 1];
        LPSTR pch = szBuf;
        UINT ib;
        UINT cb;
        HWND hwndScrn = GetDlgItem(hwnd, CID_T_EB_SCREEN);

        for (ib = ibStart, cb = 0; cb < cbRead; cb++, ib = (ib + 1) % SIZE_ReceiveBuf)
            {
            char ch = ptd->pbReceiveBuf[ib];

            /* Formatting: Converts CRs to LFs (there seems to be no VK_
            ** for LF) and throws away LFs.  This prevents the user from
            ** exiting the dialog when they press Enter (CR) in the
            ** terminal screen.  LF looks like CRLF in the edit box.  Also,
            ** throw away TABs because otherwise they change focus to the
            ** next control.
            */
            if (ch == VK_RETURN)
                {
                /* Must send whenever end-of-line is encountered because
                ** EM_REPLACESEL doesn't handle VK_RETURN characters well
                ** (prints garbage).
                */
                *pch = '\0';

                /* Turn off current selection, if any, and replace the null
                ** selection with the current buffer.  This has the effect
                ** of adding the buffer at the caret.  Finally, send the
                ** EOL to the window which (unlike EM_REPLACESEL) handles
                ** it correctly.
                */
                SendMessage(hwndScrn, WM_SETREDRAW, (WPARAM )FALSE, 0);

                SendMessage(hwndScrn, EM_SETSEL, 32767, 32767 );
                SendMessage(hwndScrn, EM_REPLACESEL, 0, (LPARAM )szBuf );
                SendMessage(hwndScrn, WM_EOLFROMDEVICE, 0, 0 );

                SendMessage(hwndScrn, WM_SETREDRAW, (WPARAM )TRUE, 0);
                SendMessage(hwndScrn, EM_SCROLLCARET, 0, 0);
                InvalidateRect(hwndScrn, NULL, FALSE);

                /* Start afresh on the output buffer.
                */
                pch = szBuf;
                continue;
                }
            else if (ch == '\n' || ch == VK_TAB)
                continue;

            *pch++ = ch;
            }

        *pch = '\0';

        if (pch != szBuf)
            {
            /* Send the last remnant of the line.
            */
            SendMessage(hwndScrn, EM_SETSEL, 32767, 32767);
            SendMessage(hwndScrn, EM_REPLACESEL, 0, (LPARAM)szBuf );
            SendMessage(hwndScrn, EM_SCROLLCARET, 0, 0);
            }
        }

    DBG_EXIT_BOOL(GetInput, bRet);

    return bRet;
    }

/*----------------------------------------------------------------------------
** Terminal Output Handler
**----------------------------------------------------------------------------
*/

/*----------------------------------------------------------
Purpose: Send a byte to the device.
Returns: --
Cond:    --
*/
void PUBLIC SendByte(
    HWND hwnd, 
    BYTE byte)
    {
#ifndef WINNT_RAS
//
// On NT. we use a SCRIPTDATA structure to hold information about the script.
//
    PTERMDLG  ptd;
#else // !WINNT_RAS
    SCRIPTDATA* ptd;
#endif // !WINNT_RAS
    DWORD     cbWrite;
    OVERLAPPED ov;

    DBG_ENTER(SendByte);

#ifndef WINNT_RAS
//
// On NT, the "hwnd" argument is actually a pointer to a SCRIPTDATA structure
// for the script being parsed.
//

    ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);

#else // !WINNT_RAS

    ptd = (SCRIPTDATA *)hwnd;

#endif // !WINNT_RAS

    /* Send the character to the device.  It is not passed thru
    ** because the device will echo it.
    */
    ptd->pbSendBuf[0] = (BYTE)byte;

    /* Make sure we still have the comm port
    */
    ov.Internal     = 0;
    ov.InternalHigh = 0;
    ov.Offset       = 0;
    ov.OffsetHigh   = 0;
    ov.hEvent       = NULL;
    cbWrite = 0;

#ifndef WINNT_RAS
//
// On NT, we output data on the COM port by calling RxWriteFile
// which in turn passes the data to RasPortSend
//

    WriteFile(ptd->hport, ptd->pbSendBuf, SIZE_SendBuf, &cbWrite, &ov);

#else // !WINNT_RAS

    RxWriteFile(ptd->hscript, ptd->pbSendBuf, SIZE_SendBuf, &cbWrite);

#endif // !WINNT_RAS

    TRACE_MSG(TF_BUFFER, "Sent byte %#02x", byte);

    DBG_EXIT(SendByte);
    }


/*----------------------------------------------------------------------------
** Terminal Appearance Adjuster
**----------------------------------------------------------------------------
*/

VOID NEAR PASCAL AdjustTerminal (HWND hwnd, int wWidth, int wHeight)
{
  HWND  hwndCtrl;
  RECT  rect;
  SIZE  sizeButton;
  POINT ptPos;
  DWORD dwUnit;

  // Get the sizes of the push buttons
  //
  dwUnit = GetDialogBaseUnits();
  hwndCtrl = GetDlgItem(hwnd, IDOK);
  GetWindowRect(hwndCtrl, &rect);
  sizeButton.cx = rect.right  - rect.left;
  sizeButton.cy = rect.bottom - rect.top;
  ptPos.x   = wWidth/2 - ((X_SPACING*LOWORD(dwUnit))/4)/2 - sizeButton.cx;
  ptPos.y   = wHeight - (sizeButton.cy+((Y_MARGIN*HIWORD(dwUnit))/4));

  // Move the push buttons
  MoveWindow(hwndCtrl, ptPos.x, ptPos.y, sizeButton.cx, sizeButton.cy, TRUE);

  ptPos.x  += ((X_SPACING*LOWORD(dwUnit))/4) + sizeButton.cx;
  MoveWindow(GetDlgItem(hwnd, IDCANCEL), ptPos.x, ptPos.y,
             sizeButton.cx, sizeButton.cy, TRUE);

  // Move the input enable box
  hwndCtrl = GetDlgItem(hwnd, CID_T_CB_MIN);
  GetWindowRect(hwndCtrl, &rect);
  sizeButton.cx = rect.right  - rect.left;
  sizeButton.cy = rect.bottom - rect.top;
  ptPos.y -= (sizeButton.cy + ((Y_MARGIN*HIWORD(dwUnit))/4));
  ScreenToClient(hwnd, (LPPOINT)&rect);
  MoveWindow(hwndCtrl, rect.left, ptPos.y,
             sizeButton.cx,
             sizeButton.cy,
             TRUE);

  // Move the start-minimized box
  hwndCtrl = GetDlgItem(hwnd, CID_T_CB_INPUT);
  GetWindowRect(hwndCtrl, &rect);
  sizeButton.cx = rect.right  - rect.left;
  sizeButton.cy = rect.bottom - rect.top;
  ptPos.y -= (sizeButton.cy + ((Y_SMALL_MARGIN*HIWORD(dwUnit))/4));
  ScreenToClient(hwnd, (LPPOINT)&rect);
  MoveWindow(hwndCtrl, rect.left, ptPos.y,
             sizeButton.cx,
             sizeButton.cy,
             TRUE);

  // Get the current position of the terminal screen
  hwndCtrl = GetDlgItem(hwnd, CID_T_EB_SCREEN);
  GetWindowRect(hwndCtrl, &rect);
  ScreenToClient(hwnd, (LPPOINT)&rect);
  MoveWindow(hwndCtrl, rect.left, rect.top,
             wWidth - 2*rect.left,
             ptPos.y - rect.top - ((Y_SMALL_MARGIN*HIWORD(dwUnit))/4),
             TRUE);

  InvalidateRect(hwnd, NULL, TRUE);
  return;
}

/*----------------------------------------------------------------------------
** Terminal caption update
**----------------------------------------------------------------------------
*/

void NEAR PASCAL UpdateTerminalCaption(PTERMDLG ptd, UINT ids)
{
  LPSTR szTitle, szFmt;
  UINT  iRet;

  // If we are not running a script, do not update the caption
  //
  if (*ptd->script.szPath == '\0')
    return;

  // Allocate buffer
  //
  if ((szFmt = (LPSTR)LocalAlloc(LMEM_FIXED, 2*MAX_PATH)) != NULL)
  {
    // Load the display format
    //
    if((iRet = LoadString(g_hinst, ids, szFmt, MAX_PATH)))
    {
      // Get the title buffer
      //
      szTitle = szFmt+iRet+1;
      {
        // Build up the title
        //
        wsprintf(szTitle, szFmt, ptd->script.szPath);
        SetWindowText(ptd->hwnd, szTitle);
      };
    };
    LocalFree((HLOCAL)szFmt);
  };
  return;
}

/*----------------------------------------------------------------------------
** Terminal read-notification thread
**----------------------------------------------------------------------------
*/

void WINAPI TerminalThread (PTERMDLG  ptd)
    {
    DWORD     dwEvent;
    DWORD     dwMask;

    while((dwEvent = WaitForMultipleObjects(MAX_EVENT, ptd->hEvent,
                                            FALSE, INFINITE))
            < WAIT_OBJECT_0+MAX_EVENT)
        {
        switch (dwEvent)
            {
        case READ_EVENT:
            // Are we stopped?
            if (WAIT_TIMEOUT == WaitForSingleObject(ptd->hEvent[STOP_EVENT], 0))
                {
                // No; wait for next character
                dwMask = 0;

                TRACE_MSG(TF_BUFFER, "Waiting for comm traffic...");
                WaitCommEvent(ptd->hport, &dwMask, NULL);

                if ((dwMask & EV_RXCHAR) && (ptd->hwnd != NULL))
                    {
                    TRACE_MSG(TF_BUFFER, "...EV_RXCHAR incoming");
                    PostMessage(ptd->hwnd, WM_MODEMNOTIFY, 0, 0);
                    }
                else
                    {
                    TRACE_MSG(TF_BUFFER, "...EV_other (%#08lx) incoming", dwMask);
                    }
                }
            else
                {
                // Yes; just get out of here
                ExitThread(ERROR_SUCCESS);
                }
            break;

        case STOP_EVENT:
            ExitThread(ERROR_SUCCESS);
            break;

        default:
            ASSERT(0);
            break;
            }
        }
    }

/*----------------------------------------------------------------------------
** Set IP address
**----------------------------------------------------------------------------
*/

DWORD   NEAR PASCAL TerminalSetIP(HWND hwnd, LPCSTR pszIPAddr)
{
  PTERMDLG  ptd;
  DWORD dwRet;

  ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);

  if (IS_TEST_SCRIPT(ptd))
  {
    // We are testing, just display the ip address
    //
    MsgBox(g_hinst,
           hwnd,
           MAKEINTRESOURCE(IDS_IP_Address),
           MAKEINTRESOURCE(IDS_CAP_Script),
           NULL,
           MB_OK | MB_ICONINFORMATION,
           pszIPAddr);
  };

  // Set the IP address permanently
  //
  dwRet = AssignIPAddress(ptd->pscanner->psci->szEntryName,
                          pszIPAddr);
  return dwRet;
}

/*----------------------------------------------------------------------------
** Terminal Input settings
**----------------------------------------------------------------------------
*/

void NEAR PASCAL TerminalSetInput(HWND hwnd, BOOL fEnable)
{
  PTERMDLG ptd;

  ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);

  // If the status is not changed, do nothing
  //
  if ((ptd->fInputEnabled && !fEnable) ||
      (!ptd->fInputEnabled && fEnable))
  {
    // Mark the input enabling flag
    //
    ptd->fInputEnabled = fEnable;

    // Check the control properly
    //
    CheckDlgButton(hwnd, CID_T_CB_INPUT,
                   fEnable ? BST_CHECKED : BST_UNCHECKED);

    // Repaint the terminal screen
    //
    InvalidateRect(hwnd, NULL, FALSE);

    // If enable and the window is iconic, restore it
    //
    if (fEnable)
    {
      if (IsIconic(hwnd))
      {
        ShowWindow(hwnd, SW_RESTORE);
      };

      SetFocus(GetDlgItem(hwnd, CID_T_EB_SCREEN));
    };
  };
}

/*----------------------------------------------------------------------------
** Dump the script window
**----------------------------------------------------------------------------
*/

BOOL NEAR PASCAL DisplayScript (PTERMDLG ptd)
{
  // Create the debug script window
  //
  ptd->hwndDbg = CreateDialogParam(g_hinst,
                                   MAKEINTRESOURCE(IDD_TERMINALTESTDLG),
                                   NULL,
                                   DbgScriptDlgProc,
                                   (LPARAM)ptd);

  // Did we have the debug window?
  //
  if (!IsWindow(ptd->hwndDbg))
  {
    ptd->hwndDbg = NULL;
    return FALSE;
  };
  return TRUE;
}

/*----------------------------------------------------------------------------
** Script debug window procedure
**----------------------------------------------------------------------------
*/

LRESULT FAR PASCAL DbgScriptDlgProc(HWND   hwnd,
                                    UINT   wMsg,
                                    WPARAM wParam,
                                    LPARAM lParam )
{
  PTERMDLG ptd;

  switch (wMsg)
  {
    case WM_INITDIALOG:
    {
      HMENU  hMenuSys;

      ptd = (PTERMDLG)lParam;
      SetWindowLongPtr(hwnd, DWLP_USER, (ULONG_PTR)lParam);
      ptd->hwndDbg = hwnd;

      // Show its own icon
      //
      SendMessage(hwnd, WM_SETICON, TRUE,
                  (LPARAM)LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_SCRIPT)));

      // Always gray out size and maximize command
      //
      hMenuSys   = GetSystemMenu(hwnd, FALSE);
      EnableMenuItem(hMenuSys, SC_CLOSE, MF_BYCOMMAND | MF_GRAYED);

      return (InitDebugWindow(hwnd));
    }
    case WM_PROCESSSCRIPT:
    {
      PTERMDLG ptd;
      HWND     hCtrl;

      //
      // The main window notifies that it is done with the current line
      //
      ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);

      // Make sure we do not continue processing the script
      //
      ptd->fContinue = FALSE;

      hCtrl = GetDlgItem(hwnd, CID_T_PB_STEP);
      EnableWindow(hCtrl, TRUE);
      SetFocus(hCtrl);
      TrackScriptLine(ptd, Astexec_GetCurLine(&ptd->astexec)-1);

      break;
    }

    case WM_COMMAND:
      switch (LOWORD(wParam))
      {
        case CID_T_EB_SCRIPT:
        {
          HWND hCtrl = GET_WM_COMMAND_HWND(wParam, lParam);

          if (GET_WM_COMMAND_CMD(wParam, lParam)==EN_SETFOCUS)
          {
            PTERMDLG ptd;

            ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);
            TrackScriptLine(ptd, ptd->iMarkLine);
          };
          break;
        }

        case CID_T_PB_STEP:
        {
          PTERMDLG ptd;

          ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);

          // Allow the next step
          //
          EnableWindow(GET_WM_COMMAND_HWND(wParam, lParam), FALSE);

          // Tell the main window to process the next script line
          //
          ptd->fContinue = TRUE;
          PostProcessScript(ptd->hwnd);
          break;
        }

      };
      break;

    case WM_HELP:
    case WM_CONTEXTMENU:
      ContextHelp(gaDebug, wMsg, wParam, lParam);
      break;
  };

  return 0;
}

/*----------------------------------------------------------------------------
** Init script debug window
**----------------------------------------------------------------------------
*/

BOOL NEAR PASCAL InitDebugWindow (HWND hwnd)
{
  PTERMDLG ptd;
  HANDLE hFile;
  LPBYTE lpBuffer;
  DWORD  cbRead;
  HWND   hCtrl;
  UINT   iLine, cLine, iMark;

  ptd = (PTERMDLG)GetWindowLongPtr(hwnd, DWLP_USER);

  ASSERT(IS_TEST_SCRIPT(ptd));

  // Do not start the script yet
  //
  ptd->fContinue = FALSE;

  // Allocate the read buffer
  //
  if ((lpBuffer = (LPBYTE)LocalAlloc(LMEM_FIXED, SIZE_ReceiveBuf)) == NULL)
    return FALSE;

  hCtrl = GetDlgItem(hwnd, CID_T_EB_SCRIPT);
  hFile = CreateFile(ptd->script.szPath, GENERIC_READ, FILE_SHARE_READ,
                     NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

  if (INVALID_HANDLE_VALUE != hFile)
  {
    while(ReadFile(hFile, lpBuffer, sizeof(SIZE_ReceiveBuf), &cbRead, NULL) &&
          (cbRead != 0))
    {
      // Clean up the end garbage
      //
      if (cbRead < SIZE_ReceiveBuf)
        lpBuffer[cbRead] = '\0';

      SendMessage(hCtrl, EM_SETSEL, 32767, 32767 );
      SendMessage(hCtrl, EM_REPLACESEL, 0, (LPARAM)lpBuffer );
    };
    CloseHandle(hFile);
  };

  // Display the file name
  //
  cbRead = GetDlgItemText(hwnd, CID_T_ST_FILE, lpBuffer, SIZE_ReceiveBuf) + 1;
  if(SIZE_ReceiveBuf >= (cbRead + (lstrlen(ptd->script.szPath) * sizeof(TCHAR))))
  {
      wsprintf(lpBuffer+cbRead, lpBuffer, ptd->script.szPath);
      SetDlgItemText(hwnd, CID_T_ST_FILE, lpBuffer+cbRead);
  }
  else
  {
    ASSERT(FALSE);
    SetDlgItemText(hwnd, CID_T_ST_FILE, ptd->script.szPath);
  }
  
  LocalFree(lpBuffer);

  // Init script track
  //
  for (iLine = 0, cLine = Edit_GetLineCount(hCtrl);
       iLine < cLine; iLine++)
  {
    iMark = Edit_LineIndex(hCtrl, iLine);
    Edit_SetSel(hCtrl, iMark, iMark);
    Edit_ReplaceSel(hCtrl, TRACE_UNMARK);
  };

  // Initialize script tracking
  //
  PostProcessScript(hwnd);

  return TRUE;
}

/*----------------------------------------------------------------------------
** Trace the script
**----------------------------------------------------------------------------
*/

void NEAR PASCAL TrackScriptLine(PTERMDLG ptd, DWORD iLine)
{
  HWND hCtrl;
  UINT iMark, iRange;
#pragma data_seg(DATASEG_READONLY)
const static char c_szLastline[] = {0x0d, 0x0a, ' '};
#pragma data_seg()

  ASSERT(0 <= iLine || INVALID_SCRIPT_LINE == iLine);

  hCtrl = GetDlgItem(ptd->hwndDbg, CID_T_EB_SCRIPT);

  // Do not update the screen until we are done
  //
  SendMessage(hCtrl, WM_SETREDRAW, (WPARAM )FALSE, 0);

  if ((ptd->iMarkLine != iLine) || (iLine == INVALID_SCRIPT_LINE))
  {
    // Remove the old mark
    //
    iMark = Edit_LineIndex(hCtrl, ptd->iMarkLine);
    Edit_SetSel(hCtrl, iMark, iMark+sizeof(TRACE_MARK)-1);
    Edit_ReplaceSel(hCtrl, TRACE_UNMARK);

    // If this is the last line, make a dummy line
    //
    if (iLine == INVALID_SCRIPT_LINE)
    {
      Edit_SetSel(hCtrl, 32767, 32767);
      Edit_ReplaceSel(hCtrl, c_szLastline);
      iLine = Edit_GetLineCount(hCtrl);
      EnableWindow(GetDlgItem(ptd->hwndDbg, CID_T_PB_STEP), FALSE);

#ifdef PROMPT_AT_COMPLETION
      // Prompt the user to continue
      //
      SetFocus(GetDlgItem(ptd->hwnd, IDOK));
#else
      // We are done processing the script, continue automatically
      //
      ptd->fContinue = TRUE;
      PostProcessScript(ptd->hwnd);
#endif // PROMPT_AT_COMPLETION

    };

    // Mark the current line
    //
    iMark = Edit_LineIndex(hCtrl, iLine);
    Edit_SetSel(hCtrl, iMark, iMark+sizeof(TRACE_UNMARK)-1);
    Edit_ReplaceSel(hCtrl, TRACE_MARK);
    ptd->iMarkLine = iLine;
  }
  else
  {
    iMark = Edit_LineIndex(hCtrl, iLine);
  };

  // Select the current line
  //
  iRange = Edit_LineLength(hCtrl, iMark)+1;
  Edit_SetSel(hCtrl, iMark, iMark+iRange);

  // Update the screen now
  //
  SendMessage(hCtrl, WM_SETREDRAW, (WPARAM )TRUE, 0);
  InvalidateRect(hCtrl, NULL, FALSE);
  Edit_ScrollCaret(hCtrl);

  return;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasscrpt\typechk.c ===
//
// Copyright (c) Microsoft Corporation 1995
//
// typechk.c
//
// This file contains the typechecking functions.
//
// The typechecking rules are:
//
// waitfor      Takes a string expression
// transmit     Takes a string expression
// delay        Takes an integer expression
// while        Evaluates a boolean expression
// set ipaddr   Takes a string expression
// getip        Takes an integer expression
// 
//
//
// History:
//  06-15-95 ScottH     Created
//


#include "proj.h"
#include "rcids.h"

RES     PRIVATE Stmt_Typecheck(PSTMT this, PSYMTAB pst, HSA hsaStxerr);


/*----------------------------------------------------------
Purpose: Typechecks whether an identifier is a valid type.

Returns: RES_OK
         RES_E_REQUIRELABEL
         RES_E_UNDEFINED

Cond:    --
*/
RES PRIVATE Ident_Typecheck(
    LPCSTR pszIdent,
    DATATYPE dt,
    PDATATYPE pdt,          // May be NULL
    DWORD iLine,
    PSYMTAB pst,
    HSA hsaStxerr)
    {
    RES res = RES_OK;
    PSTE pste;

    if (RES_OK == Symtab_FindEntry(pst, pszIdent, STFF_DEFAULT, &pste, NULL))
        {
        if (pdt)
            {
            *pdt = STE_GetDataType(pste);
            res = RES_OK;
            }
        else if (dt == STE_GetDataType(pste))
            {
            res = RES_OK;
            }
        else
            {
            switch (dt)
                {
            case DATA_LABEL:
                res = RES_E_REQUIRELABEL;
                break;

            case DATA_STRING:
                res = RES_E_REQUIRESTRING;
                break;

            case DATA_INT:
                res = RES_E_REQUIREINT;
                break;

            case DATA_BOOL:
                res = RES_E_REQUIREBOOL;
                break;

            default:
                ASSERT(0);
                break;
                }
            Stxerr_Add(hsaStxerr, pszIdent, iLine, res);
            }
        }
    else
        {
        res = Stxerr_Add(hsaStxerr, pszIdent, iLine, RES_E_UNDEFINED);
        }
        
    return res;
    }


//
// Exprs
//

RES PRIVATE Expr_Typecheck(PEXPR this, PSYMTAB pst, HSA hsaStxerr);


/*----------------------------------------------------------
Purpose: Return a string given a binoptype.

Returns: Pointer to string
Cond:    --
*/
LPCSTR PRIVATE SzFromBot(
    BINOPTYPE bot)
    {
#pragma data_seg(DATASEG_READONLY)
    static const LPCSTR s_mpbotsz[] = 
        { "'or' operand", 
          "'and' operand", 
          "'<=' operand", 
          "'<' operand", 
          "'>=' operand", 
          "'>' operand", 
          "'!=' operand", 
          "'==' operand", 
          "'+' operand", 
          "'-' operand", 
          "'*' operand", 
          "'/' operand",
        };
#pragma data_seg()
    
    if (ARRAY_ELEMENTS(s_mpbotsz) <= bot)
        {
        ASSERT(0);
        return "";
        }

    return s_mpbotsz[bot];
    }


/*----------------------------------------------------------
Purpose: Return a string given a unoptype.

Returns: Pointer to string
Cond:    --
*/
LPCSTR PRIVATE SzFromUot(
    UNOPTYPE uot)
    {
#pragma data_seg(DATASEG_READONLY)
    static const LPCSTR s_mpuotsz[] = 
        {
        "unary '-' operand", 
        "'!' operand", 
        "'getip' parameter",
        };
#pragma data_seg()
    
    if (ARRAY_ELEMENTS(s_mpuotsz) <= uot)
        {
        ASSERT(0);
        return "";
        }

    return s_mpuotsz[uot];
    }


/*----------------------------------------------------------
Purpose: Typechecks a variable reference expression.

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE VarExpr_Typecheck(
    PEXPR this,
    PSYMTAB pst,
    HSA hsaStxerr)
    {
    RES res;
    LPSTR pszIdent;
    PSTE pste;

    ASSERT(this);
    ASSERT(hsaStxerr);

    pszIdent = VarExpr_GetIdent(this);

    if (RES_OK == Symtab_FindEntry(pst, pszIdent, STFF_DEFAULT, &pste, NULL))
        {
        DATATYPE dt = STE_GetDataType(pste);

        ASSERT(DATA_BOOL == dt || DATA_INT == dt || DATA_STRING == dt);

        Expr_SetDataType(this, dt);
        res = RES_OK;
        }
    else
        {
        res = Stxerr_Add(hsaStxerr, pszIdent, Ast_GetLine(this), RES_E_UNDEFINED);
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Typechecks a binary operator expression.

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE BinOpExpr_Typecheck(
    PEXPR this,
    PSYMTAB pst,
    HSA hsaStxerr)
    {
    RES res;
    PEXPR pexpr1;
    PEXPR pexpr2;

    ASSERT(this);
    ASSERT(hsaStxerr);

    pexpr1 = BinOpExpr_GetExpr1(this);
    res = Expr_Typecheck(pexpr1, pst, hsaStxerr);
    if (RSUCCEEDED(res))
        {
        pexpr2 = BinOpExpr_GetExpr2(this);
        res = Expr_Typecheck(pexpr2, pst, hsaStxerr);
        if (RSUCCEEDED(res))
            {
            BINOPTYPE bot = BinOpExpr_GetType(this);

            // Types must match
            if (Expr_GetDataType(pexpr1) != Expr_GetDataType(pexpr2))
                {
                res = RES_E_TYPEMISMATCH;
                }
            else
                {
                // Just choose one of the datatypes, since they
                // should be the same.
                DATATYPE dt = Expr_GetDataType(pexpr1);

                switch (bot)
                    {
                case BOT_OR:
                case BOT_AND:
                    Expr_SetDataType(this, DATA_BOOL);

                    if (DATA_BOOL != dt)
                        res = RES_E_REQUIREBOOL;
                    break;

                case BOT_PLUS:
                    Expr_SetDataType(this, dt);

                    // String + string means concatenate.
                    if (DATA_INT != dt && DATA_STRING != dt)
                        res = RES_E_REQUIREINTSTRING;
                    break;

                case BOT_NEQ:
                case BOT_EQ:
                    Expr_SetDataType(this, DATA_BOOL);

                    if (DATA_INT != dt && DATA_STRING != dt && 
                        DATA_BOOL != dt)
                        res = RES_E_REQUIREINTSTRBOOL;
                    break;

                case BOT_LEQ:
                case BOT_LT:
                case BOT_GEQ:
                case BOT_GT:
                    Expr_SetDataType(this, DATA_BOOL);

                    if (DATA_INT != dt)
                        res = RES_E_REQUIREINT;
                    break;

                case BOT_MINUS:
                case BOT_MULT:
                case BOT_DIV:
                    Expr_SetDataType(this, DATA_INT);

                    if (DATA_INT != dt)
                        res = RES_E_REQUIREINT;
                    break;

                default:
                    ASSERT(0);
                    res = RES_E_INVALIDPARAM;
                    break;
                    }
                }

            if (RFAILED(res))
                Stxerr_Add(hsaStxerr, SzFromBot(bot), Ast_GetLine(this), res);
            }
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Typechecks a unary operator expression.

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE UnOpExpr_Typecheck(
    PEXPR this,
    PSYMTAB pst,
    HSA hsaStxerr)
    {
    RES res;
    PEXPR pexpr;

    ASSERT(this);
    ASSERT(hsaStxerr);

    pexpr = UnOpExpr_GetExpr(this);
    res = Expr_Typecheck(pexpr, pst, hsaStxerr);

    if (RSUCCEEDED(res))
        {
        UNOPTYPE uot = UnOpExpr_GetType(this);
        DATATYPE dt = Expr_GetDataType(pexpr);

        // Check the type of the expression
        switch (uot)
            {
        case UOT_NEG:
            Expr_SetDataType(this, DATA_INT);

            if (DATA_INT != dt)
                res = RES_E_REQUIREINT;
            break;

        case UOT_NOT:
            Expr_SetDataType(this, DATA_BOOL);

            if (DATA_BOOL != dt)
                res = RES_E_REQUIREBOOL;
            break;

        case UOT_GETIP:
            Expr_SetDataType(this, DATA_STRING);

            if (DATA_INT != dt)
                res = RES_E_REQUIREINT;
            break;

        default:
            ASSERT(0);
            res = RES_E_INVALIDPARAM;
            break;
            }

        if (RFAILED(res))
            Stxerr_Add(hsaStxerr, SzFromUot(uot), Ast_GetLine(this), res);
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Typechecks an expression.

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE Expr_Typecheck(
    PEXPR this,
    PSYMTAB pst,
    HSA hsaStxerr)
    {
    RES res;

    ASSERT(this);
    ASSERT(hsaStxerr);

    switch (Ast_GetType(this))
        {
    case AT_INT_EXPR:
        Expr_SetDataType(this, DATA_INT);
        res = RES_OK;
        break;

    case AT_STRING_EXPR:
        Expr_SetDataType(this, DATA_STRING);
        res = RES_OK;
        break;

    case AT_BOOL_EXPR:
        Expr_SetDataType(this, DATA_BOOL);
        res = RES_OK;
        break;

    case AT_VAR_EXPR:
        res = VarExpr_Typecheck(this, pst, hsaStxerr);
        break;

    case AT_UNOP_EXPR:
        res = UnOpExpr_Typecheck(this, pst, hsaStxerr);
        break;

    case AT_BINOP_EXPR:
        res = BinOpExpr_Typecheck(this, pst, hsaStxerr);
        break;

    default:
        ASSERT(0);
        res = RES_E_INVALIDPARAM;
        break;
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Typecheck the assignment statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE AssignStmt_Typecheck(
    PSTMT this,
    PSYMTAB pst,
    HSA hsaStxerr)
    {
    RES res;
    LPSTR pszIdent;
    DATATYPE dt;

    ASSERT(this);
    ASSERT(hsaStxerr);
    ASSERT(AT_ASSIGN_STMT == Ast_GetType(this));

    pszIdent = AssignStmt_GetIdent(this);
    res = Ident_Typecheck(pszIdent, 0, &dt, Ast_GetLine(this), pst, hsaStxerr);
    if (RSUCCEEDED(res))
        {
        PEXPR pexpr = AssignStmt_GetExpr(this);

        res = Expr_Typecheck(pexpr, pst, hsaStxerr);

        // Types must match
        if (dt != Expr_GetDataType(pexpr))
            {
            res = Stxerr_Add(hsaStxerr, "=", Ast_GetLine(pexpr), RES_E_TYPEMISMATCH);
            }
        }
    return res;
    }


/*----------------------------------------------------------
Purpose: Typecheck the 'while' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE WhileStmt_Typecheck(
    PSTMT this,
    PSYMTAB pst,
    HSA hsaStxerr)
    {
    RES res;
    PEXPR pexpr;

    ASSERT(this);
    ASSERT(hsaStxerr);
    ASSERT(AT_WHILE_STMT == Ast_GetType(this));

    pexpr = WhileStmt_GetExpr(this);
    res = Expr_Typecheck(pexpr, pst, hsaStxerr);
    if (RSUCCEEDED(res))
        {
        if (DATA_BOOL != Expr_GetDataType(pexpr))
            {
            res = Stxerr_Add(hsaStxerr, "'while' expression", Ast_GetLine(pexpr), RES_E_REQUIREBOOL);
            }
        else
            {
            // Typecheck the statement block
            DWORD i;
            DWORD cstmts;
            HPA hpaStmts = WhileStmt_GetStmtBlock(this);

            res = RES_OK;

            cstmts = PAGetCount(hpaStmts);

            // Typecheck each statement
            for (i = 0; i < cstmts; i++)
                {
                PSTMT pstmt = PAFastGetPtr(hpaStmts, i);

                res = Stmt_Typecheck(pstmt, pst, hsaStxerr);
                if (RFAILED(res))
                    break;
                }
            }
        }
        
    return res;
    }


/*----------------------------------------------------------
Purpose: Typecheck the 'if' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE IfStmt_Typecheck(
    PSTMT this,
    PSYMTAB pst,
    HSA hsaStxerr)
    {
    RES res;
    PEXPR pexpr;

    ASSERT(this);
    ASSERT(hsaStxerr);
    ASSERT(AT_IF_STMT == Ast_GetType(this));

    pexpr = IfStmt_GetExpr(this);
    res = Expr_Typecheck(pexpr, pst, hsaStxerr);
    if (RSUCCEEDED(res))
        {
        if (DATA_BOOL != Expr_GetDataType(pexpr))
            {
            res = Stxerr_Add(hsaStxerr, "'if' expression", Ast_GetLine(pexpr), RES_E_REQUIREBOOL);
            }
        else
            {
            // Typecheck the statement block
            DWORD i;
            DWORD cstmts;
            HPA hpaStmts = IfStmt_GetStmtBlock(this);

            res = RES_OK;

            cstmts = PAGetCount(hpaStmts);

            // Typecheck each statement
            for (i = 0; i < cstmts; i++)
                {
                PSTMT pstmt = PAFastGetPtr(hpaStmts, i);

                res = Stmt_Typecheck(pstmt, pst, hsaStxerr);
                if (RFAILED(res))
                    break;
                }
            }
        }
        
    return res;
    }


/*----------------------------------------------------------
Purpose: Typecheck the label statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE LabelStmt_Typecheck(
    PSTMT this,
    PSYMTAB pst,
    HSA hsaStxerr)
    {
    RES res;
    PSTE pste;
    LPSTR pszIdent;

    ASSERT(this);
    ASSERT(hsaStxerr);
    ASSERT(AT_LABEL_STMT == Ast_GetType(this));

    pszIdent = LabelStmt_GetIdent(this);

    if (RES_OK == Symtab_FindEntry(pst, pszIdent, STFF_DEFAULT, &pste, NULL))
        {
        if (DATA_LABEL == STE_GetDataType(pste))
            res = RES_OK;
        else
            res = Stxerr_Add(hsaStxerr, pszIdent, Ast_GetLine(this), RES_E_REQUIRELABEL);
        }
    else
        {
        // This should never get here
        ASSERT(0);
        res = RES_E_FAIL;
        }
        
    return res;
    }


/*----------------------------------------------------------
Purpose: Typecheck the 'goto' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE GotoStmt_Typecheck(
    PSTMT this,
    PSYMTAB pst,
    HSA hsaStxerr)
    {
    LPSTR pszIdent;

    ASSERT(this);
    ASSERT(hsaStxerr);
    ASSERT(AT_GOTO_STMT == Ast_GetType(this));

    pszIdent = GotoStmt_GetIdent(this);

    return Ident_Typecheck(pszIdent, DATA_LABEL, NULL, Ast_GetLine(this), pst, hsaStxerr);
    }


/*----------------------------------------------------------
Purpose: Typecheck the transmit statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE TransmitStmt_Typecheck(
    PSTMT this,
    PSYMTAB pst,
    HSA hsaStxerr)
    {
    RES res;
    PEXPR pexpr;

    ASSERT(this);
    ASSERT(hsaStxerr);
    ASSERT(AT_TRANSMIT_STMT == Ast_GetType(this));

    pexpr = TransmitStmt_GetExpr(this);
    res = Expr_Typecheck(pexpr, pst, hsaStxerr);
    if (DATA_STRING != Expr_GetDataType(pexpr))
        {
        res = Stxerr_Add(hsaStxerr, "'transmit' parameter", Ast_GetLine(pexpr), RES_E_REQUIRESTRING);
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Typecheck the 'waitfor' statement

            waitfor <Expr> 
                [ then IDENT { , <Expr> then IDENT } ]
                [ until <UntilExpr> ]
         
         where:
            <Expr>          is a string
            IDENT           is a label
            <UntilExpr>     is an integer

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE WaitforStmt_Typecheck(
    PSTMT this,
    PSYMTAB pst,
    HSA hsaStxerr)
    {
    RES res;
    PEXPR pexpr;
    HSA hsa;
    DWORD i;
    DWORD ccase;
    PWAITCASE pwc;

    ASSERT(this);
    ASSERT(hsaStxerr);
    ASSERT(AT_WAITFOR_STMT == Ast_GetType(this));

    // Typecheck that <Expr> is of type string, and any 
    // IDENTs are labels.

    hsa = WaitforStmt_GetCaseList(this);
    ccase = SAGetCount(hsa);
    for (i = 0; i < ccase; i++)
        {
        SAGetItemPtr(hsa, i, &pwc);
        ASSERT(pwc);

        // Typecheck <Expr>
        res = Expr_Typecheck(pwc->pexpr, pst, hsaStxerr);
        if (DATA_STRING != Expr_GetDataType(pwc->pexpr))
            {
            res = Stxerr_Add(hsaStxerr, "'waitfor' parameter", Ast_GetLine(pwc->pexpr), RES_E_REQUIRESTRING);
            break;
            }

        // Typecheck IDENT label.  If there is only one <Expr>, there
        // may not be an IDENT label.

        if (pwc->pszIdent)
            {
            res = Ident_Typecheck(pwc->pszIdent, DATA_LABEL, NULL, Ast_GetLine(pwc->pexpr), pst, hsaStxerr);
            if (RFAILED(res))
                break;
            }
        else
            ASSERT(1 == ccase);
        }

    // 'until' expression is optional
    if (RSUCCEEDED(res) &&
        NULL != (pexpr = WaitforStmt_GetUntilExpr(this)))
        {
        res = Expr_Typecheck(pexpr, pst, hsaStxerr);
        if (DATA_INT != Expr_GetDataType(pexpr))
            {
            res = Stxerr_Add(hsaStxerr, "'until' parameter", Ast_GetLine(pexpr), RES_E_REQUIREINT);
            }
        }    
    return res;
    }


/*----------------------------------------------------------
Purpose: Typecheck the 'delay' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE DelayStmt_Typecheck(
    PSTMT this,
    PSYMTAB pst,
    HSA hsaStxerr)
    {
    RES res;
    PEXPR pexpr;

    ASSERT(this);
    ASSERT(hsaStxerr);
    ASSERT(AT_DELAY_STMT == Ast_GetType(this));

    pexpr = DelayStmt_GetExpr(this);
    res = Expr_Typecheck(pexpr, pst, hsaStxerr);
    if (DATA_INT != Expr_GetDataType(pexpr))
        {
        res = Stxerr_Add(hsaStxerr, "'delay' parameter", Ast_GetLine(pexpr), RES_E_REQUIREINT);
        }
        
    return res;
    }


/*----------------------------------------------------------
Purpose: Typecheck the 'set' statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE SetStmt_Typecheck(
    PSTMT this,
    PSYMTAB pst,
    HSA hsaStxerr)
    {
    RES res;
    PEXPR pexpr;

    ASSERT(this);
    ASSERT(hsaStxerr);
    ASSERT(AT_SET_STMT == Ast_GetType(this));

    switch (SetStmt_GetType(this))
        {
    case ST_IPADDR:
        pexpr = SetIPStmt_GetExpr(this);
        res = Expr_Typecheck(pexpr, pst, hsaStxerr);
        if (DATA_STRING != Expr_GetDataType(pexpr))
            {
            res = Stxerr_Add(hsaStxerr, "'ipaddr' parameter", Ast_GetLine(pexpr), RES_E_REQUIRESTRING);
            }
        break;

    case ST_PORT:
    case ST_SCREEN:
        res = RES_OK;
        break;

    default:
        ASSERT(0);
        res = RES_E_INVALIDPARAM;
        break;
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Typecheck a statement

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE Stmt_Typecheck(
    PSTMT this,
    PSYMTAB pst,
    HSA hsaStxerr)
    {
    RES res;

    ASSERT(this);
    ASSERT(hsaStxerr);

    switch (Ast_GetType(this))
        {
    case AT_ENTER_STMT:
    case AT_LEAVE_STMT:
        res = RES_OK;
        break;

    case AT_WHILE_STMT:
        res = WhileStmt_Typecheck(this, pst, hsaStxerr);
        break;

    case AT_IF_STMT:
        res = IfStmt_Typecheck(this, pst, hsaStxerr);
        break;

    case AT_ASSIGN_STMT:
        res = AssignStmt_Typecheck(this, pst, hsaStxerr);
        break;

    case AT_HALT_STMT:
        // Nothing to typecheck here
        res = RES_OK;
        break;

    case AT_TRANSMIT_STMT:
        res = TransmitStmt_Typecheck(this, pst, hsaStxerr);
        break;

    case AT_WAITFOR_STMT:
        res = WaitforStmt_Typecheck(this, pst, hsaStxerr);
        break;

    case AT_DELAY_STMT:
        res = DelayStmt_Typecheck(this, pst, hsaStxerr);
        break;

    case AT_LABEL_STMT:
        res = LabelStmt_Typecheck(this, pst, hsaStxerr);
        break;

    case AT_GOTO_STMT:
        res = GotoStmt_Typecheck(this, pst, hsaStxerr);
        break;

    case AT_SET_STMT:
        res = SetStmt_Typecheck(this, pst, hsaStxerr);
        break;

    default:
        ASSERT(0);
        res = RES_E_INVALIDPARAM;
        break;
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Typecheck a procedure declaration.

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PRIVATE ProcDecl_Typecheck(
    PPROCDECL this,
    PSYMTAB pst,
    HSA hsaStxerr)
    {
    RES res = RES_OK;
    DWORD i;
    DWORD cstmts;

    ASSERT(this);
    ASSERT(hsaStxerr);

    cstmts = PAGetCount(this->hpaStmts);

    // Typecheck each statement
    for (i = 0; i < cstmts; i++)
        {
        PSTMT pstmt = PAFastGetPtr(this->hpaStmts, i);

        res = Stmt_Typecheck(pstmt, this->pst, hsaStxerr);
        if (RFAILED(res))
            break;
        }

    return res;
    }


/*----------------------------------------------------------
Purpose: Typecheck a module declaration.

Returns: RES_OK
         or some error result

Cond:    --
*/
RES PUBLIC ModuleDecl_Typecheck(
    PMODULEDECL this,
    HSA hsaStxerr)
    {
    RES res = RES_OK;
    DWORD i;
    DWORD cprocs;
    BOOL bFoundMain = FALSE;

    ASSERT(this);
    ASSERT(hsaStxerr);

    TRACE_MSG(TF_GENERAL, "Typechecking...");

    cprocs = PAGetCount(this->hpaProcs);

    // Typecheck each proc
    for (i = 0; i < cprocs; i++)
        {
        PPROCDECL pprocdecl = PAFastGetPtr(this->hpaProcs, i);

        if (IsSzEqualC(ProcDecl_GetIdent(pprocdecl), "main"))
            bFoundMain = TRUE;

        res = ProcDecl_Typecheck(pprocdecl, this->pst, hsaStxerr);
        if (RFAILED(res))
            break;
        }

    // There must be a main proc
    if (RSUCCEEDED(res) && !bFoundMain)
        res = Stxerr_AddTok(hsaStxerr, NULL, RES_E_MAINMISSING);

    return res;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasscrpt\util.c ===
//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//
// Copyright  1993-1995  Microsoft Corporation.  All Rights Reserved.
//
//      MODULE:         util.c
//
//      PURPOSE:        Common utilities
//
//	PLATFORMS:	Windows 95
//
//      FUNCTIONS:
//              InitACBList() - initializes the session control block list
//              DeInitACBList() - cleans up the session control block list
//              FindACBFromConn() - searches or allocates a session control block
//              CleanupACB() - removes the session control block
//              EnumCloseThreadWindow() - closes each window for the SMM thread
//              CloseThreadWindows() - enumerates the SMM thread window
//
//	SPECIAL INSTRUCTIONS: N/A
//

#include "proj.h"     // includes common header files and global declarations
#include "rcids.h"
#include <rtutils.h>

 DWORD g_dwRasscrptTraceId = INVALID_TRACEID;

#pragma data_seg(DATASEG_READONLY)
const static char c_szScriptEntry[] = {REGSTR_KEY_PROF"\\%s"};
#pragma data_seg()

/*----------------------------------------------------------
Purpose: Determines the script info that may be associated with
         the given connection name.

Returns: TRUE if an associated script was found (in registry)
         
Cond:    --
*/
BOOL PUBLIC GetScriptInfo(
    LPCSTR pszConnection,
    PSCRIPT pscriptBuf)
    {
#pragma data_seg(DATASEG_READONLY)
    const static char c_szScript[] = REGSTR_VAL_SCRIPT;
    const static char c_szMode[]   = REGSTR_VAL_MODE;
#pragma data_seg()
    BOOL bRet;
    char szSubKey[MAX_BUF];
    DWORD cbSize;
    DWORD dwType;
    HKEY hkey;

    ASSERT(pszConnection);
    ASSERT(pscriptBuf);

    // Assume non-test mode
    pscriptBuf->uMode = NORMAL_MODE;

    // Is there a script for this connection?
    cbSize = sizeof(pscriptBuf->szPath);
    wsprintf(szSubKey, c_szScriptEntry, pszConnection);
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, szSubKey, 0, KEY_ALL_ACCESS, &hkey))
        {
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szScript, NULL, 
            &dwType, pscriptBuf->szPath, &cbSize) &&
            REG_SZ == dwType)
            {
            // Yes
            TRACE_MSG(TF_GENERAL, "Found script \"%s\" for connection \"%s\"", 
                pscriptBuf->szPath, pszConnection);

            // Get the test mode
            cbSize = sizeof(pscriptBuf->uMode);
            if (ERROR_SUCCESS != RegQueryValueEx(hkey, c_szMode, NULL,
                &dwType, (LPBYTE)&(pscriptBuf->uMode), &cbSize) ||
                REG_BINARY != dwType)
                {
                pscriptBuf->uMode = NORMAL_MODE;
                }

            bRet = TRUE;
            }
        else
            {
            // No
            TRACE_MSG(TF_GENERAL, "No script found for connection \"%s\"", 
                pszConnection);

            *(pscriptBuf->szPath) = 0;
            bRet = FALSE;
            }
        RegCloseKey(hkey);
        }
    else
        {
        TRACE_MSG(TF_GENERAL, "Connection \"%s\" not found", pszConnection);
        bRet = FALSE;
        }
    return bRet;
    }


/*----------------------------------------------------------
Purpose: Get/set the window placement of the terminal window with
         the given connection name.

Returns: TRUE if an associated script was found (in registry)
         
Cond:    --
*/
BOOL PUBLIC GetSetTerminalPlacement(
    LPCSTR pszConnection,
    LPWINDOWPLACEMENT pwp,
    BOOL fGet)
    {
#pragma data_seg(DATASEG_READONLY)
const static char c_szPlacement[] = REGSTR_VAL_TERM;
#pragma data_seg()
    BOOL bRet;
    char szSubKey[MAX_BUF];
    DWORD cbSize;
    DWORD dwType;
    HKEY hkey;

    ASSERT(pszConnection);
    ASSERT(pwp);

    bRet = FALSE;
    wsprintf(szSubKey, c_szScriptEntry, pszConnection);
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, szSubKey, 0, KEY_ALL_ACCESS, &hkey))
        {
        if (fGet)
            {
            cbSize = sizeof(*pwp);
            if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szPlacement, NULL,
                &dwType, (LPBYTE)pwp, &cbSize) &&
                REG_BINARY == dwType)
                {
                bRet = TRUE;
                };
             }
        else
            {
            if (ERROR_SUCCESS == RegSetValueEx(hkey, c_szPlacement, 0,
                REG_BINARY, (LPBYTE)pwp, sizeof(*pwp)))
                {
                bRet = TRUE;
                };
            };
        RegCloseKey(hkey);
        };
    return bRet;
    }

/*----------------------------------------------------------
Purpose: This function gets the current character from the
         given psz string, and returns the pointer to the
         next character position.  

         This function should increment on a byte-basis only.
         The callers need to compare or send on a byte basis.

         The *pbIsTailByte parameter is updated to reflect whether
         the current character is a DBCS lead-byte character.
         The caller may use this state information to determine
         whether *pch is part of a DBCS character.

Returns: see above
Cond:    --
*/
LPCSTR PUBLIC MyNextChar(
    LPCSTR psz,
    char * pch,
    DWORD * pdwFlags)       // One of MNC_* 
    {
    BOOL bIsTailByte;

    #define IS_CARET(ch)            ('^' == (ch))
    #define IS_SPECIAL_LEAD(ch)     ('<' == (ch))
    #define BYTE_CR                 0x0D
    #define BYTE_LF                 0x0A

    ASSERT(psz);
    ASSERT(pch);
    ASSERT(pdwFlags);

    bIsTailByte = IsFlagSet(*pdwFlags, MNC_ISTAILBYTE);

    // bIsTailByte should only be true for trailing bytes on entry
    ASSERT(FALSE == bIsTailByte || (bIsTailByte && !IsDBCSLeadByte(*psz)));

    // These flags must be mutually exclusive
    ASSERT(IsFlagSet(*pdwFlags, MNC_ISLEADBYTE) && IsFlagClear(*pdwFlags, MNC_ISTAILBYTE) ||
           IsFlagClear(*pdwFlags, MNC_ISLEADBYTE) && IsFlagSet(*pdwFlags, MNC_ISTAILBYTE) ||
           0 == *pdwFlags); 

    // Remember whether we're in a DBCS trailing byte for next time
    if (IsDBCSLeadByte(*psz))
        {
        SetFlag(*pdwFlags, MNC_ISLEADBYTE);
        ClearFlag(*pdwFlags, MNC_ISTAILBYTE);
        }
    else if (IsFlagSet(*pdwFlags, MNC_ISLEADBYTE))
        {
        ClearFlag(*pdwFlags, MNC_ISLEADBYTE);
        SetFlag(*pdwFlags, MNC_ISTAILBYTE);
        }
    else
        {
        *pdwFlags = 0;
        }

    // Is this a DBCS trailing byte?
    if (IsFlagSet(*pdwFlags, MNC_ISTAILBYTE))
        {
        // Yes
        *pch = *psz;
        }

    // Is this a lead control character?
    else if (IS_CARET(*psz))
        {
        // Yes; look at next character for control character
        LPCSTR pszT = psz + 1;
        if (0 == *pszT)
            {
            // Reached end of string
            *pch = '^';
            }
        else if (InRange(*pszT, '@', '_'))
            {
            *pch = *pszT - '@';
            psz = pszT;
            }
        else if (InRange(*pszT, 'a', 'z'))
            {
            *pch = *pszT - 'a' + 1;
            psz = pszT;
            }
        else 
            {
            // Show the caret as a plain old caret
            *pch = *pszT;
            }
        }
    else if (IS_SPECIAL_LEAD(*psz))
        {
        // Is this <cr> or <lf>?
        int i;
        char rgch[4];   // big enough to hold "lf>" or "cr>"
        LPCSTR pszT = psz + 1;
        LPCSTR pszTPrev = psz;

        for (i = 0; 
            *pszT && i < sizeof(rgch)-1; 
            i++, pszT++)
            {
            rgch[i] = *pszT;
            pszTPrev = pszT;
            }
        rgch[i] = 0;    // add null terminator

        if (IsSzEqualC(rgch, "cr>"))
            {
            *pch = BYTE_CR;
            psz = pszTPrev;
            }
        else if (IsSzEqual(rgch, "lf>"))
            {
            *pch = BYTE_LF;
            psz = pszTPrev;
            }
        else
            {
            *pch = *psz;
            }
        }
    else if (IS_BACKSLASH(*psz))
        {
        // Is this \", \^, \<, or \\?
        LPCSTR pszT = psz + 1;

        switch (*pszT)
            {
        case '"':
        case '\\':
        case '^':
        case '<':
            *pch = *pszT;
            psz = pszT;
            break;

        default:
            *pch = *psz;
            break;
            }
        }
    else
        {
        *pch = *psz;
        }

    return psz + 1;
    }


#pragma data_seg(DATASEG_READONLY)
struct tagMPRESIDS
    {
    RES  res;
    UINT ids;
    } const c_mpresids[] = {
        { RES_E_FAIL,               IDS_ERR_InternalError },
        { RES_E_INVALIDPARAM,       IDS_ERR_InternalError },
        { RES_E_OUTOFMEMORY,        IDS_ERR_OutOfMemory },
        { RES_E_EOF,                IDS_ERR_UnexpectedEOF },
        { RES_E_MAINMISSING,        IDS_ERR_MainProcMissing },
        { RES_E_SYNTAXERROR,        IDS_ERR_SyntaxError },
        { RES_E_REDEFINED,          IDS_ERR_Redefined },
        { RES_E_UNDEFINED,          IDS_ERR_Undefined },
        { RES_E_IDENTMISSING,       IDS_ERR_IdentifierMissing },
        { RES_E_EOFUNEXPECTED,      IDS_ERR_UnexpectedEOF },
        { RES_E_STRINGMISSING,      IDS_ERR_StringMissing },
        { RES_E_INTMISSING,         IDS_ERR_IntMissing },
        { RES_E_INVALIDTYPE,        IDS_ERR_InvalidType },
        { RES_E_INVALIDSETPARAM,    IDS_ERR_InvalidParam },
        { RES_E_INVALIDIPPARAM,     IDS_ERR_InvalidIPParam },
        { RES_E_INVALIDPORTPARAM,   IDS_ERR_InvalidPortParam },
        { RES_E_INVALIDRANGE,       IDS_ERR_InvalidRange },
        { RES_E_INVALIDSCRNPARAM,   IDS_ERR_InvalidScreenParam },
        { RES_E_RPARENMISSING,      IDS_ERR_RParenMissing },
        { RES_E_REQUIREINT,         IDS_ERR_RequireInt },
        { RES_E_REQUIRESTRING,      IDS_ERR_RequireString },
        { RES_E_REQUIREBOOL,        IDS_ERR_RequireBool },
        { RES_E_REQUIREINTSTRING,   IDS_ERR_RequireIntString },
        { RES_E_REQUIREINTSTRBOOL,  IDS_ERR_RequireIntStrBool },
        { RES_E_REQUIRELABEL,       IDS_ERR_RequireLabel },
        { RES_E_TYPEMISMATCH,       IDS_ERR_TypeMismatch },
        { RES_E_DIVBYZERO,          IDS_ERR_DivByZero },
        };
#pragma data_seg()

/*----------------------------------------------------------
Purpose: Returns a string resource ID given the specific result
         value.  This function returns 0 if the result does
         not have an associated message string.

Returns: see above
Cond:    --
*/
UINT PUBLIC IdsFromRes(
    RES res)
    {
    int i;

    for (i = 0; i < ARRAY_ELEMENTS(c_mpresids); i++)
        {
        if (res == c_mpresids[i].res)
            return c_mpresids[i].ids;
        }
    return 0;
    }

#ifdef DEBUG

#pragma data_seg(DATASEG_READONLY)
struct tagRESMAP
    {
    RES res;
    LPCSTR psz;
    } const c_rgresmap[] = {
        DEBUG_STRING_MAP(RES_OK),
        DEBUG_STRING_MAP(RES_FALSE),
        DEBUG_STRING_MAP(RES_HALT),
        DEBUG_STRING_MAP(RES_E_FAIL),
        DEBUG_STRING_MAP(RES_E_OUTOFMEMORY),
        DEBUG_STRING_MAP(RES_E_INVALIDPARAM),
        DEBUG_STRING_MAP(RES_E_EOF),
        DEBUG_STRING_MAP(RES_E_MOREDATA),
        DEBUG_STRING_MAP(RES_E_MAINMISSING),     
        DEBUG_STRING_MAP(RES_E_SYNTAXERROR),
        DEBUG_STRING_MAP(RES_E_REDEFINED),
        DEBUG_STRING_MAP(RES_E_UNDEFINED),
        DEBUG_STRING_MAP(RES_E_IDENTMISSING),    
        DEBUG_STRING_MAP(RES_E_EOFUNEXPECTED),   
        DEBUG_STRING_MAP(RES_E_STRINGMISSING),   
        DEBUG_STRING_MAP(RES_E_INTMISSING),   
        DEBUG_STRING_MAP(RES_E_INVALIDTYPE),     
        DEBUG_STRING_MAP(RES_E_INVALIDSETPARAM),
        DEBUG_STRING_MAP(RES_E_INVALIDIPPARAM),
        DEBUG_STRING_MAP(RES_E_INVALIDPORTPARAM),
        DEBUG_STRING_MAP(RES_E_INVALIDRANGE),
        DEBUG_STRING_MAP(RES_E_INVALIDSCRNPARAM),
        DEBUG_STRING_MAP(RES_E_RPARENMISSING),
        DEBUG_STRING_MAP(RES_E_REQUIREINT),
        DEBUG_STRING_MAP(RES_E_REQUIRESTRING),
        DEBUG_STRING_MAP(RES_E_REQUIREBOOL),
        DEBUG_STRING_MAP(RES_E_REQUIREINTSTRING),
        DEBUG_STRING_MAP(RES_E_REQUIREINTSTRBOOL),
        DEBUG_STRING_MAP(RES_E_REQUIRELABEL),
        DEBUG_STRING_MAP(RES_E_TYPEMISMATCH),
        DEBUG_STRING_MAP(RES_E_DIVBYZERO),
        };
#pragma data_seg()

/*----------------------------------------------------------
Purpose: Returns the string form of a RES value.

Returns: String ptr
Cond:    --
*/
LPCSTR PUBLIC Dbg_GetRes(
    RES res)
    {
    int i;

    for (i = 0; i < ARRAY_ELEMENTS(c_rgresmap); i++)
        {
        if (res == c_rgresmap[i].res)
            return c_rgresmap[i].psz;
        }
    return "Unknown RES";
    }


#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\devicedb.h ===
/*
    File    devicedb.h

    Definition of the device database for the ras dialup server.

    Paul Mayfield, 10/2/97
*/

#ifndef __rassrvui_devicedb_h
#define __rassrvui_devicedb_h

#include <windows.h>

// ===================================
// Types of incoming connections
// ===================================
#define INCOMING_TYPE_PHONE 0                
#define INCOMING_TYPE_DIRECT 1
#define INCOMING_TYPE_VPN 4
#define INCOMING_TYPE_ISDN 8

// =====================================
// Device database functions
// =====================================

//
// Opens a handle to the database of devices
//
DWORD 
devOpenDatabase(
    OUT HANDLE * hDevDatabase);

//
// Closes the general database and flushes any changes 
// to the system when bFlush is TRUE
//
DWORD 
devCloseDatabase(
    IN HANDLE hDevDatabase);

//
// Commits any changes made to the general tab values 
//
DWORD 
devFlushDatabase(
    IN HANDLE hDevDatabase);

//
// Rollsback any changes made to the general tab values
//
DWORD 
devRollbackDatabase(
    IN HANDLE hDevDatabase);

//
// Reloads any values for the general tab from disk
//
DWORD 
devReloadDatabase(
    IN HANDLE hDevDatabase);

//
// Adds all com ports as devices.  If a com port gets
// enabled (devSetDeviceEnable), then it will have a 
// null modem installed over it.
//
DWORD 
devAddComPorts(
    IN HANDLE hDevDatabase);

//
// Filters out all devices in the database except those that
// meet the given type description (can be ||'d).
//
DWORD 
devFilterDevices(
    IN HANDLE hDevDatabase, 
    IN DWORD dwType);

//
// Gets a handle to a device to be displayed in the general tab
//
DWORD 
devGetDeviceHandle(
    IN  HANDLE hDevDatabase, 
    IN  DWORD dwIndex, 
    OUT HANDLE * hDevice);

//
// Returns a count of devices to be displayed in the general tab
//
DWORD 
devGetDeviceCount(
    IN  HANDLE hDevDatabase, 
    OUT LPDWORD lpdwCount);

//
// Loads the vpn enable status
//
DWORD 
devGetVpnEnable(
    IN  HANDLE hDevDatabase, 
    OUT BOOL * pbEnabled);

//
// Saves the vpn enable status
//
DWORD 
devSetVpnEnable(
    IN HANDLE hDevDatabase, 
    IN BOOL bEnable);

// Saves the vpn Original value enable status
//
DWORD 
devSetVpnOrigEnable(
    IN HANDLE hDevDatabase, 
    IN BOOL bEnable);

//
// Returns the count of enabled endpoints accross all devices
//
DWORD 
devGetEndpointEnableCount(
    IN  HANDLE hDevDatabase, 
    OUT LPDWORD lpdwCount);

//
// Returns a pointer to the name of a device
//
DWORD 
devGetDeviceName(
    IN  HANDLE hDevice, 
    OUT PWCHAR * pszDeviceName);

//
// Returns the type of a device
//
DWORD 
devGetDeviceType(
    IN  HANDLE hDevice, 
    OUT LPDWORD lpdwType);

//
// Returns an identifier of the device that can be used in conjunction 
// with tapi calls.
//
DWORD 
devGetDeviceId(
    IN  HANDLE hDevice, 
    OUT LPDWORD lpdwId);

//
// Returns the enable status of a device for dialin
//
DWORD 
devGetDeviceEnable(
    IN  HANDLE hDevice, 
    OUT BOOL * pbEnabled);

//
// Sets the enable status of a device for dialin
//
DWORD 
devSetDeviceEnable(
    IN HANDLE hDevice, 
    IN BOOL bEnable);

//
// Returns whether the given device is a com port as added
// by devAddComPorts
//
DWORD 
devDeviceIsComPort(
    IN  HANDLE hDevice, 
    OUT PBOOL pbIsComPort);

BOOL
devIsVpnEnableChanged(
    IN HANDLE hDevDatabase) ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\error.c ===
/*
	File    error.h

    Implements the error display/handling mechanisms used by the Ras Server
    UI for connections.

    10/20/97
*/

#include "rassrv.h"

// Sends trace information
DWORD DbgOutputTrace (LPSTR pszTrace, ...) {
    va_list arglist;
    char szBuffer[1024], szTemp[1024];

    va_start(arglist, pszTrace); 
    vsprintf(szTemp, pszTrace, arglist);
    va_end(arglist);

    sprintf(szBuffer, "RasSrvUi: %s", szTemp);

    TRACE(szBuffer);
    ErrOutputDebugger(szBuffer);

    return NO_ERROR;
}

// Sends debug output to a debugger terminal
DWORD ErrOutputDebugger (LPSTR szError) {
#if DBG
    OutputDebugStringA(szError);
    OutputDebugStringA("\n");
#endif    

    return NO_ERROR;
}


// Sets error information for the user tab catagory
DWORD ErrUserCatagory(DWORD dwSubCatagory, DWORD dwErrCode, DWORD dwData) {
    return dwErrCode;
}


// Displays the error for the given catagory, subcatagory,  and code.  The 
// parameters define what error messages are loaded from the resources
// of this project.
DWORD ErrDisplayError (HWND hwndParent, 
                       DWORD dwErrCode, 
                       DWORD dwCatagory, 
                       DWORD dwSubCatagory, 
                       DWORD dwData) {

    BOOL bDisplay = TRUE;
    DWORD dwMessage, dwTitle;
    PWCHAR pszMessage, pszTitle;

    switch (dwCatagory) {
        case ERR_QUEUE_CATAGORY:
        case ERR_GLOBAL_CATAGORY:
        case ERR_RASSRV_CATAGORY:
        case ERR_MULTILINK_CATAGORY:
        case ERR_GENERIC_CATAGORY:
        case ERR_GENERALTAB_CATAGORY:
        case ERR_ADVANCEDTAB_CATAGORY:
        case ERR_IPXPROP_CATAGORY:
        case ERR_TCPIPPROP_CATAGORY:
            dwMessage = dwErrCode; 
            break;

        case ERR_USERTAB_CATAGORY:
            dwMessage = ErrUserCatagory(dwSubCatagory, dwErrCode, dwData);
            break;
    }

    if (bDisplay) {
        dwTitle = dwCatagory;
        pszMessage = (PWCHAR) PszLoadString(Globals.hInstDll, dwMessage);
        pszTitle = (PWCHAR) PszLoadString(Globals.hInstDll, dwTitle);
        MessageBoxW(hwndParent, 
                    pszMessage, 
                    pszTitle, 
                    MB_OK | MB_ICONERROR | MB_APPLMODAL);

    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\error.h ===
/*
	File    error.h

    Defines the error display/handling mechanisms used by the Ras Server
    UI for connections.

    10/20/97
*/

#ifndef _rassrvui_error_h
#define _rassrvui_error_h

#include <windows.h>


// Displays the error for the given catagory, subcatagory,  and code.  The 
// parameters define what error messages are loaded from the resources
// of this project.
DWORD ErrDisplayError (HWND hwndParent, 
                       DWORD dwErrCode, 
                       DWORD dwCatagory, 
                       DWORD dwSubCatagory, 
                       DWORD dwData);

// Sends debug output to a debugger terminal
DWORD ErrOutputDebugger (LPSTR szError);

// Sends trace information out
DWORD DbgOutputTrace (LPSTR pszTrace, ...);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\gentab.c ===
/*
    File    gentab.c

    Implements the ui behind the general tab for the 
    connections dialup server ui.

    Paul Mayfield, 10/2/97
*/

#include "rassrv.h"
#include <tapi.h>

// Help maps
static const DWORD phmGenTab[] =
{
    CID_GenTab_LV_Devices,          IDH_GenTab_LV_Devices,
    CID_GenTab_CB_Multilink,        IDH_GenTab_CB_Multilink,
    CID_GenTab_PB_Properties,       IDH_GenTab_PB_Properties,
    CID_GenTab_CB_Vpn,              IDH_GenTab_CB_Vpn,
    CID_GenTab_CB_ShowIcons,        IDH_GenTab_CB_ShowIcons,
    0,                              0
};

// Fills in the property sheet structure with the information 
// required to display the general tab.
//
DWORD 
GenTabGetPropertyPage(
    IN LPPROPSHEETPAGE ppage, 
    IN LPARAM lpUserData) 
{
    // Initialize
    ZeroMemory(ppage, sizeof(PROPSHEETPAGE));

    // Fill in the values
    ppage->dwSize      = sizeof(PROPSHEETPAGE);
    ppage->hInstance   = Globals.hInstDll;
    ppage->pszTemplate = MAKEINTRESOURCE(PID_GenTab);
    ppage->pfnDlgProc  = GenTabDialogProc;
    ppage->pfnCallback = RasSrvInitDestroyPropSheetCb;
    ppage->lParam      = lpUserData;
    ppage->dwFlags     = PSP_USECALLBACK;

    return NO_ERROR;
}

// Error reporting
//
VOID
GenTabDisplayError(
    IN HWND hwnd, 
    IN DWORD dwErr) 
{
    ErrDisplayError(
        hwnd, 
        dwErr, 
        ERR_GENERALTAB_CATAGORY, 
        0, 
        Globals.dwErrorData);
}

//
// Returns the index of an to display icon based on the type of incoming
// connection and whether or not it should be checked.
//
INT 
GenTabGetIconIndex(
    IN DWORD dwType, 
    IN BOOL bEnabled) 
{
    if (dwType == INCOMING_TYPE_PHONE)
    {
        return DI_Phone;
    }
    else
    {
        return DI_Direct;
    }
}

//
// Fills in the device list with the list of the devices stored in the 
// device database.  Also, initializes the checked/unchecked status
// of each device.
//
DWORD 
GenTabFillDeviceList(
    IN HWND hwndDlg, 
    IN HWND hwndLV, 
    IN HANDLE hDevDatabase) 
{
    LV_ITEM lvi;
    LV_COLUMN lvc;
    DWORD dwCount, i, dwErr, dwType;
    HANDLE hDevice;
    PWCHAR pszName;
    char pszAName[1024];
    BOOL bEnabled;

    // Get the count of all the users
    dwErr = devGetDeviceCount(hDevDatabase, &dwCount);
    if (dwErr != NO_ERROR) 
    {
        GenTabDisplayError(hwndLV, ERR_DEVICE_DATABASE_CORRUPT);
        return dwErr;
    }

    // Initialize the list item
    ZeroMemory(&lvi, sizeof(LV_ITEM));
    lvi.mask = LVIF_TEXT | LVIF_IMAGE;

    // If there are devices to display then populate the list box
    // with them
    if (dwCount > 0) 
    {
        ListView_SetDeviceImageList(hwndLV, Globals.hInstDll);

        // Looop through all of the devices adding them to the list
        for (i=0; i<dwCount; i++) 
        {
            dwErr = devGetDeviceHandle(hDevDatabase, i, &hDevice);
            if (dwErr == NO_ERROR) 
            {
                devGetDeviceName (hDevice, &pszName);
                devGetDeviceEnable (hDevice, &bEnabled);
                devGetDeviceType (hDevice, &dwType);
                lvi.iImage = GenTabGetIconIndex(dwType, bEnabled);
                lvi.iItem = i;
                lvi.pszText = pszName;
                lvi.cchTextMax = wcslen(pszName)+1;
                ListView_InsertItem(hwndLV,&lvi);
                ListView_SetCheck(hwndLV, i, bEnabled);
            }
        }

        // Select the first item in the list view if any items exist
        //
        ListView_SetItemState(
            hwndLV, 
            0, 
            LVIS_SELECTED | LVIS_FOCUSED, 
            LVIS_SELECTED | LVIS_FOCUSED);

        // Initialize the alignment of the text that gets displayed
        lvc.mask = LVCF_FMT;
        lvc.fmt = LVCFMT_LEFT;
    }

    // If there are no devices then we display a message in the big
    // white box explaining that we have no devices to show.
    else 
    {
        PWCHAR pszLine1, pszLine2;

        pszLine1 = (PWCHAR) 
            PszLoadString(Globals.hInstDll, SID_NO_DEVICES1);
            
        pszLine2 = (PWCHAR) 
            PszLoadString(Globals.hInstDll, SID_NO_DEVICES2);
            
        lvi.mask = LVIF_TEXT;

        lvi.iItem = 0;
        lvi.pszText = pszLine1;
        lvi.cchTextMax = wcslen(pszLine1);
        ListView_InsertItem(hwndLV, &lvi);
        
        lvi.iItem = 1;
        lvi.pszText = pszLine2;
        lvi.cchTextMax = wcslen(pszLine2);
        ListView_InsertItem(hwndLV, &lvi);

        // Initialize the alignment of the text that gets displayed
        lvc.mask = LVCF_FMT;
        lvc.fmt = LVCFMT_CENTER;

        // Disable the list view
        EnableWindow(hwndLV, FALSE);

        // Disable the properties button while you're at it
        EnableWindow(
            GetDlgItem(hwndDlg, CID_GenTab_PB_Properties), 
            FALSE);
    }
    
    // Add a colum so that we'll display in report view
    ListView_InsertColumn(hwndLV, 0, &lvc);
    ListView_SetColumnWidth(hwndLV, 0, LVSCW_AUTOSIZE_USEHEADER);
    
    return NO_ERROR;
}

//
// This function causes the multilink check box behave in a way that 
// allows the user to see how multilink works.
//
DWORD 
GenTabAdjustMultilinkAppearance(
    IN HWND hwndDlg, 
    IN HANDLE hDevDatabase, 
    IN HANDLE hMiscDatabase) 
{
    DWORD dwErr = NO_ERROR, i, dwEndpointsEnabled;
    HWND hwndML = GetDlgItem(hwndDlg, CID_GenTab_CB_Multilink);
    BOOL bDisable, bUncheck, bFlag = FALSE, bIsServer;

    do
    {
        // Initialize default behavior in case of an error
        //
        bDisable = TRUE;
        bUncheck = FALSE;
    
        // Find out how many endpoints are enabled for inbound calls
        //
        dwErr = devGetEndpointEnableCount(
                    hDevDatabase, 
                    &dwEndpointsEnabled);
        if (dwErr != NO_ERROR)
        {
            break;
        }
    
        // If multiple devices are not enabled for inbound calls then
        // multilink is meaningless.  Disable the multilink control and 
        // uncheck it.
        //
        if (dwEndpointsEnabled < 2) 
        {
            bUncheck = TRUE;
            bDisable = TRUE;
            dwErr = NO_ERROR;
            break;
        }
    
        // The multilink check only makes sense on NT Server.  This is 
        // based on the following assumptions
        //   1. You only disable multilink so that you can free lines 
        //      for additional callers.
        //   2. PPP will enforce that you only have one caller over 
        //      modem device on nt wks anyway.
        //
        miscGetProductType(hMiscDatabase, &bIsServer);
        if (! bIsServer) 
        {
            bDisable = TRUE;
            bUncheck = FALSE;
            dwErr = NO_ERROR;
            break;
        }

        // Otherwise, multilink makes sense.  Enable the multilink 
        // control and set its check according to what the system says
        bDisable = FALSE;
        bUncheck = FALSE;
        dwErr = miscGetMultilinkEnable(hMiscDatabase, &bFlag);
        if (dwErr != NO_ERROR) 
        {
            GenTabDisplayError(hwndDlg, ERR_DEVICE_DATABASE_CORRUPT);
            break;
        }
        
    } while (FALSE);

    // Cleanup
    {
        EnableWindow(hwndML, !bDisable);
        
        if (bUncheck)
        {
            SendMessage(
                hwndML, 
                BM_SETCHECK, 
                BST_UNCHECKED, 
                0);
        }
        else
        {
            SendMessage(
                hwndML, 
                BM_SETCHECK, 
                (bFlag) ? BST_CHECKED : BST_UNCHECKED, 
                0);
        }
    }

    return dwErr;
}

//
// Initializes the general tab.  By now a handle to the general 
// database has been placed in the user data of the dialog
//
DWORD 
GenTabInitializeDialog(
    IN HWND hwndDlg, 
    IN WPARAM wParam, 
    IN LPARAM lParam) 
{
    DWORD dwErr, dwCount;
    BOOL bFlag, bIsServer = FALSE;
    HANDLE hDevDatabase = NULL, hMiscDatabase = NULL;
    HWND hwndLV = GetDlgItem(hwndDlg, CID_GenTab_LV_Devices);;

    // Get handles to the databases we're interested in
    //
    RasSrvGetDatabaseHandle(
        hwndDlg, 
        ID_DEVICE_DATABASE, 
        &hDevDatabase);
        
    RasSrvGetDatabaseHandle(
        hwndDlg, 
        ID_MISC_DATABASE, 
        &hMiscDatabase);

    // Set the logging level
    //
    miscSetRasLogLevel(hMiscDatabase, MISCDB_RAS_LEVEL_ERR_AND_WARN);

    // Fill in the list view will all available devices
    //
    ListView_InstallChecks(hwndLV, Globals.hInstDll);
    GenTabFillDeviceList(hwndDlg, hwndLV, hDevDatabase);

    // Adjust the multilink control
    //
    miscGetProductType(hMiscDatabase, &bIsServer);
    if (bIsServer)
    {
        GenTabAdjustMultilinkAppearance(
            hwndDlg, 
            hDevDatabase, 
            hMiscDatabase);
    }
    else
    {
        ShowWindow(
            GetDlgItem(hwndDlg, CID_GenTab_CB_Multilink), 
            SW_HIDE);
    }

    // Initialize the vpn check
    //
    dwErr = devGetVpnEnable(hDevDatabase, &bFlag);
    if (dwErr != NO_ERROR) 
    {
        GenTabDisplayError(hwndDlg, ERR_DEVICE_DATABASE_CORRUPT);
        return dwErr;
    }
    
    SendMessage(
        GetDlgItem(hwndDlg,  CID_GenTab_CB_Vpn), 
        BM_SETCHECK,
        (bFlag) ? BST_CHECKED : BST_UNCHECKED,
        0);

    // Initialize the show icons check
    //
    dwErr = miscGetIconEnable(hMiscDatabase, &bFlag);
    if (dwErr != NO_ERROR) 
    {
        GenTabDisplayError(hwndDlg, ERR_DEVICE_DATABASE_CORRUPT);
        return dwErr;
    }
    
    SendMessage(
        GetDlgItem(hwndDlg, CID_GenTab_CB_ShowIcons), 
        BM_SETCHECK,
        (bFlag) ? BST_CHECKED : BST_UNCHECKED,
        0);

    //
    //for bug 154607 whistler, Enable/Disable Show Icon on taskbar 
    //check box according to Policy
    //
    {
        BOOL fShowStatistics = TRUE;
        HRESULT hr;
        INetConnectionUiUtilities * pNetConUtilities = NULL;        

        hr = HrCreateNetConnectionUtilities(&pNetConUtilities);
        if ( SUCCEEDED(hr))
        {
            fShowStatistics =
            INetConnectionUiUtilities_UserHasPermission(
                        pNetConUtilities, NCPERM_Statistics);

            EnableWindow( GetDlgItem(hwndDlg, CID_GenTab_CB_ShowIcons), fShowStatistics );
            INetConnectionUiUtilities_Release(pNetConUtilities);
        }
    }

    return NO_ERROR;
}

//
// Deals with changes in the check of a device
//
DWORD 
GenTabHandleDeviceCheck(
    IN HWND hwndDlg, 
    IN INT iItem) 
{
    HANDLE hDevDatabase = NULL, hMiscDatabase = NULL, hDevice = NULL;
    DWORD dwErr;

    RasSrvGetDatabaseHandle(hwndDlg, ID_DEVICE_DATABASE, &hDevDatabase);
    RasSrvGetDatabaseHandle(hwndDlg, ID_MISC_DATABASE, &hMiscDatabase);

    // Set the enabling of the given device
    dwErr = devGetDeviceHandle(hDevDatabase, (DWORD)iItem, &hDevice);
    if (dwErr == NO_ERROR)
    {
        // Set the device
        devSetDeviceEnable(
            hDevice, 
            ListView_GetCheck(GetDlgItem(hwndDlg, CID_GenTab_LV_Devices), 
            iItem));
        
        // Update the multilink check
        GenTabAdjustMultilinkAppearance(
            hwndDlg, 
            hDevDatabase, 
            hMiscDatabase);
    }
    
    return NO_ERROR;
}

//
// Go through the list view and get the device enablings and 
// commit them to the database.
//
DWORD 
GenTabCommitDeviceSettings(
    IN HWND hwndLV, 
    IN HANDLE hDevDatabase) 
{
    return NO_ERROR;
}

//
// Processes the activation of the general tab.  Return TRUE to 
// report that the message has been handled.
//
BOOL 
GenTabSetActive (
    IN HWND hwndDlg) 
{
    HANDLE hDevDatabase = NULL;
    DWORD dwErr, dwCount, dwId;

    PropSheet_SetWizButtons(GetParent(hwndDlg), 0);

    // Find out if we're the device page in the incoming wizard.
    dwErr = RasSrvGetPageId (hwndDlg, &dwId);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }
        
    if (dwId == RASSRVUI_DEVICE_WIZ_TAB) 
    {
        // Find out if there are any devices to show
        RasSrvGetDatabaseHandle(
            hwndDlg, 
            ID_DEVICE_DATABASE, 
            &hDevDatabase);
            
        dwErr = devGetDeviceCount (hDevDatabase, &dwCount);

        // If there are no devices or if there's a database problem,
        // don't allow this page to be activated.
        if ((dwErr != NO_ERROR) || (dwCount == 0))
        {
            SetWindowLongPtr (hwndDlg, DWLP_MSGRESULT, (LONG_PTR)-1);
        }
    }
    
    PropSheet_SetWizButtons(
        GetParent(hwndDlg), 
        PSWIZB_NEXT | PSWIZB_BACK);

    return TRUE;
}    

//
// Displays properties for the given device
//
DWORD 
GenTabRaiseProperties (
    IN HWND hwndDlg, 
    IN DWORD dwIndex) 
{
    HANDLE hDevDatabase = NULL, hDevice = NULL;
    DWORD dwId, dwErr;

    // Get the device id 
    RasSrvGetDatabaseHandle(
        hwndDlg, 
        ID_DEVICE_DATABASE, 
        &hDevDatabase);

    dwErr = devGetDeviceHandle(hDevDatabase, dwIndex, &hDevice);
    if (dwErr != NO_ERROR)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }
    
    if (devGetDeviceId(hDevice, &dwId) != NO_ERROR)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }
    
    // Launch the device properties dialog
    dwErr = lineConfigDialogW(dwId, hwndDlg, NULL);
    if (dwErr == LINEERR_OPERATIONUNAVAIL)
    {
        GenTabDisplayError(hwndDlg, ERR_DEVICE_HAS_NO_CONFIG);
        dwErr = NO_ERROR;
    }
    
    return dwErr;
}

//
// WM_COMMAND handler 
//
DWORD
GenTabCommand(
    IN HWND hwndDlg,
    IN WPARAM wParam)
{
    HANDLE hMiscDatabase = NULL, hDevDatabase = NULL;
    
    RasSrvGetDatabaseHandle(
        hwndDlg, 
        ID_MISC_DATABASE, 
        &hMiscDatabase);
        
    RasSrvGetDatabaseHandle(
        hwndDlg, 
        ID_DEVICE_DATABASE, 
        &hDevDatabase);

    switch (wParam) 
    {
        case CID_GenTab_CB_Multilink:
            miscSetMultilinkEnable(
                hMiscDatabase,
                (BOOL)SendDlgItemMessage(
                            hwndDlg,
                            CID_GenTab_CB_Multilink,
                            BM_GETCHECK,
                            0,
                            0));
            break;
            
        case  CID_GenTab_CB_Vpn:
            devSetVpnEnable(
                hDevDatabase,
                (BOOL)SendDlgItemMessage(
                        hwndDlg, 
                        CID_GenTab_CB_Vpn,
                        BM_GETCHECK,
                        0,
                        0));
            break;
            
        case CID_GenTab_CB_ShowIcons:
            miscSetIconEnable(
                hMiscDatabase,
                (BOOL)SendDlgItemMessage(
                        hwndDlg,
                        CID_GenTab_CB_ShowIcons,
                        BM_GETCHECK,
                        0,
                        0));
            break;
        case CID_GenTab_PB_Properties:
            GenTabRaiseProperties (
                hwndDlg, 
                ListView_GetSelectionMark(
                    GetDlgItem(hwndDlg, CID_GenTab_LV_Devices)));
            break;                                               
    }

    return NO_ERROR;
}

//
// This is the dialog procedure that responds to messages sent 
// to the general tab.
//
INT_PTR 
CALLBACK 
GenTabDialogProc(
    IN HWND hwndDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam) 
{
    // Filter the customized list view messages
    if (ListView_OwnerHandler(
            hwndDlg, 
            uMsg, 
            wParam, 
            lParam, 
            LvDrawInfoCallback )
        )
    {        
        return TRUE;
    }

    // Filter the customized ras server ui page messages. By 
    // filtering messages through here, we are able to call 
    // RasSrvGetDatabaseHandle below
    //
    if (RasSrvMessageFilter(hwndDlg, uMsg, wParam, lParam))
    {
        return TRUE;
    }

    // Process other messages as normal
    switch (uMsg) 
    {
        case WM_INITDIALOG:
            return FALSE;
            break;

        case WM_HELP:
        case WM_CONTEXTMENU:
            RasSrvHelp (hwndDlg, uMsg, wParam, lParam, phmGenTab);
            break;

        case WM_NOTIFY:
            {
                NM_LISTVIEW* pLvNotifyData;
                NMHDR* pNotifyData = (NMHDR*)lParam;
                switch (pNotifyData->code) {
                    //
                    // Note: PSN_APPLY and PSN_CANCEL are handled 
                    // by RasSrvMessageFilter
                    //
                    case PSN_SETACTIVE:
                        // Initailize the dialog if it isn't already
                        //
                        if (! GetWindowLongPtr(hwndDlg, GWLP_USERDATA))
                        {
                            GenTabInitializeDialog(hwndDlg, wParam, lParam);
                            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR)1);
                        }
                        if (GenTabSetActive (hwndDlg))
                            return TRUE;
                        break;

                    // The check of an item is changing
                    case LVXN_SETCHECK:
                        pLvNotifyData = (NM_LISTVIEW*)lParam;
                        GenTabHandleDeviceCheck(
                            hwndDlg, 
                            pLvNotifyData->iItem);
                        break;

                    case LVXN_DBLCLK:
                        pLvNotifyData = (NM_LISTVIEW*)lParam;
                        GenTabRaiseProperties(
                            hwndDlg, 
                            pLvNotifyData->iItem);
                        break;
                }
            }
            break;

        case WM_COMMAND:
            GenTabCommand(hwndDlg, wParam);
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\gentab.h ===
/*
    File    gentab.h

    Definitions needed to display the dialup server ui general tab.

    Paul Mayfield, 10/10/97
*/

#ifndef __gentab_h
#define __gentab_h

// Fills a LPPROPSHEETPAGE structure with the information
// needed to display the general tab. dwUserData is ignored.
DWORD GenTabGetPropertyPage(LPPROPSHEETPAGE lpPage, LPARAM lpUserData);    

// This dialog procedure responds to messages sent to the 
// general tab.
INT_PTR CALLBACK GenTabDialogProc(HWND hwndDlg,
                              UINT uMsg,
                              WPARAM wParam,
                              LPARAM lParam);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\hnportmapping.c ===
/*
    File    hnportmapping.c

    Definition of the set port mapping functions for intergrating incoming
    connection with personal firewall, for whistler bug#123769

    Gang Zhao 11/6/2000
*/

#include "rassrv.h"
#include "precomp.h"

//When Using CoSetProxyBlanket, we should set both the interface 
//and the IUnknown interface queried from it
HRESULT
HnPMSetProxyBlanket (
    IUnknown* pUnk)
{
    HRESULT hr;
    TRACE("HnPMSetProxyBlanket()");

    hr = CoSetProxyBlanket (
            pUnk,
            RPC_C_AUTHN_WINNT,      // use NT default security
            RPC_C_AUTHZ_NONE,       // use NT default authentication
            NULL,                   // must be null if default
            RPC_C_AUTHN_LEVEL_CALL, // call
            RPC_C_IMP_LEVEL_IMPERSONATE,
            NULL,                   // use process token
            EOAC_NONE);

    if(SUCCEEDED(hr)) 
    {
        IUnknown * pUnkSet = NULL;
        hr = IUnknown_QueryInterface(pUnk, &IID_IUnknown, (void**)&pUnkSet);
        if(SUCCEEDED(hr)) 
        {
            hr = CoSetProxyBlanket (
                    pUnkSet,
                    RPC_C_AUTHN_WINNT,      // use NT default security
                    RPC_C_AUTHZ_NONE,       // use NT default authentication
                    NULL,                   // must be null if default
                    RPC_C_AUTHN_LEVEL_CALL, // call
                    RPC_C_IMP_LEVEL_IMPERSONATE,
                    NULL,                   // use process token
                    EOAC_NONE);
			if (pUnkSet)
			{
            	IUnknown_Release(pUnk);
            }
        }
    }


    return hr;
}
//end of HnPMSetProxyBlanket()

//Initialize function to do COM initialization
//
DWORD
HnPMInit(
        IN OUT LPHNPMParams pInfo)
{        
    HRESULT hr;
    DWORD dwErr = NO_ERROR;

    TRACE("HnPMInit");
        if( !pInfo->fComInitialized )
        {
            hr = CoInitializeEx(NULL, COINIT_MULTITHREADED|COINIT_DISABLE_OLE1DDE);
            if ( RPC_E_CHANGED_MODE == hr )
            {
                hr = CoInitializeEx (NULL, 
                        COINIT_APARTMENTTHREADED |COINIT_DISABLE_OLE1DDE);
            }
            
            if (FAILED(hr)) 
            {
                TRACE1("HnPMCfgMgrInit: CoInitializeEx=%x", hr);
                pInfo->fCleanupOle = FALSE;
                pInfo->fComInitialized = FALSE;
                dwErr= HRESULT_CODE(hr);
             }
             else
             {
                pInfo->fCleanupOle = TRUE;
                pInfo->fComInitialized = TRUE;
             }
        }

        return dwErr;
}//HnPMInit()


//CleanUp function to UnInitialize Com
//If needed
//
DWORD
HnPMCleanUp(
        IN OUT LPHNPMParams pInfo)
{

    if (pInfo->fCleanupOle)
    {
        CoUninitialize();
        pInfo->fComInitialized = FALSE;
        pInfo->fCleanupOle = FALSE;
    }

    return NO_ERROR;

}//HnPMCleanUp()


//Parameter Validation for pHNetCfgMgr
//
DWORD
HnPMParamsInitParameterCheck(
    IN  LPHNPMParams pInfo)
{
    ASSERT(pInfo->pHNetCfgMgr);

    if( !pInfo->pHNetCfgMgr )
    {
        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}

//Function:
//Initialize some members of HNPMParams structure
//pSettings, pEnumPMP, Read Title for PPTP, L2TP, IKE
//from resource file
//
//Requirements:
//pHNetCfgMgr should be valid
//
HnPMParamsInit(
    IN OUT  LPHNPMParams pInfo)
{

    HRESULT hr;
    DWORD dwErr = NO_ERROR;

    dwErr = HnPMParamsInitParameterCheck(pInfo);
    if ( NO_ERROR != dwErr)
    {
        TRACE("HnPMParamsInit: HnPMParamsInitParameterCheck failed!");
        return dwErr;
    }

    do{
        hr = IHNetCfgMgr_QueryInterface(
                pInfo->pHNetCfgMgr,
                &IID_IHNetProtocolSettings,
                &pInfo->pSettings
                );

        if (!SUCCEEDED(hr) )
        {
            TRACE("HnPMParamsInit: IHNetCfgMgr_QueryInterface failed");
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }


        hr = IHNetProtocolSettings_EnumPortMappingProtocols(
                pInfo->pSettings,
                &pInfo->pEnumPMP
                );

        if ( !SUCCEEDED( hr ) )
        {
            TRACE("HnPMParamsInit: IHNetProtocolSettings_EnumPortMappingProotocols failed");

            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }


        //Get title, address information from resource
        //
        {
            TCHAR * pszTmp = NULL;

            pszTmp = PszFromId(Globals.hInstDll, SID_PPTP_Title);

            if(!pszTmp)
            {
                TRACE("HnPMParamsInit: Get PPTP_Title string failed!");
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }

            pInfo->pwszTitlePPTP = StrDupWFromT(pszTmp);
            Free0(pszTmp);

            if( !pInfo->pwszTitlePPTP )
            {
                TRACE("HnPMParamsInit: PPTP_Title string Conversion failed!");
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }

            pszTmp = PszFromId(Globals.hInstDll, SID_L2TP_Title);

            if(!pszTmp)
            {
                TRACE("HnPMParamsInit: Get L2TP_Title string failed!");
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }

            pInfo->pwszTitleL2TP = StrDupWFromT(pszTmp);
            Free0(pszTmp);

            if( !pInfo->pwszTitleL2TP )
            {
                TRACE("HnPMParamsInit: L2TP_Title string Conversion failed!");
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }

            pszTmp = PszFromId(Globals.hInstDll, SID_IKE_Title);

            if(!pszTmp)
            {
                TRACE("HnPMParamsInit: Get IKE_Title string failed!");
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }

            pInfo->pwszTitleIKE = StrDupWFromT(pszTmp);
            Free0(pszTmp);

            if( !pInfo->pwszTitleIKE )
            {
                TRACE("HnPMParamsInit: IKE_Title string Conversion failed!");
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }

            pInfo->pszLoopbackAddr = PszFromId(Globals.hInstDll, SID_LoopbackAddr);

            if(!pInfo->pszLoopbackAddr)
            {
                TRACE("HnPMParamsInit: Get IKE_Title string failed!");
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }
        }

    }while(FALSE);

    return dwErr;
}//HnPMParamsInit()

//Release pEnumPMP, pSettings
//Free memory for titles for PPTP, L2TP, IKE
//if allocated before
//
DWORD
HnPMParamsCleanUp(
    IN OUT  LPHNPMParams pInfo)
{
    if ( pInfo->pEnumPMP )
    {
        IEnumHNetPortMappingProtocols_Release( pInfo->pEnumPMP );
        pInfo->pEnumPMP = NULL;
    }

    if ( pInfo->pSettings ) 
    {
        IHNetProtocolSettings_Release( pInfo->pSettings );
        pInfo->pSettings = NULL;
    }


    if (pInfo->pwszTitlePPTP)
    {
        Free0(pInfo->pwszTitlePPTP);
        pInfo->pwszTitlePPTP = NULL;
    }

    if (pInfo->pwszTitleL2TP)
    {
        Free0(pInfo->pwszTitleL2TP);
        pInfo->pwszTitleL2TP = NULL;
    }

    if (pInfo->pwszTitleIKE)
    {
        Free0(pInfo->pwszTitleIKE);
        pInfo->pwszTitleIKE = NULL;
    }

    if (pInfo->pszLoopbackAddr)
    {
        Free0(pInfo->pszLoopbackAddr);
        pInfo->pszLoopbackAddr = NULL;
    }

    return NO_ERROR;
} //HnPMParamsCleanUp()


//Initialization function before Enumerate all connections of
// type (INetConnection * )
//
//Init connection manager ConnMan,
//Init Connection Enumerator EnumCon
//
DWORD
HnPMConnectionEnumInit(
    IN LPHNPMParams pInfo)
{
    DWORD dwErr = NO_ERROR;
    HRESULT hr;

    TRACE("HnPMConnectionEnumInit");
    do{
        //Do Com Initialization
        //
        dwErr = HnPMInit(pInfo);

        if ( NO_ERROR != dwErr )
        {
            TRACE("HnPMConnectionEnumInit: HnPMCfgMgrInit failed!");
            break;
        }
            
        // Instantiate the connection manager
        //

        hr = CoCreateInstance(
                &CLSID_ConnectionManager,
                NULL,
                CLSCTX_SERVER,
                &IID_INetConnectionManager,
                (PVOID*)&pInfo->ConnMan
                );
     
        if (!SUCCEEDED(hr)) 
        {
            TRACE1("HnPMConnectionEnumInit: CoCreateInstance=%x", hr);
            pInfo->ConnMan = NULL; 
            dwErr = ERROR_CAN_NOT_COMPLETE; 
            break;
        }

        hr = HnPMSetProxyBlanket( (IUnknown*)pInfo->ConnMan );

        if (!SUCCEEDED(hr) && ( E_NOINTERFACE != hr )) 
        {
            TRACE1("HnPMConnectionEnumInit: HnPMSetProxyBlanket=%x for ConnMan", hr);
//            dwErr = ERROR_CAN_NOT_COMPLETE; 
//            break;
        }

        //
        // Instantiate a connection-enumerator
        //

        hr =
            INetConnectionManager_EnumConnections(
                pInfo->ConnMan,
                NCME_DEFAULT,
                &pInfo->EnumCon
                );

        if (!SUCCEEDED(hr)) 
        {
            TRACE1("HnPMConnectionEnumInit: EnumConnections=%x", hr);
            pInfo->EnumCon = NULL; 
            dwErr = ERROR_CAN_NOT_COMPLETE; 
            break;
        }


        hr = HnPMSetProxyBlanket( (IUnknown*)pInfo->EnumCon );

        if (!SUCCEEDED(hr) && ( E_NOINTERFACE != hr ) ) 
        {
            TRACE1("HnPMConnectionEnumInit: HnPMSetProxyBlanket=%x for EnumCon", hr);
         //   dwErr = ERROR_CAN_NOT_COMPLETE; 
         //   break;
        }
     }
     while(FALSE);

     return dwErr;
} //HnPMConnectionEnumInit()

//Connection Enumeration CleanUp
//Release EnumCon, and ConnMan
DWORD
HnPMConnectionEnumCleanUp(
    IN LPHNPMParams pInfo)
{
    TRACE("HnPMConnectionEnumCleanUp");
    if (pInfo->EnumCon) 
    { 
        IEnumNetConnection_Release(pInfo->EnumCon);
        pInfo->EnumCon = NULL;
    }

    if (pInfo->ConnMan) 
    { 
        INetConnectionManager_Release(pInfo->ConnMan); 
        pInfo->ConnMan = NULL;
    }

    HnPMCleanUp(pInfo);

    return NO_ERROR;
}


//Connection Enumeration function:
//Its Initialize function will do: 
//          COM initialized if needed
//          Init Connection Manager-- ConnMan
//          Init Connection Enumerator--EnumCon
//
//It returns: Array of connections found--ConnArray
//            Array of connection properties--ConnPropTable

//Its CleanUp function will do: 
//          COM un-initialize if needed
//          Release ConnMan
//          Release EnumCon
//                              
DWORD
HnPMConnectionEnum(
    IN LPHNPMParams pInfo)
{
    INetConnection *     ConnArray[32];
    INetConnection **    LocalConnArray = NULL;
    NETCON_PROPERTIES *  LocalConnPropTable = NULL;
    NETCON_PROPERTIES *  ConnProps = NULL;
    ULONG   LocalConnCount = 0, PerConnCount, i;
    DWORD   dwErr= NO_ERROR;
    HRESULT hr;

    TRACE("HnPMConnectionEnum() begins");

    i = 0;
    do {
        dwErr = HnPMConnectionEnumInit(pInfo);
        if ( NO_ERROR != dwErr )
        {
            TRACE("HnPMConnectionEnum: HnPMConnectionEnumInit failed!");
            break;
        }

        // Enumerate the connections of INetConnection type
        //
        for ( ; ; ) 
        {
            hr = IEnumNetConnection_Next(
                    pInfo->EnumCon,
                    Dimension(ConnArray),
                    ConnArray,
                    &PerConnCount
                    );

            if (!SUCCEEDED(hr) || !PerConnCount) 
            { 
                hr = S_OK; 
                break; 
            }
            // Allocate or reallocate the memory for storing
            // connections properties which we will return to the caller.
            //

            TRACE("Allocating memory for LocalConnPropTable");
            if (!LocalConnPropTable) 
            {
                LocalConnPropTable =
                    (NETCON_PROPERTIES*)
                        GlobalAlloc(
                            0,
                            PerConnCount * sizeof(NETCON_PROPERTIES)
                            );
            } 
            else 
            {
                PVOID Temp =
                    GlobalAlloc(
                        0,
                        (LocalConnCount + PerConnCount) * sizeof(NETCON_PROPERTIES) );

                if (Temp) 
                {
                    CopyMemory(
                        Temp,
                        LocalConnPropTable,
                        LocalConnCount * sizeof(NETCON_PROPERTIES));
                }

                GlobalFree(LocalConnPropTable);
                LocalConnPropTable = Temp;
            }

            // Allocate or reallocate the memory for storing
            // connections which we will return to the caller.
            //

            TRACE("Allocating memory for LocalConnArray");
            if (!LocalConnArray ) 
            {
                LocalConnArray = 
                (INetConnection**) GlobalAlloc( 0,
                            PerConnCount * sizeof(INetConnection *) );
            } 
            else 
            {
               INetConnection** Temp = 
                 (INetConnection**) GlobalAlloc( 0,
                             (LocalConnCount + PerConnCount) * 
                                sizeof(INetConnection *));

                if (Temp) 
                {
                    CopyMemory(
                        Temp,
                        LocalConnArray,
                        LocalConnCount * sizeof(INetConnection *) );
                }

                GlobalFree(LocalConnArray);
                LocalConnArray = Temp;
            }

            if (!LocalConnPropTable) 
            { 
                TRACE("No memory for LocalConnPropTable");
                dwErr = ERROR_NOT_ENOUGH_MEMORY; 
                break; 
            }

            if (!LocalConnArray) 
            { 
                TRACE("No memeory for LocalConnArray");
                dwErr = ERROR_NOT_ENOUGH_MEMORY; 
                break; 
            }

            TRACE1("HnPMConnectionEnum: PerConnCount=(%d)",PerConnCount);
            for (i=0; i< PerConnCount; i++)
            {
                LocalConnArray[LocalConnCount+i] = ConnArray[i];

                //Need to set up the proxy blanket for each conneciton
                //
                TRACE1("SetProxyBlanket for (%d) i", i);
                hr = HnPMSetProxyBlanket( (IUnknown*)ConnArray[i] );
                
                if (!SUCCEEDED(hr) && ( E_NOINTERFACE != hr ) ) 
                {
                    TRACE1("HnPMConnectionEnum:HnPMSetProxyBlanket error at (%d) connection!", i );
                    //Commented out for whistler bug 256921
                    //dwErr = ERROR_CAN_NOT_COMPLETE;
                    //break;
                }
                
                TRACE1("GetProperty for (%d)",i);

                hr = INetConnection_GetProperties(ConnArray[i], &ConnProps);

                ASSERT(ConnProps);
                if(!SUCCEEDED(hr))
                {
                    TRACE1("HnPMConnectionEnum:INetConnection_GetProperties error at (%d) connection!", i );
                    dwErr = ERROR_CAN_NOT_COMPLETE;
                    break;
                }

                LocalConnPropTable[LocalConnCount+i] = *ConnProps;
                LocalConnPropTable[LocalConnCount+i].pszwName = 
                                        StrDup(ConnProps->pszwName);

                LocalConnPropTable[LocalConnCount+i].pszwDeviceName =
                                        StrDup(ConnProps->pszwDeviceName);
                CoTaskMemFree(ConnProps);
                ConnProps = NULL;
            }

            if( dwErr )
            {
                break;
            }

            LocalConnCount += PerConnCount;

        } // end Enumerate items

        //
        //Add this line just in case we will add more code in the future
        //and to break out of the do...while block
        //
        if ( dwErr )
        {
           GlobalFree(LocalConnArray);
           GlobalFree(LocalConnPropTable);
           break;
        }

    } while (FALSE);

    //Save connection Info
    if ( NO_ERROR == dwErr )
    {
        pInfo->ConnPropTable = LocalConnPropTable; 
        pInfo->ConnArray = LocalConnArray; 
        pInfo->ConnCount = LocalConnCount; 
    }


    HnPMConnectionEnumCleanUp(pInfo);

    TRACE("HnPMConnectionEnum ends");
    return dwErr;

}//end of HnPMConnectionEnum()

//Input parameter check for HnPMPickProtocol
//Requirement: 
//          All the protocol titles are valid
//
DWORD
HnPMPickProtcolParameterCheck(
    IN LPHNPMParams pInfo)
{
    ASSERT( pInfo->pwszTitlePPTP );
    ASSERT( pInfo->pwszTitleL2TP );
    ASSERT( pInfo->pwszTitleIKE );

    if ( !pInfo->pwszTitlePPTP ||
         !pInfo->pwszTitleL2TP ||
         !pInfo->pwszTitleIKE )
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    return NO_ERROR;
}


//Pick the PortMapping Protocols needed from all
//the PortMapping Protocols founded by HnPMProtocolEnum()
//
//Criteria: Match the---
//                  Protocol title
//                  IPProtocol values: TCP 6, UDP 17
//                  Transport Layer Port number: PPTP--1723
//                                               L2TP--1701
//                                               IKE---500
//
DWORD
HnPMPickProtocol(
    IN OUT LPHNPMParams pInfo,
    IN IHNetPortMappingProtocol * pProtocolTemp,
    IN WCHAR * pszwName,
    IN UCHAR   uchIPProtocol,
    IN USHORT  usPort )
{
    DWORD dwErr = NO_ERROR;
    
    dwErr = HnPMPickProtcolParameterCheck(pInfo);
    if ( NO_ERROR != dwErr )
    {
        TRACE("HnPMPickProtocol: HnPMPickProtcolParameterCheck failed!");
        return dwErr;
    }

    dwErr = ERROR_CONTINUE;

    if ( !pInfo->pProtocolPPTP &&
         NAT_PROTOCOL_TCP == uchIPProtocol   && 
         !lstrcmpW( pszwName, pInfo->pwszTitlePPTP ) &&
         1723 == usPort )
    {
        pInfo->pProtocolPPTP = pProtocolTemp;
        IHNetPortMappingProtocol_AddRef(pInfo->pProtocolPPTP);
        dwErr = ERROR_CONTINUE;
    }
    else if ( !pInfo->pProtocolL2TP &&
         NAT_PROTOCOL_UDP == uchIPProtocol   && 
         !lstrcmpW( pszwName, pInfo->pwszTitleL2TP ) &&
         1701 == usPort )
    {
        pInfo->pProtocolL2TP = pProtocolTemp;
        IHNetPortMappingProtocol_AddRef(pInfo->pProtocolL2TP);
        dwErr = ERROR_CONTINUE;
    }
    else if ( !pInfo->pProtocolIKE &&
         NAT_PROTOCOL_UDP == uchIPProtocol   && 
         !lstrcmpW( pszwName, pInfo->pwszTitleIKE ) &&
         500 == usPort )
    {
        pInfo->pProtocolIKE = pProtocolTemp;
        IHNetPortMappingProtocol_AddRef(pInfo->pProtocolIKE);
        dwErr = ERROR_CONTINUE;
    }

    if ( pInfo->pProtocolPPTP && 
         pInfo->pProtocolL2TP && 
         pInfo->pProtocolIKE )
    {
        dwErr = NO_ERROR;
    }

    return dwErr;

}//HnPMPickProtocol()


//Parameter check for HnPMPProtocolEnum()
//
DWORD
HnPMPProtoclEnumParameterCheck(
    IN LPHNPMParams pInfo)
{
    ASSERT(pInfo->pEnumPMP);
    if( !pInfo->pEnumPMP )
    {
        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}

//Function:
//          (1) Enumerate all existing PortMappingProtocol
//          (2) then use the CallBack function or the defaulet HnPMPickProtocol
//              to pick suitable protocols
//              
//Requrement:
//           pInfo->pEnumPMP is valid
//
DWORD
HnPMProtocolEnum(
        IN OUT LPHNPMParams pInfo,
        IN PFNHNPMPICKPROTOCOL pfnPickProtocolCallBack
        )
{
    IHNetPortMappingProtocol *pProtocolTemp = NULL;
    ULONG PerProtocolCount;
    DWORD dwErr = NO_ERROR;
    HRESULT hr;
    UCHAR uchIPProtocol;
    USHORT usPort;
    WCHAR * pszwName = NULL;


    dwErr = HnPMPProtoclEnumParameterCheck(pInfo);
    if( NO_ERROR != dwErr )
    {
        TRACE("HnPMPProtocolEnum: HnPMPProtoclEnumParameterCheck failed!");
        return dwErr;
    }

    dwErr = ERROR_CONTINUE;
    do {
        hr = IEnumHNetPortMappingProtocols_Next(
                pInfo->pEnumPMP,
                1,
                &pProtocolTemp,
                &PerProtocolCount
                );

        if ( !SUCCEEDED(hr) || 1 != PerProtocolCount ) 
        { 
            TRACE("HnPMPProtocolEnum: EnumHNetPortMappingProtocols_Next failed");

            hr = S_OK; 
            break; 
         }

        hr = IHNetPortMappingProtocol_GetIPProtocol(
                pProtocolTemp,
                &uchIPProtocol
                );

        if (SUCCEEDED(hr) )
        {
            hr = IHNetPortMappingProtocol_GetPort(
                    pProtocolTemp,
                    &usPort
                    );
        }

        if ( SUCCEEDED(hr) )
        {
            hr = IHNetPortMappingProtocol_GetName(
                    pProtocolTemp,
                    &pszwName
                    );
        }

        if ( SUCCEEDED(hr) )
        {
          if(pfnPickProtocolCallBack)
          {
              dwErr = pfnPickProtocolCallBack(
                                       pInfo, 
                                       pProtocolTemp, 
                                       pszwName, 
                                       uchIPProtocol, 
                                       ntohs(usPort) );
          }
          else
          {
              dwErr = HnPMPickProtocol(
                                       pInfo, 
                                       pProtocolTemp, 
                                       pszwName, 
                                       uchIPProtocol, 
                                       ntohs(usPort) );

          }
        }

        if ( pszwName )
        {
            Free(pszwName);
            pszwName = NULL;
        }

        IHNetPortMappingProtocol_Release(pProtocolTemp);

        if ( NO_ERROR == dwErr )
        {
              break;
        }

    }while(TRUE);

    return dwErr;
}//HnPMProtocolEnum()


DWORD
HnPMCreatePorotocolParameterCheck(
        IN LPHNPMParams pInfo)
{

    ASSERT( pInfo->pSettings );
    ASSERT( pInfo->pwszTitlePPTP );
    ASSERT( pInfo->pwszTitleL2TP );
    ASSERT( pInfo->pwszTitleIKE );

    if ( !pInfo->pSettings ||
         !pInfo->pwszTitlePPTP ||
         !pInfo->pwszTitleL2TP ||
         !pInfo->pwszTitleIKE )
    {
        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}


//Create PortMapping Protocols
//Function:
//      If one or more of PPTP, L2TP and IKE PortMapping protocols are not existing
//      create the missing ones.
//
//Requirement: 
//      pSettings is valid
//      All the portmapping protocol titles are valid
//
DWORD
HnPMCreateProtocol(
        IN OUT LPHNPMParams pInfo)
{
    DWORD dwErr=NO_ERROR;
    HRESULT hr;

    dwErr = HnPMCreatePorotocolParameterCheck(pInfo);

    if( NO_ERROR != dwErr )
    {
        TRACE("HnPMCreateProtocol: HnPMCreatePorotocolParameterCheck failed!");
        return dwErr;
    }

    do {
        if ( !pInfo->pProtocolPPTP )
        {
            //
            //Do port Mapping for PPTP
            //Get PortMapping protocol
            //the tile should be with WCHAR or OLECHAR type
            //any numerical values are in network byte order
            //and the type of port is USHORT, so I use htons
            //here
            //
            hr = IHNetProtocolSettings_CreatePortMappingProtocol(
                        pInfo->pSettings,
                        pInfo->pwszTitlePPTP,
                        NAT_PROTOCOL_TCP,
                        htons(1723),
                        &pInfo->pProtocolPPTP
                        );

            //If the protocol has already been defined, the CreatePortMapping
            //above will fail and returns ERROR_OBJECT_ALREADY_EXISTS
            //
            if ( ERROR_OBJECT_ALREADY_EXISTS == hr )
            {
                TRACE("HnPMCreateProtocol: The PortMapping for PPTP is already defined");
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }

            if (!SUCCEEDED(hr) )
            {
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }
        }// end of assigning PPTP protocol
    
        //Create a new PortMappingProtocol for L2TP
        if ( !pInfo->pProtocolL2TP)
        {
            //
            //Do port Mapping for L2TP
            //Get PortMapping protocol
            //the tile should be with WCHAR or OLECHAR type
            //any numerical values are in network byte order
            //and the type of port is USHORT, so I use htons
            //here
            //
            hr = IHNetProtocolSettings_CreatePortMappingProtocol(
                        pInfo->pSettings,
                        pInfo->pwszTitleL2TP,
                        NAT_PROTOCOL_UDP,
                        htons(1701),
                        &pInfo->pProtocolL2TP
                        );

            //If the protocol has already been defined, the CreatePortMapping
            //above will fail and returns ERROR_OBJECT_ALREADY_EXISTS
            //
            if ( ERROR_OBJECT_ALREADY_EXISTS == hr )
            {
                TRACE("HnPMCreateProtocol: The PortMapping for L2TP is already defined!");
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }

            if (!SUCCEEDED(hr) )
            {
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }
        }// end of assigning L2TP protocol
    
        //Create a new PortMappingProtocol for IKE
        if ( !pInfo->pProtocolIKE )
        {
            //
            //Do port Mapping for IKE
            //Get PortMapping protocol
            //the tile should be with WCHAR or OLECHAR type
            //any numerical values are in network byte order
            //and the type of port is USHORT, so I use htons
            //here
            //
            hr = IHNetProtocolSettings_CreatePortMappingProtocol(
                        pInfo->pSettings,
                        pInfo->pwszTitleIKE,
                        NAT_PROTOCOL_UDP,
                        htons(500),
                        &pInfo->pProtocolIKE
                        );

            //If the protocol has already been defined, the CreatePortMapping
            //above will fail and returns ERROR_OBJECT_ALREADY_EXISTS
            //
            if ( ERROR_OBJECT_ALREADY_EXISTS == hr )
            {
                TRACE("HnPMCreateProtocol: The PortMapping for IKE is already defined!");
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }

            if (!SUCCEEDED(hr) )
            {
                dwErr = ERROR_CAN_NOT_COMPLETE;
                break;
            }
        }// end of assigning IKE protocol

    }while (FALSE);

    return dwErr;

} //HnPMCreateProtocol()


//Function: Enable/Disable a single portmapping Protocol  on a Single
//          Connection of type IHNetConnection
//
DWORD
HnPMSetSinglePMForSingleConnection(
    IN  IHNetConnection * pHNetConn,
    IN  IHNetPortMappingProtocol * pProtocol,
    IN  TCHAR * pszLoopbackAddr,
    IN  BOOL fEnabled)
{
    IHNetPortMappingBinding * pBinding = NULL;
    HRESULT hr;
    DWORD dwErr = NO_ERROR;
    ULONG ulAddress = INADDR_NONE;

    do {
        hr = IHNetConnection_GetBindingForPortMappingProtocol(
                    pHNetConn,
                    pProtocol,
                    &pBinding
                    );

        if (!SUCCEEDED(hr) )
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        ulAddress = IpPszToHostAddr( pszLoopbackAddr ); 

        hr = IHNetPortMappingBinding_SetTargetComputerAddress(
                    pBinding,
                    htonl(ulAddress)
                    );

        if (!SUCCEEDED(hr) )
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        hr = IHNetPortMappingBinding_SetEnabled(
                    pBinding,
                    !!fEnabled
                    );

        if (!SUCCEEDED(hr) )
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

    } while(FALSE);

    if (pBinding)
    {
        IHNetPortMappingBinding_Release(pBinding);
    }

    return dwErr;
} //HnPMSetSinglePMForSingleConnection()


DWORD
HnPMConfigureAllPMForSingleConnectionParameterCheck(
        IN OUT LPHNPMParams pInfo)
{
    ASSERT( pInfo->pHNetConn );
    ASSERT( pInfo->pProtocolPPTP );
    ASSERT( pInfo->pProtocolL2TP );
    ASSERT( pInfo->pProtocolIKE );
    ASSERT( pInfo->pszLoopbackAddr );

    if ( !pInfo->pHNetConn ||
         !pInfo->pProtocolPPTP ||
         !pInfo->pProtocolL2TP ||
         !pInfo->pszLoopbackAddr )
    {
        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}

//Function:
//      Enable/Disable all the PortMapping protocols inside pInfo 
//      (currently PPTP, L2TP, IKE)  on a single connection
//
//Requirement:
//      pHNetConn is valid
//      All the portmapping protocols inside pInfo are valid
//
DWORD
HnPMConfigureAllPMForSingleConnection(
        IN OUT LPHNPMParams pInfo,
        BOOL fEnabled)
{
    DWORD dwErr = NO_ERROR;

    dwErr = HnPMConfigureAllPMForSingleConnectionParameterCheck(pInfo);
    if( NO_ERROR != dwErr )
    {
        TRACE("HnPMConfigureAllPMForSingleConnection: parameter check failed!");
        return dwErr;
    }

    do{
        dwErr = HnPMSetSinglePMForSingleConnection(
                           pInfo->pHNetConn,
                           pInfo->pProtocolPPTP,
                           pInfo->pszLoopbackAddr,
                           fEnabled);

        if( NO_ERROR != dwErr )
        {
            TRACE("HnPMConfigureAllPMForSingleConnection: PortMapping failed for PPTP!");
            break;
        }

        dwErr = HnPMSetSinglePMForSingleConnection(
                           pInfo->pHNetConn,
                           pInfo->pProtocolL2TP,
                           pInfo->pszLoopbackAddr,
                           fEnabled);

        if( NO_ERROR != dwErr )
        {
            TRACE("HnPMConfigureAllPMForSingleConnection: PortMapping failed for L2TP!");
            break;
        }

        dwErr = HnPMSetSinglePMForSingleConnection(
                           pInfo->pHNetConn,
                           pInfo->pProtocolIKE,
                           pInfo->pszLoopbackAddr,
                           fEnabled);

        if( NO_ERROR != dwErr )
        {
            TRACE("HnPMConfigureAllPMForSingleConnection: PortMapping failed for IKE!");
            break;
        }

    } while(FALSE);

    return dwErr;
} //HnPMConfigureAllPMForSingleConnection()


//Make sure:
//      pHNetCfgMgr is valid
//      one and only one of pNetConnection and pGuid is valid
//
DWORD
HnPMConfigureSingleConnectionInitParameterCheck(
    IN LPHNPMParams pInfo )
{
    ASSERT( pInfo->pHNetCfgMgr );
    ASSERT( pInfo->pNetConnection || pInfo->pGuid );

    if ( !pInfo->pHNetCfgMgr || 
         ( !pInfo->pNetConnection && !pInfo->pGuid ) ||
         ( pInfo->pNetConnection && pInfo->pGuid ) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    return NO_ERROR;
}//HnPMConfigureSingleConnectionInitParameterCheck()


// (1) Call Parameter checking function
//          pHNetCfgMgr is valid
//          one and only one of pNetConnection and pGuid is valid
//
// (2) init pHNetConn by converting from pNetConnection or pGuid
//
// (3) call HnPMParamsInit()
//          Initialize some members of HNPMParams structure
//          pSettings, pEnumPMP, Read Title for PPTP, L2TP, IKE
//          from resource file
//
DWORD
HnPMConfigureSingleConnectionInit(
    IN OUT  LPHNPMParams pInfo)
{
    
    DWORD dwErr = NO_ERROR;
    HRESULT hr;

    dwErr = HnPMConfigureSingleConnectionInitParameterCheck(pInfo);
    if ( NO_ERROR != dwErr )
    {
        return  dwErr;
    }

    do {
        if ( pInfo->pNetConnection )
            {
                hr = IHNetCfgMgr_GetIHNetConnectionForINetConnection(
                                pInfo->pHNetCfgMgr,
                                pInfo->pNetConnection,
                                &pInfo->pHNetConn
                                );

                if (!SUCCEEDED(hr) )
                {
                    TRACE("HnPMConfigureSingleConnection: GetIHNetConnectionForINetConnection failed");
                    dwErr = ERROR_CAN_NOT_COMPLETE;
                    break;
                }
            }
            else
            {
                hr = IHNetCfgMgr_GetIHNetConnectionForGuid(
                                            pInfo->pHNetCfgMgr,
                                            pInfo->pGuid,
                                            FALSE,//This is not for Lan Connection
                                            TRUE, //This should always be TRUE
                                            &pInfo->pHNetConn
                                            );

                            if (!SUCCEEDED(hr) )
                            {
                                TRACE("HnPMConfigureSingleConnection: GetIHNetConnectionForGuid failed");
                                dwErr = ERROR_CAN_NOT_COMPLETE;
                                break;
                            }

              }

              dwErr = HnPMParamsInit(pInfo);

        }while(FALSE);

    return dwErr;
} //HnPMConfigureSingleConnectionInit()

// (1) Release all PortMapping Protocols
// (2) release the connection just configured
// (3) call HnPMParamsCleanUp()
//          Release pEnumPMP, pSettings
//          Free memory for titles for PPTP, L2TP, IKE if allocated before
//

DWORD
HnPMConfigureSingleConnectionCleanUp(
        IN OUT LPHNPMParams pInfo)
{

    if ( pInfo->pProtocolPPTP ) 
    {
        IHNetPortMappingProtocol_Release( pInfo->pProtocolPPTP );
        pInfo->pProtocolPPTP = NULL;
    }

    if ( pInfo->pProtocolL2TP ) 
    {
       IHNetPortMappingProtocol_Release( pInfo->pProtocolL2TP ); 
       pInfo->pProtocolL2TP = NULL;
    }

    if ( pInfo->pHNetConn ) 
    {
        IHNetConnection_Release( pInfo->pHNetConn );
        pInfo->pHNetConn = NULL;
    }

    if ( pInfo->pProtocolIKE ) 
    {
        IHNetPortMappingProtocol_Release( pInfo->pProtocolIKE ); 
        pInfo->pProtocolIKE = NULL;
    }

    HnPMParamsCleanUp(pInfo);

    return NO_ERROR;
}//HnPMConfigureSingleConnectionCleanUp

//Function:
//      Enable/Disable PortMappping(PPTP, L2TP, IKE) on a single connection
//Step:
//  (1) Initialization
//  (2) Enumerate all existing portmapping protocols
//  (3) Pick PPTP, L2TP, IKE from them
//  (4) If not all of them exist, Create the missing ones
//  (5) Configure each protocol on this connection
//
DWORD
HnPMConfigureSingleConnection(
        IN OUT LPHNPMParams pInfo,
        BOOL fEnabled)
{
    DWORD dwErr = NO_ERROR;

    do{
        //Init the value needed in this function
        //
        dwErr = HnPMConfigureSingleConnectionInit(pInfo);

        if( NO_ERROR != dwErr )
        {
            TRACE("HnPMConfigureSingleConnection: Init failed!");
            break;
        }

        //Enumerate all PortMapping Protocls and 
        //pick the PPTP, L2TP, IKE from them
        //
         dwErr = HnPMProtocolEnum(pInfo, HnPMPickProtocol);

        //Create a new PortMappingProtocol for PPTP
        //if didnt find the PPTP protocl and it is to
        //Enable it
        //

        if ( NO_ERROR != dwErr )
        {
            dwErr = HnPMCreateProtocol(pInfo);
        }

        if ( NO_ERROR != dwErr )
        {
            TRACE("HnPMConfigureSingleConnection: HnPMCreateProtocol failed!");
            break;
        }

        dwErr = HnPMConfigureAllPMForSingleConnection(pInfo, fEnabled);
        if ( NO_ERROR != dwErr )
        {
            TRACE("HnPMConfigureSingleConnection: HnPMConfigureAllPMForSingleConnection failed!");
            break;
        }

    }
    while( FALSE );

    //clean up the structure changed in this function
    //
    HnPMConfigureSingleConnectionCleanUp(pInfo);

    return dwErr;
} //HnPMConfigureSingleConnection()

DWORD
HnPMDeletePortMappingInit(
        IN OUT LPHNPMParams pInfo)
{
    HRESULT hr;
    DWORD dwErr = NO_ERROR;

    do{
        dwErr = HnPMCfgMgrInit(pInfo);
        if ( NO_ERROR != dwErr )
        {
            TRACE("HnPMDeletePortMappingInit: HnPMCfgMgrInit failed!");
            break;
        }

        dwErr = HnPMParamsInit(pInfo);

    }while(FALSE);

    return dwErr;
} //HnPMDeletePortMappingInit()

DWORD
HnPMDeletePortMappingCleanUp(
        IN OUT LPHNPMParams pInfo)
{
    HnPMParamsCleanUp(pInfo);

    HnPMCfgMgrCleanUp(pInfo);

    return NO_ERROR;
}

//Function:
//      Delete the PortMapping Protocols (PPTP, L2TP, IKE)
//Step:
//  (1)Initialization:
//          Get all the protocol names, IP protocol number, 
//          Transport Layer port number (PPTP: TCP/1723
//          L2TP:UDP/1701, IKE (UDP:500)
//  (2)Enumerate all existing portmapping protocols
//  (3) Pick the protocols to delete and store them in pInfo
//  (4) delete protocols
//
DWORD
HnPMDeletePortMapping()
{
    HNPMParams Info;
    LPHNPMParams pInfo;
    DWORD dwErr;
    HRESULT hr;

    dwErr = NO_ERROR;

    ZeroMemory(&Info, sizeof(Info) );
    pInfo = &Info;

    do{
        dwErr = HnPMDeletePortMappingInit(pInfo);
        if (NO_ERROR != dwErr)
        {
            TRACE("HnPMDeletePortMapping: HnPMDeletePortMappingInit failed!");
            break;
        }

        //Enumerate all PortMapping Protocls and 
        //pick the PPTP, L2TP, IKE from them
        //
        dwErr = HnPMProtocolEnum(pInfo, HnPMPickProtocol);
        if (NO_ERROR != dwErr)
        {
            TRACE("HnPMDeletePortMapping: HnPMProtocolEnum failed!");
            break;
        }

        //Delete All Port Mapping protocols
        if ( pInfo->pProtocolPPTP ) 
        {
            hr = IHNetPortMappingProtocol_Delete( pInfo->pProtocolPPTP );
            pInfo->pProtocolPPTP = NULL;
            ASSERT(SUCCEEDED(hr));
            if (!SUCCEEDED(hr))
            {
                TRACE1("HnPMDeletePortMapping: delete PPTP portmaping failed = %x!", hr);
            }
        }

        if ( pInfo->pProtocolL2TP ) 
        {
           hr = IHNetPortMappingProtocol_Delete( pInfo->pProtocolL2TP ); 
           pInfo->pProtocolL2TP = NULL;
           ASSERT(SUCCEEDED(hr));
            if (!SUCCEEDED(hr))
            {
                TRACE1("HnPMDeletePortMapping: delete L2TP portmaping failed = %x!", hr);
            }
        }

        if ( pInfo->pProtocolIKE ) 
        {
            hr = IHNetPortMappingProtocol_Delete( pInfo->pProtocolIKE ); 
            pInfo->pProtocolIKE = NULL;
            ASSERT(SUCCEEDED(hr));
            if (!SUCCEEDED(hr))
            {
                TRACE1("HnPMDeletePortMapping: delete IKE portmaping failed = %x!", hr);
            }
        }

    }while(FALSE);

    HnPMDeletePortMappingCleanUp(pInfo);

    return dwErr;
}//DeletePortMapping()

DWORD
HnPMConfigureAllConnectionsInit(
        IN OUT LPHNPMParams pInfo)
{
    DWORD dwErr = NO_ERROR;

    dwErr = HnPMCfgMgrInit(pInfo);
        
    return NO_ERROR;
}

DWORD
HnPMParamsConnectionCleanUp(
        IN OUT LPHNPMParams pInfo)
{
    DWORD i;

    if ( pInfo->ConnArray )
    {
        for ( i = 0; i < pInfo->ConnCount; i++ )
        {
            INetConnection_Release(pInfo->ConnArray[i]);
        }

        GlobalFree( pInfo->ConnArray );
        pInfo->ConnArray = NULL;
    }

    if ( pInfo->ConnPropTable )
    {
        for ( i = 0; i < pInfo->ConnCount; i++ )
        {
           Free0(pInfo->ConnPropTable[i].pszwName);
           pInfo->ConnPropTable[i].pszwName = NULL;
           Free0(pInfo->ConnPropTable[i].pszwDeviceName);
           pInfo->ConnPropTable[i].pszwDeviceName = NULL;
        }

        GlobalFree( pInfo->ConnPropTable );
        pInfo->ConnPropTable = NULL;
        pInfo->ConnCount = 0;
    }

    return NO_ERROR;
}//HnPMParamsConnectionCleanUp()


DWORD
HnPMConfigureAllConnectionsCleanUp(
        IN OUT LPHNPMParams pInfo)
{
    HnPMParamsConnectionCleanUp(pInfo);

    HnPMCfgMgrCleanUp(pInfo);

    return NO_ERROR;
}


//  Enable/Disable portmapping on all connections except incoming connection
//  PortMapping protocols: PPTP, L2TP, IKE
//  If there are no such protocols, create them first
//  Steps:
//      (1) Initialization
//      (2) Enumerate all connections of type INetConnection *
//      (3) If it is not an incomming connection set the portmapping protocols
//              on it.

DWORD
HnPMConfigureAllConnections( 
    IN BOOL fEnabled )
{
    DWORD  dwErr = NO_ERROR, i;
    HNPMParams Info;
    LPHNPMParams pInfo;
    static const CLSID CLSID_InboundConnection=
    {0xBA126AD9,0x2166,0x11D1,{0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E}};

    TRACE1("HnPMConfigureAllConnections: fEnabled = %d", fEnabled);
    TRACE1("%s", fEnabled ? "Enable PortMaping on all connections." :
                            "Diable PortMaping on all connections.");

    ZeroMemory(&Info, sizeof(Info));
    pInfo = &Info;

    do {
        dwErr = HnPMConfigureAllConnectionsInit(pInfo);
        if( NO_ERROR != dwErr )
        {
            TRACE("HnPMConfigureAllConnections: Init failed!");
            break;
        }

        //Get All Connections
        //
        dwErr = HnPMConnectionEnum(pInfo);

        if ( NO_ERROR != dwErr )
        {
            TRACE("HnPMConfigureAllConnections: HnPMConnectionEnum() failed!");
            break;
        }

        TRACE1("HnPMConfigureAllConnections: %l Connections detected", pInfo->ConnCount);

        //Set up PortMapping for each connection
        //
        for ( i = 0; i < pInfo->ConnCount; i++ )
        {
            //won't do PortMapping for Incoming connections
            //
            if ( pInfo->ConnPropTable )
            {
            //define the class id for Incoming connections
            // reference to /nt/net/config/shell/wanui/rasui.cpp


               if( IsEqualCLSID( 
                    &CLSID_InboundConnection, 
                    &(pInfo->ConnPropTable[i].clsidThisObject) ) )
               {
                continue;
               }
            }

            pInfo->pNetConnection = pInfo->ConnArray[i];

            if ( NO_ERROR != HnPMConfigureSingleConnection(pInfo, fEnabled) )
            {
                TRACE1("HnPMConfigureAllConnections: HnPMConfigureSingleConnection failed for %lth connection",i);
            }
        }

    }
    while (FALSE);

    //Clean Up
    //
    HnPMConfigureAllConnectionsCleanUp(pInfo);

    return dwErr;
}//end of HnPMConfigureAllConnections()


// do the COM initialization and create pHNetCfgMgr
DWORD
HnPMCfgMgrInit(
        IN OUT LPHNPMParams pInfo)
{        
    HRESULT hr;
    DWORD dwErr = NO_ERROR;
        
    do{
        dwErr = HnPMInit(pInfo);

        if (NO_ERROR != dwErr )
        {
            TRACE("HnPMCfgMgrInit: HnPMInit failed!");
            break;
        }

        hr = CoCreateInstance(
                &CLSID_HNetCfgMgr,
                NULL,
                CLSCTX_ALL,
                &IID_IHNetCfgMgr,
                (VOID**) &pInfo->pHNetCfgMgr
                );

        if ( !SUCCEEDED(hr) )
        {
            TRACE("HnPMCfgMgrInit: CoCreateInstance failed");
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }
    }while(FALSE);

    return dwErr;
}//HnPMCfgMgrInit()


DWORD
HnPMCfgMgrCleanUp(
        IN OUT LPHNPMParams pInfo)
{
    if ( pInfo->pHNetCfgMgr )
    {
        IHNetCfgMgr_Release(pInfo->pHNetCfgMgr);
        pInfo->pHNetCfgMgr = NULL;
    }

    HnPMCleanUp(pInfo);

    return NO_ERROR;
}


DWORD
HnPMConfigureSingleConnectionGUIDInit(
        IN OUT LPHNPMParams pInfo,
        GUID * pGuid)
{
    DWORD dwErr = NO_ERROR;

    do{
        dwErr = HnPMCfgMgrInit(pInfo);
        if ( NO_ERROR != dwErr )
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        //Use Guid to indentify the connection
        pInfo->pGuid = pGuid;
        pInfo->pNetConnection = NULL;

    }while(FALSE);

    return dwErr;
}


DWORD
HnPMConfigureSingleConnectionGUIDCleanUp(
        IN OUT LPHNPMParams pInfo)
{
    pInfo->pGuid = NULL;
    pInfo->pNetConnection = NULL;

    HnPMCfgMgrCleanUp(pInfo);

    return NO_ERROR;
}

//Setup PortMapping protocols on a single connection
//represented by its GUID
//
DWORD
HnPMConfigureSingleConnectionGUID(
    IN GUID * pGuid,
    IN BOOL fEnabled)
{
    HNPMParams Info;
    LPHNPMParams pInfo;
    DWORD dwErr = NO_ERROR;
   
    TRACE1("HnPMConfigureSingleConnectionGUID: fEnabled = %d", fEnabled);

    TRACE1("%s", fEnabled ? "Enable PortMapping on this Connection" :
                            "Diable PortMapping on this Connection");
    ASSERT( pGuid );
    if ( !pGuid )
    {
        return ERROR_INVALID_PARAMETER;
    }

    ZeroMemory(&Info, sizeof(Info) );
    pInfo = &Info;


    dwErr = NO_ERROR;

    do{
        dwErr = HnPMConfigureSingleConnectionGUIDInit(pInfo, pGuid);
        if (NO_ERROR != dwErr)
        {
            TRACE("HnPMConfigureSingleConnectionGUID: Init failed!");
            break;
        }

        dwErr = HnPMConfigureSingleConnection(pInfo, fEnabled);
        if ( NO_ERROR != dwErr )
        {
            TRACE("HnPMConfigureSingleConnectionGUID: SetPortMappingForSingleConnection failed ");
            break;
        }
    }
    while (FALSE);

    HnPMConfigureSingleConnectionGUIDCleanUp(pInfo);

    return dwErr;
}//HnPMConfigureSingleConnectionGUID()



//Set up the port mapping for only one
//connection according to its GUID only when
//Incoming Connection exists and
//the VPN is enabled
//
DWORD
HnPMConfigureSingleConnectionGUIDIfVpnEnabled(
     GUID* pGuid,
     BOOL fDual,
     HANDLE hDatabase)
{
    HANDLE hDevDatabase = NULL;
    DWORD dwErr;
    BOOL  fEnabled = FALSE;

    dwErr = NO_ERROR;
    do 
    {
        // Get handles to the databases we're interested in
        //
        if ( !hDatabase )
        {
            dwErr = devOpenDatabase( &hDevDatabase );
            if ( NO_ERROR != dwErr )
            {
                TRACE("HnPMConfigureSingleConnectionGUIDIfVpnEnabled: devOpenDatabase failed!");
                break;
            }
        }
        else
        {
            hDevDatabase = hDatabase;
        }

        dwErr = devGetVpnEnable(hDevDatabase, &fEnabled );
        if ( NO_ERROR != dwErr )
        {
            TRACE("HnPMConfigureSingleConnectionGUIDIfVpnEnabled: devGetVpnEnable failed!");
            break;
        }

        //if fDual == TRUE, can disable/enable the portmapping 
        //according to if VPN is enabled or not
        //otherwise, dont do anything if VPN is not enabled.
        if ( !fEnabled && !fDual)
        {
            dwErr = NO_ERROR;
            break;
        }

        dwErr = HnPMConfigureSingleConnectionGUID( pGuid, fEnabled );
        if ( NO_ERROR != dwErr )
        {
            TRACE("HnPMConfigureSingleConnectionGUIDIfVpnEnabled: HnPMConfigureSingleConnectionGUID failed!");
            break;
        }
    }
    while (FALSE);

    if ( !hDatabase && hDevDatabase )
    {
        devCloseDatabase( hDevDatabase );
    }
 
    return dwErr;

}//HnPMConfigureSingleConnectionGUIDIfVpnEnabled()

//whistler bug 123769, 
//when Incoming Connection is running
//if VPN enabled, go to set up port mapping
//
DWORD
HnPMConfigureIfVpnEnabled(
     BOOL fDual,
     HANDLE hDatabase)
{
    HANDLE hDevDatabase = NULL;
    DWORD dwErr;
    BOOL  fEnabled = FALSE;

    dwErr = NO_ERROR;
    do 
    {
        // Get handles to the databases we're interested in
        //
        if ( !hDatabase )
        {
            dwErr = devOpenDatabase( &hDevDatabase );
            if ( NO_ERROR != dwErr )
            {
                TRACE("HnPMConfigureIfVpnEnabled: devOpenDatabase failed!");
                break;
            }
        }
        else
        {
            hDevDatabase = hDatabase;
        }

        dwErr = devGetVpnEnable(hDevDatabase, &fEnabled );
        if ( NO_ERROR != dwErr )
        {
            TRACE("HnPMConfigureIfVpnEnabled: devGetVpnEnable failed!");
            break;
        }

        //if fDual == TRUE, can disable/enable the portmapping 
        //according to if VPN is enabled or not
        //otherwise, dont do anything if VPN is not enabled.
        if ( !fEnabled && !fDual)
        {
            dwErr = NO_ERROR;
            break;
        }

        dwErr = HnPMConfigureAllConnections( fEnabled );
        if ( NO_ERROR != dwErr )
        {
            TRACE("HnPMConfigureIfVpnEnabled: SetPortMapingForICVpn failed!");
            break;
        }
    }
    while (FALSE);

    if ( !hDatabase && hDevDatabase )
    {
        devCloseDatabase( hDevDatabase );
    }
 
    return dwErr;

}//End of HnPMConfigureIfVpnEnabled()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\ipxui.h ===
/*
    File    Ipxui.c

    Dialog that edits the Ipx properties.
    
    Paul Mayfield, 10/9/97
*/

#ifndef __rassrvui_ipxui_h
#define __rassrvui_ipxui_h

#include "protedit.h"

// Brings up a modal dialog that allows the editing of Ipx parameters
// specific to the dialup server.  When this function completes, the 
// parameters are stored in pParams, and pbCommit is set to TRUE if the
// parameters are supposed to be saved to the system (i.e. OK was pressed)
DWORD IpxEditProperties(HWND hwndParent, PROT_EDIT_DATA * pEditData, BOOL * pbCommit);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rasscrpt\script.c ===
//============================================================================
// Copyright (c) 1996, Microsoft Corporation
//
// File:    script.c
//
// History:
//  Abolade-Gbadegesin  03-29-96    Created.
//
// This file contains functions implementing the NT port
// of Win9x dial-up scripting, listed in alphabetical order.
//
// See scriptp.h for details on the NT implementation.
//============================================================================


#include <scriptp.h>
#include <lmwksta.h>        // For NetWkstaUserGetInfo
#include <lmapibuf.h>       // For NetApiBufferFree


//
// Handle of module-instance for this DLL
//
HANDLE              g_hinst;
//
// global critical section used to synhronize access to IP address strings
//
CRITICAL_SECTION    g_cs;
//
// name of file to which script syntax errors are logged
//
CHAR                c_szScriptLog[] = RASSCRIPT_LOG;
//
// event handle which would be notified in case of IPAddress Change
//
HANDLE                          hIpAddressSet = INVALID_HANDLE_VALUE;

#define NET_SVCS_GROUP      "-k netsvcs"

//----------------------------------------------------------------------------
// Function:    DLLMAIN
//
// DLL entry-point for RASSCRIPT
//----------------------------------------------------------------------------

BOOL
WINAPI
RasScriptDllMain(
    IN      HINSTANCE   hinstance,
    IN      DWORD       dwReason,
    IN      PVOID       pUnused
    ) {

    BOOL bRetVal = TRUE;

    if (dwReason == DLL_PROCESS_ATTACH) {

        g_hinst = (HANDLE)hinstance;

        try 
        {
            InitializeCriticalSection(&g_cs);
        }
        except (EXCEPTION_EXECUTE_HANDLER) 
        {
            bRetVal = FALSE;
        }
    }
    else
    if (dwReason == DLL_PROCESS_DETACH) {

        DeleteCriticalSection(&g_cs);
    }

    return bRetVal;
}




//----------------------------------------------------------------------------
// Function:    RasScriptExecute
//
// Examines the given connection, and if there is a script for the connection,
// executes the script to completion.
// Returns the error code from script processing if a script is given,
// and returns NO_ERROR otherwise.
//----------------------------------------------------------------------------

DWORD
APIENTRY
RasScriptExecute(
    IN      HRASCONN        hrasconn,
    IN      PBENTRY*        pEntry,
    IN      CHAR*           pszUserName,
    IN      CHAR*           pszPassword,
    OUT     CHAR*           pszIpAddress
    ) {


    DWORD dwErr;
    HANDLE hevent = NULL, hscript = NULL;
    HANDLE hEvents[2];

    RASSCRPT_TRACE("RasScriptExecute");

    do {
        //
        // create event on which to receive notification
        //

        hevent = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (!hevent) {
            RASSCRPT_TRACE1("error %d creating event", dwErr = GetLastError());
            break;
        }


                // Create a separate event for SCRIPTCODE_IpAddressSet
                // event. We hit a timing window ow where we lose this
                // event (when we get a script complete event immediately
                // after a SCRIPTCODE_IpAddressSet event. bug 75226.
                hIpAddressSet = CreateEvent (NULL, FALSE, FALSE, NULL);

                if (!hIpAddressSet) {

                        RASSCRPT_TRACE1("error %d creating event", dwErr = GetLastError());
                        break;

                }


        //
        // initialize script processing
        //

        dwErr = RasScriptInit(
                    hrasconn, pEntry, pszUserName, pszPassword, 0, hevent,
                    &hscript
                    );

        if (dwErr != NO_ERROR) {
            RASSCRPT_TRACE1("error %d initializing scripting", dwErr);
            break;
        }


        hEvents[0] = hevent;
        hEvents[1] = hIpAddressSet;

        //
        // loop waiting for script to finish running
        //

        for ( ; ; ) {

            dwErr = WaitForMultipleObjects(2, hEvents, FALSE, INFINITE);

            if (dwErr - WAIT_OBJECT_0 == 0) {

                //
                // Retrieve the code for the event which occurred
                //

                DWORD dwCode = RasScriptGetEventCode(hscript);

                RASSCRPT_TRACE1("RasScriptExecute: eventcode %d", dwCode);


                //
                // Handle the event
                //

                if (dwCode == SCRIPTCODE_Done ||
                    dwCode == SCRIPTCODE_Halted ||
                    dwCode == SCRIPTCODE_HaltedOnError) {

                    RASSCRPT_TRACE("script processing completed");

                    dwErr = NO_ERROR;

                    break;
                }
            }

            else
            if (dwErr - WAIT_OBJECT_0 == 1) {

                    //
                    // The IP address has been changed;
                    // read the new IP address into the caller's buffer
                    //

                    RASSCRPT_TRACE("IP address changed");

                    dwErr = RasScriptGetIpAddress(hscript, pszIpAddress);
                    RASSCRPT_TRACE2("RasScriptGetIpAddress(e=%d,a=%s)",dwErr,pszIpAddress);
            }
        }

    } while(FALSE);


    if (hscript) { RasScriptTerm(hscript); }

    if (hevent) { CloseHandle(hevent); }

    if (hIpAddressSet) { CloseHandle (hIpAddressSet); }

    return dwErr;
}





//----------------------------------------------------------------------------
// Function:    RasScriptGetEventCode
//
// This function should be called to retrieve the event-code
// when the scripting thread signals an event.
// The event codes which may be returned are as follows:
//
//  NO_ERROR:                   no code has been set
//  SCRIPTCODE_Done:            the script has finished running;
//                              the thread blocks until RasScriptTerm is called.
//  SCRIPTCODE_InputNotify:     data is available in the buffer; if the buffer
//                              is full, the thread blocks until
//                              RasScriptReceive is called and the data
//                              is read successfully.
//  SCRIPTCODE_KeyboardEnable:  the keyboard should be enabled.
//  SCRIPTCODE_KeyboardDisable: the keyboard should be disabled.
//  SCRIPTCODE_IpAddressSet:    the IP address has changed; the new address
//                              can be retrieved via RasScriptGetIPAddress.
//  SCRIPTCODE_HaltedOnError:   the script has halted due to an error.
//----------------------------------------------------------------------------

DWORD
RasScriptGetEventCode(
    IN      HANDLE      hscript
    ) {

    SCRIPTCB* pscript = (SCRIPTCB *)hscript;

    RASSCRPT_TRACE("RasGetEventCode");

    if (!pscript) { return ERROR_INVALID_PARAMETER; }

    return pscript->dwEventCode;
}




//----------------------------------------------------------------------------
// Function:    RasScriptGetIpAddress
//
// This function retrieves the current IP address as set by the script.
//----------------------------------------------------------------------------

DWORD
RasScriptGetIpAddress(
    IN      HANDLE      hscript,
    OUT     CHAR*       pszIpAddress
    ) {

    SCRIPTCB* pscript = (SCRIPTCB *)hscript;

    RASSCRPT_TRACE("RasGetIpAddress");

    if (!pscript || !pszIpAddress) { return ERROR_INVALID_PARAMETER; }


    //
    // Access to the IP address string must be synchronized
    // since it may also be accessed via RxSetIPAddress
    //

    EnterCriticalSection(&g_cs);

    if (pscript->pszIpAddress) {

        lstrcpy(pszIpAddress, pscript->pszIpAddress);
    }
    else {

        lstrcpy(pszIpAddress, "0.0.0.0");
    }

    LeaveCriticalSection(&g_cs);

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    RasScriptInit
//
// Initializes for script processing on the given HRASCONN.
//
// This function creates a thread which handles script input and output
// on the given connection's port.
//
// If there is no script for the connection, this function returns an error
// unless the flag RASSCRIPT_NotifyOnInput is specified, in which case
// the thread loops posting receive-data requests on the connection's port
// until RasScriptTerm is called.
//
// If there is a script for the connection, the thread runs the script
// to completion. If the flag RASSCRIPT_NotifyOnInput is specified,
// the caller is notified when data is received on the port. The caller
// can then retrieve the data by calling RasScriptReceive.
//
// Notification may be event-based or message-based. By default, notification
// is event-based, and "Hnotifier" is treated as an event-handle.
// The event is signalled to by the scripting thread, and the caller retrieves
// the event code by calling RasScriptGetEventCode.
//
// Setting the flag RASSCRIPT_HwndNotify selects message-based notification,
// and indicates that "Hnotifier" is an HWND. The WM_RASSCRIPT event is sent
// to the window by the scripting thread, and "LParam" in the message sent
// contains the event code. See RasScriptGetEventCode for descriptions
// of the codes sent by the scripting thread.
//----------------------------------------------------------------------------

DWORD
APIENTRY
RasScriptInit(
    IN      HRASCONN        hrasconn,
    IN      PBENTRY*        pEntry,
    IN      CHAR*           pszUserName,
    IN      CHAR*           pszPassword,
    IN      DWORD           dwFlags,
    IN      HANDLE          hNotifier,
    OUT     HANDLE*         phscript
    ) {

    DWORD dwErr, dwSyntaxError = NO_ERROR;
    static const CHAR szSwitch[] = MXS_SWITCH_TXT;
    SCRIPTCB* pscript = NULL;
#ifdef UNICODEUI
//
// Define structures to use depending on whether or not the RAS UI
// is being built with Unicode.
//
#define PUISTR  CHAR*
#define PUIRCS  RASCONNSTATUSA*
#define PUIRC   RASCREDENTIALSA*
    RASCONNSTATUSW rcs;
    WCHAR* pszSwitch = StrDupWFromA(MXS_SWITCH_TXT);
#else
#define PUISTR  CHAR*
#define PUIRCS  RASCONNSTATUSA*
#define PUIRC   RASCREDENTIALSA*
    RASCONNSTATUSA rcs;
    CHAR* pszSwitch = szSwitch;
#endif

    RASSCRPT_TRACE_INIT("RASSCRPT");
    
    RASSCRPT_TRACE("RasScriptInit");


    //
    // validate arguments
    //

    if (phscript) { *phscript = NULL; }

    if (!hrasconn ||
        !pEntry ||
        !pszUserName ||
        !pszPassword ||
        !hNotifier ||
        !phscript) {

        RASSCRPT_TRACE("RasScriptInit: required parameter not specified");

#ifdef UNICODEUI
        Free(pszSwitch);
#endif
        return ERROR_INVALID_PARAMETER;
    }


    //
    // initialize script processing
    //

    do {

        DWORD dwsize;
        DWORD dwthread;
        HANDLE hthread;


        //
        // Load required DLL function pointers.
        //
        dwErr = LoadRasapi32Dll();
        if (dwErr)
            break;
        dwErr = LoadRasmanDll();
        if (dwErr)
            break;
        //
        // Initialize RAS
        //
        dwErr = g_pRasInitialize();

        if ( dwErr )
            break;

        /*
        //
        // Connect to the local rasman server
        //
        dwErr = g_pRasRpcConnect ( NULL, NULL );

        if (dwErr)
            break; */

        //
        // allocate space for a control block
        //

        pscript = Malloc(sizeof(*pscript));

        if (!pscript) {
            dwErr = GetLastError();
            RASSCRPT_TRACE2("error %d allocating %d bytes", dwErr, sizeof(*pscript));
            break;
        }


        //
        // initialize the control block
        //

        ZeroMemory(pscript, sizeof(*pscript));


        //
        // copy the argument fields
        //

        pscript->hrasconn = hrasconn;
        pscript->pEntry = pEntry;
        pscript->dwFlags = dwFlags;
        pscript->hNotifier = hNotifier;
        pscript->hport = g_pRasGetHport(hrasconn);

        if (pscript->pEntry->pszIpAddress) {

            //
            // Copy the IP address for the entry
            //

            pscript->pszIpAddress =
                    Malloc(lstrlenUI(pscript->pEntry->pszIpAddress) + 1);

            if (pscript->pszIpAddress) {

                StrCpyAFromUI(
                    pscript->pszIpAddress, pscript->pEntry->pszIpAddress
                    );
            }
            else {

                RASSCRPT_TRACE("error copying entry's IP address");

                dwErr = ERROR_NOT_ENOUGH_MEMORY;

                break;
            }
        }


        //
        // Initialize our Win9x-compatible session-config-info structure
        //

        ZeroMemory(&pscript->sci, sizeof(pscript->sci));

        pscript->sci.dwSize = sizeof(pscript->sci);
        StrCpyAFromUI(pscript->sci.szEntryName, pEntry->pszEntryName);
        lstrcpy(pscript->sci.szUserName, pszUserName);
        lstrcpy(pscript->sci.szPassword, pszPassword);


        //
        // See if the user name is missing;
        // if so, read the currently-logged on user's name
        //

        if (!pscript->sci.szUserName[0]) {

            WKSTA_USER_INFO_1* pwkui1 = NULL;

            //
            // Not all params were specified, so read the dial-params
            // for this phonebook entry
            //

            dwErr = NetWkstaUserGetInfo(NULL, 1, (LPBYTE*)&pwkui1);
            RASSCRPT_TRACE2("NetWkstaUserGetInfo(e=%d,u=(%ls))", dwErr,
                   (pwkui1) ? pwkui1->wkui1_username : L"null");

            if (dwErr == NO_ERROR && pwkui1 != NULL) {

                StrCpyAFromUI(pscript->sci.szUserName,
                    (LPCWSTR)pwkui1->wkui1_username);

                NetApiBufferFree(pwkui1);
            }
        }



        //
        // See if there is a script for this connection's state;
        // if there is one then the device-type will be "switch"
        // and the device-name will be the script path
        //

        ZeroMemory(&rcs, sizeof(rcs));

        rcs.dwSize = sizeof(rcs);

        dwErr = g_pRasGetConnectStatus(hrasconn, (PUIRCS)&rcs);

        if (dwErr != NO_ERROR) {
            RASSCRPT_TRACE1("error %d getting connect status", dwErr);
            break;
        }



        //
        // Check the device-type (will be "switch" for scripted entries)
        // and the device name (will be a filename for scripted entries)
        //

        if (lstrcmpiUI(rcs.szDeviceType, pszSwitch) == 0 &&
            GetFileAttributesUI(rcs.szDeviceName) != 0xFFFFFFFF) {

            CHAR szDevice[RAS_MaxDeviceName + 1], *pszDevice = szDevice;

            StrCpyAFromUI(szDevice, rcs.szDeviceName);


            //
            // The device-type is "Switch" and the device-name
            // contains the name of an existing file;
            // initialize the SCRIPTDATA structure.
            //

            dwErr = RsInitData(pscript, pszDevice);


            //
            // If there was a syntax error in the script, we continue
            // with the initialization, but record the error code.
            // on any other error, we immediately terminate initialization.
            //

            if (dwErr == ERROR_SCRIPT_SYNTAX) {
                dwSyntaxError = dwErr;
            }
            else
            if (dwErr != NO_ERROR) { break; }
        }



        //
        // Initialize RASMAN fields, allocating buffers for RASMAN I/O
        //

        dwsize = SIZE_RecvBuffer;
        dwErr = g_pRasGetBuffer(&pscript->pRecvBuffer, &dwsize);
        RASSCRPT_TRACE2("RasGetBuffer:e=%d,s=%d", dwErr, dwsize);

        if (dwErr != NO_ERROR) {
            RASSCRPT_TRACE1("error %d allocating receive-buffer", dwErr);
            break;
        }

        dwsize = SIZE_SendBuffer;
        dwErr = g_pRasGetBuffer(&pscript->pSendBuffer, &dwsize);
        RASSCRPT_TRACE2("RasGetBuffer:e=%d,s=%d", dwErr, dwsize);

        if (dwErr != NO_ERROR) {
            RASSCRPT_TRACE1("error %d alloacting send-buffer", dwErr);
            break;
        }



        //
        // Create synchronization events used to control the background thread
        //

        pscript->hRecvRequest = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (!pscript->hRecvRequest) {
            RASSCRPT_TRACE1("error %d creating receive-event", dwErr = GetLastError());
            break;
        }

        pscript->hRecvComplete = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (!pscript->hRecvComplete) {
            RASSCRPT_TRACE1("error %d creating received-event", dwErr = GetLastError());
            break;
        }

        pscript->hStopRequest = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (!pscript->hStopRequest) {
            RASSCRPT_TRACE1("error %d creating stop-event", dwErr = GetLastError());
            break;
        }

        pscript->hStopComplete = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (!pscript->hStopComplete) {
            RASSCRPT_TRACE1("error %d creating stopped-event", dwErr = GetLastError());
            break;
        }



        //
        // Create the thread which will receive data and process the script
        //

        hthread = CreateThread(
                    NULL, 0, RsThread, (PVOID)pscript, 0, &dwthread
                    );

        if (!hthread) {
            RASSCRPT_TRACE1("error %d creating script-thread", dwErr = GetLastError());
            break;
        }

        CloseHandle(hthread);

        pscript->dwFlags |= RASSCRIPT_ThreadCreated;


        if ((VOID*)pszSwitch != (VOID*)szSwitch) { Free0(pszSwitch); }


        //
        // we've successfully initialized, return control to caller
        //

        *phscript = (HANDLE)pscript;


        //
        // if there was a syntax error in the script, return the special
        // error code (ERROR_SCRIPT_SYNTAX) to indicate the problem;
        // otherwise return  NO_ERROR.
        //

        return (dwSyntaxError ? dwSyntaxError : NO_ERROR);

    } while(FALSE);


    //
    // an error occurred, so do cleanup
    //

    if ((VOID*)pszSwitch != (VOID*)szSwitch) { Free0(pszSwitch); }

    RasScriptTerm((HANDLE)pscript);

    return (dwErr ? dwErr : ERROR_UNKNOWN);
}




//----------------------------------------------------------------------------
// Function:    RasScriptReceive
//
// Called to retrieve the contents of the scripting thread's input buffer.
// When this function completes successfully, if the input buffer was full
// and the scripting thread was blocked, the thread continues executing.
//
// On input, "PdwBufferSize" should contain the size of "PBuffer", unless
// "PBuffer" is NULL, in which case "*PdwBufferSize" is treated as 0.
// On output, "PdwBufferSize" contains the size required to read
// the input buffer, and if the return value is NO_ERROR, then "PBuffer"
// contains the data in the input buffer. If the return value is
// ERROR_INSUFFICIENT_BUFFER, "PBuffer" was not large enough.
//----------------------------------------------------------------------------

DWORD
APIENTRY
RasScriptReceive(
    IN      HANDLE      hscript,
    IN      BYTE*       pBuffer,
    IN OUT  DWORD*      pdwBufferSize
    ) {

    SCRIPTCB* pscript = (SCRIPTCB *)hscript;

    RASSCRPT_TRACE("RasScriptReceive");

    //
    // return if the caller didn't request input-notification
    // or if no buffer-size is available
    //

    if (!pscript || !pdwBufferSize ||
        !(pscript->dwFlags & RASSCRIPT_NotifyOnInput)) {
        return ERROR_INVALID_PARAMETER;
    }


    //
    // return if no buffer or if buffer too small
    //

    if (!pBuffer || *pdwBufferSize < pscript->dwRecvSize) {
        *pdwBufferSize = pscript->dwRecvSize;
        return ERROR_INSUFFICIENT_BUFFER;
    }


    //
    // copy the data, and notify the thread that the data has been read
    //

    CopyMemory(pBuffer, pscript->pRecvBuffer, pscript->dwRecvSize);

    *pdwBufferSize = pscript->dwRecvSize;

    SetEvent(pscript->hRecvComplete);

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    RasScriptSend
//
// This function transmits bytes over the connection's port.
//
// "DwBufferSize" contains the number of bytes to insert from "PBuffer"
//----------------------------------------------------------------------------

DWORD
APIENTRY
RasScriptSend(
    IN      HANDLE      hscript,
    IN      BYTE*       pBuffer,
    IN      DWORD       dwBufferSize
    ) {

    DWORD dwsize;
    DWORD dwErr;
    SCRIPTCB *pscript = (SCRIPTCB *)hscript;

    RASSCRPT_TRACE("RasScriptSend");


    if (!pscript || !pBuffer || !dwBufferSize) {
        return ERROR_INVALID_PARAMETER;
    }


    //
    // send all the data in the buffer
    //

    for (dwsize = min(dwBufferSize, SIZE_SendBuffer);
         dwBufferSize;
         dwBufferSize -= dwsize, pBuffer += dwsize,
         dwsize = min(dwBufferSize, SIZE_SendBuffer)) {

        CopyMemory(pscript->pSendBuffer, pBuffer, dwsize);

        dwErr = g_pRasPortSend(
                    pscript->hport, pscript->pSendBuffer, dwsize
                    );
        RASSCRPT_TRACE1("g_pRasPortSend=%d", dwErr);
        DUMPB(pBuffer, dwsize);
    }


    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    RasScriptTerm
//
// This function terminates script processing, stopping the scripting thread.
// The return code is the code from processing the script, and it may be
//
//  NO_ERROR:           the script had finished running, or the connection
//                      had no script and the scripting thread was acting
//                      in simple I/O mode.
//  ERROR_MORE_DATA:    the script was still running.
//----------------------------------------------------------------------------

DWORD
APIENTRY
RasScriptTerm(
    IN      HANDLE      hscript
    ) {

    SCRIPTCB* pscript = hscript;

    RASSCRPT_TRACE("RasScriptTerm");

    if (!pscript) { return ERROR_INVALID_PARAMETER; }


    //
    // stop the thread if it is running
    //

    if (pscript->dwFlags & RASSCRIPT_ThreadCreated) {

        SetEvent(pscript->hStopRequest);

        WaitForSingleObject(pscript->hStopComplete, INFINITE);
    }

    if (pscript->pdata) { RsDestroyData(pscript); }

    if (pscript->hStopRequest) { CloseHandle(pscript->hStopRequest); }

    if (pscript->hStopComplete) { CloseHandle(pscript->hStopComplete); }

    if (pscript->hRecvRequest) { CloseHandle(pscript->hRecvRequest); }

    if (pscript->hRecvComplete) { CloseHandle(pscript->hRecvComplete); }


    if (pscript->pRecvBuffer) { g_pRasFreeBuffer(pscript->pRecvBuffer); }

    if (pscript->pSendBuffer) { g_pRasFreeBuffer(pscript->pSendBuffer); }

    Free0(pscript->pszIpAddress);

    Free(pscript);

    RASSCRPT_TRACE_TERM();

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    RsDestroyData
//
// This function destroys the SCRIPTDATA portion of a SCRIPTCB.
//----------------------------------------------------------------------------

DWORD
RsDestroyData(
    IN      SCRIPTCB*   pscript
    ) {

    SCRIPTDATA* pdata = pscript->pdata;

    if (!pdata) { return ERROR_INVALID_PARAMETER; }

    if (pdata->pmoduledecl) { Decl_Delete((PDECL)pdata->pmoduledecl); }

    if (pdata->pastexec) {
        Astexec_Destroy(pdata->pastexec); Free(pdata->pastexec);
    }

    if (pdata->pscanner) { Scanner_Destroy(pdata->pscanner); }

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    RsInitData
//
// This function initializes the SCRIPTDATA portion of a SCRIPTCB,
// preparing for script-processing.
//----------------------------------------------------------------------------

DWORD
RsInitData(
    IN      SCRIPTCB*   pscript,
    IN      LPCSTR      pszScriptPath
    ) {

    RES res;
    DWORD dwErr = ERROR_SUCCESS;
    SCRIPTDATA *pdata;

    RASSCRPT_TRACE("RsInitData");

    do {

        //
        // allocate space for the SCRIPTDATA;
        //

        pscript->pdata = pdata = Malloc(sizeof(*pdata));

        if (!pdata) {
            RASSCRPT_TRACE1("error %d allocating SCRIPTDATA", dwErr = GetLastError());
            break;
        }


        //
        // initialize the structure
        //

        ZeroMemory(pdata, sizeof(*pdata));

        pdata->hscript = (HANDLE)pscript;
        lstrcpy(pdata->script.szPath, pszScriptPath);


        //
        // create a scanner and use it to open the script
        //

        res = Scanner_Create(&pdata->pscanner, &pscript->sci);

        if (RFAILED(res)) {
            RASSCRPT_TRACE1("failure %d creating scanner", res);
            break;
        }

        res = Scanner_OpenScript(pdata->pscanner, pszScriptPath);

        if (res == RES_E_FAIL || RFAILED(res)) {
            RASSCRPT_TRACE1("failure %d opening script", res);
            break;
        }


        //
        // allocate a script-execution handler
        //

        pdata->pastexec = Malloc(sizeof(*pdata->pastexec));

        if (!pdata->pastexec) {
            RASSCRPT_TRACE1("error %d allocating ASTEXEC", dwErr = GetLastError());
            break;
        }

        ZeroMemory(pdata->pastexec, sizeof(*pdata->pastexec));


        //
        // initialize the script-execution handler
        //

        res = Astexec_Init(
                pdata->pastexec, pscript, &pscript->sci,
                Scanner_GetStxerrHandle(pdata->pscanner)
                );

        if (!RSUCCEEDED(res)) {
            RASSCRPT_TRACE1("failure %d initializing ASTEXEC", res);
            break;
        }

        Astexec_SetHwnd(pdata->pastexec, (HWND)pdata);


        //
        // parse the script using the created scanner
        // and writing into the execution-handler's symbol-table
        //

        res = ModuleDecl_Parse(
                &pdata->pmoduledecl, pdata->pscanner,
                pdata->pastexec->pstSystem
                );

        if (RSUCCEEDED(res)) {

            //
            // generate code for the script
            //

            res = ModuleDecl_Codegen(pdata->pmoduledecl, pdata->pastexec);
        }


        //
        // see if anything went wrong
        //

        if (RFAILED(res)) {

            //
            // there was an error parsing the script.
            // we return the special error code ERROR_SCRIPT_SYNTAX
            // and log the errors to a file.
            //
            // This is not necessarily a fatal error, and so returning
            // the above error doesn't cause script-initialization to fail,
            // since if the user is in interactive mode, the connection
            // may be completed manually by typing into the terminal window.
            //
            // If we are not in interactive mode, this is a fatal error,
            // and RasScriptExecute handles the condition correctly
            // by terminating the script immediately
            //

            RASSCRPT_TRACE1("failure %d parsing script", res);

            RxLogErrors(
                (HANDLE)pscript, (VOID*)Scanner_GetStxerrHandle(pdata->pscanner)
                );

            Decl_Delete((PDECL)pdata->pmoduledecl);
            Astexec_Destroy(pdata->pastexec); Free(pdata->pastexec);
            Scanner_Destroy(pdata->pscanner);

            pscript->pdata = NULL;

            dwErr = ERROR_SCRIPT_SYNTAX;

            return dwErr;
        }


        //
        // all went well, return
        //

        return NO_ERROR;

    } while(FALSE);


    //
    // an error occurred, so do cleanup
    //

    if (pscript->pdata) { RsDestroyData(pscript); }

    return (dwErr ? dwErr : ERROR_UNKNOWN);
}



//----------------------------------------------------------------------------
// Function:    RsPostReceive
//
// Internal function:
// posts receive-request to RASMAN
//----------------------------------------------------------------------------

DWORD
RsPostReceive(
    IN      SCRIPTCB*   pscript
    ) {

    DWORD dwSize;
    DWORD dwErr;

    RASSCRPT_TRACE("RsPostReceive");

    dwSize = SIZE_RecvBuffer;

    dwErr = g_pRasPortReceive(
                pscript->hport, pscript->pRecvBuffer, &dwSize, SECS_RecvTimeout,
                pscript->hRecvRequest
                );

    RASSCRPT_TRACE2("RsPostReceive=%d,%d", dwErr, dwSize);

    return dwErr;
}

BOOL
IsRasmanProcess()
{
    CHAR *pszCmdLine = NULL;
    BOOL fRet = FALSE;

    pszCmdLine = GetCommandLineA();

    if(     (NULL != pszCmdLine)
        &&  (strstr(pszCmdLine, NET_SVCS_GROUP)))
    {
        fRet = TRUE;
    }

    return fRet;    
}


DWORD
RsPostReceiveEx(
    IN SCRIPTCB* pscript
    ) {

    DWORD dwSize = 0;
    DWORD dwErr = ERROR_SUCCESS;

    RASSCRPT_TRACE("RsPostReceiveEx");

    if(IsRasmanProcess())
    {
        goto done;
    }

    RASSCRPT_TRACE("Calling RsPostReceiveEx");

    dwSize = SIZE_RecvBuffer;
    dwErr = g_pRasPortReceiveEx(
            pscript->hport,
            pscript->pRecvBuffer,
            &dwSize
            );

done:

    RASSCRPT_TRACE2("RsPostReceiveEx=%d, %d",dwErr, dwSize );

    return dwErr;

}




//----------------------------------------------------------------------------
// Function:    RsSignal
//
// Internal function:
// this is called to signal the notifier for a script, which may involve
// setting an event or sending a message.
//----------------------------------------------------------------------------

VOID
RsSignal(
    IN  SCRIPTCB*   pscript,
    IN  DWORD       dwEventCode
    ) {

    RASSCRPT_TRACE1("RsSignal: %d", dwEventCode);

    InterlockedExchange(&pscript->dwEventCode, dwEventCode);

    if (pscript->dwFlags & RASSCRIPT_HwndNotify) {

        SendNotifyMessage(
            (HWND)pscript->hNotifier, WM_RASAPICOMPLETE, 0, dwEventCode
            );
    }
    else {

        SetEvent(pscript->hNotifier);
    }
}




//----------------------------------------------------------------------------
// Function:    RsThread
//
// This function is the entry-point for the script processing thread.
//
// The scripting thread operates in a loop, posting receive requests
// and receiving incoming data. If a script is associated with the port,
// the thread also runs the script.
//----------------------------------------------------------------------------

DWORD
RsThread(
    IN      PVOID       pParam
    ) {

    WORD wSize;
#define POS_STOP    0
#define POS_RECV    1
#define POS_LAST    2
    BOOL bFirstRecv = TRUE;
    HANDLE hEvents[POS_LAST];
    SCRIPTCB* pscript = (SCRIPTCB *)pParam;
    SCRIPTDATA* pdata = pscript->pdata;
    DWORD dwErr, dwTicksBefore, dwTicksAfter, dwTicksElapsed;


    RASSCRPT_TRACE("RsThread");

    //
    // post receive-request to RASMAN
    //

    dwErr = RsPostReceive(pscript);
    if (dwErr != NO_ERROR && dwErr != PENDING) {

        RASSCRPT_TRACE1("error %d posting receive to RASMAN", dwErr);

        RsPostReceiveEx ( pscript );

        RsSignal(pscript, SCRIPTCODE_Halted);

        SetEvent(pscript->hStopComplete);

        return dwErr;
    }


    //
    // set up event array; we place the stop-request event first
    // in the array since the receive-event will be signalled more often
    // and placing it first might result in starvation
    // (waits are always satisfied by the first signalled object)
    //

    hEvents[POS_STOP] = pscript->hStopRequest;
    hEvents[POS_RECV] = pscript->hRecvRequest;

    if (pdata) { pdata->dwTimeout = INFINITE; }

    while (TRUE) {


        //
        // wait for receive to complete, for stop signal,
        // or for timeout to expire
        //
        // save the tick count so we can tell how long the wait lasted
        //

        dwTicksBefore = GetTickCount();

        dwErr = WaitForMultipleObjects(
                    POS_LAST, hEvents, FALSE, pdata ? pdata->dwTimeout:INFINITE
                    );

        dwTicksAfter = GetTickCount();


        //
        // see if the tick count wrapped around, and if so
        // adjust so we always get the correct elapsed time
        // from the expression (dwTicksAfter - dwTicksBefore)
        //

        if (dwTicksAfter < dwTicksBefore) {
            dwTicksAfter += MAXDWORD - dwTicksBefore;
            dwTicksBefore = 0;
        }

        dwTicksElapsed = dwTicksAfter - dwTicksBefore;

        RASSCRPT_TRACE1("RsThread: waited for %d milliseconds", dwTicksElapsed);


        //
        // if the timeout isn't INFINITE, decrement it by
        // the amount of time we've already waited
        //

        if (pdata && pdata->dwTimeout != INFINITE) {

            if (dwTicksElapsed >= pdata->dwTimeout) {
                pdata->dwTimeout = INFINITE;
            }
            else {
                pdata->dwTimeout -= dwTicksElapsed;
            }
        }


        //
        // Handle the return-code from WaitForMultipleObjects
        //

        if (dwErr == (WAIT_OBJECT_0 + POS_STOP)) {

            //
            // stop-request signalled, break
            //

            RASSCRPT_TRACE("RsThread: stop event signalled");

            RsSignal(pscript, SCRIPTCODE_Halted);

            break;
        }
        else
        if (dwErr == WAIT_TIMEOUT) {


            if (!pdata) { continue; }


            //
            // wait timed out, so that means we were blocked
            // on a "delay" or "waitfor ... until" statement;
            //

            Astexec_ClearPause(pdata->pastexec);


            //
            // if we blocked because of a "waitfor ... until",
            // finish processing the statement
            //

            if (Astexec_IsWaitUntil(pdata->pastexec)) {

                Astexec_SetStopWaiting(pdata->pastexec);

                Astexec_ClearWaitUntil(pdata->pastexec);
            }


            //
            // continue processing the script
            //

            if (RsThreadProcess(pscript) == ERROR_NO_MORE_ITEMS) {

                //
                // the script has stopped; if done, break;
                // otherwise, continue receiving data
                //

                if (pscript->dwEventCode == SCRIPTCODE_Done) {

                    break;
                }
                else {

                    //
                    // Cleanup the script, but continue receiving data
                    //

                    RsDestroyData(pscript);

                    pdata = pscript->pdata = NULL;
                }
            }
        }
        else
        if (dwErr == (WAIT_OBJECT_0 + POS_RECV)) {

            //
            // receive completed
            //

            RASMAN_INFO info;
            DWORD dwStart, dwRead;

            RASSCRPT_TRACE("RsThread: receive event signalled");


            //
            // Get the data received
            //
            dwErr = RsPostReceiveEx ( pscript );

            if (    NO_ERROR != dwErr
                &&  PENDING  != dwErr )
            {
                RASSCRPT_TRACE1("error %d in RsPostReceiveEx", dwErr);

                RsSignal(pscript, SCRIPTCODE_Halted );

                break;
            }

            //
            // get the number of bytes received
            //

            dwErr = g_pRasGetInfo(NULL, pscript->hport, &info);

            if (dwErr != NO_ERROR) {

                RASSCRPT_TRACE1("error %d retrieving RASMAN_INFO", dwErr);

                RsSignal(pscript, SCRIPTCODE_Halted);

                break;
            }

            if(  (info.RI_LastError != NO_ERROR)
              && (info.RI_ConnState != CONNECTING))
            {
                RASSCRPT_TRACE("Link dropped! port no longer in connecting state");

                RsSignal(pscript, SCRIPTCODE_Halted);

                break;
            }
            
            if (info.RI_LastError != NO_ERROR) {
                RASSCRPT_TRACE1("last error: %d", info.RI_LastError);
                continue;
            }

            RASSCRPT_TRACE1("RsThread: received %d bytes", info.RI_BytesReceived);


            //
            // on the first receive, we proceed even if there aren't any
            // characters read, since we need to run the first script commands
            //

            if (!bFirstRecv && info.RI_BytesReceived == 0) {

                //
                // something went wrong, post another receive request
                //

                dwErr = RsPostReceive(pscript);

                if (    dwErr != NO_ERROR
                    &&  dwErr != PENDING)
                {
                    RASSCRPT_TRACE1("error %d in RsPostReceive", dwErr);

                    RsSignal(pscript, SCRIPTCODE_Halted);

                    break;
                }

                continue;
            }

            bFirstRecv = FALSE;

            pscript->dwRecvSize = info.RI_BytesReceived;
            pscript->dwRecvRead = 0;

            DUMPB(pscript->pRecvBuffer, pscript->dwRecvSize);


            //
            // if the creator wants to know when data arrives,
            // signal the creator's notification now;
            // wait till the creator reads the data before proceeding
            //

            if (info.RI_BytesReceived &&
                (pscript->dwFlags & RASSCRIPT_NotifyOnInput)) {

                RsSignal(pscript, SCRIPTCODE_InputNotify);

                WaitForSingleObject(pscript->hRecvComplete, INFINITE);
            }


            //
            // if we have no script that's all we have to do,
            // so just post another receive request and go back to waiting
            //

            if (!pdata) {

                dwErr = RsPostReceive(pscript);

                if (    dwErr != NO_ERROR
                    &&  dwErr != PENDING )
                {
                    RASSCRPT_TRACE1("error %d in RsPostReceive",dwErr);

                    RsSignal(pscript, SCRIPTCODE_Halted);

                    break;
                }

                continue;
            }


            //
            // read the data into the script's circular buffer
            //

            ReadIntoBuffer(pdata, &dwStart, &dwRead);


            //
            // do more script processing
            //

            if (RsThreadProcess(pscript) == ERROR_NO_MORE_ITEMS) {

                //
                // the script has stopped; if done, break;
                // otherwise, continue receiving data
                //

                if (pscript->dwEventCode == SCRIPTCODE_Done) {

                    break;
                }
                else {

                    //
                    // Cleanup the script, but continue receiving data
                    //

                    RsDestroyData(pscript);

                    pdata = pscript->pdata = NULL;
                }
            }
        }
    }


    //
    // cancel any pending receives
    //

    g_pRasPortCancelReceive(pscript->hport);


    SetEvent(pscript->hStopComplete);

    RASSCRPT_TRACE("RsThread done");

    return NO_ERROR;
}



//----------------------------------------------------------------------------
// Function:    RsThreadProcess
//
// Called to process the script until it is blocked
// by a "waitfor" statement or a "delay" statement.
//----------------------------------------------------------------------------

DWORD
RsThreadProcess(
    IN      SCRIPTCB*   pscript
    ) {

    RES res;
    DWORD dwErr;
    SCRIPTDATA *pdata = pscript->pdata;

    RASSCRPT_TRACE("RsThreadProcess");


    //
    // now step through the script until we are blocked
    // by a "delay" statement or a "waitfor" statement
    //

    dwErr = NO_ERROR;

    do {

        //
        // break if its time to stop
        //

        if (WaitForSingleObject(pscript->hStopRequest, 0) == WAIT_OBJECT_0) {

            SetEvent(pscript->hStopRequest);

            break;
        }


        //
        // process next command
        //

        res = Astexec_Next(pdata->pastexec);

//        if (res != RES_OK) { break; }


        //
        // examine the resulting state
        //

        if (Astexec_IsDone(pdata->pastexec) ||
            Astexec_IsHalted(pdata->pastexec)) {

            //
            // the script has come to an end, so set our stop event
            // and break out of this loop
            //

            RASSCRPT_TRACE("RsThreadProcess: script completed");

            //
            // do stop-completion notification
            //

            if (Astexec_IsDone(pdata->pastexec)) {
                RsSignal(pscript, SCRIPTCODE_Done);
            }
            else
            if (!RFAILED(res)) {
                RsSignal(pscript, SCRIPTCODE_Halted);
            }
            else {
                RsSignal(pscript, SCRIPTCODE_HaltedOnError);
            }


            dwErr = ERROR_NO_MORE_ITEMS;

            break;
        }
        else
        if (Astexec_IsReadPending(pdata->pastexec)) {

            //
            // we're blocked waiting for input,
            // so post another receive request and go back
            // to waiting for data;
            // if we're blocked on a "waitfor ... until"
            // then the timeout will be in pdata->dwTimeout,
            // otherwise pdata->dwTimeout will be INFINITE
            // which is exactly how long we'll be waiting
            //

            RsPostReceive(pscript);

            RASSCRPT_TRACE("RsThreadProcess: script waiting for input");

            break;
        }
        else
        if (Astexec_IsPaused(pdata->pastexec)) {

            //
            // we're blocked with a timeout, so pick up
            // the timeout value from pdata->dwTimeout.
            // we don't want to listen for input
            // while we're blocked, so we don't post another receive-request
            //

            RASSCRPT_TRACE("RsThreadProcess: script paused");

            break;
        }

    } while (TRUE);

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    RxLogErrors
//
// Logs script syntax errors to a file named %windir%\system32\ras\script.log
//----------------------------------------------------------------------------

DWORD
RxLogErrors(
    IN      HANDLE      hscript,
    IN      HSA         hsaStxerr
    ) {

    HANDLE hfile;
    CHAR *pszPath;
    STXERR stxerr;
    SCRIPTDATA *pdata;
    SCRIPTCB *pscript = hscript;
    DWORD i, cel, dwErr, dwSize;

    RASSCRPT_TRACE("RxLogErrors");

    if (!pscript || !pscript->pdata) { return ERROR_INVALID_PARAMETER; }

    pdata = pscript->pdata;



    //
    // get the pathname for the logfile
    //

    dwSize = ExpandEnvironmentStrings(c_szScriptLog, NULL, 0);

    pszPath = Malloc((dwSize + 1) * sizeof(CHAR));
    if (!pszPath) { return ERROR_NOT_ENOUGH_MEMORY; }

    ExpandEnvironmentStrings(c_szScriptLog, pszPath, dwSize);


    //
    // create the file, overwriting it if it already exists
    //

    hfile = CreateFile(
                pszPath, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL, NULL
                );
    Free(pszPath);

    if (INVALID_HANDLE_VALUE == hfile) {
        dwErr = GetLastError();
        RASSCRPT_TRACE1("error %d creating logfile", dwErr);
        return dwErr;
    }


    //
    // truncate the previous contents of the file, if any
    //

    SetFilePointer(hfile, 0, 0, FILE_BEGIN);
    SetEndOfFile(hfile);


    //
    // get the number of syntax errors
    //

    cel = SAGetCount(hsaStxerr);


    //
    // append each error to the file
    //

    for (i = 0; i < cel; i++) {

        UINT ids;
        CHAR* pszErr;
        BOOL bRet = SAGetItem(hsaStxerr, i, &stxerr);


        if (!bRet) { continue; }

        ids = IdsFromRes(Stxerr_GetRes(&stxerr));

        if (ids == 0) { continue; }


        //
        // format the error message
        //

        ConstructMessage(
            &pszErr, g_hinst, MAKEINTRESOURCE(ids), pdata->script.szPath,
            Stxerr_GetLine(&stxerr), Stxerr_GetLexeme(&stxerr)
            );

        if (!pszErr) { continue; }


        //
        // write the message to the log file
        //

        dwSize = lstrlen(pszErr);

        WriteFile(hfile, pszErr, lstrlen(pszErr), &dwSize, NULL);

        WriteFile(hfile, "\r\n", 2, &dwSize, NULL);


        //
        // free the message pointer
        //

        GFree(pszErr);
    }

    CloseHandle(hfile);

    return 0;
}



//----------------------------------------------------------------------------
// Function:    RxReadFile
//
// Transfers data out of a RASMAN buffer into the circular buffer used
// by the Win9x scripting code
//----------------------------------------------------------------------------

BOOL
RxReadFile(
    IN      HANDLE      hscript,
    IN      BYTE*       pBuffer,
    IN      DWORD       dwBufferSize,
    OUT     DWORD*      pdwBytesRead
    ) {

    SCRIPTCB* pscript = (SCRIPTCB*)hscript;
    DWORD dwRecvSize = pscript->dwRecvSize - pscript->dwRecvRead;

    RASSCRPT_TRACE("RxReadFile");

    if (!pdwBytesRead) { return FALSE; }

    *pdwBytesRead = 0;
    if ((INT)dwRecvSize <= 0) { return FALSE; }

    if (!dwBufferSize) { return FALSE; }

    *pdwBytesRead = min(dwBufferSize, dwRecvSize);
    CopyMemory(
        pBuffer, pscript->pRecvBuffer + pscript->dwRecvRead, *pdwBytesRead
        );
    pscript->dwRecvRead += *pdwBytesRead;

    RASSCRPT_TRACE2("RxReadFile(rr=%d,br=%d)",pscript->dwRecvRead,*pdwBytesRead);

    return TRUE;
}



//----------------------------------------------------------------------------
// Function:    RxSetIPAddress
//
// Sets the IP address for the script's RAS entry
//----------------------------------------------------------------------------

DWORD
RxSetIPAddress(
    IN      HANDLE      hscript,
    IN      LPCSTR      lpszAddress
    ) {

    DWORD dwErr = NO_ERROR;
    SCRIPTCB *pscript = (SCRIPTCB *)hscript;

    RASSCRPT_TRACE1("RxSetIPAddress: %s", lpszAddress);


    EnterCriticalSection(&g_cs);


    //
    // Free the existing IP address, if any
    //

    Free0(pscript->pszIpAddress);


    //
    // Allocate space for a copy of the address
    //

    pscript->pszIpAddress = Malloc(lstrlen(lpszAddress) + 1);

    if (!pscript->pszIpAddress) { dwErr = ERROR_NOT_ENOUGH_MEMORY; }
    else {

        //
        // Copy the new IP address
        //

        lstrcpy(pscript->pszIpAddress, lpszAddress);
    }

    LeaveCriticalSection(&g_cs);



    //
    // If successful, signal the caller that the IP address has changed
    //

    if (dwErr != NO_ERROR) {
        RASSCRPT_TRACE1("error %d writing phonebook file", dwErr);
    }
    else {


                if (    INVALID_HANDLE_VALUE != hIpAddressSet
                        &&      !(pscript->dwFlags  & RASSCRIPT_HwndNotify))
                {
                DWORD dwEventCode = SCRIPTCODE_IpAddressSet;
                        RASSCRPT_TRACE1("RxSetIPAddress: %d", dwEventCode);

                        InterlockedExchange(&pscript->dwEventCode, dwEventCode);
                        SetEvent (hIpAddressSet);

                }

                else if (pscript->dwFlags & RASSCRIPT_HwndNotify)
                RsSignal(pscript, SCRIPTCODE_IpAddressSet);
    }

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    RxSetKeyboard
//
// Signals the script-owner to enable or disable keyboard input.
//----------------------------------------------------------------------------

DWORD
RxSetKeyboard(
    IN      HANDLE      hscript,
    IN      BOOL        bEnable
    ) {

    RASSCRPT_TRACE("RxSetKeyboard");

    RsSignal(
        (SCRIPTCB *)hscript,
        bEnable ? SCRIPTCODE_KeyboardEnable : SCRIPTCODE_KeyboardDisable
        );

    return NO_ERROR;
}

//----------------------------------------------------------------------------
// Function:    RxSendCreds
//
// Sends users password over the wire.
//----------------------------------------------------------------------------
DWORD
RxSendCreds(
    IN HANDLE hscript,
    IN CHAR controlchar
    ) {

    SCRIPTCB *pscript = (SCRIPTCB *) hscript;
    DWORD dwErr;

    RASSCRPT_TRACE("RasSendCreds");

    dwErr = RasSendCreds(pscript->hport, controlchar);

    RASSCRPT_TRACE1("RasSendCreds done. 0x%x", dwErr);

    return (dwErr == NO_ERROR) ? RES_OK : RES_E_FAIL;
    
}


//----------------------------------------------------------------------------
// Function:    RxSetPortData
//
// Changes settings for the COM port.
//----------------------------------------------------------------------------

DWORD
RxSetPortData(
    IN      HANDLE      hscript,
    IN      VOID*       pStatement
    ) {

    RES res;
    STMT* pstmt;
    RAS_PARAMS* pparam;
    DWORD dwErr, dwFlags;
    RASMAN_PORTINFO *prmpi;
    SCRIPTCB *pscript = (SCRIPTCB *)hscript;
    BYTE aBuffer[sizeof(RASMAN_PORTINFO) + sizeof(RAS_PARAMS) * 2];

    RASSCRPT_TRACE("RxSetPortData");


    //
    // Retrieve the 'set port' statement
    //

    pstmt = (STMT*)pStatement;

    dwFlags = SetPortStmt_GetFlags(pstmt);


    //
    // Set up the RASMAN_PORTINFO to be passed to RasPortSetInfo
    //

    prmpi = (RASMAN_PORTINFO*)aBuffer;

    prmpi->PI_NumOfParams = 0;

    pparam = prmpi->PI_Params;


    //
    // Collect the changes into the port-info structure
    //

    if (IsFlagSet(dwFlags, SPF_DATABITS)) {

        lstrcpyA(pparam->P_Key, SER_DATABITS_KEY);

        pparam->P_Type = Number;

        pparam->P_Attributes = 0;

        pparam->P_Value.Number = SetPortStmt_GetDatabits(pstmt);

        RASSCRPT_TRACE1("GetDatabits==%d", pparam->P_Value.Number);

        ++prmpi->PI_NumOfParams;

        ++pparam;
    }


    if (IsFlagSet(dwFlags, SPF_STOPBITS)) {

        lstrcpyA(pparam->P_Key, SER_STOPBITS_KEY);

        pparam->P_Type = Number;

        pparam->P_Attributes = 0;

        pparam->P_Value.Number = SetPortStmt_GetStopbits(pstmt);


        //
        // The only 'stopbits' settings supported are 1 and 2;
        // in order to set stopbits of 1, we need to pass 0
        // to RasPortSetInfo, so the value is adjusted here.
        //

        if (pparam->P_Value.Number == 1) { --pparam->P_Value.Number; }

        RASSCRPT_TRACE1("GetStopbits==%d", pparam->P_Value.Number);

        ++prmpi->PI_NumOfParams;

        ++pparam;
    }

    if (IsFlagSet(dwFlags, SPF_PARITY)) {

        lstrcpyA(pparam->P_Key, SER_PARITY_KEY);

        pparam->P_Type = Number;

        pparam->P_Attributes = 0;

        pparam->P_Value.Number = SetPortStmt_GetParity(pstmt);

        RASSCRPT_TRACE1("GetParity==%d", pparam->P_Value.Number);

        ++prmpi->PI_NumOfParams;

        ++pparam;
    }


    //
    // Send the changes down to RASMAN
    //

    if (!prmpi->PI_NumOfParams) { dwErr = NO_ERROR; }
    else {

        dwErr = g_pRasPortSetInfo(pscript->hport, prmpi);

        RASSCRPT_TRACE1("g_pRasPortSetInfo==%d", dwErr);

        if (dwErr != NO_ERROR) {

            Stxerr_Add(
                pscript->pdata->pastexec->hsaStxerr, "set port",
                Ast_GetLine(pstmt), RES_E_FAIL
                );
        }
    }

    return (dwErr == NO_ERROR) ? RES_OK : RES_E_FAIL;
}



//----------------------------------------------------------------------------
// Function:    RxWriteFile
//
// Transmits the given buffer thru RASMAN on a port
//----------------------------------------------------------------------------

VOID
RxWriteFile(
    IN      HANDLE      hscript,
    IN      BYTE*       pBuffer,
    IN      DWORD       dwBufferSize,
    OUT     DWORD*      pdwBytesWritten
    ) {

    RASSCRPT_TRACE("RxWriteFile");

    if (!pdwBytesWritten) { return; }

    RasScriptSend(hscript, pBuffer, dwBufferSize);

    *pdwBytesWritten = dwBufferSize;

    RASSCRPT_TRACE1("RxWriteFile(bw=%d)", *pdwBytesWritten);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\ipxui.c ===
/*
    File    ipxui.c

    Dialog that edits the ipx properties.
    
    Paul Mayfield, 10/9/97
*/

#include "rassrv.h"

// Help maps
static const DWORD phmIpxui[] =
{
    CID_NetTab_Ipxui_RB_AutoAssign,         IDH_NetTab_Ipxui_RB_AutoAssign,
    CID_NetTab_Ipxui_RB_ManualAssign,       IDH_NetTab_Ipxui_RB_ManualAssign,
    CID_NetTab_Ipxui_CB_AssignSame,         IDH_NetTab_Ipxui_CB_AssignSame,
    CID_NetTab_Ipxui_EB_Netnum,             IDH_NetTab_Ipxui_EB_Netnum,
    //CID_NetTab_Ipxui_ST_Network,            IDH_NetTab_Ipxui_ST_Network,
    CID_NetTab_Ipxui_CB_CallerSpec,         IDH_NetTab_Ipxui_CB_CallerSpec,
    //CID_NetTab_Ipxui_CB_ExposeNetwork,      IDH_NetTab_Ipxui_CB_ExposeNetwork,
    0,                                      0
};

void IpxUiDisplayError(HWND hwnd, DWORD dwErr) {
    ErrDisplayError(hwnd, dwErr, ERR_IPXPROP_CATAGORY, 0, Globals.dwErrorData);
}

// Enables/disables windows in the dialog box depending
// on the ipx parameters
DWORD IpxEnableWindows(HWND hwndDlg, IPX_PARAMS * pIpxParams) {
    // If auto assign is selected, disable address and global wan fields
    EnableWindow(GetDlgItem(hwndDlg, CID_NetTab_Ipxui_EB_Netnum), !pIpxParams->bAutoAssign);
    //EnableWindow(GetDlgItem(hwndDlg, CID_NetTab_Ipxui_CB_AssignSame), !pIpxParams->bAutoAssign);

    return NO_ERROR;
}

// Adjusts the label that determines whether internal net numbers
// are automatically assigned.
DWORD IpxAdjustNetNumberLabel(HWND hwndDlg, BOOL bGlobalWan) {
    PWCHAR pszManAssignLabel, pszAutoAssignLabel;

    // Modify the net num label according to the global wan setting
    if (bGlobalWan) {
        pszManAssignLabel = 
            (PWCHAR) PszLoadString(Globals.hInstDll, SID_NETWORKNUMBERLABEL);
        pszAutoAssignLabel = 
            (PWCHAR) PszLoadString(Globals.hInstDll, SID_AUTO_NETNUM_LABEL);
    }
    else {
        pszManAssignLabel = 
            (PWCHAR) PszLoadString(Globals.hInstDll, SID_STARTNETNUMLABEL);
        pszAutoAssignLabel = 
            (PWCHAR) PszLoadString(Globals.hInstDll, SID_AUTO_NETNUMS_LABEL);
    }

    SetWindowTextW(GetDlgItem(hwndDlg, CID_NetTab_Ipxui_RB_ManualAssign), pszManAssignLabel);
    SetWindowTextW(GetDlgItem(hwndDlg, CID_NetTab_Ipxui_RB_AutoAssign), pszAutoAssignLabel);

    return NO_ERROR;
}

#define isBetween(b,a,c) ((b >= a) && (b <= c))

// Filters characters that can be edited into an ipx net number control
BOOL IpxValidNetNumberChar(WCHAR wcNumChar) {
    return (iswdigit(wcNumChar)                             ||
            isBetween(wcNumChar, (WCHAR)'A', (WCHAR)'F')    ||
            isBetween(wcNumChar, (WCHAR)'a', (WCHAR)'f')    );
}

// Returns TRUE if buf points to a valid ipx net number (8 digit hex)
// Otherwise returns FALSE and puts a corrected version of the number 
// in pszCorrect.  pszCorrect will always contain the correct version.
BOOL IpxValidNetNumber(PWCHAR pszNum, PWCHAR pszCorrect) {
    BOOL cFlag = TRUE;
    int i, j=0, len = (int) wcslen(pszNum);

    // Validate the name
    if (len > 8) {
        lstrcpynW(pszCorrect, pszNum, 8);
        pszCorrect[8] = (WCHAR)0;
        return FALSE;
    }

    // Validate the characters
    for (i = 0; i < len; i++) {
        if (IpxValidNetNumberChar(pszNum[i]))
            pszCorrect[j++] = pszNum[i];
        else
            cFlag = FALSE;
    }
    pszCorrect[j] = (WCHAR)0;

    return cFlag;
}

// We subclass the ipx address text fields so that they don't
// allow bogus values to be typed.
LRESULT CALLBACK IpxNetNumProc (HWND hwnd,
                            UINT uMsg,
                            WPARAM wParam,
                            LPARAM lParam) {

    WNDPROC wProc = (WNDPROC) GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if (uMsg == WM_CHAR) {
        if ((wParam != VK_BACK) && (!IpxValidNetNumberChar((WCHAR)wParam)))
            return FALSE;
    }

    return CallWindowProc(wProc, hwnd, uMsg, wParam, lParam);
}

// Initializes the Ipx Properties Dialog
DWORD IpxInitDialog(HWND hwndDlg, LPARAM lParam) {
    WCHAR pszAddr[16];
    IPX_PARAMS * pIpxParams = (IPX_PARAMS *)(((PROT_EDIT_DATA*)lParam)->pbData);
    ULONG_PTR pOldWndProc;
    HWND hwndEdit;
                                                   
    // Store the parameters with the window handle
    SetWindowLongPtr(hwndDlg, GWLP_USERDATA, lParam);

    // Subclass the edit control(s)
    hwndEdit = GetDlgItem(hwndDlg, CID_NetTab_Ipxui_EB_Netnum);
    pOldWndProc = SetWindowLongPtr(hwndEdit, GWLP_WNDPROC, (LONG_PTR)IpxNetNumProc);
    SetWindowLongPtr(hwndEdit, GWLP_USERDATA, (LONG_PTR)pOldWndProc);
    
    // Set the network exposure check
    SendDlgItemMessage(hwndDlg, 
                       CID_NetTab_Ipxui_CB_ExposeNetwork,
                       BM_SETCHECK, 
                       (((PROT_EDIT_DATA*)lParam)->bExpose) ? BST_CHECKED : BST_UNCHECKED,
                       0);

    // Set the address assignmnet radio buttons
    SendDlgItemMessage(hwndDlg, 
                       CID_NetTab_Ipxui_RB_AutoAssign, 
                       BM_SETCHECK, 
                       (pIpxParams->bAutoAssign) ? BST_CHECKED : BST_UNCHECKED,
                       0);
    
    // Set the address assignmnet radio buttons
    SendDlgItemMessage(hwndDlg, 
                       CID_NetTab_Ipxui_RB_ManualAssign, 
                       BM_SETCHECK, 
                       (pIpxParams->bAutoAssign) ? BST_UNCHECKED : BST_CHECKED,
                       0);
    
    // Set the "allow caller to request an ipx node number" check
    SendDlgItemMessage(hwndDlg, 
                       CID_NetTab_Ipxui_CB_CallerSpec, 
                       BM_SETCHECK, 
                       (pIpxParams->bCaller) ? BST_CHECKED : BST_UNCHECKED,
                       0);

    // Set the global wan number check
    SendDlgItemMessage(hwndDlg, 
                       CID_NetTab_Ipxui_CB_AssignSame, 
                       BM_SETCHECK, 
                       (pIpxParams->bGlobalWan) ? BST_CHECKED : BST_UNCHECKED,
                       0);

    // Set the maximum amount of text that can be entered into the edit control
    SendDlgItemMessage(hwndDlg, CID_NetTab_Ipxui_EB_Netnum, EM_SETLIMITTEXT , 8, 0);
    
    // Set the text of the ip addresses
    wsprintfW(pszAddr, L"%x", pIpxParams->dwIpxAddress);
    SetDlgItemTextW(hwndDlg, CID_NetTab_Ipxui_EB_Netnum, pszAddr);

    // Enable/disable windows as per the settings
    IpxEnableWindows(hwndDlg, pIpxParams);
    IpxAdjustNetNumberLabel(hwndDlg, pIpxParams->bGlobalWan);

    return NO_ERROR;
}

// Gets the settings from the ui and puts them into 
// the ipx parameter structure.
DWORD IpxGetUISettings(HWND hwndDlg, PROT_EDIT_DATA * pEditData) {
    IPX_PARAMS * pIpxParams = (IPX_PARAMS *) pEditData->pbData;
    WCHAR pszAddr[10];
    GetDlgItemTextW(hwndDlg, CID_NetTab_Ipxui_EB_Netnum, pszAddr, 10);

    pIpxParams->dwIpxAddress = wcstoul(pszAddr, (WCHAR)NULL, 16);

    // A configuration that specificies a wan net pool begining with
    // zero or 0xffffffff is illegal.  Force the user to enter a 
    // valid config
    if ((!pIpxParams->bAutoAssign) &&
           ((pIpxParams->dwIpxAddress == 0x0) ||
            (pIpxParams->dwIpxAddress == 0xFFFFFFFF)))
    {
        IpxUiDisplayError(hwndDlg, ERR_IPX_BAD_POOL_CONFIG);
        return ERROR_CAN_NOT_COMPLETE;
    }

    pEditData->bExpose = SendDlgItemMessage(hwndDlg, CID_NetTab_Ipxui_CB_ExposeNetwork, BM_GETCHECK, 0, 0) == BST_CHECKED;

    return NO_ERROR;
}

// Dialog proc that governs the ipx settings dialog
INT_PTR CALLBACK IpxSettingsDialogProc (HWND hwndDlg,
                                        UINT uMsg,
                                        WPARAM wParam,
                                        LPARAM lParam) {
    switch (uMsg) {
        case WM_INITDIALOG:
            IpxInitDialog(hwndDlg, lParam);
            return FALSE;
        
        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            RasSrvHelp (hwndDlg, uMsg, wParam, lParam, phmIpxui);
            break;
        }

        case WM_DESTROY:                           
            // Cleanup the work done at WM_INITDIALOG 
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, 0);
            break;
        
        case WM_COMMAND:
            {
                IPX_PARAMS * pIpxParams = (IPX_PARAMS *)(((PROT_EDIT_DATA*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA))->pbData);
                switch (wParam) {
                    case IDOK:
                        if (IpxGetUISettings(hwndDlg, (PROT_EDIT_DATA*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA)) == NO_ERROR)
                            EndDialog(hwndDlg, 1);
                        break;
                    case IDCANCEL:
                        EndDialog(hwndDlg, 0);
                        break;
                    case CID_NetTab_Ipxui_RB_AutoAssign:
                        pIpxParams->bAutoAssign = TRUE;
                        IpxEnableWindows(hwndDlg, pIpxParams);
                        break;
                    case CID_NetTab_Ipxui_RB_ManualAssign:
                        pIpxParams->bAutoAssign = FALSE;
                        IpxEnableWindows(hwndDlg, pIpxParams);
                        break;
                    case CID_NetTab_Ipxui_CB_CallerSpec:
                        pIpxParams->bCaller = (BOOL)SendDlgItemMessage(hwndDlg, 
                                                                   CID_NetTab_Ipxui_CB_CallerSpec, 
                                                                   BM_GETCHECK, 
                                                                   0,
                                                                   0);
                        break;
                    case CID_NetTab_Ipxui_CB_AssignSame:
                        pIpxParams->bGlobalWan = (BOOL)SendDlgItemMessage(hwndDlg, 
                                                                   CID_NetTab_Ipxui_CB_AssignSame, 
                                                                   BM_GETCHECK, 
                                                                   0,
                                                                   0);
                        IpxAdjustNetNumberLabel(hwndDlg, pIpxParams->bGlobalWan);                                           
                        break;
                }
                // Adjust the values written to the ipx address edit control
                if (HIWORD(wParam) == EN_UPDATE) {
                    WCHAR wbuf[10], wcorrect[10];
                    POINT pt;
                    GetWindowTextW((HWND)lParam, wbuf, 10);
                    if (!IpxValidNetNumber(wbuf, wcorrect)) {
                        GetCaretPos(&pt);
                        SetWindowTextW((HWND)lParam, wcorrect);
                        SetCaretPos(pt.x, pt.y);
                    }
                }
                break;
            }
    }

    return FALSE;
}

// Edits tcp ip protocol properties
DWORD IpxEditProperties(HWND hwndParent, PROT_EDIT_DATA * pEditData, BOOL * pbCommit) {
    DWORD dwErr;
    int ret;

    // Popup the dialog box
    ret = (int) DialogBoxParam(Globals.hInstDll,
                             MAKEINTRESOURCE(DID_NetTab_Ipxui),
                             hwndParent,
                             IpxSettingsDialogProc,
                             (LPARAM)pEditData);
    if (ret == -1) {
        IpxUiDisplayError(hwndParent, ERR_IPX_CANT_DISPLAY);
    }

    // If ok was pressed, save off the new settings
    *pbCommit = FALSE;
    if (ret && ret != -1)
        *pbCommit = TRUE;

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\hnportmapping.h ===
/*
    File    hnportmapping.h

    Definition of the set port mapping functions for intergrating incoming
    connection with personal firewall, for whistler bug#123769

    Gang Zhao 11/6/2000
*/

#ifndef __rassrvui_hnportmapping_h
#define __rassrvui_hnportmapping_h

#include <windows.h>
#include <hnetcfg.h>


typedef struct {
    //An Array to store Connections of INetConnection * type
    //
    INetConnection  **      ConnArray;

    //Number of Connections found
    DWORD       ConnCount;

    //An Array to store connection properties
    //
    NETCON_PROPERTIES*      ConnPropTable;

    //Connection Manager used to generate another member EnumCon
    //
    INetConnectionManager*  ConnMan;

    //Connection Enumerator
    //
    IEnumNetConnection*     EnumCon;

    //Connection on which to Set Up PortMapping right now
    // pNetConnection and pGuid can both represent connections
    //but only one of them is used and valid for portmapping at each time
    //
    INetConnection    *     pNetConnection;

    //The Guid of the current connection on which to Set Up PortMapping right now
    //
    GUID *      pGuid;

    //Converted from pNetConnection, the PortMapping needs
    //the connection to be of type (IHNetConnection *)
    //In all, Enumerate Connection will return connections of
    // INetConnection * type, PortMapping operations require 
    //IHNetConnection * type
    //
    IHNetConnection   *     pHNetConn;

    //High level COM interface to generate pSettings
    //
    IHNetCfgMgr           * pHNetCfgMgr;

    //Used to generate pEnumPMP(PortMapping protocol enumerator)
    //
    IHNetProtocolSettings * pSettings;
    
    //PortMapping protocol enumerator, to enumerate existing
    //PortMapping protocols like (PPTP, L2TP, IKE (if exist)), FTP, ....
    //
    IEnumHNetPortMappingProtocols* pEnumPMP;


    //PortMapping Protocol for PPTP
    //
    IHNetPortMappingProtocol * pProtocolPPTP;

    //PortMapping Protocol for L2TP
    //
    IHNetPortMappingProtocol * pProtocolL2TP;
    
    //PortMapping Protocol for IKE
    //
    IHNetPortMappingProtocol * pProtocolIKE;

    //Title for PPTP, read from resource file
    //
    WCHAR * pwszTitlePPTP;

    //Title for L2TP, read from resource file
    //
    WCHAR * pwszTitleL2TP;

    //Title for IKE, read from resource file
    //
    WCHAR * pwszTitleIKE;

    //Title for PortMapping address, read from resource file
    //currently, it is always 127.0.0.1 loopback address
    //
    TCHAR * pszLoopbackAddr;

    //Indicating if COM is already initialized
    //
    BOOL fComInitialized;

    //Indicating if we need to do the COM un-initialization
    BOOL fCleanupOle;

} HNPMParams, * LPHNPMParams;


//Define callback function type for Pick Protocol 
typedef  DWORD (APIENTRY * PFNHNPMPICKPROTOCOL) ( LPHNPMParams, IHNetPortMappingProtocol* , WCHAR *, UCHAR, USHORT );


//When Using CoSetProxyBlanket, we should set both the interface 
//and the IUnknown interface queried from it
//
HRESULT
HnPMSetProxyBlanket (
    IUnknown* pUnk);


//Do the CoInitialize() COM if necessary
//Set up cleanup flag and initialized flag
//
DWORD
HnPMInit(
        IN OUT LPHNPMParams pInfo);

DWORD
HnPMCleanUp(
        IN OUT LPHNPMParams pInfo);

DWORD
HnPMParamsInitParameterCheck(
    IN  LPHNPMParams pInfo);

HnPMParamsInit(
    IN OUT  LPHNPMParams pInfo);

DWORD
HnPMParamsCleanUp(
    IN OUT  LPHNPMParams pInfo);

DWORD
HnPMCfgMgrInit(
        IN OUT LPHNPMParams pInfo);

DWORD
HnPMCfgMgrCleanUp(
        IN OUT LPHNPMParams pInfo);


DWORD
HnPMConnectionEnumInit(
    IN LPHNPMParams pInfo);

DWORD
HnPMConnectionEnumCleanUp(
    IN LPHNPMParams pInfo);

//Return all the connections like DUN, VPN, LAN and Incoming Connection
//and the properties of them
//
DWORD
HnPMConnectionEnum(
    IN LPHNPMParams pInfo);



DWORD
HnPMPickProtcolParameterCheck(
    IN LPHNPMParams pInfo);

//Pick PortMapping protocols: PPTP, L2TP, IKE
//
DWORD
HnPMPickProtocol(
    IN OUT LPHNPMParams pInfo,
    IN IHNetPortMappingProtocol * pProtocolTemp,
    IN WCHAR * pszwName,
    IN UCHAR   uchIPProtocol,
    IN USHORT  usPort );


DWORD
HnPMPProtoclEnumParameterCheck(
    IN LPHNPMParams pInfo);

//Enumerate all existing Port Mapping protocols
//
DWORD
HnPMProtocolEnum(
        IN OUT LPHNPMParams pInfo,
        IN PFNHNPMPICKPROTOCOL pfnPickProtocolCallBack
        );

DWORD
HnPMCreatePorotocolParameterCheck(
        IN LPHNPMParams pInfo);

//Create PortMapping Protocols for PPTP, L2TP, IKE
// if they are not found by HnPMPProtocolEnum()
//
DWORD
HnPMCreateProtocol(
        IN OUT LPHNPMParams pInfo);


//Set up a single PortMapping protocol on
//a single connection
//
DWORD
HnPMSetSinglePMForSingleConnection(
    IN  IHNetConnection * pHNetConn,
    IN  IHNetPortMappingProtocol * pProtocol,
    IN  TCHAR * pszLoopbackAddr,
    IN  BOOL fEnabled);


//Clean up the ConnArray and ConnPropTable items
//in the HNPMParams struct
//
DWORD
HnPMParamsConnectionCleanUp(
        IN OUT LPHNPMParams pInfo);


//Set up the PortMapping of PPTP, L2TP for a single
//Connection
//
DWORD
HnPMConfigureAllPMForSingleConnection(
        IN OUT LPHNPMParams pInfo,
        BOOL fEnabled);

DWORD
HnPMConfigureAllPMForSingleConnectionParameterCheck(
        IN OUT LPHNPMParams pInfo);

DWORD
HnPMConfigureSingleConnectionInitParameterCheck(
    IN LPHNPMParams pInfo );

DWORD
HnPMConfigureSingleConnectionInit(
    IN OUT  LPHNPMParams pInfo);

DWORD
HnPMConfigureSingleConnectionCleanUp(
        IN OUT LPHNPMParams pInfo);

//Set the PortMapping on a single connection
//According to pInfo->pNetConnection 
//
DWORD
HnPMConfigureSingleConnection(
        IN OUT LPHNPMParams pInfo,
        BOOL fEnabled);

//Delete the PortMapping protocols:PPTP, L2TP, IKE
//
DWORD
HnPMDeletePortMapping();

DWORD
HnPMDeletePortMappingInit(
        IN OUT LPHNPMParams pInfo);

DWORD
HnPMDeletePortMappingCleanUp(
        IN OUT LPHNPMParams pInfo);


DWORD
HnPMConfigureAllConnectionsInit(
        IN OUT LPHNPMParams pInfo);

DWORD
HnPMConfigureAllConnectionsCleanUp(
        IN OUT LPHNPMParams pInfo);

//
//Set up the PortMapping of PPTP, L2TP for a 
//group of Connections
//
DWORD
HnPMConfigureAllConnections( 
    IN BOOL fEnabled );


//Configure Port Mapping on a single connection
//
DWORD
HnPMConfigureSingleConnectionGUID(
    IN GUID * pGuid,
    IN BOOL fEnabled);


DWORD
HnPMConfigureSingleConnectionGUIDInit(
        IN OUT LPHNPMParams pInfo,
        GUID * pGuid);


DWORD
HnPMConfigureSingleConnectionGUIDCleanUp(
        IN OUT LPHNPMParams pInfo);


//Set up the port mapping for only one
//connection according to its GUID only when
//Incoming Connection exists and
//the VPN is enabled
//
DWORD
HnPMConfigureSingleConnectionGUIDIfVpnEnabled(
     GUID* pGuid,
     BOOL fDual,
     HANDLE hDatabase);

//Set up the port mapping on all connections
//only when Incoming Connection exists and
//the VPN is enabled
//
DWORD
HnPMConfigureIfVpnEnabled(
     BOOL fDual,
     HANDLE hDatabase);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\miscdb.c ===
/*
    File    Miscdb.c

    Implementation of the miscellaneous settings database.

    Paul Mayfield, 10/8/97
*/

#include "rassrv.h"
#include "miscdb.h"
#include <stdlib.h>

// ===================================
// Definitions of the database objects
// ===================================
#define FLAG_MULTILINK 1
#define FLAG_SHOWICON 2

typedef struct _RASSRV_MISCDB {
    BOOL bMultilinkEnabled;
    BOOL bShowIcons;
    BOOL bFlushOnClose;
    BOOL bIsServer;
    DWORD dwOrigFlags;
    DWORD dwLogLevel;
    BOOL bLogLevelDirty;
} RASSRV_MISCDB;

// Opens a handle to the database of general tab values
DWORD miscOpenDatabase(HANDLE * hMiscDatabase) {
    RASSRV_MISCDB * This;
    DWORD dwErr, i;
    
    if (!hMiscDatabase)
        return ERROR_INVALID_PARAMETER;

    // Allocate the database cache
    if ((This = RassrvAlloc (sizeof(RASSRV_MISCDB), TRUE)) == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    // Initialize the values from the system
    miscReloadDatabase((HANDLE)This);

    // Record the original flag state for efficiency
    This->dwOrigFlags = 0;
    if (This->bMultilinkEnabled)
        This->dwOrigFlags |= FLAG_MULTILINK;
    if (This->bShowIcons)
        This->dwOrigFlags |= FLAG_SHOWICON;

    // Return the handle
    *hMiscDatabase = (HANDLE)This;
    This->bFlushOnClose = FALSE;

    return NO_ERROR;
}

// Closes the general database and flushes any changes 
// to the system when bFlushOnClose is TRUE
DWORD miscCloseDatabase(HANDLE hMiscDatabase) {
    RASSRV_MISCDB * This = (RASSRV_MISCDB*)hMiscDatabase;
    
    // Flush if requested
    if (This->bFlushOnClose)
        miscFlushDatabase(hMiscDatabase);
    
    // Free up the database cache
    RassrvFree(This);

    return NO_ERROR;
}

BOOL miscFlagsAreSame(BOOL bVal, DWORD dwFlags, DWORD dwFlag) {
    if ((bVal != 0) && ((dwFlags & dwFlag) != 0))
        return TRUE;
    if ((bVal == 0) && ((dwFlags & dwFlag) == 0))
        return TRUE;
    return FALSE;
}


//for whistler bug 143344       gangz
//
DWORD
miscTrayNotifyIconChangeCleanUp(
        IN OUT LPHNPMParams pInfo)
{
    HnPMParamsConnectionCleanUp(pInfo);

    return NO_ERROR;
}//miscTrayNotifyIconChangeCleanUp()


//Notify that the "Show Icon in Notification area" has changed
//Used by GenCommand() in GenTab.c
//
DWORD
miscTrayNotifyIconChange()
{
    INetConnectionSysTray * pSysTray = NULL;
    HNPMParams Info;
    LPHNPMParams pInfo;
    HRESULT hr;
    DWORD dwErr = NO_ERROR, i;
    static const CLSID CLSID_InboundConnection=
    {0xBA126AD9,0x2166,0x11D1,{0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E}};


    TRACE("miscTrayNotifyIconChanged");

    ZeroMemory(&Info, sizeof(Info));
    pInfo = &Info;

    do{
        dwErr = HnPMConnectionEnum(pInfo);

        if ( NO_ERROR != dwErr )
        {
            TRACE("miscTrayNotifyIconChange: HnPMConnectionEnum failed!");
            break;
        }

        TRACE1("miscTrayNotifyIconChange: %l Connections detected", pInfo->ConnCount);

        //Set up PortMapping for each connection
        //
        for ( i = 0; i < pInfo->ConnCount; i++ )
        {
            //won't do PortMapping for Incoming connections
            //
            if ( pInfo->ConnPropTable )
            {
            //define the class id for Incoming connections
            // reference to /nt/net/config/shell/wanui/rasui.cpp

               if( IsEqualCLSID( 
                    &CLSID_InboundConnection, 
                    &(pInfo->ConnPropTable[i].clsidThisObject) ) )
               {
                    hr = INetConnection_QueryInterface(
                            pInfo->ConnArray[i],
                            &IID_INetConnectionSysTray,
                            &pSysTray);

                    ASSERT(pSysTray);

                    if ( !SUCCEEDED(hr))
                    {
                        TRACE("miscTrayNotifyIconChange: Query pSysTray failed!");
                        dwErr = ERROR_CAN_NOT_COMPLETE;
                        break;
                    }

                    if( !pSysTray )
                    {
                        TRACE("miscTrayNotifyIconChange: pSysTray get NULL pointer!");
                        dwErr = ERROR_CAN_NOT_COMPLETE;
                        break;
                    }

                    INetConnectionSysTray_IconStateChanged(pSysTray);
                    break;
               }
            }
        }//end of for(;;)

        if(pSysTray)
        {
            INetConnectionSysTray_Release(pSysTray);
        }

    }
    while(FALSE);

    miscTrayNotifyIconChangeCleanUp(pInfo);

    return dwErr;
}//end of miscTrayNotifyIconChange()


// Commits any changes made to the general tab values 
DWORD miscFlushDatabase(HANDLE hMiscDatabase) {
    RASSRV_MISCDB * This = (RASSRV_MISCDB*)hMiscDatabase;
    DWORD dwErr, dwRet = NO_ERROR;

    // Flush out the multilink value
    if (!miscFlagsAreSame(This->bMultilinkEnabled, This->dwOrigFlags,  FLAG_MULTILINK)) {
        dwErr = RasSrvSetMultilink(This->bMultilinkEnabled);
        if (dwErr != NO_ERROR) {
            DbgOutputTrace("miscFlushDatabase: Can't commit multilink 0x%08x", dwErr);
            dwRet = dwErr;
        }
    }

    // Flush the show icon setting
    if (!miscFlagsAreSame(This->bShowIcons, This->dwOrigFlags,  FLAG_SHOWICON)) 
    {
        DWORD dwErr = NO_ERROR;

        dwErr = RasSrvSetIconShow(This->bShowIcons);
        if (dwErr != NO_ERROR) {
            DbgOutputTrace("miscFlushDatabase: Can't commit show icons 0x%08x", dwErr);
            dwRet = dwErr;
        }

       //for whistler bug 143344    gangz
       //update the tray icon on the taskbar
       //This notification should be done after RasSrvSetIconShow()
       //
       dwErr = miscTrayNotifyIconChange();
        
       TRACE1("miscFlushDatabase: %s", NO_ERROR == dwErr ?
                                   "miscTrayNotifyIconChange succeeded!" :
                                   "miscTrayNotifyIconChange failed!");
    }

    // Flush the log level setting as appropriate
    if (This->bLogLevelDirty)
    {
        RasSrvSetLogLevel(This->dwLogLevel); 
    }

    return dwRet;
}

// Rollsback any changes made to the general tab values
DWORD miscRollbackDatabase(HANDLE hMiscDatabase) {
    RASSRV_MISCDB * This = (RASSRV_MISCDB*)hMiscDatabase;
    This->bFlushOnClose = FALSE;
    return NO_ERROR;
}

// Reloads any values for the general tab from disk
DWORD miscReloadDatabase(HANDLE hMiscDatabase) {
    RASSRV_MISCDB * This = (RASSRV_MISCDB*)hMiscDatabase;
    DWORD dwRet = NO_ERROR, dwErr, dwFlags = 0;

    // Initialize the product type
    dwErr = RasSrvGetMachineFlags (&dwFlags);
    if (dwErr != NO_ERROR) 
    {
        DbgOutputTrace("RasSrvGetMachineFlags: Failed %x", dwErr);
        dwRet = dwErr;
    }

    // Initialize what we can from the flags
    //
    This->bIsServer = !!(dwFlags & RASSRVUI_MACHINE_F_Server);

    // Initialize the show icons setting
    //
    dwErr = RasSrvGetIconShow(&This->bShowIcons);
    if (dwErr != NO_ERROR) 
    {
        DbgOutputTrace("miscReloadDatabase: Can't get iconshow 0x%08x", dwErr);
        dwRet = dwErr;
    }
    
    // Initialize multilink setting
    //
    dwErr = RasSrvGetMultilink(&(This->bMultilinkEnabled));
    if (dwErr != NO_ERROR) 
    {
        DbgOutputTrace("miscReloadDatabase: Can't get encryption 0x%08x", dwErr);
        dwRet = dwErr;
    }

    return dwRet;
}

// Gets the multilink enable status
DWORD miscGetMultilinkEnable(HANDLE hMiscDatabase, BOOL * pbEnabled) {
    RASSRV_MISCDB * This = (RASSRV_MISCDB*)hMiscDatabase;
    if (!This || !pbEnabled)
        return ERROR_INVALID_PARAMETER;
    
    if (!pbEnabled)
        return ERROR_INVALID_HANDLE;

    *pbEnabled = This->bMultilinkEnabled;

    return NO_ERROR;
}

// Sets the multilink enable status
DWORD miscSetMultilinkEnable(HANDLE hMiscDatabase, BOOL bEnable) {
    RASSRV_MISCDB * This = (RASSRV_MISCDB*)hMiscDatabase;
    if (!This)
        return ERROR_INVALID_PARAMETER;

    This->bMultilinkEnabled = bEnable;

    return NO_ERROR;
}

// Gets the enable status of the "Show icons in the task bar" check box
DWORD miscGetIconEnable(HANDLE hMiscDatabase, BOOL * pbEnabled) {
    RASSRV_MISCDB * This = (RASSRV_MISCDB*)hMiscDatabase;
    if (!This || !pbEnabled)
        return ERROR_INVALID_PARAMETER;

    *pbEnabled = This->bShowIcons;

    return NO_ERROR;
}

// Sets the enable status of the "Show icons in the task bar" check box
DWORD miscSetIconEnable(HANDLE hMiscDatabase, BOOL bEnable) {
    RASSRV_MISCDB * This = (RASSRV_MISCDB*)hMiscDatabase;
    if (!This)
        return ERROR_INVALID_PARAMETER;

    This->bShowIcons = bEnable;

    return NO_ERROR;
}

// Tells whether this is nt workstation or nt server
DWORD miscGetProductType(HANDLE hMiscDatabase, PBOOL pbIsServer) {
    RASSRV_MISCDB * This = (RASSRV_MISCDB*)hMiscDatabase;
    if (!This || !pbIsServer)
        return ERROR_INVALID_PARAMETER;

    *pbIsServer = This->bIsServer;

    return NO_ERROR;
}

// Turns on ras error and warning logging
DWORD 
miscSetRasLogLevel(
    IN HANDLE hMiscDatabase,
    IN DWORD dwLevel)
{
    RASSRV_MISCDB * This = (RASSRV_MISCDB*)hMiscDatabase;
    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    This->dwLogLevel = dwLevel;
    This->bLogLevelDirty = TRUE;

    return NO_ERROR;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\miscdb.h ===
/*
	File	miscdb

	The miscellaneous settings database definition for the dialup server ui.

	Paul Mayfield, 10/8/97
*/

#ifndef __miscdb_h
#define __miscdb_h

#include <windows.h>

#define MISCDB_RAS_LEVEL_ERR_AND_WARN 0x2

// Opens a handle to the database of devices
DWORD miscOpenDatabase(HANDLE * hMiscDatabase);

// Closes the general database and flushes any changes 
// to the system when bFlush is TRUE
DWORD miscCloseDatabase(HANDLE hMiscDatabase);

// Commits any changes made to the general tab values 
DWORD miscFlushDatabase(HANDLE hMiscDatabase);

// Rollsback any changes made to the general tab values
DWORD miscRollbackDatabase(HANDLE hMiscDatabase);

// Reloads any values for the general tab from disk
DWORD miscReloadDatabase(HANDLE hMiscDatabase);

// Gets the multilink enable status
DWORD miscGetMultilinkEnable(HANDLE hMiscDatabase, BOOL * pbEnabled);

// Sets the multilink enable status
DWORD miscSetMultilinkEnable(HANDLE hMiscDatabase, BOOL bEnable);

// Gets the enable status of the "Show icons in the task bar" check box
DWORD miscGetIconEnable(HANDLE hMiscDatabase, BOOL * pbEnabled);

// Sets the enable status of the "Show icons in the task bar" check box
DWORD miscSetIconEnable(HANDLE hMiscDatabase, BOOL bEnable);

// Tells whether this is nt workstation or nt server
DWORD miscGetProductType(HANDLE hMiscDatabase, PBOOL pbIsServer);

// Turns on ras error and warning logging
DWORD miscSetRasLogLevel(HANDLE hMiscDatabase, DWORD dwLevel);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\multilink.c ===
/*
    File    multilink.c

    Implements the multilink dialog display by the connections
    status monitor

    Paul Mayfield 10/17/97
*/

#include "rassrv.h"

#define MTL_TIMER_ID 1

typedef struct _MULTILINKDATA {
    HANDLE hConn;
    RAS_PORT_0 * pPorts;
    RAS_PORT_0 * pCurPort0;
    RAS_PORT_1 * pCurPort1;
    DWORD dwCurPort;
    DWORD dwPortCount;
} MULTILINKDATA;

// This dialog procedure responds to messages send to the 
// mtleral tab.
BOOL CALLBACK mtlUiDialogProc(HWND hwndDlg,
                              UINT uMsg,
                              WPARAM wParam,
                              LPARAM lParam);

// Fills in the property sheet structure with the information required to display
// the multilink tab.
DWORD mtlUiGetPropertyPage(LPPROPSHEETPAGE ppage, DWORD dwUserData) {
    MULTILINKDATA * mld;

    // Create the multilink data to send
    mld = (MULTILINKDATA*) malloc (sizeof (MULTILINKDATA));
    ZeroMemory(mld, sizeof(MULTILINKDATA));
    mld->hConn = (HANDLE)dwUserData;

    // Initialize
    ZeroMemory(ppage, sizeof(LPPROPSHEETPAGE));

    // Fill in the values
    ppage->dwSize      = sizeof(PROPSHEETPAGE);
    ppage->hInstance   = Globals.hInstDll;
    ppage->pszTemplate = MAKEINTRESOURCE(IDD_MULTILINKTAB);
    ppage->pfnDlgProc  = mtlUiDialogProc;
    ppage->pfnCallback = NULL;
    ppage->dwFlags     = 0;
    ppage->lParam      = (LPARAM)mld;

    return NO_ERROR;
}

// Error reporting
void mtlUiErrorMessageBox(HWND hwnd, DWORD err) {
    WCHAR buf[1024];
    FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM,NULL,err,(DWORD)NULL,buf,1024,NULL);
    MessageBoxW(hwnd, 
                buf, 
                L"Dialup Server Configuration Error", 
                MB_OK | MB_ICONERROR | MB_APPLMODAL);
}

// Formats an unsigned number with commas, etc.  
PWCHAR mtlFormatDword(DWORD dwVal) {
    static WCHAR ret[64];
    WCHAR num[64];
    int i = 0, tmp, j, k;

    if (dwVal == 0) {
        ret[0] = (WCHAR)'0';
        ret[1] = (WCHAR)0;
        return ret;
    }

    // Get the value in reverse order
    while (dwVal) {
        tmp = dwVal % 10;
        dwVal /= 10;
        num[i++] = (WCHAR)('0' + tmp);
    }
    num[i] = (WCHAR)0;
    
    // Add commas
    k = 0;
    for (j = 0; j < i; j++) {
        if (k%4 == 3)
            ret[k++] = (WCHAR)',';
        ret[k++] = num[j];
    }
    ret[k] = 0;
    k--;
        
    // reverse the string
    for (j=0; j < (k+1)/2; j++) {
        tmp = ret[j];
        ret[j] = ret[k-j];
        ret[k-j] = tmp;
    }

    return ret;
}

// Formats a string representing the time that a connection is connected
PWCHAR mtlFormatTime(DWORD dwSeconds) {
    DWORD dwSec, dwHr, dwMin;
    static WCHAR ret[16];

    dwSec = dwSeconds % 60;
    dwMin = dwSeconds / 60;
    dwHr  = dwSeconds / 3600;
    
    wsprintfW(ret, L"%02d:%02d:%02d", dwHr, dwMin, dwSec);

    return ret;
}

// Formats a string to display connection speed
PWCHAR mtlFormatSpeed(DWORD dwBps) {
    static WCHAR ret[64];

    wsprintfW(ret, L"%s bps", mtlFormatDword(dwBps));
    return ret;
}

// The list view control requires the list of icons it will display
// to be provided up front.  This function initializes and presents
// this list.
DWORD mtlUiInitializeListViewIcons(HWND hwndLV) {
    return NO_ERROR;
}

// Returns the index of an to display icon based on the type of incoming
// connection and whether or not it should be checked.
int mtlGetIconIndex(DWORD dwType, BOOL bEnabled) {
    if (bEnabled)
        return dwType + 1;
    return dwType;
}

// Fills in the user list view with the names of the users stored in the 
// user database provide.  Also, initializes the checked/unchecked status
// of each user.
DWORD mtlUiFillPortList(HWND hwndLV, MULTILINKDATA * mld) {
    LV_ITEM lvi;
    DWORD i, dwErr, dwType;
    char pszAName[1024];

    // Add the images that this list item will display
    dwErr = mtlUiInitializeListViewIcons(hwndLV);
    if (dwErr != NO_ERROR)
        return dwErr;

    // Initialize the list item
    ZeroMemory(&lvi, sizeof(LV_ITEM));
    lvi.mask = LVIF_TEXT;
    // lvi.mask = LVIF_TEXT | LVIF_IMAGE;

    // Looop through all of the users adding their names as we go
    for (i=0; i<mld->dwPortCount; i++) {
        //WideCharToMultiByte(CP_ACP,0,mld->pPorts[i].wszPortName,-1,pszAName,1024,NULL,NULL);
        lvi.iItem = i;
        //lvi.pszText = pszAName;
        lvi.pszText = mld->pPorts[i].wszPortName;
        //lvi.cchTextMax = strlen(pszAName) + 1;
        lvi.cchTextMax = wcslen(mld->pPorts[i].wszPortName) + 1;
        ListView_InsertItem(hwndLV,&lvi);
    }
    
    return NO_ERROR;
}

// Loads the current port
DWORD mtlLoadCurrentPort(MULTILINKDATA * mld) {
    DWORD dwErr;

    // Cleanup the old data
    if (mld->pCurPort0)
        MprAdminBufferFree(mld->pCurPort0);
    if (mld->pCurPort1)
        MprAdminBufferFree(mld->pCurPort1);

    dwErr = MprAdminPortGetInfo(Globals.hRasServer,
                                1,
                                mld->pPorts[mld->dwCurPort].hPort,
                                (LPBYTE*)&mld->pCurPort1);

    dwErr = MprAdminPortGetInfo(Globals.hRasServer,
                                0,
                                mld->pPorts[mld->dwCurPort].hPort,
                                (LPBYTE*)&mld->pCurPort0);

    return dwErr;
}

// Initializes the multilink data
DWORD mtlLoadPortData(MULTILINKDATA * mld, DWORD dwCur) {
    DWORD dwTot, dwErr;

    // Set the current port and load the data
    mld->dwCurPort = dwCur;

    // Cleanup
    if (mld->pPorts)
        MprAdminBufferFree(mld->pPorts);

    // Get the count of ports
    dwErr = MprAdminPortEnum (Globals.hRasServer, 
                              0, 
                              mld->hConn, 
                              (LPBYTE*)&mld->pPorts,
                              1024*1024,
                              &mld->dwPortCount,
                              &dwTot,
                              NULL);
    if (dwErr != NO_ERROR)
        return dwErr;

    if (mld->dwPortCount) {
        dwErr = mtlLoadCurrentPort(mld);
        if (dwErr != NO_ERROR) 
            return NO_ERROR;
    }

    return NO_ERROR;
}

// Updates the dialog with the current statistics stored in mld
DWORD mtlUpdateStats(HWND hwndDlg, MULTILINKDATA * mld) {
    WCHAR buf[128];
    DWORD dwErr = 0;

    // Mark the bytes in and out
    SetWindowTextW(GetDlgItem(hwndDlg, IDC_BYTESIN), mtlFormatDword(mld->pCurPort1->dwBytesRcved));
    SetWindowTextW(GetDlgItem(hwndDlg, IDC_BYTESOUT), mtlFormatDword(mld->pCurPort1->dwBytesXmited));

    // Mark the compression ratios
    wsprintfW(buf, L"%d%%", mld->pCurPort1->dwCompressionRatioIn);
    SetWindowTextW(GetDlgItem(hwndDlg, IDC_COMPIN), buf); 
    wsprintfW(buf, L"%d%%", mld->pCurPort1->dwCompressionRatioOut);
    SetWindowTextW(GetDlgItem(hwndDlg, IDC_COMPOUT), buf); 

    // Mark the errors
    dwErr = mld->pCurPort1->dwCrcErr +
            mld->pCurPort1->dwTimeoutErr +
            mld->pCurPort1->dwAlignmentErr +
            mld->pCurPort1->dwHardwareOverrunErr +
            mld->pCurPort1->dwFramingErr +
            mld->pCurPort1->dwBufferOverrunErr;
    wsprintfW(buf, L"%d", dwErr);
    SetWindowTextW(GetDlgItem(hwndDlg, IDC_ERRORIN), buf);
    SetWindowTextW(GetDlgItem(hwndDlg, IDC_ERROROUT), L"0");

    // Mark the duration
    SetWindowTextW(GetDlgItem(hwndDlg, IDC_DURATION), 
                   mtlFormatTime(mld->pCurPort0->dwConnectDuration));

    // Mark the speed
    SetWindowTextW(GetDlgItem(hwndDlg, IDC_SPEED), 
                   mtlFormatSpeed(mld->pCurPort1->dwLineSpeed));

    return NO_ERROR;
}

// Initializes the mtleral tab.  By now a handle to the mtleral database
// has been placed in the user data of the dialog
DWORD mtlUiInitializeDialog(HWND hwndDlg, WPARAM wParam, LPARAM lParam) {
    DWORD dwErr, dwCount;
    BOOL bFlag;
    HANDLE hConn, hMiscDatabase;
    HWND hwndLV;
    LV_COLUMN lvc;
    MULTILINKDATA * mld;
    LPPROPSHEETPAGE ppage;
 
    // Set the Timer
    SetTimer(hwndDlg, MTL_TIMER_ID, 500, NULL);

    // Set the data for this dialog
    ppage = (LPPROPSHEETPAGE)lParam;
    mld = (MULTILINKDATA*)(ppage->lParam);
    SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR)mld);

    // Initialize all of the values in the multilink data structure
    mtlLoadPortData(mld, 0);

    // Cause the list view to send LV_EXTENSION_??? messages and to do full
    // row select
    hwndLV = GetDlgItem(hwndDlg, IDC_PORTLIST);
    lvxExtend(hwndLV);
    ListView_SetExtendedListViewStyle(hwndLV, LVS_EX_FULLROWSELECT);

    // Fill in the list view will all available mtlices
    mtlUiFillPortList(hwndLV, mld);

    // Select the first item in the list view if any items exist
    dwCount = mld->dwPortCount;
    if (dwCount)
        ListView_SetItemState(hwndLV, 0, LVIS_SELECTED | LVIS_FOCUSED, 0xffffffff);

    // Add a colum so that we'll display in report view
    lvc.mask = LVCF_FMT;
    lvc.fmt = LVCFMT_LEFT;
    ListView_InsertColumn(hwndLV,0,&lvc);
    ListView_SetColumnWidth(hwndLV, 0, LVSCW_AUTOSIZE_USEHEADER);

    // Update the statistics
    mtlUpdateStats(hwndDlg, mld);

    return NO_ERROR;
}

// Updates the current port 
DWORD mtlUpdateCurPort(MULTILINKDATA * mld, DWORD dwNewPort) {
    mld->dwCurPort = dwNewPort;
    return mtlLoadCurrentPort(mld);
}

// Hangsup the current port
DWORD mtlHangup(HWND hwndDlg, MULTILINKDATA * mld) {
    DWORD dwErr;
    HWND hwndLV = GetDlgItem(hwndDlg, IDC_PORTLIST);

    if ((dwErr = MprAdminPortDisconnect(Globals.hRasServer, mld->pCurPort0->hPort)) != NO_ERROR)
        return dwErr;

    // There are no more ports if mtlLoadPortData returns an error
    if ((dwErr = mtlLoadPortData(mld, 0)) != NO_ERROR) 
        DestroyWindow(hwndDlg);
    else {
        ListView_DeleteAllItems(hwndLV);
        mtlUiFillPortList(hwndLV, mld);
        ListView_SetItemState(hwndLV, 0, LVIS_SELECTED | LVIS_FOCUSED, 0xffffffff);
        mtlUpdateStats(hwndDlg, mld);
    }

    return NO_ERROR;
}


// Cleansup the mtleral tab as it is being destroyed
DWORD mtlUiCleanupDialog(HWND hwndDlg, WPARAM wParam, LPARAM lParam) {
    // Cleanup the data
    MULTILINKDATA * mld = (MULTILINKDATA *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    if (mld) {
        if (mld->pCurPort0)
            MprAdminBufferFree(mld->pCurPort0);
        if (mld->pCurPort1)
            MprAdminBufferFree(mld->pCurPort1);
        if (mld)
            free(mld);
    }

    // Stop the timer
    KillTimer(hwndDlg, MTL_TIMER_ID);

    return NO_ERROR;
}

// This is the dialog procedure that responds to messages sent to the 
// mtleral tab.
BOOL CALLBACK mtlUiDialogProc(HWND hwndDlg,
                              UINT uMsg,
                              WPARAM wParam,
                              LPARAM lParam) {
    NMHDR* pNotifyData;
    NM_LISTVIEW* pLvNotifyData;
    LV_KEYDOWN* pLvKeyDown;
    MULTILINKDATA * mld = (MULTILINKDATA*) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

    // Process other messages as normal
    switch (uMsg) {
        case WM_INITDIALOG:
            return mtlUiInitializeDialog(hwndDlg, wParam, lParam);

        case WM_NOTIFY:
            pNotifyData = (NMHDR*)lParam;
            switch (pNotifyData->code) {
                // The property sheet apply button was pressed
                case PSN_APPLY:                    
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                    return TRUE;

                // The property sheet cancel was pressed
                case PSN_RESET:                    
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
                    break;

                // An item is changing state, keep track of any newly
                // selected item so space bar can toggle him.
                case LVN_ITEMCHANGING:
                    pLvNotifyData = (NM_LISTVIEW*)lParam;
                    if (pLvNotifyData->uNewState & LVIS_SELECTED) {
                        mtlUpdateCurPort(mld, pLvNotifyData->iItem);
                        mtlUpdateStats(hwndDlg, mld);
                    }
                    break;
            }
            break;

        // Called when the timer expires
        case WM_TIMER:
            mtlLoadCurrentPort(mld);
            mtlUpdateStats(hwndDlg, mld);
            break;

        // This is a custom message that we defined to toggle dialin permission
        // when the mouse is clicked on a user.
        case LV_EXTENSION_ITEMCLICKED:
        case LV_EXTENSION_ITEMDBLCLICKED:
            mtlUpdateCurPort(mld, wParam);
            mtlUpdateStats(hwndDlg, mld);
            break;

        case WM_COMMAND:
            if (wParam == IDC_HANGUP) 
                mtlHangup(hwndDlg, mld);
            break;

        // Cleanup the work done at WM_INITDIALOG 
        case WM_DESTROY:                           
            mtlUiCleanupDialog(hwndDlg, wParam, lParam);
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\multilink.h ===
/*
    File    multilink.h

    Definitions required to display the multilink page.

    Paul Mayfield, 10/17/97
*/

#ifndef __rassrvui_multilink_h
#define __rassrvui_multilink_h

#include <windows.h>
#include <prsht.h>

// Fills in the property sheet structure with the information required to display
// the multilink tab.
DWORD mtlUiGetPropertyPage(LPPROPSHEETPAGE ppage, DWORD dwUserData);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\netcfgdb.h ===
/*
    File    netcfgdb.h

    Implements a database abstraction on top of the net config
    items needed by the ras server ui for connections.

    Paul Mayfield, 12/15/97
*/

#ifndef _rassrvui_netcfg_h
#define _rassrvui_netcfg_h

//
// Network component types
//
#define NETCFGDB_SERVICE        0x1
#define NETCFGDB_CLIENT         0x2
#define NETCFGDB_PROTOCOL       0x4

//
// Identifiers for net components.
//
// These will be sorted in numerical order
// of these identifiers.
//
#define NETCFGDB_ID_IP          0x1
#define NETCFGDB_ID_IPX         0x2
#define NETCFGDB_ID_NETBUI      0x4
#define NETCFGDB_ID_ARAP        0x8
#define NETCFGDB_ID_FILEPRINT   0x10
#define NETCFGDB_ID_OTHER       0xf0000000

//
// Parameters that can be set for tcpip on the dialin
// server.
//
#define TCPIP_ADDR_LEN 20
typedef struct _TCPIP_PARAMS 
{
    DWORD dwPoolStart;  // Start ip addr of the static pool (host order)
    DWORD dwPoolEnd;    // End ip addr of the static pool (host order)
    BOOL bCaller;       // Whether caller can specify addr
    BOOL bUseDhcp;      // TRUE =  Use dhcp to assign addr
                        // FALSE = Use a pool to assign addr
} TCPIP_PARAMS;

// Parameters that can be set for Ipx on the dialin
// server.
//
typedef struct _IPX_PARAMS 
{
    DWORD dwIpxAddress;   // Beginning ipx address to allocate        
    BOOL bCaller;         // Whether to allow the caller to specify addr
    BOOL bAutoAssign;     // Whether to automatically assign node nums
    BOOL bGlobalWan;      // Whether to assign same net node to all clients
    
} IPX_PARAMS;

DWORD 
netDbOpen (
    OUT HANDLE * phNetCompDatabase, 
    IN  PWCHAR pszClientName);
    
DWORD 
netDbClose (
    IN HANDLE hNetCompDatabase);

DWORD 
netDbFlush (
    IN HANDLE hNetCompDatabase);
    
DWORD 
netDbLoad (
    IN HANDLE hNetCompDatabase);
    
DWORD 
netDbReload (
    IN HANDLE hNetCompDatabase);

DWORD
netDbReloadComponent (
    IN HANDLE hNetCompDatabase,
    IN DWORD dwComponentId);
    
DWORD 
netDbRollback (
    IN HANDLE hNetCompDatabase);

BOOL 
netDbIsLoaded(
    IN HANDLE hNetCompDatabase);

DWORD 
netDbGetCompCount(
    IN HANDLE hNetCompDatabase, 
    OUT LPDWORD lpdwCount);

DWORD 
netDbGetName(
    IN  HANDLE hNetCompDatabase, 
    IN  DWORD dwIndex, 
    OUT PWCHAR* pszName);

DWORD 
netDbGetDesc(
    IN  HANDLE hNetCompDatabase, 
    IN  DWORD dwIndex, 
    OUT PWCHAR* pszName);

DWORD 
netDbGetType(
    IN  HANDLE hNetCompDatabase, 
    IN  DWORD dwIndex, 
    OUT LPDWORD lpdwType);

DWORD
netDbGetId(
    IN  HANDLE hNetCompDatabase,
    IN  DWORD dwIndex,
    OUT LPDWORD lpdwId);

DWORD 
netDbGetEnable(
    IN  HANDLE hNetCompDatabase, 
    IN  DWORD dwIndex, 
    OUT PBOOL pbEnabled);

DWORD 
netDbSetEnable(
    IN HANDLE hNetCompDatabase, 
    IN DWORD dwIndex, 
    IN BOOL bEnabled);

DWORD 
netDbIsRasManipulatable(
    IN  HANDLE hNetCompDatabase, 
    IN  DWORD dwIndex, 
    OUT PBOOL pbManip);

//For whistler bug 347355
//
DWORD
netDbHasRemovePermission(
    IN HANDLE hNetCompDatabase,
    IN DWORD dwIndex,
    OUT PBOOL pbHasPermit);

DWORD 
netDbHasPropertiesUI(
    IN  HANDLE hNetCompDatabase, 
    IN  DWORD dwIndex, 
    OUT PBOOL pbHasUi);

DWORD 
netDbRaisePropertiesDialog(
    IN HANDLE hNetCompDatabase, 
    IN DWORD dwIndex, 
    IN HWND hwndParent);

DWORD 
netDbRaiseInstallDialog(
    IN HANDLE hNetCompDatabase, 
    IN HWND hwndParent);

DWORD 
netDbRaiseRemoveDialog(
    IN HANDLE hNetCompDatabase, 
    IN DWORD dwIndex, 
    IN HWND hwndParent);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\netcfgdb.c ===
/*
    File    netcfgdb.c

    Implements a database abstraction on top of the net config
    items needed by the ras server ui for connections.

    Paul Mayfield, 12/15/97
*/

#include <rassrv.h>
#include "protedit.h"

// Macro for bounds checking
#define netDbBoundsCheck(db, ind) (((ind) < (db)->dwCompCount) ? TRUE : FALSE)

//
// Defines function that sends pnp event through ndis
//
typedef
UINT
(* pNdisHandlePnpEventFunc)(
    IN      UINT                    Layer,
    IN      UINT                    Operation,
    IN      PUNICODE_STRING         LowerComponent,
    IN      PUNICODE_STRING         UpperComponent,
    IN      PUNICODE_STRING         BindList,
    IN      PVOID                   ReConfigBuffer,
    IN      UINT                    ReConfigBufferSize);

//
// Maps a protocol string to its integer id
//
typedef struct _COMP_MAPPING
{
    LPCTSTR pszId;
    DWORD   dwId;

} COMP_MAPPING;

//
// Defines attributes of a network component
//
typedef struct _RASSRV_NET_COMPONENT
{
    DWORD dwType;           // Is it client/service/protocol
    PWCHAR pszName;         // Display name
    PWCHAR pszDesc;         // Display description
    PWCHAR pszId;           // Id to destinguish which client/service, etc
    BOOL bManip;            // Whether is manipulatable by ras (ip, ipx, etc.)
    BOOL bHasUi;            // For whether has properties ui (non-manip only)
    INetCfgComponent * pINetCfgComp;

    // The following fields only apply to manipulatable
    // components (bManip == TRUE)
    //
    DWORD dwId;             // DWORD counterpart to pszId.
    BOOL bEnabled;          // whether it is enabled for dialin
    BOOL bEnabledOrig;      // original value of bEnabled (optimization)
    BOOL bExposes;          // whether it exposes the network its on
    LPBYTE pbData;          // pointer to protocol specific data
    BOOL bDataDirty;        // should the protocol specific data be flushed?

    //For whistler bug 347355
    //
    BOOL bRemovable;       //If this component removable //TCP/IP is not user removable
    
} RASSRV_NET_COMPONENT;

//
// Defines attributes of a network component database
//
typedef struct _RASSRV_COMPONENT_DB
{
    INetCfg * pINetCfg;
    BOOL bHasINetCfgLock;
    BOOL bInitCom;
    DWORD dwCompCount;
    BOOL bFlushOnClose;
    RASSRV_NET_COMPONENT ** pComps;
    PWCHAR pszClientName;
    INetConnectionUiUtilities * pNetConUtilities;

} RASSRV_COMPONENT_DB;

//
// Definitions of functions taken from ndis
//
const static WCHAR pszNdispnpLib[]  = L"ndispnp.dll";
const static CHAR  pszNidspnpFunc[] =  "NdisHandlePnPEvent";

// Parameters for the protocols
const static WCHAR pszRemoteAccessParamStub[]   =
    L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Parameters\\";
static WCHAR pszIpParams[]                      = L"Ip";
static WCHAR pszIpxParams[]                     = L"Ipx";
static WCHAR pszNetBuiParams[]                  = L"Nbf";
static WCHAR pszArapParams[]                    = L"AppleTalk";
static WCHAR pszShowNetworkToClients[]          = L"AllowNetworkAccess";
static WCHAR pszShowNetworkArap[]               = L"NetworkAccess";
static WCHAR pszEnableForDialin[]               = L"EnableIn";
static WCHAR pszIpPoolSubKey[]                  = L"\\StaticAddressPool\\0";

// Ip specific registry parameters
const static WCHAR pszIpFrom[]                  = L"From";
const static WCHAR pszIpTo[]                    = L"To";
const static WCHAR pszIpAddress[]               = L"IpAddress";
const static WCHAR pszIpMask[]                  = L"IpMask";
const static WCHAR pszIpClientSpec[]            = L"AllowClientIpAddresses";
const static WCHAR pszIpShowNetworkToClients[]  = L"AllowNetworkAccess";
const static WCHAR pszIpUseDhcp[]               = L"UseDhcpAddressing";

// Ipx specific registry paramters
const static WCHAR pszIpxAddress[]              = L"FirstWanNet";
const static WCHAR pszIpxClientSpec[]           = L"AcceptRemoteNodeNumber";
const static WCHAR pszIpxAutoAssign[]           = L"AutoWanNetAllocation";
const static WCHAR pszIpxAssignSame[]           = L"GlobalWanNet";

// Tcp specific registry parameters
const static WCHAR pszTcpipParamsKey[]
    = L"SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\";
const static WCHAR pszTcpEnableRouter[]         = L"IPEnableRouter";

const static WCHAR pszEmptyString[]             = L"";

//
// Initializes a unicode string
//
VOID SetUnicodeString (
        IN OUT UNICODE_STRING*  pustr,
        IN     LPCWSTR          psz )
{
    pustr->Buffer = (PWSTR)(psz);
    pustr->Length = (USHORT)(lstrlenW(pustr->Buffer) * sizeof(WCHAR));
    pustr->MaximumLength = pustr->Length + sizeof(WCHAR);
}

//
// Sets the expose property of a protocol
//
DWORD
protSetExpose(
    IN BOOL bExposes,
    IN DWORD dwId)
{
    PWCHAR pszProtocol = NULL, pszKey = NULL;
    PWCHAR pszAccess = pszShowNetworkToClients;
    DWORD dwErr;
    WCHAR pszProtKey[1024];

   bExposes = (bExposes) ? 1 : 0;

   // Base the registry location on the
   // id of the protocol
   switch (dwId)
   {
        case NETCFGDB_ID_IP:
            pszProtocol = (PWCHAR)pszIpParams;
            break;

        case NETCFGDB_ID_IPX:
            pszProtocol = (PWCHAR)pszIpxParams;
            break;

        case NETCFGDB_ID_NETBUI:
            pszProtocol = (PWCHAR)pszNetBuiParams;
            break;

        case NETCFGDB_ID_ARAP:
            pszProtocol = (PWCHAR)pszArapParams;
            pszAccess = (PWCHAR)pszShowNetworkArap;
            break;

        default:
            return ERROR_CAN_NOT_COMPLETE;
    }

    // Generate the registry key
    //
    wsprintfW(pszProtKey, L"%s%s", pszRemoteAccessParamStub, pszProtocol);
    if (! pszKey)
    {
        pszKey = pszProtKey;
    }

    // Set the value and return
    //
    dwErr = RassrvRegSetDw(bExposes, pszKey, pszAccess);

    return dwErr;
}

//
// Gets the expose property of a protocol
//
DWORD
protGetExpose(
    OUT BOOL* pbExposed,
    IN  DWORD dwId)
{
    PWCHAR pszProtocol = NULL, pszKey = NULL;
    PWCHAR pszAccess = pszShowNetworkToClients;
    DWORD dwErr;
    WCHAR pszProtKey[1024];

    switch (dwId)
    {
        case NETCFGDB_ID_IP:
            pszProtocol = (PWCHAR)pszIpParams;
            break;

        case NETCFGDB_ID_IPX:
            pszProtocol = (PWCHAR)pszIpxParams;
            break;

        case NETCFGDB_ID_NETBUI:
            pszProtocol = (PWCHAR)pszNetBuiParams;
            break;

        case NETCFGDB_ID_ARAP:
            pszProtocol = (PWCHAR)pszArapParams;
            pszAccess = (PWCHAR)pszShowNetworkArap;
            break;

        default:
            return ERROR_CAN_NOT_COMPLETE;
    }

    // Generate the registry key if needed
    if (! pszKey)
    {
        wsprintfW(
            pszProtKey,
            L"%s%s",
            pszRemoteAccessParamStub,
            pszProtocol);
        pszKey = pszProtKey;
    }

    // Get the value and return it
    dwErr = RassrvRegGetDw(pbExposed, TRUE, pszKey, pszAccess);

    return dwErr;
}

//
// Sets the enable property of a protocol
//
DWORD
protSetEnabling(
    IN BOOL bExposes,
    IN DWORD dwId)
{
    PWCHAR pszProtocol = NULL;
    DWORD dwErr;
    bExposes = (bExposes) ? 1 : 0;

    if (dwId == NETCFGDB_ID_IP)
    {
        pszProtocol = pszIpParams;
    }
    else if (dwId == NETCFGDB_ID_IPX)
    {
        pszProtocol = pszIpxParams;
    }
    else if (dwId == NETCFGDB_ID_NETBUI)
    {
        pszProtocol = pszNetBuiParams;
    }
    else if (dwId == NETCFGDB_ID_ARAP)
    {
        pszProtocol = pszArapParams;
    }

    if (pszProtocol)
    {
        WCHAR pszProtKey[512];

        wsprintfW(
            pszProtKey,
            L"%s%s",
            pszRemoteAccessParamStub,
            pszProtocol);

        dwErr = RassrvRegSetDw(bExposes, pszProtKey, pszEnableForDialin);
        if (dwErr != NO_ERROR)
        {
            DbgOutputTrace(
                "protSetEnabling: Failed for %S:  0x%08x",
                pszProtocol,
                dwErr);
        }

        return dwErr;
    }

    return ERROR_CAN_NOT_COMPLETE;
}

//
// Gets the Enabling property of a protocol
//
DWORD
protGetEnabling(
    OUT BOOL* pbExposed,
    IN  DWORD dwId)
{
    PWCHAR pszProtocol = NULL;
    DWORD dwErr;

    if (dwId == NETCFGDB_ID_IP)
    {
        pszProtocol = pszIpParams;
    }
    else if (dwId == NETCFGDB_ID_IPX)
    {
        pszProtocol = pszIpxParams;
    }
    else if (dwId == NETCFGDB_ID_NETBUI)
    {
        pszProtocol = pszNetBuiParams;
    }
    else if (dwId == NETCFGDB_ID_ARAP)
    {
        pszProtocol = pszArapParams;
    }

    if (pszProtocol)
    {
        WCHAR pszProtKey[512];

        wsprintfW(
            pszProtKey,
            L"%s%s",
            pszRemoteAccessParamStub,
            pszProtocol);

        dwErr = RassrvRegGetDw(
                    pbExposed,
                    TRUE,
                    pszProtKey,
                    pszEnableForDialin);
        if (dwErr != NO_ERROR)
        {
            DbgOutputTrace(
                "protGetEnabling: Failed for %S:  0x%08x",
                pszProtocol,
                dwErr);
        }

        return dwErr;
    }

    return ERROR_CAN_NOT_COMPLETE;
}

//
// Saves the enabling of a service out to the
// system.
//
DWORD
svcSetEnabling(
    IN RASSRV_NET_COMPONENT* pComp)
{
    HANDLE hService = NULL;
    DWORD dwErr = NO_ERROR;

    do
    {
        // Or enable the component
        //
        if (pComp->bEnabled)
        {
            if (pComp->dwId == NETCFGDB_ID_FILEPRINT)
            {
                // Start the service
                //
                dwErr = SvcOpenServer(&hService);
                if (dwErr != NO_ERROR)
                {
                    break;
                }
                dwErr = SvcStart(hService, 10);
                if (dwErr != NO_ERROR)
                {
                    break;
                }
            }
        }

    } while (FALSE);

    // Cleanup
    {
        if (hService)
        {
            SvcClose(hService);
        }
    }

    return dwErr;
}

//
// Gets the enabling property of a service
//
DWORD
svcGetEnabling(
    OUT BOOL* pbExposed,
    IN  DWORD dwId)
{
    HANDLE hService = NULL;
    DWORD dwErr = NO_ERROR;

    do
    {
        dwErr = SvcOpenServer(&hService);
        if (dwErr != NO_ERROR)
        {
            break;
        }
        dwErr = SvcIsStarted(hService, pbExposed);
        if (dwErr != NO_ERROR)
        {
            break;
        }

    } while (FALSE);

    // Cleanup
    {
        if (hService)
        {
            SvcClose(hService);
        }
    }

    return dwErr;
}

//
// Loads the tcpip parameters from the system
//
DWORD
TcpipLoadParamsFromSystem(
    OUT TCPIP_PARAMS *pTcpipParams)
{
    WCHAR buf[256], pszKey[512];
    DWORD dwRet = NO_ERROR, dwErr;
    DWORD dwNet = 0, dwMask = 0;

    wsprintfW(pszKey, L"%s%s", pszRemoteAccessParamStub, pszIpParams);

    // Load the params from the various registry locations.
    dwErr = RassrvRegGetDw(
                &pTcpipParams->bUseDhcp,
                TRUE,
                pszKey,
                (const PWCHAR)pszIpUseDhcp);
    if (dwErr != NO_ERROR)
    {
        DbgOutputTrace("TcpipLoad: dhcp fail 0x%08x", dwErr);
        dwRet = dwErr;
    }

    dwErr = RassrvRegGetDw(
                &pTcpipParams->bCaller,
                TRUE,
                pszKey,
                (const PWCHAR)pszIpClientSpec);
    if (dwErr != NO_ERROR)
    {
        DbgOutputTrace("TcpipLoad: clientspec fail 0x%08x", dwErr);
        dwRet = dwErr;
    }

    // Read in the "legacy" pool values (w2k RC1, w2k Beta3)
    //
    {
        WCHAR pszNet[256]=L"0.0.0.0", pszMask[256]=L"0.0.0.0";
        
        RassrvRegGetStr(
            pszNet,
            L"0.0.0.0",
            pszKey,
            (PWCHAR)pszIpAddress);
            
        RassrvRegGetStr(
            pszMask,
            L"0.0.0.0",
            pszKey,
            (PWCHAR)pszIpMask);

        dwNet = IpPszToHostAddr(pszNet);
        dwMask = IpPszToHostAddr(pszMask);
    }

    // Generate the path the the new registry values
    //
    wcscat(pszKey, pszIpPoolSubKey);

    // See if new info is stored by reading the "from"
    // value
    //
    dwErr = RassrvRegGetDwEx(
                &pTcpipParams->dwPoolStart,
                0,
                pszKey,
                (const PWCHAR)pszIpFrom,
                FALSE);

    // There is new info in the registry -- use it
    //
    if (dwErr == ERROR_SUCCESS)
    {
        // Read in the "to" value
        //
        dwErr = RassrvRegGetDwEx(
                    &pTcpipParams->dwPoolEnd,
                    0,
                    pszKey,
                    (const PWCHAR)pszIpTo,
                    FALSE);
        if (dwErr != NO_ERROR)
        {
            DbgOutputTrace("TcpipLoad: mask fail 0x%08x", dwErr);
            dwRet = dwErr;
        }
    }

    // There is not new data in the new section -- use legacy
    // values
    //
    else if (dwErr == ERROR_FILE_NOT_FOUND)
    {
        pTcpipParams->dwPoolStart = dwNet;
        pTcpipParams->dwPoolEnd = (dwNet + ~dwMask);
    }

    // An unexpected error occured
    //
    else if (dwErr != NO_ERROR)
    {
        DbgOutputTrace("TcpipLoad: pool fail 0x%08x", dwErr);
        dwRet = dwErr;
    }

    return dwRet;
}

//
// Commits the given tcpip parameters to the system.
//
DWORD
TcpipSaveParamsToSystem(
    IN TCPIP_PARAMS * pTcpipParams)
{
    WCHAR pszKey[512];
    DWORD dwRet = NO_ERROR, dwErr;

    wsprintfW(pszKey, L"%s%s", pszRemoteAccessParamStub, pszIpParams);

    // Load the params from the various registry locations.
    dwErr = RassrvRegSetDw(
                pTcpipParams->bUseDhcp,
                pszKey,
                (const PWCHAR)pszIpUseDhcp);
    if (dwErr != NO_ERROR)
    {
        DbgOutputTrace("TcpipSave: dhcp fail 0x%08x", dwErr);
        dwRet = dwErr;
    }

    dwErr = RassrvRegSetDw(
                pTcpipParams->bCaller,
                pszKey,
                (const PWCHAR)pszIpClientSpec);
    if (dwErr != NO_ERROR)
    {
        DbgOutputTrace("TcpipSave: callerspec fail 0x%08x", dwErr);
        dwRet = dwErr;
    }

    wcscat(pszKey, pszIpPoolSubKey);

    dwErr = RassrvRegSetDwEx(
                pTcpipParams->dwPoolStart,
                pszKey,
                (const PWCHAR)pszIpFrom,
                TRUE);
    if (dwErr != NO_ERROR)
    {
        DbgOutputTrace("TcpipSave: from fail 0x%08x", dwErr);
        dwRet = dwErr;
    }

    dwErr = RassrvRegSetDwEx(
                pTcpipParams->dwPoolEnd,
                pszKey,
                (const PWCHAR)pszIpTo,
                TRUE);
    if (dwErr != NO_ERROR)
    {
        DbgOutputTrace("TcpipSave: to fail 0x%08x", dwErr);
        dwRet = dwErr;
    }

    return dwRet;
}

//
// Loads the ipx parameters from the system
//
DWORD
IpxLoadParamsFromSystem(
    OUT IPX_PARAMS *pIpxParams)
{
    WCHAR pszKey[512];
    DWORD dwRet = NO_ERROR, dwErr;

    wsprintfW(pszKey, L"%s%s", pszRemoteAccessParamStub, pszIpxParams);

    // Load the params from the various registry locations.
    dwErr = RassrvRegGetDw(
                &pIpxParams->bAutoAssign,
                TRUE,
                pszKey,
                (const PWCHAR)pszIpxAutoAssign);
    if (dwErr != NO_ERROR)
    {
        DbgOutputTrace("IpxLoad: auto-assign fail 0x%08x", dwErr);
        dwRet = dwErr;
    }

    dwErr = RassrvRegGetDw(
                &pIpxParams->bCaller,
                TRUE,
                pszKey,
                (const PWCHAR)pszIpxClientSpec);
    if (dwErr != NO_ERROR)
    {
        DbgOutputTrace("IpxLoad: client-spec fail 0x%08x", dwErr);
        dwRet = dwErr;
    }

    dwErr = RassrvRegGetDw(
                &pIpxParams->dwIpxAddress,
                0,
                pszKey,
                (const PWCHAR)pszIpxAddress);
    if (dwErr != NO_ERROR)
    {
        DbgOutputTrace("IpxLoad: address fail 0x%08x", dwErr);
        dwRet = dwErr;
    }

    dwErr = RassrvRegGetDw(
                &pIpxParams->bGlobalWan,
                0,
                pszKey,
                (const PWCHAR)pszIpxAssignSame);
    if (dwErr != NO_ERROR)
    {
        DbgOutputTrace("IpxLoad: same-addr fail 0x%08x", dwErr);
        dwRet = dwErr;
    }

    return dwRet;
}

//
// Commits the given ipx parameters to the system.
//
DWORD
IpxSaveParamsToSystem(
    IN IPX_PARAMS * pIpxParams)
{
    WCHAR pszKey[512];
    DWORD dwRet = NO_ERROR, dwErr;

    wsprintfW(pszKey, L"%s%s", pszRemoteAccessParamStub, pszIpxParams);

    // Save params to the various registry locations.
    dwErr = RassrvRegSetDw(
                pIpxParams->bAutoAssign,
                pszKey,
                (const PWCHAR)pszIpxAutoAssign);
    if (dwErr != NO_ERROR)
    {
        DbgOutputTrace("IpxSave: auto-addr save 0x%08x", dwErr);
        dwRet = dwErr;
    }

    dwErr = RassrvRegSetDw(
                pIpxParams->bCaller,
                pszKey,
                (const PWCHAR)pszIpxClientSpec);
    if (dwErr != NO_ERROR)
    {
        DbgOutputTrace("IpxSave: client-spec fail 0x%08x", dwErr);
        dwRet = dwErr;
    }

    dwErr = RassrvRegSetDw(
                pIpxParams->dwIpxAddress,
                pszKey,
                (const PWCHAR)pszIpxAddress);
    if (dwErr != NO_ERROR)
    {
        DbgOutputTrace("IpxSave: addr save 0x%08x", dwErr);
        dwRet = dwErr;
    }

    dwErr = RassrvRegSetDw(
                pIpxParams->bGlobalWan,
                pszKey,
                (const PWCHAR)pszIpxAssignSame);
    if (dwErr != NO_ERROR)
    {
        DbgOutputTrace("IpxSave: assign-same fail 0x%08x", dwErr);
        dwRet = dwErr;
    }

    return dwRet;
}

//
// Dialog procedure that handles the editing of generic protocol
// information. Dialog proc that governs the ipx settings dialog
//
INT_PTR
CALLBACK
GenericProtSettingsDialogProc (
    IN HWND hwndDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            PROT_EDIT_DATA* pEditData = ((PROT_EDIT_DATA*)lParam);

            // Set the network exposure check
            SendDlgItemMessage(
                hwndDlg,
                CID_NetTab_GenProt_CB_ExposeNetwork,
                BM_SETCHECK,
                (pEditData->bExpose) ? BST_CHECKED : BST_UNCHECKED,
                0);
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, lParam);
            return FALSE;
        }
        break;

        case WM_DESTROY:
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, 0);
            break;

        case WM_COMMAND:
            {
                PROT_EDIT_DATA * pEditData = (PROT_EDIT_DATA*)
                    GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

                switch (wParam)
                {
                    case IDOK:
                        pEditData->bExpose =
                            SendDlgItemMessage(
                                hwndDlg,
                                CID_NetTab_GenProt_CB_ExposeNetwork,
                                BM_GETCHECK,
                                0,
                                0) == BST_CHECKED;
                        EndDialog(hwndDlg, 1);
                        break;

                    case IDCANCEL:
                        EndDialog(hwndDlg, 0);
                        break;
                }
            }
            break;
    }

    return FALSE;
}

//
// Function edits the properties of a generic protocol,
// that is a protocol that has no ras-specific properties.
//
DWORD
GenericProtocolEditProperties(
    IN HWND hwndParent,
    IN OUT PROT_EDIT_DATA * pEditData,
    IN OUT BOOL * pbCommit)
{
    DWORD dwErr;
    INT_PTR iRet;

    // Popup the dialog box
    iRet = DialogBoxParam(
            Globals.hInstDll,
            MAKEINTRESOURCE(DID_NetTab_GenProt),
            hwndParent,
            GenericProtSettingsDialogProc,
            (LPARAM)pEditData);

    // If ok was pressed, save off the new settings
    *pbCommit = FALSE;
    if ( (iRet) && (iRet != -1) )
    {
        *pbCommit = TRUE;
    }

    return NO_ERROR;
}

//
// Releases resources reserved by this
// network component database.
//
DWORD
netDbCleanup(
    RASSRV_COMPONENT_DB* This)
{
    DWORD i, dwCount;

    // Free all of the strings
    if (This->pComps)
    {
        for (i = 0; i < This->dwCompCount; i++)
        {
            if (This->pComps[i])
            {
                if (This->pComps[i]->pINetCfgComp)
                {
                    dwCount = INetCfgComponent_Release(
                                This->pComps[i]->pINetCfgComp);
                                
                    DbgOutputTrace(
                        "netDbCleanup: %ls ref=%x", 
                        This->pComps[i]->pszId,
                        dwCount);
                }
                if (This->pComps[i]->pszName)
                {
                    CoTaskMemFree(This->pComps[i]->pszName);
                }
                if (This->pComps[i]->pszDesc)
                {
                    CoTaskMemFree(This->pComps[i]->pszDesc);
                }
                if (This->pComps[i]->pszId)
                {
                    CoTaskMemFree(This->pComps[i]->pszId);
                }
                RassrvFree(This->pComps[i]);
            }
        }
        RassrvFree(This->pComps);
    }

    // Reset all of the values
    This->dwCompCount = 0;
    This->pComps = 0;

    return NO_ERROR;
}

//
// Loads in the netshell library which is responsible for adding
// and removing network components
//
DWORD
netDbLoadNetShell (
    RASSRV_COMPONENT_DB* This)
{
    if (!This->pNetConUtilities)
    {
        HRESULT hr;

        hr = HrCreateNetConnectionUtilities(&This->pNetConUtilities);
        if (FAILED(hr))
        {
            DbgOutputTrace("LoadNetShell: loadlib fial 0x%08x", hr);
        }
    }

    return NO_ERROR;
}

//
// Loads protocol specific info for a ras-manipulatable protocol.  This
// function assumes that the component passed in is a ras-manipulatable
// component. (tcpip, ipx, nbf, arap)
//
DWORD
netDbLoadProtcolInfo(
    IN OUT RASSRV_NET_COMPONENT * pNetComp)
{
    LPBYTE pbData;

    // Initialize the dirty bit and the data
    pNetComp->bDataDirty = FALSE;
    pNetComp->pbData = NULL;

    // Get the enabled and exposed properties
    protGetEnabling(&(pNetComp->bEnabled), pNetComp->dwId);
    protGetExpose(&(pNetComp->bExposes), pNetComp->dwId);
    pNetComp->bEnabledOrig = pNetComp->bEnabled;

    // Load protocol specific data
    //
    switch (pNetComp->dwId)
    {
        case NETCFGDB_ID_IP:
            pNetComp->pbData = RassrvAlloc(sizeof(TCPIP_PARAMS), TRUE);
            if (pNetComp->pbData == NULL)
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }
            TcpipLoadParamsFromSystem((TCPIP_PARAMS*)(pNetComp->pbData));
            break;

        case NETCFGDB_ID_IPX:
            pNetComp->pbData = RassrvAlloc(sizeof(IPX_PARAMS), TRUE);
            if (pNetComp->pbData == NULL)
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }
            IpxLoadParamsFromSystem((IPX_PARAMS*)(pNetComp->pbData));
            break;
    }

    return NO_ERROR;
}

//
// Loads service specific info for a ras-manipulatable service.  This
// function assumes that the component passed in is a ras-manipulatable
// component.
//
DWORD
netDbLoadServiceInfo(
    IN OUT RASSRV_NET_COMPONENT * pNetComp)
{
    // Get the enabled property
    //
    svcGetEnabling(&(pNetComp->bEnabled), pNetComp->dwId);
    pNetComp->bEnabledOrig = pNetComp->bEnabled;

    return NO_ERROR;
}

//
// Returns the protol id of the given component
//
DWORD
netDbLoadCompId (
    IN OUT RASSRV_NET_COMPONENT * pNetComp)
{
    DWORD i;
    static const COMP_MAPPING pManipCompMap [] =
    {
        { NETCFG_TRANS_CID_MS_TCPIP,     NETCFGDB_ID_IP },
        { NETCFG_TRANS_CID_MS_NWIPX,     NETCFGDB_ID_IPX },
        { NETCFG_TRANS_CID_MS_NETBEUI,   NETCFGDB_ID_NETBUI },
        { NETCFG_TRANS_CID_MS_APPLETALK, NETCFGDB_ID_ARAP },
        { NETCFG_SERVICE_CID_MS_SERVER,  NETCFGDB_ID_FILEPRINT }
    };

    // See if the id matches any of the protocols that we manage.
    //
    pNetComp->dwId = NETCFGDB_ID_OTHER;
    for (i = 0; i < sizeof(pManipCompMap)/sizeof(*pManipCompMap); i++)
    {
        if (lstrcmpi(pNetComp->pszId, pManipCompMap[i].pszId) == 0)
        {
            pNetComp->dwId = pManipCompMap[i].dwId;
            break;
        }
    }

    return pNetComp->dwId;
}

//
// Returns TRUE if this iNetCfg component is not hidden and if
// it successfully yeilds it's information.
//
BOOL
netDbGetCompInfo(
    IN INetCfgComponent * pComponent,
    IN OUT RASSRV_NET_COMPONENT * pNetComp,
    IN RASSRV_COMPONENT_DB * pCompDb )
{
    DWORD dwCharacter;
    GUID Guid;
    HRESULT hr = S_OK, hr2;

    // Make sure that this is not a "hidden" component
    //
    hr = INetCfgComponent_GetCharacteristics (pComponent, &dwCharacter);
    if ( (FAILED(hr)) || (dwCharacter & NCF_HIDDEN) )
    {
        return FALSE;
    }

    // Get the display name
    hr = INetCfgComponent_GetDisplayName (pComponent, &pNetComp->pszName);
    if (FAILED(hr))
    {
        return FALSE;
    }

    // Assign the has properties value
    pNetComp->bHasUi = !!(dwCharacter & NCF_HAS_UI);

    // pmay: 323274
    //
    // Make sure that the component can display properties without
    // a context if it claims to support displaying properties.
    //
    if (pNetComp->bHasUi)
    {
        hr2 = INetCfgComponent_RaisePropertyUi(
                    pComponent,
                    GetActiveWindow(),
                    NCRP_QUERY_PROPERTY_UI,
                    NULL);
        pNetComp->bHasUi = !!(hr2 == S_OK);
    }
    
    // Load the rest of the props
    if (FAILED(INetCfgComponent_GetClassGuid (pComponent, &Guid))         ||
        FAILED(INetCfgComponent_GetId (pComponent, &pNetComp->pszId))     ||
        FAILED(INetCfgComponent_GetHelpText(pComponent, &pNetComp->pszDesc))
       )
    {
        DbgOutputTrace("GetCompInfo: fail %S", pNetComp->pszName);
        return FALSE;
    }

    // Assign the type
    if (memcmp(&Guid, &GUID_DEVCLASS_NETCLIENT, sizeof(GUID)) == 0)
    {
        pNetComp->dwType = NETCFGDB_CLIENT;
    }
    else if (memcmp(&Guid, &GUID_DEVCLASS_NETSERVICE, sizeof(GUID)) == 0)
    {
        pNetComp->dwType = NETCFGDB_SERVICE;
    }
    else
    {
        pNetComp->dwType = NETCFGDB_PROTOCOL;
    }

    // If this is a protocol that ras server can manipulate,
    // initailize its additional fields here.
    pNetComp->dwId = netDbLoadCompId(pNetComp);
    if (pNetComp->dwId != NETCFGDB_ID_OTHER)
    {
        if (pNetComp->dwType == NETCFGDB_PROTOCOL)
        {
            netDbLoadProtcolInfo(pNetComp);
        }
        else if (pNetComp->dwType == NETCFGDB_SERVICE)
        {
            netDbLoadServiceInfo(pNetComp);
        }

        pNetComp->bManip = TRUE;
    }

    // Assign the inetcfg component
    pNetComp->pINetCfgComp = pComponent;
    INetCfgComponent_AddRef(pComponent);

    //For whistler bug  347355
    //
    {
        BOOL fEnableRemove=FALSE;
        DWORD dwFlags;
        HRESULT hr;
      
        fEnableRemove = INetConnectionUiUtilities_UserHasPermission(
                                       pCompDb->pNetConUtilities,
                                       NCPERM_AddRemoveComponents);

        hr = INetCfgComponent_GetCharacteristics(pComponent, &dwFlags );
        if( SUCCEEDED(hr) && (NCF_NOT_USER_REMOVABLE & dwFlags) )
        {
            fEnableRemove = FALSE;
        }

        pNetComp->bRemovable = fEnableRemove;
    }

    return TRUE;
}

//
// Raise the ui for a ras-manipulatable protocol
//
DWORD
netDbRaiseRasProps(
    IN RASSRV_NET_COMPONENT * pNetComp,
    IN HWND hwndParent)
{
    PROT_EDIT_DATA ProtEditData;
    TCPIP_PARAMS TcpParams;
    IPX_PARAMS IpxParams;
    BOOL bOk;
    DWORD dwErr;

    // Initialize the protocol data properties structure
    //
    ProtEditData.bExpose = pNetComp->bExposes;
    ProtEditData.pbData = NULL;

    // Launch the appropriate ui
    switch (pNetComp->dwId)
    {
        case NETCFGDB_ID_IP:
            CopyMemory(&TcpParams, pNetComp->pbData, sizeof(TCPIP_PARAMS));
            ProtEditData.pbData = (LPBYTE)(&TcpParams);
            dwErr = TcpipEditProperties(hwndParent, &ProtEditData, &bOk);
            if (dwErr != NO_ERROR)
            {
                return dwErr;
            }
            if (bOk)
            {
                pNetComp->bDataDirty = TRUE;
                CopyMemory(
                    pNetComp->pbData,
                    &TcpParams,
                    sizeof(TCPIP_PARAMS));
                pNetComp->bExposes = ProtEditData.bExpose;;
            }
            break;

        case NETCFGDB_ID_IPX:
            CopyMemory(&IpxParams, pNetComp->pbData, sizeof(IPX_PARAMS));
            ProtEditData.pbData = (LPBYTE)(&IpxParams);
            dwErr = IpxEditProperties(hwndParent, &ProtEditData, &bOk);
            if (dwErr != NO_ERROR)
            {
                return dwErr;
            }
            if (bOk)
            {
                pNetComp->bDataDirty = TRUE;
                CopyMemory(pNetComp->pbData, &IpxParams, sizeof(IPX_PARAMS));
                pNetComp->bExposes = ProtEditData.bExpose;;
            }
            break;

        default:
            dwErr = GenericProtocolEditProperties(
                        hwndParent,
                        &ProtEditData,
                        &bOk);
            if (dwErr != NO_ERROR)
            {
                return dwErr;
            }
            if (bOk)
            {
                pNetComp->bDataDirty = TRUE;
                pNetComp->bExposes = ProtEditData.bExpose;;
            }
            break;
    }

    return NO_ERROR;
}

//
// Comparison function used to sort the network components
// It's easier to implement here rather than the UI
//
int
__cdecl
netDbCompare (
    CONST VOID* pElem1,
    CONST VOID* pElem2)
{
    RASSRV_NET_COMPONENT * pc1 = *((RASSRV_NET_COMPONENT **)pElem1);
    RASSRV_NET_COMPONENT * pc2 = *((RASSRV_NET_COMPONENT **)pElem2);

    if (pc1->bManip == pc2->bManip)
    {
        if (pc1->bManip == FALSE)
        {
            return 0;
        }

        if (pc1->dwId == pc2->dwId)
        {
            return 0;
        }
        else if (pc1->dwId < pc2->dwId)
        {
            return -1;
        }

        return 1;
    }
    else if (pc1->bManip)
    {
        return -1;
    }

    return 1;
}

//
// Opens the database of network config components
//
DWORD
netDbOpen (
    OUT PHANDLE phNetCompDatabase,
    IN  PWCHAR pszClientName)
{
    RASSRV_COMPONENT_DB * This;
    DWORD dwLength;

    // Validate parameters
    if (! phNetCompDatabase || !pszClientName)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Allocate the database
    This = RassrvAlloc (sizeof(RASSRV_COMPONENT_DB), TRUE);
    if (This == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Initialize
    dwLength = wcslen(pszClientName);
    if (dwLength)
    {
        This->pszClientName =
            RassrvAlloc((dwLength + 1) * sizeof(WCHAR), FALSE);
        if (This->pszClientName)
        {
            wcscpy(This->pszClientName, pszClientName);
        }
    }
    This->bFlushOnClose = FALSE;
    *phNetCompDatabase = (HANDLE)This;

    // Load the net shell library
    netDbLoadNetShell(This);

    return NO_ERROR;
}

//
// Cleans up all resources held by the database
//
DWORD
netDbClose (
    IN HANDLE hNetCompDatabase)
{
    RASSRV_COMPONENT_DB* This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;

    // Validate parameters
    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Flush if needed
    if (This->bFlushOnClose)
    {
        netDbFlush(hNetCompDatabase);
    }
    else
    {
        // If we've made changes to inetcfg that require backing out,
        // do so now.
        if (This->pINetCfg)
        {
            INetCfg_Cancel(This->pINetCfg);
        }
    }
    netDbCleanup(This);

    // Free the client name
    if (This->pszClientName)
    {
        RassrvFree(This->pszClientName);
    }

    // Release our reference to inetcfg.  We will still have it
    // at this point if a protocol/client/service was added.
    if (This->pINetCfg)
    {
        HrUninitializeAndReleaseINetCfg (
            This->bInitCom,
            This->pINetCfg,
            This->bHasINetCfgLock);
    }

    // Free the netshell library if appropriate
    if (This->pNetConUtilities)
    {
        INetConnectionUiUtilities_Release(This->pNetConUtilities);
    }

    // Free this
    RassrvFree(This);

    return NO_ERROR;
}

// Commits all changes to the database to the system
DWORD
netDbFlush (
    IN HANDLE hNetCompDatabase)
{
    RASSRV_COMPONENT_DB * This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;
    RASSRV_NET_COMPONENT* pComp = NULL;
    DWORD i;

    // Validate parameters
    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Flush any ras-manipulatable's data if dirty
    for (i = 0; i < This->dwCompCount; i++)
    {
        pComp = This->pComps[i];

        // If the enabling of this component has changed, commit
        // that change
        if ((pComp->bEnabled != pComp->bEnabledOrig) && (pComp->bManip))
        {
            if (pComp ->dwType == NETCFGDB_PROTOCOL)
            {
                protSetEnabling(
                    pComp->bEnabled,
                    pComp->dwId);
            }
            else if (pComp->dwType == NETCFGDB_SERVICE)
            {
                svcSetEnabling(pComp);
            }
        }

        // If the ras-server-specific properties of the component
        // have changed, commit the changes.
        if (pComp->bDataDirty)
        {
            protSetExpose(pComp->bExposes, pComp->dwId);

            switch (pComp->dwId)
            {
                case NETCFGDB_ID_IP:
                {
                    TCPIP_PARAMS* pTcpParams =
                        (TCPIP_PARAMS*)(pComp->pbData);

                    TcpipSaveParamsToSystem(pTcpParams);
                }
                break;

                case NETCFGDB_ID_IPX:
                {
                    IPX_PARAMS* pIpxParams =
                        (IPX_PARAMS*)(pComp->pbData);

                    IpxSaveParamsToSystem(pIpxParams);
                }
                break;
            }
        }
    }

    // If we have a pointer to the inetcfg instance then we can
    // commit the changes now
    if (This->pINetCfg)
    {
        INetCfg_Apply(This->pINetCfg);
    }

    return NO_ERROR;
}

//
// Loads the net config database for the first time.  Because inetcfg
// requires time to load and be manipulated, we delay the load of this
// database until it is explicitly requested.
//
DWORD
netDbLoad(
    IN HANDLE hNetCompDatabase)
{
    return netDbReload(hNetCompDatabase);
}

//
// Reloads net information from system
//
DWORD
netDbReload(
    IN HANDLE hNetCompDatabase)
{
    RASSRV_COMPONENT_DB * This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;
    DWORD i, j, dwProtCount = 0, dwRefCount;
    HRESULT hr;
    RASSRV_NET_COMPONENT TempComp;
    INetCfgComponent* pComponents [256];
    PWCHAR pszName = NULL;
    static const GUID* c_apguidClasses [] =
    {
        &GUID_DEVCLASS_NETTRANS,
        &GUID_DEVCLASS_NETCLIENT,
        &GUID_DEVCLASS_NETSERVICE,
    };

    // Validate
    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    DbgOutputTrace(
        "netDbReload %x %x %x %x %x %x %x %x", 
        This->pINetCfg, 
        This->bHasINetCfgLock,
        This->bInitCom,
        This->dwCompCount,
        This->bFlushOnClose,
        This->pComps,
        This->pszClientName,
        This->pNetConUtilities);

    // Cleanup any previous values
    netDbCleanup(This);

    // If we don't have a reference to inetcfg yet, get it
    // here.
    if (This->pINetCfg == NULL)
    {
        This->bInitCom = TRUE;
        This->bHasINetCfgLock = TRUE;
        hr = HrCreateAndInitializeINetCfg(
                &This->bInitCom,
                &This->pINetCfg,
                TRUE,
                0,
                This->pszClientName,
                NULL);
        // Handle error conditions here
        if (S_FALSE == hr)
        {
            return ERROR_CAN_NOT_COMPLETE;
        }
        else if (FAILED(hr))
        {
            return ERROR_CAN_NOT_COMPLETE;
        }
    }

    //
    // Enumerate all of the client and service components in the system.
    //
    hr = HrEnumComponentsInClasses (
            This->pINetCfg,
            sizeof(c_apguidClasses) / sizeof(c_apguidClasses[0]),
            (GUID**)c_apguidClasses,
            sizeof(pComponents) / sizeof(pComponents[0]),
            pComponents,
            &This->dwCompCount);
    if (!SUCCEEDED(hr))
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    // Initialize the array of internal objects
    This->pComps = RassrvAlloc (
                    This->dwCompCount * sizeof (RASSRV_NET_COMPONENT*),
                    TRUE);
    if (!This->pComps)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Initialize the installed component array
    //
    j = 0;
    ZeroMemory(&TempComp, sizeof(TempComp));
    for (i = 0; i < This->dwCompCount; i++)
    {
        pszName = L"";

        //Add this (RASSRV_COMPONENT_DB *) for whistler bug 347355
        //
        if (netDbGetCompInfo(pComponents[i], &TempComp, This))
        {
            This->pComps[j] =
                RassrvAlloc (sizeof(RASSRV_NET_COMPONENT), FALSE);
            if (!This->pComps[j])
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            // Fill in the fields
            CopyMemory(This->pComps[j], &TempComp, sizeof(TempComp));
            ZeroMemory(&TempComp, sizeof(TempComp));
            if (This->pComps[j]->dwType == NETCFGDB_PROTOCOL)
            {
                dwProtCount++;
            }
            pszName = This->pComps[j]->pszName;
            j++;
        }
        dwRefCount = INetCfgComponent_Release(pComponents[i]);
        DbgOutputTrace(
            "netDbReload: %ls ref=%d", pszName, dwRefCount);
    }
    This->dwCompCount = j;

    // Sort the array.
    //
    qsort(
        This->pComps,
        This->dwCompCount,
        sizeof(This->pComps[0]),
        netDbCompare);

    return NO_ERROR;
}

//
// Reload the status of a given component
//
DWORD
netDbReloadComponent (
    IN HANDLE hNetCompDatabase,
    IN DWORD dwComponentId)
{
    RASSRV_COMPONENT_DB * This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;
    RASSRV_NET_COMPONENT* pComp = NULL;
    DWORD i;

    // Validate
    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Currently, we only need to support the fileprint
    // component
    //
    if (dwComponentId != NETCFGDB_ID_FILEPRINT)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Find the appropriate component
    //
    for (i = 0; i < This->dwCompCount; i++)
    {
        if (This->pComps[i]->dwId == dwComponentId)
        {
            pComp = This->pComps[i];
            break;
        }
    }

    // Nothing to do if we can't find the component
    //
    if (pComp == NULL)
    {
        return ERROR_NOT_FOUND;
    }

    // Reload the component information
    //
    if (dwComponentId == NETCFGDB_ID_FILEPRINT)
    {
        svcGetEnabling(&(pComp->bEnabled), NETCFGDB_ID_FILEPRINT);
    }

    return NO_ERROR;
}


//
// Reverts the database to the state it was in when opened
//
DWORD
netDbRollback (
    IN HANDLE hNetCompDatabase)
{
    RASSRV_COMPONENT_DB * This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;

    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    This->bFlushOnClose = FALSE;

    return NO_ERROR;
}

//
// Special function denotes whether the network tab has been
// loaded
//
BOOL
netDbIsLoaded (
    IN HANDLE hNetCompDatabase)
{
    RASSRV_COMPONENT_DB * This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;

    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    return (!!(This->pINetCfg));// || (This->bHasINetCfgLock));
}

//
// Gets the number of components in the database
//
DWORD
netDbGetCompCount (
    IN  HANDLE hNetCompDatabase,
    OUT LPDWORD lpdwCount)
{
    RASSRV_COMPONENT_DB * This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;
    DWORD i;

    // Validate parameters
    if (!This || !lpdwCount)
    {
        return ERROR_INVALID_PARAMETER;
    }

    *lpdwCount = This->dwCompCount;

    return NO_ERROR;
}

//
// Returns a pointer to the name of a component (don't alter it)
//
DWORD
netDbGetName(
    IN  HANDLE hNetCompDatabase,
    IN  DWORD dwIndex,
    OUT PWCHAR* pszName)
{
    RASSRV_COMPONENT_DB * This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;

    // Validate
    if (!This || !pszName)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Bounds check
    if (!netDbBoundsCheck(This, dwIndex))
    {
        return ERROR_INVALID_INDEX;
    }

    // return the name
    *pszName = This->pComps[dwIndex]->pszName;

    return NO_ERROR;
}

//
// Returns a description of a component (don't alter it)
//
DWORD
netDbGetDesc(
    IN HANDLE hNetCompDatabase,
    IN DWORD dwIndex,
    IN PWCHAR* pszName)
{
    RASSRV_COMPONENT_DB * This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;

    // Validate
    if (!This || !pszName)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Bounds check
    if (!netDbBoundsCheck(This, dwIndex))
    {
        return ERROR_INVALID_INDEX;
    }

    // return the name
    *pszName = This->pComps[dwIndex]->pszDesc;

    return NO_ERROR;
}

//
// Returns a type of a component (don't alter it)
//
DWORD
netDbGetType (
    IN  HANDLE hNetCompDatabase,
    IN  DWORD dwIndex,
    OUT LPDWORD lpdwType)
{
    RASSRV_COMPONENT_DB * This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;

    // Validate
    if (!This || !lpdwType)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Bounds check
    if (!netDbBoundsCheck(This, dwIndex))
    {
        return ERROR_INVALID_INDEX;
    }

    // return the name
    *lpdwType = This->pComps[dwIndex]->dwType;

    return NO_ERROR;
}

//
// Get a component id
//
DWORD
netDbGetId(
    IN  HANDLE hNetCompDatabase,
    IN  DWORD dwIndex,
    OUT LPDWORD lpdwId)
{
    RASSRV_COMPONENT_DB * This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;

    // Validate
    if (!This || !lpdwId)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Bounds check
    if (!netDbBoundsCheck(This, dwIndex))
    {
        return ERROR_INVALID_INDEX;
    }

    // return the name
    *lpdwId = This->pComps[dwIndex]->dwId;

    return NO_ERROR;
}

//
// Gets whether the given component is enabled.  For non-ras-manipulatable
// components, this yields TRUE
//
DWORD
netDbGetEnable(
    IN  HANDLE hNetCompDatabase,
    IN  DWORD dwIndex,
    OUT PBOOL pbEnabled)
{
    RASSRV_COMPONENT_DB * This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;

    // Validate
    if (!This || !pbEnabled)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Bounds check
    if (!netDbBoundsCheck(This, dwIndex))
    {
        return ERROR_INVALID_INDEX;
    }

    // return the name
    if (This->pComps[dwIndex]->bManip)
    {
        *pbEnabled = This->pComps[dwIndex]->bEnabled;
    }
    else
    {
        *pbEnabled = TRUE;
    }

    return NO_ERROR;
}

//
// Gets whether the given component is enabled. This function only has
// effect on ras-manipulatable components.
//
DWORD
netDbSetEnable(
    IN HANDLE hNetCompDatabase,
    IN DWORD dwIndex,
    IN BOOL bEnabled)
{
    RASSRV_COMPONENT_DB * This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;

    // Validate
    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Bounds check
    if (!netDbBoundsCheck(This, dwIndex))
    {
        return ERROR_INVALID_INDEX;
    }

    // return the name
    This->pComps[dwIndex]->bEnabled = bEnabled;

    return NO_ERROR;
}

//
// Returns whether the given network component can
// be manipulated by ras server.
//
DWORD
netDbIsRasManipulatable (
    IN  HANDLE hNetCompDatabase,
    IN  DWORD dwIndex,
    OUT PBOOL pbManip)
{
    RASSRV_COMPONENT_DB * This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;

    // Validate
    if (!This || !pbManip)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Bounds check
    if (! netDbBoundsCheck(This, dwIndex))
    {
        return ERROR_INVALID_INDEX;
    }

    // return the name
    *pbManip = This->pComps[dwIndex]->bManip;

    return NO_ERROR;
}


//
////Disable/Enable the Uninstall button for whislter bug 347355     gangz
//
DWORD
netDbHasRemovePermission(
    IN HANDLE hNetCompDatabase,
    IN DWORD dwIndex,
    OUT PBOOL pbHasPermit)
{
    RASSRV_COMPONENT_DB * This = NULL;
    INetCfgComponent*   pComponent = NULL;
    BOOL fEnableRemove = FALSE;
    HRESULT hr  = S_OK;
    DWORD dwErr = NO_ERROR, dwFlags;
    
    //Disable/Enable Uninstall button according to its user permission and user 
    // removability
    //
    do
    {
        This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;

        // Validate pointer
        if (!This || !pbHasPermit || ( -1 == dwIndex ))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

        // Make sure that netshell library has been opened
        if (!This->pNetConUtilities)
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        if (dwIndex >= This->dwCompCount)
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        ASSERT(This->pComps[dwIndex]);
        if( !(This->pComps[dwIndex]) )
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        fEnableRemove = This->pComps[dwIndex]->bRemovable;

        *pbHasPermit = fEnableRemove;
    }
    while(FALSE);
  
    return dwErr;
}


//
// Returns whether the given network component has
// a properties ui that it can raise
//
DWORD
netDbHasPropertiesUI(
    IN  HANDLE hNetCompDatabase,
    IN  DWORD dwIndex,
    OUT PBOOL pbHasUi)
{
    RASSRV_COMPONENT_DB * This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;
    RASSRV_NET_COMPONENT* pComp = NULL;

    // Validate
    if (!This || !pbHasUi)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Bounds check
    if (!netDbBoundsCheck(This, dwIndex))
    {
        return ERROR_INVALID_INDEX;
    }

    pComp = This->pComps[dwIndex];

    if ((pComp->bManip) && (pComp->dwType == NETCFGDB_PROTOCOL))
    {
        *pbHasUi = TRUE;
    }
    else
    {
        *pbHasUi = pComp->bHasUi;
    }

    return NO_ERROR;
}

//
// Raises the properties of the component at the given index
//
DWORD
netDbRaisePropertiesDialog (
    IN HANDLE hNetCompDatabase,
    IN DWORD dwIndex,
    IN HWND hwndParent)
{
    RASSRV_COMPONENT_DB * This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;
    RASSRV_NET_COMPONENT* pComp = NULL;

    // Validate
    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Bounds check
    if (dwIndex >= This->dwCompCount)
    {
        return ERROR_INVALID_INDEX;
    }

    pComp = This->pComps[dwIndex];

    // If this is a ras-manipulatable protocol, raise its
    // properties manually.
    if ((pComp->bManip) && (pComp->dwType == NETCFGDB_PROTOCOL))
    {
        netDbRaiseRasProps(This->pComps[dwIndex], hwndParent);
    }

    // Otherwise, let inetcfg do the work
    else
    {
        return INetCfgComponent_RaisePropertyUi (
                    pComp->pINetCfgComp,
                    hwndParent,
                    NCRP_SHOW_PROPERTY_UI,
                    NULL);
    }

    return NO_ERROR;
}

//
// Brings up the UI that allows a user to install a component
//
DWORD
netDbRaiseInstallDialog(
    IN HANDLE hNetCompDatabase,
    IN HWND hwndParent)
{
    RASSRV_COMPONENT_DB * This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;
    HRESULT hr;

    // Validate
    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Make sure that netshell library has been opened
    if (!This->pNetConUtilities)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }
    else
    {
        // If we have our pointer to the function used to bring up the add
        // component dialog (obtained above only once), call it.
        HRESULT hr = S_OK;

        // We want to filter out protocols that RAS does not care about
        // We do this by sending in a CI_FILTER_INFO structure indicating
        // we want non-RAS protocols filtered out
        //
        CI_FILTER_INFO cfi = {0};
        cfi.eFilter = FC_RASSRV;
        hr = INetConnectionUiUtilities_DisplayAddComponentDialog(
                        This->pNetConUtilities,
                        hwndParent,
                        This->pINetCfg,
                        &cfi);

        // Ui will handle reboot
        if (hr == NETCFG_S_REBOOT)
        {
            netDbReload(hNetCompDatabase);
            return hr;
        }

        // If the user didn't cancel, refresh the database.
        if (S_FALSE != hr)
        {
            if (SUCCEEDED (hr))
            {
                netDbReload(hNetCompDatabase);
                return NO_ERROR;
            }
            else
            {
                return hr;
            }
        }
    }

    return ERROR_CANCELLED;
}


//
// Uninstalls the given component
//
DWORD
netDbRaiseRemoveDialog (
    IN HANDLE hNetCompDatabase,
    IN DWORD dwIndex,
    IN HWND hwndParent)
{
    RASSRV_COMPONENT_DB * This = (RASSRV_COMPONENT_DB*)hNetCompDatabase;
    HRESULT hr;

    // Validate
    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Make sure that netshell library has been opened
    if (!This->pNetConUtilities)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    // If we have our pointer to the function used to bring up the add
    // component dialog (obtained above only once), call it.
    if (dwIndex < This->dwCompCount)
    {
        if (This->pComps[dwIndex]->pINetCfgComp)
        {
            hr = INetConnectionUiUtilities_QueryUserAndRemoveComponent(
                            This->pNetConUtilities,
                            hwndParent,
                            This->pINetCfg,
                            This->pComps[dwIndex]->pINetCfgComp);

            // Ui will handle reboot
            if (hr == NETCFG_S_REBOOT)
            {
                netDbReload(hNetCompDatabase);
                return hr;
            }

            // If the user didn't cancel, refresh the database.
            else if (S_FALSE != hr)
            {
                if (SUCCEEDED (hr))
                {
                    netDbReload(hNetCompDatabase);
                    return NO_ERROR;
                }
                else
                {
                    return hr;
                }
            }
        }
    }

    return ERROR_CANCELLED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\nettab.h ===
/*
    File    advantab.h

    Definitions needed to display the dialup server ui networking tab.

    Paul Mayfield, 10/10/97
*/

#ifndef __advantab_h
#define __advantab_h

#include <windows.h>
#include <prsht.h>

// Fills a LPPROPSHEETPAGE structure with the information
// needed to display the advanced tab.  dwUserData is ignored.
DWORD NetTabGetPropertyPage(LPPROPSHEETPAGE lpPage, LPARAM lpUserData);     

// This dialog procedure responds to messages send to the 
// advanced tab.
INT_PTR CALLBACK NetTabDialogProc(HWND hwndDlg,
                              UINT uMsg,
                              WPARAM wParam,
                              LPARAM lParam);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\rassrv.c ===
/*
    File    Rassrv.h

    Functions that perform ras server operations that can be implemented 
    independent of the ui.

    Paul Mayfield, 10/7/97
*/

#include "rassrv.h"

// ============================================================
// ============================================================
// Functions to maintain data accross property sheet pages.
// ============================================================
// ============================================================

// This message queries all other pages to find out if 
// any other ras server pages exist.  If this message is
// not responded to, then we know it's safe to cleanup
// any global context in the wizard/property sheet.
#define RASSRV_CMD_QUERY_LIVING     237     

// These commands hide and show ras server pages.
#define RASSRV_CMD_HIDE_PAGES       238
#define RASSRV_CMD_SHOW_PAGES       239

//
// Reasons for RasSrvSErviceInitialize to fail
//
#define RASSRV_REASON_SvcError     0
#define RASSRV_REASON_Pending      1

// 
// This structure defines the data that needs to be stored
// for each set of related property pages.  Multiple instances
// of this context can exist for each wizard/propsheet.
//
typedef struct _RASSRV_PAGESET_CONTEXT 
{
    HWND hwndSheet;
    HWND hwndFirstPage; // first to be activated in the set
    
    HANDLE hDeviceDatabase;
    HANDLE hUserDatabase;
    HANDLE hNetCompDatabase;
    HANDLE hMiscDatabase;

    DWORD dwPagesInited;  // Acts as a reference-count mechansim so we know
                          // what set of pages in the wizard/propsheet are
                          // referencing this context.
                                    
    BOOL bShow;           // Whether pages that ref this context show be vis.
    BOOL bCommitOnClose;  // Whether to commit settings changes on close
} RASSRV_PAGESET_CONTEXT;

//
// This structure defines the global context that is available on a 
// per-wizard/propsheet basis.  Even pages that don't share the same
// RASSRV_PAGESET_CONTEXT context will share this structure if they
// are owned by the same wizard/propsheet.
//
typedef struct _RASSRV_PROPSHEET_CONTEXT 
{
    BOOL  bRemoteAccessWasStarted;    
    BOOL  bRemoteAccessIsRunning;    
    BOOL  bLeaveRemoteAccessRunning; 
    DWORD dwServiceErr;
} RASSRV_PROPSHEET_CONTEXT;

DWORD 
APIENTRY 
RassrvCommitSettings (
    IN PVOID pvContext, 
    IN DWORD dwRasWizType);

//
// Verifies that the current state of services in the system
// is condusive to configuring incoming connectins starting 
// services as needed.
//
DWORD 
RasSrvServiceInitialize(
    IN  RASSRV_PROPSHEET_CONTEXT * pPropSheetCtx, 
    IN  HWND hwndSheet, 
    OUT LPDWORD lpdwReason)
{
    DWORD dwErr = NO_ERROR;
    HANDLE hDialupService = NULL;
    BOOL bPending = FALSE;

    // If we already know there's an error, then there's no
    // need to proceed.
    //
    if (pPropSheetCtx->dwServiceErr)
    {
        return pPropSheetCtx->dwServiceErr;
    }

    // If we already started the service or if we already know the 
    // service is running, then there's nothing to do.
    //
    if (pPropSheetCtx->bRemoteAccessWasStarted || 
        pPropSheetCtx->bRemoteAccessIsRunning
       )
    {
        return NO_ERROR;
    }

    do 
    {
        // Get a reference to the service
        //
        dwErr = SvcOpenRemoteAccess(&hDialupService);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // See if we're pending something.
        //
        dwErr = SvcIsPending(hDialupService, &bPending);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // If the service is stopping, then we can't continue
        //
        if (bPending)
        {
            *lpdwReason = RASSRV_REASON_Pending;
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        // See if we're started
        //
        dwErr = SvcIsStarted(
                    hDialupService, 
                    &(pPropSheetCtx->bRemoteAccessIsRunning));
        if (dwErr != NO_ERROR)
        {
            *lpdwReason = RASSRV_REASON_SvcError;
            pPropSheetCtx->dwServiceErr = dwErr;
            break;
        }
            
        // If we find out the service is running, there's nothing to do
        if (pPropSheetCtx->bRemoteAccessIsRunning) 
        {
            pPropSheetCtx->bLeaveRemoteAccessRunning = TRUE;
            break;
        }        

        // Start the service since it's not running.
        dwErr = RasSrvInitializeService();
        if (dwErr != NO_ERROR)
        {
            *lpdwReason = RASSRV_REASON_SvcError;
            pPropSheetCtx->dwServiceErr = dwErr;
            break;
        }

        // Record the fact that we did so.
        pPropSheetCtx->bRemoteAccessWasStarted = TRUE;
        pPropSheetCtx->bRemoteAccessIsRunning = TRUE;
        
    } while (FALSE);        

    // Cleanup
    {
        // Cleanup the reference to the dialup service
        //
        if (hDialupService)
        {
            SvcClose(hDialupService);
        }            
    }
    
    return dwErr;
}

//
// Abort any changes to the remoteaccess service that were made
// during RasSrvServiceInitialize
//
DWORD 
RasSrvServiceCleanup(
    IN HWND hwndPage) 
{
    DWORD dwErr;
    RASSRV_PROPSHEET_CONTEXT * pPropSheetCtx = NULL;

    pPropSheetCtx = (RASSRV_PROPSHEET_CONTEXT *) 
        GetProp(GetParent(hwndPage), Globals.atmRassrvPageData);
        
    if (pPropSheetCtx == NULL)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    // If we started the modified the remote access service, reverse 
    // the changes and record the fact that we did
    if (pPropSheetCtx->bRemoteAccessWasStarted) 
    {
        if ((dwErr = RasSrvCleanupService()) != NO_ERROR)
        {
            return dwErr;
        }
        
        pPropSheetCtx->bRemoteAccessWasStarted = FALSE;
        pPropSheetCtx->bLeaveRemoteAccessRunning = FALSE;
        pPropSheetCtx->bRemoteAccessIsRunning = FALSE;
    }

    return NO_ERROR;
}

//
// Intializes a property sheet.  This causes a handle to the 
// property sheet data object to be placed in the GWLP_USERDATA
// section of the window handle to the page.
//
DWORD 
RasSrvPropsheetInitialize(
    IN HWND hwndPage, 
    IN LPPROPSHEETPAGE pPropPage) 
{
    DWORD dwErr, dwPageId, dwShowCommand;
    RASSRV_PAGE_CONTEXT * pPageCtx = NULL;
    RASSRV_PAGESET_CONTEXT * pPageSetCtx = NULL; 
    HWND hwndSheet = GetParent(hwndPage);
    int ret;
    
    // 
    // Retrieve the per page context as well as the per-page-set context.
    // these will have been provided by the caller and are placed in the
    // lparam.
    // 
    pPageCtx = (RASSRV_PAGE_CONTEXT *) pPropPage->lParam;
    pPageSetCtx = (RASSRV_PAGESET_CONTEXT *) pPageCtx->pvContext;
    
    // Associate the page's context with the page.
    //
    SetProp(hwndPage, Globals.atmRassrvPageData, (HANDLE)pPageCtx);

    // Record the handle to the property sheet.
    pPageSetCtx->hwndSheet = hwndSheet;

    return NO_ERROR;
}

//
// Callback occurs whenever a page is being created or 
// destroyed.
//
UINT 
CALLBACK 
RasSrvInitDestroyPropSheetCb(
    IN HWND hwndPage,
    IN UINT uMsg,
    IN LPPROPSHEETPAGE pPropPage) 
{
    RASSRV_PAGE_CONTEXT * pPageCtx = NULL;
    RASSRV_PAGESET_CONTEXT * pPageSetCtx = NULL;
    HWND hwndSheet = GetParent(hwndPage);
    BOOL bLastPage = FALSE, bStopService = FALSE;

    // Retrieve the per-page context
    //pPageCtx = (RASSRV_PAGE_CONTEXT *) 
    //    GetProp(hwndPage, Globals.atmRassrvPageData);
    pPageCtx = (RASSRV_PAGE_CONTEXT *) pPropPage->lParam;
    if (pPageCtx == NULL)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    // Get the per-group-of-related-pages context.  There may be multiple
    // instances of this context per wizard/property sheet.  For example, 
    // the Incoming connections wizard and the DCC host wizard both have 
    // sets of pages that share different contexts.  
    // 
    pPageSetCtx = (RASSRV_PAGESET_CONTEXT *) pPageCtx->pvContext;
    
    // This callback is only used for cleanup
    if (uMsg != PSPCB_RELEASE)
    {
        // Record that the given page is referencing
        // the given pageset context.
        pPageSetCtx->dwPagesInited |= pPageCtx->dwId;

        // Return true to indicate that the page should
        // be created.
        return TRUE;
    }

    // Cleanup the page set information.
    //
    if (pPageSetCtx != NULL)
    {
        // Record that this page is cleaned up
        pPageSetCtx->dwPagesInited &= ~(pPageCtx->dwId);

        // When the dwPagesInited variable hits zero,
        // it means that no other pages in the current
        // wizard/propsheet are referencing this propsheet
        // context.  Now is the time to cleanup all resources
        // held by the context.
        if (pPageSetCtx->dwPagesInited == 0) 
        {
            // Commit the settings if we are supposed to do 
            // so
            if (pPageSetCtx->bCommitOnClose) 
            {
                DbgOutputTrace("RasSrvCleanPropSht commit dbs.");
                RassrvCommitSettings ((PVOID)pPageSetCtx, pPageCtx->dwType);
            }

            // Close the databases
            DbgOutputTrace("RasSrvCleanPropSht closing dbs.");
            if (pPageSetCtx->hUserDatabase)
            {
                usrCloseLocalDatabase(pPageSetCtx->hUserDatabase);
            }
                
            if (pPageSetCtx->hDeviceDatabase)
            {
                devCloseDatabase(pPageSetCtx->hDeviceDatabase);
            }
                
            if (pPageSetCtx->hMiscDatabase)
            {
                miscCloseDatabase(pPageSetCtx->hMiscDatabase);
            }
                
            if (pPageSetCtx->hNetCompDatabase)
            {
                netDbClose(pPageSetCtx->hNetCompDatabase);
            }

            // Since there are no other pages referencing this property
            // sheet context, go ahead and free it.
            DbgOutputTrace (
                "RasSrvCleanPropSht %d freeing pageset data.", 
                pPageCtx->dwId);
            RassrvFree(pPageSetCtx);
        }
    }

    // Mark the page as dead
    SetProp (hwndPage, Globals.atmRassrvPageData, NULL);
    
    // This page is gone, so clear its context
    DbgOutputTrace (
        "RasSrvCleanPropSht %d freeing page data.", 
        pPageCtx->dwId);
    RassrvFree(pPageCtx);

    return NO_ERROR;
}

// Commits any settings in the given context.
// 
DWORD 
APIENTRY 
RassrvCommitSettings (
    IN PVOID pvContext, 
    IN DWORD dwRasWizType) 
{
    RASSRV_PAGESET_CONTEXT * pPageSetCtx = 
        (RASSRV_PAGESET_CONTEXT *)pvContext;
        
    RASSRV_PROPSHEET_CONTEXT * pPropSheetCtx = NULL;
    
    DbgOutputTrace ("RassrvCommitSettings entered : %x", dwRasWizType);

    if (pPageSetCtx) 
    {
        BOOL fCallSetPortMapping = TRUE;

        // Flush all appropriate settings
        if (pPageSetCtx->hUserDatabase)
        {
            usrFlushLocalDatabase(pPageSetCtx->hUserDatabase);
        }

        if (pPageSetCtx->hDeviceDatabase)
        {
            //This must be called before devFlushDatabase
            //for whistler bug 123769
            //
            fCallSetPortMapping = devIsVpnEnableChanged( pPageSetCtx->hDeviceDatabase );

            devFlushDatabase(pPageSetCtx->hDeviceDatabase);
        }
            
        if (pPageSetCtx->hMiscDatabase)
        {
            miscFlushDatabase(pPageSetCtx->hMiscDatabase);
        }
            
        if (pPageSetCtx->hNetCompDatabase)
        {
            netDbFlush(pPageSetCtx->hNetCompDatabase);
        }
            
        // Set state so that the service will not be stopped.
        if (pPageSetCtx->hwndSheet) 
        {
            DbgOutputTrace ("RassrvCommitSettings: keep svc running.");
            pPropSheetCtx = (RASSRV_PROPSHEET_CONTEXT *) 
                GetProp(pPageSetCtx->hwndSheet, Globals.atmRassrvPageData);
                
            if (pPropSheetCtx)
            {
                pPropSheetCtx->bLeaveRemoteAccessRunning = TRUE;
            }
        }
        //whistler bug 123769, 
        //<one of the scenarios>
        //Set up PortMapping for all possible connections
        //when we are going to create a Incoming Connection
        //with VPN enabled

        if ( fCallSetPortMapping &&
             FIsUserAdminOrPowerUser() &&
             IsFirewallAvailablePlatform() && //Add this for bug 342810
             IsGPAEnableFirewall() )  
        {
            HnPMConfigureIfVpnEnabled( TRUE, pPageSetCtx->hDeviceDatabase );
        }
    }

    return NO_ERROR;
}

//
// Causes the remoteaccess service to not be stopped even if the context
// associated with the given property sheet page is never committed.
//
DWORD 
RasSrvLeaveServiceRunning (
    IN HWND hwndPage) 
{
    RASSRV_PAGE_CONTEXT * pPageCtx = 
        (RASSRV_PAGE_CONTEXT *)GetProp(hwndPage, Globals.atmRassrvPageData);
    RASSRV_PAGESET_CONTEXT * pPageSetCtx = 
        (RASSRV_PAGESET_CONTEXT *) pPageCtx->pvContext;
    RASSRV_PROPSHEET_CONTEXT * pPropSheetCtx = NULL;
    
    DbgOutputTrace ("RasSrvLeaveServiceRunning entered for type");

    if (! pPageSetCtx)
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    // Let the property sheet know that some settings have been committed
    // so that it will not stop the remoteaccess service when it closes.
    if (pPageSetCtx->hwndSheet) 
    {
        DbgOutputTrace ("RasSrvLeaveServiceRunning: keep svc running.");
        pPropSheetCtx = (RASSRV_PROPSHEET_CONTEXT *) 
            GetProp(pPageSetCtx->hwndSheet, Globals.atmRassrvPageData);
        if (pPropSheetCtx)
        {
            pPropSheetCtx->bLeaveRemoteAccessRunning = TRUE;
        }
    }

    return NO_ERROR;
}

// Called just before a page is activated.  Return NO_ERROR to allow the 
// activation and an error code to reject it.
DWORD 
RasSrvActivatePage (
    IN HWND hwndPage, 
    IN NMHDR *pData) 
{
    BOOL fAdminOrPower;
    MSGARGS MsgArgs;


    RASSRV_PAGE_CONTEXT * pPageCtx = 
        (RASSRV_PAGE_CONTEXT *) 
            GetProp(hwndPage, Globals.atmRassrvPageData);
            
    RASSRV_PAGESET_CONTEXT * pPageSetCtx = 
        (RASSRV_PAGESET_CONTEXT *) pPageCtx->pvContext;
        
    RASSRV_PROPSHEET_CONTEXT * pPropSheetCtx = NULL;
    HWND hwndSheet = GetParent(hwndPage);
    DWORD dwErr, dwReason = 0;

    DbgOutputTrace("RasSrvActivatePage: Entered for %x", pPageCtx->dwId);

    ZeroMemory(&MsgArgs, sizeof(MsgArgs));
    MsgArgs.dwFlags = MB_OK;

    // Make sure we have a context for this page.
    if (!pPageSetCtx)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    // Record the first page in the page set if needed
    //
    if (pPageSetCtx->hwndFirstPage == NULL)
    {
        pPageSetCtx->hwndFirstPage = hwndPage;
    }

    // Make sure that we can show
    if (pPageSetCtx->bShow == FALSE) 
    {
        DbgOutputTrace("RasSrvActivatePage: Show turned off");
        return ERROR_CAN_NOT_COMPLETE;
    }

    // Manipulate settings in the property sheet
    // context
    pPropSheetCtx = GetProp(hwndSheet, Globals.atmRassrvPageData);
       


    // Make sure everything's ok with the services we rely on.
    //
    if (pPropSheetCtx != NULL) 
    {

        //Check if the current user has enough privileges
        //For Whistler Bug #235091
        //
        fAdminOrPower = FIsUserAdminOrPowerUser();
        if ( !fAdminOrPower )
        {
            if (hwndPage == pPageSetCtx->hwndFirstPage)
            {
                MsgDlgUtil(
                    GetActiveWindow(),
                    ERR_SERVICE_NOT_GRANTED,
                    &MsgArgs,
                    Globals.hInstDll,
                    WRN_TITLE);

                PostMessage(hwndSheet, PSM_SETCURSEL, 0, 0);
            }

            return ERROR_CAN_NOT_COMPLETE;
        }

        dwErr = RasSrvServiceInitialize(
                    pPropSheetCtx, 
                    hwndPage,
                    &dwReason);

        if (dwErr != NO_ERROR)
        {
            if (hwndPage == pPageSetCtx->hwndFirstPage)
            {
                // Display the appropriate message
                //
                MsgDlgUtil(
                    GetActiveWindow(),
                    (dwReason == RASSRV_REASON_Pending) ? 
                        SID_SERVICE_StopPending          :
                        ERR_SERVICE_CANT_START,
                    &MsgArgs,
                    Globals.hInstDll,
                    WRN_TITLE);

                PostMessage(hwndSheet, PSM_SETCURSEL, 0, 0);
                PostMessage(hwndSheet, PSM_PRESSBUTTON, (WPARAM)PSBTN_NEXT, 0);
            }
                        
            return dwErr;
        }
    }        

    return NO_ERROR;
}

//
// Flags the context associated with the given page to have its settings 
// committed when the dialog closes
//
DWORD 
RasSrvCommitSettingsOnClose (
    IN HWND hwndPage) 
{
    RASSRV_PAGE_CONTEXT * pPageCtx = 
        (RASSRV_PAGE_CONTEXT *) GetProp(hwndPage, Globals.atmRassrvPageData);
    RASSRV_PAGESET_CONTEXT * pPageSetCtx = 
        (RASSRV_PAGESET_CONTEXT *) pPageCtx->pvContext;

    pPageSetCtx->bCommitOnClose = TRUE;
    
    return NO_ERROR;
}

//
// Returns the id of the page whose handle is hwndPage
// 
DWORD 
RasSrvGetPageId (
    IN  HWND hwndPage, 
    OUT LPDWORD lpdwId) 
{
    RASSRV_PAGE_CONTEXT * pPageCtx = 
        (RASSRV_PAGE_CONTEXT *)GetProp(hwndPage, Globals.atmRassrvPageData);

    if (!lpdwId)
    {
        return ERROR_INVALID_PARAMETER;
    }
        
    if (!pPageCtx)
    {
        return ERROR_NOT_FOUND;
    }

    *lpdwId = pPageCtx->dwId;

    return NO_ERROR;
}

// 
// Gets a handle to a particular database, opening the database
// as needed.
// 
DWORD 
RasSrvGetDatabaseHandle(
    IN  HWND hwndPage, 
    IN  DWORD dwDatabaseId, 
    OUT HANDLE * hDatabase) 
{
    RASSRV_PAGE_CONTEXT * pPageCtx = 
        (RASSRV_PAGE_CONTEXT *)GetProp(hwndPage, Globals.atmRassrvPageData);
    RASSRV_PAGESET_CONTEXT * pPageSetCtx = 
        (RASSRV_PAGESET_CONTEXT *) pPageCtx->pvContext;
    
    if (!pPageSetCtx || !hDatabase)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Key off of the database id, opening databases as needed
    switch (dwDatabaseId) 
    {
        case ID_DEVICE_DATABASE:
            if (pPageSetCtx->hDeviceDatabase == NULL) 
            {
                devOpenDatabase(&(pPageSetCtx->hDeviceDatabase));    
            }
            *hDatabase = pPageSetCtx->hDeviceDatabase;
            break;
            
        case ID_USER_DATABASE:
            if (pPageSetCtx->hUserDatabase == NULL) 
            {
                usrOpenLocalDatabase(&(pPageSetCtx->hUserDatabase));    
            }
            *hDatabase = pPageSetCtx->hUserDatabase;
            break;
            
        case ID_MISC_DATABASE:
            if (pPageSetCtx->hMiscDatabase == NULL) 
            {
                miscOpenDatabase(&(pPageSetCtx->hMiscDatabase));    
            }
            *hDatabase = pPageSetCtx->hMiscDatabase;
            break;
            
        case ID_NETCOMP_DATABASE:
            {
                if (pPageSetCtx->hNetCompDatabase == NULL) 
                {
                    WCHAR buf[64], *pszString = NULL;
                    DWORD dwCount;

                    dwCount = GetWindowTextW(
                                GetParent(hwndPage), 
                                (PWCHAR)buf, 
                                sizeof(buf)/sizeof(WCHAR));
                    if (dwCount == 0)
                    {
                        pszString = (PWCHAR) PszLoadString(
                                        Globals.hInstDll, 
                                        SID_DEFAULT_CONNECTION_NAME);
                        lstrcpynW(
                            (PWCHAR)buf, 
                            pszString, 
                            sizeof(buf) / sizeof(WCHAR));
                    }
                    netDbOpen(&(pPageSetCtx->hNetCompDatabase), (PWCHAR)buf); 
                    
                 }
                *hDatabase = pPageSetCtx->hNetCompDatabase;
            }
            break;
            
        default:
            return ERROR_CAN_NOT_COMPLETE;
    }

    return NO_ERROR;
}

// 
// Creates a context to associate with a set of 
// related pages in a property sheet or wizard.
// 
DWORD 
RassrvCreatePageSetCtx(
    OUT PVOID * ppvContext) 
{
    RASSRV_PAGESET_CONTEXT * pPageCtx = NULL;
    
    if (ppvContext == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Allocate enough memory for a RASSRV_PAGESET_CONTEXT structure
    *ppvContext = RassrvAlloc (sizeof(RASSRV_PAGESET_CONTEXT), TRUE);
    if (*ppvContext == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Initialize the page set context
    pPageCtx = ((RASSRV_PAGESET_CONTEXT*)(*ppvContext));
    pPageCtx->bShow = TRUE;
        
    return NO_ERROR;
}

// 
// Function causes the ras-server specific pages to allow 
// activation or not
//
DWORD 
APIENTRY 
RassrvShowWizPages (
    IN PVOID pvContext, 
    IN BOOL bShow) 
{
    RASSRV_PAGESET_CONTEXT * pPageSetCtx = 
        (RASSRV_PAGESET_CONTEXT *) pvContext;
    
    if (pPageSetCtx)
    {
        pPageSetCtx->bShow = bShow;
    }
                
    return NO_ERROR;
}

// 
// Returns the maximum number of pages for the
// a ras server wizard of the given type.  Return
// 0 to specify that a wizard not be run.
//
DWORD 
APIENTRY 
RassrvQueryMaxPageCount(
    IN DWORD dwRasWizType)
{
    BOOL bAllowWizard;
    DWORD dwErr;
    HANDLE hRasman;
    BOOL bTemp;

    // Find out if displaying the incoming connections wizard
    // is allowed.
    if (RasSrvAllowConnectionsWizard (&bAllowWizard) != NO_ERROR)
    {
        return 0;
    }

    // If the wizard is not to be run, return the appropriate 
    // count.
    if (! bAllowWizard)
    {
        return RASSRVUI_WIZ_PAGE_COUNT_SWITCH;                   
    }

    // At this point, we know that everything's kosher.  Return 
    // the number of pages that we support.
    switch (dwRasWizType) 
    {
        case RASWIZ_TYPE_INCOMING:
            return RASSRVUI_WIZ_PAGE_COUNT_INCOMING;
            break;
            
        case RASWIZ_TYPE_DIRECT:
            return RASSRVUI_WIZ_PAGE_COUNT_DIRECT;
            break;
    }
    
    return 0;
}

//
// Filters messages for RasSrv Property Pages.  If this function returns 
// true, the window proc of the dialog window should return true without
// processing the message.
//
// This message filter does the following:
//      1. Maintains databases and grants access to them.
//      2. Starts/stops remoteaccess service as needed.
//      3. Maintains the per-page, per-pageset, and per-wizard contexts.
//
BOOL 
RasSrvMessageFilter(
    IN HWND hwndDlg, 
    IN UINT uMsg, 
    IN WPARAM wParam, 
    IN LPARAM lParam) 
{
    RASSRV_PROPSHEET_CONTEXT * pPropSheetCtx = NULL;
    
    switch (uMsg) 
    {
        // A page is being created.  Initailizes all contexts with respect
        // to this page and start services as needed.
        case WM_INITDIALOG:
            // Initialize and add the per-propsheet context if another
            // page has not already done so.
            // 
            {
                HWND hwndSheet = GetParent(hwndDlg);
                pPropSheetCtx = (RASSRV_PROPSHEET_CONTEXT *) 
                                    GetProp (
                                        hwndSheet, 
                                        Globals.atmRassrvPageData);
                if (!pPropSheetCtx) 
                {
                    pPropSheetCtx = 
                        RassrvAlloc(
                            sizeof(RASSRV_PROPSHEET_CONTEXT), 
                            TRUE);
                        
                    SetProp (
                        hwndSheet, 
                        Globals.atmRassrvPageData, 
                        (HANDLE)pPropSheetCtx);
                }        

                // Initialize the page
                RasSrvPropsheetInitialize(
                    hwndDlg, 
                    (LPPROPSHEETPAGE)lParam);
            }
            break;

        case WM_DESTROY:
            // WM_DESTROY is sent for each page that has been activated.
            // Cleanup the global data if it hasn't already been
            // cleaned up on a previous call to WM_DESTROY.
            // 
            {
                HWND hwndSheet = GetParent(hwndDlg);
                pPropSheetCtx = (RASSRV_PROPSHEET_CONTEXT *) 
                            GetProp(hwndSheet, Globals.atmRassrvPageData);
                if (pPropSheetCtx) 
                {
                    if (!pPropSheetCtx->bLeaveRemoteAccessRunning)
                    {
                        DbgOutputTrace("Stop service.");
                        RasSrvServiceCleanup(hwndDlg);
                    }                
                    DbgOutputTrace ("Free propsht data.");
                    RassrvFree (pPropSheetCtx);
                    
                    // Reset the global data
                    SetProp (hwndSheet, Globals.atmRassrvPageData, NULL);
                }  
            }
            break;

        case WM_NOTIFY: 
        {
            NMHDR * pNotifyData = (NMHDR*)lParam;
            
            switch (pNotifyData->code) 
            {
                // The page is becoming active.  
                case PSN_SETACTIVE:
                    DbgOutputTrace(
                        "SetActive: %x %x",
                        pNotifyData->hwndFrom,
                        pNotifyData->idFrom);
                        
                    if (RasSrvActivatePage(hwndDlg, pNotifyData) != NO_ERROR) 
                    {
                        // reject activation
                        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);   
                        return TRUE;
                    }
                    break;

                // Ok was pressed on the property sheet
                case PSN_APPLY:                    
                    RasSrvCommitSettingsOnClose (hwndDlg);
                    break;
            }
       }
       break;
        
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\nettab.c ===
/*
    File    nettab.c

    Implementation of the ui behind the networking tab in the dialup server
    ui.

    Paul Mayfield 10/8/97.
*/

#include <rassrv.h>

// Help maps
static const DWORD phmNetTab[] =
{
    CID_NetTab_LV_Components,       IDH_NetTab_LV_Components,
    CID_NetTab_PB_Add,              IDH_NetTab_PB_Add,
    CID_NetTab_PB_Remove,           IDH_NetTab_PB_Remove,
    CID_NetTab_PB_Properties,       IDH_NetTab_PB_Properties,
    0,                              0
};

//
// Fills in the property sheet structure with the information 
// required to display the networking tab.
//
DWORD 
NetTabGetPropertyPage(
    IN LPPROPSHEETPAGE ppage, 
    IN LPARAM lpUserData) 
{
    // Initialize
    ZeroMemory(ppage, sizeof(PROPSHEETPAGE));

    // Fill in the values
    ppage->dwSize      = sizeof(PROPSHEETPAGE);
    ppage->hInstance   = Globals.hInstDll;
    ppage->pszTemplate = MAKEINTRESOURCE(PID_NetTab);
    ppage->pfnDlgProc  = NetTabDialogProc;
    ppage->pfnCallback = RasSrvInitDestroyPropSheetCb;
    ppage->dwFlags     = PSP_USECALLBACK;
    ppage->lParam      = lpUserData;

    return NO_ERROR;
}

// Error reporting
VOID 
NetTabDisplayError(
    IN HWND hwnd, 
    IN DWORD dwErr) 
{
    ErrDisplayError(
        hwnd, 
        dwErr, 
        ERR_ADVANCEDTAB_CATAGORY, 
        0, 
        Globals.dwErrorData);
}

//
// Returns the index of an to display icon based on the 
// type of incoming connection.
//
INT 
NetTabGetIconIndex(
    IN DWORD dwType) 
{
    switch (dwType) 
    {
        case NETCFGDB_SERVICE:
            return NI_Service;
            
        case NETCFGDB_CLIENT:
            return NI_Client;
            
        case NETCFGDB_PROTOCOL:
            return NI_Protocol;
    }
    
    return 0;
}

//
// Sets up the UI so that the user is forced to complete the 
// config they've started.  Triggered when a non-reversable option 
// is taken such as adding/removing a networking component.
//
DWORD
NetTabDisableRollback(
    IN HWND hwndDlg)
{
    DWORD dwErr, dwId = 0; 

    do
    {
        dwErr = RasSrvGetPageId (hwndDlg, &dwId);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        if (dwId == RASSRVUI_ADVANCED_TAB)
        {
            PropSheet_CancelToClose(GetParent(hwndDlg));
        }
        
    } while (FALSE);

    // Cleanup
    {
    }
    
    return dwErr;
}

//
// Fills in the given list view with the names of the components 
// stored in the  database provided.  
//
DWORD 
NetTabFillComponentList(
    IN HWND hwndLV, 
    IN HANDLE hNetCompDatabase) 
{
    LV_ITEM lvi;
    DWORD dwCount, i, dwErr, dwProtCount, dwType;
    PWCHAR pszName;
    BOOL bManip, bEnabled;

    // Get the count of all the components
    //
    dwErr = netDbGetCompCount (hNetCompDatabase, &dwCount);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    // Initialize the list item
    ZeroMemory(&lvi, sizeof(LV_ITEM));
    lvi.mask = LVIF_TEXT | LVIF_IMAGE;

    // Looop through all of the network components 
    // adding their names as we go
    for (i = 0; i < dwCount; i++) 
    {
        netDbGetType (hNetCompDatabase, i, &dwType);
        netDbIsRasManipulatable (hNetCompDatabase, i, &bManip);
        netDbGetEnable (hNetCompDatabase, i, &bEnabled);

        // Fill in the data
        //
        netDbGetName (hNetCompDatabase, i, &pszName);
        lvi.iImage = NetTabGetIconIndex(dwType);
        lvi.iItem = i;
        lvi.pszText = pszName;
        lvi.cchTextMax = wcslen(pszName)+1;
        ListView_InsertItem(hwndLV,&lvi);
        ListView_SetCheck(hwndLV, i, bEnabled);

        // If this is not a ras manipulateable component, 
        // disable the check since it can't be set anyway.
        if (!bManip) 
        {
            ListView_DisableCheck(hwndLV, i);
        }
    }
    
    return NO_ERROR;
}

//
// Updates the description of the currently selected protocol
//
DWORD 
NetTabUpdateDescription(
    IN HWND hwndDlg, 
    IN DWORD i) 
{
    HANDLE hNetCompDatabase = NULL, hProt = NULL;
    PWCHAR pszDesc;
    DWORD dwErr = NO_ERROR;

    // Get handles to the databases we're interested in
    RasSrvGetDatabaseHandle(
        hwndDlg, 
        ID_NETCOMP_DATABASE, 
        &hNetCompDatabase);

    do
    {
        dwErr = netDbGetDesc(hNetCompDatabase, i, &pszDesc);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // Set the description
        SetDlgItemTextW(
            hwndDlg, 
            CID_NetTab_ST_Description, 
            pszDesc);
        
    } while (FALSE);

    // Cleanup
    {
        if (dwErr != NO_ERROR)
        {
            SetDlgItemTextW(
                hwndDlg, 
                CID_NetTab_ST_Description, 
                L"");
        }
    }

    return dwErr;
}


//
//When an Item in the listview is selected, check if the user can Uninstall it
//for whistler bug 347355           gangz
//
DWORD
NetTabEnableDisableRemoveButton (
    IN HWND hwndDlg,
    IN DWORD iItem)
{
  HANDLE hNetCompDatabase = NULL;
  DWORD  dwErr;
  HWND   hwndRemove = NULL;
  BOOL   bHasPermit = FALSE;

  if ( !hwndDlg )
  {
    return ERROR_INVALID_PARAMETER;
  }
  
  hwndRemove = GetDlgItem(hwndDlg, CID_NetTab_PB_Remove);

  dwErr = RasSrvGetDatabaseHandle(
                hwndDlg, 
                ID_NETCOMP_DATABASE, 
                &hNetCompDatabase);

  if ( NO_ERROR != dwErr || 
       NULL == hwndRemove )
  {
    return ERROR_CAN_NOT_COMPLETE;
  }

  dwErr = netDbHasRemovePermission(
             hNetCompDatabase,
             iItem,
             &bHasPermit);

  if( NO_ERROR == dwErr )
  {
       EnableWindow( hwndRemove, bHasPermit);
  }

  return dwErr;

}


//
// Enables or disables the properties button based on whether
// the index of the given item in the list view can have properties
// invoked on it.  Currently, only non-ras-manaipulatable protocols 
// can not have their properties invoked.
//
DWORD 
NetTabEnableDisablePropButton(
    IN HWND hwndDlg, 
    IN INT iItem) 
{
    HANDLE hNetCompDatabase = NULL;
    DWORD dwErr;
    BOOL bHasUi;

    // Get a reference to the network component database
    //
    RasSrvGetDatabaseHandle(
        hwndDlg, 
        ID_NETCOMP_DATABASE, 
        &hNetCompDatabase);

    // Get the type and whether it is manipulatable
    //
    dwErr = netDbHasPropertiesUI (hNetCompDatabase, iItem, &bHasUi);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    // Enable or disable properties
    EnableWindow(
        GetDlgItem(hwndDlg, CID_NetTab_PB_Properties), 
        bHasUi);
        
    return NO_ERROR;
}

//
// Refreshes the list view
//
DWORD 
NetTabRefreshListView(
    IN HWND hwndLV, 
    IN HANDLE hNetCompDatabase) 
{
    DWORD dwCount, dwErr; 
    HWND hwndDlg = GetParent(hwndLV);   
    
    // Get rid of all of the old elements in the list view
    //
    ListView_DeleteAllItems(hwndLV);
    
    // Re-stock the list views
    //
    dwErr = NetTabFillComponentList(hwndLV, hNetCompDatabase);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    // Select the first protocol in the list view if any items exist.  
    // Also in this case, make sure that "remove" is enabled/disabled
    // according to the the first item in the list view
    //
    netDbGetCompCount(hNetCompDatabase, &dwCount);
    if (dwCount) 
    {
        ListView_SetItemState(
            hwndLV, 
            0, 
            LVIS_SELECTED | LVIS_FOCUSED, 
            LVIS_SELECTED | LVIS_FOCUSED);

      //for whistler bug 406698       gangz
      //
      NetTabEnableDisableRemoveButton (
                           hwndDlg,
                           0);
    }

    // If there are no components, disable the properties 
    // and remove buttons
    else 
    {
        EnableWindow(
            GetDlgItem(hwndDlg, CID_NetTab_PB_Properties), 
            FALSE);
            
        EnableWindow(
            GetDlgItem(hwndDlg, CID_NetTab_PB_Remove), 
            FALSE);
    }

    return NO_ERROR;
}

//
// Initializes the networking tab.  By now a handle to the advanced 
// database has been placed in the user data of the dialog
//
DWORD 
NetTabInitializeDialog(
    HWND hwndDlg, 
    WPARAM wParam)
{
    DWORD dwErr, dwCount, i;
    BOOL bFlag;
    HANDLE hNetCompDatabase = NULL, hMiscDatabase = NULL;
    HWND hwndLV;
    LV_COLUMN lvc;
    BOOL bExpose = FALSE, bIsServer;
    
    // Get handles to the databases we're interested in
    //
    RasSrvGetDatabaseHandle(
        hwndDlg, 
        ID_MISC_DATABASE, 
        &hMiscDatabase);
        
    RasSrvGetDatabaseHandle(
        hwndDlg, 
        ID_NETCOMP_DATABASE, 
        &hNetCompDatabase);

    // Fill in the list view will all available protocols followed 
    // by all of the installed network components.
    //
    hwndLV = GetDlgItem(hwndDlg, CID_NetTab_LV_Components);
    ListView_InstallChecks(hwndLV, Globals.hInstDll);
    ListView_SetNetworkComponentImageList(hwndLV, Globals.hInstDll);

    // Fill the list view
    NetTabRefreshListView(hwndLV, hNetCompDatabase);

    //for whistler bug 347355       gangz
    //
    NetTabEnableDisablePropButton(
         hwndDlg, 
         0);

    NetTabEnableDisableRemoveButton (
         hwndDlg,
         0);

    // Add a colum so that we'll display in report view
    lvc.mask = LVCF_FMT;
    lvc.fmt = LVCFMT_LEFT;
    ListView_InsertColumn(hwndLV,0,&lvc);
    ListView_SetColumnWidth(hwndLV, 0, LVSCW_AUTOSIZE_USEHEADER);

    return NO_ERROR;
}

// Handles a check being made
DWORD 
NetTabHandleProtCheck(
    IN HWND hwndDlg, 
    IN DWORD dwIndex) 
{
    BOOL bEnable = FALSE, bEnabled = FALSE;
    DWORD dwErr = NO_ERROR, dwId = 0;
    HANDLE hNetCompDatabase = NULL;
    HWND hwndLV = 
        GetDlgItem(hwndDlg, CID_NetTab_LV_Components);
    MSGARGS MsgArgs;
    INT iRet;
    PWCHAR pszName = NULL;
    
    // Initailize the message arguments
    //
    ZeroMemory(&MsgArgs, sizeof(MsgArgs));

    // Find out whether the component is being enabled or
    // disabled
    bEnable = !!ListView_GetCheck(hwndLV, dwIndex);

    // Get the handle for the Prot database
    //
    RasSrvGetDatabaseHandle(
        hwndDlg, 
        ID_NETCOMP_DATABASE, 
        &hNetCompDatabase);

    // Get component id
    //
    dwErr = netDbGetId(
                hNetCompDatabase,
                dwIndex,
                &dwId);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    // Get component name
    //
    dwErr = netDbGetName(
                hNetCompDatabase,
                dwIndex,
                &pszName);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    // Get component enabling
    //
    dwErr = netDbGetEnable(
                hNetCompDatabase,
                dwIndex,
                &bEnabled);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    // If F&P is being unchecked, then popup the mmc warning
    //
    if ((dwId == NETCFGDB_ID_FILEPRINT) &&
        (bEnable == FALSE)              && 
        (bEnabled == TRUE))
    {
        // Ask the user whether we should bring up the 
        // mmc console to allow him/her to stop FPS.
        //
        MsgArgs.apszArgs[0] = pszName;
        MsgArgs.dwFlags = MB_YESNO;

        iRet = MsgDlgUtil(
                    GetActiveWindow(),
                    SID_STOP_FP_SERVICE,
                    &MsgArgs,
                    Globals.hInstDll,
                    WRN_TITLE);

        // If the user agrees, bring up the console
        //
        if (iRet == IDYES)
        {
            dwErr = RassrvLaunchMMC(RASSRVUI_SERVICESCONSOLE);
            if (dwErr != NO_ERROR)
            {
                return dwErr;
            }
        }
    }

    // If F&P is not being unchecked, treat the component
    // normally.
    //
    else
    {
        // Update the check
        dwErr = netDbSetEnable(hNetCompDatabase, dwIndex, bEnable);
                    
        if (dwErr != NO_ERROR)
        {
            return dwErr;
        }
    }
    
    return NO_ERROR;
}

//
// Adds networking components
//
DWORD 
NetTabAddComponent(
    IN HWND hwndDlg) 
{
    HANDLE hNetCompDatabase = NULL;
    DWORD dwErr;

    RasSrvGetDatabaseHandle(
        hwndDlg, 
        ID_NETCOMP_DATABASE, 
        &hNetCompDatabase);

    dwErr = netDbRaiseInstallDialog(hNetCompDatabase, hwndDlg);
    if (dwErr == NO_ERROR || dwErr == NETCFG_S_REBOOT)
    {
        NetTabRefreshListView(
            GetDlgItem(hwndDlg, CID_NetTab_LV_Components), 
            hNetCompDatabase);

        NetTabDisableRollback(hwndDlg);            
    }
    if (dwErr == NETCFG_S_REBOOT)
    {
        RasSrvReboot(hwndDlg);
    }
    
    return dwErr;
}

//
// Removes networking components
//
DWORD 
NetTabRemoveComponent(
    IN HWND hwndDlg, 
    IN DWORD dwIndex) 
{
    HANDLE hNetCompDatabase = NULL;
    DWORD dwCount, dwErr;

    RasSrvGetDatabaseHandle(
        hwndDlg, 
        ID_NETCOMP_DATABASE, 
        &hNetCompDatabase);

    // or else, remove the requested component
    //
    dwErr = netDbRaiseRemoveDialog(
                hNetCompDatabase, 
                dwIndex, 
                hwndDlg);
                
    if (dwErr == NO_ERROR || dwErr == NETCFG_S_REBOOT) 
    {
        NetTabRefreshListView(
            GetDlgItem(hwndDlg, CID_NetTab_LV_Components), 
            hNetCompDatabase);

        NetTabDisableRollback(hwndDlg);            
    }
    if (dwErr == NETCFG_S_REBOOT)
    {
        RasSrvReboot(hwndDlg);
    }
    
    return dwErr;
}

// Edits network component properties
//
DWORD 
NetTabEditProperties(
    IN HWND hwndDlg, 
    IN DWORD dwIndex) 
{
    HANDLE hNetCompDatabase = NULL;
    DWORD dwCount, dwErr;

    RasSrvGetDatabaseHandle(
        hwndDlg, 
        ID_NETCOMP_DATABASE, 
        &hNetCompDatabase);

    dwErr = netDbRaisePropertiesDialog (
                hNetCompDatabase, 
                dwIndex, 
                hwndDlg);
                
    if (dwErr == NETCFG_S_REBOOT)
    {
        RasSrvReboot(hwndDlg);
    }

    return dwErr;
}

//
// Switch to mmc
//
DWORD 
NetTabSwitchToMMC(
    IN HWND hwndDlg) 
{
    if (RassrvWarnMMCSwitch(hwndDlg)) 
    {
        // Commit the changes to this property sheet 
        // and close it
        PropSheet_PressButton(GetParent(hwndDlg), PSBTN_OK);
        
        return RassrvLaunchMMC(RASSRVUI_NETWORKCONSOLE);
    }
    
    return ERROR_CANCELLED;
}    

//
// Handles the activation call
//
BOOL 
NetTabSetActive(
    IN HWND hwndDlg,
    IN WPARAM wParam)
{
    HANDLE hNetCompDatabase = NULL;
    DWORD dwErr;
    BOOL bRet = FALSE;
    
    PropSheet_SetWizButtons(GetParent(hwndDlg), 0);
    
    RasSrvGetDatabaseHandle(
        hwndDlg, 
        ID_NETCOMP_DATABASE, 
        &hNetCompDatabase);
        
    if (! netDbIsLoaded(hNetCompDatabase)) 
    {
        dwErr = netDbLoad(hNetCompDatabase);
        if (dwErr == NO_ERROR)
        {
            NetTabInitializeDialog(
                hwndDlg, 
                wParam);
        }
        else 
        {
            NetTabDisplayError(
                hwndDlg, 
                ERR_CANT_SHOW_NETTAB_INETCFG);
                
            // reject activation
            SetWindowLongPtr(
                hwndDlg, 
                DWLP_MSGRESULT,
                -1);   
                
            bRet = TRUE;
        }
    }

    PropSheet_SetWizButtons(
        GetParent(hwndDlg), 
        PSWIZB_NEXT | PSWIZB_BACK);		

    return bRet;
}

//
// When the net tab receives WM_ACTIVATE, it means that 
// the user left the IC property sheet/wizard and is now coming back
// to it.  Since this occurs when switching to MMC update the UI as 
// here appropriate.
//
DWORD
NetTabActivate(
    IN HWND hwndDlg, 
    IN WPARAM wParam)
{    
    HANDLE hNetCompDatabase = NULL;
    DWORD dwErr = NO_ERROR;
    
    if (LOWORD(wParam) == WA_INACTIVE)
    {
        return NO_ERROR;
    }

    DbgOutputTrace("NetTabActivate: updating components.");

    // Get the database handle
    //
    dwErr = RasSrvGetDatabaseHandle(
                hwndDlg, 
                ID_NETCOMP_DATABASE, 
                &hNetCompDatabase);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    // Update the appropriate components
    //
    dwErr = netDbReloadComponent(hNetCompDatabase, NETCFGDB_ID_FILEPRINT);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }
    
    // Refresh the net component list view
    //
    NetTabRefreshListView(
        GetDlgItem(hwndDlg, CID_NetTab_LV_Components),
        hNetCompDatabase);

    return NO_ERROR;        
}

//
// Handles commands
//
DWORD 
NetTabCommand(
    IN HWND hwndDlg,
    IN WPARAM wParam)
{
    switch (wParam) 
    {
        case CID_NetTab_PB_Properties:
            NetTabEditProperties(
                hwndDlg, 
                ListView_GetSelectionMark(
                    GetDlgItem(hwndDlg, CID_NetTab_LV_Components)));
            break;
            
        case CID_NetTab_PB_Add:
            NetTabAddComponent(hwndDlg);
            break;
            
        case CID_NetTab_PB_Remove:
            NetTabRemoveComponent(
                hwndDlg, 
                ListView_GetSelectionMark(
                    GetDlgItem(hwndDlg, CID_NetTab_LV_Components)));
            break;
            
        case CID_NetTab_PB_SwitchToMMC:
            NetTabSwitchToMMC(hwndDlg);
            break;
    }

    return NO_ERROR;
}

//
// This is the dialog procedure that responds to messages sent 
// to the networking tab.
//
INT_PTR 
CALLBACK 
NetTabDialogProc(
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam) 
{
    // Filter the customized list view messages
    if (ListView_OwnerHandler(
            hwndDlg, 
            uMsg, 
            wParam, 
            lParam, 
            LvDrawInfoCallback )
        )
    {        
        return TRUE;
    }

    // Filter the customized ras server ui page messages. 
    // By filtering messages through here, we are able to 
    // call RasSrvGetDatabaseHandle below
    //
    if (RasSrvMessageFilter(hwndDlg, uMsg, wParam, lParam))
    {
        return TRUE;
    }

    switch (uMsg) 
    {
        case WM_INITDIALOG:
            return 0;

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            RasSrvHelp (hwndDlg, uMsg, wParam, lParam, phmNetTab);
            break;
        }


        case WM_NOTIFY:
            {
                NMHDR* pNotifyData;
                NM_LISTVIEW* pLvNotifyData;
    
                pNotifyData = (NMHDR*)lParam;
                switch (pNotifyData->code) 
                {
                    //
                    // Note: PSN_APPLY and PSN_CANCEL are handled
                    // by RasSrvMessageFilter
                    //
                    
                    // The item focus is changing -- update the 
                    // protocol description
                    case LVN_ITEMCHANGING:
                        pLvNotifyData = (NM_LISTVIEW*)lParam;
                        if (pLvNotifyData->uNewState & LVIS_SELECTED) 
                        {
                            NetTabUpdateDescription(
                                hwndDlg, 
                                pLvNotifyData->iItem);
                                
                            NetTabEnableDisablePropButton(
                                hwndDlg, 
                                pLvNotifyData->iItem);

                            //for whistler bug 347355       gangz
                            //
                            NetTabEnableDisableRemoveButton (
                                hwndDlg,
                                (DWORD)pLvNotifyData->iItem);

                        }
                        break;     

                    // The check of an item is changing
                    case LVXN_SETCHECK:
                        pLvNotifyData = (NM_LISTVIEW*)lParam;
                        NetTabHandleProtCheck(
                            hwndDlg, 
                            (DWORD)pLvNotifyData->iItem);
                        break;

                    case LVXN_DBLCLK:
                        pLvNotifyData = (NM_LISTVIEW*)lParam;
                        NetTabEditProperties(
                            hwndDlg, 
                            pLvNotifyData->iItem);
                        break;
                        
                    // The networking tab is becoming active.  
                    // Attempt to load the netcfg database at 
                    // this time.  If unsuccessful, pop up a  
                    // message and don't allow the activation.
                    case PSN_SETACTIVE:
                        return NetTabSetActive(hwndDlg, wParam);
                        break;
                }
            }
            break;

        case WM_ACTIVATE:
            NetTabActivate(hwndDlg, wParam);
            break;

        case WM_COMMAND:
            NetTabCommand(hwndDlg, wParam);
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\protedit.h ===
/*
    File    protedit.h

    Defines mechanisms for editing protocols.

    Paul Mayfield, 11/11/97
*/

#ifndef __rassrvui_protedit_h
#define __rassrvui_protedit_h

#include <windows.h>
#include "rassrv.h"

// Structure that defines data that is needed in order to 
// edit the properties of a given protocol for the ras server
// ui under connections.
typedef struct _PROT_EDIT_DATA {
    BOOL bExpose;       // whether to expose the network the ras server is
                        // connected to for the given protocol.
    LPBYTE pbData;      // Data specific to the protocol in question.
} PROT_EDIT_DATA;

#include "ipxui.h"
#include "tcpipui.h"

// Function edits the properties of a generic protocol, that is a protocol that
// has no ras-specific properties.
DWORD GenericProtocolEditProperties(IN HWND hwndParent,                 // Parent window
                                    IN OUT PROT_EDIT_DATA * pEditData,  // Edit data
                                    IN OUT BOOL * pbOk);                // Was ok pressed?

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\rassrvui.c ===
/*
    File    rassrvui.c

    Entry point implementation for the connections dialup server ui dll.

    Paul Mayfield, 9/29/97
    Much code was borrowed from stevec's rasdlg.
*/

#include "rassrv.h"

//
// Called to add property pages for the dialup server property sheet
//
DWORD
RasSrvAddPropPage(
    IN LPPROPSHEETPAGE lpPage,
    IN RASSRV_PAGE_CONTEXT * pPageData)
{
    DWORD dwErr = ERROR_UNKNOWN_PROPERTY;

    switch(pPageData->dwId)
    {
        case RASSRVUI_GENERAL_TAB:
            dwErr = GenTabGetPropertyPage (lpPage, (LPARAM)pPageData);
            break;

        case RASSRVUI_USER_TAB:
            dwErr = UserTabGetPropertyPage (lpPage, (LPARAM)pPageData);
            break;

        case RASSRVUI_ADVANCED_TAB:
            dwErr = NetTabGetPropertyPage (lpPage, (LPARAM)pPageData);
            break;

        case RASSRVUI_DEVICE_WIZ_TAB:
            dwErr = DeviceWizGetPropertyPage (lpPage, (LPARAM)pPageData);
            break;

        case RASSRVUI_VPN_WIZ_TAB:
            dwErr = VpnWizGetPropertyPage (lpPage, (LPARAM)pPageData);
            break;

        case RASSRVUI_USER_WIZ_TAB:
            dwErr = UserWizGetPropertyPage (lpPage, (LPARAM)pPageData);
            break;

        case RASSRVUI_PROT_WIZ_TAB:
            dwErr = ProtWizGetPropertyPage (lpPage, (LPARAM)pPageData);
            break;

        case RASSRVUI_DCC_DEVICE_WIZ_TAB:
            dwErr = DccdevWizGetPropertyPage (lpPage, (LPARAM)pPageData);
            break;

        case RASSRVUI_SWITCHMMC_WIZ_TAB:
            dwErr = SwitchMmcWizGetProptertyPage (lpPage, (LPARAM)pPageData);
            break;
    }

    return dwErr;
}

//
// Helper function might make code easier to read.
//
DWORD
AddPageHelper (
    IN DWORD dwPageId,
    IN DWORD dwType,
    IN PVOID pvContext,
    IN LPFNADDPROPSHEETPAGE pfnAddPage,
    IN LPARAM lParam)
{
    DWORD dwErr;
    HPROPSHEETPAGE hPropPage;
    PROPSHEETPAGE PropPage;
    RASSRV_PAGE_CONTEXT * pPageCtx = NULL;

    // Initialize the page data to send.  RassrvMessageFilter will
    // clean this stuff up.
    pPageCtx = RassrvAlloc(sizeof (RASSRV_PAGE_CONTEXT), TRUE);
    if (pPageCtx == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    pPageCtx->dwId = dwPageId;
    pPageCtx->dwType = dwType;
    pPageCtx->pvContext = pvContext;

    // Create the tab and add it to the property sheet
    if ((dwErr = RasSrvAddPropPage(&PropPage, pPageCtx)) != NO_ERROR)
    {
        return dwErr;
    }

    if ((hPropPage = CreatePropertySheetPage(&PropPage)) == NULL)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    if (! (*pfnAddPage)(hPropPage, lParam))
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    return NO_ERROR;
}

//
// Helper function generates a connection name based on the data
// returned from MprApi calls.
//
DWORD
GenerateConnectionName(
    IN  RAS_CONNECTION_2 * pConn,
    OUT PWCHAR pszNameBuffer)
{
    NET_API_STATUS nStatus;
    USER_INFO_2 * pUserInfo;
    DWORD dwFullNameLength;

    // Get the full name
    nStatus = NetUserGetInfo(
                    NULL,
                    pConn->wszUserName,
                    2,
                    (LPBYTE*)&pUserInfo);

    if (nStatus == NERR_Success)
    {
        dwFullNameLength = wcslen(pUserInfo->usri2_full_name);
        if (dwFullNameLength)
        {
            wsprintfW(
                pszNameBuffer,
                L"%s (%s)",
                pConn->wszUserName,
                pUserInfo->usri2_full_name);
        }
        else
        {
            lstrcpynW(
                pszNameBuffer,
                pConn->wszUserName,
                sizeof(pConn->wszUserName) / sizeof(WCHAR));
        }

        NetApiBufferFree((LPBYTE)pUserInfo);
    }
    else
    {
        lstrcpynW(
            pszNameBuffer,
            pConn->wszUserName,
            sizeof(pConn->wszUserName) / sizeof(WCHAR));
    }

    return NO_ERROR;
}

//
// Generate the connection type and device name
//
DWORD
GenerateConnectionDeviceInfo (
    RAS_CONNECTION_2 * pConn,
    LPDWORD lpdwType,
    PWCHAR pszDeviceName)
{
    DWORD dwErr, dwRead, dwTot, dwType, dwClass;
    RAS_PORT_0 * pPort = NULL;
    RASMAN_INFO Info;

    // Initialize the variables
    *lpdwType = 0;
    *pszDeviceName = (WCHAR)0;

    gblConnectToRasServer();

    do
    {
        // Enumerate the ports
        //
        dwErr = MprAdminPortEnum(
                    Globals.hRasServer,
                    0,
                    pConn->hConnection,
                    (LPBYTE*)&pPort,
                    sizeof(RAS_PORT_0) * 2,
                    &dwRead,
                    &dwTot,
                    NULL);
        if (dwErr != NO_ERROR)
        {
            break;
        }
        if (dwRead == 0)
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        // Get extended information about the first
        // port
        //
        dwErr = RasGetInfo(NULL, pPort->hPort, &Info);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        dwClass = RAS_DEVICE_CLASS(Info.RI_rdtDeviceType);
        dwType = RAS_DEVICE_TYPE(Info.RI_rdtDeviceType);

        lstrcpynW(
            pszDeviceName,
            pPort[0].wszDeviceName,
            MAX_DEVICE_NAME + 1);
        if ((dwClass & RDT_Direct) || (dwClass & RDT_Null_Modem))
        {
            *lpdwType = RASSRVUI_DCC;
        }
        else if (dwClass & RDT_Tunnel)
        {
            *lpdwType = RASSRVUI_VPN;
        }
        else
        {
            *lpdwType = RASSRVUI_MODEM;
        }

    } while (FALSE);

    // Cleanup
    {
        if (pPort)
        {
            MprAdminBufferFree((LPBYTE)pPort);
        }
    }

    return dwErr;
}

//
// Starts the remote access service and marks it as autostart
//
DWORD
RasSrvInitializeService()
{
    DWORD dwErr = NO_ERROR, dwTimeout = 60*2;
    HANDLE hDialupService, hData = NULL;
    BOOL bInitialized = FALSE;

    // Get a reference to the service
    if ((dwErr = SvcOpenRemoteAccess(&hDialupService)) != NO_ERROR)
    {
        return dwErr;
    }

    do
    {
        RasSrvShowServiceWait(
            Globals.hInstDll,
            GetActiveWindow(),
            &hData);

        // First, mark the service as autostart
        if ((dwErr = SvcMarkAutoStart(hDialupService)) != NO_ERROR)
        {
            break;
        }

        // Start it (with a 5 minute timeout)
        dwErr = SvcStart(hDialupService, 60*5);
        if (dwErr == ERROR_TIMEOUT)
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

        // Wait for the service to complete initialization
        //
        while (dwTimeout)
        {
            bInitialized = MprAdminIsServiceRunning(NULL);
            if (bInitialized)
            {
                break;
            }
            Sleep(1000);
            dwTimeout--;
        }
        if (dwTimeout == 0)
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }

    } while (FALSE);

    // Cleanup
    //
    {
        RasSrvFinishServiceWait(hData);

        // Cleanup the reference to the dialup service
        SvcClose(hDialupService);
    }

    return dwErr;
}

//
// Stops and marks the remote access service as disabled.
//
DWORD
RasSrvCleanupService()
{
    DWORD dwErr = NO_ERROR;
    HANDLE hDialupService, hData = NULL;
    BOOL fIcRunningBefore = FALSE;
    BOOL fIcRunningAfter = FALSE;

    RasSrvIsServiceRunning( &fIcRunningBefore );

    // Get a reference to the service
    if ((dwErr = SvcOpenRemoteAccess(&hDialupService)) != NO_ERROR)
    {
        return dwErr;
    }

    do
    {
        RasSrvShowServiceWait(
            Globals.hInstDll,
            GetActiveWindow(),
            &hData);

        // First, stop the service (with a 5 minute timeout)
        //
        dwErr = SvcStop(hDialupService, 60*5);
        if (dwErr == ERROR_TIMEOUT)
        {
            dwErr = ERROR_CAN_NOT_COMPLETE;
            break;
        }
        if (dwErr != NO_ERROR)
        {
            break;
        }


        // Mark it as disabled
        if ((dwErr = SvcMarkDisabled(hDialupService)) != NO_ERROR)
        {
            break;
        }

    } while (FALSE);

    // Cleanup
    //
    {
        RasSrvFinishServiceWait(hData);
        SvcClose(hDialupService);
    }

    //For whistler bug 123769
    //If the this connection to be deleted is Incoming connection
    //go to disable PortMapping

    if ( NO_ERROR == RasSrvIsServiceRunning( &fIcRunningAfter ) )
     {
        if ( fIcRunningBefore && !fIcRunningAfter )
        {
            dwErr = HnPMConfigureAllConnections( FALSE );

		//this is taken out because we decide not to delete the portmappings,
		//just disable them instead. I keep this just for future reference.  gangz
		//
		
        //    if (NO_ERROR == dwErr )
        //    {
        //        dwErr = HnPMDeletePortMapping();
        //    }
        }
      }

    return dwErr;
}

//
// Reports whether the dialup service is running
//
DWORD
APIENTRY
RasSrvIsServiceRunning (
    OUT BOOL* pfIsRunning)
{
    DWORD dwErr = NO_ERROR;
    HANDLE hDialupService = NULL;

    // Get a reference to the service
    if ((dwErr = SvcOpenRemoteAccess(&hDialupService)) != NO_ERROR)
    {
        return dwErr;
    }

    do
    {
        // Get the current status.  SvcIsStarted checks the validity
        // of the pfIsRunning parameter.
        dwErr = SvcIsStarted(hDialupService, pfIsRunning);
        if (dwErr != NO_ERROR)
        {
            break;
        }

    } while (FALSE);

    // Cleanup
    {
        // Cleanup the reference to the dialup service
        SvcClose(hDialupService);
    }

    return NO_ERROR;
}

//
// Returns whether the conenctions wizard should be allowed to show.
//
DWORD
APIENTRY
RasSrvAllowConnectionsWizard (
    OUT BOOL* pfAllow)
{
    DWORD dwErr = NO_ERROR, dwFlags = 0;

    if (!pfAllow)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Initialize the product type
    if ((dwErr = RasSrvGetMachineFlags (&dwFlags)) != NO_ERROR)
    {
        return dwErr;
    }

    // Member or domain servers are not allowed to be shown
    if ((dwFlags & RASSRVUI_MACHINE_F_Server) &&
        (dwFlags & RASSRVUI_MACHINE_F_Member))
    {
        *pfAllow = FALSE;
    }
    else
    {
        *pfAllow = TRUE;
    }

    return NO_ERROR;
}

//
// On ntw or standalone nts, returns result of RasSrvIsServiceRunning.
// Otherwise returns false.
//
DWORD
APIENTRY
RasSrvAllowConnectionsConfig (
    OUT BOOL* pfAllow)
{
    BOOL bAllowWizard;
    DWORD dwErr;

    if ((dwErr = RasSrvAllowConnectionsWizard (&bAllowWizard)) != NO_ERROR)
    {
        return dwErr;
    }

    if (bAllowWizard)
    {
        return RasSrvIsServiceRunning(pfAllow);
    }

    *pfAllow = FALSE;
    return NO_ERROR;
}

//
// Checks to see if remote access service is installed
//
BOOL
RasSrvIsRemoteAccessInstalled ()
{
    const WCHAR pszServiceKey[] =
        L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess";
    HKEY hkService = NULL;
    DWORD dwErr = NO_ERROR;

    // Attempt to open the service registry key
    dwErr = RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                pszServiceKey,
                0,
                KEY_READ | KEY_WRITE,
                &hkService);

    // If we opened the key ok, then we can assume
    // that the service is installed
    if (dwErr == ERROR_SUCCESS)
    {
        RegCloseKey(hkService);
        return TRUE;
    }

    return FALSE;
}

//
// Adds the required tabs to the incoming connections property sheet.
//
DWORD
APIENTRY
RasSrvAddPropPages (
    IN HRASSRVCONN          hRasSrvConn,
    IN HWND                 hwndParent,
    IN LPFNADDPROPSHEETPAGE pfnAddPage,
    IN LPARAM               lParam,
    IN OUT PVOID *          ppvContext)
{
    DWORD dwErr;

    // Check parameters
    if (!pfnAddPage || !ppvContext)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Make sure remote access is installed
    if (!RasSrvIsRemoteAccessInstalled())
    {
        return ERROR_SERVICE_DEPENDENCY_FAIL;
    }

    // Create the context for this page
    if ((dwErr = RassrvCreatePageSetCtx(ppvContext)) != NO_ERROR)
    {
        return dwErr;
    }

    // Add the tabs
    AddPageHelper(RASSRVUI_GENERAL_TAB,
                  RASWIZ_TYPE_INCOMING,
                  *ppvContext,
                  pfnAddPage,
                  lParam);

    AddPageHelper(RASSRVUI_USER_TAB,
                  RASWIZ_TYPE_INCOMING,
                  *ppvContext,
                  pfnAddPage,
                  lParam);

    AddPageHelper(RASSRVUI_ADVANCED_TAB,
                  RASWIZ_TYPE_INCOMING,
                  *ppvContext,
                  pfnAddPage,
                  lParam);

    return NO_ERROR;
}

//
// Adds the required tabs to the incoming connections wizard
//
DWORD
APIENTRY
RasSrvAddWizPages (
    IN LPFNADDPROPSHEETPAGE pfnAddPage,
    IN LPARAM               lParam,
    IN OUT PVOID *          ppvContext)
{
    DWORD dwErr;
    BOOL bAllowWizard;

    // Check parameters
    if (!pfnAddPage || !ppvContext)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Make sure remote access is installed
    if (!RasSrvIsRemoteAccessInstalled())
    {
        return ERROR_SERVICE_DEPENDENCY_FAIL;
    }

    // Find out if configuration through connections is allowed
    dwErr = RasSrvAllowConnectionsWizard (&bAllowWizard);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    // Create the context for this page
    if ((dwErr = RassrvCreatePageSetCtx(ppvContext)) != NO_ERROR)
    {
        return dwErr;
    }

    // If configuration is allowed, add the wizard pages as normal
    if (bAllowWizard)
    {
        // Add the tabs
        AddPageHelper(RASSRVUI_DEVICE_WIZ_TAB,
                      RASWIZ_TYPE_INCOMING,
                      *ppvContext,
                      pfnAddPage,
                      lParam);

        AddPageHelper(RASSRVUI_VPN_WIZ_TAB,
                      RASWIZ_TYPE_INCOMING,
                      *ppvContext,
                      pfnAddPage,
                      lParam);

        AddPageHelper(RASSRVUI_USER_WIZ_TAB,
                      RASWIZ_TYPE_INCOMING,
                      *ppvContext,
                      pfnAddPage,
                      lParam);

        AddPageHelper(RASSRVUI_PROT_WIZ_TAB,
                      RASWIZ_TYPE_INCOMING,
                      *ppvContext,
                      pfnAddPage,
                      lParam);
    }

    // Otherwise, add the bogus page that
    // switches to mmc.
    else
    {
        // Add the tabs
        AddPageHelper(RASSRVUI_SWITCHMMC_WIZ_TAB,
                      RASWIZ_TYPE_INCOMING,
                      *ppvContext,
                      pfnAddPage,
                      lParam);
    }

    return NO_ERROR;
}

//
// Function adds the host-side direct connect wizard pages
//
DWORD
APIENTRY
RassrvAddDccWizPages(
    IN LPFNADDPROPSHEETPAGE pfnAddPage,
    IN LPARAM               lParam,
    IN OUT PVOID *          ppvContext)
{
    DWORD dwErr;
    BOOL bAllowWizard;

    // Check parameters
    if (!pfnAddPage || !ppvContext)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Make sure remote access is installed
    if (!RasSrvIsRemoteAccessInstalled())
    {
        return ERROR_SERVICE_DEPENDENCY_FAIL;
    }

    // Find out if configuration through connections is allowed
    dwErr = RasSrvAllowConnectionsWizard (&bAllowWizard);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    // Create the context for this page
    if ((dwErr = RassrvCreatePageSetCtx(ppvContext)) != NO_ERROR)
    {
        return dwErr;
    }

    if (bAllowWizard)
    {
        // Add the tabs
        AddPageHelper(RASSRVUI_DCC_DEVICE_WIZ_TAB,
                      RASWIZ_TYPE_DIRECT,
                      *ppvContext,
                      pfnAddPage,
                      lParam);

        AddPageHelper(RASSRVUI_USER_WIZ_TAB,
                      RASWIZ_TYPE_DIRECT,
                      *ppvContext,
                      pfnAddPage,
                      lParam);
    }

    // Otherwise, add the bogus page that
    // switches to mmc.
    else
    {
        // Add the tabs
        AddPageHelper(RASSRVUI_SWITCHMMC_WIZ_TAB,
                      RASWIZ_TYPE_DIRECT,
                      *ppvContext,
                      pfnAddPage,
                      lParam);
    }

    return NO_ERROR;
}

//
// Function returns the suggested name for an incoming connection.
//
DWORD
APIENTRY
RassrvGetDefaultConnectionName (
    IN OUT PWCHAR pszBuffer,
    IN OUT LPDWORD lpdwBufSize)
{
    PWCHAR pszName;
    DWORD dwLen;

    // Load the resource string
    pszName = (PWCHAR) PszLoadString(
                            Globals.hInstDll,
                            SID_DEFAULT_CONNECTION_NAME);

    // Calculate length
    dwLen = wcslen(pszName);
    if (dwLen > *lpdwBufSize)
    {
        *lpdwBufSize = dwLen;
        return ERROR_INSUFFICIENT_BUFFER;
    }

    // Return the result
    wcscpy(pszBuffer, pszName);
    *lpdwBufSize = dwLen;

    return NO_ERROR;
}

//
// Function behaves anagolously to the WIN32 function RasEnumConnections
// but for client connections instead of dialout connections.
//
DWORD
RasSrvEnumConnections(
    IN  LPRASSRVCONN pRasSrvCon,
    OUT LPDWORD lpcb,
    OUT LPDWORD lpcConnections)
{
    DWORD dwErr = NO_ERROR, dwEntriesRead, dwTotal, dwFlags = 0;
    DWORD dwPrefMax = 1000000, i, dwSizeNeeded = 0;
    RAS_CONNECTION_2 * pConnList;
    BOOL bCopy = TRUE;

    // Sanity Check
    if (!pRasSrvCon || !lpcb || !lpcConnections)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // We do not allow IC ui for member servers
    //
    RasSrvGetMachineFlags(&dwFlags);
    if ((dwFlags & RASSRVUI_MACHINE_F_Server) &&
        (dwFlags & RASSRVUI_MACHINE_F_Member))
    {
        *lpcb = 0;
        *lpcConnections = 0;
        return NO_ERROR;
    }

    //
    // Get the MprAdmin handle
    //
    gblConnectToRasServer();

    do
    {
        // Enumerate the structures
        dwErr = MprAdminConnectionEnum (
                    Globals.hRasServer,
                    2,
                    (LPBYTE *)&pConnList,
                    dwPrefMax,
                    &dwEntriesRead,
                    &dwTotal,
                    NULL);
        if (dwErr != NO_ERROR)
        {
            DbgOutputTrace ("MprAdminEnum failed %x\n", dwErr);
            break;
        }

        // Reuse the dwTotal variable
        dwTotal = 0;
        dwSizeNeeded = 0;

        // Copy over the pertanent information
        for (i = 0; i < dwEntriesRead; i++)
        {
            if (pConnList[i].dwInterfaceType == ROUTER_IF_TYPE_CLIENT)
            {
                dwSizeNeeded += sizeof (RASSRVCONN);
                if (dwSizeNeeded > *lpcb)
                {
                    bCopy = FALSE;
                }
                if (bCopy)
                {
                    // Connection handle
                    pRasSrvCon[dwTotal].hRasSrvConn =
                        pConnList[i].hConnection;

                    // Name
                    dwErr = GenerateConnectionName(
                                &pConnList[i],
                                pRasSrvCon[dwTotal].szEntryName);
                    if (dwErr != NO_ERROR)
                    {
                        continue;
                    }

                    // Type and Device Name
                    dwErr = GenerateConnectionDeviceInfo(
                                &pConnList[i],
                                &(pRasSrvCon[dwTotal].dwType),
                                pRasSrvCon[dwTotal].szDeviceName);
                    if (dwErr != NO_ERROR)
                    {
                        continue;
                    }

                    // Guid
                    pRasSrvCon[dwTotal].Guid = pConnList[i].guid;

                    dwTotal++;
                }
            }
        }

        *lpcb = dwSizeNeeded;
        *lpcConnections = dwTotal;

    } while (FALSE);

    // Cleanup
    {
        MprAdminBufferFree((LPBYTE)pConnList);
    }

    if (!bCopy)
    {
        dwErr = ERROR_BUFFER_TOO_SMALL;
    }

    return dwErr;
}

//
// Gets the status of a Ras Server Connection
//
DWORD
APIENTRY
RasSrvIsConnectionConnected (
    IN  HRASSRVCONN hRasSrvConn,
    OUT BOOL*       pfConnected)
{
    RAS_CONNECTION_2 * pConn;
    DWORD dwErr;

    // Sanity check the parameters
    if (!pfConnected)
    {
        return ERROR_INVALID_PARAMETER;
    }

    gblConnectToRasServer();

    // Query rasman for the connection information
    dwErr = MprAdminConnectionGetInfo(
                Globals.hRasServer,
                0,
                hRasSrvConn,
                (LPBYTE*)&pConn);
    if (dwErr != NO_ERROR)
    {
        *pfConnected = FALSE;
    }
    else
    {
        *pfConnected = TRUE;
    }

    if (pfConnected)
    {
        MprAdminBufferFree((LPBYTE)pConn);
    }

    return NO_ERROR;
}

//
// Hangs up the given connection
//
DWORD
RasSrvHangupConnection(
    IN HRASSRVCONN hRasSrvConn)
{
     RAS_PORT_0 * pPorts;
     DWORD dwRead, dwTot, dwErr, i, dwRet = NO_ERROR;

    gblConnectToRasServer();

    // Enumerate all of the ports on this connection
    dwErr = MprAdminPortEnum(
                Globals.hRasServer,
                0,
                hRasSrvConn,
                (LPBYTE*)&pPorts,
                4096,
                &dwRead,
                &dwTot,
                NULL);
     if (dwErr != NO_ERROR)
     {
        return dwErr;
     }

    // Hang up each of the ports individually
    for (i = 0; i < dwRead; i++)
    {
        dwErr = MprAdminPortDisconnect(
                    Globals.hRasServer,
                    pPorts[i].hPort);

        if (dwErr != NO_ERROR)
        {
            dwRet = dwErr;
        }
    }
    MprAdminBufferFree((LPBYTE)pPorts);

    return dwRet;
}

//
// Queries whether to show icons in the task bar.
//
DWORD
APIENTRY
RasSrvQueryShowIcon (
    OUT BOOL* pfShowIcon)
{
    DWORD dwErr = NO_ERROR;
    HANDLE hMiscDatabase = NULL;

    if (!pfShowIcon)
    {
        return ERROR_INVALID_PARAMETER;
    }

    do
    {
        // Open a copy of the miscellaneous database
        dwErr = miscOpenDatabase(&hMiscDatabase);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // Return the status
        dwErr = miscGetIconEnable(hMiscDatabase, pfShowIcon);
        if (dwErr != NO_ERROR)
        {
            break;
        }

    } while (FALSE);

    // Cleanup
    {
        if (hMiscDatabase)
        {
            miscCloseDatabase(hMiscDatabase);
        }
    }

    return dwErr;
}

// ===================================
// ===================================
// Dll entry management
// ===================================
// ===================================

//
// Called when another process attaches to this dll
//
DWORD
RassrvHandleProcessAttach(
    IN HINSTANCE hInstDll,
    IN LPVOID pReserved)
{
    // Initialize global variables
    //
    return gblInit(hInstDll, &Globals);
}

//
// Called when process detaches from this dll
//
DWORD
RassrvHandleProcessDetach(
    IN HINSTANCE hInstDll,
    IN LPVOID pReserved)
{
    // Cleanup global variables
    //
    return gblCleanup(&Globals);
}

//
// Called when thread attaches to this dll
//
DWORD
RassrvHandleThreadAttach(
    IN HINSTANCE hInstDll,
    IN LPVOID pReserved)
{
    return NO_ERROR;
}

//
// Called when thread detaches from this dll
//
DWORD
RassrvHandleThreadDetach(
    IN HINSTANCE hInstDll,
    IN LPVOID pReserved)
{
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\rassrv.h ===
/*
    File    Rassrv.h

    Functions that perform ras server operations that can be implemented 
    independent of the ui.

    Paul Mayfield, 10/7/97
*/

#ifndef __rassrv_h
#define __rassrv_h

// Standard includes
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>	    // Windows base lib
#include <windowsx.h>
#include <mprapi.h>	        // Public router api's
#include <mprapip.h>        // Private router api's
#include <commctrl.h>	    // Common controls header
#include <lmaccess.h>	    // Needed to add new users
#include <lmapibuf.h>	    // " "         "  "
#include <lmerr.h>	        // " "         "  "
#include <stdlib.h>	        // duh
#include <uiutil.h>	        // Common ui utilities
#include <popupdlg.h>       // Msg box utilities
#include <debug.h>          // Trace/assert library
#include <inetcfgp.h>       // INetCfg interfaces
#include <rasman.h>         // rasman stuff used in devicedb
#include <dsrole.h>         // is this machine ntw, nts, dc, etc?
#include <raserror.h>		// some ras error codes we return
#include <devguid.h>


#define _PNP_POWER_
#include <ntdef.h>
#include "ndispnp.h"
#include "ntddip.h"			// IP_PNP_RECONFIG_REQUEST



// temporary
#include <stdio.h>	  // duh

// Definition of interface between shell and ras server ui
#include <rasuip.h>

// The resource file is in a common directory so that it gets
// built into rasdlg.dll.  Also, the help id file.
#include <rassrvrc.h>
#include <rassrvrh.h>

// Includes within the project
#include "utils.h"
#include "devicedb.h"
#include "hnportmapping.h"
#include "miscdb.h"
#include "userdb.h"
#include "netcfgdb.h"
#include "gentab.h"
#include "usertab.h"
#include "nettab.h"
#include "wizard.h"
#include "service.h"
#include "error.h"
#include "ipxui.h"
#include "tcpipui.h"
#include "mdm.h"

// ============================================================
// ============================================================
// Tab and property sheet identifiers.
// ============================================================
// ============================================================

// Property Sheet Page ID's
#define RASSRVUI_GENERAL_TAB        1
#define RASSRVUI_USER_TAB           2
#define RASSRVUI_ADVANCED_TAB       4
#define RASSRVUI_MULTILINK_TAB      8

// Wizard Page ID's
#define RASSRVUI_DEVICE_WIZ_TAB     16
#define RASSRVUI_VPN_WIZ_TAB        32
#define RASSRVUI_USER_WIZ_TAB       64
#define RASSRVUI_PROT_WIZ_TAB       128
#define RASSRVUI_FINISH_WIZ_TAB     256

// Wizard Page ID's for the direct connect wizard (host)
#define RASSRVUI_DCC_DEVICE_WIZ_TAB 512

// Wizard Page ID that allows us to pop up warning and 
// switch to mmc
#define RASSRVUI_SWITCHMMC_WIZ_TAB  1024

// Console page id's to be used for launching mmc consoles.
#define RASSRVUI_NETWORKCONSOLE     1
#define RASSRVUI_USERCONSOLE        2
#define RASSRVUI_MPRCONSOLE         3
#define RASSRVUI_SERVICESCONSOLE    4

// Wizard page counts to report to the shell
#define RASSRVUI_WIZ_PAGE_COUNT_INCOMING 5
#define RASSRVUI_WIZ_PAGE_COUNT_SWITCH   1
#define RASSRVUI_WIZ_PAGE_COUNT_DIRECT   2

// Reasons for restarting remoteaccess at commit time
#define RASSRVUI_RESTART_REASON_NONE            0
#define RASSRVUI_RESTART_REASON_NBF_ADDED       1
#define RASSRVUI_RESTART_REASON_NBF_REMOVED     2

// ============================================================
// ============================================================
// Functions to maintain data accross property sheet pages.
// ============================================================
// ============================================================

//
// This structure defines the information that needs 
// to be provided for each property sheet (wizard) page
// that uses the RasSrvMessageFilter.  The structure must be 
// passed in as the lParam member of the PROPSHEETPAGE of the page.
// 
typedef struct _RASSRV_PAGE_CONTEXT {
    DWORD dwId;         // ID_XXX value below
    DWORD dwType;       // RASWIZ_TYPE_XXX value
    PVOID pvContext;    // Created with RasSrvCreateContext
} RASSRV_PAGE_CONTEXT;

#define ID_DEVICE_DATABASE 1
#define ID_USER_DATABASE 2
#define ID_PROTOCOL_DATABASE 4
#define ID_MISC_DATABASE 8
#define ID_NETCOMP_DATABASE 16

// Helper function lets us know if we should display the
// connections ras server wizard.
DWORD 
APIENTRY
RasSrvAllowConnectionsWizard (
    OUT BOOL* pfAllow);
    
// Creates a context to be used to manage information associated 
// with a given page.
DWORD 
RassrvCreatePageSetCtx(
    OUT PVOID * ppvContext);

// Causes the remoteaccess service to not be stopped even if the context
// associated with the given property sheet page is never committed.
DWORD 
RasSrvLeaveServiceRunning (
    IN HWND hwndPage);

// Gets a handle to a particular database.  If this database needs 
// to be opened, it will be opened.  In order to use this function, 
// the window proc of hwndPage must first call into RasSrvMessageFilter.
DWORD 
RasSrvGetDatabaseHandle(
    IN HWND hwndPage, 
    IN DWORD dwDatabaseId, 
    IN HANDLE * hDatabase);

// Returns the id of the page whose handle is hwndPage
DWORD 
RasSrvGetPageId (
    IN  HWND hwndPage, 
    OUT LPDWORD lpdwId);

//
// Callback function for property sheet pages that cleans up 
// the page.
//
UINT 
CALLBACK 
RasSrvInitDestroyPropSheetCb(
    IN HWND hwndPage,
    IN UINT uMsg,
    IN LPPROPSHEETPAGE pPropPage);

// Filters messages for RasSrv Property Pages.  If this function returns 
// true, the winproc of the dialog window should return true immediately.  
// Otherwise message processing may continue as normal.
BOOL 
RasSrvMessageFilter(
    IN HWND hwndDlg, 
    IN UINT uMsg, 
    IN WPARAM wParam, 
    IN LPARAM lParam);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\tcpipui.c ===
/*
    File    tcpipui.c

    Dialog that edits the tcpip properties.
    
    Paul Mayfield, 10/9/97
*/

#include "rassrv.h"

#define IDH_DISABLEHELP	((DWORD)-1)

// Help maps
static const DWORD phmTcpipui[] =
{
    CID_NetTab_Tcpipui_CB_ExposeNetwork,    IDH_NetTab_Tcpipui_CB_ExposeNetwork, 
    CID_NetTab_Tcpipui_EB_Start,            IDH_NetTab_Tcpipui_EB_Start,
    CID_NetTab_Tcpipui_RB_Dhcp,             IDH_NetTab_Tcpipui_RB_Dhcp,
    CID_NetTab_Tcpipui_RB_StaticPool,       IDH_NetTab_Tcpipui_RB_StaticPool, 
    CID_NetTab_Tcpipui_EB_Mask,             IDH_NetTab_Tcpipui_EB_Mask,      
    CID_NetTab_Tcpipui_CB_CallerSpec,       IDH_NetTab_Tcpipui_CB_CallerSpec, 
    CID_NetTab_Tcpipui_EB_Range,            IDH_DISABLEHELP,          
    CID_NetTab_Tcpipui_EB_Total,            IDH_DISABLEHELP,
    0,                                      0
};

// Error reporting
void 
TcpipUiDisplayError(
    HWND hwnd, 
    DWORD dwErr) 
{
    ErrDisplayError(
        hwnd, 
        dwErr, 
        ERR_TCPIPPROP_CATAGORY, 
        0, 
        Globals.dwErrorData);
}

// Converts a dword ip address (in host order) to a wide character string 
//
DWORD 
TcpipDwordToAddr(
    DWORD dwAddr, 
    PWCHAR pszAddr) 
{
    wsprintfW(
        pszAddr, 
        L"%d.%d.%d.%d", 
        FIRST_IPADDRESS (dwAddr),
        SECOND_IPADDRESS(dwAddr),
        THIRD_IPADDRESS (dwAddr),
        FOURTH_IPADDRESS(dwAddr));
        
    return NO_ERROR;
}

// 
// Returns NO_ERROR if the given address is a valid IP pool.
// The offending component is returned in lpdwErrReason.  
// See RASIP_F_* values
//
DWORD
TcpipUiValidatePool(
    IN  DWORD dwAddress, 
    IN  DWORD dwEnd, 
    OUT LPDWORD lpdwErrReason 
    )
{
    DWORD i, dwMaskMask;
    DWORD dwLowIp, dwHighIp, dwErr;

    // Initialize
    //
    dwLowIp = MAKEIPADDRESS(1,0,0,0);
    dwHighIp = MAKEIPADDRESS(224,0,0,0);

    // Make sure that the netId is a valid class 
    //
    if ((dwAddress < dwLowIp)               || 
        (dwAddress >= dwHighIp)             ||
        (FIRST_IPADDRESS(dwAddress) == 127))
    {
        *lpdwErrReason = SID_TCPIP_InvalidNetId;
        return ERROR_BAD_FORMAT;
    }

    // Make sure the pool base is not more specific than
    // the mask
    //
    if (dwAddress >= dwEnd)
    {
        *lpdwErrReason = SID_TCPIP_NetidMaskSame;
        return ERROR_BAD_FORMAT;
    }

    return NO_ERROR;
}


// Enables/disables windows in the dialog box depending
// on the tcpip parameters
//
DWORD 
TcpipEnableWindows(
    HWND hwndDlg, 
    TCPIP_PARAMS * pTcpipParams) 
{
    EnableWindow(
        GetDlgItem(
            hwndDlg, 
            CID_NetTab_Tcpipui_EB_Start), 
        !pTcpipParams->bUseDhcp);
            
    EnableWindow(
        GetDlgItem(
            hwndDlg, 
            CID_NetTab_Tcpipui_EB_Mask), 
        !pTcpipParams->bUseDhcp);
    
    return NO_ERROR;
}

// Generates number formatting data
//
DWORD 
TcpipGenerateNumberFormatter (
    NUMBERFMT * pNumFmt) 
{
    CHAR pszNeg[64], pszLz[2];

    ZeroMemory (pNumFmt->lpDecimalSep, 4);
    pNumFmt->NumDigits = 0;
    pNumFmt->Grouping = 3;
    
    GetLocaleInfoA (LOCALE_SYSTEM_DEFAULT, 
                   LOCALE_ILZERO, 
                   pszLz, 
                   2);
                   
    GetLocaleInfoW (LOCALE_SYSTEM_DEFAULT, 
                   LOCALE_STHOUSAND, 
                   pNumFmt->lpThousandSep, 
                   2);
                   
    GetLocaleInfoA (LOCALE_SYSTEM_DEFAULT, 
                   LOCALE_INEGNUMBER, 
                   pszNeg, 
                   2);

    pNumFmt->LeadingZero = atoi(pszLz);
    pNumFmt->NegativeOrder = atoi(pszNeg);
    
    return NO_ERROR;
}

// Formats an unsigned number with commas, etc.  
//
PWCHAR 
TcpipFormatDword(
    DWORD dwVal) 
{
    static WCHAR pszRet[64], pszDSep[2], pszTSep[2] = {0,0};
    static NUMBERFMT NumberFmt = {0,0,0,pszDSep,pszTSep,0};
    static BOOL bInitialized = FALSE;
    WCHAR pszNum[64];
    
    // Stringize the number
    wsprintfW (pszNum, L"%u", dwVal);
    pszRet[0] = (WCHAR)0;

    // Initialize number formatting
    if (!bInitialized) 
    {
        TcpipGenerateNumberFormatter (&NumberFmt);
        bInitialized = TRUE;
    }        
    
    // Get the local version of this
    GetNumberFormatW (
        LOCALE_SYSTEM_DEFAULT,    
        0,
        pszNum,
        &NumberFmt,
        pszRet,
        sizeof(pszRet) / sizeof(WCHAR));
                     
    return pszRet;                     
}

// Sets the range and total incoming clients fields of the tcpip properties
// dialog.
//
DWORD 
TcpipReCalcPoolSize(
    HWND hwndDlg) 
{
    HWND hwndStart, hwndEnd, hwndTotal;
    DWORD dwStart = 0, dwEnd = 0, dwTotal=0;
    WCHAR pszBuf[256];

    hwndStart = GetDlgItem(hwndDlg, CID_NetTab_Tcpipui_EB_Start);
    hwndEnd   = GetDlgItem(hwndDlg, CID_NetTab_Tcpipui_EB_Mask);
    hwndTotal = GetDlgItem(hwndDlg, CID_NetTab_Tcpipui_EB_Total);

    SendMessage(hwndStart, IP_GETADDRESS, 0, (LPARAM)&dwStart);
    SendMessage(hwndEnd, IP_GETADDRESS, 0, (LPARAM)&dwEnd);

    //For whistler bug 281545   gangz
    //
    if ( 0 == dwStart )
    {
        dwTotal = dwEnd - dwStart;
    }
    else
    {
        if (dwEnd >= dwStart) 
        {
            dwTotal = dwEnd - dwStart + 1;
        }
        else
        {
            dwTotal = 0;
        }
    }
    
    SetWindowTextW(hwndTotal, TcpipFormatDword(dwTotal) );

    return NO_ERROR;
}

// Initializes the Tcpip Properties Dialog
//
DWORD 
TcpipInitDialog(
    HWND hwndDlg, 
    LPARAM lParam) 
{
    LPSTR pszAddr;
    TCPIP_PARAMS * pTcpipParams = (TCPIP_PARAMS *)
        (((PROT_EDIT_DATA*)lParam)->pbData);
    HWND hwndFrom, hwndTo;
    WCHAR pszAddrW[256];
                                                   
    // Store the parameters with the window handle
    SetWindowLongPtr(hwndDlg, GWLP_USERDATA, lParam);
    
    // Set the network exposure check
    SendDlgItemMessage(
        hwndDlg, 
        CID_NetTab_Tcpipui_CB_ExposeNetwork,
        BM_SETCHECK, 
        (((PROT_EDIT_DATA*)lParam)->bExpose) ? BST_CHECKED : BST_UNCHECKED,
        0);

    // Set the address assignmnet radio buttons
    SendDlgItemMessage(
        hwndDlg, 
        CID_NetTab_Tcpipui_RB_Dhcp, 
        BM_SETCHECK, 
        (pTcpipParams->bUseDhcp) ? BST_CHECKED : BST_UNCHECKED,
        0);
    
    // Set the address assignmnet radio buttons
    SendDlgItemMessage(
        hwndDlg, 
        CID_NetTab_Tcpipui_RB_StaticPool, 
        BM_SETCHECK, 
        (pTcpipParams->bUseDhcp) ? BST_UNCHECKED : BST_CHECKED,
        0);
    
    // Set the "allow caller to specify ip address" check
    SendDlgItemMessage(
        hwndDlg, 
        CID_NetTab_Tcpipui_CB_CallerSpec, 
        BM_SETCHECK, 
        (pTcpipParams->bCaller) ? BST_CHECKED : BST_UNCHECKED,
        0);

    // Set the text of the ip addresses
    if (pTcpipParams->dwPoolStart != 0)
    {
        hwndFrom = GetDlgItem(hwndDlg, CID_NetTab_Tcpipui_EB_Start);
        hwndTo = GetDlgItem(hwndDlg, CID_NetTab_Tcpipui_EB_Mask);
        TcpipDwordToAddr(pTcpipParams->dwPoolStart, pszAddrW);
        SetWindowText(hwndFrom, pszAddrW);
        TcpipDwordToAddr(pTcpipParams->dwPoolEnd, pszAddrW);
        SetWindowText(hwndTo, pszAddrW);
    }        

    // Enable/disable windows as per the settings
    TcpipEnableWindows(hwndDlg, pTcpipParams);

    return NO_ERROR;
}

// Gets the settings from the ui and puts them into 
// the tcpip parameter structure.
//
DWORD 
TcpipGetUISettings(
    IN  HWND hwndDlg,  
    OUT PROT_EDIT_DATA * pEditData,
    OUT LPDWORD lpdwFrom,
    OUT LPDWORD lpdwTo) 
{
    TCPIP_PARAMS * pTcpipParams = 
        (TCPIP_PARAMS *) pEditData->pbData;
    HWND hwndFrom, hwndTo;

    hwndFrom = GetDlgItem(hwndDlg, CID_NetTab_Tcpipui_EB_Start);
    hwndTo = GetDlgItem(hwndDlg, CID_NetTab_Tcpipui_EB_Mask);
        
    pEditData->bExpose = 
        SendDlgItemMessage(
            hwndDlg, 
            CID_NetTab_Tcpipui_CB_ExposeNetwork, 
            BM_GETCHECK, 
            0, 
            0) == BST_CHECKED;

    SendMessage(
        hwndFrom, 
        IP_GETADDRESS, 
        0, 
        (LPARAM)&pTcpipParams->dwPoolStart);
        
    SendMessage(
        hwndTo, 
        IP_GETADDRESS, 
        0, 
        (LPARAM)&pTcpipParams->dwPoolEnd);

    *lpdwFrom = pTcpipParams->dwPoolStart;
    *lpdwTo = pTcpipParams->dwPoolEnd;

    return NO_ERROR;
}

DWORD
TcpipUiHandleOk(
    IN HWND hwndDlg)
{
    PROT_EDIT_DATA* pData = NULL;
    TCPIP_PARAMS * pParams = NULL;
    DWORD dwErr, dwId = SID_TCPIP_InvalidPool;
    DWORD dwStart = 0, dwEnd = 0;
    PWCHAR pszMessage = NULL;
    MSGARGS MsgArgs;

    // Get the context
    //
    pData = (PROT_EDIT_DATA*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    if (pData == NULL)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    // Read values from the UI
    //
    dwErr = TcpipGetUISettings(hwndDlg, pData, &dwStart, &dwEnd);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    // Validate the pool if one was entered
    //
    pParams = (TCPIP_PARAMS *)pData->pbData;    
    if (pParams->bUseDhcp == FALSE)
    {
        dwErr = TcpipUiValidatePool(
                    dwStart,
                    dwEnd,
                    &dwId);
        if (dwErr != NO_ERROR)
        {
            ZeroMemory(&MsgArgs, sizeof(MsgArgs));                            
            MsgArgs.dwFlags = MB_OK;

            MsgDlgUtil(
                hwndDlg,
                dwId,
                &MsgArgs,
                Globals.hInstDll,
                SID_DEFAULT_MSG_TITLE);
        }
    }

    return dwErr;
}        

// Dialog proc that governs the tcpip settings dialog
INT_PTR 
CALLBACK 
TcpipSettingsDialogProc (
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam) 
{
    switch (uMsg) {
        case WM_INITDIALOG:
            TcpipInitDialog(hwndDlg, lParam);
            return FALSE;
        
        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            RasSrvHelp (hwndDlg, uMsg, wParam, lParam, phmTcpipui);
            break;
        }

        case WM_DESTROY:                           
            // Cleanup the work done at WM_INITDIALOG 
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, 0);
            break;
        
        case WM_COMMAND:
            {
                TCPIP_PARAMS * pTcpipParams = (TCPIP_PARAMS *)
                    (((PROT_EDIT_DATA*)
                        GetWindowLongPtr(hwndDlg, GWLP_USERDATA))->pbData);
                switch (wParam) 
                {
                    case IDOK:
                        if (TcpipUiHandleOk(hwndDlg) == NO_ERROR)
                        {
                            EndDialog(hwndDlg, 1);
                        }
                        break;
                        
                    case IDCANCEL:
                        EndDialog(hwndDlg, 0);
                        break;
                        
                    case CID_NetTab_Tcpipui_RB_Dhcp:
                        pTcpipParams->bUseDhcp = TRUE;
                        TcpipEnableWindows(hwndDlg, pTcpipParams);
                        break;
                        
                    case CID_NetTab_Tcpipui_RB_StaticPool:
                        pTcpipParams->bUseDhcp = FALSE;
                        TcpipEnableWindows(hwndDlg, pTcpipParams);
                        break;
                        
                    case CID_NetTab_Tcpipui_CB_CallerSpec:
                        pTcpipParams->bCaller = (BOOL)
                            SendDlgItemMessage(
                                hwndDlg, 
                                CID_NetTab_Tcpipui_CB_CallerSpec, 
                                BM_GETCHECK, 
                                0,
                                0);
                        break;
                }
                
                // Recal the pool size as appropriate
                // 
                if (HIWORD(wParam) == EN_CHANGE) 
                {
                    if (LOWORD(wParam) == CID_NetTab_Tcpipui_EB_Start || 
                        LOWORD(wParam) == CID_NetTab_Tcpipui_EB_Mask)
                    {                        
                        TcpipReCalcPoolSize(hwndDlg);
                    }
                }
                break;
            }
    }

    return FALSE;
}

// Edits tcp ip protocol properties
//
DWORD 
TcpipEditProperties(
    HWND hwndParent, 
    PROT_EDIT_DATA * pEditData, 
    BOOL * pbCommit) 
{
    DWORD dwErr;
    int ret;

    // Initialize the ip address custom controls
    IpAddrInit(Globals.hInstDll, SID_TCPIP_TITLE, SID_TCPIP_BADRANGE);

    // Popup the dialog box
    ret = (int) DialogBoxParam(
                    Globals.hInstDll,
                    MAKEINTRESOURCE(DID_NetTab_Tcpipui),
                    hwndParent,
                    TcpipSettingsDialogProc,
                    (LPARAM)pEditData);
    if (ret == -1) 
    {
        TcpipUiDisplayError(hwndParent, ERR_TCPIP_CANT_DISPLAY);
    }

    // If ok was pressed, save off the new settings
    *pbCommit = FALSE;
    if (ret && ret != -1)
    {
        *pbCommit = TRUE;
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\service.h ===
/*
    File    service.h

    Defines Dialup Server Service Object.

    Paul Mayfield, 11/3/97
*/

#ifndef __rassrvui_service
#define __rassrvui_service

// Creates/destroys instances of dialup server service objects
DWORD SvcOpenRemoteAccess(HANDLE * phService);
DWORD SvcOpenRasman(HANDLE * phService);
DWORD SvcOpenServer(HANDLE * phService);
DWORD SvcClose(HANDLE hService);

// Gets the status of a dialup server service object.  If the service
// is in the process of being started or stopped or paused, then only
// SvcIsPending will return TRUE.
DWORD SvcIsStarted (HANDLE hService, PBOOL pbStarted);
DWORD SvcIsStopped (HANDLE hService, PBOOL pbStopped);
DWORD SvcIsPaused  (HANDLE hService, PBOOL pbPaused );
DWORD SvcIsPending (HANDLE hService, PBOOL pbPending);

// Start and stop the service.  Both functions block until the service
// completes startup/stop or until dwTimeout (in seconds) expires.
DWORD SvcStart(HANDLE hService, DWORD dwTimeout);
DWORD SvcStop(HANDLE hService, DWORD dwTimeout);

// Changes the configuration of the service
DWORD SvcMarkAutoStart(HANDLE hService);
DWORD SvcMarkDisabled(HANDLE hService);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\service.c ===
/*
    File    service.c

    Handles requests to deal with the remote access service as neccessary for
    the dialup-server ui.

    Paul Mayfield, 11/3/97
*/

#include "rassrv.h"

// Data used for the dialup server 
typedef struct _SERVICE_DATA {
    HANDLE hSC;
    HANDLE hService;
    SERVICE_STATUS Status;
} SERVICE_DATA;

// This is the string that holds the name of the remote access service
static WCHAR pszRemoteAccess[] = L"remoteaccess";
static WCHAR pszRasman[] = L"rasman";
static WCHAR pszServer[] = L"lanmanserver";

// Opens a named dialup service object
//
DWORD 
DialupOpenNamedService(
    IN WCHAR* pszService,
    OUT HANDLE * phDialup)
{
    SERVICE_DATA * pServData;
    BOOL bOk = FALSE;
    DWORD dwErr = NO_ERROR;

    // Validate parameters
    if (!phDialup)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Create the data structure
    if ((pServData = RassrvAlloc(sizeof(SERVICE_DATA), TRUE)) == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    do
    {
        // Open the service manager
        pServData->hSC = OpenSCManager(
                            NULL, 
                            SERVICES_ACTIVE_DATABASE, 
                            GENERIC_EXECUTE);
        if (! pServData->hSC) 
        {
            dwErr = GetLastError();
            break;
        }

        // Open the dialup service
        pServData->hService = OpenServiceW(
                                pServData->hSC, 
                                pszService, 
                                SERVICE_START         | 
                                SERVICE_STOP          | 
                                SERVICE_CHANGE_CONFIG | 
                                SERVICE_QUERY_STATUS);
        if (! pServData->hService) 
        {
            dwErr = GetLastError();
            break;
        }

        // Assign the handle
        *phDialup = (HANDLE)pServData;
        bOk = TRUE;
        
    } while (FALSE);
    
    // Cleanup 
    {
        if (! bOk) 
        {
            if (pServData->hService)
            {
                CloseServiceHandle(pServData->hService);
            }
            if (pServData->hSC)
            {
                CloseServiceHandle(pServData->hSC);
            }
            
            RassrvFree(pServData);
            *phDialup = NULL;
        }
    }

    return NO_ERROR;
}

// Opens a reference to the server service object
DWORD SvcOpenServer(HANDLE * phDialup) {
    return DialupOpenNamedService(pszServer, phDialup);
}

// Opens a reference to the rasman service object
DWORD SvcOpenRasman(HANDLE * phDialup) {
    return DialupOpenNamedService(pszRasman, phDialup);
}

// Creates/destroys instances of the dialup server service object
DWORD SvcOpenRemoteAccess(HANDLE * phDialup) { 
    return DialupOpenNamedService(pszRemoteAccess, phDialup);
}

// Close up the references to the dialup service object
DWORD SvcClose(HANDLE hDialup) { 
    SERVICE_DATA * pServData = (SERVICE_DATA *)hDialup;
    if (! pServData)
        return ERROR_INVALID_PARAMETER;

    if (pServData->hService)
        CloseServiceHandle(pServData->hService);
    if (pServData->hSC)
        CloseServiceHandle(pServData->hSC);

    RassrvFree(pServData);

    return NO_ERROR;
}

// Gets the status of a dialup server service object.  
DWORD SvcIsStarted (HANDLE hDialup, PBOOL pbStarted) { 
    SERVICE_DATA * pServData = (SERVICE_DATA *)hDialup;
    BOOL bOk;

    // Verify parameters
    if (!pServData || !pbStarted)
        return ERROR_INVALID_PARAMETER;

    // Get the status
    bOk = QueryServiceStatus (pServData->hService, &pServData->Status);
    if (! bOk) 
        return GetLastError();

    // Return the status
    *pbStarted = (BOOL)(pServData->Status.dwCurrentState == SERVICE_RUNNING);       

    return NO_ERROR;
}

// Gets the status of a dialup server service object.  
DWORD SvcIsStopped (HANDLE hDialup, PBOOL pbStopped) { 
    SERVICE_DATA * pServData = (SERVICE_DATA *)hDialup;
    BOOL bOk;

    // Verify parameters
    if (!pServData || !pbStopped)
        return ERROR_INVALID_PARAMETER;

    // Get the status
    bOk = QueryServiceStatus (pServData->hService, &pServData->Status);
    if (! bOk) 
        return GetLastError();

    // Return the status
    *pbStopped = (BOOL)(pServData->Status.dwCurrentState == SERVICE_STOPPED);       

    return NO_ERROR;
}

// Gets the status of a dialup server service object.  
DWORD SvcIsPaused  (HANDLE hDialup, PBOOL pbPaused) { 
    SERVICE_DATA * pServData = (SERVICE_DATA *)hDialup;
    BOOL bOk;

    // Verify parameters
    if (!pServData || !pbPaused)
        return ERROR_INVALID_PARAMETER;

    // Get the status
    bOk = QueryServiceStatus (pServData->hService, &pServData->Status);
    if (! bOk) 
        return GetLastError();

    // Return the status
    *pbPaused = (BOOL)(pServData->Status.dwCurrentState ==  SERVICE_PAUSED);       

    return NO_ERROR;
}

//
// Returns whether the given state is a pending state
//
BOOL DialupIsPendingState (DWORD dwState) {
    return (BOOL) ((dwState == SERVICE_START_PENDING)    ||
                   (dwState == SERVICE_STOP_PENDING)     ||
                   (dwState == SERVICE_CONTINUE_PENDING) ||
                   (dwState == SERVICE_PAUSE_PENDING)    
                   ); 
}

// Gets the status of a dialup server service object.  
DWORD SvcIsPending (HANDLE hDialup, PBOOL pbPending) { 
    SERVICE_DATA * pServData = (SERVICE_DATA *)hDialup;
    BOOL bOk;

    // Verify parameters
    if (!pServData || !pbPending)
        return ERROR_INVALID_PARAMETER;

    // Get the status
    bOk = QueryServiceStatus (pServData->hService, &pServData->Status);
    if (! bOk) 
        return GetLastError();

    // Return the status
    *pbPending = DialupIsPendingState (pServData->Status.dwCurrentState);

    return NO_ERROR;
}

// Start and stop the service.  Both functions block until the service
// completes startup/stop or until dwTimeout (in seconds) expires.
DWORD SvcStart(HANDLE hDialup, DWORD dwTimeout) { 
    SERVICE_DATA * pServData = (SERVICE_DATA *)hDialup;
    DWORD dwErr, dwState;
    BOOL bStarted, bOk;

    // See if we're already started
    if ((dwErr = SvcIsStarted(hDialup, &bStarted)) != NO_ERROR)
        return dwErr;
    if (bStarted)
        return NO_ERROR;

    // Put the service in a state that so that 
    // it is trying to start.  (continue if paused,
    // start if stopped)
    dwState = pServData->Status.dwCurrentState;
    switch (dwState) {
        case SERVICE_STOPPED:
            bOk = StartService(pServData->hService, 0, NULL);
            if (! bOk)
                return GetLastError();
            break;
        case SERVICE_PAUSED:
            bOk = ControlService(pServData->hService, 
                                 SERVICE_CONTROL_CONTINUE, 
                                 &(pServData->Status));
            if (! bOk)
                return GetLastError();
            break;
    }

    // Wait for the service to change states or for the timeout to
    // expire.
    while (dwTimeout != 0) {
        // Wait for something to happen
        Sleep(1000);
        dwTimeout--;

        // Get the status of the service
        bOk = QueryServiceStatus (pServData->hService, 
                                  &(pServData->Status));
        if (! bOk) 
            return GetLastError();

        // See if the state changed
        if (dwState != pServData->Status.dwCurrentState) {
            // If the service changed to a pending state, continue
            if (DialupIsPendingState (pServData->Status.dwCurrentState))
                dwState = pServData->Status.dwCurrentState;

            // Otherwise, we're either stopped or running
            else
                break;
        }
    }

    // Return a timeout error if appropriate
    if (dwTimeout == 0)
        return ERROR_TIMEOUT;

    // If the service is now running, then everything
    if (pServData->Status.dwCurrentState == SERVICE_RUNNING)
        return NO_ERROR;

    // Otherwise, return the fact that we were'nt able to 
    // get to a running state
    if (pServData->Status.dwWin32ExitCode != NO_ERROR)
        return pServData->Status.dwWin32ExitCode;

    return ERROR_CAN_NOT_COMPLETE;
}

// Stops the service.
DWORD SvcStop(HANDLE hDialup, DWORD dwTimeout) { 
    SERVICE_DATA * pServData = (SERVICE_DATA *)hDialup;
    DWORD dwErr, dwState;
    BOOL bStopped, bOk;

    // See if we're already stopped
    if ((dwErr = SvcIsStopped(hDialup, &bStopped)) != NO_ERROR)
        return dwErr;
    if (bStopped)
        return NO_ERROR;

    // Stop the service
    dwState = pServData->Status.dwCurrentState;
    bOk = ControlService(pServData->hService, SERVICE_CONTROL_STOP, &pServData->Status);
    if (! bOk)
        return GetLastError();

    // Wait for the service to change states or for the timeout to
    // expire.
    while (dwTimeout != 0) {
        // Wait for something to happen
        Sleep(1000);
        dwTimeout--;

        // Get the status of the service
        bOk = QueryServiceStatus (pServData->hService, 
                                  &(pServData->Status));
        if (! bOk) 
            return GetLastError();

        // See if the state changed
        if (dwState != pServData->Status.dwCurrentState) {
            // If the service changed to a pending state, continue
            if (DialupIsPendingState (pServData->Status.dwCurrentState))
                dwState = pServData->Status.dwCurrentState;

            // Otherwise, we're either stopped or running
            else
                break;
        }
    }

    // Report a timeout
    if (dwTimeout == 0)
        return ERROR_TIMEOUT;

    // If the service is now stopped, then everything is great
    if (pServData->Status.dwCurrentState == SERVICE_STOPPED)
        return NO_ERROR;

    // Otherwise report that we're unable to stop the service
    return ERROR_CAN_NOT_COMPLETE;
}

// Marks the dialup service as autostart
DWORD SvcMarkAutoStart(HANDLE hDialup) {
    SERVICE_DATA * pServData = (SERVICE_DATA *)hDialup;
    BOOL bOk;

    // Validate the parameters
    if (! pServData)
        return ERROR_INVALID_PARAMETER;

    // Stop the service
    bOk = ChangeServiceConfig(pServData->hService, 
                              SERVICE_NO_CHANGE, 
                              SERVICE_AUTO_START,
                              SERVICE_NO_CHANGE,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL);
    if (! bOk)
        return GetLastError();

    return NO_ERROR;
}

// Marks the service as disabled.
DWORD SvcMarkDisabled(HANDLE hDialup) {
    SERVICE_DATA * pServData = (SERVICE_DATA *)hDialup;
    BOOL bOk;

    // Validate the parameters
    if (! pServData)
        return ERROR_INVALID_PARAMETER;

    // Stop the service
    bOk = ChangeServiceConfig(pServData->hService, 
                              SERVICE_NO_CHANGE, 
                              SERVICE_DISABLED,
                              SERVICE_NO_CHANGE,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL);
    if (! bOk)
        return GetLastError();

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\tcpipui.h ===
/*
    File    tcpipui.c

    Dialog that edits the tcpip properties.
    
    Paul Mayfield, 10/9/97
*/

#ifndef __rassrvui_tcpipui_h
#define __rassrvui_tcpipui_h

#include "protedit.h"

// Brings up a modal dialog that allows the editing of tcpip parameters
// specific to the dialup server.  When this function completes, the 
// parameters are stored in pParams, and pbCommit is set to TRUE if the
// parameters are supposed to be saved to the system (i.e. OK was pressed)
DWORD TcpipEditProperties(HWND hwndParent, PROT_EDIT_DATA * pEditData, BOOL * pbCommit);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\userdb.h ===
/*
    File    userdb.h

    Definition of the local user database object.

    Paul Mayfield, 10/8/97
*/


#ifndef __userdb_h
#define __userdb_h

#include <windows.h>

// Creates a user data base object, initializing it from the local user database
// and returning a handle to it.
DWORD usrOpenLocalDatabase (HANDLE * hUserDatabase);

// Frees up the resources held by a user database object flushing all 
// changes to the system.
DWORD usrCloseLocalDatabase (HANDLE hUserDatabase);

// Flushes the data written to the database object to the system
DWORD usrFlushLocalDatabase (HANDLE hUserDatabase);

// Rolls back the local user database so that it is in 
// the same state it was in when usrOpenLocalDatabase was
// called. The rollback is automatically flushed to the 
// system. (i.e. usrFlushLocalDatabase doesn't need to follow)
DWORD usrRollbackLocalDatabase (HANDLE hUserDatabase);

// Reloads the local user database from the system 
DWORD usrReloadLocalDatabase (HANDLE hUserDatabase);

// Gets global user data
DWORD usrGetEncryption (HANDLE hUserDatabase, PBOOL pbEncrypted);

// Gets user encryption setting
DWORD usrSetEncryption (HANDLE hUserDatabase, BOOL bEncrypt);

// Returns whether dcc connections are allowed to bypass authentication
DWORD usrGetDccBypass (HANDLE hUserDatabase, PBOOL pbBypass);

// Sets whether dcc connections are allowed to bypass authentication
DWORD usrSetDccBypass (HANDLE hUserDatabase, BOOL bBypass);

// Reports whether the user database is pure. (i.e. nobody has
// gone into MMC and messed with it).
DWORD usrIsDatabasePure (HANDLE hUserdatabase, PBOOL pbPure);

// Marks the user database's purity
DWORD usrSetDatabasePure(HANDLE hUserDatabase, BOOL bPure);

// Gives the count of users stored in the user database object
DWORD usrGetUserCount (HANDLE hUserDatabase, LPDWORD lpdwCount);

// Adds a user to the given database.  This user will not be 
// added to the system's local user database until this database
// object is flushed (and as long as Rollback is not called on 
// this database object)
//
// On success, an optional handle to the user is returned 
//
DWORD usrAddUser (HANDLE hUserDatabase, PWCHAR pszName, OPTIONAL HANDLE * phUser);

// Deletes the user at the given index 
DWORD usrDeleteUser (HANDLE hUserDatabase, DWORD dwIndex);

// Gives a handle to the user at the given index
DWORD usrGetUserHandle (HANDLE hUserDatabase, DWORD dwIndex, HANDLE * hUser);

// Gets a pointer to the name of the user (do not modify this)
DWORD usrGetName (HANDLE hUser, PWCHAR* pszName);

// Fills the given buffer with the full name of the user
DWORD usrGetFullName (HANDLE hUser, IN PWCHAR pszBuffer, IN OUT LPDWORD lpdwBufSize);

// Commits the full name of a user
DWORD usrSetFullName (HANDLE hUser, PWCHAR pszFullName);

// Commits the password of a user
DWORD usrSetPassword (HANDLE hUser, PWCHAR pszNewPassword);

// Fills the given buffer with a friendly display name (in the form username (fullname))
DWORD usrGetDisplayName (HANDLE hUser, IN PWCHAR pszBuffer, IN OUT LPDWORD lpdwBufSize);

// Determines whether users has callback/dialin priveleges.
DWORD usrGetDialin (HANDLE hUser, BOOL* bEnabled);

// Determines which if any callback priveleges are granted to a given user.  Either (or both) of 
// bAdminOnly and bCallerSettable can be NULL
DWORD usrGetCallback (HANDLE hUser, BOOL* bAdminOnly, BOOL * bCallerSettable);

// Enable/disable dialin privelege.
DWORD usrEnableDialin (HANDLE hUser, BOOL bEnable);

// The flags are evaluated in the following order with whichever condition
// being satisfied fist defining the behavior of the function.
// bNone == TRUE => Callback is disabled for the user
// bCaller == TRUE => Callback is set to caller-settable
// bAdmin == TRUE => Callback is set to a predefine callback number set in usrSetCallbackNumer
// All 3 are FALSE => No op
DWORD usrEnableCallback (HANDLE hUser, BOOL bNone, BOOL bCaller, BOOL bAdmin);

// Retreives a pointer to the callback number of the given user
DWORD usrGetCallbackNumber(HANDLE hUser, PWCHAR * lpzNumber);

// Sets the callback number of the given user.  If lpzNumber is NULL, an empty phone number
// is copied.
DWORD usrSetCallbackNumber(HANDLE hUser, PWCHAR lpzNumber);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\usertab.h ===
/*
    File    usertab.h

    Defines structures/methods for operating on the local user database.

    Paul Mayfield, 9/29/97
*/

#ifndef _usertab_h
#define _usertab_h

// ======================================
//  Structures
// ======================================

// Fills a LPPROPSHEETPAGE structure with the information
// needed to display the user tab. dwUserData is ignored.
DWORD UserTabGetPropertyPage(LPPROPSHEETPAGE lpPage, LPARAM lpUserData);     

// Function is the window procedure of the user tab in the incoming connections
// property sheet and wizard.
INT_PTR CALLBACK UserTabDialogProc(HWND hwndDlg,
                              UINT uMsg,
                              WPARAM wParam,
                              LPARAM lParam);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\userdb.c ===
/*
    File    userdb.c

    Implementation of the local user database object.

    Paul Mayfield, 10/8/97
*/

#include "rassrv.h"

// Registry values
extern WCHAR pszregRasParameters[];
extern WCHAR pszregServerFlags[];
extern WCHAR pszregPure[];

// Cached values for users
typedef struct _RASSRV_USERINFO 
{
    HANDLE hUser;        // Handle to user
    PWCHAR pszName;
    PWCHAR pszFullName;  // Only loaded if requested
    PWCHAR pszPassword;  // Only non-null if this is new password to be committed
    WCHAR wszPhoneNumber[MAX_PHONE_NUMBER_LEN + 1];
    BYTE bfPrivilege;
    BYTE bDirty;
    
} RASSRV_USERINFO;

// Structure used to implement/manipulate the local user database
typedef struct _RASSRV_USERDB 
{
    HANDLE hServer;                 // Handle to user server
    DWORD dwUserCount;              // Number of users in the database
    DWORD dwCacheSize;              // Number of users can be stored in cache
    BOOL bEncrypt;                  // Whether encryption should be used
    BOOL bDccBypass;                // Whether dcc connections can bypass auth.
    BOOL bPure;                     // Whether database is "Pure"
    BOOL bEncSettingLoaded;         // Whether we've read in the enc setting
    BOOL bFlushOnClose;
    RASSRV_USERINFO ** pUserCache;  // Cache of users
    
} RASSRV_USERDB;

// Defines a callback for enumerating users.  Returns TRUE to continue the enueration
// FALSE to stop it.
typedef 
BOOL 
(* pEnumUserCb)(
    IN NET_DISPLAY_USER* pUser, 
    IN HANDLE hData);

// We use this to guess the size of the the user array 
// (so we can grow it when new users are added)
#define USR_ARRAY_GROW_SIZE 50

// Dirty flags
#define USR_RASPROPS_DIRTY 0x1  // whether callback is dirty
#define USR_FULLNAME_DIRTY 0x2  // whether full name needs to be flushed
#define USR_PASSWORD_DIRTY 0x4  // whether password needs to be flushed
#define USR_ADD_DIRTY      0x8  // whether user needs to be added

// Helper macros for dealing with dirty flags
#define usrDirtyRasProps(pUser) ((pUser)->bDirty |= USR_RASPROPS_DIRTY)
#define usrDirtyFullname(pUser) ((pUser)->bDirty |= USR_FULLNAME_DIRTY)
#define usrDirtyPassword(pUser) ((pUser)->bDirty |= USR_PASSWORD_DIRTY)
#define usrDirtyAdd(pUser) ((pUser)->bDirty |= USR_ADD_DIRTY)

#define usrIsDirty(pUser) ((pUser)->bDirty)
#define usrIsRasPropsDirty(pUser) ((pUser)->bDirty & USR_RASPROPS_DIRTY) 
#define usrIsFullNameDirty(pUser) ((pUser)->bDirty & USR_FULLNAME_DIRTY) 
#define usrIsPasswordDirty(pUser) ((pUser)->bDirty & USR_PASSWORD_DIRTY) 
#define usrIsAddDirty(pUser) ((pUser)->bDirty & USR_ADD_DIRTY) 

#define usrClearDirty(pUser) ((pUser)->bDirty = 0)
#define usrClearRasPropsDirty(pUser) ((pUser)->bDirty &= ~USR_CALLBACK_DIRTY) 
#define usrClearFullNameDirty(pUser) ((pUser)->bDirty &= ~USR_FULLNAME_DIRTY) 
#define usrClearPasswordDirty(pUser) ((pUser)->bDirty &= ~USR_PASSWORD_DIRTY) 
#define usrClearAddDirty(pUser) ((pUser)->bDirty &= ~USR_ADD_DIRTY) 

#define usrFlagIsSet(_val, _flag) (((_val) & (_flag)) != 0)
#define usrFlagIsClear(_val, _flag) (((_val) & (_flag)) == 0)

//
// Reads in server flags and determines whether encrypted 
// password and data are required.  
// 
// lpdwFlags is assigned one of the following on success
//      0               = data and pwd enc not required
//      MPR_USER_PROF_FLAG_SECURE = data and pwd enc required
//      MPR_USER_PROF_FLAG_UNDETERMINED = Can't say for sure
//
DWORD 
usrGetServerEnc(
    OUT  LPDWORD lpdwFlags) 
{
    DWORD dwFlags = 0;

    if (!lpdwFlags)
        return ERROR_INVALID_PARAMETER;

    // Read in the flags
    RassrvRegGetDw(&dwFlags, 
                   0, 
                   (const PWCHAR)pszregRasParameters, 
                   (const PWCHAR)pszregServerFlags);

    // The following bits will be set for secure auth.
    //
    if (
        (usrFlagIsSet   (dwFlags, PPPCFG_NegotiateMSCHAP))       &&
        (usrFlagIsSet   (dwFlags, PPPCFG_NegotiateStrongMSCHAP)) &&
        (usrFlagIsClear (dwFlags, PPPCFG_NegotiateMD5CHAP))      &&
        (usrFlagIsClear (dwFlags, PPPCFG_NegotiateSPAP))         &&
        (usrFlagIsClear (dwFlags, PPPCFG_NegotiateEAP))          &&
        (usrFlagIsClear (dwFlags, PPPCFG_NegotiatePAP))        
       )
    {
        *lpdwFlags = MPR_USER_PROF_FLAG_SECURE; 
        return NO_ERROR;
    }

    // The following bits will be set for insecure auth.
    //
    else if (
            (usrFlagIsSet   (dwFlags, PPPCFG_NegotiateMSCHAP))       &&
            (usrFlagIsSet   (dwFlags, PPPCFG_NegotiateStrongMSCHAP)) &&
            (usrFlagIsSet   (dwFlags, PPPCFG_NegotiateSPAP))         &&
            (usrFlagIsSet   (dwFlags, PPPCFG_NegotiatePAP))          &&
            (usrFlagIsClear (dwFlags, PPPCFG_NegotiateEAP))          &&
            (usrFlagIsClear (dwFlags, PPPCFG_NegotiateMD5CHAP))      
           )
        {
            *lpdwFlags = 0;  // data and pwd enc not required
            return NO_ERROR;
        }

    // Otherwise, we are undetermined
    *lpdwFlags = MPR_USER_PROF_FLAG_UNDETERMINED;
    return NO_ERROR;
}

//
// Sets the encryption policy for the server
//
DWORD 
usrSetServerEnc(
    IN DWORD dwFlags) 
{
    DWORD dwSvrFlags = 0;

    // Read in the old flags
    RassrvRegGetDw(&dwSvrFlags, 
                   0, 
                   (const PWCHAR)pszregRasParameters, 
                   (const PWCHAR)pszregServerFlags);

    // If the user requires encryption then set MSCHAP
    // and CHAP as the only authentication types and 
    // set the ipsec flag.
    if (dwFlags & MPR_USER_PROF_FLAG_SECURE) 
    {
        dwSvrFlags |= PPPCFG_NegotiateMSCHAP;
        dwSvrFlags |= PPPCFG_NegotiateStrongMSCHAP;
        dwSvrFlags &= ~PPPCFG_NegotiateMD5CHAP;
        dwSvrFlags &= ~PPPCFG_NegotiateSPAP;
        dwSvrFlags &= ~PPPCFG_NegotiateEAP;
        dwSvrFlags &= ~PPPCFG_NegotiatePAP;
    }

    // Otherwise, the user does require encryption,
    // so enable all authentication types and disable
    // the requirement to use IPSEC
    else 
    {
        dwSvrFlags &= ~PPPCFG_NegotiateMD5CHAP;
        dwSvrFlags &= ~PPPCFG_NegotiateEAP;
        dwSvrFlags |= PPPCFG_NegotiateMSCHAP;
        dwSvrFlags |= PPPCFG_NegotiateStrongMSCHAP;
        dwSvrFlags |= PPPCFG_NegotiateSPAP;
        dwSvrFlags |= PPPCFG_NegotiatePAP;
    }

    // Commit changes to the registry
    RassrvRegSetDw(dwSvrFlags, 
                   (const PWCHAR)pszregRasParameters, 
                   (const PWCHAR)pszregServerFlags);
   
    return NO_ERROR;
}

// Encrypts an in-memory password
//
DWORD 
usrEncryptPassword(
    IN PWCHAR pszPassword, 
    IN DWORD dwLength) 
{
    DWORD i;
    WCHAR ENCRYPT_MASK = (WCHAR)0x85;

    for (i = 0; i < dwLength; i++) {
        pszPassword[i] ^= ENCRYPT_MASK;
        pszPassword[i] ^= ENCRYPT_MASK;
    }

    return NO_ERROR;
}    

// Decrypts an in-memory encrypted password
//
DWORD 
usrDecryptPassword(
    IN PWCHAR pszPassword, 
    IN DWORD dwLength) 
{
    return usrEncryptPassword(pszPassword, dwLength);
}

// Enumerates the local users
//
DWORD 
usrEnumLocalUsers(
    IN pEnumUserCb pCbFunction,
    IN HANDLE hData)
{
    DWORD dwErr, dwIndex = 0, dwCount = 100, dwEntriesRead, i;
    NET_DISPLAY_USER  * pUsers;
    NET_API_STATUS nStatus;
    RAS_USER_0 RasUser0;
    HANDLE hUser = NULL, hServer = NULL;
    
    // Enumerate the users, 
    while (TRUE) 
    {
        // Read in the first block of user names
        nStatus = NetQueryDisplayInformation(
                    NULL,
                    1,
                    dwIndex,
                    dwCount,
                    dwCount * sizeof(NET_DISPLAY_USER),    
                    &dwEntriesRead,
                    &pUsers);
                    
        // Get out if there's an error getting user names
        if ((nStatus != NERR_Success) &&
            (nStatus != ERROR_MORE_DATA))
        {
            break;
        }

        // For each user read in, call the callback function
        for (i = 0; i < dwEntriesRead; i++) 
        {
            BOOL bOk;

            //For whistler bug 243874 gangz
            //On whistler Personal version, we wont show the Administrator
            //in the user's listview on the Incoming connection's User Tab
            //

            if ( (DOMAIN_USER_RID_ADMIN == pUsers[i].usri1_user_id) &&
                  IsPersonalPlatform() )
            {
                continue;
            }
			
            bOk = (*pCbFunction)(&(pUsers[i]), hData);
            if (bOk == FALSE)
            {
                nStatus = NERR_Success;
                break;
            }
        }

        // Set the index to read in the next set of users
        dwIndex = pUsers[dwEntriesRead - 1].usri1_next_index;  
        
        // Free the users buffer
        NetApiBufferFree (pUsers);

        // If we've read in everybody, go ahead and break
        if (nStatus != ERROR_MORE_DATA)
        {
            break;
        }
    }
    
    return NO_ERROR;
}

// Copies the data in pRassrvUser to its equivalent in UserInfo
DWORD 
usrSyncRasProps(
    IN  RASSRV_USERINFO * pRassrvUser, 
    OUT RAS_USER_0 * UserInfo) 
{
    UserInfo->bfPrivilege = pRassrvUser->bfPrivilege;
    lstrcpynW( UserInfo->wszPhoneNumber, 
             pRassrvUser->wszPhoneNumber, 
             MAX_PHONE_NUMBER_LEN);
    UserInfo->wszPhoneNumber[MAX_PHONE_NUMBER_LEN] = (WCHAR)0;
    return NO_ERROR;
}

// Commits the data for the given user to the local user database
DWORD 
usrCommitRasProps(
    IN RASSRV_USERINFO * pRassrvUser) 
{
    DWORD dwErr = NO_ERROR;
    RAS_USER_0 UserInfo;

    dwErr = usrSyncRasProps(pRassrvUser, &UserInfo);
    if (dwErr != NO_ERROR)
        return dwErr;

    dwErr = MprAdminUserWrite(pRassrvUser->hUser, 0, (LPBYTE)&UserInfo);
    if (dwErr != NO_ERROR) 
        DbgOutputTrace ("usrCommitRasProps: unable to commit %S (0x%08x)", 
                        pRassrvUser->pszName, dwErr);
    
    return dwErr;
}

// Simple bounds checking
BOOL 
usrBoundsCheck(
    IN RASSRV_USERDB * This, 
    IN DWORD dwIndex) 
{
    // Dwords are unsigned, so no need to check < 0
    if (This->dwUserCount <= dwIndex)
        return FALSE;
        
    return TRUE;
}

// Frees an array of users
DWORD 
usrFreeUserArray(
    IN RASSRV_USERINFO ** pUsers, 
    IN DWORD dwCount) 
{
    DWORD i;

    if (!pUsers)
        return ERROR_INVALID_PARAMETER;

    for (i=0; i < dwCount; i++) {
        if (pUsers[i]) {
            if (pUsers[i]->hUser)
                MprAdminUserClose(pUsers[i]->hUser);
            if (pUsers[i]->pszName)
                RassrvFree (pUsers[i]->pszName);
            if (pUsers[i]->pszFullName)
                RassrvFree (pUsers[i]->pszFullName);
            if (pUsers[i]->pszPassword)
                RassrvFree (pUsers[i]->pszPassword);
            RassrvFree(pUsers[i]);
        }
        
    }

    return NO_ERROR;
}

// Standard user comparison function used for sorting
int _cdecl 
usrCompareUsers(
    IN const void * elem1, 
    IN const void * elem2) 
{
    RASSRV_USERINFO* p1 = *((RASSRV_USERINFO**)elem1);
    RASSRV_USERINFO* p2 = *((RASSRV_USERINFO**)elem2);

    return lstrcmpi(p1->pszName, p2->pszName);
}

// Returns whether a given user exists
BOOL 
usrUserExists (
    IN RASSRV_USERDB * This, 
    IN PWCHAR pszName) 
{
    DWORD i;
    int iCmp;

    for (i = 0; i < This->dwUserCount; i++) {
        iCmp = lstrcmpi(This->pUserCache[i]->pszName, pszName);
        if (iCmp == 0)
            return TRUE;
        if (iCmp > 0)
            return FALSE;
    }

    return FALSE;
}

// Resorts the cache
DWORD 
usrResortCache(
    IN RASSRV_USERDB * This) 
{
    qsort(
        This->pUserCache, 
        This->dwUserCount, 
        sizeof(RASSRV_USERINFO*), 
        usrCompareUsers);
        
    return NO_ERROR;
}

// Resizes the user cache to allow for added users
DWORD 
usrResizeCache(
    IN RASSRV_USERDB * This, 
    IN DWORD dwNewSize) 
{
    RASSRV_USERINFO ** pNewCache;
    DWORD i;

    // Only resize bigger (this could be changed)
    if ((!This) || (dwNewSize <= This->dwCacheSize))
        return ERROR_INVALID_PARAMETER;

    // Allocate the new cache
    pNewCache = RassrvAlloc(dwNewSize * sizeof (RASSRV_USERINFO*), TRUE);
    if (pNewCache == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    // Copy over the old entries and free the old cache
    if (This->pUserCache) 
    {
        CopyMemory( (PVOID)pNewCache, 
                    (CONST VOID *)(This->pUserCache), 
                    This->dwCacheSize * sizeof(RASSRV_USERINFO*));
        RassrvFree(This->pUserCache);
    }

    // Reassign the new cache and update the cache size
    This->pUserCache = pNewCache;
    This->dwCacheSize = dwNewSize;

    return NO_ERROR;
}

// Enumeration callback that adds users to the local database
// as they are read from the system.
BOOL 
usrInitializeUser(
    NET_DISPLAY_USER * pNetUser,
    HANDLE hUserDatabase)
{
    RASSRV_USERDB * This = (RASSRV_USERDB*)hUserDatabase;
    RASSRV_USERINFO * pRasUser = NULL;
    DWORD dwErr = NO_ERROR, dwSize;
    RAS_USER_0 UserInfo;

    // Make sure we have a valid database
    if (!This)
    {
        return FALSE;
    }
    
    // Resize the cache to accomodate more users if needed
    if (This->dwUserCount >= This->dwCacheSize)
    {
        dwErr = usrResizeCache(
                    This, 
                    This->dwCacheSize + USR_ARRAY_GROW_SIZE);
                    
        if (dwErr != NO_ERROR)
        {
            return FALSE;
        }
    }

    // Allocate this user
    pRasUser = RassrvAlloc(sizeof(RASSRV_USERINFO), TRUE);
    if (pRasUser == NULL)
    {
        return FALSE;
    }

    do 
    {
        // Point to the user name
        dwSize = (wcslen(pNetUser->usri1_name) + 1) * sizeof(WCHAR);
        pRasUser->pszName = RassrvAlloc(dwSize, FALSE);
        if (!pRasUser->pszName)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }
        wcscpy(pRasUser->pszName, pNetUser->usri1_name);

        // Open the user handle
        dwErr = MprAdminUserOpen (
                    This->hServer, 
                    pRasUser->pszName, 
                    &(pRasUser->hUser));
        if (dwErr != NO_ERROR)
        {
            break;
        }
        
        // Get the ras user info
        dwErr = MprAdminUserRead(pRasUser->hUser, 0, (LPBYTE)&UserInfo);
        if (dwErr != NO_ERROR)
        {
            break;
        }

        // Clear any dirty flags
        usrClearDirty(pRasUser);

        // Copy the phone number
        lstrcpynW(
            pRasUser->wszPhoneNumber, 
            UserInfo.wszPhoneNumber, 
            MAX_PHONE_NUMBER_LEN);
        pRasUser->wszPhoneNumber[MAX_PHONE_NUMBER_LEN] = (WCHAR)0;

        // Copy the privelege flags
        pRasUser->bfPrivilege = UserInfo.bfPrivilege;

        // Assign the user in the cache
        This->pUserCache[This->dwUserCount] = pRasUser;
        
        // Update the user count
        This->dwUserCount += 1;
        
    } while (FALSE);

    // Cleanup
    {
        if (dwErr != NO_ERROR)
        {
            if (pRasUser)
            {
                if (pRasUser->pszName)
                {
                    RassrvFree(pRasUser->pszName);
                }
                
                RassrvFree(pRasUser);
            }
        }
    }

    return (dwErr == NO_ERROR) ? TRUE : FALSE;
}

// 
// Loads the global encryption setting.  Because the operation opens
// up .mdb files to read profiles, etc.  it is put in its own function
// and is called only when absolutely needed.
//
DWORD 
usrLoadEncryptionSetting(
    IN RASSRV_USERDB * This)
{
    DWORD dwErr = NO_ERROR;
    DWORD dwSvrFlags, dwProfFlags;

    if (This->bEncSettingLoaded)
    {
        return NO_ERROR;
    }
    
    // Read in the encryption setting by combining the 
    // server flags with the values in the default 
    // profile.
    dwSvrFlags  = MPR_USER_PROF_FLAG_UNDETERMINED;
    dwProfFlags = MPR_USER_PROF_FLAG_UNDETERMINED;
    
    MprAdminUserReadProfFlags (This->hServer, &dwProfFlags);
    usrGetServerEnc (&dwSvrFlags);

    // If both sources confirm the encryption requirement
    // then we require encryption
    if ((dwProfFlags & MPR_USER_PROF_FLAG_SECURE) &&
        (dwSvrFlags  & MPR_USER_PROF_FLAG_SECURE))
    {
        This->bEncrypt = TRUE;
    }
    else
    {
        This->bEncrypt = FALSE;
    }

    This->bEncSettingLoaded = TRUE;

    return dwErr;
}
    
// Creates a user data base object, initializing it from the local 
// user database and returning a handle to it.
DWORD 
usrOpenLocalDatabase (
    IN HANDLE * hUserDatabase) 
{
    RASSRV_USERDB * This = NULL;
    DWORD dwErr;

    if (!hUserDatabase)
        return ERROR_INVALID_PARAMETER;

    // Allocate the database
    if ((This = RassrvAlloc(sizeof(RASSRV_USERDB), TRUE)) == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    // Connect to the user server
    dwErr = MprAdminUserServerConnect(NULL, TRUE, &(This->hServer));
    if (dwErr != NO_ERROR)
        return dwErr;

    // Load in the data from the system
    if ((dwErr = usrReloadLocalDatabase((HANDLE)This)) == NO_ERROR) {
        *hUserDatabase = (HANDLE)This;
        This->bFlushOnClose = FALSE;
        return NO_ERROR;
    }

    DbgOutputTrace ("usrOpenLocalDb: unable to load user db 0x%08x", 
                    dwErr);
                    
    RassrvFree(This);
    *hUserDatabase = NULL;
    
    return dwErr;
}

// Reloads the user information cached in the user database obj 
// from the system.  This can be used to implement a refresh in the ui.
// 
DWORD 
usrReloadLocalDatabase (
    IN HANDLE hUserDatabase) 
{
    RASSRV_USERDB * This = (RASSRV_USERDB*)hUserDatabase;
    DWORD dwErr;

    // Validate
    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Cleanup the old database
    if (This->pUserCache) 
    {
        usrFreeUserArray(This->pUserCache, This->dwUserCount);
        RassrvFree(This->pUserCache);
    }

    // The encryption setting is loaded on demand from the
    // usrGetEncryption/usrSetEncryption api's.  This is a performance
    // tune so that the IC wizard wouldn't have to wait for
    // the profile to be loaded even though it doesn't use the result.

    // Read in the purity of the system
    {
        DWORD dwPure = 0;
        
        RassrvRegGetDw(&dwPure, 
                       0, 
                       (const PWCHAR)pszregRasParameters, 
                       (const PWCHAR)pszregPure);
                       
        if (dwPure == 1)
            This->bPure = FALSE;
        else 
            This->bPure = TRUE;
    }

    // Read in whether dcc connections can be bypassed
    {
        DWORD dwSvrFlags = 0;

        RassrvRegGetDw(
            &dwSvrFlags,
            dwSvrFlags,
            (const PWCHAR)pszregRasParameters, 
            (const PWCHAR)pszregServerFlags);

        if (dwSvrFlags & PPPCFG_AllowNoAuthOnDCPorts)
            This->bDccBypass = TRUE;
        else
            This->bDccBypass = FALSE;
    }

    // Enumerate the local users from the system adding them
    // to this database.
    dwErr = usrEnumLocalUsers(usrInitializeUser, hUserDatabase);
    if (dwErr != NO_ERROR)
    {
        return NO_ERROR;
    }

    return NO_ERROR;
}

// Frees up the resources held by a user database object.
DWORD 
usrCloseLocalDatabase (
    IN HANDLE hUserDatabase) 
{
    DWORD i;
    RASSRV_USERDB * This = (RASSRV_USERDB*)hUserDatabase;

    // Make sure we were passed a valid handle
    if (!This)
        return ERROR_INVALID_PARAMETER;

    // We're done if there are no users
    if (!This->dwUserCount)
        return NO_ERROR;

    // Commit any settings as appropriate
    if (This->bFlushOnClose)
        usrFlushLocalDatabase(hUserDatabase);

    // Free the user cache 
    usrFreeUserArray(This->pUserCache, This->dwUserCount);
    RassrvFree(This->pUserCache);

    // Disconnect from the user server
    MprAdminUserServerDisconnect (This->hServer);

    // Free This
    RassrvFree(This);

    return NO_ERROR;
}

// Flushes the data written to the database object
DWORD 
usrFlushLocalDatabase (
    IN HANDLE hUserDatabase) 
{
    RASSRV_USERDB * This = (RASSRV_USERDB*)hUserDatabase;
    RASSRV_USERINFO * pUser;
    DWORD dwErr, dwRet = NO_ERROR, dwCount, i, dwLength;

    dwErr = usrGetUserCount (This, &dwCount);
    if (dwErr != NO_ERROR)
        return dwErr;

    for (i=0; i<dwCount; i++) {
        pUser = This->pUserCache[i];
        // Flush any dirty settings
        if (usrIsDirty(pUser)) {
            // Add the user to the local user database if it hasn't 
            // already been done
            if (usrIsAddDirty(pUser)) {
                dwErr = RasSrvAddUser (
                            pUser->pszName,
                            (pUser->pszFullName) ? pUser->pszFullName : L"",
                            (pUser->pszPassword) ? pUser->pszPassword : L"");
                if (dwErr != NO_ERROR)
                    dwRet = dwErr;

                // Now get the SDO handle to the user
                // so we can commit ras properties below.
                dwErr = MprAdminUserOpen (
                            This->hServer, 
                            pUser->pszName, 
                            &(pUser->hUser));
                if (dwErr != NO_ERROR)
                    continue;
            }
        
            // Flush dirty callback properties
            if (usrIsRasPropsDirty(pUser)) {
                if ((dwErr = usrCommitRasProps(This->pUserCache[i])) != NO_ERROR)
                    dwRet = dwErr;
            }

            // Flush dirty password and full name settings
            if (usrIsFullNameDirty(pUser) || usrIsPasswordDirty(pUser)) {
                if (pUser->pszPassword) {
                    dwLength = wcslen(pUser->pszPassword);
                    usrDecryptPassword(pUser->pszPassword, dwLength);
                }
                RasSrvEditUser (
                    pUser->pszName,
                    (usrIsFullNameDirty(pUser)) ? pUser->pszFullName : NULL,
                    (usrIsPasswordDirty(pUser)) ? pUser->pszPassword : NULL);
                if (pUser->pszPassword) 
                    usrEncryptPassword(pUser->pszPassword, dwLength);
            }

            // Reset the user as not being dirty
            usrClearDirty(pUser);
        }
    }

    // Flush the encryption setting if it has been read
    if (This->bEncSettingLoaded)
    {
        DWORD dwFlags;

        if (This->bEncrypt)
            dwFlags = MPR_USER_PROF_FLAG_SECURE;
        else
            dwFlags = 0;
            
        MprAdminUserWriteProfFlags (This->hServer, dwFlags);
        usrSetServerEnc(dwFlags);
    }

    // Flush out the purity of the system
    {
        DWORD dwPure = 0;
        
        if (This->bPure)
            dwPure = 0;
        else 
            dwPure = 1;
            
        RassrvRegSetDw(dwPure, 
                       (const PWCHAR)pszregRasParameters, 
                       (const PWCHAR)pszregPure);
    }

    // Flush out whether dcc connections can be bypassed
    {
        DWORD dwSvrFlags = 0;

        RassrvRegGetDw(
            &dwSvrFlags,
            dwSvrFlags,
            (const PWCHAR)pszregRasParameters, 
            (const PWCHAR)pszregServerFlags);

        if (This->bDccBypass)
             dwSvrFlags |= PPPCFG_AllowNoAuthOnDCPorts;
        else
             dwSvrFlags &= ~PPPCFG_AllowNoAuthOnDCPorts;

        RassrvRegSetDw(
            dwSvrFlags,
            (const PWCHAR)pszregRasParameters, 
            (const PWCHAR)pszregServerFlags);
    }


    return dwRet;
}

// Rolls back the local user database so that no
// changes will be committed when Flush is called.
DWORD 
usrRollbackLocalDatabase (
    IN HANDLE hUserDatabase) 
{
    DWORD i, dwIndex, dwErr;
    BOOL bCommit;
    RASSRV_USERDB * This = (RASSRV_USERDB*)hUserDatabase;

    if (!This)
        return ERROR_INVALID_PARAMETER;
        
    if (!This->dwUserCount)
        return NO_ERROR;

    // Go through the database, marking each user as not dirty
    for (i = 0; i < This->dwUserCount; i++) 
        usrClearDirty(This->pUserCache[i]);

    This->bFlushOnClose = FALSE;
    
    return NO_ERROR;
}

//
// Determines whether all users are required to encrypt
// their data and passwords.
//
DWORD usrGetEncryption (
        IN  HANDLE hUserDatabase, 
        OUT PBOOL pbEncrypted)
{
    RASSRV_USERDB * This = (RASSRV_USERDB*)hUserDatabase;
    
    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Load in the encryption setting
    usrLoadEncryptionSetting(This);

    *pbEncrypted = This->bEncrypt;

    return NO_ERROR;
}

// Gets user encryption setting
DWORD 
usrSetEncryption (
    IN HANDLE hUserDatabase, 
    IN BOOL bEncrypt) 
{
    RASSRV_USERDB * This = (RASSRV_USERDB*)hUserDatabase;
    
    if (!This)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Load in the encryption setting
    usrLoadEncryptionSetting(This);

    This->bEncrypt = bEncrypt;

    return NO_ERROR;
}

// Returns whether dcc connections are allowed to 
// bypass authentication
DWORD 
usrGetDccBypass (
    IN  HANDLE hUserDatabase, 
    OUT PBOOL pbBypass)
{
    RASSRV_USERDB * This = (RASSRV_USERDB*)hUserDatabase;
    if (!This)
        return ERROR_INVALID_PARAMETER;

    *pbBypass = This->bDccBypass;

    return NO_ERROR;
}

// Sets whether dcc connections are allowed to 
// bypass authentication
DWORD 
usrSetDccBypass (
    IN HANDLE hUserDatabase, 
    IN BOOL bBypass)
{
    RASSRV_USERDB * This = (RASSRV_USERDB*)hUserDatabase;
    if (!This)
        return ERROR_INVALID_PARAMETER;

    This->bDccBypass = bBypass;

    return NO_ERROR;
}

// Reports whether the user database is pure. (i.e. nobody has
// gone into MMC and messed with it).
DWORD 
usrIsDatabasePure (
    IN  HANDLE hUserDatabase, 
    OUT PBOOL pbPure) 
{
    RASSRV_USERDB * This = (RASSRV_USERDB*)hUserDatabase;
    if (!This)
        return ERROR_INVALID_PARAMETER;

    *pbPure = This->bPure;

    return NO_ERROR;
}

// Marks the user database's purity
DWORD 
usrSetDatabasePure(
    IN HANDLE hUserDatabase, 
    IN BOOL bPure) 
{
    RASSRV_USERDB * This = (RASSRV_USERDB*)hUserDatabase;
    if (!This)
        return ERROR_INVALID_PARAMETER;

    This->bPure = bPure;

    return NO_ERROR;
}

// Returns the number of users cached in this database
DWORD 
usrGetUserCount (
    IN  HANDLE hUserDatabase, 
    OUT LPDWORD lpdwCount) 
{
    RASSRV_USERDB * This = (RASSRV_USERDB*)hUserDatabase;
    if (!This || !lpdwCount)
        return ERROR_INVALID_PARAMETER;

    *lpdwCount = This->dwUserCount;
    return NO_ERROR;
}

// Adds a user to the given database.  This user will not be 
// added to the system's local user database until this database
// object is flushed (and as long as Rollback is not called on 
// this database object)
//
// On success, an optional handle to the user is returned 
//
DWORD usrAddUser (
        IN  HANDLE hUserDatabase, 
        IN  PWCHAR pszName, 
        OUT OPTIONAL HANDLE * phUser) 
{
    RASSRV_USERDB * This = (RASSRV_USERDB*)hUserDatabase;
    RASSRV_USERINFO * pUser;
    DWORD dwErr, dwLength;

    // Validate the parameters
    if (!This || !pszName)
        return ERROR_INVALID_PARAMETER;

    // If the user already exists, don't add him
    if (usrUserExists(This, pszName))
        return ERROR_ALREADY_EXISTS;

    // Resize the cache to accomodate if neccessary
    if (This->dwUserCount + 1 >= This->dwCacheSize) {
        dwErr = usrResizeCache(This, This->dwCacheSize + USR_ARRAY_GROW_SIZE);
        if (dwErr != NO_ERROR)
            return dwErr;
    }

    // Allocate the new user control block
    if ((pUser = RassrvAlloc(sizeof(RASSRV_USERINFO), TRUE)) == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    // Allocate space for the name
    dwLength = wcslen(pszName);
    pUser->pszName = RassrvAlloc((dwLength + 1) * sizeof(WCHAR), FALSE);
    if (pUser->pszName == NULL)
        return ERROR_NOT_ENOUGH_MEMORY;

    // Copy the name
    wcscpy(pUser->pszName, pszName);

    // Enable the user for dialin by default
    usrEnableDialin ((HANDLE)pUser, TRUE);
    
    // Dirty the user
    usrDirtyAdd(pUser);
    usrDirtyRasProps(pUser);

    // Put the user in the array and re-sort it
    This->pUserCache[This->dwUserCount++] = pUser;
    usrResortCache(This);

    // Return the handle
    if (phUser)
        *phUser = (HANDLE)pUser;
    
    return NO_ERROR;
}

// Gives the count of users stored in the user database object
// Deletes the given user
DWORD 
usrDeleteUser (
        IN HANDLE hUserDatabase, 
        IN DWORD dwIndex) 
{
    RASSRV_USERDB * This = (RASSRV_USERDB*)hUserDatabase;
    RASSRV_USERINFO * pUser;
    DWORD dwErr, dwMoveElemCount;
    
    // Validate the parameters
    if (!This)
        return ERROR_INVALID_PARAMETER;

    // Bounds Check
    if (!usrBoundsCheck(This, dwIndex))
        return ERROR_INVALID_INDEX;

    // Get a reference to the user in question and remove him
    // from the cache
    pUser = This->pUserCache[dwIndex];

    // Attempt to delete the user from the system
    if ((dwErr = RasSrvDeleteUser(pUser->pszName)) != NO_ERROR)
        return dwErr;

    // Remove the user from the cache
    This->pUserCache[dwIndex] = NULL;

    // Pull down every thing in the cache so that there are no holes
    dwMoveElemCount = This->dwUserCount - dwIndex; 
    if (dwMoveElemCount) {
        MoveMemory(&(This->pUserCache[dwIndex]),
                   &(This->pUserCache[dwIndex + 1]), 
                   dwMoveElemCount * sizeof(RASSRV_USERINFO*));
    }

    // Decrement the number of users
    This->dwUserCount--;

    // Cleanup the user
    usrFreeUserArray(&pUser, 1);

    return NO_ERROR;
}

// Gives a handle to the user at the given index
DWORD 
usrGetUserHandle (
    IN  HANDLE hUserDatabase, 
    IN  DWORD dwIndex, 
    OUT HANDLE * hUser) 
{
    RASSRV_USERDB * This = (RASSRV_USERDB*)hUserDatabase;
    if (!This || !hUser)
        return ERROR_INVALID_PARAMETER;

    if (!usrBoundsCheck(This, dwIndex))
        return ERROR_INVALID_INDEX;

    *hUser = (HANDLE)(This->pUserCache[dwIndex]);
    
    return NO_ERROR;
}

// Gets a pointer to the name of the user (do not modify this)
DWORD 
usrGetName (
    IN HANDLE hUser, 
    OUT PWCHAR* pszName) 
{
    RASSRV_USERINFO* pRassrvUser = (RASSRV_USERINFO*)hUser;
    
    if (!pRassrvUser || !pszName)
        return ERROR_INVALID_PARAMETER;

    *pszName = pRassrvUser->pszName;
    
    return NO_ERROR;
}

// Fills the given buffer with a friendly display name 
// (in the form username (fullname))
DWORD 
usrGetDisplayName (
    IN HANDLE hUser, 
    IN PWCHAR pszBuffer, 
    IN OUT LPDWORD lpdwBufSize) 
{
    RASSRV_USERINFO * pRassrvUser = (RASSRV_USERINFO*)hUser;
    NET_API_STATUS nStatus;
    DWORD dwUserNameLength, dwFullLength, dwSizeRequired;
    WCHAR pszTemp[150];
    DWORD dwErr = NO_ERROR;

    // Sanity check the params
    if (!pRassrvUser || !pszBuffer || !lpdwBufSize)
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    do
    {
        // Get the full name of the user
        dwFullLength = sizeof(pszTemp);
        dwErr = usrGetFullName(hUser, pszTemp, &dwFullLength);
        if (dwErr != NO_ERROR)
        {
            break;
        }
        
        // Make sure the buffer is big enough
        dwUserNameLength = wcslen(pRassrvUser->pszName);
        dwSizeRequired = dwUserNameLength + 
                         dwFullLength     + 
                         ((dwFullLength) ? 3 : 0);
        if (*lpdwBufSize < dwSizeRequired) 
        {
            dwErr = ERROR_INSUFFICIENT_BUFFER;
            break;
        }
            
        if (dwFullLength)
        {
            wsprintfW(
                pszBuffer, 
                L"%s (%s)", 
                pRassrvUser->pszName, 
                pszTemp);
        }
        else
        {
            wcscpy(pszBuffer, pRassrvUser->pszName);
        }
        
    } while (FALSE);

    // Cleanup
    {
        *lpdwBufSize = dwSizeRequired;
    }

    return dwErr;
}

// Fills the given buffer with a friendly display name 
// (in the form username (fullname))
DWORD 
usrGetFullName (
    IN HANDLE hUser, 
    IN PWCHAR pszBuffer, 
    IN OUT LPDWORD lpdwBufSize) 
{
    RASSRV_USERINFO * pRassrvUser = (RASSRV_USERINFO*)hUser;
    NET_API_STATUS nStatus;
    USER_INFO_2 * pUserInfo = NULL;
    DWORD dwLength;
    PWCHAR pszFullName;
    DWORD dwErr = NO_ERROR;
    
    // Sanity check the params
    if (!pRassrvUser || !pszBuffer || !lpdwBufSize)
        return ERROR_INVALID_PARAMETER;

    // If the full name is already loaded, return it
    if (pRassrvUser->pszFullName)
        pszFullName = pRassrvUser->pszFullName;

    // or if this is a new user, get the name from memory
    else if (usrIsAddDirty(pRassrvUser)) {
        pszFullName = (pRassrvUser->pszFullName) ? 
                          pRassrvUser->pszFullName : L"";        
    }
    
    // Load the full name of the user
    else {    
        nStatus = NetUserGetInfo(
                    NULL, 
                    pRassrvUser->pszName, 
                    2, 
                    (LPBYTE*)&pUserInfo);
        if (nStatus != NERR_Success) {
            DbgOutputTrace (
                "usrGetFullName: %x returned from NetUserGetInfo for %S", 
                nStatus, 
                pRassrvUser->pszName);
            return nStatus;
        }
        pszFullName = (PWCHAR)pUserInfo->usri2_full_name;
    }

    do
    {
        // Make sure the length is ok
        dwLength = wcslen(pszFullName);

        // Assign the full name here if it hasn't already been done
        if (dwLength && !pRassrvUser->pszFullName) 
        {
            DWORD dwSize = dwLength * sizeof(WCHAR) + sizeof(WCHAR);
            pRassrvUser->pszFullName = RassrvAlloc(dwSize, FALSE);
            if (pRassrvUser->pszFullName)
            {
                wcscpy(pRassrvUser->pszFullName, pszFullName);
            }
        }

        // Check the size
        if (*lpdwBufSize < (dwLength + 1) * sizeof(WCHAR))
        {
            dwErr = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        // Copy in the full name
        wcscpy(pszBuffer, pszFullName);
        
   } while (FALSE);

   // Cleanup
   {
        // report the size
       *lpdwBufSize = dwLength * sizeof(WCHAR);
        if (pUserInfo)
        {
            NetApiBufferFree((LPBYTE)pUserInfo);
        }
   }

   return dwErr;
}

// Commits the full name of a user
DWORD usrSetFullName (
        IN HANDLE hUser, 
        IN PWCHAR pszFullName) 
{
    RASSRV_USERINFO* pRassrvUser = (RASSRV_USERINFO*)hUser;
    DWORD dwLength;

    if (!pRassrvUser || !pszFullName)
        return ERROR_INVALID_PARAMETER;

    // If this is not a new name, don't do anything
    if (pRassrvUser->pszFullName) {
        if (wcscmp(pRassrvUser->pszFullName, pszFullName) == 0)
            return NO_ERROR;
        RassrvFree(pRassrvUser->pszFullName);
    }

    // Allocate a new one
    dwLength = wcslen(pszFullName);
    pRassrvUser->pszFullName = RassrvAlloc(dwLength * sizeof(WCHAR) * sizeof(WCHAR), 
                                           FALSE);
    if (!pRassrvUser->pszFullName)
        return ERROR_NOT_ENOUGH_MEMORY;

    // Copy it over
    wcscpy(pRassrvUser->pszFullName, pszFullName);

    // Mark it dirty -- a newly added user has his/her full name commited
    // whenever it exists automatically
    if (!usrIsAddDirty(pRassrvUser))
        usrDirtyFullname(pRassrvUser);
    
    return NO_ERROR;
}

// Commits the password of a user
DWORD 
usrSetPassword (
    IN HANDLE hUser, 
    IN PWCHAR pszNewPassword) 
{
    RASSRV_USERINFO* pRassrvUser = (RASSRV_USERINFO*)hUser;
    DWORD dwLength;

    if (!pRassrvUser || !pszNewPassword)
        return ERROR_INVALID_PARAMETER;

    // Cleanup the old password if it exists
    if (pRassrvUser->pszPassword)
        RassrvFree(pRassrvUser->pszPassword);

    // Allocate a new one
    dwLength = wcslen(pszNewPassword);
    pRassrvUser->pszPassword = RassrvAlloc(dwLength * sizeof(WCHAR) * sizeof(WCHAR), 
                                           FALSE);
    if (!pRassrvUser->pszPassword)
        return ERROR_NOT_ENOUGH_MEMORY;

    // Copy it over
    wcscpy(pRassrvUser->pszPassword, pszNewPassword);

    // Encrypt it
    usrEncryptPassword(pRassrvUser->pszPassword, dwLength);

    // Mark it dirty -- a newly added user has his/her full name commited
    // whenever it exists automatically
    if (!usrIsAddDirty(pRassrvUser))
        usrDirtyPassword(pRassrvUser);
    
    return NO_ERROR;
}

// Determines whether users have callback/dialin priveleges.
DWORD 
usrGetDialin (
    IN HANDLE hUser, 
    OUT BOOL* bEnabled) 
{
    RASSRV_USERINFO* pRassrvUser = (RASSRV_USERINFO*)hUser;
    DWORD dwErr;
    RAS_USER_0 UserInfo;

    if (!pRassrvUser || !bEnabled)
        return ERROR_INVALID_PARAMETER;

    // Get the user info
    *bEnabled = (pRassrvUser->bfPrivilege & RASPRIV_DialinPrivilege);
    
    return NO_ERROR;
}

// Determines which if any callback priveleges are granted to a given user.  
// Either (or both) of bAdminOnly and bUserSettable can be null
DWORD 
usrGetCallback (
    IN  HANDLE hUser, 
    OUT BOOL* bAdminOnly, 
    OUT BOOL* bUserSettable) 
{
    RASSRV_USERINFO* pRassrvUser = (RASSRV_USERINFO*)hUser;
    DWORD dwErr;

    if (!pRassrvUser || !bAdminOnly || !bUserSettable)
        return ERROR_INVALID_PARAMETER;
    
    // Return whether we have callback privelege
    if (bAdminOnly)
    {
        *bAdminOnly = 
            (pRassrvUser->bfPrivilege & RASPRIV_AdminSetCallback);
    }
    
    if (bUserSettable)
    {
        *bUserSettable = 
            (pRassrvUser->bfPrivilege & RASPRIV_CallerSetCallback);
    }
    
    return NO_ERROR;
}

// Enable/disable dialin privelege.
DWORD 
usrEnableDialin (
    IN HANDLE hUser, 
    IN BOOL bEnable) 
{
    RASSRV_USERINFO* pRassrvUser = (RASSRV_USERINFO*)hUser;
    DWORD dwErr = NO_ERROR;
    BOOL bIsEnabled;

    if (!pRassrvUser)
        return ERROR_INVALID_PARAMETER;

    // If the dialin privelege is already set as requested return success
    bIsEnabled = pRassrvUser->bfPrivilege & RASPRIV_DialinPrivilege;
    if ((!!bIsEnabled) == (!!bEnable))
        return NO_ERROR;

    // Otherwise reset the privelege
    if (bEnable)
        pRassrvUser->bfPrivilege |= RASPRIV_DialinPrivilege;
    else
        pRassrvUser->bfPrivilege &= ~RASPRIV_DialinPrivilege;
    
    // Dirty the user (cause him/her to be flushed at apply time)
    usrDirtyRasProps(pRassrvUser);

    return dwErr;
}

// The flags are evaluated in the following order with whichever condition
// being satisfied fist defining the behavior of the function.
// bNone == TRUE => Callback is disabled for the user
// bCaller == TRUE => Callback is set to caller-settable
// bAdmin == TRUE => Callback is set to a predefine callback number set 
// All 3 are FALSE => No op
DWORD 
usrEnableCallback (
    IN HANDLE hUser, 
    IN BOOL bNone, 
    IN BOOL bCaller, 
    IN BOOL bAdmin) 
{
    RASSRV_USERINFO* pRassrvUser = (RASSRV_USERINFO*)hUser;
    DWORD dwErr = NO_ERROR;
    BOOL bIsEnabled;

    if (!pRassrvUser)
        return ERROR_INVALID_PARAMETER;

    if (bNone) {
        pRassrvUser->bfPrivilege |= RASPRIV_NoCallback;         
        pRassrvUser->bfPrivilege &= ~RASPRIV_CallerSetCallback; 
        pRassrvUser->bfPrivilege &= ~RASPRIV_AdminSetCallback;  
    }
    else if (bCaller) {
        pRassrvUser->bfPrivilege &= ~RASPRIV_NoCallback;         
        pRassrvUser->bfPrivilege |= RASPRIV_CallerSetCallback; 
        pRassrvUser->bfPrivilege &= ~RASPRIV_AdminSetCallback;  
    }
    else if (bAdmin) {
        pRassrvUser->bfPrivilege &= ~RASPRIV_NoCallback;         
        pRassrvUser->bfPrivilege &= ~RASPRIV_CallerSetCallback; 
        pRassrvUser->bfPrivilege |= RASPRIV_AdminSetCallback;  
    }
    else 
        return NO_ERROR;

    // Dirty the user (cause him/her to be flushed at apply time)
    usrDirtyRasProps(pRassrvUser);

    return dwErr;
}

// Retreives a pointer to the callback number of the given user
DWORD 
usrGetCallbackNumber(
    IN  HANDLE hUser, 
    OUT PWCHAR * lpzNumber) 
{
    RASSRV_USERINFO* pRassrvUser = (RASSRV_USERINFO*)hUser;
    
    if (!pRassrvUser || !lpzNumber)
        return ERROR_INVALID_PARAMETER;

    // Return the pointer to the callback number
    *lpzNumber = pRassrvUser->wszPhoneNumber;

    return NO_ERROR;
}

// Sets the callback number of the given user.  If lpzNumber is NULL, 
// an empty phone number is copied.
DWORD 
usrSetCallbackNumber(
    IN HANDLE hUser, 
    IN PWCHAR lpzNumber) 
{
    RASSRV_USERINFO* pRassrvUser = (RASSRV_USERINFO*)hUser;
    DWORD dwErr = NO_ERROR;

    if (!pRassrvUser)
        return ERROR_INVALID_PARAMETER;
    
    // Modify the phone number appropriately
    if (!lpzNumber)
        wcscpy(pRassrvUser->wszPhoneNumber, L"");
    else {
        lstrcpynW(pRassrvUser->wszPhoneNumber, lpzNumber, MAX_PHONE_NUMBER_LEN);
        pRassrvUser->wszPhoneNumber[MAX_PHONE_NUMBER_LEN] = (WCHAR)0;
    }

    // Dirty the user (cause him/her to be flushed at apply time)
    usrDirtyRasProps(pRassrvUser);

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\usertab.c ===
/*
    File    usertab.c

    Implementation of the users dialog tab for the dialup server ui.

    Paul Mayfield, 9/29/97
*/

#include "rassrv.h"
#include "usertab.h"

#define USERTAB_PASSWORD_BUFFER_SIZE 33
static const WCHAR pszDummyPassword[] = L"XXXXXXXXXXXXXXX";

// Help maps
static const DWORD phmUserTab[] =
{
    CID_UserTab_LV_Users,           IDH_UserTab_LV_Users,
    CID_UserTab_PB_New,             IDH_UserTab_PB_New,
    CID_UserTab_PB_Delete,          IDH_UserTab_PB_Delete,
    CID_UserTab_PB_Properties,      IDH_UserTab_PB_Properties,
    CID_UserTab_PB_SwitchToMMC,     IDH_UserTab_PB_SwitchToMMC,
    CID_UserTab_CB_Encryption,      IDH_UserTab_CB_Encryption,
    CID_UserTab_CB_BypassDcc,       IDH_UserTab_CB_BypassDcc,
    0,                              0
};

static const DWORD phmCallback[] =
{
    CID_UserTab_Callback_RB_Caller, IDH_UserTab_Callback_RB_Caller,
    CID_UserTab_Callback_RB_Admin,  IDH_UserTab_Callback_RB_Admin,
    CID_UserTab_Callback_EB_Number, IDH_UserTab_Callback_EB_Number,
    CID_UserTab_Callback_RB_No,     IDH_UserTab_Callback_RB_No,
    0,                              0
};

static const DWORD phmNewUser[] =
{
    CID_UserTab_New_EB_Username,    IDH_UserTab_New_EB_Username,
    CID_UserTab_New_EB_Fullname,    IDH_UserTab_New_EB_Fullname,
    CID_UserTab_New_EB_Password1,   IDH_UserTab_New_EB_Password1,
    CID_UserTab_New_EB_Password2,   IDH_UserTab_New_EB_Password2,
    0,                              0
};

// Parameters to track net users
//
typedef struct _RASSRV_USER_PARAMS 
{
    BOOL bCanceled;         // Set by property sheets when cancel pressed

    // General properties
    //For whistler bug 210032 to allow username be 20 characters long
    WCHAR pszLogonName[22];
    WCHAR pszFullName [129];
    WCHAR pszPassword1[USERTAB_PASSWORD_BUFFER_SIZE];
    WCHAR pszPassword2[USERTAB_PASSWORD_BUFFER_SIZE];
    DWORD dwErrorCode;

    // Callback properties
    HANDLE hUser;      
    BOOL bNone; 
    BOOL bCaller; 
    BOOL bAdmin;    
    WCHAR pszNumber[MAX_PHONE_NUMBER_LEN];
} RASSRV_USER_PARAMS;

// Fills in the property sheet structure with the information 
// required to display the user database tab.
//
DWORD 
UserTabGetPropertyPage(
    IN LPPROPSHEETPAGE ppage, 
    IN LPARAM lpUserData) 
{
    // Initialize
    ZeroMemory(ppage, sizeof(PROPSHEETPAGE));

    // Fill in the values
    ppage->dwSize      = sizeof(PROPSHEETPAGE);
    ppage->hInstance   = Globals.hInstDll;
    ppage->pszTemplate = MAKEINTRESOURCE(PID_UserTab);
    ppage->pfnDlgProc  = UserTabDialogProc;
    ppage->pfnCallback = RasSrvInitDestroyPropSheetCb;
    ppage->dwFlags     = PSP_USECALLBACK;
    ppage->lParam      = lpUserData;

    return NO_ERROR;
}

//
// Error reporting
//
VOID 
UserTabDisplayError(
    IN HWND hwnd, 
    IN DWORD err) 
{
    ErrDisplayError(
        hwnd, 
        err, 
        ERR_USERTAB_CATAGORY, 
        ERR_USERDB_SUBCAT, 
        Globals.dwErrorData);
}

// Fills in the user list view with the names of the users stored in the 
// user database provide.  Also, initializes the checked/unchecked status
// of each user.
DWORD 
UserTabFillUserList(
    IN HWND hwndLV, 
    IN HANDLE hUserDatabase) 
{
    LV_ITEM lvi;
    DWORD dwCount, i, dwErr, dwSize;
    HANDLE hUser;
    WCHAR pszName[512];
    char pszAName[512];
    HIMAGELIST checks;
    BOOL bDialinEnabled;

    // Get the count of all the users
    if ((dwErr = usrGetUserCount(hUserDatabase, &dwCount)) != NO_ERROR) 
    {
        UserTabDisplayError(hwndLV, ERR_USER_DATABASE_CORRUPT);
        return dwErr;
    }

    ListView_SetUserImageList(hwndLV, Globals.hInstDll);

    // Initialize the list item
    ZeroMemory(&lvi, sizeof(LV_ITEM));
    lvi.mask = LVIF_TEXT | LVIF_IMAGE;

    // Looop through all of the users adding their names as we go
    for (i=0; i<dwCount; i++) 
    {
        dwSize = 512;
        if ((dwErr = usrGetUserHandle(hUserDatabase, i, &hUser)) == NO_ERROR) 
        {
            usrGetDisplayName (hUser, pszName, &dwSize);
            usrGetDialin(hUser, &bDialinEnabled);
            lvi.iImage = UI_Connections_User;
            lvi.iItem = i;
            lvi.pszText = pszName;
            lvi.cchTextMax = wcslen(pszName)+1;
            ListView_InsertItem(hwndLV,&lvi);
            ListView_SetCheck(hwndLV, i, bDialinEnabled);
        }
    }
    
    // Select the first item in the list view
    ListView_SetItemState(
        hwndLV, 
        0, 
        LVIS_SELECTED | LVIS_FOCUSED, 
        LVIS_SELECTED | LVIS_FOCUSED);

    return NO_ERROR;
}

//
// Initialize the user tab, returns false if focus was set, 
// true otherwise.
//
DWORD 
UserTabInitializeDialog(
    HWND hwndDlg, 
    WPARAM wParam, 
    LPARAM lParam) 
{
    HANDLE hUserDatabase = NULL;
    HWND hwndLV, hwndEnc, hwndBypass;
    LV_COLUMN lvc;
    RECT r;
    BOOL bEncrypt;
    DWORD dwErr;
    BOOL bPure = FALSE, bBypass = FALSE;

    // Obtain handle to user database
    RasSrvGetDatabaseHandle(hwndDlg, ID_USER_DATABASE, &hUserDatabase);

    // Figure out if MMC has been used.
    dwErr = usrIsDatabasePure (hUserDatabase, &bPure);
    if ((dwErr == NO_ERROR) && (bPure == FALSE)) 
    {
        PWCHAR pszWarning, pszTitle;

        pszWarning = (PWCHAR) PszLoadString(
                                Globals.hInstDll,
                                WRN_USERS_CONFIGURED_MMC);

        pszTitle = (PWCHAR) PszLoadString(
                                Globals.hInstDll,
                                ERR_USERTAB_CATAGORY);

        MessageBox(hwndDlg, pszWarning, pszTitle, MB_OK | MB_ICONWARNING);
        usrSetDatabasePure(hUserDatabase, TRUE);
    }

    // Fill in the user list if it's not already filled
    hwndLV = GetDlgItem(hwndDlg, CID_UserTab_LV_Users);
    if (ListView_GetItemCount (hwndLV) == 0) 
    {
        ListView_InstallChecks(hwndLV, Globals.hInstDll);
        UserTabFillUserList(hwndLV, hUserDatabase);

        // Add a colum so that we'll display in report view
        GetClientRect(hwndLV, &r);
        lvc.mask = LVCF_FMT;
        lvc.fmt = LVCFMT_LEFT;
        ListView_InsertColumn(hwndLV,0,&lvc);
        ListView_SetColumnWidth(hwndLV, 0, LVSCW_AUTOSIZE_USEHEADER);

        // Initialize the encryption check box
        hwndEnc = GetDlgItem(hwndDlg, CID_UserTab_CB_Encryption);
        usrGetEncryption(hUserDatabase, &bEncrypt);
        if (hwndEnc != NULL)
        {
            SendMessage(
                hwndEnc,
                BM_SETCHECK,
                (bEncrypt) ? BST_CHECKED : BST_UNCHECKED,
                0);
        }                
            
        // Initialize the "bypass dcc" checkbox
        hwndBypass = GetDlgItem(hwndDlg, CID_UserTab_CB_BypassDcc);
        if (hwndBypass != NULL)
        {
            usrGetDccBypass(hUserDatabase, &bBypass);
            SendMessage(
                hwndBypass, 
                BM_SETCHECK,
                (bBypass) ? BST_CHECKED : BST_UNCHECKED,
                0);
        }                
    }
    
    return TRUE;
}

// 
// Cleanup anything done in the initialization function
//
DWORD 
UserTabCleanupDialog(
    IN HWND hwndDlg, 
    IN WPARAM wParam, 
    IN LPARAM lParam) 
{
    // Restore the user data
    SetWindowLongPtr(hwndDlg, GWLP_USERDATA, 0);

    return NO_ERROR;
}

//
// Grants/revokes the dialin privelege of a user and reflects this 
// in the UI
//
DWORD 
UserTabHandleUserCheck(
    IN HWND hwndDlg, 
    IN DWORD dwIndex) 
{
    DWORD dwErr;
    HANDLE hUser = NULL, hUserDatabase = NULL;
    HWND hwndLV = GetDlgItem(hwndDlg, CID_UserTab_LV_Users);

    // Get the user handle from the user database
    RasSrvGetDatabaseHandle(hwndDlg, ID_USER_DATABASE, &hUserDatabase);
    dwErr = usrGetUserHandle(hUserDatabase, dwIndex, &hUser);
    if (dwErr != NO_ERROR) 
    {
        UserTabDisplayError(hwndDlg, ERR_USER_DATABASE_CORRUPT);
        return dwErr;
    }

    // Set the dialin permission of the given user
    usrEnableDialin(hUser, ListView_GetCheck(hwndLV, dwIndex));
    
    return NO_ERROR;
}

//
// Encrypts an in-memory password
//
DWORD 
UserTabEncryptPassword(
    IN PWCHAR pszPassword, 
    IN DWORD dwLength) 
{
    DWORD i;
    WCHAR ENCRYPT_MASK = (WCHAR)0xA5;

    for (i = 0; i < dwLength; i++) 
    {
        pszPassword[i] ^= ENCRYPT_MASK;
        pszPassword[i] ^= ENCRYPT_MASK;
    }

    return NO_ERROR;
}    
    
DWORD 
UserTabDecryptPassword(
    IN PWCHAR pszPassword, 
    IN DWORD dwLength) 
{
    return UserTabEncryptPassword(pszPassword, dwLength);
}

//
// Loads the New User parameters and returns whether they
// have been correctly entered or not.
//
BOOL 
UserTabNewUserParamsOk(
    IN HWND hwndDlg, 
    IN RASSRV_USER_PARAMS * pNuParams)
{
    USER_MODALS_INFO_0 * pModInfo;
    NET_API_STATUS nStatus;
    DWORD dwMinPasswordLength=0, dwLength;
    BOOL bOk = FALSE;

    // Find the minium password length
    nStatus = NetUserModalsGet(NULL, 0, (LPBYTE*)&pModInfo);
    if (nStatus == NERR_Success) 
    {
        dwMinPasswordLength = pModInfo->usrmod0_min_passwd_len;
        NetApiBufferFree((LPBYTE)pModInfo);
    }

    // Load the parameters
    GetWindowTextW(
        GetDlgItem(hwndDlg, CID_UserTab_New_EB_Username),
        pNuParams->pszLogonName, 
        (sizeof(pNuParams->pszLogonName)/sizeof(WCHAR)) - 1);
        
    GetWindowTextW(
        GetDlgItem(hwndDlg, CID_UserTab_New_EB_Fullname),
        pNuParams->pszFullName,  
        (sizeof(pNuParams->pszFullName)/sizeof(WCHAR)) - 1);
        
    GetWindowTextW(
        GetDlgItem(hwndDlg, CID_UserTab_New_EB_Password1),
        pNuParams->pszPassword1, 
        (sizeof(pNuParams->pszPassword1)/sizeof(WCHAR)) - 1);
        
    GetWindowTextW(
        GetDlgItem(hwndDlg, CID_UserTab_New_EB_Password2),
        pNuParams->pszPassword2, 
        (sizeof(pNuParams->pszPassword2)/sizeof(WCHAR)) - 1);

    do
    {
        // Verify that we have a login name
        dwLength = wcslen(pNuParams->pszLogonName);
        if (dwLength < 1) 
        {
            pNuParams->dwErrorCode = ERR_LOGON_NAME_TOO_SMALL;
            bOk = FALSE;
            break;
        }
    
        // Verify the minimum password length
        dwLength = wcslen(pNuParams->pszPassword1);
        if (dwLength < dwMinPasswordLength) 
        {
            pNuParams->dwErrorCode = ERR_PASSWORD_TOO_SMALL;
            bOk = FALSE;
            break;
        }
        
        // Verify the passwords was entered correctly
        if (wcscmp(pNuParams->pszPassword1, pNuParams->pszPassword2)) 
        {
            pNuParams->dwErrorCode = ERR_PASSWORD_MISMATCH;
            bOk = FALSE;
            break;
        }

        bOk = TRUE;
        
    } while (FALSE);

    // Cleanup
    {
        if (!bOk) 
        {
            ZeroMemory(
                pNuParams->pszPassword1, 
                USERTAB_PASSWORD_BUFFER_SIZE);
                
            ZeroMemory(
                pNuParams->pszPassword2, 
                USERTAB_PASSWORD_BUFFER_SIZE);
        }
    }

    // Encrypt the passwords in memory for security
    UserTabEncryptPassword(pNuParams->pszPassword1, dwLength);
    UserTabEncryptPassword(pNuParams->pszPassword2, dwLength);
    
    return bOk;
}

//
// Initialize the callback properties of the given user
//
DWORD 
UserTabLoadUserProps (
    IN RASSRV_USER_PARAMS * pParams) 
{
    PWCHAR pszName;
    DWORD dwErr, dwSize; 
    PWCHAR pszNumber;

    if (!pParams)
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    // If this is a new user, default to user specified callback 
    // (convienience mode)
    if (!pParams->hUser) 
    {
        ZeroMemory(pParams, sizeof(*pParams));
        pParams->bNone = TRUE;
        pParams->bCaller = FALSE;
        pParams->bAdmin = FALSE;
    }

    // Otherwise, load the user parameters from the user database
    else 
    {
        pParams->bCanceled = FALSE;
        dwSize = sizeof(pParams->pszFullName);
        usrGetFullName (pParams->hUser, pParams->pszFullName, &dwSize);
        usrGetName(pParams->hUser, &pszName);
        lstrcpynW(
            pParams->pszLogonName, 
            pszName, 
            sizeof(pParams->pszLogonName) / sizeof(WCHAR));
        lstrcpynW(
            pParams->pszPassword1, 
            pszDummyPassword,
            sizeof(pParams->pszPassword1) / sizeof(WCHAR));
        lstrcpynW(
            pParams->pszPassword2, 
            pszDummyPassword,
            sizeof(pParams->pszPassword2) / sizeof(WCHAR));
        dwErr = usrGetCallback(
                    pParams->hUser, 
                    &pParams->bAdmin, 
                    &pParams->bCaller);
        if (dwErr != NO_ERROR)
        {
            return dwErr;
        }

        dwErr = usrGetCallbackNumber(pParams->hUser, &pszNumber);
        if (dwErr != NO_ERROR)
        {
            return dwErr;
        }
        lstrcpynW(
            pParams->pszNumber, 
            pszNumber,
            sizeof(pParams->pszNumber) / sizeof(WCHAR));
    }

    return NO_ERROR;
}

//
// Commit the call back properties of the given user. 
//
DWORD 
UserTabSaveCallbackProps (
    IN RASSRV_USER_PARAMS * pParams) 
{
    if (!pParams)
    {
        return ERROR_INVALID_PARAMETER;
    }
        
    // If we have a valid handle to the user, set his/her
    // properties
    if (pParams->hUser) 
    {
        pParams->bNone = 
            (pParams->bCaller == FALSE && pParams->bAdmin == FALSE);
        
        // Set the enabling and number
        usrEnableCallback(
            pParams->hUser, 
            pParams->bNone, 
            pParams->bCaller, 
            pParams->bAdmin);
            
        if (pParams->bAdmin)
        {
            usrSetCallbackNumber(pParams->hUser, pParams->pszNumber);
        }
    }
        
    return NO_ERROR;
}

// Commit the parameters of the given user.  If pOrig is non-null, then all
// fields of pParams will be compare against pOrig and only those that have changed
// will be committed. (optimization)
//
DWORD 
UserTabSaveUserProps (
    IN RASSRV_USER_PARAMS * pParams, 
    IN RASSRV_USER_PARAMS * pOrig, 
    IN PBOOL pbChanged) 
{
    DWORD dwLength;
    
    if (!pParams || !pOrig || !pbChanged)
    {
        return ERROR_INVALID_PARAMETER;
    }

    *pbChanged = FALSE;
    
    // Commit the full name if changed
    if (wcscmp(pParams->pszFullName, pOrig->pszFullName)) 
    {
        usrSetFullName(pParams->hUser, pParams->pszFullName);
        *pbChanged = TRUE;
    }

    // Commit the password if changed
    dwLength = wcslen(pParams->pszPassword1);
    UserTabDecryptPassword(pParams->pszPassword1, dwLength);
    if (wcscmp(pParams->pszPassword1, pszDummyPassword))
    {
        usrSetPassword(pParams->hUser, pParams->pszPassword1);
    }
    UserTabEncryptPassword(pParams->pszPassword1, dwLength);
        
    UserTabSaveCallbackProps(pParams);
    return NO_ERROR;
}

DWORD
UserTabCallbackApply(
    IN HWND hwndDlg)
{
    RASSRV_USER_PARAMS * pParams = NULL;
    LONG dwResult = PSNRET_NOERROR;
    
    pParams = (RASSRV_USER_PARAMS *)
        GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    
    pParams->bNone = (BOOL)
        SendMessage(
            GetDlgItem(hwndDlg,CID_UserTab_Callback_RB_No),
            BM_GETCHECK,
            0,
            0);
            
    pParams->bCaller = (BOOL)
        SendMessage(
            GetDlgItem(hwndDlg,CID_UserTab_Callback_RB_Caller),
            BM_GETCHECK,
            0,
            0);
            
    pParams->bAdmin = (BOOL)
        SendMessage(
            GetDlgItem(hwndDlg,CID_UserTab_Callback_RB_Admin),
            BM_GETCHECK,
            0,
            0);
            
    if (pParams->bAdmin) 
    {
        GetWindowTextW(
            GetDlgItem(hwndDlg,CID_UserTab_Callback_EB_Number), 
            pParams->pszNumber, 
            MAX_PHONE_NUMBER_LEN);

        // If admin callback was set, but no admin callback number was set,
        // then popup an error and don't to refuse the apply
        //
        if (wcslen(pParams->pszNumber) == 0) 
        {
            UserTabDisplayError(hwndDlg, ERR_CALLBACK_NUM_REQUIRED);
            PropSheet_SetCurSel ( GetParent(hwndDlg), hwndDlg, 0 );
            dwResult = PSNRET_INVALID;
        }
    }                                
    
    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, dwResult);
    return TRUE;
}

//
// Dialog procedure that implements getting callback properties 
//
INT_PTR 
CALLBACK 
UserTabCallbackDialogProc(
    IN HWND hwndDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam) 
{
    switch (uMsg) 
    {
        case WM_INITDIALOG:
        {
            PWCHAR lpzNumber, lpzName;
            HWND hwCb = GetDlgItem(hwndDlg, CID_UserTab_Callback_EB_Number);
            RASSRV_USER_PARAMS * pu = 
                (RASSRV_USER_PARAMS *)(((PROPSHEETPAGE*)lParam)->lParam);
            
            // Initialize
            SendMessage(
                hwCb, 
                EM_SETLIMITTEXT, 
                sizeof(pu->pszNumber)/2 - 1, 0);
                
            SetWindowLongPtr(
                hwndDlg, 
                GWLP_USERDATA, 
                (LONG_PTR)pu);
            
            // Display the callback properties
            if (!pu->bAdmin && !pu->bCaller) 
            {
                SendMessage(
                    GetDlgItem(hwndDlg,CID_UserTab_Callback_RB_No),
                    BM_SETCHECK,BST_CHECKED,
                    0);
                    
                SetFocus(
                    GetDlgItem(hwndDlg, CID_UserTab_Callback_RB_No));
            }
            else if (pu->bCaller) 
            {
                SendMessage(
                    GetDlgItem(hwndDlg,CID_UserTab_Callback_RB_Caller),
                    BM_SETCHECK,BST_CHECKED,
                    0);
                    
                SetFocus(
                    GetDlgItem(hwndDlg, CID_UserTab_Callback_RB_Caller));
            }
            else 
            {
                SendMessage(
                    GetDlgItem(hwndDlg,CID_UserTab_Callback_RB_Admin),
                    BM_SETCHECK,BST_CHECKED,
                    0);
                
                SetFocus(
                    GetDlgItem(hwndDlg, CID_UserTab_Callback_RB_Admin));
            }
            
            SetWindowTextW(hwCb, pu->pszNumber);
            EnableWindow(hwCb, !!pu->bAdmin);
        }
        return TRUE;

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            RasSrvHelp (hwndDlg, uMsg, wParam, lParam, phmCallback);
            break;
        }

        case WM_DESTROY:                           
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, 0);
            break;
        
        case WM_NOTIFY:
            {
                NMHDR* pNotifyData;
                NM_LISTVIEW* pLvNotifyData;
    
                pNotifyData = (NMHDR*)lParam;
                switch (pNotifyData->code) 
                {
                    // The property sheet apply button was pressed
                    case PSN_APPLY:
                        return UserTabCallbackApply(hwndDlg);
                        break;
                        
                    // The property sheet cancel was pressed
                    case PSN_RESET:                    
                        SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
                        break;
               }
           }
           break;
           
        case WM_COMMAND:
            switch (wParam) 
            {
                case CID_UserTab_Callback_RB_No:
                case CID_UserTab_Callback_RB_Caller:
                case CID_UserTab_Callback_RB_Admin:
                {
                    HWND hwndNumber = NULL;
                    HWND hwndAdmin = NULL;

                    hwndNumber = 
                        GetDlgItem(hwndDlg, CID_UserTab_Callback_EB_Number);

                    hwndAdmin = 
                        GetDlgItem(hwndDlg, CID_UserTab_Callback_RB_Admin);
                        
                    EnableWindow(
                        hwndNumber,
                        (BOOL) SendMessage(
                                    hwndAdmin,
                                    BM_GETCHECK, 
                                    0, 
                                    0));
                }
                break;
            }
            break;
    }

    return FALSE;
}

// 
// Initializes the user properties dialog procedure. 
//
// Return TRUE if focus is set, false otherwise.
//
BOOL
UserTabInitUserPropsDlg(
    IN HWND hwndDlg,
    IN WPARAM wParam,
    IN LPARAM lParam)
{
    HWND hwLogon, hwFull, hwPass1, hwPass2, hwOk, hwCancel;
    
    RASSRV_USER_PARAMS * pu = 
        (RASSRV_USER_PARAMS *)(((PROPSHEETPAGE*)lParam)->lParam);
        
    hwLogon = GetDlgItem(
                hwndDlg, 
                CID_UserTab_New_EB_Username);
    hwFull = GetDlgItem(
                hwndDlg, 
                CID_UserTab_New_EB_Fullname);
    hwPass1 = GetDlgItem(
                hwndDlg, 
                CID_UserTab_New_EB_Password1);
    hwPass2 = GetDlgItem(
                hwndDlg, 
                CID_UserTab_New_EB_Password2);
    hwOk = GetDlgItem(
                hwndDlg, 
                IDOK);
    hwCancel = GetDlgItem(
                hwndDlg, 
                IDCANCEL);

    // Store the parameters with the window handle
    SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR)pu);

    // Set limits to the text that can be entered
    SendMessage(
        hwLogon, 
        EM_SETLIMITTEXT, 
        sizeof(pu->pszLogonName)/2 - 2, 
        0);
    SendMessage(
        hwFull,  
        EM_SETLIMITTEXT, 
        sizeof(pu->pszFullName)/2 - 2, 
        0);
    SendMessage(
        hwPass1, 
        EM_SETLIMITTEXT, 
        sizeof(pu->pszPassword1)/2 - 2 , 
        0);
    SendMessage(
        hwPass2, 
        EM_SETLIMITTEXT, 
        sizeof(pu->pszPassword2)/2 - 2, 
        0);

    // Fill out the fields
    SetWindowTextW(hwLogon, pu->pszLogonName); 
    SetWindowTextW(hwFull,  pu->pszFullName); 
    SetWindowTextW(hwPass1, pu->pszPassword1);
    SetWindowTextW(hwPass2, pu->pszPassword2);

    // Don't allow editing of the logon name if user already exists
    // Also, don't show the ok and cancel buttons if the user already 
    // exits (because it's a property sheet with its own buttons)
    if (pu->hUser) {
        EnableWindow(hwLogon, FALSE);
        ShowWindow(hwOk, SW_HIDE);
        ShowWindow(hwCancel, SW_HIDE);
    }

    // Otherwise, we are creating a new user.  Change the window 
    // title to other than "General".  Also disable the ok button
    // since it will be enabled when a user name is typed in.
    else {
        PWCHAR pszTitle;
        pszTitle = (PWCHAR) PszLoadString (
                                Globals.hInstDll, 
                                SID_NEWUSER);
        SetWindowTextW (hwndDlg, pszTitle);
        EnableWindow(hwOk, FALSE);
    }

    return FALSE;
}
    

// Dialog procedure that implements the new user 
INT_PTR 
CALLBACK 
UserTabGenUserPropsDlgProc(
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam) 
{
    switch (uMsg) {
        case WM_INITDIALOG:
            return UserTabInitUserPropsDlg(hwndDlg, wParam, lParam);
            break;
        
        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            RasSrvHelp (hwndDlg, uMsg, wParam, lParam, phmNewUser);
            break;
        }

       case WM_DESTROY:                           
            // Cleanup the work done at WM_INITDIALOG 
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, 0);
            break;

        case WM_NOTIFY:
            {
                NMHDR* pNotifyData;
                NM_LISTVIEW* pLvNotifyData;
    
                pNotifyData = (NMHDR*)lParam;
                switch (pNotifyData->code) {
                    // The property sheet apply button was pressed
                    case PSN_APPLY:                    
                        {
                            RASSRV_USER_PARAMS * pParams;
                            pParams = (RASSRV_USER_PARAMS *)
                                GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                            if (UserTabNewUserParamsOk(hwndDlg, pParams))
                            {
                                SetWindowLongPtr(
                                    hwndDlg, 
                                    DWLP_MSGRESULT, 
                                    PSNRET_NOERROR);
                            }
                            else 
                            {
                                ErrDisplayError(
                                    hwndDlg, 
                                    pParams->dwErrorCode, 
                                    ERR_USERTAB_CATAGORY,ERR_USERDB_SUBCAT,
                                    0);
                                    
                                SetWindowLongPtr(
                                    hwndDlg, 
                                    DWLP_MSGRESULT, 
                                    PSNRET_INVALID_NOCHANGEPAGE);
                            }
                        }
                        return TRUE;
                        
                    // The property sheet cancel was pressed
                    case PSN_RESET:                    
                        {
                            RASSRV_USER_PARAMS * pParams;
                            pParams = (RASSRV_USER_PARAMS *)
                                GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                            pParams->bCanceled = TRUE;
                            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
                            break;
                        }
               }
           }
           break;

        case WM_COMMAND:
            // Handle ok being pressed
            //
            if (wParam == IDOK) 
            {
                RASSRV_USER_PARAMS * pParams;
                pParams = (RASSRV_USER_PARAMS *)
                    GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
                if (UserTabNewUserParamsOk(hwndDlg, pParams))
                {
                    EndDialog(hwndDlg, 1);
                }
                else
                {
                    ErrDisplayError(
                        hwndDlg, 
                        pParams->dwErrorCode, 
                        ERR_USERTAB_CATAGORY,ERR_USERDB_SUBCAT,
                        0);
                }
            }

            // And cancel being pressed
            else if (wParam == IDCANCEL) 
            {
                EndDialog(hwndDlg, 0);
            }
            
            // Notice whether the user name has been updated and 
            // if so enable/disable the "Ok" button according to 
            // whether a name has been entered.
            if (HIWORD(wParam) == EN_UPDATE) 
            {
                WCHAR pszName[256];
                HWND hwndName;
                BOOL bEnable = FALSE;

                if (CID_UserTab_New_EB_Username == LOWORD(wParam))
                {
                    // Get the current name
                    hwndName = (HWND)lParam;
                    pszName[0] = (WCHAR)0;
                    GetWindowTextW(
                        hwndName, 
                        pszName, 
                        sizeof(pszName)/sizeof(WCHAR));

                    // If the length is greater than 1, enable the 
                    // ok button.  Otherwise, disable it.
                    bEnable = pszName[0] != (WCHAR)0;
                    EnableWindow(GetDlgItem(hwndDlg, IDOK), bEnable);
                }
            }
            break;
    }

    return FALSE;
}

// Brings up the new user/properties property sheet.
//
// If bNewUser is set, this is a new user, otherwise pUserParams
// contains the pertanent user information.
//
// Returns:
//      NO_ERROR on success, pUserParams will be filled in 
//      ERROR_CANCELLED if cancel was pressed
//      win32 error otherwise
//
DWORD 
UserTabRaiseProperties (
    IN HWND hwndParent, 
    IN RASSRV_USER_PARAMS * pUserParams) 
{
    PROPSHEETPAGE Pages[2];
    PROPSHEETHEADER Header;
    INT_PTR ret;

    if (!pUserParams)
        return ERROR_INVALID_PARAMETER;
        
    // Initialize
    ZeroMemory(&Pages, sizeof(Pages));
    ZeroMemory(&Header, sizeof(Header));

    // Fill in the values for the general tab
    Pages[0].dwSize      = sizeof(PROPSHEETPAGE);
    Pages[0].hInstance   = Globals.hInstDll;
    Pages[0].pszTemplate = MAKEINTRESOURCE(DID_UserTab_New);
    Pages[0].pfnDlgProc  = UserTabGenUserPropsDlgProc;
    Pages[0].pfnCallback = NULL;
    Pages[0].dwFlags     = 0;
    Pages[0].lParam      = (LPARAM)pUserParams;

    // Fill in the values for the callback tab
    Pages[1].dwSize      = sizeof(PROPSHEETPAGE);
    Pages[1].hInstance   = Globals.hInstDll;
    Pages[1].pszTemplate = MAKEINTRESOURCE(DID_UserTab_Callback);
    Pages[1].pfnDlgProc  = UserTabCallbackDialogProc;
    Pages[1].pfnCallback = NULL;
    Pages[1].dwFlags     = 0;
    Pages[1].lParam      = (LPARAM)pUserParams;

    // Fill in the values for the header
    Header.dwSize = sizeof(Header);    
    Header.dwFlags = PSH_DEFAULT       | 
                     PSH_PROPSHEETPAGE | 
                     PSH_PROPTITLE     | 
                     PSH_NOAPPLYNOW;    
    Header.hwndParent = hwndParent;
    Header.hInstance = Globals.hInstDll;    
    Header.pszCaption = (pUserParams->hUser)      ? 
                        pUserParams->pszLogonName : 
                        pUserParams->pszFullName;
    Header.nPages = sizeof(Pages) / sizeof(Pages[0]);
    Header.ppsp = Pages;
    
    // Popup the dialog box
    if ((ret = PropertySheet(&Header)) == -1)
    {
        return GetLastError();
    }

    if (pUserParams->bCanceled)
    {
        return ERROR_CANCELLED;
    }

    return NO_ERROR;
}

//
// Raises the new user dialog
//
DWORD 
UserTabRaiseNewUserDialog(
    IN HWND hwndDlg, 
    IN RASSRV_USER_PARAMS * pParams) 
{
    PROPSHEETPAGE Pages;
    INT_PTR iRet = 0;

    if (!pParams)
    {
        return ERROR_INVALID_PARAMETER;
    }
        
    // Initialize
    ZeroMemory(&Pages, sizeof(Pages));
    Pages.lParam = (LPARAM)pParams;

    // Raise the dialog
    iRet = DialogBoxParam(
                Globals.hInstDll, 
                MAKEINTRESOURCE(DID_UserTab_New),
                hwndDlg, 
                UserTabGenUserPropsDlgProc,
                (LPARAM)&Pages);

    if (iRet == -1)
    {
        return GetLastError();
    }

    if (iRet == 0)
    {
        return ERROR_CANCELLED;
    }

    return NO_ERROR;
}

//
// Handles a request to add a new user
//
DWORD 
UserTabHandleNewUserRequest(
    IN HWND hwndDlg) 
{
    RASSRV_USER_PARAMS Params;
    DWORD dwErr, dwLength;
    HANDLE hUserDatabase = NULL;
    HWND hwndLV;

    // Initializes the callback properties
    Params.hUser = NULL;
    UserTabLoadUserProps (&Params);

    // Show the new user property sheet
    dwErr = UserTabRaiseNewUserDialog(hwndDlg, &Params);
    if (dwErr != NO_ERROR)
    {
        return dwErr;
    }

    // Flush any changes to the local user database.  These can be 
    // rolled back later with usrRollbackLocalDatabase
    RasSrvGetDatabaseHandle(hwndDlg, ID_USER_DATABASE, &hUserDatabase);

    // Unencrypt the passwords
    dwLength = wcslen(Params.pszPassword1);
    UserTabDecryptPassword(Params.pszPassword1, dwLength);

    // Make sure you can add the user
    dwErr = RasSrvAddUser (
                Params.pszLogonName,
                Params.pszFullName,
                Params.pszPassword1);

    UserTabEncryptPassword(Params.pszPassword1, dwLength);
                          
    // Figure out whether the user was added successfully                          
    if (dwErr != NO_ERROR) 
    {
        // Clear the passwords from memory
        ZeroMemory(Params.pszPassword1, USERTAB_PASSWORD_BUFFER_SIZE);
        ZeroMemory(Params.pszPassword2, USERTAB_PASSWORD_BUFFER_SIZE);

        switch (dwErr) {
            case ERROR_ACCESS_DENIED:
                UserTabDisplayError(hwndDlg, ERR_CANT_ADD_USER_ACCESS);
                break;
                
            case ERROR_USER_EXISTS:
                UserTabDisplayError(hwndDlg, ERR_CANT_ADD_USER_DUPLICATE);
                break;
                
            case ERROR_INVALID_PASSWORDNAME:
                UserTabDisplayError(hwndDlg, ERR_CANT_ADD_USER_PASSWORD);
                break;
                
            default:
                UserTabDisplayError(hwndDlg, ERR_CANT_ADD_USER_GENERIC);
        }
        
        return dwErr;
    }

    // Delete the user (since he/she will be added later when the database
    // is flushed
    RasSrvDeleteUser(Params.pszLogonName);

    // Add the user to the database
    dwErr = usrAddUser(hUserDatabase, Params.pszLogonName, &(Params.hUser)); 
    if (dwErr == ERROR_ALREADY_EXISTS) 
    {
        UserTabDisplayError(hwndDlg, ERR_CANT_ADD_USER_DUPLICATE);
        return dwErr;
    }
    if (dwErr != NO_ERROR) 
    {
        UserTabDisplayError(hwndDlg, ERR_CANT_ADD_USER_GENERIC);
        return dwErr;
    }

    // Commit the parameters of this user
    if (wcslen(Params.pszFullName) > 0)
    {
        usrSetFullName (Params.hUser, Params.pszFullName);
    }
    if (dwLength > 0) 
    {
        UserTabDecryptPassword(Params.pszPassword1, dwLength);
        usrSetPassword (Params.hUser, Params.pszPassword1);
        ZeroMemory(Params.pszPassword1, USERTAB_PASSWORD_BUFFER_SIZE);
        ZeroMemory(Params.pszPassword2, USERTAB_PASSWORD_BUFFER_SIZE);
    }
    UserTabSaveCallbackProps (&Params);

    // Delete all of the old items from the list view
    hwndLV = GetDlgItem(hwndDlg, CID_UserTab_LV_Users);
    if (!ListView_DeleteAllItems(hwndLV)) 
    {
        UserTabDisplayError(hwndDlg, ERR_GENERIC_CODE);
        return ERR_GENERIC_CODE;
    }

    // Finally, restock the list view
    UserTabFillUserList(hwndLV, hUserDatabase);

    return NO_ERROR;
}

DWORD 
UserTabHandleProperties(
    IN HWND hwndDlg, 
    IN DWORD dwIndex) 
{
    HANDLE hUser = NULL, hUserDatabase = NULL;
    RASSRV_USER_PARAMS Params, Orig;
    DWORD dwErr = NO_ERROR;
    BOOL bNameChanged;

    // Get a handle to the user in question
    RasSrvGetDatabaseHandle(hwndDlg, ID_USER_DATABASE, &hUserDatabase);
    dwErr = usrGetUserHandle (hUserDatabase, dwIndex, &hUser);
    if (dwErr != NO_ERROR) 
    {
        UserTabDisplayError(hwndDlg, ERR_USER_DATABASE_CORRUPT);
        return dwErr;
    }

    // Initializes the callback properties
    Params.hUser = hUser;
    if ((dwErr = UserTabLoadUserProps (&Params)) != NO_ERROR)
    {
        return dwErr;
    }
    CopyMemory(&Orig, &Params, sizeof(Params));

    // Show the user property sheet
    if ((dwErr = UserTabRaiseProperties(hwndDlg, &Params)) != NO_ERROR)
    {
        return dwErr;
    }

    // Commit any changes needed
    UserTabSaveUserProps(&Params, &Orig, &bNameChanged);

    // If the name changed, update the list view
    if (bNameChanged) 
    {
        LV_ITEM lvi;
        WCHAR pszDispName[128];
        DWORD dwSize = sizeof(pszDispName);
        HWND hwndLV = GetDlgItem(hwndDlg, CID_UserTab_LV_Users);

        // Initialize the list item
        ZeroMemory(&lvi, sizeof(LV_ITEM));
        lvi.mask = LVIF_TEXT;
        lvi.iItem = dwIndex;
        lvi.pszText = pszDispName;
        usrGetDisplayName(hUser, pszDispName, &dwSize);

        ListView_SetItem(hwndLV, &lvi);
        ListView_RedrawItems(hwndLV, dwIndex, dwIndex);
    }

    return NO_ERROR;
}

//
// Handles the request to delete the user at index dwIndex
//
DWORD 
UserTabHandleDeleteUser(
    IN HWND hwndDlg, 
    IN DWORD dwIndex) 
{
    WCHAR *pszCapString, pszCaption[512];
    WCHAR *pszTitle, *pszName, pszFullName[128];
    HANDLE hUserDatabase = NULL, hUser = NULL;
    DWORD dwErr= NO_ERROR, dwSize = sizeof(pszFullName);
    HWND hwndLV = NULL;
    INT iRet;

    // Get a handle to the user in question
    RasSrvGetDatabaseHandle(hwndDlg, ID_USER_DATABASE, &hUserDatabase);
    dwErr = usrGetUserHandle (hUserDatabase, dwIndex, &hUser);
    if (dwErr != NO_ERROR) 
    {
        UserTabDisplayError(hwndDlg, ERR_USER_DATABASE_CORRUPT);
        return dwErr;
    }
    
    if ((dwErr = usrGetName(hUser, &pszName)) != NO_ERROR)
    {
        return dwErr;
    }
    if ((dwErr = usrGetFullName(hUser, pszFullName, &dwSize)) != NO_ERROR)
    {
        return dwErr;
    }

    // Load resources
    pszCapString = 
        (PWCHAR) PszLoadString (Globals.hInstDll, WRN_DELETE_USER_PERMANENT);
    pszTitle = 
        (PWCHAR) PszLoadString (Globals.hInstDll, WRN_TITLE);

    // Format the caption
    if (wcslen(pszFullName))
        wsprintfW(pszCaption, pszCapString, pszFullName);
    else
        wsprintfW(pszCaption, pszCapString, pszName);
    
    // Advertise the warning
    iRet = MessageBox(
                hwndDlg, 
                pszCaption, 
                pszTitle, 
                MB_YESNO | MB_ICONWARNING);
    if (iRet == IDNO)
    {
        return NO_ERROR;
    }

    // Delete the user
    if ((dwErr = usrDeleteUser(hUserDatabase, dwIndex)) != NO_ERROR) 
    {
        UserTabDisplayError(hwndDlg, ERR_CANT_DELETE_USER_GENERAL);
        return dwErr;
    }

    // Remove all items from the list view
    hwndLV = GetDlgItem(hwndDlg, CID_UserTab_LV_Users);
    if (!ListView_DeleteAllItems(hwndLV)) 
    {
        UserTabDisplayError(hwndDlg, ERR_GENERIC_CODE);
        return ERR_GENERIC_CODE;
    }

    // Finally, restock the list view
    UserTabFillUserList(hwndLV, hUserDatabase);
    
    return NO_ERROR;
}

//
// Saves the encryption setting
//
DWORD 
UserTabSaveEncryption(
    IN HWND hwndDlg) 
{
    HANDLE hUserDatabase = NULL;
    BOOL bEncrypt;
    HWND hwndCtrl;

    // Get reference to the misc database
    RasSrvGetDatabaseHandle(
        hwndDlg, 
        ID_USER_DATABASE, 
        &hUserDatabase);

    hwndCtrl = GetDlgItem(hwndDlg, CID_UserTab_CB_Encryption);
    if (hwndCtrl != NULL) 
    {
        // Get the setting of the checkbox and commit it
        bEncrypt = SendMessage(
                        hwndCtrl, 
                        BM_GETCHECK,
                        0,
                        0) == BST_CHECKED;
                                      
        usrSetEncryption(hUserDatabase, bEncrypt);
    }
    
    return NO_ERROR;
}

//
// Saves the dcc bypass setting
//
DWORD 
UserTabSaveBypassDcc(
    IN HWND hwndDlg) 
{
    HANDLE hUserDatabase = NULL;
    BOOL bBypass = FALSE;
    HWND hwndCtrl;

    // Get reference to the misc database
    RasSrvGetDatabaseHandle(
        hwndDlg, 
        ID_USER_DATABASE, 
        &hUserDatabase);

    hwndCtrl = GetDlgItem(hwndDlg, CID_UserTab_CB_BypassDcc);
    if (hwndCtrl != NULL) 
    {
        // Get the setting of the checkbox and commit it
        bBypass = SendMessage(
                        hwndCtrl, 
                        BM_GETCHECK,
                        0,
                        0) == BST_CHECKED;
                                      
        usrSetDccBypass(hUserDatabase, bBypass);
    }
    
    return NO_ERROR;
}

//
// Handles WM_COMMAND messages on the user tab.
//
DWORD 
UserTabCommand (
    HWND hwndDlg, 
    WPARAM wParam, 
    LPARAM lParam) 
{
    DWORD dwIndex;

    dwIndex = 
        ListView_GetSelectionMark(
            GetDlgItem(hwndDlg, CID_UserTab_LV_Users));
    
    switch (wParam) {
        case CID_UserTab_PB_New:
            UserTabHandleNewUserRequest(hwndDlg);
            break;
            
        case CID_UserTab_PB_Properties:
            dwIndex = 
            UserTabHandleProperties(hwndDlg, dwIndex);
            break;
            
        case CID_UserTab_PB_Delete:
            UserTabHandleDeleteUser(hwndDlg, dwIndex);
            break;
            
        case CID_UserTab_CB_Encryption:
            UserTabSaveEncryption (hwndDlg);
            break;
            
        case CID_UserTab_CB_BypassDcc:
            UserTabSaveBypassDcc (hwndDlg);
            break;
            
        case CID_UserTab_PB_SwitchToMMC:
            if (RassrvWarnMMCSwitch(hwndDlg)) 
            {
                PropSheet_PressButton(GetParent(hwndDlg), PSBTN_OK);
                RassrvLaunchMMC(RASSRVUI_USERCONSOLE);
            }    
            break;
    }

    return NO_ERROR;
}    

//
// This dialog procedure responds to messages sent to the 
// user tab.
//
INT_PTR 
CALLBACK 
UserTabDialogProc(
    IN HWND hwndDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam) 
{
    // Filter the customized list view messages
    if (ListView_OwnerHandler(
            hwndDlg, 
            uMsg, 
            wParam, 
            lParam, 
            LvDrawInfoCallback)
       )
    {
        return TRUE;
    }

    // Filter the customized ras server ui page messages. 
    // By filtering messages through here, we are able to 
    // call RasSrvGetDatabaseHandle below
    if (RasSrvMessageFilter(hwndDlg, uMsg, wParam, lParam))
    {
        return TRUE;
    }

    switch (uMsg) 
    {
        case WM_INITDIALOG:
            return FALSE;

        case WM_HELP:
        case WM_CONTEXTMENU:
        {
            RasSrvHelp (hwndDlg, uMsg, wParam, lParam, phmUserTab);
            break;
        }

        case WM_NOTIFY:
        {
            NMHDR* pNotifyData;
            NM_LISTVIEW* pLvNotifyData;

            pNotifyData = (NMHDR*)lParam;
            switch (pNotifyData->code) {
                //
                // Note: PSN_APPLY and PSN_CANCEL are handled 
                // by RasSrvMessageFilter
                //
                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(GetParent(hwndDlg), 0);
                    if (! GetWindowLongPtr(hwndDlg, GWLP_USERDATA))
                    {
                        UserTabInitializeDialog(
                            hwndDlg, 
                            wParam, 
                            lParam);
                            
                        SetWindowLongPtr(
                            hwndDlg, 
                            GWLP_USERDATA, 
                            (LONG_PTR)1);
                    }
                    PropSheet_SetWizButtons(
                        GetParent(hwndDlg), 
                        PSWIZB_NEXT | PSWIZB_BACK);		
                    break;
                    
                // The check of an item is changing
                case LVXN_SETCHECK:
                    pLvNotifyData = (NM_LISTVIEW*)lParam;
                    UserTabHandleUserCheck(
                        hwndDlg, 
                        (DWORD)pLvNotifyData->iItem);
                    break;

                case LVXN_DBLCLK:
                    pLvNotifyData = (NM_LISTVIEW*)lParam;
                    UserTabHandleProperties(
                        hwndDlg, 
                        pLvNotifyData->iItem);
                    break;
            }
        }
        break;

        case WM_COMMAND:
            UserTabCommand (hwndDlg, wParam, lParam);
            break;

        // Cleanup the work done at WM_INITDIALOG 
        case WM_DESTROY:                           
            UserTabCleanupDialog(hwndDlg, wParam, lParam);
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\wizard.h ===
/*
    File    wizard.c

    Declarations for the incoming connections wizard.

    Paul Mayfield, 10/30/97
*/

#ifndef __rassrvui_wizard_h
#define __rassrvui_wizard_h

// Fills in the property sheet structure with the information required to display
// the device tab in the incoming connections wizard.
DWORD DeviceWizGetPropertyPage(LPPROPSHEETPAGE ppage, LPARAM lpUserData);

// Fills in the property sheet structure with the information required to display
// the virtual networking tab in the incoming connections wizard.
DWORD VpnWizGetPropertyPage(LPPROPSHEETPAGE ppage, LPARAM lpUserData);

// Function fills in the given LPPROPSHEETPAGE structure with the information needed
// to run the user tab in the incoming connections wizard.
DWORD UserWizGetPropertyPage(LPPROPSHEETPAGE lpPage, LPARAM lpUserData);

// Fills a LPPROPSHEETPAGE structure with the information
// needed to display the protocol tab in the incoming connections wizard.
DWORD ProtWizGetPropertyPage(LPPROPSHEETPAGE lpPage, LPARAM lpUserData);

// Function fills in the given LPPROPSHEETPAGE structure with the information needed
// to run the dcc device tab in the incoming connections wizard.
DWORD DccdevWizGetPropertyPage (LPPROPSHEETPAGE lpPage, LPARAM lpUserData);

// Function fills in the given LPPROPSHEETPAGE structure with the information needed
// to run the dummy wizard page that switches to mmc.
DWORD SwitchMmcWizGetProptertyPage (LPPROPSHEETPAGE lpPage, LPARAM lpUserData);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\utils.c ===
/*
    File    utils.c

    Contains common utilities for the ras dialup server ui.

    Paul Mayfield, 9/30/97
*/

#include "rassrv.h"

// Remoteaccess parameters key
const WCHAR pszregRasParameters[] 
    = L"SYSTEM\\CurrentControlSet\\Services\\RemoteAccess\\Parameters";

// Registry key values
const WCHAR pszregServerFlags[]  = L"ServerFlags";
const WCHAR pszregShowIcon[]     = L"Rassrv_EnableIconsInTray";
const WCHAR pszregPure[]         = L"UsersConfiguredWithMMC";
const WCHAR pszregLogLevel[]        = L"LoggingFlags";

// Here is the instance of the global variables
RASSRVUI_GLOBALS Globals; 

DWORD 
gblInit(
    IN  HINSTANCE hInstDll,
    OUT RASSRVUI_GLOBALS * pGlobs) 
{
    // Clear out the memory
    ZeroMemory(pGlobs, sizeof(RASSRVUI_GLOBALS));

    // Record the module for use in future resource fuction calls.
    Globals.hInstDll = hInstDll;

    // Initialize the global variable lock
    InitializeCriticalSection(&(pGlobs->csLock));

    // Create the global heap
    pGlobs->hPrivateHeap = HeapCreate(0, 4096, 0);

    // Register the context ID atom for use in the Windows XxxProp calls
    // which are used to associate a context with a dialog window handle.
    Globals.atmRassrvPageData = 
        (LPCTSTR)GlobalAddAtom(TEXT("RASSRVUI_PAGE_DATA"));
    if (!Globals.atmRassrvPageData)
    {
        return GetLastError();
    }
    Globals.atmRassrvPageId = 
        (LPCTSTR)GlobalAddAtom(TEXT("RASSRVUI_PAGE_ID"));
    if (!Globals.atmRassrvPageId)
    {
        return GetLastError();
    }

    return NO_ERROR;
}

DWORD 
gblCleanup(
    IN RASSRVUI_GLOBALS * Globs) 
{
    if (Globs->hRasServer != NULL) 
    {
        MprAdminServerDisconnect(Globs->hRasServer); 
        Globs->hRasServer = NULL;
    }

    if (Globs->hPrivateHeap) 
    {
        HeapDestroy(Globs->hPrivateHeap);
    }

    GlobalDeleteAtom(LOWORD(Globals.atmRassrvPageData));
    GlobalDeleteAtom(LOWORD(Globals.atmRassrvPageId));

    DeleteCriticalSection(&(Globs->csLock));
            
    return NO_ERROR;
}

//
// Loads the machine flags         
//
DWORD 
gblLoadMachineFlags(
    IN RASSRVUI_GLOBALS * pGlobs)
{
    DWORD dwErr = NO_ERROR;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pInfo = NULL;
    BOOL bEnabled, bDefault;
    
    // If we're already initialized, there's nothing to
    // do
    //
    if (pGlobs->dwMachineFlags & RASSRVUI_MACHINE_F_Initialized)
    {
        return NO_ERROR;
    }

    do 
    {
        // Find out what kind of machine we are
        //
        dwErr = DsRoleGetPrimaryDomainInformation(
                            NULL,   
                            DsRolePrimaryDomainInfoBasic,
                            (LPBYTE *)&pInfo );

        if (dwErr != NO_ERROR) 
        {
            break;
        }

        if ((pInfo->MachineRole != DsRole_RoleStandaloneWorkstation) &&
            (pInfo->MachineRole != DsRole_RoleMemberWorkstation))
        {
            pGlobs->dwMachineFlags |= RASSRVUI_MACHINE_F_Server;
        }

        if ((pInfo->MachineRole != DsRole_RoleStandaloneWorkstation) &&
            (pInfo->MachineRole != DsRole_RoleStandaloneServer))
        {
            pGlobs->dwMachineFlags |= RASSRVUI_MACHINE_F_Member;
        }

        // Record that we've been initailized
        //
        pGlobs->dwMachineFlags |= RASSRVUI_MACHINE_F_Initialized;
        
    } while (FALSE);
    
    // Cleanup
    {
        if (pInfo)
        {
            DsRoleFreeMemory (pInfo);
        }
    }            

    return dwErr;
}

//
// Establishes communication with the ras server if
// not already established
//
DWORD 
gblConnectToRasServer() 
{
    DWORD dwErr = NO_ERROR;;

    EnterCriticalSection(&(Globals.csLock));

    if (Globals.hRasServer == NULL) 
    {
        dwErr = MprAdminServerConnect(NULL, &Globals.hRasServer);
    }

    LeaveCriticalSection(&(Globals.csLock));

    return NO_ERROR;
}

/* Enhanced list view callback to report drawing information.  'HwndLv' is
** the handle of the list view control.  'DwItem' is the index of the item
** being drawn.
**
** Returns the address of the draw information.
*/
LVXDRAWINFO*
LvDrawInfoCallback(
    IN HWND  hwndLv,
    IN DWORD dwItem )
{
    /* The enhanced list view is used only to get the "wide selection bar"
    ** feature so our option list is not very interesting.
    **
    ** Fields are 'nCols', 'dxIndent', 'dwFlags', 'adwFlags[]'.
    */
    static LVXDRAWINFO info = { 1, 0, 0, { 0 } };

    return &info;
}

//
// Allocates memory.  If bZero is TRUE, it also zeros the memory.  
//
PVOID 
RassrvAlloc (
    IN DWORD dwSize, 
    IN BOOL bZero) 
{
    PVOID pvRet = NULL;
    HANDLE hHeap = NULL;
    
    hHeap = 
        (Globals.hPrivateHeap) ? Globals.hPrivateHeap : GetProcessHeap();
        
    pvRet = HeapAlloc(
                hHeap, 
                (bZero) ? HEAP_ZERO_MEMORY: 0,
                dwSize);
    
    return pvRet;
}

//
// Frees memory allocated by RassrvAlloc
//
VOID 
RassrvFree (
    IN PVOID pvBuf) 
{
    PVOID pvRet;
    HANDLE hHeap;
    
    hHeap = 
        (Globals.hPrivateHeap) ? Globals.hPrivateHeap : GetProcessHeap();
    
    if (pvBuf)
    {
        HeapFree(hHeap, 0, pvBuf);
    }
}        

//
// Adds a user to the local machine
//
DWORD 
RasSrvAddUser (
    IN PWCHAR pszUserLogonName,
    IN PWCHAR pszUserComment,
    IN PWCHAR pszUserPassword) 
{
    NET_API_STATUS nStatus;
    WCHAR pszDomainUser[1024];
    WCHAR pszCompName[1024];
    LOCALGROUP_MEMBERS_INFO_3 meminfo;
    DWORD dwSize = 1024, dwErr;
    USER_INFO_2 * pUser2;
    RAS_USER_0 UserInfo;

    // Initialize the base user information
    USER_INFO_1 User = 
    {
        pszUserLogonName,
        pszUserPassword,
        0,
        USER_PRIV_USER,
        L"",
        L"",
        UF_SCRIPT | UF_DONT_EXPIRE_PASSWD | UF_NORMAL_ACCOUNT,
        L""
    };

    // Add the user
    nStatus = NetUserAdd(
                NULL,
                1,
                (LPBYTE)&User,
                NULL);

    // If the user wasn't added, find out why
    if (nStatus != NERR_Success) 
    {
        switch (nStatus) 
        {
            case ERROR_ACCESS_DENIED:
                return ERROR_ACCESS_DENIED;
                
            case NERR_UserExists:
                return ERROR_USER_EXISTS;
                
            case NERR_PasswordTooShort:
                return ERROR_INVALID_PASSWORDNAME;
                
            case NERR_InvalidComputer:   
            case NERR_NotPrimary:        
            case NERR_GroupExists:
            default:
                return ERROR_CAN_NOT_COMPLETE;
        }
    }

    // Now that the user is added, add the user's full name
    nStatus = NetUserGetInfo(NULL, pszUserLogonName, 2, (LPBYTE*)&pUser2);
    if (nStatus == NERR_Success) 
    {
        // Modify the full name in the structure
        pUser2->usri2_full_name = pszUserComment;
        NetUserSetInfo(NULL, pszUserLogonName, 2, (LPBYTE)pUser2, NULL);
        NetApiBufferFree((LPBYTE)pUser2);
    }

    return NO_ERROR;
}

//
// Deletes a user from the system local user datbase
//
DWORD 
RasSrvDeleteUser(
    PWCHAR pszUserLogonName) 
{
    NET_API_STATUS nStatus;
    
    // Delete the user and return the status code.  If the
    // specified user is not in the user database, consider
    // it a success
    nStatus = NetUserDel(NULL, pszUserLogonName);
    if (nStatus != NERR_Success) 
    {
        switch (nStatus) 
        {
            case ERROR_ACCESS_DENIED:
                return ERROR_ACCESS_DENIED;
                
            case NERR_UserNotFound:
                return NO_ERROR;
        }
        return nStatus;
    }

    return NO_ERROR;
}

//
// Changes the full name and password of a user.  If 
// either of pszFullName or pszPassword is null, it is
// ignored.
//
DWORD 
RasSrvEditUser (
    IN PWCHAR pszLogonName,
    IN OPTIONAL PWCHAR pszFullName,
    IN OPTIONAL PWCHAR pszPassword)
{
    NET_API_STATUS nStatus;
    DWORD dwSize = 1024, dwErr = NO_ERROR, dwParamErr;
    USER_INFO_2 * pUser2;

    // if nothing to set, return
    if (!pszFullName && !pszPassword)
    {
        return NO_ERROR;
    }

    // First, get this user's data so that we can manipulate it.
    //
    nStatus = NetUserGetInfo(
                NULL,
                pszLogonName,
                2,
                (LPBYTE*)(&pUser2));
    if (nStatus != NERR_Success)
    {
        return nStatus;
    }

    dwErr = NO_ERROR;
    do 
    {
        // Fill in the blanks accordingly
        if (pszFullName)
        {
            pUser2->usri2_full_name = pszFullName;
        }
            
        if (pszPassword)
        {
            pUser2->usri2_password = pszPassword;
        }

        // Add the user
        nStatus = NetUserSetInfo(
                        NULL,           // server name
                        pszLogonName,   // user name
                        2,              // level
                        (LPBYTE)pUser2, // buf
                        &dwParamErr);   // param error
        if (nStatus != NERR_Success)
        {
            dwErr = nStatus;
            break;
        }
        
    } while (FALSE);

    // Cleanup
    {
        NetApiBufferFree(pUser2);
    }

    return dwErr;
}

// Returns whether a dword registry value was set or not.  If the named 
// value does not exist, the value of bDefault is assigned.
DWORD 
RassrvRegGetDwEx(
    IN DWORD * lpdwFlag, 
    IN DWORD dwDefault, 
    IN CONST PWCHAR pszKeyName, 
    IN CONST PWCHAR pszValueName, 
    IN BOOL bCreate) 
{
    DWORD dwErr, dwVal, dwType = REG_DWORD, dwSize = sizeof(DWORD);
    HKEY hKey = NULL;

    if (!lpdwFlag)
    {
        return ERROR_INVALID_PARAMETER;
    }

    do
    {
        if (bCreate)
        {
            DWORD dwDisposition;
            
            dwErr = RegCreateKeyExW(
                        HKEY_LOCAL_MACHINE,
                        pszKeyName,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_READ,
                        NULL,
                        &hKey,
                        &dwDisposition);
            if (dwErr != ERROR_SUCCESS)
            {
                break;
            }
        }
        else
        {
            // Open the registry key
            dwErr = RegOpenKeyExW(
                        HKEY_LOCAL_MACHINE,
                        pszKeyName,
                        0,
                        KEY_READ,
                        &hKey);
            if (dwErr != ERROR_SUCCESS)
            {
                break;
            }
        }
        
        // Read the value
        dwErr = RegQueryValueExW(
                    hKey,
                    pszValueName,
                    0,
                    &dwType,
                    (BYTE *)&dwVal,
                    &dwSize);
        if (dwErr != ERROR_SUCCESS)
        {
            dwErr = NO_ERROR;
            dwVal = dwDefault;
        }

        // Return the value read
        *lpdwFlag = dwVal;
        
    } while (FALSE);
    
    // Cleanup
    {
        if (hKey) 
        {
            RegCloseKey(hKey);
        }
    }
    
    return dwErr;
}


// Returns whether a dword registry value was set or not.  If the named 
// value does not exist, the value of bDefault is assigned.
DWORD 
RassrvRegGetDw(
    IN DWORD * lpdwFlag, 
    IN DWORD dwDefault, 
    IN CONST PWCHAR pszKeyName, 
    IN CONST PWCHAR pszValueName) 
{
    return RassrvRegGetDwEx(
                lpdwFlag, 
                dwDefault, 
                pszKeyName, 
                pszValueName, 
                FALSE);
}

//
// Sets a dword registry value.  If the named value does not exist, 
// it is automatically created.
//
DWORD 
RassrvRegSetDwEx(
    IN DWORD dwFlag, 
    IN CONST PWCHAR pszKeyName, 
    IN CONST PWCHAR pszValueName, 
    IN BOOL bCreate) 
{
    DWORD dwErr = NO_ERROR, dwVal, dwType = REG_DWORD;
    DWORD dwSize = sizeof(DWORD);
    HKEY hKey = NULL;

    dwVal = dwFlag;

    do 
    {
        if (bCreate)
        {
            DWORD dwDisposition;
            
            dwErr = RegCreateKeyExW(
                        HKEY_LOCAL_MACHINE,
                        pszKeyName,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_WRITE,
                        NULL,
                        &hKey,
                        &dwDisposition);
            if (dwErr != ERROR_SUCCESS)
            {
                break;
            }
        }
        else
        {
            // Open the registry key
            dwErr = RegOpenKeyExW(
                        HKEY_LOCAL_MACHINE,
                        pszKeyName,
                        0,
                        KEY_WRITE,
                        &hKey);
            if (dwErr != ERROR_SUCCESS)
            {
                break;
            }
        }

        // Set the value
        dwErr = RegSetValueExW(
                    hKey,
                    pszValueName,
                    0,
                    dwType,
                    (CONST BYTE *)&dwVal,
                    dwSize);
        if (dwErr != ERROR_SUCCESS)
        {
            break;
        }
        
    } while (FALSE);

    // Cleanup
    {
        if (hKey) 
        {
            RegCloseKey(hKey);
        }
    }
    
    return dwErr;
}

DWORD 
RassrvRegSetDw(
    IN DWORD dwFlag, 
    IN CONST PWCHAR pszKeyName, 
    IN CONST PWCHAR pszValueName)
{
    return RassrvRegSetDwEx(dwFlag, pszKeyName, pszValueName, FALSE);
}

//
// Warns the user that we are about to switch to MMC returning TRUE if 
// user agrees to this and FALSE otherwise
//
BOOL 
RassrvWarnMMCSwitch(
    IN HWND hwndDlg) 
{
    PWCHAR pszWarning, pszTitle;

    pszWarning = 
        (PWCHAR) PszLoadString(Globals.hInstDll, WRN_SWITCHING_TO_MMC);
    pszTitle = 
        (PWCHAR) PszLoadString(Globals.hInstDll, WRN_TITLE);
    
    if (MessageBox(
            hwndDlg, 
            pszWarning, 
            pszTitle, 
            MB_YESNO | MB_ICONEXCLAMATION) == IDYES)
    {            
        return TRUE;
    }
    
    return FALSE;
}

//
// Switches to mmc based on the console identifier passed in
//
DWORD 
RassrvLaunchMMC (
    IN DWORD dwConsoleId) 
{
    STARTUPINFOA startupinfo;
    PROCESS_INFORMATION procinfo;
    CHAR * pszConsole;
    CHAR pszBuf[1024], pszDir[1024];

    // Set the command line accordingly
    switch (dwConsoleId) 
    {
        case RASSRVUI_NETWORKCONSOLE:
            pszConsole = "netmgmt.msc";
            break;

        case RASSRVUI_USERCONSOLE:
            pszConsole = NULL;
            break;

        case RASSRVUI_SERVICESCONSOLE:
            pszConsole = "compmgmt.msc";
            break;

        case RASSRVUI_MPRCONSOLE:
        default:
            pszConsole = "rrasmgmt.msc";
            break;
    }

    if (pszConsole) 
    {
        GetSystemDirectoryA (pszDir, sizeof(pszDir));
        sprintf (pszBuf, "mmc %s\\%s", pszDir, pszConsole);
    }
    else
        strcpy (pszBuf, "mmc.exe");
            
    // Launch MMC
    ZeroMemory(&startupinfo, sizeof(startupinfo));
    startupinfo.cb = sizeof(startupinfo);
    CreateProcessA(
        NULL,                   // name of executable module 
        pszBuf,                 // command line string
        NULL,                   // process security attributes 
        NULL,                   // thread security attributes 
        FALSE,                  // handle inheritance flag 
        NORMAL_PRIORITY_CLASS,  // creation flags 
        NULL,                   // new environment block 
        NULL,                   // current directory name 
        &startupinfo,           // STARTUPINFO 
        &procinfo);             // PROCESS_INFORMATION 

    return NO_ERROR;
}

//
// Retrieve a string from the registry
//
DWORD 
RassrvRegGetStr(
    OUT PWCHAR pszBuf, 
    IN  PWCHAR pszDefault, 
    IN  CONST PWCHAR pszKeyName, 
    IN  CONST PWCHAR pszValueName) 
{
    DWORD dwErr = NO_ERROR, dwVal, dwType = REG_SZ, dwSize = 512;
    HKEY hKey = NULL;

    do
    {
        // Open the registry key
        dwErr = RegOpenKeyExW(
                    HKEY_LOCAL_MACHINE,
                    pszKeyName,
                    0,
                    KEY_READ,
                    &hKey);
        if (dwErr != ERROR_SUCCESS)
        {
            break;
        }

        // Read the value
        dwErr = RegQueryValueExW(
                    hKey,
                    pszValueName,
                    0,
                    &dwType,
                    (BYTE *)pszBuf,
                    &dwSize);
        if (dwErr != ERROR_SUCCESS) 
        {
            dwErr = NO_ERROR;
            wcscpy(pszBuf, pszDefault);
        }
        
    } while (FALSE);
    
    // Cleanup
    {
        if (hKey) 
        {
            RegCloseKey(hKey);
        }
    }
    
    return NO_ERROR;
}

//
// Save a string to the registry
//
DWORD 
RassrvRegSetStr(
    IN PWCHAR pszStr, 
    IN CONST PWCHAR pszKeyName, 
    IN CONST PWCHAR pszValueName) 
{
    DWORD dwErr = NO_ERROR, dwVal, dwType = REG_SZ, dwSize;
    HKEY hKey = NULL;

    dwSize = wcslen(pszStr)*sizeof(WCHAR) + sizeof(WCHAR);

    do
    {
        // Open the registry key
        dwErr = RegOpenKeyExW(
                    HKEY_LOCAL_MACHINE,
                    pszKeyName,
                    0,
                    KEY_WRITE,
                    &hKey);
        if (dwErr != ERROR_SUCCESS)
        {
            break;
        }

        // Set the value
        dwErr = RegSetValueExW(
                    hKey,
                    pszValueName,
                    0,
                    dwType,
                    (CONST BYTE *)pszStr,
                    dwSize);

        if (dwErr != ERROR_SUCCESS)
        {
            break;
        }
            
    } while (FALSE);

    // Cleanup
    {
        if (hKey) 
        {
            RegCloseKey(hKey);
        }
    }
    
    return dwErr;
}

//
// Gets the machine flags
//
DWORD 
RasSrvGetMachineFlags(
    OUT LPDWORD lpdwFlags)
{
    GBL_LOCK;

    gblLoadMachineFlags(&Globals);
    *lpdwFlags = Globals.dwMachineFlags;

    GBL_UNLOCK;

    return NO_ERROR;
}

//
// Get multilink status
//
DWORD 
RasSrvGetMultilink(
    OUT BOOL * pbEnabled) 
{
    DWORD dwFlags = PPPCFG_NegotiateMultilink;

    if (!pbEnabled)
    {
        return ERROR_INVALID_PARAMETER;
    }
        
    // Read the flags
    RassrvRegGetDw(
        &dwFlags, 
        PPPCFG_NegotiateMultilink, 
        (const PWCHAR)pszregRasParameters, 
        (const PWCHAR)pszregServerFlags);

    // Assign the enable state accordingly
    if (dwFlags & PPPCFG_NegotiateMultilink)
    {
        *pbEnabled = TRUE;
    }
    else
    {
        *pbEnabled = FALSE;
    }

    return NO_ERROR;
}

//
// Private internal function that enables/disables multilink
//
DWORD 
RasSrvSetMultilink(
    IN BOOL bEnable) 
{
    DWORD dwFlags = PPPCFG_NegotiateMultilink;

    // Read the flags
    RassrvRegGetDw(
        &dwFlags, 
        PPPCFG_NegotiateMultilink, 
        (const PWCHAR)pszregRasParameters, 
        (const PWCHAR)pszregServerFlags);

    // Assign the enable state accordingly
    if (bEnable)
    {
        dwFlags |= PPPCFG_NegotiateMultilink;
    }
    else
    {
        dwFlags &= ~PPPCFG_NegotiateMultilink;
    }

    // Set the flags
    RassrvRegSetDw(
        dwFlags, 
        (CONST PWCHAR)pszregRasParameters, 
        (CONST PWCHAR)pszregServerFlags);

    return NO_ERROR;
}

//
// Initialize the show icon setting
//
DWORD 
RasSrvGetIconShow(
    OUT BOOL * pbEnabled)
{
    DWORD dwErr = NO_ERROR, dwFlags = 0;
    BOOL bDefault = TRUE;

    // Get machine flags
    //
    dwErr = RasSrvGetMachineFlags(&dwFlags);
    if (dwErr != NO_ERROR)
    {
        *pbEnabled = FALSE;
        return dwErr;
    }

    // Always off for member server
    //
    if ((dwFlags & RASSRVUI_MACHINE_F_Server) &&
        (dwFlags & RASSRVUI_MACHINE_F_Member))
    {
        *pbEnabled = FALSE;
        return NO_ERROR;
    }

    // Set default
    //
    if (dwFlags & RASSRVUI_MACHINE_F_Server)
    {
        bDefault = FALSE;
    }
    else
    {
        bDefault = TRUE;
    }

    // Load the machine flags and return accordingly
    //
    *pbEnabled = bDefault;
    dwErr = RassrvRegGetDw(
                pbEnabled, 
                bDefault, 
                (CONST PWCHAR)pszregRasParameters,
                (CONST PWCHAR)pszregShowIcon);

    return dwErr;
}

//
// Save the show icon setting
//
DWORD 
RasSrvSetIconShow(
    IN BOOL bEnable) 
{
    return RassrvRegSetDw(
                bEnable, 
                (CONST PWCHAR)pszregRasParameters,
                (CONST PWCHAR)pszregShowIcon);
}

// 
// Save the log level
//
DWORD
RasSrvSetLogLevel(
    IN DWORD dwLevel)
{
    return RassrvRegSetDw(
                dwLevel, 
                (CONST PWCHAR)pszregRasParameters,
                (CONST PWCHAR)pszregLogLevel);
}

// Calls WinHelp to popup context sensitive help.  'pdwMap' is an array
// of control-ID help-ID pairs terminated with a 0,0 pair.  'UnMsg' is
// WM_HELP or WM_CONTEXTMENU indicating the message received requesting
// help.  'Wparam' and 'lparam' are the parameters of the message received
// requesting help.
DWORD 
RasSrvHelp (
    IN HWND hwndDlg,          
    IN UINT unMsg,             
    IN WPARAM wparam,         
    IN LPARAM lparam,         
    IN const DWORD* pdwMap)   
{
    HWND hwnd;
    UINT unType;
    TCHAR pszHelpFile[] = TEXT("Netcfg.hlp");

    // Validate parameters
    if (! (unMsg==WM_HELP || unMsg==WM_CONTEXTMENU))
    {
        return ERROR_INVALID_PARAMETER;
    }

    // If no map is provided, no help will show
    if (!pdwMap)
    {
        return NO_ERROR;
    }
        
    // If an actual help topic is request...
    if (unMsg == WM_HELP) 
    {
        LPHELPINFO p = (LPHELPINFO )lparam;

        TRACE4( "ContextHelp(WM_HELP,t=%d,id=%d,h=$%08x,s=$%08x)",
            p->iContextType, p->iCtrlId,p->hItemHandle ,hwndDlg );

        if (p->iContextType != HELPINFO_WINDOW)
        {
            return NO_ERROR;
        }

        hwnd = p->hItemHandle;
        unType = HELP_WM_HELP;
    }
    
    // Standard Win95 method that produces a one-item "What's This?" 
    // menu that user must click to get help.
    else  
    {
        TRACE1( "ContextHelp(WM_CONTEXTMENU,h=$%08x)", wparam );
        
        hwnd = (HWND )wparam;
        unType = HELP_CONTEXTMENU;
    }

    WinHelp( hwnd, pszHelpFile, unType, (ULONG_PTR)pdwMap );

    return NO_ERROR;
}

BOOL CALLBACK
WSDlgProc(
    HWND   hwnd,
    UINT   unMsg,
    WPARAM wParam,
    LPARAM lParam )

    /* Standard Win32 dialog procedure.
    */
{
    if (unMsg == WM_INITDIALOG)
    {
        HMENU hmenu;
        RECT r1, r2;

        /* Remove Close from the system menu since some people think it kills
        ** the app and not just the popup.
        */
        hmenu = GetSystemMenu( hwnd, FALSE );
        if (hmenu && DeleteMenu( hmenu, SC_CLOSE, MF_BYCOMMAND ))
        {
            DrawMenuBar( hwnd );
        }

        // Center the window
        GetWindowRect(hwnd, &r1);
        GetWindowRect(GetDesktopWindow(), &r2);
        MoveWindow(
            hwnd, 
            (r2.right - r2.left)/2 - (r1.right - r1.left)/2,
            (r2.bottom - r2.top)/2 - (r1.bottom - r1.top)/2,   
            r1.right - r1.left,
            r1.bottom - r1.top,
            TRUE);
            
        return TRUE;
    }

    return FALSE;
}

//
// Bring up the start waiting for services dialog
//
DWORD 
RasSrvShowServiceWait( 
    IN HINSTANCE hInst, 
    IN HWND hwndParent, 
    OUT HANDLE * phData)
{                             
    // Set the hourglass cursor
    *phData = (HANDLE) SetCursor (LoadCursor (NULL, IDC_WAIT));
    ShowCursor (TRUE);
    
    return NO_ERROR;
}

//
// Bring down wait for services dialog                            
//
DWORD 
RasSrvFinishServiceWait (
    IN HANDLE hData) 
{
    HICON hIcon = (HICON)hData;
    
    if (hIcon == NULL)
    {
        hIcon = LoadCursor (NULL, IDC_ARROW);
    }
    
    SetCursor (hIcon);
    ShowCursor (TRUE);
    
    return NO_ERROR;
}

//-----------------------------------------------------------------------
// Function:    EnableBackupPrivilege
//
// Enables/disables backup privilege for the current process.
//-----------------------------------------------------------------------

DWORD
EnableRebootPrivilege(
    IN BOOL bEnable)
{
    LUID luid;
    HANDLE hToken = NULL;
    TOKEN_PRIVILEGES tp;
    BOOL bOk;

    // We first have to try to get the token of the current
    // thread since if it is impersonating, adjusting the
    // privileges of the process will have no affect.
    bOk = OpenThreadToken(
            GetCurrentThread(),
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
            TRUE,
            &hToken);
    if (bOk == FALSE)
    {
        // There is no thread token -- open it up for the
        // process instead.
        OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
            &hToken
            );
    }

    // Get the LUID of the privilege
    if (!LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &luid)) 
    {

        DWORD dwErr = GetLastError();
        if(NULL != hToken)
        {
            CloseHandle(hToken);
        }
        return dwErr;
    }

    // Adjust the token privileges
    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    // Commit changes to the system
    if (!AdjustTokenPrivileges(
            hToken, !bEnable, &tp, sizeof(TOKEN_PRIVILEGES), NULL, NULL
            ))
    {
        DWORD dwErr = GetLastError();
        if(NULL != hToken)
        {
            CloseHandle(hToken);
        }
        return dwErr;
    }

    // Even if AdjustTokenPrivileges succeeded (see MSDN) you still
    // need to verify success by calling GetLastError.
    if (GetLastError() == ERROR_NOT_ALL_ASSIGNED)
    {
        if(NULL != hToken)
        {
            CloseHandle(hToken);
        }
        return ERROR_NOT_ALL_ASSIGNED;
    }

    if(NULL != hToken)
    {
        CloseHandle(hToken);
    }
    
    return NO_ERROR;
}

// Pops up a warning with the given parent window and reboots
// windows
DWORD RasSrvReboot(HWND hwndParent) 
{
    DWORD dwOldState;
    INT iRet;
    PWCHAR pszWarn, pszTitle;

    // Load the strings
    pszWarn = 
        (PWCHAR) PszLoadString(Globals.hInstDll, WRN_REBOOT_REQUIRED);
    pszTitle = 
        (PWCHAR) PszLoadString(Globals.hInstDll, WRN_TITLE);

    // Display the warning
    iRet = MessageBoxW(
                hwndParent, 
                pszWarn, 
                pszTitle, 
                MB_YESNO | MB_APPLMODAL);
    if (iRet != IDYES)
    {
        return ERROR_CANCELLED;
    }
        
    // Enable the reboot privelege    
    EnableRebootPrivilege(TRUE);

    ExitWindowsEx(EWX_REBOOT, 0);

    // Restore the reboot privelege    
    EnableRebootPrivilege(FALSE);
    
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\utils.h ===
/*
    File    utils.h

    Defines utility declarations that facilitate the implementation of the 
    connections ras dialup server ui.

    Paul Mayfield, 9/29/97
*/

#ifndef _rassrvui_utils_h
#define _rassrvui_utils_h

#include "rassrv.h"

//
// Global flags that tag the current state of this 
// machine
//
#define RASSRVUI_MACHINE_F_Initialized  0x1
#define RASSRVUI_MACHINE_F_Server       0x2
#define RASSRVUI_MACHINE_F_Member       0x4
#define RASSRVUI_MACHINE_F_ShowIcon     0x8

//
// Defines the global variables data structure
//
typedef struct _RASSRVUI_GLOBALS 
{
    // 
    // The following should only be accessed when the
    // csLock is held.
    //
    MPR_SERVER_HANDLE hRasServer;   
    DWORD dwMachineFlags;           
    
    //
    // The following do not need to be protected by the
    // csLock as they are initialized at process attach
    // and thereafter are only read.
    //
    HINSTANCE hInstDll;             
    HANDLE hPrivateHeap;            
    LPCTSTR atmRassrvPageData;      
    LPCTSTR atmRassrvPageId;        
    DWORD dwErrorData;              
                                    
    //
    // Locks (some) global variables
    //
    CRITICAL_SECTION csLock;        

} RASSRVUI_GLOBALS;

extern RASSRVUI_GLOBALS Globals;

// ======================================
// Methods to operate on global variables
// ======================================

#define GBL_LOCK EnterCriticalSection(&(Globals.csLock))
#define GBL_UNLOCK LeaveCriticalSection(&(Globals.csLock))

//
// Initializes the global variables
//
DWORD 
gblInit(
    IN  HINSTANCE hInstDll,
    OUT RASSRVUI_GLOBALS * Globs);

//
// Loads the machine flags         
//
DWORD 
gblLoadMachineFlags(
    IN RASSRVUI_GLOBALS * Globs);

//
// Frees resources held by global variables
//
DWORD 
gblCleanup(
    IN RASSRVUI_GLOBALS * Globs);

//
// Establishes communication with the ras server if
// not already established
//
DWORD 
gblConnectToRasServer();    

/* Enhanced list view callback to report drawing information.  'HwndLv' is
** the handle of the list view control.  'DwItem' is the index of the item
** being drawn.
**
** Returns the address of standard draw information.
*/
LVXDRAWINFO*
LvDrawInfoCallback(
    IN HWND  hwndLv,
    IN DWORD dwItem );

// ============================================================
// ============================================================
// Special purpose ras server functions.
// ============================================================
// ============================================================

//
// Allocates and Zeros memory.  Returns pointer to allocated memory
// or NULL if ERROR_NOT_ENOUGH_MEMORY
//
PVOID 
RassrvAlloc (
    IN DWORD dwSize, 
    IN BOOL bZero);
    
VOID 
RassrvFree(
    IN PVOID pvBuf);

//
// Adds a new user to the system local user database.
//
DWORD 
RasSrvAddUser (
    IN PWCHAR pszUserLogonName,
    IN PWCHAR pszUserComment,
    IN PWCHAR pszUserPassword);

//
// Deletes a user from the system local user datbase
//
DWORD 
RasSrvDeleteUser(
    IN PWCHAR pszUserLogonName);

//
// Changes the full name and password of a user.  If 
// either of pszFullName or pszPassword is null, it is
// ignored.
//
DWORD 
RasSrvEditUser (
    IN PWCHAR pszLogonName,
    IN OPTIONAL PWCHAR pszFullName,
    IN OPTIONAL PWCHAR pszPassword);

//
// Warns the user that he/she is about to swith to mmc
//
BOOL 
RassrvWarnMMCSwitch(
    IN HWND hwndDlg);

//
// Launches the given console in MMC
//
DWORD 
RassrvLaunchMMC(
    IN DWORD dwConsoleId);

//
// Returns RASSRVUI_MACHINE_F_* values for the current machine
//
DWORD 
RasSrvGetMachineFlags(
    OUT LPDWORD lpdwFlags);

//
// Manipulate the enabling/disabling of multilink
//
DWORD 
RasSrvGetMultilink(
    OUT BOOL * bEnabled);
    
DWORD 
RasSrvSetMultilink(
    IN BOOL bEnable);

//
// Manipulate the showing of ras server icons in the task bar
//
DWORD 
RasSrvGetIconShow(
    OUT BOOL * pbEnabled);
    
DWORD 
RasSrvSetIconShow(
    IN BOOL bEnable);

// 
// Set the logging level
//
DWORD
RasSrvSetLogLevel(
    IN DWORD dwLevel);

//
// Manipulate the forcing of data and password encryption'
//
DWORD 
RasSrvGetEncryption(
    OUT BOOL * pbEncrypted);
    
DWORD 
RasSrvSetEncryption(
    IN BOOL bEncrypted);

// Displays context sensitive help
DWORD 
RasSrvHelp(
    IN HWND hwndDlg,          // Dialog needing help
    IN UINT uMsg,             // Help message
    IN WPARAM wParam,         // parameter
    IN LPARAM lParam,         // parameter
    IN const DWORD* pdwMap);  // map control id to help id

//
// Registry helper functions. All string buffers must be 
// at least 256 chars long.
//
DWORD 
RassrvRegGetDw(
    DWORD * pdwVal, 
    DWORD dwDefault, 
    const PWCHAR pszKeyName, 
    const PWCHAR pszValueName);
    
DWORD 
RassrvRegSetDw(
    DWORD dwVal, 
    const PWCHAR pszKeyName, 
    const PWCHAR pszValueName);

DWORD 
RassrvRegGetDwEx(
    DWORD * pdwVal, 
    DWORD dwDefault, 
    const PWCHAR pszKeyName, 
    const PWCHAR pszValueName,
    IN BOOL bCreate);
    
DWORD 
RassrvRegSetDwEx(
    IN DWORD dwFlag, 
    IN CONST PWCHAR pszKeyName, 
    IN CONST PWCHAR pszValueName, 
    IN BOOL bCreate);
    
DWORD 
RassrvRegGetStr(
    PWCHAR pszBuf, 
    PWCHAR pszDefault, 
    const PWCHAR pszKeyName, 
    const PWCHAR pszValueName);
    
DWORD 
RassrvRegSetStr(
    PWCHAR pszStr, 
    const PWCHAR pszKeyName, 
    const PWCHAR pszValueName);

// Api shows whatever ui is neccessary to inform the user that 
// he/she should wait while services are started.
DWORD 
RasSrvShowServiceWait( 
    IN HINSTANCE hInst, 
    IN HWND hwndParent, 
    OUT HANDLE * phData);
                             
DWORD 
RasSrvFinishServiceWait (
    IN HANDLE hData);

// Pops up a warning with the given parent window and reboots
// windows
DWORD 
RasSrvReboot(
    IN HWND hwndParent);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\routemon\comstrs.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by comstrs.rc
//
#define TOKEN_IPX                       1
#define TOKEN_IP                        2
#define TOKEN_HELP1                     3
#define TOKEN_HELP2                     4
#define TOKEN_HELP3                     5
#define TOKEN_ROUTER                    6
#define TOKEN_INTERFACECMD              7
#define TOKEN_CREATE                    8
#define TOKEN_DELETE                    9
#define TOKEN_SHOW                      10
#define TOKEN_INTERFACE                 11
#define TOKEN_SCRIPT                    13
#define TOKEN_UPDATE                    14
#define TOKEN_CONNECT                   15
#define TOKEN_DISCONNECT                16
#define TOKEN_SET                       17
#define TOKEN_PERSISTENT                18
#define TOKEN_ENABLE                    18
#define TOKEN_DISABLE                   19
#define TOKEN_LOAD                      20
#define TOKEN_SAVE                      21
#define TOKEN_REGISTER                  22
#define TOKEN_USER				        23
#define TOKEN_UPGRADE                   24
#define TOKEN_NONE                      25
#define TOKEN_CALLER                    26
#define TOKEN_ADMIN                     27
#define TOKEN_TUNNEL1                   201
#define VAL_IFTYPE_CLIENT               401
#define VAL_IFTYPE_HOME_ROUTER          402
#define VAL_IFTYPE_FULL_ROUTER          403
#define VAL_IFTYPE_DEDICATED            404
#define VAL_IFTYPE_INTERNAL             405
#define VAL_IFSTATE_CONNECTED           406
#define VAL_IFSTATE_DISCONNECTED        407
#define VAL_YES                         408
#define VAL_NO                          409
#define VAL_NA                          410
#define VAL_ENABLED                     411
#define VAL_DISABLED                    412
#define VAL_IFSTATE_CONNECTING          413
#define VAL_IFTYPE_LOOPBACK             414
#define VAL_IFTYPE_TUNNEL1              415
#define VAL_LOCAL                       416
#define VAL_DOMAIN                      417

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\routemon\guidmap.c ===
/*
	File	GuidMap.c

	Defines function to map a guid interface name to an unique descriptive 
	name describing that interface and vice versa.

	Paul Mayfield, 8/25/97

	Copyright 1997, Microsoft Corporation.
*/

#include "precomp.h"

static HANDLE hConfig = NULL;

// 
// Set the server that the name mapper will utilize
//
DWORD IfNameMapSetServer(HANDLE hMprConfig) {
    hConfig = hMprConfig;
    return NO_ERROR;
}

//
//  Map the guid name to the friendly name 
//
DWORD IfName2DescriptionW(IN PWCHAR pszName, OUT PWCHAR pszBuffer, IN LPDWORD lpdwBufSize) {
    if (hConfig == NULL || lpdwBufSize == NULL)
        return ERROR_CAN_NOT_COMPLETE;

    return MprConfigGetFriendlyName (hConfig, pszName, pszBuffer, *lpdwBufSize);
}

//
//  Map the friendly name to the guid name 
//
DWORD Description2IfNameW(IN PWCHAR pszName, OUT PWCHAR pszBuffer, IN LPDWORD lpdwBufSize) {
    if (hConfig == NULL || lpdwBufSize == NULL)
        return ERROR_CAN_NOT_COMPLETE;

    return MprConfigGetGuidName (hConfig, pszName, pszBuffer, *lpdwBufSize);
}

// ==================================================================
// ANSI versions of the above functions
// ==================================================================

#define mbtowc(mb,wc) MultiByteToWideChar (CP_ACP, 0, (mb), strlen ((mb)) + 1, (wc), 1024)
#define wctomb(wc,mb) WideCharToMultiByte (CP_ACP, 0, (wc), wcslen ((wc)) + 1, (mb), 1024, NULL, NULL)

DWORD IfName2DescriptionA(LPSTR pszName, LPSTR pszBuffer, LPDWORD lpdwBufSize) {
	WCHAR pszNameW[1024];
	WCHAR pszBufferW[1024];
	DWORD dwErr;
	int ret;

    // Translate params to wide char 
	ret = mbtowc(pszName, pszNameW);
	if (!ret)
		return GetLastError();

    // Call wide char version of function and copy back to multi byte
	dwErr = IfName2DescriptionW (pszNameW, pszBufferW, lpdwBufSize);
	if (dwErr == NO_ERROR) {
		ret = wctomb(pszBufferW, pszBuffer);
		if (ret == 0)
			return GetLastError();
	}
	
	return dwErr;
} 

DWORD Description2IfNameA(LPSTR pszDesc, LPSTR pszBuffer, LPDWORD lpdwBufSize) {
	WCHAR pszNameW[1024];
	WCHAR pszBufferW[1024];
	DWORD dwErr;
	int ret;

    // Translate params to wide char 
	ret = mbtowc(pszDesc, pszNameW);
	if (ret == 0)
		return GetLastError();

    // Call wide char version of function and copy back to multi byte
	dwErr = Description2IfNameW(pszNameW, pszBufferW, lpdwBufSize);
	if (dwErr == NO_ERROR) {
		ret = wctomb(pszBufferW, pszBuffer);
		if (!ret)
			return GetLastError();
	}
	
	return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\test\temp.c ===
/*
	File	Temp.c

	Does temporary stuff.
*/

#include "..\\error.h"
#include <stdio.h>
#include <windows.h>
#include <commctrl.h>
#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmerr.h>
#include <winsvc.h>
#include <rasuip.h>

#define MPR50 1

#include <mprapi.h>
#include <rtinfo.h>
#include <ipxrtdef.h>
#include <routprot.h>

// Error reporting
void PrintErr(DWORD err);

// [pmay] This will be removed when the router is modified to use MprInfo api's
typedef RTR_INFO_BLOCK_HEADER IPX_INFO_BLOCK_HEADER, *PIPX_INFO_BLOCK_HEADER;
typedef RTR_TOC_ENTRY IPX_TOC_ENTRY, *PIPX_TOC_ENTRY;

// Prototypes of functions that may be temporarily used for test.exe
void FixFwd();
DWORD DispPorts();
DWORD EnumGroups ();
DWORD Service();
void Crash();

// Return true if you want this function to implement test.exe
BOOL TempFunc(int argc, char ** argv) {
    //Service();
    //return TRUE;
    return FALSE;
}

// Display ports
DWORD DispPorts() {
    DWORD dwErr;
	HANDLE	hRouterAdmin;

    if ((dwErr = MprAdminServerConnect(NULL, &hRouterAdmin)) != NO_ERROR)
        return dwErr;

}

PIPX_TOC_ENTRY
GetIPXTocEntry (
	IN PIPX_INFO_BLOCK_HEADER	pInterfaceInfo,
	IN ULONG					InfoEntryType
	) {
    UINT			i;
	PIPX_TOC_ENTRY	pTocEntry;

    for (i=0, pTocEntry = pInterfaceInfo->TocEntry;
				i<pInterfaceInfo->TocEntriesCount;
					i++, pTocEntry++) {
		if (pTocEntry->InfoType == InfoEntryType) {
			return pTocEntry;
		}
	}

	SetLastError (ERROR_FILE_NOT_FOUND);
	return NULL;
}

DWORD GetNbIpxClientIf (LPTSTR		InterfaceName,
	                    UINT		msg)
{
	DWORD	rc, sz;
	LPBYTE	pClBlock;
	HANDLE	hTrCfg, hRouterAdmin;

    if ((rc = MprAdminServerConnect(NULL, &hRouterAdmin)) != NO_ERROR)
        return rc;

	hTrCfg = NULL;
	rc = MprAdminTransportGetInfo (
			hRouterAdmin,
			PID_IPX,
            NULL, NULL,
			&pClBlock,
            &sz);

    if (rc==NO_ERROR) {
		PIPX_TOC_ENTRY pIpxToc, pSapToc, pRipToc;

        // Netbios
		pIpxToc = GetIPXTocEntry ((PIPX_INFO_BLOCK_HEADER)pClBlock,
					              IPX_INTERFACE_INFO_TYPE);
		if (pIpxToc!=NULL) {
			PIPX_IF_INFO	pIpxInfo;
			pIpxInfo = (PIPX_IF_INFO)(pClBlock+pIpxToc->Offset);
            printf("\nDial-in\n");
            printf("Accept  = %d\n", pIpxInfo->NetbiosAccept);
            printf("Deliver = %d\n\n", pIpxInfo->NetbiosDeliver);
            pIpxInfo->NetbiosDeliver = 1;
		}

        // rip
		pRipToc = GetIPXTocEntry ((PIPX_INFO_BLOCK_HEADER)pClBlock,IPX_PROTOCOL_RIP);
		if (pIpxToc!=NULL) {
			PRIP_IF_CONFIG	pRipCfg;
            pRipCfg = (PRIP_IF_CONFIG)(pClBlock+pRipToc->Offset);
            printf("\nDial-in\n");
            printf("Rip   = %d\n", pRipCfg->RipIfInfo.UpdateMode);
            pRipCfg->RipIfInfo.UpdateMode = 2;
		}

        // sap
		pSapToc = GetIPXTocEntry ((PIPX_INFO_BLOCK_HEADER)pClBlock,IPX_PROTOCOL_SAP);
		if (pIpxToc!=NULL) {
			PSAP_IF_CONFIG	pSapCfg;
			pSapCfg = (PSAP_IF_CONFIG)(pClBlock+pSapToc->Offset);
            printf("\nDial-in\n");
            printf("Sap Mode = %d\n\n\n", pSapCfg->SapIfInfo.UpdateMode);
            pSapCfg->SapIfInfo.UpdateMode = 2;
		}

        MprAdminTransportSetInfo(
            hRouterAdmin,
            PID_IPX,
            (LPBYTE)NULL, 
            0, 
            pClBlock, 
            sz);
        
        MprAdminBufferFree (pClBlock);
	}

	return rc;
}

void FixFwd() {
    GetNbIpxClientIf(NULL, 0);
    GetNbIpxClientIf(NULL, 0);
}

// Enumerates the local groups on the local machine
DWORD EnumGroups () {
    NET_API_STATUS nStatus;
    GROUP_INFO_0 * buf;
    DWORD i, dwMax = 2000000, dwTot, dwRead=0;

    nStatus =  NetLocalGroupEnum(NULL,
                            0,
                            (LPBYTE*)&buf,
                            dwMax,
                            &dwRead,
                            &dwTot,
                            NULL);

    if (nStatus != NERR_Success) {
        switch (nStatus) {
            case ERROR_ACCESS_DENIED:
                return ERROR_ACCESS_DENIED;
            case NERR_UserExists:
                return ERROR_USER_EXISTS;
            case NERR_PasswordTooShort:
                return ERROR_INVALID_PASSWORDNAME;
            case NERR_InvalidComputer:          // These should never happen because
            case NERR_NotPrimary:               // we deal with local user database
            case NERR_GroupExists:
            default:
                return ERROR_CAN_NOT_COMPLETE;
        }
    }

    for (i=0; i<dwRead; i++) 
        wprintf(L"Group Name: %s\n", buf[i].grpi0_name);

    return NO_ERROR;
}


// Runs tests on starting/stopping services, etc.
DWORD Service() {
    SC_HANDLE hServiceController = NULL, hService = NULL;
    WCHAR pszRemoteAccess[] = L"remoteaccess";
    SERVICE_STATUS ServiceStatus;
    BOOL bOk;
   
    __try {
        // Open the service manager
        hServiceController = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, GENERIC_EXECUTE);
        if (! hServiceController) {
            PrintErr(GetLastError());
            return 0;
        }

        // Open the service
        hService = OpenServiceW(hServiceController, 
                               pszRemoteAccess, 
                               SERVICE_START | SERVICE_STOP | SERVICE_QUERY_STATUS);
        if (! hService) {
            PrintErr(GetLastError());
            return 0;
        }

        // Get the service status
        bOk = QueryServiceStatus (hService, 
                                  &ServiceStatus);
        if (! bOk) {
            PrintErr(GetLastError());
            return 0;
        }

        // Find out if the service is running
        if (ServiceStatus.dwCurrentState == SERVICE_STOPPED) {
            printf("\nRemote access service is stopped, attempting to start it...");
            bOk = StartService(hService, 0, NULL);
            if (! bOk) {
                PrintErr(GetLastError());
                return 0;
            }
            // Wait for the service to stop
            while (ServiceStatus.dwCurrentState != SERVICE_RUNNING) {
                Sleep(1000);
                bOk = QueryServiceStatus (hService, 
                                          &ServiceStatus);
                if (! bOk) {
                    PrintErr(GetLastError());
                    return 0;
                }
                printf(".");
            }
            printf("\nService Started.\n\n");
        }
        else if (ServiceStatus.dwCurrentState == SERVICE_RUNNING) {
            printf("\nRemote access service is started, attempting to stop it...");
            bOk = ControlService(hService, SERVICE_CONTROL_STOP, &ServiceStatus);
            if (! bOk) {
                PrintErr(GetLastError());
                return 0;
            }

            // Wait for the service to stop
            while (ServiceStatus.dwCurrentState != SERVICE_STOPPED) {
                Sleep(1000);
                bOk = QueryServiceStatus (hService, 
                                          &ServiceStatus);
                if (! bOk) {
                    PrintErr(GetLastError());
                    return 0;
                }
                printf(".");
            }
            printf("\nService Stopped.\n\n");
        }
    }
    __finally {
        if (hServiceController)
            CloseServiceHandle(hServiceController);
        if (hService)
            CloseServiceHandle(hService);
    }

    return 0;
}

/*
char x [5] = { 0xf0, 0x0f, 0xc7, 0xc8 };

void Crash() {
{
    void (*f)() = x;
    f();
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\wizard.c ===
/*
    File    wizard.c

    Implementation of the incoming connections wizard.

    Paul Mayfield, 10/30/97
*/

#include "rassrv.h"
#include <tapi.h>

// Help maps
static const DWORD phmWizardDccdev[] =
{
    CID_Wizard_Dccdev_LB_Devices,   IDH_Wizard_Dccdev_LB_Devices,
    0,                              0
};

static const DWORD phmWizardVpn[] =
{
    0,                              0
};

#define RASSRV_WIZTITLE_SIZE    256
#define RASSRV_WIZSUBTITLE_SIZE 256

// This structure let's us remember information needed
// to keep our device data page in sync
typedef struct _DCCDEV_DATA 
{
    HANDLE hDevice;
    BOOL bEnabled;
} DCCDEV_DATA;

//
// This dialog proc implements the vpn tab on the incoming connections
// wizard.
//
INT_PTR 
CALLBACK 
VpnWizDialogProc(
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);

//
// Dialog procedure that handles the host dcc wizard device page
//
INT_PTR 
CALLBACK 
DccdevWizDialogProc(
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);

//
// This dialog procedure responds to messages sent to the 
// switch to mmc wizard tab.
//
INT_PTR 
CALLBACK 
SwitchMmcWizDialogProc (
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);
                                      
//
// Fills in the property sheet structure with the information required to 
// display the device tab in the incoming connections wizard.
//
DWORD 
DeviceWizGetPropertyPage(
    IN LPPROPSHEETPAGE ppage, 
    IN LPARAM lpUserData) 
{
    LPCTSTR pszHeader, pszSubHeader;

    // Initialize
    ZeroMemory(ppage, sizeof(PROPSHEETPAGE));

    // Load the string resources
    pszHeader = PszLoadString(
                    Globals.hInstDll, 
                    SID_WIZDEVICETITLE);
    pszSubHeader = PszLoadString(
                        Globals.hInstDll, 
                        SID_WIZDEVICESUBTITLE);

    // The General Properties dialog procedure also implements the device 
    // tab in the incoming connections wizard
    ppage->pfnDlgProc  = GenTabDialogProc;       

    // Fill in the values
    ppage->dwSize      = sizeof(PROPSHEETPAGE);
    ppage->hInstance   = Globals.hInstDll;
    ppage->pszTemplate = MAKEINTRESOURCE(PID_Wizard_GenTab);
    ppage->pfnCallback = RasSrvInitDestroyPropSheetCb;
    ppage->pszHeaderTitle = (PWCHAR)pszHeader;
    ppage->pszHeaderSubTitle = (PWCHAR)pszSubHeader;
    ppage->lParam      = lpUserData;
    ppage->dwFlags     = PSP_USEHEADERSUBTITLE | 
                         PSP_USEHEADERTITLE    | 
                         PSP_USECALLBACK;

    return NO_ERROR;
}

//
// Fills in the property sheet structure with the information required 
// to display the vpn tab in the incoming connections wizard.
//
DWORD 
VpnWizGetPropertyPage(
    IN LPPROPSHEETPAGE ppage, 
    IN LPARAM lpUserData) 
{
    LPCTSTR pszHeader, pszSubHeader;

    // Initialize
    ZeroMemory(ppage, sizeof(PROPSHEETPAGE));

    // Load the string resources
    pszHeader = PszLoadString(
                    Globals.hInstDll, 
                    SID_WIZVPNTITLE);
    pszSubHeader = PszLoadString(
                        Globals.hInstDll, 
                        SID_WIZVPNSUBTITLE);

    // I could have used the general tab dialog procedure to implement the
    // vpn tab.  The only problem is that the general tab has a single 
    // check to enable vpn while the vpn tab in the wizard has a yes/no 
    // radio check group.  For this reason, I made the vpn tab its very 
    // own dialog proc.
    ppage->pfnDlgProc  = VpnWizDialogProc;
    
    // Fill in the values
    ppage->dwSize      = sizeof(PROPSHEETPAGE);
    ppage->hInstance   = Globals.hInstDll;
    ppage->pszTemplate = MAKEINTRESOURCE(PID_Wizard_Vpn);
    ppage->pfnCallback = RasSrvInitDestroyPropSheetCb;
    ppage->pszHeaderTitle = (PWCHAR)pszHeader;
    ppage->pszHeaderSubTitle = (PWCHAR)pszSubHeader;
    ppage->lParam      = lpUserData;
    ppage->dwFlags     = PSP_USEHEADERSUBTITLE | 
                         PSP_USEHEADERTITLE    | 
                         PSP_USECALLBACK;

    return NO_ERROR;
}

// 
// Function fills in the given lpPage structure with the information needed
// to run the user tab in the incoming connections wizard.
//
DWORD 
UserWizGetPropertyPage(
    IN LPPROPSHEETPAGE ppage, 
    IN LPARAM lpUserData) 
{
    LPCTSTR pszHeader, pszSubHeader;

    // Initialize
    ZeroMemory(ppage, sizeof(PROPSHEETPAGE));

    // Load the string resources
    pszHeader = PszLoadString(Globals.hInstDll, SID_WIZUSERTITLE);
    pszSubHeader = PszLoadString(Globals.hInstDll, SID_WIZUSERSUBTITLE);

    // The User Properties dialog procedure also implements the user tab
    // in the incoming connections wizard
    ppage->pfnDlgProc  = UserTabDialogProc;

    // Fill in the values
    ppage->dwSize      = sizeof(PROPSHEETPAGE);
    ppage->hInstance   = Globals.hInstDll;
    ppage->pszTemplate = MAKEINTRESOURCE(PID_Wizard_UserTab);
    ppage->pfnCallback = RasSrvInitDestroyPropSheetCb;
    ppage->pszHeaderTitle = (PWCHAR)pszHeader;
    ppage->pszHeaderSubTitle = (PWCHAR)pszSubHeader;
    ppage->lParam      = lpUserData;
    ppage->dwFlags     = PSP_USEHEADERSUBTITLE | 
                         PSP_USEHEADERTITLE    | 
                         PSP_USECALLBACK;

    return NO_ERROR;
}


// 
// Fills a LPPROPSHEETPAGE structure with the information
// needed to display the protocol tab in the incoming connections wizard.
//
DWORD 
ProtWizGetPropertyPage(
    IN LPPROPSHEETPAGE ppage, 
    IN LPARAM lpUserData) 
{
    LPCTSTR pszHeader, pszSubHeader;

    // Initialize
    ZeroMemory(ppage, sizeof(PROPSHEETPAGE));

    // Load the string resources
    pszHeader = PszLoadString(Globals.hInstDll, SID_WIZPROTTITLE);
    pszSubHeader = PszLoadString(Globals.hInstDll, SID_WIZPROTSUBTITLE);

    // The Advanced Properties dialog procedure also implements the net tab
    // in the incoming connections wizard
    ppage->pfnDlgProc  = NetTabDialogProc;

    // Fill in the values
    ppage->dwSize      = sizeof(PROPSHEETPAGE);
    ppage->hInstance   = Globals.hInstDll;
    ppage->pszTemplate = MAKEINTRESOURCE(PID_Wizard_NetTab);
    ppage->pfnCallback = RasSrvInitDestroyPropSheetCb;
    ppage->pszHeaderTitle = (PWCHAR)pszHeader;
    ppage->pszHeaderSubTitle = (PWCHAR)pszSubHeader;
    ppage->lParam      = lpUserData;
    ppage->dwFlags     = PSP_USEHEADERSUBTITLE | 
                         PSP_USEHEADERTITLE    | 
                         PSP_USECALLBACK;

    return NO_ERROR;
}

// 
// Function fills in the given LPPROPSHEETPAGE structure with the info 
// needed to run the dcc device tab in the incoming connections wizard.
// 
DWORD 
DccdevWizGetPropertyPage(
    IN LPPROPSHEETPAGE ppage, 
    IN LPARAM lpUserData) 
{
    LPCTSTR pszHeader, pszSubHeader;

    // Initialize
    ZeroMemory(ppage, sizeof(PROPSHEETPAGE));

    // Load the string resources
    pszHeader = PszLoadString(Globals.hInstDll, SID_WIZDCCDEVTITLE);
    pszSubHeader = PszLoadString(Globals.hInstDll, SID_WIZDCCDEVSUBTITLE);

    // The Advanced Properties dialog procedure also implements the protocol 
    // tab in the incoming connections wizard
    ppage->pfnDlgProc  = DccdevWizDialogProc;

    // Fill in the values
    ppage->dwSize      = sizeof(PROPSHEETPAGE);
    ppage->hInstance   = Globals.hInstDll;
    ppage->pszTemplate = MAKEINTRESOURCE(PID_Wizard_Dccdev);
    ppage->pfnCallback = RasSrvInitDestroyPropSheetCb;
    ppage->pszHeaderTitle = (PWCHAR)pszHeader;
    ppage->pszHeaderSubTitle = (PWCHAR)pszSubHeader;
    ppage->lParam      = lpUserData;
    ppage->dwFlags     = PSP_USEHEADERSUBTITLE | 
                         PSP_USEHEADERTITLE    | 
                         PSP_USECALLBACK;

    return NO_ERROR;
}

// 
// Function fills in the given LPPROPSHEETPAGE structure with the 
// information needed to run the dummy wizard page that switches to mmc.
//
DWORD 
SwitchMmcWizGetProptertyPage (
    IN LPPROPSHEETPAGE ppage, 
    IN LPARAM lpUserData) 
{
    // Initialize
    ZeroMemory(ppage, sizeof(PROPSHEETPAGE));

    // The Advanced Properties dialog procedure also implements 
    // the protocol tab in the incoming connections wizard
    ppage->pfnDlgProc  = SwitchMmcWizDialogProc;

    // Fill in the values
    ppage->dwSize      = sizeof(PROPSHEETPAGE);
    ppage->hInstance   = Globals.hInstDll;
    ppage->pszTemplate = MAKEINTRESOURCE(PID_Wizard_SwitchMmc);
    ppage->pfnCallback = RasSrvInitDestroyPropSheetCb;
    ppage->lParam      = lpUserData;
    ppage->dwFlags     = PSP_USEHEADERSUBTITLE | 
                         PSP_USEHEADERTITLE    | 
                         PSP_USECALLBACK;

    return NO_ERROR;
}

// 
// Initializes the vpn wizard tab.
// 
DWORD 
VpnWizInitializeDialog(
    IN HWND hwndDlg, 
    IN WPARAM wParam) 
{
    DWORD dwErr;
    BOOL bFlag;
    HANDLE hDevDatabase = NULL;
    
    // Get handles to the databases we're interested in
    RasSrvGetDatabaseHandle(hwndDlg, ID_DEVICE_DATABASE, &hDevDatabase);

    // Initialize the vpn check
    dwErr = devGetVpnEnable(hDevDatabase, &bFlag);
    if (dwErr != NO_ERROR)
    {
        ErrDisplayError(
            hwndDlg, 
            ERR_DEVICE_DATABASE_CORRUPT, 
            ERR_GENERALTAB_CATAGORY, 
            0, 
            Globals.dwErrorData);
        return dwErr;
    }
    
    SendMessage(GetDlgItem(hwndDlg, CID_Wizard_Vpn_RB_Yes), 
                BM_SETCHECK,
                (bFlag) ? BST_CHECKED : BST_UNCHECKED,
                0);
                
    SendMessage(GetDlgItem(hwndDlg, CID_Wizard_Vpn_RB_No), 
                BM_SETCHECK,
                (!bFlag) ? BST_CHECKED : BST_UNCHECKED,
                0);

    return NO_ERROR;
}

//
// Handles cancel button being pressed for the vpn wizard page
//
DWORD 
VpnWizCancelEdit(
    IN HWND hwndDlg, 
    IN NMHDR* pNotifyData) 
{
    HANDLE hDevDatabase = NULL;
    DWORD dwErr;
    
    DbgOutputTrace("Rolling back vpn wizard tab.");
    
    // Cancel flush of database
    RasSrvGetDatabaseHandle(hwndDlg, ID_DEVICE_DATABASE, &hDevDatabase);
    dwErr = devRollbackDatabase(hDevDatabase);
    if (dwErr != NO_ERROR)
    {
        ErrDisplayError(
            hwndDlg, 
            ERR_GENERAL_CANT_ROLLBACK_CHANGES, 
            ERR_GENERALTAB_CATAGORY, 
            0, 
            Globals.dwErrorData);
    }
        
    return NO_ERROR;
}

//
// Handles having the vpn wizard come active
//
DWORD 
VpnWizSetActive (
    IN HWND hwndDlg, 
    IN WPARAM wParam, 
    IN LPARAM lParam) 
{
    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT | PSWIZB_BACK);
    return NO_ERROR;
}

// 
// Handles vpn loose activation messages
//
DWORD 
VpnWizKillActive (
    IN HWND hwndDlg, 
    IN WPARAM wParam, 
    IN LPARAM lParam) 
{
    HANDLE hDevDatabase = NULL;
    BOOL bEnable;
    
    //For Whistler bug#123769
    //In order to let the SetPortMapping commit
    //when creating a new IC connection, we set
    //the fVpnEnabledOrig to be different from
    // the fVpnEnable
    //
    RasSrvGetDatabaseHandle(hwndDlg, ID_DEVICE_DATABASE, &hDevDatabase);

    bEnable = IsDlgButtonChecked( hwndDlg, CID_Wizard_Vpn_RB_Yes );
                
    devSetVpnOrigEnable(hDevDatabase, !bEnable);

    return NO_ERROR;
}    

// 
// Processes command messages for the vpn wizard page
// 
DWORD 
VpnWizCommand(
    IN HWND hwndDlg, 
    IN WPARAM wParam, 
    IN LPARAM lParam) 
{
    HANDLE hDevDatabase = NULL;
    BOOL bEnable;
    
    RasSrvGetDatabaseHandle(hwndDlg, ID_DEVICE_DATABASE, &hDevDatabase);

    if (wParam == CID_Wizard_Vpn_RB_Yes || wParam == CID_Wizard_Vpn_RB_No) 
    {
        bEnable = (BOOL) SendMessage(
                    GetDlgItem(hwndDlg, CID_Wizard_Vpn_RB_Yes),
                    BM_GETCHECK,
                    0,
                    0);
                    
        devSetVpnEnable(hDevDatabase, bEnable);
    }
    
    return NO_ERROR;
}

//
// This dialog procedure responds to messages sent to the 
// vpn wizard tab.
//
INT_PTR CALLBACK 
VpnWizDialogProc(
    IN HWND hwndDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam) 
{
    // Filter the customized ras server ui page messages. By filtering 
    // messages through here, we are able to call RasSrvGetDatabaseHandle 
    // below
    if (RasSrvMessageFilter(hwndDlg, uMsg, wParam, lParam))
        return TRUE;

    // Process other messages as normal
    switch (uMsg) 
    {
        case WM_INITDIALOG:
            return FALSE;
            break;

        case WM_NOTIFY:
            switch (((NMHDR*)lParam)->code) 
            {
                case PSN_RESET:                    
                    VpnWizCancelEdit(hwndDlg, (NMHDR*)lParam);
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
                    break;
                    
                case PSN_SETACTIVE:
                    if (! GetWindowLongPtr(hwndDlg, GWLP_USERDATA))
                    {
                        VpnWizInitializeDialog(hwndDlg, wParam);
                        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, 1);
                    }
                    VpnWizSetActive (hwndDlg, wParam, lParam);
                    break;
                    
                case PSN_KILLACTIVE:
                    VpnWizKillActive (hwndDlg, wParam, lParam);
                    break;
            }

        case WM_COMMAND:
            VpnWizCommand(hwndDlg, wParam, lParam);
            break;
    }

    return FALSE;
}

// Fill the device combo box
DWORD 
DccdevFillDeviceList(
    IN HWND hwndDlg, 
    IN HANDLE hDevDatabase, 
    IN HANDLE hDevSelect) 
{
    HWND hwndCb = GetDlgItem(hwndDlg, CID_Wizard_Dccdev_LB_Devices);
    DWORD dwCount, dwIndex, dwErr, i, j=0, dwSelect = 0;
    HANDLE hDevice;
    PWCHAR pszName = NULL;
    
    // Delete anything that was in the combo box
    SendMessage(hwndCb, CB_RESETCONTENT, 0, 0);

    // Get the count of devices
    if ((dwErr = devGetDeviceCount(hDevDatabase, &dwCount)) != NO_ERROR)
    {
        return dwErr;
    }

    // Add them to the device combo box
    for (i = 0; i < dwCount; i++) 
    {
        // If the device wasn't filtered out, add it to the combo
        // box and remember its handle
        dwErr = devGetDeviceHandle(hDevDatabase, i, &hDevice);
        if (dwErr == NO_ERROR) 
        {
            devGetDeviceName (hDevice, &pszName);
            
            dwIndex = (DWORD) SendMessage (
                                hwndCb, 
                                CB_ADDSTRING, 
                                0, 
                                (LPARAM)pszName);
                                
            SendMessage (
                hwndCb, 
                CB_SETITEMDATA, 
                dwIndex, 
                (LPARAM)hDevice);

            // If this is the device to select, remember that fact
            if (hDevice == hDevSelect)
            {
                dwSelect = j;
            }
            
            j++;
        }
    }

    ComboBox_SetCurSel(hwndCb, dwSelect); 

    return NO_ERROR;
}

//
// Initializes the dcc device wizard tab.
//
DWORD 
DccdevWizInitializeDialog(
    IN HWND hwndDlg, 
    IN WPARAM wParam) 
{
    HANDLE hDevDatabase = NULL, hDevice = NULL;
    DWORD dwStatus, dwErr, dwCount, i;
    BOOL bEnabled;
    DCCDEV_DATA * pDcData;

    // Whenever the dcc device page is left, the currently selected device
    // is remembered and its original enabling is recorded.  Then this device
    // is set to enabled.  Whenever the page is activated, the remembered 
    // device is restored to its original enabling state if it is still 
    // enabled.
    //
    // This whole process is a little confusing, but it ensures that the dcc
    // device page will interact correctly when the user goes down the dcc 
    // path and then the incoming path and back and forth.
    //
    if ((pDcData = RassrvAlloc (sizeof(DCCDEV_DATA), TRUE)) == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Get handles to the databases we're interested in
    RasSrvGetDatabaseHandle(hwndDlg, ID_DEVICE_DATABASE, &hDevDatabase);
    
    // Add the com ports as devices and filter out all non dcc 
    // devices from the device database
    devFilterDevices(hDevDatabase, INCOMING_TYPE_DIRECT);
    devAddComPorts(hDevDatabase);
    
    // Get the count of devices
    if ((dwErr = devGetDeviceCount(hDevDatabase, &dwCount)) != NO_ERROR)
    {
        return dwErr;
    }
        
    // Get the handle to the first device if any 
    for (i = 0; i < dwCount; i++) 
    {
        if (devGetDeviceHandle (hDevDatabase, i, &hDevice) == NO_ERROR)
        {
            break;
        }
    }

    // Record the device's enabling -- index is 0 (default)
    if (hDevice) 
    {
        dwErr = devGetDeviceEnable (hDevice, &(pDcData->bEnabled));
        if (dwErr != NO_ERROR)
        {
            return dwErr;
        }
        
        pDcData->hDevice = hDevice;
    }

    // Record the status bits
    SetWindowLongPtr (hwndDlg, GWLP_USERDATA, (LONG_PTR)pDcData);
    
    return NO_ERROR;
}

//
// Cleans up the dcc device wizard
//
DWORD 
DccdevWizCleanupDialog(
    IN HWND hwndDlg, 
    IN WPARAM wParam, 
    IN LPARAM lParam) 
{
    DCCDEV_DATA * pDcData = 
        (DCCDEV_DATA *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
        
    if (pDcData)
    {
        RassrvFree (pDcData);
    }
        
    return NO_ERROR;  
}

// 
// Called to do any processing when the dcc wizard device page is 
// gaining focus
//
DWORD 
DccdevWizSetActive (
    IN HWND hwndDlg, 
    IN WPARAM wParam, 
    IN LPARAM lParam) 
{
    HANDLE hDevDatabase = NULL;
    BOOL bEnabled;
    DCCDEV_DATA * pDcData;
    
    // Whenever the page is activated, the remembered device 
    // is restored to its original enabling state if it is still enabled.
    pDcData = (DCCDEV_DATA*) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    if (pDcData && pDcData->hDevice) 
    {
        if (devGetDeviceEnable (pDcData->hDevice, &bEnabled) == NO_ERROR) 
        {
            if (bEnabled)
            {
                devSetDeviceEnable (pDcData->hDevice, pDcData->bEnabled);
            }
        }
    }
    
    // Get handles to the databases we're interested in
    RasSrvGetDatabaseHandle (hwndDlg, ID_DEVICE_DATABASE, &hDevDatabase);
    
    // Fill the device combo box
    DccdevFillDeviceList (
        hwndDlg, 
        hDevDatabase, 
        (pDcData) ? pDcData->hDevice : NULL);
    
    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT | PSWIZB_BACK);
    
    return NO_ERROR;
}

//
// Called to do any processing when the dcc wizard device 
// page is loosing focus
//
DWORD 
DccdevWizKillActive (
    IN HWND hwndDlg, 
    IN WPARAM wParam, 
    IN LPARAM lParam) 
{
    HANDLE hDevDatabase = NULL, hDevice = NULL;
    DCCDEV_DATA * pDcData;
    INT iCurSel;
    HWND hwndCb = GetDlgItem (hwndDlg, CID_Wizard_Dccdev_LB_Devices);
    DWORD dwErr; 
    
    // Whenever the dcc device page is left, the currently selected 
    // device is remembered and its original enabling is recorded.  
    // Then this device is set to enabled.  
    pDcData = (DCCDEV_DATA*) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
    if (pDcData) 
    {
        iCurSel = ComboBox_GetCurSel(hwndCb);
        if (iCurSel != -1) 
        {
            hDevice = (HANDLE) ComboBox_GetItemData(hwndCb, iCurSel);
            dwErr = devGetDeviceEnable (hDevice, &(pDcData->bEnabled));
            if (dwErr == NO_ERROR) 
            {
                pDcData->hDevice = hDevice;
                devSetDeviceEnable (hDevice, TRUE);
            }
        }
        else 
        {
            pDcData->hDevice = NULL;
        }
    }

    // Get handles to the databases we're interested in
    RasSrvGetDatabaseHandle(
        hwndDlg, 
        ID_DEVICE_DATABASE, 
        &hDevDatabase);

    // Undo the filter so that other pages aren't affected
    //devFilterDevices(
    //    hDevDatabase, 
    //    0xffffffff);

    return NO_ERROR;
}

//
// Called to cancel the edit operation on the dcc host 
// device wizard tab.
// 
DWORD 
DccdevWizCancelEdit(
    IN HWND hwndDlg, 
    IN NMHDR* pNotifyData)  
{
    HANDLE hDevDatabase = NULL;
    DWORD dwErr;
    
    DbgOutputTrace("Rolling back dcc device wizard tab.");
    
    // Cancel the commit on the device database
    RasSrvGetDatabaseHandle(
        hwndDlg, 
        ID_DEVICE_DATABASE, 
        &hDevDatabase);
        
    dwErr = devRollbackDatabase(hDevDatabase);
    if (dwErr != NO_ERROR)
    {
        ErrDisplayError(
            hwndDlg, 
            ERR_GENERAL_CANT_ROLLBACK_CHANGES, 
            ERR_GENERALTAB_CATAGORY, 
            0, 
            Globals.dwErrorData);
    }

    return NO_ERROR;    
}

//
// Raises properties for a component
//
DWORD 
DccdevWizRaiseProperties (
    IN HWND hwndDlg, 
    IN HWND hwndLb,
    IN INT  iItem) 
{
    HANDLE hDevice;
    DWORD dwErr = NO_ERROR, dwId;
    MSGARGS MsgArgs;
    BOOL bIsComPort = FALSE;

    // Get a handle to the device
    hDevice = (HANDLE) ComboBox_GetItemData(hwndLb, iItem);
    if (hDevice == NULL)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    // Find out if the device is a com port which has not yet had a
    // null modem installed.
    //
    dwErr = devDeviceIsComPort(hDevice, &bIsComPort);
    if (dwErr != NO_ERROR)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }

    // If so, popup info to the user explaining
    // the situation.
    //
    if (bIsComPort)
    {
        ZeroMemory(&MsgArgs, sizeof(MsgArgs));

        MsgArgs.dwFlags = MB_OK | MB_ICONINFORMATION;
        MsgDlgUtil(
            hwndDlg,
            SID_COM_PORT_NOT_ENABLED,
            &MsgArgs,
            Globals.hInstDll,
            SID_DEFAULT_MSG_TITLE);
            
        return NO_ERROR;
    }

    // Get the tapi id of the device
    if (devGetDeviceId(hDevice, &dwId) != NO_ERROR)
    {
        return ERROR_CAN_NOT_COMPLETE;
    }
    
    // Launch the device properties dialog
    dwErr = lineConfigDialogW(dwId, hwndDlg, NULL);
    if (dwErr == LINEERR_OPERATIONUNAVAIL)
    {
        ErrDisplayError(
            hwndDlg, 
            ERR_DEVICE_HAS_NO_CONFIG, 
            ERR_GENERALTAB_CATAGORY, 
            0, 
            Globals.dwErrorData);
        dwErr = NO_ERROR;
    }
    
    return dwErr;
}

//
// Called when "iItem" is being selected to enable or disable the
// properties button.
//
DWORD 
DccdevWizEnableDisableProperties(
    IN HWND hwndDlg, 
    IN HWND hwndLb,
    IN INT iItem)
{
    return NO_ERROR;
}

//
// Called to cancel the edit operation on the dcc host 
// device wizard tab.
//
DWORD 
DccdevWizCommand(
    HWND hwndDlg, 
    WPARAM wParam, 
    LPARAM lParam)  
{
    switch (LOWORD(wParam))
    {
        case CID_Dccdev_PB_Properties:
        {
            HWND hwndLb;

            hwndLb = GetDlgItem(hwndDlg, CID_Wizard_Dccdev_LB_Devices);
            
            DccdevWizRaiseProperties(
                hwndDlg, 
                hwndLb,
                ComboBox_GetCurSel(hwndLb));
        }
        break;

        case CID_Wizard_Dccdev_LB_Devices:
        {
            if (HIWORD(wParam) == CBN_SELCHANGE)
            {
                DccdevWizEnableDisableProperties(
                    hwndDlg, 
                    (HWND)lParam,
                    ComboBox_GetCurSel((HWND)lParam));
            }
        }
        break;
    }
    
    return NO_ERROR;
}

INT_PTR 
CALLBACK 
DccdevWizDialogProc(
    IN HWND hwndDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam)
{
    // Filter the customized ras server ui page 
    // messages. By filtering messages through
    // here, we are able to call RasSrvGetDatabaseHandle 
    // below
    if (RasSrvMessageFilter(hwndDlg, uMsg, wParam, lParam))
        return TRUE;

    // Process other messages as normal
    switch (uMsg) 
    {
        case WM_INITDIALOG:
            return FALSE;

        case WM_NOTIFY:
            switch (((NMHDR*)lParam)->code) 
            {
                case PSN_RESET:                    
                    DccdevWizCancelEdit(hwndDlg, (NMHDR*)lParam);
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, FALSE);
                    break;
                    
                case PSN_SETACTIVE:
                    {
                        DWORD dwErr; 

                        if (! GetWindowLongPtr(hwndDlg, GWLP_USERDATA))
                        {
                            DccdevWizInitializeDialog(hwndDlg, wParam);
                        }
                        
                        dwErr = DccdevWizSetActive (
                                    hwndDlg, 
                                    wParam, 
                                    lParam);
                        if (dwErr != NO_ERROR)
                        {
                            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
                        }
                    }
                    break;
                    
                case PSN_KILLACTIVE:
                    DccdevWizKillActive (hwndDlg, wParam, lParam);
                    break;
            }
            break;//for bug 187918

        case WM_COMMAND:
            DccdevWizCommand(hwndDlg, wParam, lParam);
            break;

        case WM_DESTROY:
            DccdevWizCleanupDialog(hwndDlg, wParam, lParam);
            break;
    }

    return FALSE;
}

//
// Handles the activation of the switch to mmc wizard page.
//
DWORD 
SwitchMmcWizSetActive (
    IN HWND hwndDlg, 
    IN WPARAM wParam, 
    IN LPARAM lParam) 
{
    PWCHAR pszTitle;
    PWCHAR pszMessage;
    INT iRet;

    // Load the messages to display
    pszTitle = (PWCHAR) 
        PszLoadString(Globals.hInstDll, WRN_WIZARD_NOT_ALLOWED_TITLE);
        
    pszMessage = (PWCHAR) 
        PszLoadString(Globals.hInstDll, WRN_WIZARD_NOT_ALLOWED_MSG);

    iRet = MessageBox (
                hwndDlg, 
                pszMessage, 
                pszTitle, 
                MB_YESNO | MB_ICONINFORMATION); 
    if (iRet == 0)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // If yes was pressed, switch to mpradmin snapin.
    if (iRet == IDYES) 
    {
        RasSrvLeaveServiceRunning (hwndDlg);
        PropSheet_PressButton (GetParent (hwndDlg), PSBTN_CANCEL);
        RassrvLaunchMMC (RASSRVUI_MPRCONSOLE);
    }

    // Otherwise, display the welcome page
    else if (iRet == IDNO) 
    {
        PropSheet_PressButton (GetParent (hwndDlg), PSBTN_BACK);
    }

    // No matter what, don't accept activation
    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

    return NO_ERROR;
}

// This dialog procedure responds to messages sent to the 
// switch to mmc wizard tab.
INT_PTR 
CALLBACK 
SwitchMmcWizDialogProc (
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam) 
{
    // Filter the customized ras server ui page messages. By filtering 
    // messages through here, we are able to call RasSrvGetDatabaseHandle 
    // below
    if (RasSrvMessageFilter(hwndDlg, uMsg, wParam, lParam))
        return TRUE;

    // Process other messages as normal
    switch (uMsg) 
    {
        case WM_NOTIFY:
            switch (((NMHDR*)lParam)->code) 
            {
                case PSN_SETACTIVE:
                    return SwitchMmcWizSetActive (hwndDlg, wParam, lParam);
                    break;
            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ras\ui\rassrvui\test\main.c ===
/*
    Main.c

    Tests the dialup server ui.

    Paul Mayfield, 9/30/97
*/
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <rasuip.h>
#include <rassrvp.h>

#define mbtowc(wname, aname) MultiByteToWideChar(CP_ACP,0,aname,-1,wname,1024)

BOOL TempFunc(int argc, char ** argv);

// Error reporting
void PrintErr(DWORD err) {
        WCHAR buf[1024];
        FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM,NULL,err,(DWORD)NULL,buf,1024,NULL);
        wprintf(buf);
        wprintf(L"\n");
}

// Function adds pages to a property sheet
BOOL CALLBACK AddPageProc(HPROPSHEETPAGE hPage, LPARAM lParam) {
    PROPSHEETHEADER * pHeader = (PROPSHEETHEADER*)lParam;
    HPROPSHEETPAGE * phpage = pHeader->phpage;
    DWORD i;

    // Increment
    pHeader->nPages++;

    // Resize
    pHeader->phpage = (HPROPSHEETPAGE *) malloc(sizeof(HPROPSHEETPAGE) * pHeader->nPages);
    if (!pHeader->phpage)
        return FALSE;

    // Copy
    for (i = 0; i < pHeader->nPages - 1; i++) 
        pHeader->phpage[i] = phpage[i];
    pHeader->phpage[i] = hPage;

    // Free
    if (phpage)
        free(phpage);

    return TRUE;
}

// Displays the properties ui of the dialup server
DWORD DisplayUI() {
    PROPSHEETHEADER header;
    DWORD dwErr;
/*
    ZeroMemory(&header, sizeof(header));
    header.dwSize = sizeof(PROPSHEETHEADER);
    header.dwFlags = PSH_NOAPPLYNOW | PSH_USECALLBACK;
    header.hwndParent = GetFocus();
    header.hInstance = GetModuleHandle(NULL);
    header.pszCaption = "Incoming Connections";
    header.nPages = 0;
    header.ppsp = NULL;

    // Add the property pages and display
    if ((dwErr = RasSrvAddPropPages(NULL, AddPageProc, (LPARAM)&header)) == NO_ERROR) {
        int iErr;
        iErr = PropertySheet(&header);
        if (iErr == -1)
            PrintErr(GetLastError());
    }
*/
    return NO_ERROR;
}

DWORD DisplayWizard() {
    PROPSHEETHEADER header;
    DWORD dwErr;
    int iErr;
/*
    // Initialize the header
    ZeroMemory(&header, sizeof(header));
    header.dwSize = sizeof(PROPSHEETHEADER);
    header.dwFlags = PSH_NOAPPLYNOW | PSH_USECALLBACK | PSH_WIZARD97;
    header.hwndParent = GetFocus();
    header.hInstance = GetModuleHandle(NULL);
    header.pszCaption = "Incoming Connections";
    header.nPages = 0;
    header.ppsp = NULL;

    // Add the wizard pages
    if ((dwErr = RasSrvAddWizPages(AddPageProc, (LPARAM)&header)) != NO_ERROR)
        return dwErr;
        
    // Display the property sheet
    iErr = PropertySheet(&header);
    if (iErr == -1)
        PrintErr(GetLastError());
*/
    return NO_ERROR;
}

DWORD DisplayDccWizard() {
/*
    PROPSHEETHEADER header;
    DWORD dwErr;
    int iErr;

    // Initialize the header
    ZeroMemory(&header, sizeof(header));
    header.dwSize = sizeof(PROPSHEETHEADER);
    header.dwFlags = PSH_NOAPPLYNOW | PSH_USECALLBACK | PSH_WIZARD97;
    header.hwndParent = GetFocus();
    header.hInstance = GetModuleHandle(NULL);
    header.pszCaption = "Incoming Connections";
    header.nPages = 0;
    header.ppsp = NULL;

    // Add the wizard pages
    if ((dwErr = RassrvAddDccWizPages(AddPageProc, (LPARAM)&header)) != NO_ERROR)
        return dwErr;
        
    // Display the property sheet
    iErr = PropertySheet(&header);
    if (iErr == -1)
        PrintErr(GetLastError());

    return NO_ERROR;
*/
    RasUserPrefsDlg ( NULL );
    
    return NO_ERROR;
}

// Enumerates the active connections
void EnumConnections () {
    RASSRVCONN pConnList[3];
    DWORD dwTot = 3, dwSize = dwTot * sizeof (RASSRVCONN), i, dwErr;

    if ((dwErr = RasSrvEnumConnections((LPVOID)&pConnList, &dwSize, &dwTot)) != NO_ERROR)
        PrintErr(dwErr);
    else {
        for (i=0; i < dwTot; i++)
            wprintf(L"Connection: %s\n", pConnList[i].szEntryName);
    }
}

// Finds the given connection structure in a list.  pConn will point to the
// appropriate structure on success, otherwise it will point to NULL.  If an
// error occurs, DWORD will contain an error code, otherwise NO_ERROR.
DWORD FindConnectionInList(LPRASSRVCONN lprassrvconn, DWORD dwEntries, PWCHAR pszConnName, LPRASSRVCONN * pConn) {
    DWORD i;

    if (!pConn || !lprassrvconn)
        return ERROR_INVALID_PARAMETER;

    for (i = 0; i < dwEntries; i++) {
        if (wcscmp(lprassrvconn[i].szEntryName, pszConnName) == 0) {
            *pConn = &(lprassrvconn[i]);
            break;
        }
    }

    return NO_ERROR;
}

DWORD HangupConnection(char * pszAConnectionName) {
    WCHAR pszConnectionName[1024];
    RASSRVCONN pConnList[20], *pConn;
    DWORD dwTot = 20, dwSize = dwTot * sizeof (RASSRVCONN), i, dwErr;

    mbtowc(pszConnectionName, pszAConnectionName);
    if ((dwErr = RasSrvEnumConnections((LPVOID)&pConnList, &dwSize, &dwTot)) != NO_ERROR)
        return dwErr;
    
    if ((dwErr = FindConnectionInList(pConnList, dwTot, pszConnectionName, &pConn)) != NO_ERROR)
        return dwErr;

    return RasSrvHangupConnection(pConn->hRasSrvConn);
}

// Displays status of the given active connection
DWORD StatusUI(char * pszAConnectionName) {
    printf("Multilink status will not be included in connections.\n");
    return NO_ERROR;
}    
/*
#define numPages 1
    PROPSHEETHEADER header;
    PROPSHEETPAGE   pPages[numPages];
    WCHAR pszConnectionName[1024];
    RASSRVCONN pConnList[20], *pConn;
    DWORD dwTot = 20, dwSize = dwTot * sizeof (RASSRVCONN), i, dwErr;

    mbtowc(pszConnectionName, pszAConnectionName);
    if ((dwErr = RasSrvEnumConnections((LPVOID)&pConnList, &dwSize, &dwTot)) != NO_ERROR)
        return dwErr;
    
    if ((dwErr = FindConnectionInList(pConnList, dwTot, pszConnectionName, &pConn)) != NO_ERROR)
        return dwErr;

    if (pConn) {
        // Get the property sheet page of the user
        dwErr = RasSrvAddPropPage(&(pPages[0]), RASSRVUI_MULTILINK_TAB, (DWORD)pConn->hRasSrvConn);
        if (dwErr != NO_ERROR)
            return dwErr;

        ZeroMemory(&header, sizeof(header));
        header.dwSize = sizeof(PROPSHEETHEADER);
        header.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW | PSH_USECALLBACK;
        header.hwndParent = GetFocus();
        header.hInstance = GetModuleHandle(NULL);
        header.pszCaption = "Multilink Statistics";
        header.nPages = numPages;
        header.ppsp = pPages;

        // Display the property sheet
        PropertySheet(&header);
    }
    else {
        wprintf(L"Unable to find connection: %s\n", pszConnectionName);
        return ERROR_CAN_NOT_COMPLETE;
    }

    return NO_ERROR;
#undef numPages
}
*/

DWORD DeleteIcon() {
    DWORD dwErr;
   
    printf("Stopping remote access service... ");
    dwErr = RasSrvCleanupService();
    if (dwErr == NO_ERROR)
        printf("Success.\n");
    else 
        printf("\n");

    return dwErr;
}


char * GetParam(char * buf) {
    char * ptr = strstr(buf, " ");
    ptr++;
    return ptr;
}

DWORD RunScript(char * filename) {
    FILE * f;
    char buf[256];
    DWORD dwErr;

    f = fopen(filename, "r");
    if (!f)
        return ERROR_OPEN_FAILED;

    while (fgets(buf, 256, f)) {
        if (buf[strlen(buf)-1] == '\n')
            buf[strlen(buf)-1] = 0;
        if (strncmp(buf, "-e", 2) == 0)
            EnumConnections();
        else if (strncmp(buf, "-p", 2) == 0) {
            if ((dwErr = DisplayUI()) != NO_ERROR)
                PrintErr(dwErr);
        }
        else if (strncmp(buf, "-s", 2) == 0) {
            if ((dwErr = StatusUI(GetParam(buf))) != NO_ERROR)
                PrintErr(dwErr);
        }
        else if (strncmp(buf, "-h", 2) == 0) {
            if ((dwErr = HangupConnection(GetParam(buf))) != NO_ERROR)
                PrintErr(dwErr);
        }
        else if (strncmp(buf, "-r", 2) == 0) {
            if ((dwErr = RunScript(GetParam(buf))) != NO_ERROR)
                PrintErr(dwErr);
        }
        else if (strncmp(buf, "-w", 2) == 0) {
            if ((dwErr = DisplayWizard()) != NO_ERROR)
                PrintErr(dwErr);
        }
    }

    fclose(f);

    return NO_ERROR;
}

// usage
void usage (char * prog) {
    printf("\n");
    printf("Usage\n=====\n");
    printf("%s -d         \t Deletes the incoming connect icon (stop service).\n", prog);
    printf("%s -e         \t Enumerates the active connections.\n", prog);
    printf("%s -h <user>  \t Disconnects the given user.\n", prog);
    printf("%s -p         \t Brings up the dialup server properties page.\n", prog);
    printf("%s -r <script>\t Runs the commands in the given script file.\n", prog);
    printf("%s -s <user>  \t Shows multilink status for the given connected user.\n", prog);
    printf("%s -w         \t Runs incoming connections wizard.\n", prog);
    printf("\n");
    printf("Examples\n========\n");
    printf("%s -h \"pmay (Paul Mayfield)\" \n", prog);
    printf("%s -s \"rosemb (Rose Bigham)\" \n", prog);
    printf("%s -r script1.txt\n", prog);
}

void RunTest(int argc, char ** argv) {
    DWORD dwErr;

    if (argc < 2) 
        usage(argv[0]);
    else {
        if (strcmp(argv[1], "-e") == 0)
            EnumConnections();
        else if (strcmp(argv[1], "-p") == 0) {
            if ((dwErr = DisplayUI()) != NO_ERROR)
                PrintErr(dwErr);
        }
        else if (strcmp(argv[1], "-d") == 0) {
            if ((dwErr = DeleteIcon()) != NO_ERROR)
                PrintErr(dwErr);
        }
        else if ((argc > 2) && (strcmp(argv[1], "-s") == 0)) {
            if ((dwErr = StatusUI(argv[2])) != NO_ERROR)
                PrintErr(dwErr);
        }
        else if ((argc > 2) && (strcmp(argv[1], "-h") == 0)) {
            if ((dwErr = HangupConnection(argv[2])) != NO_ERROR)
                PrintErr(dwErr);
        }
        else if ((argc > 2) && (strcmp(argv[1], "-r") == 0)) {
            if ((dwErr = RunScript(argv[2])) != NO_ERROR)
                PrintErr(dwErr);
        }
        else if (strcmp(argv[1], "-w") == 0) {
            if ((dwErr = DisplayWizard()) != NO_ERROR)
                PrintErr(dwErr);
        }
        else if (strcmp(argv[1], "-c") == 0) {
            if ((dwErr = DisplayDccWizard()) != NO_ERROR)
                PrintErr(dwErr);
        }
        else
            usage(argv[0]);
    }
}

// Main function dispatches all of the work
int _cdecl main (int argc, char ** argv) {
    if (! TempFunc(argc, argv))
        RunTest(argc, argv);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\routemon\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddser.h>

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <memory.h>
#include <malloc.h>

#include "comstrs.h"
#include "commsgs.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\routemon\utils.h ===
#ifndef _ROUTEMON_UTILS_
#define _ROUTEMON_UTILS_

UINT APIENTRY
get_str_id (
	ENUM_TO_STR		Array[],
	ULONG			ArraySz,
	ULONG			EnumVal
	);

BOOL APIENTRY
get_enum_val (
	HINSTANCE	hModule,
	ENUM_TO_STR		Array[],
	ULONG			ArraySz,
	LPTSTR			String,
	PULONG			EnumVal
	);

ULONG APIENTRY
put_msg (
	HINSTANCE	hModule,
	UINT		MsgId,
    ... 
	);

ULONG APIENTRY
put_str_msg (
	HINSTANCE	hModule,
	UINT		MsgId,
    ... 
	);

ULONG APIENTRY
put_error_msg (
	DWORD				error
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\routemon\register.c ===
/*
    File:   Register.c

    Handles routemon options to register ras servers in domains.
*/

#include "precomp.h"

// 
// Defines a macro to perform string copies to
// unicode strings regardless of the UNICODE setting.
//
#if defined( UNICODE ) || defined( _UNICODE )
#define RaSrvStrcpy(dst, src) wcscpy((dst), (src));
#else
#define RaSrvStrcpy(dst, src) mbstowcs((dst), (src), strlen((src)));
#endif

// 
// Defines structure of parameters that can be sent to 
// a RaSrv api's.
//
typedef struct _RASRV_PARAMS {
    WCHAR pszDomain[512];   // Given domain
    PWCHAR pszMachine;      // Given machine
    BOOL bEnable;           // Whether to enable or disable
    BOOL bQuery;            // Whether to query status
} RASRV_PARAMS, * PRASRV_PARAMS;

//
// Returns a static error message
//
PWCHAR RaSrvError (DWORD dwErr) {   
    static WCHAR pszRet[512];

    ZeroMemory(pszRet, sizeof(pszRet));

    FormatMessageW (FORMAT_MESSAGE_FROM_SYSTEM, 
                    NULL, 
                    dwErr, 
                    0, 
                    pszRet, 
                    sizeof(pszRet) / sizeof(WCHAR), 
                    NULL);
                    
    return pszRet;                    
}    

//
// Displays usage and returns a generic error.
//
DWORD RaSrvUsage(
        IN  HINSTANCE hInst,
    	IN  PROUTEMON_PARAMS pRmParams,
    	IN  PROUTEMON_UTILS pUtils)
{
	pUtils->put_msg (hInst, 
	                 MSG_RASRV_HELP, 
	                 pRmParams->pszProgramName);
	                 
    return ERROR_CAN_NOT_COMPLETE;    	                 
}

//
// Parses the register command line and fills 
// the parameters accordingly.
//
DWORD RaSrvParse (
        IN  int argc, 
        IN  TCHAR *argv[], 
    	IN  PROUTEMON_PARAMS pRmParams,
    	IN  PROUTEMON_UTILS pUtils,
        IN  BOOL bLoad,
        OUT RASRV_PARAMS * pParams) 
{
    DWORD dwSize, dwErr;
    BOOL bValidCmd = FALSE;
    HINSTANCE hInst = GetModuleHandle(NULL);
	TCHAR buf[MAX_TOKEN];
    WCHAR pszComputer[1024];
    
    // Initialize the return val
    ZeroMemory(pParams, sizeof(RASRV_PARAMS));

    // Make sure a path has been provided
    if (argc == 0) 
        return RaSrvUsage(hInst, pRmParams, pUtils);
        
    // Parse out the command
	if (_tcsicmp(argv[0], GetString (hInst, TOKEN_ENABLE, buf))==0) {
	    pParams->bEnable = TRUE;
	}
	else if (_tcsicmp(argv[0], GetString (hInst, TOKEN_DISABLE, buf))==0) {
	    pParams->bEnable = FALSE;
	}
	else if (_tcsicmp(argv[0], GetString (hInst, TOKEN_SHOW, buf))==0) {
	    pParams->bQuery = TRUE;
	}
	else 
	    return RaSrvUsage(hInst, pRmParams, pUtils);

    // Initialize the computer name if present
    if (argc > 1) {
        RaSrvStrcpy(pszComputer, argv[1]);
    }        
    else {
        dwSize = sizeof(pszComputer) / sizeof(WCHAR);
        GetComputerNameW (pszComputer, &dwSize);
    }        
    pParams->pszMachine = _wcsdup (pszComputer);

    // Initialize the domain if present
    if (argc > 2) 
        RaSrvStrcpy(pParams->pszDomain, argv[2]);            

    return NO_ERROR;
}

// 
// Cleans up any RaSrv parameters
//
DWORD RaSrvCleanup (
        IN PRASRV_PARAMS pParams) 
{
    if (pParams->pszMachine)
        free(pParams->pszMachine);
        
    return NO_ERROR;
}

//
// The RaSrv functionality engine
//
DWORD RaSrvEngine (
        IN	PROUTEMON_PARAMS pRmParams,
        IN	PROUTEMON_UTILS pUtils,
        IN  PRASRV_PARAMS pParams)
{
    DWORD dwErr;
    HINSTANCE hInst = GetModuleHandle(NULL);
    BOOL bValue;
    
    // Query registration status
    //
    if (pParams->bQuery) {
        dwErr = MprAdminIsDomainRasServer (
                    pParams->pszDomain,
                    pParams->pszMachine,
                    &bValue);
        if (dwErr != NO_ERROR) {
            pUtils->put_msg(
                    hInst, 
                    MSG_REGISTER_QUERY_FAIL, 
                    pParams->pszMachine,
                    RaSrvError(dwErr));
            return dwErr;
        }

        if (bValue)
            pUtils->put_msg(
                    hInst, 
                    MSG_REGISTER_QUERY_YES, 
                    pParams->pszMachine);
        else
            pUtils->put_msg(
                    hInst, 
                    MSG_REGISTER_QUERY_NO, 
                    pParams->pszMachine);
    }
    
    // Register the service
    //
    else {
        dwErr = MprAdminEstablishDomainRasServer (
                    pParams->pszDomain,
                    pParams->pszMachine,
                    pParams->bEnable);
        if (dwErr != NO_ERROR) {
            pUtils->put_msg(
                    hInst, 
                    MSG_REGISTER_REGISTER_FAIL, 
                    pParams->pszMachine,
                    RaSrvError(dwErr));
            return dwErr;
        }

        if (pParams->bEnable)
            pUtils->put_msg(
                    hInst, 
                    MSG_REGISTER_ENABLE_SUCCESS, 
                    pParams->pszMachine);
        else
            pUtils->put_msg(
                    hInst, 
                    MSG_REGISTER_DISABLE_SUCCESS, 
                    pParams->pszMachine);
    }

    return NO_ERROR;
}

//
// Handles requests register a ras server in a domain
// or to deregister a ras server in a domain or to query
// whether a given ras server is registered in a given domain.
//
DWORD APIENTRY
RaSrvMonitor (
    IN	int					argc,
	IN	TCHAR				*argv[],
	IN	PROUTEMON_PARAMS	params,
	IN	PROUTEMON_UTILS		utils
    )
{
    DWORD dwErr = NO_ERROR;
    RASRV_PARAMS RaSrvParams;
    HINSTANCE hInst = GetModuleHandle(NULL);

    RaSrvUsage(hInst, params, utils);

 /*
    dwErr = RaSrvParse (
                    argc, 
                    argv, 
                    params, 
                    utils, 
                    TRUE, 
                    &RaSrvParams);
    if (dwErr != NO_ERROR)                    
        return dwErr;

    RaSrvEngine (params, utils, &RaSrvParams);
    
    RaSrvCleanup(&RaSrvParams);
*/    
    
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\routemon\if.c ===
#include "precomp.h"

extern WCHAR IfNamBuffer[MaxIfDisplayLength];
DWORD IfNamBufferLength=1024;

ENUM_TO_STR     InterfaceTypes[] = {
    { ROUTER_IF_TYPE_CLIENT,        VAL_IFTYPE_CLIENT },
    { ROUTER_IF_TYPE_HOME_ROUTER,   VAL_IFTYPE_HOME_ROUTER },
    { ROUTER_IF_TYPE_FULL_ROUTER,   VAL_IFTYPE_FULL_ROUTER },
    { ROUTER_IF_TYPE_DEDICATED,     VAL_IFTYPE_DEDICATED },
    { ROUTER_IF_TYPE_INTERNAL,      VAL_IFTYPE_INTERNAL},
    { ROUTER_IF_TYPE_LOOPBACK,      VAL_IFTYPE_LOOPBACK},
    { ROUTER_IF_TYPE_TUNNEL1,       VAL_IFTYPE_TUNNEL1},
};

ENUM_TO_STR     InterfaceStates[] = {
    { ROUTER_IF_STATE_DISCONNECTED, VAL_IFSTATE_DISCONNECTED },
    { ROUTER_IF_STATE_CONNECTING, VAL_IFSTATE_CONNECTING },
    { ROUTER_IF_STATE_CONNECTED, VAL_IFSTATE_CONNECTED }
};

ENUM_TO_STR     InterfacePersistency[] = {
    { FALSE,    VAL_NO },
    { TRUE,     VAL_YES }
};

ENUM_TO_STR     InterfaceEnableStatus[] = {
    { FALSE,    VAL_ENABLED },
    { TRUE,     VAL_DISABLED }
};

ENUM_TO_STR     TransportIds[] = {
    { PID_IP,   TOKEN_IP },
    { PID_IPX,  TOKEN_IPX }
};

#define LOCAL_ROUTER_PB_PATHW  L"%SystemRoot%\\system32\\RAS\\Router.Pbk"
#define REMOTE_ROUTER_PB_PATHW L"\\\\%ls\\Admin$\\system32\\RAS\\Router.Pbk"

int
UpdateInterface (
    IN  LPTSTR              InterfaceName,
    IN  DWORD               pid
    );

int
CreateInterface (
    IN  INT                 argc,
    IN  LPTSTR              *argv
    );

int
DeleteInterface (
    IN  LPTSTR              InterfaceName
    );

int
SetInterface (
    IN  LPTSTR              InterfaceName,
    IN  LPTSTR              UserName,
    IN  LPTSTR              Domain,
    IN  LPTSTR              Password
    );

int
ConnectInterface (
    IN  LPTSTR              InterfaceName
    );

int
DisconnectInterface (
    IN  LPTSTR              InterfaceName
    );


int
EnableInterface(
    IN  LPTSTR              lpInterface,
    IN  BOOL                bEnable
);


int
ShowInterfaces (
    VOID
    );

int
ShowInterface (
    IN  LPTSTR              InterfaceName
    );

DWORD
IsPhoneBookEntry (
    LPWSTR  InterfaceName
    );

HINSTANCE           HIf;
PROUTEMON_PARAMS    pParams;
PROUTEMON_UTILS     pUtils;

#if defined( UNICODE ) || defined( _UNICODE )
#define PrintString( s )    wprintf( L"%ls\n", (s) )
#define PrintWord( w )      wprintf( L"%0x\n", (w) )

#else
#define PrintString( s )    _tprintf( TEXT( "%s\n" ), (s) )
#define PrintWord( w )      _tprintf( TEXT( "%0x\n" ), (w) )

#endif



//-----------------------------------------------------------------------------
// InterfaceMonitor
//
// Dispatches the command to the appropriate function.
//-----------------------------------------------------------------------------

int APIENTRY
InterfaceMonitor (
    IN  int                 argc,
    IN  TCHAR               *argv[],
    IN  PROUTEMON_PARAMS    params,
    IN  PROUTEMON_UTILS     utils
    ) {
    DWORD   res = 0;
    TCHAR   buffer[MAX_TOKEN];

    HIf = GetModuleHandle (NULL);
    pParams = params;
    pUtils = utils;

    if (argc>0) {
        if (_tcsicmp (argv[0], GetString (HIf, TOKEN_CREATE, buffer))==0) {
            if (argc>1)
                return CreateInterface (argc-1, &argv[1]);
            else
                res = ERROR_INVALID_PARAMETER;
        }
        else if (_tcsicmp (argv[0], GetString (HIf, TOKEN_DELETE, buffer))==0) {
            if (argc>1)
                return DeleteInterface (argv[1]);
            else
                res = ERROR_INVALID_PARAMETER;
        }
        else if (_tcsicmp (argv[0], GetString (HIf, TOKEN_SET, buffer))==0) {
            if (argc>4)
                return SetInterface (argv[1],argv[2],argv[3],argv[4]);
            else
                res = ERROR_INVALID_PARAMETER;
        }
        else if (_tcsicmp (argv[0], GetString (HIf, TOKEN_SHOW, buffer))==0) {
            if (argc>1)
                return ShowInterface (argv[1]);
            else
                return ShowInterfaces ();
        }
        else if (_tcsicmp (argv[0], GetString (HIf, TOKEN_CONNECT, buffer))==0) {
            if (argc>1)
                return ConnectInterface (argv[1]);
            else
                res = ERROR_INVALID_PARAMETER;
        }
        else if (_tcsicmp (argv[0], GetString (HIf, TOKEN_DISCONNECT, buffer))==0) {
            if (argc>1)
                return DisconnectInterface (argv[1]);
            else
                res = ERROR_INVALID_PARAMETER;
        }
        else if (_tcsicmp (argv[0], GetString (HIf, TOKEN_ENABLE, buffer))==0) {
            if ( argc > 1 )
                return EnableInterface (argv[1], TRUE);
            else
                res = ERROR_INVALID_PARAMETER;
        }
        else if (_tcsicmp (argv[0], GetString (HIf, TOKEN_DISABLE, buffer))==0) {
            if ( argc > 1 )
                return EnableInterface ( argv[1], FALSE );
            else
                res = ERROR_INVALID_PARAMETER;
        }
        else if (_tcsicmp (argv[0], GetString (HIf, TOKEN_UPDATE, buffer))==0) {
            DWORD   pid;
            if ((argc>2) && (GetValueFromString (HIf, pUtils, TransportIds, argv[2], &pid)))
                return UpdateInterface (argv[1], pid);
            else
                res = ERROR_INVALID_PARAMETER;
        }
        else if ((_tcsicmp (argv[0], GetString (HIf, TOKEN_HELP1, buffer))==0)
                || (_tcsicmp (argv[0], GetString (HIf, TOKEN_HELP2, buffer))==0)
                || (_tcsicmp (argv[0], GetString (HIf, TOKEN_HELP3, buffer))==0))
            NOTHING;
        else
            res = ERROR_INVALID_PARAMETER;
    }
    else
        res = ERROR_INVALID_PARAMETER;

    pUtils->put_msg (HIf, MSG_INTERFACE_HELP, pParams->pszProgramName);
    return res;
}


//-----------------------------------------------------------------------------
// CreateInterface
//
// Create a demand-dial interface
//-----------------------------------------------------------------------------

int
CreateInterface (
    IN  INT                 argc,
    IN  LPTSTR              *argv
    ) {

    MPR_INTERFACE_0     Ri0;
    HANDLE              hIfCfg;
    DWORD               rc, dwIfType;
    unsigned            count;
    TCHAR               buffer[MAX_TOKEN];
    ULONG               ulIfIndex;

    ZeroMemory(&Ri0,
               sizeof(Ri0));

    //
    // if there is only one argument, then it is the interface name
    // which may even be called TUNNEL1
    // if there is more than one argument, and the first is TUNNEL1, then
    // the next one is the interface name
    //

    ulIfIndex = 0;
    dwIfType  = ROUTER_IF_TYPE_FULL_ROUTER;

    if(argc > 1)
    {
        if(_tcsicmp(argv[0], GetString (HIf, TOKEN_TUNNEL1, buffer))==0)
        {
            ulIfIndex = 1;
            dwIfType  = ROUTER_IF_TYPE_TUNNEL1;

            Ri0.fEnabled = TRUE;
        }
    }

    //
    // convert interface name to unicode
    //
    
#if defined(UNICODE) || defined (_UNICODE)
    wcsncpy (Ri0.wszInterfaceName, argv[ulIfIndex],
            sizeof (Ri0.wszInterfaceName)/sizeof (Ri0.wszInterfaceName[0]));
    count = wcslen (argv[ulIfIndex]);
#else
    count = mbstowcs (Ri0.wszInterfaceName, argv[ulIfIndex],
                            sizeof (Ri0.wszInterfaceName));
#endif


    do
    {

        if ( count > MAX_INTERFACE_NAME_LEN )
        {
            rc = ERROR_INVALID_PARAMETER;
            break;
        }


        if(dwIfType == ROUTER_IF_TYPE_FULL_ROUTER)
        {
            //
            // to create an interface we need a phone book entry
            // for it.
            //

            rc = IsPhoneBookEntry (Ri0.wszInterfaceName);
            
            if ( rc != NO_ERROR )
            {
                break;
            }
        }


        //
        // create interface with defaults
        //
            
        Ri0.hInterface          = INVALID_HANDLE_VALUE;
        Ri0.dwIfType            = dwIfType;

        rc = MprConfigInterfaceCreate (
                pParams->hRouterConfig,
                0,
                (LPBYTE)&Ri0,
                &hIfCfg
             );
                        
        if ( rc != NO_ERROR )
        {
            break;
        }
                
        pUtils->put_msg (HIf, MSG_INTERFACE_CREATED, Ri0.wszInterfaceName);
                    

        //
        // if router service is running add the interface
        // to it too.
        //

        if ( pParams->hRouterAdmin ) {

            HANDLE  hIfAdmin;

            rc = MprAdminInterfaceCreate (
                    pParams->hRouterAdmin,
                    0,
                    (LPBYTE)&Ri0,
                    &hIfAdmin
                 );
                            
            if ( rc != NO_ERROR )
            {
                break;
            }

            pUtils->put_msg (HIf, MSG_INTERFACE_ADDED, Ri0.wszInterfaceName);
        }
        
    } while( FALSE );

    if ( rc != NO_ERROR ) { pUtils->put_error_msg (rc); }

    return rc;
}



//-----------------------------------------------------------------------------
// SetInterface
//
// sets the credentials to be used by an interface when dialing into
// a remote router.
//-----------------------------------------------------------------------------

int
SetInterface (
    IN  LPTSTR              InterfaceName,
    IN  LPTSTR              UserName,
    IN  LPTSTR              Domain,
    IN  LPTSTR              Password
    )
{

    HANDLE              hIfCfg      = NULL;

    DWORD               rc          = (DWORD) -1,
                        rc2         = 0,
                        dwSize      = 0;

    unsigned            ci          = 0,
                        cu          = 0,
                        cd          = 0,
                        cp          = 0;
    
    PMPR_INTERFACE_0    pRi0        = NULL;


    //
    // convert parameters to WCHAR
    //

#if defined(UNICODE) || defined (_UNICODE)

    #define pInterfaceName  InterfaceName
    #define pUserName       UserName
    #define pDomain         Domain
    #define pPassword       Password

    ci = wcslen (InterfaceName);
    cu = wcslen (UserName);
    cd = wcslen (Domain);
    cp = wcslen (Password);

#else

    WCHAR   InterfaceNameW[MAX_INTERFACE_NAME_LEN+1];
    WCHAR   UserNameW[257];
    WCHAR   DomainW[257];
    WCHAR   PasswordW[257];

    #define pInterfaceName  InterfaceNameW
    #define pUserName       UserNameW
    #define pDomain         DomainW
    #define pPassword       PasswordW

    ci = mbstowcs (InterfaceNameW, InterfaceName,  sizeof (InterfaceNameW));
    cu = mbstowcs (UserNameW, UserName,  sizeof (UserNameW));
    cd = mbstowcs (DomainW, Domain,  sizeof (DomainW));
    cp = mbstowcs (PasswordW, Password,  sizeof (PasswordW));

#endif


    //======================================
    // Translate the Interface Name
    //======================================
    rc2 = Description2IfNameW(pInterfaceName,
                              IfNamBuffer,
                              &IfNamBufferLength);
    //======================================


    do
    {
        //
        // verify parameters
        //

        if ( ( ci > MAX_INTERFACE_NAME_LEN )    ||
             ( cu > 256 )                       ||
             ( cd > 256 )                       ||
             ( cp > 256 ) )
        {
            rc = ERROR_INVALID_PARAMETER;
            break;
        }


        //
        // verify if the interface is a demand-dial interface
        // before setting credentials on it.
        //

        rc = MprConfigInterfaceGetHandle(
                pParams->hRouterConfig,
                (rc2 == NO_ERROR) ? IfNamBuffer : pInterfaceName,
                &hIfCfg
             );

        if ( rc != NO_ERROR )
        {
            break;
        }

        rc = MprConfigInterfaceGetInfo (
                pParams->hRouterConfig,
                hIfCfg,
                0,
                (LPBYTE *) &pRi0,
                &dwSize
             );

        if ( rc != NO_ERROR )
        {
            break;
        }

        if ( pRi0-> dwIfType != ROUTER_IF_TYPE_FULL_ROUTER )
        {
            rc = ERROR_INVALID_PARAMETER;
            break;
        }


        //
        // set the credentials in the router
        //

        rc = MprAdminInterfaceSetCredentials (
                pParams-> wszRouterName,
                (rc2 == NO_ERROR) ? IfNamBuffer : pInterfaceName,
                pUserName,
                pDomain,
                pPassword
             );

        if ( rc != NO_ERROR )
        {
            break;
        }

        pUtils->put_msg (HIf, MSG_INTERFACE_SET, (rc2 == NO_ERROR) ? IfNamBuffer : pInterfaceName);

    } while( FALSE );


    //
    // free allocations and report errors
    //

    if ( pRi0 ) { MprConfigBufferFree( pRi0 ); }

    if ( rc != NO_ERROR ) { pUtils-> put_error_msg( rc ); }

#undef pInterfaceName
#undef pUserName
#undef pDomain
#undef pPassword

    return rc;
}


//-----------------------------------------------------------------------------
// DeleteInterface
//
// Deletes a demand-dial Interface.
//-----------------------------------------------------------------------------

int
DeleteInterface (
    IN  LPTSTR              InterfaceName
    ) {
    HANDLE              hIfCfg;
    DWORD               rc, rc2;
    unsigned            count;
    PMPR_INTERFACE_0    pRi0;
    DWORD               sz;

#if defined(UNICODE) || defined (_UNICODE)
#define pInterfaceName InterfaceName
    count = wcslen (InterfaceName);
#else
    WCHAR   InterfaceNameW[MAX_INTERFACE_NAME_LEN+1];
#define pInterfaceName InterfaceNameW
    count = mbstowcs (InterfaceNameW, InterfaceName,  sizeof (InterfaceNameW));
#endif
//======================================
// Translate the Interface Name
//======================================
rc2 = Description2IfNameW(pInterfaceName,
                          IfNamBuffer,
                          &IfNamBufferLength);
//======================================

    if (count<=MAX_INTERFACE_NAME_LEN) {
        rc = MprConfigInterfaceGetHandle (
                    pParams->hRouterConfig,
                    (rc2 == NO_ERROR) ? IfNamBuffer : pInterfaceName,
                    &hIfCfg
                    );
        if (rc==NO_ERROR) {
            rc = MprConfigInterfaceGetInfo (
                    pParams->hRouterConfig,
                    hIfCfg,
                    0,
                    (LPBYTE *)&pRi0,
                    &sz);
            if (rc==NO_ERROR) {
                if((pRi0->dwIfType==ROUTER_IF_TYPE_FULL_ROUTER) ||
                   (pRi0->dwIfType==ROUTER_IF_TYPE_TUNNEL1))
                {
                    rc = MprConfigInterfaceDelete (
                                    pParams->hRouterConfig,
                                    hIfCfg);
                    if (rc==NO_ERROR) {
                        pUtils->put_msg (HIf, MSG_INTERFACE_DELETED, (rc2 == NO_ERROR) ? IfNamBuffer : pInterfaceName);
                        if (pParams->hRouterAdmin) {
                            HANDLE              hIfAdmin;
                            rc = MprAdminInterfaceGetHandle (
                                        pParams->hRouterAdmin,
                                        (rc2 == NO_ERROR) ? IfNamBuffer : pInterfaceName,
                                        &hIfAdmin,
                                        FALSE
                                        );
                            if (rc==NO_ERROR) {
                                rc = MprAdminInterfaceDelete (
                                        pParams->hRouterAdmin,
                                        hIfAdmin);
                                if (rc==NO_ERROR)
                                    pUtils->put_msg (HIf, MSG_INTERFACE_REMOVED, (rc2 == NO_ERROR) ? IfNamBuffer : pInterfaceName);
                            }
                        }
                    }
                }
                else
                    rc = ERROR_INVALID_PARAMETER;
                MprConfigBufferFree (pRi0);
            }
        }
    }
    else
    {
        rc = ERROR_INVALID_PARAMETER;
    }

    if ( rc != NO_ERROR )
    {
        pUtils->put_error_msg (rc);
    }

    return rc;

#undef pInterfaceName
}


//-----------------------------------------------------------------------------
// ShowInterfaces
//
// Display Interfaces on a router.
//-----------------------------------------------------------------------------

int
ShowInterfaces (
    VOID
    ) {
    DWORD               rc = NO_ERROR, rc2;
    DWORD               read, total, processed=0, i;
    DWORD               hResume = 0;
    PMPR_INTERFACE_0    pRi0;

    if (pParams->hRouterAdmin)
        pUtils->put_msg (HIf, MSG_INTERFACE_RTR_TABLE_HDR);
    else
        pUtils->put_msg (HIf, MSG_INTERFACE_CFG_TABLE_HDR);

    do {
        if (pParams->hRouterAdmin)
            rc = MprAdminInterfaceEnum (
                            pParams->hRouterAdmin,
                            0,
                            (LPBYTE *)&pRi0,
                            MAXULONG,
                            &read,
                            &total,
                            &hResume);
        else
            rc = MprConfigInterfaceEnum (
                            pParams->hRouterConfig,
                            0,
                            (LPBYTE *)&pRi0,
                            MAXULONG,
                            &read,
                            &total,
                            &hResume);
        if (rc==NO_ERROR) {
            for (i=0; i<read; i++) {
                TCHAR       buffer[3][MAX_VALUE];

                //======================================
                // Translate the Interface Name
                //======================================
                rc2 = IfName2DescriptionW(pRi0[i].wszInterfaceName,
                                          IfNamBuffer,
                                          &IfNamBufferLength);
                //======================================
                        
                if (pParams->hRouterAdmin)
                    pUtils->put_msg (HIf,
                            MSG_INTERFACE_RTR_TABLE_FMT,
                            GetValueString (HIf, pUtils, InterfaceEnableStatus,
                                        pRi0[i].fEnabled ? 0 : 1,
                                        buffer[1]),
                            GetValueString (HIf, pUtils, InterfaceStates,
                                        pRi0[i].dwConnectionState, buffer[2]),
                            GetValueString (HIf, pUtils, InterfaceTypes,
                                        pRi0[i].dwIfType, buffer[0]),
                            (rc2 == NO_ERROR) ? IfNamBuffer : pRi0[i].wszInterfaceName
                            );
                else
                    pUtils->put_msg (HIf,
                            MSG_INTERFACE_CFG_TABLE_FMT,
                            GetValueString (HIf, pUtils, InterfaceEnableStatus,
                                        pRi0[i].fEnabled ? 0 : 1,
                                        buffer[1]),
                            GetValueString (HIf, pUtils, InterfaceTypes,
                                        pRi0[i].dwIfType, buffer[0] ),
                            (rc2 == NO_ERROR) ? IfNamBuffer : pRi0[i].wszInterfaceName
                            );
            }
            processed += read;
            if (pParams->hRouterAdmin)
                MprAdminBufferFree (pRi0);
            else
                MprConfigBufferFree (pRi0);
        }
        else {
            pUtils->put_error_msg (rc);
        
            break;
        }
    }
    while (processed<total);

    return rc;
}


//-----------------------------------------------------------------------------
// ShowInterface
//
// Display data for a single interface
//-----------------------------------------------------------------------------

int
ShowInterface (
    IN  LPTSTR              InterfaceName
    ) {
    HANDLE              hIfCfg;
    HANDLE              hIfAdmin;
    DWORD               rc, rc2;
    unsigned            count;
    PMPR_INTERFACE_0    pRi0;
    DWORD               sz;

#if defined(UNICODE) || defined (_UNICODE)
#define pInterfaceName InterfaceName
    count = wcslen (InterfaceName);
#else
    WCHAR   InterfaceNameW[MAX_INTERFACE_NAME_LEN+1];
#define pInterfaceName InterfaceNameW
    count = mbstowcs (InterfaceNameW, InterfaceName,  sizeof (InterfaceNameW));
#endif


    //======================================
    // Translate the Interface Name
    //======================================
    rc2 = Description2IfNameW(pInterfaceName,
                              IfNamBuffer,
                              &IfNamBufferLength);
    //======================================

    if (count<=MAX_INTERFACE_NAME_LEN) {
        if (pParams->hRouterAdmin)
            rc = MprAdminInterfaceGetHandle (
                        pParams->hRouterAdmin,
                        (rc2 == NO_ERROR) ? IfNamBuffer : pInterfaceName,
                        &hIfAdmin,
                        FALSE
                        );
        else
            rc = MprConfigInterfaceGetHandle (
                        pParams->hRouterConfig,
                        (rc2 == NO_ERROR) ? IfNamBuffer : pInterfaceName,
                        &hIfCfg
                        );
        if (rc==NO_ERROR) {
            if (pParams->hRouterAdmin)
                rc = MprAdminInterfaceGetInfo (
                    pParams->hRouterAdmin,
                    hIfAdmin,
                    0,
                    (LPBYTE *)&pRi0);
            else
                rc = MprConfigInterfaceGetInfo (
                    pParams->hRouterConfig,
                    hIfCfg,
                    0,
                    (LPBYTE *)&pRi0,
                    &sz);
            if (rc==NO_ERROR) {
                TCHAR       buffer[3][MAX_VALUE];
                //======================================
                // Translate the Interface Name
                //======================================
                rc2 = IfName2DescriptionW(pRi0->wszInterfaceName,
                                          IfNamBuffer,
                                          &IfNamBufferLength);
                //======================================
                if (pParams->hRouterAdmin)
                    pUtils->put_msg (HIf,
                            MSG_INTERFACE_RTR_SCREEN_FMT,
                            (rc2 == NO_ERROR) ? IfNamBuffer : pRi0->wszInterfaceName,
                            GetValueString (HIf, pUtils, InterfaceTypes,
                                        pRi0->dwIfType, buffer[0]),
                            GetValueString (HIf, pUtils, InterfaceEnableStatus,
                                        pRi0-> fEnabled ? 0 : 1,
                                        buffer[1]),
                            GetValueString (HIf, pUtils, InterfaceStates,
                                        pRi0->dwConnectionState, buffer[2])
                            );
                else
                    pUtils->put_msg (HIf,
                            MSG_INTERFACE_CFG_SCREEN_FMT,
                            (rc2 == NO_ERROR) ? IfNamBuffer : pRi0->wszInterfaceName,
                            IfNamBuffer,
                            GetValueString (HIf, pUtils, InterfaceTypes,
                                        pRi0->dwIfType, buffer[0]),
                            GetValueString (HIf, pUtils, InterfaceEnableStatus,
                                        pRi0-> fEnabled ? 0 : 1,
                                        buffer[1])
                            );

            }
        }

        
        if ( rc != NO_ERROR )
        {
            pUtils->put_error_msg (rc);
        }

        return rc;
    }
    
    else
    {
        pUtils->put_msg (HIf, MSG_INVALID_INTERFACE_NAME);
        return ERROR_INVALID_PARAMETER;
    }
}


//-----------------------------------------------------------------------------
// UpdateInterface
//
// Initiate autostatic updates over an interface
//-----------------------------------------------------------------------------

int
UpdateInterface (
    IN  LPTSTR              InterfaceName,
    IN  DWORD               pid
    ) {
    if (pParams->hRouterAdmin) {
        HANDLE              hIfAdmin;
        DWORD               rc, rc2;
        unsigned            count;
        PMPR_INTERFACE_0    pRi0;

#if defined(UNICODE) || defined (_UNICODE)
#define pInterfaceName InterfaceName
        count = wcslen (InterfaceName);
#else
        WCHAR   InterfaceNameW[MAX_INTERFACE_NAME_LEN+1];
#define pInterfaceName InterfaceNameW
        count = mbstowcs (InterfaceNameW, InterfaceName,  sizeof (InterfaceNameW));
#endif


        //======================================
        // Translate the Interface Name
        //======================================
        rc2 = Description2IfNameW(pInterfaceName,
                                  IfNamBuffer,
                                  &IfNamBufferLength);
        //======================================

        if (count<=MAX_INTERFACE_NAME_LEN) {
            rc = MprAdminInterfaceGetHandle (
                        pParams->hRouterAdmin,
                        (rc2 == NO_ERROR) ? IfNamBuffer : pInterfaceName,
                        &hIfAdmin,
                        FALSE
                        );
            if (rc==NO_ERROR) {
                rc = MprAdminInterfaceGetInfo (
                    pParams->hRouterAdmin,
                    hIfAdmin,
                    0,
                    (LPBYTE *)&pRi0);
                if (rc==NO_ERROR) {
                    if (pRi0->dwIfType==ROUTER_IF_TYPE_FULL_ROUTER) {
                        HANDLE  hEvent = NULL;
                        if (pParams->fLocalRouter) {
                            hEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
                            if (hEvent==NULL) {
                                rc = GetLastError ();
                                goto Exit;
                            }
                        }
                        pUtils->put_msg (HIf, MSG_WAIT_FOR_UPDATE);
                        rc = MprAdminInterfaceUpdateRoutes (
                                pParams->hRouterAdmin,
                                hIfAdmin,
                                pid,
                                hEvent);
                        if (pParams->fLocalRouter) {
                            if (rc==PENDING) {
                                rc = WaitForSingleObject (hEvent, INFINITE);
                                ASSERT (rc==WAIT_OBJECT_0);
                            }
                            CloseHandle (hEvent);
                        }

                        if (rc==NO_ERROR) {
                           DWORD   result;
                           rc = MprAdminInterfaceQueryUpdateResult (
                                    pParams->hRouterAdmin,
                                    hIfAdmin,
                                    pid,
                                    &result);
                           if (rc==NO_ERROR)
                               rc = result;
                        }
                    }
                    else
                        rc = ERROR_INVALID_PARAMETER;
                Exit:
                    MprAdminBufferFree (pRi0);
                }
                if (rc == NO_ERROR) {
                    pUtils->put_msg (HIf, MSG_UPDATE_COMPLETED);
                    return rc;
                }
                else {
                    pUtils->put_error_msg (rc);
                    return rc;
                }
            }
            else {
                pUtils->put_error_msg (rc);
                return rc;
            }
        }
        else {
            pUtils->put_msg (HIf, MSG_INVALID_INTERFACE_NAME);
            return ERROR_INVALID_PARAMETER;
        }
    }
    else {
        pUtils->put_msg (HIf, MSG_ROUTER_NOT_RUNNING);
        return NO_ERROR;
    }
}


//-----------------------------------------------------------------------------
// ConnectInterface
//
// Initiate a connect on a demand-dial interface
//-----------------------------------------------------------------------------

int
ConnectInterface (
    IN  LPTSTR              InterfaceName
    ) {


    HANDLE              hIfAdmin = NULL;
    DWORD               rc = (DWORD) -1, rc2;
    unsigned            count = 0;
    PMPR_INTERFACE_0    pRi0 = NULL;

    
    //
    // convert interface name to unicode
    //

#if defined( UNICODE ) || defined( _UNICODE )

#define pInterfaceName InterfaceName

    count = wcslen (InterfaceName);

#else

    WCHAR   InterfaceNameW[MAX_INTERFACE_NAME_LEN+1];

#define pInterfaceName InterfaceNameW

    count = mbstowcs (
                InterfaceNameW,
                InterfaceName,
                sizeof (InterfaceNameW)
            );
#endif

    //======================================
    // Translate the Interface Name
    //======================================
    rc2 = Description2IfNameW(pInterfaceName,
                              IfNamBuffer,
                              &IfNamBufferLength);
    //======================================


    do
    {

        //
        // check if connected to router
        //

        if ( !pParams-> hRouterAdmin )
        {
            pUtils-> put_msg( HIf, MSG_ROUTER_NOT_RUNNING );
            break;
        }


        //
        // verify valid interface name
        //

        if ( count > MAX_INTERFACE_NAME_LEN )
        {
            pUtils-> put_msg( HIf, MSG_INVALID_INTERFACE_NAME );
            break;
        }


        //
        // verify that specified interface is a demand dial interface
        //

        rc = MprAdminInterfaceGetHandle (
                pParams->hRouterAdmin,
                (rc2 == NO_ERROR) ? IfNamBuffer : pInterfaceName,
                &hIfAdmin,
                FALSE
             );

        if ( rc != NO_ERROR )
        {
            pUtils-> put_error_msg( rc );
            break;
        }


        rc = MprAdminInterfaceGetInfo (
                pParams->hRouterAdmin,
                hIfAdmin,
                0,
                (LPBYTE *) &pRi0
             );

        if ( rc != NO_ERROR )
        {
            pUtils-> put_error_msg( rc );
            break;
        }


        if ( pRi0-> dwIfType != ROUTER_IF_TYPE_FULL_ROUTER )
        {
            pUtils-> put_msg( HIf, ERROR_INVALID_PARAMETER );
            break;
        }


        //
        // connect interface.
        //

        pUtils-> put_msg( HIf, MSG_WAIT_FOR_CONNECT );

        rc = MprAdminInterfaceConnect(
                pParams-> hRouterAdmin,
                hIfAdmin,
                NULL,
                TRUE
             );

        if ( rc != NO_ERROR && rc != PENDING )
        {
            pUtils-> put_error_msg( rc );
            break;
        }


        pUtils-> put_msg( HIf, MSG_CONNECT_COMPLETED );

        rc = NO_ERROR;

    } while( FALSE );


    //
    // clean up
    //

    if ( pRi0 ) { MprAdminBufferFree( pRi0 ); }

    return rc;


#if 0
    if (pParams->hRouterAdmin) {

        HANDLE              hIfAdmin;
        DWORD               rc;
        unsigned            count;
        PMPR_INTERFACE_0    pRi0;


#if defined(UNICODE) || defined (_UNICODE)
#define pInterfaceName InterfaceName
        count = wcslen (InterfaceName);
#else
        WCHAR   InterfaceNameW[MAX_INTERFACE_NAME_LEN+1];
#define pInterfaceName InterfaceNameW
        count = mbstowcs (InterfaceNameW, InterfaceName,  sizeof (InterfaceNameW));
#endif


        if (count<=MAX_INTERFACE_NAME_LEN) {
        
            rc = MprAdminInterfaceGetHandle (
                        pParams->hRouterAdmin,
                        (rc2 == NO_ERROR) ? IfNamBuffer : pInterfaceName,
                        &hIfAdmin,
                        FALSE
                        );
                        
            if (rc==NO_ERROR) {
        
                rc = MprAdminInterfaceGetInfo (
                    pParams->hRouterAdmin,
                    hIfAdmin,
                    0,
                    (LPBYTE *)&pRi0);
                    
                if (rc==NO_ERROR) {

                    if (pRi0->dwIfType==ROUTER_IF_TYPE_FULL_ROUTER) {

                        HANDLE  hEvent = NULL;

                        if (pParams->fLocalRouter) {
                            hEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
                            if (hEvent==NULL) {
                                rc = GetLastError ();
                                goto Exit;
                            }
                        }

                        pUtils->put_msg (HIf, MSG_WAIT_FOR_CONNECT);

                        rc = MprAdminInterfaceConnect (
                                pParams->hRouterAdmin,
                                hIfAdmin,
                                hEvent,
                                TRUE
                             );

                        if (pParams->fLocalRouter) {
                            if (rc==PENDING) {
                                rc = WaitForSingleObject (hEvent, INFINITE);
                                ASSERT (rc==WAIT_OBJECT_0);
                            }

                            CloseHandle (hEvent);
                        }
                    }
                    else
                        rc = ERROR_INVALID_PARAMETER;
                Exit:
                    MprAdminBufferFree (pRi0);
                }

                if (rc==NO_ERROR) {
                    pUtils->put_msg (HIf, MSG_CONNECT_COMPLETED);
                    return 0;
                }
                else {
                    pUtils->put_error_msg (rc);
                    return 1;
                }
            }
            else {
                pUtils->put_error_msg (rc);
                return 1;
            }
        }
        else {
            pUtils->put_msg (HIf, MSG_INVALID_INTERFACE_NAME);
            return 1;
        }
    }
    else {
        pUtils->put_msg (HIf, MSG_ROUTER_NOT_RUNNING);
        return 1;
    }
#endif

    
}


//-----------------------------------------------------------------------------
// DisconnectInterface
//
// Disconnect a demand-dial interface
//-----------------------------------------------------------------------------

int
DisconnectInterface (
    IN  LPTSTR              InterfaceName
    ) {
    if (pParams->hRouterAdmin) {
        HANDLE              hIfAdmin;
        DWORD               rc, rc2;
        unsigned            count;
        PMPR_INTERFACE_0    pRi0;

#if defined(UNICODE) || defined (_UNICODE)
#define pInterfaceName InterfaceName
        count = wcslen (InterfaceName);
#else
        WCHAR   InterfaceNameW[MAX_INTERFACE_NAME_LEN+1];
#define pInterfaceName InterfaceNameW
        count = mbstowcs (InterfaceNameW, InterfaceName,  sizeof (InterfaceNameW));
#endif

        //======================================
        // Translate the Interface Name
        //======================================
        rc2 = Description2IfNameW(pInterfaceName,
                                  IfNamBuffer,
                                  &IfNamBufferLength);
        //======================================

        if (count<=MAX_INTERFACE_NAME_LEN) {
            rc = MprAdminInterfaceGetHandle (
                        pParams->hRouterAdmin,
                        (rc2 == NO_ERROR) ? IfNamBuffer : pInterfaceName,
                        &hIfAdmin,
                        FALSE
                        );
            if (rc==NO_ERROR) {
                rc = MprAdminInterfaceGetInfo (
                    pParams->hRouterAdmin,
                    hIfAdmin,
                    0,
                    (LPBYTE *)&pRi0);
                if (rc==NO_ERROR) {
                    if (pRi0->dwIfType==ROUTER_IF_TYPE_FULL_ROUTER) {
                        rc = MprAdminInterfaceDisconnect (
                                pParams->hRouterAdmin,
                                hIfAdmin);
                    }
                    else
                        rc = ERROR_INVALID_PARAMETER;
                //Exit:
                    MprAdminBufferFree (pRi0);
                }
                if (rc==NO_ERROR) {
                    pUtils->put_msg (HIf, MSG_DISCONNECT_COMPLETED);
                    return rc;
                }
                else {
                    pUtils->put_error_msg (rc);
                    return rc;
                }
            }
            else {
                pUtils->put_error_msg (rc);
                return rc;
            }
        }
        else {
            pUtils->put_msg (HIf, MSG_INVALID_INTERFACE_NAME);
            return ERROR_INVALID_PARAMETER;
        }
    }
    else {
        pUtils->put_msg (HIf, MSG_ROUTER_NOT_RUNNING);
        return NO_ERROR;
    }
}


//-----------------------------------------------------------------------------
// EnableInterface
//
// Enable/disable a demand-dial interface.
//-----------------------------------------------------------------------------

int
EnableInterface(
    IN  LPTSTR      lpInterface,
    IN  BOOL        bEnable
)
{

    DWORD               dwCount     = 0,
                        dwSize      = 0,
                        rc2         = 0,
                        dwErr       = (DWORD) -1;

    HANDLE              hInterface  = NULL;

    PMPR_INTERFACE_0    pMprIf0     = NULL;


    //
    // convert interface name to Unicode
    //

#if defined( UNICODE ) || defined( _UNICODE )

    #define lpInterfaceName lpInterface

    dwCount = wcslen( lpInterface );

#else

    WCHAR   InterfaceNameW[MAX_INTERFACE_NAME_LEN+1];

    #define lpInterfaceName InterfaceNameW

    dwCount = mbstowcs (
                InterfaceNameW,
                lpInterface,
                sizeof( InterfaceNameW )
            );
#endif

    //======================================
    // Translate the Interface Name
    //======================================
    rc2 = Description2IfNameW(lpInterfaceName,
                              IfNamBuffer,
                              &IfNamBufferLength);
    //======================================

    //
    // Error break out loop
    //

    do
    {
        //
        // Update the enable flag in the router config
        //

        dwErr = MprConfigInterfaceGetHandle(
                    pParams-> hRouterConfig,
                    (rc2 == NO_ERROR) ? IfNamBuffer : lpInterfaceName,
                    &hInterface
                );

        if ( dwErr != NO_ERROR )
        {
            break;
        }


        dwErr = MprConfigInterfaceGetInfo(
                    pParams-> hRouterConfig,
                    hInterface,
                    0,
                    (LPBYTE *) &pMprIf0,
                    &dwSize
                );

        if ( dwErr != NO_ERROR )
        {
            break;
        }

        pMprIf0-> fEnabled = bEnable;


        dwErr = MprConfigInterfaceSetInfo(
                    pParams-> hRouterConfig,
                    hInterface,
                    0,
                    (LPBYTE) pMprIf0
                );

        if ( dwErr != NO_ERROR )
        {
            break;
        }


        //
        // if you have a handle to the router service, update
        // the interface in the router service as well.
        //

        if ( !pParams-> hRouterAdmin )
        {
            break;
        }


        dwErr = MprAdminInterfaceGetHandle(
                    pParams-> hRouterAdmin,
                    (rc2 == NO_ERROR) ? IfNamBuffer : lpInterfaceName,
                    &hInterface,
                    FALSE
                );

        if ( dwErr != NO_ERROR )
        {
            break;
        }


        dwErr = MprAdminInterfaceSetInfo(
                    pParams-> hRouterAdmin,
                    hInterface,
                    0,
                    (LPBYTE) pMprIf0
                );

        if ( dwErr != NO_ERROR )
        {
            break;
        }

    } while ( FALSE );


    if ( dwErr != NO_ERROR ) { pUtils-> put_error_msg( dwErr ); }

    if ( pMprIf0 ) { MprConfigBufferFree( pMprIf0 ); }

    return (int) dwErr;

}



typedef DWORD (*PRasValidateEntryName)(
    LPWSTR lpszPhonebook,   // pointer to full path and filename of phone-book file
    LPWSTR lpszEntry    // pointer to the entry name to validate
   );



//-----------------------------------------------------------------------------
// IsPhoneBookEntry
//
// Verify that a phone book entry is present for a specified interface
//-----------------------------------------------------------------------------

DWORD
IsPhoneBookEntry (
    LPWSTR  InterfaceNameW
    ) {

    
    HMODULE                     hRasApi32;
    PRasValidateEntryName       RasValidateEntryName;
    DWORD                       rc;
    WCHAR                       wszPbPath[MAX_PATH+1];


    //
    // get phone book path + file name
    //

    if ( pParams->fLocalRouter ) {
    
        rc = ExpandEnvironmentStringsW (
                LOCAL_ROUTER_PB_PATHW,
                wszPbPath,
                sizeof (wszPbPath)/sizeof (wszPbPath[0])
             );
    }

    else {

        rc = wsprintfW (wszPbPath, REMOTE_ROUTER_PB_PATHW, pParams->wszRouterName);
    }

    ASSERT (rc > 0);


    //
    // Load RASAPI32 DLL and call into it to verify specified
    // phone book entry
    //

    hRasApi32 = LoadLibrary ("RASAPI32.DLL");

    if (hRasApi32!=NULL) {

        RasValidateEntryName = (PRasValidateEntryName)
            GetProcAddress (
                hRasApi32,
                "RasValidateEntryNameW"
            );
        
        if ( RasValidateEntryName != NULL ) {

            rc = RasValidateEntryName (
                    wszPbPath,
                    InterfaceNameW
                 );
                
            if ( rc == NO_ERROR )
                rc = ERROR_CANNOT_FIND_PHONEBOOK_ENTRY;
                
            else if (rc == ERROR_ALREADY_EXISTS)
                rc = NO_ERROR;
        }
        else
            rc = GetLastError ();

        FreeLibrary (hRasApi32);
    }
    else
        rc = GetLastError ();

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\routemon\utils.c ===
#include "precomp.h"



UINT APIENTRY
get_str_id (
	ENUM_TO_STR		Array[],
	ULONG			ArraySz,
	ULONG			EnumVal
	) {
	ULONG	i;
	for (i=0; (i<ArraySz) && (Array->enumVal!=EnumVal); i++, Array++) ;
	if (i<ArraySz)
		return Array->strId;
	else
		return (UINT)(-1);
}

BOOL APIENTRY
get_enum_val (
	HINSTANCE		hModule,
	ENUM_TO_STR		Array[],
	ULONG			ArraySz,
	LPTSTR			String,
	PULONG			EnumVal
	) {
	ULONG	i;
	TCHAR	buffer[MAX_VALUE];

	for (i=0; (i<ArraySz) 
				&& (_tcsicmp (
						String,
						GetString (
							hModule,
							Array->strId,
							buffer
						)
					)!=0); i++, Array++) ;
	if (i<ArraySz) {
		*EnumVal = Array->enumVal;
		return TRUE;
	}
	else
		return FALSE;
}

ULONG APIENTRY
put_msg (
	HINSTANCE	hModule,
	UINT		MsgId,
    ... 
	) {
	DWORD				msglen;
	LPTSTR				vp;
	va_list				arglist;

	va_start (arglist, MsgId);

	msglen = FormatMessage(
				FORMAT_MESSAGE_FROM_HMODULE |
					FORMAT_MESSAGE_ALLOCATE_BUFFER,
				hModule,
				MsgId,
				MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
				(LPTSTR)&vp,
				0,
				&arglist);
	if (msglen != 0) {
		_fputts (vp, stdout);
		LocalFree(vp);
	}

	va_end (arglist);
	return msglen;
}

ULONG APIENTRY
put_str_msg (
	HINSTANCE	hModule,
	UINT		StrId,
    ... 
	) {
	DWORD				msglen;
	static TCHAR		buffer[MAX_STR_MESSAGE];
	LPTSTR				vp;
	va_list				arglist;

	va_start (arglist, StrId);

	msglen = FormatMessage(
				FORMAT_MESSAGE_FROM_STRING |
					FORMAT_MESSAGE_ALLOCATE_BUFFER,
				GetString (hModule,StrId,buffer),
				0,
				MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
				(LPTSTR)&vp,
				0,
				&arglist);
	if (msglen != 0) {
		_fputts (vp, stdout);
		LocalFree(vp);
	}

	va_end (arglist);
	return msglen;
}


ULONG APIENTRY
put_error_msg (
	DWORD				error
	) {
	LPWSTR		vp;
	DWORD		msglen;

	if ((msglen=FormatMessageW (
			FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_ALLOCATE_BUFFER,
			NULL,
			error,
			MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), //The user default language
			(LPWSTR)&vp,
			0,
			NULL))>0) {
		fputws (vp, stdout);
		LocalFree (vp);
		return msglen;
	}
	else if (MprAdminGetErrorString (error,	&vp)==NO_ERROR) {
		msglen = wcslen (vp);
		fputws (vp, stdout);
		MprAdminBufferFree (vp);
		return msglen;
	}
	else if (MprAdminGetErrorString (error,	&vp)==NO_ERROR) {
		msglen = wcslen (vp);
		fputws (vp, stdout);
		MprAdminBufferFree (vp);
		return msglen;
	}
	else 
		return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\routemon\routemon.c ===
#include "precomp.h"

#define MAX_MSG_LENGTH  512


VOID
OEMfprintf(
    IN  HANDLE  hHandle,
    IN  PWCHAR  pwszUnicode
    )
{
    PCHAR achOem;
    DWORD dwLen, dwWritten;

    dwLen = WideCharToMultiByte( CP_OEMCP,
                         0,
                         pwszUnicode,
                         -1,
                         NULL,
                         0,
                         NULL,
                         NULL );

    achOem = malloc(dwLen);

    if (achOem)
    {
        WideCharToMultiByte( CP_OEMCP,
                             0,
                             pwszUnicode,
                             -1,
                             achOem,
                             dwLen,
                             NULL,
                             NULL );

        WriteFile( hHandle, achOem, dwLen-1, &dwWritten, NULL );

        free(achOem);
    }
}

#define OEMprintf(pwszUnicode) \
    OEMfprintf( GetStdHandle(STD_OUTPUT_HANDLE), pwszUnicode)

int _cdecl
wmain (
	int		argc,
	WCHAR	*argv[]
	) 
{
    DWORD       dwMsglen;
    PWCHAR      pwszOutput;
    WCHAR       rgwcInput[MAX_MSG_LENGTH];

    pwszOutput = NULL;

    do
    {
        dwMsglen = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
                                  NULL,
                                  MSG_HELP,
                                  0L,
                                  (PWCHAR)&pwszOutput,
                                  0,
                                  NULL);

        if(dwMsglen == 0)
        {
            break;
        }

        OEMprintf(pwszOutput);

    }while(FALSE);


    if(pwszOutput)
    {
        LocalFree(pwszOutput);
    }


    return ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\routemon\loadsave.c ===
/*
    File:   LoadSave.c

    Handles routemon options to load and save router configuration.
*/

#include "precomp.h"

#define LOADSAVE_PATH_SIZE 512

// 
// Defines a macro to perform string copies to
// unicode strings regardless of the UNICODE setting.
//
#if defined( UNICODE ) || defined( _UNICODE )
#define LoadSaveStrcpy(dst, src) wcscpy((dst), (src));
#else
#define LoadSaveStrcpy(dst, src) mbstowcs((dst), (src), strlen((src)));
#endif

// 
// Defines structure of parameters that can be sent to 
// a load/save config call.
//
typedef struct _LOADSAVE_PARAMS {
    WCHAR pszPath[LOADSAVE_PATH_SIZE];
} LOADSAVE_PARAMS, * PLOADSAVE_PARAMS;

//
// Returns a static error message
//
PWCHAR LoadSaveError (DWORD dwErr) {   
    static WCHAR pszRet[512];

    ZeroMemory(pszRet, sizeof(pszRet));

    FormatMessageW (FORMAT_MESSAGE_FROM_SYSTEM, 
                    NULL, 
                    dwErr, 
                    0, 
                    pszRet, 
                    sizeof(pszRet) / sizeof(WCHAR), 
                    NULL);
                    
    return pszRet;                    
}    


//
// Parse the load save config command line and fills 
// the parameters accordingly.
//
DWORD LoadSaveParse (
        IN  int argc, 
        IN  TCHAR *argv[], 
    	IN  PROUTEMON_PARAMS pRmParams,
    	IN  PROUTEMON_UTILS pUtils,
        IN  BOOL bLoad,
        OUT LOADSAVE_PARAMS * pParams) 
{
    DWORD dwLen;

    // Initialize the return val
    ZeroMemory(pParams, sizeof(LOADSAVE_PARAMS));
    
    // Make sure a path has been provided
    if (argc == 0) {
    	pUtils->put_msg (GetModuleHandle(NULL), 
    	                 MSG_LOADSAVE_HELP, 
    	                 pRmParams->pszProgramName);
        return ERROR_CAN_NOT_COMPLETE;    	                 
    }
    
    // Copy over the path
    LoadSaveStrcpy (pParams->pszPath, argv[0]);

    // Add a '\' to the end of the path if not provided
    // dwLen = wcslen (pParams->pszPath);
    // if (pParams->pszPath[dwLen - 1] != L'\\') {
    //     pParams->pszPath[dwLen] = L'\\';
    //     pParams->pszPath[dwLen + 1] = (WCHAR)0;
    // }
        
    return NO_ERROR;
}

//
// The load/save engine
//
DWORD LoadSaveConfig (
        IN	PROUTEMON_PARAMS	pRmParams,
        IN	PROUTEMON_UTILS		pUtils,
        IN  PLOADSAVE_PARAMS    pLsParams,
        IN  BOOL                bLoad)
{
    DWORD dwErr;
    
    if (bLoad) 
        dwErr = MprConfigServerRestore (pRmParams->hRouterConfig, 
                                        pLsParams->pszPath);
    else
        dwErr = MprConfigServerBackup (pRmParams->hRouterConfig, 
                                        pLsParams->pszPath);

    return dwErr;            
}

//
// Handles request to load config
//
DWORD APIENTRY
LoadMonitor (
        IN	int					argc,
    	IN	TCHAR				*argv[],
    	IN	PROUTEMON_PARAMS	params,
    	IN	PROUTEMON_UTILS		utils
	    )
{
    DWORD dwErr;
    LOADSAVE_PARAMS LsParams;
    HINSTANCE hInst = GetModuleHandle(NULL);

    if ((dwErr = LoadSaveParse (argc, argv, params, 
                                utils, TRUE, &LsParams)) != NO_ERROR)
        return dwErr;

    dwErr = LoadSaveConfig (params, utils, &LsParams, TRUE);

    switch (dwErr) {
        case NO_ERROR:
            utils->put_msg(hInst, MSG_LOAD_SUCCESS, LsParams.pszPath);
            break;

        case ERROR_ROUTER_CONFIG_INCOMPATIBLE:
            utils->put_msg(hInst, MSG_LOAD_INCOMPATIBLE, LsParams.pszPath);
            break;

        case ERROR_ACCESS_DENIED:
            utils->put_msg(hInst, MSG_LOAD_FAIL_ACCESSDENIED);
            
        default:
            utils->put_msg(
                hInst, 
                MSG_LOAD_FAIL, 
                LsParams.pszPath, 
                LoadSaveError(dwErr));
            break;
    }            
    
    return dwErr;
}

// 
// Handles request to save config
//
DWORD APIENTRY
SaveMonitor (
        IN	int					argc,
    	IN	TCHAR				*argv[],
    	IN	PROUTEMON_PARAMS	params,
    	IN	PROUTEMON_UTILS		utils
	    )
{
    DWORD dwErr;
    LOADSAVE_PARAMS LsParams;

    if ((dwErr = LoadSaveParse (argc, argv, params, 
                                utils, FALSE, &LsParams)) != NO_ERROR)
        return dwErr;

    dwErr = LoadSaveConfig (params, utils, &LsParams, FALSE);

    if (dwErr == NO_ERROR)
        utils->put_msg(GetModuleHandle(NULL), MSG_SAVE_SUCCESS, LsParams.pszPath);
    else
        utils->put_msg(GetModuleHandle(NULL), MSG_SAVE_FAIL, LsParams.pszPath, LoadSaveError(dwErr));
    
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\routemon\user.c ===
/*
    File:   user.c

    Handles routemon options to get and set RAS user properties.
*/

#include "precomp.h"

#define NT40_BUILD_NUMBER       1381
const WCHAR pszBuildNumPath[]  =
    L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion";
const WCHAR pszBuildVal[]      = L"CurrentBuildNumber";

// 
// Defines a macro to perform string copies to
// unicode strings regardless of the UNICODE setting.
//
#if defined( UNICODE ) || defined( _UNICODE )
#define UserStrcpy(dst, src) wcscpy((dst), (src));
#else
#define UserStrcpy(dst, src) mbstowcs((dst), (src), strlen((src)));
#endif

// 
// Defines structure of parameters that can be sent to 
// a User api's.
//
typedef struct _USER_PARAMS {
    PWCHAR pszMachine;           // Given machine
    DWORD dwToken;               // Token designating the desired command
    WCHAR pszAccount[1024];      // The account in question
    BOOL bPolicySpecified;       // Whether policy given on cmd line
    DWORD dwTokenPolicy;         // Specifies the token for the callback policy
    RAS_USER_0 UserInfo;         // Buffer to hold user info
} USER_PARAMS, * PUSER_PARAMS;

//
// Determines the role of the given computer (NTW, NTS, NTS DC, etc.)
//
DWORD UserGetMachineRole(
        IN  PWCHAR pszMachine,
        OUT DSROLE_MACHINE_ROLE * peRole) 
{
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pGlobalDomainInfo = NULL;
    DWORD dwErr;

    if (!peRole)
        return ERROR_INVALID_PARAMETER;

    //
    // Get the name of the domain this machine is a member of
    //
    __try {
        dwErr = DsRoleGetPrimaryDomainInformation(
                            pszMachine,   
                            DsRolePrimaryDomainInfoBasic,
                            (LPBYTE *)&pGlobalDomainInfo );

        if (dwErr != NO_ERROR) 
            return dwErr;

        *peRole = pGlobalDomainInfo->MachineRole;
    }        

    __finally {
        if (pGlobalDomainInfo)
            DsRoleFreeMemory (pGlobalDomainInfo);
    }            

    return NO_ERROR;
}    

//
// Determines the build number of a given machine
//
DWORD UserGetNtosBuildNumber(
        IN  PWCHAR pszMachine,
        OUT LPDWORD lpdwBuild)
{
    WCHAR pszComputer[1024], pszBuf[64];
    HKEY hkBuild = NULL, hkMachine = NULL;
    DWORD dwErr, dwType = REG_SZ, dwSize = sizeof(pszBuf);

    __try {
        if (pszMachine) {
            if (*pszMachine != L'\\')
                wsprintfW(pszComputer, L"\\\\%s", pszMachine);
            else
                wcscpy(pszComputer, pszMachine);
            dwErr = RegConnectRegistryW (pszComputer,
                                        HKEY_LOCAL_MACHINE,
                                        &hkMachine);
            if (dwErr != ERROR_SUCCESS)
                return dwErr;
        }
        else    
            hkMachine = HKEY_LOCAL_MACHINE;

        // Open the build number key
        dwErr = RegOpenKeyExW ( hkMachine,
                               pszBuildNumPath,
                               0,
                               KEY_READ,
                               &hkBuild);
        if (dwErr != ERROR_SUCCESS)
            return dwErr;

        // Get the value
        dwErr = RegQueryValueExW ( hkBuild,
                                   pszBuildVal,
                                   NULL,
                                   &dwType,
                                   (LPBYTE)pszBuf,
                                   &dwSize);
        if (dwErr != ERROR_SUCCESS)
            return dwErr;

        *lpdwBuild = (DWORD) _wtoi(pszBuf);
    }
    __finally {
        if (hkMachine && pszMachine)
            RegCloseKey(hkMachine);
        if (hkBuild)
            RegCloseKey(hkBuild);
    }

    return NO_ERROR;
}


//
// Returns a static error message
//
PWCHAR UserError (DWORD dwErr) {   
    static WCHAR pszRet[512];

    ZeroMemory(pszRet, sizeof(pszRet));

    FormatMessageW (FORMAT_MESSAGE_FROM_SYSTEM, 
                    NULL, 
                    dwErr, 
                    0, 
                    pszRet, 
                    sizeof(pszRet) / sizeof(WCHAR), 
                    NULL);
                    
    return pszRet;                    
}    

//
// Displays usage and returns a generic error.
//
DWORD UserUsage(
        IN  HINSTANCE hInst,
    	IN  PROUTEMON_PARAMS pRmParams,
    	IN  PROUTEMON_UTILS pUtils)
{
	pUtils->put_msg (hInst, 
	                 MSG_USER_HELP, 
	                 pRmParams->pszProgramName);
	                 
    return ERROR_CAN_NOT_COMPLETE;    	                 
}

//
// Parses the register command line and fills 
// the parameters accordingly.
//
DWORD UserParse (
        IN  int argc, 
        IN  TCHAR *argv[], 
    	IN  PROUTEMON_PARAMS pRmParams,
    	IN  PROUTEMON_UTILS pUtils,
        IN  BOOL bLoad,
        OUT USER_PARAMS * pParams) 
{
    DWORD dwSize, dwErr;
    BOOL bValidCmd = FALSE;
    HINSTANCE hInst = GetModuleHandle(NULL);
	TCHAR buf[MAX_TOKEN];
    
    // Initialize the return val
    ZeroMemory(pParams, sizeof(USER_PARAMS));

    // Parse out the name of the computer
    if (pRmParams->wszRouterName[0])
        pParams->pszMachine = (PWCHAR)&(pRmParams->wszRouterName[0]);

    // Make sure some command was issued
    if (argc == 0) 
        return UserUsage(hInst, pRmParams, pUtils);
        
    // Parse out the command
	if (_tcsicmp(argv[0], GetString (hInst, TOKEN_ENABLE, buf))==0) {
	    pParams->dwToken = TOKEN_ENABLE;
	    if (argc == 1)
    	    return UserUsage(hInst, pRmParams, pUtils);
        UserStrcpy(pParams->pszAccount, argv[1]);    	    

        // Optional setting of callback policy and number
        if (argc > 2) {
            pParams->bPolicySpecified = TRUE;
        	if (_tcsicmp(argv[2], GetString (hInst, TOKEN_NONE, buf))==0)
        	    pParams->dwTokenPolicy = TOKEN_NONE;
        	else if (_tcsicmp(argv[2], GetString (hInst, TOKEN_CALLER, buf))==0)
        	    pParams->dwTokenPolicy = TOKEN_CALLER;
        	else if (_tcsicmp(argv[2], GetString (hInst, TOKEN_ADMIN, buf))==0)
        	    pParams->dwTokenPolicy = TOKEN_ADMIN;

        	if ((pParams->dwTokenPolicy == TOKEN_ADMIN) &&
        	    (argc < 3))
        	{
                return UserUsage(hInst, pRmParams, pUtils);
        	}
        	else if (pParams->dwTokenPolicy == TOKEN_ADMIN) {
        	    UserStrcpy(pParams->UserInfo.wszPhoneNumber, argv[3]);
        	}
        }
	}
	else if (_tcsicmp(argv[0], GetString (hInst, TOKEN_DISABLE, buf))==0) {
	    pParams->dwToken = TOKEN_DISABLE;
	    if (argc == 1)
    	    return UserUsage(hInst, pRmParams, pUtils);
        UserStrcpy(pParams->pszAccount, argv[1]);    	    
	}
	else if (_tcsicmp(argv[0], GetString (hInst, TOKEN_SHOW, buf))==0) {
	    pParams->dwToken = TOKEN_SHOW;
	    if (argc == 1)
    	    return UserUsage(hInst, pRmParams, pUtils);
        UserStrcpy(pParams->pszAccount, argv[1]);    	    
	}
	else if (_tcsicmp(argv[0], GetString (hInst, TOKEN_UPGRADE, buf))==0) {
	    pParams->dwToken = TOKEN_UPGRADE;
	}
	else 
	    return UserUsage(hInst, pRmParams, pUtils);

    return NO_ERROR;
}

// 
// Cleans up any User parameters
//
DWORD UserCleanup (
        IN PUSER_PARAMS pParams) 
{
    if (pParams->pszMachine)
        free(pParams->pszMachine);
        
    return NO_ERROR;
}

//
// Gets user info
//
DWORD UserGetInfo (
        IN  PWCHAR lpszServer,
        IN  PWCHAR lpszUser,
        IN  DWORD dwLevel,
        OUT LPBYTE lpbBuffer)
{
    DWORD dwErr, dwBuild;

    // Find out the OS of the given machine.
    dwErr = UserGetNtosBuildNumber(
                lpszServer, 
                &dwBuild);
    if (dwErr != NO_ERROR)
        return dwErr;

    // If the target machine is nt4, use nt4 userparms
    if (dwBuild <= NT40_BUILD_NUMBER) {
        return MprAdminUserGetInfo(
                    lpszServer, 
                    lpszUser, 
                    dwLevel, 
                    lpbBuffer);
    }                    

    // Otherwise, use SDO's
    else {
        HANDLE hServer, hUser;

        dwErr = MprAdminUserServerConnect(
                    lpszServer,
                    TRUE,
                    &hServer);
        if (dwErr != NO_ERROR)
            return dwErr;

        dwErr = MprAdminUserOpen(
                    hServer,
                    lpszUser, 
                    &hUser);
        if (dwErr != NO_ERROR) {
            MprAdminUserServerDisconnect(hServer);
            return dwErr;
        }

        dwErr = MprAdminUserRead(
                    hUser,
                    dwLevel,
                    lpbBuffer);
        if (dwErr != NO_ERROR) {
            MprAdminUserClose(hUser);
            MprAdminUserServerDisconnect(hServer);
            return dwErr;
        }

        MprAdminUserClose(hUser);
        MprAdminUserServerDisconnect(hServer);
    }

    return NO_ERROR;
}
      
//
// Sets user info
//
DWORD UserSetInfo (
        IN  PWCHAR lpszServer,
        IN  PWCHAR lpszUser,
        IN  DWORD dwLevel,
        OUT LPBYTE lpbBuffer)
{
    DWORD dwErr, dwBuild;

    // Find out the OS of the given machine.
    dwErr = UserGetNtosBuildNumber(
                lpszServer, 
                &dwBuild);
    if (dwErr != NO_ERROR)
        return dwErr;

    // If the target machine is nt4, use nt4 userparms
    if (dwBuild <= NT40_BUILD_NUMBER) {
        return MprAdminUserSetInfo(
                    lpszServer, 
                    lpszUser, 
                    dwLevel, 
                    lpbBuffer);
    }                    

    // Otherwise, use SDO's
    else {
        HANDLE hServer, hUser;

        dwErr = MprAdminUserServerConnect(
                    lpszServer,
                    TRUE,
                    &hServer);
        if (dwErr != NO_ERROR)
            return dwErr;

        dwErr = MprAdminUserOpen(
                    hServer,
                    lpszUser, 
                    &hUser);
        if (dwErr != NO_ERROR) {
            MprAdminUserServerDisconnect(hServer);
            return dwErr;
        }

        dwErr = MprAdminUserWrite(
                    hUser,
                    dwLevel,
                    lpbBuffer);
        if (dwErr != NO_ERROR) {
            MprAdminUserClose(hUser);
            MprAdminUserServerDisconnect(hServer);
            return dwErr;
        }

        MprAdminUserClose(hUser);
        MprAdminUserServerDisconnect(hServer);
    }

    return NO_ERROR;
}

// 
// Enables or disables a user
//
DWORD UserEnableDisable(
        IN	PROUTEMON_PARAMS pRmParams,
        IN	PROUTEMON_UTILS pUtils,
        IN  PUSER_PARAMS pParams)
{
    DWORD dwErr;

    // Read in the old user properties if all the options
    // weren't specified on the command line.
    if (pParams->dwTokenPolicy != TOKEN_ADMIN) {
        dwErr = UserGetInfo(
                    pParams->pszMachine,
                    pParams->pszAccount,
                    0,
                    (LPBYTE)&(pParams->UserInfo));
        if (dwErr != NO_ERROR)
            return dwErr;
    }

    // Set the dialin policy 
    if (pParams->dwToken == TOKEN_ENABLE)
        pParams->UserInfo.bfPrivilege |= RASPRIV_DialinPrivilege;
    else         
        pParams->UserInfo.bfPrivilege &= ~RASPRIV_DialinPrivilege;

    // Set the callback policy.  The callback number will already 
    // be set through the parsing.
    if (pParams->bPolicySpecified) {
        // Initialize
        pParams->UserInfo.bfPrivilege &= ~RASPRIV_NoCallback;
        pParams->UserInfo.bfPrivilege &= ~RASPRIV_CallerSetCallback;
        pParams->UserInfo.bfPrivilege &= ~RASPRIV_AdminSetCallback;

        // Set
        if (pParams->dwTokenPolicy == TOKEN_NONE)
            pParams->UserInfo.bfPrivilege |= RASPRIV_NoCallback;
        else if (pParams->dwTokenPolicy == TOKEN_CALLER)
            pParams->UserInfo.bfPrivilege |= RASPRIV_CallerSetCallback;
        else
            pParams->UserInfo.bfPrivilege |= RASPRIV_AdminSetCallback;
    }         

    // Otherwise, initialize the display token
    else {
        if (pParams->UserInfo.bfPrivilege & RASPRIV_NoCallback)
            pParams->dwTokenPolicy = TOKEN_NONE;
        else if (pParams->UserInfo.bfPrivilege & RASPRIV_CallerSetCallback)
            pParams->dwTokenPolicy = TOKEN_CALLER;
        else
            pParams->dwTokenPolicy = TOKEN_ADMIN;
    }

    // Commit the changes to the system
    dwErr = UserSetInfo(
                pParams->pszMachine,
                pParams->pszAccount,
                0,
                (LPBYTE)&(pParams->UserInfo));
    if (dwErr != NO_ERROR)
        return dwErr;

    // Print out the results
    {
        HINSTANCE hInst = GetModuleHandle(NULL);
    	TCHAR buf1[MAX_TOKEN], buf2[MAX_TOKEN];
    	DWORD dwYesNo;

    	dwYesNo = (pParams->dwToken == TOKEN_ENABLE) ? VAL_YES : VAL_NO;
    	
        pUtils->put_msg(
                hInst,
                MSG_USER_ENABLEDISABLE_SUCCESS, 
                pParams->pszAccount,
                GetString (hInst, dwYesNo, buf1),
                GetString (hInst, pParams->dwTokenPolicy, buf2),
                pParams->UserInfo.wszPhoneNumber
                );
    }                
    
    return NO_ERROR;
}

//
// Shows a user
// 
DWORD UserShow(
        IN	PROUTEMON_PARAMS pRmParams,
        IN	PROUTEMON_UTILS pUtils,
        IN  PUSER_PARAMS pParams)
{
    DWORD dwErr;
    
    dwErr = UserGetInfo(
                pParams->pszMachine,
                pParams->pszAccount,
                0,
                (LPBYTE)&(pParams->UserInfo));
    if (dwErr != NO_ERROR)
        return dwErr;

    // Print out the results
    {
        HINSTANCE hInst = GetModuleHandle(NULL);
    	TCHAR buf1[MAX_TOKEN], buf2[MAX_TOKEN];
    	DWORD dwTknEnable, dwTknPolicy;

        dwTknEnable = (pParams->UserInfo.bfPrivilege & RASPRIV_DialinPrivilege) ?
                      VAL_YES : 
                      VAL_NO;

        if (pParams->UserInfo.bfPrivilege & RASPRIV_NoCallback)
            dwTknPolicy = TOKEN_NONE;
        else if (pParams->UserInfo.bfPrivilege & RASPRIV_CallerSetCallback)
            dwTknPolicy = TOKEN_CALLER;
        else
            dwTknPolicy = TOKEN_ADMIN;
    	
        pUtils->put_msg(
                hInst,
                MSG_USER_SHOW_SUCCESS, 
                pParams->pszAccount,
                GetString (hInst, dwTknEnable, buf1),
                GetString (hInst, dwTknPolicy, buf2),
                pParams->UserInfo.wszPhoneNumber
                );
    }                
    
    return NO_ERROR;
}

// 
// Upgrades a user
//
DWORD UserUpgrade(
        IN	PROUTEMON_PARAMS pRmParams,
        IN	PROUTEMON_UTILS pUtils,
        IN  PUSER_PARAMS pParams)
{
    BOOL bLocal = FALSE;
    DWORD dwErr, dwBuild;
    DSROLE_MACHINE_ROLE eRole;

    // Determine whether this should be local or 
    // domain upgrade.
    dwErr = UserGetNtosBuildNumber(pParams->pszMachine, &dwBuild);
    if (dwErr != NO_ERROR)
        return dwErr;

    // You can upgrade nt4->nt4
    if (dwBuild <= NT40_BUILD_NUMBER)
        return ERROR_CAN_NOT_COMPLETE;

    // Find out the role of the machine
    dwErr = UserGetMachineRole(pParams->pszMachine, &eRole);
    if (dwErr != NO_ERROR)
        return dwErr;

    // Now we know whether we're local
    bLocal = ((eRole != DsRole_RoleBackupDomainController) &&
              (eRole != DsRole_RolePrimaryDomainController));


    // Upgrade the users
    dwErr = MprAdminUpgradeUsers(pParams->pszMachine, bLocal);
    if (dwErr != NO_ERROR)
        return dwErr;

    // Print out the results
    {
        HINSTANCE hInst = GetModuleHandle(NULL);
    	TCHAR buf[MAX_TOKEN];
    	DWORD dwToken;

    	dwToken = (bLocal) ? VAL_LOCAL : VAL_DOMAIN;

        pUtils->put_msg(
                hInst,
                MSG_USER_UPGRADE_SUCCESS, 
                GetString(hInst, dwToken, buf)
                );
    }                
    
    return NO_ERROR;
}

//
// The User functionality engine
//
DWORD UserEngine (
        IN	PROUTEMON_PARAMS pRmParams,
        IN	PROUTEMON_UTILS pUtils,
        IN  PUSER_PARAMS pParams)
{
    DWORD dwErr;
    HINSTANCE hInst = GetModuleHandle(NULL);

    switch (pParams->dwToken) {
        case TOKEN_ENABLE:
        case TOKEN_DISABLE:
            return UserEnableDisable(pRmParams, pUtils, pParams);
        case TOKEN_SHOW:
            return UserShow(pRmParams, pUtils, pParams);
        case TOKEN_UPGRADE:
            return UserUpgrade(pRmParams, pUtils, pParams);
    }
    
    return NO_ERROR;
}

//
// Handles requests register a ras server in a domain
// or to deregister a ras server in a domain or to query
// whether a given ras server is registered in a given domain.
//
DWORD APIENTRY
UserMonitor (
    IN	int					argc,
	IN	TCHAR				*argv[],
	IN	PROUTEMON_PARAMS	params,
	IN	PROUTEMON_UTILS		utils
    )
{
    DWORD dwErr;
    USER_PARAMS UserParams;

    dwErr = UserParse (
                    argc, 
                    argv, 
                    params, 
                    utils, 
                    TRUE, 
                    &UserParams);
    if (dwErr != NO_ERROR)                    
        return NO_ERROR;

    dwErr = UserEngine (params, utils, &UserParams);
    
    UserCleanup(&UserParams);
    
    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtm\enumdlg.h ===
#define IDD_ENUMERATION             300
#define IDG_CRITERIA_E              301
#define IDC_PROTOCOL_FAMILY_E       302
#define IDC_INTERFACE_E             303
#define IDE_INTERFACE_E             304
#define IDC_PROTOCOL_E              305
#define IDE_PROTOCOL_E              306
#define IDC_NETWORK_E               307
#define IDE_NETWORK_E               308
#define IDC_BESTROUTES_E            309
#define IDG_RESULT_E                310
#define IDL_ROUTE_E                 311
#define IDG_BUTTONS_E               312
#define IDB_CREATEDELETE_E          313
#define IDB_GETFIRST_E              314
#define IDB_GETNEXT_E               315
#define IDB_GETBEST_E               316
#define IDL_AGESEC_E                319
#define IDG_TIMESTAMP_E             320
#define IDL_TIMELOW_E               322
#define IDB_GETAGE_E                318
#define IDG_ROUTEAGE_E              317
#define IDL_TIMEHIGH_E              321
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtm\cldlg.h ===
#define IDD_RTM_CLIENT              200
#define IDG_REGISTRATION_C          201
#define IDC_PROTOCOL_FAMILY_C       202
#define IDE_ROUTING_PROTOCOL_C      203
#define IDB_REGISTER_OP_C           204
#define IDG_CLIENT_OPERATION_C      205
#define IDE_NET_NUMBER_C            206
#define IDE_NEXT_HOP_C              207
#define IDE_INTERFACE_C             208
#define IDE_METRIC_C                209
#define IDE_TIMEOUT_C               210
#define IDL_MESSAGE_FLAGS_C         212
#define IDB_DO_IT_C                 213
#define IDG_REQUEST_C               214
#define IDR_ADD_C                   215
#define IDR_DELETE_C                216
#define IDR_DEQUEUE_C               217
#define IDR_DISABLE_C               218
#define IDR_ENABLE_C                219
#define IDL_ROUTING_PROTOCOL_C      211
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtm\pchrtm.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: pchmgm.h
//
// History:
//      V Raman	Oct-14-1997  Created.
//
// Pre compiled header for MGM
//============================================================================


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <rtm.h>
#include <rtutils.h>
#include "rmrtm.h"
#include "rtmp.h"
#include "rtmv1rtm.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtm\rtdlg.h ===
#define IDD_RTM_TABLE               100
#define IDD_CLIENT                  200
#define IDT_TICK_COUNT              103
#define IDL_ROUTES                  102
#define IDC_PROTOCOL_FAMILY         101
#define IDB_RESYNC                  104
#define IDT_EXPIRATION              107
#define IDT_UPDATE                  108
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtm\rtmdbg.h ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    rtmdbg.h

Abstract:
    Debugging in Routing Table Manager DLL

--*/

#ifndef __ROUTING_RTMDBG_H__
#define __ROUTING_RTMDBG_H__

//
// Constants used for tracing
//

#define RTM_TRACE_ANY             ((DWORD)0xFFFF0000 | TRACE_USE_MASK)
#define RTM_TRACE_ERR             ((DWORD)0x00010000 | TRACE_USE_MASK)
#define RTM_TRACE_ENTER           ((DWORD)0x00020000 | TRACE_USE_MASK)
#define RTM_TRACE_LEAVE           ((DWORD)0x00040000 | TRACE_USE_MASK)
#define RTM_TRACE_LOCK            ((DWORD)0x00080000 | TRACE_USE_MASK)
#define RTM_TRACE_REFS            ((DWORD)0x00100000 | TRACE_USE_MASK)
#define RTM_TRACE_HANDLE          ((DWORD)0x00200000 | TRACE_USE_MASK)
#define RTM_TRACE_MEMORY          ((DWORD)0x00400000 | TRACE_USE_MASK)
#define RTM_TRACE_START           ((DWORD)0x00800000 | TRACE_USE_MASK)
#define RTM_TRACE_STOP            ((DWORD)0x01000000 | TRACE_USE_MASK)
#define RTM_TRACE_REGNS           ((DWORD)0x02000000 | TRACE_USE_MASK)
#define RTM_TRACE_ROUTE           ((DWORD)0x04000000 | TRACE_USE_MASK)
#define RTM_TRACE_QUERY           ((DWORD)0x08000000 | TRACE_USE_MASK)
#define RTM_TRACE_ENUM            ((DWORD)0x10000000 | TRACE_USE_MASK)
#define RTM_TRACE_NOTIFY          ((DWORD)0x20000000 | TRACE_USE_MASK)
#define RTM_TRACE_TIMER           ((DWORD)0x40080000 | TRACE_USE_MASK)
#define RTM_TRACE_CALLBACK        ((DWORD)0x80000000 | TRACE_USE_MASK)

//
// Macros used for tracing 
//

extern  DWORD               TracingInited;

extern  ULONG               TracingHandle;

#define TRACEHANDLE         TracingHandle

#define START_TRACING()                                             \
            if (InterlockedExchange(&TracingInited, TRUE) == FALSE) \
            {                                                       \
                TRACEHANDLE = TraceRegister("RTMv1");               \
            }                                                       \
            
#define STOP_TRACING()      TraceDeregister(TRACEHANDLE)

#define Trace0(l,a)             \
            TracePrintfEx(TRACEHANDLE, RTM_TRACE_ ## l, a)
#define Trace1(l,a,b)           \
            TracePrintfEx(TRACEHANDLE, RTM_TRACE_ ## l, a, b)
#define Trace2(l,a,b,c)         \
            TracePrintfEx(TRACEHANDLE, RTM_TRACE_ ## l, a, b, c)
#define Trace3(l,a,b,c,d)       \
            TracePrintfEx(TRACEHANDLE, RTM_TRACE_ ## l, a, b, c, d)
#define Trace4(l,a,b,c,d,e)     \
            TracePrintfEx(TRACEHANDLE, RTM_TRACE_ ## l, a, b, c, d, e)
#define Trace5(l,a,b,c,d,e,f)   \
            TracePrintfEx(TRACEHANDLE, RTM_TRACE_ ## l, a, b, c, d, e, f)
#define Trace6(l,a,b,c,d,e,f,g) \
            TracePrintfEx(TRACEHANDLE, RTM_TRACE_ ## l, a, b, c, d, e, f, g)

#define Tracedump(l,a,b,c)      \
            TraceDumpEx(TRACEHANDLE,l,a,b,c,TRUE)

#if DBG_CAL

#define TraceEnter(X)    Trace0(ENTER, "Entered: "X)
#define TraceLeave(X)    Trace0(LEAVE, "Leaving: "X"\n")

#else

#define TraceEnter(X)
#define TraceLeave(X)

#endif

//
// Constants used in logging
//

#define RTM_LOGGING_NONE      0
#define RTM_LOGGING_ERROR     1
#define RTM_LOGGING_WARN      2
#define RTM_LOGGING_INFO      3

//
// Event logging macros
//

extern  HANDLE          LoggingHandle;
extern  ULONG           LoggingLevel;

#define LOGHANDLE       LoggingHandle
#define LOGLEVEL        LoggingLevel
#define LOGERR          RouterLogError
#define LOGWARN         RouterLogWarning
#define LOGINFO         RouterLogInformation
#define LOGWARNDATA     RouterLogWarningData

//
// Error logging
//

#define START_LOGGING()     LOGHANDLE = RouterLogRegister("RTMv1")

#define STOP_LOGGING()      RouterLogDeregister(LOGHANDLE)

#define LOGERR0(msg,err) \
        if (LOGLEVEL >= RTM_LOGGING_ERROR) \
            LOGERR(LOGHANDLE,RTMLOG_ ## msg,0,NULL,(err))
#define LOGERR1(msg,a,err) \
        if (LOGLEVEL >= RTM_LOGGING_ERROR) \
            LOGERR(LOGHANDLE,RTMLOG_ ## msg,1,&(a),(err))
#define LOGERR2(msg,a,b,err) \
        if (LOGLEVEL >= RTM_LOGGING_ERROR) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGERR(LOGHANDLE,RTMLOG_ ## msg,2,_asz,(err)); \
        }
#define LOGERR3(msg,a,b,c,err) \
        if (LOGLEVEL >= RTM_LOGGING_ERROR) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGERR(LOGHANDLE,RTMLOG_ ## msg,3,_asz,(err)); \
        }
#define LOGERR4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= RTM_LOGGING_ERROR) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGERR(LOGHANDLE,RTMLOG_ ## msg,4,_asz,(err)); \
        }


//
// Warning logging
//

#define LOGWARN0(msg,err) \
        if (LOGLEVEL >= RTM_LOGGING_WARN) \
            LOGWARN(LOGHANDLE,RTMLOG_ ## msg,0,NULL,(err))
#define LOGWARN1(msg,a,err) \
        if (LOGLEVEL >= RTM_LOGGING_WARN) \
            LOGWARN(LOGHANDLE,RTMLOG_ ## msg,1,&(a),(err))
#define LOGWARN2(msg,a,b,err) \
        if (LOGLEVEL >= RTM_LOGGING_WARN) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGWARN(LOGHANDLE,RTMLOG_ ## msg,2,_asz,(err)); \
        }
#define LOGWARN3(msg,a,b,c,err) \
        if (LOGLEVEL >= RTM_LOGGING_WARN) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGWARN(LOGHANDLE,RTMLOG_ ## msg,3,_asz,(err)); \
        }
#define LOGWARN4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= RTM_LOGGING_WARN) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGWARN(LOGHANDLE,RTMLOG_ ## msg,4,_asz,(err)); \
        }

#define LOGWARNDATA2(msg,a,b,dw,buf) \
        if (LOGLEVEL >= RTM_LOGGING_WARN) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGWARNDATA(LOGHANDLE,RTMLOG_ ## msg,2,_asz,(dw),(buf)); \
        }


//
// Information logging
//

#define LOGINFO0(msg,err) \
        if (LOGLEVEL >= RTM_LOGGING_INFO) \
            LOGINFO(LOGHANDLE,RTMLOG_ ## msg,0,NULL,(err))
#define LOGINFO1(msg,a,err) \
        if (LOGLEVEL >= RTM_LOGGING_INFO) \
            LOGINFO(LOGHANDLE,RTMLOG_ ## msg,1,&(a),(err))
#define LOGINFO2(msg,a,b,err) \
        if (LOGLEVEL >= RTM_LOGGING_INFO) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGINFO(LOGHANDLE,RTMLOG_ ## msg,2,_asz,(err)); \
        }
#define LOGINFO3(msg,a,b,c,err) \
        if (LOGLEVEL >= RTM_LOGGING_INFO) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGINFO(LOGHANDLE,RTMLOG_ ## msg,3,_asz,(err)); \
        }
#define LOGINFO4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= RTM_LOGGING_INFO) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGINFO(LOGHANDLE,RTMLOG_ ## msg,4,_asz,(err)); \
        }

//
// Misc Debugging Macros
//

#define IPADDR_FORMAT(x) \
    ((x)&0x000000ff),(((x)&0x0000ff00)>>8),(((x)&0x00ff0000)>>16),(((x)&0xff000000)>>24)

#define TracePrintAddress(ID, Dest, Mask)                   \
{                                                           \
    Trace2(ID, "Dest: %d.%d.%d.%d Mask: %d.%d.%d.%d",       \
           IPADDR_FORMAT(Dest),                             \
           IPADDR_FORMAT(Mask));                            \
}

#endif //__ROUTING_RTMDBG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtm\rtmdb.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\rtm\rtm.c

Abstract:
	Routing Table Manager DLL. Helper routines


Author:

	Vadim Eydelman

Revision History:

--*/

#include "pchrtm.h"
#pragma hdrstop


// Initializes sync list object
VOID
InitializeSyncList (
	PRTM_SYNC_LIST	list
	) {
	list->RSL_Sync = NULL;
	list->RSL_UseCount = 0;
	InitializeListHead (&list->RSL_Head);
	}

// Get mutually exclusive access to the sync list obect
// Returns TRUE if access if obtained, FALSE otherwise
BOOLEAN
DoEnterSyncList (
	PRTM_TABLE		table,		// Table this list belongs to
	PRTM_SYNC_LIST	list,		// List of interest
	BOOLEAN			wait		// True if caller wants to wait
								// until list becomes available
#if DBG
    , LPSTR         file,
    ULONG           line
#endif
	) {
	DWORD			status;		// Status of OS calls
	BOOLEAN			result;		// Result of operation

	EnterCriticalSection (&table->RT_Lock);
		// Protect manipilation by table-wide critical section
#if DBG
	IF_DEBUG (SYNCHRONIZATION)
		Trace4 (ANY, "%08lx (%s,%ld) - trying to enter sync list: %08x\n",
							GetCurrentThreadId (), file, line, (ULONG_PTR)list);
#endif
	if (list->RSL_UseCount<=0) {
			// Nobody uses the list -> get it and return ok
		list->RSL_UseCount = 1;
#if DBG
		IF_DEBUG (SYNCHRONIZATION)
			Trace0 (ANY, "\t - first to enter\n");
#endif
		result = TRUE;
		}
	else if (wait) { // Somebody is using it, but caller agrees to wait
		list->RSL_UseCount += 1;	// Increment usage count
#if DBG
		IF_DEBUG (SYNCHRONIZATION)
			Trace1 (ANY, "\t - list in use: %d\n", list->RSL_UseCount);
#endif
		if (list->RSL_Sync==NULL) {	// if there is no event to wait on,
									// get one
									// First see if one is available
									// in the stack
			PSINGLE_LIST_ENTRY cur = PopEntryList (&table->RT_SyncObjectList);

#if DBG
			IF_DEBUG (SYNCHRONIZATION)
				Trace0 (ANY, "\t - need event\n");
#endif
			if (cur==NULL) {		// No, we'll have to create one
				PRTM_SYNC_OBJECT	sync;
				sync = (PRTM_SYNC_OBJECT)GlobalAlloc (
									GMEM_FIXED,
									sizeof (RTM_SYNC_OBJECT));
				if (sync==NULL) {
#if DBG
					Trace2 (ANY, 
				 				"Can't allocate synchronization object.\n"
				 				"\tat line %ld of %s\n",
								__LINE__, __FILE__);
#endif
                    list->RSL_UseCount -= 1;
					LeaveCriticalSection (&table->RT_Lock);
                    SetLastError (ERROR_NOT_ENOUGH_MEMORY);
					return FALSE;
					}

				sync->RSO_Event = CreateEvent (NULL,
												FALSE,	// Auto reset event
												FALSE,	// Initially nonsignaled
												NULL);
				if (sync->RSO_Event==NULL) {
                    status = GetLastError ();
#if DBG
					Trace2 (ANY, 
				 				"Can't allocate synchronization event.\n"
				 				"\tat line %ld of %s\n",
								__LINE__, __FILE__);
#endif
                    list->RSL_UseCount -= 1;
                    GlobalFree (sync);
					LeaveCriticalSection (&table->RT_Lock);
                    SetLastError (status);
					return FALSE;
					}

				list->RSL_Sync = sync;
#if DBG
				IF_DEBUG (SYNCHRONIZATION)
					Trace0 (ANY, "\t - event created\n");
#endif
				}
			else {	// Yes, make sure it is reset
				list->RSL_Sync = CONTAINING_RECORD (cur, RTM_SYNC_OBJECT, RSO_Link);
// Autoreset event gets reset after releasing a thread anyway
//				status = ResetEvent (list->RSL_Sync->RSO_Event);
//				ASSERTERRMSG ("Can't reset event.", status);
				}
			}
				// Now as we set up the object to wait, we can leave critical
				// section and wait on event
		LeaveCriticalSection (&table->RT_Lock);
		status = WaitForSingleObject (
							list->RSL_Sync->RSO_Event,
							INFINITE
							);
		ASSERTERRMSG ("Wait event failed.", status==WAIT_OBJECT_0);
	
			// Event is signaled, we may now access the list (auto reset event
			// releases only one thread
		EnterCriticalSection (&table->RT_Lock);

#if DBG
		IF_DEBUG (SYNCHRONIZATION)
			Trace1 (ANY, "%08lx - wait completed\n", GetCurrentThreadId ());
#endif

			// If our caller was the only one waiting,
			// we can release the event
		if (list->RSL_UseCount==1) {
#if DBG
			IF_DEBUG (SYNCHRONIZATION)
				Trace0 (ANY, "\t - restocking event\n");
#endif
			PushEntryList (&table->RT_SyncObjectList, &list->RSL_Sync->RSO_Link);
			list->RSL_Sync = NULL;
			}
		result = TRUE;
		}
	else {
		// Caller does not want to wait
		result = FALSE;
#if DBG
		IF_DEBUG (SYNCHRONIZATION)
			Trace0 (ANY, "\t - doesn't want to wait\n");
#endif
		}

	LeaveCriticalSection (&table->RT_Lock);

	return result;
	}


// Release previously owned sync list object
VOID
LeaveSyncList (
	PRTM_TABLE		table,		// Table to which this object belongs
	PRTM_SYNC_LIST	list		// List to release
	) {
	DWORD			status;
								
	EnterCriticalSection (&table->RT_Lock);
#if DBG
	IF_DEBUG (SYNCHRONIZATION)
		Trace2 (ANY, "%08lx - leaving sync list: %08x\n",
									GetCurrentThreadId (), (ULONG_PTR)list);
#endif
			// Decrement the count and signal the event (only one thread
			// will be released for the auto-reset events
	list->RSL_UseCount -= 1;
	if (list->RSL_UseCount>0) {
#if DBG
		IF_DEBUG (SYNCHRONIZATION)
			Trace1 (ANY, "%\t - releasing one of %d waiting threads\n",
															list->RSL_UseCount);
#endif
		status = SetEvent (list->RSL_Sync->RSO_Event);
		ASSERTERRMSG ("Can't signal event.", status);
		}
	LeaveCriticalSection (&table->RT_Lock);
	}






// Finds list of routes that are associated with given interface and returns
// pointer to its head
// Creates new list of none exists yet
PLIST_ENTRY
FindInterfaceList (
	PRTM_SYNC_LIST	intfHash,
	DWORD			InterfaceID,	// Interface to look for
	BOOL			CreateNew
	) {
	PRTM_INTERFACE_NODE intfNode;
	PLIST_ENTRY			cur;

		// First try to find existing one in the list of interface lists
	cur = intfHash->RSL_Head.Flink;
	while (cur!=&intfHash->RSL_Head) {
		intfNode = CONTAINING_RECORD (cur, RTM_INTERFACE_NODE, IN_Link);
		if (InterfaceID<=intfNode->IN_InterfaceID) // List is ordered
												// so we can stop
												// if bigger number is reached
			break;
		cur = cur->Flink;
		}

		
	if ((cur==&intfHash->RSL_Head)
		|| (InterfaceID!=intfNode->IN_InterfaceID)) { // Create new interface
													// list
		if (!CreateNew)
			return NULL;

		intfNode = (PRTM_INTERFACE_NODE)GlobalAlloc (
										GMEM_FIXED,
										sizeof (RTM_INTERFACE_NODE));
		if (intfNode==NULL) {
	#if DBG
	 				// Report error in debuging builds
			Trace2 (ANY, 
		 				"Can't allocate interface node\n\tat line %ld of %s\n",
						__LINE__, __FILE__);
	#endif
			return NULL;
			}

		intfNode->IN_InterfaceID = InterfaceID;
		InitializeListHead (&intfNode->IN_Head);	// Insert it in
													// list of interface lists
		InsertTailList (cur, &intfNode->IN_Link);
		}

	return &intfNode->IN_Head;
	}

#if RTM_USE_PROTOCOL_LISTS
// Finds list of routes that are associated with given iprotocol and returns
// pointer to its head
// Creates new list of none exists yet
PLIST_ENTRY
FindProtocolList (
	PRTM_TABLE	Table,
	DWORD		RoutingProtocol,
	BOOL		CreateNew
	) {
	PRTM_PROTOCOL_NODE protNode;
	PLIST_ENTRY			cur;

	cur = Table->RT_ProtocolList.RSL_Head.Flink;
	while (cur!=&Table->RT_ProtocolList.RSL_Head) {
		protNode = CONTAINING_RECORD (cur, RTM_PROTOCOL_NODE, PN_Link);
		if (RoutingProtocol<=protNode->PN_RoutingProtocol)
			break;
		cur = cur->Flink;
		}

	if ((cur==&Table->RT_ProtocolList.RSL_Head)
		|| (RoutingProtocol!=protNode->PN_RoutingProtocol)) {
		
		if (!CreateNew)
			return NULL;

		protNode = (PRTM_PROTOCOL_NODE)GlobalAlloc (
										GMEM_FIXED,
										sizeof (RTM_PROTOCOL_NODE));
		if (protNode==NULL) {
#if DBG
	 				// Report error in debuging builds
			Trace2 (ANY, 
		 				"Can't allocate protocol node\n\tat line %ld of %s\n",
						__LINE__, __FILE__);
#endif
			return NULL;
			}

		protNode->PN_RoutingProtocol = RoutingProtocol;
		InitializeListHead (&protNode->PN_Head);
		InsertTailList (cur, &protNode->PN_Link);
		}

	return &protNode->PN_Head;
	}
#endif

// Adds node to temporary net number list (to be later merged with master list)
// Both lists are ordered by net number.interface.protocol.next hop address
VOID
AddNetNumberListNode (
	PRTM_TABLE	Table,
	PRTM_ROUTE_NODE	newNode
	) {
	PLIST_ENTRY		cur;
	INT				res;
	
	cur = Table->RT_NetNumberTempList.RSL_Head.Flink;
	while (cur!=&Table->RT_NetNumberTempList.RSL_Head) {
		PRTM_ROUTE_NODE node = CONTAINING_RECORD (
								cur,
								RTM_ROUTE_NODE,
								RN_Links[RTM_NET_NUMBER_LIST_LINK]
								);
		res = NetNumCmp (Table, &newNode->RN_Route, &node->RN_Route);
		if ((res<0)
			||((res==0)
			  &&((newNode->RN_Route.XX_PROTOCOL
						< node->RN_Route.XX_PROTOCOL)
				||((newNode->RN_Route.XX_PROTOCOL
						==node->RN_Route.XX_PROTOCOL)
				  &&((newNode->RN_Route.XX_INTERFACE
								< node->RN_Route.XX_INTERFACE)
					||((newNode->RN_Route.XX_INTERFACE
							== node->RN_Route.XX_INTERFACE)
					  && (NextHopCmp (Table, &newNode->RN_Route,
					  						&node->RN_Route)
							< 0)))))))
			break;
		cur = cur->Flink;
		}

	InsertTailList (cur, &newNode->RN_Links[RTM_NET_NUMBER_LIST_LINK]);
	}


// Adds node to expiration time queue.  (Queue is ordered by expiration time)
// Return TRUE if new node is the first in the queue
BOOL
AddExpirationQueueNode (
	PRTM_TABLE	Table,
	PRTM_ROUTE_NODE	newNode
	) {
	PLIST_ENTRY		cur;
	BOOL			res = TRUE;
	
		// We'll travers the queue from the back, because normally
		// new entries are added closer the end of the queue
	cur = Table->RT_ExpirationQueue.RSL_Head.Blink;
	while (cur!=&Table->RT_ExpirationQueue.RSL_Head) {
		PRTM_ROUTE_NODE node = CONTAINING_RECORD (
								cur,
								RTM_ROUTE_NODE,
								RN_Links[RTM_EXPIRATION_QUEUE_LINK]
								);
		if (IsLater(newNode->RN_ExpirationTime, node->RN_ExpirationTime)) {
			res = FALSE;
			break;
			}
		cur = cur->Blink;
		}

	InsertHeadList (cur, &newNode->RN_Links[RTM_EXPIRATION_QUEUE_LINK]);
	return res;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtm\rtm.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\rtm\rtm.c

Abstract:
        Routing Table Manager DLL. Main module


Author:

        Vadim Eydelman

Revision History:

--*/

#include "pchrtm.h"
#pragma hdrstop

/* ****** Global data ****** */

// Tables themselves
RTM_TABLE       Tables[RTM_NUM_OF_PROTOCOL_FAMILIES];



MASK_ENTRY      g_meMaskTable[ MAX_MASKS + 1 ] =
{
    { 0x00000000, 0 },

    { 0x00000001, 0 },
    { 0x00000003, 0 },
    { 0x00000007, 0 },
    { 0x0000000F, 0 },

    { 0x0000001F, 0 },
    { 0x0000003F, 0 },
    { 0x0000007F, 0 },
    { 0x000000FF, 0 },
    
    { 0x000080FF, 0 },
    { 0x0000C0FF, 0 },
    { 0x0000E0FF, 0 },
    { 0x0000F0FF, 0 },
    
    { 0x0000F8FF, 0 },
    { 0x0000FCFF, 0 },
    { 0x0000FEFF, 0 },
    { 0x0000FFFF, 0 },
    
    { 0x0080FFFF, 0 },
    { 0x00C0FFFF, 0 },
    { 0x00E0FFFF, 0 },
    { 0x00F0FFFF, 0 },
    
    { 0x00F8FFFF, 0 },
    { 0x00FCFFFF, 0 },
    { 0x00FEFFFF, 0 },
    { 0x00FFFFFF, 0 },
    
    { 0x80FFFFFF, 0 },
    { 0xC0FFFFFF, 0 },
    { 0xE0FFFFFF, 0 },
    { 0xF0FFFFFF, 0 },
    
    { 0xF8FFFFFF, 0 },
    { 0xFCFFFFFF, 0 },
    { 0xFEFFFFFF, 0 },
    { 0xFFFFFFFF, 0 }
};

#if DBG
DWORD    dbgThreadId;
ULONG    TracingHandle;
DWORD    TracingInited;
HANDLE   LoggingHandle;
ULONG    LoggingLevel;
#endif

/* ***** Internal Function Prototypes ******* */

VOID
NotifyClients (
    PRTM_TABLE              Table,
    HANDLE                  ClientHandle,
    DWORD                   Flags,
    PRTM_XX_ROUTE           CurBestRoute,
    PRTM_XX_ROUTE           PrevBestRoute
    );

VOID APIENTRY
ConsolidateNetNumberListsWI (
    PVOID                   Context
    );

VOID
ConsolidateNetNumberLists (
    PRTM_TABLE                      Table
    );

VOID APIENTRY
ScheduleUpdate (
    PVOID           Context
    );

VOID APIENTRY
ProcessExpirationQueueWI (
    PVOID                   Table
    );

VOID
ProcessExpirationQueue (
    PRTM_TABLE              Table
    );

DWORD
ReadRegistry (
    void
    );

DWORD
DoEnumerate (
    PRTM_TABLE              Table,
    PRTM_ENUMERATOR EnumPtr,
    DWORD                   EnableFlag
    );

VOID
SetMaskCount( 
    PIP_NETWORK                 pinNet,
    BOOL                        bAdd
);

#if 0 // Replaced by RTMv2's DLLMain

// DLL main function.  Called by crtdll startup routine that is
// designated as entry point for this dll.
//
//      At startup (DLL_PROCESS_ATTACH): creates all tables and starts update
//                                                                              thread
//      At shutdown (DLL_PROCESS_DETACH): stops update thread and disposes of all
//                                                                              resources

BOOL WINAPI DllMain(
    HINSTANCE   hinstDLL,                               // DLL instance handle
    DWORD               fdwReason,                              // Why is it called
    LPVOID      lpvReserved
    ) {

    switch (fdwReason) {
        case DLL_PROCESS_ATTACH:     // We are being attached to a new process
            // Create all we need to operate
            DisableThreadLibraryCalls (hinstDLL);

            return Rtmv1DllStartup(hinstDLL);

        case DLL_PROCESS_DETACH:    // The process is exiting

            Rtmv1DllCleanup();

        default:                    // Not interested in all other cases
            return TRUE;
            break;
    }
}

#endif

BOOL
Rtmv1DllStartup (
    HINSTANCE   hinstDLL  // DLL instance handle
    )
{
    DWORD                   i;

    // Create all we need to operate

#if DBG
    RTDlgThreadHdl  = CreateThread (
        NULL,
        0,
        &RTDialogThread,
        (LPVOID)hinstDLL,
        0,
        &dbgThreadId);
    ASSERTERR (RTDlgThreadHdl!=NULL);
#endif

    for (i=0; i<RTM_NUM_OF_PROTOCOL_FAMILIES; i++) {
        Tables[i].RT_APIclientCount = RTM_CLIENT_STOP_TRESHHOLD;
        Tables[i].RT_Heap = NULL;
    }

    return TRUE;
}

VOID
Rtmv1DllCleanup (
    )
{
    DWORD                   status;
    DWORD                   i;

#if DBG
    PostThreadMessage (dbgThreadId, WM_QUIT, 0, 0);
    status = WaitForSingleObject (RTDlgThreadHdl, 5*1000);
    if (status!=WAIT_OBJECT_0)
        TerminateThread (RTDlgThreadHdl, 0);
    CloseHandle (RTDlgThreadHdl);

    // Deregister with tracing utils
    STOP_TRACING();
#endif

    // Dispose of all resources
    for (i=0; i<RTM_NUM_OF_PROTOCOL_FAMILIES; i++) {
        if (Tables[i].RT_Heap!=NULL)
            RtmDeleteRouteTable (i);
    }

    return;
}

/*++
*******************************************************************

        R t m C r e a t e R o u t e T a b l e

Routine Description:
        Create route table for protocol family
Arguments:
        ProtocolFamily - index that identifies protocol family
        Config - protocol family table configuration parameters
Return Value:
        NO_ERROR - table was created ok
        ERROR_NOT_ENOUGH_MEMORY - could not allocate memory to perform
                                                the operation
        ERROR_NO_SYSTEM_RESOURCES - not enough resources to perform the operation,
                                                        try again later

*******************************************************************
--*/
DWORD
RtmCreateRouteTable (
    IN DWORD                                                        ProtocolFamily,
    IN PRTM_PROTOCOL_FAMILY_CONFIG          Config
    ) {
    INT                             i;
    DWORD                   status;
    PRTM_TABLE              Table;

#if DBG
    // Register with tracing utils
    START_TRACING();
#endif

    if (ProtocolFamily>=RTM_NUM_OF_PROTOCOL_FAMILIES) {
#if DBG
        Trace2 ( ANY,
                 "Undefined Protocol Family.\n\tat line %ld of %s\n",
                 __LINE__, __FILE__);
#endif
        return ERROR_INVALID_PARAMETER;
    }

    Table = &Tables[ProtocolFamily];
    if (Table->RT_Heap!=NULL) {
#if DBG
        Trace2 ( ANY,
                 "Table already exists for protocol family\n\tat line %ld of %s\n",
                 __LINE__, __FILE__);
#endif
        return ERROR_ALREADY_EXISTS;
    }

    memcpy (&Table->RT_Config, Config, sizeof (Table->RT_Config));

    status = NtCreateTimer (&Table->RT_ExpirationTimer,
                            TIMER_ALL_ACCESS,
                            NULL,
                            NotificationTimer);

    if (!NT_SUCCESS (status))
        return ERROR_NO_SYSTEM_RESOURCES;

    status = NtCreateTimer (&Table->RT_UpdateTimer,
                            TIMER_ALL_ACCESS,
                            NULL,
                            NotificationTimer);

    if (!NT_SUCCESS (status)) {
        NtClose (Table->RT_ExpirationTimer);
        return ERROR_NO_SYSTEM_RESOURCES;
    }


    Table->RT_Heap = HeapCreate (0, 0, Table->RT_Config.RPFC_MaxTableSize);
    if (Table->RT_Heap==NULL) {
        NtClose (Table->RT_UpdateTimer);
        NtClose (Table->RT_ExpirationTimer);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Table->RT_NetNumberHash = (PRTM_SYNC_LIST)HeapAlloc (
        Table->RT_Heap,
        0,
        sizeof (RTM_SYNC_LIST)*Table->RT_HashTableSize);

    if (Table->RT_NetNumberHash==NULL) {
        status = GetLastError ();
        HeapDestroy (Table->RT_Heap);
        NtClose (Table->RT_UpdateTimer);
        NtClose (Table->RT_ExpirationTimer);
        return status;
    }

    Table->RT_InterfaceHash = (PRTM_SYNC_LIST)HeapAlloc (
        Table->RT_Heap,
        0,
        sizeof (RTM_SYNC_LIST)*RTM_INTF_HASH_SIZE);

    if (Table->RT_InterfaceHash==NULL) {
        status = GetLastError ();
        HeapDestroy (Table->RT_Heap);
        NtClose (Table->RT_UpdateTimer);
        NtClose (Table->RT_ExpirationTimer);
        return status;
    }

    try {
        InitializeCriticalSection (&Table->RT_Lock);
    }
    except (EXCEPTION_EXECUTE_HANDLER) {
        return GetLastError();
    }

    Table->RT_SyncObjectList.Next = NULL;

    for (i=0; i<Table->RT_HashTableSize; i++)
        InitializeSyncList (&Table->RT_NetNumberHash[i]);
    for (i=0; i<RTM_INTF_HASH_SIZE; i++)
        InitializeSyncList (&Table->RT_InterfaceHash[i]);


#if RTM_USE_PROTOCOL_LISTS
    InitializeSyncList (&Table->RT_ProtocolList);
#endif
    InitializeSyncList (&Table->RT_NetNumberMasterList);
    InitializeSyncList (&Table->RT_NetNumberTempList);
    InitializeSyncList (&Table->RT_DeletedList);

    InitializeSyncList (&Table->RT_ExpirationQueue);
    InitializeSyncList (&Table->RT_RouteChangeQueue);
    InitializeSyncList (&Table->RT_ClientList);

    Table->RT_NetNumberTempCount = 0;
    Table->RT_DeletedNodesCount = 0;
    Table->RT_UpdateWorkerPending = -1;
    Table->RT_ExpirationWorkerPending = -1;

    Table->RT_NetworkCount = 0;
    Table->RT_NumOfMessages = 0;

    InterlockedIncrement (&Table->RT_UpdateWorkerPending);
    status = RtlQueueWorkItem (ScheduleUpdate, Table, WT_EXECUTEINIOTHREAD);
    ASSERTMSG ("Could not queue update scheduling work item ", status==STATUS_SUCCESS);

    Table->RT_APIclientCount = 0;
    return NO_ERROR;
}


/*++
*******************************************************************

        R t m D e l e t e R o u t e T a b l e

Routine Description:
        Dispose of all resources allocated for the route table
Arguments:
        ProtocolFamily - index that identifies protocol family
Return Value:
        NO_ERROR - table was deleted ok
        ERROR_INVALID_PARAMETER - no table to delete

*******************************************************************
--*/
DWORD
RtmDeleteRouteTable (
    DWORD           ProtocolFamily
    ) {
    PSINGLE_LIST_ENTRY      cur;
    PRTM_TABLE                      Table;
    LONG                            curAPIclientCount;

    if (ProtocolFamily>=RTM_NUM_OF_PROTOCOL_FAMILIES) {
#if DBG
        Trace2 (ANY, 
                 "Undefined Protocol Family.\n\tat line %ld of %s\n",
                 __LINE__, __FILE__);
#endif
        return ERROR_INVALID_PARAMETER;
    }

    Table = &Tables[ProtocolFamily];
    if (Table->RT_Heap==NULL) {
#if DBG
        Trace3 (ANY, 
                 "Table does not exist or already deleted for protocol family %d\n"
                 "\tat line %ld of %s\n",
                 ProtocolFamily, __LINE__, __FILE__);
#endif
        return ERROR_INVALID_PARAMETER;
    }

    while (!IsListEmpty (&Table->RT_ClientList.RSL_Head)) {
        PRTM_CLIENT     ClientPtr = CONTAINING_RECORD (
            Table->RT_ClientList.RSL_Head.Flink,
            RTM_CLIENT,
            RC_Link);
        RtmDeregisterClient ((HANDLE)ClientPtr);
    }

    curAPIclientCount = InterlockedExchange (&Table->RT_APIclientCount,
                                             RTM_CLIENT_STOP_TRESHHOLD)
        + RTM_CLIENT_STOP_TRESHHOLD;

    while (Table->RT_APIclientCount > curAPIclientCount)
        Sleep (100);

    while (InterlockedIncrement (&Table->RT_ExpirationWorkerPending)>0) {
        while (Table->RT_ExpirationWorkerPending!=-1)
            Sleep (100);
    }

    while (InterlockedIncrement (&Table->RT_UpdateWorkerPending)>0) {
        while (Table->RT_UpdateWorkerPending!=-1)
            Sleep (100);
    }
    NtCancelTimer (Table->RT_UpdateTimer, NULL);
    NtCancelTimer (Table->RT_ExpirationTimer, NULL);
    Sleep (100);

    NtClose (Table->RT_UpdateTimer);
    NtClose (Table->RT_ExpirationTimer);
    Sleep (100);

    cur = PopEntryList (&Table->RT_SyncObjectList);
    while (cur!=NULL) {
        GlobalFree (CONTAINING_RECORD (cur, RTM_SYNC_OBJECT, RSO_Link));
        cur = PopEntryList (&Table->RT_SyncObjectList);
    }

    HeapFree (Table->RT_Heap, 0, Table->RT_InterfaceHash);
    HeapFree (Table->RT_Heap, 0, Table->RT_NetNumberHash);
    HeapDestroy (Table->RT_Heap);
    Table->RT_Heap = NULL;
    DeleteCriticalSection (&Table->RT_Lock);
    return NO_ERROR;
}

// Registers client as a handler of specified protocol
// Returns a HANDLE be used for all subsequent
// calls to identify which Protocol Family and Routing Protocol
// should be affected by the call
// Returns NULL in case of failure. Call GetLastError () to obtain
// extended error information.
// Error codes:
//      ERROR_INVALID_PARAMETER - specified protocol family is not supported
//      ERROR_CLIENT_ALREADY_EXISTS - another client already registered
//                                                      to handle specified protocol
//      ERROR_NO_SYSTEM_RESOURCES - not enough resources to lock table content
//      ERROR_NOT_ENOUGH_MEMORY - not enough memory to allocate client control block
HANDLE WINAPI
RtmRegisterClient (
    IN DWORD                ProtocolFamily,         // IP, IPX, etc.
    IN DWORD            RoutingProtocol,        // RIP, OSPF, etc.
    IN HANDLE               ChangeEvent OPTIONAL,// Notified when best
    // routes change in the table (see
    // RtmDequeueRouteChangeMessage
    IN DWORD                Flags
    ) {
    HANDLE                  ClientHandle;
#define ClientPtr ((PRTM_CLIENT)ClientHandle)   // To access handle fields
    // in this routine
    PRTM_TABLE              Table;                          // Table we associated with
    DWORD                   status;                         // Operation result
    PLIST_ENTRY             cur;

    // Check if we have the table of interest
    Table = &Tables[ProtocolFamily];

    if ((ProtocolFamily>=RTM_NUM_OF_PROTOCOL_FAMILIES)
        || !EnterTableAPI (Table)) {
#if DBG
        Trace2 (ANY, 
                 "Undefined Protocol Family.\n\tat line %ld of %s\n",
                 __LINE__, __FILE__);
#endif
        SetLastError (ERROR_INVALID_PARAMETER);
        return NULL;
    }


    if (Flags & (~RTM_PROTOCOL_SINGLE_ROUTE)) {
#if DBG
        Trace2 (ANY, 
                 "Invalid registration flags\n\tat line %ld of %s\n",
                 __LINE__, __FILE__);
#endif
        ExitTableAPI(Table);
        SetLastError (ERROR_INVALID_PARAMETER);
        return NULL;
    }
    // Allocate handle and initialize basic fields
    ClientHandle = GlobalAlloc (GMEM_FIXED, sizeof (RTM_CLIENT));
    if (ClientHandle==NULL) {
        ExitTableAPI(Table);
        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    ClientPtr->RC_RoutingProtocol = RoutingProtocol;
    ClientPtr->RC_NotificationEvent = ChangeEvent;
    ClientPtr->RC_Flags = Flags;

                                                        // Lock client list as we adding a new one
    if (!EnterSyncList (Table, &Table->RT_ClientList, TRUE)) {
        GlobalFree (ClientHandle);
        ExitTableAPI (Table);
        SetLastError (ERROR_NO_SYSTEM_RESOURCES);
        return NULL;
    }
    // Check if we have another client with same
    // Routing Protocol

    cur = Table->RT_ClientList.RSL_Head.Flink;
    while (cur!=&Table->RT_ClientList.RSL_Head) {
        PRTM_CLIENT node = CONTAINING_RECORD (cur,
                                              RTM_CLIENT,
                                              RC_Link);
        if (ClientPtr->RC_RoutingProtocol< node->RC_RoutingProtocol)
            break;
        else if (ClientPtr->RC_RoutingProtocol==node->RC_RoutingProtocol) {
            LeaveSyncList (Table, &Table->RT_ClientList);
            GlobalFree (ClientHandle);
            ExitTableAPI (Table);
            SetLastError (ERROR_CLIENT_ALREADY_EXISTS);
            return NULL;
        }
        cur = cur->Flink;
    }
    // Check if client needs notifications
    if (ChangeEvent!= NULL) {
        status = ResetEvent (ChangeEvent); // Nothing yet
        ASSERTERRMSG ("Can't reset client's event.", status);
        // Lock notification messages queue
        if (!EnterSyncList (Table, &Table->RT_RouteChangeQueue, TRUE)) {
            LeaveSyncList (Table, &Table->RT_ClientList);
            GlobalFree (ClientHandle);
            ExitTableAPI (Table);
            SetLastError (ERROR_NO_SYSTEM_RESOURCES);
            return NULL;
        }

        // Point to the end of the queue: ignore
        // all previous messages
        ClientPtr->RC_PendingMessage = &Table->RT_RouteChangeQueue.RSL_Head;
        LeaveSyncList (Table, &Table->RT_RouteChangeQueue);
    }
    // Add client to the list
    InsertTailList (cur, &ClientPtr->RC_Link);
    LeaveSyncList (Table, &Table->RT_ClientList);

    ClientPtr->RC_ProtocolFamily = ProtocolFamily|RTM_CLIENT_HANDLE_TAG;
    ExitTableAPI (Table);
    return ClientHandle;
#undef ClientPtr
}

// Frees resources and the HANDLE allocated above.
// Deletes all routes associated with Routing Protocol that was represented
// by the handle
// Returned error codes:
//      NO_ERROR - handle was disposed of ok
//      ERROR_NO_SYSTEM_RESOURCES - not enough resources to lock table content
//      ERROR_NOT_ENOUGH_MEMORY - not enough memory to allocate client control block
DWORD WINAPI
RtmDeregisterClient (
    IN HANDLE               ClientHandle
    ) {
#define ClientPtr ((PRTM_CLIENT)ClientHandle)   // To access handle fields
    // in this routine
    RTM_XX_ROUTE            Route;
    PRTM_TABLE                      Table;
    DWORD                           ProtocolFamily;

    try {
        ProtocolFamily = ClientPtr->RC_ProtocolFamily ^ RTM_CLIENT_HANDLE_TAG;
        Table = &Tables[ProtocolFamily];
        if ((ProtocolFamily<RTM_NUM_OF_PROTOCOL_FAMILIES)
            && EnterTableAPI (Table))
            NOTHING;
        else
            return ERROR_INVALID_HANDLE;
    }
    except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
            EXCEPTION_EXECUTE_HANDLER :
            EXCEPTION_CONTINUE_SEARCH) {
        return ERROR_INVALID_HANDLE;
    }


    // Lock client list
    if (!EnterSyncList (Table, &Table->RT_ClientList, TRUE)) {
        ExitTableAPI (Table);
        return ERROR_NO_SYSTEM_RESOURCES;
    }

    // Check if we need to dispose of messages
    // still waiting for this client
    if (ClientPtr->RC_NotificationEvent!= NULL) {
        if (!EnterSyncList (Table, &Table->RT_RouteChangeQueue, TRUE)) {
            LeaveSyncList (Table, &Table->RT_ClientList);
            ExitTableAPI (Table);
            return ERROR_NO_SYSTEM_RESOURCES;
        }

        while (ClientPtr->RC_PendingMessage
               != &Table->RT_RouteChangeQueue.RSL_Head) {
            PRTM_ROUTE_CHANGE_NODE node = CONTAINING_RECORD (
                ClientPtr->RC_PendingMessage,
                RTM_ROUTE_CHANGE_NODE,
                RCN_Link);
            ClientPtr->RC_PendingMessage = ClientPtr->RC_PendingMessage->Flink;
            if (node->RCN_ResponsibleClient!=ClientHandle) {
                // Tell that we processed this message so it can be freed
                // if no more clients are interested
                node->RCN_ReferenceCount -= 1;
                if (node->RCN_ReferenceCount<=0) {
                    RemoveEntryList (&node->RCN_Link);
                    if (node->RCN_Route2!=NULL)
                        HeapFree (Table->RT_Heap, 0, node->RCN_Route2);
                    HeapFree (Table->RT_Heap, 0, node);
                }
            }
        }

        LeaveSyncList (Table, &Table->RT_RouteChangeQueue);
    }
    RemoveEntryList (&ClientPtr->RC_Link);
    LeaveSyncList (Table, &Table->RT_ClientList);

    {
        RTM_CLIENT      DeadClient;
        DeadClient.RC_ProtocolFamily = ClientPtr->RC_ProtocolFamily;
        DeadClient.RC_RoutingProtocol = ClientPtr->RC_RoutingProtocol;
        // Invlaidate client's handle memory block
        ClientPtr->RC_ProtocolFamily ^= RTM_CLIENT_HANDLE_TAG;
        GlobalFree (ClientHandle);
        // Delete all routes associated with routing protocol
        // controled by the client
        RtmBlockDeleteRoutes ((HANDLE)&DeadClient, 0, &Route);
    }

    ExitTableAPI (Table);
    return NO_ERROR;
#undef ClientPtr
}

// Dequeues and returns the first change message from the queue.
// Should be called if NotificationEvent is signalled to retrieve
// chage messages pending for the client
// Change messages are generated if best route to some destination
// or any of its routing parameters (metric or protocol specific fields)
// get changed as the result of some route being added, deleted, updated,
// disabled, reenabled, or aged out.  Note that change in protocol specific fields
// or in TimeToLive parameters do not produce notification messages
// Returns NO_ERROR and resets the event if there are no more messages
//              pending for the client,
//      otherwise ERROR_MORE_MESSAGES is returned (client should keep calling
//              until NO_ERROR is returned)
//      ERROR_NO_MESSAGES will be returned if there were no messages
//              to return (can happen if called when event was not signalled)
//      ERROR_NO_SYSTEM_RESOURCES - not enough resources to lock table content
DWORD WINAPI
RtmDequeueRouteChangeMessage (
    IN      HANDLE          ClientHandle,                   // Handle that identifies client
    OUT     DWORD           *Flags,                                 // Flags that indentify what
    // is this message about:
    // RTM_ROUTE_ADDED - this message informs
    //      of new route (CurBestRoute is filled with
    //      this route parameters if provided)
    // RTM_ROUTE_DELETED - this message informs
    //      that route was deleted (PrevBestRoute is
    //      filled with this route parameters if provuded)
    // RTM_ROUTE_CHANGED - best route to some network has
    //      changed, (CurBestRoute is filled with parameter
    //      of route that became the best, PrevBestRoute is
    //      filled with parameters of route that was best
    //      before this change)
    OUT PVOID               CurBestRoute    OPTIONAL,
    OUT     PVOID           PrevBestRoute   OPTIONAL
    ){
#define ClientPtr ((PRTM_CLIENT)ClientHandle)   // To access handle fields
    // in this routine
    PRTM_ROUTE_CHANGE_NODE  node=NULL;
    DWORD                                   status;
    PRTM_TABLE                              Table;
    DWORD                                   ProtocolFamily;

    try {
        ProtocolFamily = ClientPtr->RC_ProtocolFamily ^ RTM_CLIENT_HANDLE_TAG;
        Table = &Tables[ProtocolFamily];
        if ((ProtocolFamily<RTM_NUM_OF_PROTOCOL_FAMILIES)
            && EnterTableAPI (Table))
            NOTHING;
        else
            return ERROR_INVALID_HANDLE;
    }
    except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
            EXCEPTION_EXECUTE_HANDLER :
            EXCEPTION_CONTINUE_SEARCH) {
        return ERROR_INVALID_HANDLE;
    }

    // Events are reported only to the clients that
    // requested them by providing notification event
    if (ClientPtr->RC_NotificationEvent==NULL) {
#if DBG
        Trace2 (ANY, 
                 "Dequeue message is called by the client that did not provide."
                 " notification event\n"
                 "\tat line %ld of %s\n",
                 __LINE__, __FILE__);
#endif
        ExitTableAPI (Table);
        return ERROR_INVALID_HANDLE;
    }

    if (!EnterSyncList (Table, &Table->RT_RouteChangeQueue, TRUE)) {
        ExitTableAPI (Table);
        return ERROR_NO_SYSTEM_RESOURCES;
    }

    // Traverse the queue to find the message that was not caused
    // by client's actions
    while (ClientPtr->RC_PendingMessage
           != &Table->RT_RouteChangeQueue.RSL_Head) {
        node = CONTAINING_RECORD (ClientPtr->RC_PendingMessage,
                                  RTM_ROUTE_CHANGE_NODE,
                                  RCN_Link);
        if (node->RCN_ResponsibleClient!=ClientHandle)
            break;
        ClientPtr->RC_PendingMessage = ClientPtr->RC_PendingMessage->Flink;
    }

    if (ClientPtr->RC_PendingMessage!=&Table->RT_RouteChangeQueue.RSL_Head)
        ClientPtr->RC_PendingMessage = ClientPtr->RC_PendingMessage->Flink;
    else {
        // There must be a pending message or we should have been
        // called
#if DBG
        Trace2 (ANY, 
                 "Dequeue message is called, but nothing is pending.\n"
                 "\tat line %ld of %s\n",
                 __LINE__, __FILE__);
#endif
        status = ResetEvent (ClientPtr->RC_NotificationEvent);
        ASSERTERRMSG ("Can't reset client's event.", status);
        LeaveSyncList (Table, &Table->RT_RouteChangeQueue);
        ExitTableAPI (Table);
        return ERROR_NO_MESSAGES;
    }

    // Copy message to client's buffers
    *Flags = node->RCN_Flags;
    switch (node->RCN_Flags) {
        case RTM_ROUTE_CHANGED:
            if (ARGUMENT_PRESENT (PrevBestRoute))
                memcpy (PrevBestRoute, &node->RCN_Route2->RN_Route,
                        Table->RT_RouteSize);
            break;
        case RTM_ROUTE_ADDED:
            if (ARGUMENT_PRESENT (CurBestRoute))
                memcpy (CurBestRoute, &node->RCN_Route1, Table->RT_RouteSize);
            break;
        case RTM_ROUTE_DELETED:
            if (ARGUMENT_PRESENT (PrevBestRoute))
                memcpy (PrevBestRoute, &node->RCN_Route1, Table->RT_RouteSize);
            break;
        default:
            ASSERTMSG ("Invalid message flag", FALSE);
            break;
    }


    // Tell that we processed this message so it can be freed if
    // no more clients are interested
    node->RCN_ReferenceCount -= 1;
    if (node->RCN_ReferenceCount<=0) {
        Table->RT_NumOfMessages -= 1;
        RemoveEntryList (&node->RCN_Link);
        if (node->RCN_Route2!=NULL)
            HeapFree (Table->RT_Heap, 0, node->RCN_Route2);
        HeapFree (Table->RT_Heap, 0, node);
    }

    // Traverse the queue to locate next pending message
    // (not caused by the client)
    while (ClientPtr->RC_PendingMessage
           != &Table->RT_RouteChangeQueue.RSL_Head) {
        node = CONTAINING_RECORD (ClientPtr->RC_PendingMessage,
                                  RTM_ROUTE_CHANGE_NODE,
                                  RCN_Link);
        if (node->RCN_ResponsibleClient!=ClientHandle)
            break;
        ClientPtr->RC_PendingMessage = ClientPtr->RC_PendingMessage->Flink;
    }

    if (ClientPtr->RC_PendingMessage==&Table->RT_RouteChangeQueue.RSL_Head) {
        // All pending messages are processed: reset the event
        status = ResetEvent (ClientPtr->RC_NotificationEvent);
        ASSERTERRMSG ("Can't reset client's event.", status);
        status = NO_ERROR;
    }
    else
        status = ERROR_MORE_MESSAGES;

    LeaveSyncList (Table, &Table->RT_RouteChangeQueue);
    ExitTableAPI (Table);
    return status;
#undef ClientPtr
}


// Adds new route change message to the queue and notifies
// all interesed clients
VOID
NotifyClients (
    PRTM_TABLE              Table,                          // Table to which this change applies
    HANDLE                  ClientHandle,           // Client that caused this change (can
    // be NULL if this is a result of
    // route aging)
    DWORD                   Flags,                          // Change message flags
    PRTM_XX_ROUTE           CurBestRoute,           // Current best route for the network
    PRTM_XX_ROUTE           PrevBestRoute           // Previous best route for the network
    ) {
    PRTM_ROUTE_CHANGE_NODE  node;
    PLIST_ENTRY                             cur;
    BOOL                                    nodeInserted = FALSE;

    (*Table->RT_Config.RPFC_Change) (Flags, CurBestRoute, PrevBestRoute);
    // Allocate and initialize queue node
    node = (PRTM_ROUTE_CHANGE_NODE)HeapAlloc (
        Table->RT_Heap,
        0,
        FIELD_OFFSET (RTM_ROUTE_NODE, RN_Route)+Table->RT_RouteSize);
    if (node==NULL)
        return;

    if (Flags==RTM_ROUTE_CHANGED) {
        node->RCN_Route2 = (PRTM_ROUTE_NODE)HeapAlloc (
            Table->RT_Heap,
            0,
            FIELD_OFFSET (RTM_ROUTE_NODE, RN_Route)+Table->RT_RouteSize);
        if (node->RCN_Route2==NULL) {
            HeapFree (Table->RT_Heap, 0, node);
            return;
        }
    }
    else
        node->RCN_Route2 = NULL;

    node->RCN_ReferenceCount = 0;
    node->RCN_ResponsibleClient = ClientHandle;
    node->RCN_Flags = Flags;
    switch (Flags) {
        case RTM_ROUTE_CHANGED:
            if (ARGUMENT_PRESENT (PrevBestRoute))
                memcpy (&node->RCN_Route2->RN_Route, PrevBestRoute,
                        Table->RT_RouteSize);
            break;
        case RTM_ROUTE_ADDED:
            if (ARGUMENT_PRESENT (CurBestRoute))
                memcpy (&node->RCN_Route1, CurBestRoute, Table->RT_RouteSize);
            break;
        case RTM_ROUTE_DELETED:
            if (ARGUMENT_PRESENT (PrevBestRoute))
                memcpy (&node->RCN_Route1, PrevBestRoute, Table->RT_RouteSize);
            break;
        default:
            ASSERTMSG ("Invalid message flag", FALSE);
            break;
    }


    if (!EnterSyncList (Table, &Table->RT_ClientList, TRUE)) {
        if (node->RCN_Route2!=NULL)
            HeapFree (Table->RT_Heap, 0, node->RCN_Route2);
        HeapFree (Table->RT_Heap, 0, node);
        return ;
    }

    // Find and notify interested clients
    cur = Table->RT_ClientList.RSL_Head.Flink;
    if (!EnterSyncList (Table, &Table->RT_RouteChangeQueue, TRUE)) {
        LeaveSyncList (Table, &Table->RT_ClientList);
        if (node->RCN_Route2!=NULL)
            HeapFree (Table->RT_Heap, 0, node->RCN_Route2);
        HeapFree (Table->RT_Heap, 0, node);
        return ;
    }

    while (cur!=&Table->RT_ClientList.RSL_Head) {
        PRTM_CLIENT     clientPtr = CONTAINING_RECORD (
            cur,
            RTM_CLIENT,
            RC_Link);
        if (((HANDLE)clientPtr!=ClientHandle)
            && (clientPtr->RC_NotificationEvent!=NULL)) {
            node->RCN_ReferenceCount += 1;
            if (node->RCN_ReferenceCount==1) {
                InsertTailList (&Table->RT_RouteChangeQueue.RSL_Head,
                                &node->RCN_Link);
                Table->RT_NumOfMessages += 1;
            }

            if (clientPtr->RC_PendingMessage
                ==&Table->RT_RouteChangeQueue.RSL_Head) {
                BOOL res = SetEvent (clientPtr->RC_NotificationEvent);
                ASSERTERRMSG ("Can't set client notification event.", res);
                clientPtr->RC_PendingMessage = &node->RCN_Link;
            }
            else if ((Table->RT_NumOfMessages>RTM_MAX_ROUTE_CHANGE_MESSAGES)
                     && (clientPtr->RC_PendingMessage==
                         Table->RT_RouteChangeQueue.RSL_Head.Flink)) {
                PRTM_ROUTE_CHANGE_NODE firstNode = CONTAINING_RECORD (
                    clientPtr->RC_PendingMessage,
                    RTM_ROUTE_CHANGE_NODE,
                    RCN_Link);
#if DBG
                Trace3 (ANY, 
                         "Dequeueing message for 'lazy' client %lx.\n"
                         "\tat line %ld of %s\n",
                         (ULONG_PTR)clientPtr, __LINE__, __FILE__);
#endif
                clientPtr->RC_PendingMessage =
                    clientPtr->RC_PendingMessage->Flink;
                firstNode->RCN_ReferenceCount -= 1;
                if (firstNode->RCN_ReferenceCount==0) {
                    Table->RT_NumOfMessages -= 1;
                    RemoveEntryList (&firstNode->RCN_Link);
                    if (firstNode->RCN_Route2!=NULL)
                        HeapFree (Table->RT_Heap, 0, firstNode->RCN_Route2);
                    HeapFree (Table->RT_Heap, 0, firstNode);
                }

            }

        }
        cur = cur->Flink;
    }

    if (node->RCN_ReferenceCount==0) {
        if (node->RCN_Route2!=NULL)
            HeapFree (Table->RT_Heap, 0, node->RCN_Route2);
        HeapFree (Table->RT_Heap, 0, node);
    }
    LeaveSyncList (Table, &Table->RT_RouteChangeQueue);
    LeaveSyncList (Table, &Table->RT_ClientList);
}


PRTM_ROUTE_NODE
CreateRouteNode (
    PRTM_TABLE              Table,
    PLIST_ENTRY             hashLink,
    PLIST_ENTRY             intfLink,
    BOOL                    intfLinkFinal,
#if RTM_USE_PROTOCOL_LISTS
    PLIST_ENTRY             protLink,
    BOOL                    protLinkFinal,
#endif
    PRTM_SYNC_LIST  hashBasket,
    PRTM_XX_ROUTE           ROUTE
    ) {
    PRTM_SYNC_LIST  intfBasket;
    PRTM_ROUTE_NODE theNode = (PRTM_ROUTE_NODE)HeapAlloc (Table->RT_Heap, 0,
                                                          FIELD_OFFSET (RTM_ROUTE_NODE, RN_Route)+Table->RT_RouteSize);

    if (theNode==NULL) {
#if DBG
        // Report error in debuging builds
        Trace2 (ANY, 
                 "Can't allocate route\n\tat line %ld of %s\n",
                 __LINE__, __FILE__);
#endif
        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }


    theNode->RN_Flags = RTM_NODE_FLAGS_INIT;
    theNode->RN_Hash = hashBasket;
    memcpy (&theNode->RN_Route, ROUTE, Table->RT_RouteSize);
    InitializeListEntry (&theNode->RN_Links[RTM_EXPIRATION_QUEUE_LINK]);

    // Make sure we can lock all list before adding
    // We'll keep them locked untill we are sure
    // that route can be added to prevent "partially
    // inserted" entries in case of memory allocation failure, etc.
#if RTM_USE_PROTOCOL_LISTS
    if (!EnterSyncList (Table, &Table->RT_ProtocolList, TRUE)) {
        HeapFree (Table->RT_Heap, 0, theNode);
        SetLastError (ERROR_NO_SYSTEM_RESOURCES);
        return NULL;
    }

    if (protLink==NULL) {// If we haven't seen any entries with same
        // net number and protocol, we'll find the
        // protocol list and insert at the end
        protLink = FindProtocolList (Table, ROUTE->XX_PROTOCOL);
        if (protLink==NULL) {
            LeaveSyncList (Table, &Table->RT_ProtocolList);
            HeapFree (Table->RT_Heap, 0, theNode);
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);
            return NULL;
        }
    }
#endif

    intfBasket = &Table->RT_InterfaceHash[IntfHashFunction(Table,
                                                           ROUTE->XX_INTERFACE)];
    if (!EnterSyncList (Table, intfBasket, TRUE)) {
#if RTM_USE_PROTOCOL_LISTS
        LeaveSyncList (Table, &Table->RT_ProtocolList);
#endif
        HeapFree (Table->RT_Heap, 0, theNode);
        SetLastError (ERROR_NO_SYSTEM_RESOURCES);
        return NULL;
    }

    if (intfLink==NULL) {
        intfLink = FindInterfaceList (intfBasket, ROUTE->XX_INTERFACE, TRUE);
        if (intfLink==NULL) {
#if RTM_USE_PROTOCOL_LISTS
            LeaveSyncList (Table, &Table->RT_ProtocolList);
#endif
            LeaveSyncList (Table, intfBasket);
            HeapFree (Table->RT_Heap, 0, theNode);
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);
            return NULL;
        }
    }

    if (!EnterSyncList (Table, &Table->RT_NetNumberTempList, TRUE)) {
        LeaveSyncList (Table, intfBasket);
#if RTM_USE_PROTOCOL_LISTS
        LeaveSyncList (Table, &Table->RT_ProtocolList);
#endif
        HeapFree (Table->RT_Heap, 0, theNode);
        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    // Add route to hash basket list
    InsertTailList (hashLink, &theNode->RN_Links[RTM_NET_NUMBER_HASH_LINK]);
    // Add route to protocol list
#if RTM_USE_PROTOCOL_LISTS
    if (protLinkFinal) {
        InsertTailList (protLink,
                        &theNode->RN_Links[RTM_PROTOCOL_LIST_LINK]);
    }
    else {
        InsertHeadList (protLink,
                        &theNode->RN_Links[RTM_PROTOCOL_LIST_LINK]);
    }
#endif
    // Add it to interface list
    if (intfLinkFinal) {
        InsertTailList (intfLink,
                        &theNode->RN_Links[RTM_INTERFACE_LIST_LINK]);
    }
    else {
        InsertHeadList (intfLink,
                        &theNode->RN_Links[RTM_INTERFACE_LIST_LINK]);
    }

    // We can now release interface and procotol lists
    // because we are sure that addition to net number sorted
    // list won't fail
    LeaveSyncList (Table, intfBasket);
#if RTM_USE_PROTOCOL_LISTS
    LeaveSyncList (Table, &Table->RT_ProtocolList);
#endif

    // Add route to temporary net number list (to be later moved
    // to the master list by the update thread)
    AddNetNumberListNode (Table, theNode);
    Table->RT_NetNumberTempCount += 1;
    if (Table->RT_NetNumberTempCount==RTM_TEMP_LIST_MAX_COUNT) {
        if (InterlockedIncrement (&Table->RT_UpdateWorkerPending)==0) {
            DWORD   status;
            status = RtlQueueWorkItem (ConsolidateNetNumberListsWI, Table, 0);
            ASSERTERRMSG ("Can't queue update work item", status==STATUS_SUCCESS);
        }
    }

    LeaveSyncList (Table, &Table->RT_NetNumberTempList);

    return theNode;
}


DWORD
RemoveRouteNode (
    PRTM_TABLE              Table,
    PRTM_ROUTE_NODE theNode
    ) {
    PLIST_ENTRY                     head;
    PRTM_SYNC_LIST          intfBasket
        = &Table->RT_InterfaceHash[IntfHashFunction(Table,
                                                    theNode->RN_Route.XX_INTERFACE)];

#if RTM_USE_PROTOCOL_LISTS
    if (!EnterSyncList (Table, &Table->RT_ProtocolList, TRUE)) {
        LeaveSyncList (Table, &Table->RT_ExpirationQueue);
        return ERROR_NO_SYSTEM_RESOURCES;
    }
#endif
    if (!EnterSyncList (Table, intfBasket, TRUE)) {
#if RTM_USE_PROTOCOL_LISTS
        LeaveSyncList (Table, &Table->RT_ProtocolList);
#endif
        return ERROR_NO_SYSTEM_RESOURCES;
    }

    if (!EnterSyncList (Table, &Table->RT_ExpirationQueue, TRUE)) {
        LeaveSyncList (Table, intfBasket);
#if RTM_USE_PROTOCOL_LISTS
        LeaveSyncList (Table, &Table->RT_ProtocolList);
#endif
        return ERROR_NO_SYSTEM_RESOURCES;
    }

    if (!EnterSyncList (Table, &Table->RT_DeletedList, TRUE)) {
        LeaveSyncList (Table, &Table->RT_ExpirationQueue);
        LeaveSyncList (Table, intfBasket);
#if RTM_USE_PROTOCOL_LISTS
        LeaveSyncList (Table, &Table->RT_ProtocolList);
#endif
        return ERROR_NO_SYSTEM_RESOURCES;
    }



    // Remove node from the interface list
    head = theNode->RN_Links[RTM_INTERFACE_LIST_LINK].Flink;
    RemoveEntryList (&theNode->RN_Links[RTM_INTERFACE_LIST_LINK]);
    if (IsListEmpty (head)) {
        PRTM_INTERFACE_NODE     intfNode = CONTAINING_RECORD (head,
                                                              RTM_INTERFACE_NODE,
                                                              IN_Head);
        RemoveEntryList (&intfNode->IN_Link);
        GlobalFree (intfNode);
    }

    LeaveSyncList (Table, intfBasket);


#if RTM_USE_PROTOCOL_LISTS
    RemoveEntryList (&theNode->RN_Links[RTM_PROTOCOL_LIST_LINK]);
    // Remove node from the protocol list
    LeaveSyncList (Table, &Table->RT_ProtocolList);
#endif
    // Remove form expiration queue if it was there
    if (IsListEntry (&theNode->RN_Links[RTM_EXPIRATION_QUEUE_LINK])) {
        RemoveEntryList (&theNode->RN_Links[RTM_EXPIRATION_QUEUE_LINK]);
    }
    LeaveSyncList (Table, &Table->RT_ExpirationQueue);

                // Remove node from the hash basket list
    RemoveEntryList (&theNode->RN_Links[RTM_NET_NUMBER_HASH_LINK]);
    // let update thread take care of disposing
    InsertHeadList (&Table->RT_DeletedList.RSL_Head,
                    &theNode->RN_Links[RTM_DELETED_LIST_LINK]);
    Table->RT_DeletedNodesCount += 1;
    if (Table->RT_DeletedNodesCount==RTM_DELETED_LIST_MAX_COUNT) {
        if (InterlockedIncrement (&Table->RT_UpdateWorkerPending)==0) {
            DWORD status = RtlQueueWorkItem (ConsolidateNetNumberListsWI, Table, 0);
            ASSERTERRMSG ("Can't queue update work item", status==STATUS_SUCCESS);
        }
    }
    LeaveSyncList (Table, &Table->RT_DeletedList);

    return NO_ERROR;
}

// Adds a given route or updates metric, TimeToLive, and reserved fields
// if route with same net number, interface, routing protocol,
// and next hop address already exists in the table
// Returns:
//              NO_ERROR                                - if route was added OK or
//              ERROR_INVALID_PARAMETER - if Route contains invalid parameter (suh as
//                                                              protocol does not match client's protocol)
//              ERROR_NOT_ENOUGH_MEMORY - if route can not be inserted because of memory
//                                                              allocation problem
//              ERROR_NO_SYSTEM_RESOURCES               - not enough resources to lock table content
DWORD WINAPI
RtmAddRoute(
    IN HANDLE           ClientHandle, // Handle that identifies protocol family
    // and routing protocol of the route
    // to add/update (RoutingProtocol field
    // of the Route parameter is ignored)
    // and coordinates this operation with
    // notifications
    // through the event (notificanitons will not
    // be sent to the caller)
    IN PVOID                Route,                  // Route to add
    // Route fields used as input:
    // Destination network
    // Interface through which route was received
    // Address of next hop router
    // Three fields above combined with protocol id uniquely
    // identify the route in the table
    // Data specific to protocol family
    // Protocol independent metric
    // Any data specific to routing
    //      protocol (subject to size limitation
    //      defined by PROTOCOL_SPECIFIC_DATA
    //      structure above)
    IN DWORD                TimeToLive,   // In seconds. INFINITE if route is not to
    // be aged out. The maximum value for
    // this parameter is 2147483 sec (that
    // is 24+ days)

    OUT DWORD               *Flags,                 // If added/updated route is the best route to the
    // destination RTM_CURRENT_BEST_ROUTE will be set,
    //  AND if added/updated route changed (or
    // replaced alltogether) previous
    // best route info for the destination,
    // RTM_PREVIOUS_BEST_ROUTE will be set
    OUT PVOID           CurBestRoute OPTIONAL,// This buffer (if present) will
    // receive the route that became the best as
    // the result of this addition/update if
    // RTM_CURRENT_BEST_ROUTE is set
    OUT PVOID           PrevBestRoute OPTIONAL// This buffer (if present) will
    // receive the route that was the best before
    // this addition/update if
    // RTM_PREVIOUS_BEST_ROUTE is set
    ) {
#define ROUTE ((PRTM_XX_ROUTE)Route)
#define ClientPtr ((PRTM_CLIENT)ClientHandle)
    DWORD                                   status; // Operation result
    INT                                             res;    // Comparison result
    PRTM_SYNC_LIST                  hashBasket;     // Hash basket to which added route
    // belongs
    // Links in all mantained lists for added route
    PLIST_ENTRY                             cur, hashLink=NULL, intfLink=NULL, protLink=NULL;
    // Node created for added route and best node for the
    // network
    PRTM_ROUTE_NODE                 theNode=NULL, curBestNode=NULL;
    // Flags that indicate that corresponing links are determined
    BOOL                                    intfLinkFinal=FALSE;
#if RTM_USE_PROTOCOL_LISTS
    BOOL                                    protLinkFinal=FALSE;
#endif
    BOOL                                    newRoute=FALSE, updatedRoute=FALSE;

    PRTM_TABLE                              Table;
    DWORD                                   ProtocolFamily;

    try {
        ProtocolFamily = ClientPtr->RC_ProtocolFamily ^ RTM_CLIENT_HANDLE_TAG;
        Table = &Tables[ProtocolFamily];
        if ((ProtocolFamily<RTM_NUM_OF_PROTOCOL_FAMILIES)
            && EnterTableAPI (Table))
            NOTHING;
        else
            return ERROR_INVALID_HANDLE;
    }
    except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
            EXCEPTION_EXECUTE_HANDLER :
            EXCEPTION_CONTINUE_SEARCH) {
        return ERROR_INVALID_HANDLE;
    }

    ROUTE->XX_PROTOCOL = ClientPtr->RC_RoutingProtocol;
    GetSystemTimeAsFileTime (&ROUTE->XX_TIMESTAMP);

    status = ValidateRoute (Table, ROUTE);
    if (status!=NO_ERROR)
        return status;

                // Find and lock the hash basket for added route
    hashBasket = &Table->RT_NetNumberHash [HashFunction (Table,
                                                         ((char *)ROUTE)
                                                         +sizeof(RTM_XX_ROUTE))];
    if (!EnterSyncList (Table, hashBasket, TRUE)) {
        ExitTableAPI(Table);
        return ERROR_NO_SYSTEM_RESOURCES;
    }

    // Traverse the list attached to the hash basket to
    // find proper place for added route (entries in hash
    // basket are ordered by network number and metric
    cur = hashBasket->RSL_Head.Flink;
    while (cur!=&hashBasket->RSL_Head) {
        PRTM_ROUTE_NODE node = CONTAINING_RECORD (
            cur,
            RTM_ROUTE_NODE,
            RN_Links[RTM_NET_NUMBER_HASH_LINK]
            );

        if (!IsEnumerator (node)) {

            // Check if network numbers match
            res = NetNumCmp (Table, ROUTE, &node->RN_Route);


            if (res==0) { // We found block of entries with same net number
                // We'll have to look through all of them

                // Check all parameters of the node to see if we already
                // have this route and this is just an update
                if ((hashLink==NULL) && (theNode==NULL)) {
                    if (ROUTE->XX_PROTOCOL
                        == node->RN_Route.XX_PROTOCOL) {
                        if (ClientPtr->RC_Flags&RTM_PROTOCOL_SINGLE_ROUTE)
                            theNode = node;
                        else if (ROUTE->XX_INTERFACE
                                 == node->RN_Route.XX_INTERFACE) {
                            res = NextHopCmp (Table, ROUTE, &node->RN_Route);
                            if (res == 0)
                                theNode = node;
                            else if (res < 0)
                                hashLink = cur;
                        }
                        else if (ROUTE->XX_INTERFACE
                                 < node->RN_Route.XX_INTERFACE)
                            hashLink = cur;
                    }
                    else if (ROUTE->XX_PROTOCOL
                             < node->RN_Route.XX_PROTOCOL)
                        hashLink = cur;
                }

                // Just looking for current best route
                // (not including added/updated route)
                if ((node!=theNode)
                    && IsEnabled(node)
                    && ((curBestNode==NULL)
                        || IsBest(node)
                        || (MetricCmp (Table,
                                       &curBestNode->RN_Route,
                                       &node->RN_Route)>0)))
                    curBestNode = node;


                // We have to check all entries with same net number
                // anyway (to find the best route), so we might as
                // well find links for the added route in protocol
                // and interface list if such links exist (if not, we'll
                // just insert new entry at the end of the list)

#if RTM_USE_PROTOCOL_LISTS
                // If we need and haven't found yet a proper place to
                // insert added route into the protocol list and this route
                // has the same protocol as added route we should
                // consider it.
                if (!protLinkFinal && (theNode==NULL)
                    && (ROUTE->XX_PROTOCOL
                        ==node->RN_Route.XX_PROTOCOL)) {
                    protLink = &node->RN_Links[RTM_PROTOCOL_LIST_LINK];
                    // If added route has lower interface number than
                    // this one we'll insert it in protocol list right
                    // BEFORE this one, otherwise
                    // we are not sure if this is a proper place yet (there
                    // may be other routes with same protocol that have
                    // lower interface number), but we note the position
                    // and insert added route right AFTER this one if there
                    // are no more routes of this protocol.
                    protLinkFinal = ROUTE->XX_INTERFACE
                        < node->RN_Route.XX_INTERFACE;
                }
#endif

                // Same story with the interface list
                if (!intfLinkFinal
                    && (ROUTE->XX_INTERFACE
                        ==node->RN_Route.XX_INTERFACE)) {
                    intfLink = &node->RN_Links[RTM_INTERFACE_LIST_LINK];
                    intfLinkFinal = ROUTE->XX_PROTOCOL
                        < node->RN_Route.XX_PROTOCOL;
                }
            }
            else if (res < 0) // We must have seen all entries with
                // matching network number -> nothing
                // to look for anymore
                break;

        }
        cur = cur->Flink;
    }



    if (theNode!=NULL) {
        // We found the route, so just need to update its parameters

        if (ClientPtr->RC_Flags&RTM_PROTOCOL_SINGLE_ROUTE) {
            updatedRoute = (MetricCmp (Table, &theNode->RN_Route, ROUTE)!=0)
                || (theNode->RN_Route.XX_INTERFACE!=ROUTE->XX_INTERFACE)
                || (NextHopCmp (Table, &theNode->RN_Route, ROUTE)!=0)
                || !FSDCmp (Table, &theNode->RN_Route, ROUTE);

            if (ROUTE->XX_INTERFACE!=theNode->RN_Route.XX_INTERFACE) {
                PRTM_SYNC_LIST                  intfBasketOld
                    = &Table->RT_InterfaceHash[IntfHashFunction(Table,
                                                                theNode->RN_Route.XX_INTERFACE)];
                PRTM_SYNC_LIST                  intfBasketNew
                    = &Table->RT_InterfaceHash[IntfHashFunction(Table,
                                                                ROUTE->XX_INTERFACE)];


                // Make sure we lock interface hash table basket
                // in the same order to prevent possible deadlock
                if (intfBasketOld<intfBasketNew) {
                    if (!EnterSyncList (Table, intfBasketOld, TRUE)) {
                        status = ERROR_NO_SYSTEM_RESOURCES;
                        goto ExitAddRoute;
                    }
                    if (!EnterSyncList (Table, intfBasketNew, TRUE)) {
                        LeaveSyncList (Table, intfBasketOld);
                        status = ERROR_NO_SYSTEM_RESOURCES;
                        goto ExitAddRoute;
                    }
                }
                else if (intfBasketOld>intfBasketNew) {
                    if (!EnterSyncList (Table, intfBasketNew, TRUE)) {
                        status = ERROR_NO_SYSTEM_RESOURCES;
                        goto ExitAddRoute;
                    }
                    if (!EnterSyncList (Table, intfBasketOld, TRUE)) {
                        LeaveSyncList (Table, intfBasketOld);
                        status = ERROR_NO_SYSTEM_RESOURCES;
                        goto ExitAddRoute;
                    }
                }
                else {
                    if (!EnterSyncList (Table, intfBasketOld, TRUE)) {
                        status = ERROR_NO_SYSTEM_RESOURCES;
                        goto ExitAddRoute;
                    }
                }


                if (intfLink==NULL) {
                    intfLink = FindInterfaceList (intfBasketNew, ROUTE->XX_INTERFACE, TRUE);
                    if (intfLink==NULL) {
                        status = ERROR_NOT_ENOUGH_MEMORY;
                        LeaveSyncList (Table, intfBasketOld);
                        if (intfBasketNew!=intfBasketOld)
                            LeaveSyncList (Table, intfBasketNew);
                        goto ExitAddRoute;
                    }
                }
                // Add it to interface list
                RemoveEntryList (&theNode->RN_Links[RTM_INTERFACE_LIST_LINK]);
                InsertTailList (intfLink,
                                &theNode->RN_Links[RTM_INTERFACE_LIST_LINK]);
                LeaveSyncList (Table, intfBasketOld);
                if (intfBasketNew!=intfBasketOld)
                    LeaveSyncList (Table, intfBasketNew);
            }
        }
        else
            updatedRoute = MetricCmp (Table, &theNode->RN_Route, ROUTE)
            || !FSDCmp (Table, &theNode->RN_Route, ROUTE)!=0;

    }

    else /*if (theNode==NULL)*/ {   //      We haven't found matching route,
        //      so we'll add a new one
        // If we were not able to find place to insert added route
        // into the list, we use the place where we stop
        // the search (it is either end of the list or
        // network with higher number if we did not see our
        // network or all other entries had lower metric
        if (hashLink==NULL)
            hashLink = cur;
        theNode = CreateRouteNode (Table,
                                   hashLink,
                                   intfLink,
                                   intfLinkFinal,
#if RTM_USE_PROTOCOL_LISTS
                                   protLink,
                                   protLinkFinal,
#endif
                                   hashBasket,
                                   ROUTE);
        if (theNode==NULL) {
            status = GetLastError ();
            goto ExitAddRoute;
        }

        if (curBestNode==NULL) {
            InterlockedIncrement (&Table->RT_NetworkCount);
            SetBest (theNode);       // This is the first
            // route to the network, and thus
            // it is the best.
            newRoute = TRUE;
        }
        else {
            newRoute = FALSE;
        }
    }


    // All routes (new or old) need to be placed into the Expiration list
    // to be properly aged out
    if (!EnterSyncList (Table, &Table->RT_ExpirationQueue, TRUE)) {
        status = ERROR_NO_SYSTEM_RESOURCES;
        goto ExitAddRoute;
    }

    if (IsListEntry (&theNode->RN_Links[RTM_EXPIRATION_QUEUE_LINK])) {
        RemoveEntryList (&theNode->RN_Links[RTM_EXPIRATION_QUEUE_LINK]);
    }

    if (TimeToLive!=INFINITE) {
        TimeToLive *= 1000;
        if (TimeToLive > (MAXTICKS/2-1))
            TimeToLive = MAXTICKS/2-1;
        theNode->RN_ExpirationTime = (GetTickCount () + TimeToLive)&0xFFFFFF00;
        if (AddExpirationQueueNode (Table, theNode)) {
            if (InterlockedIncrement (&Table->RT_ExpirationWorkerPending)==0) {
                // New route expiration time comes before the update thread
                // is scheduled to wakeup next time, so wake it up NOW
                status = RtlQueueWorkItem (ProcessExpirationQueueWI, Table, 
                                                          WT_EXECUTEINIOTHREAD);
                ASSERTERRMSG ("Can't queue expiration work item", status==STATUS_SUCCESS);
            }
        }
    }
    else
        // Initilaize this list link, so we know it is not
        // in the list and we do not have to remove it from
        // there
        InitializeListEntry (&theNode->RN_Links[RTM_EXPIRATION_QUEUE_LINK]);
    LeaveSyncList (Table, &Table->RT_ExpirationQueue);



    if (!IsEnabled(theNode))  {// Ignore disabled nodes
        if (updatedRoute)
            // Update the route data
            memcpy (&theNode->RN_Route, ROUTE, Table->RT_RouteSize);
        else {
            memcpy (&theNode->RN_Route.XX_TIMESTAMP,
                    &ROUTE->XX_TIMESTAMP,
                    sizeof (theNode->RN_Route.XX_TIMESTAMP));
            memcpy (&theNode->RN_Route.XX_PSD,
                    &ROUTE->XX_PSD,
                    sizeof (theNode->RN_Route.XX_PSD));
        }
        *Flags = 0;
    }
    else if (curBestNode!=NULL) { // There is at least one other route to the
        // same network as the route we're adding/updating
        if (MetricCmp (Table, ROUTE, &curBestNode->RN_Route)<0) {
            // Added/updated route metric is lower, it is the best
            if (!IsBest(theNode)) {// The best route has changed, we need to
                // update best route designation
                ResetBest (curBestNode);
                SetBest (theNode);
                memcpy (&theNode->RN_Route, ROUTE, Table->RT_RouteSize);

                                                                        // include previous best route info
                                                                        // in notificaion message
                *Flags = RTM_PREVIOUS_BEST_ROUTE|RTM_CURRENT_BEST_ROUTE;
                if (ARGUMENT_PRESENT (CurBestRoute))
                    memcpy (CurBestRoute, ROUTE, Table->RT_RouteSize);
                if (ARGUMENT_PRESENT (PrevBestRoute))
                    memcpy (PrevBestRoute, &curBestNode->RN_Route, Table->RT_RouteSize);
                NotifyClients (Table, ClientHandle, *Flags, ROUTE,
                               &curBestNode->RN_Route);
            }
            else {
                if (updatedRoute) {
                    *Flags = RTM_PREVIOUS_BEST_ROUTE|RTM_CURRENT_BEST_ROUTE;
                    if (ARGUMENT_PRESENT (CurBestRoute))
                        memcpy (CurBestRoute, ROUTE, Table->RT_RouteSize);
                    if (ARGUMENT_PRESENT (PrevBestRoute))
                        memcpy (PrevBestRoute, &theNode->RN_Route, Table->RT_RouteSize);
                    NotifyClients (Table, ClientHandle, *Flags, ROUTE, &theNode->RN_Route);
                    // Update the route data
                    memcpy (&theNode->RN_Route, ROUTE, Table->RT_RouteSize);
                }
                else {
                    memcpy (&theNode->RN_Route.XX_TIMESTAMP,
                            &ROUTE->XX_TIMESTAMP,
                            sizeof (theNode->RN_Route.XX_TIMESTAMP));
                    memcpy (&theNode->RN_Route.XX_PSD,
                            &ROUTE->XX_PSD,
                            sizeof (theNode->RN_Route.XX_PSD));
                }
            }
        }
        else if (IsBest(theNode)) {
            if (MetricCmp (Table, ROUTE, &curBestNode->RN_Route)>0) {
                // We are downgrading our best route,
                // and new best route poped up.
                // Update best route designation
                ResetBest (theNode);
                SetBest (curBestNode);
                memcpy (&theNode->RN_Route, ROUTE, Table->RT_RouteSize);
                // Inform clients about the change
                *Flags = RTM_CURRENT_BEST_ROUTE | RTM_PREVIOUS_BEST_ROUTE;
                if (ARGUMENT_PRESENT (PrevBestRoute))
                    memcpy (PrevBestRoute, &curBestNode->RN_Route, Table->RT_RouteSize);
                if (ARGUMENT_PRESENT (CurBestRoute))
                    memcpy (CurBestRoute, ROUTE, Table->RT_RouteSize);
                NotifyClients (Table, ClientHandle, *Flags, &curBestNode->RN_Route,
                               ROUTE);
            }
            else if (updatedRoute) {
                *Flags = RTM_PREVIOUS_BEST_ROUTE|RTM_CURRENT_BEST_ROUTE;
                if (ARGUMENT_PRESENT (CurBestRoute))
                    memcpy (CurBestRoute, ROUTE, Table->RT_RouteSize);
                if (ARGUMENT_PRESENT (PrevBestRoute))
                    memcpy (PrevBestRoute, &theNode->RN_Route, Table->RT_RouteSize);
                NotifyClients (Table, ClientHandle, *Flags, ROUTE, &theNode->RN_Route);
                // Update the route data
                memcpy (&theNode->RN_Route, ROUTE, Table->RT_RouteSize);
            }
            else {
                memcpy (&theNode->RN_Route.XX_TIMESTAMP,
                        &ROUTE->XX_TIMESTAMP,
                        sizeof (theNode->RN_Route.XX_TIMESTAMP));
                memcpy (&theNode->RN_Route.XX_PSD,
                        &ROUTE->XX_PSD,
                        sizeof (theNode->RN_Route.XX_PSD));
            }
        }
        else {  // Added route metric was and is higher and thus has no
            // effect on best route to the network
            *Flags = 0;
            // Update the route data
            if (updatedRoute) {
                memcpy (&theNode->RN_Route, ROUTE, Table->RT_RouteSize);
            }
            else {
                memcpy (&theNode->RN_Route.XX_TIMESTAMP,
                        &ROUTE->XX_TIMESTAMP,
                        sizeof (theNode->RN_Route.XX_TIMESTAMP));
                memcpy (&theNode->RN_Route.XX_PSD,
                        &ROUTE->XX_PSD,
                        sizeof (theNode->RN_Route.XX_PSD));
            }
        }
    }
    else { // Not other node exist for this network
        if (newRoute) {
            *Flags = RTM_CURRENT_BEST_ROUTE;
            if (ARGUMENT_PRESENT (CurBestRoute))
                memcpy (CurBestRoute, ROUTE, Table->RT_RouteSize);
            NotifyClients (Table, ClientHandle, *Flags, ROUTE, NULL);
        }
        else if (updatedRoute) {
            *Flags = RTM_CURRENT_BEST_ROUTE | RTM_PREVIOUS_BEST_ROUTE;
            if (ARGUMENT_PRESENT (CurBestRoute))
                memcpy (CurBestRoute, ROUTE, Table->RT_RouteSize);
            if (ARGUMENT_PRESENT (CurBestRoute))
                memcpy (PrevBestRoute, &theNode->RN_Route, Table->RT_RouteSize);
            NotifyClients (Table, ClientHandle, *Flags, ROUTE, &theNode->RN_Route);
            // Update the route data
            memcpy (&theNode->RN_Route, ROUTE, Table->RT_RouteSize);
        }
        else {
            memcpy (&theNode->RN_Route.XX_TIMESTAMP,
                    &ROUTE->XX_TIMESTAMP,
                    sizeof (theNode->RN_Route.XX_TIMESTAMP));
            memcpy (&theNode->RN_Route.XX_PSD,
                    &ROUTE->XX_PSD,
                    sizeof (theNode->RN_Route.XX_PSD));
            *Flags = 0;
        }
    }

    //
    // for each new route added the size of the net mask is noted.
    //
    // This is useful at route lookup time.  For now since there
    // is no efficient way to do a route lookup, it is necessary to 
    // guess the (sub)net mask associated with a destination to find
    // the best route associated with it.  By tracking the net mask
    // for each added route the number of guesses for the mask can
    // be minimized.
    //

    if ( newRoute )
    {
#if ROUTE_LOOKUP_BDG
        TRACE2( 
            ANY, "Network : %x %x", 
            ((PIP_NETWORK) NNM(ROUTE))->N_NetNumber,
            ((PIP_NETWORK) NNM(ROUTE))->N_NetMask
            );

        TRACE1(
            ANY, "Next Hop : %x",
            ((PRTM_IP_ROUTE) NNM(ROUTE))-> RR_NextHopAddress.N_NetNumber
            );
#endif            
        SetMaskCount( (PIP_NETWORK) NNM( ROUTE ), TRUE );
    }
    
    status = NO_ERROR;

ExitAddRoute:
    LeaveSyncList (Table, hashBasket);
    ExitTableAPI(Table);

#undef ClientPtr
#undef ROUTE
    return status;
}



// Deletes a given route
//
// Returns:
//              NO_ERROR                                - if route was deleted OK or
//              ERROR_NO_SUCH_ROUTE - if route to be deleted was not found in the table
DWORD WINAPI
RtmDeleteRoute (
    IN HANDLE           ClientHandle,       // Handle to coordinate
    // this operation with notifications
    // through the event (notificanitons will not
    // be sent to the caller)
    IN PVOID                Route,                  // ROUTE to delete
    OUT     DWORD           *Flags,                 // If deleted route was the best
    // route, RTM_PREVIOUS_BEST_ROUTE will be set
    // AND if there is another route for the same
    // network, RTM_CURRENT_BEST_ROUTE will be set
    OUT PVOID           CurBestRoute OPTIONAL// // This buffer will (optionally) receive
    // the best route for the same network
    // if RTM_CURRENT_BEST_ROUTE is set
    ) {
#define ROUTE ((PRTM_XX_ROUTE)Route)
#define ClientPtr ((PRTM_CLIENT)ClientHandle)
    DWORD                                   status; // Operation result
    INT                                             res;    // Comparison result
    PRTM_SYNC_LIST                  hashBasket;     // Hash basket to which the route belongs
    PLIST_ENTRY                             cur;
    PRTM_ROUTE_NODE                 theNode=NULL,// Table node associated with the route
        curBestNode=NULL; // New best route for the
    // network which route is deleted
    // (if any)

    PRTM_TABLE                              Table;
    DWORD                                   ProtocolFamily;

    try {
        ProtocolFamily = ClientPtr->RC_ProtocolFamily ^ RTM_CLIENT_HANDLE_TAG;
        Table = &Tables[ProtocolFamily];
        if ((ProtocolFamily<RTM_NUM_OF_PROTOCOL_FAMILIES)
            && EnterTableAPI (Table))
            NOTHING;
        else
            return ERROR_INVALID_HANDLE;
    }
    except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
            EXCEPTION_EXECUTE_HANDLER :
            EXCEPTION_CONTINUE_SEARCH) {
        return ERROR_INVALID_HANDLE;
    }


    ROUTE->XX_PROTOCOL = ClientPtr->RC_RoutingProtocol;

                        // Try locate the node in hash basket
    hashBasket = &Table->RT_NetNumberHash [HashFunction (Table,
                                                         ((char *)ROUTE)
                                                         +sizeof(RTM_XX_ROUTE))];

    if (!EnterSyncList (Table, hashBasket, TRUE)) {
        ExitTableAPI (Table);
        return ERROR_NO_SYSTEM_RESOURCES;
    }

    cur = hashBasket->RSL_Head.Flink;
    while (cur!=&hashBasket->RSL_Head) {
        PRTM_ROUTE_NODE node = CONTAINING_RECORD (
            cur,
            RTM_ROUTE_NODE,
            RN_Links[RTM_NET_NUMBER_HASH_LINK]
            );
        if (!IsEnumerator (node)) {

            // Check if network number matches
            res = NetNumCmp (Table, ROUTE, &node->RN_Route);

            if (res==0) {
                // Go through entries for network of interest

                // Try to locate the route to be deleted
                if ((theNode==NULL)
                    && (ROUTE->XX_INTERFACE
                        == node->RN_Route.XX_INTERFACE)
                    && (ROUTE->XX_PROTOCOL
                        == node->RN_Route.XX_PROTOCOL)
                    && (NextHopCmp (Table, ROUTE, &node->RN_Route)
                        ==0)) {
                    theNode = node;
                    if (!IsBest(theNode))
                        break;
                }
                else if (IsEnabled(node)
                         && ((curBestNode==NULL)
                             || (MetricCmp (Table,
                                            &curBestNode->RN_Route,
                                            &node->RN_Route)>0)))
                    curBestNode = node;

            }
            else if (res < 0)
                // We passed the place where routes for our
                // network are located
                break;
        }
        cur = cur->Flink;
    }


    if (theNode!=NULL) {    // Yes, we found the node
        if (IsBest(theNode)) { // And it was the best,
            // inform interested clients
            if (curBestNode!=NULL) {        // There is another best node

                ResetBest (theNode);
                SetBest (curBestNode);

                *Flags = RTM_CURRENT_BEST_ROUTE | RTM_PREVIOUS_BEST_ROUTE;
                if (ARGUMENT_PRESENT(CurBestRoute))
                    memcpy (CurBestRoute, &curBestNode->RN_Route,
                            Table->RT_RouteSize);
                NotifyClients (Table, ClientHandle, *Flags,
                               &curBestNode->RN_Route,
                               &theNode->RN_Route);
            }
            else {                          // This one was the only available node
                InterlockedDecrement (&Table->RT_NetworkCount);
                *Flags = RTM_PREVIOUS_BEST_ROUTE;
                NotifyClients (Table, ClientHandle, *Flags, NULL, &theNode->RN_Route);


                //
                // Decrement mask count
                //
                
                SetMaskCount( (PIP_NETWORK) NNM( ROUTE ), FALSE );
    
            }
        }
        else    // This was not the best node, nobody cares
            *Flags = 0;

        status = RemoveRouteNode (Table, theNode);
    }
    else
        // Well, we don't have this node already (aged out ?)
        status = ERROR_NO_SUCH_ROUTE;

    LeaveSyncList (Table, hashBasket);
    ExitTableAPI (Table);
#undef ClientPtr
#undef ROUTE
    return status;
}



// Check if route exists and return it if so.
// Returns:
//                      TRUE if route exists for the given network
//                      FALSE otherwise
// If one of the parameters is invalid, the function returns FALSE
// and GetLastError() returns ERROR_INVALID_PARAMETER
BOOL WINAPI
RtmIsRoute (
    IN      DWORD           ProtocolFamily,
    IN      PVOID           Network,                        // Network whose existence is being checked
    OUT PVOID           BestRoute OPTIONAL      // Returns the best route if the network
    // is found
    ) {
    INT                                             res;
    PRTM_TABLE                              Table;
    PRTM_SYNC_LIST                  hashBasket;
    PLIST_ENTRY                             cur;
    PRTM_ROUTE_NODE                 bestNode = NULL;
    BOOL                                    result = FALSE;

    Table = &Tables[ProtocolFamily];
    if ((ProtocolFamily>=RTM_NUM_OF_PROTOCOL_FAMILIES)
        || !EnterTableAPI (Table)) {
#if DBG
        Trace2 (ANY, 
                 "Undefined Protocol Family\n\tat line %ld of %s\n",
                 __LINE__, __FILE__);
#endif
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }



    // Locate the network in the hash basket
    hashBasket = &Table->RT_NetNumberHash[HashFunction (Table, Network)];

    if (!EnterSyncList (Table, hashBasket, TRUE)) {
        ExitTableAPI (Table);
        SetLastError (ERROR_NO_SYSTEM_RESOURCES);
        return FALSE;
    }

    cur = hashBasket->RSL_Head.Flink;
    while (cur!=&hashBasket->RSL_Head) {
        PRTM_ROUTE_NODE                 node;
        node = CONTAINING_RECORD (
            cur,
            RTM_ROUTE_NODE,
            RN_Links[RTM_NET_NUMBER_HASH_LINK]
            );
        if (!IsEnumerator (node)
            && IsEnabled(node)) {

            res = (*Table->RT_Config.RPFC_NNcmp) (
                Network,
                NNM(&node->RN_Route));

            if ((res == 0)
                && IsBest(node)) {
                bestNode = node;
                break;
            }
            else if (res < 0)
                break;
        }
        cur = cur->Flink;
    }



    if (bestNode!=NULL) { // We found a match
        if (ARGUMENT_PRESENT(BestRoute)) {
            memcpy (BestRoute, &bestNode->RN_Route, Table->RT_RouteSize);
        }
        LeaveSyncList (Table, hashBasket);
        result = TRUE;
    }
    else {
        // We don't have one (result is FALSE by default)
        LeaveSyncList (Table, hashBasket);
        // This is not an error condition, we just do not have it
        SetLastError (NO_ERROR);
    }

    ExitTableAPI (Table);
    return result;
}


// Gets number of networks with known routes for a specific protocol family
ULONG WINAPI
RtmGetNetworkCount (
    IN      DWORD           ProtocolFamily
    ) {
    PRTM_TABLE              Table;

    Table = &Tables[ProtocolFamily];
    if ((ProtocolFamily>=RTM_NUM_OF_PROTOCOL_FAMILIES)
        || !EnterTableAPI (&Tables[ProtocolFamily])) {
#if DBG
        Trace2 (ANY, 
                 "Undefined Protocol Family\n\tat line %ld of %s\n",
                 __LINE__, __FILE__);
#endif
        SetLastError (ERROR_INVALID_PARAMETER);
        return 0;
    }


    ExitTableAPI (Table);
    return Table->RT_NetworkCount;
}

// Gets route age (time since it was created or updated last) in seconds
// from its time stamp.
// Rtm time stamps routes whenever they are added or updated.
// Note: that information returned by this routine is actually
// derived from TimeStamp field of the route structure, so it
// returns valid results only if route structure passed to was
// actually filled by Rtm
// If value in TimeStamp field is invalid this routing returns 0xFFFFFFFF
ULONG WINAPI
RtmGetRouteAge (
    IN PVOID        Route
    ) {
#define ROUTE ((PRTM_XX_ROUTE)Route)
    ULONGLONG               curTime;
    GetSystemTimeAsFileTime ((FILETIME *)&curTime);
    curTime -= *((PULONGLONG)&ROUTE->XX_TIMESTAMP);
    if (((PULARGE_INTEGER)&curTime)->HighPart<10000000)
        return (ULONG)(curTime/10000000);
    else {
        SetLastError (ERROR_INVALID_PARAMETER);
        return 0xFFFFFFFF;
    }
#undef ROUTE
}


// Creates enumeration handle to start scan by specified criteria.
// Places a dummy node in the beginning of the table.
// Returns NULL in case of failure.  Call GetLastError () to get extended
// error information
// Error codes:
//      ERROR_INVALID_PARAMETER - specified protocol family is not supported or
//                                                      undefined enumeration flag
//      ERROR_NO_ROUTES - no routes exist with specified criteria
//      ERROR_NO_SYSTEM_RESOURCES - not enough resources to lock table content
//      ERROR_NOT_ENOUGH_MEMORY - not enough memory to allocate client control block
HANDLE WINAPI
RtmCreateEnumerationHandle (
    IN      DWORD           ProtocolFamily,
    IN      DWORD           EnumerationFlags,       // Limitation flags
    IN      PVOID           CriteriaRoute // Criteria for limitation flags
    // The following fields shout be set
    // Protocol if interest if RTM_ONLY_THIS_PROTOCOL is set
    // Network of interest if RTM_ONLY_THIS_NETWORK is set
    // Interface of interest if RTM_ONLY_THIS_INTERFACE is set
    ) {
#define ROUTE ((PRTM_XX_ROUTE)CriteriaRoute)
    HANDLE                          EnumerationHandle;
#define EnumPtr ((PRTM_ENUMERATOR)EnumerationHandle) // To access fields
    // in this routine
    PRTM_TABLE                      Table;

    Table = &Tables[ProtocolFamily];
    if ((ProtocolFamily>=RTM_NUM_OF_PROTOCOL_FAMILIES)
        || !EnterTableAPI (&Tables[ProtocolFamily])) {
#if DBG
        Trace2 (ANY, 
                 "Undefined Protocol Family\n\tat line %ld of %s\n",
                 __LINE__, __FILE__);
#endif
        SetLastError (ERROR_INVALID_PARAMETER);
        return NULL;
    }

    if (EnumerationFlags &
        (~(RTM_ONLY_THIS_NETWORK|RTM_ONLY_THIS_INTERFACE
           |RTM_ONLY_THIS_PROTOCOL|RTM_ONLY_BEST_ROUTES
           |RTM_INCLUDE_DISABLED_ROUTES))) {
        ExitTableAPI (Table);
        SetLastError (ERROR_INVALID_PARAMETER);
        return NULL;
    }

    // Allocate and initialize enumerator
    EnumerationHandle = GlobalAlloc (GMEM_FIXED,
                                     FIELD_OFFSET (RTM_ENUMERATOR, RE_Route)+Table->RT_RouteSize);
    if (EnumerationHandle!=NULL) {
        EnumPtr->RE_Flags = RTM_ENUMERATOR_FLAGS_INIT;
        EnumPtr->RE_EnumerationFlags = EnumerationFlags;
        if (EnumerationFlags
            & (RTM_ONLY_THIS_NETWORK
               |RTM_ONLY_THIS_INTERFACE
               |RTM_ONLY_THIS_PROTOCOL))
            memcpy (&EnumPtr->RE_Route, CriteriaRoute, Table->RT_RouteSize);
        EnumPtr->RE_Hash = NULL;
        EnumPtr->RE_Head = NULL;
        // WHICH LIST TO USE ?
        // In general we should have more interfaces than protocols,
        // so:
        //      if they only want a specific interface, we'll use
        //      the interface list even if they want a specific protocol too
        if (EnumerationFlags & RTM_ONLY_THIS_INTERFACE) {
            EnumPtr->RE_Link = RTM_INTERFACE_LIST_LINK;
            EnumPtr->RE_Lock = &Table->RT_InterfaceHash[IntfHashFunction(Table,
                                                                         EnumPtr->RE_Route.XX_INTERFACE)];
            if (EnterSyncList (Table, EnumPtr->RE_Lock, TRUE)) {
                EnumPtr->RE_Head = FindInterfaceList (EnumPtr->RE_Lock,
                                                      EnumPtr->RE_Route.XX_INTERFACE, FALSE);
                if (EnumPtr->RE_Head!=NULL) {
                    InsertTailList (EnumPtr->RE_Head,
                                    &EnumPtr->RE_Links[EnumPtr->RE_Link]);
                }
                LeaveSyncList (Table, EnumPtr->RE_Lock);
            }
        }
#if RTM_USE_PROTOCOL_LISTS
        else if (EnumerationFlags & RTM_ONLY_THIS_PROTOCOL) {
            //      if they only want a specific protocol, we'll use
            //      the protocol list
            EnumPtr->RE_Link = RTM_PROTOCOL_LIST_LINK;
            EnumPtr->RE_Lock = &Table->RT_ProtocolList;
            if (EnterSyncList (Table, EnumPtr->RE_Lock, TRUE)) {
                EnumPtr->RE_Head = FindProtocolList (Table,
                                                     EnumPtr->RE_Route.XX_PROTOCOL, FALSE);
                if (EnumPtr->RE_Head!=NULL) {
                    InsertTailList (EnumPtr->RE_Head,
                                    &EnumPtr->RE_Links[EnumPtr->RE_Link]);
                }
                LeaveSyncList (Table, EnumPtr->RE_Lock);
            }
        }
#endif
        else {
            //      otherwise, we have to use hash table
            EnumPtr->RE_Link = RTM_NET_NUMBER_HASH_LINK;
            //      Now, if they want a specific network,
            //      we'll only search in one hash basket
            if (EnumerationFlags & RTM_ONLY_THIS_NETWORK) {
                EnumPtr->RE_Lock = &Table->RT_NetNumberHash[HashFunction (
                    Table,
                    ((char *)ROUTE)
                    +sizeof(RTM_XX_ROUTE))];
                if (EnterSyncList (Table, EnumPtr->RE_Lock, TRUE)) {
                    if (!IsListEmpty (&EnumPtr->RE_Lock->RSL_Head)) {
                        EnumPtr->RE_Head = &EnumPtr->RE_Lock->RSL_Head;
                        InsertTailList (EnumPtr->RE_Head,
                                        &EnumPtr->RE_Links[EnumPtr->RE_Link]);
                    }
                    LeaveSyncList (Table, EnumPtr->RE_Lock);
                }
            }
            else {
                //      Otherwise, we'll have to go through all of them
                //      starting with the first one
                EnumPtr->RE_Lock = &Table->RT_NetNumberHash[0];
                if (EnterSyncList (Table, EnumPtr->RE_Lock, TRUE)) {
                    EnumPtr->RE_Head = &EnumPtr->RE_Lock->RSL_Head;
                    InsertTailList (EnumPtr->RE_Head,
                                    &EnumPtr->RE_Links[EnumPtr->RE_Link]);
                    LeaveSyncList (Table, EnumPtr->RE_Lock);
                }
            }
        }

        if (EnumPtr->RE_Head!=NULL)
            EnumPtr->RE_ProtocolFamily = ProtocolFamily | RTM_CLIENT_HANDLE_TAG;
        else {
            GlobalFree (EnumerationHandle);
            EnumerationHandle = NULL;
            SetLastError (ERROR_NO_ROUTES);
        }
    }

    ExitTableAPI (Table);
    return EnumerationHandle;
#undef EnumPtr
}


// Returns first route that satisfies criteria of the enumeration handle
// and advances handle's dummy node past the returned route.
// Routes are not returned in any particular order.
// Returns
//              NO_ERROR                        - if next route was found in the table acording
//                                                              to specified criteria
//              ERROR_NO_MORE_ROUTES - when end of the table is reached,
//              ERROR_NO_SYSTEM_RESOURCES       - not enough resources to lock table content
DWORD WINAPI
RtmEnumerateGetNextRoute (
    IN  HANDLE      EnumerationHandle,      // Handle returned by prev call
    OUT PVOID               Route                           // Next route found
    ) {
#define EnumPtr ((PRTM_ENUMERATOR)EnumerationHandle) // To access fields
    // in this routine
    DWORD                           status;
    PRTM_TABLE                      Table;
    DWORD                           ProtocolFamily;

    try {
        ProtocolFamily = EnumPtr->RE_ProtocolFamily ^ RTM_CLIENT_HANDLE_TAG;
        Table = &Tables[ProtocolFamily];
        if ((ProtocolFamily<RTM_NUM_OF_PROTOCOL_FAMILIES)
            && EnterTableAPI (Table))
            NOTHING;
        else
            return ERROR_INVALID_HANDLE;
    }
    except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
            EXCEPTION_EXECUTE_HANDLER :
            EXCEPTION_CONTINUE_SEARCH) {
        return ERROR_INVALID_HANDLE;
    }


    if (!EnterSyncList (Table, EnumPtr->RE_Lock, TRUE)) {
        ExitTableAPI (Table);
        return ERROR_NO_SYSTEM_RESOURCES;
    }
    status = DoEnumerate (Table, EnumPtr,
                          (EnumPtr->RE_EnumerationFlags&RTM_INCLUDE_DISABLED_ROUTES)
                          ? RTM_ANY_ENABLE_STATE
                          : RTM_ENABLED_NODE_FLAG);
    if (status==NO_ERROR) {
        PRTM_ROUTE_NODE node = CONTAINING_RECORD (
            EnumPtr->RE_Links[EnumPtr->RE_Link].Flink,
            RTM_ROUTE_NODE,
            RN_Links[EnumPtr->RE_Link]
            );


        // Copy found route to the client's buffer
        memcpy (Route, &node->RN_Route, Table->RT_RouteSize);
        if (EnumPtr->RE_EnumerationFlags&RTM_ONLY_BEST_ROUTES) {
            // Move past all entries of given network
            // so we don't return more than one best route
            // for same network in case best route gets reassigned
            // while client is processing results of this call
            // (because we enumerate in the direction opposite
            // to the direction of insertion, new node can't
            // be inserted before the enumerator)
            PLIST_ENTRY     cur     = EnumPtr->RE_Links[EnumPtr->RE_Link].Blink;
            while (cur!=EnumPtr->RE_Head) {
                node = CONTAINING_RECORD (cur, RTM_ROUTE_NODE,
                                          RN_Links[EnumPtr->RE_Link]);

                if (!IsEnumerator (node)
                    && (NetNumCmp (Table, Route, &node->RN_Route)!=0))
                    break;
                cur = cur->Blink;
            }
            RemoveEntryList (&EnumPtr->RE_Links[EnumPtr->RE_Link]);
            InsertHeadList (cur, &EnumPtr->RE_Links[EnumPtr->RE_Link]);
        }

    }
    else if (status==ERROR_NO_MORE_ROUTES) {
        // We are at the end of the list, nothing to return
        ;
    }
    else {
        // There was an error (DoEnumerate cleaned up everything itself)
        ExitTableAPI (Table);
        return status;
    }

    if (EnumPtr->RE_Hash!=NULL) {
        LeaveSyncList (Table, EnumPtr->RE_Hash);
        EnumPtr->RE_Hash = NULL;
    }

    LeaveSyncList (Table, EnumPtr->RE_Lock);
    ExitTableAPI (Table);
    return status;
#undef EnumPtr
}

// Frees resources allocated for enumeration handle
// Returned error codes:
//      NO_ERROR - handle was disposed of ok
//      ERROR_NO_SYSTEM_RESOURCES - not enough resources to lock table content
DWORD WINAPI
RtmCloseEnumerationHandle (
    IN HANDLE               EnumerationHandle
    ) {
#define EnumPtr ((PRTM_ENUMERATOR)EnumerationHandle) // To access fields
    // in this routine
    PLIST_ENTRY             head;
    PRTM_TABLE              Table;
    DWORD                   ProtocolFamily;

    try {
        ProtocolFamily = EnumPtr->RE_ProtocolFamily ^ RTM_CLIENT_HANDLE_TAG;
        Table = &Tables[ProtocolFamily];
        if ((ProtocolFamily<RTM_NUM_OF_PROTOCOL_FAMILIES)
            && EnterTableAPI (Table))
            NOTHING;
        else
            return ERROR_INVALID_HANDLE;
    }
    except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
            EXCEPTION_EXECUTE_HANDLER :
            EXCEPTION_CONTINUE_SEARCH) {
        return ERROR_INVALID_HANDLE;
    }


    // Just pull out the enumeration node and dispose of it
    if (!EnterSyncList (Table, EnumPtr->RE_Lock, TRUE)) {
        ExitTableAPI (Table);
        return ERROR_NO_SYSTEM_RESOURCES;
    }

    head = EnumPtr->RE_Links[EnumPtr->RE_Link].Flink;
    RemoveEntryList (&EnumPtr->RE_Links[EnumPtr->RE_Link]);
    if (IsListEmpty (head)) {
        if (EnumPtr->RE_Link==RTM_INTERFACE_LIST_LINK) {
            PRTM_INTERFACE_NODE     intfNode = CONTAINING_RECORD (head,
                                                                  RTM_INTERFACE_NODE,
                                                                  IN_Head);
            RemoveEntryList (&intfNode->IN_Link);
            GlobalFree (intfNode);
        }
#if RTM_USE_PROTOCOL_LISTS
        else if (EnumPtr->RE_Link==RTM_PROTOCOL_LIST_LINK) {
            PRTM_PROTOCOL_NODE      protNode = CONTAINING_RECORD (head,
                                                                  RTM_PROTOCOL_NODE,
                                                                  PN_Head);
            RemoveEntryList (&protNode->PN_Link);
            GlobalFree (protNode);
        }
#endif
    }
    EnumPtr->RE_ProtocolFamily ^= RTM_CLIENT_HANDLE_TAG;
    LeaveSyncList (Table, EnumPtr->RE_Lock);
    GlobalFree (EnumerationHandle);
    ExitTableAPI (Table);
    return NO_ERROR;
#undef EnumPtr
}

// Delete all routes as specified by enumeraion flags (same meaning as in
// enumeration calls above, but RTM_ONLY_THIS_PROTOCOL is always set and protocol
// family and protocol values are taken from Client Handle).
// Returned error codes:
//      NO_ERROR - handle was disposed of ok
//      ERROR_INVALID_PARAMETER - undefined or unsupported enumeration flag
//      ERROR_NO_SYSTEM_RESOURCES - not enough resources to lock table content
//      ERROR_NOT_ENOUGH_MEMORY - not enough memory no perform the operation
DWORD WINAPI
RtmBlockDeleteRoutes (
    IN HANDLE               ClientHandle,           // Protocol family and protocol to
    // which this operation applies
    IN DWORD                EnumerationFlags,       // limitation flags
    IN PVOID                CriteriaRoute // Criteria for limitation flags
    // The following fields shout be set
    // Network of interest if RTM_ONLY_THIS_NETWORK is set
    // Interface of interest if RTM_ONLY_THIS_INTERFACE is set
    ) {
#define ROUTE ((PRTM_XX_ROUTE)CriteriaRoute)
#define ClientPtr ((PRTM_CLIENT)ClientHandle)   // To access handle fields
    // in this routine
    HANDLE                  EnumerationHandle;
#define EnumPtr ((PRTM_ENUMERATOR)EnumerationHandle)
    DWORD                   status;
    PRTM_TABLE              Table;
    DWORD                   ProtocolFamily;

    try {
        ProtocolFamily = ClientPtr->RC_ProtocolFamily ^ RTM_CLIENT_HANDLE_TAG;
        Table = &Tables[ProtocolFamily];
        if ((ProtocolFamily<RTM_NUM_OF_PROTOCOL_FAMILIES)
            && EnterTableAPI (Table))
            NOTHING;
        else
            return ERROR_INVALID_HANDLE;
    }
    except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
            EXCEPTION_EXECUTE_HANDLER :
            EXCEPTION_CONTINUE_SEARCH) {
        return ERROR_INVALID_HANDLE;
    }

    if (EnumerationFlags & (~(RTM_ONLY_THIS_NETWORK|RTM_ONLY_THIS_INTERFACE))) {
        ExitTableAPI (Table);
        return ERROR_INVALID_PARAMETER;
    }

    ROUTE->XX_PROTOCOL = ClientPtr->RC_RoutingProtocol;
    EnumerationFlags |= RTM_ONLY_THIS_PROTOCOL;
    EnumerationHandle = RtmCreateEnumerationHandle (
        ProtocolFamily,
        EnumerationFlags,
        CriteriaRoute);
    if (EnumerationHandle==NULL) {
        ExitTableAPI (Table);
        return GetLastError ();
    }

    if (!EnterSyncList (Table, EnumPtr->RE_Lock, TRUE)) {
        RtmCloseEnumerationHandle (EnumerationHandle);
        ExitTableAPI (Table);
        return ERROR_NO_SYSTEM_RESOURCES;
    }

    while ((status=DoEnumerate (Table, EnumPtr, RTM_ANY_ENABLE_STATE))==NO_ERROR) {
        PRTM_ROUTE_NODE theNode = CONTAINING_RECORD (
            EnumPtr->RE_Links[EnumPtr->RE_Link].Flink,
            RTM_ROUTE_NODE,
            RN_Links[EnumPtr->RE_Link]
            );
        if (EnumPtr->RE_Link!=RTM_NET_NUMBER_HASH_LINK)
            LeaveSyncList (Table, EnumPtr->RE_Lock);

        if (IsBest(theNode)) {
            // We'll look back and forward to check all nodes
            // around us with same net number trying to find another best
            // node
            DWORD   Flags;
            PRTM_ROUTE_NODE curBestNode=NULL;
            PLIST_ENTRY cur = theNode->RN_Links[RTM_NET_NUMBER_HASH_LINK].Blink;
            while (cur!=&theNode->RN_Hash->RSL_Head) {
                PRTM_ROUTE_NODE node1 = CONTAINING_RECORD (
                    cur,
                    RTM_ROUTE_NODE,
                    RN_Links[RTM_NET_NUMBER_HASH_LINK]);
                if (!IsEnumerator (node1)
                    && IsEnabled(node1)) {
                    if (NetNumCmp (Table, &theNode->RN_Route,
                                   &node1->RN_Route)==0) {
                        if ((curBestNode==NULL)
                            || (MetricCmp (Table,
                                           &curBestNode->RN_Route,
                                           &node1->RN_Route)>0))
                            // Looking for the node with lowest
                            // metric that can replace disabled
                            // node
                            curBestNode = node1;
                    }
                    else
                        break;
                }
                cur = cur->Blink;
            }

            cur = theNode->RN_Links[RTM_NET_NUMBER_HASH_LINK].Flink;
            while (cur!=&theNode->RN_Hash->RSL_Head) {
                PRTM_ROUTE_NODE node1 = CONTAINING_RECORD (
                    cur,
                    RTM_ROUTE_NODE,
                    RN_Links[RTM_NET_NUMBER_HASH_LINK]);
                if (!IsEnumerator (node1)
                    && IsEnabled(node1)) {
                    if (NetNumCmp (Table, &theNode->RN_Route,
                                   &node1->RN_Route)==0) {
                        if ((curBestNode==NULL)
                            || (MetricCmp (Table,
                                           &curBestNode->RN_Route,
                                           &node1->RN_Route)>0))
                            curBestNode = node1;
                    }
                    else
                        break;
                }
                cur = cur->Flink;
            }

            if (curBestNode!=NULL) {        // There is another best node

                ResetBest (theNode);
                SetBest (curBestNode);

                Flags = RTM_CURRENT_BEST_ROUTE | RTM_PREVIOUS_BEST_ROUTE;
                NotifyClients (Table, ClientHandle, Flags,
                               &curBestNode->RN_Route,
                               &theNode->RN_Route);
            }
            else {                          // This one was the only available node
                InterlockedDecrement (&Table->RT_NetworkCount);
                Flags = RTM_PREVIOUS_BEST_ROUTE;
                NotifyClients (Table, ClientHandle, Flags, NULL, &theNode->RN_Route);
            }
        }

        status = RemoveRouteNode (Table, theNode);
        if (status!=NO_ERROR)
            break;

        if (EnumPtr->RE_Link!=RTM_NET_NUMBER_HASH_LINK) {
            if (!EnterSyncList (Table, EnumPtr->RE_Lock, TRUE)) {
                status = ERROR_NO_SYSTEM_RESOURCES;
                if (EnumPtr->RE_Hash!=NULL)
                    LeaveSyncList (Table, EnumPtr->RE_Hash);
                break;
            }
        }
    }

    if (status==ERROR_NO_MORE_ROUTES) {
        if (EnumPtr->RE_Hash!=NULL)
            LeaveSyncList (Table, EnumPtr->RE_Hash);
        LeaveSyncList (Table, EnumPtr->RE_Lock);

        status = NO_ERROR;
    }

    RtmCloseEnumerationHandle (EnumerationHandle);
    ExitTableAPI (Table);
    return status;
#undef EnumPtr
#undef ClientPtr
#undef ROUTE
}

// Converts all routes as specified by enumeration flags to routes of
// static protocol (as defined by ClientHandle)
// Returned error codes:
//      NO_ERROR - routes were converted ok
//      ERROR_INVALID_PARAMETER - undefined or unsupported enumeration flag
//      ERROR_NO_SYSTEM_RESOURCES - not enough resources to lock table content
//      ERROR_NOT_ENOUGH_MEMORY - not enough memory no perform the operation
DWORD WINAPI
RtmBlockConvertRoutesToStatic (
    IN HANDLE               ClientHandle,           // Handle of client that registered
    // to handle static protocol for
    // specified protocol family
    IN DWORD                EnumerationFlags,       // limitation flags
    IN PVOID                CriteriaRoute // Criteria for limitation flags
    // The following fields shout be set
    // Protocol of interest if RTM_ONLY_THIS_PROTOCOL is set
    // Network of interest if RTM_ONLY_THIS_NETWORK is set
    // Interface of interest if RTM_ONLY_THIS_INTERFACE is set
    ) {
#define ClientPtr ((PRTM_CLIENT)ClientHandle)   // To access handle fields
    // in this routine
    HANDLE                  EnumerationHandle;
#define EnumPtr ((PRTM_ENUMERATOR)EnumerationHandle)
    DWORD                   status;
    PRTM_TABLE              Table;
    DWORD                   ProtocolFamily;

    try {
        ProtocolFamily = ClientPtr->RC_ProtocolFamily ^ RTM_CLIENT_HANDLE_TAG;
        Table = &Tables[ProtocolFamily];
        if ((ProtocolFamily<RTM_NUM_OF_PROTOCOL_FAMILIES)
            && EnterTableAPI (Table))
            NOTHING;
        else
            return ERROR_INVALID_HANDLE;
    }
    except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
            EXCEPTION_EXECUTE_HANDLER :
            EXCEPTION_CONTINUE_SEARCH) {
        return ERROR_INVALID_HANDLE;
    }



    EnumerationHandle = RtmCreateEnumerationHandle (
        ProtocolFamily,
        EnumerationFlags,
        CriteriaRoute);
    if (EnumerationHandle==NULL) {
        ExitTableAPI(Table);
        return GetLastError ();
    }

    if (!EnterSyncList (Table, EnumPtr->RE_Lock, TRUE)) {
        RtmCloseEnumerationHandle (EnumerationHandle);
        ExitTableAPI(Table);
        return ERROR_NO_SYSTEM_RESOURCES;
    }

    while ((status=DoEnumerate (Table, EnumPtr, RTM_ENABLED_NODE_FLAG))==NO_ERROR) {
        PRTM_ROUTE_NODE theNode;
        PRTM_ROUTE_NODE node = CONTAINING_RECORD (
            EnumPtr->RE_Links[EnumPtr->RE_Link].Flink,
            RTM_ROUTE_NODE,
            RN_Links[EnumPtr->RE_Link]
            );
        if (ClientPtr->RC_RoutingProtocol==node->RN_Route.XX_PROTOCOL)
            continue;

        if (EnumPtr->RE_Link!=RTM_NET_NUMBER_HASH_LINK)
            LeaveSyncList (Table, EnumPtr->RE_Lock);

        if (ClientPtr->RC_RoutingProtocol>node->RN_Route.XX_PROTOCOL) {
            PLIST_ENTRY cur = node->RN_Links[RTM_NET_NUMBER_HASH_LINK].Flink;
            while (cur!=&node->RN_Hash->RSL_Head) {
                PRTM_ROUTE_NODE node1 = CONTAINING_RECORD (
                    cur,
                    RTM_ROUTE_NODE,
                    RN_Links[RTM_NET_NUMBER_HASH_LINK]
                    );
                if (!IsEnumerator (node1)) {
                    INT res = NetNumCmp (Table, &node->RN_Route, &node1->RN_Route);
                    if (res==0) {
                        if (ClientPtr->RC_RoutingProtocol
                            == node1->RN_Route.XX_PROTOCOL) {
                            if (node->RN_Route.XX_INTERFACE
                                == node1->RN_Route.XX_INTERFACE) {
                                res = NextHopCmp (Table, &node->RN_Route, &node1->RN_Route);
                                ASSERTMSG ("RtmBlockConvertRoutesToStatic:"
                                           " Already have same static route ",
                                           res != 0);
                                if (res <= 0)
                                    break;
                            }
                            else if (node->RN_Route.XX_INTERFACE
                                     < node1->RN_Route.XX_INTERFACE)
                                break;
                        }
                        else if (ClientPtr->RC_RoutingProtocol
                                 < node1->RN_Route.XX_PROTOCOL)
                            break;
                    }
                    else if (res<0)
                        break;
                }
                cur = cur->Flink;
            }
            theNode = CreateRouteNode (Table,
                                       cur,
                                       &node->RN_Links[RTM_INTERFACE_LIST_LINK],
                                       FALSE,
                                       node->RN_Hash,
                                       &node->RN_Route);
        }
        else {
            PLIST_ENTRY cur = node->RN_Links[RTM_NET_NUMBER_HASH_LINK].Blink;
            while (cur!=&node->RN_Hash->RSL_Head) {
                PRTM_ROUTE_NODE node1 = CONTAINING_RECORD (
                    cur,
                    RTM_ROUTE_NODE,
                    RN_Links[RTM_NET_NUMBER_HASH_LINK]
                    );
                if (!IsEnumerator (node1)) {
                    INT res = NetNumCmp (Table, &node->RN_Route, &node1->RN_Route);
                    if (res==0) {
                        if (ClientPtr->RC_RoutingProtocol
                            == node1->RN_Route.XX_PROTOCOL) {
                            if (node->RN_Route.XX_INTERFACE
                                == node1->RN_Route.XX_INTERFACE) {
                                res = NextHopCmp (Table, &node->RN_Route, &node1->RN_Route);
                                ASSERTMSG ("RtmBlockConvertRoutesToStatic:"
                                           " Already have same static route ",
                                           res != 0);
                                if (res >= 0)
                                    break;
                            }
                            else if (node->RN_Route.XX_INTERFACE
                                     > node1->RN_Route.XX_INTERFACE)
                                break;
                        }
                        else if (ClientPtr->RC_RoutingProtocol
                                 > node1->RN_Route.XX_PROTOCOL)
                            break;
                    }
                    else if (res>0)
                        break;
                }
                cur = cur->Blink;
            }
            theNode = CreateRouteNode (Table,
                                       cur->Flink,
                                       &node->RN_Links[RTM_INTERFACE_LIST_LINK],
                                       TRUE,
                                       node->RN_Hash,
                                       &node->RN_Route);
        }

        if (theNode==NULL) {
            status = GetLastError ();
            if (EnumPtr->RE_Hash!=NULL)
                LeaveSyncList (Table, EnumPtr->RE_Hash);
            break;
        }

        theNode->RN_Route.XX_PROTOCOL = ClientPtr->RC_RoutingProtocol;
        theNode->RN_Flags = node->RN_Flags;
        status = RemoveRouteNode (Table, node);
        if (status!=NO_ERROR)
            break;

        if (EnumPtr->RE_Link!=RTM_NET_NUMBER_HASH_LINK) {
            if (!EnterSyncList (Table, EnumPtr->RE_Lock, TRUE)) {
                status = ERROR_NO_SYSTEM_RESOURCES;
                if (EnumPtr->RE_Hash!=NULL)
                    LeaveSyncList (Table, EnumPtr->RE_Hash);
                break;
            }
        }
    }

    if (status==ERROR_NO_MORE_ROUTES) {
        if (EnumPtr->RE_Hash!=NULL)
            LeaveSyncList (Table, EnumPtr->RE_Hash);
        LeaveSyncList (Table, EnumPtr->RE_Lock);

        status = NO_ERROR;
    }

    RtmCloseEnumerationHandle (EnumerationHandle);
    ExitTableAPI (Table);
    return status;
#undef EnumPtr
#undef ClientPtr
}

// Disables/reenables all routes as specified by enumeraion flags
// (same meaning as in enumeration calls above, but RTM_ONLY_THIS_PROTOCOL
// is always set and protocol family and protocol values are taken from
// Client Handle).

// Disables/reenables all routes as specified by enumeraion flags
// (same meaning as in enumeration calls above, but RTM_ONLY_THIS_PROTOCOL
// is always set and protocol family and protocol values are taken from
// Client Handle). Currently the only flag supported is RTN_ONLY_THIS_INTERFACE

// Disabled routes are invisible, but still maintained by the RTM.
// E.g.:        enumeration methods won't notice them;
//                      if disabled route was the best, other route will take its
//                              place (if there is one) and all clients will be
//                              notified of best route change;
//      however: disabled route can still be deleted or updated using
//                              RtmDeleteRoute or RtmAddRoute correspondingly;
//                      they can also be aged out by the RTM itself.
// Returned error codes:
//      NO_ERROR - routes were converted ok
//      ERROR_INVALID_PARAMETER - undefined or unsupported enumeration flag
//      ERROR_NO_SYSTEM_RESOURCES - not enough resources to lock table content
//      ERROR_NOT_ENOUGH_MEMORY - not enough memory no perform the operation
DWORD WINAPI
RtmBlockSetRouteEnable (
    IN HANDLE               ClientHandle,           // Protocol family and protocol to
    // which this operation applies
    IN DWORD                EnumerationFlags,       // limitation flags
    IN PVOID                CriteriaRoute, // Criteria for limitation flags
    // The following fields shout be set
    // Network of interest if RTM_ONLY_THIS_NETWORK is set
    // Interface of interest if RTM_ONLY_THIS_INTERFACE is set
    IN BOOL                 Enable                          // FALSE to disable routes, TRUE to
    // reenable them
    ) {
#define ClientPtr ((PRTM_CLIENT)ClientHandle)   // To access handle fields
    // in this routine
#define ROUTE ((PRTM_XX_ROUTE)CriteriaRoute)
    HANDLE                  EnumerationHandle;
#define EnumPtr ((PRTM_ENUMERATOR)EnumerationHandle)
    DWORD                   status;
    PRTM_TABLE              Table;
    DWORD                   ProtocolFamily;
    DWORD                   EnableFlag;

    try {
        ProtocolFamily = ClientPtr->RC_ProtocolFamily ^ RTM_CLIENT_HANDLE_TAG;
        Table = &Tables[ProtocolFamily];
        if ((ProtocolFamily<RTM_NUM_OF_PROTOCOL_FAMILIES)
            && EnterTableAPI (Table))
            NOTHING;
        else
            return ERROR_INVALID_HANDLE;
    }
    except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
            EXCEPTION_EXECUTE_HANDLER :
            EXCEPTION_CONTINUE_SEARCH) {
        return ERROR_INVALID_HANDLE;
    }


    if (EnumerationFlags & (~(RTM_ONLY_THIS_NETWORK|RTM_ONLY_THIS_INTERFACE))) {
        ExitTableAPI (Table);
        return ERROR_INVALID_PARAMETER;
    }

    ROUTE->XX_PROTOCOL = ClientPtr->RC_RoutingProtocol;
    EnableFlag = Enable ? 0 : RTM_ENABLED_NODE_FLAG;
    EnumerationHandle = RtmCreateEnumerationHandle (
        ProtocolFamily,
        EnumerationFlags|RTM_ONLY_THIS_PROTOCOL,
        CriteriaRoute);
    if (EnumerationHandle==NULL) {
        ExitTableAPI (Table);
        return GetLastError ();
    }

    if (!EnterSyncList (Table, EnumPtr->RE_Lock, TRUE)) {
        RtmCloseEnumerationHandle (EnumerationHandle);
        ExitTableAPI (Table);
        return ERROR_NO_SYSTEM_RESOURCES;
    }

    while ((status=DoEnumerate (Table, EnumPtr, EnableFlag))==NO_ERROR) {
        PRTM_ROUTE_NODE node = CONTAINING_RECORD (
            EnumPtr->RE_Links[EnumPtr->RE_Link].Flink,
            RTM_ROUTE_NODE,
            RN_Links[EnumPtr->RE_Link]
            );

        // Update node status
        SetEnable (node, Enable);
        // If we enable this node, we'll have to check if it is the
        // best one, if we disable this node and it was the best we'll
        // try to locate another route.  In both cases we'll have to
        // locate and check all nodes to the destination
        if (Enable || IsBest(node)) {
            PRTM_ROUTE_NODE         bestNode=NULL;
            PLIST_ENTRY                     cur1;


            // We'll look back and forward to check all nodes
            // around us with same net number
            cur1 = node->RN_Links[RTM_NET_NUMBER_HASH_LINK].Blink;
            while (cur1!=&node->RN_Hash->RSL_Head) {
                PRTM_ROUTE_NODE node1 = CONTAINING_RECORD (
                    cur1,
                    RTM_ROUTE_NODE,
                    RN_Links[RTM_NET_NUMBER_HASH_LINK]);
                if (!IsEnumerator (node1)
                    && IsEnabled(node1)) {
                    if (NetNumCmp (Table, &node->RN_Route,
                                   &node1->RN_Route)==0) {
                        if (Enable && IsBest(node1)) {
                            // Looking for current best node
                            // that we might have to replace
                            bestNode = node1;
                            break;
                        }
                        else if (!Enable
                                 && ((bestNode==NULL)
                                     || (MetricCmp (Table,
                                                    &bestNode->RN_Route,
                                                    &node1->RN_Route)>0)))
                            // Looking for the node with lowest
                            // metric that can replace disabled
                            // node
                            bestNode = node1;
                    }
                    else
                        break;
                }
                cur1 = cur1->Blink;
            }

            // If disabling, we need to check all nodes to find
            // the best one
            // if enabling we continue only if we haven't
            // located the best node yet
            if (!Enable || (bestNode==NULL)) {
                cur1 = node->RN_Links[RTM_NET_NUMBER_HASH_LINK].Flink;
                while (cur1!=&node->RN_Hash->RSL_Head) {
                    PRTM_ROUTE_NODE node1 = CONTAINING_RECORD (
                        cur1,
                        RTM_ROUTE_NODE,
                        RN_Links[RTM_NET_NUMBER_HASH_LINK]);
                    if (!IsEnumerator (node1)
                        && IsEnabled(node1)) {
                        // Looking for current best node
                        // that we might have to replace
                        if (NetNumCmp (Table, &node->RN_Route,
                                       &node1->RN_Route)==0) {
                            if (Enable && IsBest(node1)) {
                                bestNode = node1;
                                break;
                            }
                            else if (!Enable
                                     && ((bestNode==NULL)
                                         || (MetricCmp (Table,
                                                        &bestNode->RN_Route,
                                                        &node1->RN_Route)>0)))
                                // Looking for the node with lowest
                                // metric that can replace disabled
                                // node
                                bestNode = node1;
                        }
                        else
                            break;
                    }
                    cur1 = cur1->Flink;
                }
            }

            if (!Enable // Disabling: we already know that we're removing
                // the best node (see above), so we'll have
                // to notify clients whether or not we found the
                // replacement
                // Enabling: we'll have to notify only if there
                // is no best route yet or if the route we're
                // enabling is better then current best route
                || (bestNode==NULL)
                || (MetricCmp (Table,
                               &node->RN_Route,
                               &bestNode->RN_Route)<0)) {

                if (bestNode!=NULL) {
                    // There is another route that loses or gains
                    // best status as the result of our operation
                    if (Enable) {
                        ResetBest (bestNode);
                        SetBest (node);
                        // Enabling: node replaces bestNode
                        NotifyClients (Table,
                                       NULL,
                                       RTM_CURRENT_BEST_ROUTE|RTM_PREVIOUS_BEST_ROUTE,
                                       &node->RN_Route,
                                       &bestNode->RN_Route);
                    }
                    else {
                        ResetBest (node);
                        SetBest (bestNode);
                        // Disabling: bestNode replaces node
                        NotifyClients (Table,
                                       NULL,
                                       RTM_CURRENT_BEST_ROUTE|RTM_PREVIOUS_BEST_ROUTE,
                                       &bestNode->RN_Route,
                                       &node->RN_Route);
                    }
                }
                else /* if (bestNode==NULL) */ {
                    // No other node
                    if (Enable) {
                        SetBest (node);
                        // Enabling: our node becomes the best
                        NotifyClients (Table,
                                       NULL,
                                       RTM_CURRENT_BEST_ROUTE,
                                       &node->RN_Route,
                                       NULL);
                    }
                    else {
                        ResetBest (node);
                        // Disabling: we removed the only available
                        // route
                        NotifyClients (Table,
                                       NULL,
                                       RTM_PREVIOUS_BEST_ROUTE,
                                       NULL,
                                       &node->RN_Route);
                    }
                }

            }
        }
    }

    if (status==ERROR_NO_MORE_ROUTES) {
        if (EnumPtr->RE_Hash!=NULL)
            LeaveSyncList (Table, EnumPtr->RE_Hash);
        LeaveSyncList (Table, EnumPtr->RE_Lock);

        status = NO_ERROR;
    }

    RtmCloseEnumerationHandle (EnumerationHandle);
    ExitTableAPI (Table);
    return status;

#undef EnumPtr
#undef ClientPtr
#undef ROUTE
    return NO_ERROR;
}




// Slow enumeration that may require traversing up to all the entries in the
// table if route used to compute the next entry no longer exists.
// Routes are returned in the increasing net number order

// Get first route that matches specified criteria
// Returns:
//              NO_ERROR - if matching route is found
//              ERROR_NO_ROUTES  - if no routes available with specified criteria
//              ERROR_INVALID_PARAMETER - if one of the parameters is invalid
//              ERROR_NO_SYSTEM_RESOURCES - not enough resources to lock table content
DWORD WINAPI
RtmGetFirstRoute (
    IN      DWORD           ProtocolFamily,
    IN      DWORD           EnumerationFlags,// Limiting flags
    IN OUT PVOID Route      // On Entry: if any of the EnumerationFlags are set,
    //                       the corresponding fields of Route will
    //           be used to limit the search
    //                       to the only table entries that have
    //                       same value in the specified field.
    // On Exit:     contains first route in the table that
    //                      matches specified criteria
    ){
#define ROUTE ((PRTM_XX_ROUTE)Route)
    PRTM_TABLE                      Table;
    PLIST_ENTRY                     cur, head;
    INT                                     res, link;
    PRTM_SYNC_LIST          hashBasket;
    DWORD                           status = ERROR_NO_ROUTES;

    Table = &Tables[ProtocolFamily];
    if ((ProtocolFamily>=RTM_NUM_OF_PROTOCOL_FAMILIES)
        || !EnterTableAPI (Table)) {
#if DBG
        Trace2 (ANY, 
                 "Undefined Protocol Family\n\tat line %ld of %s\n",
                 __LINE__, __FILE__);
#endif
        return ERROR_INVALID_PARAMETER;
    }


    if (EnumerationFlags &
        (~(RTM_ONLY_THIS_NETWORK|RTM_ONLY_THIS_INTERFACE
           |RTM_ONLY_THIS_PROTOCOL|RTM_ONLY_BEST_ROUTES
           |RTM_INCLUDE_DISABLED_ROUTES))) {
        ExitTableAPI (Table);
        return ERROR_INVALID_PARAMETER;
    }

    if (EnumerationFlags & RTM_ONLY_THIS_NETWORK) {
        hashBasket = &Table->RT_NetNumberHash [HashFunction (Table,
                                                             ((char *)ROUTE)
                                                             +sizeof(RTM_XX_ROUTE))];
        link = RTM_NET_NUMBER_HASH_LINK;
        if (!EnterSyncList (Table, hashBasket, TRUE)) {
            ExitTableAPI (Table);
            return ERROR_NO_SYSTEM_RESOURCES;
        }
        head = &hashBasket->RSL_Head;
    }
    else {
        hashBasket = NULL;
        link = RTM_NET_NUMBER_LIST_LINK;
        head = &Table->RT_NetNumberMasterList.RSL_Head;


        if (EnterSyncList (Table, &Table->RT_NetNumberMasterList, FALSE))
            ConsolidateNetNumberLists (Table);
        else if (!EnterSyncList (Table, &Table->RT_NetNumberMasterList, TRUE)) {
            ExitTableAPI (Table);
            return ERROR_NO_SYSTEM_RESOURCES;
        }
    }
    // Go through the list till entry that matches specified
    // criteria is found
    cur = head->Flink;
    while (cur!=head) {
        PRTM_ROUTE_NODE         node = CONTAINING_RECORD (cur,
                                                          RTM_ROUTE_NODE,
                                                          RN_Links[link]);
        if (!IsEnumerator (node)
            && ((EnumerationFlags&RTM_INCLUDE_DISABLED_ROUTES)
                || IsEnabled(node))) {
            if (EnumerationFlags & RTM_ONLY_THIS_NETWORK) {
                // Check network number if asked
                res = NetNumCmp (Table, ROUTE, &node->RN_Route);
                if (res > 0)    // It may be further ahead
                    goto DoNextNode;
                else if (res < 0)       // No chance to find it anymore
                    break;
            }

            // Check if it is the best route if asked
            if (EnumerationFlags & RTM_ONLY_BEST_ROUTES) {
                // We need to lock the hash list to make sure the
                // best node designation won't change while we are
                // scaning through the list
                if (hashBasket!=node->RN_Hash) {
                    if (hashBasket!=NULL)
                        LeaveSyncList (Table, hashBasket);
                    hashBasket = node->RN_Hash;
                    if (!EnterSyncList (Table, hashBasket, TRUE)) {
                        hashBasket = NULL;
                        status = ERROR_NO_SYSTEM_RESOURCES;
                        goto ExitGetFirst;
                    }
                }

                if (!IsBest(node))
                    goto DoNextNode;
            }

            // Check protocol if asked
            if ((EnumerationFlags & RTM_ONLY_THIS_PROTOCOL)
                && (ROUTE->XX_PROTOCOL
                    !=node->RN_Route.XX_PROTOCOL))
                goto DoNextNode;

            // Check interface if asked
            if ((EnumerationFlags & RTM_ONLY_THIS_INTERFACE)
                && (ROUTE->XX_INTERFACE
                    !=node->RN_Route.XX_INTERFACE))
                goto DoNextNode;

            // Now we have it
            memcpy (ROUTE, &node->RN_Route, Table->RT_RouteSize);

            status = NO_ERROR;
            break;
        }

DoNextNode:     // Continue searching
        cur = cur->Flink;
    }

ExitGetFirst:
    if (link==RTM_NET_NUMBER_HASH_LINK)
        LeaveSyncList (Table, hashBasket);
    else {
        if (hashBasket!=NULL)
            LeaveSyncList (Table, hashBasket);
        LeaveSyncList (Table, &Table->RT_NetNumberMasterList);
    }
    ExitTableAPI (Table);
#undef ROUTE
    return status;
}

// Compute and return route next to the input route limiting serach to the routes
// with specified criteria
// Returns:
//              NO_ERROR - if matching route is found
//              ERROR_NO_MORE_ROUTES  - if no matching route was found while end of
//                                                               the table is reached and no route
//              ERROR_INVALID_PARAMETER - if one of the parameters is invalid
//              ERROR_NO_SYSTEM_RESOURCES - not enough resources to lock table content
DWORD WINAPI
RtmGetNextRoute (
    IN      DWORD           ProtocolFamily,
    IN      DWORD           EnumerationFlags,// Limiting flags
    IN OUT PVOID Route      // On Entry: contains the route from which to start
    //                       the search.
    //                       if any of the EnumerationFlags are set,
    //                       the corresponding fields of Route will
    //           be used to limit the search
    //                       to the only table entries that have
    //                       same value in the specified field.
    // On Exit:     contains first route in the table that
    //                      matches specified criteria
    ) {
#define ROUTE ((PRTM_XX_ROUTE)Route)
    PRTM_TABLE                      Table;
    PLIST_ENTRY                     cur, posLink = NULL;
    INT                                     res;
    PRTM_SYNC_LIST          hashBasket = NULL;
    DWORD                           status = ERROR_NO_MORE_ROUTES;

    Table = &Tables[ProtocolFamily];
    if ((ProtocolFamily>=RTM_NUM_OF_PROTOCOL_FAMILIES)
        || !EnterTableAPI (Table)) {
#if DBG
        Trace2 (ANY, 
                 "Undefined Protocol Family\n\tat line %ld of %s\n",
                 __LINE__, __FILE__);
#endif
        return ERROR_INVALID_PARAMETER;
    }


    if (EnumerationFlags &
        (~(RTM_ONLY_THIS_NETWORK|RTM_ONLY_THIS_INTERFACE
           |RTM_ONLY_THIS_PROTOCOL|RTM_ONLY_BEST_ROUTES
           |RTM_INCLUDE_DISABLED_ROUTES))) {
        ExitTableAPI (Table);
        return ERROR_INVALID_PARAMETER;
    }

    if (EnterSyncList (Table, &Table->RT_NetNumberMasterList, FALSE))
        ConsolidateNetNumberLists (Table);
    else if (!EnterSyncList (Table, &Table->RT_NetNumberMasterList, TRUE)) {
        ExitTableAPI (Table);
        return ERROR_NO_SYSTEM_RESOURCES;
    }


    // First try to locate starting point for the serach
    // using the hash table (should work most of the
    // time unless route was deleted while client was
    // processing it)
    hashBasket = &Table->RT_NetNumberHash [HashFunction (Table,
                                                         ((char *)ROUTE)
                                                         +sizeof(RTM_XX_ROUTE))];


    if (!EnterSyncList (Table, hashBasket, TRUE)) {
        status = ERROR_NO_SYSTEM_RESOURCES;
        goto ExitGetNext;
    }


    cur = hashBasket->RSL_Head.Flink;
    while (cur!=&hashBasket->RSL_Head) {
        PRTM_ROUTE_NODE node = CONTAINING_RECORD (
            cur,
            RTM_ROUTE_NODE,
            RN_Links[RTM_NET_NUMBER_HASH_LINK]
            );
        if (!IsEnumerator (node)
            && ((EnumerationFlags&RTM_INCLUDE_DISABLED_ROUTES)
                || IsEnabled(node))) {
            // First check network number
            // (lists are ordered by net number)
            res = NetNumCmp (Table, ROUTE, &node->RN_Route);
            if (res==0) {
                if (ROUTE->XX_PROTOCOL
                    == node->RN_Route.XX_PROTOCOL) {
                    if (ROUTE->XX_INTERFACE
                        == node->RN_Route.XX_INTERFACE) {
                        res = NextHopCmp (Table, ROUTE, &node->RN_Route);
                        if ((res == 0)
                            && IsSorted (node))
                            posLink = node->RN_Links[RTM_NET_NUMBER_LIST_LINK].Flink;
                        else if (res < 0)
                            break;
                    }
                    else if (ROUTE->XX_INTERFACE
                             < node->RN_Route.XX_INTERFACE)
                        break;
                }
                else if (ROUTE->XX_PROTOCOL
                         < node->RN_Route.XX_PROTOCOL)
                    break;
            }
            else if (res < 0)
                break;
        }
        cur = cur->Flink;
    }

    LeaveSyncList (Table, hashBasket);

    hashBasket = NULL;

    if (posLink!=NULL)
        cur = posLink; // Note the place to start with
    else { // If we didn't find the entry in
        // hash table, we'll have to go through
        // the master net number list from the
        // beginning
        cur = Table->RT_NetNumberMasterList.RSL_Head.Flink;
        while (cur!=&Table->RT_NetNumberMasterList.RSL_Head) {
            PRTM_ROUTE_NODE node = CONTAINING_RECORD (
                cur,
                RTM_ROUTE_NODE,
                RN_Links[RTM_NET_NUMBER_LIST_LINK]
                );
            if (!IsEnumerator (node)
                && ((EnumerationFlags&RTM_INCLUDE_DISABLED_ROUTES)
                    || IsEnabled(node))) {
                // Just do all the necessary comparisons to
                // find the following entry
                res = NetNumCmp (Table, ROUTE, &node->RN_Route);
                if ((res < 0)
                    ||((res == 0)
                       &&((ROUTE->XX_PROTOCOL
                           < node->RN_Route.XX_PROTOCOL)
                          ||((ROUTE->XX_PROTOCOL
                              ==node->RN_Route.XX_PROTOCOL)
                             &&((ROUTE->XX_INTERFACE
                                 < node->RN_Route.XX_INTERFACE)
                                ||((ROUTE->XX_INTERFACE
                                    ==node->RN_Route.XX_INTERFACE)
                                   && (NextHopCmp (Table, ROUTE,
                                                   &node->RN_Route)
                                       < 0)))))))
                    break;
            }

            cur = cur->Flink;
        }
    }

    // Now we need to locate first entry that satisfies all criteria
    while (cur!=&Table->RT_NetNumberMasterList.RSL_Head) {
        PRTM_ROUTE_NODE node = CONTAINING_RECORD (
            cur,
            RTM_ROUTE_NODE,
            RN_Links[RTM_NET_NUMBER_LIST_LINK]
            );
        if (!IsEnumerator (node)
            && ((EnumerationFlags&RTM_INCLUDE_DISABLED_ROUTES)
                || IsEnabled(node))) {

            if (EnumerationFlags & RTM_ONLY_BEST_ROUTES) {
                // We need to lock the hash list to make sure the
                // best node designation won't change while we are
                // scaning through the list
                if (hashBasket!=node->RN_Hash) {
                    if (hashBasket!=NULL)
                        LeaveSyncList (Table, hashBasket);
                    hashBasket = node->RN_Hash;
                    if (!EnterSyncList (Table, hashBasket, TRUE)) {
                        status = ERROR_NO_SYSTEM_RESOURCES;
                        goto ExitGetNext;
                    }
                }

                // For best routes we must check if the route is best
                // and also make sure we do not return same net as in
                // previous call in case the best route was moved
                // while client was processing results of the
                // previous call
                if (!IsBest(node)
                    || (NetNumCmp (Table, ROUTE, &node->RN_Route)==0))
                    goto DoNextNode;
            }

            if (EnumerationFlags & RTM_ONLY_THIS_NETWORK) {
                // checking net number
                res = NetNumCmp (Table, ROUTE, &node->RN_Route);
                if (res > 0) // It is still ahead
                    goto DoNextNode;
                else if (res < 0) // no chance to find it
                    break;
                // else (res == 0), found it, continue
            }

            // Check interface if asked
            if ((EnumerationFlags & RTM_ONLY_THIS_INTERFACE)
                && (node->RN_Route.XX_INTERFACE
                    !=ROUTE->XX_INTERFACE))
                goto DoNextNode;

            // Check protocol if asked
            if ((EnumerationFlags & RTM_ONLY_THIS_PROTOCOL)
                && (node->RN_Route.XX_PROTOCOL
                    !=ROUTE->XX_PROTOCOL))
                goto DoNextNode;


            // Now we can return it
            // Make sure nobody changes the route while we copy
            memcpy (ROUTE, &node->RN_Route, Table->RT_RouteSize);

            status = NO_ERROR;
            break;
        }

DoNextNode:
        cur = cur->Flink;
    }

    if (hashBasket!=NULL)
        LeaveSyncList (Table, hashBasket);

ExitGetNext:
    LeaveSyncList (Table, &Table->RT_NetNumberMasterList);
    ExitTableAPI (Table);
#undef ROUTE
    return status;
}


//----------------------------------------------------------------------------
// RtmLookupIPDestination
//
//  Given a destination address does a route lookup to get the best route
//  to that destination.
//----------------------------------------------------------------------------

BOOL WINAPI
RtmLookupIPDestination(
    DWORD                       dwDestAddr,
    PRTM_IP_ROUTE               prir
)
{
    INT         nInd;
    IP_NETWORK  ipNet;

    for ( nInd = MAX_MASKS; nInd >= 0; nInd-- )
    {
        if ( g_meMaskTable[ nInd ].dwCount == 0 )
        {
            continue;
        }

        
        ipNet.N_NetNumber   = dwDestAddr & g_meMaskTable[ nInd ].dwMask;
        ipNet.N_NetMask     = g_meMaskTable[ nInd ].dwMask;

        if ( RtmIsRoute( RTM_PROTOCOL_FAMILY_IP, &ipNet, prir ) )
        {
            if ( IsRouteLoopback( prir ) )
            {
                continue;
            }
            
            return TRUE;
        }
    }

    return FALSE;
}


//----------------------------------------------------------------------------
//
//
//
//----------------------------------------------------------------------------

VOID
UpdateAPC (
    PVOID           Context,
    ULONG           TimeLow,
    LONG            TimeHigh
    ) {
#define Table ((PRTM_TABLE)Context)
    if (InterlockedIncrement (&Table->RT_UpdateWorkerPending)==0) {
        DWORD status = RtlQueueWorkItem (ConsolidateNetNumberListsWI, Context, 0);
        if (status!=STATUS_SUCCESS) {
            ASSERTERRMSG ("Can't queue update work item", FALSE);
            ScheduleUpdate (Context);
        }
    }
#undef Table
}

VOID APIENTRY
ScheduleUpdate (
    PVOID           Context
    ) {
#define Table ((PRTM_TABLE)Context)
    DWORD                                   status;
    static LARGE_INTEGER    dueTime = RTM_NET_NUMBER_UPDATE_PERIOD;

    if (InterlockedDecrement (&Table->RT_UpdateWorkerPending)>=0) {
        status = RtlQueueWorkItem (ConsolidateNetNumberListsWI, Context, 0);
        if (status==STATUS_SUCCESS)
            return;
        ASSERTERRMSG ("Can't queue update work item", FALSE);
        InterlockedExchange (&Table->RT_UpdateWorkerPending, -1);
    }

    status = NtSetTimer (Table->RT_UpdateTimer,
                         &dueTime,
                         UpdateAPC,
                         Context,
                         FALSE,
                         0,
                         NULL);
    ASSERTMSG ("Could not set expiration timer ", NT_SUCCESS (status));
#undef Table
}

VOID
ConsolidateNetNumberListsWI (
    PVOID                   Context
    ) {
#define Table ((PRTM_TABLE)Context)
    DWORD                   status;

    if (EnterSyncList (Table, &Table->RT_NetNumberMasterList, TRUE)) {
        InterlockedExchange (&Table->RT_UpdateWorkerPending, 0);
        ConsolidateNetNumberLists (Table);
        LeaveSyncList (Table, &Table->RT_NetNumberMasterList);
    }

    status = RtlQueueWorkItem (ScheduleUpdate, Context, WT_EXECUTEINIOTHREAD);
    ASSERTERRMSG ("Can't queue update work item", status==STATUS_SUCCESS);
#undef Table
}

// This procedure merges temporary and master net number lists
// It also removes and disposes of nodes in the deleted list
VOID
ConsolidateNetNumberLists (
    PRTM_TABLE                      Table   // Table for which operation is performed
    ) {
    PLIST_ENTRY                     curMaster, curTemp;
    LIST_ENTRY                      tempHead;
    PRTM_ROUTE_NODE         tempNode;
    INT                                     res;
    DWORD                           status;
#if DBG
    INT                                     curMasterIdx = 0;
#endif

    // Temp and deleted lists are locked for a very short period
    // of time so that overall performance should not
    // degrade

    if (!EnterSyncList (Table, &Table->RT_NetNumberTempList, TRUE)) {
        return;
    }

    if (!EnterSyncList (Table, &Table->RT_DeletedList, TRUE)) {
        LeaveSyncList (Table, &Table->RT_NetNumberTempList);
        return;
    }

    // Process entries in deleted list
    while (!IsListEmpty (&Table->RT_DeletedList.RSL_Head)) {
        curTemp = RemoveHeadList (&Table->RT_DeletedList.RSL_Head);
        tempNode = CONTAINING_RECORD (curTemp,
                                      RTM_ROUTE_NODE,
                                      RN_Links[RTM_DELETED_LIST_LINK]);
        RemoveEntryList (&tempNode->RN_Links[RTM_NET_NUMBER_LIST_LINK]);
#if DBG
        IF_DEBUG (DISPLAY_TABLE)
            DeleteRouteFromLB (Table, tempNode);
#endif
        HeapFree (Table->RT_Heap, 0, tempNode);
    }
    // Unlock the list
    Table->RT_DeletedNodesCount = 0;
    LeaveSyncList (Table, &Table->RT_DeletedList);

                // Now, just copy the head of the temp list,
                // so we won't delay others while processing it
    if (!IsListEmpty (&Table->RT_NetNumberTempList.RSL_Head)) {
        curTemp = Table->RT_NetNumberTempList.RSL_Head.Flink;
        RemoveEntryList (&Table->RT_NetNumberTempList.RSL_Head);
        InitializeListHead (&Table->RT_NetNumberTempList.RSL_Head);
        InsertTailList (curTemp, &tempHead);
    }
    else
        InitializeListHead (&tempHead);

    Table->RT_NetNumberTempCount = 0;
    LeaveSyncList (Table, &Table->RT_NetNumberTempList);


    curMaster = Table->RT_NetNumberMasterList.RSL_Head.Flink;

    // Merge master and temp lists (both are ordered by
    // net number.interface.protocol.next hop address)
    while (!IsListEmpty (&tempHead)) {
        // Take the first entry
        curTemp = RemoveHeadList (&tempHead);
        tempNode = CONTAINING_RECORD (curTemp,
                                      RTM_ROUTE_NODE,
                                      RN_Links[RTM_NET_NUMBER_LIST_LINK]);

        // Find master list entry that should follow it
        while (curMaster!=&Table->RT_NetNumberMasterList.RSL_Head) {
            PRTM_ROUTE_NODE node = CONTAINING_RECORD (curMaster,
                                                      RTM_ROUTE_NODE,
                                                      RN_Links[RTM_NET_NUMBER_LIST_LINK]);
            if (!IsEnumerator (node)) {
                res = NetNumCmp (Table, &tempNode->RN_Route, &node->RN_Route);
                if ((res < 0)
                    ||((res == 0)
                       &&((tempNode->RN_Route.XX_PROTOCOL
                           < node->RN_Route.XX_PROTOCOL)
                          ||((tempNode->RN_Route.XX_PROTOCOL
                              ==node->RN_Route.XX_PROTOCOL)
                             &&((tempNode->RN_Route.XX_INTERFACE
                                 < node->RN_Route.XX_INTERFACE)
                                ||((tempNode->RN_Route.XX_INTERFACE
                                    ==node->RN_Route.XX_INTERFACE)
                                   && (NextHopCmp (Table, &tempNode->RN_Route,
                                                   &node->RN_Route)
                                       < 0)))))))
                    break;
            }
            curMaster = curMaster->Flink;
#if DBG
            IF_DEBUG (DISPLAY_TABLE)
                curMasterIdx += 1;
#endif
        }
        // Insert at the located point
        InsertTailList (curMaster, curTemp);
        SetSorted (tempNode);
#if DBG
        IF_DEBUG (DISPLAY_TABLE) {
            AddRouteToLB (Table, tempNode, curMasterIdx);
            curMasterIdx += 1;
        }
#endif
    }
    // We are done now
}

VOID
ExpirationAPC (
    PVOID           Context,
    ULONG           TimeLow,
    LONG            TimeHigh
    ) {
#define Table ((PRTM_TABLE)Context)
    if (InterlockedIncrement (&Table->RT_ExpirationWorkerPending)==0) {
        do {
            ProcessExpirationQueue (Table);
        }
        while (InterlockedDecrement (&Table->RT_ExpirationWorkerPending)>=0);
    }
#undef Table
}

VOID APIENTRY
ProcessExpirationQueueWI (
    PVOID           Context
    ) {
#define Table ((PRTM_TABLE)Context)
    do {
        ProcessExpirationQueue (Table);
    }
    while (InterlockedDecrement (&Table->RT_ExpirationWorkerPending)>=0);
#undef Table
}

// Checks if any entries in expiration queue have expired and deletes them
VOID
ProcessExpirationQueue (
    PRTM_TABLE              Table   // Affected table
    ) {
    DWORD                           status;
    ULONG                           tickCount = GetTickCount ();

    if (!EnterSyncList (Table, &Table->RT_ExpirationQueue, TRUE))
        return;

                // Check all relevant entries
    while (!IsListEmpty (&Table->RT_ExpirationQueue.RSL_Head)) {
        PRTM_SYNC_LIST  hashBasket;
        PLIST_ENTRY             cur;
        PRTM_ROUTE_NODE node = CONTAINING_RECORD (
            Table->RT_ExpirationQueue.RSL_Head.Flink,
            RTM_ROUTE_NODE,
            RN_Links[RTM_EXPIRATION_QUEUE_LINK]);
        LONGLONG                dueTime;
        ULONG   timeDiff = TimeDiff (node->RN_ExpirationTime,tickCount);

        InterlockedExchange (&Table->RT_ExpirationWorkerPending, 0);

        if (IsPositiveTimeDiff (timeDiff)) {
            // The first entry in the queue is not due yet, so are
            // the others (queue is ordered by expiration time)

            dueTime = (LONGLONG)timeDiff*(-10000);
            status = NtSetTimer (Table->RT_ExpirationTimer,
                                 (PLARGE_INTEGER)&dueTime,
                                 ExpirationAPC,
                                 Table,
                                 FALSE,
                                 0,
                                 NULL);
            ASSERTMSG ("Could not set expiration timer ", NT_SUCCESS (status));
            break;
        }


        hashBasket = node->RN_Hash;
        // We need to lock the hash basket to delete the entry
        if (!EnterSyncList (Table, hashBasket, FALSE)) {
            // Can't do it at once, so we first release
            // expiration queue lock (to prevent a deadlock)
            // and then try again)
            LeaveSyncList (Table, &Table->RT_ExpirationQueue);
            if (!EnterSyncList (Table, hashBasket, TRUE)) {
                return;
            }

            if (!EnterSyncList (Table, &Table->RT_ExpirationQueue, TRUE)) {
                LeaveSyncList (Table, hashBasket);
                return;
            }
            // Now we have both of them, but is our route still there
            if (node!=CONTAINING_RECORD (
                Table->RT_ExpirationQueue.RSL_Head.Flink,
                RTM_ROUTE_NODE,
                RN_Links[RTM_EXPIRATION_QUEUE_LINK])) {
                // Well, somebody took care of it while we were
                // waiting
                LeaveSyncList (Table, hashBasket);
                // We'll try the next one
                continue;
            }
            // Unlikely, but its due time could have changed
            timeDiff = TimeDiff (node->RN_ExpirationTime,tickCount);
            if (IsPositiveTimeDiff (timeDiff) ) {
                // The first entry in the queue is not due yet, so are
                // the others (queue is ordered by expiration time)
                LeaveSyncList (Table, hashBasket);
                dueTime = (LONGLONG)timeDiff*(-10000);
                // Well, we are done then (this was the first entry
                // in the queue (we just checked), so other are not
                // due as well)
                // Just make sure that updated thread returns soon enough
                // to take care of our first entry
                status = NtSetTimer (Table->RT_ExpirationTimer,
                                     (PLARGE_INTEGER)&dueTime,
                                     ExpirationAPC,
                                     Table,
                                     FALSE,
                                     0,
                                     NULL);
                ASSERTMSG ("Could not set expiration timer ", NT_SUCCESS (status));
                break;
            }

        }

        LeaveSyncList (Table, &Table->RT_ExpirationQueue);

        if (IsBest(node)) {
            // We need to locate the best node after this one is gone
            PRTM_ROUTE_NODE bestNode = NULL;

            cur = node->RN_Links[RTM_NET_NUMBER_HASH_LINK].Blink;
            while (cur!=&hashBasket->RSL_Head) {
                PRTM_ROUTE_NODE node1 = CONTAINING_RECORD (
                    cur,
                    RTM_ROUTE_NODE,
                    RN_Links[RTM_NET_NUMBER_HASH_LINK]);
                if (!IsEnumerator (node1)
                    && IsEnabled(node1)) {
                    if (NetNumCmp (Table, &node->RN_Route, &node1->RN_Route)==0) {
                        if ((bestNode==NULL)
                            || (MetricCmp (Table,
                                           &bestNode->RN_Route,
                                           &node1->RN_Route)>0))
                            bestNode = node1;
                    }
                    else
                        break;
                }
                cur = cur->Blink;
            }

            cur = node->RN_Links[RTM_NET_NUMBER_HASH_LINK].Flink;
            while (cur!=&hashBasket->RSL_Head) {
                PRTM_ROUTE_NODE node1 = CONTAINING_RECORD (
                    cur,
                    RTM_ROUTE_NODE,
                    RN_Links[RTM_NET_NUMBER_HASH_LINK]);
                if (!IsEnumerator (node1)
                    && IsEnabled(node1)) {
                    if (NetNumCmp (Table, &node->RN_Route, &node1->RN_Route)==0) {
                        if ((bestNode==NULL)
                            || (MetricCmp (Table,
                                           &bestNode->RN_Route,
                                           &node1->RN_Route)>0))
                            bestNode = node1;
                    }
                    else
                        break;
                }
                cur = cur->Flink;
            }

            if (bestNode!=NULL) {   // We did find another node

                ResetBest (node);
                SetBest (bestNode);

                NotifyClients (Table,
                               NULL,
                               RTM_CURRENT_BEST_ROUTE|RTM_PREVIOUS_BEST_ROUTE,
                               &bestNode->RN_Route,
                               &node->RN_Route);
            }
            else {
                InterlockedDecrement (&Table->RT_NetworkCount);
                // No best node anymore
                NotifyClients (Table,
                               NULL,
                               RTM_PREVIOUS_BEST_ROUTE,
                               NULL,
                               &node->RN_Route);
            }
        }


        if (RemoveRouteNode (Table, node)!=NO_ERROR) {
            LeaveSyncList (Table, hashBasket);
            return;
        }

        LeaveSyncList (Table, hashBasket);
        // Reenter expiration queue to continue
        if (!EnterSyncList (Table, &Table->RT_ExpirationQueue, TRUE))
            return;
    }

    LeaveSyncList (Table, &Table->RT_ExpirationQueue);
}





DWORD
DoEnumerate (
    PRTM_TABLE              Table,
    PRTM_ENUMERATOR EnumPtr,
    DWORD                   EnableFlag
    ) {
    // Now, we'll go ahead and find an entry that satisfies
    // specified criteria
    while (1) {     // This external loop is needed for the case
        // of enumerating through the hash table when
        // reaching the end of the list doesn't mean that process has
        // to be stopped: we need to move the next basket till
        // we've gone through all of them

        PLIST_ENTRY cur = EnumPtr->RE_Links[EnumPtr->RE_Link].Blink;
        while (cur!=EnumPtr->RE_Head) {
            PRTM_ROUTE_NODE node = CONTAINING_RECORD (cur, RTM_ROUTE_NODE,
                                                      RN_Links[EnumPtr->RE_Link]);
            INT     res;

            if (!IsEnumerator (node)
                && ((EnableFlag==RTM_ANY_ENABLE_STATE)
                    || IsSameEnableState(node,EnableFlag))) {


                if ((EnumPtr->RE_Link!=RTM_NET_NUMBER_HASH_LINK)
                    && (EnumPtr->RE_Hash!=node->RN_Hash)) {
                    if (EnumPtr->RE_Hash!=NULL)
                        LeaveSyncList (Table, EnumPtr->RE_Hash);
                    EnumPtr->RE_Hash = node->RN_Hash;
                    if (!EnterSyncList (Table, node->RN_Hash, FALSE)) {
                        RemoveEntryList (&EnumPtr->RE_Links[EnumPtr->RE_Link]);
                        InsertHeadList (cur, &EnumPtr->RE_Links[EnumPtr->RE_Link]);
                        LeaveSyncList (Table, EnumPtr->RE_Lock);
                        if (!EnterSyncList (Table, EnumPtr->RE_Hash, TRUE)) {
                            EnumPtr->RE_Hash = NULL;
                            return ERROR_NO_SYSTEM_RESOURCES;
                        }
                        if (!EnterSyncList (Table, EnumPtr->RE_Lock, TRUE)) {
                            LeaveSyncList (Table, EnumPtr->RE_Hash);
                            EnumPtr->RE_Hash = NULL;
                            return ERROR_NO_SYSTEM_RESOURCES;
                        }
                        cur = EnumPtr->RE_Links[EnumPtr->RE_Link].Blink;
                        continue;
                    }
                }

                switch (EnumPtr->RE_Link) {
                    // Using the interface link:
                    case RTM_INTERFACE_LIST_LINK:
#if !RTM_USE_PROTOCOL_LISTS
                    case RTM_NET_NUMBER_HASH_LINK:
#endif
                        // Check protocol if necessary
                        if ((EnumPtr->RE_EnumerationFlags & RTM_ONLY_THIS_PROTOCOL)
                            && (EnumPtr->RE_Route.XX_PROTOCOL
                                !=node->RN_Route.XX_PROTOCOL)) {
                            // Break out to move ahead if protocol
                            // check fails
                            break;
                        }
                        // else Pass through to do other checks

                        // Using the protocol link: (thus we don't
                        // care about interface or we would have used
                        // interface link - see RtmCreateEnumerationHandle).
#if RTM_USE_PROTOCOL_LISTS
                    case RTM_PROTOCOL_LIST_LINK:
                        // Using the hash link: (thus we don't
                        // care about interface and protocol or we would have
                        // used other links - see RtmCreateEnumerationHandle).
                    case RTM_NET_NUMBER_HASH_LINK:
#endif
                        // Check the network number if necessary
                        if (EnumPtr->RE_EnumerationFlags & RTM_ONLY_THIS_NETWORK) {
                            res = NetNumCmp (Table, &EnumPtr->RE_Route,
                                             &node->RN_Route);
                            if (res == 0)
                                // Match, continue checks
                                ;
                            else if ((res > 0)
                                     && (EnumPtr->RE_Link
                                         ==RTM_NET_NUMBER_HASH_LINK)) {
                                // Hash list are ordered by net
                                // number, so if we got network
                                // number that is less than ours
                                // we don't have search anymore
                                // (we are going backwards)
                                return ERROR_NO_MORE_ROUTES;
                            }
                            else //  Otherwise break out of switch
                                // statement to continue the search
                                break;
                        }
                        // We didn't care about net number,
                        // so current entry will do


                        if (!(EnumPtr->RE_EnumerationFlags & RTM_ONLY_BEST_ROUTES)
                            || IsBest(node)) {
                            RemoveEntryList (&EnumPtr->RE_Links[EnumPtr->RE_Link]);
                            InsertTailList (cur,
                                            &EnumPtr->RE_Links[EnumPtr->RE_Link]);
                            return NO_ERROR;
                        }

                        break;
                }

            }
            // Go get next entry
            cur = cur->Blink;
        }

        // If we are not going through hash table or
        // we just interested in one network
        // or we've already been through all baskets
        // call it quits
        if ((EnumPtr->RE_Link!=RTM_NET_NUMBER_HASH_LINK)
            || (EnumPtr->RE_EnumerationFlags & RTM_ONLY_THIS_NETWORK)
            || (EnumPtr->RE_Lock
                ==&Table->RT_NetNumberHash[Table->RT_HashTableSize-1]))
            break;

                        // Otherwise, go through the next basket
        RemoveEntryList (&EnumPtr->RE_Links[RTM_NET_NUMBER_HASH_LINK]);
        LeaveSyncList (Table, EnumPtr->RE_Lock);
        EnumPtr->RE_Lock += 1;
        EnumPtr->RE_Head = &EnumPtr->RE_Lock->RSL_Head;
        if (!EnterSyncList (Table, EnumPtr->RE_Lock, TRUE)) {
            InitializeListEntry (&EnumPtr->RE_Links[RTM_NET_NUMBER_HASH_LINK]);
            return ERROR_NO_SYSTEM_RESOURCES;
        }

        InsertTailList (EnumPtr->RE_Head,
                        &EnumPtr->RE_Links[RTM_NET_NUMBER_HASH_LINK]);
    }
    return ERROR_NO_MORE_ROUTES;
}


//----------------------------------------------------------------------------
// SetMaskCount
//
//  Does a binary search of the g_meMaskTable to find the matching 
//  mask entry and increments the count for the specified mask
//  
//----------------------------------------------------------------------------

VOID
SetMaskCount( 
    PIP_NETWORK                 pinNet,
    BOOL                        bAdd
)
{

    DWORD                       dwLower, dwUpper, dwInd, dwMask;

    
    dwLower = 0;

    dwUpper = MAX_MASKS;

    dwMask  = pinNet-> N_NetMask;
    
    while ( dwLower <= dwUpper )
    {
        dwInd = ( dwLower + dwUpper ) / 2;

        if ( g_meMaskTable[ dwInd ].dwMask < dwMask )
        {
            //
            // Match is to be found in upper half of search region.
            //
            
            dwLower = dwInd + 1;
        }

        else if ( g_meMaskTable[ dwInd ].dwMask > dwMask )
        {
            //
            // Match is to be found in lower half of search region.
            //
            
            dwUpper = dwInd - 1;
        }

        else
        {
            //
            // Match found
            //

            if ( bAdd )
            {
                InterlockedIncrement( &g_meMaskTable[ dwInd ].dwCount );
            }

            else
            {
                InterlockedDecrement( &g_meMaskTable[ dwInd ].dwCount );
            }

            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtm\rtmdlg.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\rtm\rtmdlg.c

Abstract:
	Routing Table Manager DLL. Debugging code to display table entries
	in dialog box


Author:

	Vadim Eydelman

Revision History:

--*/

#include "pchrtm.h"
#pragma hdrstop

#if DBG


#define IP_PROTOCOL		RR_RoutingProtocol
#define	IP_INTERFACE	RR_InterfaceID
#define IP_METRIC		RR_FamilySpecificData.FSD_Metric1
#define IP_TIMESTAMP	RR_TimeStamp
#define IP_NET_NUM		RR_Network.N_NetNumber
#define IP_NET_MSK		RR_Network.N_NetMask
#define IP_NEXT_HOP_NUM	RR_NextHopAddress.N_NetNumber
#define IP_NEXT_HOP_MSK	RR_NextHopAddress.N_NetMask
#define IP_ADPTER_INDEX	RR_FamilySpecificData.FSD_AdapterIndex
#define IP_PROTOCOL_METRIC RR_FamilySpecificData.FSD_ProtocolMetric
#define IP_PSD			RR_ProtocolSpecificData

#define IPX_PROTOCOL		RR_RoutingProtocol
#define	IPX_INTERFACE		RR_InterfaceID
#define IPX_METRIC			RR_FamilySpecificData.FSD_TickCount
#define IPX_TIMESTAMP		RR_TimeStamp
#define IPX_NET_NUM			RR_Network.N_NetNumber
#define IPX_NEXT_HOP_MAC	RR_NextHopAddress.NHA_Mac
#define IPX_HOP_COUNT		RR_FamilySpecificData.FSD_HopCount
#define IPX_PSD				RR_ProtocolSpecificData

	// Make table accessible to debugging code
extern RTM_TABLE 	Tables[RTM_NUM_OF_PROTOCOL_FAMILIES];

	// Define protype internal to rtm.c
VOID
ConsolidateNetNumberLists (
	PRTM_TABLE			Table	// Table for which operation is performed
	);

DWORD		DbgLevel = 0;
DWORD		MaxTicks = MAXULONG;
DWORD 		MaxMessages=10000;



HANDLE		RTDlgThreadHdl;
ULONG		DisplayedTableIdx = 0xFFFFFFFF;
HWND		RTDlg=NULL;

	// Internal function prototypes
INT_PTR CALLBACK
RTDlgProc (
    HWND  	hDlg,
    UINT  	uMsg,
    WPARAM  wParam,
    LPARAM  lParam
   	);

INT
PrintRoute (
	char			*buffer,
	PRTM_ROUTE_NODE	node,
	BOOLEAN			full
	);

VOID
FillUpRouteLB (
	);



#define DLLInstanceHdl ((HANDLE)param)
DWORD WINAPI
RTDialogThread (
	LPVOID	param
	) {
	MSG			msg;
	DWORD		status;
	BOOLEAN		Done = FALSE;
	HANDLE		RegChangeEvt;
	HKEY		regHdl;
	DWORD		length, disposition, value;


	RegChangeEvt = CreateEvent (NULL, FALSE, TRUE, NULL);
	ASSERTERR (RegChangeEvt!=NULL);

	status = RegCreateKeyEx (HKEY_LOCAL_MACHINE,
								TEXT ("System\\CurrentControlSet\\Services\\RemoteAccess\\RTM"),
								0,
								NULL,
								REG_OPTION_NON_VOLATILE,
								KEY_READ,
								NULL,
								&regHdl,
								&disposition
								);
	ASSERTMSG ("Can't create registry key. ", status==NO_ERROR);

	length = sizeof (DWORD);
	status = RegQueryValueEx (regHdl, TicksWrapAroundValueName, NULL, NULL,
									 (PUCHAR)&value, &length);

	if (status==NO_ERROR)
		MaxTicks = value;

	length = sizeof (DWORD);
	status = RegQueryValueEx (regHdl, MaxMessagesValueName, NULL, NULL,
									 (PUCHAR)&value, &length);

	if (status==NO_ERROR)
		MaxMessages = value;

	while (!Done) {
		status = MsgWaitForMultipleObjects (1, &RegChangeEvt,
											FALSE, INFINITE, QS_ALLINPUT);
		if (status==(WAIT_OBJECT_0+1)) {
			while (PeekMessage (&msg, NULL, 0, 0, PM_REMOVE)) {
				if (msg.message==WM_QUIT) {
					Done = TRUE;
					break;
					}
				else if (!IsWindow(RTDlg)
					|| !IsDialogMessage(RTDlg, &msg)) {
					TranslateMessage (&msg);
					DispatchMessage (&msg);
					}
				}
			}
		else if (status==WAIT_OBJECT_0) {
			length = sizeof (DWORD);
			status = RegQueryValueEx (regHdl, DbgLevelValueName, NULL, NULL,
											 (PUCHAR)&DbgLevel, &length);
			if (status!=NO_ERROR)
				DbgLevel = 0;

			IF_DEBUG (DISPLAY_TABLE) {
				if (!IsWindow(RTDlg)) {
					RTDlg = CreateDialog (DLLInstanceHdl,
									MAKEINTRESOURCE (IDD_RTM_TABLE),
									NULL,
									&RTDlgProc);

					ASSERTERR (RTDlg!=NULL);
					}
				}
			else {
				if (IsWindow (RTDlg)) {
					DestroyWindow (RTDlg);
					RTDlg = NULL;
					}
				}
					

			status = RegNotifyChangeKeyValue (regHdl,
									 FALSE,
									 REG_NOTIFY_CHANGE_LAST_SET,
									 RegChangeEvt,
									 TRUE);
			ASSERTMSG ("Can't start registry notifications. ",
													 status==NO_ERROR);
			}
		}

	if (IsWindow (RTDlg)) {
		DestroyWindow (RTDlg);
		RTDlg = NULL;
		}
	RegCloseKey (regHdl);
	return 0;
	}
#undef DLLInstanceHdl

	// Dialog box procedure
INT_PTR CALLBACK
RTDlgProc (
    HWND  	hDlg,
    UINT  	uMsg,
    WPARAM  wParam,
    LPARAM  lParam
   	) {
	BOOL		res = FALSE;
	char		buf[32];
	int			idx;
	TIMER_BASIC_INFORMATION	TimerInfo;
	DWORD		status;

	switch (uMsg) {
		case WM_INITDIALOG:		// Dialog is being created
								// Fill in protocol family combo box
			SendDlgItemMessage (hDlg,
							IDC_PROTOCOL_FAMILY,
							CB_INSERTSTRING,
							RTM_PROTOCOL_FAMILY_IPX,
							(LPARAM)"IPX"
							);

			SendDlgItemMessage (hDlg,
							IDC_PROTOCOL_FAMILY,
							CB_INSERTSTRING,
							RTM_PROTOCOL_FAMILY_IP,
							(LPARAM)"IP"
							);

			DisplayedTableIdx = RTM_PROTOCOL_FAMILY_IPX;
			SendDlgItemMessage (hDlg,
							IDC_PROTOCOL_FAMILY,
							CB_SETCURSEL,
							DisplayedTableIdx,
							0
							);

				// Start timer (updates improvized clock)
			SetTimer (hDlg, 0, 1000, NULL);

			res = TRUE;
			break;

		case WM_COMMAND:		// Process child window messages only
			switch (LOWORD(wParam)) {
				case IDCANCEL:
					res = FALSE;
					break;
				case IDC_PROTOCOL_FAMILY:
					if (HIWORD(wParam)==CBN_SELENDOK) {
						DWORD	newFamily = (DWORD)SendMessage (
												        (HWND)lParam,
												        CB_GETCURSEL,
												        0, 0);
						if ((newFamily!=CB_ERR)
							&& (newFamily!=DisplayedTableIdx)) {
								// Change the displayed table if
								// user makes different selection
                            DisplayedTableIdx = newFamily;
							SendDlgItemMessage (hDlg,
									IDL_ROUTES,
									LB_RESETCONTENT,
									0, 0);
							if (Tables[DisplayedTableIdx].RT_Heap!=NULL) {
								ConsolidateNetNumberLists (&Tables[DisplayedTableIdx]);
								FillUpRouteLB ();
								}
							}
						} 
					break;
//				case IDL_ROUTES:
//						// Update entry on which user double clicks
//					if (HIWORD(wParam)==LBN_SELCHANGE)
//						UpdateLBSelections ();
//					break;
				case IDB_RESYNC:
					SendDlgItemMessage (hDlg,
							IDL_ROUTES,
							LB_RESETCONTENT,
							0, 0);
					if (Tables[DisplayedTableIdx].RT_Heap!=NULL) {
						ConsolidateNetNumberLists (&Tables[DisplayedTableIdx]);
						FillUpRouteLB ();
						}
					break;
				}
			break;
		
		case WM_TIMER:
				// Update improvised clock
			sprintf (buf, "%08d", GetTickCount ()/1000);
			SendDlgItemMessage (hDlg, IDT_TICK_COUNT, WM_SETTEXT,
									 		0, (LPARAM)buf);
			status = NtQueryTimer (
						Tables[DisplayedTableIdx].RT_ExpirationTimer,
						TimerBasicInformation,
						&TimerInfo,
						sizeof (TimerInfo),
						NULL);
			if (NT_SUCCESS (status)) {
				if (!TimerInfo.TimerState)
					sprintf (buf, "%08d",
						(ULONG)((LONGLONG)TimerInfo.RemainingTime.QuadPart
									/(10000*1000)));
				else
					sprintf (buf, "Not set");
				}
			else
				sprintf (buf, "error");
			SendDlgItemMessage (hDlg, IDT_EXPIRATION, WM_SETTEXT,
									 		0, (LPARAM)buf);

			status = NtQueryTimer (
						Tables[DisplayedTableIdx].RT_UpdateTimer,
						TimerBasicInformation,
						&TimerInfo,
						sizeof (TimerInfo),
						NULL);
			if (NT_SUCCESS (status)) {
				if (!TimerInfo.TimerState)
					sprintf (buf, "%08d",
						(ULONG)((LONGLONG)TimerInfo.RemainingTime.QuadPart
									/(10000*1000)));
				else
					sprintf (buf, "Not set");
				}
			else
				sprintf (buf, "error");
			SendDlgItemMessage (hDlg, IDT_UPDATE, WM_SETTEXT,
									 		0, (LPARAM)buf);
			res = TRUE;
			break;
		case RT_ADDROUTE:
			SendDlgItemMessage (hDlg, IDL_ROUTES,
										LB_INSERTSTRING, wParam, lParam);
//			Trace2 (ANY, "%2d - %s added\n", wParam, lParam);
			GlobalFree ((VOID *)lParam);
			res = TRUE;
			break;

		case RT_DELETEROUTE:
			idx = (int) SendDlgItemMessage (hDlg, IDL_ROUTES,
										LB_FINDSTRING, (WPARAM)0, lParam);
			if (idx!=LB_ERR)
				SendDlgItemMessage (hDlg, IDL_ROUTES,
											LB_DELETESTRING, (WPARAM)idx, 0);
//			Trace2 (ANY, "%2d - %s deleted\n", idx, lParam);
			GlobalFree ((VOID *)lParam);
			res = TRUE;
			break;
		case WM_DESTROY:
			DisplayedTableIdx = 0xFFFFFFFF;
			break;
		}

	return res;
	}


// Prints route information
INT
PrintRoute (
	char			*buf,		// Buffer to print to
	PRTM_ROUTE_NODE	node,		// Route to print
	BOOLEAN			full		// Print everything (including variable part)
	) {
	INT res;

	switch (DisplayedTableIdx) {
		case RTM_PROTOCOL_FAMILY_IPX:
			res = sprintf (buf,
					 "     %08x    ",
					 ((PRTM_IPX_ROUTE)&node->RN_Route)->IPX_NET_NUM
					 );
			break;

		case RTM_PROTOCOL_FAMILY_IP:
			res = sprintf (buf,
					 "%08x-%08x",
					 ((PRTM_IP_ROUTE)&node->RN_Route)->IP_NET_NUM,
					 ((PRTM_IP_ROUTE)&node->RN_Route)->IP_NET_MSK
					 );
			break;
		}
	res += sprintf (&buf[res],
				" %4d %4d",
				 node->RN_Route.XX_INTERFACE,
				 node->RN_Route.XX_PROTOCOL);

	switch (DisplayedTableIdx) {
		case RTM_PROTOCOL_FAMILY_IPX:
			res += sprintf (&buf[res],
				 "   %02x%02x%02x%02x%02x%02x  ",
				 ((PRTM_IPX_ROUTE)&node->RN_Route)->IPX_NEXT_HOP_MAC[0],
				 ((PRTM_IPX_ROUTE)&node->RN_Route)->IPX_NEXT_HOP_MAC[1],
				 ((PRTM_IPX_ROUTE)&node->RN_Route)->IPX_NEXT_HOP_MAC[2],
				 ((PRTM_IPX_ROUTE)&node->RN_Route)->IPX_NEXT_HOP_MAC[3],
				 ((PRTM_IPX_ROUTE)&node->RN_Route)->IPX_NEXT_HOP_MAC[4],
				 ((PRTM_IPX_ROUTE)&node->RN_Route)->IPX_NEXT_HOP_MAC[5]
				 );
			break;

		case RTM_PROTOCOL_FAMILY_IP:
			res += sprintf (&buf[res],
				 " %08x-%08x",
				 ((PRTM_IP_ROUTE)&node->RN_Route)->IP_NEXT_HOP_NUM,
				 ((PRTM_IP_ROUTE)&node->RN_Route)->IP_NEXT_HOP_MSK
				 );
			break;
		}

	if (full) {
		switch (DisplayedTableIdx) {
			case RTM_PROTOCOL_FAMILY_IPX:
				res += sprintf (&buf[res],
						" %6d %08d %1d %1d",
				 		((PRTM_IPX_ROUTE)&node->RN_Route)->IPX_METRIC,
						node->RN_ExpirationTime/1000,
						IsBest (node),
						IsEnabled (node));
				break;
			case RTM_PROTOCOL_FAMILY_IP:
				res += sprintf (&buf[res],
						" %6d %08d %1d %1d",
				 		((PRTM_IP_ROUTE)&node->RN_Route)->IP_METRIC,
						node->RN_ExpirationTime/1000,
						IsBest (node),
						IsEnabled (node));
				break;
			}
		}
	return res;
	}


// Fills list box with all routes in the current table
VOID
FillUpRouteLB (
	void
	) {
	PLIST_ENTRY			cur;
	INT					idx=0;
	PRTM_TABLE			Table = &Tables[DisplayedTableIdx];

		// Make sure we own the table while printing
	EnterSyncList (Table, &Table->RT_NetNumberMasterList, TRUE);
	cur = Table->RT_NetNumberMasterList.RSL_Head.Flink;

	while (cur!=&Table->RT_NetNumberMasterList.RSL_Head) {
		PRTM_ROUTE_NODE		node = CONTAINING_RECORD (cur,
										RTM_ROUTE_NODE,
										RN_Links[RTM_NET_NUMBER_LIST_LINK]);
		if (!IsEnumerator (node))
			AddRouteToLB (Table, node, idx++);

		cur = cur->Flink;
		}

	LeaveSyncList (Table, &Table->RT_NetNumberMasterList);
	}
	

// Insert line with item data at specified position in the list box
VOID
AddRouteToLB (
	PRTM_TABLE			Table,
	PRTM_ROUTE_NODE		node,
	INT					idx
	) {
	char		*buf;

	if (IsWindow (RTDlg)
		&& (Table==&Tables[DisplayedTableIdx])) {
		buf = (char *)GlobalAlloc (GMEM_FIXED, 80);

			// Print node
		PrintRoute (buf, node, TRUE);
			// Insert at specified position
		SendNotifyMessage (RTDlg, RT_ADDROUTE, (WPARAM)idx, (LPARAM)buf);
		}
	}

// Deletes route line from the list box
VOID
DeleteRouteFromLB (
	PRTM_TABLE			Table,
	PRTM_ROUTE_NODE		node
	) {
	char		*buf;

	if (IsWindow (RTDlg)
		&& (Table==&Tables[DisplayedTableIdx])) {
		buf = (char *)GlobalAlloc (GMEM_FIXED, 80);

			// Print route info
		PrintRoute (buf, node, FALSE);
			// Find corresponding line in the list
		SendNotifyMessage (RTDlg, RT_DELETEROUTE, 0, (LPARAM)buf);
		}
		
	}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtm\rtmv1rtm.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: rtmv1rtm.h
//
// History:
//      Chaitk	Feb-13-1999  Created.
//
// Private interface between RTMv1 and RTMv2
//============================================================================


#ifndef _ROUTING_RTMv1RTM_
#define _ROUTING_RTMv1RTM_

BOOL
Rtmv1DllStartup(
    HINSTANCE   hinstDLL  // DLL instance handle
);


VOID
Rtmv1DllCleanup(
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtm\rtmdlg.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\rtm\rtmdlg.c

Abstract:
	Routing Table Manager DLL. Debugging code to display table entries
	in dialog box. External prototypes


Author:

	Vadim Eydelman

Revision History:

--*/
#ifndef _RTMDLG_
#define _RTMDLG_

#include <windows.h>
#include <stdio.h>
#include "rtdlg.h"

#define	DbgLevelValueName TEXT("DbgLevel")
#define	TicksWrapAroundValueName TEXT("TicksWrapAround")
#define	MaxMessagesValueName TEXT("MaxMessages")


#define RT_ADDROUTE		(WM_USER+10)
#define RT_UPDATEROUTE	(WM_USER+11)
#define RT_DELETEROUTE	(WM_USER+12)

// Debug flags
#define DEBUG_DISPLAY_TABLE			0x00000001
#define DEBUG_SYNCHRONIZATION		0x00000002

extern DWORD		DbgLevel;
#define IF_DEBUG(flag) if (DbgLevel & DEBUG_ ## flag)


// Make it setable to be able to test time wraparound
extern ULONG	MaxTicks;
#undef MAXTICKS
#define MAXTICKS	MaxTicks
#define GetTickCount() (GetTickCount()&MaxTicks)
#undef IsLater
#define IsLater(Time1,Time2)	\
			(((Time1-Time2)&MaxTicks)<MaxTicks/2)
#undef TimeDiff
#define TimeDiff(Time1,Time2)	\
			((Time1-Time2)&MaxTicks)
#undef IsPositiveTimeDiff
#define IsPositiveTimeDiff(TimeDiff) \
			(TimeDiff<MaxTicks/2)


extern DWORD MaxMessages;
#undef RTM_MAX_ROUTE_CHANGE_MESSAGES
#define RTM_MAX_ROUTE_CHANGE_MESSAGES MaxMessages


// Routing Table Dialog Thread
extern HANDLE		RTDlgThreadHdl;
extern HWND			RTDlg;

DWORD WINAPI
RTDialogThread (
	LPVOID	param
	);
	    
VOID
AddRouteToLB (
	PRTM_TABLE			Table,
	PRTM_ROUTE_NODE		node,
	INT					idx
	);

VOID
DeleteRouteFromLB (
	PRTM_TABLE			Table,
	PRTM_ROUTE_NODE		node
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtm\rtmp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\rtm\rtmp.h

Abstract:
	Provate Interface for Routing Table Manager DLL


Author:

	Vadim Eydelman

Revision History:

--*/

#if 0

#ifndef NT_INCLUDED
#include <nt.h>
#endif

#ifndef _NTRTL_
#include <ntrtl.h>
#endif

#ifndef _NTURTL_
#include <nturtl.h>
#endif

#ifndef _WINDEF_
#include <windef.h>
#endif

#ifndef _WINBASE_
#include <winbase.h>
#endif

#ifndef _WINREG_
#include <winreg.h>
#endif

#ifndef _ROUTING_RTM_
#include "rtm.h"
#endif

#ifndef _ROUTING_RMRTM_
#include "rmrtm.h"
#endif

#endif


/*++
*******************************************************************
	S u p l e m e n t s  t o   R T M . H   S t r u c t u r e s

*******************************************************************
--*/
// Basic route info, present in routes of all types
typedef	struct {
		ROUTE_HEADER;
		} RTM_XX_ROUTE, *PRTM_XX_ROUTE;


#define XX_INTERFACE	RR_InterfaceID
#define XX_PROTOCOL		RR_RoutingProtocol
#define XX_METRIC		RR_Metric
#define XX_TIMESTAMP	RR_TimeStamp
#define XX_PSD			RR_ProtocolSpecificData



/*++
*******************************************************************
	S u p l e m e n t s  t o   N T R T L . H   S t r u c t u r e s

*******************************************************************
--*/
#define InitializeListEntry(entry) InitializeListHead(entry)
#define IsListEntry(entry)	(!IsListEmpty(entry))

#if DBG
#define ASSERTERR(exp) 										\
    if (!(exp)) {											\
		DbgPrint("Get last error= %d\n", GetLastError ());	\
        RtlAssert( #exp, __FILE__, __LINE__, NULL );		\
		}
#else
#define ASSERTERR(exp)
#endif

#if DBG
#define ASSERTERRMSG(msg,exp) 									\
    if (!(exp)) {											\
		DbgPrint("Get last error= %d\n", GetLastError ());	\
        RtlAssert( #exp, __FILE__, __LINE__, msg );			\
		}
#else
#define ASSERTERRMSG(msg,exp)
#endif



/*++
*******************************************************************
	C o n f i g u r a t i o n   C o n s t a n t s 

*******************************************************************
--*/

// Size of interface index hash table
#define RTM_INTF_HASH_SIZE					31

// Maximum number of nodes in temp net number list that will
// triger an update (temp list is scaned when inserting the route)
#define RTM_TEMP_LIST_MAX_COUNT			16
// Maximum number of nodes in deleted list that will
// triger an update
#define RTM_DELETED_LIST_MAX_COUNT		16
// Maximum time between updates (if not triggered by the conditions above or
// client's query)
#define RTM_NET_NUMBER_UPDATE_PERIOD	{(ULONG)(-60*1000*10000), -1L}
// Maximum number of pednign notification change messages
// the queue. If this number is exceeded because some client(s) are
// not dequeueing them, oldest message will be purged
#define RTM_MAX_ROUTE_CHANGE_MESSAGES	10000




/*++
*******************************************************************
	D a t a   T y p e s 

*******************************************************************
--*/


// Types of nodes that can exist in the table
#define RTM_ENUMERATOR_FLAG				0x00000001

#define RTM_BEST_NODE_FLAG				0x00000002
#define RTM_ENABLED_NODE_FLAG			0x00000004
#define RTM_ANY_ENABLE_STATE			((DWORD)(~RTM_ENABLED_NODE_FLAG))
#define RTM_SORTED_NODE_FLAG			0x00000008

#define IsEnumerator(node) (node->RN_Flags&RTM_ENUMERATOR_FLAG)

#define IsBest(node) (node->RN_Flags&RTM_BEST_NODE_FLAG)
#define SetBest(node) node->RN_Flags|=RTM_BEST_NODE_FLAG
#define ResetBest(node) node->RN_Flags&=(~RTM_BEST_NODE_FLAG)

#define IsEnabled(node) (node->RN_Flags&RTM_ENABLED_NODE_FLAG)
#define IsSameEnableState(node,EnableFlag) \
			((node->RN_Flags&RTM_ENABLED_NODE_FLAG)==EnableFlag)
#define SetEnable(node,enable) 								\
		node->RN_Flags = enable								\
				? (node->RN_Flags|RTM_ENABLED_NODE_FLAG)	\
				: (node->RN_Flags&(~RTM_ENABLED_NODE_FLAG))

#define IsSorted(node) (node->RN_Flags&RTM_SORTED_NODE_FLAG)
#define SetSorted(node) node->RN_Flags|=RTM_SORTED_NODE_FLAG

#define RTM_NODE_FLAGS_INIT			RTM_ENABLED_NODE_FLAG
#define RTM_ENUMERATOR_FLAGS_INIT 	RTM_ENUMERATOR_FLAG
// Each node will have the following links:

	// Hash table link (routes in each basket are ordered by
	// net number.interface.protocol.next_hop_address)
#define RTM_NET_NUMBER_HASH_LINK		0

	// Deleted list link: used if entry cannot be deleted
	// immediately because net number list is locked by the
	// update thread. It is same as hash table link
	// because one must first delete entry form the hash table
	// before adding it to deleted list (there is no ordering
	// in this list)
#define RTM_DELETED_LIST_LINK			RTM_NET_NUMBER_HASH_LINK

#if RTM_USE_PROTOCOL_LISTS
	// Link in the list of routes associated with a particular routing protocol
	// (routes are grouped (not oredered) by the net number and
	// ordered by protocol.next_hop_address inside of net number group
#define RTM_PROTOCOL_LIST_LINK			(RTM_NET_NUMBER_HASH_LINK+1)
	// Link in the list of routes associated with a particular interface
	// (routes are grouped (not oredered) by the net number and
	// ordered by interface.next_hop_address inside of net number group
#define RTM_INTERFACE_LIST_LINK			(RTM_PROTOCOL_LIST_LINK+1)
#else
#define RTM_INTERFACE_LIST_LINK			(RTM_NET_NUMBER_HASH_LINK+1)
#endif

	// Link in the list ordered by net number.interface.protocol.next_hop_address
	// There are two of these list. New routes are normaly inserted
	// in temporary list that is periodically merged with master list
#define RTM_NET_NUMBER_LIST_LINK		(RTM_INTERFACE_LIST_LINK+1)

	// Link in list ordered by expiration time
#define RTM_EXPIRATION_QUEUE_LINK		(RTM_NET_NUMBER_LIST_LINK+1)

	// Total number of links for each node
#define RTM_NUM_OF_LINKS				(RTM_EXPIRATION_QUEUE_LINK+1)

	// Client count treshold that prevents client from entering RTM
	// API's until table is initialized
#define RTM_CLIENT_STOP_TRESHHOLD		(-10000)


// Event with link to store it in the stack
typedef struct _RTM_SYNC_OBJECT {
	HANDLE				RSO_Event;
	SINGLE_LIST_ENTRY	RSO_Link;
	} RTM_SYNC_OBJECT, *PRTM_SYNC_OBJECT;

// Doubly linked list protected by the event that is
// assigned to the list on demand (when somebody is trying
// to access the list that is already in use)
typedef struct _RTM_SYNC_LIST {
	PRTM_SYNC_OBJECT	RSL_Sync;		// Assigned event
	LONG				RSL_UseCount;	// Number of user accessing or waiting
	LIST_ENTRY			RSL_Head;		// List itself (head)
	} RTM_SYNC_LIST, *PRTM_SYNC_LIST;


#if RTM_PROTOCOL_LIST_LINK
/* ****** Protocol lists no longer used ****** */
// Node of list of protocol lists
typedef struct _RTM_PROTOCOL_NODE {
		LIST_ENTRY			PN_Link;	// Link in list of protocol lists
		LIST_ENTRY			PN_Head;	// List of routes associated with
										// a protocol
		DWORD				PN_RoutingProtocol; // Routing Protocol number
		} RTM_PROTOCOL_NODE, *PRTM_PROTOCOL_NODE;
#endif

// Node of list of interface lists
typedef struct _RTM_INTERFACE_NODE {
		LIST_ENTRY			IN_Link;	// Link in list of interface lists
		LIST_ENTRY			IN_Head;	// List of routes associated with
										// an interface
		DWORD				IN_InterfaceID; // Interface handle
		} RTM_INTERFACE_NODE, *PRTM_INTERFACE_NODE;


// Node of Routing Table
typedef struct _RTM_ROUTE_NODE {
	LIST_ENTRY		RN_Links[RTM_NUM_OF_LINKS];	// Links in all lists
	DWORD			RN_Flags;
	PRTM_SYNC_LIST	RN_Hash;			// Hash bucket this entry belongs to
	DWORD			RN_ExpirationTime; 	// System (Windows) Time in msec
	RTM_XX_ROUTE	RN_Route;			// Route entry
	} RTM_ROUTE_NODE, *PRTM_ROUTE_NODE;

// Node used to enumerate through any of the lists
typedef struct _RTM_ENUMERATOR {
	LIST_ENTRY		RE_Links[RTM_NUM_OF_LINKS]; // header is same as in
	DWORD			RE_Flags;			// RTM_ROUTE_NODE
	INT				RE_Link;			// Which link is used for enumeration
	PLIST_ENTRY		RE_Head;			// Head of list through which we are
										// enumerting
	PRTM_SYNC_LIST	RE_Lock;			// Syncronization object protecting
										// the this list
	PRTM_SYNC_LIST	RE_Hash;			// Hash bucket this entry belongs to
	DWORD			RE_ProtocolFamily;	// Table in which we are enumerating
	DWORD			RE_EnumerationFlags; // Which types of entries to limit
										// enumeration to
	RTM_XX_ROUTE	RE_Route;			// Criteria
	} RTM_ENUMERATOR, *PRTM_ENUMERATOR;

// Node in route change message list
typedef struct _RTM_ROUTE_CHANGE_NODE {
	LIST_ENTRY			RCN_Link;				// Link in the list
	HANDLE				RCN_ResponsibleClient; // Client that caused this change
											// or null if route was aged out
	ULONG				RCN_ReferenceCount; // Initialized with total number
				// of registered clients and decremented as messages are reported to
				// each client until all clients are informed at which point the node
				// can be deleted
	DWORD				RCN_Flags;
	PRTM_ROUTE_NODE		RCN_Route2;
	RTM_XX_ROUTE		RCN_Route1;
	} RTM_ROUTE_CHANGE_NODE, *PRTM_ROUTE_CHANGE_NODE;


#define RTM_NODE_BASE_SIZE 										\
	(FIELD_OFFSET(RTM_ROUTE_NODE,RN_Route)						\
			>FIELD_OFFSET(RTM_ROUTE_CHANGE_NODE,RCN_Route1))	\
		? FIELD_OFFSET(RTM_ROUTE_NODE,RN_Route)					\
		: FIELD_OFFSET(RTM_ROUTE_CHANGE_NODE,RCN_Route1)


// Routing Manager Table
typedef struct _RTM_TABLE {
	HANDLE				RT_Heap;			// Heap to allocate nodes from
	LONG				RT_APIclientCount;	// Count of clients that are
											// inside of RTM API calls
	HANDLE				RT_ExpirationTimer;	// Nt timer handle
	HANDLE				RT_UpdateTimer;		// Nt timer handle
	DWORD				RT_NumOfMessages;	// Number of notification
											// messages in the queue
	ULONG				RT_NetworkCount;	// Total number of networks
											// to which we have routes
	DWORD				RT_NetNumberTempCount; // How many entries are in
											// net number temp list
	DWORD				RT_DeletedNodesCount; // How many entries are in
											// deleted list
	LONG				RT_UpdateWorkerPending;	// Sorted list update is
											// being performed or scheduled
											// if >=0
	LONG				RT_ExpirationWorkerPending;	// Expiration queue check is
											// being performed or scheduled 
											// if >=0
	SINGLE_LIST_ENTRY	RT_SyncObjectList;	// Stack of events that can be
											// used for synchronization
#if RTM_PROTOCOL_LIST_LINK
/* ****** Protocol lists no longer used ****** */
	RTM_SYNC_LIST		RT_ProtocolList;	// List of protocol lists
#endif
	RTM_SYNC_LIST		RT_NetNumberMasterList; // Master net number list
	RTM_SYNC_LIST		RT_NetNumberTempList; // Temp net number list
	RTM_SYNC_LIST		RT_DeletedList;		// List of deleted routes
	RTM_SYNC_LIST		RT_ExpirationQueue;	// Expiration queue
	RTM_SYNC_LIST		RT_RouteChangeQueue;// List of route change messages
	RTM_SYNC_LIST		RT_ClientList;		// List of registered clients
	PRTM_SYNC_LIST		RT_NetNumberHash; 	// Hash table
	PRTM_SYNC_LIST		RT_InterfaceHash;	// Hash table of interface lists
	RTM_PROTOCOL_FAMILY_CONFIG	RT_Config;			// Configuration params
	CRITICAL_SECTION	RT_Lock;			// Table-wide lock
	} RTM_TABLE, *PRTM_TABLE;

// Structure associated with each client
typedef struct _RTM_CLIENT {
	LIST_ENTRY				RC_Link;		// Link in client list
	DWORD					RC_ProtocolFamily;
	DWORD					RC_RoutingProtocol;
	DWORD					RC_Flags;
	HANDLE					RC_NotificationEvent;	// Event through which client
								// is notified about route change
	PLIST_ENTRY				RC_PendingMessage;	// Pointer to first message in 
								// the route change queue that was not reported
								// to the client
	} RTM_CLIENT, *PRTM_CLIENT;

#define RT_RouteSize 		RT_Config.RPFC_RouteSize
#define RT_HashTableSize	RT_Config.RPFC_HashSize
#define NNM(Route) 			(((char *)Route)+sizeof (RTM_XX_ROUTE))

#define NetNumCmp(Table,Route1,Route2)	\
			(*Table->RT_Config.RPFC_NNcmp)(NNM(Route1),NNM(Route2))
#define NextHopCmp(Table,Route1,Route2)	\
			(*Table->RT_Config.RPFC_NHAcmp)(Route1,Route2)
#define FSDCmp(Table,Route1,Route2)	\
			(*Table->RT_Config.RPFC_FSDcmp)(Route1,Route2)
#define ValidateRoute(Table,Route) \
			(*Table->RT_Config.RPFC_Validate)(Route)
#define MetricCmp(Table,Route1,Route2) \
			(*Table->RT_Config.RPFC_RMcmp)(Route1,Route2)

#define EnterTableAPI(Table)										\
	((InterlockedIncrement(&(Table)->RT_APIclientCount)>0)			\
		? TRUE														\
		: (InterlockedDecrement (&(Table)->RT_APIclientCount), FALSE))

#define ExitTableAPI(Table)	\
	InterlockedDecrement(&(Table)->RT_APIclientCount)

/*++
*******************************************************************
	I n t e r n a l   F u n c t i o n   P r o t o t y p e s 

*******************************************************************
--*/

// Initializes sync list object
VOID
InitializeSyncList (
	PRTM_SYNC_LIST	list
	);

#if DBG
#define EnterSyncList(table,list,wait) DoEnterSyncList(table,list,wait,__FILE__,__LINE__)
#else
#define EnterSyncList(table,list,wait) DoEnterSyncList(table,list,wait)
#endif

// Get mutually exclusive access to the sync list obect
// Returns TRUE if access if obtained, FALSE otherwise
BOOLEAN
DoEnterSyncList (
	PRTM_TABLE		table,
	PRTM_SYNC_LIST	list,
	BOOLEAN			wait
#if DBG
    , LPSTR         file,
    ULONG           line
#endif
	);


// Release previously owned sync list object
VOID
LeaveSyncList (
	PRTM_TABLE		table,
	PRTM_SYNC_LIST	list
	);



#define HashFunction(Table,Net)	\
			(*Table->RT_Config.RPFC_Hash)(Net)

#define IntfHashFunction(Table,InterfaceID) \
			(InterfaceID%RTM_INTF_HASH_SIZE)

// Finds list of routes that are associated with given interface and returns
// pointer to its head
// Creates new list of none exists yet
PLIST_ENTRY
FindInterfaceList (
	PRTM_SYNC_LIST	intfHash,
	DWORD			Interface,
	BOOL			CreateNew
	);

// Finds list of routes that are associated with given iprotocol and returns
// pointer to its head
// Creates new list of none exists yet
PLIST_ENTRY
FindProtocolList (
	PRTM_TABLE	Table,
	DWORD		RoutingProtocol,
	BOOL		CreateNew
	);

// Adds node to temporary net number list (to be later merged with master list)
// Both lists are ordered by net number.interface.protocol.next hop address
VOID
AddNetNumberListNode (
	PRTM_TABLE	Table,
	PRTM_ROUTE_NODE	newNode
	);

// Adds node to expiration time queue.  (Queue is ordered by expiration time)
// Return TRUE if new node is the first in the queue
BOOL
AddExpirationQueueNode (
	PRTM_TABLE	Table,
	PRTM_ROUTE_NODE	newNode
	);

#define MAXTICKS	MAXULONG
#define IsLater(Time1,Time2)	\
			(Time1-Time2<MAXTICKS/2)
#define TimeDiff(Time1,Time2)	\
			(Time1-Time2)
#define IsPositiveTimeDiff(TimeDiff) \
			(TimeDiff<MAXTICKS/2)

#if DBG
	// Include debugging function prototypes
#ifndef _RTMDLG_
#include "rtmdlg.h"
#endif

#include <rtutils.h>
#include "rtmdbg.h"

#endif

typedef struct _MASK_ENTRY
{
    DWORD   dwMask;
    DWORD   dwCount;
    
} MASK_ENTRY, *PMASK_ENTRY;


//
// for IPv4 addresses
//

#define MAX_MASKS       32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\apitest.c ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    apitest.c

Abstract:
    Contains routines for testing the RTMv2 API.

Author:
    Chaitanya Kodeboyina (chaitk) 26-Jun-1998

Revision History:

--*/

#include "apitest.h"

MY_ENTITY_EXPORT_METHODS
Rip2Methods =
{
    5,

    {
        EntityExportMethod,
        EntityExportMethod,
        NULL,
        EntityExportMethod,
        EntityExportMethod
    }
};

MY_ENTITY_EXPORT_METHODS
OspfMethods =
{
    6,

    {
        EntityExportMethod,
        EntityExportMethod,
        EntityExportMethod,
        EntityExportMethod,
        EntityExportMethod,
        EntityExportMethod
    }
};

MY_ENTITY_EXPORT_METHODS
Bgp4Methods =
{
    4,

    {
        EntityExportMethod,
        EntityExportMethod,
        EntityExportMethod,
        EntityExportMethod
    }
};


ENTITY_CHARS
GlobalEntityChars [] =
{
//
//  {
//    Rtmv2Registration,
//    { RtmInstanceId, AddressFamily, { EntityProtocolId, EntityInstanceId } },
//    EntityEventCallback,    ExportMethods,
//    RoutesFileName,
//  }
//
/*
    {
        FALSE,
        { 0, RTM_PROTOCOL_FAMILY_IP, { PROTO_IP_RIP, 1   } },
        EntityEventCallback, &Rip2Methods,
        "test.out"
    },
*/
    {
        TRUE,
        { 1, AF_INET, { PROTO_IP_RIP, 1   } },
        EntityEventCallback, &Rip2Methods,
        "test.out"
    },

    {
        TRUE,
        { 1, AF_INET, { PROTO_IP_OSPF, 1  } },
        EntityEventCallback, &OspfMethods,
        "test.out"
    },

    {
        TRUE,
        { 1, AF_INET, { PROTO_IP_BGP, 1   } },
        EntityEventCallback, &Bgp4Methods,
        "test.out"
    },

    {
        TRUE,
        { 0, 0,        { 0,           0   } },
        NULL,                NULL,
        ""
    }
};

const RTM_VIEW_SET VIEW_MASK_ARR[]
          = {
              0,
              RTM_VIEW_MASK_UCAST,
              RTM_VIEW_MASK_MCAST,
              RTM_VIEW_MASK_UCAST | RTM_VIEW_MASK_MCAST
            };

// Disable warnings for unreferenced params and local variables
#pragma warning(disable: 4100)
#pragma warning(disable: 4101)

//
// Main
//

#if !LOOKUP_TESTING

int
__cdecl
main (void)
{
    PENTITY_CHARS           Entity;
    DWORD                   Status;
    LPTHREAD_START_ROUTINE  EntityThreadProc;
#if MT
    UINT                    NumThreads;
    HANDLE                  Threads[64];
#endif

    Entity = &GlobalEntityChars[0];

#if MT
    NumThreads = 0;
#endif

    while (Entity->EntityInformation.EntityId.EntityId != 0)
    {
        if (Entity->Rtmv2Registration)
        {
            EntityThreadProc = Rtmv2EntityThreadProc;
        }
        else
        {
            EntityThreadProc = Rtmv1EntityThreadProc;
        }

#if MT
        Threads[NumThreads] = CreateThread(NULL,
                                           0,
                                           EntityThreadProc,
                                           Entity++,
                                           0,
                                           NULL);

        Print("Thread ID %d: %p\n", NumThreads, Threads[NumThreads]);

        NumThreads++;
#else
        Status = EntityThreadProc(Entity++);
#endif
    }

#if MT
    WaitForMultipleObjects(NumThreads, Threads, TRUE, INFINITE);
#endif

    return 0;
}

#endif

//
// A general state machine for a protocol thread (RTMv1)
//

DWORD Rtmv1EntityThreadProc (LPVOID ThreadParameters)
{
    RTM_PROTOCOL_FAMILY_CONFIG FamilyConfig;
    PENTITY_CHARS            EntityChars;
    PRTM_ENTITY_INFO         EntityInfo;
    HANDLE                   Event;
    HANDLE                   V1RegnHandle;
    DWORD                    ProtocolId;
    UINT                     i;
    FILE                     *FilePtr;
    IP_NETWORK               Network;
    UINT                     NumDests;
    UINT                     NumRoutes;
    Route                    ThisRoute;
    Route                    Routes[MAXROUTES];
    RTM_IP_ROUTE             V1Route;
    RTM_IP_ROUTE             V1Route2;
    HANDLE                   V1EnumHandle;
    BOOL                     Exists;
    DWORD                    Flags;
    DWORD                    Status;

    //
    // Get all characteristics of this entity
    //

    EntityChars = (PENTITY_CHARS) ThreadParameters;

    EntityInfo = &EntityChars->EntityInformation;

    Assert(EntityInfo->AddressFamily == RTM_PROTOCOL_FAMILY_IP);

    Print("\n--------------------------------------------------------\n");

#if WRAPPER
    FamilyConfig.RPFC_Validate = ValidateRouteCallback;
    FamilyConfig.RPFC_Change = RouteChangeCallback;

    Status = RtmCreateRouteTable(EntityInfo->AddressFamily, &FamilyConfig);

    if (Status != ERROR_ALREADY_EXISTS)
    {
        Check(Status, 50);
    }
    else
    {
        Print("Protocol Family's Route Table already created\n");
    }

    Event = CreateEvent(NULL, TRUE, FALSE, NULL);

    Assert(Event != NULL);

    ProtocolId = EntityInfo->EntityId.EntityProtocolId,

    V1RegnHandle = RtmRegisterClient(EntityInfo->AddressFamily,
                                      ProtocolId,
                                      NULL,
                                      NULL); // RTM_PROTOCOL_SINGLE_ROUTE);
    if (V1RegnHandle == NULL)
    {
        Status = GetLastError();

        Check(Status, 52);
    }

    if ((FilePtr = fopen(EntityChars->RoutesFileName, "r")) == NULL)
    {
        Fatal("Failed open route database with status = %p\n",
                ERROR_OPENING_DATABASE);
    }

    NumRoutes = ReadRoutesFromFile(FilePtr, MAX_ROUTES, Routes);

    fclose(FilePtr);

    //
    // How many destinations do we have in table ?
    //

    NumDests = RtmGetNetworkCount(EntityInfo->AddressFamily);

    if (NumDests == 0)
    {
        Check(Status, 63);
    }

    Print("Number of destinations = %lu\n\n", NumDests);

    //
    // Add a bunch of routes from the input file
    //

    for (i = 0; i < NumRoutes; i++)
    {
        // Print("Add Route: Addr = %08x, Mask = %08x\n",
        //            Routes[i].addr,
        //            Routes[i].mask);

        ConvertRouteToV1Route(&Routes[i], &V1Route);

        V1Route.RR_ProtocolSpecificData.PSD_Data[0] =
        V1Route.RR_ProtocolSpecificData.PSD_Data[1] =
        V1Route.RR_ProtocolSpecificData.PSD_Data[2] =
        V1Route.RR_ProtocolSpecificData.PSD_Data[3] = i;

        V1Route.RR_FamilySpecificData.FSD_Priority = ProtocolId;

        V1Route.RR_FamilySpecificData.FSD_Flags = (ULONG) ~0;

        Status = RtmAddRoute(V1RegnHandle,
                              &V1Route,
                              INFINITE,
                              &Flags,
                              NULL,
                              NULL);

        Check(Status, 54);
    }

    //
    // Check if routes exist to the destination
    //

    for (i = 0; i < NumRoutes; i++)
    {
        Network.N_NetNumber = Routes[i].addr;
        Network.N_NetMask = Routes[i].mask;

        Exists = RtmIsRoute(EntityInfo->AddressFamily,
                             &Network,
                             &V1Route);
        if (!Exists)
        {
            Check(Status, 64);

            continue;
        }

        // ConvertV1RouteToRoute(&V1Route, &ThisRoute);

        // PrintRoute(&ThisRoute);

        Exists = RtmLookupIPDestination(Routes[i].addr,
                                         &V1Route2);

        if (Exists)
        {
            if (!RtlEqualMemory(&V1Route, &V1Route2, sizeof(RTM_IP_ROUTE)))
            {
                Print("Routes different: \n");

                ConvertV1RouteToRoute(&V1Route, &ThisRoute);
                // PrintRoute(&ThisRoute);

                ConvertV1RouteToRoute(&V1Route2, &ThisRoute);
                // PrintRoute(&ThisRoute);

                Print("\n");
            }
        }
        else
        {
            Status = GetLastError();

            PrintIPAddr(&Routes[i].addr); Print("\n");

            Check(Status, 65);
        }
    }

    //
    // How many destinations do we have in table ?
    //

    NumDests = RtmGetNetworkCount(EntityInfo->AddressFamily);

    if (NumDests == 0)
    {
        Check(Status, 63);
    }

    Print("Number of destinations = %lu\n\n", NumDests);

    // Try using RtmGetFirstRoute and RtmGetNextRoute

    NumRoutes = 0;

    Status = RtmGetFirstRoute(EntityInfo->AddressFamily,
                               NULL,
                               &V1Route);

    // Check(Status, 59);

    while (SUCCESS(Status))
    {
        NumRoutes++;

        // Print the V1 Route that is next in the enum

        // ConvertV1RouteToRoute(&V1Route, &ThisRoute);

        // PrintRoute(&ThisRoute);

        Status = RtmGetNextRoute(EntityInfo->AddressFamily,
                                  NULL,
                                  &V1Route);

        // Check(Status, 60);
    }


    // Print("Num of routes in table : %lu\n", NumRoutes);


    //
    // Disable and reenable all routes that match criteria
    //

    V1Route.RR_InterfaceID = 3;

    Status = RtmBlockSetRouteEnable(V1RegnHandle,
                                     RTM_ONLY_THIS_INTERFACE,
                                     &V1Route,
                                     FALSE);
    Check(Status, 66);

/*
    V1Route.RR_InterfaceID = 3;

    Status = RtmBlockSetRouteEnable(V1RegnHandle,
                                     RTM_ONLY_THIS_INTERFACE,
                                     &V1Route,
                                     TRUE);
    Check(Status, 66);

    //
    // Convert all routes that match criteria to static
    //

    V1Route.RR_InterfaceID = 3;

    Status = RtmBlockConvertRoutesToStatic(V1RegnHandle,
                                            RTM_ONLY_THIS_INTERFACE,
                                            &V1Route);

    Check(Status, 62);
*/

    //
    // Delete all routes that match the criteria
    //

    ZeroMemory(&V1Route, sizeof(RTM_IP_ROUTE));

    V1Route.RR_InterfaceID = 2;

    Status= RtmBlockDeleteRoutes(V1RegnHandle,
                                 RTM_ONLY_THIS_INTERFACE|RTM_ONLY_THIS_NETWORK,
                                 &V1Route);

    Check(Status, 61);

    //
    // Enum and del this regn's routes in the table
    //

    V1Route.RR_RoutingProtocol = ProtocolId;

    V1EnumHandle = RtmCreateEnumerationHandle(EntityInfo->AddressFamily,
                                              RTM_ONLY_THIS_PROTOCOL,
                                              &V1Route);
    if (V1EnumHandle == NULL)
    {
        Status = GetLastError();

        Check(Status, 56);
    }

    NumRoutes = 0;

    do
    {
        Status = RtmEnumerateGetNextRoute(V1EnumHandle,
                                          &V1Route);

        // Check(Status, 58);

        if (!SUCCESS(Status))
        {
            break;
        }

        NumRoutes++;

        // Print the V1 Route that is next in the enum

        // ConvertV1RouteToRoute(&V1Route, &ThisRoute);

        // PrintRoute(&ThisRoute);

        // Delete this route from the table forever

        Status = RtmDeleteRoute(V1RegnHandle,
                                &V1Route,
                                &Flags,
                                NULL);

        Check(Status, 55);
    }
    while (TRUE);

    Print("Num of routes in table : %lu\n", NumRoutes);

    Status = RtmCloseEnumerationHandle(V1EnumHandle);

    Check(Status, 57);

    //
    // Enumerate all routes in table once again
    //

    V1EnumHandle = RtmCreateEnumerationHandle(EntityInfo->AddressFamily,
                                              RTM_INCLUDE_DISABLED_ROUTES,
                                              NULL);
    if (V1EnumHandle == NULL)
    {
        Status = GetLastError();

        Check(Status, 56);
    }

    NumRoutes = 0;

    do
    {
        Status = RtmEnumerateGetNextRoute(V1EnumHandle,
                                          &V1Route);

        // Check(Status, 58);

        if (!SUCCESS(Status))
        {
            break;
        }

        NumRoutes++;

        // Print the V1 Route that is next in the enum

        ConvertV1RouteToRoute(&V1Route, &ThisRoute);

        // PrintRoute(&ThisRoute);

        UNREFERENCED_PARAMETER(Flags);

        Status = RtmDeleteRoute(V1RegnHandle,
                                &V1Route,
                                &Flags,
                                NULL);

        Check(Status, 55);
    }
    while (TRUE);

    Print("Num of routes in table : %lu\n", NumRoutes);

    Status = RtmCloseEnumerationHandle(V1EnumHandle);

    Check(Status, 57);

    //
    // Deregister the entity and clean up now
    //

    Status = RtmDeregisterClient(V1RegnHandle);

    Check(Status, 53);

    if (Event)
    {
        CloseHandle(Event);
    }

    Status = RtmDeleteRouteTable(EntityInfo->AddressFamily);

    Check(Status, 51);
#endif

    Print("\n--------------------------------------------------------\n");

    return 0;
}

VOID
ConvertRouteToV1Route(Route *ThisRoute, RTM_IP_ROUTE *V1Route)
{
    ZeroMemory(V1Route, sizeof(RTM_IP_ROUTE));

    V1Route->RR_Network.N_NetNumber = ThisRoute->addr;
    V1Route->RR_Network.N_NetMask = ThisRoute->mask;

    V1Route->RR_InterfaceID = PtrToUlong(ThisRoute->interface);

    V1Route->RR_NextHopAddress.N_NetNumber = ThisRoute->nexthop;
    V1Route->RR_NextHopAddress.N_NetMask = 0xFFFFFFFF;

    V1Route->RR_FamilySpecificData.FSD_Metric = ThisRoute->metric;

    return;
}

VOID
ConvertV1RouteToRoute(RTM_IP_ROUTE *V1Route, Route *ThisRoute)
{
    DWORD Mask;

    ZeroMemory(ThisRoute, sizeof(Route));

    ThisRoute->addr = V1Route->RR_Network.N_NetNumber;
    ThisRoute->mask = V1Route->RR_Network.N_NetMask;

    ThisRoute->len = 0;

    // No checking for contiguous masks

    Mask = ThisRoute->mask;
    while (Mask)
    {
        if (Mask & 1)
        {
            ThisRoute->len++;
        }

        Mask >>= 1;
    }

    ThisRoute->interface = ULongToPtr(V1Route->RR_InterfaceID);

    ThisRoute->nexthop = V1Route->RR_NextHopAddress.N_NetNumber;
    Assert(V1Route->RR_NextHopAddress.N_NetMask ==  0xFFFFFFFF);

    ThisRoute->metric = V1Route->RR_FamilySpecificData.FSD_Metric;

    Print("Owner = %08x, ", V1Route->RR_RoutingProtocol);
    PrintRoute(ThisRoute);

    return;
}

DWORD
ValidateRouteCallback(
    IN      PVOID                           Route
    )
{
    UNREFERENCED_PARAMETER(Route);

    return NO_ERROR;
}

VOID
RouteChangeCallback(
    IN      DWORD                           Flags,
    IN      PVOID                           CurrBestRoute,
    IN      PVOID                           PrevBestRoute
    )
{
    Route       ThisRoute;

    Print("Route Change Notification:\n");

    Print("Flags = %08x\n", Flags);

    Print("Prev Route = ");
    if (Flags & RTM_PREVIOUS_BEST_ROUTE)
    {
        ConvertV1RouteToRoute((RTM_IP_ROUTE *) PrevBestRoute, &ThisRoute);
        // PrintRoute(ThisRoute);
    }
    else
    {
        Print("NULL Route\n");
    }

    // Print("Curr Route = ");
    if (Flags & RTM_CURRENT_BEST_ROUTE)
    {
        ConvertV1RouteToRoute((RTM_IP_ROUTE *) CurrBestRoute, &ThisRoute);
        // PrintRoute(ThisRoute);
    }
    else
    {
        Print("NULL Route\n");
    }

    return;
}


//
// A general state machine for a protocol thread (RTMv2)
//

DWORD Rtmv2EntityThreadProc (LPVOID ThreadParameters)
{
    PENTITY_CHARS             EntityChars;
    PRTM_ENTITY_INFO          EntityInfo;
    RTM_INSTANCE_CONFIG       InstanceConfig;
    RTM_ADDRESS_FAMILY_CONFIG AddrFamConfig;
    RTM_ADDRESS_FAMILY_INFO   AddrFamilyInfo;
    RTM_ENTITY_HANDLE         RtmRegHandle;
    RTM_VIEW_SET              ViewSet;
    UINT                      NumViews;
    UINT                      NumInstances;
    RTM_INSTANCE_INFO         Instances[MAX_INSTANCES];
    RTM_ADDRESS_FAMILY_INFO   AddrFams[MAX_ADDR_FAMS];
    UINT                      NumEntities;
    RTM_ENTITY_HANDLE         EntityHandles[MAX_ENTITIES];
    RTM_ENTITY_INFO           EntityInfos[MAX_ENTITIES];
    UINT                      NumMethods;
    RTM_ENTITY_EXPORT_METHOD  ExportMethods[MAX_METHODS];
    RTM_ENTITY_METHOD_INPUT   Input;
    UINT                      OutputHdrSize;
    UINT                      OutputSize;
    RTM_ENTITY_METHOD_OUTPUT  Output[MAX_METHODS];
    UINT                      i, j, k, l, m;
    UCHAR                     *p;
    FILE                      *FilePtr;
    UINT                      NumRoutes;
    Route                     Routes[MAXROUTES];
    RTM_NEXTHOP_INFO          NextHopInfo;
    RTM_NEXTHOP_HANDLE        NextHopHandle;
    PRTM_NEXTHOP_INFO         NextHopPointer;
    DWORD                     ChangeFlags;
    RTM_ENUM_HANDLE           EnumHandle;
    RTM_ENUM_HANDLE           EnumHandle1;
    RTM_ENUM_HANDLE           EnumHandle2;
    UINT                      TotalHandles;
    UINT                      NumHandles;
    HANDLE                    Handles[MAX_HANDLES];
    RTM_NET_ADDRESS           NetAddress;
    UINT                      DestInfoSize;
    PRTM_DEST_INFO            DestInfo1;
    PRTM_DEST_INFO            DestInfo2;
    UINT                      NumInfos;
    PRTM_DEST_INFO            DestInfos;
    RTM_ROUTE_INFO            RouteInfo;
    RTM_ROUTE_HANDLE          RouteHandle;
    PRTM_ROUTE_INFO           RoutePointer;
    RTM_PREF_INFO             PrefInfo;
    RTM_ROUTE_LIST_HANDLE     RouteListHandle1;
    RTM_ROUTE_LIST_HANDLE     RouteListHandle2;
    RTM_NOTIFY_HANDLE         NotifyHandle;
    BOOL                      Marked;
    DWORD                     Status;
    DWORD                     Status1;
    DWORD                     Status2;

    //
    // Test the mask to len conversion macros in rtmv2.h
    //

    for (i = 0; i < 33; i++)
    {
        j = RTM_IPV4_MASK_FROM_LEN(i);

        p = (PUCHAR) &j;

        RTM_IPV4_LEN_FROM_MASK(k, j);

        Assert(i == k);

        printf("Len %2d: %08x: %02x.%02x.%02x.%02x: %2d\n",
               i, j, p[0], p[1], p[2], p[3], k);
    }

    //
    // Get all characteristics of this entity
    //

    EntityChars = (PENTITY_CHARS) ThreadParameters;

    EntityInfo = &EntityChars->EntityInformation;

    Print("\n--------------------------------------------------------\n");

    //
    // -00- Is this addr family config in registry
    //

    Status = RtmReadAddressFamilyConfig(EntityInfo->RtmInstanceId,
                                        EntityInfo->AddressFamily,
                                        &AddrFamConfig);

    DBG_UNREFERENCED_LOCAL_VARIABLE(InstanceConfig);

    if (!SUCCESS(Status))
    {
        // Fill in the instance config

        Status = RtmWriteInstanceConfig(EntityInfo->RtmInstanceId,
                                        &InstanceConfig);

        Check(Status, 0);

        // Fill in the address family config

        AddrFamConfig.AddressSize = sizeof(DWORD);

        AddrFamConfig.MaxChangeNotifyRegns = 10;
        AddrFamConfig.MaxOpaqueInfoPtrs = 10;
        AddrFamConfig.MaxNextHopsInRoute = 5;
        AddrFamConfig.MaxHandlesInEnum = 100;

        AddrFamConfig.ViewsSupported = RTM_VIEW_MASK_UCAST|RTM_VIEW_MASK_MCAST;

        Status = RtmWriteAddressFamilyConfig(EntityInfo->RtmInstanceId,
                                             EntityInfo->AddressFamily,
                                             &AddrFamConfig);
        Check(Status, 0);
    }

    //
    // -01- Register with an AF on an RTM instance
    //

    Status = RtmRegisterEntity(EntityInfo,
                               (PRTM_ENTITY_EXPORT_METHODS)
                               EntityChars->ExportMethods,
                               EntityChars->EventCallback,
                               TRUE,
                               &EntityChars->RegnProfile,
                               &RtmRegHandle);

    Check(Status, 1);

    //
    // Count the number of views for later use
    //

    NumViews = EntityChars->RegnProfile.NumberOfViews;

    //
    // Test all the management APIs before others
    //

    NumInstances = MAX_INSTANCES;

    Status = RtmGetInstances(&NumInstances,
                             &Instances[0]);

    Check(Status, 100);

    for (i = 0; i < NumInstances; i++)
    {
        Status = RtmGetInstanceInfo(Instances[i].RtmInstanceId,
                                    &Instances[i],
                                    &Instances[i].NumAddressFamilies,
                                    AddrFams);

        Check(Status, 101);
    }

    //
    // Query the appropriate table to check regn
    //

    NumEntities = MAX_ENTITIES;

    Status = RtmGetAddressFamilyInfo(EntityInfo->RtmInstanceId,
                                     EntityInfo->AddressFamily,
                                     &AddrFamilyInfo,
                                     &NumEntities,
                                     EntityInfos);
    Check(Status, 102);

    //
    // -03- Get all currently registered entities
    //

    NumEntities = MAX_ENTITIES;

    Status = RtmGetRegisteredEntities(RtmRegHandle,
                                      &NumEntities,
                                      EntityHandles,
                                      EntityInfos);

    Print("\n");
    for (i = 0; i < NumEntities; i++)
    {
        Print("%02d: Handle: %p\n", i, EntityHandles[i]);
    }
    Print("\n");

    Check(Status, 3);

    //
    // -04- Get all exports methods of each entity
    //

    for (i = 0; i < NumEntities; i++)
    {
        NumMethods = 0;

        Status = RtmGetEntityMethods(RtmRegHandle,
                                     EntityHandles[i],
                                     &NumMethods,
                                     NULL);

        Check(Status, 4);

        Print("\n");
        Print("Number of methods for %p = %2d\n",
                  EntityHandles[i],
                  NumMethods);
        Print("\n");

        Status = RtmGetEntityMethods(RtmRegHandle,
                                     EntityHandles[i],
                                     &NumMethods,
                                     ExportMethods);

        Check(Status, 4);

/*
        //
        // -06- Try blocking methods & then calling invoke
        //      Wont block as thread owns Critical Section
        //

        Status = RtmBlockMethods(RtmRegHandle,
                                 NULL,
                                 0,
                                 RTM_BLOCK_METHODS);

        Check(Status, 6);
*/

        // for (j = 0; j < NumMethods; j++)
        {
            //
            // -05- Invoke all exports methods of an entity
            //

            Input.MethodType = METHOD_TYPE_ALL_METHODS; // 1 << j;

            Input.InputSize = 0;

            OutputHdrSize = FIELD_OFFSET(RTM_ENTITY_METHOD_OUTPUT, OutputData);

            OutputSize = OutputHdrSize * MAX_METHODS;

            Status = RtmInvokeMethod(RtmRegHandle,
                                     EntityHandles[i],
                                     &Input,
                                     &OutputSize,
                                     Output);

            Print("\n");
            Print("Num Methods Called = %d\n", OutputSize / OutputHdrSize);
            Print("\n");

            Check(Status, 5);
        }
    }

    //
    // -44- Release handles we have on the entities
    //

    Status = RtmReleaseEntities(RtmRegHandle,
                                NumEntities,
                                EntityHandles);

    Check(Status, 44);

    //
    // -07- Add next hops to the table (from the info file)
    //

    if ((FilePtr = fopen(EntityChars->RoutesFileName, "r")) == NULL)
    {
        Fatal("Failed open route database with status = %x\n",
                ERROR_OPENING_DATABASE);
    }

    NumRoutes = ReadRoutesFromFile(FilePtr,
                                   MAX_ROUTES,
                                   Routes);

    fclose(FilePtr);

    // For each route, add its next-hop to the next-hop table

    for (i = 0; i < NumRoutes; i++)
    {
        RTM_IPV4_MAKE_NET_ADDRESS(&NextHopInfo.NextHopAddress,
                                  Routes[i].nexthop,
                                  ADDRSIZE);

        NextHopInfo.RemoteNextHop = NULL;
        NextHopInfo.Flags = 0;
        NextHopInfo.EntitySpecificInfo = UIntToPtr(i);
        NextHopInfo.InterfaceIndex = PtrToUlong(Routes[i].interface);

        NextHopHandle = NULL;

        Status = RtmAddNextHop(RtmRegHandle,
                               &NextHopInfo,
                               &NextHopHandle,
                               &ChangeFlags);

        Check(Status, 7);

        // Print("Add Next Hop %lu: %p\n", i, NextHopHandle);

        if (!(ChangeFlags & RTM_NEXTHOP_CHANGE_NEW))
        {
            Status = RtmReleaseNextHops(RtmRegHandle,
                                        1,
                                        &NextHopHandle);
            Check(Status, 15);
        }
#if _DBG_
        else
        {
            Status = RtmDeleteNextHop(RtmRegHandle,
                                      NextHopHandle,
                                      NULL);
            Check(Status, 14);
        }
#endif
    }


    //
    // 08 - Find the next-hops added using RtmFindNextHop
    //

    for (i = 0; i < NumRoutes; i++)
    {
        RTM_IPV4_MAKE_NET_ADDRESS(&NextHopInfo.NextHopAddress,
                                  Routes[i].nexthop,
                                  ADDRSIZE);

        NextHopInfo.NextHopOwner = RtmRegHandle;

        NextHopInfo.InterfaceIndex = PtrToUlong(Routes[i].interface);

        NextHopHandle = NULL;

        Status = RtmFindNextHop(RtmRegHandle,
                                &NextHopInfo,
                                &NextHopHandle,
                                &NextHopPointer);

        // Print("NextHop: Handle: %p,\n\t Addr: ", NextHopHandle);
        // Print("%3d.", (UINT) NextHopPointer->NextHopAddress.AddrBits[0]);
        // Print("%3d.", (UINT) NextHopPointer->NextHopAddress.AddrBits[1]);
        // Print("%3d.", (UINT) NextHopPointer->NextHopAddress.AddrBits[2]);
        // Print("%3d ", (UINT) NextHopPointer->NextHopAddress.AddrBits[3]);
        // Print("\n\tInterface = %lu\n", NextHopPointer->InterfaceIndex);

        Check(Status, 8);

        Status = RtmReleaseNextHops(RtmRegHandle,
                                    1,
                                   &NextHopHandle);

        Check(Status, 15);
    }

    //
    // -40- Register with RTM for getting change notifications
    //

    Status = RtmRegisterForChangeNotification(RtmRegHandle,
                                              RTM_VIEW_MASK_MCAST,
                                              RTM_CHANGE_TYPE_BEST,
                                              // RTM_NOTIFY_ONLY_MARKED_DESTS,
                                              EntityChars,
                                              &NotifyHandle);

    Check(Status, 40);

    Print("Change Notification Registration Successful\n\n");

    //
    // -35- Create an entity specific list to add routes to
    //

    Status = RtmCreateRouteList(RtmRegHandle,
                                &RouteListHandle1);

    Check(Status, 35);

    //
    // -17- Add routes to RIB with approprate next-hops
    //

    for (i = 0; i < NumRoutes; i++)
    {
        // Get the next hop handle using next hop address

        RTM_IPV4_MAKE_NET_ADDRESS(&NextHopInfo.NextHopAddress,
                                  Routes[i].nexthop,
                                  ADDRSIZE);

        NextHopInfo.NextHopOwner = RtmRegHandle;

        NextHopInfo.InterfaceIndex = PtrToUlong(Routes[i].interface);

        NextHopHandle = NULL;

        Status = RtmFindNextHop(RtmRegHandle,
                                &NextHopInfo,
                                &NextHopHandle,
                                NULL);
        Check(Status, 8);

        // Now do the route add with the right information

        RouteHandle = NULL;

        RTM_IPV4_MAKE_NET_ADDRESS(&NetAddress,
                                  Routes[i].addr,
                                  Routes[i].len);

        // Print("Add Route: Len : %08x, Addr = %3d.%3d.%3d.%3d\n",
        //           NetAddress.NumBits,
        //           NetAddress.AddrBits[0],
        //           NetAddress.AddrBits[1],
        //           NetAddress.AddrBits[2],
        //           NetAddress.AddrBits[3]);

        ZeroMemory(&RouteInfo, sizeof(RTM_ROUTE_INFO));

        // Assume 'neighbour learnt from' is the 1st nexthop
        RouteInfo.Neighbour = NextHopHandle;

        RouteInfo.PrefInfo.Preference = EntityInfo->EntityId.EntityProtocolId;
        RouteInfo.PrefInfo.Metric = Routes[i].metric;

        RouteInfo.BelongsToViews = VIEW_MASK_ARR[1 + (i % 3)];

        RouteInfo.EntitySpecificInfo = UIntToPtr(i);

        RouteInfo.NextHopsList.NumNextHops = 1;
        RouteInfo.NextHopsList.NextHops[0] = NextHopHandle;

        ChangeFlags = RTM_ROUTE_CHANGE_NEW;

        Status = RtmAddRouteToDest(RtmRegHandle,
                                   &RouteHandle,
                                   &NetAddress,
                                   &RouteInfo,
                                   INFINITE,
                                   RouteListHandle1,
                                   0,
                                   NULL,
                                   &ChangeFlags);

        Check(Status, 17);

        // Update the same route using the handle

        ChangeFlags = 0;

        RouteInfo.Flags = RTM_ROUTE_FLAGS_DISCARD;

        Status = RtmAddRouteToDest(RtmRegHandle,
                                   &RouteHandle,
                                   &NetAddress,
                                   &RouteInfo,
                                   INFINITE,
                                   RouteListHandle1,
                                   0,
                                   NULL,
                                   &ChangeFlags);

        Check(Status, 17);

        // Print("Add Route %lu: %p\n", i, RouteHandle);

        Status = RtmLockRoute(RtmRegHandle,
                              RouteHandle,
                              TRUE,
                              TRUE,
                              &RoutePointer);

        Check(Status, 46);

        // Update route parameters in place

        RoutePointer->PrefInfo.Metric = 1000 - RoutePointer->PrefInfo.Metric;

        RoutePointer->BelongsToViews = VIEW_MASK_ARR[i % 3];

        RoutePointer->EntitySpecificInfo = UIntToPtr(1000 - i);

        Status = RtmUpdateAndUnlockRoute(RtmRegHandle,
                                         RouteHandle,
                                         10, // INFINITE,
                                         NULL,
                                         0,
                                         NULL,
                                         &ChangeFlags);

        Check(Status, 47);

        // Print("Update Route %lu: %p\n", i, RouteHandle);

        if (!SUCCESS(Status))
        {
            Status = RtmLockRoute(RtmRegHandle,
                                  RouteHandle,
                                  TRUE,
                                  FALSE,
                                  NULL);

            Check(Status, 46);
        }

        // Try doing a add specifying the route handle

        RouteInfo.PrefInfo.Metric = Routes[i].metric;

        RouteInfo.BelongsToViews = VIEW_MASK_ARR[1 + (i % 3)];

        RouteInfo.EntitySpecificInfo = UIntToPtr(i);

        ChangeFlags = 0;

        Status = RtmAddRouteToDest(RtmRegHandle,
                                   &RouteHandle,
                                   &NetAddress,
                                   &RouteInfo,
                                   INFINITE,
                                   RouteListHandle1,
                                   0,
                                   NULL,
                                   &ChangeFlags);
        
        Check(Status, 17);

        Status = RtmReleaseNextHops(RtmRegHandle,
                                    1,
                                    &NextHopHandle);

        // Check(Status, 15);

        if (!SUCCESS(Status))
        {
            // Print("%p %p\n", RtmRegHandle,NextHopHandle);

            Status = RtmReleaseNextHops(RtmRegHandle,
                                    1,
                                    &NextHopHandle);

            Check(Status, 15);
        }
    }

    Status = RtmCreateRouteList(RtmRegHandle,
                                &RouteListHandle2);

    Check(Status, 35);

    //
    // -38- Create an enumeration on the route list
    //

    Status = RtmCreateRouteListEnum(RtmRegHandle,
                                    RouteListHandle1,
                                    &EnumHandle);

    Check(Status, 38);

    TotalHandles = 0;

    do
    {
        //
        // -39- Get next set of routes on the enum
        //

        NumHandles = MAX_HANDLES;

        Status = RtmGetListEnumRoutes(RtmRegHandle,
                                      EnumHandle,
                                      &NumHandles,
                                      Handles);
        Check(Status, 39);

        TotalHandles += NumHandles;

        for (i = 0; i < NumHandles; i++)
        {
            ; // Print("Route Handle %5lu: %p\n", i, Handles[i]);
        }

        //
        // -37- Move all routes in one route list to another
        //

        Status = RtmInsertInRouteList(RtmRegHandle,
                                      RouteListHandle2,
                                      NumHandles,
                                      Handles);

        Check(Status, 37);

        //
        // Release the routes that have been enum'ed
        //

        Status = RtmReleaseRoutes(RtmRegHandle, NumHandles, Handles);

        Check(Status, 27);
    }
    while (NumHandles == MAX_HANDLES);

    Print("\nTotal Num of handles in list: %lu\n", TotalHandles);


    //
    // -36- Destroy all the entity specific lists
    //

    Status = RtmDeleteRouteList(RtmRegHandle, RouteListHandle1);

    Check(Status, 36);


    Status = RtmDeleteRouteList(RtmRegHandle, RouteListHandle2);

    Check(Status, 36);


    DestInfoSize = RTM_SIZE_OF_DEST_INFO(NumViews);

    DestInfo1 = ALLOC_RTM_DEST_INFO(NumViews, 1);

    DestInfo2 = ALLOC_RTM_DEST_INFO(NumViews, 1);

    //
    // -18- Get dests from the table using exact match
    //

    for (i = 0; i < NumRoutes; i++)
    {
        // Query for the route with the right information

        RTM_IPV4_MAKE_NET_ADDRESS(&NetAddress, Routes[i].addr, Routes[i].len);

        Status = RtmGetExactMatchDestination(RtmRegHandle,
                                             &NetAddress,
                                             RTM_BEST_PROTOCOL,
                                             0,
                                             DestInfo1);
        Check(Status, 18);

        //
        // For each destination in table, mark the dest
        //

        Status = RtmMarkDestForChangeNotification(RtmRegHandle,
                                                  NotifyHandle,
                                                  DestInfo1->DestHandle,
                                                  TRUE);
        Check(Status, 48);

        Status = RtmIsMarkedForChangeNotification(RtmRegHandle,
                                                  NotifyHandle,
                                                  DestInfo1->DestHandle,
                                                  &Marked);
        Check(Status, 49);

        Assert(Marked == TRUE);

        Status = RtmReleaseDestInfo(RtmRegHandle, DestInfo1);

        Check(Status, 22);
    }

    DestInfo1 = ALLOC_RTM_DEST_INFO(NumViews, 1);

    DestInfo2 = ALLOC_RTM_DEST_INFO(NumViews, 1);

    //
    // -29- Get routes from the table using exact match
    //

    for (i = 0; i < NumRoutes; i++)
    {
        // Get the next hop handle using next hop address

        RTM_IPV4_MAKE_NET_ADDRESS(&NextHopInfo.NextHopAddress,
                                  Routes[i].nexthop,
                                  ADDRSIZE);

        NextHopInfo.NextHopOwner = RtmRegHandle;

        NextHopInfo.InterfaceIndex = PtrToUlong(Routes[i].interface);

        NextHopHandle = NULL;

        Status = RtmFindNextHop(RtmRegHandle,
                                &NextHopInfo,
                                &NextHopHandle,
                                NULL);
        Check(Status, 8);

        RTM_IPV4_MAKE_NET_ADDRESS(&NetAddress,
                                  Routes[i].addr,
                                  Routes[i].len);

        // Query for the route with the right information

        RouteInfo.Neighbour = NextHopHandle;

        RouteInfo.RouteOwner = RtmRegHandle;

        RouteInfo.PrefInfo.Preference = EntityInfo->EntityId.EntityProtocolId;
        RouteInfo.PrefInfo.Metric = Routes[i].metric;

        RouteInfo.NextHopsList.NumNextHops = 1;
        RouteInfo.NextHopsList.NextHops[0] = NextHopHandle;

        Status = RtmGetExactMatchRoute(RtmRegHandle,
                                       &NetAddress,
                                       RTM_MATCH_FULL,
                                       &RouteInfo,
                                       PtrToUlong(Routes[i].interface),
                                       0,
                                       &RouteHandle);

        Check(Status, 29);

        Status = RtmReleaseNextHops(RtmRegHandle,
                                    1,
                                    &NextHopHandle);

        Check(Status, 15);

        Status = RtmReleaseRoutes(RtmRegHandle, 1, &RouteHandle);

        Check(Status, 27);

        Status = RtmReleaseRouteInfo(RtmRegHandle, &RouteInfo);

        Check(Status, 31);
    }


    //
    // -19- Get dests from the table using prefix match
    //
    // -20- Do a prefix walk up the tree for each dest
    //

    for (i = j = 0; i < NumRoutes; i++)
    {
        // Query for the route with the right information

        RTM_IPV4_MAKE_NET_ADDRESS(&NetAddress,
                                  Routes[i].addr,
                                  Routes[i].len);

        Status = RtmGetMostSpecificDestination(RtmRegHandle,
                                               &NetAddress,
                                               RTM_BEST_PROTOCOL,
                                               RTM_VIEW_MASK_UCAST,
                                               DestInfo1);

        // Check(Status, 19);

        if (DestInfo1->DestAddress.NumBits != NetAddress.NumBits)
        {
           ; // Print("No Exact Match : %5lu\n", j++);
        }

        while (SUCCESS(Status))
        {
            Status = RtmGetLessSpecificDestination(RtmRegHandle,
                                                   DestInfo1->DestHandle,
                                                   RTM_BEST_PROTOCOL,
                                                   RTM_VIEW_MASK_UCAST,
                                                   DestInfo2);

            // Check(Status, 20);

            Check(RtmReleaseDestInfo(RtmRegHandle, DestInfo1), 22);

            if (!SUCCESS(Status)) break;

            // Print("NumBits: %d\n", DestInfo2->DestAddress.NumBits);

            Status = RtmGetLessSpecificDestination(RtmRegHandle,
                                                   DestInfo2->DestHandle,
                                                   RTM_BEST_PROTOCOL,
                                                   RTM_VIEW_MASK_UCAST,
                                                   DestInfo1);

            // Check(Status, 20);

            Check(RtmReleaseDestInfo(RtmRegHandle, DestInfo2), 20);

            if (!SUCCESS(Status)) break;

            // Print("NumBits: %d\n", DestInfo1->DestAddress.NumBits);
        }
    }

#if DBG
    for (i = 0; i < 100000000; i++) { ; }
#endif


    //
    // Just do a "route enum" over the whole table
    //

    Status2 = RtmCreateRouteEnum(RtmRegHandle,
                                 NULL,
                                 0, // RTM_VIEW_MASK_UCAST|RTM_VIEW_MASK_MCAST,
                                 RTM_ENUM_OWN_ROUTES,
                                 NULL,
                                 0,
                                 NULL,
                                 0,
                                 &EnumHandle2);

    Check(Status2, 25);

    l = 0;

    do
    {
        NumHandles = MAX_HANDLES;

        Status2 = RtmGetEnumRoutes(RtmRegHandle,
                                   EnumHandle2,
                                   &NumHandles,
                                   Handles);

        // Check(Status2, 26);

        for (k = 0; k < NumHandles; k++)
        {
            ; // Print("Route %d: %p\n", l++, Handles[k]);
        }

        Check(RtmReleaseRoutes(RtmRegHandle,
                               NumHandles,
                               Handles),           27);
    }
    while (SUCCESS(Status2));

    //
    // Just try a enum query after ERROR_NO_MORE_ITEMS is retd
    //

    NumHandles = MAX_HANDLES;

    Status2 = RtmGetEnumRoutes(RtmRegHandle,
                               EnumHandle2,
                               &NumHandles,
                               Handles);

    Assert((NumHandles == 0) && (Status2 == ERROR_NO_MORE_ITEMS));

    Status2 = RtmDeleteEnumHandle(RtmRegHandle,
                                  EnumHandle2);

    Check(Status2, 16);

    //
    // Get dests from the table using an enumeration
    //    -23- Open a new dest enumeration
    //    -24- Get dests in enum
    //    -16- Close destination enum.
    //

    DestInfos = ALLOC_RTM_DEST_INFO(NumViews, MAX_HANDLES);

#if MCAST_ENUM

    RTM_IPV4_MAKE_NET_ADDRESS(&NetAddress,
                              0x000000E0,
                              4);

#else

    RTM_IPV4_MAKE_NET_ADDRESS(&NetAddress,
                              0x00000000,
                              0);

#endif

    Status = RtmCreateDestEnum(RtmRegHandle,
                               RTM_VIEW_MASK_UCAST | RTM_VIEW_MASK_MCAST,
                               RTM_ENUM_RANGE | RTM_ENUM_OWN_DESTS,
                               &NetAddress,
                               RTM_THIS_PROTOCOL,
                               &EnumHandle1);

    Check(Status, 23);

    m = j = 0;

    do
    {
        NumInfos = MAX_HANDLES;

        Status1 = RtmGetEnumDests(RtmRegHandle,
                                  EnumHandle1,
                                  &NumInfos,
                                  DestInfos);

        // Check(Status1, 24);

        for (i = 0; i < NumInfos; i++)
        {
            DestInfo1 = (PRTM_DEST_INFO) ((PUCHAR)DestInfos+(i*DestInfoSize));

            // Print("Dest %d: %p\n", j++, DestInfo1->DestHandle);

            // PrintDestInfo(DestInfo1);

            Status2 = RtmCreateRouteEnum(RtmRegHandle,
                                         DestInfo1->DestHandle,
                                         RTM_VIEW_MASK_UCAST |
                                         RTM_VIEW_MASK_MCAST,
                                         RTM_ENUM_OWN_ROUTES,
                                         NULL,
                                         0, // RTM_MATCH_INTERFACE,
                                         NULL,
                                         0,
                                         &EnumHandle2);

            Check(Status2, 25);
/*
            Check(RtmHoldDestination(RtmRegHandle,
                                     DestInfo1->DestHandle,
                                     RTM_VIEW_MASK_UCAST,
                                     100),  33);
*/
            l = 0;

            PrefInfo.Preference = (ULONG) ~0;
            PrefInfo.Metric = (ULONG) 0;

            do
            {
                NumHandles = MAX_HANDLES;

                Status2 = RtmGetEnumRoutes(RtmRegHandle,
                                           EnumHandle2,
                                           &NumHandles,
                                           Handles);

                // Check(Status2, 26);

                for (k = 0; k < NumHandles; k++)
                {
                    // Print("\tRoute %d: %p\t", l++, Handles[k]);

                    // PrintRouteInfo(Handles[k]);

                    Status = RtmIsBestRoute(RtmRegHandle,
                                            Handles[k],
                                            &ViewSet);

                    Check(Status, 28);

                    // Print("Best In Views: %08x\n", ViewSet);


                    Status = RtmGetRouteInfo(RtmRegHandle,
                                             Handles[k],
                                             &RouteInfo,
                                             &NetAddress);

                    Check(Status, 30);

                    Print("RouteDest: Len : %08x,"   \
                          " Addr = %3d.%3d.%3d.%3d," \
                          " Pref = %08x, %08x\n",
                               NetAddress.NumBits,
                               NetAddress.AddrBits[0],
                               NetAddress.AddrBits[1],
                               NetAddress.AddrBits[2],
                               NetAddress.AddrBits[3],
                               RouteInfo.PrefInfo.Preference,
                               RouteInfo.PrefInfo.Metric);

                    //
                    // Make sure that list is ordered by PrefInfo
                    //

                    if ((PrefInfo.Preference < RouteInfo.PrefInfo.Preference)||
                        ((PrefInfo.Preference == RouteInfo.PrefInfo.Preference)
                         && (PrefInfo.Metric > RouteInfo.PrefInfo.Metric)))
                    {
                        Check(ERROR_INVALID_DATA, 150);
                    }

                    Status = RtmReleaseRouteInfo(RtmRegHandle,
                                                 &RouteInfo);

                    Check(Status, 31);

                    // Print("Del Route %lu: %p\n", m++, Handles[k]);

                    Status = RtmDeleteRouteToDest(RtmRegHandle,
                                                  Handles[k],
                                                  &ChangeFlags);

                    Check(Status, 32);
                }

                Check(RtmReleaseRoutes(RtmRegHandle,
                                       NumHandles,
                                       Handles),           27);
            }
            while (SUCCESS(Status2));

            //
            // Just try a enum query after ERROR_NO_MORE_ITEMS is retd
            //

            NumHandles = MAX_HANDLES;

            Status2 = RtmGetEnumRoutes(RtmRegHandle,
                                       EnumHandle2,
                                       &NumHandles,
                                       Handles);

            Assert((NumHandles == 0) && (Status2 == ERROR_NO_MORE_ITEMS));
/*
            Check(RtmHoldDestination(RtmRegHandle,
                                     DestInfo1->DestHandle,
                                     RTM_VIEW_MASK_MCAST,
                                     100),  33);
*/
            Status2 = RtmDeleteEnumHandle(RtmRegHandle,
                                          EnumHandle2);

            Check(Status2, 16);

            // Check(RtmReleaseDestInfo(RtmRegHandle,
            //                          DestInfo1),           22);
        }

        Check(RtmReleaseDests(RtmRegHandle,
                              NumInfos,
                              DestInfos), 34);
    }
    while (SUCCESS(Status1));

    //
    // Just try a enum query after ERROR_NO_MORE_ITEMS is retd
    //

    NumInfos = MAX_HANDLES;

    Status1 = RtmGetEnumDests(RtmRegHandle,
                              EnumHandle1,
                              &NumInfos,
                              DestInfos);

    Assert((NumInfos == 0) && (Status1 == ERROR_NO_MORE_ITEMS));

    Status1 = RtmDeleteEnumHandle(RtmRegHandle,
                                  EnumHandle1);

    Check(Status1, 16);


    //
    // -10- Enumerate all the next-hops in table,
    //
    // -11- For each next-hop in table
    //      -12- Get the next hop info,
    //      -14- Delete the next-hop,
    //      -13- Release next hop info.
    //
    // -15- Release all the next-hops in table,
    //
    // -16- Close the next hop enumeration handle.
    //

    Status = RtmCreateNextHopEnum(RtmRegHandle,
                                  0,
                                  NULL,
                                  &EnumHandle);

    Check(Status, 10);

    j = 0;

    do
    {
        NumHandles = 5; // MAX_HANDLES;

        Status = RtmGetEnumNextHops(RtmRegHandle,
                                    EnumHandle,
                                    &NumHandles,
                                    Handles);

        // Check(Status, 11);

        for (i = 0; i < NumHandles; i++)
        {
            Check(RtmGetNextHopInfo(RtmRegHandle,
                                    Handles[i],
                                    &NextHopInfo), 12);

            // Print("Deleting NextHop %lu: %p\n", j++, Handles[i]);
            // Print("State: %04x, Interface: %d\n",
            //           NextHopInfo.State,
            //           NextHopInfo.InterfaceIndex);

            Check(RtmDeleteNextHop(RtmRegHandle,
                                       Handles[i],
                                       NULL),          14);

            Check(RtmReleaseNextHopInfo(RtmRegHandle,
                                        &NextHopInfo), 13);
        }

        Check(RtmReleaseNextHops(RtmRegHandle,
                                 NumHandles,
                                 Handles),         15);
    }
    while (SUCCESS(Status));

    //
    // Just try a enum query after ERROR_NO_MORE_ITEMS is retd
    //

    NumHandles = MAX_HANDLES;

    Status = RtmGetEnumNextHops(RtmRegHandle,
                                EnumHandle,
                                &NumHandles,
                                Handles);

    Assert((NumHandles == 0) && (Status == ERROR_NO_MORE_ITEMS));

    Status = RtmDeleteEnumHandle(RtmRegHandle,
                                 EnumHandle);

    Check(Status, 16);

    //
    // Make sure that the next hop table is empty now
    //

    Status = RtmCreateNextHopEnum(RtmRegHandle,
                                  0,
                                  NULL,
                                  &EnumHandle);

    NumHandles = MAX_HANDLES;

    Status = RtmGetEnumNextHops(RtmRegHandle,
                                EnumHandle,
                                &NumHandles,
                                Handles);


    if ((Status != ERROR_NO_MORE_ITEMS) || (NumHandles != 0))
    {
        Check(Status, 11);
    }

    Status = RtmDeleteEnumHandle(RtmRegHandle,
                                 EnumHandle);

    Check(Status, 16);

    Sleep(1000);

    //
    // -41- Deregister all existing change notif registrations
    //

    Status = RtmDeregisterFromChangeNotification(RtmRegHandle,
                                                 NotifyHandle);
    Check(Status, 41);

    Print("Change Notification Deregistration Successful\n\n");

    //
    // -02- De-register with the RTM before exiting
    //

    Status = RtmDeregisterEntity(RtmRegHandle);

    Check(Status, 2);

#if _DBG_
    Status = RtmDeregisterEntity(RtmRegHandle);

    Check(Status, 2);
#endif

    Print("\n--------------------------------------------------------\n");

    return NO_ERROR;
}


DWORD
EntityEventCallback (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_EVENT_TYPE                  EventType,
    IN      PVOID                           Context1,
    IN      PVOID                           Context2
    )
{
    RTM_ENTITY_HANDLE EntityHandle;
    PENTITY_CHARS     EntityChars;
    PRTM_ENTITY_INFO  EntityInfo;
    RTM_NOTIFY_HANDLE NotifyHandle;
    PRTM_DEST_INFO    DestInfos;
    UINT              NumDests;
    UINT              NumViews;
    RTM_ROUTE_HANDLE  RouteHandle;
    PRTM_ROUTE_INFO   RoutePointer;
    DWORD             ChangeFlags;
    DWORD             Status;

    Print("\nEvent callback called for %p :", RtmRegHandle);

    Status = NO_ERROR;

    Print("\n\tEntity Event = ");

    switch (EventType)
    {
    case RTM_ENTITY_REGISTERED:

        EntityHandle = (RTM_ENTITY_HANDLE) Context1;
        EntityInfo   = (PRTM_ENTITY_INFO)  Context2;

        Print("Registration\n\tEntity Handle = %p\n\tEntity IdInst = %p\n\n",
              EntityHandle,
              EntityInfo->EntityId);

/*
        //
        // -45- Make a copy of the handle of new entity
        //

        Status = RtmReferenceHandles(RtmRegHandle,
                                     1,
                                     &EntityHandle);

        Check(Status, 45);
*/
        break;

    case RTM_ENTITY_DEREGISTERED:

        EntityHandle = (RTM_ENTITY_HANDLE) Context1;
        EntityInfo   = (PRTM_ENTITY_INFO)  Context2;

        Print("Deregistration\n\tEntity Handle = %p\n\tEntity IdInst = %p\n\n",
               EntityHandle,
              EntityInfo->EntityId);

/*
        //
        // -44- Release the handle we have on the entity
        //

        Status = RtmReleaseEntities(RtmRegHandle,
                                    1,
                                    &EntityHandle);

        Check(Status, 44);
*/
        break;

    case RTM_CHANGE_NOTIFICATION:

        NotifyHandle = (RTM_NOTIFY_HANDLE) Context1;

        EntityChars  = (PENTITY_CHARS) Context2;

        Print("Changes Available\n\tNotify Handle = %p\n\tEntity Ch = %p\n\n",
              NotifyHandle,
              EntityChars);

        //
        // Count the number of view for later use
        //

        NumViews = EntityChars->RegnProfile.NumberOfViews;

        //
        // -43- Get all changes to destinations
        //

        DestInfos = ALLOC_RTM_DEST_INFO(NumViews, MAX_HANDLES);

        do
        {
            NumDests = MAX_HANDLES;

            Status = RtmGetChangedDests(RtmRegHandle,
                                        NotifyHandle,
                                        &NumDests,
                                        DestInfos);
            // Check(Status, 42);

            printf("Status = %lu\n", Status);

            Print("Num Changed Dests = %d\n", NumDests);

            EntityChars->TotalChangedDests += NumDests;

            Status = RtmReleaseChangedDests(RtmRegHandle,
                                            NotifyHandle,
                                            NumDests,
                                            DestInfos);
            Check(Status, 43);
        }
        while (NumDests > 0);

        Print("Total Changed Dests = %d\n", EntityChars->TotalChangedDests);

        break;

    case RTM_ROUTE_EXPIRED:

        RouteHandle = (RTM_ROUTE_HANDLE) Context1;

        RoutePointer = (PRTM_ROUTE_INFO) Context2;

        Print("Route Aged Out\n\tRoute Handle = %p\n\tRoute Pointer = %p\n\n",
               RouteHandle,
              RoutePointer);

        // Refresh the route by doing dummy update in place

        Status = RtmLockRoute(RtmRegHandle,
                              RouteHandle,
                              TRUE,
                              TRUE,
                              NULL);

        // Check(Status, 46);

        if (Status == NO_ERROR)
        {
            Status = RtmUpdateAndUnlockRoute(RtmRegHandle,
                                             RouteHandle,
                                             INFINITE,
                                             NULL,
                                             0,
                                             NULL,
                                             &ChangeFlags);

            Check(Status, 47);

            if (!SUCCESS(Status))
            {
                Status = RtmLockRoute(RtmRegHandle,
                                      RouteHandle,
                                      TRUE,
                                      FALSE,
                                      NULL);

                Check(Status, 46);
            }
        }

        Check(RtmReleaseRoutes(RtmRegHandle,
                               1,
                               &RouteHandle),           27);

        break;

    default:
        Status = ERROR_NOT_SUPPORTED;
    }

    return Status;
}

VOID
EntityExportMethod (
    IN  RTM_ENTITY_HANDLE         CallerHandle,
    IN  RTM_ENTITY_HANDLE         CalleeHandle,
    IN  RTM_ENTITY_METHOD_INPUT  *Input,
    OUT RTM_ENTITY_METHOD_OUTPUT *Output
    )
{
    Print("Export Function %2d called on %p: Caller = %p\n\n",
          Input->MethodType,
          CalleeHandle,
          CallerHandle);

    Output->MethodStatus = NO_ERROR;

    return;
}

// Default warnings for unreferenced params and local variables
#pragma warning(default: 4100)
#pragma warning(default: 4101)

#if _DBG_

00 RtmReadAddrFamilyConfig
00 RtmWriteAddrFamilyConfig
00 RtmWriteInstanceConfig

01 RtmRegisterEntity
02 RtmDeregisterEntity
03 RtmGetRegdEntities
04 RtmGetEntityMethods
05 RtmInvokeMethod
06 RtmBlockMethods
07 RtmAddNextHop
08 RtmFindNextHop
09 RtmLockNextHop
10 RtmCreateNextHopEnum
11 RtmGetEnumNextHops
12 RtmGetNextHopInfo
13 RtmReleaseNextHopInfo
14 RtmDelNextHop
15 RtmReleaseNextHops
16 RtmDeleteEnumHandle
17 RtmAddRouteToDest
18 RtmGetExactMatchDestination
19 RtmGetMostSpecificDestination
20 RtmGetLessSpecificDestination
21 RtmGetDestInfo
22 RtmReleaseDestInfo
23 RtmCreateDestEnum
24 RtmGetEnumDests
25 RtmCreateRouteEnum
26 RtmGetEnumRoutes
27 RtmReleaseRoutes
28 RtmIsBestRoute
29 RtmGetExactMatchRoute
30 RtmGetRouteInfo
31 RtmReleaseRouteInfo
32 RtmDelRoute
33 RtmHoldDestination
34 RtmReleaseDests
35 RtmCreateRouteList
36 RtmDeleteRouteList
37 RtmInsertInRouteList
38 RtmCreateRouteListEnum
39 RtmGetListEnumRoutes
40 RtmRegisterForChangeNotification
41 RtmDeregisterFromChangeNotification
42 RtmGetChangedDests
43 RtmReleaseChangedDests
44 RtmReleaseEntities
45 RtmReferenceHandles
46 RtmLockRoute
47 RtmUpdateAndUnlockRoute
48 RtmMarkDestForChangeNotification
49 RtmIsMarkedForChangeNotification

50 RtmCreateRouteTable
51 RtmDeleteRouteTable
52 RtmRegisterClient
53 RtmDeregisterClient
54 RtmAddRoute
55 RtmDeleteRoute
56 RtmCreateEnumerationHandle
57 RtmCloseEnumerationHandle
58 RtmEnumerateGetNextRoute
59 RtmGetFirstRoute
60 RtmGetNextRoute
61 RtmBlockDeleteRoutes
62 RtmBlockConvertRoutesToStatic
63 RtmGetNetworkCount
64 RtmIsRoute
65 RtmLookupIPDestination
66 RtmBlockSetRouteEnable

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\apitest.h ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    apitest.h

Abstract:
    Contains defines for testing the RTMv2 API.

Author:
    Chaitanya Kodeboyina (chaitk) 26-Aug-1998

Revision History:

--*/

#ifndef __APITEST_H
#define __APITEST_H

#include <winsock2.h>

#include <routprot.h>

#include "rtmv2.h"

#include "rtmcnfg.h"

#include "rtmmgmt.h"

#include "rtm.h"

#include "rmrtm.h"

//
// Constants
//

#define MAX_FNAME_LEN               255

#define MAX_LINE_LEN                255

#define BITSINBYTE                  8

#define ADDRSIZE                    32

#define NUMBYTES                    4

#define MAXLEVEL                    32

#define MAX_INSTANCES               10

#define MAX_ADDR_FAMS               10

#define MAX_ENTITIES                10

#define MAX_METHODS                 10

#define MAX_HANDLES                 25

#define MAX_ROUTES                  64000

#define ERROR_IPLMISC_BASE          -100

#define ERROR_WRONG_CMDUSAGE        ERROR_IPLMISC_BASE - 1
#define ERROR_OPENING_DATABASE      ERROR_IPLMISC_BASE - 2
#define ERROR_MAX_NUM_ROUTES        ERROR_IPLMISC_BASE - 3

//
// Structures
//

// Set of exported entity methods (a copy of one in rtmv2.h - but with const 7)
typedef struct _MY_ENTITY_EXPORT_METHODS 
{
  USHORT                   NumMethods;
  RTM_ENTITY_EXPORT_METHOD Methods[7];
} 
MY_ENTITY_EXPORT_METHODS, *PMY_ENTITY_EXPORT_METHODS;


// A structure that represents all entity properties
typedef struct _ENTITY_CHARS
{
    BOOL                            Rtmv2Registration;
    RTM_ENTITY_INFO                 EntityInformation;
    RTM_EVENT_CALLBACK              EventCallback;
    PMY_ENTITY_EXPORT_METHODS       ExportMethods;
    CHAR                            RoutesFileName[MAX_FNAME_LEN];

    RTM_REGN_PROFILE                RegnProfile;

    ULONGLONG                       TotalChangedDests;
}
ENTITY_CHARS, *PENTITY_CHARS;


//
// Useful Misc Macros
//

#define FHalf(B)        (B) >> 4
#define BHalf(B)        (B) & 0xF

#define Print           printf

#define Assert(S)       assert(S)

#define SUCCESS(S)      (S == NO_ERROR)

#define ErrorF(S, F, E)  { \
                            fprintf(stderr, S, F, E); \
                            DebugBreak();             \
                         }

#define FatalF(S, F, E)  { \
                            ErrorF(S, F, E);          \
                            exit(E);                  \
                         }

#define Check(E, F)     { \
                            if (!SUCCESS(E)) \
                            { \
                                FatalF("-%2d- failed with status %lu\n",F,E);\
                            } \
                        }

#define ClearMemory(pm, nb) memset((pm), 0, (nb))


//
// Profiling Macros
//

#if PROF

#define    PROFVARS     LARGE_INTEGER PCStart; /* PerformanceCountStart */ \
                        LARGE_INTEGER PCStop;  /* PerformanceCountStop  */ \
                        LARGE_INTEGER PCFreq;  /* PerformanceCountFreq  */ \
                        double        timer;                               \
                        double        duration;                            \
                                                                           \
                        QueryPerformanceFrequency(&PCFreq);                \
                        // Print("Perf Counter Resolution = %.3f ns\n\n",  \
                        //     (double) 1000 * 1000 * 1000 / PCFreq.QuadPart);

#define    STARTPROF    QueryPerformanceCounter(&PCStart);

#define    STOPPROF     QueryPerformanceCounter(&PCStop);

#define    INITPROF     duration = 0;


#define    ADDPROF      timer = (double)(PCStop.QuadPart - PCStart.QuadPart) \
                                     * 1000 * 1000 * 1000 / PCFreq.QuadPart; \
                        duration += timer;                                   \
                        // Print("Add : %.3f ns\n\n", timer);


#define    SUBPROF      timer = (double)(PCStop.QuadPart - PCStart.QuadPart) \
                                     * 1000 * 1000 * 1000 / PCFreq.QuadPart; \
                        duration -= timer;                                   \
                        // Print("Sub : %.3f ns\n\n", timer);

#define    PRINTPROF    // Print("Total Time Taken To Finish : %.3f ns\n",   \
                        //          duration);

#endif // if PROF


//
// Other Misc Macros
//

// Macro to allocate a RTM_DEST_INFO on the stack

#define ALLOC_RTM_DEST_INFO(NumViews, NumInfos)                              \
        (PRTM_DEST_INFO) _alloca(RTM_SIZE_OF_DEST_INFO(NumViews) * NumInfos)

//
// Prototypes
//

DWORD 
Rtmv1EntityThreadProc (
    IN      LPVOID                          ThreadParam
    );

DWORD
ValidateRouteCallback(
    IN      PVOID                           Route
    );

VOID 
RouteChangeCallback(
    IN      DWORD                           Flags, 
    IN      PVOID                           CurBestRoute, 
    IN      PVOID                           PrevBestRoute
    );

VOID
ConvertRouteToV1Route (
    IN      Route                         *ThisRoute, 
    OUT     RTM_IP_ROUTE                  *V1Route
    );

VOID
ConvertV1RouteToRoute (
    IN      RTM_IP_ROUTE                  *V1Route,
    OUT     Route                         *ThisRoute
    );

DWORD 
Rtmv2EntityThreadProc (
    IN      LPVOID                          ThreadParam
    );

DWORD
EntityEventCallback (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_EVENT_TYPE                  EventType,
    IN      PVOID                           Context1,
    IN      PVOID                           Context2
    );

VOID
EntityExportMethod (
    IN      RTM_ENTITY_HANDLE               CallerHandle,
    IN      RTM_ENTITY_HANDLE               CalleeHandle,
    IN      RTM_ENTITY_METHOD_INPUT        *Input,
    OUT     RTM_ENTITY_METHOD_OUTPUT       *Output
    );

#endif // __APITEST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtm\rtmtest.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\rtm\rtmdlg.c

Abstract:
	Interactive test code for RTM dll


Author:

	Vadim Eydelman

Revision History:

--*/


#ifndef NT_INCLUDED
#include <nt.h>
#endif

#ifndef _NTRTL_
#include <ntrtl.h>
#endif

#ifndef _NTURTL_
#include <nturtl.h>
#endif

#include <windows.h>

#ifndef _WINSOCKAPI_
#include <winsock.h>
#endif

#ifndef _WSIPX_
#include <wsipx.h>
#endif

#ifndef _WSNWLINK_
#include <wsnwlink.h>
#endif

#include <stdio.h>
#include <stdlib.h>

#ifndef _ROUTING_RTM_
#include "RTM.h"
#endif

#ifndef _ROUTING_RMRTM_
#include "RMRTM.h"
#endif


#include "cldlg.h"
#include "enumdlg.h"


#if DBG
#define ASSERTERR(exp) 										\
    if (!(exp)) {											\
		DbgPrint("Get last error= %d\n", GetLastError ());	\
        RtlAssert( #exp, __FILE__, __LINE__, NULL );		\
		}

#define ASSERTERRMSG(msg,exp)								\
    if (!(exp)) {											\
		DbgPrint("Get last error= %d\n", GetLastError ());	\
        RtlAssert( #exp, __FILE__, __LINE__, msg );			\
		}
#else
#define ASSERTERR(exp)
#define ASSERTERRMSG(msg,exp)
#endif

// Basic route info, present in routes of all types
typedef	struct {
		ROUTE_HEADER;
		} RTM_XX_ROUTE, *PRTM_XX_ROUTE;

typedef union _RTM_ROUTE {
	RTM_XX_ROUTE		XX;
	RTM_IP_ROUTE		IP;
	RTM_IPX_ROUTE		IPX;
	} RTM_ROUTE, *PRTM_ROUTE;

#define XX_INTERFACE	XX.RR_InterfaceID
#define XX_PROTOCOL		XX.RR_RoutingProtocol
#define XX_TIMESTAMP	XX.RR_TimeStamp

#define IP_PROTOCOL		IP.RR_RoutingProtocol
#define	IP_INTERFACE	IP.RR_InterfaceID
#define IP_METRIC		IP.RR_FamilySpecificData.FSD_Metric1
#define IP_TIMESTAMP	IP.RR_TimeStamp
#define IP_NET_NUM		IP.RR_Network.N_NetNumber
#define IP_NET_MSK		IP.RR_Network.N_NetMask
#define IP_NEXT_HOP_NUM	IP.RR_NextHopAddress.N_NetNumber
#define IP_NEXT_HOP_MSK	IP.RR_NextHopAddress.N_NetMask
#define IP_ADPTER_INDEX	IP.RR_FamilySpecificData.FSD_AdapterIndex
#define IP_PROTOCOL_METRIC IP.RR_FamilySpecificData.FSD_ProtocolMetric
#define IP_PSD			IP.RR_ProtocolSpecificData

#define IPX_PROTOCOL		IPX.RR_RoutingProtocol
#define	IPX_INTERFACE		IPX.RR_InterfaceID
#define IPX_METRIC			IPX.RR_FamilySpecificData.FSD_Ticks
#define IPX_TIMESTAMP		IPX.RR_TimeStamp
#define IPX_NET_NUM			IPX.RR_Network.N_NetNumber
#define IPX_NEXT_HOP_MAC	IPX.RR_NextHopAddress.NHA_Mac
#define IPX_HOP_COUNT		IPX.RR_FamilySpecificData.FSD_HopCount
#define IPX_PSD				IPX.RR_ProtocolSpecificData

typedef struct _ENABLE_DLG_GROUP_PARAM {
			HWND			hCtlFirst;
			BOOLEAN			foundFirst;
			BOOLEAN			enableFlag;
			} ENABLE_DLG_GROUP_PARAM, *PENABLE_DLG_GROUP_PARAM;

HANDLE		*Clients;
HANDLE		*Events;
HANDLE		hDLLInstance;
HANDLE		*InteractiveThreads;
HANDLE		*IPXRIPThreads;
SOCKET		*Sockets;
HANDLE		*Enums;

DWORD WINAPI
ClientThread (
	LPVOID param
	);
	
	
BOOL CALLBACK
ClientDlgProc (
    HWND  	hDlg,
    UINT  	uMsg,
    WPARAM  wParam,
    LPARAM  lParam
   	);

BOOL CALLBACK
DoEnable (
	HWND		hwnd,	// handle of child window
	LPARAM		lParam	// application-defined value
	);

VOID
EnableDlgGroup (
	HWND		hDlg,
	HWND		hCtlFirst,
	BOOLEAN		enable
	);

VOID
DoRegister (
	HWND			hDlg,
	LONG			idx
	);

VOID
DoDeregister (
	HWND			hDlg,
	LONG			idx
	);

VOID
SetupAdd (
	HWND		hDlg
	);

VOID
SetupDelete (
	HWND		hDlg
	);

VOID
SetupDequeue (
	HWND		hDlg
	);

VOID
SetupSetEnable (
	HWND		hDlg
	);

VOID
SetupConvert (
	HWND		hDlg
	);

VOID
DoOperation (
	HWND		hDlg,
	LONG		idx
	);

DWORD WINAPI
IPXRIPListenThread (
	LPVOID		param
	);

DWORD WINAPI
EnumThread (
	LPVOID param
	);
	
BOOL CALLBACK
EnumDlgProc (
    HWND  	hDlg,
    UINT  	uMsg,
    WPARAM  wParam,
    LPARAM  lParam
   	);
VOID
GetCriteria (
	HWND		hDlg,
	DWORD		*ProtocolFamily,
	DWORD		*flags,
	PRTM_ROUTE	Route
	);

VOID
GetLastRoute (
	HWND		hDlg,
	DWORD		ProtocolFamily,
	PRTM_ROUTE	Route
	);

VOID
DisplayRoute (
	HWND		hDlg,
	DWORD		ProtocolFamily,
	PRTM_ROUTE	Route
	);


INT
IPNetCmp (
	PVOID		Net1,
	PVOID		Net2
	) {
#define IPNet1 ((PIP_NETWORK)Net1)
#define IPNet2 ((PIP_NETWORK)Net2)
	if (IPNet1->N_NetNumber>IPNet2->N_NetNumber)
		return 1;
	else if (IPNet1->N_NetNumber<IPNet2->N_NetNumber)
		return -1;
	else if (IPNet1->N_NetMask==IPNet2->N_NetMask)
		return 0;
	else if (IPNet1->N_NetMask>IPNet2->N_NetMask)
		return 1;
	else /*if (IPNet1->N_NetMask<IPNet2->N_NetMask)*/
		return -1;

#undef IPNet2
#undef IPNet1
	}
INT
IPNhaCmp (
	PVOID		Route1,
	PVOID		Route2
	) {
#define IPRoute1 ((PRTM_ROUTE)Route1)
#define IPRoute2 ((PRTM_ROUTE)Route2)
	if (IPRoute1->IP_NET_NUM>IPRoute2->IP_NET_NUM)
		return 1;
	else if (IPRoute1->IP_NET_NUM<IPRoute2->IP_NET_NUM)
		return -1;
	else if (IPRoute1->IP_NET_MSK==IPRoute2->IP_NET_MSK)
		return 0;
	else if (IPRoute1->IP_NET_MSK>IPRoute2->IP_NET_MSK)
		return 1;
	else /*if (IPNet1->IP_NET_MSK<IPNet2->IP_NET_MSK)*/
		return -1;

#undef IPRoute2
#undef IPRoute1
	}

INT
IPMetricCmp (
	PVOID		Route1,
	PVOID		Route2
	) {
#define IPRoute1 ((PRTM_ROUTE)Route1)
#define IPRoute2 ((PRTM_ROUTE)Route2)
	if (IPRoute1->IP_METRIC>IPRoute2->IP_METRIC)
		return 1;
	else if (IPRoute1->IP_METRIC<IPRoute2->IP_METRIC)
		return -1;
	else
		return 0;
#undef IPRoute2
#undef IPRoute1
	}

BOOL
IPFsdCmp (
	PVOID		Route1,
	PVOID		Route2
	) {
#define IPRoute1 ((PRTM_ROUTE)Route1)
#define IPRoute2 ((PRTM_ROUTE)Route2)
	return memcmp (&IPRoute1->IP.RR_FamilySpecificData,
					&IPRoute2->IP.RR_FamilySpecificData,
					sizeof (IPRoute1->IP.RR_FamilySpecificData))==0;
#undef IPRoute2
#undef IPRoute1
	}

INT
IPHash (
	PVOID		Net
	) {
	return (*((PULONG)Net))%257;
	}

VOID
IPChange (
	DWORD		Flags,
	PVOID		CurBestRoute,
	PVOID		PrevBestRoute
	) {
	fprintf (stderr, "IPRouteChange: Flags=%d, CurBest: %08x, PrevBest: %08x\n",
					Flags, CurBestRoute, PrevBestRoute);
	}


INT
IPXNetCmp (
	PVOID		Net1,
	PVOID		Net2
	) {
#define IPXNet1 ((PIPX_NETWORK)Net1)
#define IPXNet2 ((PIPX_NETWORK)Net2)
	if (IPXNet1->N_NetNumber>IPXNet2->N_NetNumber)
		return 1;
	else if (IPXNet1->N_NetNumber<IPXNet2->N_NetNumber)
		return -1;
	else
		return 0;
#undef IPXNet2
#undef IPXNet1
	}

INT
IPXNhaCmp (
	PVOID		Route1,
	PVOID		Route2
	) {
#define IPXRoute1 ((PRTM_ROUTE)Route1)
#define IPXRoute2 ((PRTM_ROUTE)Route2)
	return memcmp (IPXRoute1->IPX_NEXT_HOP_MAC,
					IPXRoute2->IPX_NEXT_HOP_MAC,
					sizeof (IPXRoute1->IPX_NEXT_HOP_MAC));
#undef IPXRoute2
#undef IPXRoute1
	}

INT
IPXMetricCmp (
	PVOID		Route1,
	PVOID		Route2
	) {
#define IPXRoute1 ((PRTM_ROUTE)Route1)
#define IPXRoute2 ((PRTM_ROUTE)Route2)
	if (IPXRoute1->IPX_METRIC>IPXRoute2->IPX_METRIC)
		return 1;
	else if (IPXRoute1->IPX_METRIC<IPXRoute2->IPX_METRIC)
		return -1;
	else
		return 0;
#undef IPXRoute2
#undef IPXRoute1
	}

BOOL
IPXFsdCmp (
	PVOID		Route1,
	PVOID		Route2
	) {
#define IPXRoute1 ((PRTM_ROUTE)Route1)
#define IPXRoute2 ((PRTM_ROUTE)Route2)
	return IPXRoute1->IPX_HOP_COUNT==IPXRoute1->IPX_HOP_COUNT;
#undef IPXRoute2
#undef IPXRoute1
	}
INT
IPXHash (
	PVOID		Net
	) {
	return (*((PULONG)Net))%257;
	}

VOID
IPXChange (
	DWORD		Flags,
	PVOID		CurBestRoute,
	PVOID		PrevBestRoute
	) {
	fprintf (stderr, "IPXRouteChange: Flags=%d, CurBest: %08x, PrevBest: %08x\n",
					Flags, CurBestRoute, PrevBestRoute);
	}

DWORD
Validate (
	PVOID	Route
	) {
	return NO_ERROR;
	}

int _cdecl
main (
	int argc,
	char **argv
	) {
	INT				i, n, m, p;
	INT				id;
	DWORD			status;
static RTM_PROTOCOL_FAMILY_CONFIG IPXConfig = {
							8*1024*1024,
							257,
							sizeof (RTM_IPX_ROUTE),
							IPXNetCmp,
							IPXNhaCmp,
							IPXMetricCmp,
							IPXFsdCmp,
							IPHash,
							Validate,
							IPXChange };
static RTM_PROTOCOL_FAMILY_CONFIG IPConfig = {
							8*1024*1024,
							257,
							sizeof (RTM_IP_ROUTE),
							IPNetCmp,
							IPNhaCmp,
							IPXMetricCmp,
							IPFsdCmp,
							IPHash,
							Validate,
							IPChange };
	status = RtmCreateRouteTable (RTM_PROTOCOL_FAMILY_IPX,
							&IPXConfig);
	ASSERTMSG ("Could not create IPX Route Table ", status == NO_ERROR);

	status = RtmCreateRouteTable (RTM_PROTOCOL_FAMILY_IP,
							&IPConfig);


	ASSERTMSG ("Could not create IPX Route Table ", status == NO_ERROR);
	if (argc>=4) {
		n = atoi (argv[1]);
		p = atoi (argv[2]);
		m = atoi (argv[3]);

		Clients = (HANDLE *)GlobalAlloc (GMEM_FIXED, n*sizeof (HANDLE));
		ASSERTERR (Clients!=NULL);

		Events = (HANDLE *)GlobalAlloc (GMEM_FIXED, n*sizeof (HANDLE));
		ASSERTERR (Events!=NULL);

		Enums = (HANDLE *)GlobalAlloc (GMEM_FIXED, p*sizeof (HANDLE));
		ASSERTERR (Events!=NULL);

		InteractiveThreads = (HANDLE *)GlobalAlloc (GMEM_FIXED, (n+p)*sizeof (HANDLE));
		ASSERTERR (InteractiveThreads!=NULL);

		hDLLInstance = LoadLibrary ("rtm.dll");
		ASSERTERR (hDLLInstance!=NULL);

		if (m>0) {
			INT		m1;
			WORD			wVersionRequested;
			WSADATA			wsaData;
			INT				err, length;
			SOCKADDR_IPX	addr;
			SOCKET			s;
			IPX_ADDRESS_DATA adptData;
			BOOL			flag;

			wVersionRequested = MAKEWORD( 1, 1 );
			err = WSAStartup( wVersionRequested, &wsaData );
			ASSERT (err==NO_ERROR);

			s = socket (AF_IPX, SOCK_DGRAM, NSPROTO_IPX);
			ASSERTERR (s!=INVALID_SOCKET);

			memset (&addr, 0, sizeof (addr));
			addr.sa_family = AF_IPX;
			status = bind (s, (PSOCKADDR)&addr, sizeof (addr));
			ASSERTERRMSG ("Can't bind to default address.\n", status==0);
		
			// Get number of available adapters
			length = sizeof (INT);
			status = getsockopt (s,
					NSPROTO_IPX,
					IPX_MAX_ADAPTER_NUM,
					(PUCHAR)&m1,
					&length);
			ASSERTERRMSG ("Can't get number of adapters.", status==0);
			ASSERTMSG ("No adapters available", m1>0);
			if (m>m1)
				m = m1;

			IPXRIPThreads = (HANDLE *)GlobalAlloc (GMEM_FIXED, m*sizeof(HANDLE));
			ASSERTERR (IPXRIPThreads!=NULL);

			Sockets = (SOCKET *)GlobalAlloc (GMEM_FIXED, m*sizeof (SOCKET));
			ASSERTERR (Sockets!=NULL);

			for (i=0; i<m; i++) {
				Sockets[i] = socket (AF_IPX, SOCK_DGRAM, NSPROTO_IPX);
				ASSERTERR (Sockets[i]!=INVALID_SOCKET);

				flag = TRUE;
				status = setsockopt (Sockets[i],
									SOL_SOCKET,
									SO_BROADCAST,
									(PCHAR)&flag,
									sizeof (BOOL));
				ASSERTERRMSG ("Can't set socket broadcast option.", status==0);

				flag = TRUE;
				status = setsockopt (Sockets[i],
									NSPROTO_IPX,
									IPX_RECEIVE_BROADCAST,
									(PCHAR)&flag,
									sizeof (BOOL));
				ASSERTERRMSG ("Can't set IPX broadcast option.", status==0);

				flag = TRUE;
				status = setsockopt (Sockets[i],
									NSPROTO_IPX,
									IPX_RECVHDR,
									(PCHAR)&flag,
									sizeof (BOOL));
				ASSERTERRMSG ("Can't set receive header option.", status==0);

				length = sizeof (adptData);
				adptData.adapternum = i;
				status = getsockopt (s,
									NSPROTO_IPX,
									IPX_ADDRESS,
									(PCHAR)&adptData,
									&length);
				ASSERTERRMSG ("Can't get adapter parameters.", status==0);

				memcpy (&addr.sa_netnum, &adptData.netnum, sizeof (addr.sa_netnum));
				fprintf (stderr,
					 "IPX RIP Listener # %d: Net=%02x%02x%02x%02x\n",
					 i, (UCHAR)addr.sa_netnum[0],
					 	(UCHAR)addr.sa_netnum[1],
					 	(UCHAR)addr.sa_netnum[2],
					 	(UCHAR)addr.sa_netnum[3]); 
				memcpy (&addr.sa_nodenum, &adptData.nodenum, sizeof (addr.sa_nodenum));
				fprintf (stderr,
					 "IPX RIP Listener # %d: Node=%02x%02x%02x%02x%02x%02x\n",
					 i, (UCHAR)addr.sa_nodenum[0],
					 	(UCHAR)addr.sa_nodenum[1],
					 	(UCHAR)addr.sa_nodenum[2],
					 	(UCHAR)addr.sa_nodenum[3],
					 	(UCHAR)addr.sa_nodenum[4],
					 	(UCHAR)addr.sa_nodenum[5]); 

				addr.sa_family = AF_IPX;
				addr.sa_socket = htons (0x452);

				status = bind (Sockets[i], (PSOCKADDR)&addr, sizeof(addr));
				ASSERTERRMSG ("Can't bind to adapter's address.", status==0);

				IPXRIPThreads[i] = CreateThread (NULL,
												0,
												&IPXRIPListenThread,
												(LPVOID)i,
												0,
												&id);
				ASSERTERR (IPXRIPThreads[i]!=NULL);
				}
			closesocket (s);			
			}

		for (i=0; i<n; i++) {
			InteractiveThreads[i] = CreateThread (NULL,
												 0,
												 &ClientThread, 
												 (LPVOID)i, 
												 0, 
												 &id);
			ASSERTERR (InteractiveThreads[i]!=NULL);
			}

		for (i=0; i<p ; i++) {
			InteractiveThreads[n+i] = CreateThread (NULL,
												 0,
												 &EnumThread, 
												 (LPVOID)i, 
												 0, 
												 &id);
			ASSERTERR (InteractiveThreads[n+i]!=NULL);
			}


		WaitForMultipleObjects (n+p, InteractiveThreads, TRUE, INFINITE);
		if (m>0) {
			for (i=0; i<m; i++)
				closesocket (Sockets[i]);
			status = WaitForMultipleObjects (m, IPXRIPThreads, TRUE, 5*1000);
			if (status==WAIT_TIMEOUT) {
				for (i=0; i<m; i++)
					TerminateThread (IPXRIPThreads[i], 0);
				}
			for (i=0; i<m; i++)
				CloseHandle (IPXRIPThreads[i]);

			}

		for (i=0; i<=n; i++)
			CloseHandle (InteractiveThreads[i]);
		FreeLibrary (hDLLInstance);
		WSACleanup ();
		}
	else 
		fprintf (stderr,
			 "Usage: %s <n_of_clients> <n_of_enumerators> <max_rip_listeners>\n",
			 argv[0]);

	RtmDeleteRouteTable (RTM_PROTOCOL_FAMILY_IP);
	RtmDeleteRouteTable (RTM_PROTOCOL_FAMILY_IPX);
	return 0;
	}

#define idx ((LONG)param)
DWORD WINAPI
ClientThread (
	LPVOID param
	) {
	MSG				msg;
	DWORD			status;
	HWND			ClientDlg;
	char			buf[16];
	BOOLEAN			done = FALSE;
	
	Clients[idx] = NULL;

	Events[idx] = CreateEvent (NULL, FALSE, FALSE, NULL);
	ASSERTERR (Events[idx]!=NULL);

		// Create dialog window
	ClientDlg = CreateDialogParam (hDLLInstance,
				MAKEINTRESOURCE(IDD_RTM_CLIENT),
				NULL,
				&ClientDlgProc,
				(LPARAM)idx);
	ASSERTERR (ClientDlg!=NULL);

	sprintf (buf, "Client # %d", idx+1);
	SetWindowText (ClientDlg, buf);

	while (!done) {
		status = MsgWaitForMultipleObjects (
					1,
					&Events[idx],
					FALSE,
					1000,
					QS_ALLINPUT
					);

		ASSERTERR (status!=0xFFFFFFFF);
		if (status==WAIT_OBJECT_0) {
			if (IsWindow (ClientDlg) && (Clients[idx]!=NULL))
				EnableWindow (GetDlgItem (ClientDlg, IDR_DEQUEUE_C), TRUE);
			else
				ASSERTMSG ("Event signalled to dead client or closed window ", FALSE);
			}
		while (PeekMessage (&msg,  NULL, 0, 0, PM_REMOVE)) {
			if (msg.message!=WM_QUIT) {
				if (!IsWindow(ClientDlg)
					|| !IsDialogMessage(ClientDlg, &msg)) {
					TranslateMessage (&msg);
					DispatchMessage (&msg);
					}
				}
			else
				done = TRUE;
			}
		}

	if (IsWindow (ClientDlg)) {
		DestroyWindow (ClientDlg);
		ClientDlg = NULL;
		}
	CloseHandle (Events[idx]);

	return msg.wParam;
	}
#undef idx	


BOOL CALLBACK
ClientDlgProc (
    HWND  	hDlg,
    UINT  	uMsg,
    WPARAM  wParam,
    LPARAM  lParam
   	) {
	BOOL		res = FALSE;
	LONG		idx;

	idx = GetWindowLong (hDlg, DWL_USER)-1;

	switch (uMsg) {
		case WM_INITDIALOG:		// Dialog is being created
			idx = lParam+1;
			SetWindowLong (hDlg, DWL_USER, idx);
			ASSERTERR (GetLastError ()==NO_ERROR);
			EnableDlgGroup (hDlg, GetDlgItem (hDlg, IDG_CLIENT_OPERATION_C), FALSE);
			EnableDlgGroup (hDlg, GetDlgItem (hDlg, IDG_REQUEST_C), FALSE);
			SendDlgItemMessage (hDlg,
							IDC_PROTOCOL_FAMILY_C,
							CB_INSERTSTRING,
							RTM_PROTOCOL_FAMILY_IPX,
							(LPARAM)"IPX"
							);

			SendDlgItemMessage (hDlg,
							IDC_PROTOCOL_FAMILY_C,
							CB_INSERTSTRING,
							RTM_PROTOCOL_FAMILY_IP,
							(LPARAM)"IP"
							);

			SendDlgItemMessage (hDlg,
							IDC_PROTOCOL_FAMILY_C,
							CB_SETCURSEL,
							0,
							0
							);
			SetDlgItemText (hDlg, IDB_REGISTER_OP_C, "Register");

			res = TRUE;
			break;

		case WM_COMMAND:		// Process child window messages only
			switch (LOWORD(wParam)) {
				case IDCANCEL:
					PostQuitMessage (0);
					res = TRUE;
					break;
				case IDB_REGISTER_OP_C:
					if (Clients[idx]==NULL)
						DoRegister (hDlg, idx);
					else
						DoDeregister (hDlg, idx);
					res = TRUE;
					break;
				case IDR_ADD_C:
					SetupAdd (hDlg);
					res = TRUE;
					break;
				case IDR_DELETE_C:
					SetupDelete (hDlg);
					res = TRUE;
					break;
				case IDR_DEQUEUE_C:
					if (GetDlgItemInt (hDlg, IDE_ROUTING_PROTOCOL_C,
								 NULL, FALSE)!=0)
						SetupDequeue (hDlg);
					else
						SetupConvert (hDlg);
					res = TRUE;
					break;
				case IDR_DISABLE_C:
				case IDR_ENABLE_C:
					SetupSetEnable (hDlg);
					res = TRUE;
					break;
				case IDB_DO_IT_C:
					DoOperation (hDlg, idx);
					res = TRUE;
					break;
				}
			break;
		case WM_DESTROY:
			if (Clients[idx]!=NULL) {
				if (RtmDeregisterClient (Clients[idx])!=NO_ERROR)
					MessageBox (hDlg, "Deregister failed!", NULL, MB_OK|MB_ICONSTOP);

				Clients[idx] = NULL;
				}
			break;
		}

	return res;
	}



VOID
DoRegister (
	HWND			hDlg,
	LONG			idx
	) {
	DWORD	ProtocolFamily;
	DWORD	RoutingProtocol;

	ProtocolFamily = SendDlgItemMessage (hDlg, IDC_PROTOCOL_FAMILY_C,
										CB_GETCURSEL, 0, 0);
	RoutingProtocol = GetDlgItemInt (hDlg, IDE_ROUTING_PROTOCOL_C, NULL, FALSE);
	SetDlgItemInt (hDlg, IDE_ROUTING_PROTOCOL_C, RoutingProtocol, FALSE);
	Clients[idx] = RtmRegisterClient (ProtocolFamily, 
									RoutingProtocol,
									(RoutingProtocol!=0)
										? Events[idx]
										: NULL,
									(RoutingProtocol!=0)
										? 0
										: RTM_PROTOCOL_SINGLE_ROUTE);
	if (Clients[idx]!=NULL) {
		RECT	rectScr, rectDlg;

		EnableWindow (GetDlgItem (hDlg, IDC_PROTOCOL_FAMILY_C), FALSE);
		EnableWindow (GetDlgItem (hDlg, IDE_ROUTING_PROTOCOL_C), FALSE);
		SetDlgItemText (hDlg, IDB_REGISTER_OP_C, "Deregister");
		EnableDlgGroup (hDlg, GetDlgItem (hDlg, IDG_REQUEST_C), TRUE);
		if (RoutingProtocol!=0) {
			SetDlgItemText (hDlg, IDR_DEQUEUE_C, "Dequeue");
			EnableWindow (GetDlgItem (hDlg, IDR_DEQUEUE_C), FALSE);
			}
		else
			SetDlgItemText (hDlg, IDR_DEQUEUE_C, "Convert");

		GetWindowRect (GetDlgItem (hDlg, IDE_NET_NUMBER_C), &rectScr);
		MapWindowPoints (HWND_DESKTOP, hDlg, (LPPOINT)&rectScr, 2);
				rectDlg.left = rectDlg.top = rectDlg.bottom = 0;
		switch (ProtocolFamily) {
			case RTM_PROTOCOL_FAMILY_IPX:
				rectDlg.right = 8*4+5;
				break;
			case RTM_PROTOCOL_FAMILY_IP:
				rectDlg.right = 16*4+5;
				break;
			}
		MapDialogRect (hDlg, &rectDlg);
		MoveWindow (GetDlgItem (hDlg, IDE_NET_NUMBER_C),
					rectScr.left,
					rectScr.top,
					rectDlg.right,
					rectScr.bottom-rectScr.top,
					TRUE);

		GetWindowRect (GetDlgItem (hDlg, IDE_NEXT_HOP_C), &rectScr);
		MapWindowPoints (HWND_DESKTOP, hDlg, (LPPOINT)&rectScr, 2);
				rectDlg.left = rectDlg.top = rectDlg.bottom = 0;
		switch (ProtocolFamily) {
			case RTM_PROTOCOL_FAMILY_IPX:
				rectDlg.right = 12*4+5;
				break;
			case RTM_PROTOCOL_FAMILY_IP:
				rectDlg.right = 16*4+5;
				break;
			}
		MapDialogRect (hDlg, &rectDlg);
		MoveWindow (GetDlgItem (hDlg, IDE_NEXT_HOP_C),
					rectScr.left,
					rectScr.top,
					rectDlg.right,
					rectScr.bottom-rectScr.top,
					TRUE);
		SendDlgItemMessage (hDlg, IDR_ADD_C, BM_SETCHECK, (WPARAM)1, 0);
		SetupAdd (hDlg);
		}
	else
		MessageBox (hDlg, "Registration failed!", NULL, MB_OK|MB_ICONSTOP);
	}


VOID
DoDeregister (
	HWND			hDlg,
	LONG			idx
	) {

	if (RtmDeregisterClient (Clients[idx])!=NO_ERROR)
		MessageBox (hDlg, "Deregister failed!", NULL, MB_OK|MB_ICONSTOP);

	Clients[idx] = NULL;
	ResetEvent (Events[idx]);

	EnableWindow (GetDlgItem (hDlg, IDC_PROTOCOL_FAMILY_C), TRUE);
	EnableWindow (GetDlgItem (hDlg, IDE_ROUTING_PROTOCOL_C), TRUE);
	SetDlgItemText (hDlg, IDB_REGISTER_OP_C, "Register");
	EnableDlgGroup (hDlg, GetDlgItem (hDlg, IDG_CLIENT_OPERATION_C), FALSE);
	EnableDlgGroup (hDlg, GetDlgItem (hDlg, IDG_REQUEST_C), FALSE);
	}

VOID
SetupAdd (
	HWND		hDlg
	) {
	EnableDlgGroup (hDlg, GetDlgItem (hDlg, IDG_CLIENT_OPERATION_C), TRUE);
	EnableWindow (GetDlgItem (hDlg, IDB_DO_IT_C), TRUE);
	}

VOID
SetupDelete (
	HWND		hDlg
	) {
	EnableDlgGroup (hDlg, GetDlgItem (hDlg, IDG_CLIENT_OPERATION_C), TRUE);
	EnableWindow (GetDlgItem (hDlg, IDE_METRIC_C), FALSE);
	EnableWindow (GetDlgItem (hDlg, IDE_TIMEOUT_C), FALSE);
	EnableWindow (GetDlgItem (hDlg, IDB_DO_IT_C), TRUE);
	}

VOID
SetupDequeue (
	HWND		hDlg
	) {
	EnableDlgGroup (hDlg, GetDlgItem (hDlg, IDG_CLIENT_OPERATION_C), TRUE);
	EnableWindow (GetDlgItem (hDlg, IDE_NET_NUMBER_C), FALSE);
	EnableWindow (GetDlgItem (hDlg, IDE_NEXT_HOP_C), FALSE);
	EnableWindow (GetDlgItem (hDlg, IDE_INTERFACE_C), FALSE);
	EnableWindow (GetDlgItem (hDlg, IDE_METRIC_C), FALSE);
	EnableWindow (GetDlgItem (hDlg, IDE_TIMEOUT_C), FALSE);
	EnableWindow (GetDlgItem (hDlg, IDB_DO_IT_C), TRUE);
	}

VOID
SetupSetEnable (
	HWND		hDlg
	) {
	EnableDlgGroup (hDlg, GetDlgItem (hDlg, IDG_CLIENT_OPERATION_C), TRUE);
	EnableWindow (GetDlgItem (hDlg, IDE_NET_NUMBER_C), FALSE);
	EnableWindow (GetDlgItem (hDlg, IDE_NEXT_HOP_C), FALSE);
	EnableWindow (GetDlgItem (hDlg, IDE_INTERFACE_C), TRUE);
	EnableWindow (GetDlgItem (hDlg, IDE_METRIC_C), FALSE);
	EnableWindow (GetDlgItem (hDlg, IDE_TIMEOUT_C), FALSE);
	EnableWindow (GetDlgItem (hDlg, IDB_DO_IT_C), TRUE);
	}

VOID
SetupConvert (
	HWND		hDlg
	) {
	EnableDlgGroup (hDlg, GetDlgItem (hDlg, IDG_CLIENT_OPERATION_C), TRUE);
	EnableWindow (GetDlgItem (hDlg, IDE_NET_NUMBER_C), FALSE);
	EnableWindow (GetDlgItem (hDlg, IDE_NEXT_HOP_C), FALSE);
	EnableWindow (GetDlgItem (hDlg, IDE_INTERFACE_C), TRUE);
	EnableWindow (GetDlgItem (hDlg, IDE_METRIC_C), FALSE);
	EnableWindow (GetDlgItem (hDlg, IDE_TIMEOUT_C), FALSE);
	EnableWindow (GetDlgItem (hDlg, IDB_DO_IT_C), TRUE);
	}

VOID
DoOperation (
	HWND		hDlg,
	LONG		idx
	) {
	char						buf[32];
	LONG						TimeToLive;
	RTM_ROUTE					Route;
	DWORD						status;
	DWORD						ProtocolFamily;
	INT							i,n,val;
	DWORD						Flags;
	char						*p;
		
	memset (&Route, 0 , sizeof (RTM_ROUTE));
	ProtocolFamily = SendDlgItemMessage (hDlg, IDC_PROTOCOL_FAMILY_C,
										CB_GETCURSEL, 0, 0);

	if (IsDlgButtonChecked (hDlg, IDR_ADD_C)
		|| IsDlgButtonChecked (hDlg, IDR_DELETE_C)) {
		Route.XX_PROTOCOL 
			= GetDlgItemInt (hDlg, IDE_ROUTING_PROTOCOL_C, NULL, FALSE);

		
		GetDlgItemText (hDlg, IDE_NET_NUMBER_C, buf, sizeof (buf)-1);
		p = buf;
		switch (ProtocolFamily) {
			case RTM_PROTOCOL_FAMILY_IPX:
				if (sscanf (p, "%8X%n", &val, &n)==1)
					Route.IPX_NET_NUM = val;
				else
					Route.IPX_NET_NUM = 0;
    			p += n;
				break;
			case RTM_PROTOCOL_FAMILY_IP:
				if (sscanf (p, "%8X%n", &val, &n)==1)
					Route.IP_NET_NUM = val;
				else
					Route.IP_NET_NUM = 0;
    			p += n;
				if (sscanf (p, "%8X%n", &val, &n)==1)
					Route.IP_NET_MSK = val;
				else
					Route.IP_NET_MSK = 0;
    			p += n;
				break;
			}

		GetDlgItemText (hDlg, IDE_NEXT_HOP_C, buf, sizeof (buf)-1);
		p = buf;
		switch (ProtocolFamily) {
			case RTM_PROTOCOL_FAMILY_IPX:
				for (i=0; i<sizeof(Route.IPX_NEXT_HOP_MAC); i++, p+=n) {
					if (sscanf (p, "%2X%n", &val, &n)==1)
						Route.IPX_NEXT_HOP_MAC[i] = (BYTE)val;
					else
						Route.IPX_NEXT_HOP_MAC[i] = 0;
					}
				break;
			case RTM_PROTOCOL_FAMILY_IP:
				if (sscanf (p, "%8X%n", &val, &n)==1)
					Route.IP_NEXT_HOP_NUM = val;
				else
					Route.IP_NEXT_HOP_NUM = 0;
    			p += n;
				if (sscanf (p, "%8X%n", &val, &n)==1)
					Route.IP_NEXT_HOP_MSK = val;
				else
					Route.IP_NEXT_HOP_MSK = 0;
    			p += n;
				break;
			}

		Route.XX_INTERFACE
			 = GetDlgItemInt (hDlg, IDE_INTERFACE_C, NULL, FALSE);

		if (IsDlgButtonChecked (hDlg, IDR_ADD_C)) {
			switch (ProtocolFamily) {
				case RTM_PROTOCOL_FAMILY_IPX:
					Route.IPX_METRIC = (USHORT)GetDlgItemInt 
								(hDlg, IDE_METRIC_C, NULL, FALSE);
					break;
				case RTM_PROTOCOL_FAMILY_IP:
					Route.IP_METRIC = (USHORT)GetDlgItemInt 
								(hDlg, IDE_METRIC_C, NULL, FALSE);
					break;
				}


			TimeToLive = GetDlgItemInt (hDlg, IDE_TIMEOUT_C, NULL, FALSE);
			SetDlgItemInt (hDlg, IDE_TIMEOUT_C, TimeToLive, FALSE);
			GetDlgItemText (hDlg, IDR_ADD_C, buf, sizeof (buf)-1);
			status = RtmAddRoute (Clients[idx], &Route,
						TimeToLive,
						&Flags, NULL, NULL);
				
			}
		else {
			status = RtmDeleteRoute (Clients[idx], &Route,
									&Flags, NULL);
			SetDlgItemText (hDlg, IDE_TIMEOUT_C, "");
			}
		if (status!=NO_ERROR) {
			sprintf (buf, "Rtm returned error: %ld", status);
			MessageBox (hDlg, buf, "Error", MB_OK|MB_ICONEXCLAMATION);
			}
		SetDlgItemText (hDlg, IDL_ROUTING_PROTOCOL_C, "");
		}
	else if (IsDlgButtonChecked (hDlg, IDR_DEQUEUE_C)) {
		RTM_ROUTE	Route1;
		Route.XX_PROTOCOL
			 = GetDlgItemInt (hDlg, IDE_ROUTING_PROTOCOL_C, NULL, FALSE);
		
		if (Route.XX_PROTOCOL!=0) {
			status = RtmDequeueRouteChangeMessage (Clients[idx],
													&Flags,
													&Route,
													&Route1);
			if (status==NO_ERROR) {
				SendDlgItemMessage (hDlg, IDR_DEQUEUE_C, BM_SETCHECK, (WPARAM)0, 0);
				EnableWindow (GetDlgItem (hDlg, IDR_DEQUEUE_C), FALSE);
				EnableWindow (GetDlgItem (hDlg, IDB_DO_IT_C), FALSE);
				}
			else if (status!=ERROR_MORE_MESSAGES) {
				sprintf (buf, "Rtm returned error: %ld", status);
				MessageBox (hDlg, buf, "Error", MB_OK|MB_ICONEXCLAMATION);
				}
			if (!(Flags & RTM_CURRENT_BEST_ROUTE))
				memcpy (&Route, &Route1, sizeof (Route));
			SetDlgItemInt (hDlg, IDL_ROUTING_PROTOCOL_C, (UINT)Route.XX_PROTOCOL, FALSE);
			SetDlgItemText (hDlg, IDE_TIMEOUT_C, "");
			}
		else {
			Route.XX_INTERFACE
				 = GetDlgItemInt (hDlg, IDE_INTERFACE_C, NULL, FALSE);
			status = RtmBlockConvertRoutesToStatic (
						Clients[idx],
						RTM_ONLY_THIS_INTERFACE,
						&Route);
			goto OpDone;
			}
		}
	else if (IsDlgButtonChecked (hDlg, IDR_DISABLE_C)
				|| IsDlgButtonChecked (hDlg, IDR_ENABLE_C)) {
		Route.XX_PROTOCOL
			 = GetDlgItemInt (hDlg, IDE_ROUTING_PROTOCOL_C, NULL, FALSE);
		Route.XX_INTERFACE 
			= GetDlgItemInt (hDlg, IDE_INTERFACE_C, NULL, FALSE);
		status = RtmBlockSetRouteEnable (Clients[idx],
											RTM_ONLY_THIS_INTERFACE,
											&Route,
							IsDlgButtonChecked (hDlg, IDR_ENABLE_C));
		goto OpDone;
		}

	SetDlgItemInt (hDlg, IDL_MESSAGE_FLAGS_C, (UINT)Flags, FALSE);
	SetDlgItemInt (hDlg, IDE_INTERFACE_C, (UINT)Route.XX_INTERFACE, FALSE);

	switch (ProtocolFamily) {
		case RTM_PROTOCOL_FAMILY_IPX:
			sprintf (buf,
					"%08X",
					Route.IPX_NET_NUM);
			SetDlgItemInt (hDlg, IDE_METRIC_C, (UINT)Route.IPX_METRIC, FALSE);
			break;
		case RTM_PROTOCOL_FAMILY_IP:
			sprintf (buf,
					"%08X%08X",
					Route.IP_NET_NUM,
					Route.IP_NET_MSK);
			SetDlgItemInt (hDlg, IDE_METRIC_C, (UINT)Route.IP_METRIC, FALSE);
			break;
		}
	SetDlgItemText (hDlg, IDE_NET_NUMBER_C, buf);

	switch (ProtocolFamily) {
		case RTM_PROTOCOL_FAMILY_IPX:
			sprintf (buf,
					"%02X%02X%02X%02X%02X%02X",
					Route.IPX_NEXT_HOP_MAC[0],
					Route.IPX_NEXT_HOP_MAC[1],
					Route.IPX_NEXT_HOP_MAC[2],
					Route.IPX_NEXT_HOP_MAC[3],
					Route.IPX_NEXT_HOP_MAC[4],
					Route.IPX_NEXT_HOP_MAC[5]);
			break;
		case RTM_PROTOCOL_FAMILY_IP:
			sprintf (buf,
					"%08X%08X",
					Route.IP_NEXT_HOP_NUM,
					Route.IP_NEXT_HOP_MSK);
			break;
		}

	SetDlgItemText (hDlg, IDE_NEXT_HOP_C, buf);
OpDone:
	;
	}


#define pParam ((PENABLE_DLG_GROUP_PARAM)lParam)
BOOL CALLBACK
DoEnable (
	HWND		hwnd,	// handle of child window
	LPARAM		lParam	// application-defined value
	) {
	if (!pParam->foundFirst) {
		if (pParam->hCtlFirst != hwnd)
			return TRUE;
		else
			pParam->foundFirst = TRUE;
		}
	else if (GetWindowLong (hwnd, GWL_STYLE) & WS_GROUP)
		return FALSE;

	EnableWindow (hwnd, pParam->enableFlag);
	return TRUE;
	}
#undef pParam


VOID
EnableDlgGroup (
	HWND		hDlg,
	HWND		hCtlFirst,
	BOOLEAN		enable
	) {
	ENABLE_DLG_GROUP_PARAM		param;
	
	param.hCtlFirst	= hCtlFirst;
	param.foundFirst = FALSE;
	param.enableFlag = enable;

	EnumChildWindows (hDlg, DoEnable, (LPARAM)&param);
	}




typedef USHORT IPX_SOCKETNUM, *PIPX_SOCKETNUM;
typedef UCHAR IPX_NETNUM[4], *PIPX_NETNUM;
typedef UCHAR IPX_NODENUM[6], *PIPX_NODENUM;

typedef struct _IPX_ADDRESS_BLOCK {
	IPX_NETNUM		net;
	IPX_NODENUM	node;
	IPX_SOCKETNUM	socket;
	} IPX_ADDRESS_BLOCK, *PIPX_ADDRESS_BLOCK;

// IPX Net Number copy macro
#define IPX_NETNUM_CPY(dst,src) memcpy(dst,src,sizeof(IPX_NETNUM))
// IPX Net Number comparison
#define IPX_NETNUM_CMP(addr1,addr2) memcmp(net1,net2,sizeof(IPX_NETNUM))

// IPX Node Number copy macro
#define IPX_NODENUM_CPY(dst,src) memcpy(dst,src,sizeof(IPX_NODENUM))
// IPX Node Number comparison
#define IPX_NODENUM_CMP(node1,node2) memcmp(node1,node2,sizeof(IPX_NODENUM))

// IPX Address copy macro
#define IPX_ADDR_CPY(dst,src) memcpy(dst,src,sizeof(IPX_ADDRESS_BLOCK))
// IPX Address comparison
#define IPX_ADDR_CMP(addr1,addr2) memcmp(addr1,addr2,sizeof(IPX_ADDRESS_BLOCK))

	// Header of IPX packet
typedef struct _IPX_HEADER {
		USHORT				checksum;
		USHORT				length;
		UCHAR				transportctl;
		UCHAR				pkttype;
		IPX_ADDRESS_BLOCK	dst;
		IPX_ADDRESS_BLOCK	src;
		} IPX_HEADER, *PIPX_HEADER;

typedef struct _IPX_SAP_PACKET {
		IPX_HEADER			hdr;
		USHORT				operation;
		struct {
			USHORT				type;
			UCHAR				name[48];
			IPX_ADDRESS_BLOCK	addr;
			USHORT				hops;
			}				entry[7];
		} IPX_SAP_PACKET, *PIPX_SAP_PACKET;

DWORD WINAPI
IPXRIPListenThread (
	LPVOID		param
	) {
#define adptIdx ((INT)param)
	INT				status;
	IPX_SAP_PACKET	packet;
	HANDLE			hClient;
	RTM_IPX_ROUTE	Route;
	DWORD			flags;
	IPX_NETNUM_DATA	netData;
	INT				length;


	fprintf (stderr, "IXP RIP Listener # %d: Started.\n", adptIdx);

	hClient = RtmRegisterClient (RTM_PROTOCOL_FAMILY_IPX, 1000+adptIdx, NULL, 0);
	ASSERT (hClient!=NULL);
	
	while (((status=recvfrom (Sockets[adptIdx],
							 (PCHAR)&packet,
							 sizeof (packet),
							  0, NULL, NULL)) != 0)
				&& (status!=SOCKET_ERROR)) {

//		fprintf (stderr, "IXP RIP Listener # %d: Packet received.\n", adptIdx);
		if (status>=sizeof (IPX_HEADER)) {
			packet.hdr.length = (USHORT)ntohs (packet.hdr.length);
			if (packet.hdr.length>status)
				packet.hdr.length = (USHORT)status;
			if (packet.hdr.length>=FIELD_OFFSET (IPX_SAP_PACKET, entry[0])) {
				if ((packet.hdr.pkttype==4)
						&& (ntohs(packet.operation)==2)) {
					if (FIELD_OFFSET(IPX_SAP_PACKET,entry[1])
								 					<= packet.hdr.length) {
						IPX_NETNUM_CPY (&netData.netnum, &packet.entry[0].addr.net);
						length = sizeof (netData);
						status = getsockopt (Sockets[adptIdx],
										NSPROTO_IPX,
										IPX_GETNETINFO,
										(PCHAR)&netData,
										&length);
						if (status==0) {
							Route.RR_InterfaceID = (1000+adptIdx);
							Route.RR_RoutingProtocol = 0;
							Route.RR_FamilySpecificData.FSD_Ticks =
												(USHORT)netData.netdelay;
							RtlRetrieveUlong (&Route.RR_Network.N_NetNumber,
																 netData.netnum);
							Route.RR_Network.N_NetNumber =
										 ntohl (Route.RR_Network.N_NetNumber);
							IPX_NODENUM_CPY (&Route.RR_NextHopAddress.NHA_Mac,
															 &netData.router);
							Route.RR_FamilySpecificData.FSD_HopCount = netData.hopcount;
							if (Route.RR_FamilySpecificData.FSD_HopCount<16)
								status = RtmAddRoute (hClient, &Route, 200, &flags, NULL, NULL);
							else
								status = RtmDeleteRoute (hClient, &Route, &flags, NULL);
							if (status!=0) {
								fprintf (stderr,
									"IPX RIP Listener # %d: %s failed with status %d\n",
									adptIdx,
									Route.RR_FamilySpecificData.FSD_HopCount<16 ? "AddRoute" : "DeleteRoute",
									status);
								}
							}
						else 
							fprintf (stderr,
								 "IPX RIP Listener # %d:"
								 " Can't get info about net # %02x%02x%02x%02x\n",
								 adptIdx,
								 netData.netnum[0],
								 netData.netnum[1],
								 netData.netnum[2],
								 netData.netnum[3]);

						}
					else
						fprintf (stderr,
								 "IPX RIP Listener # %d:"
								 " Invalid packet length %d.\n",
								 adptIdx,
								 packet.hdr.length);

					}
//				else
//					fprintf (stderr,
//						"IPX RIP Listener # %d:"
//						" Packet type %d, operation %d ignored.\n",
//						adptIdx,
//						packet.hdr.pkttype,
//						ntohs (packet.operation));
				}
			else
				fprintf (stderr, "IPX RIP Listener # %d: Short packet: %d\n",
								adptIdx,
								packet.hdr.length);
			}
		else
			fprintf (stderr, "IPX RIP Listener # %d: Invalid packet: %d\n",
								adptIdx,
								status);
//		Sleep (5*1000);
		}

	fprintf (stderr,
		 "IPX RIP Listener # %d: Terminating loop. Status: %d, err: %d\n",
		 adptIdx, status, GetLastError ());

	if (RtmDeregisterClient (hClient)!=NO_ERROR)
		fprintf (stderr, "Deregister client failed.\n");

	fprintf (stderr, "IXP RIP Listener # %d exited.\n", adptIdx);

	return 0;
#undef adptIdx
	}


#define idx ((LONG)param)
DWORD WINAPI
EnumThread (
	LPVOID param
	) {
	MSG				msg;
	HWND			EnumDlg;
	char			buf[16];
	
	Enums[idx] = NULL;

		// Create dialog window
	EnumDlg = CreateDialogParam (hDLLInstance,
				MAKEINTRESOURCE(IDD_ENUMERATION),
				NULL,
				&EnumDlgProc,
				(LPARAM)idx);
	ASSERTERR (EnumDlg!=NULL);

	sprintf (buf, "Enumerator # %d", idx+1);
	SetWindowText (EnumDlg, buf);

	while (GetMessage (&msg,  NULL, 0, 0)) {
		if (!IsWindow(EnumDlg)
			|| !IsDialogMessage(EnumDlg, &msg)) {
			TranslateMessage (&msg);
			DispatchMessage (&msg);
			}
		}

	if (IsWindow (EnumDlg)) {
		DestroyWindow (EnumDlg);
		EnumDlg = NULL;
		}

	if (Enums[idx]!=NULL) {
		if (Enums[idx]!=INVALID_HANDLE_VALUE) {
			if (RtmCloseEnumerationHandle (Enums[idx])!=NO_ERROR)
				MessageBox (NULL, "Close handle failed!", NULL, MB_OK|MB_ICONSTOP);
			}
		Enums[idx] = NULL;
		}

	return msg.wParam;
	}
#undef idx

BOOL CALLBACK
EnumDlgProc (
    HWND  	hDlg,
    UINT  	uMsg,
    WPARAM  wParam,
    LPARAM  lParam
   	) {
	BOOL		res = FALSE;
	LONG		idx;
	RTM_ROUTE	Route;
	DWORD		ProtocolFamily;
	DWORD		flags;
	DWORD		status;
	RECT		rectDlg, rectScr;

	idx = GetWindowLong (hDlg, DWL_USER)-1;

	switch (uMsg) {
		case WM_INITDIALOG:		// Dialog is being created
			idx = lParam+1;
			SetWindowLong (hDlg, DWL_USER, idx);
			ASSERTERR (GetLastError ()==NO_ERROR);
			EnableDlgGroup (hDlg, GetDlgItem (hDlg, IDG_CRITERIA_E), TRUE);
			EnableDlgGroup (hDlg, GetDlgItem (hDlg, IDG_BUTTONS_E), TRUE);
			EnableWindow (GetDlgItem (hDlg, IDB_GETNEXT_E), FALSE);
			SendDlgItemMessage (hDlg,
							IDC_PROTOCOL_FAMILY_E,
							CB_INSERTSTRING,
							RTM_PROTOCOL_FAMILY_IPX,
							(LPARAM)"IPX"
							);

			SendDlgItemMessage (hDlg,
							IDC_PROTOCOL_FAMILY_E,
							CB_INSERTSTRING,
							RTM_PROTOCOL_FAMILY_IP,
							(LPARAM)"IP"
							);

			SendDlgItemMessage (hDlg,
							IDC_PROTOCOL_FAMILY_E,
							CB_SETCURSEL,
							0,
							0
							);
			GetWindowRect (GetDlgItem (hDlg, IDE_NETWORK_E), &rectScr);
			MapWindowPoints (HWND_DESKTOP, hDlg, (LPPOINT)&rectScr, 2);
			rectDlg.left = rectDlg.top = rectDlg.bottom = 0;
			rectDlg.right = 8*4+5;
			MapDialogRect (hDlg, &rectDlg);
			EnableWindow (GetDlgItem (hDlg, IDE_NETWORK_E), TRUE);
			MoveWindow (GetDlgItem (hDlg, IDE_NETWORK_E),
						rectScr.left,
						rectScr.top,
						rectDlg.right,
						rectScr.bottom-rectScr.top,
						TRUE);

			EnableWindow (GetDlgItem (hDlg, IDE_INTERFACE_E),
						 IsDlgButtonChecked (hDlg, IDC_INTERFACE_E));
			EnableWindow (GetDlgItem (hDlg, IDE_PROTOCOL_E),
						 IsDlgButtonChecked (hDlg, IDC_PROTOCOL_E));
			EnableWindow (GetDlgItem (hDlg, IDE_NETWORK_E),
						 IsDlgButtonChecked (hDlg, IDC_NETWORK_E));

			EnableWindow (GetDlgItem (hDlg, IDB_GETBEST_E),
						 IsDlgButtonChecked (hDlg, IDC_NETWORK_E));

			SetDlgItemText (hDlg, IDB_CREATEDELETE_E, "Create Handle");
			SetDlgItemText (hDlg, IDB_GETFIRST_E, "Get First");
			res = TRUE;
			break;

		case WM_COMMAND:		// Process child window messages only
			switch (LOWORD(wParam)) {
				case IDCANCEL:
					PostQuitMessage (0);
					res = TRUE;
					break;
				case IDC_PROTOCOL_FAMILY_E:
					if (HIWORD(wParam)==CBN_SELENDOK) {
						ProtocolFamily = SendMessage (
												(HWND)lParam,
												CB_GETCURSEL,
												0, 0);
						GetWindowRect (GetDlgItem (hDlg, IDE_NETWORK_E), &rectScr);
						MapWindowPoints (HWND_DESKTOP, hDlg, (LPPOINT)&rectScr, 2);
						rectDlg.left = rectDlg.top = rectDlg.bottom = 0;
						switch (ProtocolFamily) {
							case RTM_PROTOCOL_FAMILY_IPX:
								rectDlg.right = 8*4+5;
								break;
							case RTM_PROTOCOL_FAMILY_IP:
								rectDlg.right = 16*4+5;
								break;
							}
						MapDialogRect (hDlg, &rectDlg);
						EnableWindow (GetDlgItem (hDlg, IDE_NETWORK_E), TRUE);
						MoveWindow (GetDlgItem (hDlg, IDE_NETWORK_E),
									rectScr.left,
									rectScr.top,
									rectDlg.right,
									rectScr.bottom-rectScr.top,
									TRUE);
						EnableWindow (GetDlgItem (hDlg, IDE_NETWORK_E),
									 IsDlgButtonChecked (hDlg, IDC_NETWORK_E));
						}
					break;

				case IDC_NETWORK_E:
					if (HIWORD(wParam)==BN_CLICKED)
						EnableWindow (GetDlgItem (hDlg, IDB_GETBEST_E),
								IsDlgButtonChecked (hDlg, LOWORD(wParam)));
                                        break;
				case IDC_INTERFACE_E:
				case IDC_PROTOCOL_E:
					if (HIWORD(wParam)==BN_CLICKED)
						EnableWindow (GetDlgItem (hDlg, LOWORD(wParam)+1),
								IsDlgButtonChecked (hDlg, LOWORD(wParam)));
					break;
					
				case IDB_CREATEDELETE_E:
					if (Enums[idx]==NULL) {
						GetCriteria (hDlg, &ProtocolFamily, &flags, &Route);
						Enums[idx] = RtmCreateEnumerationHandle (
												ProtocolFamily,
												flags,
												&Route);
						if (Enums[idx]!=NULL) {
							EnableDlgGroup (hDlg,
								 GetDlgItem (hDlg, IDG_CRITERIA_E), FALSE);
							EnableWindow (GetDlgItem (hDlg, IDB_GETFIRST_E),
																		 FALSE);
							SetWindowText ((HWND)lParam, "Close Handle");
							EnableWindow (GetDlgItem (hDlg, IDB_GETNEXT_E),
																		 TRUE);
							}
						else
							MessageBox (hDlg, "Create Handle failed!",
												 NULL, MB_OK|MB_ICONSTOP);
						}
					else {
						if (RtmCloseEnumerationHandle (Enums[idx])!=NO_ERROR)
							MessageBox (hDlg, "Close handle failed!",
												 NULL, MB_OK|MB_ICONSTOP);
						Enums[idx] = NULL;
						EnableWindow (GetDlgItem (hDlg, IDB_GETNEXT_E), FALSE);
						SetWindowText ((HWND)lParam, "Create Handle");
						EnableWindow (GetDlgItem (hDlg, IDB_GETFIRST_E), TRUE);
						EnableDlgGroup (hDlg,
								 GetDlgItem (hDlg, IDG_CRITERIA_E), TRUE);
						}
					res = TRUE;
					break;
				case IDB_GETFIRST_E:
					if (Enums[idx]==NULL) {
						GetCriteria (hDlg, &ProtocolFamily, &flags, &Route);
						status = RtmGetFirstRoute (
												ProtocolFamily,
												flags,
												&Route);
						if (status==NO_ERROR) {
							DisplayRoute (hDlg, ProtocolFamily, &Route);
							Enums[idx] = INVALID_HANDLE_VALUE;
							EnableWindow (GetDlgItem (hDlg, IDB_GETBEST_E), FALSE);
							EnableDlgGroup (hDlg,
								 GetDlgItem (hDlg, IDG_CRITERIA_E), FALSE);
							EnableWindow (GetDlgItem (hDlg, IDB_CREATEDELETE_E),
																		 FALSE);
							SetWindowText ((HWND)lParam, "Stop Scan");
							EnableWindow (GetDlgItem (hDlg, IDB_GETNEXT_E),
																		 TRUE);
							}
						else if (status==ERROR_NO_ROUTES)
							MessageBox (hDlg, "ERROR_NO_ROUTES!",
												 NULL, MB_OK|MB_ICONSTOP);
						else
							MessageBox (hDlg, "ERROR!",
												 NULL, MB_OK|MB_ICONSTOP);
						}
					else {
						Enums[idx] = NULL;
						EnableWindow (GetDlgItem (hDlg, IDB_GETNEXT_E), FALSE);
						SetWindowText ((HWND)lParam, "Get First");
						EnableWindow (GetDlgItem (hDlg, IDB_CREATEDELETE_E), TRUE);
						EnableDlgGroup (hDlg,
								 GetDlgItem (hDlg, IDG_CRITERIA_E), TRUE);
						EnableWindow (GetDlgItem (hDlg, IDB_GETBEST_E),
									IsDlgButtonChecked (hDlg, IDC_NETWORK_E));
						}
					res = TRUE;
					break;
				case IDB_GETNEXT_E:
					if (Enums[idx]==INVALID_HANDLE_VALUE) {
						GetCriteria (hDlg, &ProtocolFamily, &flags, &Route);
						GetLastRoute (hDlg, ProtocolFamily, &Route);
						status = RtmGetNextRoute (ProtocolFamily, flags, &Route);
						}
					else {
						status = RtmEnumerateGetNextRoute (Enums[idx], &Route);
						ProtocolFamily = SendDlgItemMessage (hDlg,
											IDC_PROTOCOL_FAMILY_E,
											CB_GETCURSEL, 0, 0);
						}
					if (status==NO_ERROR)
						DisplayRoute (hDlg, ProtocolFamily, &Route);
					else if (status==ERROR_NO_MORE_ROUTES)
						MessageBox (hDlg, "ERROR_NO_MORE_ROUTES!",
												 NULL, MB_OK|MB_ICONSTOP);
					else
						MessageBox (hDlg, "ERROR!",
												 NULL, MB_OK|MB_ICONSTOP);
							
					res = TRUE;
					break;
				case IDB_GETBEST_E:
					GetCriteria (hDlg, &ProtocolFamily, &flags, &Route);
					res = RtmIsRoute (ProtocolFamily, ((char *)&Route)+sizeof(RTM_XX_ROUTE), &Route);

					if (res)
						DisplayRoute (hDlg, ProtocolFamily, &Route);
					else
						MessageBox (hDlg, "NO_ROUTES!",
												 NULL, MB_OK|MB_ICONSTOP);
					res = TRUE;
					break;
				case IDB_GETAGE_E:
					ProtocolFamily = SendDlgItemMessage (hDlg,
											IDC_PROTOCOL_FAMILY_E,
											CB_GETCURSEL, 0, 0);
					GetLastRoute (hDlg, ProtocolFamily, &Route);
					status = RtmGetSpecificRoute (ProtocolFamily, &Route);

					if (status==NO_ERROR) {
						DisplayRoute (hDlg, ProtocolFamily, &Route);
						SetDlgItemInt (hDlg, IDL_AGESEC_E,
							 						RtmGetRouteAge (&Route), FALSE);
						}
					else
						MessageBox (hDlg, "NO_ROUTES!",
												 NULL, MB_OK|MB_ICONSTOP);
					res = TRUE;
					break;
				}
			break;
		case WM_DESTROY:
			if (Enums[idx]!=NULL) {
				if (Enums[idx]!=INVALID_HANDLE_VALUE) {
					if (RtmCloseEnumerationHandle (Enums[idx])!=NO_ERROR)
						MessageBox (hDlg, "Close handle failed!",
											 NULL, MB_OK|MB_ICONSTOP);
					}
				Enums[idx] = NULL;
				}
			break;
		}

	return res;
	}


VOID
GetCriteria (
	HWND		hDlg,
	DWORD		*ProtocolFamily,
	DWORD		*flags,
	PRTM_ROUTE	Route
	) {
	char						buf[32];
	char						*p;
	INT							val,i,n;
		
	*ProtocolFamily = SendDlgItemMessage (hDlg, IDC_PROTOCOL_FAMILY_E,
										CB_GETCURSEL, 0, 0);

	if (IsDlgButtonChecked (hDlg, IDC_BESTROUTES_E)) {
		*flags = RTM_ONLY_BEST_ROUTES;
		}
	else
		*flags = 0;

	if (IsDlgButtonChecked (hDlg, IDC_INTERFACE_E)) {
		*flags |= RTM_ONLY_THIS_INTERFACE;

		Route->XX_INTERFACE = GetDlgItemInt (hDlg,
									IDE_INTERFACE_E, NULL, FALSE);
		}
	if (IsDlgButtonChecked (hDlg, IDC_PROTOCOL_E)) {
		*flags |= RTM_ONLY_THIS_PROTOCOL;
		Route->XX.RR_RoutingProtocol = GetDlgItemInt (hDlg,
										IDE_PROTOCOL_E, NULL, FALSE);
		}
	if (IsDlgButtonChecked (hDlg, IDC_NETWORK_E)) {
		*flags |= RTM_ONLY_THIS_NETWORK;
		GetDlgItemText (hDlg, IDE_NETWORK_E, buf, sizeof (buf)-1);
		p = buf;
		switch (*ProtocolFamily) {
			case RTM_PROTOCOL_FAMILY_IPX:
				if (sscanf (p, "%8X%n", &val, &n)==1)
					Route->IPX_NET_NUM = val;
				else
					Route->IPX_NET_NUM = 0;
    			p += n;
				sprintf (buf,
						"%08X",
						Route->IPX_NET_NUM);
				break;
			case RTM_PROTOCOL_FAMILY_IP:
				if (sscanf (p, "%8X%n", &val, &n)==1)
					Route->IP_NET_NUM = val;
				else
					Route->IP_NET_NUM = 0;
    			p += n;
				if (sscanf (p, "%8X%n", &val, &n)==1)
					Route->IP_NET_MSK = val;
				else
					Route->IP_NET_MSK = 0;
    			p += n;
				sprintf (buf,
						"%08X%08X",
						Route->IP_NET_NUM,
						Route->IP_NET_MSK);
				break;
			}
		SetDlgItemText (hDlg, IDE_NETWORK_E, buf);
		}
	}

VOID
GetLastRoute (
	HWND		hDlg,
	DWORD		ProtocolFamily,
	PRTM_ROUTE	Route
	) {
	char		buf[128];
	char		*p;
	INT			i,n,val;


	GetDlgItemText (hDlg, IDL_ROUTE_E, buf, sizeof (buf)-1);
	p = buf;
	switch (ProtocolFamily) {
		case RTM_PROTOCOL_FAMILY_IPX:
			if (sscanf (p, "%8X%n", &val, &n)==1)
				Route->IPX_NET_NUM = val;
			else
				Route->IPX_NET_NUM = 0;
			p += n;
			sscanf (p,
					" %d %d %n",
					&Route->XX_INTERFACE,
					&Route->XX_PROTOCOL,
					&n);
			p += n;
			for (i=0; i<sizeof(Route->IPX_NEXT_HOP_MAC); i++, p+=n) {
				if (sscanf (p, "%2X%n", &val, &n)==1)
					Route->IPX_NEXT_HOP_MAC[i] = (BYTE)val;
				else
					Route->IPX_NEXT_HOP_MAC[i] = 0;
				}
			break;
		case RTM_PROTOCOL_FAMILY_IP:
			if (sscanf (p, "%8X%n", &val, &n)==1)
				Route->IP_NET_NUM = val;
			else
				Route->IP_NET_NUM = 0;
			p += n;
			sscanf (p, "-%n", &n);
			p += n;
			if (sscanf (p, "%8X%n", &val, &n)==1)
				Route->IP_NET_MSK = val;
			else
				Route->IP_NET_MSK = 0;
			p += n;
			sscanf (p,
					" %d %d %n",
					&Route->XX_INTERFACE,
					&Route->XX_PROTOCOL,
					&n);
			p += n;

			if (sscanf (p, "%8X%n", &val, &n)==1)
				Route->IP_NEXT_HOP_NUM = val;
			else
				Route->IP_NEXT_HOP_NUM = 0;
			p += n;
			sscanf (p, "-%n", &n);
			p += n;
			if (sscanf (p, "%8X%n", &val, &n)==1)
				Route->IP_NEXT_HOP_MSK = val;
			else
				Route->IP_NEXT_HOP_MSK = 0;
			p += n;

			break;
		}
	}

VOID
DisplayRoute (
	HWND		hDlg,
	DWORD		ProtocolFamily,
	PRTM_ROUTE	Route
	) {
	char		buf[128];

	switch (ProtocolFamily) {
		case RTM_PROTOCOL_FAMILY_IPX:
			sprintf (buf,
					"     %08X    "
					" %4d %4d"
					"    %02X%02X%02X%02X%02X%02X  "
					" %4d",
					Route->IPX_NET_NUM,
					Route->XX_INTERFACE,
					Route->XX_PROTOCOL,
					Route->IPX_NEXT_HOP_MAC[0],
					Route->IPX_NEXT_HOP_MAC[1],
					Route->IPX_NEXT_HOP_MAC[2],
					Route->IPX_NEXT_HOP_MAC[3],
					Route->IPX_NEXT_HOP_MAC[4],
					Route->IPX_NEXT_HOP_MAC[5],
					Route->IPX_METRIC);
			break;
		case RTM_PROTOCOL_FAMILY_IP:
			sprintf (buf,
					"%08X-%08X"
					" %4d %4d"
					" %08X-%08X"
					" %4d",
					Route->IP_NET_NUM,
					Route->IP_NET_MSK,
					Route->XX_INTERFACE,
					Route->XX_PROTOCOL,
					Route->IP_NEXT_HOP_NUM,
					Route->IP_NEXT_HOP_MSK,
					Route->IP_METRIC);

			break;
		}

	SetDlgItemText (hDlg, IDL_ROUTE_E, buf);
	sprintf (buf, "%08X", Route->XX_TIMESTAMP.dwHighDateTime);
	SetDlgItemText (hDlg, IDL_TIMEHIGH_E, buf);
	sprintf (buf, "%08X", Route->XX_TIMESTAMP.dwLowDateTime);
	SetDlgItemText (hDlg, IDL_TIMELOW_E, buf);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\avltrie.c ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    avltrie.c

Abstract:

    Contains routines for a best matching
    prefix lookup using an AVL trie.

Author:

    Chaitanya Kodeboyina (chaitk)   24-Jun-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop

#include "avltrie.h"


DWORD
WINAPI
CreateTable(
    IN       UINT                            MaxBytes,
    OUT      HANDLE                         *Table
    )

/*++

Routine Description:

    Create a table that enables to you add and delete prefixes
    (and associated data) and do best matching prefix queries.

Arguments:

    MaxBytes          - Max length of any prefix in the table,

    Table             - Pointer to the table that was created.

Return Value:

    Status of the operation

--*/

{
    PAVL_TRIE         NewTrie;

    ASSERT(sizeof(AVL_CONTEXT) <= sizeof(LOOKUP_CONTEXT));

    ASSERT(sizeof(AVL_LINKAGE) <= sizeof(LOOKUP_LINKAGE));

    if (MaxBytes == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Allocate and initialize a new prefix table
    //

    NewTrie = AllocNZeroMemory(sizeof(AVL_TRIE));
    if (NewTrie == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

#if _PROF_
    NewTrie->MemoryInUse = sizeof(AVL_TRIE);
#endif

    NewTrie->MaxKeyBytes = MaxBytes;

    *Table = NewTrie;

    return NO_ERROR;
}


DWORD
WINAPI
InsertIntoTable(
    IN       HANDLE                          Table,
    IN       USHORT                          NumBits,
    IN       PUCHAR                          KeyBits,
    IN       PLOOKUP_CONTEXT                 Context OPTIONAL,
    IN       PLOOKUP_LINKAGE                 Data
    )

/*++

Routine Description:

    Inserts new prefix (and associated data) into a prefix table.

Arguments:

    Table             - Table into which prefix is being inserted,

    NumBits           - Number of bits in the prefix being added,

    KeyBits           - Value of the bits that form the prefix,

    Context           - Search context for the prefix being added,

    Data              - Data associated with this prefix being added.

Return Value:

    Status of the operation

--*/

{
    PAVL_TRIE         Trie;
    PAVL_NODE         PrevNode;
    PAVL_NODE         BestNode;
    PAVL_NODE         NewNode;
    LOOKUP_CONTEXT    Context1;
    AVL_BALANCE       NextChild;
    PLOOKUP_LINKAGE   Dummy;

    Trie = Table;

#if PROF
    Trie->NumInsertions++;
#endif

    //
    // If there is a search context, and we have an
    // update, we can avoid the lookup (common case)
    //

    if (!ARGUMENT_PRESENT(Context))
    {
        Context = &Context1;

        SearchInTable(Table, NumBits, KeyBits, Context, &Dummy);
    }

    BestNode = ((PAVL_CONTEXT) Context)->BestNode;

    if (BestNode && (BestNode->NumBits == NumBits))
    {
        SET_NODEPTR_INTO_DATA(BestNode->Data, NULL);
        
        BestNode->Data = Data;

        SET_NODEPTR_INTO_DATA(Data, BestNode);

        return NO_ERROR;
    }

    NewNode = CreateTrieNode(Trie, NumBits, KeyBits, BestNode, Data);
    if (NewNode)
    {
        PrevNode = ((PAVL_CONTEXT) Context)->InsPoint;

        if (PrevNode)
        {
            NextChild = ((PAVL_CONTEXT) Context)->InsChild;

            PrevNode->Child[NextChild] = NewNode;

            NewNode->Parent = PrevNode;

            ((PAVL_CONTEXT) Context)->BestNode = NewNode;

            // Enumerate in range of the new node & update prefixes
            AdjustPrefixes(Trie, BestNode, NewNode, NewNode, Context);

            // Balance trie if it was thrown off balance
            BalanceAfterInsert(Trie, PrevNode, NextChild);
        }
        else
        {
            Trie->TrieRoot = NewNode;
        }

#if _DBG_
        if (CheckTable(Table) != TRUE)
        {
            DbgBreakPoint();
        }
#endif
        
        return NO_ERROR;
    }
    else // if CreateTrieNode failed
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
}


DWORD
WINAPI
DeleteFromTable(
    IN       HANDLE                          Table,
    IN       USHORT                          NumBits,
    IN       PUCHAR                          KeyBits,
    IN       PLOOKUP_CONTEXT                 Context OPTIONAL,
    OUT      PLOOKUP_LINKAGE                *Data
    )

/*++

Routine Description:

    Deletes a prefix from a prefix table and returns associated data.

Arguments:

    Table             - Table from which prefix is being deleted,

    NumBits           - Number of bits in the prefix being deleted,

    KeyBits           - Value of the bits that form the prefix,

    Context           - Search context for the prefix being deleted,

    Data              - Data associated with this prefix is retd here.

Return Value:

    Status of the operation

--*/

{
    PAVL_TRIE         Trie;
    PAVL_NODE         PrevNode;
    PAVL_NODE         CurrNode;
    PAVL_NODE         NextNode;
    LOOKUP_CONTEXT    Context1;
    AVL_BALANCE       NextChild;
    DWORD             Status;

#if _DBG_
    USHORT Depth = 0;
#endif

    Trie = Table;

#if PROF
    Trie->NumDeletions++;
#endif

    //
    // If there is a search context that is valid,
    // we will avoid doing a lookup (common case)
    //

    if (!ARGUMENT_PRESENT(Context))
    {
        Context = &Context1;

        Status = SearchInTable(Table, NumBits, KeyBits, Context, Data);

        if (Status != NO_ERROR)
        {
            return Status;
        }
    }

#if WRN
    NextChild = INVALID;
#endif

    //
    // We should not come here unless the context
    // points accurately to element to be deleted
    //

    CurrNode = ((PAVL_CONTEXT) Context)->BestNode;

    ASSERT(CurrNode && (CurrNode->NumBits == NumBits) &&
           (CompareFullKeys(CurrNode->KeyBits,
                            KeyBits,
                            Trie->MaxKeyBytes) == 0));

    PrevNode = ((PAVL_CONTEXT) Context)->InsPoint;

    ASSERT(PrevNode == CurrNode->Parent);

    if (PrevNode)
    {
        NextChild = ((PAVL_CONTEXT) Context)->InsChild;
    }

    ASSERT(((PrevNode == NULL) && (Trie->TrieRoot == CurrNode))
           || (PrevNode->Child[NextChild] == CurrNode));

    //
    // If the node being deleted has two children,
    // swap its position with its successor node
    //

    if (CurrNode->Child[LEFT] && CurrNode->Child[RIGHT])
    {
#if _DBG_
        if (CheckSubTrie(PrevNode, &Depth) != NO_ERROR)
        {
            DbgBreakPoint();
        }
#endif

        SwapWithSuccessor(Trie, (PAVL_CONTEXT) Context);

#if _DBG_
        if (CheckSubTrie(PrevNode, &Depth) != NO_ERROR)
        {
            DbgBreakPoint();
        }
#endif

        CurrNode  = ((PAVL_CONTEXT) Context)->BestNode;
        PrevNode  = ((PAVL_CONTEXT) Context)->InsPoint;
        NextChild = ((PAVL_CONTEXT) Context)->InsChild;
    }

    ASSERT(((PrevNode == NULL) && (Trie->TrieRoot == CurrNode))
           || (PrevNode->Child[NextChild] == CurrNode));

#if _DBG_
    if (CheckTable(Table) != TRUE)
    {
        DbgBreakPoint();
    }
#endif

    AdjustPrefixes(Trie, CurrNode, CurrNode->Prefix, CurrNode, Context);

#if _DBG_
    if (CheckTable(Table) != TRUE)
    {
        DbgBreakPoint();
    }
#endif


    if (!CurrNode->Child[LEFT])
    {
        // (LEFT Child = NULL) => Promote the right child

        NextNode = CurrNode->Child[RIGHT];
          
        if (NextNode)
        {
            NextNode->Parent = CurrNode->Parent;
        }
    }
    else
    {
        // (RIGHT Child = NULL) => Promote the left child

        ASSERT(!CurrNode->Child[RIGHT]);

        NextNode = CurrNode->Child[LEFT];

        NextNode->Parent = CurrNode->Parent;
    }
  
    if (PrevNode)
    {
        PrevNode->Child[NextChild] = NextNode;

        // Balance trie if it was thrown off balance
        BalanceAfterDelete(Trie, PrevNode, NextChild);
    }
    else
    {
        Trie->TrieRoot = NextNode;
    }

    *Data = CurrNode->Data;

    DestroyTrieNode(Trie, CurrNode);

#if _DBG_
    if (CheckTable(Table) != TRUE)
    {
        DbgBreakPoint();
    }
#endif

    return NO_ERROR;
}


DWORD
WINAPI
SearchInTable(
    IN       HANDLE                          Table,
    IN       USHORT                          NumBits,
    IN       PUCHAR                          KeyBits,
    OUT      PLOOKUP_CONTEXT                 Context OPTIONAL,
    OUT      PLOOKUP_LINKAGE                *Data
    )
{
    PAVL_TRIE         Trie;
    PAVL_NODE         PrevNode;
    PAVL_NODE         CurrNode;
    PAVL_NODE         BestNode;
    AVL_BALANCE       NextChild;
    INT               Comp;
#if _PROF_
    UINT              NumTravsDn;
    UINT              NumTravsUp;  
#endif

    Trie = Table;

    ASSERT(NumBits <= Trie->MaxKeyBytes * BITS_IN_BYTE);

#if _PROF_
    NumTravsDn = 0;
    NumTravsUp = 0;
#endif

    //
    // Go down the trie using key comparisions
    // in search of a prefix matching this key
    //

    CurrNode = Trie->TrieRoot;
    PrevNode = NULL;
    
    NextChild = LEFT;

    BestNode = NULL;

    while (CurrNode)
    {
#if _PROF_
        NumTravsDn++;
#endif
        Comp = CompareFullKeys(KeyBits, 
                               CurrNode->KeyBits,
                               Trie->MaxKeyBytes);

        if ((Comp < 0) || ((Comp == 0) && (NumBits < CurrNode->NumBits)))
        {
            NextChild = LEFT;
        }
        else
        if ((Comp > 0) || (NumBits > CurrNode->NumBits))
        {
            NextChild = RIGHT;

            BestNode = CurrNode;
        }
        else
        {
            BestNode = CurrNode; 
            
            break;
        }
      
        PrevNode = CurrNode;
        CurrNode = PrevNode->Child[NextChild];
    }

    if (!CurrNode)
    {
        //
        // We do not have an exact match - so now
        // we try to refine BestNode guess to get
        // the next best prefix to the new prefix
        //

        while(BestNode)
        {
            if (BestNode->NumBits <= NumBits)
            {
                if (!(ComparePartialKeys(BestNode->KeyBits,
                                         KeyBits,
                                         BestNode->NumBits)))
                {
                    break;
                }
            }

            BestNode = BestNode->Prefix;

#if _PROF_
            if (BestNode)
            {
                NumTravsUp++;
            }
#endif
        }
    }

    if (ARGUMENT_PRESENT(Context))
    {
        ((PAVL_CONTEXT) Context)->BestNode = BestNode;
        ((PAVL_CONTEXT) Context)->InsPoint = PrevNode;
        ((PAVL_CONTEXT) Context)->InsChild = NextChild;
    }

    *Data = BestNode ? BestNode->Data : NULL;

#if _PROF_
    Print("Num Travs Dn = %5d, Travs Up = %5d\n",
             NumTravsDn,
             NumTravsUp);
#endif

    return CurrNode ? NO_ERROR : ERROR_NOT_FOUND;
}


DWORD
WINAPI
BestMatchInTable(
    IN       HANDLE                          Table,
    IN       PUCHAR                          KeyBits,
    OUT      PLOOKUP_LINKAGE                *BestData
    )
{
    PAVL_TRIE         Trie;
    PAVL_NODE         CurrNode;
    PAVL_NODE         BestNode;
    INT               Comp;
#if _PROF_
    UINT              NumTravsDn;
    UINT              NumTravsUp;  
#endif

    Trie = Table;

#if _PROF_
    NumTravsDn = 0;
    NumTravsUp = 0;
#endif

    //
    // Go down the trie using key comparisions
    // in search of a prefix matching this key
    //

    CurrNode = Trie->TrieRoot;

    BestNode = NULL;

    while (CurrNode)
    {
#if _PROF_
        NumTravsDn++;
#endif
        Comp = CompareFullKeys(KeyBits, 
                               CurrNode->KeyBits,
                               Trie->MaxKeyBytes);

        if (Comp < 0)
        {
            CurrNode = CurrNode->Child[LEFT];
        }
        else
        {
            BestNode = CurrNode;
            CurrNode = CurrNode->Child[RIGHT];
        }
    }

    //
    // Now we refine the BestNode guess to get
    // the next best prefix to the new prefix
    //

    while(BestNode)
    {
        if (!(ComparePartialKeys(BestNode->KeyBits,
                                 KeyBits,
                                 BestNode->NumBits)))
        {
            break;
        }

        BestNode = BestNode->Prefix;

#if _PROF_
        if (BestNode)
        {
            NumTravsUp++;
        }
#endif
    }

    *BestData = BestNode ? BestNode->Data : NULL;

#if _PROF_
    Print("Num Travs Dn = %5d, Travs Up = %5d\n",
             NumTravsDn,
             NumTravsUp);
#endif

    return NO_ERROR;
}


DWORD
WINAPI
NextMatchInTable(
    IN       HANDLE                          Table,
    IN       PLOOKUP_LINKAGE                 BestData,
    OUT      PLOOKUP_LINKAGE                *NextBestData
    )
{
  PAVL_NODE         BestNode;

  UNREFERENCED_PARAMETER(Table);

  //
  // Assume the input data passed in is valid,
  // and the data is one of the items in trie
  //

  BestNode = GET_NODEPTR_FROM_DATA(BestData);

  *NextBestData = BestNode->Prefix ? BestNode->Prefix->Data : NULL;

  return NO_ERROR;
}


DWORD
WINAPI
EnumOverTable(
    IN       HANDLE                          Table,
    IN OUT   PUSHORT                         StartNumBits,
    IN OUT   PUCHAR                          StartKeyBits,
    IN OUT   PLOOKUP_CONTEXT                 Context     OPTIONAL,
    IN       USHORT                          StopNumBits OPTIONAL,
    IN       PUCHAR                          StopKeyBits OPTIONAL,
    IN OUT   PUINT                           NumItems,
    OUT      PLOOKUP_LINKAGE                *DataItems
    )
{
    PAVL_TRIE         Trie;
    PLOOKUP_LINKAGE   Data;
    PAVL_NODE         PrevNode;
    PAVL_NODE         CurrNode;
    PAVL_NODE         NextNode;
    LOOKUP_CONTEXT    Context1;
    AVL_BALANCE       NextChild;
    UINT              ItemsCopied;
    INT               Comp;

    Trie = Table;

    if (!ARGUMENT_PRESENT(Context))
    {
        // No context - initialize local context

        Context = &Context1;

        ((PAVL_CONTEXT) Context)->InsChild = EVEN;
    }

    //
    // If there is a search context that is valid,
    // we will avoid doing a lookup (common case)
    //
    
    if (((PAVL_CONTEXT) Context)->InsChild == EVEN)
    {
        //
        // If we did not find an exact match,
        // remember it by modifying context
        //

        if (SearchInTable(Table,
                          *StartNumBits,
                          StartKeyBits,
                          Context,
                          &Data) != NO_ERROR)
        {
            ((PAVL_CONTEXT) Context)->BestNode = NULL;
        }
    }

    CurrNode  = ((PAVL_CONTEXT) Context)->BestNode;

    //
    // If we did not find an exact match, find the
    // successor ( node with smallest key > key )
    //

    if (!CurrNode)
    {
        PrevNode  = ((PAVL_CONTEXT) Context)->InsPoint;

        if (!PrevNode)
        {
            // No items copied
            *NumItems = 0;

            return ERROR_NO_MORE_ITEMS;
        }

        NextChild = ((PAVL_CONTEXT) Context)->InsChild;

        if (NextChild == LEFT)
        {
            CurrNode = PrevNode;
        }
        else
        {
            CurrNode = PrevNode;
            while (CurrNode->Parent)
            {
                if (CurrNode->Parent->Child[LEFT] == CurrNode)
                {
                    break;
                }

                CurrNode = CurrNode->Parent;
            }
          
            if (CurrNode->Parent)
            {
                CurrNode = CurrNode->Parent;
            }
            else
            {
                // No Items copied
                *NumItems = 0;

                return ERROR_NO_MORE_ITEMS;
            }
        }
    }

    if (*NumItems == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Enumeration Order: Node->LeftTree, Node, Node->RightTree
    //

    ItemsCopied = 0;

    do
    {
        // Check if this dest is before Stop Prefix (if it exists)
        if (StopKeyBits)
        {
            Comp = CompareFullKeys(CurrNode->KeyBits,
                                   StopKeyBits,
                                   Trie->MaxKeyBytes);

            if (Comp == 0)
            {
                if (CurrNode->NumBits <= StopNumBits)
                {
                    Comp = -1;
                }
                else
                {
                    Comp = +1;
                }
            }

            if (Comp > 0)
            {
                // Return Items Copied
                *NumItems = ItemsCopied;
                
                return ERROR_NO_MORE_ITEMS;
            }
        }

        // Copy current data to the output buffer
        DataItems[ItemsCopied++] = CurrNode->Data;
          
        // Find successor (smallest node > this node)

        if (CurrNode->Child[RIGHT])
        {
            NextNode  = CurrNode->Child[RIGHT];

            while (NextNode->Child[LEFT])
            {
                NextNode = NextNode->Child[LEFT];
            }

            CurrNode = NextNode;
        }
        else
        {
            while (CurrNode->Parent)
            {
                if (CurrNode->Parent->Child[LEFT] == CurrNode)
                {
                    break;
                }

                CurrNode = CurrNode->Parent;
            }

            if (CurrNode->Parent)
            {
                CurrNode = CurrNode->Parent;
            }
            else
            {
                // Return Items Copied
                *NumItems = ItemsCopied;

                return ERROR_NO_MORE_ITEMS;
            }
        }
    }
    while (ItemsCopied < *NumItems);

    // Update the temporary context

    ((PAVL_CONTEXT) Context)->BestNode = CurrNode;

    // Update enumeration context by adjusting starting prefix

    if (StartKeyBits)
    {
        *StartNumBits = CurrNode->NumBits;
        CopyFullKeys(StartKeyBits,
                     CurrNode->KeyBits,
                     Trie->MaxKeyBytes);
    }

    // Return Items Copied
    *NumItems = ItemsCopied;

    return NO_ERROR;
}


DWORD
WINAPI
DestroyTable(
    IN       HANDLE                          Table
    )
{
    PAVL_TRIE         Trie;

    Trie = Table;

    if (Trie->TrieRoot != NULL)
    {
        return ERROR_NOT_EMPTY;
    }

    ASSERT(Trie->NumNodes == 0);

#if _PROF_
    Trie->MemoryInUse -= sizeof(AVL_TRIE);
#endif

    FreeMemory(Trie);

    return NO_ERROR;
}


BOOL
WINAPI
CheckTable(
    IN       HANDLE                           Table
    )
{
    BOOL              Status;
    USHORT            Depth;

    Status = CheckSubTrie(((PAVL_TRIE)Table)->TrieRoot, &Depth);

#if _DBG_
    if (SUCCESS(Status))
    {
        Print("\nDepth of the AVL Trie = %lu\n\n", Depth);
    }
#endif

    return SUCCESS(Status) ? TRUE : FALSE;
}


VOID
WINAPI
DumpTable(
    IN       HANDLE                           Table,
    IN       DWORD                           Flags
    )
{
    PAVL_TRIE         Trie;

    Trie = Table;

    Print("---------------- TABLE BEGIN ---------------------------\n\n");

    if (Flags & SUMMARY)
    {
        ;
    }

#if PROF
    if (Flags & STATS)
    {
        Print(
         "Num of Ins = %6lu, Dels = %6lu, Sing Rots = %6lu, Dob Rots = %6lu\n"
         "Num Allocs = %6lu, Free = %6lu, Num Nodes = %6lu, Mem Used = %6lu\n",
         Trie->NumInsertions,
         Trie->NumDeletions,
         Trie->NumSingleRots,
         Trie->NumDoubleRots,
         Trie->NumAllocs,
         Trie->NumFrees,
         Trie->NumNodes,
         Trie->MemoryInUse);
    }
#endif

    if (Flags & ITEMS)
    {
        Print("\n");
        DumpSubTrie(Trie->TrieRoot);
        Print("\n");
    }

    Print("---------------- TABLE  END  ---------------------------\n\n");
}


//
// Helper Functions - used in insert and delete
//

VOID
BalanceAfterInsert(
    IN       PAVL_TRIE                        Trie,
    IN       PAVL_NODE                        Node,
    IN       AVL_BALANCE                      Longer
    )
{
#if _DBG_
    Print("Balance after Insert Called: %p %02x\n", Node, Longer);
#endif
    
    ASSERT((Longer == LEFT) || (Longer == RIGHT));

    // Go up the tree adjusting the balances
    while (Node->Balance == EVEN)
    {
        Node->Balance = Longer;

        if (!Node->Parent)
        {
            return;
        }

        Longer = (Node->Parent->Child[LEFT] == Node) ? LEFT : RIGHT;
          
        Node = Node->Parent;
    }

    // We made the balance of an ancestor even
    if (Node->Balance != Longer)
    {
        Node->Balance = EVEN;
        return;
    }

    // Unbalanced a ancestor - rotate the tree
    if (Node->Child[Longer]->Balance == Longer)
    {
        SingleRotate(Trie, Node, (AVL_BALANCE) -Longer, &Node);
    }
    else
    {
        DoubleRotate(Trie, Node, (AVL_BALANCE) -Longer, &Node);
    }

    return;
}


VOID
BalanceAfterDelete(
    IN       PAVL_TRIE                        Trie,
    IN       PAVL_NODE                        Node,
    IN       AVL_BALANCE                      Shorter
    )
{
#if _DBG_
    Print("Balance after Delete Called: %p %02x\n", Node, Shorter);
#endif

    ASSERT((Shorter == LEFT) || (Shorter == RIGHT));

    while (TRUE)
    {
        if (Node->Balance == EVEN)
        {
            Node->Balance = -Shorter;
            return;
        }

        if (Node->Balance == Shorter)
        {
            Node->Balance = EVEN;
        }
        else
        {
            ASSERT(Node->Child[-Shorter] != NULL);

            if (Node->Child[-Shorter]->Balance == -Shorter)
            {
                SingleRotate(Trie, Node, Shorter, &Node);
            }
            else
            if (Node->Child[-Shorter]->Balance ==  Shorter)
            {
                DoubleRotate(Trie, Node, Shorter, &Node);
            }
            else
            {
                SingleRotate(Trie, Node, Shorter, &Node);

                Node->Balance = Shorter;

                Node->Child[Shorter]->Balance = -Shorter;

                return;
            }
        }

        if (!Node->Parent)
        {
            return;
        }

        Shorter = (Node->Parent->Child[LEFT] == Node) ? LEFT : RIGHT;
      
        Node = Node->Parent;
    }
}


VOID
SingleRotate(
    IN       PAVL_TRIE                        Trie,
    IN       PAVL_NODE                        UnbalNode,
    IN       AVL_BALANCE                      Direction,
    OUT      PAVL_NODE                       *BalancedNode
)
{
    PAVL_NODE         PrevNode;
    PAVL_NODE         CurrNode;
    PAVL_NODE         NextNode;

#if _DBG_
    Print("Single Rotate Called: %p %02x\n", UnbalNode, Direction);
#endif

#if PROF
    Trie->NumSingleRots++;
#endif

    ASSERT((Direction == LEFT) || (Direction == RIGHT));

    CurrNode = UnbalNode;

    ASSERT(CurrNode != NULL);

    // To rotate right, we need left child and vice versa
    NextNode = CurrNode->Child[-Direction];

    ASSERT(NextNode != NULL);

    //
    // Promote the child to the unbalanced node's position
    //

    PrevNode = CurrNode->Parent;
    if (PrevNode)
    {
        if (PrevNode->Child[LEFT] == CurrNode)
        {
            PrevNode->Child[LEFT] = NextNode;
        }
        else
        {
            PrevNode->Child[RIGHT] = NextNode;
        }
    }
    else
    {
        Trie->TrieRoot = NextNode;
    }

    NextNode->Parent = PrevNode;

    //
    // Shift a subtree of child node to unbalanced node
    //

    CurrNode->Child[-Direction] = NextNode->Child[Direction];
    if (NextNode->Child[Direction])
    {
        NextNode->Child[Direction]->Parent = CurrNode;
    }
    
    //
    // Push unbalanced node as child of the next node
    // in place of this subtree that was moved before
    //

    NextNode->Child[Direction] = CurrNode;

    CurrNode->Parent = NextNode;

    //
    // Adjust balances that have changed due to rotation.
    // When this is not accurate, the caller adjusts the
    // balances appropriately upon return from this func.
    //

    CurrNode->Balance = NextNode->Balance = EVEN;

    // Return the next node as the new balanced node
    *BalancedNode = NextNode;

    return;
}


VOID
DoubleRotate(
    IN       PAVL_TRIE                        Trie,
    IN       PAVL_NODE                        UnbalNode,
    IN       AVL_BALANCE                      Direction,
    OUT      PAVL_NODE                       *BalancedNode
)
{
    PAVL_NODE         PrevNode;
    PAVL_NODE         CurrNode;
    PAVL_NODE         NextNode;
    PAVL_NODE         LastNode;

#if _DBG_
    Print("Double Rotate Called: %p %02x\n", UnbalNode, Direction);
#endif

#if PROF
    Trie->NumDoubleRots++;
#endif

    ASSERT((Direction == LEFT) || (Direction == RIGHT));

    CurrNode = UnbalNode;

    ASSERT(CurrNode != NULL);

    //
    // To rotate right, we need left child and its right child
    //

    NextNode = CurrNode->Child[-Direction];

    ASSERT(NextNode != NULL);

    LastNode = NextNode->Child[Direction];
  
    ASSERT(LastNode != NULL);

    //
    // Move grandchild's children to other nodes higher up
    //

    CurrNode->Child[-Direction] = LastNode->Child[Direction];
    if (LastNode->Child[Direction])
    {
        LastNode->Child[Direction]->Parent = CurrNode;
    }

    NextNode->Child[Direction] = LastNode->Child[-Direction];
    if (LastNode->Child[-Direction])
    {
        LastNode->Child[-Direction]->Parent = NextNode;
    }

    //
    // Adjust the balances after the above node movements
    //

    CurrNode->Balance = EVEN;
    NextNode->Balance = EVEN;
    
    if (LastNode->Balance == LEFT)
    {
        if (Direction == LEFT)
        {
            NextNode->Balance = RIGHT;
        }
        else
        {
            CurrNode->Balance = RIGHT;
        }
    }
    else
    if (LastNode->Balance == RIGHT)
    {
        if (Direction == LEFT)
        {
            CurrNode->Balance = LEFT;
        }
        else
        {
            NextNode->Balance = LEFT;
        }
    }

    //
    // Promote grandchild to the unbalanced node's position
    //

    PrevNode = CurrNode->Parent;

    LastNode->Parent = PrevNode;

    if (PrevNode)
    {
        if (PrevNode->Child[LEFT] == CurrNode)
        {
            PrevNode->Child[LEFT] = LastNode;
        }
        else
        {
            PrevNode->Child[RIGHT] = LastNode;
        }
    }
    else
    {
        Trie->TrieRoot = LastNode;
    }

    LastNode->Child[-Direction] = NextNode;
    NextNode->Parent = LastNode;
  
    LastNode->Child[Direction] = CurrNode;
    CurrNode->Parent = LastNode;
    
    LastNode->Balance = EVEN;

    // The grandchild node is the new balanced node now

    *BalancedNode = LastNode;

    return;
}


VOID
SwapWithSuccessor(
    IN       PAVL_TRIE                        Trie,
    IN OUT   PAVL_CONTEXT                     Context
    )
{
    PAVL_NODE         PrevNode;
    PAVL_NODE         CurrNode;
    PAVL_NODE         NextNode;
    PAVL_NODE         TempNode1;
    PAVL_NODE         TempNode2;
    AVL_BALANCE       NextChild;

    // Get the context before the successor swap
    CurrNode  = Context->BestNode;
    PrevNode  = Context->InsPoint;
    NextChild = Context->InsChild;

    ASSERT(CurrNode->Child[LEFT] && CurrNode->Child[RIGHT]);

    // Find successor (smallest node > this node)
    NextNode = CurrNode->Child[RIGHT];
    while (NextNode->Child[LEFT])
    {
        NextNode = NextNode->Child[LEFT];
    }

    //
    // Save info for swapping node with its successor
    //

    TempNode1 = NextNode->Parent;

    TempNode2 = NextNode->Child[RIGHT];

    //
    // Promote the successor to the node's position
    //

    NextNode->Balance = CurrNode->Balance;

    NextNode->Parent = PrevNode;
    if (PrevNode)
    {
        PrevNode->Child[NextChild] = NextNode;
    }
    else
    {
        Trie->TrieRoot = NextNode;
    }

    NextNode->Child[LEFT] = CurrNode->Child[LEFT];
    NextNode->Child[LEFT]->Parent = NextNode;

    // Is the successor the immediate right child ?
    if (NextNode != CurrNode->Child[RIGHT])
    {
        NextNode->Child[RIGHT] = CurrNode->Child[RIGHT];

        CurrNode->Parent = TempNode1;

        TempNode1->Child[LEFT] = CurrNode;

        NextChild = LEFT;
    }
    else
    {
        NextNode->Child[RIGHT] = CurrNode;
        
        NextChild = RIGHT;
    }

    NextNode->Child[RIGHT]->Parent = NextNode;

    //
    // Put the node in the successor position
    //

    CurrNode->Child[LEFT] = NULL;

    CurrNode->Child[RIGHT] = TempNode2;

    if (CurrNode->Child[RIGHT])
    {
        CurrNode->Child[RIGHT]->Parent = CurrNode;
          
        CurrNode->Balance = RIGHT;
    }
    else
    {
        CurrNode->Balance = EVEN;
    }

    PrevNode = CurrNode->Parent;

    //
    // Adjust prefix relationship between the
    // node and its successor (if it existed)
    //

    if (NextNode->Prefix == CurrNode)
    {
        NextNode->Prefix = CurrNode->Prefix;
    }

    // Update context to reflect the successor swap
    Context->BestNode = CurrNode;
    Context->InsPoint = PrevNode;
    Context->InsChild = NextChild;
    
    return;
}


VOID
AdjustPrefixes(
    IN       PAVL_TRIE                        Trie,
    IN       PAVL_NODE                        OldNode,
    IN       PAVL_NODE                        NewNode,
    IN       PAVL_NODE                        TheNode,
    IN       PLOOKUP_CONTEXT                  Context
    )
{
    PAVL_NODE         CurrNode;
    UINT              NumItems;
    PLOOKUP_LINKAGE   Dummy;
    DWORD             Status;
    INT               Comp;
#if _PROF_
    UINT              NumChecks;
    UINT              NumAdjust;
#endif


#if _DBG_
    Print("Adjust Prefix Called: %p %p %p\n", OldNode, NewNode, TheNode);
#endif

    //
    // If this is part of an insert, we end our prefixes'
    // adjustment when we pass out of the range of the
    // node being inserted, while in the case of delete
    // the range is determined by the node being deleted
    //
    // This node being deleted or inserted is "TheNode"
    //

    ASSERT((OldNode == TheNode) || (NewNode == TheNode));

#if _PROF_
    NumChecks = 0;
    NumAdjust = 0;
#endif

    NumItems = 1;

    do
    {
#if _PROF_
        NumChecks++;
#endif

        Status = 
          EnumOverTable(Trie, NULL, NULL, Context, 0, NULL, &NumItems, &Dummy);

        CurrNode = ((PAVL_CONTEXT) Context)->BestNode;

        if (CurrNode->NumBits > TheNode->NumBits)
        {
            // Did we reach the end of our range ?
            Comp = ComparePartialKeys(CurrNode->KeyBits,
                                      TheNode->KeyBits,
                                      TheNode->NumBits);

            if (Comp > 0)
            {
                break;
            }
            
            if (CurrNode->Prefix == OldNode)
            {
#if _PROF_
                NumAdjust++;
#endif
                CurrNode->Prefix = NewNode;
            }
        }
    }
    while (Status != ERROR_NO_MORE_ITEMS);

#if _PROF_
    Print("Num Checks = %5d, Num Adjusts = %5d\n",
             NumChecks,
             NumAdjust);
#endif
}

//
// Helper Functions - used in CheckTable
//

DWORD
CheckSubTrie(
    IN       PAVL_NODE                        Node,
    OUT      PUSHORT                          Depth
    )
{
    DWORD             Status;
    USHORT            LDepth;
    USHORT            RDepth;

    Status = NO_ERROR;

    *Depth = 0;

#if WRN
    LDepth = 0;
    RDepth = 0;
#endif
    
    if (Node)
    {
        if (SUCCESS(Status))
        {
            Status = CheckSubTrie(Node->Child[LEFT],  &LDepth);
        }

        if (SUCCESS(Status))
        {
            Status = CheckSubTrie(Node->Child[RIGHT], &RDepth);
        }

        if (SUCCESS(Status))
        {
            Status = CheckTrieNode(Node, LDepth, RDepth);

            if (!SUCCESS(Status))
            {
                Print("Inconsistent information @ Node: %p\n",
                          Node);
            }
        }

        if (SUCCESS(Status))
        {
            *Depth = (USHORT)((LDepth > RDepth) ? (LDepth + 1) : (RDepth + 1));
        }
    }

    return Status;
}

DWORD
CheckTrieNode(
    IN       PAVL_NODE                        Node,
    IN       USHORT                           LDepth,
    IN       USHORT                           RDepth
    )
{
    AVL_BALANCE    Balance;

    // Check the balance first w.r.t LDepth and RDepth
    Balance = RDepth - LDepth;

    if ((Balance < -1) || (Balance > 1))
    {
        Print("Balance out of bounds: %d\n", Balance);

        Print("LDepth = %lu, RDepth = %lu, NodeBal = %d\n",
                  LDepth, RDepth, Node->Balance);

        DumpSubTrie(Node);

        return ERROR_INVALID_DATA;
    }

    if (Balance != Node->Balance)
    {
        Print("Balance inconsistent\n");
        return ERROR_INVALID_DATA;
    }

    // Check its child relationship with its parent
    if (Node->Parent)
    {
        if ((Node->Parent->Child[LEFT] != Node) &&
            (Node->Parent->Child[RIGHT] != Node))
        {
            Print("Parent relationship bad\n");
            return ERROR_INVALID_DATA;
        }
    }

    // Check its prefix relationship with its prefix
    if (Node->Prefix)
    {
        if (Node->Prefix->NumBits >= Node->NumBits)
        {
            Print("Prefix relationship bad @1\n");
            return ERROR_INVALID_DATA;
        }
      
        if (ComparePartialKeys(Node->Prefix->KeyBits,
                               Node->KeyBits,
                               Node->Prefix->NumBits) != 0)
        {
            Print("Prefix relationship bad @2\n");
            return ERROR_INVALID_DATA;
        }
    }

    return NO_ERROR;
}

//
// Helper Functions - used in DumpTable
//

VOID
DumpSubTrie(
    IN       PAVL_NODE                        Node
    )
{
    if (Node)
    {
        DumpSubTrie(Node->Child[LEFT]);
        DumpTrieNode(Node);
        DumpSubTrie(Node->Child[RIGHT]);
    }
}

VOID
DumpTrieNode(
    IN       PAVL_NODE                        Node
    )
{
    USHORT         i;

    if (Node)
    {
        Print("TrieNode @ %p: NB = %8d, KB = ", Node, Node->NumBits);

        for (i = 0; i < (Node->NumBits + BITS_IN_BYTE - 1) / BITS_IN_BYTE; i++)
        {
            Print("%3d.", Node->KeyBits[i]);
        }

        Print("\nLeft = %p, Parent = %p, Right = %p\n",
                 Node->Child[LEFT],
                 Node->Parent,
                 Node->Child[RIGHT]);

        Print("Prefix = %p, Data = %p, Balance = %2d\n\n",
                 Node->Prefix,
                 Node->Data,
                 Node->Balance);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\avltrie.h ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    avltrie.h

Abstract:

    Contains interface for a best matching
    prefix lookup using an AVL trie.

Author:

    Chaitanya Kodeboyina (chaitk)   24-Jun-1998

Revision History:

--*/

#ifndef __ROUTING_AVLLOOKUP_H__
#define __ROUTING_AVLLOOKUP_H__

#include "lookup.h"

#define Print                    printf

#define BITS_IN_BYTE           (UINT) 8

//
// Balance factor at an AVL node
//

#define LEFT                        -1
#define EVEN                         0
#define RIGHT                       +1
#define INVALID                    100

typedef INT AVL_BALANCE, *PAVL_BALANCE;

//
// A node in the AVL trie
//
typedef struct _AVL_NODE *PAVL_NODE;

// Disable warnings for unnamed structs
#pragma warning(disable : 4201)  

typedef struct _AVL_NODE
{
    PAVL_NODE         Prefix;           // Node with the next best prefix

    PAVL_NODE         Parent;           // Parent of this AVL trie node

    struct
    {
        PAVL_NODE     LChild;
        union
        {
            PAVL_NODE Child[1];         // Child[-1] = Left, Child[1] = Right

            PVOID     Data;             // Opaque Pointer to data in the node
        };
        PAVL_NODE     RChild;
    };

    AVL_BALANCE       Balance;          // Balance factor at this node

    USHORT            NumBits;          // Actual number of bits in key
    UCHAR             KeyBits[1];       // Value of key bits to compare
}
AVL_NODE;

#pragma warning(default : 4201)  


//
// AVL trie with prefix matching
//
typedef struct _AVL_TRIE
{
    PAVL_NODE         TrieRoot;         // Pointer to the AVL trie
    
    UINT              MaxKeyBytes;      // Max num of bytes in key

    UINT              NumNodes;         // Number of nodes in trie

#if PROF

    ULONG             MemoryInUse;      // Total memory in use now
    UINT              NumAllocs;        // Num of total allocations
    UINT              NumFrees;         // Num of total free allocs

    UINT              NumInsertions;    // Num of total insertions
    UINT              NumDeletions;     // Num of total deletions
    UINT              NumSingleRots;    // Num of single rotations
    UINT              NumDoubleRots;    // Num of double rotations

#endif
}
AVL_TRIE, *PAVL_TRIE;

//
// Lookup context for an AVL trie
//
typedef struct _AVL_CONTEXT
{
    PVOID             BestNode;         // Node with best the matching prefix
    PVOID             InsPoint;         // Node to which new node is attached
    AVL_BALANCE       InsChild;         // Node should attached as this child
}
AVL_CONTEXT, *PAVL_CONTEXT;


//
// Linkage Info Kept in Data
//
typedef struct _AVL_LINKAGE
{
    PAVL_NODE         NodePtr;          // Back pointer to the owning node
}
AVL_LINKAGE, *PAVL_LINKAGE;


#define SET_NODEPTR_INTO_DATA(Data, Node) ((PAVL_LINKAGE)Data)->NodePtr = Node

#define GET_NODEPTR_FROM_DATA(Data)       ((PAVL_LINKAGE)Data)->NodePtr

//
// Key Compare/Copy inlines
//

INT
__inline
CompareFullKeys(
    IN       PUCHAR                          Key1,
    IN       PUCHAR                          Key2,
    IN       UINT                            NumBytes
    )
{
    UINT  Count;

#if _OPT_
    ULONG Temp1;
    ULONG Temp2;

    if (NumBytes == sizeof(ULONG))
    {
        Temp1 = RtlUlongByteSwap(*(ULONG *)Key1);
        Temp2 = RtlUlongByteSwap(*(ULONG *)Key2);

        if (Temp1 > Temp2)
        {
            return +1;
        }

        if (Temp1 < Temp2)
        {
            return -1;
        }

        return 0;
    }
#endif

    Count = NumBytes;

    if (!Count)
    {
        return 0;
    }

    Count--;

    while (Count && (*Key1 == *Key2))
    {
        Key1++;
        Key2++;

        Count--;
    }

    return *Key1 - *Key2;
}

INT
__inline
ComparePartialKeys(
    IN       PUCHAR                          Key1,
    IN       PUCHAR                          Key2,
    IN       USHORT                          NumBits
    )
{
    UINT  Count;

#if _OPT_
    ULONG Temp1;
    ULONG Temp2;

    if (NumBits <= sizeof(ULONG) * BITS_IN_BYTE)
    {
        Count = sizeof(ULONG) * BITS_IN_BYTE - NumBits;
        
        Temp1 = RtlUlongByteSwap(*(ULONG *)Key1) >> Count;
        Temp2 = RtlUlongByteSwap(*(ULONG *)Key2) >> Count;

        if (Temp1 > Temp2)
        {
            return +1;
        }

        if (Temp1 < Temp2)
        {
            return -1;
        }

        return 0;
    }
#endif

    Count = NumBits / BITS_IN_BYTE;

    while (Count && *Key1 == *Key2)
    {
        Key1++;
        Key2++;

        Count--;
    }
  
    if (Count)
    {
        return (*Key1 - *Key2);
    }

    Count = NumBits % BITS_IN_BYTE;

    if (Count)
    {
        Count = BITS_IN_BYTE - Count;

        return (*Key1 >> Count) - (*Key2 >> Count);
    }

    return 0;
}

VOID
__inline
CopyFullKeys(
    OUT      PUCHAR                          KeyDst,
    IN       PUCHAR                          KeySrc,
    IN       UINT                            NumBytes
    )
{
    UINT Count = NumBytes;
  
    while (Count--)
    {
        *KeyDst++ = *KeySrc++;
    }

    return;
}

VOID
__inline
CopyPartialKeys(
    OUT      PUCHAR                          KeyDst,
    IN       PUCHAR                          KeySrc,
    IN       USHORT                          NumBits
    )
{
    UINT Count = (NumBits + BITS_IN_BYTE - 1) / BITS_IN_BYTE;
  
    while (Count--)
    {
        *KeyDst++ = *KeySrc++;
    }

    return;
}

//
// Node Creation and Deletion inlines
//

PAVL_NODE
__inline
CreateTrieNode(
    IN       PAVL_TRIE                       Trie,
    IN       USHORT                          NumBits,
    IN       PUCHAR                          KeyBits,
    IN       PAVL_NODE                       Prefix,
    IN       PLOOKUP_LINKAGE                 Data
    )
{
    PAVL_NODE NewNode;
    UINT      NumBytes;

    NumBytes = FIELD_OFFSET(AVL_NODE, KeyBits) + Trie->MaxKeyBytes;

    NewNode = AllocNZeroMemory(NumBytes);
    if (NewNode)
    {
        NewNode->Prefix = Prefix;

        NewNode->Data = Data;

        SET_NODEPTR_INTO_DATA(Data, NewNode);

        NewNode->Balance = EVEN;

        NewNode->NumBits = NumBits;
        CopyPartialKeys(NewNode->KeyBits,
                        KeyBits, 
                        NumBits);

        Trie->NumNodes++;

#if PROF
        Trie->NumAllocs++;
        Trie->MemoryInUse += NumBytes;
#endif
    }

    return NewNode;
}

VOID
__inline
DestroyTrieNode(
    IN       PAVL_TRIE                       Trie,
    IN       PAVL_NODE                       Node
    )
{
    UINT NumBytes;

    SET_NODEPTR_INTO_DATA(Node->Data, NULL);

    NumBytes = FIELD_OFFSET(AVL_NODE, KeyBits) + Trie->MaxKeyBytes;

    Trie->NumNodes--;

#if PROF
    Trie->NumFrees++;
    Trie->MemoryInUse -= NumBytes;
#endif
    
    FreeMemory(Node);
}

//
// Helper Prototypes
//

VOID
BalanceAfterInsert(
    IN       PAVL_TRIE                        Trie,
    IN       PAVL_NODE                        Node,
    IN       AVL_BALANCE                      Longer
    );

VOID
BalanceAfterDelete(
    IN       PAVL_TRIE                        Trie,
    IN       PAVL_NODE                        Node,
    IN       AVL_BALANCE                      Shorter
    );

VOID
SingleRotate(
    IN       PAVL_TRIE                        Trie,
    IN       PAVL_NODE                        UnbalNode,
    IN       AVL_BALANCE                      Direction,
    OUT      PAVL_NODE                       *BalancedNode
    );

VOID
DoubleRotate(
    IN       PAVL_TRIE                        Trie,
    IN       PAVL_NODE                        UnbalNode,
    IN       AVL_BALANCE                      Direction,
    OUT      PAVL_NODE                       *BalancedNode
    );

VOID
SwapWithSuccessor(
    IN       PAVL_TRIE                        Trie,
    IN OUT   PAVL_CONTEXT                     Context
    );

VOID
AdjustPrefixes(
    IN       PAVL_TRIE                        Trie,
    IN       PAVL_NODE                        OldNode,
    IN       PAVL_NODE                        NewNode,
    IN       PAVL_NODE                        TheNode,
    IN       PLOOKUP_CONTEXT                  Context
    );

DWORD
CheckSubTrie(
    IN       PAVL_NODE                        Node,
    OUT      PUSHORT                          Depth
    );

DWORD
CheckTrieNode(
    IN       PAVL_NODE                        Node,
    IN       USHORT                           LDepth,
    IN       USHORT                           RDepth
    );

VOID
DumpSubTrie(
    IN       PAVL_NODE                        Node
    );

VOID
DumpTrieNode(
    IN       PAVL_NODE                        Node
    );

#endif //__ROUTING_AVLLOOKUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\lkuptst.c ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    lkuptst.c

Abstract:
    Contains routines for testing an implementation
    for the generalized best matching prefix lookup
    interface.

Author:
    Chaitanya Kodeboyina (chaitk) 30-Jun-1998

Revision History:

--*/

#include "lkuptst.h"

//
// Main
//

#if LOOKUP_TESTING

__cdecl
main (
    IN      UINT                            argc,
    IN      CHAR                           *argv[]
    )
{
    CHAR    RouteDatabase[MAX_FNAME_LEN];
    FILE    *FilePtr;
    UINT    NumRoutes;
    Route   InputRoutes[MAXROUTES];
    UINT    i;
    DWORD   Status;

    // Initialize input arguments
    RouteDatabase[0] = '\0';

    for ( i = 1; i < argc - 1; i++ )
    {
        if ( ( argv[i][0] == '-' ) || ( argv[i][0] == '/' ) )
        {
            if (argv[i][2])
            {
                Usage();
            }

            switch (toupper(argv[i][1]))
            {
            case 'D':
                strcpy(RouteDatabase, argv[++i]);
                continue;

            default:
                Usage();
            }
        }
        else
        {
            Usage();
        }
    }

    if (RouteDatabase[0] == '\0')
    {
        Usage();
    }

    if ((FilePtr = fopen(RouteDatabase, "r")) == NULL)
    {
        Fatal("Failed open route database with status = %08x\n",
                           ERROR_OPENING_DATABASE);
    }

    // Print("InputRoutes = %p\n", InputRoutes);
    NumRoutes = ReadRoutesFromFile(FilePtr, MAXROUTES, InputRoutes);
    // Print("InputRoutes = %p\n", InputRoutes);

    fclose(FilePtr);

    Status = WorkOnLookup(InputRoutes,
                          NumRoutes);

    return 0;
}

#endif

DWORD
WorkOnLookup (
    IN      Route                          *InputRoutes,
    IN      UINT                            NumRoutes
    )
{
    Route          *OutputRoute;
    HANDLE          Table;
    UINT            Status;
    UINT            i, j;
    PLOOKUP_LINKAGE linkage;

#if PROF
    HANDLE    Thread;
    UINT      Priority;

    PROFVARS;

    Thread   = GetCurrentThread();
    Priority = GetThreadPriority(Thread);

    SetThreadPriority(Thread, THREAD_PRIORITY_TIME_CRITICAL);
#endif

    // Create and Initialize a new lookup table

#if PROF
    INITPROF;
    STARTPROF;
#endif

    Status = CreateTable(NUMBYTES, &Table);

#if PROF
    STOPPROF;
    ADDPROF;
    PRINTPROF;

    Print("Time for an Initialize Table : %.3f ns\n\n", duration);
#endif

    if (!SUCCESS(Status))
    {
        Fatal("Initialize Failed With Status: %08x\n", Status);
    }

    CheckTable(Table);

    // Compute the total time for inserting all routes

#if PROF
    INITPROF;
    STARTPROF;
#endif

    // Add each route one by one to the table
    for (i = 0; i < NumRoutes ; i++)
    {
        // Print("Inserting Route %6d\n", i + 1);

        Status = InsertIntoTable(Table,
                                 LEN(&InputRoutes[i]),
                                 (PUCHAR) &DEST(&InputRoutes[i]),
                                 NULL,
                                 &InputRoutes[i].backptr);

        // CheckTable(Table);

        if (!SUCCESS(Status))
        {
            Print("Inserting item %08x/%08x, but got an error",
                             DEST(&InputRoutes[i]),
                             MASK(&InputRoutes[i]));

            Fatal("Insert Failed With Status: %08x\n", Status);
        }
    }

#if PROF
    STOPPROF;
    ADDPROF;
#endif

    // Subtract from above the for - loop overhead
#if PROF
    STARTPROF;
#endif

    for (i = 0; i < NumRoutes ; i++) { ; }

#if PROF
    STOPPROF;
    SUBPROF;

    Print("Avg Time for an Insert Table : %.3f ns for %d routes\n\n",
                         duration/i, i);
#endif

    CheckTable(Table);

#ifdef _DBG_
    DumpTable(Table, VERBOSE);
#endif

#ifdef _DBG_
    EnumerateAllRoutes(Table);
#endif

#ifdef _DBG_
    ReadAddrAndGetRoute(Table);
#endif

    // Compute the total time for searching all routes
#if PROF
    INITPROF;
    STARTPROF;
#endif

    for (i = 0; i < NumRoutes ; i++)
    {
        Status = SearchInTable(Table,
                               LEN(&InputRoutes[i]),
                               (PUCHAR) &DEST(&InputRoutes[i]),
                               NULL,
                               &linkage);

        if (!SUCCESS(Status))
        {
            Print("Searching for %08x/%08x, but got an error\n",
                             DEST(&InputRoutes[i]),
                             MASK(&InputRoutes[i]));

            Fatal("Search Failed With Status: %08x\n", Status);
        }

        OutputRoute = CONTAINING_RECORD(linkage, Route, backptr);

        if (OutputRoute != &InputRoutes[i])
        {
            if ((DEST(OutputRoute) != DEST(&InputRoutes[i])) ||
                (MASK(OutputRoute) != MASK(&InputRoutes[i])))
            {
                Print("Searching for %08x/%08x, but got %08x/%08x\n",
                             DEST(&InputRoutes[i]),
                             MASK(&InputRoutes[i]),
                             DEST(OutputRoute),
                             MASK(OutputRoute));
            }
            else
            {
                // Print("Possible Duplicate Insertion @S\n");
            }
        }
    }

#if PROF
    STOPPROF;
    ADDPROF;
#endif

    // Subtract from above the for - loop overhead
#if PROF
    STARTPROF;
#endif

    for (i = 0; i < NumRoutes ; i++) { ; }

#if PROF
    STOPPROF;
    SUBPROF;

    Print("Avg Time for a  Search Table : %.3f ns for %d routes\n\n",
                              duration/i, i);
#endif

    // Compute the total time for searching all prefixes
#if PROF
    INITPROF;
    STARTPROF;
#endif

    for (i = 0; i < NumRoutes ; i++)
    {
        Status = BestMatchInTable(Table,
                                  (PUCHAR) &DEST(&InputRoutes[i]),
                                  &linkage);

        OutputRoute = CONTAINING_RECORD(linkage, Route, backptr);

        if (!SUCCESS(Status))
        {
            Print("Searching for %08x, but got an error\n",
                             DEST(&InputRoutes[i]));

            Fatal("Search Failed With Status: %08x\n", Status);
        }

        if (OutputRoute != &InputRoutes[i])
        {
            if (DEST(OutputRoute) != DEST(&InputRoutes[i]))
            {
                Print("Searching for %08x, but got %08x/%08x\n",
                             DEST(&InputRoutes[i]),
                             DEST(OutputRoute),
                             MASK(OutputRoute));
            }
            else
            {
                // Print("Possible Duplicate Insertion @S\n");
            }
        }
    }

#if PROF
    STOPPROF;
    ADDPROF;
#endif

    // Subtract from above the for - loop overhead
#if PROF
    STARTPROF;
#endif

    for (i = 0; i < NumRoutes ; i++) { ; }

#if PROF
    STOPPROF;
    SUBPROF;

    Print("Avg Time for Prefix in Table : %.3f ns for %d routes\n\n",
                            duration/i, i);
#endif

  // Compute the total time for deleting all routes
#if PROF
    INITPROF;
    STARTPROF;
#endif

    // Del each route one by one to the table
    for (i = 0; i < NumRoutes ; i++)
    {
        // Print("Deleting Route %6d\n", i + 1);

        j = NumRoutes - 1 - i;

        Status = DeleteFromTable(Table,
                                 LEN(&InputRoutes[j]),
                                 (PUCHAR) &DEST(&InputRoutes[j]),
                                 NULL,
                                 &linkage);

        OutputRoute = CONTAINING_RECORD(linkage, Route, backptr);

        // CheckTable(Table);

        if (!SUCCESS(Status))
        {
/*
            Print("Deleting route %08x/%08x, but got an error\n",
                             DEST(&InputRoutes[j]),
                             MASK(&InputRoutes[j]));

            Error("Delete Failed With Status: %08x\n", Status);
*/
        }
        else
        if (OutputRoute != &InputRoutes[j])
        {
            if ((DEST(OutputRoute) != DEST(&InputRoutes[j])) ||
                (MASK(OutputRoute) != MASK(&InputRoutes[j])))
            {
                Print("Deleting route %08x/%08x, but got %08x/%08x\n",
                             DEST(&InputRoutes[j]),
                             MASK(&InputRoutes[j]),
                             DEST(OutputRoute),
                             MASK(OutputRoute));
            }
            else
            {
                // Print("Possible Duplicate Insertion @D\n");
            }
        }
    }

#if PROF
    STOPPROF;
    ADDPROF;
#endif

  // Subtract from above the for - loop overhead
#if PROF
    STARTPROF;
#endif

    for (i = 0; i < NumRoutes ; i++) { j = NumRoutes - 1 - i; }

#if PROF
    STOPPROF;
    SUBPROF;

    Print("Avg Time for a  Delete Table : %.3f ns for %d routes\n\n",
                          duration/i, i);
#endif

    CheckTable(Table);

#ifdef _DBG_
    DumpTable(Table, VERBOSE);
#endif

#ifdef _DBG_
    EnumerateAllRoutes(Table);
#endif

#ifdef _DBG_
    ReadAddrAndGetRoute(Table);
#endif

    // Destory the lookup table

#if PROF
    INITPROF;
    STARTPROF;
#endif

    Status = DestroyTable(Table);

#if PROF
    STOPPROF;
    ADDPROF;
    PRINTPROF;

    Print("Time for a Destroy Table     : %.3f ns\n\n", duration);
#endif

    if (!SUCCESS(Status))
    {
        Fatal("Destroy Failed With Status: %08x\n", Status);
    }

#if PROF
    SetThreadPriority(Thread, Priority);
#endif

    return 0;
}


// Search Testing

VOID
ReadAddrAndGetRoute (
    IN      PVOID                           Table
    )
{
    LOOKUP_CONTEXT  Context;
    FILE           *FilePtr;
    Route          *BestRoute;
    UINT            Status;
    ULONG           Addr;
    PLOOKUP_LINKAGE linkage;

    FilePtr = fopen("con", "r");

    do
    {
        Print("Enter the IP Addr to search for: ");
        ReadIPAddr(FilePtr, &Addr);

        Print("Searching route table for Addr = ");
        PrintIPAddr(&Addr);
        Print("\n");

        Status = SearchInTable(Table,
                               ADDRSIZE,
                               (PUCHAR) &Addr,
                               &Context,
                               &linkage);

        BestRoute = CONTAINING_RECORD(linkage, Route, backptr);

        if (!SUCCESS(Status))
        {
            Fatal("Search Failed With Status: %08x\n", Status);
        }

        Print("The BMP for this addr: \n");
        PrintRoute(BestRoute);
    }
    while (Addr != 0);

    fclose(FilePtr);
}


// Enumerate Testing

VOID
EnumerateAllRoutes (
    IN      PVOID                           Table
    )
{
    LOOKUP_CONTEXT  Context;
    USHORT          NumBits;
    UCHAR           KeyBits[NUMBYTES];
    UINT            Status;
    PLOOKUP_LINKAGE Linkage;
    UINT            NumDests = 1;
    PVOID           DestItems[1];

    Print("\n---------------- ENUMERATION BEGIN ---------------------\n");

    ZeroMemory(&Context, sizeof(LOOKUP_CONTEXT));

    ZeroMemory(&KeyBits, NUMBYTES);
    NumBits = 0;

    do
    {
        Status = EnumOverTable(Table,
                               &NumBits,
                               KeyBits,
                               &Context,
                               0,
                               NULL,
                               &NumDests,
                               &Linkage);

        DestItems[0] = CONTAINING_RECORD(Linkage, Route, backptr);

        if (SUCCESS(Status))
        {
            PrintRoute((Route *)DestItems[0]);
        }
    }
    while (SUCCESS(Status));

    // If it is just an EOF, print last route
    if (Status == ERROR_NO_MORE_ITEMS)
    {
        PrintRoute((Route *)DestItems[0]);
    }

    Print("---------------- ENUMERATION  END  ---------------------\n\n");
}

UINT ReadRoutesFromFile(
    IN      FILE                           *FilePtr,
    IN      UINT                            NumRoutes,
    OUT     Route                          *RouteTable
    )
{
    UINT    i;

    for (i = 0; (!feof(FilePtr)) && (i < NumRoutes) ; )
    {
        // Print("RouteTable = %p\n", RouteTable);
        if (ReadRoute(FilePtr, &RouteTable[i]) != EOF)
        {
            if (RouteTable[i].len)
            {
                ;
            }
            else
            {
                ;
            }

            i++;
        }

        // Print("RouteTable = %p\n", RouteTable);
    }

    if (i >= NumRoutes)
    {
        Error("Number of routes in file exceeds the limit\n",
                   ERROR_MAX_NUM_ROUTES);
    }

    Print("Total number of routes = %lu\n\n", i);

    return i;
}

INT
ReadRoute (
    IN      FILE                           *FilePtr,
    OUT     Route                          *route
    )
{
    UCHAR    currLine[MAX_LINE_LEN];
    UCHAR   *addrBytes;
    UCHAR   *maskBytes;
    UINT     byteRead;
    UINT     byteTemp;
    INT      numConv;
    UINT     i;

    // Zero the input addr, mask, and len
    ClearMemory(route, sizeof(Route));

    // Input format: A1.A2..An/M1.M2..Mn!

    // Read destination IP address
    addrBytes = (UCHAR *) &DEST(route);

    // Read the address A1.A2..An
    for (i = 0; i < NUMBYTES; i++)
    {
        numConv = fscanf(FilePtr, "%d.", &byteRead);

        // Last Line in file
        if (numConv == EOF)
        {
            return EOF;
        }

        // End of Address
        if (numConv == 0)
        {
            break;
        }

        addrBytes[i] = (UCHAR) byteRead;
    }

    // Read the '/' seperator
    fscanf(FilePtr, "%c", &byteRead);

    // Read destination IP mask
    maskBytes = (UCHAR *) &MASK(route);

    // Read the mask M1.M2..Mn
    for (i = 0; i < NUMBYTES; i++)
    {
        numConv = fscanf(FilePtr, "%d.", &byteRead);

        // Incomplete line
        if (numConv == EOF)
        {
            return EOF;
        }

        // End of Mask
        if (numConv == 0)
        {
            break;
        }

        maskBytes[i] = (UCHAR) byteRead;

        // Assume route mask is contiguous
        byteTemp = byteRead;
        while (byteTemp)
        {
            byteTemp &= byteTemp - 1;
            LEN(route)++;
        }
    }

    // Read the ',' seperator
    fscanf(FilePtr, "%c", &byteRead);

    // Read next hop information
    addrBytes = (UCHAR *) &NHOP(route);

    // Read the next hop N1.N2..Nn
    for (i = 0; i < NUMBYTES; i++)
    {
        numConv = fscanf(FilePtr, "%d.", &byteRead);

        // Incomplete line
        if (numConv == EOF)
        {
            return EOF;
        }

        // End of Address
        if (numConv == 0)
        {
            break;
        }

        addrBytes[i] = (UCHAR) byteRead;
    }

    // Read the ',' seperator
    fscanf(FilePtr, "%c", &byteRead);

    // Read interface addr/index
    addrBytes = (UCHAR *) &IF(route);

    // Read the interface I1.I2..In
    for (i = 0; i < NUMBYTES; i++)
    {
        numConv = fscanf(FilePtr, "%d.", &byteRead);

        // Incomplete line
        if (numConv == EOF)
        {
            return EOF;
        }

        // End of Address
        if (numConv == 0)
        {
            break;
        }

        addrBytes[i] = (UCHAR) byteRead;
    }

    // Read the ',' seperator
    fscanf(FilePtr, "%c", &byteRead);

    // Read the route's metric
    fscanf(FilePtr, "%lu", &METRIC(route));

    // Read the rest of the line
    fscanf(FilePtr, "%s\n", currLine);

#ifdef _DBG_
    PrintRoute(route);
#endif

    return TRUE;
}

VOID
PrintRoute (
    IN      Route                          *route
    )
{
    if (NULL_ROUTE(route))
    {
        Print("NULL route\n");
    }
    else
    {
        Print("Route: Len = %2d", LEN(route));

        Print(", Addr = ");
        PrintIPAddr(&DEST(route));

        Print(", NHop = ");
        PrintIPAddr(&NHOP(route));

        Print(", IF = %08x", PtrToInt(IF(route)));

        Print(", Metric = %3lu\n", METRIC(route));
    }
}

INT
ReadIPAddr (
    IN      FILE                           *FilePtr,
    OUT     ULONG                          *addr
    )
{
    UCHAR  *addrBytes;
    UINT    byteRead;
    INT     numConv;
    UINT    i;

    // Initialize the addr variable to 0
    *addr = 0;

    // Cast it for easy byte access
    addrBytes = (UCHAR *)addr;

    // Read the address A1.A2..An
    for (i = 0; i < NUMBYTES; i++)
    {
        numConv = fscanf(FilePtr, "%d.", &byteRead);

        // Last Line in file
        if (numConv == EOF)
        {
            return EOF;
        }

        // End of Address
        if (numConv == 0)
        {
            break;
        }

        addrBytes[i] = (UCHAR) byteRead;
    }

    return 0;
}

VOID
PrintIPAddr (
    IN      ULONG                          *addr
    )
{
    UCHAR    *addrBytes = (UCHAR *) addr;
    UINT     i;

    if (addrBytes)
    {
        for (i = 0; i < NUMBYTES; i++)
        {
            Print("%3d.", addrBytes[i]);
        }
        Print(" ");
    }
    else
    {
        Print("NULL Addr ");
    }
}

VOID
Usage (
    VOID
    )
{
    Fatal("Failed Operation with status = %08x"
          "\n"
          "Tests and measures the IP route lookup mechanism \n"
          "\n"
          "Usage: \n"
          "\t lkuptst \t [ -d routing_database      ]  \n"
          "\n"
          "Options:\n"
          " -d routing_database  \t Name of the route database\n"
          "\n",
          ERROR_WRONG_CMDUSAGE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\lookup.c ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    lookup.h

Abstract:
    Contains routines for a generalized best
    matching prefix lookup data structure.

Author:
    Chaitanya Kodeboyina (chaitk) 20-Jun-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop

#if PAT_TRIE

#include "pattrie.c"

#else

#include "avltrie.c"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\lookup.h ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    lookup.h

Abstract:
    Contains interface for a generalized best
    matching prefix lookup data structure.

Author:
    Chaitanya Kodeboyina (chaitk) 20-Jun-1998

Revision History:

--*/

#ifndef __ROUTING_LOOKUP_H__
#define __ROUTING_LOOKUP_H__

#ifdef __cplusplus
extern "C"
{
#endif

//
// Flags used to control the information dumped by the DumpTable func.
//
#define   SUMMARY       0x00
#define   STATS         0x01
#define   ITEMS         0x02
#define   VERBOSE       0xFF


//
// Field used to link the data item in the lookup structure
// [ Eg: A LIST_ENTRY field is used to link into a d-list ]
//
typedef struct _LOOKUP_LINKAGE
{
    PVOID           Pointer1;            // Usage depends on implementation
    PVOID           Pointer2;            // Usage depends on implementation
}
LOOKUP_LINKAGE, *PLOOKUP_LINKAGE;


//
// Context returned in Search useful in following Inserts and Deletes.
//
// This context remains valid after a search only until the
// read/write lock that is taken for the search is released.
//
typedef struct _LOOKUP_CONTEXT
{
    PVOID           Context1;           // Usage depends on implementation
    PVOID           Context2;           // Usage depends on implementation
    PVOID           Context3;           // Usage depends on implementation
    PVOID           Context4;           // Usage depends on implementation
}
LOOKUP_CONTEXT, *PLOOKUP_CONTEXT;


DWORD
WINAPI
CreateTable(
    IN       UINT                            MaxBytes,
    OUT      HANDLE                         *Table
    );

DWORD
WINAPI
InsertIntoTable(
    IN       HANDLE                          Table,
    IN       USHORT                          NumBits,
    IN       PUCHAR                          KeyBits,
    IN       PLOOKUP_CONTEXT                 Context OPTIONAL,
    IN       PLOOKUP_LINKAGE                 Data
    );

DWORD
WINAPI
DeleteFromTable(
    IN       HANDLE                          Table,
    IN       USHORT                          NumBits,
    IN       PUCHAR                          KeyBits,
    IN       PLOOKUP_CONTEXT                 Context OPTIONAL,
    OUT      PLOOKUP_LINKAGE                *Data
    );

DWORD
WINAPI
SearchInTable(
    IN       HANDLE                          Table,
    IN       USHORT                          NumBits,
    IN       PUCHAR                          KeyBits,
    OUT      PLOOKUP_CONTEXT                 Context OPTIONAL,
    OUT      PLOOKUP_LINKAGE                *Data
    );

DWORD
WINAPI
BestMatchInTable(
    IN       HANDLE                          Table,
    IN       PUCHAR                          KeyBits,
    OUT      PLOOKUP_LINKAGE                *BestData
    );

DWORD
WINAPI
NextMatchInTable(
    IN       HANDLE                          Table,
    IN       PLOOKUP_LINKAGE                 BestData,
    OUT      PLOOKUP_LINKAGE                *NextBestData
    );

DWORD
WINAPI
EnumOverTable(
    IN       HANDLE                          Table,
    IN OUT   PUSHORT                         StartNumBits,
    IN OUT   PUCHAR                          StartKeyBits,
    IN OUT   PLOOKUP_CONTEXT                 Context     OPTIONAL,
    IN       USHORT                          StopNumBits OPTIONAL,
    IN       PUCHAR                          StopKeyBits OPTIONAL,
    IN OUT   PUINT                           NumItems,
    OUT      PLOOKUP_LINKAGE                *DataItems
    );

DWORD
WINAPI
DestroyTable(
    IN       HANDLE                          Table
    );

DWORD
WINAPI
GetStatsFromTable(
    IN       HANDLE                          Table,
    OUT      PVOID                           Stats
    );

BOOL
WINAPI
CheckTable(
    IN       HANDLE                          Table
    );

VOID
WINAPI
DumpTable(
    IN       HANDLE                          Table,
    IN       DWORD                           Flags
    );

#ifdef __cplusplus
}
#endif

#endif //__ROUTING_LOOKUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\makefile.inc ===
$(O)\rtmmsg.mc: ..\mgm\log.h
    mapmsg NET IPMGMLOG_BASE ..\mgm\log.h > $(O)\rtmmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\lkuptst.h ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    lkuptst.h

Abstract:
    Contains routines for testing an implementation
    for the generalized best matching prefix lookup 
    interface.

Author:
    Chaitanya Kodeboyina (chaitk) 30-Jun-1998

Revision History:

--*/

#ifndef __LKUPTST_H
#define __LKUPTST_H

#include "lookup.h"

// Constants
#define MAX_FNAME_LEN               255

#define MAX_LINE_LEN                255

#define BITSINBYTE                  8

#define ADDRSIZE                    32

#define NUMBYTES                    4

#define MAXLEVEL                    32

#define MAXROUTES                   64000

#define ERROR_IPLMISC_BASE          -100

#define ERROR_WRONG_CMDUSAGE        ERROR_IPLMISC_BASE - 1
#define ERROR_OPENING_DATABASE      ERROR_IPLMISC_BASE - 2
#define ERROR_MAX_NUM_ROUTES        ERROR_IPLMISC_BASE - 3

// Macros
#define FHalf(B)        (B) >> 4
#define BHalf(B)        (B) & 0xF

#define Print           printf

#define Assert(S)       assert(S)

#define SUCCESS(S)      (S == NO_ERROR)

#define Error(S, E)     { \
                            fprintf(stderr, S, E); \
                        }

#define Fatal(S, E)     { \
                            fprintf(stderr, S, E); \
                            exit(E); \
                        }

#define ClearMemory(pm, nb) memset((pm), 0, (nb))

#if PROF

#define    PROFVARS     LARGE_INTEGER PCStart; /* PerformanceCountStart */ \
                        LARGE_INTEGER PCStop;  /* PerformanceCountStop  */ \
                        LARGE_INTEGER PCFreq;  /* PerformanceCountFreq  */ \
                        double        timer;                               \
                        double        duration;                            \
                                                                           \
                        QueryPerformanceFrequency(&PCFreq);                \
                        // Print("Perf Counter Resolution = %.3f ns\n\n",  \
                        //     (double) 1000 * 1000 * 1000 / PCFreq.QuadPart);

#define    STARTPROF    QueryPerformanceCounter(&PCStart);

#define    STOPPROF     QueryPerformanceCounter(&PCStop);

#define    INITPROF     duration = 0;


#define    ADDPROF      timer = (double)(PCStop.QuadPart - PCStart.QuadPart) \
                                     * 1000 * 1000 * 1000 / PCFreq.QuadPart; \
                        duration += timer;                                   \
                        // Print("Add : %.3f ns\n\n", timer);


#define    SUBPROF      timer = (double)(PCStop.QuadPart - PCStart.QuadPart) \
                                     * 1000 * 1000 * 1000 / PCFreq.QuadPart; \
                        duration -= timer;                                   \
                        // Print("Sub : %.3f ns\n\n", timer);

#define    PRINTPROF    // Print("Total Time Taken To Finish : %.3f ns\n",   \
                        //          duration);

#endif // if PROF

// Route Structures

typedef ULONG   IPAddr;
typedef ULONG   IPMask;

// A Route Corr. to a Prefix
typedef struct _Route Route;

struct _Route
{
  IPAddr         addr;       // ULONG (32 bits) representing addr
  IPMask         mask;       // ULONG (32 bits) representing mask
  IPAddr         nexthop;    // ULONG (32 bits) for next hop addr
  USHORT         len;        // Num of bits in the address route
  UINT           metric;     // A measure to compare routes with
  PVOID          interface;  // Interface on which packet is sent
  LOOKUP_LINKAGE backptr;    // Points back to the lookup structure
};

// Route Macros

#define  DEST(_pRoute_)        ((_pRoute_)->addr)
#define  MASK(_pRoute_)        ((_pRoute_)->mask)
#define  NHOP(_pRoute_)        ((_pRoute_)->nexthop)
#define  LEN(_pRoute_)         ((_pRoute_)->len)
#define  METRIC(_pRoute_)      ((_pRoute_)->metric)
#define  IF(_pRoute_)          ((_pRoute_)->interface)

#define  NULL_ROUTE(_pRoute_)  (_pRoute_ == NULL)

// Prototypes

DWORD 
WorkOnLookup (
    IN      Route                          *InputRoutes,
    IN      UINT                            NumRoutes
    );

VOID 
ReadAddrAndGetRoute (
    IN      PVOID                           Table
    );

VOID 
EnumerateAllRoutes (
    IN      PVOID                           Table
    );

UINT ReadRoutesFromFile(
    IN      FILE                           *FilePtr,
    IN      UINT                            NumRoutes,
    OUT     Route                          *RouteTable
    );

INT 
ReadRoute (
    IN      FILE                           *FilePtr,
    OUT     Route                          *route 
    );

VOID 
PrintRoute (
    IN      Route                          *route
    );

INT 
ReadIPAddr (
    IN      FILE                           *FilePtr,
    OUT     ULONG                          *addr
    );

VOID 
PrintIPAddr (
    IN      ULONG                          *addr
    );

VOID 
Usage (
    VOID
    );

#endif // __LKUPTST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\pattrie.c ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    avltrie.c

Abstract:

    Contains routines for a best matching
    prefix lookup using an PATRICIA trie.

Author:

    Chaitanya Kodeboyina (chaitk)   24-Jun-1998

Revision History:

--*/

#include "pattrie.h"

DWORD
WINAPI
CreateTable(
    IN       USHORT                          MaxBytes,
    OUT      HANDLE                         *Table
    )
{
    PPAT_TRIE         NewTrie;

    ASSERT(sizeof(PAT_CONTEXT) <= sizeof(LOOKUP_CONTEXT));

    ASSERT(sizeof(PAT_LINKAGE) <= sizeof(DATA_ENTRY));

    if (MaxBytes)
    {
        if (NewTrie = AllocNZeroMemory(sizeof(PAT_TRIE)))
        {
            NewTrie->MaxKeyBytes = (MaxBytes + sizeof(ULONG) - 1) / sizeof(ULONG);

#if _PROF_
            NewTrie->MemoryInUse = sizeof(PAT_TRIE);
#endif

            *Table = NewTrie;

            return NO_ERROR;
        }
        else // if (NewTrie == NULL)
        {
            *Table = NULL;
          
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else // (if MaxBytes == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }
}


DWORD
WINAPI
SearchInTable(
    IN       HANDLE                          Table,
    IN       USHORT                          NumBits,
    IN       PUCHAR                          KeyBits,
    OUT      PLOOKUP_CONTEXT                 Context OPTIONAL,
    OUT      PDATA_ENTRY                    *Data
)
{
    PPAT_TRIE         Trie;
    PPAT_NODE         PrevNode;
    PPAT_NODE         CurrNode;
    PPAT_NODE         BestNode;
    PAT_CHILD         NextChild;
    ULONG             Key;
#if _PROF_
    UINT              NumTravs1;
    UINT              NumTravs2;
#endif

    Trie = Table;

#if DBG
    if (NumBits > Trie->MaxKeyBytes * BITS_IN_BYTE)
    {
        *Data = NULL;

        return ERROR_INVALID_PARAMETER;
    }
#endif

#if _PROF_
    NumTravs1 = 0;
    NumTravs2 = 0;
#endif

    //
    // Go down the search trie matching the
    // next set of bits in key as u do so
    //

    Key = RtlUlongByteSwap(KeyBits);

    CurrNode = Trie->TrieRoot;
    PrevNode = NULL;

    NextChild = LCHILD;

    BestNode = NULL;

    while (CurrNode)
    {
#if _PROF_
        NumTravs1++;

        if (CurrNode->Data)
        {
            NumTravs2++;
        }
#endif
    }

    return NO_ERROR;
}

DWORD
WINAPI
BestMatchInTable(
    IN       HANDLE                          Table,
    IN       PUCHAR                          KeyBits,
    OUT      PDATA_ENTRY                    *BestData
)
{
    PPAT_TRIE         Trie;
    PPAT_NODE         CurrNode;
    PAT_CHILD         NextChild;
    UINT              BitsLeft;
    ULONG             Key;
    ULONG             CurrMask;
    ULONG             CurrBits;
#if _PROF_
    UINT              NumTravs1;
    UINT              NumTravs2;  
#endif

    *BestData = NULL;

    Trie = Table;

    BytesLeft = Trie->MaxKeyBytes;

#if _PROF_
    NumTravs1 = 0;
    NumTravs2 = 0;
#endif

    //
    // Go down trie after trie until all bits done
    //

    while (BytesLeft)
    {
        //
        // Get the key for the next trie search
        //

        Key = RtlUlongByteSwap(*(ULONG *)KeyBits);

        KeyBits  += sizeof(ULONG);

        BytesLeft -= sizeof(ULONG);

        //
        // Go down the current search trie
        //

        CurrNode = Trie->TrieRoot;

        BitsLeft = sizeof(ULONG) * BITS_IN_BYTE;

        Data = NULL;

        while (CurrNode)
        {
#if _PROF_
            NumTravs1++;

            if (CurrNode->Data)
            {
                NumTravs2++;
            }
#endif

            CurrMask = MaskBits(CurrNode->NumBits);

            CurrBits = CurrNode->KeyBits;

            //
            // Try to match bits in the current node
            //

            if ((Key & CurrMask) != CurrBits)
            {
                // Failed to match this node

                break;
            }

            //
            // Update node with best data so far
            //

            if (CurrNode->Data)
            {
                Data = CurrNode->Data;
            }

            //
            // Go down for more specific match
            //

            BitsLeft -= CurrNode->NumBits;

            Key <<= CurrNode->NumBits;

            NextChild = PickMostSigNBits(Key, 1);

            CurrNode = CurrNode->Child[NextChild];
        }

        //
        // Do we do a full match in this sub-trie
        // & do we have more sub-trees to work on
        //

        if (BitsLeft || (!IS_SUB_TRIE(Data)))
        {
            *BestData = Data;
            break;
        }

        Trie = GET_SUB_TRIE(*BestData);
    }

#if _PROF_
    Print("Num Travs 1 = %5d, Travs 2 = %5d\n",
             NumTravs1,
             NumTravs2);
#endif

    return BitsLeft ? ERROR_NOT_FOUND : NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\pattrie.h ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    pattrie.h

Abstract:

    Contains interface for a best matching
    prefix lookup using an PATRICIA trie.

Author:

    Chaitanya Kodeboyina (chaitk)   26-Sep-1998

Revision History:

--*/

#ifndef __ROUTING_PATLOOKUP_H__
#define __ROUTING_PATLOOKUP_H__

#include "lookup.h"

#define Print                       printf

#define BITS_IN_BYTE                     8 

#define NODE_KEY_SIZE        sizeof(ULONG)

//
// Direction in Iterator
//

#define    LCHILD                        0
#define    RCHILD                        1
#define    PARENT                        2

typedef INT PAT_CHILD, *PPAT_CHILD;

//
// A node in the PAT trie
//
typedef struct _PAT_NODE *PPAT_NODE;

typedef struct _PAT_NODE
{
    PPAT_NODE         Child[2];         // Pointers to left & right child nodes

    PVOID             Data;             // Opaque Pointer to data in the node

    USHORT            NumBits;          // Actual number of bits in this node
    ULONG             KeyBits;          // Value of bits to match in this node
}
PAT_NODE;

//
// PAT trie for prefix matching
//
typedef struct _PAT_TRIE
{
    PPAT_NODE         TrieRoot;         // Pointer to the PAT trie

    USHORT            MaxKeyBytes;      // Max num of bytes in key

    USHORT            NumNodes;         // Number of nodes in trie

#if PROF

    ULONG             MemoryInUse;      // Total memory in use now
    UINT              NumAllocs;        // Num of total allocations
    UINT              NumFrees;         // Num of total free allocs

    UINT              NumInsertions;    // Num of total insertions
    UINT              NumDeletions;     // Num of total deletions

#endif
}
PAT_TRIE, *PPAT_TRIE;

//
// Lookup context for a PAT trie
//
typedef struct _PAT_CONTEXT
{
    PVOID             BestNode;         // Node with best the matching prefix
    PVOID             InsPoint;         // Node to which new node is attached
    PAT_CHILD         InsChild;         // Node should attached as this child
}
PAT_CONTEXT, *PPAT_CONTEXT;

//
// Linkage Info Kept in Data
//
typedef struct _PAT_LINKAGE
{
    PPAT_NODE         NodePtr;          // Back pointer to the owning node
}
PAT_LINKAGE, *PPAT_LINKAGE;


#define SET_NODEPTR_INTO_DATA(Data, Node) ((PPAT_LINKAGE)Data)->NodePtr = Node

#define GET_NODEPTR_FROM_DATA(Data)       ((PPAT_LINKAGE)Data)->NodePtr


//
// Macros for doing bit operations on keys
//

//
// MaskBitsArr[i] = First 'i' bits set to 1
//

const ULONG MaskBitsArr[] =
{
    0x00000000, 0x80000000, 0xC0000000, 0xE0000000,
    0xF0000000, 0xF8000000, 0xFC000000, 0xFE000000,
    0xFF000000, 0xFF800000, 0xFFC00000, 0xFFE00000,
    0xFFF00000, 0xFFF80000, 0xFFFC0000, 0xFFFE0000,
    0xFFFF0000, 0xFFFF8000, 0xFFFFC000, 0xFFFFE000,
    0xFFFFF000, 0xFFFFF800, 0xFFFFFC00, 0xFFFFFE00,
    0xFFFFFF00, 0xFFFFFF80, 0xFFFFFFC0, 0xFFFFFFE0,
    0xFFFFFFF0, 0xFFFFFFF8, 0xFFFFFFFC, 0xFFFFFFFE,
    0xFFFFFFFF
};

#define    PickMostSigNBits(ul, nb)       ((ul) >> (NODE_KEY_SIZE - nb))

#define    MaskBits(nb)                   MaskBitsArr[nb]

//
// Key Compare/Copy inlines
//

// Disable warnings for no return value
#pragma warning(disable:4035)

__inline 
ULONG
RtmUlongByteSwap(
    IN  ULONG    Value
    )
{
    __asm 
        {
            mov     eax, Value
            bswap   eax
        }
}

#pragma warning(default:4035)

#define RtlUlongByteSwap RtmUlongByteSwap

#endif //__ROUTING_PATLOOKUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\pchrtm.h ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    pchrtm.h

Abstract:
    Precompiled Header for Routing Table Manager v2 DLL

Author:
    Chaitanya Kodeboyina (chaitk) 1-Jun-1998

Revision History:

--*/

//
// NT OS Headers
//

// Disable compiler warnings in public header files
#pragma warning(disable: 4115)

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winbase.h>
#include <stdio.h>
#include <stdlib.h>

#include <winsock2.h>

#include <rtutils.h>

#include "sync.h"

#include "rtmv1rtm.h"
#include "mgmrtm.h"

#pragma warning(default: 4115)


//
// RTMv2 Headers
//

// Disable warnings for `do { ; } while (FALSE);'
#pragma warning(disable: 4127)

// Disable warnings for cases of failing to inline
#pragma warning(disable: 4710)

// Disable warnings for probable unreachable code
#pragma warning(disable: 4702)

#include "rtmv2.h"

#include "rtmconst.h"

#include "rtmglob.h"

#include "rtmlog.h"
#include "rtmdbg.h"

#include "rtmmain.h"
#include "rtmcnfg.h"
#include "rtmmgmt.h"

#include "lookup.h"

#include "rtmregn.h"

#include "rtmrout.h"
#include "rtminfo.h"

#include "rtmtimer.h"

#include "rtmenum.h"

#include "rtmchng.h"

#include "rtmlist.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\rtm1to2.c ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtm1to2.c

Abstract:

    Contains routines that wrap RTMv2 functions
    in the RTMv1 API.

Author:

    Chaitanya Kodeboyina (chaitk)   13-Oct-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop

#if WRAPPER

#include "rtm1to2.h"

// Wrapper Globals
V1_GLOBAL_INFO  V1Globals;

DWORD
RtmCreateRouteTable (
    IN      DWORD                           ProtocolFamily,
    IN      PRTM_PROTOCOL_FAMILY_CONFIG     Config
    )

/*++

Routine Description:

    Triggers the creation of a new route table corresponding
    to a protocol family (same as address family in RTMv2) 
    in the default instance of RTMv2 by performing the very 
    first registration in that protocol family.

    This default registration is also used for mapping RTMv1
    operations that do not require a registration handle 
    (V1 enums etc.) to their corresponding RTMv2 operations.
    Note that all RTMv2 calls require a registration handle.

    This call also creates a list of all V1 registrations at
    any time. This is used to automatically deregister all 
    RTMv1 registrations before destroying this route table.

    We also set up the notification of changes in best routes
    to the router manager (RM) that invoked this function.

Arguments:

    ProtocolFamily - Protocol Family (same as v2 address family)

    Config         - Protocol family's router manager callbacks
                     (Only the "route change callback" and the
                     "validate route callback" funcs are used)

Return Value:

    Status of the operation

--*/

{
    HANDLE           V1RegHandle;
    DWORD            Status;

    //
    // Validate incoming parameters before action
    //

    if (ProtocolFamily >= RTM_NUM_OF_PROTOCOL_FAMILIES)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (V1Globals.PfRegInfo[ProtocolFamily])
    {
        return ERROR_ALREADY_EXISTS;
    }

    //
    // Initialize the lock that guards regns list
    //

    try
    {
        InitializeCriticalSection(&V1Globals.PfRegnsLock[ProtocolFamily]);
    }
    except(EXCEPTION_EXECUTE_HANDLER)
        {
            return GetLastError();
        }

    // Initialize list of regns on protocol family
    InitializeListHead(&V1Globals.PfRegistrations[ProtocolFamily]);

    //
    // Register on behalf of this protocol family
    //
    // This handle is also used for ops that
    // need a handle in RTM v2 but not in v1
    //
    // We are also setting up best route change
    // notifications for RM using its callback
    //

    V1RegHandle = RtmpRegisterClient(ProtocolFamily,
                                     V1_WRAPPER_REGN_ID,
                                     Config->RPFC_Change,
                                     NULL,
                                     0);
    if (V1RegHandle == NULL)
    {
        Status = GetLastError();

        DeleteCriticalSection(&V1Globals.PfRegnsLock[ProtocolFamily]);

        return Status;
    }

    V1Globals.PfValidateRouteFunc[ProtocolFamily] = Config->RPFC_Validate;

    V1Globals.PfRegInfo[ProtocolFamily] = GET_POINTER_FROM_HANDLE(V1RegHandle);

    return NO_ERROR;
}


DWORD
RtmDeleteRouteTable (
    IN      DWORD                           ProtocolFamily
    )

/*++

Routine Description:

    Deletes the route table for a particular address family
    after deregistering any active V1 registrations present.
    Note that atleast 1 registration (the wrapper's default
    registration) is active at this point.

    We assume that all RTMv2 protocols have deregistered by
    the time this function is called. We also assume that
    no RTMv1 protocols are trying to register or deregister
    while this function is executing, as we do not hold the
    lock that protects the list of registrations.

Arguments:

    ProtocolFamily - Protocol Family whose table is deleted.

Return Value:

    Status of the operation

--*/

{
    PV1_REGN_INFO    Regn;
    PLIST_ENTRY      Regns;
    DWORD            Status;

    //
    // Validate incoming parameters before action
    //

    if (ProtocolFamily >= RTM_NUM_OF_PROTOCOL_FAMILIES)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (V1Globals.PfRegInfo[ProtocolFamily] == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Deregister existing regns on protocol family
    // including the default regn of the V1 wrapper
    //

    Regns = &V1Globals.PfRegistrations[ProtocolFamily];

    // We have atleast the default regn available
    ASSERT(!IsListEmpty(Regns));

    while (!IsListEmpty(Regns))
    {
        Regn = CONTAINING_RECORD(Regns->Flink, V1_REGN_INFO, RegistrationsLE);

        Status = RtmDeregisterClient(MAKE_HANDLE_FROM_POINTER(Regn));

        ASSERT(Status == NO_ERROR);
    }

    // Free the lock used to guard the regns list
    DeleteCriticalSection(&V1Globals.PfRegnsLock[ProtocolFamily]);

    V1Globals.PfRegInfo[ProtocolFamily] = NULL;

    return NO_ERROR;
}


HANDLE 
WINAPI
RtmRegisterClient (
    IN      DWORD                           ProtocolFamily,
    IN      DWORD                           RoutingProtocol,
    IN      HANDLE                          ChangeEvent OPTIONAL,
    IN      DWORD                           Flags
    )

/*++

Routine Description:

    Registers an RTMv1 client with the default instance and
    given protocol family in RTMv2. Also sets up notification
    of best route changes if caller asks for it.

Arguments:

    ProtocolFamily  - Protocol Family we are registering with.

    RoutingProtocol - Protocol ID of registering component.

    ChangeEvent     - Event to indicate changes in best routes.

    Flags           - RTM_PROTOCOL_SINGLE_ROUTE indicates that
                      this protocol adds atmost one route per
                      destination.

Return Value:

    Registration Handle or NULL ( Use GetLastError() to get error )

--*/

{
    return RtmpRegisterClient(ProtocolFamily,
                              RoutingProtocol,
                              NULL,
                              ChangeEvent,
                              Flags);
}

HANDLE 
RtmpRegisterClient (
    IN      DWORD                           ProtocolFamily,
    IN      DWORD                           RoutingProtocol,
    IN      PROUTE_CHANGE_CALLBACK          ChangeFunc  OPTIONAL,
    IN      HANDLE                          ChangeEvent OPTIONAL,
    IN      DWORD                           Flags
    )

/*++

Routine Description:

    Registers an RTMv1 client with the default instance and
    given protocol family in RTMv2. Also sets up notification
    of best route changes if caller asks for it.

    Note that any protocol that needs to be indicated of best
    -route changes can either specify an event OR a callback
    for this purpose.

Arguments:

    ProtocolFamily  - Protocol Family we are registering with.

    RoutingProtocol - Protocol ID of registering component.

    ChangeFunc      - Callback to indicates changes in best routes.

    ChangeEvent     - Event to indicate changes in best routes.

    Flags           - RTM_PROTOCOL_SINGLE_ROUTE indicates that 
                      this component keeps atmost one route per 
                      network (destination in RTMv2) in RTM.

Return Value:

    Registration Handle or NULL ( Use GetLastError() to get error )

--*/

{
    PV1_REGN_INFO    V1Regn;
    RTM_ENTITY_INFO  EntityInfo;
    BOOL             LockInited;
    BOOL             Success;
    DWORD            Status;

    //
    // Check parameters for validity (in v1 bounds)
    //

    if ((ProtocolFamily >= RTM_NUM_OF_PROTOCOL_FAMILIES) ||
        (Flags & (~RTM_PROTOCOL_SINGLE_ROUTE)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    //
    // Create a RTMv1->v2 registration wrapper
    //

    V1Regn = (PV1_REGN_INFO) AllocNZeroObject(sizeof(V1_REGN_INFO));

    if (V1Regn == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    LockInited = FALSE;

    do
    {
#if DBG_HDL
        V1Regn->ObjectHeader.TypeSign = V1_REGN_ALLOC;
#endif
        //
        // Register with RTMv2 after mapping input params to RTMv2
        //

        // All v1 registrations fall in default Instance in RTMv2
        EntityInfo.RtmInstanceId = 0; 

        // We need to convert v1 protocol family id to winsock id
        EntityInfo.AddressFamily = ADDRESS_FAMILY[ProtocolFamily];

        // All v1 protocols can register atmost once with RTMv2
        // as they all will use the same "Protocol Instance Id"
        EntityInfo.EntityId.EntityProtocolId = RoutingProtocol;
        EntityInfo.EntityId.EntityInstanceId = V1_PROTOCOL_INSTANCE;

        Status = RtmRegisterEntity(&EntityInfo,
                                   (PRTM_ENTITY_EXPORT_METHODS) NULL,
                                   V2EventCallback,
                                   FALSE,
                                   &V1Regn->Rtmv2Profile,
                                   &V1Regn->Rtmv2RegHandle);

        if (Status != NO_ERROR)
        {
            break;
        }

        //
        // Cache RTMv1 specific params in RTMv1 regn
        //

        V1Regn->ProtocolFamily = ProtocolFamily;

        V1Regn->RoutingProtocol = RoutingProtocol;

        V1Regn->Flags = Flags;

        //
        // Store actual number of views in this regn
        //

        V1Regn->Rtmv2NumViews = V1Regn->Rtmv2Profile.NumberOfViews;

        //
        // Is caller interested in being notified of best route changes ?
        //

        if (/*ARGUMENT_PRESENT*/(ChangeFunc) || ARGUMENT_PRESENT(ChangeEvent))
        {
            if (/*ARGUMENT_PRESENT*/(ChangeFunc))
            {
                // The caller to be notified of changes directly

                V1Regn->NotificationFunc = ChangeFunc;
            }
            else
            {
                // Caller to be notified of changes with an event

                Success = ResetEvent(ChangeEvent);

                if (!Success)
                {
                    Status = GetLastError();
                    break;
                }

                V1Regn->NotificationEvent = ChangeEvent;

                // Initialize lock to syncronize set/reset event
                
                try
                {
                    InitializeCriticalSection(&V1Regn->NotificationLock);

                    LockInited = TRUE;
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        Status = GetLastError();
                        break;
                    }
            }

            //
            // Register for change notifications with v2
            //

            Status = 
                RtmRegisterForChangeNotification(V1Regn->Rtmv2RegHandle,
                                                 RTM_VIEW_MASK_UCAST,
                                                 RTM_CHANGE_TYPE_ALL,
                                                 (PVOID) V1Regn,
                                                 &V1Regn->Rtmv2NotifyHandle);

            if (Status != NO_ERROR)
            {
                break;
            }
        }

        //
        // Stick it in the list of regns on protocol family
        //

        ACQUIRE_V1_REGNS_LOCK(ProtocolFamily);

        InsertHeadList(&V1Globals.PfRegistrations[ProtocolFamily],
                       &V1Regn->RegistrationsLE);

        RELEASE_V1_REGNS_LOCK(ProtocolFamily);

        return MAKE_HANDLE_FROM_POINTER(V1Regn);
    }
    while (FALSE);

    //
    // Some error occured - clean up and return NULL
    //

    if (LockInited)
    {
        DeleteCriticalSection(&V1Regn->NotificationLock);
    }

    if (V1Regn->Rtmv2RegHandle)
    {
        ASSERT(RtmDeregisterEntity(V1Regn->Rtmv2RegHandle) == NO_ERROR);
    }

#if DBG_HDL
    V1Regn->ObjectHeader.TypeSign = V1_REGN_FREED;
#endif

    FreeObject(V1Regn);

    SetLastError(Status);

    return NULL;
}


DWORD 
WINAPI
RtmDeregisterClient (
    IN      HANDLE                          ClientHandle
    )

/*++

Routine Description:

    Deregisters an RTMv1 client from the default instance and
    given protocol family in RTMv2. Also deletes any state
    that the RTMv1 caller left out - routes, nexthops etc.
    and deregisters any change notifications set up during
    registration time.

Arguments:

    ClientHandle - RTMv1 registration handle being deregistered.

Return Value:

    Status of the operation.

--*/

{
    RTM_NEXTHOP_HANDLE  EnumHandle;
    PV1_REGN_INFO       V1Regn;
    HANDLE             *Handles;
    UINT                NumHandles, i;
    BOOL                Success;
    DWORD               Status;

    VALIDATE_V1_REGN_HANDLE(ClientHandle, &V1Regn);

    //
    // Remove the regn from the list of regns on protocol family
    //

    ACQUIRE_V1_REGNS_LOCK(V1Regn->ProtocolFamily);

    RemoveEntryList(&V1Regn->RegistrationsLE);

    RELEASE_V1_REGNS_LOCK(V1Regn->ProtocolFamily);

    do
    {
        // Allocate this var-size handles array on the stack
        Handles = ALLOC_HANDLES(V1Regn->Rtmv2Profile.MaxHandlesInEnum);

        //
        // Remove all the next-hops added by this client protocol 
        //

        Status = RtmCreateNextHopEnum(V1Regn->Rtmv2RegHandle,
                                      0,
                                      NULL,
                                      &EnumHandle);
        if (Status != NO_ERROR)
        {
            break;
        }

        do 
        {
            NumHandles = V1Regn->Rtmv2Profile.MaxHandlesInEnum;

            Status = RtmGetEnumNextHops(V1Regn->Rtmv2RegHandle,
                                        EnumHandle,
                                        &NumHandles,
                                        Handles);
        
            for (i = 0; i < NumHandles; i++)
            {
                ASSERT(RtmDeleteNextHop(V1Regn->Rtmv2RegHandle,
                                        Handles[i],
                                        NULL) == NO_ERROR);
            }
        }
        while (Status == NO_ERROR);

        ASSERT(RtmDeleteEnumHandle(V1Regn->Rtmv2RegHandle, 
                                   EnumHandle) == NO_ERROR);

        //
        // Clean up resources allocated for change processing
        //

        if (V1Regn->NotificationFunc || V1Regn->NotificationEvent)
        {
            // Stop the notification of changes to best routes
            
            Status = 
                RtmDeregisterFromChangeNotification(V1Regn->Rtmv2RegHandle,
                                                    V1Regn->Rtmv2NotifyHandle);
            if (Status != NO_ERROR)
            {
                break;
            }
    
            if (V1Regn->NotificationEvent)
            {
                // Free the lock that serves in syncronization
                DeleteCriticalSection(&V1Regn->NotificationLock);

                // Reset the event to indicate no more changes
                Success = ResetEvent(V1Regn->NotificationEvent);
    
                if (!Success)
                {
                    Status = GetLastError();
                    break;
                }
            }
        }

        //
        // Deregister with RTMv2 using RTMv2 regn handle
        //
        
        Status = RtmDeregisterEntity(V1Regn->Rtmv2RegHandle);

        if (Status != NO_ERROR)
        {
            break;
        }

        //
        // Free resources allocated for the regn wrapper
        //

#if DBG_HDL
        V1Regn->ObjectHeader.TypeSign = V1_REGN_FREED;
#endif

        FreeObject(V1Regn);

        return NO_ERROR;
    }
    while (FALSE);

    //
    // Some error occured - clean up and return status
    //

    ASSERT(FALSE);

    return Status;
}


DWORD 
WINAPI
RtmAddRoute (
    IN      HANDLE                          ClientHandle,
    IN      PVOID                           Route,
    IN      DWORD                           TimeToLive,
    OUT     DWORD                          *Flags         OPTIONAL,
    OUT     PVOID                           CurBestRoute  OPTIONAL,
    OUT     PVOID                           PrevBestRoute OPTIONAL
)

/*++

Routine Description:

    Adds a route to RTMv2 after converting the RTMv1 route to
    RTMv2 format.

    We create a next hop object if one does not exist, and add
    a route through it.

Arguments:

    ClientHandle  - RTMv1 registration handle of the caller.

    Route         - Info for V1 route being added/updated.

    TimeToLive    - Time for which the route is kept in RTM
                    before being deleted (value is seconds).

    THE FOLLOWING PARAMETERS ARE OBSOLETE IN THIS WRAPPER

    Flags         - Returns error if this param is not NULL.

    CurBestRoute  - Returns error if this param is not NULL.

    PrevBestRoute - Returns error if this param is not NULL.

Return Value:

    Status of the operation.

--*/

{
    PV1_REGN_INFO      V1Regn;
    RTM_NET_ADDRESS    DestAddr;
    RTM_ROUTE_INFO     V2RouteInfo;
    RTM_NEXTHOP_INFO   V2NextHopInfo;
    RTM_NEXTHOP_HANDLE V2NextHop;
    DWORD              ChangeFlags;
    DWORD              Status;

    VALIDATE_V1_REGN_HANDLE(ClientHandle, &V1Regn);

    // Protocols specify Flags parameter but don't use it

    *Flags = RTM_NO_CHANGE;

    if (ARGUMENT_PRESENT(CurBestRoute) || ARGUMENT_PRESENT(PrevBestRoute))
    {
        return ERROR_NOT_SUPPORTED;
    }

    //
    // Call back into RM to validate route, set priority
    //

    Status = V1Globals.PfValidateRouteFunc[V1Regn->ProtocolFamily](Route);

    if (Status != NO_ERROR)
    {
        return Status;
    }

    //
    // Create a new next-hop with this interface
    // (if this next-hop is not already present)
    //

    MakeV2NextHopFromV1Route(V1Regn, Route, &V2NextHopInfo);

    V2NextHop = NULL;

    Status = RtmAddNextHop(V1Regn->Rtmv2RegHandle,
                           &V2NextHopInfo,
                           &V2NextHop,
                           &ChangeFlags);

    if (Status != NO_ERROR)
    {
        return Status;
    }

    //
    // Create a new route with the above nexthop
    //
    
    MakeV2RouteFromV1Route(V1Regn, Route, V2NextHop, &DestAddr, &V2RouteInfo);

    //
    // Convert TimeToLive for secs to ms
    //

    if (TimeToLive != INFINITE)
    {
        TimeToLive *= 1000;
            
        if (TimeToLive > (MAXTICKS/2-1))
        {
            TimeToLive = MAXTICKS/2-1;
        }
    }

    // Setup flags that control RTMv2's add route

    ChangeFlags = (V1Regn->Flags & RTM_PROTOCOL_SINGLE_ROUTE) 
                      ? RTM_ROUTE_CHANGE_FIRST : 0;

    //
    // Add the new route using the RTMv2 API call
    //
        
    Status = RtmAddRouteToDest(V1Regn->Rtmv2RegHandle,
                               NULL,
                               &DestAddr,
                               &V2RouteInfo,
                               TimeToLive,
                               NULL,
                               0,
                               NULL,
                               &ChangeFlags);

    //
    // Remove the handle ref we got on the nexthop above
    //

    ASSERT(RtmReleaseNextHops(V1Regn->Rtmv2RegHandle,
                              1,
                              &V2NextHop) == NO_ERROR);
    return Status;
}


DWORD 
WINAPI
RtmDeleteRoute (
    IN      HANDLE                          ClientHandle,
    IN      PVOID                           Route,
    OUT     DWORD                          *Flags        OPTIONAL,
    OUT     PVOID                           CurBestRoute OPTIONAL
    )

/*++

Routine Description:

    Deletes the route in RTMv2 that corresponds to input RTMv1
    route.

Arguments:

    ClientHandle  - RTMv1 registration handle of the caller.

    Route         - Info for V1 route being deleted in RTM.

    THE FOLLOWING PARAMETERS ARE OBSOLETE IN THIS WRAPPER

    Flags         - Returns error if this param is not NULL.

    CurBestRoute  - Returns error if this param is not NULL.

Return Value:

    Status of the operation.

--*/

{
    PV1_REGN_INFO      V1Regn;
    RTM_NET_ADDRESS    DestAddr;
    RTM_ROUTE_INFO     V2RouteInfo;
    RTM_ROUTE_HANDLE   V2Route;
    RTM_NEXTHOP_INFO   V2NextHopInfo;
    RTM_NEXTHOP_HANDLE V2NextHop;
    DWORD              ChangeFlags;
    DWORD              Status;

    VALIDATE_V1_REGN_HANDLE(ClientHandle, &V1Regn);

    // Protocols specify Flags parameter but don't use it

    *Flags = RTM_NO_CHANGE;

    if (ARGUMENT_PRESENT(CurBestRoute))
    {
        return ERROR_NOT_SUPPORTED;
    }

    //
    // Find the next-hop with this interface
    //

    MakeV2NextHopFromV1Route(V1Regn, Route, &V2NextHopInfo);

    V2NextHop = NULL;

    Status = RtmFindNextHop(V1Regn->Rtmv2RegHandle,
                            &V2NextHopInfo,
                            &V2NextHop,
                            NULL);

    if (Status != NO_ERROR)
    {
        return Status;
    }

    //
    // Delete the route with the above nexthop
    //

    MakeV2RouteFromV1Route(V1Regn, Route, V2NextHop, &DestAddr, &V2RouteInfo);

    //
    // We can get this route by matching the route's
    // net addr, its owner and neighbour learnt from
    //

    Status = RtmGetExactMatchRoute(V1Regn->Rtmv2RegHandle,
                                   &DestAddr,
                                   RTM_MATCH_OWNER | RTM_MATCH_NEIGHBOUR,
                                   &V2RouteInfo,
                                   0,
                                   0,
                                   &V2Route);
    if (Status == NO_ERROR)
    {
        //
        // Delete the route found above using the handle
        //
        
        Status = RtmDeleteRouteToDest(V1Regn->Rtmv2RegHandle,
                                      V2Route,
                                      &ChangeFlags);

        if (Status != NO_ERROR)
        {
            // If delete was successful, this deref is automatic

            ASSERT(RtmReleaseRoutes(V1Regn->Rtmv2RegHandle,
                                    1,
                                    &V2Route) == NO_ERROR);
        }

        ASSERT(RtmReleaseRouteInfo(V1Regn->Rtmv2RegHandle,
                                   &V2RouteInfo) == NO_ERROR);
    }

    //
    // Remove the handle ref we got on the nexthop
    //

    ASSERT(RtmReleaseNextHops(V1Regn->Rtmv2RegHandle,
                              1,
                              &V2NextHop) == NO_ERROR);

    return Status;
}


DWORD 
WINAPI
RtmDequeueRouteChangeMessage (
    IN      HANDLE                          ClientHandle,
    OUT     DWORD                          *Flags,
    OUT     PVOID                           CurBestRoute    OPTIONAL,
    OUT     PVOID                           PrevBestRoute   OPTIONAL
    )

/*++

Routine Description:

    Removes a route change message (basically a dest that has
    changed recently) from the client's own queue of pending
    changes to be notified.

    If a best route exists on the dest, RTM_CURRENT_BEST_ROUTE
    is set in flags and CurBestRoute is filled with best info.

    If the dest has no best routes (in unicast view), then the
    flags are set to RTM_PREVIOUS_BEST_ROUTE, and a route with
    correct network address and rest of route info set to some
    dummy info is returned.

    At no point are both flags set (as was the case in RTMv1).

Arguments:

    ClientHandle  - RTMv1 registration handle of the caller.

    THESE HAVE A SLIGHTLY DIFFERENT MEANING IN THE WRAPPER

    Flags         - RTM_NO_CHANGE, RTM_PREVIOUS_BEST_ROUTE 
                    or RTM_CURRENT_BEST_ROUTE

    CurBestRoute  - Info for current best route is filled.
                    ( See routine description just above )

    PrevBestRoute - Info for previous best route is filled.
                    ( See routine description just above )

Return Value:

    Status of the operation.

--*/

{
    PV1_REGN_INFO      V1Regn;
    PRTM_DEST_INFO     DestInfo;
    PRTM_ROUTE_INFO    V2RouteInfo;
    RTM_ROUTE_HANDLE   V2RouteHandle;
    UINT               NumDests;
    DWORD              Status;
    DWORD              Status1;

    VALIDATE_V1_REGN_HANDLE(ClientHandle, &V1Regn);

    *Flags = RTM_NO_CHANGE;


    // Allocate this var-size dest-info on the stack
    DestInfo = ALLOC_DEST_INFO(V1Regn->Rtmv2NumViews, 1);


    if (V1Regn->NotificationEvent)
    {
        //
        // This lock serves to make the RtmGetChangedDests
        // call and resetting of the "more changes" event 
        // a single combined atomic operation, preventing
        // a case when a set gets lost due to a late reset.
        //

        ACQUIRE_V1_NOTIFY_LOCK(V1Regn);
    }


    Status = NO_ERROR;

    NumDests = 0;


    while (Status == NO_ERROR)
    {
        //
        // Release any destination we got in the prev loop
        //

        if (NumDests == 1)
        {
            ASSERT(RtmReleaseChangedDests(V1Regn->Rtmv2RegHandle,
                                          V1Regn->Rtmv2NotifyHandle,
                                          1,
                                          DestInfo) == NO_ERROR);
        }

        //
        // Get the next changed destination for client
        //
        
        NumDests = 1;

        Status = RtmGetChangedDests(V1Regn->Rtmv2RegHandle,
                                    V1Regn->Rtmv2NotifyHandle,
                                    &NumDests,
                                    DestInfo);
        if (NumDests < 1)
        {
            break;
        }

        //
        // Get the current best route for this dest
        //

        V2RouteHandle = DestInfo->ViewInfo[0].Route;

        if (V2RouteHandle != NULL)
        {
            //
            // We have a best route on the changed dest
            // Give the caller the new best route info 
            //

            if (ARGUMENT_PRESENT(CurBestRoute))
            {
                // Get the route's information from RTMv2

                V2RouteInfo = 
                  ALLOC_ROUTE_INFO(V1Regn->Rtmv2Profile.MaxNextHopsInRoute, 1);

                Status1 = RtmGetRouteInfo(V1Regn->Rtmv2RegHandle,
                                          V2RouteHandle,
                                          V2RouteInfo,
                                          NULL);

                if (Status1 != NO_ERROR)
                {
                    // Best Route would have got deleted - get next change
                    continue;
                };

                Status1 = 
                    MakeV1RouteFromV2Route(V1Regn, V2RouteInfo, CurBestRoute);

                ASSERT(RtmReleaseRouteInfo(V1Regn->Rtmv2RegHandle, 
                                           V2RouteInfo) == NO_ERROR);

                if (Status1 != NO_ERROR)
                {
                    // Best Route would have got changed - get next change
                    continue;
                }
            }

            *Flags = RTM_CURRENT_BEST_ROUTE;
        }
        else
        {
            //
            // We have no best route on the changed dest,
            // Give dummy best route info with this dest
            //

            if (ARGUMENT_PRESENT(PrevBestRoute))
            {
                MakeV1RouteFromV2Dest(V1Regn, DestInfo, PrevBestRoute);
            }

            *Flags = RTM_PREVIOUS_BEST_ROUTE;
        }

        //
        // Do we have more changes to process here ?
        //

        if (Status == ERROR_NO_MORE_ITEMS)
        {
            // We have no more changes to notify - reset event if present
            
            if (V1Regn->NotificationEvent)
            {
                ResetEvent(V1Regn->NotificationEvent);
            }

            Status = NO_ERROR;
        }
        else
        {
            // We have more changes to give out - indicate so in status
            
            ASSERT(Status == NO_ERROR);

            Status = ERROR_MORE_DATA;
        }

        break;
    }

    if (NumDests == 1)
    {
        ASSERT(SUCCESS(RtmReleaseChangedDests(V1Regn->Rtmv2RegHandle,
                                              V1Regn->Rtmv2NotifyHandle,
                                              1,
                                              DestInfo)));
    }

    if (V1Regn->NotificationEvent)
    {
        RELEASE_V1_NOTIFY_LOCK(V1Regn);
    }

    return Status;
}


DWORD
V2EventCallback (
    IN      RTM_ENTITY_HANDLE               Rtmv2RegHandle,
    IN      RTM_EVENT_TYPE                  EventType,
    IN      PVOID                           Context1,
    IN      PVOID                           Context2
    )

/*++

Routine Description:

    This is the callback function that gets called when any
    RTMv2 event happens like change notification available,
    route's timed out etc.

    Context1 & Context2 contain event specific information.

Arguments:

    Rtmv2RegHandle  - Regn handle of entity being informed.

    EventType       - Type of event that caused this call.

    Context1        - Context associated with this event.

    Context2        - Context associated with this event.

Return Value:

    Status of the operation being returned to RTMv2

--*/

{
    PV1_REGN_INFO      V1Regn;
    HANDLE             V1RegHandle;
    V1_ROUTE_INFO      CurBestRoute;
    V1_ROUTE_INFO      PrevBestRoute;
    DWORD              Flags;
    DWORD              Status;

    UNREFERENCED_PARAMETER(Rtmv2RegHandle);
    UNREFERENCED_PARAMETER(Context1);

    switch(EventType)
    {
    case RTM_CHANGE_NOTIFICATION:

        V1Regn = (PV1_REGN_INFO) Context2;

        //
        // Signal availability of new changes using either callback or event
        //

        if (V1Regn->NotificationFunc)
        {
            V1RegHandle = MAKE_HANDLE_FROM_POINTER(V1Regn);

            do
            {
                // Get the next change in this regn's queue

                Status = RtmDequeueRouteChangeMessage(V1RegHandle,
                                                      &Flags,
                                                      &CurBestRoute,
                                                      &PrevBestRoute);
                if (Status != ERROR_MORE_DATA)
                {
                    break;
                }

                // Call the notification callback with data
                V1Regn->NotificationFunc(Flags, &CurBestRoute, &PrevBestRoute);
            }
            while (TRUE);

            // Give the final notification call if needed

            if (Status == NO_ERROR)
            {
                // Call the notification callback with data
                V1Regn->NotificationFunc(Flags, &CurBestRoute, &PrevBestRoute);
            }
        }
        else
        {
            //
            // Set event to signal availability of changes
            //

            ASSERT(V1Regn->NotificationEvent);

            ACQUIRE_V1_NOTIFY_LOCK(V1Regn);

            SetEvent(V1Regn->NotificationEvent);

            RELEASE_V1_NOTIFY_LOCK(V1Regn);
        }

        return NO_ERROR;

    case RTM_ROUTE_EXPIRED:

        //
        // Do not handle this route expiry notification.
        // This will automatically cause deletion of the
        // route and the appropriate change notification
        // generated and indicated to all the protocols.
        //

        return ERROR_NOT_SUPPORTED;
    }

    return ERROR_NOT_SUPPORTED;
}


HANDLE
WINAPI
RtmCreateEnumerationHandle (
    IN      DWORD                           ProtocolFamily,
    IN      DWORD                           EnumerationFlags,
    IN      PVOID                           CriteriaRoute
    )

/*++

Routine Description:

    Creates an enumeration on routes in RTM that match the
    appropriate criteria in the input route.

    This call does not need an RTMv1 registration handle,
    so we use the wrapper's default V1 registration with
    RTMv2 to make RTMv2 calls.

    Matching Routes are returned in the order governed the
    following fields -

    ( Dest Address and Mask, Route Preference and Metric )

Arguments:

    ProtocolFamily   - Protocol family of the routes we want

    EnumerationFlags - Flags indicating the criteria to match

    CriteriaRoute    - The route that we are matching against

Return Value:

    Enumeration Handle or NULL ( GetLastError() to get error )

--*/

{
    PV1_REGN_INFO     V1Regn;
    RTM_DEST_HANDLE   DestHandle;
    PRTM_DEST_INFO    DestInfo;
    RTM_NET_ADDRESS   DestAddr;
    PV1_ENUM_INFO     V1Enum;
    PVOID             Network;
    RTM_VIEW_SET      TargetViews;
    ULONG             TempUlong;
    DWORD             EnumFlags;
    DWORD             MatchFlags;
    ULONG             InterfaceIndex;
    DWORD             Status;

    //
    // Validate incoming parameters before action
    //

    if ((ProtocolFamily >= RTM_NUM_OF_PROTOCOL_FAMILIES) ||
        (EnumerationFlags & ~(RTM_ONLY_THIS_NETWORK   |
                              RTM_ONLY_THIS_PROTOCOL  |
                              RTM_ONLY_THIS_INTERFACE |
                              RTM_ONLY_BEST_ROUTES    |
                              RTM_ONLY_OWND_ROUTES    |
                              RTM_INCLUDE_DISABLED_ROUTES)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    // Specify Criteria if these flags are set

    if ((!ARGUMENT_PRESENT(CriteriaRoute)) &&
        (EnumerationFlags & (RTM_ONLY_THIS_NETWORK   |
                             RTM_ONLY_THIS_PROTOCOL  |
                             RTM_ONLY_THIS_INTERFACE)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return NULL;
    }

    V1Regn = V1Globals.PfRegInfo[ProtocolFamily];
    if (V1Regn == NULL)
    {
        SetLastError(ERROR_INVALID_HANDLE);
        return NULL;
    }

    //
    // If we don't need disabled routes, just use unicast view;
    // or use 0 views to get all routes including disabled ones
    //

    if (EnumerationFlags & RTM_INCLUDE_DISABLED_ROUTES)
    {
        TargetViews = RTM_VIEW_MASK_ANY;
    }
    else
    {
        TargetViews = RTM_VIEW_MASK_UCAST;
    }

    //
    // If enuming a certain n/w, check if corr. dest exists
    //

    DestHandle = NULL;

#if WRN
    DestInfo = NULL;
#endif

    if (EnumerationFlags & RTM_ONLY_THIS_NETWORK)
    {
        V1GetRouteNetwork(CriteriaRoute, ProtocolFamily, &Network);

        MakeNetAddress(Network, ProtocolFamily, TempUlong, &DestAddr);

        // Allocate this var-size dest-info on the stack
        DestInfo = ALLOC_DEST_INFO(V1Regn->Rtmv2NumViews, 1);

        Status = RtmGetExactMatchDestination(V1Regn->Rtmv2RegHandle,
                                             &DestAddr,
                                             RTM_BEST_PROTOCOL,
                                             TargetViews,
                                             DestInfo);
        if (Status != NO_ERROR)
        {
            SetLastError(Status);
            return NULL;
        }

        DestHandle = DestInfo->DestHandle;
    }

    do
    {
        //
        // Allocate a V1 enumeration wrapper structure
        //

        V1Enum = (PV1_ENUM_INFO) AllocNZeroObject(sizeof(V1_ENUM_INFO));

        if (V1Enum == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

#if DBG_HDL
        V1Enum->ObjectHeader.TypeSign = V1_ENUM_ALLOC;
#endif
        //
        // Cache RTMv1 specific params in RTMv1 enum
        //

        V1Enum->ProtocolFamily = ProtocolFamily;

        V1Enum->EnumFlags = EnumerationFlags;

        if (ARGUMENT_PRESENT(CriteriaRoute))
        {
            // Convert the V1 criteria into V2 criteria

            V1CopyRoute(V1Enum->CriteriaRoute.Route, 
                        CriteriaRoute, 
                        ProtocolFamily);
        }

        //
        // Create a route enum on a dest or all dests
        //

        if (EnumerationFlags & RTM_ONLY_OWND_ROUTES)
        {
            EnumFlags = RTM_ENUM_OWN_ROUTES;
        }
        else
        {
            EnumFlags = RTM_ENUM_ALL_ROUTES;
        }
        
        MatchFlags = InterfaceIndex = 0;

        // Do we have to enum's routes on an interface

        if (EnumerationFlags & RTM_ONLY_THIS_INTERFACE) 
        {
            MatchFlags = RTM_MATCH_INTERFACE;

            InterfaceIndex = 
                ((PV1_ROUTE_INFO) CriteriaRoute)->XxRoute.RR_InterfaceID;
        }

        Status = RtmCreateRouteEnum(V1Regn->Rtmv2RegHandle,
                                    DestHandle,
                                    TargetViews,
                                    EnumFlags,
                                    NULL,
                                    MatchFlags,
                                    NULL,
                                    InterfaceIndex,
                                    &V1Enum->Rtmv2RouteEnum);
        if (Status != NO_ERROR)
        {
            break;
        }

        //
        // Initialize lock used to serialize enum ops
        //

        try
        {
            InitializeCriticalSection(&V1Enum->EnumLock);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
            {
                Status = GetLastError();
                break;
            }

        //
        // Release the destination info as we are done
        //

        if (EnumerationFlags & RTM_ONLY_THIS_NETWORK)
        {
            ASSERT(SUCCESS(RtmReleaseDestInfo(V1Regn->Rtmv2RegHandle, 
                                              DestInfo)));
        }

        return MAKE_HANDLE_FROM_POINTER(V1Enum);
    }
    while (FALSE);

    //
    // Some error occurred - clean up and return NULL
    //

    if (EnumerationFlags & RTM_ONLY_THIS_NETWORK)
    {
        ASSERT(SUCCESS(RtmReleaseDestInfo(V1Regn->Rtmv2RegHandle, 
                                          DestInfo)));
    }

    if (V1Enum)
    {
        if (V1Enum->Rtmv2RouteEnum)
        {
            ASSERT(SUCCESS(RtmDeleteEnumHandle(V1Regn->Rtmv2RegHandle, 
                                               V1Enum->Rtmv2RouteEnum)));
        }

#if DBG_HDL
        V1Enum->ObjectHeader.TypeSign = V1_ENUM_FREED;
#endif

        FreeObject(V1Enum);
    }

    SetLastError(Status);

    return NULL;
}


DWORD 
WINAPI
RtmEnumerateGetNextRoute (
    IN      HANDLE                          EnumerationHandle,
    OUT     PVOID                           Route
    )

/*++

Routine Description:

    Get the next route in the V1 enumeration (satisfying the
    enumeration critieria).

Arguments:

    EnumerationHandle - Handle that identifies the enumeration

    Route             - Next route is returned in this param

Return Value:

    Status of the operation

--*/

{
    PV1_REGN_INFO     V1Regn;
    RTM_ROUTE_HANDLE  V2Route;
    PV1_ENUM_INFO     V1Enum;
    UINT              NumRoutes;
    BOOL              Match;
    DWORD             Status;

    VALIDATE_V1_ENUM_HANDLE(EnumerationHandle, &V1Enum);

    V1Regn = V1Globals.PfRegInfo[V1Enum->ProtocolFamily];

    // Acquire the enum lock to serialize requests
    ACQUIRE_V1_ENUM_LOCK(V1Enum);

    //
    // Do until you have a matching route or no more routes
    //

    Match = FALSE;

    do 
    {
        // Get next route in enum, and check if it matches

        //
        // Routes are enum'ed in the following order,
        // Network Addr, Route Priority, Route Metric
        //

        NumRoutes = 1;

        Status = RtmGetEnumRoutes(V1Regn->Rtmv2RegHandle,
                                  V1Enum->Rtmv2RouteEnum,
                                  &NumRoutes,
                                  &V2Route);
        if (NumRoutes < 1)
        {
            break;
        }

        Match = MatchCriteriaAndCopyRoute(V1Regn, V2Route, V1Enum, Route);

        ASSERT(SUCCESS(RtmReleaseRoutes(V1Regn->Rtmv2RegHandle,
                                        1,
                                        &V2Route)));
    }
    while (!Match);

    RELEASE_V1_ENUM_LOCK(V1Enum);

    return Match ? NO_ERROR : Status;
}


DWORD 
WINAPI
RtmCloseEnumerationHandle (
    IN      HANDLE                          EnumerationHandle
    )

/*++

Routine Description:

    Closes the enumeration and releases its resources.

Arguments:

    EnumerationHandle - Handle that identifies the enumeration

Return Value:

    Status of the operation

--*/

{
    PV1_REGN_INFO     V1Regn;
    PV1_ENUM_INFO     V1Enum;
    DWORD             Status;

    VALIDATE_V1_ENUM_HANDLE(EnumerationHandle, &V1Enum);

    V1Regn = V1Globals.PfRegInfo[V1Enum->ProtocolFamily];
    
    do
    {
        //
        // Free the RTMv2 route enumeration and resouces
        //

        if (V1Enum->Rtmv2RouteEnum)
        {
            Status = RtmDeleteEnumHandle(V1Regn->Rtmv2RegHandle, 
                                         V1Enum->Rtmv2RouteEnum);

            ASSERT(Status == NO_ERROR);

            V1Enum->Rtmv2RouteEnum = NULL;
        }

        //
        // Free resources allocated for the enum wrapper
        //

        DeleteCriticalSection(&V1Enum->EnumLock);

#if DBG_HDL
        V1Enum->ObjectHeader.TypeSign = V1_ENUM_FREED;
#endif

        FreeObject(V1Enum);

        return NO_ERROR;
    }
    while (FALSE);

    ASSERT(FALSE);

    return Status;
}


DWORD 
WINAPI
RtmGetFirstRoute (
    IN      DWORD                           ProtocolFamily,
    IN      DWORD                           EnumerationFlags,
    IN OUT  PVOID                           Route
    )

/*++

Routine Description:

    Returns the first route in the table that matches the
    criteria.

    This function just opens a new enumeration and gets
    the first route that matches enumeration critiria,
    and closes the enumeration.

Arguments:

    ProtocolFamily   - Protocol family of the route we want

    EnumerationFlags - Flags indicating the criteria to match

    CriteriaRoute    - The route that we are matching against

Return Value:

    Status of the operation

--*/

{
    HANDLE            V1EnumHandle;
    DWORD             Status;

    //
    // Create an enumeration and return the first route in it
    //

    V1EnumHandle = RtmCreateEnumerationHandle(ProtocolFamily,
                                              EnumerationFlags,
                                              Route);
    if (V1EnumHandle == NULL)
    {
        return GetLastError();
    }

    Status = RtmEnumerateGetNextRoute(V1EnumHandle, Route);

    ASSERT(SUCCESS(RtmCloseEnumerationHandle(V1EnumHandle)));

    return Status;
}


DWORD 
WINAPI
RtmGetNextRoute (
    IN      DWORD                           ProtocolFamily,
    IN      DWORD                           EnumerationFlags,
    OUT     PVOID                           Route
    )

/*++

Routine Description:

    Returns the next route in the table that matches the
    criteria.

    The routes in RTMv2 are ordered using the following 
    fields -
    (Dest Address and Mask, Route Preference and Metric)

    If we have 2 routes with identical values for all the
    above fields, then you have no way of knowing which
    of these routes you returned the last time this call
    was made. For this reason, this call is not supported
    in this wrapper.

    One should create an enumeration to actually get the
    next route in the table.

Arguments:

    ProtocolFamily   - Protocol family of the route we want

    EnumerationFlags - Flags indicating the criteria to match

    CriteriaRoute    - The route that we are matching against

Return Value:

    Status of the operation

--*/

{
    UNREFERENCED_PARAMETER(ProtocolFamily);
    UNREFERENCED_PARAMETER(EnumerationFlags);
    UNREFERENCED_PARAMETER(Route);

    return ERROR_NOT_SUPPORTED;
}


DWORD 
WINAPI
RtmBlockDeleteRoutes (
    IN      HANDLE                          ClientHandle,
    IN      DWORD                           EnumerationFlags,
    IN      PVOID                           CriteriaRoute
    )

/*++

Routine Description:

    Deletes all routes in the route table that match the 
    criteria specified.

    Note that if we have multiple instances of a protocol
    running (say RIP), then each version can delete only
    the routes in owns.

Arguments:

    ClientHandle     - RTM v1 registration handle of caller

    EnumerationFlags - Flags indicating the criteria to match

    CriteriaRoute    - The route that we are matching against

Return Value:

    Status of the operation

--*/

{
    PV1_REGN_INFO     V1Regn;

    //
    // Check parameters for validity (in v1 bounds)
    //

    VALIDATE_V1_REGN_HANDLE(ClientHandle, &V1Regn);

    if (EnumerationFlags & ~(RTM_ONLY_THIS_NETWORK | RTM_ONLY_THIS_INTERFACE))
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Deletes only routes of this instance of the protocol
    // Also include all disabled routes in the enumeration
    //

    EnumerationFlags |= (RTM_ONLY_OWND_ROUTES | RTM_INCLUDE_DISABLED_ROUTES);

    //
    // Call block operation to delete all matching routes
    //

    return BlockOperationOnRoutes(V1Regn,
                                  EnumerationFlags,
                                  CriteriaRoute,
                                  MatchCriteriaAndDeleteRoute);
}


BOOL
MatchCriteriaAndDeleteRoute (
    IN      PV1_REGN_INFO                   V1Regn,
    IN      PRTM_ROUTE_HANDLE               V2RouteHandle,
    IN      PV1_ENUM_INFO                   V1Enum
    )

/*++

Routine Description:

    Deletes input route if it matches the enumeration criteria.

    The enumeration criteria returns only routes owned by the
    caller. See RTM_ONLY_OWND_ROUTES in RtmBlockDeleteRoutes.

Arguments:

    V1Regn           - RTM v1 registration info of the caller

    V2RouteHandle    - Handle of the route being considered

    V1Enum           - Enum info that gives matching criteria

Return Value:

    TRUE if you have released input route handle, FALSE if not

--*/

{
    DWORD      ChangeFlags;
    BOOL       Match;
    DWORD      Status;

    Match = MatchCriteria(V1Regn, V2RouteHandle, V1Enum);

    if (Match)
    {
        // Caller can delete the route only if he owns it

        Status = RtmDeleteRouteToDest(V1Regn->Rtmv2RegHandle,
                                      V2RouteHandle,
                                      &ChangeFlags);
        if (Status != NO_ERROR)
        {
            ASSERT(FALSE);

            Match = FALSE;
        }
    }

    return Match;
}


DWORD
WINAPI
RtmBlockSetRouteEnable (
    IN      HANDLE                          ClientHandle,
    IN      DWORD                           EnumerationFlags,
    IN      PVOID                           CriteriaRoute,
    IN      BOOL                            Enable
    )

/*++

Routine Description:

    Enables or disables all routes in the route table that
    match the criteria specified.

    Disabling a route removes it from consideration in all
    best route computations. We do this by adding this 
    route in "no" views in RTMv2. In other words, this
    route is not considered for best route computations
    in any views.

    Note that if we have multiple instances of a protocol
    running (say RIP), then each version can disable or
    enable only the routes it owns.

Arguments:

    ClientHandle     - RTM v1 registration handle of caller

    EnumerationFlags - Flags indicating the criteria to match

    CriteriaRoute    - The route that we are matching against

    Enable           - TRUE to enable, and FALSE to disable

Return Value:

    Status of the operation

--*/

{
    PV1_REGN_INFO     V1Regn;
    DWORD            *Flags;

    VALIDATE_V1_REGN_HANDLE(ClientHandle, &V1Regn);

    if (EnumerationFlags & ~(RTM_ONLY_THIS_NETWORK | RTM_ONLY_THIS_INTERFACE))
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Enable/Disable routes only of this instance of the protocol

    EnumerationFlags |= RTM_ONLY_OWND_ROUTES;

    // If we are enabling routes, get disable routes too

    if (Enable)
    {
        EnumerationFlags |= RTM_INCLUDE_DISABLED_ROUTES;
    }

    //
    // Set the enable/disable flag in the criteria route
    //

    V1GetRouteFlags(CriteriaRoute, V1Regn->ProtocolFamily, Flags);

    if (Enable)
    {
        (*Flags) |=  IP_VALID_ROUTE;
    }
    else
    {
        (*Flags) &= ~IP_VALID_ROUTE;
    }

    //
    // Call block operation to enable/disable all matching routes
    //

    return BlockOperationOnRoutes(V1Regn,
                                  EnumerationFlags,
                                  CriteriaRoute,
                                  MatchCriteriaAndEnableRoute);
}


BOOL
MatchCriteriaAndEnableRoute (
    IN      PV1_REGN_INFO                   V1Regn,
    IN      PRTM_ROUTE_HANDLE               V2RouteHandle,
    IN      PV1_ENUM_INFO                   V1Enum
    )

/*++

Routine Description:

    Enables/disables route if it matches enumeration criteria.

    We enable or disable a route by adding or removing it
    from the unicast view, as we assume that v1 protocols 
    understand only the unicast view. This will work only
    if we enable or disable route owned by caller.

    Enumeration criteria returns only routes owned by caller.
    See RTM_ONLY_OWND_ROUTES in RtmBlockSetRouteEnable.

Arguments:

    V1Regn           - RTM v1 registration info of the caller

    V2RouteHandle    - Handle of the route being considered

    V1Enum           - Enum info that gives matching criteria

Return Value:

    TRUE if you have released input route handle, FALSE if not

--*/

{
    PRTM_ROUTE_INFO V2RoutePointer;
    RTM_VIEW_SET    Views;
    DWORD           ChangeFlags;
    BOOL            Match;
    DWORD          *Flags;
    DWORD           Status;

    Match = MatchCriteria(V1Regn, V2RouteHandle, V1Enum);

    if (!Match)
    {
        return FALSE;
    }

    do
    {
        // Do we need to enable or disable the route ?

        V1GetRouteFlags(&V1Enum->CriteriaRoute, V1Regn->ProtocolFamily, Flags);

        //
        // Remove route from unicast view to disable;
        // add it back to the unicast view to enable
        //

        if ((*Flags) & IP_VALID_ROUTE)
        {
            Views = RTM_VIEW_MASK_UCAST;
        }
        else
        {
            Views = RTM_VIEW_MASK_NONE;
        }

        // 
        // Only the route's owner can lock and update it
        //

        Status = RtmLockRoute(V1Regn->Rtmv2RegHandle,
                              V2RouteHandle,
                              TRUE,
                              &V2RoutePointer);

        if (Status != NO_ERROR)
        {
            break;
        }

        V2RoutePointer->BelongsToViews = Views;

        // Note that we are not preserving timeout value

        Status = RtmUpdateAndUnlockRoute(V1Regn->Rtmv2RegHandle,
                                         V2RouteHandle,
                                         INFINITE,
                                         NULL,
                                         0,
                                         NULL,
                                         &ChangeFlags);

        if (Status != NO_ERROR)
        {
            break;
        }

        return FALSE;
    }
    while (FALSE);

    ASSERT(FALSE);

    return FALSE;
}


DWORD 
WINAPI
RtmBlockConvertRoutesToStatic (
    IN      HANDLE                          ClientHandle,
    IN      DWORD                           EnumerationFlags,
    IN      PVOID                           CriteriaRoute
    )

/*++

Routine Description:

    Makes the caller the owner of all the routes matching
    the input criteria.

    Changing the owner is done by adding a new route for
    each matching route with the same info. The caller
    is the owner of the new route.

Arguments:

    ClientHandle     - RTM v1 registration handle of caller

    EnumerationFlags - Flags indicating the criteria to match

    CriteriaRoute    - The route that we are matching against

Return Value:

    Status of the operation

--*/

{
    PV1_REGN_INFO     V1Regn;

    VALIDATE_V1_REGN_HANDLE(ClientHandle, &V1Regn);

    //
    // In accordance with RTMv1, act only on enabled routes
    //

    EnumerationFlags &= ~RTM_INCLUDE_DISABLED_ROUTES;

    //
    // Call block op to add a new route for each matching one.
    //

    return BlockOperationOnRoutes(V1Regn,
                                  EnumerationFlags,
                                  CriteriaRoute,
                                  MatchCriteriaAndChangeOwner);
}


BOOL
MatchCriteriaAndChangeOwner (
    IN      PV1_REGN_INFO                   V1Regn,
    IN      PRTM_ROUTE_HANDLE               V2RouteHandle,
    IN      PV1_ENUM_INFO                   V1Enum
    )

/*++

Routine Description:

    Makes a copy of the route if it matches the enum criteria.
    The new copy of the route will have the caller as its
    owner. The matching route can then be deleted (if needed).

Arguments:

    V1Regn           - RTM v1 registration info of the caller

    V2RouteHandle    - Handle of the route being considered

    V1Enum           - Enum info that gives matching criteria

Return Value:

    TRUE if you have released input route handle, FALSE if not

--*/

{
    RTM_ENTITY_INFO    EntityInfo;
    PRTM_DEST_INFO     DestInfo;
    PRTM_ROUTE_INFO    V2RouteInfo;
    RTM_NEXTHOP_HANDLE NextHopHandle;
    RTM_NEXTHOP_HANDLE OldNextHop;
    RTM_NEXTHOP_HANDLE OldNeighbour;
    RTM_NEXTHOP_INFO   NextHopInfo;
    RTM_VIEW_SET       BestInViews;
    ULONG              Protocol;
    BOOL               Match;
    DWORD              ChangeFlags;
    DWORD              Status;

    //
    // Get the route's information from RTMv2
    //

    V2RouteInfo = 
        ALLOC_ROUTE_INFO(V1Regn->Rtmv2Profile.MaxNextHopsInRoute, 1);

    Status = RtmGetRouteInfo(V1Regn->Rtmv2RegHandle,
                             V2RouteHandle,
                             V2RouteInfo,
                             NULL);
    
    if (Status != NO_ERROR)
    {
        return FALSE;
    }

    Match = FALSE;

    do
    {
        //
        // Is the route owner already target protocol ?
        //

        if (V2RouteInfo->RouteOwner == V1Regn->Rtmv2RegHandle)
        {
            break;
        }

        //
        // Does it match the criteria route's protocol ?
        //

        if (V1Enum->EnumFlags & RTM_ONLY_THIS_PROTOCOL)
        {
            //
            // Get the protocol type for this route
            //

            Status = RtmGetEntityInfo(V1Regn->Rtmv2RegHandle,
                                      V2RouteInfo->RouteOwner,
                                      &EntityInfo);
            if (Status != NO_ERROR)
            {
                break;
            }

            Protocol = EntityInfo.EntityId.EntityProtocolId;

            Status = RtmReleaseEntityInfo(V1Regn->Rtmv2RegHandle,
                                          &EntityInfo);

            ASSERT(Status == NO_ERROR);

            // Is this the routing protocol we need ?

            if (V1Enum->CriteriaRoute.XxRoute.RR_RoutingProtocol
                    != Protocol)
            {
                break;
            }
        }

        //
        // And does it match other criteria in enum ?
        //

        if (V1Enum->EnumFlags & RTM_ONLY_BEST_ROUTES)
        {
            Status = RtmIsBestRoute(V1Regn->Rtmv2RegHandle,
                                    V2RouteHandle,
                                    &BestInViews);

            if ((BestInViews & RTM_VIEW_MASK_UCAST) == 0)
            {
                break;
            }
        }

        //
        // We are checking only the first next hop
        // as we expect this function to be used
        // only by V1 protocols on their own routes
        //

        ASSERT(V2RouteInfo->NextHopsList.NumNextHops == 1);

        Status = RtmGetNextHopInfo(V1Regn->Rtmv2RegHandle,
                                   V2RouteInfo->NextHopsList.NextHops[0],
                                   &NextHopInfo);

        if (Status != NO_ERROR)
        {
            break;
        }

#if DBG
        // Do we need to match the nexthop intf ?

        if (V1Enum->EnumFlags & RTM_ONLY_THIS_INTERFACE)
        {
            // Compare this next-hops interface with criteria

            if (NextHopInfo.InterfaceIndex ==
                V1Enum->CriteriaRoute.XxRoute.RR_InterfaceID)
            {
                Match = TRUE;
            }

            // We have already done this filtering in RTM v2
            ASSERT(Match == TRUE);
        }
#endif

        // Add the same next hop with a different owner

        if (Match)
        {
            NextHopHandle = NULL;

            do
            {
                Status = RtmAddNextHop(V1Regn->Rtmv2RegHandle,
                                       &NextHopInfo,
                                       &NextHopHandle,
                                       &ChangeFlags);

                if (Status != NO_ERROR)
                {
                    Match = FALSE;
                    break;
                }

                // Allocate this var-size dest-info on the stack
                DestInfo = ALLOC_DEST_INFO(V1Regn->Rtmv2NumViews, 1);

                //
                // Get the destination address corr to handle
                //

                Status = RtmGetDestInfo(V1Regn->Rtmv2RegHandle,
                                        V2RouteInfo->DestHandle,
                                        RTM_BEST_PROTOCOL,
                                        RTM_VIEW_ID_UCAST,
                                        DestInfo);

                if (Status != NO_ERROR)
                {
                    Match = FALSE;
                    break;
                }

                //
                // Add this route again with a different owner
                //

                ChangeFlags = (V1Regn->Flags & RTM_PROTOCOL_SINGLE_ROUTE) 
                                   ? RTM_ROUTE_CHANGE_FIRST : 0;

                // Update route with new next hop neighbour

                OldNeighbour = V2RouteInfo->Neighbour;
                V2RouteInfo->Neighbour = NextHopHandle;

                // Update route with new forwarding next hop

                OldNextHop = V2RouteInfo->NextHopsList.NextHops[0];
                V2RouteInfo->NextHopsList.NextHops[0] = NextHopHandle;

                //
                // Add the new route using the RTMv2 API call
                //
        
                Status = RtmAddRouteToDest(V1Regn->Rtmv2RegHandle,
                                           NULL,
                                           &DestInfo->DestAddress,
                                           V2RouteInfo,
                                           INFINITE,
                                           NULL,
                                           0,
                                           NULL,
                                           &ChangeFlags);
                if (Status != NO_ERROR)
                {
                    Match = FALSE;
                }

                //
                // Restore old information nexthop information
                //

                V2RouteInfo->Neighbour = OldNeighbour;
                V2RouteInfo->NextHopsList.NextHops[0] = OldNextHop;

                Status = RtmReleaseDestInfo(V1Regn->Rtmv2RegHandle,
                                            DestInfo);

                ASSERT(Status == NO_ERROR);
            }
            while (FALSE);

            // If we have a next hop handle, release it

            if (NextHopHandle)
            {
                Status = RtmReleaseNextHops(V1Regn->Rtmv2RegHandle,
                                            1,
                                            &NextHopHandle);
                ASSERT(Status == NO_ERROR);
            }
        }

        Status = RtmReleaseNextHopInfo(V1Regn->Rtmv2RegHandle, &NextHopInfo);

        ASSERT(Status == NO_ERROR);

    }
    while (FALSE);

#if DELETE_OLD

    //
    // Impersonate previous owner and delete his route
    //

    if (Match)
    {
        Status = RtmDeleteRouteToDest(V2RouteInfo->RouteOwner,
                                      V2RouteHandle,
                                      &ChangeFlags);
        if (Status != NO_ERROR)
        {
            // Must have been deleted meanwhile - ignore

            Match = FALSE;
        }
    }

#else

    Match = FALSE;

#endif

    ASSERT(SUCCESS(RtmReleaseRouteInfo(V1Regn->Rtmv2RegHandle, V2RouteInfo)));

    return Match;
}


DWORD 
BlockOperationOnRoutes (
    IN      PV1_REGN_INFO                   V1Regn,
    IN      DWORD                           EnumerationFlags,
    IN      PVOID                           CriteriaRoute,
    IN      PFUNC                           RouteOperation
    )

/*++

Routine Description:

    Performs the route operation specified on each route in
    the table that matches the enumeration criteria.

    The route operation is called with the route handle of
    each matching route. If the operation returns FALSE,
    then the route handle is released, else it is expected
    that the handle was released by the operation itself.

Arguments:

    V1Regn           - RTM v1 registration info of the caller

    EnumerationFlags - Flags indicating the criteria to match

    CriteriaRoute    - The route that we are matching against

    RouteOperation   - Operation performed on matching routes

Return Value:

    Status of the operation

--*/

{
    HANDLE            V1EnumHandle;
    PV1_ENUM_INFO     V1Enum;
    PRTM_ROUTE_HANDLE V2RouteHandles;
    UINT              NumRoutes;
    UINT              i;
    DWORD             Status1;
    DWORD             Status;

    //
    // Create an enumeration to get all matching routes
    //

    V1EnumHandle = RtmCreateEnumerationHandle(V1Regn->ProtocolFamily,
                                              EnumerationFlags,
                                              CriteriaRoute);
    if (V1EnumHandle == NULL)
    {
        return GetLastError();
    }

    VALIDATE_V1_ENUM_HANDLE(V1EnumHandle, &V1Enum);

    //
    // Get list of all  matching routes and call operation
    //

    // Allocate this var-size handles array on the stack
    V2RouteHandles = ALLOC_HANDLES(V1Regn->Rtmv2Profile.MaxHandlesInEnum);

    do 
    {
        // Get next route in enum, and run operation on it

        NumRoutes = V1Regn->Rtmv2Profile.MaxHandlesInEnum;

        Status = RtmGetEnumRoutes(V1Regn->Rtmv2RegHandle,
                                  V1Enum->Rtmv2RouteEnum,
                                  &NumRoutes,
                                  V2RouteHandles);

        for (i = 0; i < NumRoutes; i++)
        {
            if (!RouteOperation(V1Regn, V2RouteHandles[i], V1Enum))
            {
                // Operation not successful - release handle

                Status1 = RtmReleaseRoutes(V1Regn->Rtmv2RegHandle,
                                           1,
                                           &V2RouteHandles[i]);
                ASSERT(SUCCESS(Status1));
            }
        }
    }
    while (Status == NO_ERROR);

    ASSERT(SUCCESS(RtmCloseEnumerationHandle(V1EnumHandle)));

    return (Status == ERROR_NO_MORE_ROUTES) ? NO_ERROR : Status;
}


BOOL
MatchCriteriaAndCopyRoute (
    IN      PV1_REGN_INFO                   V1Regn,
    IN      PRTM_ROUTE_HANDLE               V2RouteHandle,
    IN      PV1_ENUM_INFO                   V1Enum  OPTIONAL,
    OUT     PVOID                           V1Route OPTIONAL
    )

/*++

Routine Description:

    If the input route matches enumeration criteria, it converts
    to a V1 route and copies it to the output buffer.

Arguments:

    V1Regn           - RTM v1 registration info of the caller

    V2RouteHandle    - Handle of the route being considered

    V1Enum           - Enum info that gives matching criteria

    V1Route          - Buffer in which the V1 route is copied

Return Value:

    TRUE if route matches criteria, and FALSE if it does not

--*/

{
    RTM_ENTITY_INFO   EntityInfo;
    PRTM_ROUTE_INFO   V2RouteInfo;
    RTM_VIEW_SET      BestInViews;
    ULONG             Protocol;
    BOOL              Match;
    DWORD             Status;

    //
    // Get the route's information from RTMv2
    //

    V2RouteInfo = 
        ALLOC_ROUTE_INFO(V1Regn->Rtmv2Profile.MaxNextHopsInRoute, 1);

    Status = RtmGetRouteInfo(V1Regn->Rtmv2RegHandle,
                             V2RouteHandle,
                             V2RouteInfo,
                             NULL);
    
    if (Status != NO_ERROR)
    {
        return FALSE;
    }

    //
    // If we have no criteria, we match every route
    //

    if (!ARGUMENT_PRESENT(V1Enum))
    {
        Match = TRUE;
    }
    else
    {
        Match = FALSE;

        do
        {
            if (V1Enum->EnumFlags & RTM_INCLUDE_DISABLED_ROUTES)
            {
                // Is route anything but a unicast or disabled one ?

                if (V2RouteInfo->BelongsToViews & ~RTM_VIEW_MASK_UCAST)
                {
                    break;
                }
            }

            //
            // Does it match the criteria route's protocol ?
            //

            if (V1Enum->EnumFlags & RTM_ONLY_THIS_PROTOCOL)
            {
                //
                // Get the protocol type for this route
                //

                Status = RtmGetEntityInfo(V1Regn->Rtmv2RegHandle,
                                          V2RouteInfo->RouteOwner,
                                          &EntityInfo);

                if (Status != NO_ERROR)
                {
                    break;
                }

                Protocol = EntityInfo.EntityId.EntityProtocolId;

                Status = RtmReleaseEntityInfo(V1Regn->Rtmv2RegHandle,
                                              &EntityInfo);

                ASSERT(Status == NO_ERROR);

                // Is this the routing protocol we need ?

                if (V1Enum->CriteriaRoute.XxRoute.RR_RoutingProtocol
                        != Protocol)
                {
                    break;
                }
            }

            //
            // And does it match other criteria in enum ?
            //

            if (V1Enum->EnumFlags & RTM_ONLY_BEST_ROUTES)
            {
                Status = RtmIsBestRoute(V1Regn->Rtmv2RegHandle,
                                        V2RouteHandle,
                                        &BestInViews);

                if ((BestInViews & RTM_VIEW_MASK_UCAST) == 0)
                {
                    break;
                }
            }

#if DBG
            if (V1Enum->EnumFlags & RTM_ONLY_THIS_INTERFACE)
            {
                RTM_NEXTHOP_INFO  NextHopInfo;
                ULONG             IfIndex;

                //
                // We are checking only the first next hop
                // as we expect this function to be used
                // only by V1 protocols on their own routes
                //

                ASSERT(V2RouteInfo->NextHopsList.NumNextHops == 1);

                Status = 
                    RtmGetNextHopInfo(V1Regn->Rtmv2RegHandle,
                                      V2RouteInfo->NextHopsList.NextHops[0],
                                      &NextHopInfo);

                if (Status != NO_ERROR)
                {
                    break;
                }

                // Get the interface index for this nexthop

                IfIndex = NextHopInfo.InterfaceIndex;

                Status = RtmReleaseNextHopInfo(V1Regn->Rtmv2RegHandle,
                                               &NextHopInfo);

                ASSERT(Status == NO_ERROR);

                // Is this the interface that we are enum'ing
                
                if (IfIndex !=V1Enum->CriteriaRoute.XxRoute.RR_InterfaceID)
                {
                    // We have already done this filtering in RTM v2
                    ASSERT(FALSE);

                    break;
                }
            }
#endif

            Match = TRUE;
        }
        while (FALSE);
    }


    //
    // If we have a match, then make a copy of this route
    //

    if (Match)
    {
        if (ARGUMENT_PRESENT(V1Route))
        {
            Status = MakeV1RouteFromV2Route(V1Regn, V2RouteInfo, V1Route);

            if (Status != NO_ERROR)
            {
                Match = FALSE;
            }
        }
    }

    Status = RtmReleaseRouteInfo(V1Regn->Rtmv2RegHandle, V2RouteInfo);

    ASSERT(Status == NO_ERROR);

    return Match;
}


BOOL
WINAPI
RtmIsRoute (
    IN      DWORD                           ProtocolFamily,
    IN      PVOID                           Network,
    OUT     PVOID                           BestRoute OPTIONAL
    )

/*++

Routine Description:

    Checks the route table corr. to a protocol family
    for the existence of a route to the input network.

Arguments:

    ProtocolFamily - Protocol family of the route table

    Network        - Network address we are trying to reach

    BestRoute      - Best route to the network is filled

Return Value:

    TRUE if a best route exists, FALSE if not, 
    Use GetLastError to check the status code

--*/

{
    PV1_REGN_INFO     V1Regn;
    RTM_ROUTE_HANDLE  V2RouteHandle;
    PRTM_DEST_INFO    DestInfo;
    RTM_NET_ADDRESS   NetAddr;
    BOOL              Match;
    DWORD             Status;

    //
    // Validate incoming parameters before action
    //

    if (ProtocolFamily >= RTM_NUM_OF_PROTOCOL_FAMILIES)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    V1Regn = V1Globals.PfRegInfo[ProtocolFamily];

    if (V1Regn == NULL)
    {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    // Allocate this var-size dest-info on the stack
    DestInfo = ALLOC_DEST_INFO(V1Regn->Rtmv2NumViews, 1);

    MakeNetAddress(Network, TempUlong, ProtocolFamily, &NetAddr);

    Status = RtmGetExactMatchDestination(V1Regn->Rtmv2RegHandle,
                                         &NetAddr,
                                         RTM_BEST_PROTOCOL,
                                         RTM_VIEW_MASK_UCAST,
                                         DestInfo);
    if (Status == NO_ERROR)
    {
        //
        // We have a unicast route to the network
        //

        if (ARGUMENT_PRESENT(BestRoute))
        {
            V2RouteHandle = DestInfo->ViewInfo[0].Route;

            ASSERT(V2RouteHandle != NULL);

            // We have no criteria; so pass NULL for it

            Match = MatchCriteriaAndCopyRoute(V1Regn,
                                              V2RouteHandle,
                                              NULL,
                                              BestRoute);

            ASSERT(Match == TRUE);
        }

        Status = RtmReleaseDestInfo(V1Regn->Rtmv2RegHandle, DestInfo);

        ASSERT(Status == NO_ERROR);

        return TRUE;
    }

    return FALSE;
}


BOOL
WINAPI
RtmLookupIPDestination(
    IN      DWORD                           DestAddr,
    OUT     PRTM_IP_ROUTE                   IPRoute
)

/*++

Routine Description:

    Gets the best non-loopback IP route to the
    input destination address.

Arguments:

    DestAddr  - Network address of the input dest

    IPRoute   - Best non-loopback route is filled

Return Value:

    TRUE if a best route exists, FALSE if not, 
    Use GetLastError to check the status code

--*/

{
    PV1_REGN_INFO     V1Regn;
    RTM_NET_ADDRESS   NetAddr;
    PRTM_DEST_INFO    DestInfo1;
    PRTM_DEST_INFO    DestInfo2;
    DWORD             Status;

    //
    // Validate incoming parameters before action
    //

    V1Regn = V1Globals.PfRegInfo[RTM_PROTOCOL_FAMILY_IP];
    if (V1Regn == NULL)
    {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    // Allocate this var-size dest-infos on the stack

    DestInfo1 = ALLOC_DEST_INFO(V1Regn->Rtmv2NumViews, 1);
    DestInfo2 = ALLOC_DEST_INFO(V1Regn->Rtmv2NumViews, 1);

    // Convert the V1 addr to a V2 net address format

    MakeHostAddress((PUCHAR)&DestAddr, RTM_PROTOCOL_FAMILY_IP, &NetAddr);

    //
    // Get the best route to the input dest
    //

    Status = RtmGetMostSpecificDestination(V1Regn->Rtmv2RegHandle,
                                           &NetAddr,
                                           RTM_BEST_PROTOCOL,
                                           RTM_VIEW_MASK_UCAST,
                                           DestInfo1);

    while (Status == NO_ERROR)
    {
        //
        // Check if this route is a non-loopback one
        //

        if (CopyNonLoopbackIPRoute(V1Regn, DestInfo1, IPRoute))
        {
            break;
        }

        //
        // Backtrack up the tree for next best route
        //

        Status = RtmGetLessSpecificDestination(V1Regn->Rtmv2RegHandle,
                                               DestInfo1->DestHandle,
                                               RTM_BEST_PROTOCOL,
                                               RTM_VIEW_MASK_UCAST,
                                               DestInfo2);

        ASSERT(SUCCESS(RtmReleaseDestInfo(V1Regn->Rtmv2RegHandle, DestInfo1)));

        SWAP_POINTERS(DestInfo1, DestInfo2);
    }

    if (Status == NO_ERROR)
    {
        ASSERT(SUCCESS(RtmReleaseDestInfo(V1Regn->Rtmv2RegHandle, DestInfo1)));

        return TRUE;
    }

    SetLastError(Status);

    return FALSE;
}


BOOL
CopyNonLoopbackIPRoute (
    IN          PV1_REGN_INFO               V1Regn,
    IN          PRTM_DEST_INFO              V2DestInfo,
    OUT         PVOID                       V1Route
    )

/*++

Routine Description:

    Check if the input destination has a non-
    loopback best route, and if so copy route to
    the output buffer after conversion to v1

Arguments:

    V1Regn     - RTMv1 Registration info of caller

    V2DestInfo - Dest whose route we are checking

    V1Route    - Best route is converted to V1
                 and filled if it is not-loopack

Return Value:

    TRUE if best route is non-loopback, or FALSE

--*/

{
    RTM_ROUTE_HANDLE  V2RouteHandle;
    PRTM_ROUTE_INFO   V2RouteInfo;
    BOOL              Match;
    ULONG             Address;
    DWORD             Status;

    //
    // Check if the destination addr is loopback
    // [ Optimized to avoid getting route info ]
    //

    Address = * (ULONG *) V2DestInfo->DestAddress.AddrBits;

    if ((Address & 0x000000FF) == 0x0000007F)
    {
        return FALSE;
    }

    V2RouteHandle = V2DestInfo->ViewInfo[0].Route;

    V2RouteInfo = 
        ALLOC_ROUTE_INFO(V1Regn->Rtmv2Profile.MaxNextHopsInRoute, 1);

    // Get the route's information from RTMv2

    Status = RtmGetRouteInfo(V1Regn->Rtmv2RegHandle,
                             V2RouteHandle,
                             V2RouteInfo,
                             NULL);

    if (Status != NO_ERROR)
    {
        return FALSE;
    };

    // If this is a non-loopback route, copy it

    Match = !(V2RouteInfo->Flags & RTM_ROUTE_FLAGS_LOOPBACK);

    if (Match)
    {
        Status = MakeV1RouteFromV2Route(V1Regn, V2RouteInfo, V1Route);

        if (Status != NO_ERROR)
        {
            Match = FALSE;
        }
    }

    Status = RtmReleaseRouteInfo(V1Regn->Rtmv2RegHandle, V2RouteInfo);

    ASSERT(Status == NO_ERROR);

    return Match;
}


ULONG
WINAPI
RtmGetNetworkCount (
    IN      DWORD                           ProtocolFamily
    )

/*++

Routine Description:

    Get the number of networks (same as RTMv2 destinations)
    in the route table corr. to the input protocol family

Arguments:

    ProtocolFamily - Protocol family of the route table

Return Value:

    Number of destinations, or 0 (Use GetLastError() here)

--*/

{
    RTM_ADDRESS_FAMILY_INFO  AddrFamilyInfo;
    PV1_REGN_INFO            V1Regn;
    UINT                     NumEntities;
    DWORD                    Status;

    do
    {
        //
        // Validate incoming parameters before action
        //

        if (ProtocolFamily >= RTM_NUM_OF_PROTOCOL_FAMILIES)
        {
            Status = ERROR_INVALID_PARAMETER;
            break;
        }

        V1Regn = V1Globals.PfRegInfo[ProtocolFamily];

        if (V1Regn == NULL)
        {
            Status = ERROR_INVALID_HANDLE;
            break;
        }

        //
        // Query the appropriate table for reqd info
        //

        NumEntities = 0;

        Status = RtmGetAddressFamilyInfo(0, // v1 maps to default Instance
                                         ADDRESS_FAMILY[ProtocolFamily],
                                         &AddrFamilyInfo,
                                         &NumEntities,
                                         NULL);

        if (Status != NO_ERROR)
        {
            break;
        }

        return AddrFamilyInfo.NumDests;
    }
    while (FALSE);

    //
    // Some error occured - clean up and return 0
    //

    SetLastError(Status);

    return 0;
}


ULONG 
WINAPI
RtmGetRouteAge (
    IN          PVOID                       Route
    ) 

/*++

Routine Description:

    Computes the age of the route from its creation
    time and the current time in seconds.

    Assumes that the creation time of the route is
    correctly filled in, which is not the case as
    we are currently not keeping a FILETIME in the
    route to save space. If we do keep time, then
    this function would work without any changes.

Arguments:

    Route - Route whose age we want.

Return Value:

     Age of the route in seconds, or FFFFFFFF
     (GetLastError gives error in this case).

--*/

{
    ULONGLONG  CurTime;

    //
    // This code has been directly copied from RTMv1
    //

    GetSystemTimeAsFileTime((FILETIME *)&CurTime);

    CurTime -= * (PULONGLONG) &(((PRTM_IP_ROUTE)Route)->RR_TimeStamp);

    if (((PULARGE_INTEGER)&CurTime)->HighPart<10000000)
    {
        return (ULONG)(CurTime/10000000);
    }
    else 
    {
        SetLastError (ERROR_INVALID_PARAMETER);

        return 0xFFFFFFFF;
    }
}


//
// Common Helper routines
//


VOID 
MakeV2RouteFromV1Route (
    IN          PV1_REGN_INFO               V1Regn,
    IN          PVOID                       V1Route,
    IN          PRTM_NEXTHOP_HANDLE         V2NextHop,
    OUT         PRTM_NET_ADDRESS            V2DestAddr  OPTIONAL,
    OUT         PRTM_ROUTE_INFO             V2RouteInfo OPTIONAL
    )

/*++

Routine Description:

    Converts a route in RTM v1 format to a route in
    the RTM v2 format (at present for IP only).

    The nexthop for the V2 route should have been
    computed before and passed in as a parameter.
    Also see function 'MakeV2NextHopFromV1Route'.

    The function also returns the destination addr
    along with the RTMv2 route info, as the route
    info itself does not contain the dest address.

Arguments:

    V1Regn      - RTMv1 Registration info of caller

    V1Route     - RTMv1 route being converted to V2

    V2NextHop   - The V2 nexthop for the V2 route

    V2DestAddr  - V2 destination addr is filled here

    V2RouteInfo - V2 route information is filled here

Return Value:

    None

--*/

{
    PRTM_IP_ROUTE  IPRoute;
    ULONG          TempUlong;

    //
    // Do conversion for IP alone (worry about IPX later)
    //

    IPRoute = (PRTM_IP_ROUTE) V1Route;
    
    if (ARGUMENT_PRESENT(V2RouteInfo))
    {
        ZeroMemory(V2RouteInfo, sizeof(RTM_ROUTE_INFO));

        // Fill up the V2 Route Info with V1 info

        // Assumes caller is owner of the route
        V2RouteInfo->RouteOwner = V1Regn->Rtmv2RegHandle;

        V2RouteInfo->Neighbour = V2NextHop;

        // Should keep all the V1 flags in the V2 route

        V2RouteInfo->Flags1 = 
            (UCHAR) IPRoute->RR_FamilySpecificData.FSD_Flags;

        // The only flag we understand is the valid flag
        // If route is not valid, we add it to no views

#if DBG
        V2RouteInfo->BelongsToViews = RTM_VIEW_MASK_NONE;
#endif
        if (V2RouteInfo->Flags1 & IP_VALID_ROUTE)
        {
            V2RouteInfo->BelongsToViews = RTM_VIEW_MASK_UCAST;
        }

        if (IsRouteLoopback(IPRoute))
        {
            V2RouteInfo->Flags = RTM_ROUTE_FLAGS_LOOPBACK;
        }

        switch (IPRoute->RR_FamilySpecificData.FSD_Type)
        {
        case 3:
            V2RouteInfo->Flags |= RTM_ROUTE_FLAGS_LOCAL;
            break;

        case 4:
            V2RouteInfo->Flags |= RTM_ROUTE_FLAGS_REMOTE;
            break;            
        }

        V2RouteInfo->PrefInfo.Preference = 
            IPRoute->RR_FamilySpecificData.FSD_Priority;

        V2RouteInfo->PrefInfo.Metric = 
            IPRoute->RR_FamilySpecificData.FSD_Metric;

        // Only the first DWORD is copied by wrapper
        V2RouteInfo->EntitySpecificInfo =
            (PVOID) (ULONG_PTR) IPRoute->RR_ProtocolSpecificData.PSD_Data[0];

        V2RouteInfo->NextHopsList.NumNextHops = 1;
        V2RouteInfo->NextHopsList.NextHops[0] = V2NextHop;
    }
    
    // Fill up the V2 Dest Address with V1 info

    if (ARGUMENT_PRESENT(V2DestAddr))
    {
        MakeNetAddressForIP(&IPRoute->RR_Network, TempUlong, V2DestAddr);
    }

    return;
}


VOID 
MakeV2NextHopFromV1Route (
    IN          PV1_REGN_INFO               V1Regn,
    IN          PVOID                       V1Route,
    OUT         PRTM_NEXTHOP_INFO           V2NextHopInfo
    )

/*++

Routine Description:

    Computes RTMv2 next hop info using the nexthop
    address and interface index in the RTMv1 route.

Arguments:

    V1Regn         - RTMv1 Registration info of caller

    V1Route        - V1 route that is being considered

    V2NextHopInfo  - V2 Next hop info for input route

Return Value:

    None

--*/

{
    PRTM_IP_ROUTE  IPRoute;
    ULONG          TempUlong;

    ZeroMemory(V2NextHopInfo, sizeof(RTM_NEXTHOP_INFO));

    //
    // Do conversion for IP alone (worry about IPX later)
    //

    IPRoute = (PRTM_IP_ROUTE) V1Route;

    //
    // We ignore the next hop mask in the conversion
    //
    //
    // MakeNetAddressForIP(&IPRoute->RR_NextHopAddress, 
    //                    TempUlong,
    //                    &V2NextHopInfo->NextHopAddress);
    //

    UNREFERENCED_PARAMETER(TempUlong);

    MakeHostAddressForIP(&IPRoute->RR_NextHopAddress, 
                         &V2NextHopInfo->NextHopAddress);

    V2NextHopInfo->NextHopOwner = V1Regn->Rtmv2RegHandle;

    V2NextHopInfo->InterfaceIndex = IPRoute->RR_InterfaceID;

    return;
}


VOID
MakeV1RouteFromV2Dest (
    IN          PV1_REGN_INFO               V1Regn,
    IN          PRTM_DEST_INFO              DestInfo,
    OUT         PVOID                       V1Route
    )

/*++

Routine Description:

    Fills a V1 route buffer with the destination addr
    from the V2 route.

Arguments:

    V1Regn         - RTMv1 Registration info of caller

    DestInfo       - Destination info in RTMv2

    V1Route        - V1 route that is being filled in

Return Value:

    None

--*/

{
    PRTM_IP_ROUTE    IPRoute;
    UINT             AddrLen;

    UNREFERENCED_PARAMETER(V1Regn);

    //
    // Do conversion for IP alone (worry about IPX later)
    //

    IPRoute = (PRTM_IP_ROUTE) V1Route;
    
    ZeroMemory(IPRoute, sizeof(RTM_IP_ROUTE));

    //
    // Get the destination addr for this route
    //

    IPRoute->RR_Network.N_NetNumber = 
        * (ULONG *) DestInfo->DestAddress.AddrBits;

    AddrLen = DestInfo->DestAddress.NumBits;

    ASSERT(AddrLen <= 32);
    if (AddrLen != 0)
    {
        IPRoute->RR_Network.N_NetMask = 
            RtlUlongByteSwap((~0) << (32 - AddrLen));
    }

    //
    // Fill in dummy family specific data for route
    //
    // We make the route the least preferred - by
    // minimizing its priority and maximizing its
    // metric - we also treat the route as being
    // valid and added to the stack - this will
    // force router manager to delete the route
    // to this dest in the stack if all routes 
    // to this destination are deleted from RTM.
    //

    IPRoute->RR_FamilySpecificData.FSD_Priority = (ULONG) 0;

    IPRoute->RR_FamilySpecificData.FSD_Metric  = 
    IPRoute->RR_FamilySpecificData.FSD_Metric1 = (ULONG) ~0;

    IPRoute->RR_FamilySpecificData.FSD_Flags = (ULONG) ~0;

    return;
}


DWORD
MakeV1RouteFromV2Route (
    IN          PV1_REGN_INFO               V1Regn,
    IN          PRTM_ROUTE_INFO             V2RouteInfo,
    OUT         PVOID                       V1Route
    )
/*++

Routine Description:

    Converts a route in the RTMv2 format to a V1 route
    ( at present for IP only ).

Arguments:

    V1Regn      - RTMv1 Registration info of caller

    V2RouteInfo - V2 route information being converted

    V1Route     - Buffer in which V1 route is filled

Return Value:

    Status of the operation

--*/

{
    RTM_ENTITY_INFO  EntityInfo;
    PRTM_DEST_INFO   DestInfo;
    PRTM_IP_ROUTE    IPRoute;
    RTM_NEXTHOP_INFO NextHopInfo;
    UINT             AddrLen;
    DWORD            Status;

    //
    // Do conversion for IP alone (worry about IPX later)
    //

    IPRoute = (PRTM_IP_ROUTE) V1Route;
    
    ZeroMemory(IPRoute, sizeof(RTM_IP_ROUTE));

    //
    // Get the routing protocol for this route
    //

    Status = RtmGetEntityInfo(V1Regn->Rtmv2RegHandle,
                              V2RouteInfo->RouteOwner,
                              &EntityInfo);

    if (Status != NO_ERROR)
    {
        return Status;
    }

    IPRoute->RR_RoutingProtocol = EntityInfo.EntityId.EntityProtocolId;

    Status = RtmReleaseEntityInfo(V1Regn->Rtmv2RegHandle,
                                  &EntityInfo);

    ASSERT(Status == NO_ERROR);


    //
    // Get the destination addr for this route
    //

    // Allocate this var-size dest-info on the stack
    DestInfo = ALLOC_DEST_INFO(V1Regn->Rtmv2NumViews, 1);

    Status = RtmGetDestInfo(V1Regn->Rtmv2RegHandle,
                            V2RouteInfo->DestHandle,
                            RTM_BEST_PROTOCOL,
                            RTM_VIEW_ID_UCAST,
                            DestInfo);

    if (Status != NO_ERROR)
    {
        return Status;
    }
    
    IPRoute->RR_Network.N_NetNumber = 
        * (ULONG *) DestInfo->DestAddress.AddrBits;

    AddrLen = DestInfo->DestAddress.NumBits;

    ASSERT(AddrLen <= 32);
    if (AddrLen != 0)
    {
        IPRoute->RR_Network.N_NetMask = 
            RtlUlongByteSwap((~0) << (32 - AddrLen));
    }

    Status = RtmReleaseDestInfo(V1Regn->Rtmv2RegHandle,
                                DestInfo);

    ASSERT(Status == NO_ERROR);


    //
    // Get the next hop address and interface
    //

    ASSERT(V2RouteInfo->NextHopsList.NumNextHops > 0);

    Status = RtmGetNextHopInfo(V1Regn->Rtmv2RegHandle,
                               V2RouteInfo->NextHopsList.NextHops[0],
                               &NextHopInfo);

    if (Status != NO_ERROR)
    {
        return Status;
    }

    IPRoute->RR_InterfaceID = NextHopInfo.InterfaceIndex;

    IPRoute->RR_NextHopAddress.N_NetNumber = 
         * (ULONG *) NextHopInfo.NextHopAddress.AddrBits;

    AddrLen = NextHopInfo.NextHopAddress.NumBits;
    ASSERT(AddrLen <= 32);
    if (AddrLen != 0)
    {
        IPRoute->RR_NextHopAddress.N_NetMask = 
            RtlUlongByteSwap((~0) >> (32 - AddrLen));
    }

    Status = RtmReleaseNextHopInfo(V1Regn->Rtmv2RegHandle,
                                   &NextHopInfo);

    ASSERT(Status == NO_ERROR);

    //
    // Get the family specific data for route
    //

    IPRoute->RR_FamilySpecificData.FSD_Priority = 
                        V2RouteInfo->PrefInfo.Preference;

    IPRoute->RR_FamilySpecificData.FSD_Metric  = 
    IPRoute->RR_FamilySpecificData.FSD_Metric1 = 
                            V2RouteInfo->PrefInfo.Metric;

    IPRoute->RR_FamilySpecificData.FSD_Flags = V2RouteInfo->Flags1; 

    if (V2RouteInfo->Flags & RTM_ROUTE_FLAGS_LOCAL)
    {
        IPRoute->RR_FamilySpecificData.FSD_Type = 3;
    }
    else
    if (V2RouteInfo->Flags & RTM_ROUTE_FLAGS_REMOTE)
    {
        IPRoute->RR_FamilySpecificData.FSD_Type = 4;
    }

    //
    // Get the protocol specific data for route
    //

    IPRoute->RR_ProtocolSpecificData.PSD_Data[0] =
                     PtrToUlong(V2RouteInfo->EntitySpecificInfo);

    return NO_ERROR;
}

#endif // WRAPPER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\rtmchng.h ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmchng.h

Abstract:

    Contains defintions related to change
    notification registrations to entities
    registered with the RTM.

Author:

    Chaitanya Kodeboyina (chaitk)   10-Sep-1998

Revision History:

--*/

#ifndef __ROUTING_RTMCHNG_H__
#define __ROUTING_RTMCHNG_H__

//
// Constants used in change notification processing
//

#define TIMER_CALLBACK_FREQUENCY    1000

#define MAX_DESTS_TO_PROCESS_ONCE     16

//
// Change type info must be consistent
// with this information in rtmv2.h
//

// Change types that we support

#define RTM_CHANGE_TYPE_ID_ALL         0
#define RTM_CHANGE_TYPE_ID_BEST        1
#define RTM_CHANGE_TYPE_ID_FORWARDING  2

#define RTM_CHANGE_TYPES_MASK     0x0007

//
// Queue data structure used below
//

typedef struct _QUEUE
{
    UINT              Front;
    UINT              Rear;
    UINT              Size;
    PVOID             Array[1];
} QUEUE, *PQUEUE;


//
// Change Notification Info Block
//

typedef struct _NOTIFY_INFO
{
    OPEN_HEADER       NotifyHeader;     // Signature, Type and Reference Count

    PENTITY_INFO      OwningEntity;     // Entity that opened this notification

    RTM_VIEW_SET      TargetViews;      // Views that we are interested in

    UINT              NumberOfViews;    // Num. of views we are interested in

    RTM_NOTIFY_FLAGS  ChangeTypes;      // Change types we are interested in

    INT               CNIndex;          // Index for this CN registration

    CRITICAL_SECTION  NotifyLock;       // Lock that serializes ops on CN

    HANDLE            NotifyContext;    // Context for the new changes callback

    QUEUE             NotifyDests;      // Dests to be notified to this CN
}
NOTIFY_INFO, *PNOTIFY_INFO;



//
// Macros for testing, setting and reseting CN related bits
//

#define  IS_BIT_SET(Value, Bit)   (Value  &  (1 << (Bit)))

#define  SET_BIT(Value, Bit)      (Value |=  (1 << (Bit)))

#define  RESET_BIT(Value, Bit)    (Value &= ~(1 << (Bit)))

#define  LOCKED_SET_BIT(Value, BitIndex)                             \
     InterlockedExchangeAdd((PLONG) &(Value),  +(1 << (BitIndex)))

#define  LOCKED_RESET_BIT(Value, BitIndex)                           \
     InterlockedExchangeAdd((PLONG) &(Value),  -(1 << (BitIndex)))

//
// Macros for acquiring various locks defined in this file
// 

#define ACQUIRE_CHANGE_NOTIFICATION_LOCK(Notification)               \
    ACQUIRE_LOCK(&Notification->NotifyLock)

#define RELEASE_CHANGE_NOTIFICATION_LOCK(Notification)               \
    RELEASE_LOCK(&Notification->NotifyLock)

//
// Other misc macros
//

#define CHANGE_LIST_TO_INSERT(Dest)                                  \
    (UINT)(((*(ULONG *)&Dest->DestAddress.AddrBits) >> 8)            \
             % NUM_CHANGED_DEST_LISTS)                               \

//
// Queue manipulation macros
//

#define InitializeQueue(Q, N)                                        \
    (Q)->Front = 0;                                                  \
    (Q)->Rear = 0;                                                   \
    (Q)->Size = (N);                                                 \

#define IsQueueEmpty(Q)                                              \
    ((Q)->Front == (Q)->Rear)                                        \

#define EnqueueItem(Q, I, S)                                         \
{                                                                    \
    UINT _R_;                                                        \
                                                                     \
    _R_ = ((Q)->Rear + 1) % (Q)->Size;                               \
                                                                     \
    if ((Q)->Front == (_R_))                                         \
    {                                                                \
        (S) = TRUE;                                                  \
    }                                                                \
    else                                                             \
    {                                                                \
        (Q)->Rear = (_R_);                                           \
                                                                     \
        (Q)->Array[(Q)->Rear] = I;                                   \
                                                                     \
        (S) = FALSE;                                                 \
    }                                                                \
}                                                                    \

#define DequeueItem(Q, I)                                            \
                                                                     \
    if ((Q)->Front == (Q)->Rear)                                     \
    {                                                                \
        (*(I)) = NULL;                                               \
    }                                                                \
    else                                                             \
    {                                                                \
        ((Q)->Front)++;                                              \
                                                                     \
        ((Q)->Front) %= (Q)->Size;                                   \
                                                                     \
        (*(I)) = (Q)->Array[(Q)->Front];                             \
    }                                                                \


//
// Change Notification Helper Functions
//

DWORD
ComputeCNsToBeNotified (
    IN      PADDRFAM_INFO                   AddrFamInfo,
    IN      DWORD                           DestMarkedBits,
    IN      DWORD                          *ViewsForChangeType
    );

DWORD
AddToChangedDestLists (
    IN      PADDRFAM_INFO                   AddrFamInfo,
    IN      PDEST_INFO                      Dest,
    IN      ULONG                           NotifyCNs
    );

VOID 
NTAPI
ProcessChangedDestLists (
    IN      PVOID                           Context,
    IN      BOOLEAN                         TimeOut
    );

#endif //__ROUTING_RTMCHNG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\rtmchng.c ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmchng.c

Abstract:

    Contains routines for giving out change
    notification registrations to entities
    registered with the RTM.

Author:

    Chaitanya Kodeboyina (chaitk)   10-Sep-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop

DWORD
WINAPI
RtmRegisterForChangeNotification (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_VIEW_SET                    TargetViews,
    IN      RTM_NOTIFY_FLAGS                NotifyFlags,
    IN      PVOID                           NotifyContext,
    OUT     PRTM_NOTIFY_HANDLE              NotifyHandle
    )

/*++

Routine Description:

    Creates a new change notification using which the caller can
    receive notifications to changes in best route information.

Arguments:

    RtmRegHandle   - RTM registration handle for calling entity,

    TargetViews    - Set of views in which changes are tracked,

    NotifyFlags    - Flags that indicate the change types and 
                     dests (marked or all) caller is interested in,

    NotifyContext  - Context for callback to indicate new changes,

    NotifyHandle   - Handle to this notification info used in all
                     subsequent calls - to get changes and so on.

Return Value:

    Status of the operation

--*/

{
    PADDRFAM_INFO   AddrFamInfo;
    PENTITY_INFO    Entity;
    PNOTIFY_INFO    Notif;
    BOOL            LockInited;
    UINT            i, j;
    DWORD           Status;

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    AddrFamInfo = Entity->OwningAddrFamily;

    //
    // Is he interested in any change types supported ?
    //

    if ((NotifyFlags & RTM_CHANGE_TYPES_MASK) == 0)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Is he interested in any non-supported views ?
    //

    if (TargetViews & ~AddrFamInfo->ViewsSupported)
    {
        return ERROR_NOT_SUPPORTED;
    }

    //
    // Create and initialize a change notification block
    //

    Notif = (PNOTIFY_INFO) AllocNZeroObject(sizeof(NOTIFY_INFO) +
                                            AddrFamInfo->MaxHandlesInEnum *
                                            sizeof(PDEST_INFO));
    if (Notif == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

#if WRN
    Status = ERROR_GEN_FAILURE;
#endif

    do
    {
#if DBG_HDL
        Notif->NotifyHeader.ObjectHeader.TypeSign = NOTIFY_ALLOC;

        Notif->NotifyHeader.HandleType = NOTIFY_TYPE;
#endif
        Notif->OwningEntity = Entity;

        Notif->TargetViews = TargetViews;

        Notif->NumberOfViews = NUMBER_OF_BITS(TargetViews);

        Notif->ChangeTypes = NotifyFlags;

        LockInited = FALSE;

        try
        {
            InitializeCriticalSection(&Notif->NotifyLock);

            LockInited = TRUE;
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            Status = GetLastError();
            break;
        }

        Notif->NotifyContext = NotifyContext;

        InitializeQueue(&Notif->NotifyDests, AddrFamInfo->MaxHandlesInEnum);

        Notif->CNIndex = -1;

        ACQUIRE_NOTIFICATIONS_WRITE_LOCK(AddrFamInfo);

        do
        {
            //
            // Do we have any space for a new change notification ?
            //

            if (AddrFamInfo->NumChangeNotifs >= AddrFamInfo->MaxChangeNotifs)
            {
                Status = ERROR_NO_SYSTEM_RESOURCES;
                break;
            }

            //
            // Search for an unused change notification (CN) slot
            //

            for (i = 0; i < AddrFamInfo->MaxChangeNotifs; i++)
            {
                if (AddrFamInfo->ChangeNotifsDir[i] == 0)
                {
                    break;
                }
            }

            ASSERT(i < AddrFamInfo->MaxChangeNotifs);


            //
            // Reserve the CN index in the change notification dir
            //

            Notif->CNIndex = i;

            AddrFamInfo->ChangeNotifsDir[i] = Notif;

            AddrFamInfo->NumChangeNotifs++;

            //
            // Fill in the CN information for this index on AF
            //

            SET_BIT(AddrFamInfo->ChangeNotifRegns, i);

            // Do we indicate changes to marked dests only

            if (NotifyFlags & RTM_NOTIFY_ONLY_MARKED_DESTS)
            {
                SET_BIT(AddrFamInfo->CNsForMarkedDests, i);
            }

            //
            // Mark each view in which CN is interested
            //

            if (TargetViews == RTM_VIEW_MASK_ANY)
            {
                TargetViews = RTM_VIEW_MASK_ALL;
            }

            for (j = 0; TargetViews; j++)
            {
                if (TargetViews & 0x01)
                {
                    SET_BIT(AddrFamInfo->CNsForView[j], i);
                }
        
                TargetViews >>= 1;
            }

            //
            // Mark change types in which CN is interested
            //

            for (j = 0; j < RTM_NUM_CHANGE_TYPES; j++)
            {
                if (NotifyFlags & 0x01)
                {
                    SET_BIT(AddrFamInfo->CNsForChangeType[j], i);
                }

                NotifyFlags >>= 1;
            }
        }
        while (FALSE);

        RELEASE_NOTIFICATIONS_WRITE_LOCK(AddrFamInfo);

        if (Notif->CNIndex == -1)
        {
            break;
        }

#if DBG_HDL
        //
        // Insert into list of handles opened by entity
        //

        ACQUIRE_OPEN_HANDLES_LOCK(Entity);
        InsertTailList(&Entity->OpenHandles, &Notif->NotifyHeader.HandlesLE);
        RELEASE_OPEN_HANDLES_LOCK(Entity);
#endif

        REFERENCE_ENTITY(Entity, NOTIFY_REF);

        //
        // Make a handle to the notify block and return
        //

        *NotifyHandle = MAKE_HANDLE_FROM_POINTER(Notif);

        return NO_ERROR;
    }
    while (FALSE);

    //
    // Something failed - undo work done and return status
    //

    if (LockInited)
    {
        DeleteCriticalSection(&Notif->NotifyLock);
    }

#if DBG_HDL
    Notif->NotifyHeader.ObjectHeader.TypeSign = NOTIFY_FREED;
#endif

    FreeObject(Notif);

    *NotifyHandle = NULL;

    return Status;
}


DWORD
WINAPI
RtmGetChangedDests (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NOTIFY_HANDLE               NotifyHandle,
    IN OUT  PUINT                           NumDests,
    OUT     PRTM_DEST_INFO                  ChangedDests
    )

/*++

Routine Description:

    Get the next set of destinations whose best route information
    has changed.

Arguments:

    RtmRegHandle   - RTM registration handle for calling entity,

    NotifyHandle   - Handle to the change notification,

    NumDests       - Num. of DestInfo's in output is passed in,
                     Num. of DestInfo's copied out is returned.

    ChangedDests   - Output buffer where destination info is retd.

Return Value:

    Status of the operation

--*/

{
    PADDRFAM_INFO   AddrFamInfo;
    PENTITY_INFO    Entity;
    PNOTIFY_INFO    Notif;
    UINT            DestInfoSize;
    UINT            DestsInput;
    PDEST_INFO      Dest;
    INT             CnIndex;
    DWORD           Status;

    //
    // Init the output params in case we fail validation
    //

    DestsInput = *NumDests;

    *NumDests = 0;

    //
    // Do some validation checks on the input params
    //

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_NOTIFY_HANDLE(NotifyHandle, &Notif);

    AddrFamInfo = Entity->OwningAddrFamily;

    if (DestsInput > AddrFamInfo->MaxHandlesInEnum)
    {
        return ERROR_INVALID_PARAMETER;
    }

    DestInfoSize = RTM_SIZE_OF_DEST_INFO(Notif->NumberOfViews);

    CnIndex = Notif->CNIndex;

    Status = NO_ERROR;

    //
    // Get changed dests from the local queue on CN
    //

    ACQUIRE_CHANGE_NOTIFICATION_LOCK(Notif);

    while (*NumDests < DestsInput)
    {
        //
        // Get the next destination from the queue
        //

        DequeueItem(&Notif->NotifyDests, &Dest);

        if (Dest == NULL)
        {
            break;
        }

#if DBG_TRACE
        if (TRACING_ENABLED(NOTIFY))
        {
            ULONG TempAddr, TempMask;
            
            RTM_IPV4_GET_ADDR_AND_MASK(TempAddr, TempMask, &Dest->DestAddress);
            Trace2(NOTIFY,"Returning dest %p to CN %d:", Dest, Notif->CNIndex);
            TracePrintAddress(NOTIFY, TempAddr, TempMask); Trace0(NOTIFY,"\n");
        }
#endif

        ACQUIRE_DEST_WRITE_LOCK(Dest);

        // The queue bit for this CN should be set

        ASSERT(IS_BIT_SET(Dest->DestOnQueueBits, CnIndex));

        //
        // Do not copy dest if a change was ignored
        // after the dest was put on the queue - in which
        // case both Changed & OnQueue bits are set
        // 

        if (IS_BIT_SET(Dest->DestChangedBits, CnIndex))
        {
            RESET_BIT(Dest->DestChangedBits, CnIndex);
        }
        else
        {
            //
            // Copy the dest information to output
            //

            GetDestInfo(Entity,
                        Dest,
                        RTM_BEST_PROTOCOL,
                        Notif->TargetViews,
                        ChangedDests);

            (*NumDests)++;

            ChangedDests = 
                (PRTM_DEST_INFO) (DestInfoSize + (PUCHAR) ChangedDests);
        }

        // Reset bit as it has been pulled off the queue

        RESET_BIT(Dest->DestOnQueueBits, CnIndex);

        RELEASE_DEST_WRITE_LOCK(Dest);

        DEREFERENCE_DEST(Dest, NOTIFY_REF);
    }

    //
    // Do we have any more destinations in the queue ?
    //

    if ((*NumDests) == 0)
    {
        Status = ERROR_NO_MORE_ITEMS;
    }

    RELEASE_CHANGE_NOTIFICATION_LOCK(Notif);

    return Status;
}


DWORD
WINAPI
RtmReleaseChangedDests (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NOTIFY_HANDLE               NotifyHandle,
    IN      UINT                            NumDests,
    IN      PRTM_DEST_INFO                  ChangedDests
)

/*++

Routine Description:

    Releases all handles present in the input dest info structures.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    NotifyHandle      - Handle to the change notification,

    NumDests          - Number of dest info structures in buffer,

    ChangedDests      - Array of dest info structures being released.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO    Entity;
    UINT            NumViews;
    UINT            DestInfoSize;
    UINT            i;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    //
    // De-registration could have happened by now
    // so do not validate the notification handle
    //

    UNREFERENCED_PARAMETER(NotifyHandle);

    //
    // Get size of dest info in info array
    //

    NumViews = ((PRTM_DEST_INFO) ChangedDests)->NumberOfViews;

    DestInfoSize = RTM_SIZE_OF_DEST_INFO(NumViews);

    //
    // Dereference each dest info in array
    //

    for (i = 0; i < NumDests; i++)
    {
        RtmReleaseDestInfo(RtmRegHandle, ChangedDests);

        ChangedDests = (PRTM_DEST_INFO) (DestInfoSize + (PUCHAR) ChangedDests);
    }

    return NO_ERROR;
}


DWORD
WINAPI
RtmIgnoreChangedDests (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NOTIFY_HANDLE               NotifyHandle,
    IN      UINT                            NumDests,
    IN      PRTM_DEST_HANDLE                ChangedDests
    )

/*++

Routine Description:

    Ignores the next change on each of the input destinations if
    it has already occurred.
    
    We do not take a lock on the notification here as we are not
    serializing this call with other RtmGetChangedDests calls.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    NotifyHandle      - Handle to the change notification,

    NumDests          - Number of dest handles in buffer below,

    ChangedDests      - Dests whose next change we are ignoring.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO    Entity;
    PNOTIFY_INFO    Notif;
    PDEST_INFO      Dest;
    INT             CnIndex;
    BOOL            ChangedBit;
    BOOL            OnQueueBit;
    UINT            i;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_NOTIFY_HANDLE(NotifyHandle, &Notif);

    CnIndex = Notif->CNIndex;

    for (i = 0; i < NumDests; i++)
    {
        Dest = DEST_FROM_HANDLE(ChangedDests[i]);

        ACQUIRE_DEST_WRITE_LOCK(Dest);

        ChangedBit = IS_BIT_SET(Dest->DestChangedBits, CnIndex);

        OnQueueBit = IS_BIT_SET(Dest->DestOnQueueBits, CnIndex);

        if (ChangedBit && !OnQueueBit)
        {
            //
            // Dest on a changed list - reset the changed bit
            //

            RESET_BIT(Dest->DestChangedBits, CnIndex);

            //
            // If there are no more "changed bits" set on dest,
            // it is removed from the change list when the list
            // is processed next (in ProcessChangedDests call)
            //
        }
        else
        if (!ChangedBit && OnQueueBit)
        {
            //
            // Dest on queue - Invalidate by setting changed bit
            //

            SET_BIT(Dest->DestChangedBits, CnIndex);
        }

        RELEASE_DEST_WRITE_LOCK(Dest);
    }

    return NO_ERROR;
}


DWORD
WINAPI
RtmGetChangeStatus (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NOTIFY_HANDLE               NotifyHandle,
    IN      RTM_DEST_HANDLE                 DestHandle,
    OUT     PBOOL                           ChangeStatus
    )

/*++

Routine Description:

    Checks if there are pending changes to be notified on a dest.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    NotifyHandle      - Handle to the change notification,

    DestHandle        - Dest whose change status we are querying,

    ChangedStatus     - Change Status of this dest is returned.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO    Entity;
    PNOTIFY_INFO    Notif;
    PDEST_INFO      Dest;
    INT             CnIndex;
    BOOL            ChangedBit;
    BOOL            OnQueueBit;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_NOTIFY_HANDLE(NotifyHandle, &Notif);

    VALIDATE_DEST_HANDLE(DestHandle, &Dest);


    CnIndex = Notif->CNIndex;


    ACQUIRE_DEST_READ_LOCK(Dest);

    ChangedBit = IS_BIT_SET(Dest->DestChangedBits, CnIndex);

    OnQueueBit = IS_BIT_SET(Dest->DestOnQueueBits, CnIndex);

    RELEASE_DEST_READ_LOCK(Dest);

    if (ChangedBit)
    {
        if (OnQueueBit)
        {
            // The last change has been ignored

            *ChangeStatus = FALSE;
        }
        else
        {
            // A pending change to be notified

            *ChangeStatus = TRUE;
        }
    }
    else
    {
        if (OnQueueBit)
        {
            // A pending change to be notified

            *ChangeStatus = TRUE;
        }
        else
        {
            // No changes available on this dest
            
            *ChangeStatus = FALSE;
        }
    }

    return NO_ERROR;
}


DWORD
WINAPI
RtmMarkDestForChangeNotification (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NOTIFY_HANDLE               NotifyHandle,
    IN      RTM_DEST_HANDLE                 DestHandle,
    IN      BOOL                            MarkDest
    )

/*++

Routine Description:

    Marks a destination to request notifications to changes to its
    best route information on this change notification.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    NotifyHandle      - Handle to the change notification,

    DestHandle        - Dest that we are marking for notifications,

    MarkDest          - Mark dest if TRUE, Unmark dest if FALSE

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO    Entity;
    PNOTIFY_INFO    Notif;
    PDEST_INFO      Dest;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_NOTIFY_HANDLE(NotifyHandle, &Notif);

    // VALIDATE_DEST_HANDLE(DestHandle, &Dest);
    Dest = DEST_FROM_HANDLE(DestHandle);
    if (!Dest)
    {
        return ERROR_INVALID_HANDLE;
    }
    
    //
    // We make this check so that we can avoid taking
    // the dest lock (which is dynamic) unnecessarily
    //

    if (IS_BIT_SET(Dest->DestMarkedBits, Notif->CNIndex))
    {
        //
        // Reset mark bit on dest for this CN if reqd
        //

        if (!MarkDest)
        {
            ACQUIRE_DEST_WRITE_LOCK(Dest);
            RESET_BIT(Dest->DestMarkedBits, Notif->CNIndex);
            RELEASE_DEST_WRITE_LOCK(Dest);
        }
    }
    else
    {
        //
        // Set mark bit on dest for this CN if reqd
        //

        if (MarkDest)
        {
            ACQUIRE_DEST_WRITE_LOCK(Dest);
            SET_BIT(Dest->DestMarkedBits,   Notif->CNIndex);
            RELEASE_DEST_WRITE_LOCK(Dest);
        }
    }

    return NO_ERROR;
}


DWORD
WINAPI
RtmIsMarkedForChangeNotification (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NOTIFY_HANDLE               NotifyHandle,
    IN      RTM_DEST_HANDLE                 DestHandle,
    OUT     PBOOL                           DestMarked
    )

/*++

Routine Description:

    Checks if a dest has been marked (by a CN handle) for receving 
    notifications to changes in its best route information.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    NotifyHandle      - Handle to the change notification,

    DestHandle        - Dest that we want to check is marked or not,

    DestMarked        - TRUE if marked, and FALSE if not.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO    Entity;
    PNOTIFY_INFO    Notif;
    PDEST_INFO      Dest;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_NOTIFY_HANDLE(NotifyHandle, &Notif);

    // VALIDATE_DEST_HANDLE(DestHandle, &Dest);
    Dest = DEST_FROM_HANDLE(DestHandle);
    if (!Dest)
    {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Return the state of mark bit on the dest for CN
    //

    *DestMarked = IS_BIT_SET(Dest->DestMarkedBits, Notif->CNIndex);

    return NO_ERROR;
}


DWORD
WINAPI
RtmDeregisterFromChangeNotification (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NOTIFY_HANDLE               NotifyHandle
    )

/*++

Routine Description:

    Deregisters a change notification and frees all resources
    allocated to it. It also cleans up all information kept 
    in the destination for this particular notification index.

Arguments:

    RtmRegHandle   - RTM registration handle for calling entity,

    NotifyHandle   - Handle to notification being de-registered.

Return Value:

    Status of the operation

--*/

{
    PADDRFAM_INFO   AddrFamInfo;
    PENTITY_INFO    Entity;
    PNOTIFY_INFO    Notif;
    PDEST_INFO      Dest;
    UINT            NumDests;
    INT             CNIndex;
    UINT            i;
    DWORD           Status;
    RTM_NET_ADDRESS NetAddress;
    RTM_VIEW_SET    ViewSet;
    PLOOKUP_LINKAGE DestData[DEFAULT_MAX_HANDLES_IN_ENUM];


    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    AddrFamInfo = Entity->OwningAddrFamily;


    VALIDATE_NOTIFY_HANDLE(NotifyHandle, &Notif);

    //
    // Remove this notification from CN regn's mask
    // so that no more bits for this CN will be set
    //

    ACQUIRE_NOTIFICATIONS_WRITE_LOCK(AddrFamInfo);

    CNIndex = Notif->CNIndex;

    ASSERT(AddrFamInfo->ChangeNotifsDir[CNIndex] == Notif);

    Notif->CNIndex = -1;

    RESET_BIT(AddrFamInfo->ChangeNotifRegns, CNIndex);

    //
    // Reset other bits that refer to the CN's state
    //

    // Unmark state whether this CN need marked dests

    RESET_BIT(AddrFamInfo->CNsForMarkedDests, CNIndex);

    // Unmark interest of this CN in each view

    ViewSet = RTM_VIEW_MASK_ALL;

    for (i = 0; ViewSet; i++)
    {
        if (ViewSet & 0x01)
        {
            RESET_BIT(AddrFamInfo->CNsForView[i], CNIndex);
        }
        
        ViewSet >>= 1;
    }

    // Unmark CN's interest in each change type

    for (i = 0; i < RTM_NUM_CHANGE_TYPES; i++)
    {
        RESET_BIT(AddrFamInfo->CNsForChangeType[i], CNIndex);
    }

    RELEASE_NOTIFICATIONS_WRITE_LOCK(AddrFamInfo);

    //
    // Cleanup the notification's "DestChanged" bits
    //

    ProcessChangedDestLists(AddrFamInfo, FALSE);

    //
    // Reset the CN's marked bits on all the dests
    //

    ZeroMemory(&NetAddress, sizeof(RTM_NET_ADDRESS));

    do
    {
        NumDests = DEFAULT_MAX_HANDLES_IN_ENUM;

        ACQUIRE_ROUTE_TABLE_READ_LOCK(AddrFamInfo);

        Status = EnumOverTable(AddrFamInfo->RouteTable,
                               &NetAddress.NumBits,
                               NetAddress.AddrBits,
                               NULL,
                               0,
                               NULL,
                               &NumDests,
                               DestData);

        for (i = 0; i < NumDests; i++)
        {
            Dest = CONTAINING_RECORD(DestData[i], DEST_INFO, LookupLinkage);

            if (IS_BIT_SET(Dest->DestMarkedBits, CNIndex))
            {
                LOCKED_RESET_BIT(Dest->DestMarkedBits, CNIndex);
            }
        }

        RELEASE_ROUTE_TABLE_READ_LOCK(AddrFamInfo);
    }
    while (SUCCESS(Status));

    //
    // Now remove the CN completely from dir of CNs
    //

    ACQUIRE_NOTIFICATIONS_WRITE_LOCK(AddrFamInfo);

    AddrFamInfo->ChangeNotifsDir[CNIndex] = NULL;

    AddrFamInfo->NumChangeNotifs--;

    RELEASE_NOTIFICATIONS_WRITE_LOCK(AddrFamInfo);

    //
    // Deference any destinations on the CN's queue
    //

    while (TRUE)
    {
        //
        // Get the next destination from the queue
        //

        DequeueItem(&Notif->NotifyDests, &Dest);

        if (Dest == NULL)
        {
            break;
        }

        // Reset the "on CN's queue" bit on dest

        if (IS_BIT_SET(Dest->DestOnQueueBits, CNIndex))
        {
            LOCKED_RESET_BIT(Dest->DestOnQueueBits, CNIndex);
        }

        DEREFERENCE_DEST(Dest, NOTIFY_REF);
    }

    //
    // Free all resources allocated to this CN
    //

    DeleteCriticalSection(&Notif->NotifyLock);

#if DBG_HDL
    //
    // Remove from the list of handles opened by entity
    //

    ACQUIRE_OPEN_HANDLES_LOCK(Entity);
    RemoveEntryList(&Notif->NotifyHeader.HandlesLE);
    RELEASE_OPEN_HANDLES_LOCK(Entity);
#endif

    DEREFERENCE_ENTITY(Entity, NOTIFY_REF);

    // Free memory allocated for notification and return

#if DBG_HDL
    Notif->NotifyHeader.ObjectHeader.TypeSign = NOTIFY_FREED;
#endif

    FreeObject(Notif);

    return NO_ERROR;
}


DWORD
ComputeCNsToBeNotified (
    IN      PADDRFAM_INFO                   AddrFamInfo,
    IN      DWORD                           DestMarkedBits,
    IN      DWORD                          *ViewsForChangeType
    )

/*++

Routine Description:

    Computes the set of change notification registrations that
    need to be notified when the best route to a particular
    destination changes.

Arguments:

    AddrFamInfo    - Address family that has the CN regn info,

    DestMarkedBits - CN's that marked for changes this dest
                     or the dest's parent if it's a new dest

    ViewsForChangeType 
                   - Views in which change of a type occurred.

Return Value:

    CNs that need to be notified of this change.

Locks:

    Called with ChangeNotifsLock in AddrFamInfo in READ mode
    as this protects CN regn info from changing while we are
    reading it.

--*/

{
    RTM_VIEW_SET ViewSet;
    DWORD        FilterCNs;
    DWORD        CNsForCT;
    UINT         i, j;
    DWORD        NotifyCNs;

    //
    // Either a CN has marked the dest, or wants all changes
    //

    NotifyCNs = DestMarkedBits | ~AddrFamInfo->CNsForMarkedDests;

    if (NotifyCNs == 0)
    {
        return 0;
    }

    // The CNs not in this bit-mask should not be notified

    FilterCNs = NotifyCNs;


    NotifyCNs = 0;

    for (i = 0; i < RTM_NUM_CHANGE_TYPES; i++)
    {
        //
        // For each change type, get all CN's that can be notified
        //

        // See what views this change type (CT) applies to

        CNsForCT = 0;

        ViewSet = ViewsForChangeType[i];

        for (j = 0; ViewSet; j++)
        {
            // For each view, get all interested CN's

            if (ViewSet & 0x01)
            {
                CNsForCT |= AddrFamInfo->CNsForView[j];
            }
        
            ViewSet >>= 1;
        }

        // Now see which CNs are actually interested in CT

        CNsForCT &= AddrFamInfo->CNsForChangeType[i];

        // Add these CNs to the CNs need to be notified

        NotifyCNs |= CNsForCT;

        //
        // If we have to notify all CNs, we are done here
        //

        if (NotifyCNs == AddrFamInfo->ChangeNotifRegns)
        {
            break;
        }
    }

    //
    // Apply the filer of CNs you stored away earlier
    //

    NotifyCNs &= FilterCNs;

    return NotifyCNs;
}


DWORD
AddToChangedDestLists (
    IN      PADDRFAM_INFO                   AddrFamInfo,
    IN      PDEST_INFO                      Dest,
    IN      DWORD                           NotifyCNs
    )

/*++

Routine Description:

    Add a destination to a list of changed dests on address
    family, and sets the appropriate state in dest.

Arguments:

    AddrFamInfo  - The address family holding the change-list,

    Dest         - Pointer to the dest that has changed,

    NotifyCNs    - CNs that need to be notified of this change.

Return Value:

    Status of the operation

Locks:

    Called with destination lock held in WRITE mode as we are
    updating the DestChanged and DestOnQueue bits on it. This
    lock also protects the change list linkage.In other words
    you need to have the dest lock for inserting or removing
    from a change list.

    Also called with ChangeNotifsLock in AddrFamInfo in READ 
    mode as this protects CN registration info from changing
    while we are adding to the list. If we do not take this 
    lock, we might end up adding to the change list after an 
    entity has de-registered from notifications. See code in
    RtmDeregisterFromChangeNotification.

--*/

{
    SINGLE_LIST_ENTRY *ListPtr;
    UINT               ListNum;
    BOOL               Success;

    //
    // Set change bits to 1 if not already on queue
    //

    Dest->DestChangedBits |= (NotifyCNs & ~Dest->DestOnQueueBits);

    //
    // Reset change bits to 0 if already on queue
    //

    Dest->DestChangedBits &= ~(NotifyCNs & Dest->DestOnQueueBits);

    //
    // Push dest into the change list if it is not
    // already on the list and we have new changes
    //

    if ((Dest->ChangeListLE.Next == NULL) &&
        (Dest->DestChangedBits & ~Dest->DestOnQueueBits))
    {
        // Get the change list to insert the dest in

        ListNum = CHANGE_LIST_TO_INSERT(Dest);

        //
        // Note that we take a lock on changes list
        // only if the dest (which is locked) isn't
        // already on the list, else could deadlock
        // with the code in ProcessChangedDestLists
        //

#if DBG_TRACE
    if (TRACING_ENABLED(NOTIFY))
    {
        ULONG TempAddr, TempMask;
        
        RTM_IPV4_GET_ADDR_AND_MASK(TempAddr, TempMask, &Dest->DestAddress);
        Trace2(NOTIFY,"Adding dest %p to change list %d: ", Dest, ListNum);
        TracePrintAddress(NOTIFY, TempAddr, TempMask); Trace0(NOTIFY,"\n");
    }
#endif

        ACQUIRE_CHANGED_DESTS_LIST_LOCK(AddrFamInfo, ListNum);

        //
        // Insert the item at the end of the list
        // and update the pointer to the list end
        //

        ListPtr = AddrFamInfo->ChangeLists[ListNum].ChangedDestsTail;

        PushEntryList(ListPtr, &Dest->ChangeListLE);

        AddrFamInfo->ChangeLists[ListNum].ChangedDestsTail = 
                                                 &Dest->ChangeListLE;

        RELEASE_CHANGED_DESTS_LIST_LOCK(AddrFamInfo, ListNum);

        REFERENCE_DEST(Dest, NOTIFY_REF);

        //
        // Activate a timer if it is not already done.
        // This is done with the dest lock held so the
        // dest doesn't get removed before this code.
        //

        if (InterlockedIncrement(&AddrFamInfo->NumChangedDests) == 1)
        {
            //
            // Create a periodic notifications timer
            //

            ACQUIRE_NOTIF_TIMER_LOCK(AddrFamInfo);

            ASSERT(AddrFamInfo->ChangeNotifTimer == NULL);
            
            do
            {
                Success = CreateTimerQueueTimer(&AddrFamInfo->ChangeNotifTimer,
                                                AddrFamInfo->NotifTimerQueue,
                                                ProcessChangedDestLists,
                                                AddrFamInfo,
                                                TIMER_CALLBACK_FREQUENCY,
                                                TIMER_CALLBACK_FREQUENCY,
                                                0);
                if (Success)
                {
                    break;
                }

                // Should not happen - but try again

                Sleep(0);
            }
            while (TRUE);

            RELEASE_NOTIF_TIMER_LOCK(AddrFamInfo);
        }
    }

    return NO_ERROR;
}


VOID 
NTAPI
ProcessChangedDestLists (
    IN      PVOID                           Context,
    IN      BOOLEAN                         TimeOut
    )

/*++

Routine Description:

    Processes the lists of changes on the address family, and 
    populates the per CN queues of changed destinations. If a
    dest is distributed to queues of all interested CNs, it is
    removed from the change list on address family to which it
    belonged.

Arguments:

    AddrFamInfo  - The address family holding the change-list.

    TimeOut      - TRUE if called from a timer, FALSE if not

Return Value:

    None

--*/

{
    PADDRFAM_INFO       AddrFamInfo;
    RTM_ENTITY_HANDLE   EntityHandle;
    PSINGLE_LIST_ENTRY  ListPtr, TempList;
    PSINGLE_LIST_ENTRY  Prev, Curr;
    RTM_EVENT_CALLBACK  NotifyCallback;
    PNOTIFY_INFO        Notif;
    PDEST_INFO          Dest;
    UINT                ListNum;
    UINT                NumDests, i;
    INT                 NumDestsRemoved;
    DWORD               ActualChangedBits;
    DWORD               NotifyChanges;
    BOOL                QueueEmpty, QueueFull;
    ULONG               ThreadId;
    PLONG               ListInUse;
    BOOL                Success;

    UNREFERENCED_PARAMETER(TimeOut);
    DBG_UNREFERENCED_LOCAL_VARIABLE(ThreadId);

#if DBG_TRACE
    ThreadId = HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread);

    if (TRACING_ENABLED(NOTIFY))
    {
        Trace1(NOTIFY, "Entering ProcessChangedDestLists: %lu", ThreadId);
    }
#endif

    AddrFamInfo = (PADDRFAM_INFO) Context;

    NotifyChanges = 0;

    NumDestsRemoved = 0;

    ACQUIRE_NOTIFICATIONS_READ_LOCK(AddrFamInfo);

    for (ListNum = 0; ListNum < NUM_CHANGED_DEST_LISTS; ListNum++)
    {
        //
        // Check if this list is already being processed
        //

        ListInUse = &AddrFamInfo->ChangeLists[ListNum].ChangesListInUse;

        if (InterlockedIncrement(ListInUse) != 1)
        {
            InterlockedDecrement(ListInUse);
            continue;
        }

        //
        // Move all items in the list to a temp list
        //

        ListPtr = &AddrFamInfo->ChangeLists[ListNum].ChangedDestsHead;

        ACQUIRE_CHANGED_DESTS_LIST_LOCK(AddrFamInfo, ListNum);

        TempList = ListPtr->Next;
    
        ListPtr->Next = ListPtr;

        AddrFamInfo->ChangeLists[ListNum].ChangedDestsTail = ListPtr;

        RELEASE_CHANGED_DESTS_LIST_LOCK(AddrFamInfo, ListNum);

        //
        // Process each destination in the temp list
        //

        Prev = CONTAINING_RECORD(&TempList, SINGLE_LIST_ENTRY, Next);

        Curr = Prev->Next;

        NumDests = 0;

        while (Curr != ListPtr)
        {
            // Get the next destination on the list

            Dest = CONTAINING_RECORD(Curr, DEST_INFO, ChangeListLE);

#if DBG_TRACE
            if (TRACING_ENABLED(NOTIFY))
            {
                ULONG Addr, Mask;
                
                RTM_IPV4_GET_ADDR_AND_MASK(Addr, Mask, &Dest->DestAddress);
                Trace2(NOTIFY, "Next dest %p in list %d: ", Dest, ListNum);
                TracePrintAddress(NOTIFY, Addr, Mask); Trace0(NOTIFY,"\n");
            }
#endif
            ACQUIRE_DEST_WRITE_LOCK(Dest);

            //
            // Note that this dest can have no "changed bits" set,
            // yet be on the list because the changes were ignored
            // or because one of the entities deregistered its CN
            //

            // Remove bits obsoleted by any CN deregistrations

            Dest->DestChangedBits &= AddrFamInfo->ChangeNotifRegns;

            //
            // Process all CNs whose DestChanged bit is set on dest
            //

            ActualChangedBits = Dest->DestChangedBits & ~Dest->DestOnQueueBits;

            for (i = 0; i < AddrFamInfo->MaxChangeNotifs; i++)
            {
                if (!ActualChangedBits)
                {
                    break;
                }

                if (IS_BIT_SET(ActualChangedBits, i))
                {
                    Notif = AddrFamInfo->ChangeNotifsDir[i];

                    //
                    // Note that we take a lock on notify block
                    // only if the dest (which is locked) isn't
                    // already on the queue - otherwise we will
                    // deadlock with code in RtmGetChangedDests
                    //

                    ACQUIRE_CHANGE_NOTIFICATION_LOCK(Notif);

                    QueueEmpty = IsQueueEmpty(&Notif->NotifyDests);

                    //
                    // Enqueue this destination if the
                    // the CN's queue is not yet full
                    //

                    EnqueueItem(&Notif->NotifyDests, Dest, QueueFull);

                    if (!QueueFull)
                    {
                        //
                        // If we are adding changes to an
                        // empty queue, signal this event
                        //

                        if (QueueEmpty)
                        {
                            SET_BIT(NotifyChanges, i);
                        }

                        //
                        // Adjust dest change and queue bits
                        //

                        SET_BIT(Dest->DestOnQueueBits, i);

                        RESET_BIT(Dest->DestChangedBits, i);

                        RESET_BIT(ActualChangedBits, i);

                        REFERENCE_DEST(Dest, NOTIFY_REF);
                    }

                    RELEASE_CHANGE_NOTIFICATION_LOCK(Notif);
                }
            }

            //
            // Do we have any more changes to process on dest ?
            //

            if (ActualChangedBits == 0)
            {
                // Splice this dest from the changed list
                Prev->Next = Curr->Next;

                NumDestsRemoved++;

                // "Next" == NULL means it is not on list
                Curr->Next = NULL;
            }

            RELEASE_DEST_WRITE_LOCK(Dest);

            //
            // Do we have any more changes to process on dest ?
            //

            if (ActualChangedBits == 0)
            {
                DEREFERENCE_DEST(Dest, NOTIFY_REF);
            }
            else
            {
                // Advance the pointer to next dest in list
                Prev = Curr;
            }

            Curr = Prev->Next;

            if ((++NumDests == MAX_DESTS_TO_PROCESS_ONCE) || 
                (Curr == ListPtr))
            {
                //
                // Do we have any changes to inform to entities
                //

                for (i = 0; NotifyChanges != 0; i++)
                {
                    if (NotifyChanges & 0x01)
                    {
                        Notif = AddrFamInfo->ChangeNotifsDir[i];

                        NotifyCallback = Notif->OwningEntity->EventCallback;

                        EntityHandle = 
                            MAKE_HANDLE_FROM_POINTER(Notif->OwningEntity);

#if DBG_TRACE
                        if (TRACING_ENABLED(NOTIFY))
                        {
                            Trace1(NOTIFY, "Notifying CN %d BEGIN", i);
                        }
#endif
                        NotifyCallback(EntityHandle,
                                       RTM_CHANGE_NOTIFICATION,
                                       MAKE_HANDLE_FROM_POINTER(Notif),
                                       Notif->NotifyContext);
#if DBG_TRACE
                        if (TRACING_ENABLED(NOTIFY))
                        {
                            Trace1(NOTIFY, "Notifying CN %d END\n", i);
                        }
#endif
                    }

                    NotifyChanges >>= 1;
                }

                // Reset counter for number of dests processed
                NumDests = 0;
            }
        }

        if (TempList != ListPtr)
        {
            //
            // Merge back what is left of the temp list
            //

            ASSERT(Prev->Next == ListPtr);

            ACQUIRE_CHANGED_DESTS_LIST_LOCK(AddrFamInfo, ListNum);

            if (ListPtr->Next == ListPtr)
            {
                AddrFamInfo->ChangeLists[ListNum].ChangedDestsTail = Prev;
            }

            Prev->Next = ListPtr->Next;

            ListPtr->Next = TempList;

            RELEASE_CHANGED_DESTS_LIST_LOCK(AddrFamInfo, ListNum);
        }

        InterlockedDecrement(ListInUse);
    }

    //
    // Update number of destinations left to process on change list
    //

    if (NumDestsRemoved)
    {
        //
        // Do we have any more destinations to process ?
        //

        ACQUIRE_NOTIF_TIMER_LOCK(AddrFamInfo);

        if (InterlockedExchangeAdd(&AddrFamInfo->NumChangedDests, 
                                   (-1) * NumDestsRemoved) == NumDestsRemoved)
        {
            //
            // Delete timer as we have no items on change list
            //

            ASSERT(AddrFamInfo->ChangeNotifTimer);

            Success = DeleteTimerQueueTimer(AddrFamInfo->NotifTimerQueue,
                                            AddrFamInfo->ChangeNotifTimer,
                                            NULL);
            // ASSERT(Success);

            AddrFamInfo->ChangeNotifTimer = NULL;
        }

        RELEASE_NOTIF_TIMER_LOCK(AddrFamInfo);
    }

    RELEASE_NOTIFICATIONS_READ_LOCK(AddrFamInfo);

#if DBG_TRACE
    if (TRACING_ENABLED(NOTIFY))
    {
        Trace1(NOTIFY, "Leaving  ProcessChangedDestLists: %lu\n", ThreadId);
    }
#endif

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\rtmconst.c ===
/*++

Copyright (c) 1997-1998 Microsoft Corporation

Module Name:

    rtmconst.c

Abstract:
    Private Constants used in the RTMv2 DLL

Author:
    Chaitanya Kodeboyina (chaitk)  17-Aug-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop

//
// RTM supported view related constants
//
// const DWORD VIEW_MASK[] =
// {
//    RTM_VIEW_MASK_UCAST,
//    RTM_VIEW_MASK_MCAST
// };


#if DBG_HDL

//
// Type & Signature of allocated structures
//

const DWORD OBJECT_SIGNATURE[] = 
{ 
    GENERIC_ALLOC,
    INSTANCE_ALLOC,
    ADDRESS_FAMILY_ALLOC,
    ENTITY_ALLOC,
    DEST_ALLOC,
    ROUTE_ALLOC,
    NEXTHOP_ALLOC,
    DEST_ENUM_ALLOC,
    ROUTE_ENUM_ALLOC,
    NEXTHOP_ENUM_ALLOC,
    NOTIFY_ALLOC,
    ROUTE_LIST_ALLOC,
    LIST_ENUM_ALLOC,
    V1_REGN_ALLOC,
    V1_ENUM_ALLOC
};

#endif

#if _DBG_

//
// Names of the references
//

const CHAR *REF_NAME[MAX_REFS] =
{
    "Creation",
    "Addr Fam",
    "Entity",
    "Dest",
    "Route",
    "Nexthop",
    "Enum",
    "Notify",
    "List",
    "Hold",
    "Timer",
    "Temp Use",
    "Handle"
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\rtm1to2.h ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtm1to2.h

Abstract:

    Contains definitions/macros that wrap RTMv2
    in the RTMv1 API.

Author:

    Chaitanya Kodeboyina (chaitk)   13-Oct-1998

Revision History:

--*/

#ifndef __ROUTING_RTM1TO2_H__
#define __ROUTING_RTM1TO2_H__

#include <winsock2.h>

#include <rtm.h>

#include <rmrtm.h>

// Protocol Id for the default wrapper registration
#define V1_WRAPPER_REGN_ID   0xA1B2C3D4

// Protocol instance for a v1 entity registration
#define V1_PROTOCOL_INSTANCE 0xABCD1234

//
// Misc defines for wrapper picked from rtmv2p.h
//

#define MAXTICKS             MAXULONG

// Basic route info, present in routes of all types

// Disable warnings for unnamed structs
#pragma warning(disable : 4201)  

typedef struct
{
    ROUTE_HEADER;
} 
RTM_XX_ROUTE, *PRTM_XX_ROUTE;

#pragma warning(default : 4201)  

//
// Extending certain V1 flags in the wrapper
//

#define RTM_ONLY_OWND_ROUTES   0x00000010

//
// Mapping of v1 address families to standard ids
//

const USHORT ADDRESS_FAMILY[2] =
{
    AF_IPX,         // RTM_PROTOCOL_FAMILY_IPX = 0
    AF_INET         // RTM_PROTOCOL_FAMILY_IP  = 1
};

//
// Address sizes of supported address families
//

#define IPX_ADDR_SIZE        6
#define IP_ADDR_SIZE         4

const USHORT ADDRESS_SIZE[2] =
{
    IPX_ADDR_SIZE,   // RTM_PROTOCOL_FAMILY_IPX = 0
    IP_ADDR_SIZE     // RTM_PROTOCOL_FAMILY_IP  = 1
};

//
// Forward declarations for structs
//
typedef struct _V1_REGN_INFO *PV1_REGN_INFO;


//
// Global info for RTMv1 - v2 wrapper
//

typedef struct _V1_GLOBAL_INFO
{
    CRITICAL_SECTION  PfRegnsLock[RTM_NUM_OF_PROTOCOL_FAMILIES];
                                       // Lock guards the registrations list

    LIST_ENTRY        PfRegistrations[RTM_NUM_OF_PROTOCOL_FAMILIES];
                                       // List of regns on Protocol family

    PV1_REGN_INFO     PfRegInfo[RTM_NUM_OF_PROTOCOL_FAMILIES];
                                       // Default regn for this Protocol family

    PROUTE_VALIDATE_FUNC
                      PfValidateRouteFunc[RTM_NUM_OF_PROTOCOL_FAMILIES];
                                       // Func to validate route, fill priority
}
V1_GLOBAL_INFO, *PV1_GLOBAL_INFO;


//
// RTMv2 to v1 Registration Wrapper
//

typedef struct _V1_REGN_INFO
{
    OBJECT_HEADER     ObjectHeader;     // Signature, Type and Reference Count

    LIST_ENTRY        RegistrationsLE;  // Linkage on list of registrations

    DWORD             ProtocolFamily;   // This maps to RTMv2's address family

    DWORD             RoutingProtocol;  // Routing protocol (RIP, OSPF...)

    DWORD             Flags;            // RTMv1 Registration flags

    RTM_ENTITY_HANDLE Rtmv2RegHandle;   // Handle to actual RTMv2 registration

    RTM_REGN_PROFILE  Rtmv2Profile;     // RTMv2 registration profile

    UINT              Rtmv2NumViews;    // Number of views in the V2 instance

    CRITICAL_SECTION  NotificationLock; // RTMv1 Notification Lock

    PROUTE_CHANGE_CALLBACK
                      NotificationFunc; // RTMv1 Notification Callback

    HANDLE            NotificationEvent;// RTMv1 Notification Event

    RTM_NOTIFY_HANDLE Rtmv2NotifyHandle;// RTMv2 Notification Handle
}
V1_REGN_INFO, *PV1_REGN_INFO;


//
// RTMv1 Route Info structure
//

typedef union {
    RTM_IPX_ROUTE     IpxRoute;         // IPX route info structure

    RTM_IP_ROUTE      IpRoute;          // IP route info structure

    RTM_XX_ROUTE      XxRoute;          // The Common route header

    UCHAR             Route[1];         // Generic route info structure
}
V1_ROUTE_INFO, *PV1_ROUTE_INFO;


//
// RTMv2 to v1 Enumeration Wrapper
//

typedef struct _V1_ENUM_INFO
{
    OBJECT_HEADER     ObjectHeader;     // Signature, Type and Reference Count

    DWORD             ProtocolFamily;   // This maps to RTMv2's address family

    DWORD             EnumFlags;        // RTMv1 Enumeration flags

    V1_ROUTE_INFO     CriteriaRoute;    // V1 Criteria route for this enum

    CRITICAL_SECTION  EnumLock;         // To serialize enumeration calls

    RTM_ENUM_HANDLE   Rtmv2RouteEnum;   // Handle to the RTMv2 route enum
}
V1_ENUM_INFO, *PV1_ENUM_INFO;

//
// Miscellaneos Func Pointer Defs
//

typedef BOOL (*PFUNC) (PVOID p, PVOID q, PVOID r);


//
// Macros to validate RTMv1 to v2 wrapper handles
//

#define V1_REGN_FROM_HANDLE(V1RegnHandle)                                   \
            (PV1_REGN_INFO) GetObjectFromHandle(V1RegnHandle, V1_REGN_TYPE)

#define VALIDATE_V1_REGN_HANDLE(V1RegnHandle, pV1Regn)                      \
            *pV1Regn = V1_REGN_FROM_HANDLE(V1RegnHandle);                   \
            if ((!*pV1Regn))                                                \
            {                                                               \
                return ERROR_INVALID_HANDLE;                                \
            }                                                               \


#define V1_ENUM_FROM_HANDLE(V1EnumHandle)                                   \
            (PV1_ENUM_INFO) GetObjectFromHandle(V1EnumHandle, V1_ENUM_TYPE)

#define VALIDATE_V1_ENUM_HANDLE(V1EnumHandle, pV1Enum)                      \
            *pV1Enum = V1_ENUM_FROM_HANDLE(V1EnumHandle);                   \
            if ((!*pV1Enum))                                                \
            {                                                               \
                return ERROR_INVALID_HANDLE;                                \
            }                                                               \

//
// Macros to acquire locks in the structures above
//

#define ACQUIRE_V1_REGNS_LOCK(ProtocolFamily)                               \
            ACQUIRE_LOCK(&V1Globals.PfRegnsLock[ProtocolFamily])

#define RELEASE_V1_REGNS_LOCK(ProtocolFamily)                               \
            RELEASE_LOCK(&V1Globals.PfRegnsLock[ProtocolFamily])


#define ACQUIRE_V1_ENUM_LOCK(V1Enum)                                        \
            ACQUIRE_LOCK(&V1Enum->EnumLock)

#define RELEASE_V1_ENUM_LOCK(V1Enum)                                        \
            RELEASE_LOCK(&V1Enum->EnumLock)


#define ACQUIRE_V1_NOTIFY_LOCK(V1Regn)                                      \
            ACQUIRE_LOCK(&V1Regn->NotificationLock)

#define RELEASE_V1_NOTIFY_LOCK(V1Regn)                                      \
            RELEASE_LOCK(&V1Regn->NotificationLock)


//
// Macros to convert RTMv1 to RTMv2 structs and vice versa
//

#define MakeNetAddress(Network, ProtocolFamily, TempUlong, NetAddr)        \
            MakeNetAddressForIP(Network, TempUlong, NetAddr)

#define MakeNetAddressForIP(Network, TempUlong, NetAddr)                   \
            (NetAddr)->AddressFamily = AF_INET;                            \
            (NetAddr)->NumBits = 0;                                        \
                                                                           \
            TempUlong =                                                    \
                 RtlUlongByteSwap(((PIP_NETWORK)(Network))->N_NetMask);    \
                                                                           \
            while (TempUlong)                                              \
            {                                                              \
                ASSERT(TempUlong & 0x80000000);                            \
                TempUlong <<= 1;                                           \
                (NetAddr)->NumBits++;                                      \
            }                                                              \
                                                                           \
            (* (ULONG *) ((NetAddr)->AddrBits)) =                          \
                                  ((PIP_NETWORK) (Network))->N_NetNumber;  \


#define MakeHostAddress(HostAddr, ProtocolFamily, NetAddr)                 \
            MakeHostAddressForIP(HostAddr, NetAddr)

#define MakeHostAddressForIP(HostAddr, NetAddr)                            \
            (NetAddr)->AddressFamily = AF_INET;                            \
            (NetAddr)->NumBits = IP_ADDR_SIZE * BITS_IN_BYTE;              \
            (* (ULONG *) ((NetAddr)->AddrBits)) = (* (ULONG *) HostAddr);  \

//
// Misc V1 Macros
//

// Macro that gets the network address in the route

#define V1GetRouteNetwork(Route, ProtocolFamily, Network)                   \
        if (ProtocolFamily == RTM_PROTOCOL_FAMILY_IP)                       \
        {                                                                   \
            (*Network) = (PVOID) &((PRTM_IP_ROUTE)  Route)->RR_Network;     \
        }                                                                   \
        else                                                                \
        {                                                                   \
            (*Network) = (PVOID) &((PRTM_IPX_ROUTE) Route)->RR_Network;     \
        }                                                                   \



// Macro that gets the addr of flags in the route

#define V1GetRouteFlags(Route, ProtocolFamily, Flags)                       \
        if (ProtocolFamily == RTM_PROTOCOL_FAMILY_IP)                       \
        {                                                                   \
            Flags =                                                         \
              &((PRTM_IP_ROUTE)Route)->RR_FamilySpecificData.FSD_Flags;     \
        }                                                                   \
        else                                                                \
        {                                                                   \
            Flags =                                                         \
              &((PRTM_IPX_ROUTE)Route)->RR_FamilySpecificData.FSD_Flags;    \
        }                                                                   \


// Macro that copies one v1 route to another

#define V1CopyRoute(RouteDst, RouteSrc, ProtocolFamily)                     \
        if (ProtocolFamily == RTM_PROTOCOL_FAMILY_IP)                       \
        {                                                                   \
            CopyMemory(RouteDst, RouteSrc, sizeof(RTM_IP_ROUTE));           \
        }                                                                   \
        else                                                                \
        {                                                                   \
            CopyMemory(RouteDst, RouteSrc, sizeof(RTM_IPX_ROUTE));          \
        }                                                                   \

//
// Misc V2 Macros
//

// Macro to allocate a set of handles on the stack

#define ALLOC_HANDLES(NumHandles)                                           \
        (HANDLE *) _alloca(sizeof(HANDLE) * NumHandles)                     \


// Macro to allocate a RTM_DEST_INFO on the stack

#define ALLOC_DEST_INFO(NumViews, NumInfos)                                 \
        (PRTM_DEST_INFO) _alloca(RTM_SIZE_OF_DEST_INFO(NumViews) * NumInfos)

// Macro to allocate a RTM_ROUTE_INFO on the stack

#define ALLOC_ROUTE_INFO(NumNextHops, NumInfos)                             \
        (PRTM_ROUTE_INFO) _alloca((sizeof(RTM_ROUTE_INFO) +                 \
                                  (NumNextHops - 1) *                       \
                                   sizeof(RTM_NEXTHOP_HANDLE)) * NumInfos)  \

// Misc Macros

#define SWAP_POINTERS(p1, p2)   { PVOID p = p1; p1 = p2; p2 = p; }

//
// Callback that converts RTMv2 events to RTMv1
//

DWORD
WINAPI
V2EventCallback (
    IN      RTM_ENTITY_HANDLE               Rtmv2RegHandle,
    IN      RTM_EVENT_TYPE                  EventType,
    IN      PVOID                           Context1,
    IN      PVOID                           Context2
    );

//
// Other helper functions
//

HANDLE 
RtmpRegisterClient (
    IN      DWORD                           ProtocolFamily,
    IN      DWORD                           RoutingProtocol,
    IN      PROUTE_CHANGE_CALLBACK          ChangeFunc  OPTIONAL,
    IN      HANDLE                          ChangeEvent OPTIONAL,
    IN      DWORD                           Flags
    );

DWORD 
BlockOperationOnRoutes (
    IN      PV1_REGN_INFO                   V1Regn,
    IN      DWORD                           EnumerationFlags,
    IN      PVOID                           CriteriaRoute,
    IN      PFUNC                           RouteOperation
    );

BOOL
MatchCriteriaAndCopyRoute (
    IN      PV1_REGN_INFO                   V1Regn,
    IN      PRTM_ROUTE_HANDLE               V2RouteHandle,
    IN      PV1_ENUM_INFO                   V1Enum  OPTIONAL,
    OUT     PVOID                           V1Route OPTIONAL
    );

#define MatchCriteria(R, H, E) MatchCriteriaAndCopyRoute(R, H, E, NULL)

BOOL
MatchCriteriaAndDeleteRoute (
    IN      PV1_REGN_INFO                   V1Regn,
    IN      PRTM_ROUTE_HANDLE               V2RouteHandle,
    IN      PV1_ENUM_INFO                   V1Enum
    );

BOOL
MatchCriteriaAndChangeOwner (
    IN      PV1_REGN_INFO                   V1Regn,
    IN      PRTM_ROUTE_HANDLE               V2RouteHandle,
    IN      PV1_ENUM_INFO                   V1Enum
    );

BOOL
MatchCriteriaAndEnableRoute (
    IN      PV1_REGN_INFO                   V1Regn,
    IN      PRTM_ROUTE_HANDLE               V2RouteHandle,
    IN      PV1_ENUM_INFO                   V1Enum
    );

BOOL
CopyNonLoopbackIPRoute (
    IN      PV1_REGN_INFO                   V1Regn,
    IN      PRTM_DEST_INFO                  V2DestInfo,
    OUT     PVOID                           V1Route
    );

VOID 
MakeV2RouteFromV1Route (
    IN     PV1_REGN_INFO                   V1Regn,
    IN     PVOID                           V1Route,
    IN     PRTM_NEXTHOP_HANDLE             V2NextHop,
    OUT    PRTM_NET_ADDRESS                V2DestAddr  OPTIONAL,
    OUT    PRTM_ROUTE_INFO                 V2RouteInfo OPTIONAL
    );

VOID 
MakeV2NextHopFromV1Route (
    IN     PV1_REGN_INFO                   V1Regn,
    IN     PVOID                           V1Route,
    OUT    PRTM_NEXTHOP_INFO               V2NextHop
    );

VOID
MakeV1RouteFromV2Dest (
    IN          PV1_REGN_INFO               V1Regn,
    IN          PRTM_DEST_INFO              DestInfo,
    OUT         PVOID                       V1Route
    );

DWORD 
MakeV1RouteFromV2Route (
    IN     PV1_REGN_INFO                   V1Regn,
    IN     PRTM_ROUTE_INFO                 V2Route,
    OUT    PVOID                           V1Route
    );

#endif // __ROUTING_RTM1TO2_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\rtmcnfg.c ===
/*++

Copyright (c) 1997-1998 Microsoft Corporation

Module Name:

    rtmcnfg.c

Abstract:
    Routines that operate on configuration
    information for RTM in the registry.

Author:
    Chaitanya Kodeboyina (chaitk) 21-Aug-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop

DWORD
RtmWriteDefaultConfig (
    IN      USHORT                          RtmInstanceId
    )

/*++

Routine Description:

    Write default configuration information into the
    registry.
    
Arguments:

    RtmInstanceId  - Unique Id for this RTM instance

Return Value:

    Status of the operation.
    
--*/

{
    RTM_INSTANCE_CONFIG       InstanceConfig;
    RTM_ADDRESS_FAMILY_CONFIG AddrFamConfig;
    DWORD                     Status;

    CHECK_FOR_RTM_API_INITIALIZED();

    TraceEnter("RtmWriteDefaultConfig");

    //
    // We have no RTM instance parameters at present
    //

    Status = RtmWriteInstanceConfig(RtmInstanceId, &InstanceConfig);

    if (Status != NO_ERROR)
    {
        Trace1(ERR, "Default Config: Error %d writing instance key", Status);

        TraceLeave("RtmWriteDefaultConfig");

        return Status;
    }

    //
    // Set up default address family parameters
    //

    AddrFamConfig.AddressSize = DEFAULT_ADDRESS_SIZE;

    AddrFamConfig.MaxOpaqueInfoPtrs = DEFAULT_OPAQUE_INFO_PTRS;
    AddrFamConfig.MaxNextHopsInRoute = DEFAULT_NEXTHOPS_IN_ROUTE;

    AddrFamConfig.ViewsSupported = DEFAULT_VIEWS_SUPPORTED;
    
    AddrFamConfig.MaxHandlesInEnum = DEFAULT_MAX_HANDLES_IN_ENUM;
    AddrFamConfig.MaxChangeNotifyRegns = DEFAULT_MAX_NOTIFY_REGS;

    //
    // Write the default address family config
    //

    Status = RtmWriteAddressFamilyConfig(RtmInstanceId,
                                         AF_INET,
                                         &AddrFamConfig);

    if (Status != NO_ERROR)
    {
        Trace1(ERR, 
               "Default Config: Error %d writing address family subkey",
               Status);
    }

    TraceLeave("RtmWriteDefaultConfig");

    return Status;
}


DWORD
WINAPI
RtmReadInstanceConfig (
    IN      USHORT                          RtmInstanceId,
    OUT     PRTM_INSTANCE_CONFIG            InstanceConfig
    )

/*++

Routine Description:

    Reads the configuration information for a particular
    instance at creation time.
    
Arguments:

    RtmInstanceId  - Unique Id for this instance,

    InstanceConfig - Buffer in which config info is retd.

Return Value:

    Status of the operation.
    
--*/

{
    HKEY     ConfigHandle;
    ULONG    KeySize;
    DWORD    Status;

    UNREFERENCED_PARAMETER(InstanceConfig);

    CHECK_FOR_RTM_API_INITIALIZED();

    TraceEnter("RtmReadInstanceConfig");

    //
    // Open the key that holds this instance's config
    //

    _snprintf(RtmGlobals.RegistryPath + RTM_CONFIG_ROOT_SIZE - 1,
              MAX_CONFIG_KEY_SIZE,
              REG_KEY_INSTANCE_TEMPLATE,
              RtmInstanceId);

    Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          RtmGlobals.RegistryPath,
                          0,
                          KEY_READ,
                          &ConfigHandle);

    if (Status != NO_ERROR)
    {
        Trace1(ERR, "Instance Config: Error %d opening instance key", Status);

        TraceLeave("RtmReadInstanceConfig");

        return Status;
    }

    do
    {
        //
        // Query values for parameters in instance config
        //

        KeySize = sizeof(DWORD);


        // Nothing in the instance config at present


        //
        // Close the instance key once you are done querying
        //

        RegCloseKey(ConfigHandle);

        TraceLeave("RtmReadInstanceConfig");

        return NO_ERROR;
    }
    while (FALSE);

    //
    // Some error in the config - close handle and ret error
    //

    RegCloseKey(ConfigHandle);

    TraceLeave("RtmReadInstanceConfig");

    return (Status != NO_ERROR) ? Status: ERROR_BAD_CONFIGURATION;
}


DWORD
WINAPI
RtmWriteInstanceConfig (
    IN      USHORT                          RtmInstanceId,
    IN      PRTM_INSTANCE_CONFIG            InstanceConfig
    )

/*++

Routine Description:

    Write the input instance config information into the
    registry.
    
Arguments:

    RtmInstanceId  - Unique Id for this instance,

    InstanceConfig - Config info for this instance.

Return Value:

    Status of the operation.
    
--*/

{
    HKEY     ConfigHandle;
    DWORD    Status;

    UNREFERENCED_PARAMETER(InstanceConfig);

    CHECK_FOR_RTM_API_INITIALIZED();

    TraceEnter("RtmWriteInstanceConfig");

    //
    // Create a key (or open existing) to hold instance's config
    //

    _snprintf(RtmGlobals.RegistryPath + RTM_CONFIG_ROOT_SIZE - 1,
              MAX_CONFIG_KEY_SIZE,
              REG_KEY_INSTANCE_TEMPLATE,
              RtmInstanceId);

    Status = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                            RtmGlobals.RegistryPath,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_WRITE,
                            NULL,
                            &ConfigHandle,
                            NULL);

    if (Status != NO_ERROR)
    {
        Trace1(ERR, "Instance Config: Error %d creating instance key", Status);

        TraceLeave("RtmWriteInstanceConfig");

        return Status;
    }

    do
    {
        //
        // Write values in instance config into the registry
        //


        // Nothing in the instance config at present time


        //
        // Close the instance key once you are done writing
        //

        RegCloseKey(ConfigHandle);

        TraceLeave("RtmWriteInstanceConfig");

        return NO_ERROR;
    }
    while (FALSE);

    //
    // Error writing values; close the handle and delete the key
    //

    Trace1(ERR, 
           "Instance Config: Error %d writing instance config parameters",
           Status);

    RegCloseKey(ConfigHandle);

    RegDeleteKey(HKEY_LOCAL_MACHINE, RtmGlobals.RegistryPath);

    TraceLeave("RtmWriteInstanceConfig");

    return Status;
}


DWORD
WINAPI
RtmReadAddressFamilyConfig (
    IN      USHORT                          RtmInstanceId,
    IN      USHORT                          AddressFamily,
    OUT     PRTM_ADDRESS_FAMILY_CONFIG      AddrFamilyConfig
    )

/*++

Routine Description:

    Reads the configuration information for a particular
    address family at creation time.
    
Arguments:

    RtmInstanceId    - ID (IPv4..) for this addr family info,

    AddrFamilyConfig - Buffer in which addr family info is retd.

Return Value:

    Status of the operation.
    
--*/

{
    HKEY     ConfigHandle;
    ULONG    KeySize;
    ULONG    KeyValue;
    ULONG    KeyType;
    DWORD    Status;

    CHECK_FOR_RTM_API_INITIALIZED();

    TraceEnter("RtmReadAddressFamilyConfig");

    //
    // Open the key that holds this address family's config
    //
        
    _snprintf(RtmGlobals.RegistryPath + RTM_CONFIG_ROOT_SIZE - 1,
              MAX_CONFIG_KEY_SIZE,
              REG_KEY_ADDR_FAMILY_TEMPLATE,
              RtmInstanceId,
              AddressFamily);
    
    Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          RtmGlobals.RegistryPath,
                          0,
                          KEY_READ,
                          &ConfigHandle);
    
    if (Status != NO_ERROR)
    {
        Trace1(ERR, 
               "Address Family Config: Error %d opening address family key", 
               Status);

        TraceLeave("RtmReadAddressFamilyConfig");

        return Status;
    }

    do
    {
        //
        // Query values for parameters in address family config
        //

        KeySize = sizeof(DWORD);

        //
        // Query the 'address size' parameter
        //

        Status = RegQueryValueEx(ConfigHandle,
                                 REG_KEY_ADDRESS_SIZE,
                                 NULL,
                                 &KeyType,
                                 (PBYTE)&KeyValue,
                                 &KeySize);

        if ((Status != NO_ERROR) || (KeyType != REG_DWORD))
        {
            Trace1(ERR, 
                   "Address Family Config: Error %d reading address size key",
                   Status);
            break;
        }

        if ((KeyValue < MINIMUM_ADDRESS_SIZE) ||
            (KeyValue > MAXIMUM_ADDRESS_SIZE))
        {
            Trace1(ERR, 
                   "Address Family Config: Address Size %d out of bounds", 
                   KeyValue);
            break;
        }
         
        AddrFamilyConfig->AddressSize = KeyValue;


        //
        // Query the 'views supported' parameter
        //

        Status = RegQueryValueEx(ConfigHandle,
                                 REG_KEY_VIEWS_SUPPORTED,
                                 NULL,
                                 &KeyType,
                                 (PBYTE)&KeyValue,
                                 &KeySize);
        
        AddrFamilyConfig->ViewsSupported = DEFAULT_VIEWS_SUPPORTED;

        if (Status == NO_ERROR)
        {
            if (KeyValue == 0)
            {
                Trace0(ERR, "Address Family Config: No supported views");
                break;
            }

            AddrFamilyConfig->ViewsSupported = KeyValue;
        }


        //
        // Query the 'max change notifications' parameter
        //

        Status = RegQueryValueEx(ConfigHandle,
                                 REG_KEY_MAX_NOTIFY_REGS,
                                 NULL,
                                 &KeyType,
                                 (PBYTE)&KeyValue,
                                 &KeySize);

        AddrFamilyConfig->MaxChangeNotifyRegns = DEFAULT_MAX_NOTIFY_REGS;

        if (Status == NO_ERROR)
        {
            if ((KeyValue < MIN_MAX_NOTIFY_REGS) ||
                (KeyValue > MAX_MAX_NOTIFY_REGS))
            {
                Trace1(ERR,
                       "Address Family Config: # notifications out of range",
                       KeyValue);
                break;
            }

            AddrFamilyConfig->MaxChangeNotifyRegns = KeyValue;
        }


        //
        // Query the 'max opaque info ptrs' parameter
        //

        Status = RegQueryValueEx(ConfigHandle,
                                 REG_KEY_OPAQUE_INFO_PTRS,
                                 NULL,
                                 &KeyType,
                                 (PBYTE)&KeyValue,
                                 &KeySize);

        AddrFamilyConfig->MaxOpaqueInfoPtrs = DEFAULT_OPAQUE_INFO_PTRS;

        if (Status == NO_ERROR)
        {
            if (((int)KeyValue < MIN_OPAQUE_INFO_PTRS) ||
                (KeyValue > MAX_OPAQUE_INFO_PTRS))
            {
                Trace1(ERR,
                       "Address Family Config: # opaque ptrs out of range",
                       KeyValue);
                break;
            }

            AddrFamilyConfig->MaxOpaqueInfoPtrs = KeyValue;
        }


        //
        // Query the 'max next hops per route' parameter
        //

        Status = RegQueryValueEx(ConfigHandle,
                                 REG_KEY_NEXTHOPS_IN_ROUTE,
                                 NULL,
                                 &KeyType,
                                 (PBYTE)&KeyValue,
                                 &KeySize);

        AddrFamilyConfig->MaxNextHopsInRoute = DEFAULT_NEXTHOPS_IN_ROUTE;

        if (Status == NO_ERROR)
        {
            if ((KeyValue < MIN_NEXTHOPS_IN_ROUTE) ||
                (KeyValue > MAX_NEXTHOPS_IN_ROUTE))
            {
                Trace1(ERR, 
                       "Address Family Config: # nexthops out of range",
                       KeyValue);
                break;
            }

            AddrFamilyConfig->MaxNextHopsInRoute = KeyValue;
        }


        //
        // Query the 'max handles returned in enum' parameter
        //

        Status = RegQueryValueEx(ConfigHandle,
                                 REG_KEY_MAX_HANDLES_IN_ENUM,
                                 NULL,
                                 &KeyType,
                                 (PBYTE)&KeyValue,
                                 &KeySize);

        AddrFamilyConfig->MaxHandlesInEnum = DEFAULT_MAX_HANDLES_IN_ENUM;

        if (Status == NO_ERROR)
        {
            if ((KeyValue < MIN_MAX_HANDLES_IN_ENUM) ||
                (KeyValue > MAX_MAX_HANDLES_IN_ENUM))
            {
                Trace1(ERR, 
                       "Address Family Config: # handles returned in enum",
                       KeyValue);
                break;
            }

            AddrFamilyConfig->MaxHandlesInEnum = KeyValue;
        }

        //
        // Close the instance key once you are done querying
        //

        RegCloseKey(ConfigHandle);

        TraceLeave("RtmReadAddressFamilyConfig");

        return NO_ERROR;
    }
    while (FALSE);

    //
    // Some error in the config - close handle and ret error
    //

    RegCloseKey(ConfigHandle);

    TraceLeave("RtmReadAddressFamilyConfig");

    return (Status != NO_ERROR) ? Status: ERROR_BAD_CONFIGURATION;
}


DWORD
WINAPI
RtmWriteAddressFamilyConfig (
    IN      USHORT                          RtmInstanceId,
    IN      USHORT                          AddressFamily,
    IN      PRTM_ADDRESS_FAMILY_CONFIG      AddrFamilyConfig
    )

/*++

Routine Description:

    Write the input address family config information
    into the registry.
    
Arguments:

    RtmInstanceId    - Instance to which addr family belongs to,

    AddressFamily    - ID for this address family,

    AddrFamilyConfig - Configuration info for this address family.

Return Value:

    Status of the operation.
    
--*/

{
    CHAR     AddressFamilySubKey[MAX_CONFIG_KEY_SIZE];
    HKEY     InstanceConfig;
    HKEY     ConfigHandle;
    ULONG    KeyValue;
    DWORD    Status;

    CHECK_FOR_RTM_API_INITIALIZED();

    TraceEnter("RtmWriteAddressFamilyConfig");

    //
    // Open the existing key that holds this RTM instance's config
    //

    _snprintf(RtmGlobals.RegistryPath + RTM_CONFIG_ROOT_SIZE - 1,
              MAX_CONFIG_KEY_SIZE,
              REG_KEY_INSTANCE_TEMPLATE,
              RtmInstanceId);

    Status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          RtmGlobals.RegistryPath,
                          0,
                          KEY_READ,
                          &InstanceConfig);

    if (Status != NO_ERROR)
    {
        //
        // Need to create an instance before creating addr family
        //

        Trace1(ERR, 
               "Address Family Config: Error %d opening instance key", 
               Status);

        TraceLeave("RtmWriteAddressFamilyConfig");

        return Status;
    }

    //
    // Create (or open existing) key to hold addr family's config
    //

    _snprintf(AddressFamilySubKey,
              MAX_CONFIG_KEY_SIZE,
              REG_KEY_ADDR_FAMILY_SUBKEY,
              AddressFamily);

    Status = RegCreateKeyEx(InstanceConfig,
                            AddressFamilySubKey,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_WRITE,
                            NULL,
                            &ConfigHandle,
                            NULL);

    // Close the instance key as you no longer need it
    RegCloseKey(InstanceConfig);

    if (Status != NO_ERROR)
    {
        Trace1(ERR, 
               "Address Family Config: Error %d creating address family key",
               Status);

        TraceLeave("RtmWriteAddressFamilyConfig");

        return Status;
    }

    //
    // Write values in address family config into the registry
    //

    do
    {
        //
        // Write the 'address size' value into the registry
        //

        KeyValue = AddrFamilyConfig->AddressSize;
        if ((KeyValue < MINIMUM_ADDRESS_SIZE) ||
            (KeyValue > MAXIMUM_ADDRESS_SIZE))
        {
            Trace1(ERR, 
                   "Address Family Config: Address Size %d out of bounds", 
                   KeyValue);
            break;
        }

        Status = RegSetValueEx(ConfigHandle,
                               REG_KEY_ADDRESS_SIZE,
                               0,
                               REG_DWORD,
                               (PBYTE)&KeyValue,
                               sizeof(ULONG));

        if (Status != NO_ERROR)
        {
            break;
        }

        //
        // Write the 'views supported' value into the registry
        //

        KeyValue = AddrFamilyConfig->ViewsSupported;
        if (KeyValue == 0)
        {
            Trace0(ERR, "Address Family Config: No supported views");
            break;
        }

        Status = RegSetValueEx(ConfigHandle,
                               REG_KEY_VIEWS_SUPPORTED,
                               0,
                               REG_DWORD,
                               (PBYTE)&KeyValue,
                               sizeof(ULONG));

        if (Status != NO_ERROR)
        {
            break;
        }


        //
        // Write 'max change notifications' value into registry
        //

        KeyValue = AddrFamilyConfig->MaxChangeNotifyRegns;
        if ((KeyValue < MIN_MAX_NOTIFY_REGS) ||
            (KeyValue > MAX_MAX_NOTIFY_REGS))
        {
            Trace1(ERR,
                   "Address Family Config: # Change notify regs out of range",
                   KeyValue);
            break;
        }

        Status = RegSetValueEx(ConfigHandle,
                               REG_KEY_MAX_NOTIFY_REGS,
                               0,
                               REG_DWORD,
                               (PBYTE)&KeyValue,
                               sizeof(ULONG));

        if (Status != NO_ERROR)
        {
            break;
        }


        //
        // Write 'max opaque info ptrs' value into registry
        //

        KeyValue = AddrFamilyConfig->MaxOpaqueInfoPtrs;
        if (((int)KeyValue < MIN_OPAQUE_INFO_PTRS) ||
            (KeyValue > MAX_OPAQUE_INFO_PTRS))
        {
            Trace1(ERR, 
                   "Address Family Config: # opaque ptrs out of range",
                   KeyValue);
            break;
        }

        Status = RegSetValueEx(ConfigHandle,
                               REG_KEY_OPAQUE_INFO_PTRS,
                               0,
                               REG_DWORD,
                               (PBYTE)&KeyValue,
                               sizeof(ULONG));

        if (Status != NO_ERROR)
        {
            break;
        }


        //
        // Write 'max next hops per route' value into registry
        //

        KeyValue = AddrFamilyConfig->MaxNextHopsInRoute;
        if ((KeyValue < MIN_NEXTHOPS_IN_ROUTE) ||
            (KeyValue > MAX_NEXTHOPS_IN_ROUTE))
        {
            Trace1(ERR, 
                   "Address Family Config: # nexthops out of range",
                   KeyValue);
            break;
        }

        Status = RegSetValueEx(ConfigHandle,
                               REG_KEY_NEXTHOPS_IN_ROUTE,
                               0,
                               REG_DWORD,
                               (PBYTE)&KeyValue,
                               sizeof(ULONG));

        if (Status != NO_ERROR)
        {
            break;
        }


        //
        // Write 'max handles returned in enum' value into registry
        //

        KeyValue = AddrFamilyConfig->MaxHandlesInEnum;
        if ((KeyValue < MIN_MAX_HANDLES_IN_ENUM) ||
            (KeyValue > MAX_MAX_HANDLES_IN_ENUM))
        {
            Trace1(ERR, 
                   "Address Family Config: # handles returned in enum",
                   KeyValue);
            break;
        }

        Status = RegSetValueEx(ConfigHandle,
                               REG_KEY_MAX_HANDLES_IN_ENUM,
                               0,
                               REG_DWORD,
                               (PBYTE)&KeyValue,
                               sizeof(ULONG));

        if (Status != NO_ERROR)
        {
            break;
        }


        //
        // Close the address family key once you are done writing
        //

        RegCloseKey(ConfigHandle);

        TraceLeave("RtmWriteAddressFamilyConfig");

        return NO_ERROR;
    }
    while (FALSE);

    //
    // Were config values out of bounds ? Adjust err code
    //

    if (Status == NO_ERROR)
    {
        Status = ERROR_INVALID_PARAMETER;
    }

    //
    // Error occured, close the handle and delete the key
    //

    Trace1(ERR, 
           "Address Family Config: Error %d writing address family params",
           Status);

    RegCloseKey(ConfigHandle);

    _snprintf(RtmGlobals.RegistryPath + RTM_CONFIG_ROOT_SIZE - 1,
              MAX_CONFIG_KEY_SIZE,
              REG_KEY_ADDR_FAMILY_TEMPLATE,
              RtmInstanceId,
              AddressFamily);

    RegDeleteKey(HKEY_LOCAL_MACHINE, RtmGlobals.RegistryPath);

    TraceLeave("RtmWriteAddressFamilyConfig");
        
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\rtmconst.h ===
/*++

Copyright (c) 1997-1998 Microsoft Corporation

Module Name:

    rtmconst.h

Abstract:
    Private Constants used in the RTMv2 DLL

Author:
    Chaitanya Kodeboyina (chaitk)  17-Aug-1998

Revision History:

--*/

#ifndef __ROUTING_RTMCONST_H__
#define __ROUTING_RTMCONST_H__

//
// Registry Key Names & Limits for configuration parameters
//

#define MAX_CONFIG_KEY_SIZE           260


#define RTM_CONFIG_ROOT               TEXT("SYSTEM"                      \
                                           "\\CurrentControlSet"         \
                                           "\\Services"                  \
                                           "\\RemoteAccess"              \
                                           "\\RoutingTableManager")

#define RTM_CONFIG_ROOT_SIZE          sizeof(RTM_CONFIG_ROOT)


#define REG_KEY_INSTANCE_SUBKEY       TEXT("Instance %05d")

#define REG_KEY_ADDR_FAMILY_SUBKEY    TEXT("AddressFamily %05d")


#define REG_KEY_INSTANCE_TEMPLATE     TEXT("\\Instance %05d")

#define REG_KEY_ADDR_FAMILY_TEMPLATE  TEXT("\\Instance %05d"            \
                                           "\\AddressFamily %05d")

#define DEFAULT_INSTANCE_ID           0

#define REG_KEY_VIEWS_SUPPORTED       TEXT("ViewsSupported")
#define DEFAULT_VIEWS_SUPPORTED       (RTM_VIEW_MASK_UCAST |            \
                                       RTM_VIEW_MASK_MCAST)


#define REG_KEY_ADDRESS_SIZE          TEXT("AddressSize")
#define MINIMUM_ADDRESS_SIZE          1
#define DEFAULT_ADDRESS_SIZE          4
#define MAXIMUM_ADDRESS_SIZE          RTM_MAX_ADDRESS_SIZE


#define REG_KEY_MAX_NOTIFY_REGS       TEXT("MaxChangeNotifyRegistrations")
#define MIN_MAX_NOTIFY_REGS           1
#define DEFAULT_MAX_NOTIFY_REGS       16
#define MAX_MAX_NOTIFY_REGS           32


#define REG_KEY_OPAQUE_INFO_PTRS      TEXT("MaxOpaqueInfoPointers")
#define MIN_OPAQUE_INFO_PTRS          0
#define DEFAULT_OPAQUE_INFO_PTRS      5
#define MAX_OPAQUE_INFO_PTRS          10


#define REG_KEY_NEXTHOPS_IN_ROUTE     TEXT("MaxNextHopsInRoute")
#define MIN_NEXTHOPS_IN_ROUTE         1
#define DEFAULT_NEXTHOPS_IN_ROUTE     3
#define MAX_NEXTHOPS_IN_ROUTE         10


#define REG_KEY_MAX_HANDLES_IN_ENUM   TEXT("MaxHandlesReturnedInEnum")
#define MIN_MAX_HANDLES_IN_ENUM       1
#define DEFAULT_MAX_HANDLES_IN_ENUM   25
#define MAX_MAX_HANDLES_IN_ENUM       100


//
// Number of bits in a byte (or an octet)
//
#define BITS_IN_BYTE          (UINT) 8


//
// RTM supported view related constants
//

#define VIEW_MASK(id) (DWORD) (1 << (id))


//
// RTM supported CN related constants
//

#define CN_MASK(id)   (DWORD) (1 << (id))

#define NUM_CHANGED_DEST_LISTS        16


//
// Types of various data structures
//

#define GENERIC_TYPE                0x00

#define INSTANCE_TYPE               0x01
#define ADDRESS_FAMILY_TYPE         0x02
#define ENTITY_TYPE                 0x03

#define DEST_TYPE                   0x04
#define ROUTE_TYPE                  0x05
#define NEXTHOP_TYPE                0x06

#define DEST_ENUM_TYPE              0x07
#define ROUTE_ENUM_TYPE             0x08
#define NEXTHOP_ENUM_TYPE           0x09

#define NOTIFY_TYPE                 0x0A

#define ROUTE_LIST_TYPE             0x0B
#define LIST_ENUM_TYPE              0x0C

#define V1_REGN_TYPE                0x0D
#define V1_ENUM_TYPE                0x0E


#if DBG_HDL

//
// Type & Signature of allocated structures
//

#define GENERIC_ALLOC              '+GN0'

#define INSTANCE_ALLOC             '+IN1'
#define ADDRESS_FAMILY_ALLOC       '+AF2'
#define ENTITY_ALLOC               '+EN3'

#define DEST_ALLOC                 '+DT4'
#define ROUTE_ALLOC                '+RT5'
#define NEXTHOP_ALLOC              '+NH6'

#define DEST_ENUM_ALLOC            '+DE7'
#define ROUTE_ENUM_ALLOC           '+RE8'
#define NEXTHOP_ENUM_ALLOC         '+NE9'

#define NOTIFY_ALLOC               '+NOA'

#define ROUTE_LIST_ALLOC           '+ELB'
#define LIST_ENUM_ALLOC            '+LEC'

#define V1_REGN_ALLOC              '+1RD'
#define V1_ENUM_ALLOC              '+1EE'

extern const DWORD OBJECT_SIGNATURE[];

//
// Type & Signature of internal structures
// previously allocated, but are now freed
//

#define INSTANCE_FREED             '-IN1'
#define ADDRESS_FAMILY_FREED       '-AF2'
#define ENTITY_FREED               '-EN3'

#define DEST_FREED                 '-DT4'
#define ROUTE_FREED                '-RT5'
#define NEXTHOP_FREED              '-NH6'

#define DEST_ENUM_FREED            '-DE7'
#define ROUTE_ENUM_FREED           '-RE8'
#define NEXTHOP_ENUM_FREED         '-NE9'

#define NOTIFY_FREED               '-NOA'

#define ROUTE_LIST_FREED           '-ELB'
#define LIST_ENUM_FREED            '-LEC'

#define V1_REGN_FREED              '-1RD'
#define V1_ENUM_FREED              '-1EE'

//
// Signature byte that indicates if memory
// allocated for an object has been freed
//

#define ALLOC                      '+'
#define FREED                      '-'

#endif // DBG_HDL


#if _DBG_

//
// Cleanup Functions for internal structures
//

#define DEFINE_DESTROY_FUNC(Name)      \
    DWORD                              \
    Name (PVOID);

DEFINE_DESTROY_FUNC(DestroyGeneric);
DEFINE_DESTROY_FUNC(DestroyInstance);
DEFINE_DESTROY_FUNC(DestroyAddressFamily);
DEFINE_DESTROY_FUNC(DestroyEntity);
DEFINE_DESTROY_FUNC(DestroyDest);
DEFINE_DESTROY_FUNC(DestroyRoute);
DEFINE_DESTROY_FUNC(DestroyNextHop);
DEFINE_DESTROY_FUNC(DestroyDestEnum);
DEFINE_DESTROY_FUNC(DestroyRouteEnum);
DEFINE_DESTROY_FUNC(DestroyNextHopEnum);
DEFINE_DESTROY_FUNC(DestroyChangeNotification);
DEFINE_DESTROY_FUNC(DestroyEntityList);
DEFINE_DESTROY_FUNC(DestroyEntityListEnum);

typedef DWORD (*DestroyFunc) (PVOID Pointer);

const DestroyFunc OBJECT_DESTROY_FUNCTION[] = 
{
    DestroyGeneric,
    DestroyInstance,
    DestroyAddressFamily,
    DestroyEntity,
    DestroyDest,
    DestroyRoute,
    DestroyNextHop,
    DestroyDestEnum,
    DestroyRouteEnum,
    DestroyNextHopEnum,
    DestroyChangeNotification
    DestroyEntityList,
    DestroyEntityListEnum
};

#endif // _DBG_

//
// Reference Counting related constants
//

#define MAX_REFS                   0x10

#define CREATION_REF               0x00
#define ADDR_FAMILY_REF            0x01
#define ENTITY_REF                 0x02

#define DEST_REF                   0x03
#define ROUTE_REF                  0x04
#define NEXTHOP_REF                0x05

#define ENUM_REF                   0x06
#define NOTIFY_REF                 0x07
#define LIST_REF                   0x08

#define HOLD_REF                   0x09

#define TIMER_REF                  0x0D
#define TEMP_USE_REF               0x0E
#define HANDLE_REF                 0x0F

extern const CHAR  *REF_NAME[MAX_REFS];

#endif //__ROUTING_RTMCONST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\rtmglob.h ===
/*++

Copyright (c) 1997-1998 Microsoft Corporation

Module Name:

    rtmglob.h

Abstract:
    Global Vars for Routing Table Manager DLL

Author:
    Chaitanya Kodeboyina (chaitk)  25-Sep-1998

Revision History:

--*/

#ifndef __ROUTING_RTMGLOB_H__
#define __ROUTING_RTMGLOB_H__

//
// Global Information common to all RTM instances
//

#define INSTANCE_TABLE_SIZE            1

typedef struct _RTMP_GLOBAL_INFO
{
    ULONG             TracingHandle;    //
    HANDLE            LoggingHandle;    // Handles to debugging functionality
    ULONG             LoggingLevel;     //

    DWORD             TracingFlags;     // Flags that control debug tracing

    HANDLE            GlobalHeap;       // Handle to the private memory heap

#if DBG_MEM
    CRITICAL_SECTION  AllocsLock;       // Protects the list of allocations

    LIST_ENTRY        AllocsList;       // List of all allocated mem blocks
#endif

    PCHAR             RegistryPath;     // Registry Key that has RTM config

    RTL_RESOURCE      InstancesLock;    // Protects the instances' table
                                        // and instance infos themselves
                                        // and RTM API Initialization too

    BOOL              ApiInitialized;   // TRUE if API has been initialized

    UINT              NumInstances;     // Global table of all RTM instances
    LIST_ENTRY        InstanceTable[INSTANCE_TABLE_SIZE];
} 
RTMP_GLOBAL_INFO, *PRTMP_GLOBAL_INFO;


//
// Externs for global variables for the RTMv2 DLL
//

extern RTMP_GLOBAL_INFO  RtmGlobals;


//
// Macros for acquiring various locks defined in this file
//

#if DBG_MEM

#define ACQUIRE_ALLOCS_LIST_LOCK()                           \
    ACQUIRE_LOCK(&RtmGlobals.AllocsLock)

#define RELEASE_ALLOCS_LIST_LOCK()                           \
    RELEASE_LOCK(&RtmGlobals.AllocsLock)

#endif


#define ACQUIRE_INSTANCES_READ_LOCK()                        \
    ACQUIRE_READ_LOCK(&RtmGlobals.InstancesLock)

#define RELEASE_INSTANCES_READ_LOCK()                        \
    RELEASE_READ_LOCK(&RtmGlobals.InstancesLock)

#define ACQUIRE_INSTANCES_WRITE_LOCK()                       \
    ACQUIRE_WRITE_LOCK(&RtmGlobals.InstancesLock)

#define RELEASE_INSTANCES_WRITE_LOCK()                       \
    RELEASE_WRITE_LOCK(&RtmGlobals.InstancesLock)

//
// Macros for controlling the amount of tracing in this dll
//

#if DBG_TRACE

#define TRACING_ENABLED(Type)                                \
    (RtmGlobals.TracingFlags & RTM_TRACE_ ## Type)

#endif 

//
// Other common helper functions
//

#if DBG_MEM

VOID
DumpAllocs (VOID);

#endif

#endif //__ROUTING_RTMGLOB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\rtminfo.h ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtminfo.h

Abstract:

    Contains defines related to getting info
    on various objects pointed to by handles.

Author:

    Chaitanya Kodeboyina (chaitk)   04-Sep-1998

Revision History:

--*/

#ifndef __ROUTING_RTMINFO_H__
#define __ROUTING_RTMINFO_H__

//
// Macro to allocate the var-sized DestInfo structure
//

#define AllocDestInfo(_NumViews_)                                             \
          (PRTM_DEST_INFO) AllocNZeroMemory(RTM_SIZE_OF_DEST_INFO(_NumViews_))

//
// Info Helper Functions
//

VOID
GetDestInfo (
    IN      PENTITY_INFO                    Entity,
    IN      PDEST_INFO                      Dest,
    IN      ULONG                           ProtocolId,
    IN      RTM_VIEW_SET                    TargetViews,
    OUT     PRTM_DEST_INFO                  DestInfo
);


VOID
WINAPI
GetRouteInfo (
    IN      PDEST_INFO                      Dest,
    IN      PROUTE_INFO                     Route,
    OUT     PRTM_ROUTE_INFO                 RouteInfo
    );

#endif //__ROUTING_RTMINFO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\rtmenum.h ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmenum.h

Abstract:

    Contains definitions for managing enumerations
    over destinations, routes and next hops in RTM.

Author:

    Chaitanya Kodeboyina (chaitk)   23-Aug-1998

Revision History:

--*/

#ifndef __ROUTING_RTMENUM_H__
#define __ROUTING_RTMENUM_H__


//
// Enumeration Over Destinations
//

typedef struct _DEST_ENUM
{
    OPEN_HEADER       EnumHeader;       // Enumeration Type and Reference Count

    RTM_VIEW_SET      TargetViews;      // Views over which enum is active

    UINT              NumberOfViews;    // Num of views in which enum is active

    ULONG             ProtocolId;       // OSPF, RIP, BEST_PROTOCOL etc.

    RTM_ENUM_FLAGS    EnumFlags;        // See RTM_ENUM_FLAGS in rtmv2.h

#if DBG
    RTM_NET_ADDRESS   StartAddress;     // First NetAddress in the enum
#endif

    RTM_NET_ADDRESS   StopAddress;      // Last NetAddress in the enum

    CRITICAL_SECTION  EnumLock;         // Lock that protects the 'NextDest'

    BOOL              EnumDone;         // Set to TRUE once last item is got

    RTM_NET_ADDRESS   NextDest;         // Points to the next dest in the enum
}
DEST_ENUM, *PDEST_ENUM;



//
// Enumeration Over Routes
//

typedef struct _ROUTE_ENUM
{
    OPEN_HEADER       EnumHeader;       // Enumeration Type and Reference Count

    RTM_VIEW_SET      TargetViews;      // Views over which enum is active

    RTM_ENUM_FLAGS    EnumFlags;        // See RTM_ENUM_FLAGS in rtmv2.h

    RTM_MATCH_FLAGS   MatchFlags;       // See RTM_MATCH_FLAGS in rtmv2.h

    PRTM_ROUTE_INFO   CriteriaRoute;    // Match criteria used with flags above

    ULONG             CriteriaInterface;// Interface on which routes r enum'ed

    CRITICAL_SECTION  EnumLock;         // Lock that protects the fields below

    PDEST_ENUM        DestEnum;         // Enum over dests (if enum'ing routes
                                        // on all destinations in the table)

    PRTM_DEST_INFO    DestInfo;         // Temp buffer used in above dest enum

    BOOL              EnumDone;         // Set to TRUE once last item is got

    PDEST_INFO        Destination;      // Dest for routes that we r enum'ing,

    UINT              NextRoute;        // Route to be given next on the dest

    UINT              MaxRoutes;        // Number of route slots in this array
    UINT              NumRoutes;        // Actual number of routes in the array
    PROUTE_INFO      *RoutesOnDest;     // Array of routes on this destination
}
ROUTE_ENUM, *PROUTE_ENUM;



//
// Enumeration Over Next Hops
//

typedef struct _NEXTHOP_ENUM
{
    OPEN_HEADER       EnumHeader;       // Enumeration Type and Reference Count

    RTM_ENUM_FLAGS    EnumFlags;        // See RTM_ENUM_FLAGS

#if DBG
    RTM_NET_ADDRESS   StartAddress;     // First NetAddress in the enum
#endif

    RTM_NET_ADDRESS   StopAddress;      // Last NetAddress in the enum

    CRITICAL_SECTION  EnumLock;         // Lock that protects the 'NextNextHop'

    BOOL              EnumDone;         // Set to TRUE once last item is got

    RTM_NET_ADDRESS   NextAddress;      // Address of next next-hop in the enum

    ULONG             NextIfIndex;      // Interface of next next-hop in enum
}
NEXTHOP_ENUM, *PNEXTHOP_ENUM;

//
// Used to indicate the posn of 1st
// next-hop on a list of next-hops
//

#define START_IF_INDEX    (ULONG) (-1)

//
// Macro for determinining the type of enumeration handle
//

#define GET_ENUM_TYPE(EnumHandle, Enum)                                      \
  (                                                                          \
      *Enum = (POPEN_HEADER) GetObjectFromHandle(EnumHandle, GENERIC_TYPE),  \
      (*Enum)->HandleType                                                    \
  )
    

//
// Macros for acquiring various locks defined in this file
// 

#define ACQUIRE_DEST_ENUM_LOCK(DestEnum)                                     \
    ACQUIRE_LOCK(&DestEnum->EnumLock)

#define RELEASE_DEST_ENUM_LOCK(DestEnum)                                     \
    RELEASE_LOCK(&DestEnum->EnumLock)


#define ACQUIRE_ROUTE_ENUM_LOCK(RouteEnum)                                   \
    ACQUIRE_LOCK(&RouteEnum->EnumLock)

#define RELEASE_ROUTE_ENUM_LOCK(RouteEnum)                                   \
    RELEASE_LOCK(&RouteEnum->EnumLock)


#define ACQUIRE_NEXTHOP_ENUM_LOCK(RouteEnum)                                 \
    ACQUIRE_LOCK(&RouteEnum->EnumLock)

#define RELEASE_NEXTHOP_ENUM_LOCK(RouteEnum)                                 \
    RELEASE_LOCK(&RouteEnum->EnumLock)

//
// Enumeration helper functions
//

BOOL
MatchRouteWithCriteria (
    IN      PROUTE_INFO                     Route,
    IN      RTM_MATCH_FLAGS                 MatchingFlags,
    IN      PRTM_ROUTE_INFO                 CriteriaRouteInfo,
    IN      ULONG                           CriteriaInterface
    );

#endif //  __ROUTING_RTMENUM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\rtminfo.c ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtminfo.c

Abstract:

    Contains routines for getting information
    on various objects pointed to by handles.

Author:

    Chaitanya Kodeboyina (chaitk)  22-Aug-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop


DWORD
WINAPI
RtmGetEntityInfo (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ENTITY_HANDLE               EntityHandle,
    OUT     PRTM_ENTITY_INFO                EntityInfo
    )

/*++

Routine Description:

    Retrieves information pertaining to a registered entity.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    EntityHandle      - RTM handle for entity whose info we want,

    EntityInfo        - Block in which the entity info is returned.

Return Value:

    Status of the operation

--*/

{
    PADDRFAM_INFO    AddrFamilyInfo;
    PENTITY_INFO     Entity;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_ENTITY_HANDLE(EntityHandle, &Entity);

    //
    // Copy the entity information to output buffer
    //

    AddrFamilyInfo = Entity->OwningAddrFamily;

    EntityInfo->RtmInstanceId = AddrFamilyInfo->Instance->RtmInstanceId;

    EntityInfo->AddressFamily = AddrFamilyInfo->AddressFamily;

    EntityInfo->EntityId = Entity->EntityId;

    return NO_ERROR;
}


DWORD
WINAPI
RtmGetDestInfo (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_DEST_HANDLE                 DestHandle,
    IN      ULONG                           ProtocolId,
    IN      RTM_VIEW_SET                    TargetViews,
    OUT     PRTM_DEST_INFO                  DestInfo
    )

/*++

Routine Description:

    Retrieves information for a destination in the route table

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    DestHandle        - RTM handle for dest whose info we want,

    ProtocolId        - Protocol whose best route info is retd,

    TargetViews       - Views in which best route info is retd,

    DestInfo          - Block in which the dest info is returned.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO     Entity;
    PDEST_INFO       Dest;

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    // VALIDATE_DEST_HANDLE(DestHandle, &Dest);
    Dest = DEST_FROM_HANDLE(DestHandle);
    if (!Dest)
    {
        return ERROR_INVALID_HANDLE;
    }

    ACQUIRE_DEST_READ_LOCK(Dest);

    GetDestInfo(Entity, 
                Dest, 
                ProtocolId,
                TargetViews,
                DestInfo);

    RELEASE_DEST_READ_LOCK(Dest);

    return NO_ERROR;
}


VOID
GetDestInfo (
    IN      PENTITY_INFO                    Entity,
    IN      PDEST_INFO                      Dest,
    IN      ULONG                           ProtocolId,
    IN      RTM_VIEW_SET                    TargetViews,
    OUT     PRTM_DEST_INFO                  DestInfo
)

/*++

Routine Description:

    Retrieves information for a destination in the route table

Arguments:

    Entity            - RTM registration info for calling entity,

    Dest              - Pointer to the dest whose info we want,

    ProtocolId        - Protocol whose best route info is retd,

    TargetViews       - Views in which best route info is retd,

    DestInfo          - Block in which the dest info is returned.

Return Value:

    None

--*/

{
    PENTITY_INFO     Owner;
    PROUTE_INFO      Route;
    RTM_VIEW_SET     ViewsSeen;
    RTM_VIEW_SET     ViewSet;
    RTM_VIEW_SET     BelongsToViews;
    PLIST_ENTRY      p;
    UINT             i, j, k;

    // Limit caller's interest to set of views supported
    TargetViews &= Entity->OwningAddrFamily->ViewsSupported;

    //
    // Copy dest info to output and ref handles given out
    //

    DestInfo->DestHandle = MAKE_HANDLE_FROM_POINTER(Dest);

    REFERENCE_DEST(Dest, HANDLE_REF);

    CopyMemory(&DestInfo->DestAddress,
               &Dest->DestAddress,
               sizeof(RTM_NET_ADDRESS));

    DestInfo->LastChanged = Dest->LastChanged;

    DestInfo->BelongsToViews = Dest->BelongsToViews;

    //
    // Copy the holddown route out in all requested views
    //

    ViewSet = TargetViews;
    
    for (i = j = 0; ViewSet && (i < RTM_VIEW_MASK_SIZE); i++)
    {
        if (ViewSet & 0x01)
        {
            k = Entity->OwningAddrFamily->ViewIndexFromId[i];

            Route = Dest->ViewInfo[k].HoldRoute;

            //
            // Init view info and fill the holddown route
            //

            ZeroMemory(&DestInfo->ViewInfo[j], sizeof(DestInfo->ViewInfo[0]));

            DestInfo->ViewInfo[j].ViewId = i;

            if (Route)
            {
                DestInfo->ViewInfo[j].HoldRoute = 
                            MAKE_HANDLE_FROM_POINTER(Route);

                REFERENCE_ROUTE(Route, HANDLE_REF);
            }

            j++;
        }

        ViewSet >>= 1;
    }

    // Keep track of total number of view info slots filled in
    DestInfo->NumberOfViews = j;

    //
    // Fill up information in all the views he is interested in
    //

    if (TargetViews & Dest->BelongsToViews)
    {
        // Resolve the protocol id if it is RTM_THIS_PROTOCOL

        if (ProtocolId == RTM_THIS_PROTOCOL)
        {
            ProtocolId = Entity->EntityId.EntityProtocolId;
        }

        ViewsSeen = 0;

        //
        // Copy best route in each view & ref handles given out
        //

        for (p = Dest->RouteList.Flink; p != &Dest->RouteList; p = p->Flink)
        {
            Route = CONTAINING_RECORD(p, ROUTE_INFO, DestLE);

            //
            // Make sure that this agrees with our protocol id
            //

            Owner = ENTITY_FROM_HANDLE(Route->RouteInfo.RouteOwner);

            if (ProtocolId != RTM_BEST_PROTOCOL)
            {
                if (Owner->EntityId.EntityProtocolId != ProtocolId)
                {
                    continue;
                }
            }   

            //
            // Does this route belong to any interested views
            //

            if ((TargetViews & Route->RouteInfo.BelongsToViews) == 0)
            {
                continue;
            }

            //
            // Update dest info in each view that route belongs to
            //

            BelongsToViews = Route->RouteInfo.BelongsToViews;

            ViewSet = TargetViews;

            for (i = j = 0; ViewSet && (i < RTM_VIEW_MASK_SIZE); i++)
            {
                if (ViewSet & 0x01)
                {
                    if (BelongsToViews & 0x01)
                    {
                        //
                        // Increment number of routes in this view
                        //

                        DestInfo->ViewInfo[j].NumRoutes++;

                        //
                        // If you not already seen this view (in
                        // other words got the best route in it)
                        // update the DestInfo for this view now
                        //

                        if (!(ViewsSeen & VIEW_MASK(i)))
                        {
                            DestInfo->ViewInfo[j].Route = 
                                    MAKE_HANDLE_FROM_POINTER(Route);

                            REFERENCE_ROUTE(Route, HANDLE_REF);


                            DestInfo->ViewInfo[j].Owner = 
                                    MAKE_HANDLE_FROM_POINTER(Owner);

                            REFERENCE_ENTITY(Owner, HANDLE_REF);


                            DestInfo->ViewInfo[j].DestFlags = 
                                            Route->RouteInfo.Flags;
                        }
                    }

                    j++;
                }

                ViewSet >>= 1;

                BelongsToViews >>= 1;
            }

            ViewsSeen |= Route->RouteInfo.BelongsToViews;
        }
    }

    return;
}


DWORD
WINAPI
RtmGetRouteInfo (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ROUTE_HANDLE                RouteHandle,
    OUT     PRTM_ROUTE_INFO                 RouteInfo   OPTIONAL,
    OUT     PRTM_NET_ADDRESS                DestAddress OPTIONAL
    )

/*++

Routine Description:

    Retrieves information for a route in the route table

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    RouteHandle       - RTM handle for route whose info we want,

    RouteInfo         - Block in which the route info is returned.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO     Entity;
    PROUTE_INFO      Route;
    PDEST_INFO       Dest;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

#if 1
    Route = ROUTE_FROM_HANDLE(RouteHandle);                         

    if (!Route)
    {                                                               
        return ERROR_INVALID_HANDLE;                                
    }                                                               

#else
    VALIDATE_ROUTE_HANDLE(RouteHandle, &Route);
#endif

    Dest = DEST_FROM_HANDLE(Route->RouteInfo.DestHandle);

    // Get a consitent picture of the route

    ACQUIRE_DEST_READ_LOCK(Dest);

    if (ARGUMENT_PRESENT(RouteInfo))
    {
        GetRouteInfo(Dest, Route, RouteInfo);
    }

    RELEASE_DEST_READ_LOCK(Dest);

    // No lock reqd - dest addr is constant

    if (ARGUMENT_PRESENT(DestAddress))
    {
        CopyMemory(DestAddress, &Dest->DestAddress, sizeof(RTM_NET_ADDRESS));
    }

    return NO_ERROR;
}


VOID
WINAPI
GetRouteInfo (
    IN      PDEST_INFO                      Dest,
    IN      PROUTE_INFO                     Route,
    OUT     PRTM_ROUTE_INFO                 RouteInfo
    )

/*++

Routine Description:

    Retrieves information for a route in the route table

Arguments:

    Dest              - Pointer to the destination of the route,

    Route             - Pointer to the route whose info we want,

    RouteInfo         - Block in which the route info is returned.

Return Value:

    None

--*/

{
    PENTITY_INFO     Entity;
    PNEXTHOP_INFO    Neighbour;
    PNEXTHOP_INFO    NextHop;
    UINT             NumBytes;
    UINT             i;

    //
    // Copy the route information to output buffer
    //

    NumBytes = sizeof(RTM_ROUTE_INFO) + 
                    sizeof(RTM_NEXTHOP_HANDLE) *
                        (Route->RouteInfo.NextHopsList.NumNextHops - 1);

    CopyMemory(RouteInfo, &Route->RouteInfo, NumBytes);

    //
    // Reference handles that are given out in info
    //

    Entity = ENTITY_FROM_HANDLE(RouteInfo->RouteOwner);
    REFERENCE_ENTITY(Entity, HANDLE_REF);

    if (RouteInfo->Neighbour)
    {
        Neighbour = NEXTHOP_FROM_HANDLE(RouteInfo->Neighbour);
        REFERENCE_NEXTHOP(Neighbour, HANDLE_REF);
    }

    for (i = 0; i < RouteInfo->NextHopsList.NumNextHops; i++)
    {
        NextHop = NEXTHOP_FROM_HANDLE(RouteInfo->NextHopsList.NextHops[i]);
        REFERENCE_NEXTHOP(NextHop, HANDLE_REF);
    }

    REFERENCE_DEST(Dest, HANDLE_REF);

    return;
}


DWORD
WINAPI
RtmGetNextHopInfo (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NEXTHOP_HANDLE              NextHopHandle,
    OUT     PRTM_NEXTHOP_INFO               NextHopInfo
    )

/*++

Routine Description:

    Retrieves information for a next-hop in the route table

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    NextHopHandle     - RTM handle for next-hop whose info we want,

    NextHopInfo       - Block in which the next-hop info is returned.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO     Entity;
    PNEXTHOP_INFO    NextHop;
    PDEST_INFO       Dest;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_NEXTHOP_HANDLE(NextHopHandle, &NextHop);

    Entity = ENTITY_FROM_HANDLE(NextHop->NextHopInfo.NextHopOwner);

    ACQUIRE_NHOP_TABLE_READ_LOCK(Entity);

    //
    // Copy the next-hop information to output buffer
    //

    CopyMemory(NextHopInfo, &NextHop->NextHopInfo, sizeof(RTM_NEXTHOP_INFO));

    //
    // Reference handles that are given out in info
    //

    if (NextHop->NextHopInfo.RemoteNextHop)
    {
        Dest = DEST_FROM_HANDLE(NextHop->NextHopInfo.RemoteNextHop);
        REFERENCE_DEST(Dest, HANDLE_REF);
    }

    REFERENCE_ENTITY(Entity, HANDLE_REF);

    RELEASE_NHOP_TABLE_READ_LOCK(Entity);

    return NO_ERROR;
}


DWORD
WINAPI
RtmReleaseEntityInfo (
    IN      RTM_ENTITY_HANDLE              RtmRegHandle,
    IN      PRTM_ENTITY_INFO               EntityInfo
    )

/*++

Routine Description:

    Releases all handles present in the input info structure

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    EntityInfo        - All handles in this info are de-referenced.

Return Value:

    Status of the operation

--*/

{
    UNREFERENCED_PARAMETER(RtmRegHandle);
    UNREFERENCED_PARAMETER(EntityInfo);

    return NO_ERROR;
}


DWORD
WINAPI
RtmReleaseDestInfo (
    IN      RTM_ENTITY_HANDLE              RtmRegHandle,
    IN      PRTM_DEST_INFO                 DestInfo
    )

/*++

Routine Description:

    Releases all handles present in the input info structure

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    DestInfo          - All handles in this info are de-referenced.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO     Entity;
    PENTITY_INFO     Owner;
    PDEST_INFO       Dest;
    PROUTE_INFO      Route;
    UINT             i;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    for (i = 0; i < DestInfo->NumberOfViews; i++)
    {
        //
        // If a best route, dereference it and its owner
        //

        if (DestInfo->ViewInfo[i].Route)
        {
            Route = ROUTE_FROM_HANDLE(DestInfo->ViewInfo[i].Route);
            DEREFERENCE_ROUTE(Route, HANDLE_REF);

            Owner = ENTITY_FROM_HANDLE(DestInfo->ViewInfo[i].Owner);
            DEREFERENCE_ENTITY(Owner, HANDLE_REF);
        }

        //
        // If we have a holddown route, dereference it
        //

        if (DestInfo->ViewInfo[i].HoldRoute)
        {
            Route = ROUTE_FROM_HANDLE(DestInfo->ViewInfo[i].HoldRoute);
            DEREFERENCE_ROUTE(Route, HANDLE_REF);
        }
    }

    Dest = DEST_FROM_HANDLE(DestInfo->DestHandle);
    DEREFERENCE_DEST(Dest, HANDLE_REF);

    return NO_ERROR;
}


DWORD
WINAPI
RtmReleaseRouteInfo (
    IN      RTM_ENTITY_HANDLE              RtmRegHandle,
    IN      PRTM_ROUTE_INFO                RouteInfo
    )

/*++

Routine Description:

    Releases all handles present in the input info structure

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    RouteInfo         - All handles in this info are de-referenced.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO     Entity;
    PDEST_INFO       Dest;
    PNEXTHOP_INFO    Neighbour;
    PNEXTHOP_INFO    NextHop;
    UINT             i;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    for (i = 0; i < RouteInfo->NextHopsList.NumNextHops; i++)
    {
        NextHop = NEXTHOP_FROM_HANDLE(RouteInfo->NextHopsList.NextHops[i]);
        DEREFERENCE_NEXTHOP(NextHop, HANDLE_REF);
    }

    if (RouteInfo->Neighbour)
    {
        Neighbour = NEXTHOP_FROM_HANDLE(RouteInfo->Neighbour);
        DEREFERENCE_NEXTHOP(Neighbour, HANDLE_REF);
    }

    Entity = ENTITY_FROM_HANDLE(RouteInfo->RouteOwner);
    DEREFERENCE_ENTITY(Entity, HANDLE_REF);

    Dest = DEST_FROM_HANDLE(RouteInfo->DestHandle);
    DEREFERENCE_DEST(Dest, HANDLE_REF);

    return NO_ERROR;
}


DWORD
WINAPI
RtmReleaseNextHopInfo (
    IN      RTM_ENTITY_HANDLE              RtmRegHandle,
    IN      PRTM_NEXTHOP_INFO              NextHopInfo
    )
    
/*++

Routine Description:

    Releases all handles present in the input info structure

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    NextHopInfo       - All handles in this info are de-referenced.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO     Entity;
    PDEST_INFO       Dest;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    if (NextHopInfo->RemoteNextHop)
    {
        Dest = DEST_FROM_HANDLE(NextHopInfo->RemoteNextHop);

        if (Dest)
        {
            DEREFERENCE_DEST(Dest, HANDLE_REF);
        }
    }

    Entity = ENTITY_FROM_HANDLE(NextHopInfo->NextHopOwner);
    DEREFERENCE_ENTITY(Entity, HANDLE_REF);

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\rtmlist.c ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmlist.c

Abstract:

    Contains routines for managing entity-specific
    list of routes in RTM.

Author:

    Chaitanya Kodeboyina (chaitk)   10-Sep-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop


DWORD
WINAPI
RtmCreateRouteList (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    OUT     PRTM_ROUTE_LIST_HANDLE          RouteListHandle
    )

/*++

Routine Description:

    Creates a list in which the caller can keep routes owned
    by it.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity

    RouteListHandle   - Handle to the new route list is returned

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO    Entity;
    PROUTE_LIST     RouteList;

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    //
    // Create and initialize a new route list
    //

    RouteList = (PROUTE_LIST) AllocNZeroObject(sizeof(ROUTE_LIST));

    if (RouteList == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

#if DBG_HDL
    RouteList->ListHeader.ObjectHeader.TypeSign = ROUTE_LIST_ALLOC;

    RouteList->ListHeader.HandleType = ROUTE_LIST_TYPE;
#endif

    InitializeListHead(&RouteList->ListHead);

#if DBG_HDL
    //
    // Insert into list of handles opened by entity
    //

    ACQUIRE_OPEN_HANDLES_LOCK(Entity);
    InsertTailList(&Entity->OpenHandles, &RouteList->ListHeader.HandlesLE);
    RELEASE_OPEN_HANDLES_LOCK(Entity);
#endif

    REFERENCE_ENTITY(Entity, LIST_REF);

    //
    // Make a handle to the route list and return
    //

    *RouteListHandle = MAKE_HANDLE_FROM_POINTER(RouteList);

    return NO_ERROR;
}


DWORD
WINAPI
RtmInsertInRouteList (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ROUTE_LIST_HANDLE           RouteListHandle OPTIONAL,
    IN      UINT                            NumRoutes,
    IN      PRTM_ROUTE_HANDLE               RouteHandles
    )

/*++

Routine Description:

    Inserts a set of routes into the route list. If any route
    is already in another route list, it is removed from this
    old list in the process.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity

    RouteListHandle   - Handle to the route list into which we are
                        moving the routes to; if this argument is 
                        NULL then we are just removing the routes 
                        from the route lists to which they belonged

    NumRoutes         - Num. of route handles in the input buffer

    RouteHandles      - Array of handles to insert into the new list

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO    Entity;
    PROUTE_LIST     RouteList;
    PROUTE_INFO     Route;
    UINT            i;

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    RouteList = NULL;

    if (ARGUMENT_PRESENT(RouteListHandle))
    {
        VALIDATE_ROUTE_LIST_HANDLE(RouteListHandle, &RouteList);
    }

    ACQUIRE_ROUTE_LISTS_WRITE_LOCK(Entity);

    for (i = 0; i < NumRoutes; i++)
    {
        Route = ROUTE_FROM_HANDLE(RouteHandles[i]);

        ASSERT(Route->RouteInfo.RouteOwner == RtmRegHandle);

        //
        // Remove from old list if it was present in one
        //

        if (!IsListEmpty(&Route->RouteListLE))
        {
            RemoveEntryList(&Route->RouteListLE);

            DEREFERENCE_ROUTE(Route, LIST_REF);
        }

        //
        // Insert in the new list if a new list is specified
        //

        if (RouteList)
        {
            InsertTailList(&RouteList->ListHead, &Route->RouteListLE);

            REFERENCE_ROUTE(Route, LIST_REF);
        }
    }

    RELEASE_ROUTE_LISTS_WRITE_LOCK(Entity);

    return NO_ERROR;
}


DWORD
WINAPI
RtmCreateRouteListEnum (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ROUTE_LIST_HANDLE           RouteListHandle,
    OUT     PRTM_ENUM_HANDLE                RtmEnumHandle
    )

/*++

Routine Description:

    Creates a enumeration on routes in the specified route list.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    RouteListHandle   - Handle to route list whose routes we want,

    RtmEnumHandle     - Handle to this enumeration, which is used
                        in calls to get routes in the route list

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO  Entity;
    PROUTE_LIST   RouteList;
    PLIST_ENUM    Enum;

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_ROUTE_LIST_HANDLE(RouteListHandle, &RouteList);

    //
    // Create and initialize an list enumeration block
    //

    Enum = (PLIST_ENUM) AllocNZeroObject(sizeof(LIST_ENUM));
    if (Enum == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

#if DBG_HDL
    Enum->EnumHeader.ObjectHeader.TypeSign = LIST_ENUM_ALLOC;
#endif
    Enum->EnumHeader.HandleType = LIST_ENUM_TYPE;

    Enum->RouteList = RouteList;

    //
    // Insert marker into the route list
    //

    ACQUIRE_ROUTE_LISTS_WRITE_LOCK(Entity);
    InsertHeadList(&RouteList->ListHead, &Enum->MarkerRoute.RouteListLE);
    RELEASE_ROUTE_LISTS_WRITE_LOCK(Entity);

#if DBG_HDL
    //
    // Insert into the list of handles opened by entity
    //
  
    ACQUIRE_OPEN_HANDLES_LOCK(Entity);
    InsertTailList(&Entity->OpenHandles,&Enum->EnumHeader.HandlesLE);
    RELEASE_OPEN_HANDLES_LOCK(Entity);
#endif

    REFERENCE_ENTITY(Entity, ENUM_REF);

    //
    // Make a handle to the enum block and return
    //
    
    *RtmEnumHandle = MAKE_HANDLE_FROM_POINTER(Enum);

    return NO_ERROR;
}


DWORD
WINAPI
RtmGetListEnumRoutes (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ENUM_HANDLE                 EnumHandle,
    IN OUT  PUINT                           NumRoutes,
    OUT     PRTM_ROUTE_HANDLE               RouteHandles
    )

/*++

Routine Description:

    Enumerates a set of routes in the route list starting from
    a specific route (if given) or the start of the route list.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    EnumHandle        - Handle to enumeration on the route list,

    NumRoutes         - Max. number of routes to fill is passed in,
                        Num. of routes actually copied is returned.

    RouteHandles      - Output buffer where route handles are retd.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO    Entity;
    PLIST_ENUM      ListEnum;
    PROUTE_INFO     Route;
    UINT            RoutesInput;
    PLIST_ENTRY     p;

    RoutesInput = *NumRoutes;

    *NumRoutes = 0;

    //
    // Do some validation checks on the input params
    //

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_LIST_ENUM_HANDLE(EnumHandle, &ListEnum);

    if (RoutesInput > Entity->OwningAddrFamily->MaxHandlesInEnum)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // List routes starting from the enum's marker route
    //

    ACQUIRE_ROUTE_LISTS_WRITE_LOCK(Entity);
    
    for (p = ListEnum->MarkerRoute.RouteListLE.Flink;
             p != &ListEnum->RouteList->ListHead;
                 p = p->Flink)
    {
        if (*NumRoutes >= RoutesInput)
        {
            break;
        }

        Route = CONTAINING_RECORD(p, ROUTE_INFO, RouteListLE);

        //
        // If this route is not a marker route, copy handle
        //

        if (Route->RouteInfo.DestHandle)
        {
            RouteHandles[(*NumRoutes)++] = MAKE_HANDLE_FROM_POINTER(Route);

            REFERENCE_ROUTE(Route, HANDLE_REF);
        }
    }

    //
    // Re-adjust the marker to reflect its new posn
    //

    RemoveEntryList(&ListEnum->MarkerRoute.RouteListLE);

    InsertTailList(p, &ListEnum->MarkerRoute.RouteListLE);

    RELEASE_ROUTE_LISTS_WRITE_LOCK(Entity);
        
    return NO_ERROR;
}


DWORD
WINAPI
RtmDeleteRouteList (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ROUTE_LIST_HANDLE           RouteListHandle
    )

/*++

Routine Description:

    Removes all routes on an entity specific list and frees
    resources allocated to it.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    RouteListHandle   - Handle to the route list to delete.

Return Value:

    Status of the operation

--*/
{
    PENTITY_INFO    Entity;
    PROUTE_LIST     RouteList;
    PLIST_ENUM      Enum;
    PROUTE_INFO     Route;
    PLIST_ENTRY     p;

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_ROUTE_LIST_HANDLE(RouteListHandle, &RouteList);


    ACQUIRE_ROUTE_LISTS_WRITE_LOCK(Entity);

    //
    // Remove each route from the route list
    //

    while (!IsListEmpty(&RouteList->ListHead))
    {
        p = RemoveHeadList(&RouteList->ListHead);

        Route = CONTAINING_RECORD(p, ROUTE_INFO, RouteListLE);

        if (Route->RouteInfo.DestHandle)
        {
            // This is an actual route in the list

            DEREFERENCE_ROUTE(Route, LIST_REF);
        }
        else
        {
            // This is a marker route for an enum

            Enum = CONTAINING_RECORD(Route, LIST_ENUM, MarkerRoute);

#if DBG_HDL
            //
            // Remove from the list of handles opened by entity
            //
                
            ACQUIRE_OPEN_HANDLES_LOCK(Entity);
            RemoveEntryList(&Enum->EnumHeader.HandlesLE);
            RELEASE_OPEN_HANDLES_LOCK(Entity);
#endif

            DEREFERENCE_ENTITY(Entity, ENUM_REF);

            // Free the memory allocated for the enum and continue

#if DBG_HDL
            Enum->EnumHeader.ObjectHeader.TypeSign = LIST_ENUM_FREED;
#endif
            FreeObject(Enum);
        }
    }

    RELEASE_ROUTE_LISTS_WRITE_LOCK(Entity);

#if DBG_HDL
    //
    // Remove from the list of handles opened by entity
    //

    ACQUIRE_OPEN_HANDLES_LOCK(Entity);
    RemoveEntryList(&RouteList->ListHeader.HandlesLE);
    RELEASE_OPEN_HANDLES_LOCK(Entity);
#endif

    DEREFERENCE_ENTITY(Entity, LIST_REF);

    // Free the memory allocated for the list and return

#if DBG_HDL
    RouteList->ListHeader.ObjectHeader.TypeSign = ROUTE_LIST_FREED;
#endif

    FreeObject(RouteList);

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\rtmdbg.h ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    rtmdbg.h

Abstract:
    Debugging in Routing Table Manager v2 DLL

Author:
    Chaitanya Kodeboyina (chaitk) 1-Jun-1998

Revision History:

--*/

#ifndef __ROUTING_RTMDBG_H__
#define __ROUTING_RTMDBG_H__

#if TESTING

//
// Bypass the system assert
//

#ifdef  ASSERT
#undef  ASSERT
#endif 
#define ASSERT(a)               { if ((a) == FALSE) DbgBreakPoint(); }

#endif

//
// Constants used for tracing
//

#define RTM_TRACE_ANY             ((DWORD)0xFFFF0000 | TRACE_USE_MASK)
#define RTM_TRACE_ERR             ((DWORD)0x00010000 | TRACE_USE_MASK)
#define RTM_TRACE_ENTER           ((DWORD)0x00020000 | TRACE_USE_MASK)
#define RTM_TRACE_LEAVE           ((DWORD)0x00040000 | TRACE_USE_MASK)
#define RTM_TRACE_LOCK            ((DWORD)0x00080000 | TRACE_USE_MASK)
#define RTM_TRACE_REFS            ((DWORD)0x00100000 | TRACE_USE_MASK)
#define RTM_TRACE_HANDLE          ((DWORD)0x00200000 | TRACE_USE_MASK)
#define RTM_TRACE_MEMORY          ((DWORD)0x00400000 | TRACE_USE_MASK)
#define RTM_TRACE_START           ((DWORD)0x00800000 | TRACE_USE_MASK)
#define RTM_TRACE_STOP            ((DWORD)0x01000000 | TRACE_USE_MASK)
#define RTM_TRACE_REGNS           ((DWORD)0x02000000 | TRACE_USE_MASK)
#define RTM_TRACE_ROUTE           ((DWORD)0x04000000 | TRACE_USE_MASK)
#define RTM_TRACE_QUERY           ((DWORD)0x08000000 | TRACE_USE_MASK)
#define RTM_TRACE_ENUM            ((DWORD)0x10000000 | TRACE_USE_MASK)
#define RTM_TRACE_NOTIFY          ((DWORD)0x20000000 | TRACE_USE_MASK)
#define RTM_TRACE_TIMER           ((DWORD)0x40080000 | TRACE_USE_MASK)
#define RTM_TRACE_CALLBACK        ((DWORD)0x80000000 | TRACE_USE_MASK)

//
// Macros used for tracing 
//

#define TRACEHANDLE         RtmGlobals.TracingHandle

#define START_TRACING()     TRACEHANDLE = TraceRegister("RTM")
            
#define STOP_TRACING()      TraceDeregister(TRACEHANDLE)

#define Trace0(l,a)             \
            TracePrintfEx(TRACEHANDLE, RTM_TRACE_ ## l, a)
#define Trace1(l,a,b)           \
            TracePrintfEx(TRACEHANDLE, RTM_TRACE_ ## l, a, b)
#define Trace2(l,a,b,c)         \
            TracePrintfEx(TRACEHANDLE, RTM_TRACE_ ## l, a, b, c)
#define Trace3(l,a,b,c,d)       \
            TracePrintfEx(TRACEHANDLE, RTM_TRACE_ ## l, a, b, c, d)
#define Trace4(l,a,b,c,d,e)     \
            TracePrintfEx(TRACEHANDLE, RTM_TRACE_ ## l, a, b, c, d, e)
#define Trace5(l,a,b,c,d,e,f)   \
            TracePrintfEx(TRACEHANDLE, RTM_TRACE_ ## l, a, b, c, d, e, f)
#define Trace6(l,a,b,c,d,e,f,g) \
            TracePrintfEx(TRACEHANDLE, RTM_TRACE_ ## l, a, b, c, d, e, f, g)

#define Tracedump(l,a,b,c)      \
            TraceDumpEx(TRACEHANDLE,l,a,b,c,TRUE)

#if DBG_CAL

#define TraceEnter(X)    Trace0(ENTER, "Entered: "X)
#define TraceLeave(X)    Trace0(LEAVE, "Leaving: "X"\n")

#else

#define TraceEnter(X)
#define TraceLeave(X)

#endif

//
// Constants used in logging
//

#define RTM_LOGGING_NONE      0
#define RTM_LOGGING_ERROR     1
#define RTM_LOGGING_WARN      2
#define RTM_LOGGING_INFO      3

//
// Event logging macros
//

#define LOGHANDLE       RtmGlobals.LoggingHandle
#define LOGLEVEL        RtmGlobals.LoggingLevel
#define LOGERR          RouterLogError
#define LOGWARN         RouterLogWarning
#define LOGINFO         RouterLogInformation
#define LOGWARNDATA     RouterLogWarningData

//
// Error logging
//
#define START_LOGGING()     LOGHANDLE = RouterLogRegister("RTM")

#define STOP_LOGGING()      RouterLogDeregister(LOGHANDLE)

#define LOGERR0(msg,err) \
        if (LOGLEVEL >= RTM_LOGGING_ERROR) \
            LOGERR(LOGHANDLE,RTMLOG_ ## msg,0,NULL,(err))
#define LOGERR1(msg,a,err) \
        if (LOGLEVEL >= RTM_LOGGING_ERROR) \
            LOGERR(LOGHANDLE,RTMLOG_ ## msg,1,&(a),(err))
#define LOGERR2(msg,a,b,err) \
        if (LOGLEVEL >= RTM_LOGGING_ERROR) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGERR(LOGHANDLE,RTMLOG_ ## msg,2,_asz,(err)); \
        }
#define LOGERR3(msg,a,b,c,err) \
        if (LOGLEVEL >= RTM_LOGGING_ERROR) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGERR(LOGHANDLE,RTMLOG_ ## msg,3,_asz,(err)); \
        }
#define LOGERR4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= RTM_LOGGING_ERROR) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGERR(LOGHANDLE,RTMLOG_ ## msg,4,_asz,(err)); \
        }


//
// Warning logging
//

#define LOGWARN0(msg,err) \
        if (LOGLEVEL >= RTM_LOGGING_WARN) \
            LOGWARN(LOGHANDLE,RTMLOG_ ## msg,0,NULL,(err))
#define LOGWARN1(msg,a,err) \
        if (LOGLEVEL >= RTM_LOGGING_WARN) \
            LOGWARN(LOGHANDLE,RTMLOG_ ## msg,1,&(a),(err))
#define LOGWARN2(msg,a,b,err) \
        if (LOGLEVEL >= RTM_LOGGING_WARN) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGWARN(LOGHANDLE,RTMLOG_ ## msg,2,_asz,(err)); \
        }
#define LOGWARN3(msg,a,b,c,err) \
        if (LOGLEVEL >= RTM_LOGGING_WARN) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGWARN(LOGHANDLE,RTMLOG_ ## msg,3,_asz,(err)); \
        }
#define LOGWARN4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= RTM_LOGGING_WARN) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGWARN(LOGHANDLE,RTMLOG_ ## msg,4,_asz,(err)); \
        }

#define LOGWARNDATA2(msg,a,b,dw,buf) \
        if (LOGLEVEL >= RTM_LOGGING_WARN) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGWARNDATA(LOGHANDLE,RTMLOG_ ## msg,2,_asz,(dw),(buf)); \
        }


//
// Information logging
//

#define LOGINFO0(msg,err) \
        if (LOGLEVEL >= RTM_LOGGING_INFO) \
            LOGINFO(LOGHANDLE,RTMLOG_ ## msg,0,NULL,(err))
#define LOGINFO1(msg,a,err) \
        if (LOGLEVEL >= RTM_LOGGING_INFO) \
            LOGINFO(LOGHANDLE,RTMLOG_ ## msg,1,&(a),(err))
#define LOGINFO2(msg,a,b,err) \
        if (LOGLEVEL >= RTM_LOGGING_INFO) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGINFO(LOGHANDLE,RTMLOG_ ## msg,2,_asz,(err)); \
        }
#define LOGINFO3(msg,a,b,c,err) \
        if (LOGLEVEL >= RTM_LOGGING_INFO) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGINFO(LOGHANDLE,RTMLOG_ ## msg,3,_asz,(err)); \
        }
#define LOGINFO4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= RTM_LOGGING_INFO) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGINFO(LOGHANDLE,RTMLOG_ ## msg,4,_asz,(err)); \
        }

//
// Misc Debugging Macros
//

#define IPADDR_FORMAT(x) \
    ((x)&0x000000ff),(((x)&0x0000ff00)>>8),(((x)&0x00ff0000)>>16),(((x)&0xff000000)>>24)

#define TracePrintAddress(ID, Dest, Mask)                   \
{                                                           \
    Trace2(ID, "Dest: %d.%d.%d.%d Mask: %d.%d.%d.%d",       \
           IPADDR_FORMAT(Dest),                             \
           IPADDR_FORMAT(Mask));                            \
}

#endif //__ROUTING_RTMDBG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\rtmhndl.c ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmhndl.c

Abstract:

    Contains routines for operating on handles
    to RTM objects like routes and dests.


Author:

    Chaitanya Kodeboyina (chaitk)   23-Aug-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop


DWORD
WINAPI
RtmReferenceHandles (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      UINT                            NumHandles,
    IN      HANDLE                         *RtmHandles
    )

/*++

Routine Description:

    Increment the reference count on objects pointed to by
    input RTM handles.


Arguments:

    RtmRegHandle  - RTM registration handle for calling entity,

    NumHandles    - Number of handles that are being referenced,

    RtmHandles    - Array of handles that are being referenced.

Return Value:

    Status of the operation

--*/

{    
    PENTITY_INFO     Entity;
    POBJECT_HEADER   Object;
    UINT             i;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    //
    // Reference each handle in input array
    //

    for (i = 0; i < NumHandles; i++)
    {
        Object = GET_POINTER_FROM_HANDLE(RtmHandles[i]);

#if DBG_HDL
        try
        {
            if (Object->TypeSign != OBJECT_SIGNATURE[atoi(&Object->Type)])
            {
                continue;
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        { 
            continue;
        }
#endif

        ReferenceObject(Object, HANDLE_REF);
    }

    return NO_ERROR;
}


DWORD
WINAPI
RtmDereferenceHandles (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      UINT                            NumHandles,
    IN      HANDLE                         *RtmHandles
    )

/*++

Routine Description:

    Decrement the reference count on objects pointed to by
    input RTM handles.

Arguments:

    RtmRegHandle  - RTM registration handle for calling entity,

    NumHandles    - Number of handles that are being dereferenced,

    RtmHandles    - Array of handles that are being dereferenced.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO     Entity;
    POBJECT_HEADER   Object;
    UINT             i;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    //
    // Dereference each handle in input array
    //

    for (i = 0; i < NumHandles; i++)
    {
        Object = GET_POINTER_FROM_HANDLE(RtmHandles[i]);

#if DBG_HDL
        try
        {
            if (Object->TypeSign != OBJECT_SIGNATURE[atoi(&Object->Type)])
            {
                continue;
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        { 
            continue;
        }
#endif
        //
        // This function can be used only if you know
        // that the reference count does not go to 0
        //

        if (DereferenceObject(Object, HANDLE_REF) == 0)
        {
            ASSERT(FALSE); // ? Destroy which object ?
        }
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\rtmenum.c ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmenum.c

Abstract:

    Contains routines for managing any enumerations
    over destinations, routes and next hops in RTM.

Author:

    Chaitanya Kodeboyina (chaitk)   23-Aug-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop


DWORD
WINAPI
RtmCreateDestEnum (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_VIEW_SET                    TargetViews,
    IN      RTM_ENUM_FLAGS                  EnumFlags,
    IN      PRTM_NET_ADDRESS                NetAddress,
    IN      ULONG                           ProtocolId,
    OUT     PRTM_ENUM_HANDLE                RtmEnumHandle
    )

/*++

Routine Description:

    Creates a enumeration over the destinations in the route table.

Arguments:

    RtmRegHandle   - RTM registration handle for calling entity,

    TargetViews    - Set of views in which the enumeration is done,

    EnumFlags      - Flags that control the dests returned in enum,

    NetAddress     - Start and/or stop address of the enumeration,
                     [ See a description of RTM_ENUM_FLAGS ...]

    Protocol Id    - Protocol Id that determines the best route
                     information returned in 'GetEnumDests' call,

    RtmEnumHandle  - Handle to this enumeration, which is used
                     in subsequent calls to get dests, and so on.

Return Value:

    Status of the operation

--*/

{
    PADDRFAM_INFO   AddrFamInfo;
    PENTITY_INFO    Entity;
    PDEST_ENUM      Enum;
    PUCHAR          AddrBits;
    UINT            AddrSize;
    UINT            i, j;
    DWORD           Status;

    //
    // Do some validation checks on the input params
    //

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    if ((EnumFlags & RTM_ENUM_NEXT) && (EnumFlags & RTM_ENUM_RANGE))
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    if (EnumFlags & (RTM_ENUM_NEXT | RTM_ENUM_RANGE))
    {
        if (!NetAddress)
        {
            return ERROR_INVALID_PARAMETER;
        }
    }

    AddrFamInfo = Entity->OwningAddrFamily;

    //
    // Is he interested in any non-supported views ?
    //

    if (TargetViews & ~AddrFamInfo->ViewsSupported)
    {
        return ERROR_NOT_SUPPORTED;
    }

    //
    // Create and initialize an dest enumeration block
    //

    Enum = (PDEST_ENUM) AllocNZeroObject(sizeof(DEST_ENUM));
    if (Enum == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    do
    {
#if DBG_HDL
        Enum->EnumHeader.ObjectHeader.TypeSign = DEST_ENUM_ALLOC;
#endif
        Enum->EnumHeader.HandleType = DEST_ENUM_TYPE;

        Enum->TargetViews = TargetViews;

        Enum->NumberOfViews = NUMBER_OF_BITS(TargetViews);

        Enum->ProtocolId = ProtocolId;

        Enum->EnumFlags = EnumFlags;

#if DBG
        // Initialize the first address in the enum

        if (Enum->EnumFlags & (RTM_ENUM_NEXT | RTM_ENUM_RANGE))
        {
            CopyMemory(&Enum->StartAddress,
                       NetAddress, 
                       sizeof(RTM_NET_ADDRESS));
        }
#endif

        AddrSize = AddrFamInfo->AddressSize;

        //
        // Initialize the last address in the enum
        //

        if (Enum->EnumFlags & RTM_ENUM_RANGE)
        {
            //
            // Convert the NetAddress a.b/n -> a.b.FF.FF/N where N = ADDRSIZE
            //

            Enum->StopAddress.AddressFamily = NetAddress->AddressFamily;

            Enum->StopAddress.NumBits = (USHORT) (AddrSize * BITS_IN_BYTE);

            AddrBits = Enum->StopAddress.AddrBits;

            for (i = 0; i < (NetAddress->NumBits / BITS_IN_BYTE); i++)
            {
                AddrBits[i] = NetAddress->AddrBits[i];
            }

            j = i;

            for (; i < AddrSize; i++)
            {
                AddrBits[i] = 0xFF;
            }

            if (j < AddrSize)
            {
                AddrBits[j] >>= (NetAddress->NumBits % BITS_IN_BYTE);

                AddrBits[j] |= NetAddress->AddrBits[j];
            }
        }

        try
        {
            InitializeCriticalSection(&Enum->EnumLock);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            Status = GetLastError();
            break;
        }

        // Initialize the next destination context

        if (EnumFlags & (RTM_ENUM_NEXT | RTM_ENUM_RANGE))
        {
            CopyMemory(&Enum->NextDest,
                       NetAddress,
                       sizeof(RTM_NET_ADDRESS));
        }

#if DBG_HDL
        //
        // Insert into list of handles opened by entity
        //

        ACQUIRE_OPEN_HANDLES_LOCK(Entity);
        InsertTailList(&Entity->OpenHandles, &Enum->EnumHeader.HandlesLE);
        RELEASE_OPEN_HANDLES_LOCK(Entity);
#endif

        REFERENCE_ENTITY(Entity, ENUM_REF);

        //
        // Make a handle to the enum block and return
        //

        *RtmEnumHandle = MAKE_HANDLE_FROM_POINTER(Enum);

        return NO_ERROR;
    }
    while (FALSE);

    //
    // Something failed - undo work done and return status
    //

#if DBG_HDL
    Enum->EnumHeader.ObjectHeader.TypeSign = DEST_ENUM_FREED;
#endif

    FreeObject(Enum);

    *RtmEnumHandle = NULL;

    return Status;
}


DWORD
WINAPI
RtmGetEnumDests (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ENUM_HANDLE                 EnumHandle,
    IN OUT  PUINT                           NumDests,
    OUT     PRTM_DEST_INFO                  DestInfos
    )

/*++

Routine Description:

    Gets the next set of destinations in the given enumeration
    on the route table.

Arguments:

    RtmRegHandle   - RTM registration handle for calling entity,

    EnumHandle     - Handle to the destination enumeration,

    NumDests       - Num. of DestInfo's in output is passed in,
                     Num. of DestInfo's copied out is returned.

    DestInfos      - Output buffer where destination info is retd.

Return Value:

    Status of the operation

--*/

{
    PADDRFAM_INFO   AddrFamInfo;
    PENTITY_INFO    Entity;
    PDEST_ENUM      Enum;
    LOOKUP_CONTEXT  Context;
    PUCHAR          EndofBuffer;
    UINT            DestInfoSize;
    UINT            DestsInput;
    UINT            DestsCopied;
    UINT            DestsLeft;
    PDEST_INFO      Dest;
    PLOOKUP_LINKAGE*DestData;
    PROUTE_INFO     Route;
    USHORT          StopNumBits;
    PUCHAR          StopKeyBits;
    UINT            i, j;
    DWORD           Status;

    //
    // Init the output params in case we fail validation
    //

    DestsInput = *NumDests;

    *NumDests = 0;

    //
    // Do some validation checks on the input params
    //

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_DEST_ENUM_HANDLE(EnumHandle, &Enum);

    AddrFamInfo = Entity->OwningAddrFamily;

    if ((DestsInput > AddrFamInfo->MaxHandlesInEnum) ||
        (DestsInput < 1))
    {
        return ERROR_INVALID_PARAMETER;
    }


    // Acquire lock to block other RtmGetEnumDests
    ACQUIRE_DEST_ENUM_LOCK(Enum);

    // Make sure enum is active at this point
    if (Enum->EnumDone)
    {
        RELEASE_DEST_ENUM_LOCK(Enum);

        return ERROR_NO_MORE_ITEMS;
    }


    //
    // Get the next set of destinations from table
    //

    // Initialize the lookup context before Enum
    ZeroMemory(&Context, sizeof(LOOKUP_CONTEXT));

    DestInfoSize = RTM_SIZE_OF_DEST_INFO(Enum->NumberOfViews);

    EndofBuffer = (PUCHAR) DestInfos + DestsInput * DestInfoSize;

    DestsLeft = DestsInput;

    DestsCopied = 0;

    ACQUIRE_ROUTE_TABLE_READ_LOCK(AddrFamInfo);

    do
    {
        // Use the end of the caller's buffer as temp space

        DestData = (PLOOKUP_LINKAGE *) (EndofBuffer - 
                                        DestsLeft * sizeof(PLOOKUP_LINKAGE));

        if (Enum->EnumFlags & RTM_ENUM_RANGE)
        {
            StopNumBits = Enum->StopAddress.NumBits;
            StopKeyBits = Enum->StopAddress.AddrBits;
        }
        else
        {
            StopNumBits = 0;
            StopKeyBits = NULL;
        }

        Status = EnumOverTable(AddrFamInfo->RouteTable,
                               &Enum->NextDest.NumBits,
                               Enum->NextDest.AddrBits,
                               &Context,
                               StopNumBits,
                               StopKeyBits,
                               &DestsLeft,
                               DestData);

        for (i = 0; i < DestsLeft; i++)
        {
            Dest = CONTAINING_RECORD(DestData[i], DEST_INFO, LookupLinkage);
          
            if ((Enum->TargetViews == RTM_VIEW_MASK_ANY) || 
                (Dest->BelongsToViews & Enum->TargetViews))
            {
                if (Enum->EnumFlags & RTM_ENUM_OWN_DESTS)
                {
                    // Check if this dest is owned in any view by caller
                    
                    for (j = 0; j < AddrFamInfo->NumberOfViews; j++)
                    {
                        Route = Dest->ViewInfo[j].BestRoute;

                        if (Route)
                        {
                            if (Route->RouteInfo.RouteOwner == RtmRegHandle)
                            {
                                break;
                            }
                        }
                    }

                    if (j == AddrFamInfo->NumberOfViews)
                    {
                        continue;
                    }
                }

                //
                // Get the destination info from the dest
                //

                GetDestInfo(Entity, 
                            Dest, 
                            Enum->ProtocolId, 
                            Enum->TargetViews, 
                            DestInfos);

                DestsCopied++;

                DestInfos = (PRTM_DEST_INFO)(DestInfoSize + (PUCHAR)DestInfos);
            }
        }

        DestsLeft = DestsInput - DestsCopied;
    }
    while (SUCCESS(Status) && (DestsLeft > 0));

    //
    // We have no more dests, or we have filled output
    //

    ASSERT(!SUCCESS(Status) || ((PUCHAR) DestInfos == (PUCHAR) EndofBuffer));

    RELEASE_ROUTE_TABLE_READ_LOCK(AddrFamInfo);

    // If we are at end of the enum, make enum as done

    if (Status == ERROR_NO_MORE_ITEMS)
    {
        Enum->EnumDone = TRUE;
    }

    RELEASE_DEST_ENUM_LOCK(Enum);

    *NumDests = DestsCopied;

    return *NumDests ? NO_ERROR : ERROR_NO_MORE_ITEMS;
}


DWORD
WINAPI
RtmReleaseDests (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      UINT                            NumDests,
    IN      PRTM_DEST_INFO                  DestInfos
    )

/*++

Routine Description:

    Release destination information obtained in other calls -
    like dest enumerations.

Arguments:

    RtmRegHandle   - RTM registration handle for calling entity,

    NumDests       - Number of dest infos that are being released,

    DestInfos      - Array of dest infos that are being released.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO    Entity;
    UINT            NumViews;
    UINT            DestInfoSize;
    UINT            i;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    //
    // Get the size of each info in dest info array
    //

    NumViews = ((PRTM_DEST_INFO) DestInfos)->NumberOfViews;

    DestInfoSize = RTM_SIZE_OF_DEST_INFO(NumViews);

    //
    // Dereference each dest info in array
    //

    for (i = 0; i < NumDests; i++)
    {
        RtmReleaseDestInfo(RtmRegHandle, DestInfos);

        DestInfos = (PRTM_DEST_INFO)(DestInfoSize + (PUCHAR)DestInfos);
    }

    return NO_ERROR;
}


DWORD
WINAPI
RtmCreateRouteEnum (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_DEST_HANDLE                 DestHandle        OPTIONAL,
    IN      RTM_VIEW_SET                    TargetViews,
    IN      RTM_ENUM_FLAGS                  EnumFlags,
    IN      PRTM_NET_ADDRESS                StartDest         OPTIONAL,
    IN      RTM_MATCH_FLAGS                 MatchingFlags,
    IN      PRTM_ROUTE_INFO                 CriteriaRoute     OPTIONAL,
    IN      ULONG                           CriteriaInterface OPTIONAL,
    OUT     PRTM_ENUM_HANDLE                RtmEnumHandle
    )

/*++

Routine Description:

    Creates a enumeration over the routes on a particular dest
    in the route table. If the dest is NULL, an enumeration is
    created over the whole route table.

    If matching flags are specified, only routes that match the
    criteria are returned.

Arguments:

    RtmRegHandle   - RTM registration handle for calling entity,

    DestHandle     - The destination whose routes we are enum'ing,
                     Or NULL if we are enum'ing over all dests.

    TargetViews    - Set of views in which the enumeration is done,

    EnumFlags      - Flags that control the routes retd in enum,

    MatchingFlags  - Indicates the elements of the route to match,

    CriteriaRoute  - Values to match each route in the enum,

    CritInterface  - Interface on which routes should fall on,

    RtmEnumHandle  - Handle to this enumeration, which is used
                     in subsequent calls to get routes, and so on.

Return Value:

    Status of the operation

--*/

{
    PADDRFAM_INFO   AddrFamInfo;
    PENTITY_INFO    Entity;
    PROUTE_ENUM     Enum;
    PDEST_INFO      Dest;
    BOOL            LockInited;
    ULONG           NumBytes;
    DWORD           Status;

    //
    // Do some validation checks on the input params
    //

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    AddrFamInfo = Entity->OwningAddrFamily;

#if WRN
    Dest = NULL;
#endif

    if (ARGUMENT_PRESENT(DestHandle))
    {
        // StartDest doesnt apply if enum'ing a dest
        if (ARGUMENT_PRESENT(StartDest))
        {
            return ERROR_INVALID_PARAMETER;
        }

        VALIDATE_DEST_HANDLE(DestHandle, &Dest);
    }

    // If we have matching flags, we need corr. route
    if (MatchingFlags & ~RTM_MATCH_INTERFACE)
    {
        if (!ARGUMENT_PRESENT(CriteriaRoute))
        {
            return ERROR_INVALID_PARAMETER;
        }
    }

    //
    // Is he interested in any non-supported views ?
    //

    if (TargetViews & ~AddrFamInfo->ViewsSupported)
    {
        return ERROR_NOT_SUPPORTED;
    }

    //
    // Create and initialize a route enumeration block
    //

    Enum = (PROUTE_ENUM) AllocNZeroObject(sizeof(ROUTE_ENUM));

    if (Enum == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }


    LockInited = FALSE;

#if WRN
    Status = ERROR_GEN_FAILURE;
#endif

    do
    {
#if DBG_HDL
        Enum->EnumHeader.ObjectHeader.TypeSign = ROUTE_ENUM_ALLOC;
#endif
        Enum->EnumHeader.HandleType = ROUTE_ENUM_TYPE;

        Enum->TargetViews = TargetViews;

        Enum->EnumFlags = EnumFlags;

        if (MatchingFlags)
        {
            Enum->MatchFlags = MatchingFlags;

            if (MatchingFlags & ~RTM_MATCH_INTERFACE)
            {
                NumBytes = sizeof(RTM_ROUTE_INFO) +
                           (AddrFamInfo->MaxNextHopsInRoute - 1) *
                           sizeof(RTM_NEXTHOP_HANDLE);

                Enum->CriteriaRoute = AllocMemory(NumBytes);

                if (Enum->CriteriaRoute == NULL)
                {
                    break;
                }

                CopyMemory(Enum->CriteriaRoute, CriteriaRoute, NumBytes);
            }

            Enum->CriteriaInterface = CriteriaInterface;
        }

        //
        // Initialize the lock to serialize enum requests
        //

        try
        {
            InitializeCriticalSection(&Enum->EnumLock);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            Status = GetLastError();
            break;
        }

        LockInited = TRUE;


        //
        // Are we enumerating routes on all destinations ?
        //

        if (!ARGUMENT_PRESENT(DestHandle))
        {
            //
            // Create a temp dest info structure for enum
            //

            Enum->DestInfo = AllocDestInfo(AddrFamInfo->NumberOfViews);

            if (Enum->DestInfo == NULL)
            {
                Status = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            //
            // Open a dest enumeration to get all dests
            //

            Status = RtmCreateDestEnum(RtmRegHandle,
                                       TargetViews,
                                       EnumFlags,
                                       StartDest,
                                       RTM_BEST_PROTOCOL,
                                       &Enum->DestEnum);

            if (!SUCCESS(Status))
            {
                break;
            }
        }
        else
        {
            //
            // Ref dest whose routes we are enum'ing
            //

            Enum->Destination = Dest;

            REFERENCE_DEST(Dest, ENUM_REF);
        }

#if DBG_HDL
        //
        // Insert into list of handles opened by entity
        //

        ACQUIRE_OPEN_HANDLES_LOCK(Entity);
        InsertTailList(&Entity->OpenHandles, &Enum->EnumHeader.HandlesLE);
        RELEASE_OPEN_HANDLES_LOCK(Entity);
#endif

        REFERENCE_ENTITY(Entity, ENUM_REF);

        //
        // Make a handle to the enum block and return
        //

        *RtmEnumHandle = MAKE_HANDLE_FROM_POINTER(Enum);

        return NO_ERROR;
    }
    while (FALSE);

    //
    // Something failed - undo work done and return status
    //

    if (Enum->DestInfo)
    {
        FreeMemory(Enum->DestInfo);
    }

    if (LockInited)
    {
        DeleteCriticalSection(&Enum->EnumLock);
    }

    if (Enum->CriteriaRoute)
    {
        FreeMemory(Enum->CriteriaRoute);
    }

    FreeObject(Enum);

    *RtmEnumHandle = NULL;

    return Status;
}


DWORD
WINAPI
RtmGetEnumRoutes (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ENUM_HANDLE                 EnumHandle,
    IN OUT  PUINT                           NumRoutes,
    OUT     PRTM_ROUTE_HANDLE               RouteHandles
    )

/*++

Routine Description:

    Gets the next set of routes in the given enumeration on the
    route table.

Arguments:

    RtmRegHandle   - RTM registration handle for calling entity,

    EnumHandle     - Handle to the route enumeration,

    NumRoutes      - Max. number of routes to fill is passed in,
                     Num. of routes actually copied is returned.

    RouteHandles   - Output buffer where route handles are retd.

Return Value:

    Status of the operation

--*/

{
    PADDRFAM_INFO   AddrFamInfo;
    PENTITY_INFO    Entity;
    PROUTE_ENUM     Enum;
    PDEST_INFO      Dest;
    PROUTE_INFO     Route;
    PROUTE_INFO    *NextRoute;
    UINT            NumDests;
    UINT            RoutesInput;
    UINT            RoutesCopied;
    UINT            RoutesOnDest;
    UINT            RoutesToCopy;
    PLIST_ENTRY     p;
    UINT            i;
    DWORD           Status;

    //
    // Init the output params in case we fail validation
    //

    RoutesInput = *NumRoutes;

    *NumRoutes = 0;

    //
    // Do some validation checks on the input params
    //

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_ROUTE_ENUM_HANDLE(EnumHandle, &Enum);

    AddrFamInfo = Entity->OwningAddrFamily;

    if ((RoutesInput > AddrFamInfo->MaxHandlesInEnum) ||
        (RoutesInput < 1))
    {
        return ERROR_INVALID_PARAMETER;
    }


    // Acquire lock to block other RtmGetEnumRoutes
    ACQUIRE_ROUTE_ENUM_LOCK(Enum);

    // Make sure enum is active at this point
    if (Enum->EnumDone)
    {
        RELEASE_ROUTE_ENUM_LOCK(Enum);

        return ERROR_NO_MORE_ITEMS;
    }


    //
    // Get more routes until you satisfy the request
    //

    Status = NO_ERROR;

    RoutesCopied = 0;

    do
    {
        //
        // Do we have any routes in current snapshot ?
        //

        RoutesOnDest = Enum->NumRoutes - Enum->NextRoute;

        if (RoutesOnDest == 0)
        {
            //
            // Destination value in the enum is not set if
            //
            //    1. we are doing an enum over the whole
            //       table, and 
            //
            //    2. we did not run out of memory in the
            //       previous attempt to take a snapshot
            //       ( if we did make an attempt before )
            //

            if (Enum->Destination == NULL)
            {
                ASSERT(Enum->DestEnum);

                //
                // Get the next destination in the table
                //

                NumDests = 1;

                Status = RtmGetEnumDests(RtmRegHandle,
                                         Enum->DestEnum,
                                         &NumDests,
                                         Enum->DestInfo);

                if (NumDests < 1)
                {
                    break;
                }

                Dest = DEST_FROM_HANDLE(Enum->DestInfo->DestHandle);

                Enum->Destination = Dest;

                REFERENCE_DEST(Dest, ENUM_REF);

                RtmReleaseDestInfo(RtmRegHandle,
                                   Enum->DestInfo);
            }
            else
            {
                Dest = Enum->Destination;
            }

            ASSERT(Enum->Destination != NULL);


            //
            // Allocate memory to hold snapshot of routes
            //

            ACQUIRE_DEST_READ_LOCK(Dest);

            if (Enum->MaxRoutes < Dest->NumRoutes)
            {
                //
                // Re-adjust the size of snapshot buffer
                //

                if (Enum->RoutesOnDest)
                {
                    FreeMemory(Enum->RoutesOnDest);
                }

                Enum->RoutesOnDest = (PROUTE_INFO *)
                                      AllocNZeroMemory(Dest->NumRoutes * 
                                                      sizeof(PROUTE_INFO));

                if (Enum->RoutesOnDest == NULL)
                {
                    RELEASE_DEST_READ_LOCK(Dest);

                    Enum->MaxRoutes = 0;
                    Enum->NumRoutes = 0;
                    Enum->NextRoute = 0;

                    Status = ERROR_NOT_ENOUGH_MEMORY;

                    break;
                }

                Enum->MaxRoutes = Dest->NumRoutes;
            }


            //
            // Get snapshot of all routes on this dest
            //

            Enum->NumRoutes = Enum->NextRoute = 0;

            for (p = Dest->RouteList.Flink; p != &Dest->RouteList; p= p->Flink)
            {
                Route = CONTAINING_RECORD(p, ROUTE_INFO, DestLE);

                //
                // Does this route belong one of interesting views ?
                //

                if ((Enum->TargetViews == RTM_VIEW_MASK_ANY) || 
                    (Route->RouteInfo.BelongsToViews & Enum->TargetViews))
                {
                    if (Enum->EnumFlags & RTM_ENUM_OWN_ROUTES)
                    {
                        // Check if this route is owned by the caller
                    
                        if (Route->RouteInfo.RouteOwner != RtmRegHandle)
                        {
                            continue;
                        }
                    }

                    // Does this route match the enumeration criteria ?

                    if (Enum->MatchFlags && 
                        !MatchRouteWithCriteria(Route,
                                                Enum->MatchFlags,
                                                Enum->CriteriaRoute,
                                                Enum->CriteriaInterface))
                    {
                        continue;
                    }

                    REFERENCE_ROUTE(Route, ENUM_REF);

                    //
                    // Reference the route and copy the handle to output
                    //

                    Enum->RoutesOnDest[Enum->NumRoutes++] = Route;
                }
            }

            ASSERT(Enum->NumRoutes <= Dest->NumRoutes);

            RELEASE_DEST_READ_LOCK(Dest);

            //
            // If we are enum'ing the whole table, we do
            // not need the dest whose snapshot is taken
            //

            if (Enum->DestEnum)
            {
                Enum->Destination = NULL;

                DEREFERENCE_DEST(Dest, ENUM_REF);
            }

            // Adjust the number of routes on the dest

            RoutesOnDest = Enum->NumRoutes - Enum->NextRoute;
        }

        //
        // Copy routes to output from the current snapshot
        //

        if (RoutesOnDest)
        {
            RoutesToCopy = RoutesInput - RoutesCopied;

            if (RoutesToCopy > RoutesOnDest)
            {
                RoutesToCopy = RoutesOnDest;
            }

            NextRoute = &Enum->RoutesOnDest[Enum->NextRoute];

            for (i = 0; i < RoutesToCopy; i++)
            {
#if DBG_REF
                REFERENCE_ROUTE(*NextRoute, HANDLE_REF);

                DEREFERENCE_ROUTE(*NextRoute, ENUM_REF);
#endif
                RouteHandles[RoutesCopied++] = 
                    MAKE_HANDLE_FROM_POINTER(*NextRoute++);
            }

            Enum->NextRoute += RoutesToCopy;

            RoutesOnDest -= RoutesToCopy;
        }

        //
        // Are we done with all the routes in snapshot ?
        //

        if (RoutesOnDest == 0)
        {
            //
            // If we are enum'ing a single dest, we are done
            //

            if (Enum->DestEnum == NULL)
            {
                Status = ERROR_NO_MORE_ITEMS;
                break;
            }
        }
    }
    while (SUCCESS(Status) && (RoutesCopied < RoutesInput));

    // If we are at end of the enum, make enum as done
    if ((Status == ERROR_NO_MORE_ITEMS) && (RoutesOnDest == 0))
    {
        Enum->EnumDone = TRUE;
    }

    RELEASE_ROUTE_ENUM_LOCK(Enum);

    //
    // Update output to reflect number of routes copied
    //

    *NumRoutes = RoutesCopied;

    return *NumRoutes ? NO_ERROR : ERROR_NO_MORE_ITEMS;
}


BOOL
MatchRouteWithCriteria (
    IN      PROUTE_INFO                     Route,
    IN      RTM_MATCH_FLAGS                 MatchingFlags,
    IN      PRTM_ROUTE_INFO                 CriteriaRouteInfo,
    IN      ULONG                           CriteriaInterface
    )

/*++

Routine Description:

    Matches a route with the input criteria given by input flags
    and the route to match.

Arguments:

    Route             - Route that we are matching criteria with,

    MatchingFlags     - Flags that indicate which fields to match,

    CriteriaRouteInfo - Route info that specifies match criteria,

    CriteriaInterface - Interface to match if MATCH_INTERFACE is set.

Return Value:

    TRUE if route matches criteria, FALSE if not

--*/

{
    PRTM_NEXTHOP_HANDLE NextHops;
    PNEXTHOP_INFO       NextHop;
    UINT                NumNHops;
    UINT                i;

    //
    // Try matching the route owner if flags say so
    //

    if (MatchingFlags & RTM_MATCH_OWNER)
    {
        if (Route->RouteInfo.RouteOwner != CriteriaRouteInfo->RouteOwner)
        {
            return FALSE;
        }
    }

    //
    // Try matching the neighbour if flags say so
    //

    if (MatchingFlags & RTM_MATCH_NEIGHBOUR)
    {
        if (Route->RouteInfo.Neighbour != CriteriaRouteInfo->Neighbour)
        {
            return FALSE;
        }
    }

    //
    // Try matching the preference if flags say so
    //

    if (MatchingFlags & RTM_MATCH_PREF)
    {
        if (!IsPrefEqual(&Route->RouteInfo, CriteriaRouteInfo))
        {
            return FALSE;
        }
    }

    //
    // Try matching the interface if flags say so
    //

    if (MatchingFlags & RTM_MATCH_INTERFACE)
    {
        NumNHops = Route->RouteInfo.NextHopsList.NumNextHops;
        NextHops = Route->RouteInfo.NextHopsList.NextHops;

        for (i = 0; i < NumNHops; i++)
        {
            NextHop = NEXTHOP_FROM_HANDLE(NextHops[i]);

            if (NextHop->NextHopInfo.InterfaceIndex == CriteriaInterface)
            {
                break;
            }
        }

        if (i == NumNHops)
        {
            return FALSE;
        }        
    }

    //
    // Try matching the nexthop if flags say so
    //

    if (MatchingFlags & RTM_MATCH_NEXTHOP)
    {
        NumNHops = Route->RouteInfo.NextHopsList.NumNextHops;
        NextHops = Route->RouteInfo.NextHopsList.NextHops;

        ASSERT(CriteriaRouteInfo->NextHopsList.NumNextHops == 1);

        for (i = 0; i < NumNHops; i++)
        {
            if (NextHops[i] == CriteriaRouteInfo->NextHopsList.NextHops[0])
            {
                break;
            }
        }

        if (i == NumNHops)
        {
            return FALSE;
        }
    }

    return TRUE;
}


DWORD
WINAPI
RtmReleaseRoutes (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      UINT                            NumRoutes,
    IN      PRTM_ROUTE_HANDLE               RouteHandles
    )

/*++

Routine Description:

    Release (also called de-reference) handles to routes
    obtained in other RTM calls like route enumerations.

Arguments:

    RtmRegHandle   - RTM registration handle for calling entity,

    NumRoutes      - Number of handles that are being released,

    RouteHandles   - An array of handles that are being released.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO     Entity;
    PROUTE_INFO      Route;
    UINT             i;

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    //
    // Dereference each route handle in array
    //

    for (i = 0; i < NumRoutes; i++)
    {
        Route = ROUTE_FROM_HANDLE(RouteHandles[i]);

        DEREFERENCE_ROUTE(Route, HANDLE_REF);
    }

    return NO_ERROR;
}


DWORD
WINAPI
RtmCreateNextHopEnum (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ENUM_FLAGS                  EnumFlags,
    IN      PRTM_NET_ADDRESS                NetAddress,
    OUT     PRTM_ENUM_HANDLE                RtmEnumHandle
    )

/*++

Routine Description:

    Creates a enumeration over all the next-hops in table.

Arguments:

    RtmRegHandle   - RTM registration handle for calling entity,

    EnumFlags      - Flags that control the nexthops retd in enum,

    NetAddress     - Start and/or stop address of the enumeration,
                      [ See a description of RTM_ENUM_FLAGS ...]

    RtmEnumHandle  - Handle to this enumeration, which is used in
                     subsequent calls to get next-hops, and so on.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO    Entity;
    PNEXTHOP_ENUM   Enum;
    PUCHAR          AddrBits;
    UINT            AddrSize;
    UINT            i, j;
    DWORD           Status;

    //
    // Do some validation checks on the input params
    //

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    if ((EnumFlags & RTM_ENUM_NEXT) && (EnumFlags & RTM_ENUM_RANGE))
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    if (EnumFlags & (RTM_ENUM_NEXT | RTM_ENUM_RANGE))
    {
        if (!NetAddress)
        {
            return ERROR_INVALID_PARAMETER;
        }
    }

    //
    // Create and initialize an nexthop enumeration block
    //

    Enum = (PNEXTHOP_ENUM) AllocNZeroObject(sizeof(NEXTHOP_ENUM));
    if (Enum == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    do
    {
#if DBG_HDL
        Enum->EnumHeader.ObjectHeader.TypeSign = NEXTHOP_ENUM_ALLOC;
#endif
        Enum->EnumHeader.HandleType = NEXTHOP_ENUM_TYPE;

        Enum->EnumFlags = EnumFlags;

#if DBG
        // Initialize the first address in the enum

        if (Enum->EnumFlags & (RTM_ENUM_NEXT | RTM_ENUM_RANGE))
        {
            CopyMemory(&Enum->StartAddress,
                       NetAddress, 
                       sizeof(RTM_NET_ADDRESS));
        }
#endif

        AddrSize = Entity->OwningAddrFamily->AddressSize;

        //
        // Initialize the last address in the enum
        //

        if (Enum->EnumFlags & RTM_ENUM_RANGE)
        {
            //
            // Convert the NetAddress a.b/n -> a.b.FF.FF/N where N = ADDRSIZE
            //

            Enum->StopAddress.AddressFamily = NetAddress->AddressFamily;

            Enum->StopAddress.NumBits = (USHORT) (AddrSize * BITS_IN_BYTE);

            AddrBits = Enum->StopAddress.AddrBits;

            for (i = 0; i < (NetAddress->NumBits / BITS_IN_BYTE); i++)
            {
                AddrBits[i] = NetAddress->AddrBits[i];
            }

            j = i;

            for (; i < AddrSize; i++)
            {
                AddrBits[i] = 0xFF;
            }

            if (j < AddrSize)
            {
                AddrBits[j] >>= (NetAddress->NumBits % BITS_IN_BYTE);

                AddrBits[j] |= NetAddress->AddrBits[j];
            }
        }

        try
        {
            InitializeCriticalSection(&Enum->EnumLock);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            Status = GetLastError();
            break;
        }

        // Initialize the next 'nexthop' context

        if (NetAddress)
        {
            CopyMemory(&Enum->NextAddress,
                       NetAddress,
                       sizeof(RTM_NET_ADDRESS));
        }

        Enum->NextIfIndex = START_IF_INDEX;

#if DBG_HDL
        //
        // Insert into list of handles opened by entity
        //

        ACQUIRE_OPEN_HANDLES_LOCK(Entity);
        InsertTailList(&Entity->OpenHandles, &Enum->EnumHeader.HandlesLE);
        RELEASE_OPEN_HANDLES_LOCK(Entity);
#endif

        REFERENCE_ENTITY(Entity, ENUM_REF);

        //
        // Make a handle to the enum block and return
        //

        *RtmEnumHandle = MAKE_HANDLE_FROM_POINTER(Enum);

        return NO_ERROR;
    }
    while (FALSE);

    //
    // Something failed - undo work done and return status
    //

#if DBG_HDL
    Enum->EnumHeader.ObjectHeader.TypeSign = NEXTHOP_ENUM_FREED;
#endif

    FreeObject(Enum);

    *RtmEnumHandle = NULL;

    return Status;
}


DWORD
WINAPI
RtmGetEnumNextHops (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ENUM_HANDLE                 EnumHandle,
    IN OUT  PUINT                           NumNextHops,
    OUT     PRTM_NEXTHOP_HANDLE             NextHopHandles
    )

/*++

Routine Description:

    Gets the next set of next-hops in the given enumeration
    on the next-hop table.

Arguments:

    RtmRegHandle   - RTM registration handle for calling entity,

    EnumHandle     - Handle to the next-hop enumeration,

    NumNextHops    - Num. of next-hops in output is passed in,
                     Num. of next-hops copied out is returned.

    NextHopHandles - Output buffer where next-hop handles are retd.

Return Value:

    Status of the operation

--*/

{
    PADDRFAM_INFO   AddrFamInfo;
    PENTITY_INFO    Entity;
    PNEXTHOP_ENUM   Enum;
    LOOKUP_CONTEXT  Context;
    PNEXTHOP_LIST   HopList;
    PNEXTHOP_INFO   NextHop;
    PLOOKUP_LINKAGE NextHopData;
    PLIST_ENTRY     NextHops, p;
    UINT            NextHopsInput;
    UINT            NextHopsCopied;
    UINT            NumHopLists;
    USHORT          StopNumBits;
    PUCHAR          StopKeyBits;
    DWORD           Status;

    //
    // Init the output params in case we fail validation
    //

    NextHopsInput = *NumNextHops;

    *NumNextHops = 0;

    //
    // Do some validation checks on the input params
    //

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_NEXTHOP_ENUM_HANDLE(EnumHandle, &Enum);

    AddrFamInfo = Entity->OwningAddrFamily;

    if ((NextHopsInput > AddrFamInfo->MaxHandlesInEnum) ||
        (NextHopsInput < 1))
    {
        return ERROR_INVALID_PARAMETER;
    }


    // Acquire lock to block other RtmGetEnumNextHops
    ACQUIRE_NEXTHOP_ENUM_LOCK(Enum);

    // Make sure enum is active at this point
    if (Enum->EnumDone)
    {
        RELEASE_NEXTHOP_ENUM_LOCK(Enum);

        return ERROR_NO_MORE_ITEMS;
    }


    // Initialize the lookup context before Enum
    ZeroMemory(&Context, sizeof(LOOKUP_CONTEXT));

    if (Enum->EnumFlags & RTM_ENUM_RANGE)
    {
        StopNumBits = Enum->StopAddress.NumBits;
        StopKeyBits = Enum->StopAddress.AddrBits;
    }
    else
    {
        StopNumBits = 0;
        StopKeyBits = NULL;
    }

    NextHopsCopied = 0;

    ACQUIRE_NHOP_TABLE_READ_LOCK(Entity);

    do
    {
        //
        // Get the next list of next-hops from table
        //
        
        NumHopLists = 1;

        Status = EnumOverTable(Entity->NextHopTable,
                               &Enum->NextAddress.NumBits,
                               Enum->NextAddress.AddrBits,
                               &Context,
                               StopNumBits,
                               StopKeyBits,
                               &NumHopLists,
                               &NextHopData);

        if (NumHopLists < 1)
        {
            break;
        }

        HopList = CONTAINING_RECORD(NextHopData, NEXTHOP_LIST, LookupLinkage);

        NextHops = &HopList->NextHopsList;

        // Skip all the interface indices we have seen

        for (p = NextHops->Flink; p != NextHops; p = p->Flink)
        {
            NextHop = CONTAINING_RECORD(p, NEXTHOP_INFO, NextHopsLE);

            if (NextHop->NextHopInfo.InterfaceIndex <= Enum->NextIfIndex)
            {
                break;
            }
        }

#if WRN
        NextHop = NULL;
#endif

        // Copy the rest of the next-hops in the list

        for ( ; p != NextHops; p = p->Flink)
        {
            NextHop = CONTAINING_RECORD(p, NEXTHOP_INFO, NextHopsLE);

            if (NextHopsCopied == NextHopsInput)
            {
                break;
            }

            REFERENCE_NEXTHOP(NextHop, HANDLE_REF);

            NextHopHandles[NextHopsCopied++]=MAKE_HANDLE_FROM_POINTER(NextHop);
        }

        // If we are going to the next list, reset if index

        if (p == NextHops)
        {
            Enum->NextIfIndex = START_IF_INDEX;
        }
        else
        {
            // We have copied enough for this call

            ASSERT(NextHopsCopied == NextHopsInput);

            //
            // We still have next-hops on the list,
            // set back the next 'nexthop address'
            //

            Enum->NextAddress = NextHop->NextHopInfo.NextHopAddress;
            Enum->NextIfIndex = NextHop->NextHopInfo.InterfaceIndex;
                
            Status = NO_ERROR;
        }
    }
    while (SUCCESS(Status) && (NextHopsCopied < NextHopsInput));

    RELEASE_NHOP_TABLE_READ_LOCK(Entity);

    // If we are at end of the enum, make enum as done
    if (Status == ERROR_NO_MORE_ITEMS)
    {
        Enum->EnumDone = TRUE;
    }

    RELEASE_NEXTHOP_ENUM_LOCK(Enum);

    *NumNextHops = NextHopsCopied;

    return *NumNextHops ? NO_ERROR : ERROR_NO_MORE_ITEMS;
}


DWORD
WINAPI
RtmReleaseNextHops (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      UINT                            NumNextHops,
    IN      PRTM_NEXTHOP_HANDLE             NextHopHandles
    )

/*++

Routine Description:

    Release (also called de-reference) handles to next-hops
    obtained in other RTM calls like next hop enumerations.

Arguments:

    RtmRegHandle   - RTM registration handle for calling entity,

    NumNextHops    - Number of handles that are being released,

    NextHopHandles - An array of handles that are being released.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO     Entity;
    PNEXTHOP_INFO    NextHop;
    UINT             i;

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    //
    // Dereference each nexthop handle in array
    //

    for (i = 0; i < NumNextHops; i++)
    {
        NextHop = NEXTHOP_FROM_HANDLE(NextHopHandles[i]);

        DEREFERENCE_NEXTHOP(NextHop, HANDLE_REF);
    }

    return NO_ERROR;
}


DWORD
WINAPI
RtmDeleteEnumHandle (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ENUM_HANDLE                 EnumHandle
    )

/*++

Routine Description:

    Deletes the enumeration handle and frees all resources
    allocated to the enumeration.

Arguments:

    RtmRegHandle   - RTM registration handle for calling entity,

    EnumHandle     - Handle to the enumeration.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO     Entity;
    POPEN_HEADER     Enum;
    PROUTE_ENUM      RouteEnum;
    UCHAR            HandleType;
    UINT             i;

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    //
    // Figure out the enum type and act accordingly
    //

    HandleType = GET_ENUM_TYPE(EnumHandle, &Enum);

#if DBG
    VALIDATE_OBJECT_HANDLE(EnumHandle, HandleType, &Enum);
#endif

    switch (HandleType)
    {

    case DEST_ENUM_TYPE:

        DeleteCriticalSection(&((PDEST_ENUM)Enum)->EnumLock);

        break;

    case ROUTE_ENUM_TYPE:

        RouteEnum = (PROUTE_ENUM) Enum;

        // Dereference the destination that we are enum'ing
        if (RouteEnum->Destination)
        {
            DEREFERENCE_DEST(RouteEnum->Destination, ENUM_REF);
        }

        //
        // Close the associated destination enum & resources
        //

        if (RouteEnum->DestInfo)
        {
            FreeMemory(RouteEnum->DestInfo);
        }

        if (RouteEnum->DestEnum)
        {
            RtmDeleteEnumHandle(RtmRegHandle, RouteEnum->DestEnum);
        }
       
        // Dereference all routes in the enum's snapshot
        for (i = RouteEnum->NextRoute; i < RouteEnum->NumRoutes; i++)
        {
            DEREFERENCE_ROUTE(RouteEnum->RoutesOnDest[i], ENUM_REF);
        }

        // Free memory associated with criteria matching
        if (RouteEnum->CriteriaRoute)
        {
            FreeMemory(RouteEnum->CriteriaRoute);
        }

        // Free memory allocated for the enum's snapshot
        FreeMemory(RouteEnum->RoutesOnDest);

        DeleteCriticalSection(&RouteEnum->EnumLock);

        break;

    case NEXTHOP_ENUM_TYPE:

        DeleteCriticalSection(&((PNEXTHOP_ENUM)Enum)->EnumLock);

        break;

    case LIST_ENUM_TYPE:

        //
        // Remove the enum's marker route from route list
        //

        ACQUIRE_ROUTE_LISTS_WRITE_LOCK(Entity);

        RemoveEntryList(&((PLIST_ENUM)Enum)->MarkerRoute.RouteListLE);

        RELEASE_ROUTE_LISTS_WRITE_LOCK(Entity);

        break;

    default:
        return ERROR_INVALID_HANDLE;
    }

#if DBG_HDL
    //
    // Remove from the list of handles opened by entity
    //

    ACQUIRE_OPEN_HANDLES_LOCK(Entity);
    RemoveEntryList(&Enum->HandlesLE);
    RELEASE_OPEN_HANDLES_LOCK(Entity);
#endif

    DEREFERENCE_ENTITY(Entity, ENUM_REF);

    // Free the memory allocated for the enum and return

#if DBG_HDL
    Enum->ObjectHeader.Alloc = FREED;
#endif

    FreeObject(Enum);

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\rtmlist.h ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmlist.h

Abstract:

    Contains defines for managing entity-specific
    list of routes in RTM.

Author:

    Chaitanya Kodeboyina (chaitk)   10-Sep-1998

Revision History:

--*/

#ifndef __ROUTING_RTMLIST_H__
#define __ROUTING_RTMLIST_H__


//
// Entity Specific List of Routes
//

typedef struct _ROUTE_LIST 
{
    OPEN_HEADER       ListHeader;       // Signature, Type and Reference Count

    LIST_ENTRY        ListHead;         // Points to head of the list of routes
}
ROUTE_LIST , *PROUTE_LIST ;


//
// Enumeration on a Route List
//

typedef struct _LIST_ENUM
{
    OPEN_HEADER       EnumHeader;       // Enumeration Type and Reference Count

    PROUTE_LIST       RouteList;        // Route list on which enum is created

    ROUTE_INFO        MarkerRoute;      // Pointer to next route in route list
}
LIST_ENUM, *PLIST_ENUM;

#endif //  __ROUTING_RTMLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\rtmmetd.c ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmmetd.c

Abstract:

    Contains routines that deals with invocation
    of methods that entities export to other
    entities for the purpose of interpreting
    entity specific data.

Author:

    Chaitanya Kodeboyina (chaitk)  22-Aug-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop


DWORD
WINAPI
RtmGetEntityMethods (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ENTITY_HANDLE               EntityHandle,
    IN OUT  PUINT                           NumMethods,
    OUT     PRTM_ENTITY_EXPORT_METHOD       ExptMethods
    )

/*++

Routine Description:

    Retrieves the set of methods exported by a given entity.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    EntityHandle      - RTM handle for entity whose methods we want,

    NumMethods        - Number of methods that can be filled
                        is passed in, and number of methods
                        exported by this entity is returned,

    ExptMethods       - Set of methods requested by the caller.

Return Value:

    Status of the operation

--*/

{
    PRTM_ENTITY_EXPORT_METHODS EntityMethods;
    PENTITY_INFO     Entity;
    DWORD            Status;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_ENTITY_HANDLE(EntityHandle, &Entity);

    EntityMethods = &Entity->EntityMethods;


    //
    // Does the caller just need number of methods ?
    //

    if (*NumMethods == 0)
    {
        *NumMethods = EntityMethods->NumMethods;

        return NO_ERROR;
    }


    //
    // Check if we have space to copy all methods
    //

    if (EntityMethods->NumMethods > *NumMethods)
    {
        Status = ERROR_INSUFFICIENT_BUFFER;
    }
    else
    {
        Status = NO_ERROR;

        *NumMethods = EntityMethods->NumMethods;
    }

      
    //
    // Copy as many methods as u can fit in output
    //

    ASSERT(ExptMethods != NULL);

    CopyMemory(ExptMethods,
               EntityMethods->Methods, 
               *NumMethods * sizeof(RTM_ENTITY_EXPORT_METHOD));

    *NumMethods = EntityMethods->NumMethods;

    return Status;
}


DWORD
WINAPI
RtmInvokeMethod (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ENTITY_HANDLE               EntityHandle,
    IN      PRTM_ENTITY_METHOD_INPUT        Input,
    IN OUT  PUINT                           OutputSize,
    OUT     PRTM_ENTITY_METHOD_OUTPUT       Output
    )

/*++

Routine Description:

    Invokes a method exported by another entity

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    EntityHandle      - Handle for entity whose method we are invoking,

    Input             - Input buffer with the following information
                          - Methods to be invoked,
                          - Common Input buffer to all these methods,

    OutputSize        - Size of the output buffer is passed in, and
                        the number of bytes filled in output is retd,

    Output            - Output buffer that is filled in the format of
                        a series of (Method Id, Corr. Output) tuples


Return Value:

    Status of the operation

--*/

{
    PRTM_ENTITY_EXPORT_METHODS EntityMethods;
    PENTITY_INFO     Entity;
    DWORD            MethodsCalled;
    DWORD            MethodsLeft;
    UINT             OutputHdrSize;
    UINT             OutBytes;
    UINT             BytesTotal;
    UINT             BytesLeft;
    UINT             i;

    BytesTotal = BytesLeft = *OutputSize;

    *OutputSize = 0;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    //
    // Validate the entity and target handles passed in
    //

    VALIDATE_ENTITY_HANDLE(EntityHandle, &Entity);

    //
    // Call each method in 'methods to be called' mask.
    //

    MethodsCalled = MethodsLeft = Input->MethodType;

    ACQUIRE_ENTITY_METHODS_READ_LOCK(Entity);

    if (Entity->State == ENTITY_STATE_DEREGISTERED)
    {
        RELEASE_ENTITY_METHODS_READ_LOCK(Entity);
        
        return ERROR_INVALID_HANDLE;
    }

    OutputHdrSize = FIELD_OFFSET(RTM_ENTITY_METHOD_OUTPUT, OutputData);

    EntityMethods = &Entity->EntityMethods;

    for (i = 0; (i < EntityMethods->NumMethods) && (MethodsLeft); i++)
    {
        //
        // Do we have bytes left for next method's output ?
        //

        if (BytesLeft < OutputHdrSize)
        {
            break;
        }

        //
        // If next method in list, prepare input and invoke
        //

        if (MethodsLeft & 0x01)
        {
            Input->MethodType = Output->MethodType = (1 << i);

            Output->OutputSize = BytesLeft - OutputHdrSize;

            //
            // Initialize the output params of this method
            //

            Output->OutputSize = 0;

            Output->MethodStatus = ERROR_NOT_SUPPORTED;

            //
            // If method supported, invoke with input/output
            //

            if (EntityMethods->Methods[i])
            {
                EntityMethods->Methods[i](RtmRegHandle, 
                                          EntityHandle,
                                          Input, 
                                          Output);
            }

            OutBytes = Output->OutputSize + OutputHdrSize;
                  
            Output = (PRTM_ENTITY_METHOD_OUTPUT) (OutBytes + (PUCHAR) Output);
              
            BytesLeft -= OutBytes;
        }

        MethodsLeft >>= 1;
    }

    RELEASE_ENTITY_METHODS_READ_LOCK(Entity);

    Input->MethodType = MethodsCalled;

    *OutputSize = BytesTotal - BytesLeft;

    return NO_ERROR;
}


DWORD 
WINAPI
RtmBlockMethods (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      HANDLE                          TargetHandle OPTIONAL,
    IN      UCHAR                           TargetType   OPTIONAL,
    IN      DWORD                           BlockingFlag
    )

/*++

Routine Description:

    Blocks or unblocks the execution of methods on the target
    handle or on all targets if the target handle is NULL.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    TargetHandle      - Destination, Route or NextHop Handle

    TargetType        - Type of the TargetHandle (DEST_TYPE, ...)

    BlockingFlag      - RTM_BLOCK_METHODS or RTM_RESUME_METHODS
                        to block, unblock method invocations resp.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO     Entity;

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    UNREFERENCED_PARAMETER(TargetType);
    UNREFERENCED_PARAMETER(TargetHandle);

#if DBG

    //
    // No method locks on the target used at present
    //

    if (ARGUMENT_PRESENT(TargetHandle))
    {
        PVOID            Target;

        VALIDATE_OBJECT_HANDLE(TargetHandle, TargetType, &Target);
    }

#endif


    if (BlockingFlag == RTM_BLOCK_METHODS)
    {
        ACQUIRE_ENTITY_METHODS_WRITE_LOCK(Entity);
    }
    else
    {
        RELEASE_ENTITY_METHODS_WRITE_LOCK(Entity);
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\rtmmgmt.c ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmmgmt.c

Abstract:
    Routines used to perform various management
    functions on the Routing Table Manager v2.

Author:

    Chaitanya Kodeboyina (chaitk)   17-Aug-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop

#include "rtmmgmt.h"


DWORD
WINAPI
RtmGetInstances (
    IN OUT  PUINT                           NumInstances,
    OUT     PRTM_INSTANCE_INFO              InstanceInfos
    )

/*++

Routine Description:

    Enumerates all active RTM instances with their infos.

Arguments:

    NumInstances   - Num of Instance Info slots in the input
                     buffer is passed in, and the total number 
                     of active RTM instances is returned.

    RtmInstances   - Instance Infos that are active in RTMv2.

Return Value:

    Status of the operation

--*/

{
    PINSTANCE_INFO Instance;
    PLIST_ENTRY    Instances, p;
    UINT           i, j;
    DWORD          Status;

    CHECK_FOR_RTM_API_INITIALIZED();

    TraceEnter("RtmGetInstances");

    ACQUIRE_INSTANCES_READ_LOCK();

    //
    // Get next instance in table and copy info to output
    //

    for (i = j = 0; (i < INSTANCE_TABLE_SIZE) && (j < *NumInstances); i++)
    {
        Instances = &RtmGlobals.InstanceTable[i];
            
        for (p = Instances->Flink; p != Instances; p = p->Flink)
        {
            Instance = CONTAINING_RECORD(p, INSTANCE_INFO, InstTableLE);

            // Copy all relevant Instance information to output

            InstanceInfos[j].RtmInstanceId = Instance->RtmInstanceId;

            InstanceInfos[j].NumAddressFamilies = Instance->NumAddrFamilies;

            if (++j == *NumInstances)
            {
                break;
            }
        }
    }

    Status = (*NumInstances >= RtmGlobals.NumInstances)
                   ? NO_ERROR 
                   : ERROR_INSUFFICIENT_BUFFER;

    *NumInstances = RtmGlobals.NumInstances;

    RELEASE_INSTANCES_READ_LOCK();

    TraceLeave("RtmGetInstances");

    return Status;
}


VOID
CopyAddrFamilyInfo(
    IN      USHORT                          RtmInstanceId,
    IN      PADDRFAM_INFO                   AddrFamilyBlock,
    OUT     PRTM_ADDRESS_FAMILY_INFO        AddrFamilyInfo
    )

/*++

Routine Description:

    Copies all public information from an address family
    to the output buffer.

Arguments:

    RtmInstanceId   - Instance for this addr family info

    AddrFamilyBlock - Actual address family info block

    AddrFamilyInfo  - Address family info is copied here

Return Value:

    None

Locks :

    The global instances lock is held to get a consistent
    view of the address family info in the instance.

--*/

{
    TraceEnter("CopyAddrFamilyInfo");

    AddrFamilyInfo->RtmInstanceId = RtmInstanceId;

    AddrFamilyInfo->AddressFamily = AddrFamilyBlock->AddressFamily;

    AddrFamilyInfo->ViewsSupported = AddrFamilyBlock->ViewsSupported;

    AddrFamilyInfo->MaxHandlesInEnum = AddrFamilyBlock->MaxHandlesInEnum;

    AddrFamilyInfo->MaxNextHopsInRoute = AddrFamilyBlock->MaxNextHopsInRoute;

    AddrFamilyInfo->MaxOpaquePtrs = AddrFamilyBlock->MaxOpaquePtrs;
    AddrFamilyInfo->NumOpaquePtrs = AddrFamilyBlock->NumOpaquePtrs;

    AddrFamilyInfo->NumEntities = AddrFamilyBlock->NumEntities;
        
    AddrFamilyInfo->NumDests = AddrFamilyBlock->NumDests;
    AddrFamilyInfo->NumRoutes = AddrFamilyBlock->NumRoutes;

    AddrFamilyInfo->MaxChangeNotifs = AddrFamilyBlock->MaxChangeNotifs;
    AddrFamilyInfo->NumChangeNotifs = AddrFamilyBlock->NumChangeNotifs;

    TraceLeave("CopyAddrFamilyInfo");

    return;
}


DWORD
WINAPI
RtmGetInstanceInfo (
    IN      USHORT                          RtmInstanceId,
    OUT     PRTM_INSTANCE_INFO              InstanceInfo,
    IN OUT  PUINT                           NumAddrFamilies,
    OUT     PRTM_ADDRESS_FAMILY_INFO        AddrFamilyInfos OPTIONAL
    )

/*++

Routine Description:

    Get config and run time information of an RTM instance.

Arguments:

    RtmInstanceId   - ID identifying the RTM instance,

    InstanceInfo    - Buffer to return supported address families,

    NumAddrFamilies - Number of input address family info slots,
                      Actual number of address families is retd.

    AddrFamilyInfos - Address family infos are copied here.

Return Value:

    Status of the operation

--*/

{
    PINSTANCE_INFO   Instance;
    PADDRFAM_INFO    AddrFamilyBlock;
    PLIST_ENTRY      AddrFamilies, q;
    UINT             i;
    DWORD            Status;

    CHECK_FOR_RTM_API_INITIALIZED();

    TraceEnter("RtmGetInstanceInfo");

    ACQUIRE_INSTANCES_READ_LOCK();

    do
    {
        //
        // Search for the instance with input instance id
        //

        Status = GetInstance(RtmInstanceId, FALSE, &Instance);

        if (Status != NO_ERROR)
        {
            break;
        }

        //
        // Copy RTM instance information to output
        //

        InstanceInfo->RtmInstanceId = RtmInstanceId;

        InstanceInfo->NumAddressFamilies = Instance->NumAddrFamilies;

        //
        // Copy address family infomation if reqd
        //

        if (ARGUMENT_PRESENT(AddrFamilyInfos))
        {
            if (*NumAddrFamilies < Instance->NumAddrFamilies)
            {
                Status = ERROR_INSUFFICIENT_BUFFER;
            }

            //
            // Copy info for as many addr families as possible
            //

            AddrFamilies = &Instance->AddrFamilyTable;

            for (q = AddrFamilies->Flink, i = 0;
                 (q != AddrFamilies) && (i < *NumAddrFamilies);
                 q = q->Flink)
            {
                AddrFamilyBlock =CONTAINING_RECORD(q, ADDRFAM_INFO, AFTableLE);

                CopyAddrFamilyInfo(RtmInstanceId, 
                                   AddrFamilyBlock, 
                                   &AddrFamilyInfos[i++]);
            }
        }

        *NumAddrFamilies = Instance->NumAddrFamilies;
    }
    while (FALSE);

    RELEASE_INSTANCES_READ_LOCK();

    TraceLeave("RtmGetInstanceInfo");

    return Status;
}


DWORD
WINAPI
RtmGetAddressFamilyInfo (
    IN      USHORT                          RtmInstanceId,
    IN      USHORT                          AddressFamily,
    OUT     PRTM_ADDRESS_FAMILY_INFO        AddrFamilyInfo,
    IN OUT  PUINT                           NumEntities,
    OUT     PRTM_ENTITY_INFO                EntityInfos OPTIONAL
    )

/*++

Routine Description:

    Get config and run time information of an address family
    in an RTM instance.

Arguments:

    RtmInstanceId  - ID identifying the RTM instance

    AddressFamily  - Address family that we are interested in

    AddrFamilyInfo - Buffer to return output information in

    NumEntities    - Number of slots in the EntityIds buffer and
                     filled with num of regd entities on return.

    EntityInfos    - IDs of all registered entities is retd here.

Return Value:

    Status of the operation

--*/

{
    PINSTANCE_INFO Instance;
    PADDRFAM_INFO  AddrFamilyBlock;
    PENTITY_INFO   Entity;
    PLIST_ENTRY    Entities, r;
    UINT           i, j;
    DWORD          Status;

    CHECK_FOR_RTM_API_INITIALIZED();

    TraceEnter("RtmGetAddressFamilyInfo");

    ACQUIRE_INSTANCES_READ_LOCK();

    do
    {

        //
        // Search for an instance with the input RtmInstanceId
        //

        Status = GetInstance(RtmInstanceId, FALSE, &Instance);

        if (Status != NO_ERROR)
        {
            break;
        }


        //
        // Search for an address family info with input family
        //

        Status = GetAddressFamily(Instance,
                                  AddressFamily,
                                  FALSE,
                                  &AddrFamilyBlock);

        if (Status != NO_ERROR)
        {
            break;
        }


        //
        // Copy relevant address family information
        //

        CopyAddrFamilyInfo(RtmInstanceId, AddrFamilyBlock, AddrFamilyInfo);

        //
        // Is caller interested in entity info too ?
        //

        if (ARGUMENT_PRESENT(EntityInfos))
        {
            if (*NumEntities < AddrFamilyBlock->NumEntities)
            {
                Status = ERROR_INSUFFICIENT_BUFFER;
            }

            //
            // Copy all relevant entity information to output
            //

            for (i = j = 0; (i < ENTITY_TABLE_SIZE) && (j < *NumEntities); i++)
            {
                Entities = &AddrFamilyBlock->EntityTable[i];
                    
                for (r = Entities->Flink; r != Entities; r = r->Flink)
                {
                    Entity = CONTAINING_RECORD(r, ENTITY_INFO, EntityTableLE);

                    EntityInfos[j].RtmInstanceId = RtmInstanceId;
                    EntityInfos[j].AddressFamily = AddressFamily;

                    EntityInfos[j].EntityId = Entity->EntityId;

                    if (++j == *NumEntities)
                    {
                        break;
                    }
                }
            }
        }

        *NumEntities = AddrFamilyBlock->NumEntities;
    }
    while (FALSE);

    RELEASE_INSTANCES_READ_LOCK();

    TraceLeave("RtmGetAddressFamilyInfo");

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\rtmmain.h ===
/*++

Copyright (c) 1997-1998 Microsoft Corporation

Module Name:

    rtmmain.h

Abstract:
    Private defs for Routing Table Manager DLL

Author:
    Chaitanya Kodeboyina (chaitk)  17-Aug-1998

Revision History:

--*/


#ifndef __ROUTING_RTMMAIN_H__
#define __ROUTING_RTMMAIN_H__

//
// Common Header for all RTM internal structures
//

// Disable warnings for unnamed structs
#pragma warning(disable : 4201)  

typedef struct _OBJECT_HEADER
{
#if DBG_HDL
    union
    {
        DWORD         TypeSign;        // Type & unique signature for object
        struct
        {
            CHAR      Type;            // Identifies type of the object
            CHAR      Signature[2];    // Pattern unique for an object type
            CHAR      Alloc;           // Set + if allocated, - if freed
        };
    };
#endif

#if DBG_MEM
    LIST_ENTRY        AllocLE;         // On list of all memory allocations
#endif

    LONG              RefCount;        // Reference count for this object

#if DBG_REF
    LONG              RefTypes[MAX_REFS]; // Nature of references on the object
#endif
}
OBJECT_HEADER, *POBJECT_HEADER;

#pragma warning(default : 4201)  


//
// Defns to validate handles & convert them to pointers
//

#define HANDLE_CONV_KEY                                                     \
            (ULONG_PTR)(('RTM2') | ('RTM2' << (sizeof(PVOID) - 4)))

#define MAKE_HANDLE_FROM_POINTER(ObjectHandle)                              \
            (HANDLE) (((ULONG_PTR) ObjectHandle) ^ HANDLE_CONV_KEY)

#define GET_POINTER_FROM_HANDLE(ObjectHandle)                               \
            (PVOID)  (((ULONG_PTR) ObjectHandle) ^ HANDLE_CONV_KEY)


PVOID
__inline
GetObjectFromHandle(HANDLE ObjectHandle, UCHAR ObjectType)
{
    POBJECT_HEADER ObjHdr = GET_POINTER_FROM_HANDLE(ObjectHandle);

    UNREFERENCED_PARAMETER(ObjectType);

#if DBG_HDL
    try
    {
        if (ObjHdr->TypeSign != OBJECT_SIGNATURE[ObjectType])
        {
            if (ObjectType != GENERIC_TYPE)
            {
                ObjHdr = NULL;
            }
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
        { 
            ObjHdr = NULL;
        }
#endif

    return ObjHdr;
}



#define OBJECT_FROM_HANDLE(ObjectHandle, ObjectType)                        \
          (POBJECT_HEADER) GetObjectFromHandle(ObjectHandle, ObjectType);

#define VALIDATE_OBJECT_HANDLE(ObjectHandle, ObjectType, pObject)           \
            *pObject = (PVOID) OBJECT_FROM_HANDLE(ObjectHandle, ObjectType);\
            if ((!*pObject))                                                \
            {                                                               \
                return ERROR_INVALID_HANDLE;                                \
            }                                                               \



#define ENTITY_FROM_HANDLE(EntityHandle)                                    \
            (PENTITY_INFO) GetObjectFromHandle(EntityHandle, ENTITY_TYPE)

#define VALIDATE_ENTITY_HANDLE(EntityHandle, pEntity)                       \
            *pEntity = ENTITY_FROM_HANDLE(EntityHandle);                    \
            if ((!*pEntity)||((*pEntity)->State==ENTITY_STATE_DEREGISTERED))\
            {                                                               \
                return ERROR_INVALID_HANDLE;                                \
            }                                                               \

#define DBG_VALIDATE_ENTITY_HANDLE(EntityHandle, pEntity)                   \
            UNREFERENCED_PARAMETER(EntityHandle);                           \
            DBG_UNREFERENCED_LOCAL_VARIABLE(*pEntity);                      \
            if (DBG_HDL)                                                    \
            {                                                               \
                VALIDATE_ENTITY_HANDLE(EntityHandle, pEntity)               \
            }


#define DEST_FROM_HANDLE(DestHandle)                                        \
            (PDEST_INFO) GetObjectFromHandle(DestHandle, DEST_TYPE)

#define VALIDATE_DEST_HANDLE(DestHandle, pDest)                             \
            *pDest = DEST_FROM_HANDLE(DestHandle);                          \
            if ((!(*pDest)) || ((*pDest)->State == DEST_STATE_DELETED))     \
            {                                                               \
                return ERROR_INVALID_HANDLE;                                \
            }                                                               \



#define ROUTE_FROM_HANDLE(RouteHandle)                                      \
            (PROUTE_INFO) GetObjectFromHandle(RouteHandle, ROUTE_TYPE)

#define VALIDATE_ROUTE_HANDLE(RouteHandle, pRoute)                          \
            *pRoute = ROUTE_FROM_HANDLE(RouteHandle);                       \
            if (                                                            \
                (!(*pRoute)) ||                                             \
                ((*pRoute)->RouteInfo.State == RTM_ROUTE_STATE_DELETED)     \
               )                                                            \
            {                                                               \
                return ERROR_INVALID_HANDLE;                                \
            }                                                               \



#define NEXTHOP_FROM_HANDLE(NextHopHandle)                                  \
            (PNEXTHOP_INFO) GetObjectFromHandle(NextHopHandle, NEXTHOP_TYPE)

#define VALIDATE_NEXTHOP_HANDLE(NextHopHandle, pNextHop)                    \
            *pNextHop = NEXTHOP_FROM_HANDLE(NextHopHandle);                 \
            if (!(*pNextHop))                                               \
            {                                                               \
                return ERROR_INVALID_HANDLE;                                \
            }                                                               \



#define DEST_ENUM_FROM_HANDLE(DestEnumHandle)                               \
            (PDEST_ENUM) GetObjectFromHandle(DestEnumHandle, DEST_ENUM_TYPE)

#define VALIDATE_DEST_ENUM_HANDLE(DestEnumHandle, pDestEnum)                \
            *pDestEnum = DEST_ENUM_FROM_HANDLE(DestEnumHandle);             \
            if ((!*pDestEnum))                                              \
            {                                                               \
                return ERROR_INVALID_HANDLE;                                \
            }                                                               \



#define ROUTE_ENUM_FROM_HANDLE(RouteEnumHandle)                             \
         (PROUTE_ENUM) GetObjectFromHandle(RouteEnumHandle, ROUTE_ENUM_TYPE)

#define VALIDATE_ROUTE_ENUM_HANDLE(RouteEnumHandle, pRouteEnum)             \
            *pRouteEnum = ROUTE_ENUM_FROM_HANDLE(RouteEnumHandle);          \
            if ((!*pRouteEnum))                                             \
            {                                                               \
                return ERROR_INVALID_HANDLE;                                \
            }                                                               \


#define NEXTHOP_ENUM_FROM_HANDLE(EnumHandle)                                \
          (PNEXTHOP_ENUM) GetObjectFromHandle(EnumHandle, NEXTHOP_ENUM_TYPE)

#define VALIDATE_NEXTHOP_ENUM_HANDLE(NextHopEnumHandle, pNextHopEnum)       \
            *pNextHopEnum = NEXTHOP_ENUM_FROM_HANDLE(NextHopEnumHandle);    \
            if ((!*pNextHopEnum))                                           \
            {                                                               \
                return ERROR_INVALID_HANDLE;                                \
            }                                                               \



#define NOTIFY_FROM_HANDLE(NotifyHandle)                                    \
            (PNOTIFY_INFO) GetObjectFromHandle(NotifyHandle, NOTIFY_TYPE)

#define VALIDATE_NOTIFY_HANDLE(NotifyHandle, pNotify)                       \
            *pNotify = NOTIFY_FROM_HANDLE(NotifyHandle);                    \
            if ((!*pNotify) || ((*pNotify)->CNIndex < 0))                   \
            {                                                               \
                return ERROR_INVALID_HANDLE;                                \
            }                                                               \



#define ROUTE_LIST_FROM_HANDLE(ListHandle)                                 \
            (PROUTE_LIST) GetObjectFromHandle(ListHandle, ROUTE_LIST_TYPE)

#define VALIDATE_ROUTE_LIST_HANDLE(ListHandle, pList)                       \
            *pList = ROUTE_LIST_FROM_HANDLE(ListHandle);                    \
            if ((!*pList))                                                  \
            {                                                               \
                return ERROR_INVALID_HANDLE;                                \
            }                                                               \


#define LIST_ENUM_FROM_HANDLE(ListEnumHandle)                               \
            (PLIST_ENUM) GetObjectFromHandle(ListEnumHandle, LIST_ENUM_TYPE)

#define VALIDATE_LIST_ENUM_HANDLE(ListEnumHandle, pListEnum)                \
            *pListEnum = LIST_ENUM_FROM_HANDLE(ListEnumHandle);             \
            if ((!*pListEnum))                                              \
            {                                                               \
                return ERROR_INVALID_HANDLE;                                \
            }                                                               \


//
// Defns used to maintain reference count on structures
//


ULONG
__inline
InitializeObjectReference(POBJECT_HEADER Object, UCHAR RefType)
{
    UNREFERENCED_PARAMETER(RefType);

#if DBG_REF
    InterlockedIncrement(&Object->RefTypes[RefType]);
#endif

    return InterlockedIncrement(&Object->RefCount);
}


ULONG
__inline
ReferenceObject(POBJECT_HEADER Object, UCHAR RefType)
{
    UNREFERENCED_PARAMETER(RefType);

    // Once ref falls to 0, this should never happen
    ASSERT(Object->RefCount > 0);

#if DBG_REF
    ASSERT(Object->RefTypes[RefType] >= 0);

    InterlockedIncrement(&Object->RefTypes[RefType]);
#endif

    return InterlockedIncrement(&Object->RefCount);
}


ULONG
__inline
DereferenceObject(POBJECT_HEADER Object, UCHAR RefType)
{
    UNREFERENCED_PARAMETER(RefType);

    // Ref count should be +ve before we decrement it
    ASSERT(Object->RefCount > 0);

#if DBG_REF
    ASSERT(Object->RefTypes[RefType] > 0);

    InterlockedDecrement(&Object->RefTypes[RefType]);
#endif

    return InterlockedDecrement(&Object->RefCount);
}


#define INITIALIZE_INSTANCE_REFERENCE(Instance, RefType)                    \
            InitializeObjectReference(&Instance->ObjectHeader, RefType);

#define REFERENCE_INSTANCE(Instance, RefType)                               \
            ReferenceObject(&Instance->ObjectHeader, RefType);

#define DEREFERENCE_INSTANCE(Instance, RefType)                             \
            if (DereferenceObject(&Instance->ObjectHeader, RefType) == 0)   \
                DestroyInstance(Instance);


#define INITIALIZE_ADDR_FAMILY_REFERENCE(Instance, RefType)                 \
            InitializeObjectReference(&Instance->ObjectHeader, RefType);

#define REFERENCE_ADDR_FAMILY(AddrFamilyInfo, RefType)                      \
            ReferenceObject(&AddrFamilyInfo->ObjectHeader, RefType);

#define DEREFERENCE_ADDR_FAMILY(AddrFamInfo, RefType)                       \
            if (DereferenceObject(&AddrFamInfo->ObjectHeader,RefType) == 0) \
                DestroyAddressFamily(AddrFamInfo);


#define INITIALIZE_ENTITY_REFERENCE(Entity, RefType)                        \
            InitializeObjectReference(&Entity->ObjectHeader, RefType);

#define REFERENCE_ENTITY(Entity, RefType)                                   \
            ReferenceObject(&Entity->ObjectHeader, RefType);

#define DEREFERENCE_ENTITY(Entity, RefType)                                 \
            if (DereferenceObject(&Entity->ObjectHeader, RefType) == 0)     \
                DestroyEntity(Entity);


#define INITIALIZE_DEST_REFERENCE(Dest, RefType)                            \
            InitializeObjectReference(&(Dest)->ObjectHeader, RefType);

#define REFERENCE_DEST(Dest, RefType)                                       \
            ReferenceObject(&(Dest)->ObjectHeader, RefType);

#define DEREFERENCE_DEST(Dest, RefType)                                     \
            if (DereferenceObject(&(Dest)->ObjectHeader, RefType) == 0)     \
                DestroyDest(Dest);


#define INITIALIZE_ROUTE_REFERENCE(Route, RefType)                          \
            InitializeObjectReference(&(Route)->ObjectHeader, RefType);

#define REFERENCE_ROUTE(Route, RefType)                                     \
            ReferenceObject(&(Route)->ObjectHeader, RefType);

#define DEREFERENCE_ROUTE(Route, RefType)                                   \
            if (DereferenceObject(&(Route)->ObjectHeader, RefType) == 0)    \
                DestroyRoute(Route);


#define INITIALIZE_NEXTHOP_REFERENCE(NextHop, RefType)                      \
            InitializeObjectReference(&(NextHop)->ObjectHeader, RefType);

#define REFERENCE_NEXTHOP(NextHop, RefType)                                 \
            ReferenceObject(&(NextHop)->ObjectHeader, RefType);

#define DEREFERENCE_NEXTHOP(NextHop, RefType)                               \
            if (DereferenceObject(&(NextHop)->ObjectHeader, RefType) == 0)  \
                DestroyNextHop(NextHop);

//
// Macros used to lock structures using critical sections
//

#define CREATE_LOCK(Lock)                                                   \
            InitializeCriticalSection((Lock))

#define DELETE_LOCK(Lock)                                                   \
            DeleteCriticalSection((Lock))

#define ACQUIRE_LOCK(Lock)                                                  \
            EnterCriticalSection((Lock))

#define RELEASE_LOCK(Lock)                                                  \
            LeaveCriticalSection((Lock))


//
// Macros used to lock structures in read or write mode
//

typedef RTL_RESOURCE READ_WRITE_LOCK, *PREAD_WRITE_LOCK;

#define CREATE_READ_WRITE_LOCK(pRWL)                                        \
            RtlInitializeResource((pRWL))

#define DELETE_READ_WRITE_LOCK(pRWL)                                        \
            RtlDeleteResource((pRWL))

#define READ_WRITE_LOCK_CREATED(pRWL)   (TRUE)

#define ACQUIRE_READ_LOCK(pRWL)                                             \
            RtlAcquireResourceShared((pRWL),TRUE)

#define RELEASE_READ_LOCK(pRWL)                                             \
            RtlReleaseResource((pRWL))

#define ACQUIRE_WRITE_LOCK(pRWL)                                            \
            RtlAcquireResourceExclusive((pRWL),TRUE)

#define RELEASE_WRITE_LOCK(pRWL)                                            \
            RtlReleaseResource((pRWL))

#define READ_LOCK_TO_WRITE_LOCK(pRWL)                                       \
            RtlConvertSharedToExclusive((pRWL))

#define WRITE_LOCK_TO_READ_LOCK(pRWL)                                       \
            RtlConvertExclusiveToShared((pRWL))

//
// Macros to acquire and release dynamic R/W locks
// [ This has been borrowed from the MGM libary ]
//

#define ACQUIRE_DYNAMIC_READ_LOCK(ppRWL)                                    \
            AcquireReadLock((PMGM_READ_WRITE_LOCK *)ppRWL)

#define RELEASE_DYNAMIC_READ_LOCK(ppRWL)                                    \
            ReleaseReadLock((PMGM_READ_WRITE_LOCK *)ppRWL)

#define ACQUIRE_DYNAMIC_WRITE_LOCK(ppRWL)                                   \
            AcquireWriteLock((PMGM_READ_WRITE_LOCK *)ppRWL)

#define RELEASE_DYNAMIC_WRITE_LOCK(ppRWL)                                   \
            ReleaseWriteLock((PMGM_READ_WRITE_LOCK *)ppRWL)


//
// Macros used in allocating and operating on memory
//

#define ZeroMemory             RtlZeroMemory
#define CopyMemory             RtlCopyMemory
#define CompareMemory          RtlEqualMemory

#define AllocOnStack(nb)       _alloca((nb))

#define AllocMemory(nb)        HeapAlloc(RtmGlobals.GlobalHeap,  \
                                         0,                      \
                                         (nb))

#define AllocNZeroMemory(nb)   HeapAlloc(RtmGlobals.GlobalHeap,  \
                                         HEAP_ZERO_MEMORY,       \
                                         (nb))

#define FreeMemory(ptr)        HeapFree(RtmGlobals.GlobalHeap,   \
                                        0,                       \
                                        (ptr))

#if !DBG_MEM

#define AllocNZeroObject(nb)   AllocNZeroMemory(nb)

#else

PVOID
__inline
AllocNZeroObject(UINT NumBytes)
{
    OBJECT_HEADER *Object;

    Object = AllocNZeroMemory(NumBytes);

    if (Object)
    {

        ACQUIRE_ALLOCS_LIST_LOCK();
        InsertTailList(&RtmGlobals.AllocsList, &Object->AllocLE);
        RELEASE_ALLOCS_LIST_LOCK();
    }

    return Object;
}

#endif

#if !DBG_MEM

#define FreeObject(ptr)        FreeMemory(ptr)

#else

VOID
__inline
FreeObject(PVOID Object)
{
    ACQUIRE_ALLOCS_LIST_LOCK();
    RemoveEntryList(&((POBJECT_HEADER)Object)->AllocLE);
    RELEASE_ALLOCS_LIST_LOCK();

    FreeMemory(Object);
}

#endif

//
// Other Misc Macros
//


DWORD
__inline
NumBitsInDword (DWORD Dword)
{
    DWORD  NumBits = 0;

    while (Dword)
    {
        Dword &= (Dword - 1);

        NumBits++;
    }

    return NumBits;
}

#define NUMBER_OF_BITS  NumBitsInDword

//
// Error Handling and other related macros
//
#define SUCCESS(code)          (code == NO_ERROR)

//
// DLL Startup, Cleanup Functions and Macros
//

BOOL
RtmDllStartup(
    VOID
    );

BOOL
RtmDllCleanup(
    VOID
    );

DWORD
RtmApiStartup(
    VOID
    );

#define CHECK_FOR_RTM_API_INITIALIZED()                          \
    if (!RtmGlobals.ApiInitialized)                              \
    {                                                            \
        Status = RtmApiStartup();                                \
                                                                 \
        if (Status != NO_ERROR)                                  \
        {                                                        \
            return Status;                                       \
        }                                                        \
    }                                                            \

#endif //__ROUTING_RTMMAIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\rtmmain.c ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmmain.c

Abstract:

    Contains routines that are invoked when
    the RTMv2 DLL is loaded or unloaded.

Author:

    Chaitanya Kodeboyina (chaitk)  17-Aug-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop

// All Global variables
RTMP_GLOBAL_INFO  RtmGlobals;

BOOL
WINAPI
DllMain(
    IN      HINSTANCE                       Instance,
    IN      DWORD                           Reason,
    IN      PVOID                           Unused
    )

/*++

Routine Description:

    This is the DLL's main entrypoint handler which
    initializes RTMv1, RTMv2 and MGM components. 
    
Arguments:

    None

Return Value:

    TRUE if successful, FALSE if not
    
--*/

{
    static BOOL Rtmv1Initialized = FALSE;
    static BOOL RtmInitialized = FALSE;
    static BOOL MgmInitialized = FALSE;
    BOOL        Success;

    UNREFERENCED_PARAMETER(Unused);

    Success = FALSE;

    switch(Reason) 
    {
    case DLL_PROCESS_ATTACH:

        DisableThreadLibraryCalls(Instance);

        //
        // Initialize the RTMv1, RTMv2 and MGM APIs
        //

        Rtmv1Initialized = Rtmv1DllStartup(Instance);

        if (Rtmv1Initialized)
        {
            RtmInitialized = RtmDllStartup();
            
            if (RtmInitialized)
            {
                MgmInitialized = MgmDllStartup();
            }
        }

        return MgmInitialized;

    case DLL_PROCESS_DETACH:

        //
        // Cleanup the MGM, RTMv2 and RTMv1 APIs
        //

        if (MgmInitialized)
        {
            MgmDllCleanup();
        }

        if (RtmInitialized)
        {
            Success = RtmDllCleanup();
        }

        if (Rtmv1Initialized)
        {
            Rtmv1DllCleanup();
        }

        break;

    default:

        Success = TRUE;

        break;
    }

    return Success;
}


BOOL
RtmDllStartup(
    VOID
    )

/*++

Routine Description:

    Called by DLL Main when the process is attached.
    We do minimal initialization here like creating
    a lock that protects all globals (including the
    'ApiInitialized' -- see RtmRegisterEntity func).
    
Arguments:

    None

Return Value:

    TRUE if successful, FALSE if not
    
--*/

{
    //
    // One can safely assume that globals have been set to 0
    //

    // ZeroMemory(&RtmGlobals, sizeof(RTMP_GLOBAL_INFO));

    //
    // Initialize lock to guard the global table of instances
    //

    try
    {
        CREATE_READ_WRITE_LOCK(&RtmGlobals.InstancesLock);
    }
    except(EXCEPTION_EXECUTE_HANDLER)
        {
            return FALSE;
        }
        
    return TRUE;
}


DWORD
RtmApiStartup(
    VOID
    )

/*++

Routine Description:

    Initializes most global data structures in RTMv2.

    We initialize most variables here instead of in
    RtmDllStartup as it might not be safe to perform
    some operations in the context of DLL's DLLMain.

    For example, if we find no config information, we
    set up default config information in the registry.

    This function is called when the first RTMv2 API
    call, which is typically an entity registration,
    is made. See the invocation in RtmRegisterEntity.

Arguments:

    None

Return Value:

    Status of the operation

--*/

{
    RTM_INSTANCE_CONFIG InstanceConfig;
    BOOL                ListLockInited;
    DWORD               Status;
    UINT                i;

    ListLockInited = FALSE;

    Status = NO_ERROR;

    ACQUIRE_INSTANCES_WRITE_LOCK();

    do
    {
        //
        // If API has already been initialized, work is done
        //

        if (RtmGlobals.ApiInitialized)
        {
            break;
        }

        //
        // Enable logging and tracing for debugging purposes
        //
  
        START_TRACING();
        START_LOGGING();

#if DBG_TRACE
        RtmGlobals.TracingFlags = RTM_TRACE_ANY;
#endif

#if DBG_MEM

        //
        // Init a lock & list to hold mem allocs
        //

        try
        {
            InitializeCriticalSection(&RtmGlobals.AllocsLock);

            ListLockInited = TRUE;
        }
        except(EXCEPTION_EXECUTE_HANDLER)
            {
                Status = GetLastError();
          
                Trace1(ANY, 
                       "RTMApiStartup : Failed to init a critical section %x",
                       Status);
      
                LOGERR0(INIT_CRITSEC_FAILED, Status);

                break;
            }

        InitializeListHead(&RtmGlobals.AllocsList);
#endif

        //
        // Create a private heap for RTM's use
        //

        RtmGlobals.GlobalHeap = HeapCreate(0, 0, 0);
  
        if (RtmGlobals.GlobalHeap == NULL)
        {
            Status = GetLastError();

            Trace1(ANY, 
                   "RtmApiStartup: Failed to create a global private heap %x",
                   Status);

            LOGERR0(HEAP_CREATE_FAILED, Status);
            
            break;
        }

        //
        // Initialize the root of RTM's registry information
        //

        RtmGlobals.RegistryPath = AllocNZeroMemory(MAX_CONFIG_KEY_SIZE);

        if (RtmGlobals.RegistryPath == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        CopyMemory(RtmGlobals.RegistryPath,
                   RTM_CONFIG_ROOT,
                   RTM_CONFIG_ROOT_SIZE);

        //
        // Initialize the global hash table of RTM instances
        //

        RtmGlobals.NumInstances = 0;
        for (i = 0; i < INSTANCE_TABLE_SIZE; i++)
        {
            InitializeListHead(&RtmGlobals.InstanceTable[i]);
        }

        //
        // You need to set this value to TRUE to avoid
        // any more recursive calls into this function
        //

        RtmGlobals.ApiInitialized = TRUE;

        //
        // Read config info if present ; else pick default
        //

        Status = RtmReadInstanceConfig(DEFAULT_INSTANCE_ID, &InstanceConfig);

        if (Status != NO_ERROR)
        {
            Status = RtmWriteDefaultConfig(DEFAULT_INSTANCE_ID);

            if (Status != NO_ERROR)
            {
                break;
            }
        }
    }
    while (FALSE);

    if (Status != NO_ERROR)
    {
        //
        // Some error occured - clean up and return the error code
        //

        if (RtmGlobals.RegistryPath != NULL)
        {
            FreeMemory(RtmGlobals.RegistryPath);
        }

        if (RtmGlobals.GlobalHeap != NULL)
        {
            HeapDestroy(RtmGlobals.GlobalHeap);
        }

#if DBG_MEM
        if (ListLockInited)
        {
            DeleteCriticalSection(&RtmGlobals.AllocsLock);
        }
#endif

        STOP_LOGGING();
        STOP_TRACING();

        //
        // We had prematurely set the value to TRUE above, reset it
        //

        RtmGlobals.ApiInitialized = FALSE;
    }

    RELEASE_INSTANCES_WRITE_LOCK();

    return Status;
}


BOOL
RtmDllCleanup(
    VOID
    )

/*++

Routine Description:

    Cleans up all global data structures at unload time.
    
Arguments:

    None

Return Value:

    TRUE if successful, FALSE if not

--*/

{
    PINSTANCE_INFO Instance;
    PLIST_ENTRY    Instances, p, r;
    UINT           NumInstances;
    PADDRFAM_INFO  AddrFamilyInfo;
    PLIST_ENTRY    AddrFamilies, q;
    PENTITY_INFO   Entity;
    PLIST_ENTRY    Entities, s;
    UINT           NumEntities;
    UINT           i, j, k, l;

    //
    // Do we have any instances and associated ref counts left ?
    //

    if (RtmGlobals.NumInstances != 0)
    {
        //
        // We need to stop all outstanding timers
        // on every address family as the RTM DLL
        // gets unloaded after this call returns.
        // We also forcefully destroy entities &
        // address families to reclaim resources.
        //

        ACQUIRE_INSTANCES_WRITE_LOCK();

        NumInstances = RtmGlobals.NumInstances;

        for (i = j = 0; i < INSTANCE_TABLE_SIZE; i++)
        {
            Instances = &RtmGlobals.InstanceTable[i];
        
            for (p = Instances->Flink; p != Instances; p = r)
            {
                Instance = CONTAINING_RECORD(p, INSTANCE_INFO, InstTableLE);

                AddrFamilies = &Instance->AddrFamilyTable;
#if WRN
                r = p->Flink;
#endif
                for (q = AddrFamilies->Flink; q != AddrFamilies; )
                {
                    AddrFamilyInfo = 
                        CONTAINING_RECORD(q, ADDRFAM_INFO, AFTableLE);

                    //
                    // Holding the instances lock while deleting
                    // timer queues (using blocking calls) can 
                    // result in a deadlock, so just reference
                    // the address family and release the lock.
                    //
                    
                    // Ref address family so that it does not disappear
                    REFERENCE_ADDR_FAMILY(AddrFamilyInfo, TEMP_USE_REF);

                    RELEASE_INSTANCES_WRITE_LOCK();

                    //
                    // Block until timers on address family are cleaned up
                    //

                    if (AddrFamilyInfo->RouteTimerQueue)
                    {
                        DeleteTimerQueueEx(AddrFamilyInfo->RouteTimerQueue, 
                                           (HANDLE) -1);

                        AddrFamilyInfo->RouteTimerQueue = NULL;
                    }

                    if (AddrFamilyInfo->NotifTimerQueue)
                    {
                        DeleteTimerQueueEx(AddrFamilyInfo->NotifTimerQueue, 
                                           (HANDLE) -1);

                        AddrFamilyInfo->NotifTimerQueue = NULL;
                    }

                    //
                    // We assume that we have no other code paths that
                    // access any data structures on this addr family
                    //

                    //
                    // Force destroy each entity on the address family
                    //

                    NumEntities = AddrFamilyInfo->NumEntities;

                    for (k = l = 0; k < ENTITY_TABLE_SIZE; k++)
                    {
                        Entities = &AddrFamilyInfo->EntityTable[k];

                        for (s = Entities->Flink; s != Entities; )
                        {
                            Entity = 
                              CONTAINING_RECORD(s, ENTITY_INFO, EntityTableLE);

                            s = s->Flink;

                            // To satisfy the asserts in DestroyEntity
                            Entity->ObjectHeader.RefCount = 0;

                            DestroyEntity(Entity);

                            l++;
                        }

                        if (l == NumEntities)
                        {
                            break;
                        }
                    }

                    //
                    // Also destroy entities that have deregistered
                    // but haven't been destroyed due to ref counts
                    //

                    while (!IsListEmpty(&AddrFamilyInfo->DeregdEntities))
                    {
                       Entity = 
                        CONTAINING_RECORD(AddrFamilyInfo->DeregdEntities.Flink,
                                          ENTITY_INFO, 
                                          EntityTableLE);

                       // To satisfy the asserts in DestroyEntity
                       Entity->ObjectHeader.RefCount = 0;

                       DestroyEntity(Entity);
                    }

                    ACQUIRE_INSTANCES_WRITE_LOCK();

                    // Get next address family before de-ref-ing current
                    q = q->Flink;

                    // Get next instance also as it might be deleted too
                    r = p->Flink;

                    // Remove the temporary reference use added earlier 
                    DEREFERENCE_ADDR_FAMILY(AddrFamilyInfo, TEMP_USE_REF);
                }

                j++;
            }

            if (j == NumInstances)
            {
                break;
            }
        }

        RELEASE_INSTANCES_WRITE_LOCK();
    }

    // We have freed all instances to avoid any leaks
    ASSERT(RtmGlobals.NumInstances == 0);

    //
    // Free resources allocated like locks and memory
    //

    if (RtmGlobals.ApiInitialized)
    {
        FreeMemory(RtmGlobals.RegistryPath);

        //
        // At this point we might have whole lots of dests,
        // routes, nexthops etc. that are have not been
        // freed because of outstanding ref counts; however
        // none of these objects have any locks (except
        // dest locks which are dynamic anyway and can
        // be unlocked and freed after deregistration),
        // so we can just blow the heap to reclaim memory.
        //

        HeapDestroy(RtmGlobals.GlobalHeap);

#if DBG_MEM
        DeleteCriticalSection(&RtmGlobals.AllocsLock);
#endif

        //
        // Stop debugging aids like tracing and logging
        //

        STOP_LOGGING();
        STOP_TRACING();
    }

    DELETE_READ_WRITE_LOCK(&RtmGlobals.InstancesLock);

    return TRUE;
}


#if DBG_MEM

VOID
DumpAllocs (VOID)

/*++

Routine Description:

    Debug tool to dump all objects that are
    allocated by RTMv2 at any instant.
    
Arguments:

    None

Return Value:

    None

--*/

{
    POBJECT_HEADER  Object;
    PLIST_ENTRY     p;
    UINT            i;

    printf("\n\n----------------Allocs Left Over------------------------\n");

    ACQUIRE_ALLOCS_LIST_LOCK();

    for (p = RtmGlobals.AllocsList.Flink; 
                           p != &RtmGlobals.AllocsList; 
                                                     p = p->Flink)
    {
        Object = CONTAINING_RECORD(p, OBJECT_HEADER, AllocLE);

        printf("Object @ %p: \n", Object);

#if DBG_HDL
        printf("Object Signature = %c%c%c%c\n",
                       Object->Type,
                       Object->Signature[0],
                       Object->Signature[1],
                       Object->Alloc);
#endif

#if DBG_REF
        printf("Object RefCounts: \n");

        for (i = 0; i < MAX_REFS; i++)
        {
            printf("%2lu", Object->RefTypes[i]);
        }
#endif

        printf("\n");
    }

    RELEASE_ALLOCS_LIST_LOCK();

    printf("\n--------------------------------------------------------\n\n");
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\rtmnhop.c ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmnhop.c

Abstract:

    Contains routines for managing RTM Next Hops.

Author:

    Chaitanya Kodeboyina (chaitk)   21-Aug-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop


DWORD
WINAPI
RtmAddNextHop (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      PRTM_NEXTHOP_INFO               NextHopInfo,
    IN OUT  PRTM_NEXTHOP_HANDLE             NextHopHandle OPTIONAL,
    OUT     PRTM_NEXTHOP_CHANGE_FLAGS       ChangeFlags
    )

/*++

    Adds or Updates a next hop entry to the entity's next-hop table.

    If the 'nexthop handle' argument is present, then this next-hop
    is updated. Otherwise a search is made for the address in the
    input 'nexthop info', and if a next-hop is found, it is updated.
    If no matching next-hop is found, the a new next-hop is added.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    NextHopInfo       - Info that corresponds to this next-hop,

    NextHopHandle     - Handle to the next-hop to update is passed 
                        in (or NULL), and if a next-hop is created 
                        a handle to this new next-hop is returned.

    ChangeFlags       - Flags whether this was a add or an update.

Return Value:

    Status of the operation

--*/

{
    PRTM_NET_ADDRESS  NextHopAddress;
    PENTITY_INFO      Entity;
    PDEST_INFO        Dest;
    PNEXTHOP_LIST     NewHopList;
    PNEXTHOP_INFO     NewNextHop;
    PNEXTHOP_INFO     NextHop;
    LOOKUP_CONTEXT    Context;
    PLIST_ENTRY       p;
    DWORD             Status;

    //
    // Validate incoming information before attempting an add
    //

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    if (NextHopInfo->RemoteNextHop)
    {
        VALIDATE_DEST_HANDLE(NextHopInfo->RemoteNextHop, &Dest);
    }

    //
    // If there is a next hop handle, we can avoid a search
    //

    NextHop = NULL;

    if (ARGUMENT_PRESENT(NextHopHandle) && (*NextHopHandle))
    {
        VALIDATE_NEXTHOP_HANDLE(*NextHopHandle, &NextHop);

        // Make sure that the caller owns this nexthop
        if (NextHop->NextHopInfo.NextHopOwner != RtmRegHandle)
        {
            return ERROR_ACCESS_DENIED;
        }
    }

#if WRN
    NewNextHop = NULL;
    NewHopList = NULL;
#endif

    *ChangeFlags = 0;

    ACQUIRE_NHOP_TABLE_WRITE_LOCK(Entity);

    do
    {
        //
        // Search for the next hop if we don't already have one
        //

        if (NextHop == NULL)
        {
            Status = FindNextHop(Entity, NextHopInfo, &Context, &p);

            if (SUCCESS(Status))
            {
                // The next hop already exists in the tree

                NextHop = CONTAINING_RECORD(p, NEXTHOP_INFO, NextHopsLE);
            }
            else
            {
                // Init new allocations in case we fail in between

                NewNextHop = NULL;
                NewHopList = NULL;

                //
                // Create a new next hop with the input information
                //

                Status = CreateNextHop(Entity, NextHopInfo, &NewNextHop);

                if (!SUCCESS(Status))
                {
                    break;
                }

                //
                // Do we need to create a new list of next hops too ?
                //

                if (p == NULL)
                {
                    NewHopList = AllocNZeroMemory(sizeof(NEXTHOP_LIST));

                    if (NewHopList == NULL)
                    {
                        break;
                    }

                    InitializeListHead(&NewHopList->NextHopsList);

                    // Insert the next-hop-list into the tree

                    NextHopAddress = &NextHopInfo->NextHopAddress;

                    Status = InsertIntoTable(Entity->NextHopTable,
                                             NextHopAddress->NumBits,
                                             NextHopAddress->AddrBits,
                                             &Context,
                                             &NewHopList->LookupLinkage);
                    if (!SUCCESS(Status))
                    {
                        break;
                    }

                    p = &NewHopList->NextHopsList;
                }

                // Insert the next hop in the list and ref it
                InsertTailList(p, &NewNextHop->NextHopsLE);

                Entity->NumNextHops++;

                NextHop = NewNextHop;

                *ChangeFlags = RTM_NEXTHOP_CHANGE_NEW;
            }
        }

        //
        // If this is an update, copy necessary information
        //

        if (*ChangeFlags != RTM_NEXTHOP_CHANGE_NEW)
        {
            CopyToNextHop(Entity, NextHopInfo, NextHop);
        }

        //
        // Return the next hop handle if not passed in
        //

        if (ARGUMENT_PRESENT(NextHopHandle))
        {
            if (*NextHopHandle == NULL)
            {
                *NextHopHandle = MAKE_HANDLE_FROM_POINTER(NextHop);

                REFERENCE_NEXTHOP(NextHop, HANDLE_REF);
            }
        }

        Status = NO_ERROR;
    }
    while(FALSE);

    RELEASE_NHOP_TABLE_WRITE_LOCK(Entity);

    if (!SUCCESS(Status))
    {
        // Some error occured - clean up

        if (NewHopList)
        {
            FreeMemory(NewHopList);
        }

        if (NewNextHop)
        {
            DEREFERENCE_NEXTHOP(NewNextHop, CREATION_REF);
        }
    }

    return Status;
}


DWORD
WINAPI
RtmDeleteNextHop (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NEXTHOP_HANDLE              NextHopHandle OPTIONAL,
    IN      PRTM_NEXTHOP_INFO               NextHopInfo
    )

/*++

Routine Description:

    Deletes a next hop from the next-hop table. The next-hop
    memory remains in use until all reference counts go to 0.
    
Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    NextHopHandle     - Handle to the next-hop we want to delete,

    NextHopInfo       - If no NextHopHandle is passed in, this is
                        used to match the next-hop to be deleted.

Return Value:

    Status of the operation

--*/

{
    PRTM_NET_ADDRESS  NextHopAddress;
    PLOOKUP_LINKAGE   Linkage;
    PENTITY_INFO      Entity;
    PNEXTHOP_LIST     HopList;
    PNEXTHOP_INFO     NextHop;
    PLOOKUP_CONTEXT   PContext;
    LOOKUP_CONTEXT    Context;
    PLIST_ENTRY       p;
    DWORD             Status;

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    //
    // If there is a next hop handle, we can avoid a search
    //

    NextHop = NULL;

    if (ARGUMENT_PRESENT(NextHopHandle))
    {
        VALIDATE_NEXTHOP_HANDLE(NextHopHandle, &NextHop);

        // Make sure that the caller owns this nexthop
        if (NextHop->NextHopInfo.NextHopOwner != RtmRegHandle)
        {
            return ERROR_ACCESS_DENIED;
        }
    }

#if WRN
    Status = ERROR_GEN_FAILURE;
#endif

    ACQUIRE_NHOP_TABLE_WRITE_LOCK(Entity);

    do
    {
        //
        // Search for the next hop if we don't already have one
        //

        if (NextHop == NULL)
        {
            Status = FindNextHop(Entity, 
                                 NextHopInfo, 
                                 &Context, 
                                 &p);

            if (!SUCCESS(Status))
            {
                break;
            }

            PContext = &Context;

            NextHop = CONTAINING_RECORD(p, NEXTHOP_INFO, NextHopsLE);
        }
        else
        {
            // Make sure that it has not already been deleted

            if (NextHop->NextHopInfo.State == RTM_NEXTHOP_STATE_DELETED)
            {
                break;
            }

            PContext = NULL;
        }
         
        // Get a 'possible' list entry that starts the hop list

        HopList = CONTAINING_RECORD(NextHop->NextHopsLE.Blink,
                                    NEXTHOP_LIST,
                                    NextHopsList);

        // Delete this next-hop from the nexthops list

        NextHop->NextHopInfo.State = RTM_NEXTHOP_STATE_DELETED;

        RemoveEntryList(&NextHop->NextHopsLE);
        

        // Do we have any more next hops on this list

        if (IsListEmpty(&HopList->NextHopsList))
        {
            // Remove the hop-list from the next hop table

            NextHopAddress = &NextHop->NextHopInfo.NextHopAddress;

            Status = DeleteFromTable(Entity->NextHopTable,
                                     NextHopAddress->NumBits,
                                     NextHopAddress->AddrBits,
                                     PContext,
                                     &Linkage);

            ASSERT(SUCCESS(Status) && (&HopList->LookupLinkage == Linkage));

            FreeMemory(HopList);
        }

        // Dereference the next-hop that was deleted

        Entity->NumNextHops--;

        DEREFERENCE_NEXTHOP(NextHop, CREATION_REF);

        if (ARGUMENT_PRESENT(NextHopHandle))
        {            
            DEREFERENCE_NEXTHOP(NextHop, HANDLE_REF);
        }

        Status = NO_ERROR;
    }
    while (FALSE);

    RELEASE_NHOP_TABLE_WRITE_LOCK(Entity);

    return Status;
}


DWORD
WINAPI
RtmFindNextHop (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      PRTM_NEXTHOP_INFO               NextHopInfo,
    OUT     PRTM_NEXTHOP_HANDLE             NextHopHandle,
    OUT     PRTM_NEXTHOP_INFO              *NextHopPointer OPTIONAL
    )

/*++

Routine Description:

    Finds a next hop, given its info, in entity's next-hop table.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    NextHopInfo       - Info for the next-hop we are searching for
                        ( NextHopOwner, NextHopAddress, IfIndex ),

    NextHopHandle     - Handle to next-hop is returned (if found),

    NextHopPointer    - A pointer to the next-hop is returned for
                        fast direct access by the next-hop's owner.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO      Entity;
    PNEXTHOP_INFO     NextHop;
    PLIST_ENTRY       p;
    DWORD             Status;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_ENTITY_HANDLE(NextHopInfo->NextHopOwner, &Entity);
    
    if (ARGUMENT_PRESENT(NextHopPointer))
    {
        // Only the nexthop owner gets a direct ptr
        if (RtmRegHandle != NextHopInfo->NextHopOwner)
        {
            return ERROR_ACCESS_DENIED;
        }
    }

    //
    // Search for the next hop in the next hop table
    //

    ACQUIRE_NHOP_TABLE_READ_LOCK(Entity);

    Status = FindNextHop(Entity, NextHopInfo, NULL, &p);

    if (SUCCESS(Status))
    {
        NextHop = CONTAINING_RECORD(p, NEXTHOP_INFO, NextHopsLE);

        *NextHopHandle = MAKE_HANDLE_FROM_POINTER(NextHop);

        REFERENCE_NEXTHOP(NextHop, HANDLE_REF);

        if (ARGUMENT_PRESENT(NextHopPointer))
        {
            *NextHopPointer = &NextHop->NextHopInfo;
        }
    }

    RELEASE_NHOP_TABLE_READ_LOCK(Entity);

    return Status;
}


DWORD
FindNextHop (
    IN      PENTITY_INFO                    Entity,
    IN      PRTM_NEXTHOP_INFO               NextHopInfo,
    OUT     PLOOKUP_CONTEXT                 Context OPTIONAL,
    OUT     PLIST_ENTRY                    *NextHopLE
    )

/*++

Routine Description:

    Finds a next hop, given its info, in entity's next-hop table.

    This is a helper function that is called by public functions 
    that add, delete or find a next hop in the next hop table.

Arguments:

    Entity            - Entity whose nexthop table we are searching,

    NextHopInfo       - Info for the next-hop we are searching for
                        ( NextHopOwner, NextHopAddress, IfIndex ),

    Context           - Search context for holding list of nexthops,

    NextHopLE         - List entry for the matching nexthop (if found)
                        (or) list entry before which it'll be inserted.

Return Value:

    Status of the operation

--*/

{
    PRTM_NET_ADDRESS  NextHopAddress;
    PNEXTHOP_LIST     NextHopsList;
    PNEXTHOP_INFO     NextHop;
    ULONG             IfIndex;
    PLOOKUP_LINKAGE   Linkage;
    PLIST_ENTRY       NextHops, p;
    DWORD             Status;

    *NextHopLE = NULL;

    //
    // Search for list of next hops, given the address
    //

    NextHopAddress = &NextHopInfo->NextHopAddress;

    Status = SearchInTable(Entity->NextHopTable,
                           NextHopAddress->NumBits,
                           NextHopAddress->AddrBits,
                           Context,
                           &Linkage);

    if (!SUCCESS(Status))
    {
        return Status;
    }

    NextHopsList = CONTAINING_RECORD(Linkage, NEXTHOP_LIST, LookupLinkage);

    //
    // Search for the nexthop with the interface idx
    //

    IfIndex = NextHopInfo->InterfaceIndex;

    NextHops = &NextHopsList->NextHopsList;

#if WRN
    NextHop = NULL;
#endif

    for (p = NextHops->Flink; p != NextHops; p = p->Flink)
    {
        NextHop = CONTAINING_RECORD(p, NEXTHOP_INFO, NextHopsLE);

        if (NextHop->NextHopInfo.InterfaceIndex <= IfIndex)
        {
            break;
        }
    }

    *NextHopLE = p;

    if ((p == NextHops) || (NextHop->NextHopInfo.InterfaceIndex != IfIndex))
    {
        return ERROR_NOT_FOUND;
    }

    return NO_ERROR;
}


DWORD
WINAPI
RtmGetNextHopPointer (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NEXTHOP_HANDLE              NextHopHandle,
    OUT     PRTM_NEXTHOP_INFO              *NextHopPointer
    )

/*++

Routine Description:

    Gets a direct pointer to the next-hop for read/write by its owner.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    NextHopHandle     - Handle to the next-hop whose pointer we want,

    NextHopPointer    - A pointer to the next-hop is returned for
                        fast direct access by the caller, only if
                        the caller is the owner of this next-hop.
                       
Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO      Entity;
    PNEXTHOP_INFO     NextHop;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_NEXTHOP_HANDLE(NextHopHandle, &NextHop);

    //
    // Return a pointer only if caller owns next-hop
    //

    if (NextHop->NextHopInfo.NextHopOwner != RtmRegHandle)
    {
        return ERROR_ACCESS_DENIED;
    }

    *NextHopPointer = &NextHop->NextHopInfo;

    return NO_ERROR;
}


DWORD
WINAPI
RtmLockNextHop(
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_NEXTHOP_HANDLE              NextHopHandle,
    IN      BOOL                            Exclusive,
    IN      BOOL                            LockNextHop,
    OUT     PRTM_NEXTHOP_INFO              *NextHopPointer OPTIONAL
    )

/*++

Routine Description:

    Locks or Unlocks a next hop. This function is called by the
    next-hop's owner to lock the next-hop before making changes
    directly to the next-hop using a pointer to this next-hop.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    NextHopHandle     - Handle to the next-hop that we want to lock,

    Exclusive         - TRUE to lock in write mode, else read mode,

    LockNextHop       - Lock nexthop if TRUE, Unlock it if FALSE,

    NextHopPointer    - A pointer to the next-hop is returned for
                        fast direct access by the next hop's owner.
                       
Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO      Entity;
    PNEXTHOP_INFO     NextHop;

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_NEXTHOP_HANDLE(NextHopHandle, &NextHop);

    //
    // Lock or unlock only if caller owns next-hop
    //

    if (NextHop->NextHopInfo.NextHopOwner != RtmRegHandle)
    {
        return ERROR_ACCESS_DENIED;
    }

    // Return a direct pointer for use in update

    if (ARGUMENT_PRESENT(NextHopPointer))
    {
        *NextHopPointer = &NextHop->NextHopInfo;
    }

    // Lock or unlock the nexthop as the case may be

    if (LockNextHop)
    {
        if (Exclusive)
        {
            ACQUIRE_NHOP_TABLE_WRITE_LOCK(Entity);
        }
        else
        {
            ACQUIRE_NHOP_TABLE_READ_LOCK(Entity);
        }
    }
    else
    {
        if (Exclusive)
        {
            RELEASE_NHOP_TABLE_WRITE_LOCK(Entity);
        }
        else
        {
            RELEASE_NHOP_TABLE_READ_LOCK(Entity);
        }
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\rtmobj1.c ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmobj1.c

Abstract:

    Contains routines for managing RTM objects
    like Instances, AddrFamilies and Entities.

Author:

    Chaitanya Kodeboyina (chaitk)   21-Aug-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop


DWORD
GetInstance (
    IN      USHORT                          RtmInstanceId,
    IN      BOOL                            ImplicitCreate,
    OUT     PINSTANCE_INFO                 *RtmInstance
    )

/*++

Routine Description:

    Searches for an RTM instance with the input instance
    id. If an instance is not found and ImplicitCreate
    is TRUE, then a new instance is created and added to
    the table of instances.

Arguments:

    RtmInstanceId     - Id for RTM Instance being searched for,

    ImplicitCreate    - Create a new instance if not found or not,

    RtmInstance       - Pointer to the Instance Info Structure
                        will be returned through this parameter.

Return Value:

    Status of the operation

Locks:

    The InstancesLock in RtmGlobals should be held while calling
    this function. If ImplicitCreate is FALSE, a read lock would
    do, but if it is TRUE then a write lock should be held as we
    would need to insert a new instance into the instances list.

--*/

{
    PLIST_ENTRY    Instances;
    PINSTANCE_INFO Instance;
    PLIST_ENTRY    p;
    DWORD          Status;

    Instances = &RtmGlobals.InstanceTable[RtmInstanceId % INSTANCE_TABLE_SIZE];

#if WRN
    Instance = NULL;
#endif

    do
    {
        // Search the global list for a matching instance
        for (p = Instances->Flink; p != Instances; p = p->Flink)
        {
            Instance = CONTAINING_RECORD(p, INSTANCE_INFO, InstTableLE);
            
            if (Instance->RtmInstanceId >= RtmInstanceId)
            {
                break;
            }
        }

        if ((p == Instances) || (Instance->RtmInstanceId != RtmInstanceId))
        {
            // We did not find an instance - create new one ?
            if (!ImplicitCreate)
            {
                Status = ERROR_NOT_FOUND;
                break;
            }

            // Create a new instance with input Instance id
            Status = CreateInstance(RtmInstanceId, &Instance);
            if (Status != NO_ERROR)
            {
                break;
            }

            // Insert into list in sorted Instance Id order
            InsertTailList(p, &Instance->InstTableLE);
        }

        Status = NO_ERROR;

        *RtmInstance = Instance;
    }
    while (FALSE);

    return Status;
}


DWORD
CreateInstance (
    IN      USHORT                          RtmInstanceId,
    OUT     PINSTANCE_INFO                 *NewInstance
    )

/*++

Routine Description:

    Creates a new instance info structure and initializes it.

Arguments:

    RtmInstanceId     - RTM Instance Id for the new RTM instance,

    InstConfig        - Configuration Info for the new instance,

    NewInstance       - Pointer to the Instance Info Structure
                        will be returned through this parameter.

Return Value:

    Status of the operation

Locks:

    Need to be called with the instances WRITE lock as we are
    incrementing the number of instances here.

--*/

{
    RTM_INSTANCE_CONFIG InstConfig;
    PINSTANCE_INFO      Instance;
    DWORD               Status;

    *NewInstance = NULL;

    //
    // Read Instance Configuration from the registry
    //
    
    Status = RtmReadInstanceConfig(RtmInstanceId, &InstConfig);

    if (Status != NO_ERROR)
    {
        return Status;
    }

    //
    // Allocate and initialize a new instance info
    //

    Instance = (PINSTANCE_INFO) AllocNZeroObject(sizeof(INSTANCE_INFO));

    if (Instance == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

#if DBG_HDL
    Instance->ObjectHeader.TypeSign = INSTANCE_ALLOC;
#endif

    // Will be removed when last addr family goes
    INITIALIZE_INSTANCE_REFERENCE(Instance, CREATION_REF);

    Instance->RtmInstanceId = RtmInstanceId;

    //
    // Linking instance to global list of instances is
    // done by caller, but pretend it is already done
    //

    RtmGlobals.NumInstances++;

    InitializeListHead(&Instance->InstTableLE);

    //
    // Initialize the table of address families
    //

    Instance->NumAddrFamilies = 0;

    InitializeListHead(&Instance->AddrFamilyTable);

    *NewInstance = Instance;
      
    return NO_ERROR;
}


DWORD
DestroyInstance (
    IN      PINSTANCE_INFO                  Instance
    )

/*++

Routine Description:

    Destroys an existing instance info structure. Assumes that
    no registered entities exist on this instance when called.

Arguments:

    Instance       - Pointer to the Instance Info Structure.

Return Value:

    Status of the operation

Locks:

    The InstancesLock in RtmGlobals should be held while calling
    this function as it removes an instance from that list. This
    is typically taken in DestroyEntity, but it can also happen
    that the lock is acquired in RtmRegisterEntity and an error
    occured.

--*/

{
    ASSERT(Instance->ObjectHeader.RefCount == 0);

    ASSERT(Instance->NumAddrFamilies == 0);

    //
    // Remove this instance from list of instances
    //

    RemoveEntryList(&Instance->InstTableLE);

    RtmGlobals.NumInstances--;

    //
    // Free resources allocated for this instance
    //

#if DBG_HDL
    Instance->ObjectHeader.TypeSign = INSTANCE_FREED;
#endif

    FreeObject(Instance);

    return NO_ERROR;
}


DWORD
GetAddressFamily (
    IN      PINSTANCE_INFO                  Instance,
    IN      USHORT                          AddressFamily,
    IN      BOOL                            ImplicitCreate,
    OUT     PADDRFAM_INFO                  *AddrFamilyInfo
    )

/*++

Routine Description:

    Searches for an address family in an RTM instance.
    If it is not found and ImplicitCreate is TRUE, then
    a new address family info is created and added to
    the list of address families.

Arguments:

    Instance          - RTM Instance that holds the address family,

    AddressFamily     - Address family for info being searched for,

    ImplicitCreate    - Create an addr family info if not found or not,

    AddrFamilyInfo    - Pointer to the new Address Family Info
                        will be returned through this parameter.

Return Value:

    Status of the operation

Locks:

    The InstancesLock in RtmGlobals should be held while calling
    this function. If ImplicitCreate is FALSE, a read lock would
    do, but if it is TRUE then a write lock should be held as we
    will need it to insert a new address family info into a list.

--*/

{
    PLIST_ENTRY    AddrFams;
    PADDRFAM_INFO  AddrFamInfo;
    PLIST_ENTRY    q;
    DWORD          Status;

    AddrFams = &Instance->AddrFamilyTable;

#if WRN
    AddrFamInfo = NULL;
#endif

    do
    {
        // Search the list of addr families on instance
        for (q = AddrFams->Flink; q != AddrFams; q = q->Flink)
        {
            AddrFamInfo = CONTAINING_RECORD(q, ADDRFAM_INFO, AFTableLE);
        
            if (AddrFamInfo->AddressFamily >= AddressFamily)
            {
                break;
            }      
        }

        if ((q == AddrFams) || (AddrFamInfo->AddressFamily != AddressFamily))
        {
            // We did not find an instance - create new one ?
            if (!ImplicitCreate)
            {
                Status = ERROR_NOT_FOUND;
                break;
            }

            // Create a new addr family info with input family
            Status = CreateAddressFamily(Instance,AddressFamily, &AddrFamInfo);
            if (Status != NO_ERROR)
            {
                break;
            }

            // Insert into list sorted in Address Family order
            InsertTailList(q, &AddrFamInfo->AFTableLE);
        }

        Status = NO_ERROR;

        *AddrFamilyInfo = AddrFamInfo;
    }
    while (FALSE);

    return Status;
}


DWORD
CreateAddressFamily (
    IN      PINSTANCE_INFO                  Instance,
    IN      USHORT                          AddressFamily,
    OUT     PADDRFAM_INFO                  *NewAddrFamilyInfo
    )

/*++

Routine Description:

    Creates a new address family info and initializes it

Arguments:

    Instance          - RTM Instance that owns addr family info,

    AddressFamily     - Address family  for the new info block,

    AddrFamilyInfo    - Pointer to the new Address Family Info
                        will be returned through this parameter.

Return Value:

    Status of the operation

Locks:

    Need to be called with the instances WRITE lock as we are
    are incrementing number of address families on instance.

--*/

{
    RTM_ADDRESS_FAMILY_CONFIG  AddrFamConfig;
    PADDRFAM_INFO              AddrFamilyInfo;
    RTM_VIEW_SET               ViewsSupported;
    PSINGLE_LIST_ENTRY         ListPtr;
    UINT                       i;
    DWORD                      Status;

    *NewAddrFamilyInfo = NULL;

    //
    // Read AddressFamily Configuration from the registry
    //
    
    Status = RtmReadAddressFamilyConfig(Instance->RtmInstanceId,
                                        AddressFamily,
                                        &AddrFamConfig);
    if (Status != NO_ERROR)
    {
        if (Instance->NumAddrFamilies == 0)
        {
            DEREFERENCE_INSTANCE(Instance, CREATION_REF);
        }

        return Status;
    }


    //
    // Allocate and initialize a new address family info
    //

    AddrFamilyInfo = (PADDRFAM_INFO) AllocNZeroObject(sizeof(ADDRFAM_INFO));

    if (AddrFamilyInfo == NULL)
    {
        if (Instance->NumAddrFamilies == 0)
        {
            DEREFERENCE_INSTANCE(Instance, CREATION_REF);
        }
        
        return ERROR_NOT_ENOUGH_MEMORY;
    }


    do
    {
#if DBG_HDL
        AddrFamilyInfo->ObjectHeader.TypeSign = ADDRESS_FAMILY_ALLOC;
#endif

        // Will be removed when last entity deregisters
        INITIALIZE_ADDR_FAMILY_REFERENCE(AddrFamilyInfo, CREATION_REF);

        AddrFamilyInfo->AddressFamily = AddressFamily;

        AddrFamilyInfo->AddressSize = AddrFamConfig.AddressSize;

        AddrFamilyInfo->Instance = Instance;

        REFERENCE_INSTANCE(Instance, ADDR_FAMILY_REF);

        //
        // Linking the address family to its owning instance
        // is done by caller, but pretend it is already done
        //

        Instance->NumAddrFamilies++;

        InitializeListHead(&AddrFamilyInfo->AFTableLE);

        //
        // Count number of views supported by this addr family
        // & setup the view id <-> view index in dest mappings
        //

        AddrFamilyInfo->ViewsSupported = AddrFamConfig.ViewsSupported;

        ViewsSupported = AddrFamConfig.ViewsSupported;
        AddrFamilyInfo->NumberOfViews  = 0;

        for (i = 0; i < RTM_MAX_VIEWS; i++)
        {
            AddrFamilyInfo->ViewIdFromIndex[i] = -1;
            AddrFamilyInfo->ViewIndexFromId[i] = -1;
        }

        for (i = 0; (i < RTM_MAX_VIEWS) && ViewsSupported; i++)
        {
           if (ViewsSupported & 0x01)
            {
                AddrFamilyInfo->ViewIdFromIndex[AddrFamilyInfo->NumberOfViews]
                                                   = i;

                AddrFamilyInfo->ViewIndexFromId[i] = 
                                                AddrFamilyInfo->NumberOfViews;

                AddrFamilyInfo->NumberOfViews++;
            }

            ViewsSupported >>= 1;
        }

        AddrFamilyInfo->MaxHandlesInEnum = AddrFamConfig.MaxHandlesInEnum;

        AddrFamilyInfo->MaxNextHopsInRoute = AddrFamConfig.MaxNextHopsInRoute;

        //
        // Initialize the opaque pointer's directory
        //

        AddrFamilyInfo->MaxOpaquePtrs = AddrFamConfig.MaxOpaqueInfoPtrs;
        AddrFamilyInfo->NumOpaquePtrs = 0;

        AddrFamilyInfo->OpaquePtrsDir = 
            AllocNZeroMemory(AddrFamilyInfo->MaxOpaquePtrs * sizeof(PVOID));

        if (AddrFamilyInfo->OpaquePtrsDir == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        // Initialize the list of entities on this address family
        //

        AddrFamilyInfo->NumEntities = 0;
        for (i = 0; i < ENTITY_TABLE_SIZE; i++)
        {
            InitializeListHead(&AddrFamilyInfo->EntityTable[i]);
        }

        //
        // Init list of entities de-registered but not destroyed
        //

        InitializeListHead(&AddrFamilyInfo->DeregdEntities);

        //
        // Initialize the route table and route table lock
        //

        try
        {
            CREATE_READ_WRITE_LOCK(&AddrFamilyInfo->RouteTableLock);

            AddrFamilyInfo->RoutesLockInited = TRUE;
        }
        except(EXCEPTION_EXECUTE_HANDLER)
            {
                Status = GetLastError();
                break;
            }

        Status = CreateTable(AddrFamilyInfo->AddressSize,
                             &AddrFamilyInfo->RouteTable);

        if (Status != NO_ERROR)
        {
            break;
        }

        //
        // Initialize queue to hold notification timers
        //

        AddrFamilyInfo->NotifTimerQueue = CreateTimerQueue();

        if (AddrFamilyInfo->NotifTimerQueue == NULL)
        {
            Status = GetLastError();
            break;
        }

        //
        // Initialize queue to hold route timers on AF
        //

        AddrFamilyInfo->RouteTimerQueue = CreateTimerQueue();

        if (AddrFamilyInfo->RouteTimerQueue == NULL)
        {
            Status = GetLastError();
            break;
        }

        //
        // Initialize the change notification info and lock
        //

        try
        {
            CREATE_READ_WRITE_LOCK(&AddrFamilyInfo->ChangeNotifsLock);

            AddrFamilyInfo->NotifsLockInited = TRUE;
        }
        except(EXCEPTION_EXECUTE_HANDLER)
            {
                Status = GetLastError();
                break;
            }

        AddrFamilyInfo->MaxChangeNotifs = AddrFamConfig.MaxChangeNotifyRegns;
        AddrFamilyInfo->NumChangeNotifs = 0;

        //
        // Allocate memory for the max number of notifications
        //

        AddrFamilyInfo->ChangeNotifsDir = 
            AllocNZeroMemory(AddrFamilyInfo->MaxChangeNotifs * 
                             sizeof(PVOID));

        if (AddrFamilyInfo->ChangeNotifsDir == NULL)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        // Initialize lock protecting the notification timer
        //

        try
        {
            InitializeCriticalSection(&AddrFamilyInfo->NotifsTimerLock);

            AddrFamilyInfo->TimerLockInited = TRUE;
        }
        except(EXCEPTION_EXECUTE_HANDLER)
            {
                Status = GetLastError();
                break;
            }

        //
        // Initialize each change list in the change list table
        //

        for (i = 0; i < NUM_CHANGED_DEST_LISTS; i++)
        {
            //
            // Initialize the list of changed dests and lock
            //

            // Init the change list to an empty circular list

            ListPtr = &AddrFamilyInfo->ChangeLists[i].ChangedDestsHead;

            ListPtr->Next = ListPtr;
                       
            AddrFamilyInfo->ChangeLists[i].ChangedDestsTail = ListPtr;

            try
            {
                InitializeCriticalSection
                      (&AddrFamilyInfo->ChangeLists[i].ChangesListLock);

                AddrFamilyInfo->ChangeLists[i].ChangesLockInited = TRUE;

                continue;
            }
            except(EXCEPTION_EXECUTE_HANDLER)
                {
                    Status = GetLastError();
                }

            break;
        }

        if (Status != NO_ERROR)
        {
            break;
        }

        *NewAddrFamilyInfo = AddrFamilyInfo;

        return NO_ERROR;
    }
    while (FALSE);

    //
    // Something failed - undo work done and return status
    //

    DEREFERENCE_ADDR_FAMILY(AddrFamilyInfo, CREATION_REF);

    return Status;
}


DWORD
DestroyAddressFamily (
    IN      PADDRFAM_INFO                   AddrFamilyInfo
    )

/*++

Routine Description:

    Destroys an address family info in an RTM instance.
    Assumes that no registered entities exist with this 
    address family in this RTM instance when invoked.

    This function has been written such that it can be 
    called when an error occurs in CreateAddressFamily.

Arguments:

    AddrFamilyInfo  - Pointer to the Rib Info Structure.

Return Value:

    Status of the operation

Locks:

    The InstancesLock in RtmGlobals should be held while calling
    this function as it removes an address family from the list
    of address families on the instance. This lock is typically
    taken in DestroyEntity, but it can also happen that the lock
    is acquired in RtmRegisterEntity and an error occured in the
    CreateAddressFamily function.

--*/

{
    PINSTANCE_INFO       Instance;
    PSINGLE_LIST_ENTRY   ListPtr;
    UINT                 i;

    ASSERT(AddrFamilyInfo->ObjectHeader.RefCount == 0);

    ASSERT(AddrFamilyInfo->NumEntities == 0);

    ASSERT(IsListEmpty(&AddrFamilyInfo->DeregdEntities));

    //
    // Block until timers on address family are cleaned up
    //

    if (AddrFamilyInfo->RouteTimerQueue)
    {
        DeleteTimerQueueEx(AddrFamilyInfo->RouteTimerQueue, (HANDLE) -1);
    }

    if (AddrFamilyInfo->NotifTimerQueue)
    {
        DeleteTimerQueueEx(AddrFamilyInfo->NotifTimerQueue, (HANDLE) -1);
    }

    //
    // Free resources allocated to the change lists (locks ..)
    //

    // No more dests in change list as all entities are gone

    ASSERT(AddrFamilyInfo->NumChangedDests == 0);

    for (i = 0; i < NUM_CHANGED_DEST_LISTS; i++)
    {
        ListPtr = &AddrFamilyInfo->ChangeLists[i].ChangedDestsHead;

        ASSERT(ListPtr->Next == ListPtr);

        ASSERT(AddrFamilyInfo->ChangeLists[i].ChangedDestsTail == ListPtr);

        if (AddrFamilyInfo->ChangeLists[i].ChangesLockInited)
        {
            DeleteCriticalSection
                (&AddrFamilyInfo->ChangeLists[i].ChangesListLock);
        }
    }

    //
    // Free the change notification info and the guarding lock
    //

    ASSERT(AddrFamilyInfo->NumChangeNotifs == 0);

    if (AddrFamilyInfo->ChangeNotifsDir)
    {
        FreeMemory(AddrFamilyInfo->ChangeNotifsDir);
    }

    if (AddrFamilyInfo->NotifsLockInited)
    {
        DELETE_READ_WRITE_LOCK(&AddrFamilyInfo->ChangeNotifsLock);
    }

    //
    // Free the lock guarding the notification timer
    //

    if (AddrFamilyInfo->TimerLockInited)
    {
        DeleteCriticalSection(&AddrFamilyInfo->NotifsTimerLock);
    }

    //
    // Free the route table and the route table lock
    //

    ASSERT(AddrFamilyInfo->NumRoutes == 0);

    //
    // Because some hold's are left out - this count
    // might not be equal to zero. Need to fix this
    // memory leak by cleaning up before this point
    //
    // ASSERT(AddrFamilyInfo->NumDests == 0);

    if (AddrFamilyInfo->RouteTable)
    {
        DestroyTable(AddrFamilyInfo->RouteTable);
    }

    if (AddrFamilyInfo->RoutesLockInited)
    {
        DELETE_READ_WRITE_LOCK(&AddrFamilyInfo->RouteTableLock);
    }

    //
    // Free Opaque Ptrs directory (if it is allocated)
    //

    if (AddrFamilyInfo->OpaquePtrsDir)
    {
        FreeMemory(AddrFamilyInfo->OpaquePtrsDir);
    }

    //
    // Remove the address family from owning instance
    //

    Instance = AddrFamilyInfo->Instance;

    RemoveEntryList(&AddrFamilyInfo->AFTableLE);
    Instance->NumAddrFamilies--;
    DEREFERENCE_INSTANCE(Instance, ADDR_FAMILY_REF);

    // Reclaim the instance if it has no addr familes

    if (Instance->NumAddrFamilies == 0)
    {
        DEREFERENCE_INSTANCE(Instance, CREATION_REF);
    }

#if DBG_HDL
    AddrFamilyInfo->ObjectHeader.TypeSign = ADDRESS_FAMILY_FREED;
#endif

    FreeObject(AddrFamilyInfo);

    return NO_ERROR;
}


DWORD
GetEntity (
    IN      PADDRFAM_INFO                   AddrFamilyInfo,
    IN      ULONGLONG                       EntityId,
    IN      BOOL                            ImplicitCreate,
    IN      PRTM_ENTITY_INFO                RtmEntityInfo    OPTIONAL,
    IN      BOOL                            ReserveOpaquePtr OPTIONAL,
    IN      PRTM_ENTITY_EXPORT_METHODS      ExportMethods    OPTIONAL,
    IN      RTM_EVENT_CALLBACK              EventCallback    OPTIONAL,
    OUT     PENTITY_INFO                   *EntityInfo
    )

/*++

Routine Description:

    Searches for an entity with a certain protocol id and
    protocol instance. If it is not found and ImplicitCreate
    is TRUE, then a new entity is created and added to the
    table of entities on address family.

Arguments:

    AddrFamilyInfo    - Address family block that we are seaching,

    EntityId          - Entity protocol id and protocol instance,

    ImplicitCreate    - Create a new entity if not found or not,

    For all others    - See corresponding parametes in CreateEntity

    EntityInfo        - The entity info is returned in this param.

Return Value:

    Status of the operation

Locks:

    The InstancesLock in RtmGlobals should be held while calling
    this function. If ImplicitCreate is FALSE, a read lock would
    do, but if it is TRUE then a write lock should be held as we
    would need it to insert a new entity into the entities list.

--*/

{
    PLIST_ENTRY    Entities;
    PENTITY_INFO   Entity;
    PLIST_ENTRY    r;
    DWORD          Status;

    Entities = &AddrFamilyInfo->EntityTable[EntityId % ENTITY_TABLE_SIZE];

#if WRN
    Entity = NULL;
#endif

    do
    {
        // Search for an entity with the input Entity Id
        for (r = Entities->Flink; r != Entities; r = r->Flink)
        {
            Entity = CONTAINING_RECORD(r, ENTITY_INFO, EntityTableLE);
            
            if (Entity->EntityId.EntityId >= EntityId)
            {
                break;
            }      
        }

        if ((r != Entities) && (Entity->EntityId.EntityId == EntityId))
        {
            Status = ERROR_ALREADY_EXISTS;
            break;
        }

        // We did not find an entity - create a new one ?
        if (!ImplicitCreate)
        {
            Status = ERROR_NOT_FOUND;
            break;
        }

        // Create a new entity with all the input RTM parameters

        Status = CreateEntity(AddrFamilyInfo,
                              RtmEntityInfo,
                              ReserveOpaquePtr,
                              ExportMethods,
                              EventCallback,
                              &Entity);

        if (Status != NO_ERROR)
        {
            break;
        }

        //
        // Inform all existing entities of this new entity
        //

        InformEntitiesOfEvent(AddrFamilyInfo->EntityTable,
                              RTM_ENTITY_REGISTERED,
                              Entity);

        // Insert to keep the list sorted Entity Id Order
        InsertTailList(r, &Entity->EntityTableLE);

        *EntityInfo = Entity;
    }
    while (FALSE);

    return Status;
}


DWORD
CreateEntity (
    IN      PADDRFAM_INFO                   AddrFamilyInfo,
    IN      PRTM_ENTITY_INFO                EntityInfo,
    IN      BOOL                            ReserveOpaquePtr,
    IN      PRTM_ENTITY_EXPORT_METHODS      ExportMethods,
    IN      RTM_EVENT_CALLBACK              EventCallback,
    OUT     PENTITY_INFO                   *NewEntity
    )

/*++

Routine Description:

    Creates a new entity info structure and initializes it.

Arguments:

    AddrFamilyInfo    - Address Family the entity is registering with,

    EntityInfo        - Information for the entity being created,

    ReserveOpaquePtr  - Reserve a ptr in each destination or not,

    ExportMethods     - List of methods exported by this entity,

    EventCallback     - Callback invoked to inform of certain events
                        like entity registrations, de-registrations,

    NewEntity         - Pointer to the new Entity Info structure 
                        will be returned through this parameter.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO  Entity;
    UINT          NumMethods, i;
    DWORD         Status;

    *NewEntity = NULL;

    //
    // Allocate and initialize a new entity info structure
    //

    NumMethods = ExportMethods ? ExportMethods->NumMethods : 0;

    Entity = (PENTITY_INFO) AllocNZeroObject(
                                sizeof(ENTITY_INFO) +
                                (NumMethods ? (NumMethods - 1) : 0 ) *
                                sizeof(RTM_ENTITY_EXPORT_METHOD));

    if (Entity == NULL)
    {
        if (AddrFamilyInfo->NumEntities == 0)
        {
            DEREFERENCE_ADDR_FAMILY(AddrFamilyInfo, CREATION_REF);
        }

        return ERROR_NOT_ENOUGH_MEMORY; 
    }

    do
    {
#if DBG_HDL
        Entity->ObjectHeader.TypeSign = ENTITY_ALLOC;
#endif
        INITIALIZE_ENTITY_REFERENCE(Entity, CREATION_REF);

        Entity->EntityId = EntityInfo->EntityId;

        Entity->OwningAddrFamily = AddrFamilyInfo;
        REFERENCE_ADDR_FAMILY(AddrFamilyInfo, ENTITY_REF);

        //
        // Linking the entity to its owning address family is
        // done by caller,but pretend that it is already done
        //

        AddrFamilyInfo->NumEntities++;

        InitializeListHead(&Entity->EntityTableLE);

        //
        // Allocate an opaque pointer index if asked for
        //

        Entity->OpaquePtrOffset = -1;

        if (ReserveOpaquePtr)
        {
            if (AddrFamilyInfo->NumOpaquePtrs >= AddrFamilyInfo->MaxOpaquePtrs)
            {
                Status = ERROR_NO_SYSTEM_RESOURCES;
                break;
            }

            for (i = 0; i < AddrFamilyInfo->MaxOpaquePtrs; i++)
            {
                if (AddrFamilyInfo->OpaquePtrsDir[i] == NULL)
                {
                    break;
                }
            }

            AddrFamilyInfo->OpaquePtrsDir[i] = (PVOID) Entity;

            AddrFamilyInfo->NumOpaquePtrs++;

            Entity->OpaquePtrOffset = i;

            ASSERT(Entity->OpaquePtrOffset != -1);
        }

        //
        // Initialize lock guarding entity-specific route lists
        //

        try
        {
            CREATE_READ_WRITE_LOCK(&Entity->RouteListsLock);

            Entity->ListsLockInited = TRUE;
        }
        except(EXCEPTION_EXECUTE_HANDLER)
            {
                Status = GetLastError();
                break;
            }

        //
        // Initialize the list of open handles and corresponding lock
        //

        try
        {
            InitializeCriticalSection(&Entity->OpenHandlesLock);

            Entity->HandlesLockInited = TRUE;
        }
        except(EXCEPTION_EXECUTE_HANDLER)
            {
                Status = GetLastError();
                break;
            }

        InitializeListHead(&Entity->OpenHandles);

        //
        // Initialize the next hop table and the next hop table lock
        //

        try
        {
            CREATE_READ_WRITE_LOCK(&Entity->NextHopTableLock);

            Entity->NextHopsLockInited = TRUE;
        }
        except(EXCEPTION_EXECUTE_HANDLER)
            {
                Status = GetLastError();
                break;
            }

        Status = CreateTable(AddrFamilyInfo->AddressSize,
                             &Entity->NextHopTable);

        if (Status != NO_ERROR)
        {
            break;
        }

        Entity->NumNextHops = 0;

        //
        // Initialize entity methods and the entity methods lock
        //

        try
        {
            CREATE_READ_WRITE_LOCK(&Entity->EntityMethodsLock);

            Entity->MethodsLockInited = TRUE;
        }
        except(EXCEPTION_EXECUTE_HANDLER)
            {
                Status = GetLastError();
                break;
            }
        
        Entity->EventCallback = EventCallback;

        Entity->EntityMethods.NumMethods = NumMethods;

        if (ExportMethods)
        {
            CopyMemory(Entity->EntityMethods.Methods,
                       ExportMethods->Methods,
                       NumMethods * sizeof(RTM_ENTITY_EXPORT_METHOD));
        }

        *NewEntity = Entity;

        return NO_ERROR;
    }
    while(FALSE);

    //
    // Something failed - undo work done and return status
    //

    DEREFERENCE_ENTITY(Entity, CREATION_REF);

    return Status;
}


DWORD
DestroyEntity (
    IN      PENTITY_INFO                    Entity
    )

/*++

Routine Description:

    Destroys an existing entity info structure. Frees 
    all associated resources before de-allocation.

    This function has been written such that it can be
    called when an error occurs during CreateEntity.

Arguments:

    EntityInfo - Pointer to the Entity Info Structure.

Return Value:

    Status of the operation

--*/

{
    PADDRFAM_INFO   AddrFamilyInfo;

    ASSERT(Entity->ObjectHeader.RefCount == 0);

    //
    // Take globals registrations lock while cleaning up
    //

    ACQUIRE_INSTANCES_WRITE_LOCK();

    //
    // Free lock used to block exported entity methods
    //

    if (Entity->MethodsLockInited)
    {
        DELETE_READ_WRITE_LOCK(&Entity->EntityMethodsLock);
    }

    //
    // Free the next hop table and the lock guarding it
    //

    ASSERT(Entity->NumNextHops == 0);

    if (Entity->NextHopTable)
    {
        DestroyTable(Entity->NextHopTable);
    }

    if (Entity->NextHopsLockInited)
    {
        DELETE_READ_WRITE_LOCK(&Entity->NextHopTableLock);
    }

    if (Entity->HandlesLockInited)
    {
        // There should not be any handles opened by entity

        ASSERT(IsListEmpty(&Entity->OpenHandles));

        DeleteCriticalSection(&Entity->OpenHandlesLock);
    }

    //
    // Free lock used to perform route list operations
    //

    if (Entity->ListsLockInited)
    {
        DELETE_READ_WRITE_LOCK(&Entity->RouteListsLock);
    }

    //
    // Free the opaque ptr index in the address family
    //

    AddrFamilyInfo = Entity->OwningAddrFamily;

    if (Entity->OpaquePtrOffset != -1)
    {
        AddrFamilyInfo->OpaquePtrsDir[Entity->OpaquePtrOffset] = NULL;

        AddrFamilyInfo->NumOpaquePtrs--;
    }

#if DBG_REF

    //
    // Signal event on entity to unblock de-register
    // The evnt will be freed in RtmDeregisterEntity
    //

    if (Entity->BlockingEvent)
    {
        SetEvent(Entity->BlockingEvent);
    }

#endif
  
    //
    // Remove the entity from the owning address family
    //

    RemoveEntryList(&Entity->EntityTableLE);
    AddrFamilyInfo->NumEntities--;
    DEREFERENCE_ADDR_FAMILY(AddrFamilyInfo, ENTITY_REF);

    // Reclaim the addr family if it has no entities

    if (AddrFamilyInfo->NumEntities == 0)
    {
        DEREFERENCE_ADDR_FAMILY(AddrFamilyInfo, CREATION_REF);
    }

#if DBG_HDL
    Entity->ObjectHeader.TypeSign = ENTITY_FREED;
#endif

    FreeObject(Entity);

    RELEASE_INSTANCES_WRITE_LOCK();

    return NO_ERROR;
}


VOID
InformEntitiesOfEvent (
    IN      PLIST_ENTRY                     EntityTable,
    IN      RTM_EVENT_TYPE                  EventType,
    IN      PENTITY_INFO                    EntityThis
    )

/*++

Routine Description:

    Informs all entities in the entity table that a certain
    event has occured - like a new entity registered, or an
    existing entity de-registered.

Arguments:

    EntityTable - Pointer to the hash table of entities,

    EventType   - Type of the event being notified about,

    EntityThis  - Entity that caused the event to occur.

Return Value:

    None

Locks:

    The instances lock has to be held in either write or
    read mode as we are traversing the list of entities
    on the address family.

--*/

{
    RTM_ENTITY_HANDLE  EntityHandle;
    PADDRFAM_INFO      AddrFamInfo;
    RTM_ENTITY_INFO    EntityInfo;
    PENTITY_INFO       Entity;
    UINT               i;
    PLIST_ENTRY        Entities, q;

    //
    // Prepare arguments for the Event Callbacks in loop
    //

    AddrFamInfo = EntityThis->OwningAddrFamily;

    EntityInfo.RtmInstanceId = AddrFamInfo->Instance->RtmInstanceId;
    EntityInfo.AddressFamily = AddrFamInfo->AddressFamily;

    EntityInfo.EntityId = EntityThis->EntityId;

    EntityHandle = MAKE_HANDLE_FROM_POINTER(EntityThis);


    //
    // For each entity in table, call its event callback
    //

    for (i = 0; i < ENTITY_TABLE_SIZE; i++)
    {
        Entities = &EntityTable[i];
          
        for (q = Entities->Flink; q != Entities; q = q->Flink)
        {
            Entity = CONTAINING_RECORD(q, ENTITY_INFO, EntityTableLE);

            //
            // Inform the current entity of the event
            // if it has an event handler registered
            //

            if (Entity->EventCallback)
            {
                //
                // This callback should not call any of the registration
                // APIs as it might result in corrupting the entity list
                //
                
                Entity->EventCallback(MAKE_HANDLE_FROM_POINTER(Entity),
                                      EventType,
                                      EntityHandle,
                                      &EntityInfo);
            }
        }
    }
}


VOID
CleanupAfterDeregister (
    IN      PENTITY_INFO                    Entity
    )

/*++

Routine Description:

    Cleans up all enums, notifications and entity lists
    opened by an entity. Also deletes all nexthops and
    routes owned by this entity. Assumes that the entity
    is not making any other operations in parallel.

Arguments:

    Entity     - Pointer to the entity registration info.

Return Value:

    None

--*/

{
    RTM_ENTITY_HANDLE RtmRegHandle;
    PADDRFAM_INFO     AddrFamInfo;
    PHANDLE           Handles;
    RTM_ENUM_HANDLE   EnumHandle;
    UINT              NumHandles, i;
    DWORD             ChangeFlags;
    DWORD             Status;

    AddrFamInfo = Entity->OwningAddrFamily;

    RtmRegHandle = MAKE_HANDLE_FROM_POINTER(Entity);

#if DBG_HDL

    // ACQUIRE_OPEN_HANDLES_LOCK(Entity);

    while (!IsListEmpty(&Entity->OpenHandles))
    {
        POPEN_HEADER      OpenHeader;
        HANDLE            OpenHandle;
        PLIST_ENTRY       p;

        p = RemoveHeadList(&Entity->OpenHandles);

        OpenHeader = CONTAINING_RECORD(p, OPEN_HEADER, HandlesLE);

        OpenHandle = MAKE_HANDLE_FROM_POINTER(OpenHeader);

        switch (OpenHeader->HandleType)
        {
        case DEST_ENUM_TYPE:
        case ROUTE_ENUM_TYPE:
        case NEXTHOP_ENUM_TYPE:
        case LIST_ENUM_TYPE:

            Status = RtmDeleteEnumHandle(RtmRegHandle, OpenHandle);
            break;

        case NOTIFY_TYPE:

            Status = RtmDeregisterFromChangeNotification(RtmRegHandle,
                                                         OpenHandle);
            break;

        case ROUTE_LIST_TYPE:
                
            Status = RtmDeleteRouteList(RtmRegHandle, OpenHandle);
            break;

        default:

            Status = ERROR_INVALID_DATA;
        }

        ASSERT(Status == NO_ERROR);
    }

    // RELEASE_OPEN_HANDLES_LOCK(Entity);

#endif // DBG_HDL

    Handles = AllocMemory(AddrFamInfo->MaxHandlesInEnum * sizeof(HANDLE));
    if ( Handles == NULL )
    {
        return;
    }

    //
    // Delete all routes created by this entity regn
    //

    Status = RtmCreateRouteEnum(RtmRegHandle,
                                NULL,
                                RTM_VIEW_MASK_ANY,
                                RTM_ENUM_OWN_ROUTES,
                                NULL,
                                0,
                                NULL,
                                0,
                                &EnumHandle);

    while (Status == NO_ERROR)
    {
        NumHandles = AddrFamInfo->MaxHandlesInEnum;

        Status = RtmGetEnumRoutes(RtmRegHandle,
                                  EnumHandle,
                                  &NumHandles,
                                  Handles);

        for (i = 0; i < NumHandles; i++)
        {
            Status = RtmDeleteRouteToDest(RtmRegHandle,
                                          Handles[i],
                                          &ChangeFlags);
            ASSERT(Status == NO_ERROR);
        }
    }

    Status = RtmDeleteEnumHandle(RtmRegHandle,
                                 EnumHandle);

    ASSERT(Status == NO_ERROR);


    //
    // Delete all nexthops created by this entity regn
    //

    Status = RtmCreateNextHopEnum(RtmRegHandle,
                                  0,
                                  NULL,
                                  &EnumHandle);

    while (Status == NO_ERROR) 
    {
        NumHandles = AddrFamInfo->MaxHandlesInEnum;

        Status = RtmGetEnumNextHops(RtmRegHandle,
                                    EnumHandle,
                                    &NumHandles,
                                    Handles);
        
        for (i = 0; i < NumHandles; i++)
        {
            Status = RtmDeleteNextHop(RtmRegHandle,
                                      Handles[i],
                                      NULL);

            ASSERT(Status == NO_ERROR);
        }
    }

    Status = RtmDeleteEnumHandle(RtmRegHandle,
                                 EnumHandle);

    ASSERT(Status == NO_ERROR);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\rtmlog.h ===
//============================================================================
// Copyright (c) 1997 - 98, Microsoft Corporation
//
// File:    rtmlog.h
//
// History:
//  Chaitanya Kodeboyina Jun-1-1998     Created.
//
// This file is processed by mapmsg to produce a .mc file,
// then the .mc file is compiled by the message compiler,
// and the resulting binary is included in RTM's resource file.
//
// Don't change the comments following the manifest constants
// without understanding how mapmsg works.
//============================================================================


#define RTMLOG_BASE                           30000

#define RTMLOG_INIT_CRITSEC_FAILED            (RTMLOG_BASE + 1)
/*
 * RTM was unable to initialize a critical section.
 * The data is the exception code.
 */

#define RTMLOG_HEAP_CREATE_FAILED             (RTMLOG_BASE + 2)
/*
 * RTM was unable to create a heap.
 * The data is the error code.
 */

#define RTMLOG_HEAP_ALLOC_FAILED              (RTMLOG_BASE + 3)
/*
 * RTM was unable to allocate memory from its heap.
 * The data is the error code.
 */

#define RTMLOG_RTM_ALREADY_STARTED          (RTMLOG_BASE + 4)
/*
 * RTM received a start request when it was already running.
 */

#define RTMLOG_CREATE_RWL_FAILED              (RTMLOG_BASE + 5)
/*
 * RTM was unable to create a synchronization object.
 * The data is the error code.
 */

#define RTMLOG_CREATE_EVENT_FAILED            (RTMLOG_BASE + 6)
/*
 * RTM was unable to create an event.
 * The data is the error code.
 */

#define RTMLOG_CREATE_SEMAPHORE_FAILED        (RTMLOG_BASE + 7)
/*
 * RTM was unable to create a semaphore.
 * The data is the error code.
 */

#define RTMLOG_RTM_STARTED                  (RTMLOG_BASE + 8)
/*
 * RTM has started successfully.
 */

#define RTMLOG_QUEUE_WORKER_FAILED            (RTMLOG_BASE + 9)
/*
 * RTM could not schedule a task to be executed.
 * This may have been caused by a memory allocation failure.
 * The data is the error code.
 */

#define RTMLOG_PROTOCOL_NOT_FOUND             (RTMLOG_BASE + 10)
/*
 * RTM could not find the protocol component (%1, %2)
 */

#define RTMLOG_PROTOCOL_ALREADY_PRESENT       (RTMLOG_BASE + 11)
/*
 * Protocol component has already registered with RTM 
 */

#define RTMLOG_CREATE_PROTOCOL_FAILED         (RTMLOG_BASE + 12)
/*
 * RTM failed to register the protocol component.
 * The data is in the error code.
 */

#define RTMLOG_INTERFACES_PRESENT             (RTMLOG_BASE + 13)
/*
 * The protocol component that is attempting to deregister is currently
 * enabled on one or more interfaces.   
 */

#define RTMLOG_IF_ALREADY_PRESENT             (RTMLOG_BASE + 14)
/*
 * This protocol component has already been enabled on this interface 
 */

#define RTMLOG_IF_NOT_FOUND                   (RTMLOG_BASE + 15)
/*
 * Specified interface was not present in MGM. 
 */

#define RTMLOG_IF_DIFFERENT_OWNER             (RTMLOG_BASE + 16)
/*
 * Another routing protocol component has already been enabled on
 * this interface.  Only one routing protocol component may be 
 * enabled on an interface at any time.
 */

#define RTMLOG_IF_IGMP_NOT_PRESENT            (RTMLOG_BASE + 17)
/*
 * IGMP is not enabled on this interface 
 */

#define RTMLOG_IF_PROTOCOL_NOT_PRESENT        (RTMLOG_BASE + 18)
/*
 * No routing protocol has been enabled on this interface 
 */

#define RTMLOG_INVALID_HANDLE                 (RTMLOG_BASE + 19)
/*
 * The handle specified by the protocol component is not valid. This
 * maybe because the protocol component is not registered with RTM
 */

#define RTMLOG_IF_IGMP_PRESENT                (RTMLOG_BASE + 17)
/*
 * Interface cannot be deleted because IGMP is still active on 
 * this interface. 
 */

#define RTMLOG_RTM_STOPPED                  (RTMLOG_BASE + 99)
/*
 * RTM has stopped.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\rtmregn.h ===
/*++

Copyright (c) 1997-1998 Microsoft Corporation

Module Name:

    rtmregn.h

Abstract:
    Private defns relating to the registration
    and de-registration of entities with RTMv2

Author:
    Chaitanya Kodeboyina (chaitk) 17-Aug-1998

Revision History:

--*/


#ifndef __ROUTING_RTMREGN_H__
#define __ROUTING_RTMREGN_H__

//
// Forward declarations for various Info Blocks
//
typedef struct _ADDRFAM_INFO  ADDRFAM_INFO;

//
// Info related to an RTM instance
// 

typedef struct _INSTANCE_INFO
{
    OBJECT_HEADER     ObjectHeader;     // Signature, Type and Reference Count

    USHORT            RtmInstanceId;    // Unique ID for this RTM instance

    LIST_ENTRY        InstTableLE;      // Linkage on global table of instances

    UINT              NumAddrFamilies;  // Address Family Specific Info Blocks
    LIST_ENTRY        AddrFamilyTable;  // on this instance (like IPv4 n IPv6)
} 
INSTANCE_INFO, *PINSTANCE_INFO;


//
// Info related to an address family in an RTM instance
//

#define ENTITY_TABLE_SIZE              16

typedef struct _ADDRFAM_INFO
{
    OBJECT_HEADER     ObjectHeader;     // Signature, Type and Reference Count

    USHORT            AddressFamily;    // Address Family for this info block

    UINT              AddressSize;      // Address size in this address family

    PINSTANCE_INFO    Instance;         // Back pointer to the owning instance

    LIST_ENTRY        AFTableLE;        // Linkage on table of AFs on instance

    RTM_VIEW_SET      ViewsSupported;   // Views supported by this addr family

    UINT              NumberOfViews;    // Num. of views supported by this AF

    RTM_VIEW_ID       ViewIdFromIndex[RTM_MAX_VIEWS];
                                        // View Id -> Its Index in Dest mapping

    RTM_VIEW_ID       ViewIndexFromId[RTM_MAX_VIEWS];  
                                        // View Index in Dest -> Its Id mapping

    UINT              MaxHandlesInEnum; // Max. number of handles returned in
                                        // any RTMv2 call that returns handles 

    UINT              MaxNextHopsInRoute;// Max. number of equal cost next-hops

    UINT              MaxOpaquePtrs;    //
    UINT              NumOpaquePtrs;    // Directory of opaque info ptr offsets
    PVOID            *OpaquePtrsDir;    //

    UINT              NumEntities;      // Table of all the registered entities
    LIST_ENTRY        EntityTable[ENTITY_TABLE_SIZE];

    LIST_ENTRY        DeregdEntities;   // Table of all de-registered entities

    READ_WRITE_LOCK   RouteTableLock;   // Protects the route table of routes
    BOOL              RoutesLockInited; // Was the above lock initialized ?

    PVOID             RouteTable;       // Table of dests and routes on this AF
    LONG              NumDests;         // Number of dests in the route table
    LONG              NumRoutes;        // Number of routes in the route table
                                        // [Use interlocked ops as no locking]

    HANDLE            RouteTimerQueue;  // List of route timers being used

    HANDLE            NotifTimerQueue;  // List of notification timers used

    READ_WRITE_LOCK   ChangeNotifsLock; // Protects change notification info
    BOOL              NotifsLockInited; // Was the above lock initialized ?

    UINT              MaxChangeNotifs;  //
    UINT              NumChangeNotifs;  // Directory of change notifications
    PVOID            *ChangeNotifsDir;  //

    DWORD             ChangeNotifRegns; // Mask of regd change notifications

    DWORD             CNsForMarkedDests;// Mask of CNs requesing changes on 
                                        // only destinations marked by them

    DWORD             CNsForView[RTM_MAX_VIEWS];
                                        // CNs interested in a certain view

    DWORD             CNsForChangeType[RTM_NUM_CHANGE_TYPES];
                                        // CNs interested in a change type

    CRITICAL_SECTION  NotifsTimerLock;  // Lock the protects ops on CN timer
    BOOL              TimerLockInited;  // Was the above lock initialized ?

    HANDLE            ChangeNotifTimer; // Timer used to process changes list

    LONG              NumChangedDests;  // Num of destinations on change list
                                        // [Use interlocked ops as no locking]
    struct
    {
        LONG               ChangesListInUse;  // Is this change list in use ?
        CRITICAL_SECTION   ChangesListLock;   // Protects list of changed dests
        BOOL               ChangesLockInited; // Was above lock initialized ?
        SINGLE_LIST_ENTRY  ChangedDestsHead;  // Head of list of changed dests
        PSINGLE_LIST_ENTRY ChangedDestsTail;  // Pointer to tail of above list
    } 
    ChangeLists[NUM_CHANGED_DEST_LISTS]; // Multiple chng lists for concurrency
} 
ADDRFAM_INFO, *PADDRFAM_INFO;


//
// Entity Registration Info Block
//
typedef struct _ENTITY_INFO
{
    OBJECT_HEADER     ObjectHeader;     // Signature, Type and Reference Count

    RTM_ENTITY_ID     EntityId;         // Entity Proto ID and Instance
                                        // that make a unique Entity Id
  
    PADDRFAM_INFO     OwningAddrFamily; // Back pointer to the owning AF

    LIST_ENTRY        EntityTableLE;    // Linkage on AF's table of entities

    HANDLE            BlockingEvent;    // Event used to block ops on entity

    ULONG             State;            // See ENTITY_STATE_* values below

    INT               OpaquePtrOffset;  // Offset of reserved opaque ptr or -1

    READ_WRITE_LOCK   RouteListsLock;    // Protects all route lists of entity
    BOOL              ListsLockInited;   // Was the above lock initialized ?

    CRITICAL_SECTION  OpenHandlesLock;  // Protects list of enums and notifs
    BOOL              HandlesLockInited;// Was the above lock initialized ?
    LIST_ENTRY        OpenHandles;      // List of all enums & change notifs

    READ_WRITE_LOCK   NextHopTableLock; // Protects the next hop table.
    BOOL              NextHopsLockInited;// Was the above lock initialized ?
    PVOID             NextHopTable;     // Table of next-hops that all
                                        // routes of this entity share
    ULONG             NumNextHops;      // Number of next-hops in this table

    READ_WRITE_LOCK   EntityMethodsLock;// Used to block all methods
                                        // on owned dests and routes
    BOOL              MethodsLockInited;// Was above lock initialized ?

    RTM_EVENT_CALLBACK EventCallback;   // Entity Register/De-register
                                        // event inform callback

    RTM_ENTITY_EXPORT_METHODS
                      EntityMethods;    // Method set exported to get
                                        // entity specific information
}
ENTITY_INFO, *PENTITY_INFO;

#define ENTITY_STATE_REGISTERED         0x00000000
#define ENTITY_STATE_DEREGISTERED       0x00000001

//
// Common Header for all open blocks
// ( pointed to by active handles )
//

typedef struct _OPEN_HEADER
{
    OBJECT_HEADER     ObjectHeader;     // Signature, Type and Reference Count

    UCHAR             HandleType;       // Type of handle for this open block

#if DBG_HDL
    LIST_ENTRY        HandlesLE;        // On list of handles opened by entity
#endif
}
OPEN_HEADER, *POPEN_HEADER;


//
// Macros for acquiring various locks defined in this file
// 

#define ACQUIRE_ROUTE_TABLE_READ_LOCK(AF)                    \
    ACQUIRE_READ_LOCK(&AF->RouteTableLock)

#define RELEASE_ROUTE_TABLE_READ_LOCK(AF)                    \
    RELEASE_READ_LOCK(&AF->RouteTableLock)

#define ACQUIRE_ROUTE_TABLE_WRITE_LOCK(AF)                   \
    ACQUIRE_WRITE_LOCK(&AF->RouteTableLock)

#define RELEASE_ROUTE_TABLE_WRITE_LOCK(AF)                   \
    RELEASE_WRITE_LOCK(&AF->RouteTableLock)


#define ACQUIRE_NOTIFICATIONS_READ_LOCK(AF)                  \
    ACQUIRE_READ_LOCK(&AF->ChangeNotifsLock);

#define RELEASE_NOTIFICATIONS_READ_LOCK(AF)                  \
    RELEASE_READ_LOCK(&AF->ChangeNotifsLock);

#define ACQUIRE_NOTIFICATIONS_WRITE_LOCK(AF)                 \
    ACQUIRE_WRITE_LOCK(&AF->ChangeNotifsLock);

#define RELEASE_NOTIFICATIONS_WRITE_LOCK(AF)                 \
    RELEASE_WRITE_LOCK(&AF->ChangeNotifsLock);


#define ACQUIRE_NOTIF_TIMER_LOCK(AF)                         \
    ACQUIRE_LOCK(&AF->NotifsTimerLock)

#define RELEASE_NOTIF_TIMER_LOCK(AF)                         \
    RELEASE_LOCK(&AF->NotifsTimerLock)


#define ACQUIRE_CHANGED_DESTS_LIST_LOCK(AF, ListN)           \
    ACQUIRE_LOCK(&AF->ChangeLists[ListN].ChangesListLock)

#define RELEASE_CHANGED_DESTS_LIST_LOCK(AF, ListN)           \
    RELEASE_LOCK(&AF->ChangeLists[ListN].ChangesListLock)


#define ACQUIRE_ROUTE_LISTS_READ_LOCK(Entity)                \
    ACQUIRE_READ_LOCK(&Entity->RouteListsLock)

#define RELEASE_ROUTE_LISTS_READ_LOCK(Entity)                \
    RELEASE_READ_LOCK(&Entity->RouteListsLock)

#define ACQUIRE_ROUTE_LISTS_WRITE_LOCK(Entity)               \
    ACQUIRE_WRITE_LOCK(&Entity->RouteListsLock)

#define RELEASE_ROUTE_LISTS_WRITE_LOCK(Entity)               \
    RELEASE_WRITE_LOCK(&Entity->RouteListsLock)


#define ACQUIRE_OPEN_HANDLES_LOCK(Entity)                    \
    ACQUIRE_LOCK(&Entity->OpenHandlesLock)

#define RELEASE_OPEN_HANDLES_LOCK(Entity)                    \
    RELEASE_LOCK(&Entity->OpenHandlesLock)


#define ACQUIRE_NHOP_TABLE_READ_LOCK(Entity)                 \
    ACQUIRE_READ_LOCK(&Entity->NextHopTableLock)

#define RELEASE_NHOP_TABLE_READ_LOCK(Entity)                 \
    RELEASE_READ_LOCK(&Entity->NextHopTableLock)

#define ACQUIRE_NHOP_TABLE_WRITE_LOCK(Entity)                \
    ACQUIRE_WRITE_LOCK(&Entity->NextHopTableLock)

#define RELEASE_NHOP_TABLE_WRITE_LOCK(Entity)                \
    RELEASE_WRITE_LOCK(&Entity->NextHopTableLock)


#define ACQUIRE_ENTITY_METHODS_READ_LOCK(Entity)             \
    ACQUIRE_READ_LOCK(&Entity->NextHopTableLock)

#define RELEASE_ENTITY_METHODS_READ_LOCK(Entity)             \
    RELEASE_READ_LOCK(&Entity->NextHopTableLock)

#define ACQUIRE_ENTITY_METHODS_WRITE_LOCK(Entity)            \
    ACQUIRE_WRITE_LOCK(&Entity->NextHopTableLock)

#define RELEASE_ENTITY_METHODS_WRITE_LOCK(Entity)            \
    RELEASE_WRITE_LOCK(&Entity->NextHopTableLock)


//
// Registration Helper Functions
//

DWORD
CreateInstance (
    IN      USHORT                          InstanceId,
    OUT     PINSTANCE_INFO                 *NewInstance
    );

DWORD
GetInstance (
    IN      USHORT                          RtmInstanceId,
    IN      BOOL                            ImplicitCreate,
    OUT     PINSTANCE_INFO                 *RtmInstance
    );

DWORD
DestroyInstance (
    IN      PINSTANCE_INFO                  Instance
    );


DWORD
CreateAddressFamily (
    IN      PINSTANCE_INFO                  Instance,
    IN      USHORT                          AddressFamily,
    OUT     PADDRFAM_INFO                  *NewAddrFamilyInfo
    );

DWORD
GetAddressFamily (
    IN      PINSTANCE_INFO                  Instance,
    IN      USHORT                          AddressFamily,
    IN      BOOL                            ImplicitCreate,
    OUT     PADDRFAM_INFO                  *AddrFamilyInfo
    );

DWORD
DestroyAddressFamily (
    IN      PADDRFAM_INFO                   AddrFamilyInfo
    );


DWORD
CreateEntity (
    IN      PADDRFAM_INFO                   AddressFamily,
    IN      PRTM_ENTITY_INFO                EntityInfo,
    IN      BOOL                            ReserveOpaquePtr,
    IN      PRTM_ENTITY_EXPORT_METHODS      ExportMethods,
    IN      RTM_EVENT_CALLBACK              EventCallback,
    OUT     PENTITY_INFO                   *NewEntity
    );

DWORD
GetEntity (
    IN      PADDRFAM_INFO                   AddrFamilyInfo,
    IN      ULONGLONG                       EntityId,
    IN      BOOL                            ImplicitCreate,
    IN      PRTM_ENTITY_INFO                RtmEntityInfo    OPTIONAL,
    IN      BOOL                            ReserveOpaquePtr OPTIONAL,
    IN      PRTM_ENTITY_EXPORT_METHODS      ExportMethods    OPTIONAL,
    IN      RTM_EVENT_CALLBACK              EventCallback    OPTIONAL,
    OUT     PENTITY_INFO                   *EntityInfo
    );

DWORD
DestroyEntity (
    IN      PENTITY_INFO                    Entity
    );

VOID
InformEntitiesOfEvent (
    IN      PLIST_ENTRY                     EntityTable,
    IN      RTM_EVENT_TYPE                  EventType,
    IN      PENTITY_INFO                    EntityThis
    );

VOID
CleanupAfterDeregister (
    IN      PENTITY_INFO                    Entity
    );

#endif //__ROUTING_RTMREGN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\rtmtest.h ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    rtmtest.h

Abstract:
    Contains defines for the RTMv2 test program.

Author:
    Chaitanya Kodeboyina (chaitk) 30-Jun-1998

Revision History:

--*/

#include <nt.h>

#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <stdio.h>

#include <stdlib.h>
#include <assert.h>
#include <malloc.h>

#include "lkuptst.h"

#include "apitest.h"

// Disable warnings for `do { ; } while (FALSE);'
#pragma warning(disable: 4127)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\rtmtest.cxx ===
/*++

Copyright (c) 1995-1998 Microsoft Corporation

Module Name:

    rtmtest.cxx

Abstract:
    Contains routines for testing RTM v2 API DLL.

Author:
    Chaitanya Kodeboyina (chaitk) 30-Jun-1998

Revision History:

--*/

extern "C" {

#define LOOKUP_TESTING 0

#include "rtmtest.h"

#include "apitest.c"

#include "lkuptst.c"

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\rtmrout.h ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmrout.h

Abstract:

    Contains definitions for RTM objects like
    destinations, routes and next hops.

Author:

    Chaitanya Kodeboyina (chaitk)   21-Aug-1998

Revision History:

--*/

#ifndef __ROUTING_RTMROUT_H__
#define __ROUTING_RTMROUT_H__

//
// Forward declarations for various Info Blocks
//
typedef struct _DEST_INFO     DEST_INFO;
typedef struct _ROUTE_INFO    ROUTE_INFO;
typedef struct _NEXTHOP_INFO  NEXTHOP_INFO;

//                                                                             
// Address Family independent dest structure                                   
//                                                                             
typedef struct _DEST_INFO
{
    OBJECT_HEADER     ObjectHeader;     // Signature, Type and Reference Count

    SINGLE_LIST_ENTRY ChangeListLE;     // Linkage on the list of changed dests

    LOOKUP_LINKAGE    LookupLinkage;    // Linkage into owning lookup structure

    PVOID             DestLock;         // Dynamic lock that protects this dest
 
    DWORD             DestMarkedBits;   // Bit N set => Nth CN has marked dest
    DWORD             DestChangedBits;  // Bit N set => Nth CN has a change
    DWORD             DestOnQueueBits;  // Bit N set => Dest on Nth CN's queue

    UINT              NumRoutes;        // Number of routes to destination
    LIST_ENTRY        RouteList;        // A list of routes to destination

    PVOID            *OpaqueInfoPtrs;   // Array of Opaque Info Pointers

    RTM_NET_ADDRESS   DestAddress;      // Network Address unique to this dest

    FILETIME          LastChanged;      // Last time destination was modified 

    USHORT            State;            // State of the destination

    USHORT            HoldRefCount;     // RefCount != 0 => Dest In Holddown

    RTM_VIEW_SET      BelongsToViews;   // View that this dest belongs too

    RTM_VIEW_SET      ToHoldInViews;    // Views in which holddown will apply

    struct 
    {                                   //
        ROUTE_INFO   *BestRoute;        // Best route to dest in each view
        ROUTE_INFO   *HoldRoute;        // The holddown route in each view
        ULONG         HoldTime;         // Time for which route is in held
    }                   ViewInfo[1];    //
}
DEST_INFO, *PDEST_INFO;

//
// Destination State
//
#define DEST_STATE_CREATED            0
#define DEST_STATE_DELETED            1


//
// Context used in timing out a route
//

typedef struct _ROUTE_TIMER
{
    HANDLE           Timer;             // Handle to the timer used for expiry

    PVOID            Route;             // Route being expired by this timer
}
ROUTE_TIMER, *PROUTE_TIMER;


//
// Address Family Independent route structure
//
typedef struct _ROUTE_INFO
{
    OBJECT_HEADER     ObjectHeader;     // Signature, Type and Reference Count

    LIST_ENTRY        DestLE;           // Linkage on list of routes on dest

    LIST_ENTRY        RouteListLE;      // Linkage on an entity's route list

    PROUTE_TIMER      TimerContext;     // Timer used to age-out or holddown

    RTM_ROUTE_INFO    RouteInfo;        // Part exposed directly to the owner
}
ROUTE_INFO, *PROUTE_INFO;


//
// Node in the next hop tree of which all the
// next-hops with a particular addr hang off
//
typedef struct _NEXTHOP_LIST
{
    LOOKUP_LINKAGE    LookupLinkage;    // Linkage into owning lookup structure

    LIST_ENTRY        NextHopsList;     // Head of the list of next hops
}
NEXTHOP_LIST, *PNEXTHOP_LIST;


//
// Address Family Independent next-hop structure
//
typedef struct _NEXTHOP_INFO
{
    OBJECT_HEADER     ObjectHeader;     // Signature, Type and Reference Count

    LIST_ENTRY        NextHopsLE;       // Linkage into holding nexthops list
    
    RTM_NEXTHOP_INFO  NextHopInfo;      // Part exposed directly to the owner
}
NEXTHOP_INFO, *PNEXTHOP_INFO;


//
// Macros for acquiring various locks defined in this file
// 

#define ACQUIRE_DEST_READ_LOCK(Dest)                         \
    ACQUIRE_DYNAMIC_READ_LOCK(&Dest->DestLock)

#define RELEASE_DEST_READ_LOCK(Dest)                         \
    RELEASE_DYNAMIC_READ_LOCK(&Dest->DestLock)

#define ACQUIRE_DEST_WRITE_LOCK(Dest)                        \
    ACQUIRE_DYNAMIC_WRITE_LOCK(&Dest->DestLock)

#define RELEASE_DEST_WRITE_LOCK(Dest)                        \
    RELEASE_DYNAMIC_WRITE_LOCK(&Dest->DestLock)

//
// Macros for comparing two routes using their preferences
//

BOOL
__inline
IsPrefEqual (
    IN      PRTM_ROUTE_INFO                 RouteInfo1, 
    IN      PRTM_ROUTE_INFO                 RouteInfo2
    )
{
 return ((RouteInfo1->PrefInfo.Metric == RouteInfo2->PrefInfo.Metric) &&
         (RouteInfo1->PrefInfo.Preference == RouteInfo2->PrefInfo.Preference));
}

LONG
__inline
ComparePref (
    IN      PRTM_ROUTE_INFO                 RouteInfo1, 
    IN      PRTM_ROUTE_INFO                 RouteInfo2
    )
{
    // Lower preference means "more preferred"

    if (RouteInfo1->PrefInfo.Preference < RouteInfo2->PrefInfo.Preference)
    { return +1; }
    else
    if (RouteInfo1->PrefInfo.Preference > RouteInfo2->PrefInfo.Preference)
    { return -1; }
    else
    if (RouteInfo1->PrefInfo.Metric < RouteInfo2->PrefInfo.Metric)
    { return +1; }
    else
    if (RouteInfo1->PrefInfo.Metric > RouteInfo2->PrefInfo.Metric)
    { return -1; }

    return  0;
}


//
// Dest, Route, NextHop Helper Functions
//

DWORD
CreateDest (
    IN      PADDRFAM_INFO                   AddrFamilyInfo,
    IN      PRTM_NET_ADDRESS                DestAddress,
    OUT     PDEST_INFO                     *Dest
    );

DWORD
DestroyDest (
    IN      PDEST_INFO                      Dest
    );

DWORD
CreateRoute (
    IN      PENTITY_INFO                    Entity,
    IN      PRTM_ROUTE_INFO                 RouteInfo,
    OUT     PROUTE_INFO                    *Route
    );

VOID
ComputeRouteInfoChange(
    IN      PRTM_ROUTE_INFO                 OldRouteInfo,
    IN      PRTM_ROUTE_INFO                 NewRouteInfo,
    IN      ULONG                           PrefChanged,
    OUT     PULONG                          RouteInfoChanged,
    OUT     PULONG                          ForwardingInfoChanged
    );

VOID
CopyToRoute (
    IN      PENTITY_INFO                    Entity,
    IN      PRTM_ROUTE_INFO                 RouteInfo,
    IN      PROUTE_INFO                     Route
    );

DWORD
DestroyRoute (
    IN      PROUTE_INFO                     Route
    );

DWORD
CreateNextHop (
    IN      PENTITY_INFO                    Entity,
    IN      PRTM_NEXTHOP_INFO               NextHopInfo,
    OUT     PNEXTHOP_INFO                  *NextHop
    );

VOID
CopyToNextHop (
    IN      PENTITY_INFO                    Entity,
    IN      PRTM_NEXTHOP_INFO               NextHopInfo,
    IN      PNEXTHOP_INFO                   NextHop
    );

DWORD
DestroyNextHop (
    IN      PNEXTHOP_INFO                   NextHop
    );

DWORD
FindNextHop (
    IN      PENTITY_INFO                    Entity,
    IN      PRTM_NEXTHOP_INFO               NextHopInfo,
    OUT     PLOOKUP_CONTEXT                 Context OPTIONAL,
    OUT     PLIST_ENTRY                    *NextHopLE
    );

#endif //__ROUTING_RTMROUT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\rtmobj2.c ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmobj2.c

Abstract:

    Contains routines for managing RTM objects
    like Destinations, Routes and Next Hops.

Author:

    Chaitanya Kodeboyina (chaitk)   23-Aug-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop

DWORD
CreateDest (
    IN      PADDRFAM_INFO                   AddrFamilyInfo,
    IN      PRTM_NET_ADDRESS                DestAddress,
    OUT     PDEST_INFO                     *NewDest
    )

/*++

Routine Description:

    Creates a new destination info structure and initializes it.

Arguments:

    AddrFamilyInfo    - Address family that identifies route table,

    DestAddress       - Destination network address for new dest,

    NewDest           - Pointer to the destination info structure
                        will be returned through this parameter.

Return Value:

    Status of the operation

--*/

{
    PDEST_INFO      Dest;
    UINT            NumOpaquePtrs;
    UINT            NumBytes;
    UINT            NumViews;
    DWORD           Status;

    *NewDest = NULL;

    //
    // Allocate and initialize a new route info
    //

    NumOpaquePtrs = AddrFamilyInfo->MaxOpaquePtrs;

    NumViews = AddrFamilyInfo->NumberOfViews;

    NumBytes = sizeof(DEST_INFO) + 
                   NumOpaquePtrs * sizeof(PVOID) +
                       (NumViews - 1) * sizeof(Dest->ViewInfo);

    Dest = (PDEST_INFO) AllocNZeroObject(NumBytes);

    if (Dest == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    do
    {

#if DBG_HDL
        Dest->ObjectHeader.TypeSign = DEST_ALLOC;
#endif

        // Will be removed when first route on dest is added
        INITIALIZE_DEST_REFERENCE(Dest, CREATION_REF);

        //
        // Initialize change notification bits and list entry
        //

        Dest->ChangeListLE.Next = NULL;

        //
        // Initialize the list of routes ont the destination
        //

        InitializeListHead(&Dest->RouteList);

        Dest->NumRoutes = 0;

        // Set the opaque ptr dir to memory at the end of dest

        Dest->OpaqueInfoPtrs = (PVOID *) ((PUCHAR) Dest  +
                                          NumBytes - 
                                          NumOpaquePtrs * sizeof(PVOID));

        // Set the destination address from the input parameter

        CopyMemory(&Dest->DestAddress,
                   DestAddress,
                   sizeof(RTM_NET_ADDRESS));

        *NewDest = Dest;

        return NO_ERROR;
    }
    while (FALSE);

    //
    // Some error occured in the initialization , clean up
    //

#if DBG_HDL
    Dest->ObjectHeader.TypeSign = DEST_FREED;
#endif

    FreeObject(Dest);

    *NewDest = NULL;

    return Status;
}

DWORD
DestroyDest (
    IN      PDEST_INFO                      Dest
    )

/*++

Routine Description:

    Destroys the destination by freeing resources and
    deallocating it. This function is called when the
    reference count on the dest drops to 0.

Arguments:

    Dest   - Pointer to the dest being destroyed.

Return Value:

    None

--*/

{
    ASSERT(Dest->ObjectHeader.RefCount == 0);

    ASSERT(Dest->HoldRefCount == 0);

    //
    // Dynamic lock should have been freed
    //

    ASSERT(Dest->DestLock == NULL);

    //
    // Free the memory allocated for dest
    //

#if DBG_HDL
    Dest->ObjectHeader.TypeSign = DEST_FREED;
#endif

    FreeObject(Dest);

    return NO_ERROR;
}


DWORD
CreateRoute (
    IN      PENTITY_INFO                    Entity,    
    IN      PRTM_ROUTE_INFO                 RouteInfo,
    OUT     PROUTE_INFO                    *NewRoute
    )

/*++

Routine Description:

    Creates a new route info structure and initializes it.

Arguments:

    Entity            - Entity creating the new route on a dest,

    RouteInfo         - Route info for the new route being created,

    NewRoute          - Pointer to the new route info structure
                        will be returned through this parameter.

Return Value:

    Status of the operation

--*/

{
    RTM_NEXTHOP_HANDLE NextHopHandle;
    PRTM_ROUTE_INFO    Info;
    PROUTE_INFO        Route;
    PNEXTHOP_INFO      NextHop;
    UINT               NumNextHops;
    UINT               i;
    DWORD              Status;

    *NewRoute = NULL;

    //
    // Allocate and initialize a new route info
    //

    NumNextHops = Entity->OwningAddrFamily->MaxNextHopsInRoute;

    Route = (PROUTE_INFO) AllocNZeroObject(sizeof(ROUTE_INFO) +
                                           (NumNextHops - 1) *
                                           sizeof(RTM_NEXTHOP_HANDLE));

    if (Route == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    do
    {
#if DBG_HDL
        Route->ObjectHeader.TypeSign = ROUTE_ALLOC;
#endif
        INITIALIZE_ROUTE_REFERENCE(Route, CREATION_REF);

        InitializeListHead(&Route->DestLE);

        InitializeListHead(&Route->RouteListLE);

        //
        // Initialize the public half of route info 
        //

        Info = &Route->RouteInfo;

        Info->RouteOwner = MAKE_HANDLE_FROM_POINTER(Entity);

        REFERENCE_ENTITY(Entity, ROUTE_REF);

        if (RouteInfo->Neighbour)
        {
            NextHop = NEXTHOP_FROM_HANDLE(RouteInfo->Neighbour);

            REFERENCE_NEXTHOP(NextHop, ROUTE_REF);

            // "Neighbour learnt from" entry is owned by caller

            ASSERT((NextHop) && 
                   (NextHop->NextHopInfo.NextHopOwner == Info->RouteOwner));

            Info->Neighbour = RouteInfo->Neighbour;
        }

        Info->State = RTM_ROUTE_STATE_CREATED;

        Info->Flags1 = RouteInfo->Flags1;

        Info->Flags = RouteInfo->Flags;

        Info->PrefInfo = RouteInfo->PrefInfo;

        Info->BelongsToViews = RouteInfo->BelongsToViews;

        Info->EntitySpecificInfo = RouteInfo->EntitySpecificInfo;

        //
        // Make a copy of the next hops list (as much as u can)
        //

        if (NumNextHops > RouteInfo->NextHopsList.NumNextHops)
        {
            NumNextHops = RouteInfo->NextHopsList.NumNextHops;
        }

        Info->NextHopsList.NumNextHops = (USHORT) NumNextHops;

        for (i = 0; i < NumNextHops; i++)
        {
            NextHopHandle = RouteInfo->NextHopsList.NextHops[i];

            // Make sure that the next-hop is owned by caller

            NextHop = NEXTHOP_FROM_HANDLE(NextHopHandle);

            ASSERT((NextHop) && 
                   (NextHop->NextHopInfo.NextHopOwner == Info->RouteOwner));

            Info->NextHopsList.NextHops[i] = NextHopHandle;

            REFERENCE_NEXTHOP(NextHop, ROUTE_REF);
        }

        //
        // Return a pointer to the new initialized route
        //

        *NewRoute = Route;
      
        return NO_ERROR;
    }
    while (FALSE);

    //
    // Some error occured in the initialization , clean up
    //

#if DBG_HDL
    Route->ObjectHeader.TypeSign = ROUTE_FREED;
#endif

    FreeObject(Route);    

    *NewRoute = NULL;

    return Status;
}

VOID
ComputeRouteInfoChange(
    IN      PRTM_ROUTE_INFO                 OldRouteInfo,
    IN      PRTM_ROUTE_INFO                 NewRouteInfo,
    IN      ULONG                           PrefChanged,
    OUT     PULONG                          RouteInfoChanged,
    OUT     PULONG                          ForwardingInfoChanged
    )

/*++

Routine Description:

    Updates an exising route with new route info. Note that
    only the route's owner is allowed to do this.

Arguments:

    OldRoute         - Old route information (except the PrefInfo and
                       BelongsToViews info fields already updated),

    NewRoute         - New route information to update old route with,

    PrefChanged      - Whether PrefInfo values changed from old to new,

    RouteInfoChanged - Whether the route information has changed,

    ForwardingInfoChanged - Whether forwarding info has been changed.

Return Value:

    None

--*/

{
    ULONG  DiffFlags;
    UINT   i;

    *RouteInfoChanged = *ForwardingInfoChanged = 0;

    do
    {
        //
        // Has the preference changed from old to new ?
        //

        if (PrefChanged)
        {
            break;
        }

        //
        // Are the number and handles to next hops same ?
        //

        if (OldRouteInfo->NextHopsList.NumNextHops !=
            NewRouteInfo->NextHopsList.NumNextHops)
        {
            break;
        }

        for (i = 0; i < OldRouteInfo->NextHopsList.NumNextHops; i++)
        {
            if (OldRouteInfo->NextHopsList.NextHops[i] !=
                NewRouteInfo->NextHopsList.NextHops[i])
            {
                break;
            }
        }

        if (i != OldRouteInfo->NextHopsList.NumNextHops)
        {
            break;
        }

        //
        // Have the forwarding flags changed from old ?
        //

        DiffFlags = OldRouteInfo->Flags ^ NewRouteInfo->Flags;

        if (DiffFlags & RTM_ROUTE_FLAGS_FORWARDING)
        {
            break;
        }

        //
        // Have non forwarding flags changed from old ?
        //

        if (DiffFlags)
        {
            *RouteInfoChanged = 1;
        }
        
        return;
    } 
    while (FALSE);

    //
    // Forwarding info is a subset of route info
    //

    *ForwardingInfoChanged = *RouteInfoChanged = 1;

    return;
}

VOID
CopyToRoute (
    IN      PENTITY_INFO                    Entity,
    IN      PRTM_ROUTE_INFO                 RouteInfo,
    IN      PROUTE_INFO                     Route
    )

/*++

Routine Description:

    Updates an exising route with new route info. Note that
    only the route's owner is allowed to do this.

Arguments:

    Entity      - Entity that is updating the existing route,

    RouteInfo   - Route info using which route is being updated,

    Route       - Route that is being updated with above info.

Return Value:

    None

--*/

{
    RTM_NEXTHOP_HANDLE NextHopHandle;
    PRTM_ROUTE_INFO    Info;
    PNEXTHOP_INFO      NextHop;
    UINT               NumNextHops;
    UINT               i;    

    Info = &Route->RouteInfo;

    //
    // Update the route with the new information
    //

    Info->State = RTM_ROUTE_STATE_CREATED;

    Info->Flags1 = RouteInfo->Flags1;

    Info->Flags = RouteInfo->Flags;

    Info->PrefInfo = RouteInfo->PrefInfo;

    Info->BelongsToViews = RouteInfo->BelongsToViews;

    Info->EntitySpecificInfo = RouteInfo->EntitySpecificInfo;

    //
    // Update the neighbour "learnt from" field
    //

    if (Info->Neighbour != RouteInfo->Neighbour)
    {
        // Free the previous "neighbour learnt from"

        if (Info->Neighbour)
        {
            NextHop = NEXTHOP_FROM_HANDLE(Info->Neighbour);

            DEREFERENCE_NEXTHOP(NextHop, ROUTE_REF);
        }

        // Copy the new neighbour "learnt from" now

        if (RouteInfo->Neighbour)
        {
            NextHop = NEXTHOP_FROM_HANDLE(RouteInfo->Neighbour);

            REFERENCE_NEXTHOP(NextHop, ROUTE_REF);

            // "Neighbour learnt from" entry is owned by caller

            ASSERT((NextHop) && 
                   (NextHop->NextHopInfo.NextHopOwner == Info->RouteOwner));
        }

        Info->Neighbour = RouteInfo->Neighbour;
    }

    //
    // Count the number of next-hops you can copy
    //

    NumNextHops = Entity->OwningAddrFamily->MaxNextHopsInRoute;

    if (NumNextHops > RouteInfo->NextHopsList.NumNextHops)
    {
        NumNextHops = RouteInfo->NextHopsList.NumNextHops;
    }

    //
    // Reference all next-hops that you will copy
    //

    for (i = 0; i < NumNextHops; i++)
    {
        NextHopHandle = RouteInfo->NextHopsList.NextHops[i];

        NextHop = NEXTHOP_FROM_HANDLE(NextHopHandle);

        REFERENCE_NEXTHOP(NextHop, ROUTE_REF);
    }

    //
    // Dereference existing next-hops before update
    //

    for (i = 0; i < Info->NextHopsList.NumNextHops; i++)
    {
        NextHopHandle = Info->NextHopsList.NextHops[i];

        NextHop = NEXTHOP_FROM_HANDLE(NextHopHandle);

        DEREFERENCE_NEXTHOP(NextHop, ROUTE_REF);
    }

    //
    // Make a copy of the next hops in input list 
    //

    Info->NextHopsList.NumNextHops = (USHORT) NumNextHops;

    for (i = 0; i < NumNextHops; i++)
    {
        Info->NextHopsList.NextHops[i] = RouteInfo->NextHopsList.NextHops[i];
    }

    return;
}

DWORD
DestroyRoute (
    IN      PROUTE_INFO                     Route
    )

/*++

Routine Description:

    Destroys the route by freeing resources and
    deallocating it. This function is called when
    reference count on the route drops to 0.

Arguments:

    Route  - Pointer to the route being destroyed.

Return Value:

    None

--*/

{
    RTM_NEXTHOP_HANDLE NextHopHandle;
    PRTM_ROUTE_INFO    Info;
    PNEXTHOP_INFO      NextHop;
    PENTITY_INFO       Entity;
    PDEST_INFO         Dest;
    UINT               i;

    ASSERT(Route->ObjectHeader.RefCount == 0);

    Info = &Route->RouteInfo;

    //
    // Dereference all next-hops before delete
    //

    for (i = 0; i < Info->NextHopsList.NumNextHops; i++)
    {
        NextHopHandle = Info->NextHopsList.NextHops[i];

        NextHop = NEXTHOP_FROM_HANDLE(NextHopHandle);

        DEREFERENCE_NEXTHOP(NextHop, ROUTE_REF);
    }

    //
    // Dereference advertising neighbour handle
    //

    if (Info->Neighbour)
    {
        NextHop = NEXTHOP_FROM_HANDLE(Info->Neighbour);

        DEREFERENCE_NEXTHOP(NextHop, ROUTE_REF);
    }

    //
    // Dereference the owning entity handle
    //

    Entity = ENTITY_FROM_HANDLE(Info->RouteOwner);

    DEREFERENCE_ENTITY(Entity, ROUTE_REF);


    //
    // Dereference the destination for the route
    //

    if (Info->DestHandle)
    {
        Dest = DEST_FROM_HANDLE(Info->DestHandle);

        DEREFERENCE_DEST(Dest, ROUTE_REF);
    }

    //
    // Free the resources allocated for the route
    //

#if DBG_HDL
    Route->ObjectHeader.TypeSign = ROUTE_FREED;
#endif

    FreeObject(Route);

    return NO_ERROR;
}


DWORD
CreateNextHop (
    IN      PENTITY_INFO                    Entity,
    IN      PRTM_NEXTHOP_INFO               NextHopInfo,
    OUT     PNEXTHOP_INFO                  *NewNextHop
    )

/*++

Routine Description:

    Creates a new nexthop info structure and initializes it.

Arguments:

    Entity      - Entity creating the new nexthop in table,

    NextHopInfo - Nexthop info for the nexthop being created,

    NewNextHop  - Pointer to the new nexthop info structure
                  will be returned through this parameter.

Return Value:

    Status of the operation

--*/

{
    PRTM_NEXTHOP_INFO  HopInfo;
    PNEXTHOP_INFO      NextHop;
    PDEST_INFO         Dest;

    *NewNextHop = NULL;

    //
    // Allocate and initialize a new next hop info
    //

    NextHop = (PNEXTHOP_INFO) AllocNZeroObject(sizeof(NEXTHOP_INFO));
    if (NextHop == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

#if DBG_HDL
    NextHop->ObjectHeader.TypeSign = NEXTHOP_ALLOC;
#endif

    INITIALIZE_NEXTHOP_REFERENCE(NextHop, CREATION_REF);

    HopInfo = &NextHop->NextHopInfo;

    HopInfo->NextHopAddress = NextHopInfo->NextHopAddress;

    HopInfo->NextHopOwner = MAKE_HANDLE_FROM_POINTER(Entity);

    HopInfo->InterfaceIndex = NextHopInfo->InterfaceIndex;

    REFERENCE_ENTITY(Entity, NEXTHOP_REF);

    HopInfo->State = RTM_NEXTHOP_STATE_CREATED;

    HopInfo->Flags = NextHopInfo->Flags;

    HopInfo->EntitySpecificInfo = NextHopInfo->EntitySpecificInfo;

    HopInfo->RemoteNextHop = NextHopInfo->RemoteNextHop;

    //
    // Reference the remote nexthop's destination
    //

    if (HopInfo->RemoteNextHop)
    {
        Dest = DEST_FROM_HANDLE(HopInfo->RemoteNextHop);

        REFERENCE_DEST(Dest, NEXTHOP_REF);
    }

    //
    // Return a pointer to the new initialized nexthop
    //

    *NewNextHop = NextHop;

    return NO_ERROR;
}


VOID
CopyToNextHop (
    IN      PENTITY_INFO                    Entity,
    IN      PRTM_NEXTHOP_INFO               NextHopInfo,
    IN      PNEXTHOP_INFO                   NextHop
    )

/*++

Routine Description:

    Updates an exising nexthop with new nexthop info. Note that
    only the nexthop's owner is allowed to do this.

Arguments:

    Entity      - Entity that is updating the existing nexthop,

    NextHopInfo - Info using which nexthop is being updated,

    NextHop     - Nexthop that is being updated with above info.

Return Value:

    None

--*/

{
    PRTM_NEXTHOP_INFO  HopInfo;
    PDEST_INFO         Dest;

    UNREFERENCED_PARAMETER(Entity);

    HopInfo = &NextHop->NextHopInfo;

    //
    // Update the nexthop with the new information
    //

    HopInfo->Flags = NextHopInfo->Flags;

    HopInfo->EntitySpecificInfo = NextHopInfo->EntitySpecificInfo;
        
    if (HopInfo->RemoteNextHop != NextHopInfo->RemoteNextHop)
    {
        // Dereference the old next hop and reference new one

        if (HopInfo->RemoteNextHop)
        {
            Dest = DEST_FROM_HANDLE(HopInfo->RemoteNextHop);
            DEREFERENCE_DEST(Dest, NEXTHOP_REF);
        }

        HopInfo->RemoteNextHop = NextHopInfo->RemoteNextHop;

        if (HopInfo->RemoteNextHop)
        {
            Dest = DEST_FROM_HANDLE(HopInfo->RemoteNextHop);
            REFERENCE_DEST(Dest, NEXTHOP_REF);
        }
    }

    return;
}


DWORD
DestroyNextHop (
    IN      PNEXTHOP_INFO                   NextHop
    )

/*++

Routine Description:

    Destroys the nexthop by freeing resources and
    deallocating it. This function is called when
    reference count on the nexthop drops to 0.

Arguments:

    Nexthop - Pointer to the nexthop being destroyed.

Return Value:

    None

--*/

{
    PRTM_NEXTHOP_INFO  HopInfo;
    PDEST_INFO         Dest;
    PENTITY_INFO       Entity;


    ASSERT(NextHop->ObjectHeader.RefCount == 0);

    HopInfo = &NextHop->NextHopInfo;

    //
    // Dereference remote nexthop's destination
    //

    if (HopInfo->RemoteNextHop)
    {
        Dest = DEST_FROM_HANDLE(HopInfo->RemoteNextHop);

        DEREFERENCE_DEST(Dest, NEXTHOP_REF);
    }

    Entity = ENTITY_FROM_HANDLE(HopInfo->NextHopOwner);

    DEREFERENCE_ENTITY(Entity, NEXTHOP_REF);

    //
    // Free the memory allocated for the next-hop
    //

#if DBG_HDL
    NextHop->ObjectHeader.TypeSign = NEXTHOP_FREED;
#endif
    
    FreeObject(NextHop);

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\rtmquer.c ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmquer.c

Abstract:

    Contains routines for querying the 
    best route information in RTM.

Author:

    Chaitanya Kodeboyina (chaitk)   24-Aug-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop


DWORD
WINAPI
RtmGetExactMatchDestination (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      PRTM_NET_ADDRESS                DestAddress,
    IN      ULONG                           ProtocolId,
    IN      RTM_VIEW_SET                    TargetViews,
    OUT     PRTM_DEST_INFO                  DestInfo
    )

/*++

Routine Description:

    Queries the route table for a destination with a particular
    network address.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    DestAddress       - Network Address of the destination we want,

    Protocol Id       - Protocol Id that determines the best route
                        information returned in 'DestInfo' param,

    TargetViews       - Views in which the query is executed (a '0'
                        val will eliminate view membership checks),

    DestInfo          - Information related to this dest is returned
                        in this structure for all the views requested.

Return Value:

    Status of the operation

--*/

{
    PADDRFAM_INFO   AddrFamInfo;
    PENTITY_INFO    Entity;
    PDEST_INFO      Dest;
    PLOOKUP_LINKAGE DestData;
    DWORD           Status;

    //
    // Validate the input parameters before the search
    //

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    AddrFamInfo = Entity->OwningAddrFamily;

    ACQUIRE_ROUTE_TABLE_READ_LOCK(AddrFamInfo);

    //
    // Search route table using the dest address
    // 

    Status = SearchInTable(AddrFamInfo->RouteTable,
                           DestAddress->NumBits,
                           DestAddress->AddrBits,
                           NULL,
                           &DestData);

    if (SUCCESS(Status))
    {
        Dest = CONTAINING_RECORD(DestData, DEST_INFO, LookupLinkage);

        //
        // Check if the destination is in any of the input views
        //

        if ((TargetViews == RTM_VIEW_MASK_ANY) || 
            (Dest->BelongsToViews & TargetViews))
        {
            //
            // Get the destination info from the dest
            //

            GetDestInfo(Entity, Dest, ProtocolId, TargetViews, DestInfo);

            Status = NO_ERROR;
        }
        else
        {
            Status = ERROR_NOT_FOUND;
        }
    }

    RELEASE_ROUTE_TABLE_READ_LOCK(AddrFamInfo);

    return Status;
}


DWORD
WINAPI
RtmGetMostSpecificDestination (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      PRTM_NET_ADDRESS                DestAddress,
    IN      ULONG                           ProtocolId,
    IN      RTM_VIEW_SET                    TargetViews,
    OUT     PRTM_DEST_INFO                  DestInfo
    )

/*++

Routine Description:

    Queries the route table for a destination with the best
    (longest) match of a particular network address.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    DestAddress       - Network Address that we are searching for,

    Protocol Id       - Protocol Id that determines the best route
                        information returned in 'DestInfo' param,

    TargetViews       - Views in which the query is executed (a '0'
                        val will eliminate view membership checks),

    DestInfo          - Information related to this dest is returned
                        in this structure for all the views requested.

Return Value:

    Status of the operation

--*/

{
    PADDRFAM_INFO   AddrFamInfo;
    PENTITY_INFO    Entity;
    PDEST_INFO      Dest;
    PLOOKUP_LINKAGE DestData;
    DWORD           Status;

    //
    // Validate the input parameters before the search
    //

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    AddrFamInfo = Entity->OwningAddrFamily;

    Status = ERROR_NOT_FOUND;

    ACQUIRE_ROUTE_TABLE_READ_LOCK(AddrFamInfo);

    //
    // Search the table for the best match in tree
    //

    SearchInTable(AddrFamInfo->RouteTable,
                  DestAddress->NumBits,
                  DestAddress->AddrBits,
                  NULL,
                  &DestData);

    while (DestData)
    {
        Dest = CONTAINING_RECORD(DestData, DEST_INFO, LookupLinkage);

        //
        // Check if the destination is in any of the input views
        //

        if ((TargetViews == RTM_VIEW_MASK_ANY) ||
            (Dest->BelongsToViews & TargetViews))
        {
            //
            // Get the destination info from the dest
            //

            GetDestInfo(Entity, Dest, ProtocolId, TargetViews, DestInfo);

            Status = NO_ERROR;

            break;
        }

        //
        // Get the next best prefix, and see if it is in view
        //

        NextMatchInTable(AddrFamInfo->RouteTable,
                         DestData,
                         &DestData);
    }

    RELEASE_ROUTE_TABLE_READ_LOCK(AddrFamInfo);

    return Status;
}


DWORD
WINAPI
RtmGetLessSpecificDestination (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_DEST_HANDLE                 DestHandle,
    IN      ULONG                           ProtocolId,
    IN      RTM_VIEW_SET                    TargetViews,
    OUT     PRTM_DEST_INFO                  DestInfo
    )

/*++

Routine Description:

    Queries the route table for a destination with the next best
    match (longest) prefix. (for a destination given by handle).

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    DestHandle        - Destination whose next best match we want,

    Protocol Id       - Protocol Id that determines the best route
                        information returned in 'DestInfo' param,

    TargetViews       - Views in which the query is executed (a '0'
                        val will eliminate view membership checks),

    DestInfo          - Information related to this dest is returned
                        in this structure for all the views requested.

Return Value:

    Status of the operation

--*/

{
    PADDRFAM_INFO   AddrFamInfo;
    PENTITY_INFO    Entity;
    PDEST_INFO      Dest;
    PLOOKUP_LINKAGE DestData;
    DWORD           Status;

    //
    // Validate the input parameters before the search
    //

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    AddrFamInfo = Entity->OwningAddrFamily;

    VALIDATE_DEST_HANDLE(DestHandle, &Dest);

    DestData = &Dest->LookupLinkage;

    Status = ERROR_NOT_FOUND;

    ACQUIRE_ROUTE_TABLE_READ_LOCK(AddrFamInfo);

    //
    // Go up the prefix tree till you have a dest in views
    //

    do
    {
        //
        // Get the next best prefix, and see if it is in views
        //

        NextMatchInTable(AddrFamInfo->RouteTable,
                         DestData,
                         &DestData);

        if (DestData == NULL)
        {
            break;
        }

        Dest = CONTAINING_RECORD(DestData, DEST_INFO, LookupLinkage);

        //
        // Check if the destination is in any of the input views
        //

        if ((TargetViews == RTM_VIEW_MASK_ANY) ||
            (Dest->BelongsToViews & TargetViews))
        {
            //
            // Get the destination info from the dest
            //

            GetDestInfo(Entity, Dest, ProtocolId, TargetViews, DestInfo);

            Status = NO_ERROR;

            break;
        }
    }
    while (TRUE);

    RELEASE_ROUTE_TABLE_READ_LOCK(AddrFamInfo);

    return Status;
}


DWORD
WINAPI
RtmGetExactMatchRoute (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      PRTM_NET_ADDRESS                DestAddress,
    IN      RTM_MATCH_FLAGS                 MatchingFlags,
    IN OUT  PRTM_ROUTE_INFO                 RouteInfo,
    IN      ULONG                           InterfaceIndex,
    IN      RTM_VIEW_SET                    TargetViews,
    OUT     PRTM_ROUTE_HANDLE               RouteHandle
    )

/*++

Routine Description:

    Queries the route table for a route that matches certain
    criteria - a network address, preference and/or nexthop.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    DestAddress       - Network Address of the route we want,

    MatchingFlags     - Flags that tell how to match a route,
    
    RouteInfo         - Criteria that we need to match against,

    IntefaceIndex     - Interface on which route should be present
                        in case RTM_MATCH_INTERFACE is specified,

    TargetViews       - Views in which the query is executed (a '0'
                        val will eliminate view membership checks),

    RouteHandle       - Route handle (if an exact match exists),

    RouteInfo         - Information related to this route is retd.

Return Value:

    Status of the operation

--*/

{
    PADDRFAM_INFO   AddrFamInfo;
    PENTITY_INFO    Entity;
    PDEST_INFO      Dest;
    PROUTE_INFO     Route;
    PLOOKUP_LINKAGE DestData;
    PLIST_ENTRY     p;
    DWORD           Status;

    //
    // Validate the input parameters before the search
    //

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    AddrFamInfo = Entity->OwningAddrFamily;

    ACQUIRE_ROUTE_TABLE_READ_LOCK(AddrFamInfo);

    //
    // Search route table using the dest address
    // 

    Status = SearchInTable(AddrFamInfo->RouteTable,
                           DestAddress->NumBits,
                           DestAddress->AddrBits,
                           NULL,
                           &DestData);

    if (SUCCESS(Status))
    {
        Dest = CONTAINING_RECORD(DestData, DEST_INFO, LookupLinkage);

        Status = ERROR_NOT_FOUND;
    
        //
        // Check if the destination matches any input views
        //

        if ((TargetViews == RTM_VIEW_MASK_ANY) ||
            (Dest->BelongsToViews & TargetViews))
        {
#if DBG
            REFERENCE_DEST(Dest, TEMP_USE_REF);
#endif

            // 
            // At this point, we have the dest. So take the
            // dest lock, and release the route table lock.
            //

            ACQUIRE_DEST_READ_LOCK(Dest);

            RELEASE_ROUTE_TABLE_READ_LOCK(AddrFamInfo);

            //
            // Search routes on dest for a matching route
            //
            
            for (p = Dest->RouteList.Flink; p != &Dest->RouteList; p= p->Flink)
            {
                Route = CONTAINING_RECORD(p, ROUTE_INFO, DestLE);

                // Check if this route matches any input views

                if ((TargetViews != RTM_VIEW_MASK_ANY) &&
                    (Route->RouteInfo.BelongsToViews & TargetViews) == 0)
                {
                    continue;
                }

                // Check if this route matches input criteria

                if (MatchingFlags && 
                    !MatchRouteWithCriteria(Route, 
                                            MatchingFlags, 
                                            RouteInfo,
                                            InterfaceIndex))
                    {
                        continue;
                    }

                //
                // Found a matching route - copy the route info
                //

                REFERENCE_ROUTE(Route, HANDLE_REF);

                *RouteHandle = MAKE_HANDLE_FROM_POINTER(Route);


                if (ARGUMENT_PRESENT(RouteInfo))
                {
                    GetRouteInfo(Dest, Route, RouteInfo);
                }

                Status = NO_ERROR;

                break;
            }

            RELEASE_DEST_READ_LOCK(Dest);
#if DBG
            DEREFERENCE_DEST(Dest, TEMP_USE_REF);
#endif
            return Status;
        }
    }
    
    RELEASE_ROUTE_TABLE_READ_LOCK(AddrFamInfo);

    return Status;
}


DWORD
WINAPI
RtmIsBestRoute (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_ROUTE_HANDLE                RouteHandle,
    OUT     PRTM_VIEW_SET                   BestInViews
    )

/*++

Routine Description:

    Gives the set of views in which the route is the best route
    to its destination.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    RouteHandle       - Handle to the route whose info we want, 

    BestInViews       - Views that route is the best one in is retd.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO    Entity;
    PDEST_INFO      Dest;
    PROUTE_INFO     Route;
    UINT            i;

    *BestInViews = 0;

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_ROUTE_HANDLE(RouteHandle, &Route);

    Dest = DEST_FROM_HANDLE(Route->RouteInfo.DestHandle);

    //
    // Set the bit in mask if the route is the best in the corr view
    //

    ACQUIRE_DEST_READ_LOCK(Dest);

    for (i = 0; i < Entity->OwningAddrFamily->NumberOfViews; i++)
    {
        if (Dest->ViewInfo[i].BestRoute == Route)
        {
            *BestInViews |= 
                VIEW_MASK(Entity->OwningAddrFamily->ViewIdFromIndex[i]);
        }
    }

    RELEASE_DEST_READ_LOCK(Dest);

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\rtmregn.c ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmregn.c

Abstract:

    Contains routines for managing registration
    of protocol & management entities with RTM.

Author:

    Chaitanya Kodeboyina (chaitk)   20-Aug-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop


DWORD
WINAPI
RtmRegisterEntity (
    IN      PRTM_ENTITY_INFO                RtmEntityInfo,
    IN      PRTM_ENTITY_EXPORT_METHODS      ExportMethods OPTIONAL,
    IN      RTM_EVENT_CALLBACK              EventCallback,
    IN      BOOL                            ReserveOpaquePtr,
    OUT     PRTM_REGN_PROFILE               RtmRegProfile,
    OUT     PRTM_ENTITY_HANDLE              RtmRegHandle
    )
/*++

Routine Description:

    Registers an entity with an RTM instance for a specific address
    family.

    A registration handle, and a profile of the RTM instance with
    with supported views, number of equal cost NHops / route etc.
    is returned.

    If registration is with a new instance and/or address family,
    then this instance/address family is created in this process.

Arguments:

    RtmEntityInfo     - Information (RtmInstance, Protocol ID etc.)
                        for the entity that is registering here,

    ExportMethods     - List of methods exported by this entity,

    EventCallback     - Callback invoked to inform of certain events
                        like entity registrations, de-registrations,

    ReserveOpaquePtr  - Reserve a ptr in each destination or not,

    RtmRegProfile     - RTM parameters that the entity will use in
                        RTM API calls [eg: No. of equal cost NHOPs],

    RtmRegHandle      - Identification handle for this entity used
                        in all API calls until its de-registration.

Return Value:

    Status of the operation

--*/

{
    PINSTANCE_INFO Instance;
    PADDRFAM_INFO  AddrFamilyInfo;
    PENTITY_INFO   Entity;
    DWORD          Status;

    CHECK_FOR_RTM_API_INITIALIZED();

    TraceEnter("RtmRegisterEntity");

    ACQUIRE_INSTANCES_WRITE_LOCK();

    do 
    {
        //
        // Search (or create) for an instance with the input RtmInstanceId
        //

        Status = GetInstance(RtmEntityInfo->RtmInstanceId,
                             TRUE,
                             &Instance);

        if (Status != NO_ERROR)
        {
            break;
        }


        //
        // Search (or create) for an address family info with input family
        //

        Status = GetAddressFamily(Instance,
                                  RtmEntityInfo->AddressFamily,
                                  TRUE,
                                  &AddrFamilyInfo);

        if (Status != NO_ERROR)
        {
            break;
        }


        //
        // Search (or create) for an entity with input protocol id, instance
        //

        Status = GetEntity(AddrFamilyInfo,
                           RtmEntityInfo->EntityId.EntityId,
                           TRUE,
                           RtmEntityInfo,
                           ReserveOpaquePtr,
                           ExportMethods,
                           EventCallback,
                           &Entity);

        if (Status != NO_ERROR)
        {
            break;
        }


        //
        // Collect all relevant information and build registration profile
        //

        RtmRegProfile->MaxNextHopsInRoute = AddrFamilyInfo->MaxNextHopsInRoute;

        RtmRegProfile->MaxHandlesInEnum = AddrFamilyInfo->MaxHandlesInEnum;

        RtmRegProfile->ViewsSupported = AddrFamilyInfo->ViewsSupported;

        RtmRegProfile->NumberOfViews = AddrFamilyInfo->NumberOfViews;

        //
        // Return a handle to this entity registration block 
        //

        *RtmRegHandle = MAKE_HANDLE_FROM_POINTER(Entity);
    }
    while (FALSE);

    RELEASE_INSTANCES_WRITE_LOCK();

    TraceLeave("RtmRegisterEntity");

    return Status;
}


DWORD
WINAPI
RtmDeregisterEntity (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle
    )
    
/*++

Routine Description:

    Deregisters an entity with its RTM instance and addr family.

    We assume that the entity is responsible for making sure
    that once this call is made, no other RTM calls will be
    made using this entity registration handle. In case such
    a thing happens, it might result in crashing the process.

    We make this assumption for performance reasons - else we
    we have to make sure that the entity handle passed in is
    valid in a try-except block (same with other handles) and
    this will lead to degradation in performance.

Arguments:

    RtmRegHandle      - RTM registration handle for the entity

Return Value:

    Status of the operation

--*/

{
    PADDRFAM_INFO   AddrFamInfo;
    PENTITY_INFO    Entity;
    HANDLE          Event;
    DWORD           Status;

    TraceEnter("RtmDeregisterEntity");

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    //
    // Release all handles opened by entity
    //

    CleanupAfterDeregister(Entity);

    //
    // Mark the entity info as de-registered
    //

    Entity->State = ENTITY_STATE_DEREGISTERED;

    //
    // Make sure no more methods are invoked
    //

    ACQUIRE_ENTITY_METHODS_WRITE_LOCK(Entity);

    // At this time all entity methods are 
    // done - no more methods will be called
    // as we set the state to DEREGISTERED

    RELEASE_ENTITY_METHODS_WRITE_LOCK(Entity);

    //
    // Remove from entity table and inform others
    //

    AddrFamInfo = Entity->OwningAddrFamily;

    ACQUIRE_INSTANCES_WRITE_LOCK();

    //
    // Remove entity from the list of entities
    // even before ref counts on this entity
    // go to zero - this enables the entity to
    // re-register meanwhile as a new entity.
    //

    RemoveEntryList(&Entity->EntityTableLE);

    //
    // Insert in the list of entities to be
    // destroyed on the address family info.
    //

    InsertTailList(&AddrFamInfo->DeregdEntities,
                   &Entity->EntityTableLE);

    InformEntitiesOfEvent(AddrFamInfo->EntityTable,
                          RTM_ENTITY_DEREGISTERED,
                          Entity);

    RELEASE_INSTANCES_WRITE_LOCK();


    DBG_UNREFERENCED_LOCAL_VARIABLE(Event);

#if DBG_REF

    //
    // Create an event on which to block on - this
    // event gets signalled when entity ref is 0.
    //

    Event = CreateEvent(NULL, FALSE, FALSE, NULL);

    ASSERT(Event != NULL);

    Entity->BlockingEvent = Event;

#endif

    //
    // Remove the creation reference on the entity
    //

    DEREFERENCE_ENTITY(Entity, CREATION_REF);


    DBG_UNREFERENCED_LOCAL_VARIABLE(Status);

#if DBG_REF

    //
    // Block until the reference count goes to zero
    //
    
    Status = WaitForSingleObject(Event, INFINITE);

    ASSERT(Status == WAIT_OBJECT_0);

    CloseHandle(Event);

#endif

    TraceLeave("RtmDeregisterEntity");
    
    return NO_ERROR;
}


DWORD
WINAPI
RtmGetRegisteredEntities (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN OUT  PUINT                           NumEntities,
    OUT     PRTM_ENTITY_HANDLE              EntityHandles,
    OUT     PRTM_ENTITY_INFO                EntityInfos OPTIONAL
    )

/*++

Routine Description:

    Retrieves information about all entities registered with an
    RTM instance.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    NumEntities       - Number of entities that can be filled
                        is passed in, and number of entities
                        that exist in this address family is retd,

    RegdEntityHandles - Array to return the entity handles in,

    RegdEntityInfos   - Array to return the entity infos in

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO     Entity;
    PADDRFAM_INFO    AddrFamilyInfo;
    USHORT           RtmInstanceId;
    USHORT           AddressFamily;
    UINT             EntitiesCopied;
    UINT             i;
    PLIST_ENTRY      Entities;
    PLIST_ENTRY      p;
    DWORD            Status;

    TraceEnter("RtmGetRegisteredEntities");

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    AddrFamilyInfo = Entity->OwningAddrFamily;

    //
    // Just cache the instance and address family
    // as it is identical for all entities infos.
    //

#if WRN
    RtmInstanceId = AddressFamily = 0;
#endif

    if (ARGUMENT_PRESENT(EntityInfos))
    {
        RtmInstanceId = AddrFamilyInfo->Instance->RtmInstanceId;
        AddressFamily = AddrFamilyInfo->AddressFamily;
    }

    //
    // Go over the entity table and copy out handles
    // If the OPTIONAL argument 'EntityInfos' is
    // given, copy out entity information as well.
    //

    EntitiesCopied = 0;

    ACQUIRE_INSTANCES_READ_LOCK();

    for (i = 0; (i < ENTITY_TABLE_SIZE) && (EntitiesCopied < *NumEntities);i++)
    {
        Entities = &AddrFamilyInfo->EntityTable[i];

        // 
        // Process the next bucket in the entities table
        //

        for (p = Entities->Flink; p != Entities; p = p->Flink)
        {
            Entity = CONTAINING_RECORD(p, ENTITY_INFO, EntityTableLE);

            //
            // Copy the next entity handle and info to output buffer
            //

            if (Entity->State != ENTITY_STATE_DEREGISTERED)
            {
                EntityHandles[EntitiesCopied]=MAKE_HANDLE_FROM_POINTER(Entity);

                REFERENCE_ENTITY(Entity, HANDLE_REF);

                if (ARGUMENT_PRESENT(EntityInfos))
                {
                    EntityInfos[EntitiesCopied].RtmInstanceId = RtmInstanceId;
                    EntityInfos[EntitiesCopied].AddressFamily = AddressFamily;
                    EntityInfos[EntitiesCopied].EntityId = Entity->EntityId;
                }

                if (++EntitiesCopied == *NumEntities)
                {
                    break;
                }
            }
        }
    }

    //
    // Set output to total entities present,
    // and also the appropriate return value
    //

    if (*NumEntities >= AddrFamilyInfo->NumEntities)
    {
        Status = NO_ERROR;
    }
    else
    {
        Status = ERROR_INSUFFICIENT_BUFFER;
    }

    *NumEntities = AddrFamilyInfo->NumEntities;

    RELEASE_INSTANCES_READ_LOCK();

    TraceLeave("RtmGetRegisteredEntities");

    return Status;
}


DWORD
WINAPI
RtmReleaseEntities (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      UINT                            NumEntities,
    IN      PRTM_ENTITY_HANDLE              EntityHandles
    )

/*++

Routine Description:

    Release (also called de-reference) handles to entities
    obtained in other RTM calls.

Arguments:

    RtmRegHandle   - RTM registration handle for calling entity,

    NumEntities    - Number of handles that are being released,

    EntityHandles  - An array of handles that are being released.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO     Entity;
    UINT             i;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    //
    // Dereference each entity handle in array
    //

    for (i = 0; i < NumEntities; i++)
    {
        Entity = ENTITY_FROM_HANDLE(EntityHandles[i]);

        DEREFERENCE_ENTITY(Entity, HANDLE_REF);
    }

    return NO_ERROR;
}


DWORD
WINAPI
RtmLockDestination(
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_DEST_HANDLE                 DestHandle,
    IN      BOOL                            Exclusive,
    IN      BOOL                            LockDest
    )

/*++

Routine Description:

    Locks/unlocks a destination in the route table. This function 
    is used to guard the dest while opaque ptrs are being changed.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    DestHandle        - Handle to the destination to be locked,

    Exclusive         - TRUE to lock in write mode, else read mode,

    LockDest          - Flag that tells whether to lock or unlock.

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO     Entity;
    PDEST_INFO       Dest;

    DBG_VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    VALIDATE_DEST_HANDLE(DestHandle, &Dest);

    // Lock or unlock the dest as the case may be

    if (LockDest)
    {
        if (Exclusive)
        {
            ACQUIRE_DEST_WRITE_LOCK(Dest);
        }
        else
        {
            ACQUIRE_DEST_READ_LOCK(Dest);
        }
    }
    else
    {
        if (Exclusive)
        {
            RELEASE_DEST_WRITE_LOCK(Dest);
        }
        else
        {
            RELEASE_DEST_READ_LOCK(Dest);
        }
    }

    return NO_ERROR;
}


DWORD
WINAPI
RtmGetOpaqueInformationPointer (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN      RTM_DEST_HANDLE                 DestHandle,
    OUT     PVOID                          *OpaqueInfoPtr
    )

/*++

Routine Description:

    Retrieves a pointer to the opaque info pointer field in a dest
    for this entity, or NULL if entity has not reserved such a ptr
    during registration.

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    DestHandle        - Handle to dest whose opaque info ptr we want,

    OpaqueInfoPtr     - Pointer to opaque info ptr is returned here 

Return Value:

    Status of the operation

--*/

{
    PENTITY_INFO     Entity;
    PDEST_INFO       Dest;
    DWORD            Status;

    TraceEnter("RtmGetOpaqueInformationPointer");

    *OpaqueInfoPtr = NULL;

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    Status = ERROR_NOT_FOUND;

    //
    // If dest is valid and we have an opaque slot
    // reserved, do ptr arithmetic to get the addr
    //

    if (Entity->OpaquePtrOffset != (-1))
    {
        //
        // We do not check if the dest in deleted
        // as the entity will need to access its
        // opaque info even after dest is deleted.
        //

        Dest = DEST_FROM_HANDLE(DestHandle);

        if (Dest)
        {
            *OpaqueInfoPtr = &Dest->OpaqueInfoPtrs[Entity->OpaquePtrOffset];

            Status = NO_ERROR;
        }
        else
        {
            Status = ERROR_INVALID_HANDLE;
        }
    }

    TraceLeave("RtmGetOpaqueInformationPointer");

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\rtmv2\rtmrout.c ===
/*++

Copyright (c) 1997 - 98, Microsoft Corporation

Module Name:

    rtmrout.c

Abstract:

    Contains routines for adding and deleting
    routes in the RTM.

Author:

    Chaitanya Kodeboyina (chaitk)   24-Aug-1998

Revision History:

--*/

#include "pchrtm.h"

#pragma hdrstop


DWORD
WINAPI
RtmAddRouteToDest (
    IN      RTM_ENTITY_HANDLE               RtmRegHandle,
    IN OUT  PRTM_ROUTE_HANDLE               RouteHandle     OPTIONAL,
    IN      PRTM_NET_ADDRESS                DestAddress,
    IN      PRTM_ROUTE_INFO                 RouteInfo,
    IN      ULONG                           TimeToLive,
    IN      RTM_ROUTE_LIST_HANDLE           RouteListHandle OPTIONAL,
    IN      RTM_NOTIFY_FLAGS                ChangeType,
    IN      RTM_NOTIFY_HANDLE               NotifyHandle    OPTIONAL,
    IN OUT  PRTM_ROUTE_CHANGE_FLAGS         ChangeFlags
    )

/*++

Routine Description:

    Adds a new route (or) updates an existing route to a destination. 

Arguments:

    RtmRegHandle      - RTM registration handle for calling entity,

    RouteHandle       - Handle to the route being updated (or NULL)
                        is passed in; Passing a route handle avoids
                        a search in the route table.

                        Handle to new or updated route is returned,

    DestAddress       - Destination network address for this route,

    RouteInfo         - Info for the new route/route being updated,

    TimeToLive        - Time (in ms) after which route is expired,

    RouteListHandle   - Route list to which route is being moved,

    Notify Type       -

    Notify Handle     - 

    ChangeFlags       - Whether to add a new route or update an
                        already existing one; 

                        The type of actual change (i.e) new add or
                        update, and if best route changed is retd,

Return Value:

    Status of the operation

--*/

{
    PADDRFAM_INFO    AddrFamInfo;
    PENTITY_INFO     Entity;
    PROUTE_LIST      RouteList;

    PDEST_INFO       Dest;
    PROUTE_INFO      Route;
    PROUTE_INFO      CurrRoute;
    PROUTE_INFO      BestRoute;

    BOOL             TableWriteLocked;
    LOOKUP_CONTEXT   Context;
    PLOOKUP_LINKAGE  DestData;
    BOOL             DestCreated;

    LONG             PrefChanged;
    PRTM_VIEW_ID     ViewIndices;
    RTM_VIEW_SET     ViewSet;
    RTM_VIEW_SET     BelongedToViews;
    RTM_VIEW_SET     WorseInViews;
    RTM_VIEW_SET     BetterInViews;
    RTM_VIEW_SET     RouteOldBestInViews;
    RTM_VIEW_SET     RouteNewBestInViews;
    RTM_VIEW_SET     RouteCurBestInViews;
    ULONG            RouteInfoChanged;
    ULONG            ForwardingInfoChanged;

    PROUTE_TIMER     TimerContext;

    DWORD            NotifyToCNs;
    PLOOKUP_LINKAGE  NextData;
    PDEST_INFO       NextDest;
    DWORD            ViewsForCT[RTM_NUM_CHANGE_TYPES];
    DWORD            DestMarkedBits;

    PLIST_ENTRY      p;
    UINT             i;
    DWORD            Status;
    BOOL             Success;

    UNREFERENCED_PARAMETER(ChangeType);
    UNREFERENCED_PARAMETER(NotifyHandle);

    VALIDATE_ENTITY_HANDLE(RtmRegHandle, &Entity);

    AddrFamInfo = Entity->OwningAddrFamily;

    //
    // Validate input parameters before taking locks
    //

    // We should be adding only to supported views

    if (RouteInfo->BelongsToViews & ~AddrFamInfo->ViewsSupported)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Check the route list handle for validity

    RouteList = NULL;
    if (ARGUMENT_PRESENT(RouteListHandle))
    {
        VALIDATE_ROUTE_LIST_HANDLE(RouteListHandle, &RouteList);
    }

    DestCreated = FALSE;

#if WRN
    Dest = NULL;
#endif

    //
    // Check if we have a route handle present
    //

    if (ARGUMENT_PRESENT(RouteHandle) && (*RouteHandle))
    {
        //
        // No flags apply here as this is an update
        //

        if (*ChangeFlags != 0)
        {
            return ERROR_INVALID_PARAMETER;
        }

        //
        // Make sure that route handle is valid here
        //

        Route = ROUTE_FROM_HANDLE(*RouteHandle);

        if (Route == NULL)
        {
            return ERROR_INVALID_HANDLE;
        }

        //
        // Do further checking after acquiring lock
        //

        Dest = DEST_FROM_HANDLE(Route->RouteInfo.DestHandle);

        Status = NO_ERROR;

        ACQUIRE_DEST_WRITE_LOCK(Dest);

        //
        // Only the owner has perms to modify the route
        //

        if (Route->RouteInfo.RouteOwner != RtmRegHandle)
        {
            Status = ERROR_ACCESS_DENIED;
        }

        //
        // Was this route already deleted ?
        //

        if (Route->RouteInfo.State == RTM_ROUTE_STATE_DELETED)
        {
            Status = ERROR_INVALID_HANDLE;
        }

        if (Status != NO_ERROR)
        {
            RELEASE_DEST_WRITE_LOCK(Dest);

            return Status;
        }
    }
    else
    {
        //
        // Search the table for the dest for this route
        //

        Route = NULL;

        TableWriteLocked = FALSE;

        ACQUIRE_ROUTE_TABLE_READ_LOCK(AddrFamInfo);

        Status = SearchInTable(AddrFamInfo->RouteTable,
                               DestAddress->NumBits,
                               DestAddress->AddrBits,
                               NULL,
                               &DestData);

        if (SUCCESS(Status))
        {
            Dest = CONTAINING_RECORD(DestData, DEST_INFO, LookupLinkage);
        }
        else
        {
            //
            // We did'nt find a matching destination
            //

            RELEASE_ROUTE_TABLE_READ_LOCK(AddrFamInfo);

            TableWriteLocked = TRUE;

            ACQUIRE_ROUTE_TABLE_WRITE_LOCK(AddrFamInfo);

            //
            // We upgraded our route table lock from a
            // read lock to a write lock. We need to
            // search again to see if the dest has been
            // added after we released the read lock.
            //
            // If we do not find a destination even now,
            // we create a new one and insert into table
            //

            Status = SearchInTable(AddrFamInfo->RouteTable,
                                   DestAddress->NumBits,
                                   DestAddress->AddrBits,
                                   &Context,
                                   &DestData);

            if (SUCCESS(Status))
            {
                Dest = CONTAINING_RECORD(DestData, DEST_INFO, LookupLinkage);
            }
            else
            {
                //
                // Did not find the dest; so create new route and dest
                //

                Status = CreateRoute(Entity, RouteInfo, &Route);
                
                if (SUCCESS(Status))
                {
                    Status = CreateDest(AddrFamInfo, DestAddress, &Dest);

                    if (SUCCESS(Status))
                    {
                        Status = InsertIntoTable(AddrFamInfo->RouteTable,
                                                 DestAddress->NumBits,
                                                 DestAddress->AddrBits,
                                                 &Context,
                                                 &Dest->LookupLinkage);
                    
                        if (SUCCESS(Status))
                        {
                            *ChangeFlags = RTM_ROUTE_CHANGE_NEW;

                            AddrFamInfo->NumDests++;
#if DBG_REF
                            REFERENCE_DEST(Dest, ROUTE_REF);

                            DEREFERENCE_DEST(Dest, CREATION_REF);
#endif
                            DestCreated = TRUE;

                            Route->RouteInfo.DestHandle =
                                        MAKE_HANDLE_FROM_POINTER(Dest);
                        }
                        else
                        {
                            //
                            // Free alloc'ed memory as insert failed
                            //

                            DEREFERENCE_DEST(Dest, CREATION_REF);

                            DEREFERENCE_ROUTE(Route, CREATION_REF);
                        }
                    }
                    else
                    {
                        DEREFERENCE_ROUTE(Route, CREATION_REF);
                    }
                }
            }
        }

        if (SUCCESS(Status))
        {
            ACQUIRE_DEST_WRITE_LOCK(Dest);
        }

        //
        // Release route table lock as you have the dest
        //

        if (!TableWriteLocked)
        {
            RELEASE_ROUTE_TABLE_READ_LOCK(AddrFamInfo);
        }
        else
        {
            RELEASE_ROUTE_TABLE_WRITE_LOCK(AddrFamInfo);
        }
    }

    if (SUCCESS(Status))
    {
        //
        // We have found an existing dest, or created a new one
        // In any case, we have a write lock on the destination
        //

        if (Route == NULL)
        {
            //
            // Do we have to add a new route or can we update ?
            //

            if ((*ChangeFlags & RTM_ROUTE_CHANGE_NEW) == 0)
            {
                //
                // Search for a matching route to update
                //

                for (p = Dest->RouteList.Flink;
                                          p != &Dest->RouteList;
                                                              p = p->Flink)
                {
                    Route = CONTAINING_RECORD(p, ROUTE_INFO, DestLE);

                    //
                    // Normally we consider two routes equal if
                    // they have the same owner and were learnt
                    // from the same neigbour, but if xxx_FIRST
                    // flag is set, we skip the neighbour check
                    //

                    if ((Route->RouteInfo.RouteOwner == RtmRegHandle) &&
                        ((*ChangeFlags & RTM_ROUTE_CHANGE_FIRST) ||
                         (Route->RouteInfo.Neighbour == RouteInfo->Neighbour)))
                    {
                        break;
                    }
                }
            }
            else
            {
                p = &Dest->RouteList;
            }

            if (p == &Dest->RouteList)
            {
                //
                // Need to create a new route on dest
                //

                Status = CreateRoute(Entity, RouteInfo, &Route);

                if (SUCCESS(Status))
                {
                    *ChangeFlags = RTM_ROUTE_CHANGE_NEW;

                    REFERENCE_DEST(Dest, ROUTE_REF);

                    Route->RouteInfo.DestHandle =
                                 MAKE_HANDLE_FROM_POINTER(Dest);
                }
                else
                {
                    RELEASE_DEST_WRITE_LOCK(Dest);

                    return Status;
                }
            }
        }

        //
        // At this point, we either created a new route
        // or found a existing route on the destination
        //

        if (*ChangeFlags == RTM_ROUTE_CHANGE_NEW)
        {
            //
            // New add -> route belonged to no views
            //

            BelongedToViews = 0;

            PrefChanged = +1;

            //
            // Actual insert is done after this block
            //

            InterlockedIncrement(&AddrFamInfo->NumRoutes);
        }
        else
        {
            BelongedToViews = Route->RouteInfo.BelongsToViews;

            PrefChanged = ComparePref(RouteInfo,
                                      &Route->RouteInfo);

            if (PrefChanged != 0)
            {
                Dest->NumRoutes--;

                RemoveEntryList(&Route->DestLE);
            }

            //
            // Update existing route with only information
            // needed to calc the new best route on dest.
            // The rest is updated at end of this function
            // after we determine what info has changed.
            //

            Route->RouteInfo.PrefInfo = RouteInfo->PrefInfo;
            Route->RouteInfo.BelongsToViews = RouteInfo->BelongsToViews;
        }

        if (PrefChanged)
        {
            //
            // Insert the route in sorted order of preference info
            //

            for (p = Dest->RouteList.Flink; p != &Dest->RouteList; p= p->Flink)
            {
                CurrRoute = CONTAINING_RECORD(p, ROUTE_INFO, DestLE);

                if (ComparePref(&CurrRoute->RouteInfo,
                                &Route->RouteInfo) < 0)
                {
                    break;
                }
            }        
                
            InsertTailList(p, &Route->DestLE);

            Dest->NumRoutes++;
        }

        //
        // Return the route handle if not passed in by the caller
        //

        if (ARGUMENT_PRESENT(RouteHandle))
        {
            if (*RouteHandle == NULL)
            {
                *RouteHandle = MAKE_HANDLE_FROM_POINTER(Route);

                REFERENCE_ROUTE(Route, HANDLE_REF);
            }
        }

        //
        // Adjust the best route information in each view
        //

        ViewIndices = AddrFamInfo->ViewIndexFromId;

        //
        // We have 3 cases that this add / update can trigger,
        // In a particular view -
        // 1) Route was the view's best route but not anymore,
        // 2) Route was and is still the best route after add,
        // 3) Route has become this view's "new" best route.
        //
        // If none of the above,
        // 4) Route was not the best before and is still not.
        //

        RouteCurBestInViews = 0;
        RouteNewBestInViews = 0;
        RouteOldBestInViews = 0;

        //
        // Compute all views in which this is the best route
        //

        ViewSet = BelongedToViews;

        for (i = 0; ViewSet && (i < RTM_VIEW_MASK_SIZE); i++)
        {
            if (ViewSet & 0x01)
            {
                // Update dest information in view i

                // Get best route in current view
                BestRoute = Dest->ViewInfo[ViewIndices[i]].BestRoute;

                // Was this the best route in view ?
                if (BestRoute == Route)
                {
                    RouteCurBestInViews |= VIEW_MASK(i);
                }
            }
        
            ViewSet >>= 1;
        }

        //
        // Update views where route preference got better
        //

        if (PrefChanged > 0)
        {
            BetterInViews = RouteInfo->BelongsToViews;
        }
        else
        {
            BetterInViews = ~BelongedToViews & RouteInfo->BelongsToViews;
        }

        Dest->BelongsToViews |= BetterInViews;

        ViewSet = BetterInViews;

        for (i = 0; ViewSet && (i < RTM_VIEW_MASK_SIZE); i++)
        {
            if (ViewSet & 0x01)
            {
                //
                // Update dest information in view i
                //

                // Get best route in current view
                BestRoute = Dest->ViewInfo[ViewIndices[i]].BestRoute;

                //
                // Is route most preferred now, while
                // it was not so before this update ?
                //
                
                if ((!BestRoute) || 
                        ((BestRoute != Route) &&
                            (ComparePref(RouteInfo,
                                         &BestRoute->RouteInfo) > 0)))
                {
                    Dest->ViewInfo[ViewIndices[i]].BestRoute = Route;

                    RouteNewBestInViews |= VIEW_MASK(i);
                }
            }
        
            ViewSet >>= 1;
        }

        //
        // Update in views where the route preference got worse
        //

        if (PrefChanged < 0)
        {
            WorseInViews = RouteCurBestInViews;
        }
        else
        {
            WorseInViews = RouteCurBestInViews & ~RouteInfo->BelongsToViews;
        }

        //
        // In the views that you were the best, update best route
        //

        for (p = Dest->RouteList.Flink; 
                        WorseInViews && (p != &Dest->RouteList); 
                                                          p = p->Flink)
        {
            CurrRoute = CONTAINING_RECORD(p, ROUTE_INFO, DestLE);

            ViewSet = CurrRoute->RouteInfo.BelongsToViews & WorseInViews;

            for (i = 0; ViewSet && (i < RTM_VIEW_MASK_SIZE); i++)
            {
                if (ViewSet & 0x01)
                {
                    // Get best route in current view
                    BestRoute = Dest->ViewInfo[ViewIndices[i]].BestRoute;

                    if (BestRoute != CurrRoute)
                    {
                        Dest->ViewInfo[ViewIndices[i]].BestRoute = CurrRoute;

                        RouteOldBestInViews |= VIEW_MASK(i);
                    }
                }

                ViewSet >>= 1;
            }

            WorseInViews &= ~CurrRoute->RouteInfo.BelongsToViews;
        }

        //
        // For some views, we end up not having a best route
        //

        ViewSet = WorseInViews;

        for (i = 0; ViewSet && (i < RTM_VIEW_MASK_SIZE); i++)
        {
            if (ViewSet & 0x01)
            {
                Dest->ViewInfo[ViewIndices[i]].BestRoute = NULL;

                RouteOldBestInViews |= VIEW_MASK(i);
            }
        
            ViewSet >>= 1;
        }

        Dest->BelongsToViews &= ~WorseInViews;

        //
        // Update the views in which route remains the best
        //

        RouteCurBestInViews &= ~RouteOldBestInViews;

        //
        // The following bit masks as all mutually exclusive
        //
        
        ASSERT(!(RouteOldBestInViews & RouteCurBestInViews));
        ASSERT(!(RouteCurBestInViews & RouteNewBestInViews));
        ASSERT(!(RouteNewBestInViews & RouteOldBestInViews));

        //
        // Compute the views for each change type occurred
        //

        //
        // All views affected by this add are notified
        // -views route belonged to and now belongs to
        //

        ViewsForCT[RTM_CHANGE_TYPE_ID_ALL]  = 
            BelongedToViews | RouteInfo->BelongsToViews;

        //
        // If the route's posn as the best route changed,
        // then it is definitely a best and fwding change
        //

        ViewsForCT[RTM_CHANGE_TYPE_ID_FORWARDING] = 
        ViewsForCT[RTM_CHANGE_TYPE_ID_BEST] = 
            RouteNewBestInViews | RouteOldBestInViews;

        if (RouteCurBestInViews)
        {
            //
            // Figure out what information has changed
            //

            ComputeRouteInfoChange(&Route->RouteInfo,
                                   RouteInfo,
                                   PrefChanged,
                                   &RouteInfoChanged,
                                   &ForwardingInfoChanged);
            //
            // If the route was and is still the best
            // route, then the change types depend on
            // kind of information that was modified.
            //

            ViewsForCT[RTM_CHANGE_TYPE_ID_BEST] |= 
                RouteInfoChanged & RouteCurBestInViews;

            ViewsForCT[RTM_CHANGE_TYPE_ID_FORWARDING] |=
                ForwardingInfoChanged & RouteCurBestInViews;
        }

        //
        // If not a new route, update with new info
        //

        if (*ChangeFlags != RTM_ROUTE_CHANGE_NEW)
        {
            CopyToRoute(Entity, RouteInfo, Route);
        }

        //
        // Update output flags if best route changed
        //

        if (ViewsForCT[RTM_CHANGE_TYPE_ID_BEST])
        {
            *ChangeFlags |= RTM_ROUTE_CHANGE_BEST;
        }

        //
        // Calculate the CNs that need to be notified
        //

        ACQUIRE_NOTIFICATIONS_READ_LOCK(AddrFamInfo);

        if (!DestCreated)
        {
            DestMarkedBits = Dest->DestMarkedBits;
        }
        else
        {
            DestMarkedBits = 0;

            NextMatchInTable(AddrFamInfo->RouteTable,
                             &Dest->LookupLinkage,
                             &NextData);

            if (NextData)
            {
                NextDest = 
                    CONTAINING_RECORD(NextData, DEST_INFO, LookupLinkage);

                DestMarkedBits = NextDest->DestMarkedBits;
            }
        }

        NotifyToCNs = ComputeCNsToBeNotified(AddrFamInfo,
                                             DestMarkedBits,
                                             ViewsForCT);

        //
        // Add to the global change list if required
        //
        
        if (NotifyToCNs)
        {
            AddToChangedDestLists(AddrFamInfo,
                                  Dest,
                                  NotifyToCNs);
        }

        RELEASE_NOTIFICATIONS_READ_LOCK(AddrFamInfo);

        //
        // Remove from old route list, and put in the new one
        //
    
        if (RouteList)
        {
            ACQUIRE_ROUTE_LISTS_WRITE_LOCK(Entity);

            if (!IsListEmpty(&Route->RouteListLE))
            {
                RemoveEntryList(&Route->RouteListLE);
            }
            else
            {
                REFERENCE_ROUTE(Route, LIST_REF);
            }

            InsertTailList(&RouteList->ListHead, &Route->RouteListLE);

            RELEASE_ROUTE_LISTS_WRITE_LOCK(Entity);
        }

        //
        // Set a timer if we want to age out the route
        //

        TimerContext = Route->TimerContext;

        if (TimeToLive == INFINITE)
        {
            Route->TimerContext = NULL;
        }
        else
        {
            Route->TimerContext = AllocMemory(sizeof(ROUTE_TIMER));

            if (Route->TimerContext)
            {
                Route->TimerContext->Route = Route;

                Success = CreateTimerQueueTimer(&Route->TimerContext->Timer,
                                                AddrFamInfo->RouteTimerQueue,
                                                RouteExpiryTimeoutCallback,
                                                Route->TimerContext,
                                                TimeToLive,
                                                0,
                                                0);

                if (Success)
                {
                    REFERENCE_ROUTE(Route, TIMER_REF);
                }
                else
                {
                    Status = GetLastError();

                    FreeMemory(Route->TimerContext);

                    Route->TimerContext = NULL;
                }
            }
        }

#if DBG_TRACE

        //
        // Print the route and the dest in the tracing
        //

        if (TRACING_ENABLED(ROUTE))
        {
            ULONG TempAddr, TempMask;
            
            RTM_IPV4_GET_ADDR_AND_MASK(TempAddr, TempMask, &Dest->DestAddress);
            Trace0(ROUTE, "Adding Route with address: ");
            TracePrintAddress(ROUTE, TempAddr, TempMask);
            Trace2(ROUTE, "Dest = %p and Route = %p\n", Dest, Route);
        }
#endif

        RELEASE_DEST_WRITE_LOCK(Dest);

        //
        // Cancel the timer that was attached to the route
        //

        if (TimerContext)
        {
            if (DeleteTimerQueueTimer(AddrFamInfo->RouteTimerQueue,
                                      TimerContext->Timer,
                                      (HANDLE) -1))
            {
                // Timer cancelled - delete the context

                FreeMemory(TimerContext);

                DEREFERENC