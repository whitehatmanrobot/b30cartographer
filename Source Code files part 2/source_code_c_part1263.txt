OUT  PDNS_MSG_BUF    pMsg
    )
/*++

Routine Description:

    Receives DNS message

Arguments:

    pMsg - message buffer for recv

Return Value:

    ERROR_SUCCESS if successful.
    Error status on failure.

--*/
{
    SOCKET          s;
    PDNS_HEADER     pdnsHeader;
    LONG            err = ERROR_SUCCESS;
    struct timeval  selectTimeout;
    struct fd_set   fdset;

    DNSDBG( RECV, (
        "Enter Dns_RecvUdp( %p )\n",
        pMsg ));

    DNS_ASSERT( !pMsg->fTcp );

    //
    //  verify socket
    //

    s = pMsg->Socket;
    if ( s == 0 || s == INVALID_SOCKET )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    FD_ZERO( &fdset );
    FD_SET( s, &fdset );

    if ( pMsg->Timeout > HARD_TIMEOUT_LIMIT &&
         pMsg->Timeout != ONE_HOUR_TIMEOUT )
    {
        DNSDBG( RECV, (
            "ERROR:  timeout %d, exceeded hard limit.\n",
            pMsg->Timeout ));

        return( ERROR_TIMEOUT );
    }
    selectTimeout.tv_usec = 0;
    selectTimeout.tv_sec = pMsg->Timeout;

    pdnsHeader = &pMsg->MessageHead;


    //
    //  wait for stack to indicate packet reception
    //

    err = select( 0, &fdset, NULL, NULL, &selectTimeout );

    if ( err <= 0 )
    {
        if ( err < 0 )
        {
            //  select error
            err = WSAGetLastError();
            DNS_PRINT(( "ERROR:  select() error = %d\n", err ));
            return( err );
        }
        else
        {
            DNS_PRINT(( "ERROR:  timeout on response %p\n", pMsg ));
            return( ERROR_TIMEOUT );
        }
    }

    //
    //  receive
    //

    err = recvfrom(
                s,
                (PCHAR) pdnsHeader,
                DNS_MAX_UDP_PACKET_BUFFER_LENGTH,
                0,
                (PSOCKADDR) &pMsg->RemoteAddress,
                &pMsg->RemoteAddressLength );

    if ( err == SOCKET_ERROR )
    {
        err = GetLastError();

        Trace_LogRecvEvent(
            pMsg,
            err,
            FALSE       // UDP
            );

        if ( err == WSAECONNRESET )
        {
            //DNS_ASSERT( MSG_REMOTE_IP4(pMsg) != 0 );

            DNSDBG( RECV, (
                "Leave Dns_RecvUdp( %p ) with CONNRESET\n",
                pMsg ));
            return( err );
        }

        //  message sent was too big
        //  sender was in error -- should have sent TCP

        if ( err == WSAEMSGSIZE )
        {
            pMsg->MessageLength = DNS_MAX_UDP_PACKET_BUFFER_LENGTH;

            DnsDbg_Message(
                "ERROR:  Recv UDP packet over 512 bytes.\n",
                pMsg );
        }
        IF_DNSDBG( ANY )
        {
            DnsDbg_Lock();
            DNS_PRINT((
                "ERROR:  recvfrom(sock=%d) of UDP request failed.\n"
                "\tGetLastError() = 0x%08lx.\n",
                socket,
                err ));
            DnsDbg_SockaddrIn(
                "recvfrom failed sockaddr\n",
                &pMsg->RemoteAddress,
                pMsg->RemoteAddressLength );
            DnsDbg_Unlock();
        }
        return( err );
    }
    else
    {
        //DNS_ASSERT( MSG_REMOTE_IP4(pMsg) != 0 );
        DNS_ASSERT( err <= DNS_MAX_UDP_PACKET_BUFFER_LENGTH );
        pMsg->MessageLength = (WORD)err;
        err = ERROR_SUCCESS;
    }

    //
    //  put header fields in host order
    //

    DNS_BYTE_FLIP_HEADER_COUNTS( &pMsg->MessageHead );
    //pMsg->fSwapped = FALSE;

    Trace_LogRecvEvent(
        pMsg,
        0,
        FALSE       // UDP
        );

    IF_DNSDBG( RECV )
    {
        DnsDbg_Message(
            "Received message",
            pMsg );
    }
    return( err );
}




DNS_STATUS
Dns_SendAndRecvUdp(
    IN OUT  PDNS_MSG_BUF        pMsgSend,
    OUT     PDNS_MSG_BUF        pMsgRecv,
    IN      DWORD               dwFlags,
    IN      PIP_ARRAY           aipServers,
    IN OUT  PDNS_NETINFO        pNetInfo
    )
/*++

Routine Description:

    Sends to and waits to recv from remote DNS.

Arguments:

    pMsgSend - message to send

    ppMsgRecv - and reuse

    dwFlags -- query flags

    aipServers - servers to use;  if no adapter info is specified this
        list is used

    pNetInfo -- adapter list DNS server info

Return Value:

    ERROR_SUCCESS if successful response.
    Error status for "best RCODE" response if rcode.
    ERROR_TIMEOUT on timeout.
    Error status on send\recv failure.

--*/
{
    SOCKET          s;
    INT             fcreatedSocket = FALSE;
    INT             retry;
    DWORD           timeout;
    DNS_STATUS      status = ERROR_TIMEOUT;
    //IP6_ADDRESS     recvIp = 0;
    //PIP6_ADDRESS     recvIp = 0;
    IP4_ADDRESS     recvIp = 0;
    DWORD           rcode = 0;
    DWORD           ignoredRcode = 0;
    DWORD           sendCount;
    DWORD           sentCount;
    DWORD           sendTime;
    BOOL            frecvRetry;
    BOOL            fupdate = FALSE;    // prefix
    PDNS_NETINFO    ptempNetInfo = NULL;


    DNSDBG( SEND, (
        "Enter Dns_SendAndRecvUdp()\n"
        "\ttime             %d\n"
        "\tsend msg at      %p\n"
        "\tsocket           %d\n"
        "\trecv msg at      %p\n"
        "\tflags            %08x\n"
        "\tserver IP arrap  %p\n"
        "\tadapter info at  %p\n",
        Dns_GetCurrentTimeInSeconds(),
        pMsgSend,
        pMsgSend->Socket,
        pMsgRecv,
        dwFlags,
        aipServers,
        pNetInfo ));

    //  verify params

    if ( !pMsgSend || !pMsgRecv || (!pNetInfo && !aipServers) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    //  server IP array?  if given build temp adapter info
    //

    if ( aipServers )
    {
        ptempNetInfo = NetInfo_CreateFromIpArray(
                                aipServers,
                                0,          // no single IP
                                FALSE,      // no search info
                                NULL );
        if ( !ptempNetInfo )
        {
            return( DNS_ERROR_NO_MEMORY );
        }
        pNetInfo = ptempNetInfo;
    }

    //  create socket if necessary

    s = pMsgSend->Socket;
    if ( s == 0 || s == INVALID_SOCKET )
    {
        s = Dns_GetUdpSocket();
        if ( s == INVALID_SOCKET )
        {
            status = GetLastError();
            goto Done;
        }
        pMsgSend->Socket = s;
        pMsgSend->fTcp = FALSE;
        fcreatedSocket = TRUE;
    }

    //  if already have TCP socket -- invalid
    //
    //  problem is we either leak TCP socket, or we close
    //  it here and may screw things up at higher level

    else if ( pMsgSend->fTcp )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Done;
    }

    pMsgRecv->Socket = s;
    pMsgRecv->fTcp = FALSE;

    //  determine UPDATE or standard QUERY

    fupdate = ( pMsgSend->MessageHead.Opcode == DNS_OPCODE_UPDATE );

    //
    //  loop sending until
    //      - receive successful response
    //      or
    //      - receive errors response from all servers
    //      or
    //      - reach final timeout on all servers
    //
    //
    //  DCR:  should support setting of timeouts on individual queries
    //

    retry = 0;
    sendCount = 0;

    while ( 1 )
    {
        if ( fupdate )
        {
            timeout = UpdateTimeouts[retry];
        }
        else
        {
            if ( dwFlags & DNS_QUERY_USE_QUICK_TIMEOUTS )
            {
                timeout = g_QuickQueryTimeouts[retry];
            }
            else
            {
                timeout = g_QueryTimeouts[retry];
            }
        }

        //
        //  zero timeout indicates end of retries for this query type
        //

        if ( timeout == 0 )
        {
            //  save timeout for adapter?
            //
            //  if multiple adapters and some timed out and some
            //  didn't then saving timeout is relevant
            //
            //  DCR:  this doesn't make much sense
            //      the actual test i moved inside the function
        
            if ( pNetInfo &&
                 pNetInfo->AdapterCount > 1 &&
                 ignoredRcode &&
                 status == ERROR_TIMEOUT )
            {
                resetOnFinalTimeout( pNetInfo );
            }
            break;
        }

        //
        //  send to best DNS servers in adapter list
        //      - servers sent to varies according to retry
        //      - send in previous timeout, if some servers did not respond
        //

        status = SendUdpToNextDnsServers(
                    pMsgSend,
                    pNetInfo,
                    retry,
                    sendCount ? pMsgRecv->Timeout : 0,
                    & sendCount );

        sentCount = sendCount;

        if ( status != ERROR_SUCCESS )
        {
            //  if no more servers to send to, done
            DNSDBG( RECV, (
                "No more DNS servers to send message %p\n"
                "\tprevious RCODE = %d\n",
                pMsgSend,
                ignoredRcode ));
            goto ErrorReturn;
        }
        retry++;
        recvIp = 0;
        rcode = DNS_RCODE_NO_ERROR;
        pMsgRecv->Timeout = timeout;
        DNS_ASSERT( sendCount != 0 );

        frecvRetry = FALSE;
        sendTime = GetCurrentTimeInSeconds();

        //
        //  receive response
        //
        //  note:  the loop is strictly to allow us to drop back into
        //  receive if one server is misbehaving;
        //  in that case we go back into the receive without resending
        //  to allow other servers to respond
        //

        while ( sendCount )
        {
            //
            //  if have to retry recv, adjust down timeout
            //      - note, one second granularity is handled by
            //      rounding up at zero so we wait 0-1s beyond official
            //      timeout value
            //
            //  DCR:  calculate timeouts in ms?
            //

            if ( frecvRetry )
            {
                DWORD  timeLeft;

                timeLeft = timeout + sendTime - GetCurrentTimeInSeconds();

                if ( (LONG)timeLeft < 0 )
                {
                    status = ERROR_TIMEOUT;
                    break;
                }
                else if ( timeLeft == 0 )
                {
                    timeLeft = 1;
                }
                pMsgRecv->Timeout = timeLeft;
            }
            frecvRetry = TRUE;

            status = Dns_RecvUdp( pMsgRecv );

            recvIp = MSG_REMOTE_IP4(pMsgRecv);

            //  recv wait completed
            //      - if timeout, commence next retry
            //      - if CONNRESET
            //          - indicate NO server on IP
            //          - back to recv if more DNS servers outstanding,
            //      - if success, verify packet

            if ( status != ERROR_SUCCESS )
            {
                if ( status == ERROR_TIMEOUT )
                {
                    break;
                }
                if ( status == WSAECONNRESET )
                {
                    ResetDnsServerPriority(
                        pNetInfo,
                        recvIp,
                        status );
#if 0
                    // old deal when didn't know about IP back in sockaddr
                    if ( sendCount == 1 )
                    {
                        pMsgRecv->Timeout = NO_DNS_PRIORITY_DROP;
                        status = ERROR_TIMEOUT;
                        break;
                    }
#endif
                    sendCount--;
                    continue;
                }
            }
            DNS_ASSERT( recvIp != 0 );

            //  check XID match

            if ( pMsgRecv->MessageHead.Xid != pMsgSend->MessageHead.Xid )
            {
                DNS_PRINT(( "WARNING:  Incorrect XID in response. Ignoring.\n" ));
                continue;
            }

            //  check DNS server IP match
            //  this may or may NOT be desired

            if ( fQueryIpMatching &&
                 sentCount == 1 &&
                 MSG_REMOTE_IP4(pMsgSend) != recvIp )
            {
                DNS_PRINT((
                    "WARNING:  Ignoring response from %08x to query %p\n"
                    "\tIP does not match queried IP %08x\n",
                    recvIp,
                    pMsgSend,
                    MSG_REMOTE_IP4(pMsgSend)
                    ));
                continue;
            }

            //  valid receive, drop outstanding send count

            sendCount--;

            //
            //  check question match
            //      - this is "Maggs Bug" check
            //      - ASSERT here just to investigate issue locally
            //      and make sure check is not bogus
            //      - specifically doing after sendCount decrement
            //      as this server will NOT send us a valid response
            //      - some servers don't reply with question so ignore
            //      if QuestionCount == 0
            //      

            if ( pMsgRecv->MessageHead.QuestionCount != 0
                    &&
                 !Dns_IsSamePacketQuestion(
                    pMsgRecv,
                    pMsgSend ))
            {
                DNS_PRINT((
                    "ERROR:  Bad question response from server %08x!\n"
                    "\tXID match, but question does not match question sent!\n",
                    recvIp ));
                DNS_ASSERT( FALSE );
                continue;
            }

            //  suck out RCODE

            rcode = pMsgRecv->MessageHead.ResponseCode;

            //
            //  good response?
            //
            //  special case AUTH-EMPTY and delegations
            //
            //      - AUTH-EMPTY gets similar treatment to name error
            //      (this adapter can be considered to be finished)
            //
            //      - referrals can be treated like SERVER_FAILURE
            //      (avoid this server for rest of query;  server may
            //      be fine for direct lookup, so don't drop priority)
            //

            //
            //  DCR_CLEANUP:   functionalize packet-categorization
            //      this would be standard errors
            //      plus AUTH-EMPTY versus referral
            //      plus OPT issues, etc
            //      could be called from TCP side also
            //
            //      then would have separate determination about whether
            //      packet was terminal (below)
            //

            if ( rcode == DNS_RCODE_NO_ERROR )
            {
                if ( pMsgRecv->MessageHead.AnswerCount != 0 || fupdate )
                {
                    goto GoodRecv;
                }

                //
                //  auth-empty
                //      - authoritative
                //      - or from cache, recursive response (hence not delegation)
                //
                //  note:  using dummy RCODE here as "ignored RCODE" serves
                //      the role of "best saved status" and roughly
                //      prioritizes in the way we want
                //
                //  DCR:  could change to "best saved status" as mapping is
                //      pretty much the same;  would explicitly have to
                //      check 

                if ( pMsgRecv->MessageHead.Authoritative == 1 ||
                     ( pMsgRecv->MessageHead.RecursionAvailable == 1 &&
                       pMsgRecv->MessageHead.RecursionDesired ) )
                {
                    DNSDBG( RECV, (
                        "Recv AUTH-EMPTY response from %s\n",
                        IP_STRING(recvIp) ));
                    rcode = DNS_RCODE_AUTH_EMPTY_RESPONSE;
                    status = DNS_INFO_NO_RECORDS;
                }

                //  referral

                else if ( pMsgRecv->MessageHead.RecursionAvailable == 0 )
                {
                    DNSDBG( RECV, (
                        "Recv referral response from %s\n",
                        IP_STRING(recvIp) ));

                    rcode = DNS_RCODE_SERVER_FAILURE;
                    status = DNS_ERROR_REFERRAL_RESPONSE;
                }

                //  bogus (bad packet) response

                else
                {
                    rcode = DNS_RCODE_SERVER_FAILURE;
                    status = DNS_ERROR_BAD_PACKET;
                }
            }
            else
            {
                status = Dns_MapRcodeToStatus( (UCHAR)rcode );
            }

            //
            //  OPT failure screening
            //
            //  DCR:  FORMERR overload on OPT for update
            //      unless we read result to see if OPT, no way
            //      to determine if this is update problem or
            //      OPT problem
            //
            //      - note, that checking if in list doesn't work because
            //      of MT issue (another query adds setting)
            //
            //      - could be fixed by setting flag in network info
            //      

            if ( rcode == DNS_RCODE_FORMAT_ERROR &&
                 !fupdate )
            {
                Dns_SetServerOptExclude( recvIp );

                //  redo send but explicitly force OPT excluse

                Dns_SendEx(
                    pMsgSend,
                    recvIp,
                    TRUE        // exclude OPT
                    );

                sendCount++;
                continue;
            }

            //
            //  error RCODE do NOT terminate query
            //      - SERVER_FAILUREs
            //      - malfunctioning server
            //      - disjoint nets \ DNS namespace issues
            //
            //  RCODE error removes particular server from further consideration
            //  during THIS query
            //
            //  generally the higher RCODEs are more interesting
            //      NAME_ERROR > SERVER_FAILURE
            //      and
            //      update RCODEs > NAME_ERROR
            //  save the highest as return when no ERROR_SUCCESS response
            //
            //  however for query NAME_ERROR is the highest RCODE,
            //  IF it is received on all adapters (if not REFUSED on one
            //  adapter may indicate that there really is a name)
            //
            //  for UPDATE, REFUSED and higher are terminal RCODEs.
            //  downlevel servers (non-UPDATE-aware) servers would give
            //  FORMERR or NOTIMPL, so these are either valid responses or
            //  the zone has a completely busted server which must be detected
            //  and removed
            //
            //
            //  DCR_CLEANUP:   functionalize packet-termination
            //      essentially is this type of packet terminal for
            //      this query;
            //      could be called from TCP side also
            //

            if ( rcode > ignoredRcode )
            {
                ignoredRcode = rcode;
            }

            //
            //  reset server priority for good recv
            //      - return ERROR_SUCCESS unless all adapters
            //      are 
            //      

            status = ResetDnsServerPriority(
                        pNetInfo,
                        recvIp,
                        status );

            //
            //  if all adapters are done (NAME_ERROR or NO_RECORDS)
            //      - return NAME_ERROR\NO_RECORDS rcode
            //          NO_RECORDS highest priority
            //          then NAME_ERROR
            //          then anything else

            if ( status == DNS_ERROR_RCODE_NAME_ERROR )
            {
                if ( !fupdate && ignoredRcode != DNS_RCODE_AUTH_EMPTY_RESPONSE )
                {
                    ignoredRcode = DNS_RCODE_NAME_ERROR;
                }
                goto ErrorReturn;
            }

            //
            //  update RCODEs are terminal
            //

            if ( fupdate && rcode >= DNS_RCODE_REFUSED )
            {
                goto ErrorReturn;
            }

            // continue wait for any other outstanding servers
        }

        DNSDBG( RECV, (
            "Failed retry = %d for message %p\n"
            "\tstatus           = %d\n"
            "\ttimeout          = %d\n"
            "\tservers out      = %d\n"
            "\tlast rcode       = %d\n"
            "\tignored RCODE    = %d\n\n",
            (retry - 1),
            pMsgSend,
            status,
            timeout,
            sendCount,
            rcode,
            ignoredRcode ));
        continue;

    }   //  end loop sending/recving packets

    //  
    //  falls here on retry exhausted
    //
    //  note that any ignored RCODE takes precendence over failing
    //  status (which may be winsock error, timeout, or bogus
    //  NAME_ERROR from resetServerPriorities())
    //

ErrorReturn:

    //  this can also hit on winsock error in DnsSend()
    //
    //DNS_ASSERT( ignoredRcode  ||  status == ERROR_TIMEOUT );

    //
    //  error responses from all servers or timeouts
    //

    DNSDBG( RECV, (
        "Error or timeouts from all servers for message %p\n"
        "\treturning RCODE = %d\n",
        pMsgSend,
        ignoredRcode ));

    if ( ignoredRcode )
    {
        //  empty-auth reponse is tracked with bogus RCODE,
        //  switch to status code -- DNS_INFO_NO_RECORDS

        if ( !fupdate && ignoredRcode == DNS_RCODE_AUTH_EMPTY_RESPONSE )
        {
            status = DNS_INFO_NO_RECORDS;
        }
        else
        {
            status = Dns_MapRcodeToStatus( (UCHAR)ignoredRcode );
        }
    }
    goto Done;


GoodRecv:

    ResetDnsServerPriority(
        pNetInfo,
        recvIp,
        rcode );

    DNSDBG( RECV, (
        "Recv'd response for query at %p from DNS %s\n",
        pMsgSend,
        IP_STRING(recvIp) ));

Done:

    //
    //  if created socket -- close it
    //
    //  DCR_ENHANCE:  allow for possibility of keeping socket alive
    //

    if ( fcreatedSocket )
    {
        DNSDBG( SEND, (
            "Closing socket %d after recv.\n", s ));

        Dns_ReturnUdpSocket( s );
        pMsgSend->Socket = 0;
        pMsgRecv->Socket = 0;
    }

    IF_DNSDBG( RECV )
    {
        DNSDBG( SEND, (
            "Leave Dns_SendAndRecvUdp()\n"
            "\tstatus       = %d\n"
            "\ttime         = %d\n"
            "\tsend msg     = %p\n"
            "\trecv msg     = %p\n",
            status,
            Dns_GetCurrentTimeInSeconds(),
            pMsgSend,
            pMsgRecv ));

        DnsDbg_NetworkInfo(
            "Network info after UDP recv\n",
            pNetInfo );
    }

    //  if allocated adapter list free it

    if ( ptempNetInfo )
    {
        NetInfo_Free( ptempNetInfo );
    }

    //  should not return NXRRSET except on update

    ASSERT( fupdate || status != DNS_ERROR_RCODE_NXRRSET );

    return( status );
}



DNS_STATUS
Dns_SendAndRecvMulticast(
    IN OUT  PDNS_MSG_BUF        pMsgSend,
    OUT     PDNS_MSG_BUF        pMsgRecv,
    IN OUT  PDNS_NETINFO        pNetInfo OPTIONAL
    )
/*++

Routine Description:

    Sends to and waits to recv from remote DNS.

Arguments:

    pMsgSend - message to send

    ppMsgRecv - and reuse

    pNetInfo -- adapter list DNS server info

    DCR -   pNetInfo parameter could be leveraged to
            identify specific networks to target a multicast
            query against. For example, there could be a multihomed
            machine that is configured to only multicast on one
            of many adapters, thus filtering out useless mDNS packets.

Return Value:

    ERROR_SUCCESS if successful response.
    NAME_ERROR on timeout.
    Error status on send\recv failure.

--*/
{
    SOCKET      s;
    INT         fcreatedSocket = FALSE;
    INT         retry;
    DWORD       timeout;
    DNS_STATUS  status = ERROR_TIMEOUT;
    IP_ADDRESS  recvIp = 0;
    DWORD       rcode = 0;
    DWORD       ignoredRcode = 0;

    DNSDBG( SEND, (
        "Enter Dns_SendAndRecvMulticast()\n"
        "\tsend msg at      %p\n"
        "\tsocket           %d\n"
        "\trecv msg at      %p\n",
        pMsgSend,
        pMsgSend->Socket,
        pMsgRecv ));

    //  verify params

    if ( !pMsgSend || !pMsgRecv )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    if ( pMsgSend->MessageHead.Opcode == DNS_OPCODE_UPDATE )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //  create socket if necessary

    s = pMsgSend->Socket;
    if ( s == 0 || s == INVALID_SOCKET )
    {
        s = Dns_CreateSocket(
                SOCK_DGRAM,
                INADDR_ANY,
                0 );
        if ( s == INVALID_SOCKET )
        {
            status = GetLastError();
            goto Done;
        }
        pMsgSend->Socket = s;
        pMsgSend->fTcp = FALSE;
        fcreatedSocket = TRUE;
    }

    //  if already have TCP socket -- invalid
    //
    //  problem is we either leak TCP socket, or we close
    //  it here and may screw things up at higher level

    else if ( pMsgSend->fTcp )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Done;
    }

    pMsgRecv->Socket = s;
    pMsgRecv->fTcp = FALSE;

    //
    //  loop sending until
    //      - receive successful response
    //      or
    //      - receive errors response from all servers
    //      or
    //      - reach final timeout on all servers
    //

    retry = 0;

    while ( 1 )
    {
        timeout = g_MulticastQueryTimeouts[retry];

        //
        // zero timeout indicates end of retries for this query type
        //

        if ( timeout == 0 )
        {
            break;
        }

        //
        //  send to multicast DNS address
        //

        if ( retry == 0 )
        {
            Dns_InitializeMsgRemoteSockaddr( pMsgSend, MULTICAST_DNS_RADDR );
            Dns_Send( pMsgSend );
        }
        else
        {
            Dns_Send( pMsgSend );
        }

        retry++;
        recvIp = 0;
        rcode = DNS_RCODE_NO_ERROR;
        pMsgRecv->Timeout = timeout;

        //
        //  receive response
        //
        //  note:  the loop is strictly to allow us to drop back into
        //  receive if one server is misbehaving;
        //  in that case we go back into the receive without resending
        //  to allow other servers to respond
        //

        status = Dns_RecvUdp( pMsgRecv );

        //  recv wait completed
        //      - if timeout, commence next retry
        //      - if CONNRESET
        //          - back to recv if more DNS servers outstanding,
        //          - otherwise equivalent treat as timeout, except with
        //          very long timeout
        //      - if success, verify packet

        if ( status != ERROR_SUCCESS )
        {
            if ( status == ERROR_TIMEOUT )
            {
                continue;
            }
            if ( status == WSAECONNRESET )
            {
                pMsgRecv->Timeout = NO_DNS_PRIORITY_DROP;
                status = ERROR_TIMEOUT;
                continue;
            }
            goto Done;
        }

        //  check XID match

        if ( pMsgRecv->MessageHead.Xid != pMsgSend->MessageHead.Xid )
        {
            DNS_PRINT(( "WARNING:  Incorrect XID in response. Ignoring.\n" ));
            continue;
        }

        //  suck out the IP of the machine that responded
        recvIp = MSG_REMOTE_IP4(pMsgRecv);

        //  suck out RCODE
        rcode = pMsgRecv->MessageHead.ResponseCode;

        //
        //  good response?
        //
        //  special case AUTH-EMPTY and delegations
        //
        //      - AUTH-EMPTY gets similar treatment to name error
        //      (this adapter can be considered to be finished)
        //
        //      - referrals can be treated like SERVER_FAILURE
        //      (avoid this server for rest of query;  server may
        //      be fine for direct lookup, so don't drop priority)
        //

        if ( rcode == DNS_RCODE_NO_ERROR )
        {
            if ( pMsgRecv->MessageHead.AnswerCount != 0 )
            {
                goto Done;
            }

            //  auth-empty

            if ( pMsgRecv->MessageHead.Authoritative == 1 )
            {
                DNSDBG( RECV, (
                    "Recv AUTH-EMPTY response from %s\n",
                    IP_STRING(recvIp) ));
                rcode = DNS_RCODE_AUTH_EMPTY_RESPONSE;
            }
        }
    }   //  end loop sending/recving packets

Done:

    //
    //  if created socket -- close it
    //
    //  DCR_ENHANCE:  allow for possibility of keeping socket alive
    //

    if ( fcreatedSocket )
    {
        DNSDBG( SEND, (
            "Closing socket %d after recv.\n", s ));
        Dns_CloseSocket( s );
        pMsgSend->Socket = 0;
        pMsgRecv->Socket = 0;
    }

    IF_DNSDBG( RECV )
    {
        DNSDBG( SEND, (
            "Leave Dns_SendAndRecvMulticast()\n"
            "\tstatus     = %d\n"
            "\ttime       = %d\n"
            "\tsend msg at  %p\n"
            "\trecv msg at  %p\n",
            status,
            Dns_GetCurrentTimeInSeconds(),
            pMsgSend,
            pMsgRecv ));
    }

    if ( status == ERROR_TIMEOUT )
    {
        status = DNS_ERROR_RCODE_NAME_ERROR;
    }

    return( status );
}



//
//  TCP routines
//

DNS_STATUS
Dns_OpenTcpConnectionAndSend(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      IP_ADDRESS      ipServer,
    IN      BOOL            fBlocking
    )
/*++

Routine Description:

    Connect via TCP to desired server.

Arguments:

    pMsg -- message info to set with connection socket

    ipServer -- IP of DNS server to connect to

    fBlocking -- blocking connection

Return Value:

    TRUE if successful.
    FALSE on connect error.

--*/
{
    SOCKET  s;
    INT     err;

    //  Note:  currently blocking flag is unused and default to blocking
    //      connection;  later want to allow async hence flag

    UNREFERENCED_PARAMETER( fBlocking );

    //
    //  setup a TCP socket
    //      - INADDR_ANY -- let stack select source IP
    //

    s = Dns_CreateSocket(
            SOCK_STREAM,
            INADDR_ANY,     // any address
            0               // any port
            );
    if ( s == INVALID_SOCKET )
    {
        DNS_PRINT((
            "ERROR:  unable to create TCP socket to create TCP"
            "\tconnection to %s.\n",
            IP_STRING( ipServer ) ));

        pMsg->Socket = 0;
        err = WSAGetLastError();
        if ( !err )
        {
            DNS_ASSERT( FALSE );
            err = WSAENOTSOCK;
        }
        return( err );
    }

    //
    //  set TCP params
    //      - do before connect(), so can directly use sockaddr buffer
    //

    pMsg->fTcp = TRUE;
    Dns_InitializeMsgRemoteSockaddr( pMsg, ipServer );

    //
    //  connect
    //

    err = connect(
            s,
            (struct sockaddr *) &pMsg->RemoteAddress,
            sizeof( SOCKADDR_IN )
            );
    if ( err )
    {
        PCHAR   pchIpString;

        err = GetLastError();
        pchIpString = IP_STRING( MSG_REMOTE_IP4(pMsg) );

        DNS_LOG_EVENT(
            DNS_EVENT_CANNOT_CONNECT_TO_SERVER,
            1,
            &pchIpString,
            err );

        DNSDBG( TCP, (
            "Unable to establish TCP connection to %s.\n"
            "\tstatus = %d\n",
            pchIpString,
            err ));

        Dns_CloseSocket( s );
        pMsg->Socket = 0;
        if ( !err )
        {
            err = WSAENOTCONN;
        }
        return( err );
    }

    DNSDBG( TCP, (
        "Connected to %s for message at %p.\n"
        "\tsocket = %d\n",
        IP_STRING( MSG_REMOTE_IP4(pMsg) ),
        pMsg,
        s ));

    pMsg->Socket = s;

    //
    //  send desired packet
    //

    err = Dns_Send( pMsg );

    return( (DNS_STATUS)err );

}   // Dns_OpenTcpConnectionAndSend



DNS_STATUS
Dns_RecvTcp(
    IN OUT  PDNS_MSG_BUF    pMsg
    )
/*++

Routine Description:

    Receive TCP DNS message.

Arguments:

    pMsg - message info buffer to receive packet;  must contain connected
            TCP socket

Return Value:

    ERROR_SUCCESS if successfully receive a message.
    Error code on failure.

--*/
{
    PCHAR   pchrecv;        // ptr to recv location
    INT     recvLength;     // length left to recv()
    SOCKET  socket;
    INT     err;
    WORD    messageLength;
    struct timeval  selectTimeout;
    struct fd_set   fdset;

    DNS_ASSERT( pMsg );

    socket = pMsg->Socket;

    DNSDBG( RECV, (
        "Enter Dns_RecvTcp( %p )\n"
        "\tRecv on socket = %d.\n"
        "\tBytes left to receive = %d\n"
        "\tTimeout = %d\n",
        pMsg,
        socket,
        pMsg->BytesToReceive,
        pMsg->Timeout
        ));

    //
    //  verify socket, setup fd_set and select timeout
    //

    if ( socket == 0 || socket == INVALID_SOCKET )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    FD_ZERO( &fdset );
    FD_SET( socket, &fdset );

    selectTimeout.tv_usec = 0;
    selectTimeout.tv_sec = pMsg->Timeout;

    //
    //  new message -- set to receive message length
    //      - reusing buffer
    //      - new buffer
    //
    //  continuing receive of message
    //

    if ( !pMsg->pchRecv )
    {
        DNS_ASSERT( pMsg->fMessageComplete || pMsg->MessageLength == 0 );

        pchrecv = (PCHAR) &pMsg->MessageLength;
        recvLength = (INT) sizeof( WORD );
    }
    else
    {
        pchrecv = (PCHAR) pMsg->pchRecv;
        recvLength = (INT) pMsg->BytesToReceive;
    }
    DNS_ASSERT( recvLength );


    //
    //  loop until receive the entire message
    //

    while ( 1 )
    {
        //
        //  wait for stack to indicate packet reception
        //

        err = select( 0, &fdset, NULL, NULL, &selectTimeout );
        if ( err <= 0 )
        {
            if ( err < 0 )
            {
                //  select error
                err = WSAGetLastError();
                DNS_PRINT(( "ERROR:  select() error = %p\n", err ));
                return( err );
            }
            else
            {
                Trace_LogRecvEvent(
                    pMsg,
                    ERROR_TIMEOUT,
                    TRUE        // TCP
                    );

                DNS_PRINT(( "ERROR:  timeout on response %p\n", pMsg ));
                return( ERROR_TIMEOUT );
            }
        }

        //
        //  Only recv() exactly as much data as indicated.
        //  Another message could follow during zone transfer.
        //

        err = recv(
                socket,
                pchrecv,
                recvLength,
                0 );

        DNSDBG( TCP, (
            "\nRecv'd %d bytes on TCP socket %d\n",
            err,
            socket ));

        //
        //  TCP FIN received -- error in the middle of a message.
        //

        if ( err == 0 )
        {
            goto FinReceived;
        }

        //
        //  recv error
        //      - perfectly reasonable if shutting down
        //      - otherwise actual recv() error
        //

        if ( err == SOCKET_ERROR )
        {
            goto SockError;
        }

        //
        //  update buffer params
        //

        recvLength -= err;
        pchrecv += err;

        DNS_ASSERT( recvLength >= 0 );

        //
        //  received message or message length
        //

        if ( recvLength == 0 )
        {
            //  done receiving message

            if ( pchrecv > (PCHAR)&pMsg->MessageHead )
            {
                break;
            }

            //
            //  recv'd message length, setup to recv() message
            //      - byte flip length
            //      - continue reception with this length
            //

            DNS_ASSERT( pchrecv == (PCHAR)&pMsg->MessageHead );

            messageLength = pMsg->MessageLength;
            pMsg->MessageLength = messageLength = ntohs( messageLength );
            if ( messageLength < sizeof(DNS_HEADER) )
            {
                DNS_PRINT((
                    "ERROR:  Received TCP message with bad message"
                    " length %d.\n",
                    messageLength ));

                goto BadTcpMessage;
            }
            recvLength = messageLength;

            DNSDBG( TCP, (
                "Received TCP message length %d, on socket %d,\n"
                "\tfor msg at %p.\n",
                messageLength,
                socket,
                pMsg ));

            //  starting recv of valid message length

            if ( messageLength <= pMsg->BufferLength )
            {
                continue;
            }

            //  note:  currently do not realloc

            goto BadTcpMessage;
#if 0
            //
            //  DCR:  allow TCP realloc
            //      - change call signature OR
            //      - return pMsg with ptr to realloced
            //      perhaps better to ignore and do 64K buffer all the time
            //
            //  realloc, if existing message too small
            //

            pMsg = Dns_ReallocateTcpMessage( pMsg, messageLength );
            if ( !pMsg )
            {
                return( GetLastError() );
            }
#endif
        }
    }

    //
    //  Message received
    //  recv ptr serves as flag, clear to start new message on reuse
    //

    pMsg->fMessageComplete = TRUE;
    pMsg->pchRecv = NULL;

    //
    //  return message information
    //      - flip count bytes
    //

    DNS_BYTE_FLIP_HEADER_COUNTS( &pMsg->MessageHead );

    Trace_LogRecvEvent(
        pMsg,
        0,
        TRUE        // TCP
        );

    IF_DNSDBG( RECV )
    {
        DnsDbg_Message(
            "Received TCP packet",
            pMsg );
    }
    return( ERROR_SUCCESS );


SockError:

    err = GetLastError();

#if 0
    //
    //  note:  want non-blocking sockets if doing full async
    //
    //  WSAEWOULD block is NORMAL return for message not fully recv'd.
    //      - save state of message reception
    //
    //  We use non-blocking sockets, so bad client (that fails to complete
    //  message) doesn't hang TCP receiver.
    //

    if ( err == WSAEWOULDBLOCK )
    {
        pMsg->pchRecv = pchrecv;
        pMsg->BytesToReceive = recvLength;

        DNSDBG( TCP, (
            "Leave ReceiveTcpMessage() after WSAEWOULDBLOCK.\n"
            "\tSocket=%d, Msg=%p\n"
            "\tBytes left to receive = %d\n",
            socket,
            pMsg,
            pMsg->BytesToReceive
            ));
        goto CleanupConnection;
    }
#endif

    //
    //  cancelled connection
    //      -- perfectly legal, question is why
    //

    if ( pchrecv == (PCHAR) &pMsg->MessageLength
            &&
          ( err == WSAESHUTDOWN ||
            err == WSAECONNABORTED ||
            err == WSAECONNRESET ) )
    {
        DNSDBG( TCP, (
            "WARNING:  Recv RESET (%d) on socket %d\n",
            err,
            socket ));
        goto CleanupConnection;
    }

    //  anything else is our problem

    DNS_LOG_EVENT(
        DNS_EVENT_RECV_CALL_FAILED,
        0,
        NULL,
        err );

    DNSDBG( ANY, (
        "ERROR:  recv() of TCP message failed.\n"
        "\t%d bytes recvd\n"
        "\t%d bytes left\n"
        "\tGetLastError = 0x%08lx.\n",
        pchrecv - (PCHAR)&pMsg->MessageLength,
        recvLength,
        err ));
    DNS_ASSERT( FALSE );
    goto CleanupConnection;

FinReceived:

    //
    //  valid FIN -- if recv'd between messages (before message length)
    //

    DNSDBG( TCP, (
        "ERROR:  Recv TCP FIN (0 bytes) on socket %d\n",
        socket,
        recvLength ));

    if ( !pMsg->MessageLength && pchrecv == (PCHAR)&pMsg->MessageLength )
    {
        err = DNS_ERROR_NO_PACKET;
        goto CleanupConnection;
    }

    //
    //  FIN during message -- invalid message
    //

    DNSDBG( ANY, (
        "ERROR:  TCP message received has incorrect length.\n"
        "\t%d bytes left when recv'd FIN.\n",
        recvLength ));
    goto BadTcpMessage;


BadTcpMessage:
    {
        PCHAR pchServer = IP_STRING( MSG_REMOTE_IP4(pMsg) );

        DNS_LOG_EVENT(
            DNS_EVENT_BAD_TCP_MESSAGE,
            1,
            & pchServer,
            0 );
    }
    err = DNS_ERROR_BAD_PACKET;


CleanupConnection:

    //  close connection and socket, indicate this by zeroing socket
    //      in message buffer

    Dns_CloseConnection( socket );
    pMsg->Socket = 0;
    return( DNS_ERROR_BAD_PACKET );
}



DNS_STATUS
Dns_SendAndRecvTcp(
    IN      PDNS_MSG_BUF        pMsgSend,
    OUT     PDNS_MSG_BUF        pMsgRecv,
    IN      PIP_ARRAY           aipServers,
    IN OUT  PDNS_NETINFO        pNetInfo
    )
/*++

Routine Description:

    Sends to and waits to recv from remote DNS.

Arguments:

    pMsgSend - message to send

    pMsgRecv - and reuse

    aipServers -- counted array of DNS server IP addrs

    pNetInfo -- adapter info list;  ignored if aipServers given

Return Value:

    ERROR_SUCCESS if successful packet reception.
    Error status on failure.

--*/
{
    DWORD       i;
    DNS_STATUS  status;
    PIP_ARRAY   pallocatedServerIpArray = NULL;

    DNSDBG( SEND, (
        "Enter Dns_SendAndRecvTcp()\n"
        "\tsend msg at      %p\n"
        "\tsocket           %d\n"
        "\trecv msg at      %p\n"
        "\tserver IP array  %p\n"
        "\tadapter info at  %p\n",
        pMsgSend,
        pMsgSend->Socket,
        pMsgRecv,
        aipServers,
        pNetInfo ));

    //
    //  verify params
    //

    if ( !pMsgSend || !pMsgRecv || (!pNetInfo && !aipServers) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    //  build server IP array?
    //

    if ( !aipServers )
    {
        pallocatedServerIpArray = NetInfo_ConvertToIpArray( pNetInfo );
        if ( !pallocatedServerIpArray )
        {
            return( DNS_ERROR_NO_MEMORY );
        }
        aipServers = pallocatedServerIpArray;
    }

    //  init remote sockaddr and socket
    //  setup receive buffer for TCP

    Dns_InitializeMsgRemoteSockaddr(
        pMsgSend,
        aipServers->AddrArray[0] );

    pMsgSend->Socket = 0;
    pMsgRecv->Socket = 0;
    pMsgSend->fTcp = TRUE;
    SET_MESSAGE_FOR_TCP_RECV( pMsgRecv );

    //
    //  loop sending until
    //      - receive successful response
    //      or
    //      - receive errors response from all servers
    //      or
    //      - reach final timeout on all servers
    //

    if ( pMsgRecv->Timeout == 0 )
    {
        pMsgRecv->Timeout = DEFAULT_TCP_TIMEOUT;
    }

    for( i=0; i<aipServers->AddrCount; i++ )
    {
        //
        //  close any previous connection
        //

        if ( pMsgSend->Socket )
        {
            Dns_CloseConnection( pMsgSend->Socket );
            pMsgSend->Socket = 0;
            pMsgRecv->Socket = 0;
        }

        //
        //  connect and send to next server
        //

        status = Dns_OpenTcpConnectionAndSend(
                    pMsgSend,
                    aipServers->AddrArray[i],
                    TRUE
                    );
        if ( status != ERROR_SUCCESS )
        {
            continue;
        }
        DNS_ASSERT( pMsgSend->Socket != INVALID_SOCKET && pMsgSend->Socket != 0 );

        //
        //  receive response
        //      - if successful receive, done
        //      - if timeout continue
        //      - other errors indicate some setup or system level problem
        //  note: Dns_RecvTcp will close and zero msg->socket on error!
        //

        pMsgRecv->Socket = pMsgSend->Socket;

        status = Dns_RecvTcp( pMsgRecv );

        if ( pMsgRecv->Socket == 0 )
        {
            //  socket error -> socket has been closed
            pMsgSend->Socket = 0;
        }

        //
        //  timed out (or error)
        //      - if end of timeout, quit
        //      - otherwise double timeout and resend
        //

        switch( status )
        {
        case ERROR_SUCCESS:
            break;

        case ERROR_TIMEOUT:

            DNS_PRINT((
                "ERROR:  connected to server at %s\n"
                "\tbut no response to packet at %p\n",
                IP_STRING( MSG_REMOTE_IP4(pMsgSend) ),
                pMsgSend
                ));
            continue;

        default:

            DNS_PRINT((
                "ERROR:  connected to server at %s to send packet %p\n"
                "\tbut error %d encountered on receive.\n",
                IP_STRING( MSG_REMOTE_IP4(pMsgSend) ),
                pMsgSend,
                status
                ));
            continue;
        }

        //
        //  verify XID match
        //

        if ( pMsgRecv->MessageHead.Xid != pMsgSend->MessageHead.Xid )
        {
            DNS_PRINT((
                "ERROR:  Incorrect XID in response. Ignoring.\n" ));
            continue;
        }

        //
        //  verify question match
        //      - this is "Maggs Bug" check
        //      - ASSERT here just to investigate issue locally
        //      and make sure check is not bogus
        //

        if ( !Dns_IsSamePacketQuestion(
                pMsgRecv,
                pMsgSend ))
        {
            DNS_PRINT((
                "ERROR:  Bad question response from server %08x!\n"
                "\tXID match, but question does not match question sent!\n",
                MSG_REMOTE_IP4(pMsgSend) ));

            DNS_ASSERT( FALSE );
            continue;
        }

        //
        //  check response code
        //      - some move to next server, others terminal
        //
        //  DCR_FIX1:  bring TCP RCODE handling in-line with UDP
        //
        //  DCR_FIX:  save best TCP RCODE
        //      preserve RCODE (and message) for useless TCP response
        //      would need to then reset TIMEOUT to success at end
        //      or use these RCODEs as status returns
        //

        switch( pMsgRecv->MessageHead.ResponseCode )
        {
        case DNS_RCODE_SERVER_FAILURE:
        case DNS_RCODE_NOT_IMPLEMENTED:
        case DNS_RCODE_REFUSED:

            DNS_PRINT((
                "WARNING:  Servers have responded with failure.\n" ));
            continue;

        default:

            break;
        }
        break;

    }   //  end loop sending/recving UPDATEs

    //
    //  close up final connection
    //      unless set to keep open for reuse
    //

    Dns_CloseConnection( pMsgSend->Socket );
    pMsgSend->Socket = 0;
    pMsgRecv->Socket = 0;

    //  if allocated adapter list free it

    if ( pallocatedServerIpArray )
    {
        FREE_HEAP( pallocatedServerIpArray );
    }

    DNSDBG( SEND, (
        "Leaving Dns_SendAndRecvTcp()\n"
        "\tstatus = %d\n",
        status ));

    return( status );
}




#if 0
DNS_STATUS
Dns_AsyncRecv(
    IN OUT  PDNS_MSG_BUF    pMsgRecv
    )
/*++

Routine Description:

    Drop recv on async socket.

Arguments:

    pMsgRecv - message to receive;  OPTIONAL, if NULL message buffer
        is allocated;
        in either case global pDnsAsyncRecvMsg points at buffer

Return Value:

    ERROR_SUCCESS if successful.
    Error status on failure.

--*/
{
    WSABUF      wsabuf;
    DWORD       bytesRecvd;
    DWORD       flags = 0;

    IF_DNSDBG( RECV )
    {
        DNS_PRINT((
            "Enter Dns_AsyncRecv( %p )\n",
            pMsgRecv ));
    }

    //
    //  allocate buffer if none given
    //

    if ( !pMsgRecv )
    {
        pMsgRecv = Dns_AllocateMsgBuf( MAXWORD );
        if ( !pMsgRecv )
        {
            return( GetLastError() ):
        }
    }
    pDnsAsyncRecvMsg = pMsgRecv;



    //
    //  reset i/o completion event
    //

    ResetEvent( hDnsSocketEvent );
    DNS_ASSERT( hDnsSocketEvent == Dns_SocketOverlapped.hEvent );

    //
    //  drop down recv
    //

    status = WSARecvFrom(
                DnsSocket,
                & wsabuf,
                1,
                & bytesRecvd,           // dummy
                & flags,
                & pMsgRecv->RemoteAddress,
                & pMsgRecv->RemoteAddressLength,
                & DnsSocketOverlapped,
                NULL                    //  no completion routine
                );


    return( ERROR_SUCCESS );

Failed:

    return( status );
}

#endif



DNS_STATUS
Dns_SendAndRecv(
    IN OUT  PDNS_MSG_BUF        pMsgSend,
    OUT     PDNS_MSG_BUF *      ppMsgRecv,
    OUT     PDNS_RECORD *       ppResponseRecords,
    IN      DWORD               dwFlags,
    IN      PIP_ARRAY           aipServers,
    IN OUT  PDNS_NETINFO        pNetInfo
    )
/*++

Routine Description:

    Send message, receive response.

Arguments:

    pMsgSend -- message to send

    ppMsgResponse -- addr to recv ptr to response buffer;  caller MUST
        free buffer

    ppResponseRecord -- address to receive ptr to record list returned from query

    dwFlags -- query flags

    aipDnsServers -- specific DNS servers to query;
        OPTIONAL, if specified overrides normal list associated with machine

    pDnsNetAdapters -- DNS servers to query;  if NULL get current list


Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PDNS_MSG_BUF    precvMsg = NULL;
    PDNS_MSG_BUF    psavedUdpResponse = NULL;
    DNS_STATUS      statusFromUdp = ERROR_SUCCESS;
    DNS_STATUS      status = ERROR_TIMEOUT;
    DNS_STATUS      parseStatus;
    BOOL            ftcp;
    IP_ARRAY        tempArray;

    DNSDBG( QUERY, (
        "Dns_SendAndRecv()\n"
        "\tsend msg     %p\n"
        "\trecv msg     %p\n"
        "\trecv records %p\n"
        "\tflags        %08x\n"
        "\tserver       %p\n"
        "\tadapter list %p\n",
        pMsgSend,
        ppMsgRecv,
        ppResponseRecords,
        dwFlags,
        aipServers,
        pNetInfo ));


    //  response buf passed in?
    //  if not allocate one -- big enough for TCP

    if ( ppMsgRecv && *ppMsgRecv )
    {
        precvMsg = *ppMsgRecv;
    }
    if ( !precvMsg )
    {
        precvMsg = Dns_AllocateMsgBuf( DNS_TCP_DEFAULT_PACKET_LENGTH );
        if ( !precvMsg )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Cleanup;
        }
    }

    //
    //  send packet and get response
    //      - try UDP first unless TCP only
    //

    ftcp = ( dwFlags & DNS_QUERY_USE_TCP_ONLY ) ||
           ( DNS_MESSAGE_CURRENT_OFFSET(pMsgSend) >= DNS_RFC_MAX_UDP_PACKET_LENGTH );

    if ( !ftcp )
    {
        if ( dwFlags & DNS_QUERY_MULTICAST_ONLY )
        {
            //
            // If the multicast query fails, then ERROR_TIMEOUT will
            // be returned
            //
            goto DoMulticast;
        }

        status = Dns_SendAndRecvUdp(
                    pMsgSend,
                    precvMsg,
                    dwFlags,
                    aipServers,
                    pNetInfo );

        statusFromUdp = status;

        if ( status != ERROR_SUCCESS &&
             status != DNS_ERROR_RCODE_NAME_ERROR &&
             status != DNS_INFO_NO_RECORDS )
        {
            //
            //  DCR:  this multicast ON_NAME_ERROR test is bogus
            //      this isn't NAME_ERROR this is pretty much any error
            //

            if ( pNetInfo &&
                 pNetInfo->InfoFlags & DNS_FLAG_MULTICAST_ON_NAME_ERROR )
            {
                goto DoMulticast;
            }
            else
            {
                goto Cleanup;
            }
        }

        //  if truncated response switch to TCP

        if ( precvMsg->MessageHead.Truncation &&
            ! (dwFlags & DNS_QUERY_ACCEPT_PARTIAL_UDP) )
        {
            ftcp = TRUE;
            tempArray.AddrCount = 1;
            tempArray.AddrArray[0] = MSG_REMOTE_IP4(precvMsg);
            aipServers = &tempArray;

            psavedUdpResponse = precvMsg;
            precvMsg = NULL;
        }
    }

    //
    //  TCP send
    //      - for TCP queries
    //      - or truncation on UDP unless accepting partial response
    //
    //  DCR_FIX:  this precvMsg Free is bad
    //      if message was passed in we shouldn't have it, we should
    //      just do our own thing and ignore this recv buffer somehow
    //      ideally that buffer action is at much higher level
    //      

    if ( ftcp )
    {
        if ( precvMsg &&
             precvMsg->BufferLength < DNS_TCP_DEFAULT_PACKET_LENGTH )
        {
            FREE_HEAP( precvMsg );
            precvMsg = NULL;
        }
        if ( !precvMsg )
        {
            precvMsg = Dns_AllocateMsgBuf( DNS_TCP_DEFAULT_PACKET_LENGTH );
            if ( !precvMsg )
            {
                status = DNS_ERROR_NO_MEMORY;
                goto Cleanup;
            }
        }
        pMsgSend->fTcp = TRUE;
        precvMsg->fTcp = TRUE;

#if 0
        if ( dwFlags & DNS_QUERY_SOCKET_KEEPALIVE )
        {
            precvMsg->fSocketKeepalive = TRUE;
        }
#endif
        status = Dns_SendAndRecvTcp(
                    pMsgSend,
                    precvMsg,
                    aipServers,
                    pNetInfo );

        //
        //  if recursing following truncated UDP query, then
        //      must make sure we actually have better data
        //      - if successful, but RCODE is different and bad
        //          => use UDP response
        //      - if failed TCP => use UDP
        //      - successful with good RCODE => parse TCP response
        //

        if ( psavedUdpResponse )
        {
            if ( status == ERROR_SUCCESS )
            {
                DWORD   rcode = precvMsg->MessageHead.ResponseCode;

                if ( rcode == ERROR_SUCCESS ||
                     rcode == psavedUdpResponse->MessageHead.ResponseCode ||
                     (  rcode != DNS_RCODE_SERVER_FAILURE &&
                        rcode != DNS_RCODE_FORMAT_ERROR &&
                        rcode != DNS_RCODE_REFUSED ) )
                {
                    goto Parse;
                }
            }

            //  TCP failed or returned bum error code

            FREE_HEAP( precvMsg );
            precvMsg = psavedUdpResponse;
            psavedUdpResponse = NULL;
        }

        //  direct TCP query
        //      - cleanup if failed

        else if ( status != ERROR_SUCCESS )
        {
            goto Cleanup;
        }
    }

    //
    //  DCR:  this multicast test is bogus (too wide open)
    //      essentially ANY error sends us on to multicast
    //      even INFO_NO_RECORDS
    //
    //  multicast test should be intelligent
    //      - adpater with no DNS servers, or NO_RESPONSE
    //      from any DNS server
    //

    if ( status == ERROR_SUCCESS )
    {
        DWORD   rcode = precvMsg->MessageHead.ResponseCode;

        if ( rcode == ERROR_SUCCESS ||
             ( rcode != DNS_RCODE_SERVER_FAILURE &&
               rcode != DNS_RCODE_FORMAT_ERROR &&
               rcode != DNS_RCODE_REFUSED ) )
        {
            goto Parse;
        }
    }

    //
    //  multicast?
    //

DoMulticast:

    if ( ( pNetInfo &&
           pNetInfo->InfoFlags & DNS_FLAG_ALLOW_MULTICAST )
         ||
         ( ( dwFlags & DNS_QUERY_MULTICAST_ONLY ) &&
           ! pNetInfo ) )
    {
        if ( !pMsgSend ||
             ( pMsgSend &&
               ( pMsgSend->MessageHead.Opcode == DNS_OPCODE_UPDATE ) ) )
        {
            if ( statusFromUdp )
            {
                status = statusFromUdp;
            }
            else
            {
                status = DNS_ERROR_NO_DNS_SERVERS;
            }
            goto Cleanup;
        }

        status = Dns_SendAndRecvMulticast(
                        pMsgSend,
                        precvMsg,
                        pNetInfo );

        if ( status != ERROR_SUCCESS &&
            status != DNS_ERROR_RCODE_NAME_ERROR &&
            status != DNS_INFO_NO_RECORDS )
        {
            if ( statusFromUdp )
            {
                status = statusFromUdp;
            }
            goto Cleanup;
        }
    }

    //
    //  parse response (if desired)
    //

Parse:

    if ( ppResponseRecords )
    {
        parseStatus = Dns_ExtractRecordsFromMessage(
                            precvMsg,
                            (dwFlags & DNSQUERY_UNICODE_OUT),
                            ppResponseRecords );

        if ( !(dwFlags & DNS_QUERY_DONT_RESET_TTL_VALUES ) )
        {
            Dns_NormalizeAllRecordTtls( *ppResponseRecords );
        }
    }

    //  not parsing -- just return RCODE as status

    else
    {
        parseStatus = Dns_MapRcodeToStatus( precvMsg->MessageHead.ResponseCode );
    }

    //
    //  get "best" status
    //      - no-records response beats NAME_ERROR (or other error)
    //      dump bogus records from error response
    //
    //  DCR:  multi-adapter NXDOMAIN\no-records response broken
    //      note, here we'd give back a packet with NAME_ERROR
    //      or another error
    //

    if ( status != parseStatus )
    {
        //  save previous NO_RECORDS response, from underlying query
        //  this trumps other errors (FORMERR, SERVFAIL, NXDOMAIN);
        //
        //  note, that parsed message shouldn't be HIGHER level RCODE
        //  as these should beat out NO_RECORDS in original parsing

        if ( status == DNS_INFO_NO_RECORDS &&
             parseStatus != ERROR_SUCCESS )
        {
            ASSERT( precvMsg->MessageHead.ResponseCode <= DNS_RCODE_NAME_ERROR );

            if ( *ppResponseRecords )
            {
                Dns_RecordListFree( *ppResponseRecords );
                *ppResponseRecords = NULL;
            }
        }
        else
        {
            status = parseStatus;
        }
    }


Cleanup:

    //  cleanup recv buffer?

    if ( ppMsgRecv )
    {
        if ( status == ERROR_SUCCESS || Dns_IsStatusRcode(status) )
        {
            *ppMsgRecv = precvMsg;
        }
        else
        {
            *ppMsgRecv = NULL;
            FREE_HEAP( precvMsg );
        }
    }
    else
    {
        FREE_HEAP( precvMsg );
    }
    if ( psavedUdpResponse )
    {
        FREE_HEAP( psavedUdpResponse );
    }

    DNSDBG( RECV, (
        "Leaving Dns_SendAndRecv(), status = %s (%d)\n",
        Dns_StatusString(status),
        status ));

    return( status );
}



VOID
Dns_InitQueryTimeouts(
    VOID
    )
{
    HKEY  hKey = NULL;
    DWORD status;
    DWORD dwType;
    DWORD ValueSize;
    LPSTR lpTimeouts = NULL;

    DWORD sysVersion;
    DWORD winMajorVersion;
    BOOL  fIsWin95 = FALSE;

    g_QueryTimeouts = QueryTimeouts;
    g_QuickQueryTimeouts = QuickQueryTimeouts;
    g_MulticastQueryTimeouts = MulticastQueryTimeouts;

    //
    // determine what kind of OS it is. Win95 or NT
    //
    sysVersion = GetVersion();
    winMajorVersion = (DWORD) (LOBYTE(LOWORD(sysVersion)));

    if (sysVersion < 0x80000000)
        fIsWin95 = FALSE;
    else
        fIsWin95 = TRUE;

    if ( fIsWin95 )
        status = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                               WIN95_TCPIP_REG_LOCATION,
                               0,
                               KEY_QUERY_VALUE,
                               &hKey );
    else
        status = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                               NT_TCPIP_REG_LOCATION,
                               0,
                               KEY_QUERY_VALUE,
                               &hKey );

    if ( status )
        return;

    if ( !hKey )
        return;

    status = RegQueryValueEx( hKey,
                              DNS_QUERY_TIMEOUTS,
                              NULL,
                              &dwType,
                              NULL,
                              &ValueSize );

    if ( !status )
    {
        if ( ValueSize == 0 )
        {
            goto GetQuickQueryTimeouts;
        }

        lpTimeouts = ALLOCATE_HEAP( ValueSize );

        if ( lpTimeouts )
        {
            LPSTR StringPtr;
            DWORD StringLen;
            DWORD Timeout;
            DWORD Count = 0;

            status = RegQueryValueEx( hKey,
                                      DNS_QUERY_TIMEOUTS,
                                      NULL,
                                      &dwType,
                                      lpTimeouts,
                                      &ValueSize );

            if ( status ||
                 dwType != REG_MULTI_SZ )
            {
                FREE_HEAP( lpTimeouts );
                goto GetQuickQueryTimeouts;
            }

            StringPtr = lpTimeouts;

            while ( ( StringLen = strlen( StringPtr ) ) != 0 &&
                    Count < DNS_MAX_QUERY_TIMEOUTS )
            {
                Timeout = atoi( StringPtr );

                if ( Timeout )
                    RegistryQueryTimeouts[Count++] = Timeout;

                StringPtr += (StringLen + 1);
            }

            RegistryQueryTimeouts[Count] = 0;
            g_QueryTimeouts = RegistryQueryTimeouts;
            FREE_HEAP( lpTimeouts );
        }
    }

GetQuickQueryTimeouts:

    status = RegQueryValueEx( hKey,
                              DNS_QUICK_QUERY_TIMEOUTS,
                              NULL,
                              &dwType,
                              NULL,
                              &ValueSize );

    if ( !status )
    {
        if ( ValueSize == 0 )
        {
            goto GetMulticastTimeouts;
        }

        lpTimeouts = ALLOCATE_HEAP( ValueSize );

        if ( lpTimeouts )
        {
            LPSTR StringPtr;
            DWORD StringLen;
            DWORD Timeout;
            DWORD Count = 0;

            status = RegQueryValueEx( hKey,
                                      DNS_QUICK_QUERY_TIMEOUTS,
                                      NULL,
                                      &dwType,
                                      lpTimeouts,
                                      &ValueSize );

            if ( status ||
                 dwType != REG_MULTI_SZ )
            {
                FREE_HEAP( lpTimeouts );
                goto GetMulticastTimeouts;
            }

            StringPtr = lpTimeouts;

            while ( ( StringLen = strlen( StringPtr ) ) != 0 &&
                    Count < DNS_MAX_QUERY_TIMEOUTS )
            {
                Timeout = atoi( StringPtr );

                if ( Timeout )
                    RegistryQuickQueryTimeouts[Count++] = Timeout;

                StringPtr += (StringLen + 1);
            }

            RegistryQuickQueryTimeouts[Count] = 0;
            g_QuickQueryTimeouts = RegistryQuickQueryTimeouts;
            FREE_HEAP( lpTimeouts );
        }
    }

GetMulticastTimeouts:

    status = RegQueryValueEx( hKey,
                              DNS_MULTICAST_QUERY_TIMEOUTS,
                              NULL,
                              &dwType,
                              NULL,
                              &ValueSize );

    if ( !status )
    {
        if ( ValueSize == 0 )
        {
            RegCloseKey( hKey );
            return;
        }

        lpTimeouts = ALLOCATE_HEAP( ValueSize );

        if ( lpTimeouts )
        {
            LPSTR StringPtr;
            DWORD StringLen;
            DWORD Timeout;
            DWORD Count = 0;

            status = RegQueryValueEx( hKey,
                                      DNS_MULTICAST_QUERY_TIMEOUTS,
                                      NULL,
                                      &dwType,
                                      lpTimeouts,
                                      &ValueSize );

            if ( status ||
                 dwType != REG_MULTI_SZ )
            {
                FREE_HEAP( lpTimeouts );
                RegCloseKey( hKey );
                return;
            }

            StringPtr = lpTimeouts;

            while ( ( StringLen = strlen( StringPtr ) ) != 0 &&
                    Count < DNS_MAX_QUERY_TIMEOUTS )
            {
                Timeout = atoi( StringPtr );

                if ( Timeout )
                    RegistryMulticastQueryTimeouts[Count++] = Timeout;

                StringPtr += (StringLen + 1);
            }

            RegistryMulticastQueryTimeouts[Count] = 0;
            g_MulticastQueryTimeouts = RegistryMulticastQueryTimeouts;
            FREE_HEAP( lpTimeouts );
        }
    }

    RegCloseKey( hKey );
}



//
//  OPT selection
//
//  These routines track DNS server OPT awareness.
//
//  The paradigm here is to default to sending OPTs, then track
//  OPT non-awareness.
//
//  DCR:  RPC over OPT config info
//      - either two lists (local and from-resolver in process)
//      OR
//      - RPC back OPT failures to resolver
//      OR
//      - flag network info blobs to RPC back to resolver
//
//      security wise, prefer not to get info back
//
//
//  DCR:  OPT info in network info
//      - then don't have to traverse locks
//      - save is identical to current
//      - could exclude OPT on any non-cache sends to
//          handle problem of not saving OPT failures
//

//
//  Global IP array of OPT-failed DNS servers
//

PIP_ARRAY   g_OptFailServerList = NULL;

//  Allocation size for OptFail IP array.
//  Ten servers nicely covers the typical case.

#define OPT_FAIL_LIST_SIZE      10


//
//  Use global lock for OPT list
//

#define LOCK_OPT_LIST()     LOCK_GENERAL()
#define UNLOCK_OPT_LIST()   UNLOCK_GENERAL()



BOOL
Dns_IsServerOptExclude(
    IN      IP4_ADDRESS     IpAddress
    )
/*++

Routine Description:

    Determine if particular server is not OPT aware.

Arguments:

    IpAddress -- IP address of DNS server

Return Value:

    TRUE if server should NOT get OPT send.
    FALSE if server should can send OPT

--*/
{
    BOOL    retval;

    //
    //  zero IP -- meaning TCP connect to unknown
    //      => must exclude OPT to allow success, otherwise
    //      we can't retry non-OPT
    //

    if ( IpAddress == 0 )
    {
        return  TRUE;
    }

    //
    //  no exclusions?
    //      - doing outside lock for perf once we get to
    //      the "fully-deployed" case
    //

    if ( !g_OptFailServerList )
    {
        return  FALSE;
    }
            
    //
    //  see if IP is in OPT list
    //      - only if found do we exclude
    //

    LOCK_OPT_LIST();

    retval = FALSE;

    if ( g_OptFailServerList
            &&
         Dns_IsAddressInIpArray(
            g_OptFailServerList,
            IpAddress ) )
    {
        retval = TRUE;
    }
    UNLOCK_OPT_LIST();

    return  retval;
}



VOID
Dns_SetServerOptExclude(
    IN      IP4_ADDRESS     IpAddress
    )
/*++

Routine Description:

    Set server for OPT exclusion.

Arguments:

    IpAddress -- IP address of DNS server that failed OPT

Return Value:

    None

--*/
{
    //
    //  screen zero IP (TCP connect to unknown IP)
    //

    if ( IpAddress == 0 )
    {
        return;
    }

    //
    //  put IP in OPT-fail list
    //      - create if doesn't exist
    //      - resize if won't fit
    //          note:  add failure means "won't fit"
    //
    //  note:  only safe to reset global if allocation successful
    //  note:  only one retry to protect alloc failure looping
    //

    LOCK_OPT_LIST();

    if ( ! g_OptFailServerList
            ||
         ! Dns_AddIpToIpArray(
                g_OptFailServerList,
                IpAddress ) )
    {
        PIP_ARRAY  pnewList;

        pnewList = Dns_CopyAndExpandIpArray(
                        g_OptFailServerList,
                        OPT_FAIL_LIST_SIZE,
                        TRUE        // free current
                        );
        if ( pnewList )
        {
            g_OptFailServerList = pnewList;

            Dns_AddIpToIpArray(
                g_OptFailServerList,
                IpAddress );
        }
    }

    UNLOCK_OPT_LIST();
}


//
//  End send.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\trace.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    trace.h

Abstract:

    Domain Name System (DNS) API 

    Header for DNS performance tracing functions.

Author:

    Inder Sethi     December, 2000

Revision History:

    Jim Gilroy      January 2001    cleanup, format, integrate, checkin

--*/


#ifndef _DNSAPI_TRACE_INCLUDED_
#define _DNSAPI_TRACE_INCLUDED_

//
//  Tracing functions
//

VOID
Trace_Initialize(
    VOID
    );

VOID
Trace_Cleanup(
    VOID
    );

VOID 
Trace_LogQueryEvent( 
    IN      PDNS_MSG_BUF    pMsg, 
    IN      WORD            wQuestionType
    );

VOID
Trace_LogResponseEvent( 
    IN      PDNS_MSG_BUF    pMsg, 
    IN      WORD            wRespType,
    IN      DNS_STATUS      Status
    );

VOID
Trace_LogSendEvent( 
    IN      PDNS_MSG_BUF    pMsg,
    IN      DNS_STATUS      Status
    );

VOID 
Trace_LogRecvEvent( 
    IN      PDNS_MSG_BUF    pMsg,
    IN      DNS_STATUS      Status,
    IN      BOOL            fTcp
    );

#endif  // _DNSAPI_TRACE_INCLUDED_

//
//  End trace.h
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\socket.c ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    socket.c

Abstract:

    Domain Name System (DNS) API

    Socket setup.

Author:

    Jim Gilroy (jamesg)     October, 1996

Revision History:

--*/


#include "local.h"

//
//  Winsock startup
//

LONG        WinsockStartCount = 0;
WSADATA     WsaData;


//
//  Async i/o
//
//  If want async socket i/o then can create single async socket, with
//  corresponding event and always use it.  Requires winsock 2.2
//

SOCKET      DnsSocket = 0;

OVERLAPPED  DnsSocketOverlapped;
HANDLE      hDnsSocketEvent = NULL;

//
//  App shutdown flag
//

BOOLEAN     fApplicationShutdown = FALSE;




DNS_STATUS
Dns_InitializeWinsock(
    VOID
    )
/*++

Routine Description:

    Initialize winsock for this process.

    Currently, assuming process must do WSAStartup() before
    calling any Dns_Api entry point.

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNSDBG( SOCKET, ( "Dns_InitializeWinsock()\n" ));

    //
    //  start winsock, if not already started
    //

    if ( WinsockStartCount == 0 )
    {
        DNS_STATUS  status;

        DNSDBG( TRACE, (
            "Dns_InitializeWinsock() version %x\n",
            DNS_WINSOCK_VERSION ));

        status = WSAStartup( DNS_WINSOCK_VERSION, &WsaData );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT(( "ERROR:  WSAStartup failure %d.\n", status ));
            return( status );
        }

        DNSDBG( TRACE, (
            "Winsock initialized => wHighVersion=0x%x, wVersion=0x%x\n",
            WsaData.wHighVersion,
            WsaData.wVersion ));

        InterlockedIncrement( &WinsockStartCount );
    }
    return( ERROR_SUCCESS );
}



DNS_STATUS
Dns_InitializeWinsockEx(
    IN      BOOL            fForce
    )
/*++

Routine Description:

    Dummy -- just in case called somewhere

    DCR:  eliminate Dns_InitializeWinsockEx()

--*/
{
    return  Dns_InitializeWinsock();
}



VOID
Dns_CleanupWinsock(
    VOID
    )
/*++

Routine Description:

    Cleanup winsock if it was initialized by dnsapi.dll

Arguments:

    None.

Return Value:

    None.

--*/
{
    DNSDBG( SOCKET, ( "Dns_CleanupWinsock()\n" ));

    //
    //  WSACleanup() for value of ref count
    //      - ref count pushed down to one below real value, but
    //      fixed up at end
    //      - note:  the GUI_MODE_SETUP_WS_CLEANUP deal means that
    //      we can be called other than process detach, making
    //      interlock necessary
    //      

    while ( InterlockedDecrement( &WinsockStartCount ) >= 0 )
    {
        WSACleanup();
    }

    InterlockedIncrement( &WinsockStartCount );
}



SOCKET
Dns_CreateSocketEx(
    IN      INT             Family,
    IN      INT             SockType,
    IN      IP_ADDRESS      IpAddress,
    IN      USHORT          Port,
    IN      DWORD           dwFlags
    )
/*++

Routine Description:

    Create socket.

Arguments:

    Family -- socket family AF_INET or AF_INET6

    SockType -- SOCK_DGRAM or SOCK_STREAM

    IpAddress -- IP address to listen on (net byte order)

        DCR:  will need to change to IP6_ADDRESS then use MAPPED to extract

    Port -- desired port in net order
                - NET_ORDER_DNS_PORT for DNS listen sockets
                - 0 for any port

    dwFlags -- specifiy the attributes of the sockets

Return Value:

    Socket if successful.
    Otherwise INVALID_SOCKET.

--*/
{
    SOCKET          s;
    INT             err;
    INT             val;
    DNS_STATUS      status;
    BOOL            fretry = FALSE;


    //
    //  create socket
    //      - try again if winsock not initialized

    while( 1 )
    {
        s = WSASocket(
                Family,
                SockType,
                0,
                NULL,
                0, 
                dwFlags );
     
        if ( s != INVALID_SOCKET )
        {
            break;
        }

        status = GetLastError();

        DNSDBG( SOCKET, (
            "ERROR:  Failed to open socket of type %d.\n"
            "\terror = %d.\n",
            SockType,
            status ));

        if ( status != WSANOTINITIALISED || fretry )
        {
            SetLastError( DNS_ERROR_NO_TCPIP );
            return INVALID_SOCKET;
        }

        //
        //  initialize Winsock if not already started
        //
        //  note:  do NOT automatically initialize winsock
        //      init jacks ref count and will break applications
        //      which use WSACleanup to close outstanding sockets;
        //      we'll init only when the choice is that or no service;
        //      apps can still cleanup with WSACleanup() called
        //      in loop until WSANOTINITIALISED failure
        //

        fretry = TRUE;
        status = Dns_InitializeWinsock();
        if ( status != NO_ERROR )
        {
            SetLastError( DNS_ERROR_NO_TCPIP );
            return INVALID_SOCKET;
        }
    }

    //
    //  bind socket
    //      - only if specific port given, this keeps remote winsock
    //      from grabbing it if we are on the local net
    //

    if ( IpAddress || Port )
    {
        SOCKADDR_IN6    sockaddr;
        INT             sockaddrLength;

        if ( Family == AF_INET )
        {
            PSOCKADDR_IN psin = (PSOCKADDR_IN) &sockaddr;

            sockaddrLength = sizeof(*psin);
            RtlZeroMemory( psin, sockaddrLength );

            psin->sin_family = AF_INET;
            psin->sin_port = Port;
            psin->sin_addr.s_addr = IpAddress;
        }
        else
        {
            PSOCKADDR_IN6 psin = (PSOCKADDR_IN6) &sockaddr;

            DNS_ASSERT( Family == AF_INET6 );

            sockaddrLength = sizeof(*psin);
            RtlZeroMemory( psin, sockaddrLength );

            psin->sin6_family = AF_INET6;
            psin->sin6_port = Port;
            //psin->sin6_addr = IpAddress;
        }


        if ( Port > 0 )
        {
            // allow us to bind to a port that someone else is already listening on
            val = 1;
            setsockopt(
                s,
                SOL_SOCKET,
                SO_REUSEADDR,
                (const char *)&val,
                sizeof(val) );
        }

        err = bind(
                s,
                (PSOCKADDR) &sockaddr,
                sockaddrLength );

        if ( err == SOCKET_ERROR )
        {
            DNSDBG( SOCKET, (
                "Failed to bind() socket %d, to port %d, address %s.\n"
                "\terror = %d.\n",
                s,
                ntohs(Port),
                IP_STRING( IpAddress ),
                GetLastError() ));

            closesocket( s );
            SetLastError( DNS_ERROR_NO_TCPIP );
            return INVALID_SOCKET;
        }
    }

    DNSDBG( SOCKET, (
        "Created socket %d, of type %d, for address %s, port %d.\n",
        s,
        SockType,
        inet_ntoa( *(struct in_addr *) &IpAddress ),
        ntohs(Port) ));

    return s;
}



SOCKET
Dns_CreateSocket(
    IN      INT             SockType,
    IN      IP_ADDRESS      IpAddress,
    IN      USHORT          Port
    )
/*++

Routine Description:

    Wrapper function for CreateSocketAux. Passes in 0 for dwFlags (as opposed
    to Dns_CreateMulticastSocket, which passes in flags to specify that
    the socket is to be used for multicasting).

Arguments:

    SockType -- SOCK_DGRAM or SOCK_STREAM

    IpAddress -- IP address to listen on (net byte order)

    Port -- desired port in net order
                - NET_ORDER_DNS_PORT for DNS listen sockets
                - 0 for any port

Return Value:

    socket if successful.
    Otherwise INVALID_SOCKET.

--*/
{
    return  Dns_CreateSocketEx(
                AF_INET,
                SockType,
                IpAddress,
                Port,
                0           // no flags
                );
}



SOCKET
Dns_CreateMulticastSocket(
    IN      INT             SockType,
    IN      IP_ADDRESS      IpAddress,
    IN      USHORT          Port,
    IN      BOOL            fSend,
    IN      BOOL            fReceive
    )
/*++

Routine Description:

    Create socket and join it to the multicast DNS address.

Arguments:

    SockType -- SOCK_DGRAM or SOCK_STREAM

    IpAddress -- IP address to listen on (net byte order)

    Port -- desired port in net order
                - NET_ORDER_DNS_PORT for DNS listen sockets
                - 0 for any port

Return Value:

    socket if successful.
    Otherwise INVALID_SOCKET.

--*/
{
    SOCKADDR_IN multicastAddress;
    DWORD       byteCount;
    BOOL        bflag;
    SOCKET      s;
    INT         err;
    
    s = Dns_CreateSocketEx(
            AF_INET,
            SockType,
            IpAddress,
            Port,
            WSA_FLAG_MULTIPOINT_C_LEAF |
            WSA_FLAG_MULTIPOINT_D_LEAF |
            WSA_FLAG_OVERLAPPED );

    if ( s != INVALID_SOCKET )
    {
        multicastAddress.sin_family = PF_INET;
        multicastAddress.sin_addr.s_addr = MULTICAST_DNS_RADDR;
        multicastAddress.sin_port = Port;

        //  set loopback

        bflag = TRUE;

        err = WSAIoctl(
                s,
                SIO_MULTIPOINT_LOOPBACK,    // loopback iotcl
                & bflag,                    // turn on
                sizeof(bflag),
                NULL,                       // no output
                0,                          // no output size
                &byteCount,                 // bytes returned
                NULL,                       // no overlapped
                NULL                        // no completion routine
                );

        if ( err == SOCKET_ERROR )
        {
            DNSDBG( SOCKET, (
                "Unable to turn multicast loopback on for socket %d; error = %d.\n",
                s,
                GetLastError()
                ));
        }

        //
        //  join socket to multicast group
        //

        s = WSAJoinLeaf(
                s,
                (PSOCKADDR)&multicastAddress,
                sizeof (multicastAddress),
                NULL,                                   // caller data buffer
                NULL,                                   // callee data buffer
                NULL,                                   // socket QOS setting
                NULL,                                   // socket group QOS
                ((fSend && fReceive) ? JL_BOTH :        // send and/or receive
                    (fSend ? JL_SENDER_ONLY : JL_RECEIVER_ONLY))
                );
                
        if ( s == INVALID_SOCKET )
        {
            DNSDBG( SOCKET, (
               "Unable to join socket %d to multicast address, error = %d.\n",
               s,
               GetLastError() ));
        }
    }
    
    return s;
}



VOID
Dns_CloseSocket(
    IN      SOCKET          Socket
    )
/*++

Routine Description:

    Close DNS socket.

Arguments:

    Socket -- socket to close

Return Value:

    None.

--*/
{
    if ( Socket == 0 || Socket == INVALID_SOCKET )
    {
        DNS_PRINT(( "WARNING:  Dns_CloseSocket() called on invalid socket %d.\n", Socket ));
        return;
    }

    DNSDBG( SOCKET, ( "closesocket( %d )\n", Socket ));

    closesocket( Socket );
}



VOID
Dns_CloseConnection(
    IN      SOCKET          Socket
    )
/*++

Routine Description:

    Close connection on socket.

Arguments:

    Socket -- socket to close

Return Value:

    None.

--*/
{
    if ( Socket == 0 || Socket == INVALID_SOCKET )
    {
        DNS_PRINT((
            "WARNING:  Dns_CloseTcpConnection() called on invalid socket.\n" ));
        //DNS_ASSERT( FALSE );
        return;
    }

    //  shutdown connection, then close

    DNSDBG( SOCKET, ( "shutdown and closesocket( %d )\n", Socket ));

    shutdown( Socket, 2 );
    closesocket( Socket );
}



#if 0
//
//  Global async socket routines
//

DNS_STATUS
Dns_SetupGlobalAsyncSocket(
    VOID
    )
/*++

Routine Description:

    Create global async UDP socket.

Arguments:

    SockType -- SOCK_DGRAM or SOCK_STREAM

    IpAddress -- IP address to listen on (net byte order)

    Port -- desired port in net order
                - NET_ORDER_DNS_PORT for DNS listen sockets
                - 0 for any port

Return Value:

    socket if successful.
    Otherwise INVALID_SOCKET.

--*/
{
    DNS_STATUS  status;
    INT         err;
    SOCKADDR_IN sockaddrIn;

    //
    //  start winsock, need winsock 2 for async
    //

    if ( ! fWinsockStarted )
    {
        status = WSAStartup( DNS_WINSOCK_VERSION, &WsaData );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT(( "ERROR:  WSAStartup failure %d.\n", status ));
            return( status );
        }
        if ( WsaData.wVersion != DNS_WINSOCK2_VERSION )
        {
            WSACleanup();
            return( WSAVERNOTSUPPORTED );
        }
        fWinsockStarted = TRUE;
    }

    //
    //  setup socket
    //      - overlapped i\o with event so can run asynchronously in
    //      this thread and wait with queuing event
    //

    DnsSocket = WSASocket(
                    AF_INET,
                    SOCK_DGRAM,
                    0,
                    NULL,
                    0,
                    WSA_FLAG_OVERLAPPED );
    if ( DnsSocket == INVALID_SOCKET )
    {
        status = GetLastError();
        DNS_PRINT(( "\nERROR:  Async socket create failed.\n" ));
        goto Error;
    }

    //
    //  bind socket
    //

    RtlZeroMemory( &sockaddrIn, sizeof(sockaddrIn) );
    sockaddrIn.sin_family = AF_INET;
    sockaddrIn.sin_port = 0;
    sockaddrIn.sin_addr.s_addr = INADDR_ANY;

    err = bind( DnsSocket, (PSOCKADDR)&sockaddrIn, sizeof(sockaddrIn) );
    if ( err == SOCKET_ERROR )
    {
        status = GetLastError();
        DNSDBG( SOCKET, (
            "Failed to bind() DnsSocket %d.\n"
            "\terror = %d.\n",
            DnsSocket,
            status ));
        goto Error;
    }

    //
    //  create event to signal on async i/o completion
    //

    hDnsSocketEvent = CreateEvent(
                        NULL,       // Security Attributes
                        TRUE,       // create Manual-Reset event
                        FALSE,      // start unsignalled -- paused
                        NULL        // event name
                        );
    if ( !hDnsSocketEvent )
    {
        status = GetLastError();
        DNS_PRINT(( "Failed event creation\n" ));
        goto Error;
    }
    DnsSocketOverlapped.hEvent = hDnsSocketEvent;

    DNSDBG( SOCKET, (
        "Created global async UDP socket %d.\n"
        "\toverlapped at %p\n"
        "\tevent handle %p\n",
        DnsSocket,
        DnsSocketOverlapped,
        hDnsSocketEvent ));

    return ERROR_SUCCESS;

Error:

    DNS_PRINT((
        "ERROR:  Failed async socket creation, status = %d\n",
        status ));
    closesocket( DnsSocket );
    DnsSocket = INVALID_SOCKET;
    WSACleanup();
    return( status );
}

#endif




//
//  Socket caching
//
//  Doing limited caching of UDP unbound sockets used for standard
//  DNS lookups in resolver.  This allows us to prevent denial of
//  service attack by using up all ports on the machine.
//  Resolver is the main customer for this, but we'll code it to
//  be useable by any process.
//
//  Implementation notes:
//
//  There are a couple specific goals to this implementation:
//      - Minimal code impact;  Try NOT to change the resolver
//      code.
//      - Usage driven caching;  Don't want to create on startup
//      "cache sockets" that we don't use;  Instead have actual usage
//      drive up the cached socket count.
//
//  There are several approaches here.
//
//      1) explicit resolver cache -- passed down sockets
//      
//      2) add caching seamlessly into socket open and close
//      this was my first choice, but the problem here is that on
//      close we must either do additional calls to winsock to determine
//      whether cachable (UDP-unbound) socket OR cache must include some
//      sort of "in-use" tag and we trust that socket is never closed
//      outside of path (otherwise handle reuse could mess us up)
//
//      3) new UDP-unbound open\close function
//      this essentially puts the "i-know-i'm-using-UDP-unbound-sockets"
//      burden on the caller who must switch to this new API;
//      fortunately this meshes well with our "SendAndRecvUdp()" function;
//      this approach still allows a caller driven ramp up we desire,
//      so i'm using this approach
//

//
//  Keep array of sockets
//
//  Dev note:  the Array and MaxCount MUST be kept in sync, no
//  independent check of array is done, it is assumed to exist when
//  MaxCount is non-zero, so they MUST be in sync when lock released
//

SOCKET *    g_pCacheSocketArray = NULL;

DWORD       g_CacheSocketMaxCount = 0;
DWORD       g_CacheSocketCount = 0;


//  Hard limit on what we'll allow folks to keep awake

#define MAX_SOCKET_CACHE_LIMIT  (100)


//  Lock access with generic lock
//  This is very short\fast CS, contention will be minimal

#define LOCK_SOCKET_CACHE()     LOCK_GENERAL()
#define UNLOCK_SOCKET_CACHE()   UNLOCK_GENERAL()



DNS_STATUS
Dns_CacheSocketInit(
    IN      DWORD           MaxSocketCount
    )
/*++

Routine Description:

    Initialize socket caching.

Arguments:

    MaxSocketCount -- max count of sockets to cache

Return Value:

    ERROR_SUCCESS if successful.
    DNS_ERROR_NO_MEMORY on alloc failure.
    ERROR_INVALID_PARAMETER if already initialized or bogus count.

--*/
{
    SOCKET *    parray;
    DNS_STATUS  status = NO_ERROR;

    DNSDBG( SOCKET, ( "Dns_CacheSocketInit()\n" ));

    //
    //  validity check
    //      - note, one byte of the apple, we don't let you raise
    //      count, though we later could;  i see this as at most a
    //      "configure for machine use" kind of deal
    //

    LOCK_SOCKET_CACHE();

    if ( MaxSocketCount == 0 || g_CacheSocketMaxCount != 0 )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Done;
    }

    //
    //  allocate
    //

    if ( MaxSocketCount > MAX_SOCKET_CACHE_LIMIT )
    {
        MaxSocketCount = MAX_SOCKET_CACHE_LIMIT;
    }

    parray = (SOCKET *) ALLOCATE_HEAP_ZERO( sizeof(SOCKET) * MaxSocketCount );
    if ( !parray )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    //  set globals

    g_pCacheSocketArray     = parray;
    g_CacheSocketMaxCount   = MaxSocketCount;
    g_CacheSocketCount      = 0;

Done:

    UNLOCK_SOCKET_CACHE();

    return  status;
}



VOID
Dns_CacheSocketCleanup(
    VOID
    )
/*++

Routine Description:

    Cleanup socket caching.

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD   i;
    SOCKET  sock;

    DNSDBG( SOCKET, ( "Dns_CacheSocketCleanup()\n" ));

    //
    //  close cached sockets
    //

    LOCK_SOCKET_CACHE();

    for ( i=0;  i<g_CacheSocketMaxCount;  i++ )
    {
        sock = g_pCacheSocketArray[i];
        if ( sock )
        {
            Dns_CloseSocket( sock );
            g_CacheSocketCount--;
        }
    }

    DNS_ASSERT( g_CacheSocketCount == 0 );

    //  dump socket array memory

    FREE_HEAP( g_pCacheSocketArray );

    //  clear globals

    g_pCacheSocketArray     = NULL;
    g_CacheSocketMaxCount   = 0;
    g_CacheSocketCount      = 0;

    UNLOCK_SOCKET_CACHE();
}



SOCKET
Dns_GetUdpSocket(
    VOID
    )
/*++

Routine Description:

    Get a cached socket.

Arguments:

    None

Return Value:

    Socket handle if successful.
    Zero if no cached socket available.

--*/
{
    SOCKET  sock;
    DWORD   i;

    //
    //  quick return if nothing available
    //      - do outside lock so function can be called cheaply
    //      without other checks
    //

    if ( g_CacheSocketCount == 0 )
    {
        goto Open;
    }

    //
    //  get a cached socket
    //

    LOCK_SOCKET_CACHE();

    for ( i=0;  i<g_CacheSocketMaxCount;  i++ )
    {
        sock = g_pCacheSocketArray[i];
        if ( sock != 0 )
        {
            g_pCacheSocketArray[i] = 0;
            g_CacheSocketCount--;
            UNLOCK_SOCKET_CACHE();

            //
            //  DCR:  clean out any data on cached socket
            //      it would be cool to cheaply dump useless data
            //
            //  right now we just let XID match, then question match
            //  dump data on recv
            //

            DNSDBG( SOCKET, (
                "Returning cached socket %d.\n",
                sock ));
            return  sock;
        }
    }

    UNLOCK_SOCKET_CACHE();

Open:

    sock = Dns_CreateSocket(
                SOCK_DGRAM,
                INADDR_ANY,
                0 );
    return  sock;
}



VOID
Dns_ReturnUdpSocket(
    IN      SOCKET          Socket
    )
/*++

Routine Description:

    Return UDP socket for possible caching.

Arguments:

    Socket -- socket handle

Return Value:

    None

--*/
{
    SOCKET  sock;
    DWORD   i;

    //
    //  quick return if not caching
    //      - do outside lock so function can be called cheaply
    //      without other checks
    //

    if ( g_CacheSocketMaxCount == 0 ||
         g_CacheSocketMaxCount == g_CacheSocketCount )
    {
        goto Close;
    }

    //
    //  return cached socket
    //

    LOCK_SOCKET_CACHE();

    for ( i=0;  i<g_CacheSocketMaxCount;  i++ )
    {
        if ( g_pCacheSocketArray[i] )
        {
            continue;
        }
        g_pCacheSocketArray[i] = Socket;
        g_CacheSocketCount++;
        UNLOCK_SOCKET_CACHE();

        DNSDBG( SOCKET, (
            "Returned socket %d to cache.\n",
            Socket ));
        return;
    }

    UNLOCK_SOCKET_CACHE();

    DNSDBG( SOCKET, (
        "Socket cache full, closing socket %d.\n"
        "WARNING:  should only see this message on race!\n",
        Socket ));

Close:

    Dns_CloseSocket( Socket );
}

//
//  End socket.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\svccntl.c ===
/*++

Copyright (c) 1994-2001  Microsoft Corporation

Module Name:

    svccntl.c

Abstract:

    Domain Name System (DNS) API 

    Service control routines.

Author:

    Glenn Curtis (glennc) 05-Jul-1997

Revision History:

    Jim Gilroy (jamesg)     March 2000  -- resolver notify 

--*/


#include "local.h"


//
//  DCR_CLEANUP:  identical ServiceControl routine is in resolver
//      - should either expose in dnsapi.dll or in dnslib.h
//

DWORD
_fastcall
SendServiceControl(
    IN  LPWSTR pszServiceName,
    IN  DWORD  dwControl
    )
{
    DWORD            Status = NO_ERROR;
    SC_HANDLE        scManagerHandle = NULL;
    SC_HANDLE        scServiceHandle = NULL;
    SERVICE_STATUS   ServiceStatus;


    DNSDBG( ANY, (
        "SendServiceControl( %S, %08x )\n",
        pszServiceName,
        dwControl ));

    scManagerHandle = OpenSCManagerW( NULL,
                                      NULL,
                                      SC_MANAGER_ALL_ACCESS );
                                   // SC_MANAGER_CONNECT );
    if ( !scManagerHandle )
        return GetLastError();

    scServiceHandle = OpenServiceW( scManagerHandle,
                                    pszServiceName,
                                    SERVICE_ALL_ACCESS );
                                 // SERVICE_CHANGE_CONFIG );

    if ( !scServiceHandle )
    {
        CloseServiceHandle( scManagerHandle );
        return GetLastError();
    }

    if ( !ControlService( scServiceHandle,
                          dwControl,
                          &ServiceStatus ) )
    {
        Status = GetLastError();
    }

    CloseServiceHandle( scServiceHandle );
    CloseServiceHandle( scManagerHandle );

    return Status;
}



VOID
DnsNotifyResolver(
    IN      DWORD           Flag,
    IN      PVOID           pReserved
    )
/*++

Routine Description:

    Notify resolver of configuration change.

    This allows it to wakeup and refresh its informatio and\or dump
    the cache and rebuild info.

Arguments:

    Flag -- unused

    pReserved -- unused

Return Value:

    None

--*/
{
    UNREFERENCED_PARAMETER( Flag );
    UNREFERENCED_PARAMETER( pReserved );

    DNSDBG( ANY, (
        "\nDnsNotifyResolver()\n"
        "\tFlag         = %08x\n"
        "\tpReserved    = %p\n"
        "\tTickCount    = %d\n",
        Flag,
        pReserved,
        GetTickCount() ));

    //
    //  wake the resolver
    //

    SendServiceControl(
        DNS_RESOLVER_SERVICE,
        SERVICE_CONTROL_PARAMCHANGE );

    //
    //  DCR:  hack for busted resolver permissions
    //
    //  DCR:  network change notifications
    //      this is a poor mechanism for handling notification
    //          - this should happen directly through SCM
    //          - it won't work for IPv6 or anything else
    //      probably need to move to IPHlpApi
    //
    //  notify resolver
    //  also notify DNS server, but wait briefly to allow resolver
    //      to handle the changes as i'm not sure that the server
    //      doesn't call a resolver API to do it's read
    //      note, the reason the resolver doesn't notify the DNS
    //      server is that since Jon Schwartz moved the resolver to
    //      NetworkService account, attempts to open the SCM to
    //      notify the DNS server all fail
    //
    //  DCR:  make sure server calls directly to avoid race
    //  DCR:  make sure g_IsDnsServer is current
    //  

    g_IsDnsServer = Reg_IsMicrosoftDnsServer();
    if ( g_IsDnsServer )
    {
        Sleep( 1000 );

        SendServiceControl(
            DNS_SERVER_SERVICE,
            SERVICE_CONTROL_PARAMCHANGE );
    }
}


//
//  End srvcntl.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\trace.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    trace.c

Abstract:

    Domain Name System ( DNS ) API 

    DNS performance tracing functions.

Author:

    Inder Sethi (bsethi)    December, 2000

Revision History:

    Jim Gilroy (jamesg)     January 2001    cleanup, format, integrate, checkin

--*/


#include "local.h"
#include "trace.h"

#include <tchar.h>
#include <wmistr.h>
#include <guiddef.h>
#include <evntrace.h>

//
//  Tracing definitions
//

#define EVENT_TRACE_TYPE_UDP    9
#define EVENT_TRACE_TYPE_TCP    10

typedef struct _DnsSendEvent
{
    EVENT_TRACE_HEADER  EventHeader;
    DNS_HEADER          DnsHeader;
    IP4_ADDRESS         DnsServer;
    DNS_STATUS          ReturnStatus;
}
DNS_SEND_EVENT, *PDNS_SEND_EVENT;

typedef struct _DnsRecvEvent
{
    EVENT_TRACE_HEADER  EventHeader;
    DNS_HEADER          DnsHeader;
    IP4_ADDRESS         DnsServer;
    DNS_STATUS          ReturnStatus;
}
DNS_RECV_EVENT, *PDNS_RECV_EVENT;

typedef struct _DnsQueryEvent
{
    EVENT_TRACE_HEADER  EventHeader;
    WORD                Xid;
    WORD                QueryType;
    CHAR                Query[256];
}
DNS_QUERY_EVENT, *PDNS_QUERY_EVENT;

typedef struct _DnsResponseEvent
{
    EVENT_TRACE_HEADER  EventHeader;
    WORD                Xid;
    WORD                RespType;
    DNS_STATUS          ReturnStatus;
}
DNS_RESPONSE_EVENT, *PDNS_RESPONSE_EVENT;


//
//  Tracing globals
//

TRACEHANDLE     g_LoggerHandle;
TRACEHANDLE     g_TraceRegHandle;

BOOL            g_TraceOn;
BOOL            g_TraceInit;
BOOL            g_TraceInitInProgress;
DWORD           g_TraceLastInitAttempt;

ULONG           g_NumEventGuids = 4;

//
//  Allow retry on init every minute
//

#define TRACE_INIT_RETRY_TIME   (60)


//
//  MAX ???
//

#define MAXSTR 1024


//
//  GUIDs 
//
//  Provider Guid: 1540ff4c-3fd7-4bba-9938-1d1bf31573a7

GUID    ProviderGuid =
{0x1540ff4c, 0x3fd7, 0x4bba, 0x99, 0x38, 0x1d, 0x1b, 0xf3, 0x15, 0x73, 0xa7};

//
//  Event Guids:
//      cc0c571b-d5f2-44fd-8b7f-de7770cc1984
//      6ddef4b8-9c60-423e-b1a6-deb9286fff1e
//      75f0c316-7bab-4e66-bed1-24091b1ac49e
//      9929b1c7-9e6a-4fc9-830a-f684e64f8aab
//

GUID    DnsSendGuid =
{0xcc0c571b, 0xd5f2, 0x44fd, 0x8b, 0x7f, 0xde, 0x77, 0x70, 0xcc, 0x19, 0x84};

GUID    DnsRecvGuid =
{0x6ddef4b8, 0x9c60, 0x423e, 0xb1, 0xa6, 0xde, 0xb9, 0x28, 0x6f, 0xff, 0x1e};

GUID    DnsQueryGuid =
{0x75f0c316, 0x7bab, 0x4e66, 0xbe, 0xd1, 0x24, 0x09, 0x1b, 0x1a, 0xc4, 0x9e};

GUID    DnsResponseGuid =
{0x9929b1c7, 0x9e6a, 0x4fc9, 0x83, 0x0a, 0xf6, 0x84, 0xe6, 0x4f, 0x8a, 0xab};

TRACE_GUID_REGISTRATION TraceGuidReg[] =
{
    { &DnsSendGuid , NULL},
    { &DnsRecvGuid , NULL},
    { &DnsQueryGuid   , NULL},
    { &DnsResponseGuid, NULL}
};



ULONG
ControlCallback( 
    IN      WMIDPREQUESTCODE    RequestCode,
    IN      PVOID               Context,
    IN OUT  ULONG *             InOutBufferSize,
    IN OUT  PVOID               Buffer
    )
/*++

Routine Description:

    ControlCallback is the callback which ETW will call to enable or disable
    logging. This is called by the caller in a thread-safe manner ( only one
    call at any time ).

Meaning of arguments in MSDN.

--*/
{
    ULONG   Status;

    Status = ERROR_SUCCESS;

    switch ( RequestCode )
    {
        case WMI_ENABLE_EVENTS:
        {
            g_LoggerHandle = GetTraceLoggerHandle( Buffer );
            g_TraceOn  = TRUE;
            break;
        }
        case WMI_DISABLE_EVENTS:
        {
            g_TraceOn      = FALSE;
            g_LoggerHandle = 0;
            break;
        }
        default:
        {
            Status = ERROR_INVALID_PARAMETER;
            break;
        }
    }
    return( Status );
}



VOID
Trace_Initialize(
    VOID
    )
/*++

Routine Description:

    Init DNS client tracing for DLL process attach.

    Note, does not actually init the tracing, just inits
    tracing variables.

Arguments:

    None.

Return Value:

    None.

--*/
{
    g_TraceOn               = FALSE;
    g_TraceInit             = FALSE;
    g_TraceInitInProgress   = FALSE;
    g_TraceLastInitAttempt  = 0;
}


VOID
Trace_Cleanup(
    VOID
    )
/*++

Routine Description:

    Cleaning tracing for DLL process detach.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if ( g_TraceInit )
    {
        UnregisterTraceGuids( g_TraceRegHandle );
    }
}



VOID
InitializeTracePrivate(
    VOID
    )
/*++

Routine Description:

    Real tracing init.

Arguments:

    None

Globals:

    g_TraceInit -- is set if successful

    g_TraceLastInitAttempt -- is set with timestamp (in secs) if
        init attempt is made

    g_TraceRegHandle -- if set if init was successful

Return Value:

    None.

--*/
{
    ULONG   status;
    TCHAR   imagePath[MAXSTR];
    DWORD   currentTime;
    HMODULE hModule;

    //
    //  don't try init if recently tried
    //

    currentTime = GetCurrentTimeInSeconds();

    if ( currentTime < g_TraceLastInitAttempt + TRACE_INIT_RETRY_TIME )
    {
        return;
    }

    //
    //  protect init attempts
    //
    //  note:  use separate flag for interlock
    //      since the actual use of tracing is protected by a separate
    //      flag (g_TraceOn), it looks like we could directly use g_TraceInit
    //      as lock, as it can safely be set even when not initialize;
    //      however the cleanup function will attempt cleanup of g_TraceRegHandle
    //      and i'm using g_TraceInit to protect that; 
    //      in theory we shouldn't get to cleanup function with a thread
    //      still active attempting this init, but better to lock it down
    //

    if ( InterlockedIncrement( &g_TraceInitInProgress ) != 1 )
    {
        goto Unlock;
    }

    g_TraceLastInitAttempt = currentTime;

    hModule = GetModuleHandle("dnsapi.dll");

    status = GetModuleFileName(
                    hModule,
                    &imagePath[0],
                    MAXSTR);

    if ( status == 0 )
    {
        status = GetLastError();
        DNSDBG( INIT, (
            "Trace init failed GetModuleFileName() => %d\n",
            status ));
        goto Unlock;
    }

    __try
    {
        status = RegisterTraceGuids( 
                    (WMIDPREQUEST) ControlCallback,   //use same callback function
                    NULL,
                    (LPCGUID ) &ProviderGuid,
                    g_NumEventGuids,
                    &TraceGuidReg[0],
                    (LPCTSTR) &imagePath[0],
                    (LPCTSTR) _T( "MofResource" ),
                    &g_TraceRegHandle
                    );

        if ( status == ERROR_SUCCESS )
        {
            g_TraceInit = TRUE;
        }
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        status = GetExceptionCode();
    }

Unlock:

    //  clear init lockout

    InterlockedDecrement( &g_TraceInitInProgress );
}



//
//  Public DNS trace functions
//

VOID 
Trace_LogQueryEvent( 
    IN      PDNS_MSG_BUF    pMsg, 
    IN      WORD            wQuestionType
    )
/*++

Routine Description:

    Logs query attempts.

Arguments:

    pMsg -- Ptr to query sent

    wQuestionType -- Query type

Return:

    None

--*/
{
    DNS_QUERY_EVENT queryEvent;

    if ( !g_TraceInit )
    {
        InitializeTracePrivate();
    }

    if ( g_TraceOn )
    {
        INT i;
        INT j;
        INT k;

        RtlZeroMemory(
            &queryEvent,
            sizeof(DNS_QUERY_EVENT) );

        queryEvent.EventHeader.Class.Type = 1;
        queryEvent.EventHeader.Guid  = DnsQueryGuid;
        queryEvent.EventHeader.Flags = WNODE_FLAG_TRACED_GUID;
        queryEvent.Xid               = pMsg->MessageHead.Xid;
        queryEvent.QueryType         = wQuestionType;

        i = 0;
        j = pMsg->MessageBody[i];
        i++;

        while ( j != 0 )
        {
            for( k = 0; k < j; k++, i++ )
            {
                queryEvent.Query[i-1] = pMsg->MessageBody[i];
            }
            j = pMsg->MessageBody[i];
            queryEvent.Query[i-1] = '.';
            i++;
        }
        queryEvent.Query[i-1] = '\0';

        queryEvent.EventHeader.Size =
            sizeof(DNS_QUERY_EVENT) + strlen( queryEvent.Query ) - 255;

        TraceEvent(
            g_LoggerHandle,
            (PEVENT_TRACE_HEADER) &queryEvent );
    }
}



VOID
Trace_LogResponseEvent( 
    IN      PDNS_MSG_BUF    pMsg, 
    IN      WORD            wRespType,
    IN      DNS_STATUS      Status
    )
/*++

Routine Description:

    Used to log information about the final response of a DNS query.

Arguments:

    pMsg        -- Address of the DNS_MSG_BUF containing response

    wRespType   -- Type of the first response record

    Status      -- Status returned

Return:

    None

--*/
{
    DNS_RESPONSE_EVENT respEvent;

    if ( !g_TraceInit )
    {
        InitializeTracePrivate();
    }

    if ( g_TraceOn )
    {
        RtlZeroMemory(
            &respEvent,
            sizeof(DNS_RESPONSE_EVENT) );

        respEvent.EventHeader.Class.Type = 1;
        respEvent.EventHeader.Size  = sizeof(DNS_RESPONSE_EVENT);
        respEvent.EventHeader.Guid  = DnsResponseGuid;
        respEvent.EventHeader.Flags = WNODE_FLAG_TRACED_GUID;
        respEvent.Xid               = pMsg->MessageHead.Xid;
        respEvent.RespType          = wRespType;
        respEvent.ReturnStatus      = Status;

        TraceEvent(
            g_LoggerHandle,
            (PEVENT_TRACE_HEADER) &respEvent );
    }
}



VOID
Trace_LogSendEvent( 
    IN      PDNS_MSG_BUF    pMsg,
    IN      DNS_STATUS      Status
    )
/*++

Routine Description:

    Logs a TCP or UDP send event.

Arguments:

    pMsg    - message sent

    Status  - status of the send attempt

Return Value:

    None

--*/
{
    DNS_SEND_EVENT sendEvent;

    if ( !g_TraceInit )
    {
        InitializeTracePrivate();
    }

    if ( g_TraceOn )
    {
        UCHAR   eventType = EVENT_TRACE_TYPE_UDP;

        if ( pMsg->fTcp )
        {
            eventType = EVENT_TRACE_TYPE_TCP;
        }

        RtlZeroMemory(
            &sendEvent,
            sizeof(DNS_SEND_EVENT) );

        sendEvent.EventHeader.Class.Type    = eventType;
        sendEvent.EventHeader.Size          = sizeof(DNS_SEND_EVENT);
        sendEvent.EventHeader.Guid          = DnsSendGuid;
        sendEvent.EventHeader.Flags         = WNODE_FLAG_TRACED_GUID;
        sendEvent.DnsServer                 = MSG_REMOTE_IP4(pMsg);
        sendEvent.ReturnStatus              = Status;

        RtlCopyMemory(
            & sendEvent.DnsHeader,
            & pMsg->MessageHead,
            sizeof(DNS_HEADER) );

        TraceEvent(
            g_LoggerHandle,
            (PEVENT_TRACE_HEADER) &sendEvent );
    }
}



VOID 
Trace_LogRecvEvent( 
    IN      PDNS_MSG_BUF    pMsg,
    IN      DNS_STATUS      Status,
    IN      BOOL            fTcp
    )
/*++

Routine Description:

    Logs information about a receive event.

Arguments:

    pMsg    - message received

    Status  - status returned from receive call

    fTcp    - TRUE for TCP recv;  FALSE for UDP

Return Value:

    None

--*/
{
    DNS_RECV_EVENT recvEvent;

    if ( !g_TraceInit )
    {
        InitializeTracePrivate();
    }

    if ( g_TraceOn )
    {
        IP4_ADDRESS ipAddr = 0;
        UCHAR       eventType = EVENT_TRACE_TYPE_UDP;

        if ( fTcp )
        {
            eventType = EVENT_TRACE_TYPE_TCP;
        }
        if ( pMsg )
        {

            ipAddr = MSG_REMOTE_IP4(pMsg);
        }

        RtlZeroMemory(
            & recvEvent,
            sizeof(DNS_RECV_EVENT) );

        recvEvent.EventHeader.Class.Type    = eventType;
        recvEvent.EventHeader.Size          = sizeof(DNS_RECV_EVENT);
        recvEvent.EventHeader.Guid          = DnsRecvGuid;
        recvEvent.EventHeader.Flags         = WNODE_FLAG_TRACED_GUID;
        recvEvent.DnsServer                 = ipAddr;
        recvEvent.ReturnStatus              = Status;

        if ( pMsg )
        {
            RtlCopyMemory(
                & recvEvent.DnsHeader,
                & pMsg->MessageHead,
                sizeof(DNS_HEADER) );
        }

        TraceEvent(
            g_LoggerHandle,
            (PEVENT_TRACE_HEADER) &recvEvent );
    }
}

//
//  End trace.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\update.c ===
/*++

Copyright (c) 1996-2001  Microsoft Corporation

Module Name:

    update.c

Abstract:

    Domain Name System (DNS) API

    Update client routines.

Author:

    Jim Gilroy (jamesg)     October, 1996

Revision History:

--*/


#include "local.h"


//
//  Security flag check
//

#define UseSystemDefaultForSecurity(flag)   \
        ( ((flag) & DNS_UPDATE_SECURITY_CHOICE_MASK) \
            == DNS_UPDATE_SECURITY_USE_DEFAULT )

//
//  Local update flag
//  - must make sure this is in UPDATE_RESERVED space
//

#define DNS_UPDATE_LOCAL_COPY       (0x00010000)

//
//  DCR_DELETE:  this is stupid
//

#define DNS_UNACCEPTABLE_UPDATE_OPTIONS \
        (~                                      \
          ( DNS_UPDATE_SHARED                 | \
            DNS_UPDATE_SECURITY_OFF           | \
            DNS_UPDATE_CACHE_SECURITY_CONTEXT | \
            DNS_UPDATE_SECURITY_ON            | \
            DNS_UPDATE_FORCE_SECURITY_NEGO    | \
            DNS_UPDATE_TRY_ALL_MASTER_SERVERS | \
            DNS_UPDATE_LOCAL_COPY             | \
            DNS_UPDATE_SECURITY_ONLY ))


//
//  Update Timeouts
//
//  note, max is a little longer than might be expected as DNS server
//  may have to contact primary and wait for primary to do update (inc.
//  disk access) then response
//

#define INITIAL_UPDATE_TIMEOUT  (4)     // 4 seconds
#define MAX_UPDATE_TIMEOUT      (60)    // 60 seconds



//
//  Private prototypes
//

DNS_STATUS
DoQuickUpdate(
    IN      PDNS_RECORD     pRecord,
    IN      DWORD           dwFlags,
    IN      BOOL            fUpdateTestMode,
    IN      PIP_ARRAY       pServerList     OPTIONAL,
    IN      HANDLE          hCreds          OPTIONAL
    );

DNS_STATUS
DoQuickUpdateEx(
    OUT     PDNS_MSG_BUF *      ppMsgRecv, OPTIONAL
    IN      PDNS_RECORD         pRecord,
    IN      DWORD               dwFlags,
    IN      PDNS_NETINFO        pNetworkInfo,
    IN      HANDLE              hCreds OPTIONAL
    );

DNS_STATUS
DoMultiMasterUpdate(
    IN      PDNS_RECORD     pRecord,
    IN      DWORD           dwFlags,
    IN      HANDLE          hCreds          OPTIONAL,
    IN      LPSTR           pszDomain,
    IN      IP_ADDRESS      BadIp,
    IN      PIP_ARRAY       pServerList
    );

VOID
SetLastFailedUpdateInfo(
    IN      PDNS_MSG_BUF    pMsg,
    IN      DNS_STATUS      Status
    );




PCHAR
Dns_WriteNoDataUpdateRecordToMessage(
    IN      PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      WORD            wClass,
    IN      WORD            wType
    )
/*++

Routine Description:

    No data RR cases:

    This includes prereqs and deletes except for specific record cases.

Arguments:

    pch - ptr to next byte in packet buffer

    pchStop - end of packet buffer

    wClass - class

    wType - desired RR type

Return Value:

    Ptr to next postion in buffer, if successful.
    NULL on error.

--*/
{
    PDNS_WIRE_RECORD    pdnsRR;

    DNSDBG( WRITE, (
        "Writing update RR to packet buffer at %p.\n",
        pch ));

    //
    //  out of space
    //

    pdnsRR = (PDNS_WIRE_RECORD) pch;
    pch += sizeof( DNS_WIRE_RECORD );
    if ( pch >= pchStop )
    {
        DNS_PRINT(( "ERROR  out of space writing record to packet.\n" ));
        return( NULL );
    }

    //
    //  set type and class
    //

    *(UNALIGNED WORD *) &pdnsRR->RecordType  = htons( wType );
    *(UNALIGNED WORD *) &pdnsRR->RecordClass = htons( wClass );

    //
    //  TTL and datalength zero for all no data cases
    //      - prereqs except specific record delete
    //      - deletes except specific record delete
    //

    *(UNALIGNED DWORD *) &pdnsRR->TimeToLive = 0;
    *(UNALIGNED WORD *) &pdnsRR->DataLength = 0;

    return( pch );
}



PCHAR
Dns_WriteDataUpdateRecordToMessage(
    IN      PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      WORD            wClass,
    IN      WORD            wType,
    IN      DWORD           dwTtl,
    IN      WORD            wDataLength
    )
/*++

Routine Description:

    No data RR cases:

    This includes prereqs and deletes except for specific record cases.

Arguments:

    pch - ptr to next byte in packet buffer

    pchStop - end of packet buffer

    wClass - class

    wType - desired RR type

    dwTtl - time to live

    wDataLength - data length

Return Value:

    Ptr to next postion in buffer, if successful.
    NULL on error.

--*/
{
    PDNS_WIRE_RECORD    pdnsRR;

    DNSDBG( WRITE2, (
        "Writing RR to packet buffer at %p.\n",
        pch ));

    //
    //  out of space
    //

    pdnsRR = (PDNS_WIRE_RECORD) pch;
    pch += sizeof( DNS_WIRE_RECORD );
    if ( pch + wDataLength >= pchStop )
    {
        DNS_PRINT(( "ERROR  out of space writing record to packet.\n" ));
        return( NULL );
    }

    //
    //  set type and class
    //

    *(UNALIGNED WORD *) &pdnsRR->RecordType  = htons( wType );
    *(UNALIGNED WORD *) &pdnsRR->RecordClass = htons( wClass );

    //
    //  TTL and datalength zero for all no data cases
    //      - prereqs except specific record delete
    //      - deletes except specific record delete
    //

    *(UNALIGNED DWORD *) &pdnsRR->TimeToLive = htonl( dwTtl );
    *(UNALIGNED WORD *) &pdnsRR->DataLength = htons( wDataLength );

    return( pch );
}



//
//  Host update routines
//

#if 0
PDNS_MSG_BUF
Dns_BuildHostUpdateMessage(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      LPSTR           pszZone,
    IN      LPSTR           pszName,
    IN      PIP_ARRAY       aipAddresses,
    IN      DWORD           dwTtl
    )
/*++

Routine Description:

    Build server update message.

Arguments:

    pMsg -- existing message buffer, to use;  NULL to allocate new one

    pszZone -- zone name for update

    pszName -- full DNS hostname being updated

    aipAddresses -- IP addresses to be updated

Return Value:

    ERROR_SUCCESS if successful.
    Error status on failure.

--*/
{
    PDNS_HEADER     pdnsMsg;
    PCHAR           pch;
    PCHAR           pchstop;
    DWORD           i;
    WORD            nameOffset;

    IF_DNSDBG( UPDATE )
    {
        DNS_PRINT((
            "Enter Dns_BuildHostUpdateMessage()\n"
            "\tpMsg     = %p\n"
            "\tpszZone  = %s\n"
            "\tpszName  = %s\n"
            "\tdwTtl    = %d\n",
            pMsg,
            pszZone,
            pszName,
            dwTtl ));
        DnsDbg_IpArray(
            "\tHost IP array\n",
            "host",
            aipAddresses );
    }

    //
    //  create message buffer
    //

    if ( !pMsg )
    {
        DNS_PRINT(( "Allocating new UPDATE message buffer.\n" ));

        pMsg = ALLOCATE_HEAP( DNS_UDP_ALLOC_LENGTH );
        if ( !pMsg )
        {
            return( NULL );
        }
        RtlZeroMemory(
            pMsg,
            DNS_UDP_ALLOC_LENGTH );

        pMsg->BufferLength = DNS_UDP_MAX_PACKET_LENGTH;
        pMsg->pBufferEnd = (PCHAR)&pMsg->MessageHead + pMsg->BufferLength;

        //
        //  set default sockaddr info
        //      - caller MUST choose remote IP address

        pMsg->RemoteAddress.sin_family = AF_INET;
        pMsg->RemoteAddress.sin_port = NET_ORDER_DNS_PORT;
        pMsg->RemoteAddressLength = sizeof( SOCKADDR_IN );

        //  set header for update

        pMsg->MessageHead.Opcode = DNS_OPCODE_UPDATE;
    }

    //
    //  existing message, just verify
    //

    ELSE_ASSERT( pMsg->MessageHead.Opcode == DNS_OPCODE_UPDATE );

    //
    //  reset current pointer after header
    //      - note:  send length is set based on this ptr
    //

    pMsg->pCurrent = pMsg->MessageBody;


    //
    //  build message
    //

    pch = pMsg->pCurrent;
    pchstop = pMsg->pBufferEnd;

    //
    //  zone section
    //

    pMsg->MessageHead.QuestionCount = 1;
    pch = Dns_WriteDottedNameToPacket(
            pch,
            pchstop,
            pszZone,
            NULL,
            0,
            FALSE );
    if ( !pch )
    {
        return( NULL );
    }
    *(UNALIGNED WORD *) pch = DNS_RTYPE_SOA;
    pch += sizeof(WORD);
    *(UNALIGNED WORD *) pch = DNS_RCLASS_INTERNET;
    pch += sizeof(WORD);

    //
    //  prerequisites -- no records
    //

    pMsg->MessageHead.AnswerCount = 0;

    //
    //  update
    //      - delete A records at name
    //      - add new A records
    //

    //  save offset to host name for future writes

    nameOffset = (WORD)(pch - (PCHAR) &pMsg->MessageHead);

    pch = Dns_WriteDottedNameToPacket(
                pch,
                pchstop,
                pszName,
                pszZone,
                DNS_OFFSET_TO_QUESTION_NAME,
                FALSE );
    if ( !pch )
    {
        DNS_PRINT(( "ERROR writing dotted name to packet.\n" ));
        return( NULL );
    }
    pch = Dns_WriteNoDataUpdateRecordToMessage(
                pch,
                pchstop,
                DNS_CLASS_ALL,  //  delete all
                DNS_TYPE_A     //  A records
                );
    DNS_ASSERT( pch );

    //
    //  add A record for each address in array
    //      - use offset for name
    //      - write IP

    for ( i=0; i<aipAddresses->AddrCount; i++ )
    {
        *(UNALIGNED WORD *) pch = htons( (WORD)(nameOffset|(WORD)0xC000) );
        pch += sizeof( WORD );
        pch = Dns_WriteDataUpdateRecordToMessage(
                    pch,
                    pchstop,
                    DNS_CLASS_INTERNET,
                    DNS_TYPE_A,        //  A records
                    dwTtl,
                    sizeof(IP_ADDRESS)
                    );
        DNS_ASSERT( pch );
        *(UNALIGNED DWORD *) pch = aipAddresses->AddrArray[i];
        pch += sizeof(DWORD);
    }

    //  total update sections RRs
    //      one delete RR, plus one for each new IP

    pMsg->MessageHead.NameServerCount = (USHORT)(aipAddresses->AddrCount + 1);

    //
    //  additional section - no records
    //

    pMsg->MessageHead.AdditionalCount = 0;

    //
    //  reset current ptr -- need for send routine
    //

    pMsg->pCurrent = pch;

    IF_DNSDBG( SEND )
    {
        DnsDbg_Message(
            "UPDATE packet built",
            pMsg );
    }
    return( pMsg );
}
#endif



PDNS_RECORD
Dns_HostUpdateRRSet(
    IN      LPSTR           pszHostName,
    IN      PIP_ARRAY       AddrArray,
    IN      DWORD           dwTtl
    )
/*++

Routine Description:

    Create records for host update:
        -- whack of all A records
        -- add of all A records in new set

Arguments:

    pszHostName -- host name, FULL FQDN

    AddrArray -- new IPs of host

    dwTtl -- TTL for records

Return Value:

    Ptr to record list.
    NULL on error.

--*/
{
    DNS_RRSET   rrset;
    PDNS_RECORD prr;
    DWORD       i;

    //
    //  create whack
    //

    prr = Dns_AllocateRecord( 0 );
    if ( ! prr )
    {
        return( NULL );
    }
    prr->pName = pszHostName;
    prr->wType = DNS_TYPE_A;
    prr->Flags.S.Section = DNSREC_UPDATE;
    prr->Flags.S.Delete = TRUE;

    //
    //  create update record for each address
    //

    if ( !AddrArray )
    {
        return( prr );
    }
    DNS_RRSET_INIT( rrset );
    DNS_RRSET_ADD( rrset, prr );

    for ( i=0; i<AddrArray->AddrCount; i++ )
    {
        prr = Dns_AllocateRecord( sizeof(DNS_A_DATA) );
        if ( ! prr )
        {
            Dns_RecordListFree( rrset.pFirstRR );
            return( NULL );
        }
        prr->pName = pszHostName;
        prr->wType = DNS_TYPE_A;
        prr->Flags.S.Section = DNSREC_UPDATE;
        prr->dwTtl = dwTtl;
        prr->Data.A.IpAddress = AddrArray->AddrArray[i];

        DNS_RRSET_ADD( rrset, prr );
    }

    //  return ptr to first record in list

    return( rrset.pFirstRR );
}



//
//  DCR:  dead code, remove
//
DNS_STATUS
Dns_UpdateHostAddrs(
    IN      LPSTR           pszName,
    IN      PIP_ARRAY       aipAddresses,
    IN      PIP_ARRAY       aipServers,
    IN      DWORD           dwTtl
    )
/*++

Routine Description:

    Updates client's A records registered with DNS server.

Arguments:

    pszName -- name (FQDN) of client to update

    aipAddresses -- counted array of new client IP addrs

    aipServers -- counted array of DNS server IP addrs

    dwTtl -- TTL for new A records

Return Value:

    ERROR_SUCCESS if successful.
    Error status on failure.

--*/
{
    PDNS_RECORD prr;
    DNS_STATUS  status;

    IF_DNSDBG( UPDATE )
    {
        DNS_PRINT((
            "Enter Dns_UpdateHostAddrs()\n"
            "\tpszName  = %s\n"
            "\tdwTtl    = %d\n",
            pszName,
            dwTtl ));
        DnsDbg_IpArray(
            "\tHost IP array\n",
            "\tHost",
            aipAddresses );
        DnsDbg_IpArray(
            "\tNS IP array\n",
            "\tNS",
            aipServers );
    }

    //
    //  never let anyone set a TTL longer than 1 hour
    //
    //  DCR:  define policy on what our clients should use for TTL
    //      one hour is not bad
    //      could key off type of address
    //          RAS -- 15 minutes (as may be back up again quickly)
    //          DHCP -- one hour (may move)
    //          static -- one day (machines may be reconfigured)
    //

    if ( dwTtl > 3600 )
    {
        dwTtl = 3600;
    }

    //
    //  build update RR set
    //

    prr = Dns_HostUpdateRRSet(
            pszName,
            aipAddresses,
            dwTtl );
    if ( ! prr )
    {
        status = GetLastError();
        DNS_ASSERT( status == DNS_ERROR_NO_MEMORY );
        return status;
    }

    //
    //  do the update
    //

    status = Dns_UpdateLib(
                prr,
                0,          // no flags
                NULL,       // no adapter list
                NULL,       // use default credentials
                NULL        // response not desired
                );

    Dns_RecordListFree( prr );

    DNSDBG( UPDATE, (
        "Leave Dns_UpdateHostAddrs() status=%d %s\n",
        status,
        Dns_StatusString(status) ));

    return( status );
}



DNS_STATUS
Dns_UpdateLib(
    IN      PDNS_RECORD         pRecord,
    IN      DWORD               dwFlags,
    IN      PDNS_NETINFO        pNetworkInfo,
    IN      HANDLE              hCreds          OPTIONAL,
    OUT     PDNS_MSG_BUF *      ppMsgRecv       OPTIONAL
    )
/*++

Routine Description:

    Send DNS update.

Arguments:

    pRecord -- list of records to send in update

    dwFlags -- update flags;  primarily security

    pNetworkInfo -- adapter list with necessary info for update
                        - zone name
                        - primary name server name
                        - primary name server IP

    hCreds -- credentials handle returned from


    ppMsgRecv -- OPTIONAL addr to recv ptr to response message

Return Value:

    ERROR_SUCCESS if successful.
    Error status on failure.

--*/
{
    PDNS_MSG_BUF    pmsgSend = NULL;
    PDNS_MSG_BUF    pmsgRecv = NULL;
    DNS_STATUS      status = NO_ERROR;
    WORD            length;
    PIP_ARRAY       parrayServers = NULL;
    LPSTR           pszzone;
    LPSTR           pszserverName;
    BOOL            fsecure = FALSE;
    BOOL            fswitchToTcp = FALSE;
    DNS_HEADER      header;
    PCHAR           pCreds=NULL;

    DNSDBG( UPDATE, (
        "Dns_UpdateLib()\n"
        "\tflags        = %08x\n"
        "\tpRecord      = %p\n"
        "\t\towner      = %s\n",
        dwFlags,
        pRecord,
        pRecord ? pRecord->pName : NULL ));

    //
    //  if not a UPDATE compatibile adapter list -- no action
    //

    if ( ! NetInfo_IsForUpdate(pNetworkInfo) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    //  suck info from adapter list
    //

    pszzone = NetInfo_UpdateZoneName( pNetworkInfo );

    parrayServers = NetInfo_ConvertToIpArray( pNetworkInfo );

    pszserverName = NetInfo_UpdateServerName( pNetworkInfo );

    DNS_ASSERT( pszzone && parrayServers );

    //
    //  build recv message buffer
    //      - must be big enough for TCP
    //

    pmsgRecv = Dns_AllocateMsgBuf( DNS_TCP_DEFAULT_PACKET_LENGTH );
    if ( !pmsgRecv )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Cleanup;
    }

    //
    //  build update packet
    //  note currently this function allocates TCP sized buffer if records
    //      given;  if this changes need to alloc TCP buffer here
    //

    CLEAR_DNS_HEADER_FLAGS_AND_XID( &header );
    header.Opcode = DNS_OPCODE_UPDATE;

    pmsgSend = Dns_BuildPacket(
                    &header,        // copy header
                    TRUE,           //  ... but not header counts
                    pszzone,        // question zone\type SOA
                    DNS_TYPE_SOA,
                    pRecord,
                    0,              // no other flags
                    TRUE            // building an update packet
                    );
    if ( !pmsgSend)
    {
        DNS_PRINT(( "ERROR:  failed send buffer allocation.\n" ));
        status = DNS_ERROR_NO_MEMORY;
        goto Cleanup;
    }

    //
    //  try non-secure first unless explicitly secure only
    //

    fsecure = (dwFlags & DNS_UPDATE_SECURITY_ONLY);

    if ( !fsecure )
    {
        status = Dns_SendAndRecv(
                    pmsgSend,
                    & pmsgRecv,
                    NULL,           // no response records
                    dwFlags,
                    parrayServers,
                    pNetworkInfo );

        if ( status == ERROR_SUCCESS )
        {
            status = Dns_MapRcodeToStatus( pmsgRecv->MessageHead.ResponseCode );
        }

        if ( status != DNS_ERROR_RCODE_REFUSED ||
            dwFlags & DNS_UPDATE_SECURITY_OFF )
        {
            goto Cleanup;
        }

        DNSDBG( UPDATE, (
            "Failed unsecure update, switching to secure!\n"
            "\tcurrent time (ms) = %d\n",
            GetCurrentTime() ));
        fsecure = TRUE;
    }

    //
    //  security
    //      - must have server name
    //      - must start package
    //

    if ( fsecure )
    {
        if ( !pszserverName )
        {
            status = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
        status = Dns_StartSecurity( FALSE );
        if ( status != ERROR_SUCCESS )
        {
            goto Cleanup;
        }

        //
        //  DCR:  hCreds doesn't return security context
        //      - idea of something beyond just standard security
        //      credentials was we'd been able to return the context
        //      handle
        //  

        pCreds = Dns_GetApiContextCredentials(hCreds);

        status = Dns_DoSecureUpdate(
                    pmsgSend,
                    pmsgRecv,
                    NULL,
                    dwFlags,
                    pNetworkInfo,
                    parrayServers,
                    pszserverName,
                    pCreds,         // initialized in DnsAcquireContextHandle
                    NULL            // default context name
                    );
        if ( status == ERROR_SUCCESS )
        {
            status = Dns_MapRcodeToStatus( pmsgRecv->MessageHead.ResponseCode );
        }
    }


Cleanup:

    //  free server array sucked from adapter list

    if ( parrayServers )
    {
        FREE_HEAP( parrayServers );
    }

    //  return recv message buffer

    if ( ppMsgRecv )
    {
        *ppMsgRecv = pmsgRecv;
    }
    else
    {
        FREE_HEAP( pmsgRecv );
    }
    FREE_HEAP( pmsgSend);

    DNSDBG( UPDATE, (
        "Dns_UpdateLib() completed, status = %d %s.\n\n",
        status,
        Dns_StatusString(status) ));

    return( status );
}



DNS_STATUS
Dns_UpdateLibEx(
    IN      PDNS_RECORD         pRecord,
    IN      DWORD               dwFlags,
    IN      PDNS_NAME           pszZone,
    IN      PDNS_NAME           pszServerName,
    IN      PIP_ARRAY           aipServers,
    IN      HANDLE              hCreds          OPTIONAL,
    OUT     PDNS_MSG_BUF *      ppMsgRecv       OPTIONAL
    )
/*++

Routine Description:

    Send DNS update.

    This routine builds an UPDATE compatible pNetworkInfo from the
    information given.  Then calls Dns_Update().

Arguments:

    pRecord -- list of records to send in update

    pszZone -- zone name for update

    pszServerName -- server name

    aipServers -- DNS servers to send update to

    hCreds -- Optional Credentials info

    ppMsgRecv -- addr for ptr to recv buffer, if desired

Return Value:

    ERROR_SUCCESS if successful.
    Error status on failure.

--*/
{
    PDNS_NETINFO        pnetInfo;
    DNS_STATUS          status = NO_ERROR;

    DNSDBG( UPDATE, ( "Dns_UpdateLibEx()\n" ));

    //
    //  convert params into UPDATE compatible adapter list
    //

    pnetInfo = NetInfo_CreateForUpdate(
                        pszZone,
                        pszServerName,
                        aipServers,
                        0 );

    if ( !pnetInfo )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    //  call real update function
    //

    status = Dns_UpdateLib(
                pRecord,
                dwFlags,
                pnetInfo,
                hCreds,
                ppMsgRecv );

    NetInfo_Free( pnetInfo );

    return status;
}



//
//  Update credentials
//

//
//  Credentials are an optional future parameter to allow the caller
//  to set the context handle to that of a given NT account. This
//  structure will most likely be the following as defined in rpcdce.h:
//
//  #define SEC_WINNT_AUTH_IDENTITY_ANSI    0x1
//
//  typedef struct _SEC_WINNT_AUTH_IDENTITY_A {
//        unsigned char __RPC_FAR *User;
//        unsigned long UserLength;
//        unsigned char __RPC_FAR *Domain;
//        unsigned long DomainLength;
//        unsigned char __RPC_FAR *Password;
//        unsigned long PasswordLength;
//        unsigned long Flags;
//  } SEC_WINNT_AUTH_IDENTITY_A, *PSEC_WINNT_AUTH_IDENTITY_A;
//
//  #define SEC_WINNT_AUTH_IDENTITY_UNICODE 0x2
//  
//  typedef struct _SEC_WINNT_AUTH_IDENTITY_W {
//    unsigned short __RPC_FAR *User;
//    unsigned long UserLength;
//    unsigned short __RPC_FAR *Domain;
//    unsigned long DomainLength;
//    unsigned short __RPC_FAR *Password;
//    unsigned long PasswordLength;
//    unsigned long Flags;
//  } SEC_WINNT_AUTH_IDENTITY_W, *PSEC_WINNT_AUTH_IDENTITY_W;
//


DNS_STATUS
WINAPI
DnsAcquireContextHandle_W(
    IN      DWORD           CredentialFlags,
    IN      PVOID           Credentials     OPTIONAL,
    OUT     PHANDLE         pContext
    )
/*++

Routine Description:

    Get credentials handle to security context for update.

    The handle can for the default process credentials (user account or
    system machine account) or for a specified set of credentials
    identified by Credentials.

Arguments:

    CredentialFlags -- flags

    Credentials -- a PSEC_WINNT_AUTH_IDENTITY_W
        (explicit definition skipped to avoid requiring rpcdec.h)

    pContext -- addr to receive credentials handle

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    if ( ! pContext )
    {
        return ERROR_INVALID_PARAMETER;
    }

    *pContext = Dns_CreateAPIContext(
                    CredentialFlags,
                    Credentials,
                    TRUE        // unicode
                    );
    if ( ! *pContext )
    {
        return DNS_ERROR_NO_MEMORY;
    }
    else
    {
        return NO_ERROR;
    }
}



DNS_STATUS
WINAPI
DnsAcquireContextHandle_A(
    IN      DWORD           CredentialFlags,
    IN      PVOID           Credentials     OPTIONAL,
    OUT     PHANDLE         pContext
    )
/*++

Routine Description:

    Get credentials handle to security context for update.

    The handle can for the default process credentials (user account or
    system machine account) or for a specified set of credentials
    identified by Credentials.

Arguments:

    CredentialFlags -- flags

    Credentials -- a PSEC_WINNT_AUTH_IDENTITY_A
        (explicit definition skipped to avoid requiring rpcdec.h)

    pContext -- addr to receive credentials handle

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    if ( ! pContext )
    {
        return ERROR_INVALID_PARAMETER;
    }

    *pContext = Dns_CreateAPIContext(
                    CredentialFlags,
                    Credentials,
                    FALSE );
    if ( ! *pContext )
    {
        return DNS_ERROR_NO_MEMORY;
    }
    else
    {
        return NO_ERROR;
    }
}



VOID
WINAPI
DnsReleaseContextHandle(
    IN      HANDLE          ContextHandle
    )
/*++

Routine Description:

    Frees context handle created by DnsAcquireContextHandle_X() routines.

Arguments:

    ContextHandle - Handle to be closed.

Return Value:

    None.

--*/
{
    if ( ContextHandle )
    {
        //
        //  free any cached security context handles
        //
        //  DCR_FIX0:  should delete all contexts associated with this
        //      context (credentials handle) not all
        //
        //  DCR:  to be robust, user "ContextHandle" should be ref counted
        //      it should be set one on create;  when in use, incremented
        //      then dec when done;  then this Free could not collide with
        //      another thread's use
        //

        //Dns_TimeoutSecurityContextListEx( TRUE, ContextHandle );

        Dns_TimeoutSecurityContextList( TRUE );

        Dns_FreeAPIContext( ContextHandle );
    }
}



//
//  Utilities
//

DWORD
prepareUpdateRecordSet(
    IN OUT  PDNS_RECORD     pRRSet,
    IN      BOOL            fClearTtl,
    IN      BOOL            fSetFlags,
    IN      WORD            wFlags
    )
/*++

Routine Description:

    Validate and prepare record set for update.
        - record set is single RR set
        - sets record flags for update

Arguments:

    pRRSet -- record set;  MUST be in UTF8
        note:  pRRSet is not touched (not OUT param)
        IF fClearTtl AND fSetFlags are both FALSE

    fClearTtl -- clear TTL in records;  TRUE for delete set

    fSetFlags -- set section and delete flags

    wFlags -- flags field to set
            (should contain desired section and delete flags)

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_INVALID_PARAMETER if record set is not acceptable.

--*/
{
    PDNS_RECORD prr;
    PSTR        pname;
    WORD        type;

    DNSDBG( TRACE, ( "prepareUpdateRecordSet()\n" ));

    //  validate

    if ( !pRRSet )
    {
        return ERROR_INVALID_PARAMETER;
    }

    type = pRRSet->wType;

    //
    //  note:  could do an "update-type" check here, but that just
    //      A) burns unnecessary memory and cycles
    //      B) makes it harder to test bogus records sent in updates
    //          to the server
    //

    pname = (PSTR) pRRSet->pName;
    if ( !pname )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    //  check each RR in set
    //      - validate RR is in set
    //      - set RR flags
    //

    prr = pRRSet;

    while ( prr )
    {
        if ( fSetFlags )
        {
            prr->Flags.S.Section = 0;
            prr->Flags.S.Delete = 0;
            prr->Flags.DW |= wFlags;
        }
        if ( fClearTtl )
        {
            prr->dwTtl = 0;
        }

        //  check current RR in set
        //      - matches name and type

        if ( prr != pRRSet )
        {
            if ( prr->wType != type ||
                 ! prr->pName ||
                 ! Dns_NameCompare_UTF8( pname, prr->pName ) )
            {
                return ERROR_INVALID_PARAMETER;
            }
        }

        prr = prr->pNext;
    }

    return  ERROR_SUCCESS;
}



PDNS_RECORD
DnsBuildUpdateSet(
    IN OUT  PDNS_RECORD     pPrereqSet,
    IN OUT  PDNS_RECORD     pAddSet,
    IN OUT  PDNS_RECORD     pDeleteSet
    )
/*++

Routine Description:

    Build combined record list for update.
    Combines prereq, delete and add records.

    Note:  record sets MUST be in UTF8.

Arguments:

    pPrereqSet -- prerequisite records;  note this does NOT
        include delete preqs (see note below)

    pAddSet -- records to add

    pDeleteSet -- records to delete

Return Value:

    Ptr to combined record list for update.

--*/
{
    PDNS_RECORD plast = NULL;
    PDNS_RECORD pfirst = NULL;


    DNSDBG( TRACE, ( "DnsBuildUpdateSet()\n" ));

    //
    //  append prereq set
    //
    //  DCR:  doesn't handle delete prereqs
    //      this is fine because we roll our own, but if
    //      later expand the function, then need them
    //
    //      note, I could add flag==PREREQ datalength==0
    //      test in prepareUpdateRecordSet() function, then
    //      set Delete flag;  however, we'd still have the
    //      question of how to distinguish existence (class==ANY)
    //      prereq from delete (class==NONE) prereq -- without
    //      directly exposing the record Delete flag
    //

    if ( pPrereqSet )
    {
        plast = pPrereqSet;
        pfirst = pPrereqSet;

        prepareUpdateRecordSet(
            pPrereqSet,
            FALSE,          // no TTL clear
            TRUE,           // set flags
            DNSREC_PREREQ   // prereq section
            );

        while ( plast->pNext )
        {
            plast = plast->pNext;
        }
    }

    //
    //  append delete records
    //      do before Add records so that delete\add of same record
    //      leaves it in place
    //

    if ( pDeleteSet )
    {
        if ( !plast )
        {
            plast = pDeleteSet;
            pfirst = pDeleteSet;
        }
        else
        {
            plast->pNext = pDeleteSet;
        }

        prepareUpdateRecordSet(
             pDeleteSet,
             TRUE,                          //  clear TTL
             TRUE,                          //  set flags
             DNSREC_UPDATE | DNSREC_DELETE  //  update section, delete bit
             );

        while ( plast->pNext )
        {
            plast = plast->pNext;
        }
    }

    //
    //  append add records
    //

    if ( pAddSet )
    {
        if ( !plast )
        {
            plast = pAddSet;
            pfirst = pAddSet;
        }
        else
        {
            plast->pNext = pAddSet;
        }
        prepareUpdateRecordSet(
            pAddSet,
            FALSE,              // no TTL change
            TRUE,               // set flags
            DNSREC_UPDATE       // update section
            );
    }

    return pfirst;
}


BOOL
IsPtrUpdate(
    IN      PDNS_RECORD     pRecordList
    )
/*++

Routine Description:

    Check if update is PTR update.

Arguments:

    pRecordList -- update record list

Return Value:

    TRUE if PTR update.
    FALSE otherwise.

--*/
{
    PDNS_RECORD prr = pRecordList;
    BOOL        bptrUpdate = FALSE;

    //
    //  find, then test first record in update section
    //

    while ( prr )
    {
        if ( prr->Flags.S.Section == DNSREC_UPDATE )
        {
            if ( prr->wType == DNS_TYPE_PTR )
            {
                bptrUpdate = TRUE;
            }
            break;
        }
        prr = prr->pNext;
    }

    return bptrUpdate;
}




//
//  Replace functions
//

DNS_STATUS
WINAPI
replaceRecordsInSetPrivate(
    IN      PDNS_RECORD     pReplaceSet,
    IN      DWORD           Options,
    IN      HANDLE          hCredentials,   OPTIONAL
    IN      PIP_ARRAY       pServerList,    OPTIONAL
    IN      PVOID           pReserved,
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Replace record set routine handling all character sets.

Arguments:

    pReplaceSet     - replacement record set

    Options         -  update options

    pServerList     -  list of DNS servers to go to;  if not given, machines
        default servers are queried to find correct servers to send update to

    hCredentials    - handle to credentials to be used for update;  optional,
        if not given security credentials of this process are used in update

    pReserved       - reserved;  should be NULL

    CharSet         - character set of incoming records

Return Value:

    ERROR_SUCCESS if update successful.
    ErrorCode from server if server rejects update.
    ERROR_INVALID_PARAMETER if bad param.

--*/
{
    DNS_STATUS      status;
    PDNS_RECORD     preplaceCopy = NULL;
    PDNS_RECORD     pupdateList = NULL;
    BOOL            btypeDelete;
    DNS_RECORD      rrNoCname;
    DNS_RECORD      rrDeleteType;
    BOOL            fcnameUpdate;

    DNSDBG( TRACE, (
        "replaceRecordsInSetPrivate()\n"
        "\tpReplaceSet  = %p\n"
        "\tOptions      = %08x\n"
        "\thCredentials = %p\n"
        "\tpServerList  = %p\n"
        "\tCharSet      = %d\n",
        pReplaceSet,
        Options,
        hCredentials,
        pServerList,
        CharSet
        ));

    //
    //  read update config
    //

    Reg_RefreshUpdateConfig();

    //
    //  make local copy in UTF8
    //

    if ( !pReplaceSet )
    {
        return ERROR_INVALID_PARAMETER;
    }

    preplaceCopy = Dns_RecordSetCopyEx(
                        pReplaceSet,
                        CharSet,
                        DnsCharSetUtf8 );
    if ( !preplaceCopy )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    //  validate arguments
    //      - must have single RR set
    //      - mark them for update
    //

    status = prepareUpdateRecordSet(
                preplaceCopy,
                FALSE,          // no TTL clear
                TRUE,           // set flags
                DNSREC_UPDATE   // flag as update
                );

    if ( status != ERROR_SUCCESS )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    //  check if simple type delete
    //

    btypeDelete = ( preplaceCopy->wDataLength == 0 &&
                    preplaceCopy->pNext == NULL );


    //
    //  set security for update
    //

    if ( UseSystemDefaultForSecurity( Options ) )
    {
        Options |= g_UpdateSecurityLevel;
    }
    if ( hCredentials )
    {
        Options |= DNS_UPDATE_CACHE_SECURITY_CONTEXT;
    }

    //
    //  type delete record
    //
    //  if have replace records -- this goes in front
    //  if type delete -- then ONLY need this record
    //

    RtlZeroMemory( &rrDeleteType, sizeof(DNS_RECORD) );
    rrDeleteType.pName          = (PDNS_NAME) preplaceCopy->pName;
    rrDeleteType.wType          = preplaceCopy->wType;
    rrDeleteType.wDataLength    = 0;
    rrDeleteType.Flags.DW       = DNSREC_UPDATE | DNSREC_DELETE;

    if ( btypeDelete )
    {
        rrDeleteType.pNext = NULL;
    }
    else
    {
        rrDeleteType.pNext = preplaceCopy;
    }

    pupdateList = &rrDeleteType;

    //
    //  CNAME does not exist precondition record
    //      - for all updates EXCEPT CNAME
    //

    fcnameUpdate = ( preplaceCopy->wType == DNS_TYPE_CNAME );

    if ( !fcnameUpdate )
    {
        RtlZeroMemory( &rrNoCname, sizeof(DNS_RECORD) );
        rrNoCname.pName         = (PDNS_NAME) preplaceCopy->pName;
        rrNoCname.wType         = DNS_TYPE_CNAME;
        rrNoCname.wDataLength   = 0;
        rrNoCname.Flags.DW      = DNSREC_PREREQ | DNSREC_NOEXIST;
        rrNoCname.pNext         = &rrDeleteType;

        pupdateList = &rrNoCname;
    }

    //
    //  do the update
    //

    status = DoQuickUpdate(
                pupdateList,
                Options,
                FALSE,
                pServerList,
                hCredentials);

    if ( status == NO_ERROR )
    {
        DnsFlushResolverCacheEntry_UTF8( (LPSTR) preplaceCopy->pName );
    }

    //
    //  CNAME collision test
    //
    //  if replacing CNAME may have gotten silent ignore
    //      - first check if successfully replaced CNAME
    //      - if still not sure, check that no other records
    //      at name -- if NON-CNAME found then treat silent ignore
    //      as YXRRSET error
    //

    if ( fcnameUpdate &&
         ! btypeDelete &&
         status == NO_ERROR )
    {
        PDNS_RECORD     pqueryRR = NULL;
        BOOL            fsuccess = FALSE;

        //  DCR:  need to query update server list here to
        //      avoid intermediate caching

        status = DnsQuery_UTF8(
                        preplaceCopy->pName,
                        DNS_TYPE_CNAME,
                        DNS_QUERY_BYPASS_CACHE,
                        pServerList,
                        & pqueryRR,
                        NULL );

        if ( status == NO_ERROR &&
             Dns_RecordCompare(
                    preplaceCopy,
                    pqueryRR ) )
        {
            fsuccess = TRUE;
        }
        Dns_RecordListFree( pqueryRR );

        if ( fsuccess )
        {
            goto Cleanup;
        }

        //  query for any type at CNAME
        //  if found then assume we got a silent update
        //      success

        status = DnsQuery_UTF8(
                        preplaceCopy->pName,
                        DNS_TYPE_ALL,
                        DNS_QUERY_BYPASS_CACHE,
                        pServerList,
                        & pqueryRR,
                        NULL );
    
        if ( status == ERROR_SUCCESS )
        {
            PDNS_RECORD prr = pqueryRR;
    
            while ( prr )
            {
                if ( pReplaceSet->wType != prr->wType &&
                     Dns_NameCompare_UTF8(
                            preplaceCopy->pName,
                            prr->pName ) )
                {
                    status = DNS_ERROR_RCODE_YXRRSET;
                    break;
                }
                prr = prr->pNext;
            }
        }
        else
        {
            status = ERROR_SUCCESS;
        }
    
        Dns_RecordListFree( pqueryRR );
    }


Cleanup:

    Dns_RecordListFree( preplaceCopy );

    return status;
}



DNS_STATUS
WINAPI
DnsReplaceRecordSetUTF8(
    IN      PDNS_RECORD     pReplaceSet,
    IN      DWORD           Options,
    IN      HANDLE          hCredentials  OPTIONAL,
    IN      PIP_ARRAY       aipServers      OPTIONAL,
    IN      PVOID           pReserved
    )
/*++

Routine Description:

    Dynamic update routine to replace record set on DNS server.

Arguments:

    pReplaceSet - new record set for name and type

    Options     -  update options

    pServerList -  list of DNS servers to go to;  if not given, machines
        default servers are queried to find correct servers to send update to

    hCredentials - handle to credentials to be used for update;  optional,
        if not given securit5y credentials of this process are used in update

    pReserved - reserved;  should be NULL

Return Value:

    None.

--*/
{
    DNSDBG( TRACE, ( "DnsReplaceRecordSetUTF8()\n" ));

    return replaceRecordsInSetPrivate(
                pReplaceSet,
                Options,
                hCredentials,
                aipServers,
                pReserved,
                DnsCharSetUtf8
                );
}



DNS_STATUS
WINAPI
DnsReplaceRecordSetW(
    IN      PDNS_RECORD     pReplaceSet,
    IN      DWORD           Options,
    IN      HANDLE          hCredentials    OPTIONAL,
    IN      PIP_ARRAY       aipServers      OPTIONAL,
    IN      PVOID           pReserved
    )
/*++

Routine Description:

    Dynamic update routine to replace record set on DNS server.

Arguments:

    pReplaceSet - new record set for name and type

    Options     -  update options

    pServerList -  list of DNS servers to go to;  if not given, machines
        default servers are queried to find correct servers to send update to

    hCredentials - handle to credentials to be used for update;  optional,
        if not given security credentials of this process are used in update

    pReserved - reserved;  should be NULL

Return Value:

    None.

--*/
{
    DNSDBG( TRACE, ( "DnsReplaceRecordSetW()\n" ));

    return replaceRecordsInSetPrivate(
                pReplaceSet,
                Options,
                hCredentials,
                aipServers,
                pReserved,
                DnsCharSetUnicode
                );
}



DNS_STATUS
WINAPI
DnsReplaceRecordSetA(
    IN      PDNS_RECORD     pReplaceSet,
    IN      DWORD           Options,
    IN      HANDLE          hCredentials    OPTIONAL,
    IN      PIP_ARRAY       aipServers      OPTIONAL,
    IN      PVOID           pReserved
    )
/*++

Routine Description:

    Dynamic update routine to replace record set on DNS server.

Arguments:

    pReplaceSet - new record set for name and type

    Options     -  update options

    pServerList -  list of DNS servers to go to;  if not given, machines
        default servers are queried to find correct servers to send update to

    hCredentials - handle to credentials to be used for update;  optional,
        if not given security credentials of this process are used in update

    pReserved - reserved;  should be NULL

Return Value:

    None.

--*/
{
    DNSDBG( TRACE, ( "DnsReplaceRecordSetA()\n" ));

    return replaceRecordsInSetPrivate(
                pReplaceSet,
                Options,
                hCredentials,
                aipServers,
                pReserved,
                DnsCharSetAnsi
                );
}



//
//  Modify functions
//

DNS_STATUS
WINAPI
modifyRecordsInSetPrivate(
    IN      PDNS_RECORD     pAddRecords,
    IN      PDNS_RECORD     pDeleteRecords,
    IN      DWORD           Options,
    IN      HANDLE          hCredentials,   OPTIONAL
    IN      PIP_ARRAY       pServerList,    OPTIONAL
    IN      PVOID           pReserved,
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Dynamic update routine to replace record set on DNS server.

Arguments:

    pAddRecords - records to register on server

    pDeleteRecords - records to remove from server

    Options     -  update options

    pServerList -  list of DNS servers to go to;  if not given, machines
        default servers are queried to find correct servers to send update to

    hCredentials - handle to credentials to be used for update;  optional,
        if not given security credentials of this process are used in update

    pReserved - reserved;  should be NULL

    CharSet - character set of incoming records

Return Value:

    ERROR_SUCCESS if update successful.
    ErrorCode from server if server rejects update.
    ERROR_INVALID_PARAMETER if bad param.

--*/
{
    DNS_STATUS      status;
    PDNS_RECORD     paddCopy = NULL;
    PDNS_RECORD     pdeleteCopy = NULL;
    PDNS_RECORD     pupdateSet = NULL;

    DNSDBG( TRACE, (
        "modifyRecordsInSetPrivate()\n"
        "\tpAddSet      = %p\n"
        "\tpDeleteSet   = %p\n"
        "\tOptions      = %08x\n"
        "\thCredentials = %p\n"
        "\tpServerList  = %p\n"
        "\tCharSet      = %d\n",
        pAddRecords,
        pDeleteRecords,
        Options,
        hCredentials,
        pServerList,
        CharSet
        ));

    //
    //  read update config
    //

    Reg_RefreshUpdateConfig();

    //
    //  make local copy in UTF8
    //

    if ( pAddRecords )
    {
        paddCopy = Dns_RecordSetCopyEx(
                        pAddRecords,
                        CharSet,
                        DnsCharSetUtf8 );
    }
    if ( pDeleteRecords )
    {
        pdeleteCopy = Dns_RecordSetCopyEx(
                        pDeleteRecords,
                        CharSet,
                        DnsCharSetUtf8 );
    }

    //
    //  validate arguments
    //      - add and delete must be for single RR set
    //      and must be for same RR set
    //

    if ( !paddCopy && !pdeleteCopy )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if ( paddCopy )
    {
        status = prepareUpdateRecordSet(
                    paddCopy,
                    FALSE,          // no TTL clear
                    FALSE,          // no flag clear
                    0               // no flags to set
                    );
        if ( status != ERROR_SUCCESS )
        {
            status = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
    }
    if ( pdeleteCopy )
    {
        status = prepareUpdateRecordSet(
                    pdeleteCopy,
                    FALSE,          // no TTL clear
                    FALSE,          // no flag clear
                    0               // no flags to set
                    );
        if ( status != ERROR_SUCCESS )
        {
            status = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
    }

    if ( paddCopy &&
         pdeleteCopy &&
         ! Dns_NameCompare_UTF8( paddCopy->pName, pdeleteCopy->pName ) )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    //  set security for update
    //

    if ( UseSystemDefaultForSecurity( Options ) )
    {
        Options |= g_UpdateSecurityLevel;
    }
    if ( hCredentials )
    {
        Options |= DNS_UPDATE_CACHE_SECURITY_CONTEXT;
    }

    //
    //  create update RRs
    //      - no prereqs
    //      - delete RRs set for delete
    //      - add RRs appended
    //

    pupdateSet = DnsBuildUpdateSet(
                        NULL,           // no precons
                        paddCopy,
                        pdeleteCopy );

    //
    //  do the update
    //

    status = DoQuickUpdate(
                    pupdateSet,
                    Options,
                    FALSE,
                    pServerList,
                    hCredentials );

    //
    //  flush cache entry for update
    //

    if ( status == ERROR_SUCCESS )
    {
        DnsFlushResolverCacheEntry_UTF8( (LPSTR) pupdateSet->pName );
    }

    //
    //  cleanup local copy
    //

    Dns_RecordListFree( pupdateSet );

    DNSDBG( TRACE, ( "Leave modifyRecordsInSetPrivate()\n" ));
    return status;


Cleanup:

    //
    //  cleanup copies on failure before combined list
    //

    Dns_RecordListFree( paddCopy );
    Dns_RecordListFree( pdeleteCopy );

    DNSDBG( TRACE, ( "Leave modifyRecordsInSetPrivate()\n" ));

    return status;
}



DNS_STATUS
WINAPI
DnsModifyRecordsInSet_W(
    IN      PDNS_RECORD     pAddRecords,
    IN      PDNS_RECORD     pDeleteRecords,
    IN      DWORD           Options,
    IN      HANDLE          hCredentials,   OPTIONAL
    IN      PIP_ARRAY       pServerList,    OPTIONAL
    IN      PVOID           pReserved
    )
/*++

Routine Description:

    Dynamic update routine to modify record set on DNS server.

Arguments:

    pAddRecords - records to register on server

    pDeleteRecords - records to remove from server

    Options     -  update options

    pServerList -  list of DNS servers to go to;  if not given, machines
        default servers are queried to find correct servers to send update to

    hCredentials - handle to credentials to be used for update;  optional,
        if not given security credentials of this process are used in update

    pReserved   - reserved;  should be NULL

Return Value:

    ERROR_SUCCESS if update successful.
    ErrorCode from server if server rejects update.
    ERROR_INVALID_PARAMETER if bad param.

--*/
{
    return  modifyRecordsInSetPrivate(
                pAddRecords,
                pDeleteRecords,
                Options,
                hCredentials,
                pServerList,
                pReserved,
                DnsCharSetUnicode
                );
}



DNS_STATUS
WINAPI
DnsModifyRecordsInSet_A(
    IN      PDNS_RECORD     pAddRecords,
    IN      PDNS_RECORD     pDeleteRecords,
    IN      DWORD           Options,
    IN      HANDLE          hCredentials,   OPTIONAL
    IN      PIP_ARRAY       pServerList,    OPTIONAL
    IN      PVOID           pReserved
    )
/*++

Routine Description:

    Dynamic update routine to modify record set on DNS server.

Arguments:

    pAddRecords - records to register on server

    pDeleteRecords - records to remove from server

    Options     -  update options

    pServerList -  list of DNS servers to go to;  if not given, machines
        default servers are queried to find correct servers to send update to

    hCredentials - handle to credentials to be used for update;  optional,
        if not given security credentials of this process are used in update

    pReserved   - reserved;  should be NULL

Return Value:

    ERROR_SUCCESS if update successful.
    ErrorCode from server if server rejects update.
    ERROR_INVALID_PARAMETER if bad param.

--*/
{
    return  modifyRecordsInSetPrivate(
                pAddRecords,
                pDeleteRecords,
                Options,
                hCredentials,
                pServerList,
                pReserved,
                DnsCharSetAnsi
                );
}



DNS_STATUS
WINAPI
DnsModifyRecordsInSet_UTF8(
    IN      PDNS_RECORD     pAddRecords,
    IN      PDNS_RECORD     pDeleteRecords,
    IN      DWORD           Options,
    IN      HANDLE          hCredentials,   OPTIONAL
    IN      PIP_ARRAY       pServerList,    OPTIONAL
    IN      PVOID           pReserved
    )
/*++

Routine Description:

    Dynamic update routine to modify record set on DNS server.

Arguments:

    pAddRecords - records to register on server

    pDeleteRecords - records to remove from server

    Options     -  update options

    pServerList -  list of DNS servers to go to;  if not given, machines
        default servers are queried to find correct servers to send update to

    hCredentials - handle to credentials to be used for update;  optional,
        if not given security credentials of this process are used in update

    pReserved   - reserved;  should be NULL

Return Value:

    ERROR_SUCCESS if update successful.
    ErrorCode from server if server rejects update.
    ERROR_INVALID_PARAMETER if bad param.

--*/
{
    return  modifyRecordsInSetPrivate(
                pAddRecords,
                pDeleteRecords,
                Options,
                hCredentials,
                pServerList,
                pReserved,
                DnsCharSetUtf8
                );
}




//
//  Full scale update API
//

DNS_STATUS
DnsUpdate(
    IN      PDNS_RECORD         pRecord,
    IN      DWORD               dwFlags,
    IN      PDNS_NETINFO        pNetworkInfo,
    IN      HANDLE              hCreds,         OPTIONAL
    OUT     PDNS_MSG_BUF *      ppMsgRecv       OPTIONAL
    )
/*++

Routine Description:

    Send DNS update.

    Note if pNetworkInfo is not specified or not a valid UPDATE adapter list,
    then a FindAuthoritativeZones (FAZ) query is done prior to the update.

Arguments:

    pRecord         -- list of records to send in update

    dwFlags         -- flags to update

    pNetworkInfo    -- DNS servers to send update to

    ppMsgRecv       -- addr for ptr to recv buffer, if desired

Return Value:

    ERROR_SUCCESS if successful.
    Error status on failure.

--*/
{
    DNS_STATUS          status;
    PDNS_NETINFO        plocalNetworkInfo = NULL;

    DNSDBG( TRACE, ( "DnsUpdate()\n" ));


    //
    //  read update config
    //

    Reg_RefreshUpdateConfig();

    //
    //  need to build update adapter list from FAZ
    //      - only pass on BYPASS_CACHE flag
    //      - note DnsFindAuthoritativeZone() will append
    //          DNS_QUERY_ALLOW_EMPTY_AUTH_RESP flag yet
    //          DnsQuery_UTF8 will die on that flag without
    //          BYPASS_CACHE also set, so just set BYPASS_CACHE
    //          flag here;
    //          bogus, but that's how it is now
    //

    if ( ! NetInfo_IsForUpdate(pNetworkInfo) )
    {
        status = DnsFindAuthoritativeZone(
                    pRecord->pName,
                    //(dwFlags & DNS_QUERY_BYPASS_CACHE),
                    DNS_QUERY_BYPASS_CACHE,
                    NULL,               // no specified servers
                    & plocalNetworkInfo );

        if ( status != ERROR_SUCCESS )
        {
            return( status );
        }
        pNetworkInfo = plocalNetworkInfo;
    }

    //
    //  call the real update routine in dnslib
    //

    status = Dns_UpdateLib(
                pRecord,
                dwFlags,
                pNetworkInfo,
                hCreds,
                ppMsgRecv );

    //  if there was an error sending the update, flush the resolver
    //  cache entry for the zone name to possibly pick up an alternate
    //  DNS server for the next retry attempt of a similar update.
    //
    //  DCR_QUESTION:  is this the correct error code?
    //      maybe ERROR_TIMED_OUT?
    //

    if ( status == DNS_ERROR_RECORD_TIMED_OUT )
    {
        PSTR    pzoneName;

        if ( pNetworkInfo &&
             (pzoneName = NetInfo_UpdateZoneName( pNetworkInfo )) )
        {
            DnsFlushResolverCacheEntry_UTF8( pzoneName );
            DnsFlushResolverCacheEntry_UTF8( pRecord->pName );
        }
    }

    //  cleanup local adapter list if used

    if ( plocalNetworkInfo )
    {
        NetInfo_Free( plocalNetworkInfo );
    }

    return( status );
}



//
//  Private update functions
//
//  These calls are used only inside dnsapi.dll to do the client
//  host updates.   They are exposed in dnsapi.dll only for test
//  purposes.
//
//
//  DCR:  eliminate nonsense "unique modify" routines -- they add no value
//      moral -- don't let your PM talk to your developers
//
//  DCR:  get rid of old GlennC update routines
//

DNS_STATUS
DnsRegisterRRSet_Ex (
    IN OUT PDNS_RECORD pRegisterSet,
    IN     DWORD       fOptions,
    IN     PIP_ARRAY   aipServers OPTIONAL,
    IN     HANDLE      hCreds    OPTIONAL
    );


DNS_STATUS
DnsModifyRRSet_Ex (
    IN  PDNS_RECORD pCurrentSet,
    IN  PDNS_RECORD pNewSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL,
    IN  HANDLE      hCreds     OPTIONAL
    )
/*++

Routine Description:

    Modify record set of known existing records.

    Note:  this is not my idea of "Modify".  It is really "Register"
    where you specify both what you think the existing set is and
    what you want it to be.

    Like most of these routines -- it's a big waste of time.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DNS_STATUS  status = NO_ERROR;
    PDNS_RECORD pCopyOfCurrentSet = NULL;
    PDNS_RECORD pCopyOfNewSet = NULL;
    PDNS_RECORD pAddSet = NULL;
    PDNS_RECORD pDeleteSet = NULL;
    PDNS_RECORD pUpdateSet = NULL;
    PDNS_NETINFO      pNetworkInfo = NULL;

    DNSDBG( TRACE, ( "DnsModifyRRSet_Ex()\n" ));
    IF_DNSDBG( UPDATE )
    {
        DnsDbg_RecordSet(
            "DnsModifyRRSet_Ex() -- current set",
            pCurrentSet );
        DnsDbg_RecordSet(
            "DnsModifyRRSet_Ex() -- new set",
            pNewSet );
    }

    //
    // Validate arguments ...
    //
    if ( ( fOptions != DNS_UPDATE_UNIQUE ) &&
         ( fOptions & DNS_UNACCEPTABLE_UPDATE_OPTIONS ) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if ( prepareUpdateRecordSet( pCurrentSet,
                        FALSE,
                        FALSE,
                        0 ) != NO_ERROR )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if ( prepareUpdateRecordSet( pNewSet,
                        FALSE,
                        FALSE,
                        0 ) != NO_ERROR )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if ( !Dns_NameCompare_UTF8( pCurrentSet->pName, pNewSet->pName ) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Make a copy of the RRSets, to preserve the original RRSets ...
    //
    pCopyOfCurrentSet = Dns_RecordSetCopyEx( pCurrentSet,
                                             DnsCharSetUtf8,
                                             DnsCharSetUtf8 );

    if ( !pCopyOfCurrentSet )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Exit;
    }

    pCopyOfNewSet = Dns_RecordSetCopyEx( pNewSet,
                                         DnsCharSetUtf8,
                                         DnsCharSetUtf8 );
    if ( !pCopyOfNewSet )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Exit;
    }

    //
    //  pAddSet = pCopyOfNewSet - pCopyOfCurrentSet
    //  pDeleteSet = pCopyOfCurrentSet - pCopyOfNewSet
    //

    //
    //  no change from previous registration?
    //      - touch DNS server to make sure it's in sync
    //  

    if ( Dns_RecordSetCompare( pCopyOfNewSet,
                               pCopyOfCurrentSet,
                               &pAddSet,
                               &pDeleteSet ) )
    {
        status = DnsRegisterRRSet_Ex(
                        pCopyOfNewSet,
                        fOptions,
                        aipServers,
                        hCreds );
        goto Exit;
    }

    //
    //  shared update - do simple modify
    //      - delete what was registered before, that don't want now
    //      - add everything in new set for robustness
    //

    if ( fOptions & DNS_UPDATE_SHARED )
    {
        //
        // Update with the following:
        // Prerequisites: Nothing
        // Add:           pCopyOfNewSet
        // Delete:        pDeleteSet
        //
        // Build the update request with Pre, Add, Del sets ...
        //
        pUpdateSet = DnsBuildUpdateSet( NULL,
                                        pCopyOfNewSet,
                                        pDeleteSet );

        //
        // Call update ...
        //
        status = DoQuickUpdate( pUpdateSet,
                                fOptions,
                                FALSE,
                                aipServers,
                                hCreds);

        //
        // Free memory used ...
        //
        Dns_RecordListFree( pUpdateSet );
        pUpdateSet = NULL;
        pCopyOfNewSet = NULL;
        pDeleteSet = NULL;

        goto Exit;
    }


    //
    //  Unique case
    //

    //
    // Update with the following:
    // Prerequisites: pCopyOfCurrentSet
    // Add:           pAddSet
    // Delete:        pDeleteSet
    //
    // Build the update request with Pre, Add, Del sets ...
    //
    pUpdateSet = DnsBuildUpdateSet( pCopyOfCurrentSet,
                                    pAddSet,
                                    pDeleteSet );

    //
    // Call update ...
    //
    status = DoQuickUpdate( pUpdateSet,
                            fOptions,
                            FALSE,
                            aipServers,
                            hCreds);

    //
    // Free memory used ...
    //
    Dns_RecordListFree( pUpdateSet );
    pUpdateSet = NULL;
    pCopyOfCurrentSet = NULL;
    pAddSet = NULL;
    pDeleteSet = NULL;

    if ( status == DNS_ERROR_RCODE_YXRRSET ||
         status == DNS_ERROR_RCODE_NXRRSET )
    {
        PDNS_RECORD pActualCurrentSet = NULL;
        PDNS_RECORD pSharedSet = NULL;
        PDNS_RECORD pNotUsedSet = NULL;
        DNS_RECORD  Record;
        IP_ARRAY    ipArray;
        IP_ADDRESS  serverIp = DnsGetLastServerUpdateIP();

        if ( serverIp )
        {
            ipArray.AddrCount = 1;
            ipArray.AddrArray[0] = serverIp;
        }

        pNetworkInfo = NetInfo_CreateFromIpArray(
                            aipServers,
                            serverIp,
                            FALSE,      // no search info
                            NULL );

        //
        // Make another copy of the Current RRSet ...
        //
        pCopyOfCurrentSet = Dns_RecordSetCopyEx(
                                pCurrentSet,
                                DnsCharSetUtf8,
                                DnsCharSetUtf8 );
        if ( !pCopyOfCurrentSet )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Exit;
        }

        //
        // Query server for pActualCurrentSet ...
        //

        status = QueryDirectEx(
                        NULL,                   // no response message
                        & pActualCurrentSet,
                        NULL,                   // no header
                        0,                      // no header counts
                        (LPSTR) pCopyOfCurrentSet->pName,
                        pCopyOfCurrentSet->wType,
                        NULL,                   // no input records
                        DNS_QUERY_TREAT_AS_FQDN,
                        NULL,                   // no DNS server list
                        pNetworkInfo );

        if ( IsEmptyDnsResponse( pActualCurrentSet ) )
        {
            Dns_RecordListFree( pActualCurrentSet );
            pActualCurrentSet = NULL;

            if ( status == NO_ERROR )
            {
                status = DNS_ERROR_RCODE_NAME_ERROR;
            }
        }

        if ( status == DNS_ERROR_RCODE_NAME_ERROR ||
             status == DNS_INFO_NO_RECORDS )
        {
            DNS_RECORD Record;

            //
            // Query failed to find any entry for given name and type.
            // We now need to assume that the pCurrentSet is that there
            // isn't anything registered.
            //
            RtlZeroMemory( &Record, sizeof(DNS_RECORD) );
            Record.pName = (PDNS_NAME) pCopyOfNewSet->pName;
            Record.wType = pCopyOfNewSet->wType;
            Record.wDataLength = 0; // Meaning all structures not present.
            Record.Flags.DW = DNSREC_PREREQ | DNSREC_NOEXIST;

            //
            // Do an update with the following:
            // Prerequisites: None - will be Record above.
            // Add:           pRegisterSet
            // Delete:        None
            //
            // Build the update request with Pre, Add, Del sets ...
            //
            pUpdateSet = DnsBuildUpdateSet( NULL,
                                            pCopyOfNewSet,
                                            NULL );

            Record.pNext = pCopyOfNewSet;

            status = DoQuickUpdate( &Record,
                                    fOptions,
                                    FALSE,
                                    serverIp ? &ipArray : aipServers,
                                    hCreds);

            if ( status == DNS_ERROR_RCODE_YXRRSET ||
                 status == DNS_ERROR_RCODE_NXRRSET )
            {
                status = DNS_ERROR_TRY_AGAIN_LATER;
            }

            goto Exit;
        }

        if ( status )
        {
            goto Exit;
        }

        //
        // Sometimes when DnsQuery is called, the returned record set
        // contains additional records of different types than what
        // was queried for. Need to strip off the additional records
        // from the query results.
        //
        pNotUsedSet = DnsRecordSetDetach( pActualCurrentSet );

        if ( pNotUsedSet )
        {
            Dns_RecordListFree( pNotUsedSet );
            pNotUsedSet = NULL;
        }

        //
        // pAddSet = pNewSet - pActualCurrentSet
        // pDeleteSet = pActualCurrentSet - pNewSet
        //
        (void) Dns_RecordSetCompare( pCopyOfNewSet,
                                     pActualCurrentSet,
                                     &pAddSet,
                                     &pDeleteSet );


        //
        // pSharedSet = pDeleteSet - pCopyOfCurrentSet
        // pNotUsedSet = pCopyOfCurrentSet - pDeleteSet
        //
        (void) Dns_RecordSetCompare( pDeleteSet,
                                     pCopyOfCurrentSet,
                                     &pSharedSet,
                                     &pNotUsedSet );

        Dns_RecordListFree( pDeleteSet );
        pDeleteSet = NULL;
        Dns_RecordListFree( pCopyOfCurrentSet );
        pCopyOfCurrentSet = NULL;
        Dns_RecordListFree( pNotUsedSet );
        pNotUsedSet = NULL;
        Dns_RecordListFree( pActualCurrentSet );
        pActualCurrentSet = NULL;

        //
        //  unaccounted for records indicate other updater of name
        //
        //  records we don't want (delete set) and did NOT previously
        //  register mean some other user is adding records
        //  

        if ( pSharedSet )
        {
            Dns_RecordListFree( pSharedSet );
            pSharedSet = NULL;

            status = DNS_ERROR_NOT_UNIQUE;
            goto Exit;
        }

        RtlZeroMemory( &Record, sizeof(DNS_RECORD) );
        Record.pName = (PDNS_NAME) pCopyOfNewSet->pName;
        Record.wType = pCopyOfNewSet->wType;
        Record.wDataLength = 0; // Meaning all data.
        Record.Flags.DW = DNSREC_UPDATE | DNSREC_DELETE;

        //
        // Do an update with the following:
        // Prerequisites: None
        // Add:           pCopyOfNewSet
        // Delete:        All
        //
        // Build the update request with Pre, Add, Del sets ...
        //
        pUpdateSet = DnsBuildUpdateSet( NULL,
                                        pCopyOfNewSet,
                                        NULL );

        Record.pNext = pCopyOfNewSet;

        status = DoQuickUpdate( &Record,
                                fOptions,
                                FALSE,
                                serverIp ? &ipArray : aipServers,
                                hCreds);

        goto Exit;
    }


Exit :

    if ( pCopyOfCurrentSet )
    {
        Dns_RecordListFree( pCopyOfCurrentSet );
    }

    if ( pCopyOfNewSet )
    {
        Dns_RecordListFree( pCopyOfNewSet );
    }

    if ( pAddSet )
    {
        Dns_RecordListFree( pAddSet );
    }

    if ( pDeleteSet )
    {
        Dns_RecordListFree( pDeleteSet );
    }

    if ( pNetworkInfo )
    {
        NetInfo_Free( pNetworkInfo );
    }

    DNSDBG( TRACE, ( "Leave DnsModifyRRSet_Ex()\n" ));
    return status;
}



DNS_STATUS
DnsRegisterRRSet_Ex(
    IN OUT PDNS_RECORD pRegisterSet,
    IN     DWORD       fOptions,
    IN     PIP_ARRAY   aipServers OPTIONAL,
    IN     HANDLE      hCreds    OPTIONAL
    )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DNS_STATUS      status = NO_ERROR;
    PDNS_RECORD     pCurrentSet = NULL;
    PDNS_RECORD     pUpdateSet = NULL;
    PDNS_NETINFO    pNetworkInfo = NULL;
    DNS_RECORD      Record;
    DNS_RECORD      NoCName;
    IP_ARRAY        ipArray;
    IP_ADDRESS      serverIp = 0;

    DNSDBG( TRACE, ( "DnsRegisterRRSet_Ex()\n" ));
    IF_DNSDBG( UPDATE )
    {
        DnsDbg_RecordSet(
            "DnsRegisterRRSet_Ex()",
            pRegisterSet );
    }

    //
    // Validate arguments ...
    //
    if ( ( fOptions != DNS_UPDATE_UNIQUE ) &&
         ( fOptions & DNS_UNACCEPTABLE_UPDATE_OPTIONS ) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Are all the RRSet structures of the same type and name?
    // Mark them all as Updates (add) ...
    //
    if ( prepareUpdateRecordSet(
                pRegisterSet,
                FALSE,
                TRUE,
                DNSREC_UPDATE ) != NO_ERROR )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Prepare CName does not exist record
    //
    RtlZeroMemory( &NoCName, sizeof(DNS_RECORD) );
    NoCName.pName = (PDNS_NAME) pRegisterSet->pName;
    NoCName.wType = DNS_TYPE_CNAME;
    NoCName.wDataLength = 0; // Meaning all structures not present.
    NoCName.Flags.DW = DNSREC_PREREQ | DNSREC_NOEXIST;


    //
    //  shared update
    //      - just throw our records out there (with CNAME no-exist)
    //
    //  DCR:  this case is just ModifyRecordsInSet
    //

    if ( fOptions & DNS_UPDATE_SHARED &&
         pRegisterSet->wType != DNS_TYPE_CNAME )
    {
        NoCName.pNext = pRegisterSet;

        status = DoQuickUpdate( &NoCName,
                                fOptions,
                                FALSE,
                                aipServers,
                                hCreds);

        goto Exit;
    }

    //
    // From here on down the code is handling the non-shared case ....
    //

    //
    // Do an update with the following:
    // Prerequisites: pRegisterSet
    // Add:           None
    // Delete:        None
    //
    // Build the update request with Pre, Add, Del sets ...
    //

    //
    //  DCR_PERF:  prereq only update is wasteful
    //      we need to query AND we are trusting query
    //      -- supposed to find last update server -- so
    //      just do it
    //
    //      - faz => find target DNS server
    //      - direct query for our set
    //      - compare
    //          - full match => done
    //          - unresolveable conflict => fail
    //          - ok mismatch => send replace
    //

    pUpdateSet = DnsBuildUpdateSet( pRegisterSet,
                                    NULL,
                                    NULL );

    //
    // Call update ...
    //
    if ( pUpdateSet->wType != DNS_TYPE_CNAME )
    {
        NoCName.pNext = pUpdateSet;

        status = DoQuickUpdate( &NoCName,
                                fOptions,
                                FALSE,
                                aipServers,
                                hCreds);
    }
    else
    {
        status = DoQuickUpdate( pUpdateSet,
                                fOptions,
                                FALSE,
                                aipServers,
                                hCreds);
    }

    if ( status == NO_ERROR )
    {
        //
        // We are done, no need to reregister since the server has
        // what it should have.
        //
        goto Exit;
    }

    if ( status == DNS_ERROR_RCODE_YXRRSET ||
         status == DNS_ERROR_RCODE_NXRRSET )
    {
        //
        // For these errors, we just need to figure out what the server
        // has and send the correct update info.
        //
        serverIp = DnsGetLastServerUpdateIP();

        ipArray.AddrCount = 1;
        ipArray.AddrArray[0] = serverIp;
        
        status = NO_ERROR;
    }

    if ( status )
    {
        //
        // For all other update errors, don't bother trying anything more.
        //
        goto Exit;
    }

    //  get network info for

    pNetworkInfo = NetInfo_CreateFromIpArray(
                        aipServers,
                        serverIp,
                        FALSE,      // no search info
                        NULL );

    //
    // Let's see if the DNS server doesn't know about this set at all
    // and just try to add it with the prerequisite that there is nothing
    // there already for the given record name.
    //

    if ( pRegisterSet->wType == DNS_TYPE_CNAME )
    {
        //
        // Handle CNAME type here as special case
        //

        RtlZeroMemory( &Record, sizeof(DNS_RECORD) );
        Record.pName = (PDNS_NAME) pRegisterSet->pName;
        Record.wType = DNS_TYPE_ANY;
        Record.wDataLength = 0; // Meaning all structures not present.
        Record.Flags.DW = DNSREC_PREREQ | DNSREC_NOEXIST;

        //
        // Do an update with the following:
        // Prerequisites: None - will be Record above.
        // Add:           pRegisterSet
        // Delete:        None
        //
        // Build the update request with Pre, Add, Del sets ...
        //
        pUpdateSet = DnsBuildUpdateSet( NULL,
                                        pRegisterSet,
                                        NULL );

        Record.pNext = pRegisterSet;

        status = DoQuickUpdate( &Record,
                                fOptions,
                                FALSE,
                                serverIp ? &ipArray : aipServers,
                                hCreds);

        if ( status == DNS_ERROR_RCODE_YXRRSET ||
             status == DNS_ERROR_RCODE_NXRRSET )
        {
            status = DNS_ERROR_TRY_AGAIN_LATER;
        }

        goto Exit;
    }
    else
    {
        RtlZeroMemory( &Record, sizeof(DNS_RECORD) );
        Record.pName = (PDNS_NAME) pRegisterSet->pName;
        Record.wType = pRegisterSet->wType;
        Record.wDataLength = 0; // Meaning all structures not present.
        Record.Flags.DW = DNSREC_PREREQ | DNSREC_NOEXIST;

        //
        // Do an update with the following:
        // Prerequisites: None - will be Record above and CNAME does not exist.
        // Add:           pRegisterSet
        // Delete:        All
        //
        // Build the update request with Pre, Add, Del sets ...
        //
        pUpdateSet = DnsBuildUpdateSet( NULL,
                                        pRegisterSet,
                                        NULL );

        Record.pNext = pRegisterSet;
        NoCName.pNext = &Record;

        status = DoQuickUpdate( &NoCName,
                                fOptions,
                                FALSE,
                                serverIp ? &ipArray : aipServers,
                                hCreds);
    }

    if ( status == NO_ERROR )
    {
        //
        // We are done, no need to reregister since the server has
        // what it should have.
        //
        goto Exit;
    }

    if ( status == DNS_ERROR_RCODE_YXRRSET ||
         status == DNS_ERROR_RCODE_NXRRSET )
    {
        //
        // For these errors, we just need to figure out what the server
        // has and send the correct update info.
        //
        status = NO_ERROR;
    }

    if ( status )
    {
        //
        // For all other update errors, don't bother trying anything more.
        //
        goto Exit;
    }

    //
    // Query server for pCurrentSet ...
    //

    status = QueryDirectEx(
                    NULL,                   // no response message
                    & pCurrentSet,
                    NULL,                   // no header
                    0,                      // no header counts
                    (LPSTR) pRegisterSet->pName,
                    pRegisterSet->wType,
                    NULL,                   // no input records
                    DNS_QUERY_TREAT_AS_FQDN,
                    NULL,                   // no DNS server list
                    pNetworkInfo
                    );

    if ( IsEmptyDnsResponse( pCurrentSet ) )
    {
        Dns_RecordListFree( pCurrentSet );
        pCurrentSet = NULL;
    }

    if ( pCurrentSet )
    {
        PDNS_RECORD pOtherSet = NULL;
        PDNS_RECORD pNotUsedSet = NULL;

        //
        // Sometimes when DnsQuery is called, the returned record set contains
        // additional records of different types than what was queried for.
        // Need to strip off the additional records from the query results.
        //
        pNotUsedSet = DnsRecordSetDetach( pCurrentSet );

        if ( pNotUsedSet )
        {
            Dns_RecordListFree( pNotUsedSet );
            pNotUsedSet = NULL;
        }

        //
        // There are records on the server, make sure that these are ones
        // that we know about, otherwise this call should return
        // DNS_ERROR_NOT_UNIQUE.
        //

        if ( Dns_RecordSetCompare( pCurrentSet,
                                   pRegisterSet,
                                   &pOtherSet,
                                   &pNotUsedSet ) )
        {
            //
            // The two RRSets are the same. Weird! We just did a PreReq
            // update looking for just this and it said the records weren't
            // there, now when we query they are! This should never happen
            // theoretically. Assert if otherwise . . .
            //
            DNS_ASSERT( FALSE );

            status = NO_ERROR;
            goto Exit;
        }

        if ( pNotUsedSet )
        {
            Dns_RecordListFree( pNotUsedSet );
            pNotUsedSet = NULL;
        }

        //
        // Test to see if any of the records up one the server are not the same
        // as any in our registration set. If so return error . . .
        //

        if ( pOtherSet )
        {
            Dns_RecordListFree( pOtherSet );
            pOtherSet = NULL;
            status = DNS_ERROR_NOT_UNIQUE;
            goto Exit;
        }

        //
        // Call ModifyRecordSet with the Current and Register RR sets . . .
        //

        status = DnsModifyRRSet_Ex( pCurrentSet,
                                    pRegisterSet,
                                    fOptions,
                                    serverIp ? &ipArray : aipServers,
                                    hCreds );
    }
    else
    {
        //
        // This is a confused DNS server! We've already tried a prerequisite
        // update that there should be nothing, and add the registration
        // RR set. No need to do it again, assume for now that the server
        // is busy updating the particular RR set.
        //

        status = DNS_ERROR_TRY_AGAIN_LATER;
    }

Exit :

    if ( pCurrentSet )
    {
        Dns_RecordListFree( pCurrentSet );
    }

    if ( pNetworkInfo )
    {
        NetInfo_Free( pNetworkInfo );
    }

    DNSDBG( TRACE, ( "Leave DnsRegisterRRSet_Ex()\n" ));
    return status;
}



//
//  DCR_CLEANUP:  ModifyRecordSet() functions?
//      decide what to do with these
//      if to be exposed -- then all three
//      if only used by async reg, then just
//      need UTF8 routine
//

DNS_STATUS
WINAPI
DnsModifyRecordSet_UTF8(
    IN  HANDLE      hCredentials OPTIONAL,
    IN  PDNS_RECORD pCurrentSet,
    IN  PDNS_RECORD pNewSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL )
/*++

Routine Description:

    Dynamic DNS routine to update records. This function figures out the
    records that need to be added and/or removed to modify an existing
    record set in the DNS domain name space. This routine will not remove
    any records that may have been added by another process for the given
    record set name. In the case where "other" records are detected,
    DNS_ERROR_NOT_UNIQUE will be returned.

Arguments:

    hCredentials - handle to credentials to be used for update.

    pCurrentSet - the set that the caller currently thinks is registered
                  in the DNS domain name space.

    pNewSet -  the set that should be registered in the DNS domain name
               space. The current records will be modified to get to this
               set.

    fOptions - the Dynamic DNS update options that the caller may wish to
               use (see dnsapi.h).

    aipServers -  a specific list of servers to goto to figure out the
                  authoritative DNS server(s) for the given record set
                  domain zone name.

Return Value:

    None.

--*/
{
    DNS_STATUS  status = NO_ERROR;
    PDNS_RECORD pCopyOfCurrentSet = NULL;
    PDNS_RECORD pCopyOfNewSet = NULL;
    DWORD       dwFlags = fOptions;

    DNSDBG( TRACE, ( "DnsModifyRecordSet_UTF8()\n" ));

    //
    //  if just new set -- do an add
    //

    if ( pNewSet && !pCurrentSet )
    {
        return DnsAddRecordSet_UTF8( hCredentials,
                                     pNewSet,
                                     fOptions,
                                     aipServers );
    }

    //
    //  if just current set -- do a delete
    //

    if ( !pNewSet && pCurrentSet )
    {
        return DnsModifyRecordsInSet_UTF8(
                            NULL,           // no add records
                            pCurrentSet,    // delete current set
                            fOptions,
                            hCredentials,
                            aipServers,     // DNS servers
                            NULL            // reserved
                            );
    }

    if ( !pNewSet && !pCurrentSet )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if ( UseSystemDefaultForSecurity( dwFlags ) )
    {
        dwFlags |= g_UpdateSecurityLevel;
    }

    if ( hCredentials )
    {
        dwFlags |= DNS_UPDATE_CACHE_SECURITY_CONTEXT;
    }

    //
    //  build record sets for update
    //
    //  DCR_CLEANUP:  unnecessary RR copy here
    //  DCR_FIX0:  unnecessary RR copy here
    //      ModifyRRSet_Ex() does it's own copy
    //      and doesn't touch input records
    //

    pCopyOfCurrentSet = Dns_RecordSetCopyEx(
                            pCurrentSet,
                            DnsCharSetUtf8,
                            DnsCharSetUtf8 );
    if ( !pCopyOfCurrentSet )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }
    pCopyOfNewSet = Dns_RecordSetCopyEx(
                            pNewSet,
                            DnsCharSetUtf8,
                            DnsCharSetUtf8 );
    if ( !pCopyOfNewSet )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    status = DnsModifyRRSet_Ex(
                    pCopyOfCurrentSet,
                    pCopyOfNewSet,
                    dwFlags | DNS_UPDATE_UNIQUE,
                    aipServers,
                    hCredentials );

    if ( status == NO_ERROR )
    {
        if ( pCopyOfCurrentSet )
        {
            DnsFlushResolverCacheEntry_UTF8( (LPSTR) pCopyOfCurrentSet->pName );
        }
        else
        {
            DnsFlushResolverCacheEntry_UTF8( (LPSTR) pCopyOfNewSet->pName );
        }
    }

Done:

    Dns_RecordListFree( pCopyOfCurrentSet );
    Dns_RecordListFree( pCopyOfNewSet );

    DNSDBG( TRACE, ( "Leave DnsModifyRecordSet_UTF8()\n" ));
    return status;
}


DNS_STATUS WINAPI
DnsModifyRecordSet_A (
    IN  HANDLE      hCredentials OPTIONAL,
    IN  PDNS_RECORD pCurrentSet,
    IN  PDNS_RECORD pNewSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL )
/*++

Routine Description:

    ANSI version of ModifyRecordSet.

    Note, there is NO use of this function it exists only for Elena's test
    scripts.  Once the test scripts are changed this function can be deleted.

Arguments:

    same as above

Return Value:

    None.

--*/
{
    DNS_STATUS  status;
    PDNS_RECORD pcopyCurrent;
    PDNS_RECORD pcopyNew;

    DNSDBG( TRACE, ( "DnsModifyRecordSet_A()\n" ));

    //
    //  copy record sets to UTF8
    //

    pcopyCurrent = Dns_RecordSetCopyEx(
                        pCurrentSet,
                        DnsCharSetAnsi,
                        DnsCharSetUtf8 );

    pcopyNew = Dns_RecordSetCopyEx(
                        pNewSet,
                        DnsCharSetAnsi,
                        DnsCharSetUtf8 );

    //
    //  modify in UTF8
    //

    status = DnsModifyRecordSet_UTF8(
                hCredentials,
                pcopyCurrent,
                pcopyNew,
                fOptions,
                aipServers );

    //
    //  cleanup local copies
    //

    Dns_RecordListFree( pcopyCurrent );
    Dns_RecordListFree( pcopyNew );

    return status;
}


DNS_STATUS
WINAPI
DnsModifyRecordSet_W(
    IN  HANDLE      hCredentials OPTIONAL,
    IN  PDNS_RECORD pCurrentSet,
    IN  PDNS_RECORD pNewSet,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL )
/*++

Routine Description:

    Unicode version of ModifyRecordSet.

    Note, there is NO use of this function it exists only for Elena's test
    scripts.  Once the test scripts are changed this function can be deleted.

Arguments:

    same as above

Return Value:

    None.

--*/
{
    DNS_STATUS  status;
    PDNS_RECORD pcopyCurrent;
    PDNS_RECORD pcopyNew;

    DNSDBG( TRACE, ( "DnsModifyRecordSet_W()\n" ));

    //
    //  copy record sets to UTF8
    //

    pcopyCurrent = Dns_RecordSetCopyEx(
                        pCurrentSet,
                        DnsCharSetUnicode,
                        DnsCharSetUtf8 );

    pcopyNew = Dns_RecordSetCopyEx(
                        pNewSet,
                        DnsCharSetUnicode,
                        DnsCharSetUtf8 );

    //
    //  modify in UTF8
    //

    status = DnsModifyRecordSet_UTF8(
                hCredentials,
                pcopyCurrent,
                pcopyNew,
                fOptions,
                aipServers );

    //
    //  cleanup local copies
    //

    Dns_RecordListFree( pcopyCurrent );
    Dns_RecordListFree( pcopyNew );

    return status;
}




//
//  DCR_CLEANUP:  DnsAddRecordSet() functions?
//      decide what to do with these
//      if to be exposed -- then all three
//      if only used by async reg, then just
//      need UTF8 routine
//

DNS_STATUS
WINAPI
DnsAddRecordSet_UTF8(
    IN      HANDLE          hCredentials OPTIONAL,
    IN OUT  PDNS_RECORD     pRegisterSet,
    IN      DWORD           fOptions,
    IN      PIP_ARRAY       aipServers OPTIONAL )
/*++

Routine Description:

    Dynamic DNS routine to update records. This routine adds the
    record set described by pRegisterSet to the DNS domain name
    space. This routine fails with error DNS_ERROR_NOT_UNIQUE if
    there are any pre-existing records in the DNS name space that are
    not part of the set described by pRegisterSet.

Arguments:

    hCredentials - handle to credentials to be used for update.

    pRegisterSet -  the set that should be registered in the DNS domain name
                    space.

    fOptions - the Dynamic DNS update options that the caller may wish to
               use (see dnsapi.h).

    aipServers -  a specific list of servers to goto to figure out the
                  authoritative DNS server(s) for the given record set
                  domain zone name.

Return Value:

    None.

--*/
{
    DNS_STATUS  status = NO_ERROR;
    PDNS_RECORD pCopyOfRegisterSet = NULL;
    DWORD       dwFlags = fOptions;

    DNSDBG( TRACE, ( "DnsAddRecordSet_UTF8()\n" ));
    IF_DNSDBG( UPDATE )
    {
        DnsDbg_RecordSet(
            "DnsAddRecordSet_UTF8()",
            pRegisterSet );
    }

    //
    // Validate arguments ...
    //

    if ( !pRegisterSet )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if ( UseSystemDefaultForSecurity( dwFlags ) )
    {
        dwFlags |= g_UpdateSecurityLevel;
    }

    if ( hCredentials )
    {
        dwFlags |= DNS_UPDATE_CACHE_SECURITY_CONTEXT;
    }

    pCopyOfRegisterSet = Dns_RecordSetCopyEx( pRegisterSet,
                                            DnsCharSetUtf8,
                                            DnsCharSetUtf8 );
    if ( !pCopyOfRegisterSet )
    {
        return DNS_ERROR_NO_MEMORY;
    }

    status = DnsRegisterRRSet_Ex( pCopyOfRegisterSet,
                                  dwFlags | DNS_UPDATE_UNIQUE,
                                  aipServers,
                                  hCredentials);

    if ( status == NO_ERROR )
    {
        DnsFlushResolverCacheEntry_UTF8( (LPSTR) pCopyOfRegisterSet->pName );
    }

    Dns_RecordListFree( pCopyOfRegisterSet );


    DNSDBG( TRACE, ( "Leave DnsAddRecordSet_UTF8()\n" ));
    return status;
}



DNS_STATUS
WINAPI
DnsAddRecordSet_A(
    IN      HANDLE          hCredentials OPTIONAL,
    IN OUT  PDNS_RECORD     pRegisterSet,
    IN      DWORD           fOptions,
    IN      PIP_ARRAY       aipServers OPTIONAL
    )
/*++

Routine Description:

    ANSI version of AddRecordSet.

    Note, there is NO use of this function it exists only for Elena's test
    scripts.  Once the test scripts are changed this function can be deleted.

Arguments:

    same as above

Return Value:

    None.

--*/
{
    DNS_STATUS  status;
    PDNS_RECORD pcopySet;

    DNSDBG( TRACE, ( "DnsAddRecordSet_A()\n" ));

    //
    //  copy set to UTF8
    //

    pcopySet = Dns_RecordSetCopyEx(
                    pRegisterSet,
                    DnsCharSetAnsi,
                    DnsCharSetUtf8 );

    //
    //  add set
    //

    status = DnsAddRecordSet_UTF8(
                    hCredentials,
                    pcopySet,
                    fOptions,
                    aipServers );

    //  cleanup local copy

    Dns_RecordListFree( pcopySet );

    return status;
}



DNS_STATUS
WINAPI
DnsAddRecordSet_W(
    IN      HANDLE          hCredentials OPTIONAL,
    IN OUT  PDNS_RECORD     pRegisterSet,
    IN      DWORD           fOptions,
    IN      PIP_ARRAY       aipServers OPTIONAL )
/*++

Routine Description:

    ANSI version of AddRecordSet.

    Note, there is NO use of this function it exists only for Elena's test
    scripts.  Once the test scripts are changed this function can be deleted.

Arguments:

    same as above

Return Value:

    None.

--*/
{
    DNS_STATUS  status;
    PDNS_RECORD pcopySet;

    DNSDBG( TRACE, ( "DnsAddRecordSet_W()\n" ));

    //
    //  copy set to UTF8
    //

    pcopySet = Dns_RecordSetCopyEx(
                    pRegisterSet,
                    DnsCharSetUnicode,
                    DnsCharSetUtf8 );

    //
    //  add set
    //

    status = DnsAddRecordSet_UTF8(
                    hCredentials,
                    pcopySet,
                    fOptions,
                    aipServers );

    //  cleanup local copy

    Dns_RecordListFree( pcopySet );

    return status;
}



//
//  Update test functions are called by system components
//

DNS_STATUS
WINAPI
DnsUpdateTest_UTF8(
    IN      HANDLE          hCredentials OPTIONAL,
    IN      PCSTR           pszName,
    IN      DWORD           Flags,
    IN      PIP_ARRAY       pDnsServers  OPTIONAL
    )
/*++

Routine Description:

    Dynamic DNS routine to test whether the caller can update the
    records in the DNS domain name space for the given record name.

Arguments:

    hCredentials - handle to credentials to be used for update.

    pszName -  the record set name that the caller wants to test.

    Flags - the Dynamic DNS update options that the caller may wish to
               use (see dnsapi.h).

    pDnsServers -  a specific list of servers to goto to figure out the
                  authoritative DNS server(s) for the given record set
                  domain zone name.

Return Value:

    None.

--*/
{
    PWSTR       pnameWide = NULL;
    DNS_STATUS  status = NO_ERROR;

    DNSDBG( TRACE, (
        "DnsUpdateTest_UTF8( %s )\n",
        pszName ));


    if ( !pszName )
    {
        return ERROR_INVALID_PARAMETER;
    }

    pnameWide = Dns_NameCopyAllocate(
                    (PCHAR) pszName,
                    0,
                    DnsCharSetUtf8,
                    DnsCharSetUnicode );
    if ( !pnameWide )
    {
        return ERROR_INVALID_NAME;
    }

    status = DnsUpdateTest_W(
                hCredentials,
                (PCWSTR) pnameWide,
                Flags,
                pDnsServers );

    FREE_HEAP( pnameWide );

    return  status;
}


DNS_STATUS
WINAPI
DnsUpdateTest_A(
    IN      HANDLE          hCredentials OPTIONAL,
    IN      PCSTR           pszName,
    IN      DWORD           Flags,
    IN      PIP_ARRAY       pDnsServers  OPTIONAL
    )
/*++

Routine Description:

    Dynamic DNS routine to test whether the caller can update the
    records in the DNS domain name space for the given record name.

Arguments:

    hCredentials - handle to credentials to be used for update.

    pszName -  the record set name that the caller wants to test.

    Flags - the Dynamic DNS update options that the caller may wish to
               use (see dnsapi.h).

    pDnsServers -  a specific list of servers to goto to figure out the
                  authoritative DNS server(s) for the given record set
                  domain zone name.

Return Value:

    None.

--*/
{
    PWSTR       pnameWide = NULL;
    DNS_STATUS  status = NO_ERROR;

    DNSDBG( TRACE, (
        "DnsUpdateTest_UTF8( %s )\n",
        pszName ));


    if ( !pszName )
    {
        return ERROR_INVALID_PARAMETER;
    }

    pnameWide = Dns_NameCopyAllocate(
                    (PCHAR) pszName,
                    0,
                    DnsCharSetUtf8,
                    DnsCharSetUnicode );
    if ( !pnameWide )
    {
        return ERROR_INVALID_NAME;
    }

    status = DnsUpdateTest_W(
                hCredentials,
                (PCWSTR) pnameWide,
                Flags,
                pDnsServers );

    FREE_HEAP( pnameWide );

    return  status;
}


DNS_STATUS
WINAPI
DnsUpdateTest_W(
    IN      HANDLE          hCredentials OPTIONAL,
    IN      PCWSTR          pszName,
    IN      DWORD           Flags,
    IN      PIP_ARRAY       pDnsServers OPTIONAL
    )
/*++

Routine Description:

    Dynamic DNS routine to test whether the caller can update the
    records in the DNS domain name space for the given record name.

Arguments:

    hCredentials - handle to credentials to be used for update.

    pszName -  the record set name that the caller wants to test.

    Flags - the Dynamic DNS update options that the caller may wish to
               use (see dnsapi.h).

    pDnsServers -  a specific list of servers to goto to figure out the
                  authoritative DNS server(s) for the given record set
                  domain zone name.

Return Value:

    None.

--*/
{
    DNS_STATUS  status = NO_ERROR;
    DNS_RECORD  record;
    DWORD       flags = Flags;
    LPSTR       pnameUtf8 = NULL;

    DNSDBG( TRACE, (
        "DnsUpdateTest_W( %S )\n",
        pszName ));

    //
    //  validation
    //

    if ( flags & DNS_UNACCEPTABLE_UPDATE_OPTIONS )
    {
        return ERROR_INVALID_PARAMETER;
    }
    if ( !pszName )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    //  try resolver
    //

    if ( flags & DNS_UPDATE_TEST_USE_LOCAL_SYS_ACCT )
    {
        DWORD   rpcStatus = NO_ERROR;

        if ( !pDnsServers ||
             pDnsServers->AddrCount != 1 )
        {
            return ERROR_INVALID_PARAMETER;
        }
        RpcTryExcept
        {
            status = CRrUpdateTest(
                        NULL,
                        (PWSTR) pszName,
                        0,
                        pDnsServers->AddrArray[0] );
        }
        RpcExcept( DNS_RPC_EXCEPTION_FILTER )
        {
            rpcStatus = RpcExceptionCode();
        }
        RpcEndExcept

        if ( rpcStatus == NO_ERROR )
        {
            return status;
        }
        return  rpcStatus;
    }

    //
    //  direct update attempt
    //

    //
    //  read update config
    //

    Reg_RefreshUpdateConfig();

    if ( UseSystemDefaultForSecurity( flags ) )
    {
        flags |= g_UpdateSecurityLevel;
    }
    if ( hCredentials )
    {
        flags |= DNS_UPDATE_CACHE_SECURITY_CONTEXT;
    }

    //
    //  build record
    //      - NOEXIST prerequisite
    //

    pnameUtf8 = Dns_NameCopyAllocate(
                        (PCHAR) pszName,
                        0,
                        DnsCharSetUnicode,
                        DnsCharSetUtf8 );
    if ( ! pnameUtf8 )
    {
        return DNS_ERROR_NO_MEMORY;
    }

    RtlZeroMemory( &record, sizeof(DNS_RECORD) );
    record.pName = (PDNS_NAME) pnameUtf8;
    record.wType = DNS_TYPE_ANY;
    record.wDataLength = 0;
    record.Flags.DW = DNSREC_PREREQ | DNSREC_NOEXIST;

    //
    //  do the prereq update
    //

    status = DoQuickUpdate(
                    &record,
                    flags,
                    TRUE,
                    pDnsServers,
                    hCredentials );

    FREE_HEAP( pnameUtf8 );

    return status;
}



//
//  Update execution functions
//

DNS_STATUS
DoQuickUpdate(
    IN      PDNS_RECORD     pRecord,
    IN      DWORD           dwFlags,
    IN      BOOL            fUpdateTestMode,
    IN      PIP_ARRAY       pServerList     OPTIONAL,
    IN      HANDLE          hCreds          OPTIONAL
    )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DNS_STATUS      status = NO_ERROR;
    PSTR            pzoneName;
    PDNS_NAME       pname = pRecord->pName;
    PDNS_NETINFO    pnetInfo = NULL;

    DNSDBG( UPDATE, (
        "DoQuickUpdate( rr=%p, flag=%08x )\n",
        pRecord,
        dwFlags ));

    IF_DNSDBG( UPDATE )
    {
        DnsDbg_RecordSet(
            "Entering DoQuickUpdate():",
            pRecord );
    }

    //
    //  caller has particular server list
    //

    if ( pServerList )
    {
        IP_ADDRESS  serverIp;
        PIP_ARRAY   pserverListCopy = Dns_CreateIpArrayCopy( pServerList );

        if ( !pserverListCopy )
        {
            return DNS_ERROR_NO_MEMORY;
        }

        status = DoQuickFAZ(
                    &pnetInfo,
                    pname,
                    pserverListCopy );

        if ( status != ERROR_SUCCESS )
        {
            FREE_HEAP( pserverListCopy );
            pserverListCopy = NULL;
            return status;
        }

        //
        //  FAZ should always produce update network info blob
        //

        DNS_ASSERT( NetInfo_IsForUpdate(pnetInfo) );
        pzoneName = NetInfo_UpdateZoneName( pnetInfo );

        if ( dwFlags & DNS_UPDATE_TRY_ALL_MASTER_SERVERS )
        {
            status = DoMultiMasterUpdate(
                        pRecord,
                        dwFlags,
                        hCreds,
                        pzoneName,
                        0,
                        pserverListCopy );
        }
        else
        {
            status = DoQuickUpdateEx(
                        NULL,
                        pRecord,
                        dwFlags,
                        pnetInfo,
                        hCreds );

            if ( status == ERROR_TIMEOUT )
            {
                serverIp = pnetInfo->AdapterArray[0]->ServerArray[0].IpAddress;
#if DBG
                if ( g_IsDnsServer &&
                     IsLocalIpAddress( serverIp ) )
                {
                    DnsDbg_PrintfToDebugger(
                        "DNSAPI: Note that DDNS update to local server\n"
                        "        with IP address 0x%.8x timed out,\n"
                        "        now trying other DNS servers\n"
                        "        authoritative for zone (%s)\n",
                        serverIp,
                        pzoneName );
                }
#endif
                status = DoMultiMasterUpdate(
                                pRecord,
                                dwFlags,
                                hCreds,
                                pzoneName,
                                serverIp,
                                pserverListCopy );
            }
        }

        NetInfo_Free( pnetInfo );

        FREE_HEAP( pserverListCopy );
        pserverListCopy = NULL;
        
        return status;
    }

    //
    //  server list unspecified
    //      - use FAZ to figure it out
    //

    else
    {
        PIP_ARRAY       serverListArray[ UPDATE_ADAPTER_LIMIT ];
        PDNS_NETINFO    networkInfoArray[ UPDATE_ADAPTER_LIMIT ];
        DWORD           netCount = UPDATE_ADAPTER_LIMIT;
        DWORD           iter;
        BOOL            bsuccess = FALSE;

        //
        //  build server list for update
        //      - collapse adapters on same network into single adapter
        //      - FAZ to find update servers
        //      - collapse results from same network into single target
        //

        netCount = GetDnsServerListsForUpdate(
                        serverListArray,
                        netCount,
                        dwFlags
                        );

        status = CollapseDnsServerListsForUpdate(
                        serverListArray,
                        networkInfoArray,
                        & netCount,
                        pname );

        DNS_ASSERT( netCount <= UPDATE_ADAPTER_LIMIT );

        if ( netCount == 0 )
        {
            if ( status == ERROR_SUCCESS )
            {
                status = DNS_ERROR_NO_DNS_SERVERS;
            }
            return status;
        }

        //
        //  do update on all distinct (disjoint) networks
        //

        for ( iter = 0;
              iter < netCount;
              iter++ )
        {
            PIP_ARRAY   pdnsArray = serverListArray[ iter ];

            pnetInfo = networkInfoArray[ iter ];
            if ( !pnetInfo )
            {
                ASSERT( FALSE );
                FREE_HEAP( pdnsArray );
                continue;
            }

            DNS_ASSERT( NetInfo_IsForUpdate(pnetInfo) );
            pzoneName = NetInfo_UpdateZoneName( pnetInfo );

            //
            //  multimater update?
            //      - if flag set
            //      - or simple update (best net) times out
            //

            if ( dwFlags & DNS_UPDATE_TRY_ALL_MASTER_SERVERS )
            {
                status = DoMultiMasterUpdate(
                                pRecord,
                                dwFlags,
                                hCreds,
                                pzoneName,
                                0,
                                pdnsArray );
            }
            else
            {
                status = DoQuickUpdateEx(
                                NULL,
                                pRecord,
                                dwFlags,
                                pnetInfo,
                                hCreds );

                if ( status == ERROR_TIMEOUT )
                {
                    IP_ADDRESS  serverIp;

                    serverIp = pnetInfo->AdapterArray[0]
                                            ->ServerArray[0].IpAddress;

                    status = DoMultiMasterUpdate(
                                    pRecord,
                                    dwFlags,
                                    hCreds,
                                    pzoneName,
                                    serverIp,
                                    pdnsArray );
                }
            }

            NetInfo_Free( pnetInfo );
            FREE_HEAP( pdnsArray );

            if ( status == NO_ERROR ||
                 ( fUpdateTestMode &&
                   ( status == DNS_ERROR_RCODE_YXDOMAIN ||
                     status == DNS_ERROR_RCODE_YXRRSET ||
                     status == DNS_ERROR_RCODE_NXRRSET ) ) )
            {
                bsuccess = TRUE;
            }
        }

        //
        //  successful update on any network counts as success
        //
        //  DCR_QUESTION:  not sure why don't just NO_ERROR all bsuccess,
        //      only case would be this fUpdateTestMode thing above
        //      on single network
        //

        if ( bsuccess )
        {
            if ( netCount != 1 )
            {
                return NO_ERROR;
            }
        }

        return status;
    }
}



DNS_STATUS
DoQuickUpdateEx(
    OUT     PDNS_MSG_BUF *      ppMsgRecv, OPTIONAL
    IN      PDNS_RECORD         pRecord,
    IN      DWORD               dwFlags,
    IN      PDNS_NETINFO        pNetworkInfo,
    IN      HANDLE              hCreds OPTIONAL
    )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DNS_STATUS   status = NO_ERROR;
    PDNS_MSG_BUF pmsg = NULL;

    DNSDBG( TRACE, ( "DoQuickUpdateEx()\n" ));

    //
    //  do update
    //      - optionally specify update context through net adapter list
    //      otherwise DnsUpdateEx() will use FAZ
    //

    status = DnsUpdate(
                pRecord,
                dwFlags,
                pNetworkInfo,
                hCreds,
                &pmsg
                );

    if ( pmsg )
    {
        //
        //  DCR:  why LastDnsServerUpdated requires these errors?
        //
        if ( status == NO_ERROR ||
            status == DNS_ERROR_RCODE_SERVER_FAILURE ||
            status == DNS_ERROR_RCODE_NOT_IMPLEMENTED ||
            status == DNS_ERROR_RCODE_REFUSED ||
            status == DNS_ERROR_RCODE_YXRRSET ||
            status == DNS_ERROR_RCODE_NXRRSET )
        {
            IP4_ADDRESS ip = MSG_REMOTE_IP4(pmsg);

            DNSDBG( TRACE, ( "DNS Update sent to server 0x%x\n", ip ));
            g_LastDNSServerUpdated = ip;
        }

        //
        //  build last update error blob here
        //

        if ( status != NO_ERROR )
        {
            SetLastFailedUpdateInfo(
                pmsg,
                status );
        }
    }


    if ( ppMsgRecv )
    {
        *ppMsgRecv = pmsg;
    }
    else
    {
        if ( pmsg )
        {
            FREE_HEAP( pmsg );
        }
    }

    GUI_MODE_SETUP_WS_CLEANUP( g_InNTSetupMode );

    return status;
}



DNS_STATUS
DoMultiMasterUpdate(
    IN      PDNS_RECORD     pRecord,
    IN      DWORD           dwFlags,
    IN      HANDLE          hCreds          OPTIONAL,
    IN      LPSTR           pszDomain,
    IN      IP_ADDRESS      BadIp,
    IN      PIP_ARRAY       pServerList
    )
/*++

Routine Description:

    Do update to multi-master DNS primary.

Arguments:

    pRecord -- record list to update

    Flags -- update options

    hCreds -- update credentials

    pszDomain -- domain (zone) name to update

    BadIp -- IP of server that didn't response to previous update attempt

    pServerList -- list of DNS servers

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PDNS_NETINFO      pnetInfo = NULL;
    PIP_ARRAY         pnsList = NULL;
    PIP_ARRAY         pbadServerList = NULL;
    DNS_STATUS        status = DNS_ERROR_NO_DNS_SERVERS;
    DWORD             iter;

    //
    // Get the full NS server list for the domain name and x out BadIp
    // if present.
    //

    pnsList = GetNameServersListForDomain( pszDomain, pServerList );
    if ( !pnsList )
    {
        return status;
    }

    if ( pnsList->AddrCount == 1 &&
         Dns_IsAddressInIpArray( pnsList, BadIp ) )
    {
        status = ERROR_TIMEOUT;
        goto Done;
    }

    //
    // Create and initialize bad servers list with BadIp
    //

    pbadServerList = Dns_CreateIpArray( pnsList->AddrCount + 1 );
    if ( !pbadServerList )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    if ( BadIp )
    {
        Dns_AddIpToIpArray( pbadServerList, BadIp );
    }

    //
    //  attempt update against each multi-master DNS server
    //
    //  identify multi-master servers as those which return their themselves
    //  as the authoritative server when do FAZ query
    //

    for ( iter = 0; iter < pnsList->AddrCount; iter++ )
    {
        IP_ARRAY   ipArray;
        IP_ADDRESS serverIp = pnsList->AddrArray[iter];

        //
        // If the current server that we are about to FAZ to is in
        // the ignore list, skip it . . .
        //
        if ( Dns_IsAddressInIpArray( pbadServerList, serverIp ) )
        {
            continue;
        }

        ipArray.AddrCount = 1;
        ipArray.AddrArray[0] = serverIp;

        status = DoQuickFAZ(
                    &pnetInfo,
                    pszDomain,
                    &ipArray );

        if ( status != ERROR_SUCCESS )
        {
            continue;
        }

        DNS_ASSERT( pnetInfo->AdapterCount == 1 );
        DNS_ASSERT( pnetInfo->AdapterArray[0]->ServerCount != 0 );

        if ( serverIp != pnetInfo->AdapterArray[0]->ServerArray[0].IpAddress )
        {
            serverIp = pnetInfo->AdapterArray[0]->ServerArray[0].IpAddress;

            //
            // If the current server that we are about to FAZ to is in
            // the ignore list, skip it . . .
            //
            if ( Dns_IsAddressInIpArray( pbadServerList, serverIp ) )
            {
                NetInfo_Free( pnetInfo );
                continue;
            }
        }

        status = DoQuickUpdateEx(
                        NULL,
                        pRecord,
                        dwFlags,
                        pnetInfo,
                        hCreds
                        );

        NetInfo_Free( pnetInfo );

        if ( status == ERROR_TIMEOUT )
        {
            //  
            // Add serverIp to ignore list
            //

            Dns_AddIpToIpArray( pbadServerList, serverIp );
        }
        else
        {
            if ( dwFlags & DNS_UPDATE_TRY_ALL_MASTER_SERVERS )
            {
                Dns_AddIpToIpArray( pbadServerList, serverIp );
            }
            else
            {
                goto Done;
            }
        }
    }


Done:

    FREE_HEAP( pnsList );
    FREE_HEAP( pbadServerList );
    return status;
}



//
//  DCR_DELETE:  not sure of the point of GetLastServerUpdateIp()
//

IP_ADDRESS
DnsGetLastServerUpdateIP(
    void )
/*++

Routine Description:

    None.

Arguments:

    None.

Return Value:

    None.

--*/
{
    return g_LastDNSServerUpdated;
}



//
//  Last failed update info
//

DNS_FAILED_UPDATE_INFO g_FailedUpdateInfo = { 0, 0, 0, 0 };


VOID
DnsGetLastFailedUpdateInfo(
    OUT     PDNS_FAILED_UPDATE_INFO pInfo
    )
/*++

Routine Description:

    Retrieve failed update information.

Arguments:

    pInfo -- ptr to receive failed info blob

Return Value:

    None.

--*/
{
    //  fill in last info

    RtlCopyMemory(
        pInfo,
        & g_FailedUpdateInfo,
        sizeof(*pInfo) );
}



VOID
SetLastFailedUpdateInfo(
    IN      PDNS_MSG_BUF    pMsg,
    IN      DNS_STATUS      Status
    )
/*++

Routine Description:

    Set last failed update info.

Arguments:

    pMsg -- message with update failure

    Status -- status

Return Value:

    None.

--*/
{
    g_FailedUpdateInfo.Ip4Address = MSG_REMOTE_IP4(pMsg);
    //g_FailedUpdateInfo.Ip6Address = MSG_REMOTE_IP6(pMsg);
    g_FailedUpdateInfo.Status     = Status;
    g_FailedUpdateInfo.Rcode      = pMsg->MessageHead.ResponseCode;
}

//
//  DCR:  include client secure update here
//      to do so, will have to expose
//      in dnslib some of the security utilities
//      but then can REMOVE exports of a bunch
//      of the send\recv\socket routines
//

//
//  End of udpate.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\test\adnroff.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dnssdk.h>

_cdecl
main(int argc, char **argv)
{
    WCHAR             usName[MAX_PATH];
    LONG              cch;

    cch = MultiByteToWideChar(
              CP_ACP,
              0L,
              argv[1],
              -1,
              usName,
              MAX_PATH
              );

    if ( argc == 2 )
    {
        DnsDisableAdapterDomainNameRegistration( usName );
    }

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\test\adnron.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dnssdk.h>

_cdecl
main(int argc, char **argv)
{
    WCHAR             usName[MAX_PATH];
    LONG              cch;

    cch = MultiByteToWideChar(
              CP_ACP,
              0L,
              argv[1],
              -1,
              usName,
              MAX_PATH
              );

    if ( argc == 2 )
    {
        DnsEnableAdapterDomainNameRegistration( usName );
    }

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\test\adpqry.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dnssdk.h>

VOID
PrintIpAddress (
    IN  DWORD dwIpAddress );

_cdecl
main(int argc, char **argv)
{
    PNETWORK_INFORMATION pNetworkInfo = NULL;

    printf( "Get the local adapter information list\n" );

    pNetworkInfo = DnsGetNetworkInformation();

    if ( pNetworkInfo )
    {
        printf( "Network Information:\n" );
        DnsFreeNetworkInformation( pNetworkInfo );
    }
    else
    {
        printf( "Could not get network information\n" );
    }

    return(0);
}

VOID
PrintIpAddress (
    IN  DWORD dwIpAddress )
{
    printf( "   %d.%d.%d.%d\n",
            ((BYTE *) &dwIpAddress)[0],
            ((BYTE *) &dwIpAddress)[1],
            ((BYTE *) &dwIpAddress)[2],
            ((BYTE *) &dwIpAddress)[3] );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\test\bnodeon.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dnsapi.h>

_cdecl
main(int argc, char **argv)
{
    DnsEnableBNodeResolverThread();
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\test\bnodeoff.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dnsapi.h>

_cdecl
main(int argc, char **argv)
{
    DnsDisableBNodeResolverThread();
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\test\chkname.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dnsapi.h>

_cdecl
main(int argc, char **argv)
{
    LPWSTR pszDomain = NULL;
    DNS_STATUS Status = NO_ERROR;

    if ( argc != 2 )
    {
        printf( "\n  Usage: chkname <DNS Name>\n\n" );
        return(-1);
    }

    Status = DnsCheckNameCollision_A( argv[1], 0 );

    if ( Status )
    {
        printf( "\n  DnsCheckNameCollision_A( 0 ) returned error: 0x%x\n",
                Status );
    }
    else
    {
        printf( "\n  DnsCheckNameCollision_A( 0 ) returned success\n" );
    }

    Status = DnsCheckNameCollision_A( argv[1], 1 );

    if ( Status )
    {
        printf( "\n  DnsCheckNameCollision_A( 1 ) returned error: 0x%x\n",
                Status );
    }
    else
    {
        printf( "\n  DnsCheckNameCollision_A( 1 ) returned success\n" );
    }

    Status = DnsCheckNameCollision_A( argv[1], 2 );

    if ( Status )
    {
        printf( "\n  DnsCheckNameCollision_A( 2 ) returned error: 0x%x\n",
                Status );
    }
    else
    {
        printf( "\n  DnsCheckNameCollision_A( 2 ) returned success\n" );
    }

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\test\ddnson.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dnsapi.h>

_cdecl
main(int argc, char **argv)
{
    WCHAR             usName[MAX_PATH];
    LONG              cch;

    cch = MultiByteToWideChar(
              CP_ACP,
              0L,
              argv[1],
              -1,
              usName,
              MAX_PATH
              );

    if ( argc == 1 )
    {
        DnsEnableDynamicRegistration( NULL );
    }
    else
    {
        DnsEnableDynamicRegistration( usName );
    }

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\test\ddnsoff.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dnsapi.h>

_cdecl
main(int argc, char **argv)
{
    WCHAR             usName[MAX_PATH];
    LONG              cch;

    cch = MultiByteToWideChar(
              CP_ACP,
              0L,
              argv[1],
              -1,
              usName,
              MAX_PATH
              );

    if ( argc == 1 )
    {
        DnsDisableDynamicRegistration( NULL );
    }
    else
    {
        DnsDisableDynamicRegistration( usName );
    }

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\test\dnsadd.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dnsapi.h>


_cdecl
main(int argc, char **argv)
{
    DWORD          Status = NO_ERROR;
    PDNS_RECORD    pDNSRecord = NULL;
    WCHAR          usName[MAX_PATH];
    LONG           cch;
    LPSTR          lpTemp = NULL, lpAddress = NULL;
    BYTE           Part1, Part2, Part3, Part4;

    if ( argc != 3 )
    {
        printf( "\nUsage: dnsreg <DNS Name> <IP Address>\n" );
        printf( "\nWhere:\n" );
        printf( "    DNS Name   - Server_X.dbsd-test.microsoft.com\n" );
        printf( "    IP Address - 121.55.54.121\n" );
        return(-1);
    }

    cch = MultiByteToWideChar(
              CP_ACP,
              0L,  
              argv[1],  
              -1,         
              usName, 
              MAX_PATH 
              );

    if (!cch) {
        return (GetLastError());
    }


    lpAddress = argv[2];

    lpTemp = strtok( lpAddress, "." );
    Part1 = (BYTE) atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    Part2 = (BYTE) atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    Part3 = (BYTE) atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    Part4 = (BYTE) atoi( lpTemp );

    printf( "\nRegistering DNS record with:\n" );
    printf( "Name:    %S\n", usName );
    printf( "Address: %d.%d.%d.%d\n", Part1, Part2, Part3, Part4 );

    pDNSRecord = (PDNS_RECORD) LocalAlloc( LPTR, sizeof( DNS_RECORD ) );

    if ( !pDNSRecord )
    {
        
        printf( "LocalAlloc( sizeof( DNS_RECORD ) ) call failed.\n" );
        return(-1);
    }

    //
    // Prepare a DNS RRSet with a new A record to add ...
    //
    pDNSRecord->pNext = NULL;
    pDNSRecord->nameOwner = (DNS_NAME) usName;
    pDNSRecord->wType = DNS_TYPE_A;
    pDNSRecord->wDataLength = sizeof( DNS_A_DATA );
    // pDNSRecord->wReserved = 0;
    // pDNSRecord->Flags.W = 0;
    pDNSRecord->dwTtl = 240;
    ((BYTE *) &pDNSRecord->Data.A.ipAddress)[0] = Part1;
    ((BYTE *) &pDNSRecord->Data.A.ipAddress)[1] = Part2;
    ((BYTE *) &pDNSRecord->Data.A.ipAddress)[2] = Part3;
    ((BYTE *) &pDNSRecord->Data.A.ipAddress)[3] = Part4;

    printf( "DnsAddRecordSet_W( pDNSRecord, 0 ) ...\n",
            usName );

    Status = DnsAddRecordSet_W( NULL, pDNSRecord, 0, NULL );

   LocalFree( pDNSRecord );
   if ( Status )
    {
        
        printf( "DnsAddRecordSet_W call failed with error: 0x%.8X\n",
                Status );
        return(-1);
    }

    printf( "DnsAddRecordSet_W call succeeded!\n" );


    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\test\dhcp.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dnsapi.h>

_cdecl
main(int argc, char **argv)
{
    DWORD cch, status ;
    WCHAR szName[256] ;
    REGISTER_HOST_STATUS RegisterStatus ;
    REGISTER_HOST_ENTRY  RegisterEntries[3] ;
    char c;

    if (argc != 2) {
   
        printf("Usage: dhcp <name>.\n") ;
        exit(1) ;
    }

    printf("DHCP Async API Test\n") ;



    if (!(RegisterStatus.hDoneEvent = CreateEventA(NULL, TRUE,FALSE,NULL))) {
   
        status = GetLastError();
        printf("Cant create event.\n");
        printf ("GetLastError() returned %x\n",status);
        exit(1) ;
    }

    strcpy(szName, argv[1]);

    RegisterEntries[0].Addr.ipAddr = 0x101 ;
    RegisterEntries[0].dwOptions   = REGISTER_HOST_A ;

    RegisterEntries[1].Addr.ipAddr = 0x101 ;
    RegisterEntries[1].dwOptions   = REGISTER_HOST_A | REGISTER_HOST_PTR ;

    RegisterEntries[2].Addr.ipAddr = 0x103 ;
    RegisterEntries[2].dwOptions   = REGISTER_HOST_A | REGISTER_HOST_TRANSIENT ;

    status = DnsAsyncRegisterHostAddrs(szName, 
                                       RegisterEntries,
                                       1,
                                       NULL,
                                       &RegisterStatus,
                                       678) ;

    if (status != NO_ERROR) {

        printf("DnsAsyncRegisterHostAddrs failed immediately with %x.\n",
               status) ;
        exit(1) ;
    }

    c = getchar();

    status = WaitForSingleObject(RegisterStatus.hDoneEvent, INFINITE) ;

    if (status != WAIT_OBJECT_0) {

        printf("DnsAsyncRegisterHostAddrs failed with %x.\n",status) ;
        exit(1) ;
    }
    else {

        printf("DnsAsyncRegisterHostAddrs completes with: %x.\n",
               RegisterStatus.dwStatus) ;
    }
                           

// Sleep(100000) ;
 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\test\dhcptest.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dnsapi.h>


VOID
GetStringA( char * );

VOID
GetStringW( WCHAR * );

VOID
PrintMenu( VOID );

VOID
DoInitialize( VOID );

VOID
DoTerminate( VOID );

VOID
DoRegisterWithPTR( VOID );

VOID
DoDeregisterWithPTR( VOID );

VOID
DoRegisterWithoutPTR( VOID );

VOID
DoDeregisterWithoutPTR( VOID );

VOID
DoRASRegisterWithPTR( VOID );

VOID
DoRASDeregisterWithPTR( VOID );

VOID
DoRemoveInterface( VOID );

VOID
DoMATAddSim( VOID );

VOID
DoMATAddDis( VOID );

VOID
DoMATAddMul( VOID );

VOID
DoMATModSim( VOID );

VOID
DoMATModDis( VOID );

VOID
DoMATModMul( VOID );

VOID
DoMATAddMulNTTEST( VOID );

VOID
PrintIpAddress ( DWORD IpAddress );

_cdecl
main(int argc, char **argv)
{
    char  String[256];

Menu :

    PrintMenu();
    GetStringA( String );
    printf( "\n" );

    switch( atoi( String ) )
    {
        case 1 :
            DoInitialize();
            break;

        case 2 :
            DoTerminate();
            break;

        case 3 :
            DoRegisterWithPTR();
            break;

        case 4 :
            DoDeregisterWithPTR();
            break;

        case 5 :
            DoRegisterWithoutPTR();
            break;

        case 6 :
            DoDeregisterWithoutPTR();
            break;

        case 7 :
            DoRASRegisterWithPTR();
            break;

        case 8 :
            DoRASDeregisterWithPTR();
            break;

        case 9 :
            DoRemoveInterface();
            break;

        case 10 :
            DoMATAddSim();
            break;

        case 11 :
            DoMATAddDis();
            break;

        case 12 :
            DoMATAddMul();
            break;

        case 13 :
            DoMATModSim();
            break;

        case 14 :
            DoMATModDis();
            break;

        case 15 :
            DoMATModMul();
            break;

        case 16 :
            DoMATAddMulNTTEST();
            break;

        case 17 :
            DoTerminate();
            return( -1 );

        default :
            printf( "Invalid option\n" );
    }

    goto Menu;
}


VOID
GetStringA( char * String )
{
    WORD iter = 0;
    char ch = (char) getchar();

    while ( ch != 0x0a )
    {
        String[iter] = ch;
        ch = (char) getchar();
        iter++;
    }

    String[iter] = 0;
}


VOID
GetStringW( WCHAR * String )
{
    WORD  iter = 0;
    WCHAR ch = (WCHAR) getchar();

    while ( ch != 0x0a )
    {
        String[iter] = ch;
        ch = (WCHAR) getchar();
        iter++;
    }

    String[iter] = 0;
}


VOID
PrintMenu( VOID )
{
    printf( "\n" );
    printf( "------------------------------------------------------\n" );
    printf( "|      DHCP Asyncronous Registration Test Tool       |\n" );
    printf( "------------------------------------------------------\n" );
    printf( "|                                                    |\n" );
    printf( "| 1)  Initialize Asyncronous Registration API        |\n" );
    printf( "| 2)  Terminate Asyncronous Registration API         |\n" );
    printf( "| 3)  Register entry (with PTR)                      |\n" );
    printf( "| 4)  Deregister entry (with PTR)                    |\n" );
    printf( "| 5)  Register entry (without PTR)                   |\n" );
    printf( "| 6)  Deregister entry (without PTR)                 |\n" );
    printf( "| 7)  Register entry (RAS with PTR)                  |\n" );
    printf( "| 8)  Deregister entry (RAS with PTR)                |\n" );
    printf( "| 9)  Remove interface                               |\n" );
    printf( "| 10) Multi-adapter test (Add - all similar)         |\n" );
    printf( "| 11) Multi-adapter test (Add - disjoint)            |\n" );
    printf( "| 12) Multi-adapter test (Add - multi-master)        |\n" );
    printf( "| 13) Multi-adapter test (Mod - all similar)         |\n" );
    printf( "| 14) Multi-adapter test (Mod - disjoint)            |\n" );
    printf( "| 15) Multi-adapter test (Mod - multi-master)        |\n" );
    printf( "| 16) Multi-adapter test (Mod NT Test - multi-master)|\n" );
    printf( "| 17) Quit                                           |\n" );
    printf( "|                                                    |\n" );
    printf( ">>> " );
}


VOID
PrintIpAddress ( DWORD IpAddress )
{
    printf( "   %d.%d.%d.%d\n",
            ((BYTE *) &IpAddress)[0],
            ((BYTE *) &IpAddress)[1],
            ((BYTE *) &IpAddress)[2],
            ((BYTE *) &IpAddress)[3] );
}


VOID
DoInitialize( VOID )
{
    DNS_STATUS Status = NO_ERROR;

    Status = DnsAsyncRegisterInit( NULL );

    printf( "DnsAsyncRegisterInit() returned: 0x%x\n", Status );
}


VOID
DoTerminate( VOID )
{
    DNS_STATUS Status = NO_ERROR;

    Status = DnsAsyncRegisterTerm();

    printf( "DnsAsyncRegisterTerm() returned: 0x%x\n", Status );
}


VOID
DoRegisterWithPTR( VOID )
{
    DNS_STATUS Status = NO_ERROR;
    char       AdapterName[256];
    char       HostName[256];
    char       DomainName[256];
    char       Address[500];
    LPSTR      lpTemp = NULL;
    DWORD      Part1, Part2, Part3, Part4;
    char       seps[]=" ,\t\n";
    char*      token;
    INT        ipAddrCount;
    DWORD      length, len;
    IP_ADDRESS ServerList[15];
    DWORD      ServerListCount;
    REGISTER_HOST_ENTRY  HostAddrs[5];
    REGISTER_HOST_STATUS RegisterStatus;

    if (!(RegisterStatus.hDoneEvent = CreateEventA( NULL,
                                                    TRUE,
                                                    FALSE,
                                                    NULL)))
    {
        Status = GetLastError();
        printf( "Cant create event.\n" );
        printf ( "GetLastError() returned %x\n", Status );
        exit(1);
    }

    printf( "Adapter Name: " );
    GetStringA( AdapterName );
    printf( "\n" );

    printf( "Host Name: " );
    GetStringA( HostName );
    printf( "\n" );

    printf( "Domain Name: " );
    GetStringA( DomainName );
    printf( "\n" );

    printf( "IP Address(es): " );
    GetStringA( Address );
    printf( "\n" );

    ipAddrCount = 0;

    length = strlen( Address );
    token = strtok(Address, seps);
    if ( token )
        len = (DWORD) (token - Address);

    while ( token != NULL)
    {
        len += strlen( token ) + 1;

        lpTemp = strtok( token, "." );
        Part1 = atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part2 = atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part3 = atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part4 = atoi( lpTemp );

        printf( "\nRegistering DNS record for:\n" );
        printf("AdapterName = %s\n", AdapterName);
        printf("HostName = %s\n", HostName);
        printf("DomainName = %s\n", DomainName);

        printf( "Address: %d.%d.%d.%d\n", Part1, Part2, Part3, Part4 );

        HostAddrs[ipAddrCount].dwOptions = REGISTER_HOST_A | REGISTER_HOST_PTR;

        HostAddrs[ipAddrCount].Addr.ipAddr = (DWORD)(Part1) +
                                             (DWORD)(Part2 << 8) +
                                             (DWORD)(Part3 << 16) +
                                             (DWORD)(Part4 << 24);

        ipAddrCount++;

        if ( len < length )
            lpTemp = &Address[len];
        else
            lpTemp = NULL;
        token = strtok(lpTemp, seps);
        if ( token )
            len = (DWORD) (token - Address);
    }

    printf( "Server Address(es): " );
    GetStringA( Address );
    printf( "\n" );

    ServerListCount = 0;

    length = strlen( Address );
    token = strtok(Address, seps);
    if ( token )
        len = (DWORD) (token - Address);

    while ( token != NULL)
    {
        len += strlen( token ) + 1;

        lpTemp = strtok( token, "." );
        Part1 = atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part2 = atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part3 = atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part4 = atoi( lpTemp );

        ServerList[ServerListCount] = (DWORD)(Part1) +
                                      (DWORD)(Part2 << 8) +
                                      (DWORD)(Part3 << 16) +
                                      (DWORD)(Part4 << 24);

        ServerListCount++;

        if ( len < length )
            lpTemp = &Address[len];
        else
            lpTemp = NULL;
        token = strtok(lpTemp, seps);
        if ( token )
            len = (DWORD) (token - Address);
    }

    Status = DnsAsyncRegisterHostAddrs_A( AdapterName,
                                          HostName,
                                          HostAddrs,
                                          ipAddrCount,
                                          ServerList,
                                          ServerListCount,
                                          DomainName,
                                          &RegisterStatus,
                                          300,
                                          DYNDNS_REG_PTR );

    printf( "DnsAsyncRegisterHostAddrs_A() returned: 0x%x\n", Status );

    if ( Status == NO_ERROR )
    {
        Status = WaitForSingleObject( RegisterStatus.hDoneEvent, INFINITE ) ;

        if ( Status != WAIT_OBJECT_0 )
        {
            printf( "DnsAsyncRegisterHostAddrs failed with %x.\n", Status ) ;
            exit(1) ;
        }
        else
        {
            printf( "DnsAsyncRegisterHostAddrs completes with: %x.\n",
                   RegisterStatus.dwStatus ) ;
        }
    }
}


VOID
DoDeregisterWithPTR( VOID )
{
    DNS_STATUS Status = NO_ERROR;
    char       AdapterName[256];
    char       HostName[256];
    char       DomainName[256];
    char       Address[500];
    LPSTR      lpTemp = NULL;
    DWORD      Part1, Part2, Part3, Part4;
    char       seps[]=" ,\t\n";
    char*      token;
    INT        ipAddrCount;
    DWORD      length, len;
    IP_ADDRESS ServerList[15];
    DWORD      ServerListCount;
    REGISTER_HOST_ENTRY  HostAddrs[5];
    REGISTER_HOST_STATUS RegisterStatus;

    if (!(RegisterStatus.hDoneEvent = CreateEventA( NULL,
                                                    TRUE,
                                                    FALSE,
                                                    NULL)))
    {
        Status = GetLastError();
        printf( "Cant create event.\n" );
        printf ( "GetLastError() returned %x\n", Status );
        exit(1);
    }

    printf( "Adapter Name: " );
    GetStringA( AdapterName );
    printf( "\n" );

    printf( "Host Name: " );
    GetStringA( HostName );
    printf( "\n" );

    printf( "Domain Name: " );
    GetStringA( DomainName );
    printf( "\n" );

    printf( "IP Address(es): " );
    GetStringA( Address );
    printf( "\n" );

    ipAddrCount = 0;

    length = strlen( Address );
    token = strtok(Address, seps);
    if ( token )
        len = (DWORD) (token - Address);

    while ( token != NULL)
    {
        len += strlen( token ) + 1;

        lpTemp = strtok( token, "." );
        Part1 = atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part2 = atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part3 = atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part4 = atoi( lpTemp );

        printf( "\nRegistering DNS record for:\n" );
        printf("AdapterName = %s\n", AdapterName);
        printf("HostName = %s\n", HostName);
        printf("DomainName = %s\n", DomainName);

        printf( "Address: %d.%d.%d.%d\n", Part1, Part2, Part3, Part4 );

        HostAddrs[ipAddrCount].dwOptions = REGISTER_HOST_A | REGISTER_HOST_PTR;

        HostAddrs[ipAddrCount].Addr.ipAddr = (DWORD)(Part1) +
                                             (DWORD)(Part2 << 8) +
                                             (DWORD)(Part3 << 16) +
                                             (DWORD)(Part4 << 24);

        ipAddrCount++;

        if ( len < length )
            lpTemp = &Address[len];
        else
            lpTemp = NULL;
        token = strtok(lpTemp, seps);
        if ( token )
            len = (DWORD) (token - Address);
    }

    printf( "Server Address(es): " );
    GetStringA( Address );
    printf( "\n" );

    ServerListCount = 0;

    length = strlen( Address );
    token = strtok(Address, seps);
    if ( token )
        len = (DWORD) (token - Address);

    while ( token != NULL)
    {
        len += strlen( token ) + 1;

        lpTemp = strtok( token, "." );
        Part1 = atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part2 = atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part3 = atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part4 = atoi( lpTemp );

        ServerList[ServerListCount] = (DWORD)(Part1) +
                                      (DWORD)(Part2 << 8) +
                                      (DWORD)(Part3 << 16) +
                                      (DWORD)(Part4 << 24);

        ServerListCount++;

        if ( len < length )
            lpTemp = &Address[len];
        else
            lpTemp = NULL;
        token = strtok(lpTemp, seps);
        if ( token )
            len = (DWORD) (token - Address);
    }

    Status = DnsAsyncRegisterHostAddrs_A( AdapterName,
                                          HostName,
                                          HostAddrs,
                                          ipAddrCount,
                                          ServerList,
                                          ServerListCount,
                                          DomainName,
                                          &RegisterStatus,
                                          300,
                                          DYNDNS_REG_PTR |
                                          DYNDNS_DEL_ENTRY );

    printf( "DnsAsyncRegisterHostAddrs_A() returned: 0x%x\n", Status );

    if ( Status == NO_ERROR )
    {
        Status = WaitForSingleObject( RegisterStatus.hDoneEvent, INFINITE ) ;

        if ( Status != WAIT_OBJECT_0 )
        {
            printf( "DnsAsyncRegisterHostAddrs failed with %x.\n", Status ) ;
            exit(1) ;
        }
        else
        {
            printf( "DnsAsyncRegisterHostAddrs completes with: %x.\n",
                   RegisterStatus.dwStatus ) ;
        }
    }
}


VOID
DoRegisterWithoutPTR( VOID )
{
    DNS_STATUS Status = NO_ERROR;
    char       AdapterName[256];
    char       HostName[256];
    char       DomainName[256];
    char       Address[500];
    LPSTR      lpTemp = NULL;
    DWORD      Part1, Part2, Part3, Part4;
    char       seps[]=" ,\t\n";
    char*      token;
    INT        ipAddrCount;
    DWORD      length, len;
    IP_ADDRESS ServerList[15];
    DWORD      ServerListCount;
    REGISTER_HOST_ENTRY  HostAddrs[5];
    REGISTER_HOST_STATUS RegisterStatus;

    if (!(RegisterStatus.hDoneEvent = CreateEventA( NULL,
                                                    TRUE,
                                                    FALSE,
                                                    NULL)))
    {
        Status = GetLastError();
        printf( "Cant create event.\n" );
        printf ( "GetLastError() returned %x\n", Status );
        exit(1);
    }

    printf( "Adapter Name: " );
    GetStringA( AdapterName );
    printf( "\n" );

    printf( "Host Name: " );
    GetStringA( HostName );
    printf( "\n" );

    printf( "Domain Name: " );
    GetStringA( DomainName );
    printf( "\n" );

    printf( "IP Address(es): " );
    GetStringA( Address );
    printf( "\n" );

    ipAddrCount = 0;

    length = strlen( Address );
    token = strtok(Address, seps);
    if ( token )
        len = (DWORD) (token - Address);

    while ( token != NULL)
    {
        len += strlen( token ) + 1;

        lpTemp = strtok( token, "." );
        Part1 = atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part2 = atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part3 = atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part4 = atoi( lpTemp );

        printf( "\nRegistering DNS record for:\n" );
        printf("AdapterName = %s\n", AdapterName);
        printf("HostName = %s\n", HostName);
        printf("DomainName = %s\n", DomainName);

        printf( "Address: %d.%d.%d.%d\n", Part1, Part2, Part3, Part4 );

        HostAddrs[ipAddrCount].dwOptions = REGISTER_HOST_A;

        HostAddrs[ipAddrCount].Addr.ipAddr = (DWORD)(Part1) +
                                             (DWORD)(Part2 << 8) +
                                             (DWORD)(Part3 << 16) +
                                             (DWORD)(Part4 << 24);

        ipAddrCount++;

        if ( len < length )
            lpTemp = &Address[len];
        else
            lpTemp = NULL;
        token = strtok(lpTemp, seps);
        if ( token )
            len = (DWORD) (token - Address);
    }

    printf( "Server Address(es): " );
    GetStringA( Address );
    printf( "\n" );

    ServerListCount = 0;

    length = strlen( Address );
    token = strtok(Address, seps);
    if ( token )
        len = (DWORD) (token - Address);

    while ( token != NULL)
    {
        len += strlen( token ) + 1;

        lpTemp = strtok( token, "." );
        Part1 = atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part2 = atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part3 = atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part4 = atoi( lpTemp );

        ServerList[ServerListCount] = (DWORD)(Part1) +
                                      (DWORD)(Part2 << 8) +
                                      (DWORD)(Part3 << 16) +
                                      (DWORD)(Part4 << 24);

        ServerListCount++;

        if ( len < length )
            lpTemp = &Address[len];
        else
            lpTemp = NULL;
        token = strtok(lpTemp, seps);
        if ( token )
            len = (DWORD) (token - Address);
    }

    Status = DnsAsyncRegisterHostAddrs_A( AdapterName,
                                          HostName,
                                          HostAddrs,
                                          ipAddrCount,
                                          ServerList,
                                          ServerListCount,
                                          DomainName,
                                          &RegisterStatus,
                                          300,
                                          0 );

    printf( "DnsAsyncRegisterHostAddrs_A() returned: 0x%x\n", Status );

    if ( Status == NO_ERROR )
    {
        Status = WaitForSingleObject( RegisterStatus.hDoneEvent, INFINITE ) ;

        if ( Status != WAIT_OBJECT_0 )
        {
            printf( "DnsAsyncRegisterHostAddrs failed with %x.\n", Status ) ;
            exit(1) ;
        }
        else
        {
            printf( "DnsAsyncRegisterHostAddrs completes with: %x.\n",
                   RegisterStatus.dwStatus ) ;
        }
    }
}


VOID
DoDeregisterWithoutPTR( VOID )
{
    DNS_STATUS Status = NO_ERROR;
    char       AdapterName[256];
    char       HostName[256];
    char       DomainName[256];
    char       Address[500];
    LPSTR      lpTemp = NULL;
    DWORD      Part1, Part2, Part3, Part4;
    char       seps[]=" ,\t\n";
    char*      token;
    INT        ipAddrCount;
    DWORD      length, len;
    IP_ADDRESS ServerList[15];
    DWORD      ServerListCount;
    REGISTER_HOST_ENTRY  HostAddrs[5];
    REGISTER_HOST_STATUS RegisterStatus;

    if (!(RegisterStatus.hDoneEvent = CreateEventA( NULL,
                                                    TRUE,
                                                    FALSE,
                                                    NULL)))
    {
        Status = GetLastError();
        printf( "Cant create event.\n" );
        printf ( "GetLastError() returned %x\n", Status );
        exit(1);
    }

    printf( "Adapter Name: " );
    GetStringA( AdapterName );
    printf( "\n" );

    printf( "Host Name: " );
    GetStringA( HostName );
    printf( "\n" );

    printf( "Domain Name: " );
    GetStringA( DomainName );
    printf( "\n" );

    printf( "IP Address(es): " );
    GetStringA( Address );
    printf( "\n" );

    ipAddrCount = 0;

    length = strlen( Address );
    token = strtok(Address, seps);
    if ( token )
        len = (DWORD) (token - Address);

    while ( token != NULL)
    {
        len += strlen( token ) + 1;

        lpTemp = strtok( token, "." );
        Part1 = atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part2 = atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part3 = atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part4 = atoi( lpTemp );

        printf( "\nRegistering DNS record for:\n" );
        printf("AdapterName = %s\n", AdapterName);
        printf("HostName = %s\n", HostName);
        printf("DomainName = %s\n", DomainName);

        printf( "Address: %d.%d.%d.%d\n", Part1, Part2, Part3, Part4 );

        HostAddrs[ipAddrCount].dwOptions = REGISTER_HOST_A;

        HostAddrs[ipAddrCount].Addr.ipAddr = (DWORD)(Part1) +
                                             (DWORD)(Part2 << 8) +
                                             (DWORD)(Part3 << 16) +
                                             (DWORD)(Part4 << 24);

        ipAddrCount++;

        if ( len < length )
            lpTemp = &Address[len];
        else
            lpTemp = NULL;
        token = strtok(lpTemp, seps);
        if ( token )
            len = (DWORD) (token - Address);
    }

    printf( "Server Address(es): " );
    GetStringA( Address );
    printf( "\n" );

    ServerListCount = 0;

    length = strlen( Address );
    token = strtok(Address, seps);
    if ( token )
        len = (DWORD) (token - Address);

    while ( token != NULL)
    {
        len += strlen( token ) + 1;

        lpTemp = strtok( token, "." );
        Part1 = atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part2 = atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part3 = atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part4 = atoi( lpTemp );

        ServerList[ServerListCount] = (DWORD)(Part1) +
                                      (DWORD)(Part2 << 8) +
                                      (DWORD)(Part3 << 16) +
                                      (DWORD)(Part4 << 24);

        ServerListCount++;

        if ( len < length )
            lpTemp = &Address[len];
        else
            lpTemp = NULL;
        token = strtok(lpTemp, seps);
        if ( token )
            len = (DWORD) (token - Address);
    }

    Status = DnsAsyncRegisterHostAddrs_A( AdapterName,
                                          HostName,
                                          HostAddrs,
                                          ipAddrCount,
                                          ServerList,
                                          ServerListCount,
                                          DomainName,
                                          &RegisterStatus,
                                          300,
                                          DYNDNS_DEL_ENTRY );

    printf( "DnsAsyncRegisterHostAddrs_A() returned: 0x%x\n", Status );

    if ( Status == NO_ERROR )
    {
        Status = WaitForSingleObject( RegisterStatus.hDoneEvent, INFINITE ) ;

        if ( Status != WAIT_OBJECT_0 )
        {
            printf( "DnsAsyncRegisterHostAddrs failed with %x.\n", Status ) ;
            exit(1) ;
        }
        else
        {
            printf( "DnsAsyncRegisterHostAddrs completes with: %x.\n",
                   RegisterStatus.dwStatus ) ;
        }
    }
}


VOID
DoRASRegisterWithPTR( VOID )
{
    DNS_STATUS Status = NO_ERROR;
    char       AdapterName[256];
    char       HostName[256];
    char       DomainName[256];
    char       Address[500];
    LPSTR      lpTemp = NULL;
    DWORD      Part1, Part2, Part3, Part4;
    char       seps[]=" ,\t\n";
    char*      token;
    INT        ipAddrCount;
    DWORD      length, len;
    IP_ADDRESS ServerList[15];
    DWORD      ServerListCount;
    REGISTER_HOST_ENTRY  HostAddrs[5];
    REGISTER_HOST_STATUS RegisterStatus;

    if (!(RegisterStatus.hDoneEvent = CreateEventA( NULL,
                                                    TRUE,
                                                    FALSE,
                                                    NULL)))
    {
        Status = GetLastError();
        printf( "Cant create event.\n" );
        printf ( "GetLastError() returned %x\n", Status );
        exit(1);
    }

    printf( "Adapter Name: " );
    GetStringA( AdapterName );
    printf( "\n" );

    printf( "Host Name: " );
    GetStringA( HostName );
    printf( "\n" );

    printf( "Domain Name: " );
    GetStringA( DomainName );
    printf( "\n" );

    printf( "IP Address(es): " );
    GetStringA( Address );
    printf( "\n" );

    ipAddrCount = 0;

    length = strlen( Address );
    token = strtok(Address, seps);
    if ( token )
        len = (DWORD) (token - Address);

    while ( token != NULL)
    {
        len += strlen( token ) + 1;

        lpTemp = strtok( token, "." );
        Part1 = atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part2 = atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part3 = atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part4 = atoi( lpTemp );

        printf( "\nRegistering DNS record for:\n" );
        printf("AdapterName = %s\n", AdapterName);
        printf("HostName = %s\n", HostName);
        printf("DomainName = %s\n", DomainName);

        printf( "Address: %d.%d.%d.%d\n", Part1, Part2, Part3, Part4 );

        HostAddrs[ipAddrCount].dwOptions = REGISTER_HOST_A | REGISTER_HOST_PTR;

        HostAddrs[ipAddrCount].Addr.ipAddr = (DWORD)(Part1) +
                                             (DWORD)(Part2 << 8) +
                                             (DWORD)(Part3 << 16) +
                                             (DWORD)(Part4 << 24);

        ipAddrCount++;

        if ( len < length )
            lpTemp = &Address[len];
        else
            lpTemp = NULL;
        token = strtok(lpTemp, seps);
        if ( token )
            len = (DWORD) (token - Address);
    }

    printf( "Server Address(es): " );
    GetStringA( Address );
    printf( "\n" );

    ServerListCount = 0;

    length = strlen( Address );
    token = strtok(Address, seps);
    if ( token )
        len = (DWORD) (token - Address);

    while ( token != NULL)
    {
        len += strlen( token ) + 1;

        lpTemp = strtok( token, "." );
        Part1 = atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part2 = atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part3 = atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part4 = atoi( lpTemp );

        ServerList[ServerListCount] = (DWORD)(Part1) +
                                      (DWORD)(Part2 << 8) +
                                      (DWORD)(Part3 << 16) +
                                      (DWORD)(Part4 << 24);

        ServerListCount++;

        if ( len < length )
            lpTemp = &Address[len];
        else
            lpTemp = NULL;
        token = strtok(lpTemp, seps);
        if ( token )
            len = (DWORD) (token - Address);
    }

    Status = DnsAsyncRegisterHostAddrs_A( AdapterName,
                                          HostName,
                                          HostAddrs,
                                          ipAddrCount,
                                          ServerList,
                                          ServerListCount,
                                          DomainName,
                                          &RegisterStatus,
                                          300,
                                          DYNDNS_REG_PTR |
                                          DYNDNS_REG_RAS );

    printf( "DnsAsyncRegisterHostAddrs_A() returned: 0x%x\n", Status );

    if ( Status == NO_ERROR )
    {
        Status = WaitForSingleObject( RegisterStatus.hDoneEvent, INFINITE ) ;

        if ( Status != WAIT_OBJECT_0 )
        {
            printf( "DnsAsyncRegisterHostAddrs failed with %x.\n", Status ) ;
            exit(1) ;
        }
        else
        {
            printf( "DnsAsyncRegisterHostAddrs completes with: %x.\n",
                   RegisterStatus.dwStatus ) ;
        }
    }
}


VOID
DoRASDeregisterWithPTR( VOID )
{
    DNS_STATUS Status = NO_ERROR;
    char       AdapterName[256];
    char       HostName[256];
    char       DomainName[256];
    char       Address[500];
    LPSTR      lpTemp = NULL;
    DWORD      Part1, Part2, Part3, Part4;
    char       seps[]=" ,\t\n";
    char*      token;
    INT        ipAddrCount;
    DWORD      length, len;
    IP_ADDRESS ServerList[15];
    DWORD      ServerListCount;
    REGISTER_HOST_ENTRY  HostAddrs[5];
    REGISTER_HOST_STATUS RegisterStatus;

    if (!(RegisterStatus.hDoneEvent = CreateEventA( NULL,
                                                    TRUE,
                                                    FALSE,
                                                    NULL)))
    {
        Status = GetLastError();
        printf( "Cant create event.\n" );
        printf ( "GetLastError() returned %x\n", Status );
        exit(1);
    }

    printf( "Adapter Name: " );
    GetStringA( AdapterName );
    printf( "\n" );

    printf( "Host Name: " );
    GetStringA( HostName );
    printf( "\n" );

    printf( "Domain Name: " );
    GetStringA( DomainName );
    printf( "\n" );

    printf( "IP Address(es): " );
    GetStringA( Address );
    printf( "\n" );

    ipAddrCount = 0;

    length = strlen( Address );
    token = strtok(Address, seps);
    if ( token )
        len = (DWORD) (token - Address);

    while ( token != NULL)
    {
        len += strlen( token ) + 1;

        lpTemp = strtok( token, "." );
        Part1 = atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part2 = atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part3 = atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part4 = atoi( lpTemp );

        printf( "\nRegistering DNS record for:\n" );
        printf("AdapterName = %s\n", AdapterName);
        printf("HostName = %s\n", HostName);
        printf("DomainName = %s\n", DomainName);

        printf( "Address: %d.%d.%d.%d\n", Part1, Part2, Part3, Part4 );

        HostAddrs[ipAddrCount].dwOptions = REGISTER_HOST_A | REGISTER_HOST_PTR;

        HostAddrs[ipAddrCount].Addr.ipAddr = (DWORD)(Part1) +
                                             (DWORD)(Part2 << 8) +
                                             (DWORD)(Part3 << 16) +
                                             (DWORD)(Part4 << 24);

        ipAddrCount++;

        if ( len < length )
            lpTemp = &Address[len];
        else
            lpTemp = NULL;
        token = strtok(lpTemp, seps);
        if ( token )
            len = (DWORD) (token - Address);
    }

    printf( "Server Address(es): " );
    GetStringA( Address );
    printf( "\n" );

    ServerListCount = 0;

    length = strlen( Address );
    token = strtok(Address, seps);
    if ( token )
        len = (DWORD) (token - Address);

    while ( token != NULL)
    {
        len += strlen( token ) + 1;

        lpTemp = strtok( token, "." );
        Part1 = atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part2 = atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part3 = atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part4 = atoi( lpTemp );

        ServerList[ServerListCount] = (DWORD)(Part1) +
                                      (DWORD)(Part2 << 8) +
                                      (DWORD)(Part3 << 16) +
                                      (DWORD)(Part4 << 24);

        ServerListCount++;

        if ( len < length )
            lpTemp = &Address[len];
        else
            lpTemp = NULL;
        token = strtok(lpTemp, seps);
        if ( token )
            len = (DWORD) (token - Address);
    }

    Status = DnsAsyncRegisterHostAddrs_A( AdapterName,
                                          HostName,
                                          HostAddrs,
                                          ipAddrCount,
                                          ServerList,
                                          ServerListCount,
                                          DomainName,
                                          &RegisterStatus,
                                          300,
                                          DYNDNS_REG_PTR |
                                          DYNDNS_REG_RAS |
                                          DYNDNS_DEL_ENTRY );

    printf( "DnsAsyncRegisterHostAddrs_A() returned: 0x%x\n", Status );

    if ( Status == NO_ERROR )
    {
        Status = WaitForSingleObject( RegisterStatus.hDoneEvent, INFINITE ) ;

        if ( Status != WAIT_OBJECT_0 )
        {
            printf( "DnsAsyncRegisterHostAddrs failed with %x.\n", Status ) ;
            exit(1) ;
        }
        else
        {
            printf( "DnsAsyncRegisterHostAddrs completes with: %x.\n",
                   RegisterStatus.dwStatus ) ;
        }
    }
}


VOID
DoRemoveInterface( VOID )
{
    DNS_STATUS Status = NO_ERROR;

    char  AdapterName[256];

    printf( "Adapter Name: " );
    GetStringA( AdapterName );
    printf( "\n" );

    Status = DnsAsyncRegisterHostAddrs_A( AdapterName,
                                          NULL,
                                          NULL,
                                          0,
                                          NULL,
                                          0,
                                          NULL,
                                          NULL,
                                          0,
                                          DYNDNS_DEL_ENTRY );

    printf( "DnsAsyncRegisterHostAddrs_A() returned: 0x%x\n", Status );
}


VOID
DoMATAddSim( VOID )
{
    DNS_STATUS Status = NO_ERROR;
    REGISTER_HOST_ENTRY HostAddrs[2];
    IP_ADDRESS ServerIp;

    ServerIp = inet_addr( "172.31.56.186" );

    HostAddrs[0].dwOptions = REGISTER_HOST_A | REGISTER_HOST_PTR;
    HostAddrs[0].Addr.ipAddr = inet_addr( "1.1.1.1" );

    Status = DnsAsyncRegisterHostAddrs_A( "A",
                                          "glennc",
                                          HostAddrs,
                                          1,
                                          &ServerIp,
                                          1,
                                          "foo1.com",
                                          NULL,
                                          60*5,
                                          DYNDNS_REG_PTR );

    printf( "DnsAsyncRegisterHostAddrs_A() returned: 0x%x\n", Status );

    HostAddrs[0].Addr.ipAddr = inet_addr( "2.2.2.2" );

    Status = DnsAsyncRegisterHostAddrs_A( "B",
                                          "glennc",
                                          HostAddrs,
                                          1,
                                          &ServerIp,
                                          1,
                                          "foo1.com",
                                          NULL,
                                          60*5,
                                          DYNDNS_REG_PTR );

    printf( "DnsAsyncRegisterHostAddrs_A() returned: 0x%x\n", Status );

    HostAddrs[0].Addr.ipAddr = inet_addr( "3.3.3.3" );

    Status = DnsAsyncRegisterHostAddrs_A( "C",
                                          "glennc",
                                          HostAddrs,
                                          1,
                                          &ServerIp,
                                          1,
                                          "foo1.com",
                                          NULL,
                                            60*5,
                                            DYNDNS_REG_PTR );

    printf( "DnsAsyncRegisterHostAddrs_A() returned: 0x%x\n", Status );
}


VOID
DoMATAddDis( VOID )
{
    DNS_STATUS Status = NO_ERROR;
    REGISTER_HOST_ENTRY HostAddrs[2];
    IP_ADDRESS ServerIp;

    ServerIp = inet_addr( "172.31.56.187" );

    HostAddrs[0].dwOptions = REGISTER_HOST_A | REGISTER_HOST_PTR;
    HostAddrs[0].Addr.ipAddr = inet_addr( "1.1.1.1" );

    Status = DnsAsyncRegisterHostAddrs_A( "A",
                                          "glennc",
                                          HostAddrs,
                                          1,
                                          &ServerIp,
                                          1,
                                          "upd.com",
                                          NULL,
                                          60*5,
                                          DYNDNS_REG_PTR );

    printf( "DnsAsyncRegisterHostAddrs_A() returned: 0x%x\n", Status );

    HostAddrs[0].Addr.ipAddr = inet_addr( "2.2.2.2" );

    Status = DnsAsyncRegisterHostAddrs_A( "B",
                                          "glennc",
                                          HostAddrs,
                                          1,
                                          &ServerIp,
                                          1,
                                          "upd.com",
                                          NULL,
                                          60*5,
                                          DYNDNS_REG_PTR );

    printf( "DnsAsyncRegisterHostAddrs_A() returned: 0x%x\n", Status );

    ServerIp = inet_addr( "172.31.61.174" );

    HostAddrs[0].Addr.ipAddr = inet_addr( "3.3.3.3" );

    Status = DnsAsyncRegisterHostAddrs_A( "C",
                                          "glennc",
                                          HostAddrs,
                                          1,
                                          &ServerIp,
                                          1,
                                          "upd.com",
                                          NULL,
                                          60*5,
                                          DYNDNS_REG_PTR );

    printf( "DnsAsyncRegisterHostAddrs_A() returned: 0x%x\n", Status );
}


VOID
DoMATAddMul( VOID )
{
    DNS_STATUS Status = NO_ERROR;
    REGISTER_HOST_ENTRY HostAddrs[2];
    IP_ADDRESS ServerIp;

    ServerIp = inet_addr( "172.31.56.186" );

    HostAddrs[0].dwOptions = REGISTER_HOST_A | REGISTER_HOST_PTR;
    HostAddrs[0].Addr.ipAddr = inet_addr( "1.1.1.1" );

    Status = DnsAsyncRegisterHostAddrs_A( "A",
                                          "glennc",
                                          HostAddrs,
                                          1,
                                          &ServerIp,
                                          1,
                                          "upd.com",
                                          NULL,
                                          60*5,
                                          DYNDNS_REG_PTR );

    printf( "DnsAsyncRegisterHostAddrs_A() returned: 0x%x\n", Status );

    ServerIp = inet_addr( "172.31.56.187" );

    HostAddrs[0].Addr.ipAddr = inet_addr( "2.2.2.2" );

    Status = DnsAsyncRegisterHostAddrs_A( "B",
                                          "glennc",
                                          HostAddrs,
                                          1,
                                          &ServerIp,
                                          1,
                                          "upd.com",
                                          NULL,
                                          60*5,
                                          DYNDNS_REG_PTR );

    printf( "DnsAsyncRegisterHostAddrs_A() returned: 0x%x\n", Status );

    ServerIp = inet_addr( "172.31.61.174" );

    HostAddrs[0].Addr.ipAddr = inet_addr( "3.3.3.3" );

    Status = DnsAsyncRegisterHostAddrs_A( "C",
                                          "glennc",
                                          HostAddrs,
                                          1,
                                          &ServerIp,
                                          1,
                                          "upd.com",
                                          NULL,
                                          60*5,
                                          DYNDNS_REG_PTR );

    printf( "DnsAsyncRegisterHostAddrs_A() returned: 0x%x\n", Status );
}


VOID
DoMATModSim( VOID )
{
    DNS_STATUS Status = NO_ERROR;
    REGISTER_HOST_ENTRY HostAddrs[2];
    IP_ADDRESS ServerIp;

    ServerIp = inet_addr( "172.31.56.186" );

    HostAddrs[0].dwOptions = REGISTER_HOST_A | REGISTER_HOST_PTR;
    HostAddrs[0].Addr.ipAddr = inet_addr( "1.1.1.2" );

    Status = DnsAsyncRegisterHostAddrs_A( "A",
                                          "glennc",
                                          HostAddrs,
                                          1,
                                          &ServerIp,
                                          1,
                                          "foo1.com",
                                          NULL,
                                          60*5,
                                          DYNDNS_REG_PTR );

    printf( "DnsAsyncRegisterHostAddrs_A() returned: 0x%x\n", Status );

    HostAddrs[0].Addr.ipAddr = inet_addr( "2.2.2.3" );

    Status = DnsAsyncRegisterHostAddrs_A( "B",
                                          "glennc",
                                          HostAddrs,
                                          1,
                                          &ServerIp,
                                          1,
                                          "foo1.com",
                                          NULL,
                                          60*5,
                                          DYNDNS_REG_PTR );

    printf( "DnsAsyncRegisterHostAddrs_A() returned: 0x%x\n", Status );

    HostAddrs[0].Addr.ipAddr = inet_addr( "3.3.3.3" );

    Status = DnsAsyncRegisterHostAddrs_A( "C",
                                          "glennc",
                                          HostAddrs,
                                          1,
                                          &ServerIp,
                                          1,
                                          "foo1.com",
                                          NULL,
                                          60*5,
                                          DYNDNS_REG_PTR );

    printf( "DnsAsyncRegisterHostAddrs_A() returned: 0x%x\n", Status );
}


VOID
DoMATModDis( VOID )
{
    DNS_STATUS Status = NO_ERROR;
    REGISTER_HOST_ENTRY HostAddrs[2];
    IP_ADDRESS ServerIp;

    ServerIp = inet_addr( "172.31.56.186" );

    HostAddrs[0].dwOptions = REGISTER_HOST_A | REGISTER_HOST_PTR;
    HostAddrs[0].Addr.ipAddr = inet_addr( "1.1.1.2" );

    Status = DnsAsyncRegisterHostAddrs_A( "A",
                                          "glennc",
                                          HostAddrs,
                                          1,
                                          &ServerIp,
                                          1,
                                          "upd.com",
                                          NULL,
                                          60*5,
                                          DYNDNS_REG_PTR );

    printf( "DnsAsyncRegisterHostAddrs_A() returned: 0x%x\n", Status );

    HostAddrs[0].Addr.ipAddr = inet_addr( "2.2.2.3" );

    Status = DnsAsyncRegisterHostAddrs_A( "B",
                                          "glennc",
                                          HostAddrs,
                                          1,
                                          &ServerIp,
                                          1,
                                          "upd.com",
                                          NULL,
                                          60*5,
                                          DYNDNS_REG_PTR );

    printf( "DnsAsyncRegisterHostAddrs_A() returned: 0x%x\n", Status );

    ServerIp = inet_addr( "172.31.61.174" );

    HostAddrs[0].Addr.ipAddr = inet_addr( "3.3.3.3" );

    Status = DnsAsyncRegisterHostAddrs_A( "C",
                                          "glennc",
                                          HostAddrs,
                                          1,
                                          &ServerIp,
                                          1,
                                          "upd.com",
                                          NULL,
                                          60*5,
                                          DYNDNS_REG_PTR );

    printf( "DnsAsyncRegisterHostAddrs_A() returned: 0x%x\n", Status );
}


VOID
DoMATModMul( VOID )
{
    DNS_STATUS Status = NO_ERROR;
    REGISTER_HOST_ENTRY HostAddrs[2];
    IP_ADDRESS ServerIp;

    ServerIp = inet_addr( "172.31.56.186" );

    HostAddrs[0].dwOptions = REGISTER_HOST_A | REGISTER_HOST_PTR;
    HostAddrs[0].Addr.ipAddr = inet_addr( "1.1.1.2" );

    Status = DnsAsyncRegisterHostAddrs_A( "A",
                                          "glennc",
                                          HostAddrs,
                                          1,
                                          &ServerIp,
                                          1,
                                          "upd.com",
                                          NULL,
                                          60*5,
                                          DYNDNS_REG_PTR );

    printf( "DnsAsyncRegisterHostAddrs_A() returned: 0x%x\n", Status );

    ServerIp = inet_addr( "172.31.56.187" );

    HostAddrs[0].Addr.ipAddr = inet_addr( "2.2.2.3" );

    Status = DnsAsyncRegisterHostAddrs_A( "B",
                                          "glennc",
                                          HostAddrs,
                                          1,
                                          &ServerIp,
                                          1,
                                          "upd.com",
                                          NULL,
                                          60*5,
                                          DYNDNS_REG_PTR );

    printf( "DnsAsyncRegisterHostAddrs_A() returned: 0x%x\n", Status );

    ServerIp = inet_addr( "172.31.61.174" );

    HostAddrs[0].Addr.ipAddr = inet_addr( "3.3.3.3" );

    Status = DnsAsyncRegisterHostAddrs_A( "C",
                                          "glennc",
                                          HostAddrs,
                                          1,
                                          &ServerIp,
                                          1,
                                          "upd.com",
                                          NULL,
                                          60*5,
                                          DYNDNS_REG_PTR );

    printf( "DnsAsyncRegisterHostAddrs_A() returned: 0x%x\n", Status );
}


VOID
DoMATAddMulNTTEST( VOID )
{
    DNS_STATUS Status = NO_ERROR;
    REGISTER_HOST_ENTRY HostAddrs[2];
    IP_ADDRESS ServerIp;

    ServerIp = inet_addr( "157.55.83.254" );

    HostAddrs[0].dwOptions = REGISTER_HOST_A | REGISTER_HOST_PTR;
    HostAddrs[0].Addr.ipAddr = inet_addr( "1.1.1.1" );

    Status = DnsAsyncRegisterHostAddrs_A( "A",
                                          "glennc",
                                          HostAddrs,
                                          1,
                                          &ServerIp,
                                          1,
                                          "nttest.microsoft.com",
                                          NULL,
                                          60*5,
                                          DYNDNS_REG_PTR );

    printf( "DnsAsyncRegisterHostAddrs_A() returned: 0x%x\n", Status );

    ServerIp = inet_addr( "172.31.52.7" );

    HostAddrs[0].Addr.ipAddr = inet_addr( "2.2.2.2" );

    Status = DnsAsyncRegisterHostAddrs_A( "B",
                                          "glennc",
                                          HostAddrs,
                                          1,
                                          &ServerIp,
                                          1,
                                          "nttest.microsoft.com",
                                          NULL,
                                          60*5,
                                          DYNDNS_REG_PTR );

    printf( "DnsAsyncRegisterHostAddrs_A() returned: 0x%x\n", Status );

    ServerIp = inet_addr( "157.55.92.35" );

    HostAddrs[0].Addr.ipAddr = inet_addr( "3.3.3.3" );

    Status = DnsAsyncRegisterHostAddrs_A( "C",
                                          "glennc",
                                          HostAddrs,
                                          1,
                                          &ServerIp,
                                          1,
                                          "nttest.microsoft.com",
                                          NULL,
                                          60*5,
                                          DYNDNS_REG_PTR );

    printf( "DnsAsyncRegisterHostAddrs_A() returned: 0x%x\n", Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\test\dnsqry.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#define  SDK_DNS_RECORD 1
#include <dnsapi.h>
#include "..\..\dnslib\dnslib.h"



VOID
PrintRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintARecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintSOARecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintPTRRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintMINFORecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintMXRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintHINFORecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintNULLRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintWKSRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintAAAARecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintSRVRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintATMARecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintWINSRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintWINSRRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintDNSFlags (
    IN  DNSREC_FLAGS Flags );

VOID
PrintIpAddress (
    IN  DWORD dwIpAddress )
{
    printf( " %d.%d.%d.%d\n",
            ((BYTE *) &dwIpAddress)[0],
            ((BYTE *) &dwIpAddress)[1],
            ((BYTE *) &dwIpAddress)[2],
            ((BYTE *) &dwIpAddress)[3] );
}

_cdecl
main(int argc, char **argv)
{
    DWORD             Status = NO_ERROR;
    PDNS_RECORD       pDNSRecord = NULL;
    PDNS_RECORD       pTempDNSRecord = NULL;
    WCHAR             usName[1000];
    PDNS_ADDRESS_INFO pAddressInfo;
    DWORD             dwCount;
    WORD              wType;
    LONG              cch;
    BYTE              Part1, Part2, Part3, Part4;
    LPSTR             lpTemp = NULL, lpAddress = NULL;
    IP_ADDRESS        Address;
    BYTE              Buffer[1000];
    PIP_ARRAY         pipArray = NULL;
    DWORD             dwFlags = 0; // DNS_QUERY_BYPASS_CACHE;
    PDNS_MSG_BUF      pMsg = NULL;

    if ( argc > 4 ||
         argc < 3 )
    {
        printf( "\nUsage: dnsqry <DNS Name> <Type> [DNS Server IP]\n" );
        printf( "\nWhere:\n" );
        printf( "    DNS Name   - Server_X.dbsd-test.microsoft.com\n" );
        printf( "    Type       - 1 | A, 2 | ns, 12 | Ptr, 33 | SRV, ...\n" );
        printf( "    Server IP  - 157.55.80.152 \n" );
        return(-1);
    }

    cch = MultiByteToWideChar(
              CP_ACP,
              0L,  
              argv[1],  
              -1,         
              usName, 
              1000 
              );

    if (!cch) {
         Status = GetLastError();
        return (Status);
    }

    if ( Dns_NameCompare_A( "A", argv[2] ) )
        wType = DNS_TYPE_A;
    else if ( Dns_NameCompare_A( "NS", argv[2] ) )
        wType = DNS_TYPE_NS;
    else if ( Dns_NameCompare_A( "MD", argv[2] ) )
        wType = DNS_TYPE_MD;
    else if ( Dns_NameCompare_A( "MF", argv[2] ) )
        wType = DNS_TYPE_MF;
    else if ( Dns_NameCompare_A( "CNAME", argv[2] ) )
        wType = DNS_TYPE_CNAME;
    else if ( Dns_NameCompare_A( "SOA", argv[2] ) )
        wType = DNS_TYPE_SOA;
    else if ( Dns_NameCompare_A( "MB", argv[2] ) )
        wType = DNS_TYPE_MB;
    else if ( Dns_NameCompare_A( "MG", argv[2] ) )
        wType = DNS_TYPE_MG;
    else if ( Dns_NameCompare_A( "MR", argv[2] ) )
        wType = DNS_TYPE_MR;
    else if ( Dns_NameCompare_A( "NULL", argv[2] ) )
        wType = DNS_TYPE_NULL;
    else if ( Dns_NameCompare_A( "WKS", argv[2] ) )
        wType = DNS_TYPE_WKS;
    else if ( Dns_NameCompare_A( "PTR", argv[2] ) )
        wType = DNS_TYPE_PTR;
    else if ( Dns_NameCompare_A( "HINFO", argv[2] ) )
        wType = DNS_TYPE_HINFO;
    else if ( Dns_NameCompare_A( "MINFO", argv[2] ) )
        wType = DNS_TYPE_MINFO;
    else if ( Dns_NameCompare_A( "MX", argv[2] ) )
        wType = DNS_TYPE_MX;
    else if ( Dns_NameCompare_A( "TEXT", argv[2] ) )
        wType = DNS_TYPE_TEXT;
    else if ( Dns_NameCompare_A( "RP", argv[2] ) )
        wType = DNS_TYPE_RP;
    else if ( Dns_NameCompare_A( "AFSDB", argv[2] ) )
        wType = DNS_TYPE_AFSDB;
    else if ( Dns_NameCompare_A( "X25", argv[2] ) )
        wType = DNS_TYPE_X25;
    else if ( Dns_NameCompare_A( "ISDN", argv[2] ) )
        wType = DNS_TYPE_ISDN;
    else if ( Dns_NameCompare_A( "RT", argv[2] ) )
        wType = DNS_TYPE_RT;
    else if ( Dns_NameCompare_A( "NSAP", argv[2] ) )
        wType = DNS_TYPE_NSAP;
    else if ( Dns_NameCompare_A( "NSAPPTR", argv[2] ) )
        wType = DNS_TYPE_NSAPPTR;
    else if ( Dns_NameCompare_A( "SIG", argv[2] ) )
        wType = DNS_TYPE_SIG;
    else if ( Dns_NameCompare_A( "KEY", argv[2] ) )
        wType = DNS_TYPE_KEY;
    else if ( Dns_NameCompare_A( "PX", argv[2] ) )
        wType = DNS_TYPE_PX;
    else if ( Dns_NameCompare_A( "GPOS", argv[2] ) )
        wType = DNS_TYPE_GPOS;
    else if ( Dns_NameCompare_A( "AAAA", argv[2] ) )
        wType = DNS_TYPE_AAAA;
    else if ( Dns_NameCompare_A( "LOC", argv[2] ) )
        wType = DNS_TYPE_LOC;
    else if ( Dns_NameCompare_A( "NXT", argv[2] ) )
        wType = DNS_TYPE_NXT;
    else if ( Dns_NameCompare_A( "SRV", argv[2] ) )
        wType = DNS_TYPE_SRV;
    else if ( Dns_NameCompare_A( "ATMA", argv[2] ) )
        wType = DNS_TYPE_ATMA;
    else if ( Dns_NameCompare_A( "TKEY", argv[2] ) )
        wType = DNS_TYPE_TKEY;
    else if ( Dns_NameCompare_A( "TSIG", argv[2] ) )
        wType = DNS_TYPE_TSIG;
    else if ( Dns_NameCompare_A( "IXFR", argv[2] ) )
        wType = DNS_TYPE_IXFR;
    else if ( Dns_NameCompare_A( "AXFR", argv[2] ) )
        wType = DNS_TYPE_AXFR;
    else if ( Dns_NameCompare_A( "MAILB", argv[2] ) )
        wType = DNS_TYPE_MAILB;
    else if ( Dns_NameCompare_A( "MAILA", argv[2] ) )
        wType = DNS_TYPE_MAILA;
    else if ( Dns_NameCompare_A( "WINS", argv[2] ) )
        wType = DNS_TYPE_WINS;
    else if ( Dns_NameCompare_A( "ALL", argv[2] ) )
        wType = DNS_TYPE_ALL;
    else if ( Dns_NameCompare_A( "ANY", argv[2] ) )
        wType = DNS_TYPE_ANY;
    else
        wType = (WORD) atoi( argv[2] );

    if ( argc > 3 )
    {
        lpAddress = argv[3];

        lpTemp = strtok( lpAddress, "." );
        Part1 = (BYTE) atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part2 = (BYTE) atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part3 = (BYTE) atoi( lpTemp );
        lpTemp = strtok( NULL, "." );
        Part4 = (BYTE) atoi( lpTemp );

        ((BYTE *) &Address)[0] = Part1;
        ((BYTE *) &Address)[1] = Part2;
        ((BYTE *) &Address)[2] = Part3;
        ((BYTE *) &Address)[3] = Part4;

        pipArray = (PIP_ARRAY) Buffer;
        pipArray->cAddrCount = 1;
        pipArray->aipAddrs[0] = Address;

        dwFlags |= DNS_QUERY_BYPASS_CACHE;

        printf( "\nDnsQuery( %S, %d, %d.%d.%d.%d ) ...\n\n",
                usName,
                wType,
                Part1,
                Part2,
                Part3,
                Part4 );
    }
    else
        printf( "\nDnsQuery( %S, %d, ... ) ...\n\n",
                usName,
                wType );

    Status = DnsQuery_W( usName,
                         wType,
                         dwFlags,
                         pipArray,
                         &pDNSRecord,
                         NULL ); // &pMsg );

    if ( Status )
    {
        printf( "Dns_Query call failed with error: 0x%.8X\n", Status );
    }
    else
    {
//        WORD wMsgLen = pMsg->MessageLength;

        printf( "Query found record(s) ...\n\n" );

#if 0
        DnsFreeRRSet( pDNSRecord, TRUE );
        pDNSRecord = NULL;

        printf( "Extracting record(s) from message buffer ...\n\n" );

        Status = DnsExtractRecordsFromMessage_W( (PDNS_MESSAGE_BUFFER)
                                                    &pMsg->MessageHead,
                                                    wMsgLen,
                                                    &pDNSRecord );

        if ( Status )
        {
            printf( "DnsExtractRecordsFromMessage_UTF8 call failed with error: 0x%.8X\n", Status );

            pDNSRecord = NULL;
        }
#endif

        pTempDNSRecord = pDNSRecord;

        while ( pTempDNSRecord )
        {
            printf( "   Record:\n" );
            printf( "   -------------------------------------\n" );
            printf( "       Name        : %S\n", pTempDNSRecord->pName );
            printf( "       Type        : %d\n", pTempDNSRecord->wType );
            printf( "       Data Length : %d\n", pTempDNSRecord->wDataLength );
            printf( "       Ttl (mins)  : %d\n", pTempDNSRecord->dwTtl/60 );
            printf( "       Flags       : 0x%X", pTempDNSRecord->Flags.DW );
            PrintDNSFlags( pTempDNSRecord->Flags.S );
            printf( "\n" );

            PrintRecord( pTempDNSRecord );

            pTempDNSRecord = pTempDNSRecord->pNext;
        }

#if 0
        DnsCacheRecordSet_W( pDNSRecord->nameOwner,
                             pDNSRecord->wType,
                             0,
                             pDNSRecord );
#endif

        DnsFreeRRSet( pDNSRecord, TRUE );
    }

    return(0);
}


VOID
PrintRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    switch( pDnsRecord->wType )
    {
        case DNS_TYPE_A :
            PrintARecord( pDnsRecord );
            break;

        case DNS_TYPE_SOA :
            PrintSOARecord( pDnsRecord );
            break;

        case DNS_TYPE_PTR :
        case DNS_TYPE_NS :
        case DNS_TYPE_CNAME :
        case DNS_TYPE_MB :
        case DNS_TYPE_MD :
        case DNS_TYPE_MF :
        case DNS_TYPE_MG :
        case DNS_TYPE_MR :
            PrintPTRRecord( pDnsRecord );
            break;

        case DNS_TYPE_MINFO :
        case DNS_TYPE_RP :
            PrintMINFORecord( pDnsRecord );
            break;

        case DNS_TYPE_MX :
        case DNS_TYPE_AFSDB :
        case DNS_TYPE_RT :
            PrintMXRecord( pDnsRecord );
            break;

        case DNS_TYPE_HINFO :
        case DNS_TYPE_ISDN :
        case DNS_TYPE_TEXT :
        case DNS_TYPE_X25 :
            PrintHINFORecord( pDnsRecord );
            break;

        case DNS_TYPE_NULL :
            PrintNULLRecord( pDnsRecord );
            break;

        case DNS_TYPE_WKS :
            PrintWKSRecord( pDnsRecord );
            break;

        case DNS_TYPE_AAAA :
            PrintAAAARecord( pDnsRecord );
            break;

        case DNS_TYPE_SRV :
            PrintSRVRecord( pDnsRecord );
            break;

        case DNS_TYPE_ATMA :
            PrintATMARecord( pDnsRecord );
            break;

        case DNS_TYPE_WINS :
            PrintWINSRecord( pDnsRecord );
            break;

        case DNS_TYPE_NBSTAT :
            PrintWINSRRecord( pDnsRecord );
            break;

        default :
            printf( "Don't know how to print record type %d\n", pDnsRecord->wType );
    }
}


VOID
PrintARecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "       A record :\n" );
    printf( "                  ipAddress            = %d.%d.%d.%d\n",
            ((BYTE *) &pDnsRecord->Data.A.ipAddress)[0],
            ((BYTE *) &pDnsRecord->Data.A.ipAddress)[1],
            ((BYTE *) &pDnsRecord->Data.A.ipAddress)[2],
            ((BYTE *) &pDnsRecord->Data.A.ipAddress)[3] );
    printf( "\n" );
}


VOID
PrintSOARecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "       SOA record :\n" );
    printf( "                    pNamePrimaryServer = %S\n",
            pDnsRecord->Data.SOA.pNamePrimaryServer );
    printf( "                    pNameAdministrator = %S\n",
            pDnsRecord->Data.SOA.pNameAdministrator );
    printf( "                    dwSerialNo         = %d\n",
            pDnsRecord->Data.SOA.dwSerialNo );
    printf( "                    dwRefresh          = %d\n",
            pDnsRecord->Data.SOA.dwRefresh );
    printf( "                    dwRetry            = %d\n",
            pDnsRecord->Data.SOA.dwRetry );
    printf( "                    dwExpire           = %d\n",
            pDnsRecord->Data.SOA.dwExpire );
    printf( "                    dwDefaultTtl       = %d\n",
            pDnsRecord->Data.SOA.dwDefaultTtl );
    printf( "\n" );
}


VOID
PrintPTRRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "       PTR, NS, CNAME, MB, MD, MF, MG, MR record :\n" );
    printf( "                    pNameHost          = %S\n",
            pDnsRecord->Data.PTR.pNameHost );
    printf( "\n" );
}


VOID
PrintMINFORecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "       MINFO, RP record :\n" );
    printf( "                    pNameMailbox       = %S\n",
            pDnsRecord->Data.MINFO.pNameMailbox );
    printf( "                    pNameErrorsMailbox = %S\n",
            pDnsRecord->Data.MINFO.pNameErrorsMailbox );
    printf( "\n" );
}


VOID
PrintMXRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "       MX, AFSDB, RT record :\n" );
    printf( "                    pNameExchange      = %S\n",
            pDnsRecord->Data.MX.pNameExchange );
    printf( "                    wPreference        = %d\n",
            pDnsRecord->Data.MX.wPreference );
    printf( "                    Pad                = %d\n",
            pDnsRecord->Data.MX.Pad );
    printf( "\n" );
}


VOID
PrintHINFORecord (
    IN  PDNS_RECORD pDnsRecord )
{
    DWORD iter;

    printf( "       HINFO, ISDN, TEXT, X25 record :\n" );
    printf( "                    dwStringCount      = %d\n",
            pDnsRecord->Data.HINFO.dwStringCount );
    for ( iter = 0; iter < pDnsRecord->Data.HINFO.dwStringCount; iter ++ )
    {
        printf( "                    pStringArray[%d]  = %S\n",
                iter,
                pDnsRecord->Data.HINFO.pStringArray[iter] );
    }
    printf( "\n" );
}


VOID
PrintNULLRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "       NULL record :\n" );
    printf( "\n" );
}


VOID
PrintWKSRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "       WKS record :\n" );
    printf( "                    ipAddress          = %d.%d.%d.%d\n",
            ((BYTE *) &pDnsRecord->Data.WKS.ipAddress)[0],
            ((BYTE *) &pDnsRecord->Data.WKS.ipAddress)[1],
            ((BYTE *) &pDnsRecord->Data.WKS.ipAddress)[2],
            ((BYTE *) &pDnsRecord->Data.WKS.ipAddress)[3] );
    printf( "                    chProtocol         = %d\n",
            pDnsRecord->Data.WKS.chProtocol );
    printf( "                    bBitMask           = %s\n",
            pDnsRecord->Data.WKS.bBitMask );
    printf( "\n" );
}


VOID
PrintAAAARecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "       AAAA record :\n" );
    printf( "                    ipAddress          = %d.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d\n",
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[0],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[1],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[2],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[3],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[4],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[5],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[6],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[7],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[8],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[9],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[10],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[11],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[12],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[13],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[14],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[15] );
    printf( "\n" );
}


VOID
PrintSRVRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "       SRV record :\n" );
    printf( "                    pNameTarget        = %S\n",
            pDnsRecord->Data.SRV.pNameTarget );
    printf( "                    wPriority          = %d\n",
            pDnsRecord->Data.SRV.wPriority );
    printf( "                    wWeight            = %d\n",
            pDnsRecord->Data.SRV.wWeight );
    printf( "                    wPort              = %d\n",
            pDnsRecord->Data.SRV.wPort );
    printf( "                    Pad                = %d\n",
            pDnsRecord->Data.SRV.Pad );
    printf( "\n" );
}


VOID
PrintATMARecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "       ATMA record :\n" );
    printf( "                    Address Type       = %d\n",
            pDnsRecord->Data.ATMA.AddressType );

    if ( pDnsRecord->Data.ATMA.Address &&
         pDnsRecord->Data.ATMA.AddressType == DNS_ATM_TYPE_E164 )
    {
        printf( "                    Address            = %s\n",
                pDnsRecord->Data.ATMA.Address );
    }
    else
    {
        DWORD iter;

        printf( "                    Address            =\n\t" );
        for ( iter = 0; iter < pDnsRecord->wDataLength; iter++ )
        {
            printf( "%02x", (UCHAR) pDnsRecord->Data.ATMA.Address[iter] );
        }

        printf( "\n" );
    }

    printf( "\n" );
}


VOID
PrintWINSRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    DWORD iter;

    printf( "       WINS record :\n" );
    printf( "                    dwMappingFlag      = %d\n",
            pDnsRecord->Data.WINS.dwMappingFlag );
    printf( "                    dwLookupTimeout    = %d\n",
            pDnsRecord->Data.WINS.dwLookupTimeout );
    printf( "                    dwCacheTimeout     = %d\n",
            pDnsRecord->Data.WINS.dwCacheTimeout );
    printf( "                    cWinsServerCount   = %d\n",
            pDnsRecord->Data.WINS.cWinsServerCount );
    printf( "                    aipWinsServers     =" );

    for ( iter = 0; iter < pDnsRecord->Data.WINS.cWinsServerCount; iter++ )
    {
        PrintIpAddress( pDnsRecord->Data.WINS.aipWinsServers[iter] );
        printf( " " );
    }

    printf( "\n\n" );
}


VOID
PrintWINSRRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "       NBSTAT record :\n" );
    printf( "                    dwMappingFlag      = %d\n",
            pDnsRecord->Data.WINSR.dwMappingFlag );
    printf( "                    dwLookupTimeout    = %d\n",
            pDnsRecord->Data.WINSR.dwLookupTimeout );
    printf( "                    dwCacheTimeout     = %d\n",
            pDnsRecord->Data.WINSR.dwCacheTimeout );
    printf( "                    pNameResultDomain  = %S\n",
            pDnsRecord->Data.WINSR.pNameResultDomain );
    printf( "\n" );
}


VOID
PrintDNSFlags (
    IN  DNSREC_FLAGS Flags )
{
    if ( Flags.Section == DNSREC_ANSWER )
    {
        printf( " Answer" );
    }

    if ( Flags.Section == DNSREC_AUTHORITY )
    {
        printf( " Authority" );
    }

    if ( Flags.Section == DNSREC_ADDITIONAL )
    {
        printf( " Additional" );
    }

    printf( "\n" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\test\dnsmod.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dnsapi.h>

BOOL
PrepareRecords(
    IN  LPWSTR        lpDomainName,
    OUT PDNS_RECORD * ppCurrentRecord1,
    OUT PDNS_RECORD * ppCurrentRecord2,
    OUT PDNS_RECORD * ppCurrentRecord3,
    OUT PDNS_RECORD * ppNewRecord1,
    OUT PDNS_RECORD * ppNewRecord2,
    OUT PDNS_RECORD * ppNewRecord3,
    OUT PDNS_RECORD * ppNewRecord4 );

_cdecl
main(int argc, char **argv)
{
    WCHAR DomainName[] = L"glennc_test.ntdev.microsoft.com";
    DWORD Status = NO_ERROR;
    PDNS_RECORD pCurrentRecordSet = NULL;
    PDNS_RECORD pNewRecordSet = NULL;
    PDNS_RECORD pCurrentRecord1 = NULL;
    PDNS_RECORD pCurrentRecord2 = NULL;
    PDNS_RECORD pCurrentRecord3 = NULL;
    PDNS_RECORD pNewRecord1 = NULL;
    PDNS_RECORD pNewRecord2 = NULL;
    PDNS_RECORD pNewRecord3 = NULL;
    PDNS_RECORD pNewRecord4 = NULL;
    HANDLE      hContext = NULL;
    DWORD       dwFlags = 0;

    Status = DnsAcquireContextHandle( 0, NULL, &hContext );

    if ( Status )
    {
        printf( "DnsAcquireContextHandle call failed.\n" );
        return(-1);
    }

    if ( !PrepareRecords( DomainName,
                          &pCurrentRecord1,
                          &pCurrentRecord2,
                          &pCurrentRecord3,
                          &pNewRecord1,
                          &pNewRecord2,
                          &pNewRecord3,
                          &pNewRecord4 ) )
    {
        printf( "PrepareRecords call failed.\n" );
        return(-1);
    }

    //
    // Set up pCurrentRecordSet ( 1.1.1.1, 2.2.2.2, 3.3.3.3 )
    //
    pCurrentRecordSet = pCurrentRecord1;
    pCurrentRecord1->pNext = pCurrentRecord2;
    pCurrentRecord2->pNext = pCurrentRecord3;
    pCurrentRecord3->pNext = NULL;

    //
    // Test 1
    //
    // Current = 1, 2, 3
    // New =     1, 2, 3
    // Server =  1, 2, 3
    //

    //
    // Preset server to have ( 1.1.1.1, 2.2.2.2, 3.3.3.3 )
    //
    Status = DnsReplaceRecordSet( hContext, pCurrentRecordSet, dwFlags, NULL );

    if ( Status )
    {
        printf( "DnsReplaceRecordSet call failed with error: 0x%.8X\n",
                Status );
        return(-1);
    }

    system( "pause" );

    //
    // Set up pNewRecordSet ( 1.1.1.1, 2.2.2.2, 3.3.3.3 )
    //
    pNewRecordSet = pNewRecord1;
    pNewRecord1->pNext = pNewRecord2;
    pNewRecord2->pNext = pNewRecord3;
    pNewRecord3->pNext = NULL;

    printf( "DnsModifyRecordSet( Current = 1, 2, 3\n" );
    printf( "                New =     1, 2, 3\n" );
    printf( "                Server =  1, 2, 3\n" );
    printf( "                dwFlags ); ...\n" );

    Status = DnsModifyRecordSet( hContext,
                                 pCurrentRecordSet,
                                 pNewRecordSet,
                                 dwFlags,
                                 NULL );

    if ( Status )
    {
        printf( "DnsModifyRecordSet call failed with error: 0x%.8X\n",
                Status );
        return(-1);
    }

    printf( "DnsModifyRecordSet call succeeded!\n" );

    system( "pause" );


    //
    // Test 2
    //
    // Current = 1, 2, 3
    // New =     1, 2, 3, 4
    // Server =  1, 2, 3
    //

    //
    // Preset server to have ( 1.1.1.1, 2.2.2.2, 3.3.3.3 )
    //
    Status = DnsReplaceRecordSet( hContext, pCurrentRecordSet, dwFlags, NULL );

    if ( Status )
    {
        printf( "DnsReplaceRecordSet call failed with error: 0x%.8X\n",
                Status );
        return(-1);
    }

    system( "pause" );

    //
    // Set up pNewRecordSet ( 1.1.1.1, 2.2.2.2, 3.3.3.3, 4.4.4.4 )
    //
    pNewRecordSet = pNewRecord1;
    pNewRecord1->pNext = pNewRecord2;
    pNewRecord2->pNext = pNewRecord3;
    pNewRecord3->pNext = pNewRecord4;
    pNewRecord4->pNext = NULL;

    printf( "DnsModifyRecordSet( Current = 1, 2, 3\n" );
    printf( "                New =     1, 2, 3, 4\n" );
    printf( "                Server =  1, 2, 3\n" );
    printf( "                dwFlags ); ...\n" );

    Status = DnsModifyRecordSet( hContext,
                                 pCurrentRecordSet,
                                 pNewRecordSet,
                                 dwFlags,
                                 NULL );

    if ( Status )
    {
        printf( "DnsModifyRecordSet call failed with error: 0x%.8X\n",
                Status );
        return(-1);
    }

    printf( "DnsModifyRecordSet call succeeded!\n" );

    system( "pause" );


    //
    // Test 3
    //
    // Current = 1, 2, 3
    // New =     1, 2
    // Server =  1, 2, 3
    //

    //
    // Preset server to have ( 1.1.1.1, 2.2.2.2, 3.3.3.3 )
    //
    Status = DnsReplaceRecordSet( hContext, pCurrentRecordSet, dwFlags, NULL );

    if ( Status )
    {
        printf( "DnsReplaceRecordSet call failed with error: 0x%.8X\n",
                Status );
        return(-1);
    }

    system( "pause" );

    //
    // Set up pNewRecordSet ( 1.1.1.1, 2.2.2.2 )
    //
    pNewRecordSet = pNewRecord1;
    pNewRecord1->pNext = pNewRecord2;
    pNewRecord2->pNext = NULL;

    printf( "DnsModifyRecordSet( Current = 1, 2, 3\n" );
    printf( "                New =     1, 2\n" );
    printf( "                Server =  1, 2, 3\n" );
    printf( "                dwFlags ); ...\n" );

    Status = DnsModifyRecordSet( hContext,
                                 pCurrentRecordSet,
                                 pNewRecordSet,
                                 dwFlags,
                                 NULL );

    if ( Status )
    {
        printf( "DnsModifyRecordSet call failed with error: 0x%.8X\n",
                Status );
        return(-1);
    }

    printf( "DnsModifyRecordSet call succeeded!\n" );

    system( "pause" );


    //
    // Test 4
    //
    // Current = 1, 2, 3
    // New =     1, 2, 4
    // Server =  1, 2, 3
    //

    //
    // Preset server to have ( 1.1.1.1, 2.2.2.2, 3.3.3.3 )
    //
    Status = DnsReplaceRecordSet( hContext, pCurrentRecordSet, dwFlags, NULL );

    if ( Status )
    {
        printf( "DnsReplaceRecordSet call failed with error: 0x%.8X\n",
                Status );
        return(-1);
    }

    system( "pause" );

    //
    // Set up pNewRecordSet ( 1.1.1.1, 2.2.2.2, 4.4.4.4 )
    //
    pNewRecordSet = pNewRecord1;
    pNewRecord1->pNext = pNewRecord2;
    pNewRecord2->pNext = pNewRecord4;
    pNewRecord4->pNext = NULL;

    printf( "DnsModifyRecordSet( Current = 1, 2, 3\n" );
    printf( "                New =     1, 2, 4\n" );
    printf( "                Server =  1, 2, 3\n" );
    printf( "                dwFlags ); ...\n" );

    Status = DnsModifyRecordSet( hContext,
                                 pCurrentRecordSet,
                                 pNewRecordSet,
                                 dwFlags,
                                 NULL );

    if ( Status )
    {
        printf( "DnsModifyRecordSet call failed with error: 0x%.8X\n",
                Status );
        return(-1);
    }

    printf( "DnsModifyRecordSet call succeeded!\n" );

    system( "pause" );


    //
    // Test 5
    //
    // Current = 1, 2, 3
    // New =     1, 2, 3, 4
    // Server =  1, 2
    //

    //
    // Set up pCurrentRecordSet ( 1.1.1.1, 2.2.2.2 )
    //
    pCurrentRecordSet = pCurrentRecord1;
    pCurrentRecord1->pNext = pCurrentRecord2;
    pCurrentRecord2->pNext = NULL;

    //
    // Preset server to have ( 1.1.1.1, 2.2.2.2 )
    //
    Status = DnsReplaceRecordSet( hContext, pCurrentRecordSet, dwFlags, NULL );

    if ( Status )
    {
        printf( "DnsReplaceRecordSet call failed with error: 0x%.8X\n",
                Status );
        return(-1);
    }

    system( "pause" );

    //
    // Set up pCurrentRecordSet ( 1.1.1.1, 2.2.2.2, 3.3.3.3 )
    //
    pCurrentRecord2->pNext = pCurrentRecord3;
    pCurrentRecord3->pNext = NULL;

    //
    // Set up pNewRecordSet ( 1.1.1.1, 2.2.2.2, 3.3.3.3, 4.4.4.4 )
    //
    pNewRecordSet = pNewRecord1;
    pNewRecord1->pNext = pNewRecord2;
    pNewRecord2->pNext = pNewRecord3;
    pNewRecord3->pNext = pNewRecord4;
    pNewRecord4->pNext = NULL;

    printf( "DnsModifyRecordSet( Current = 1, 2, 3\n" );
    printf( "                New =     1, 2, 3, 4\n" );
    printf( "                Server =  1, 2\n" );
    printf( "                dwFlags ); ...\n" );

    Status = DnsModifyRecordSet( hContext,
                                 pCurrentRecordSet,
                                 pNewRecordSet,
                                 dwFlags,
                                 NULL );

    if ( Status )
    {
        printf( "DnsModifyRecordSet call failed with error: 0x%.8X\n",
                Status );
        return(-1);
    }

    printf( "DnsModifyRecordSet call succeeded!\n" );

    system( "pause" );


    //
    // Test 6
    //
    // Current = 1, 2, 3
    // New =     1, 2
    // Server =  1, 2
    //

    //
    // Set up pCurrentRecordSet ( 1.1.1.1, 2.2.2.2 )
    //
    pCurrentRecordSet = pCurrentRecord1;
    pCurrentRecord1->pNext = pCurrentRecord2;
    pCurrentRecord2->pNext = NULL;

    //
    // Preset server to have ( 1.1.1.1, 2.2.2.2 )
    //
    Status = DnsReplaceRecordSet( hContext, pCurrentRecordSet, dwFlags, NULL );

    if ( Status )
    {
        printf( "DnsReplaceRecordSet call failed with error: 0x%.8X\n",
                Status );
        return(-1);
    }

    system( "pause" );

    //
    // Set up pCurrentRecordSet ( 1.1.1.1, 2.2.2.2, 3.3.3.3 )
    //
    pCurrentRecord2->pNext = pCurrentRecord3;
    pCurrentRecord3->pNext = NULL;

    //
    // Set up pNewRecordSet ( 1.1.1.1, 2.2.2.2 )
    //
    pNewRecordSet = pNewRecord1;
    pNewRecord1->pNext = pNewRecord2;
    pNewRecord2->pNext = NULL;

    printf( "DnsModifyRecordSet( Current = 1, 2, 3\n" );
    printf( "                New =     1, 2\n" );
    printf( "                Server =  1, 2\n" );
    printf( "                dwFlags ); ...\n" );

    Status = DnsModifyRecordSet( hContext,
                                 pCurrentRecordSet,
                                 pNewRecordSet,
                                 dwFlags,
                                 NULL );

    if ( Status )
    {
        printf( "DnsModifyRecordSet call failed with error: 0x%.8X\n",
                Status );
        return(-1);
    }

    printf( "DnsModifyRecordSet call succeeded!\n" );

    system( "pause" );


    //
    // Test 7
    //
    // Current = 1, 2, 3
    // New =     1, 2, 4
    // Server =  1, 2
    //

    //
    // Set up pCurrentRecordSet ( 1.1.1.1, 2.2.2.2 )
    //
    pCurrentRecordSet = pCurrentRecord1;
    pCurrentRecord1->pNext = pCurrentRecord2;
    pCurrentRecord2->pNext = NULL;

    //
    // Preset server to have ( 1.1.1.1, 2.2.2.2 )
    //
    Status = DnsReplaceRecordSet( hContext, pCurrentRecordSet, dwFlags, NULL );

    if ( Status )
    {
        printf( "DnsReplaceRecordSet call failed with error: 0x%.8X\n",
                Status );
        return(-1);
    }

    system( "pause" );

    //
    // Set up pCurrentRecordSet ( 1.1.1.1, 2.2.2.2, 3.3.3.3 )
    //
    pCurrentRecord2->pNext = pCurrentRecord3;
    pCurrentRecord3->pNext = NULL;

    //
    // Set up pNewRecordSet ( 1.1.1.1, 2.2.2.2, 4.4.4.4 )
    //
    pNewRecordSet = pNewRecord1;
    pNewRecord1->pNext = pNewRecord2;
    pNewRecord2->pNext = pNewRecord4;
    pNewRecord4->pNext = NULL;

    printf( "DnsModifyRecordSet( Current = 1, 2, 3\n" );
    printf( "                New =     1, 2, 4\n" );
    printf( "                Server =  1, 2\n" );
    printf( "                dwFlags ); ...\n" );

    Status = DnsModifyRecordSet( hContext,
                                 pCurrentRecordSet,
                                 pNewRecordSet,
                                 dwFlags,
                                 NULL );

    if ( Status )
    {
        printf( "DnsModifyRecordSet call failed with error: 0x%.8X\n",
                Status );
        return(-1);
    }

    printf( "DnsModifyRecordSet call succeeded!\n" );

    system( "pause" );


    //
    // Test 8
    //
    // Current = 1, 2
    // New =     1, 2, 3
    // Server =  1, 2, 3
    //

    //
    // Set up pCurrentRecordSet ( 1.1.1.1, 2.2.2.2, 3.3.3.3 )
    //
    pCurrentRecordSet = pCurrentRecord1;
    pCurrentRecord1->pNext = pCurrentRecord2;
    pCurrentRecord2->pNext = pCurrentRecord3;
    pCurrentRecord3->pNext = NULL;

    //
    // Preset server to have ( 1.1.1.1, 2.2.2.2, 3.3.3.3 )
    //
    Status = DnsReplaceRecordSet( hContext, pCurrentRecordSet, dwFlags, NULL );

    if ( Status )
    {
        printf( "DnsReplaceRecordSet call failed with error: 0x%.8X\n",
                Status );
        return(-1);
    }

    system( "pause" );

    //
    // Set up pCurrentRecordSet ( 1.1.1.1, 2.2.2.2 )
    //
    pCurrentRecord2->pNext = NULL;

    //
    // Set up pNewRecordSet ( 1.1.1.1, 2.2.2.2, 3.3.3.3 )
    //
    pNewRecordSet = pNewRecord1;
    pNewRecord1->pNext = pNewRecord2;
    pNewRecord2->pNext = pNewRecord3;
    pNewRecord3->pNext = NULL;

    printf( "DnsModifyRecordSet( Current = 1, 2\n" );
    printf( "                New =     1, 2, 3\n" );
    printf( "                Server =  1, 2, 3\n" );
    printf( "                dwFlags ); ...\n" );

    Status = DnsModifyRecordSet( hContext,
                                 pCurrentRecordSet,
                                 pNewRecordSet,
                                 dwFlags,
                                 NULL );

    if ( Status )
    {
        printf( "DnsModifyRecordSet call failed with error: 0x%.8X\n",
                Status );
        return(-1);
    }

    printf( "DnsModifyRecordSet call succeeded!\n" );

    system( "pause" );

    //
    // Test 9
    //
    // Current = 1, 2
    // New =     1
    // Server =  1, 2, 3
    //

    //
    // Set up pCurrentRecordSet ( 1.1.1.1, 2.2.2.2, 3.3.3.3 )
    //
    pCurrentRecordSet = pCurrentRecord1;
    pCurrentRecord1->pNext = pCurrentRecord2;
    pCurrentRecord2->pNext = pCurrentRecord3;
    pCurrentRecord3->pNext = NULL;

    //
    // Preset server to have ( 1.1.1.1, 2.2.2.2, 3.3.3.3 )
    //
    Status = DnsReplaceRecordSet( hContext, pCurrentRecordSet, dwFlags, NULL );

    if ( Status )
    {
        printf( "DnsReplaceRecordSet call failed with error: 0x%.8X\n",
                Status );
        return(-1);
    }

    system( "pause" );

    //
    // Set up pCurrentRecordSet ( 1.1.1.1, 2.2.2.2 )
    //
    pCurrentRecord2->pNext = NULL;

    //
    // Set up pNewRecordSet ( 1.1.1.1 )
    //
    pNewRecordSet = pNewRecord1;
    pNewRecord1->pNext = NULL;

    printf( "DnsModifyRecordSet( Current = 1, 2\n" );
    printf( "                New =     1\n" );
    printf( "                Server =  1, 2, 3\n" );
    printf( "                dwFlags ); ...\n" );

    Status = DnsModifyRecordSet( hContext,
                                 pCurrentRecordSet,
                                 pNewRecordSet,
                                 dwFlags,
                                 NULL );

    if ( Status == DNS_ERROR_NOT_UNIQUE )
    {
        printf( "DnsModifyRecordSet call succeeded!\n" );
    }
    else
    {
        printf( "DnsModifyRecordSet call failed with error: 0x%.8X\n",
                Status );
        return(-1);
    }

    system( "pause" );


    //
    // Test 10
    //
    // Current = 1, 2
    // New =     1, 3
    // Server =  1, 2, 3
    //

    //
    // Set up pCurrentRecordSet ( 1.1.1.1, 2.2.2.2, 3.3.3.3 )
    //
    pCurrentRecordSet = pCurrentRecord1;
    pCurrentRecord1->pNext = pCurrentRecord2;
    pCurrentRecord2->pNext = pCurrentRecord3;
    pCurrentRecord3->pNext = NULL;

    //
    // Preset server to have ( 1.1.1.1, 2.2.2.2, 3.3.3.3 )
    //
    Status = DnsReplaceRecordSet( hContext, pCurrentRecordSet, dwFlags, NULL );

    if ( Status )
    {
        printf( "DnsReplaceRecordSet call failed with error: 0x%.8X\n",
                Status );
        return(-1);
    }

    system( "pause" );

    //
    // Set up pCurrentRecordSet ( 1.1.1.1, 2.2.2.2 )
    //
    pCurrentRecord2->pNext = NULL;

    //
    // Set up pNewRecordSet ( 1.1.1.1, 3.3.3.3 )
    //
    pNewRecordSet = pNewRecord1;
    pNewRecord1->pNext = pNewRecord2;
    pNewRecord2->pNext = pNewRecord3;
    pNewRecord3->pNext = NULL;

    printf( "DnsModifyRecordSet( Current = 1, 2\n" );
    printf( "                New =     1, 3\n" );
    printf( "                Server =  1, 2, 3\n" );
    printf( "                dwFlags ); ...\n" );

    Status = DnsModifyRecordSet( hContext,
                                 pCurrentRecordSet,
                                 pNewRecordSet,
                                 dwFlags,
                                 NULL );

    if ( Status )
    {
        printf( "DnsModifyRecordSet call failed with error: 0x%.8X\n",
                Status );
        return(-1);
    }

    printf( "DnsModifyRecordSet call succeeded!\n" );

    system( "pause" );

    DnsReleaseContextHandle( hContext );

    return(0);
}


BOOL
PrepareRecords(
    IN  LPWSTR        lpDomainName,
    OUT PDNS_RECORD * ppCurrentRecord1,
    OUT PDNS_RECORD * ppCurrentRecord2,
    OUT PDNS_RECORD * ppCurrentRecord3,
    OUT PDNS_RECORD * ppNewRecord1,
    OUT PDNS_RECORD * ppNewRecord2,
    OUT PDNS_RECORD * ppNewRecord3,
    OUT PDNS_RECORD * ppNewRecord4 )
{
    *ppCurrentRecord1 = (PDNS_RECORD) LocalAlloc( LPTR, sizeof( DNS_RECORD ) );

    if ( !*ppCurrentRecord1 )
    {
        return FALSE;
    }

    *ppCurrentRecord2 = (PDNS_RECORD) LocalAlloc( LPTR, sizeof( DNS_RECORD ) );

    if ( !*ppCurrentRecord2 )
    {
        return FALSE;
    }

    *ppCurrentRecord3 = (PDNS_RECORD) LocalAlloc( LPTR, sizeof( DNS_RECORD ) );

    if ( !*ppCurrentRecord3 )
    {
        return FALSE;
    }

    *ppNewRecord1 = (PDNS_RECORD) LocalAlloc( LPTR, sizeof( DNS_RECORD ) );

    if ( !*ppNewRecord1 )
    {
        return FALSE;
    }

    *ppNewRecord2 = (PDNS_RECORD) LocalAlloc( LPTR, sizeof( DNS_RECORD ) );

    if ( !*ppNewRecord2 )
    {
        return FALSE;
    }

    *ppNewRecord3 = (PDNS_RECORD) LocalAlloc( LPTR, sizeof( DNS_RECORD ) );

    if ( !*ppNewRecord3 )
    {
        return FALSE;
    }

    *ppNewRecord4 = (PDNS_RECORD) LocalAlloc( LPTR, sizeof( DNS_RECORD ) );

    if ( !*ppNewRecord4 )
    {
        return FALSE;
    }

    (*ppCurrentRecord1)->pNext = NULL;
    (*ppCurrentRecord1)->nameOwner = (DNS_NAME) lpDomainName;
    (*ppCurrentRecord1)->wType = DNS_TYPE_A;
    (*ppCurrentRecord1)->wDataLength = sizeof( DNS_A_DATA );
    // (*ppCurrentRecord1)->wReserved = 0;
    // (*ppCurrentRecord1)->Flags.W = 0;
    // (*ppCurrentRecord1)->dwTtl = 0;
    (*ppCurrentRecord1)->Data.A.ipAddress = (IP_ADDRESS) 0x01010101; // 1.1.1.1

    (*ppCurrentRecord2)->pNext = NULL;
    (*ppCurrentRecord2)->nameOwner = (DNS_NAME) lpDomainName;
    (*ppCurrentRecord2)->wType = DNS_TYPE_A;
    (*ppCurrentRecord2)->wDataLength = sizeof( DNS_A_DATA );
    // (*ppCurrentRecord2)->wReserved = 0;
    // (*ppCurrentRecord2)->Flags.W = 0;
    // (*ppCurrentRecord2)->dwTtl = 0;
    (*ppCurrentRecord2)->Data.A.ipAddress = (IP_ADDRESS) 0x02020202; // 2.2.2.2

    (*ppCurrentRecord3)->pNext = NULL;
    (*ppCurrentRecord3)->nameOwner = (DNS_NAME) lpDomainName;
    (*ppCurrentRecord3)->wType = DNS_TYPE_A;
    (*ppCurrentRecord3)->wDataLength = sizeof( DNS_A_DATA );
    // (*ppCurrentRecord3)->wReserved = 0;
    // (*ppCurrentRecord3)->Flags.W = 0;
    // (*ppCurrentRecord3)->dwTtl = 0;
    (*ppCurrentRecord3)->Data.A.ipAddress = (IP_ADDRESS) 0x03030303; // 3.3.3.3

    (*ppNewRecord1)->pNext = NULL;
    (*ppNewRecord1)->nameOwner = (DNS_NAME) lpDomainName;
    (*ppNewRecord1)->wType = DNS_TYPE_A;
    (*ppNewRecord1)->wDataLength = sizeof( DNS_A_DATA );
    // (*ppNewRecord1)->wReserved = 0;
    // (*ppNewRecord1)->Flags.W = 0;
    // (*ppNewRecord1)->dwTtl = 0;
    (*ppNewRecord1)->Data.A.ipAddress = (IP_ADDRESS) 0x01010101; // 1.1.1.1

    (*ppNewRecord2)->pNext = NULL;
    (*ppNewRecord2)->nameOwner = (DNS_NAME) lpDomainName;
    (*ppNewRecord2)->wType = DNS_TYPE_A;
    (*ppNewRecord2)->wDataLength = sizeof( DNS_A_DATA );
    // (*ppNewRecord2)->wReserved = 0;
    // (*ppNewRecord2)->Flags.W = 0;
    // (*ppNewRecord2)->dwTtl = 0;
    (*ppNewRecord2)->Data.A.ipAddress = (IP_ADDRESS) 0x02020202; // 2.2.2.2

    (*ppNewRecord3)->pNext = NULL;
    (*ppNewRecord3)->nameOwner = (DNS_NAME) lpDomainName;
    (*ppNewRecord3)->wType = DNS_TYPE_A;
    (*ppNewRecord3)->wDataLength = sizeof( DNS_A_DATA );
    // (*ppNewRecord3)->wReserved = 0;
    // (*ppNewRecord3)->Flags.W = 0;
    // (*ppNewRecord3)->dwTtl = 0;
    (*ppNewRecord3)->Data.A.ipAddress = (IP_ADDRESS) 0x03030303; // 3.3.3.3

    (*ppNewRecord4)->pNext = NULL;
    (*ppNewRecord4)->nameOwner = (DNS_NAME) lpDomainName;
    (*ppNewRecord4)->wType = DNS_TYPE_A;
    (*ppNewRecord4)->wDataLength = sizeof( DNS_A_DATA );
    // (*ppNewRecord4)->wReserved = 0;
    // (*ppNewRecord4)->Flags.W = 0;
    // (*ppNewRecord4)->dwTtl = 0;
    (*ppNewRecord4)->Data.A.ipAddress = (IP_ADDRESS) 0x04040404; // 4.4.4.4

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\test\dnsqrya.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dnsapi.h>
#include <ctype.h>
#include <string.h>



VOID
PrintRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintARecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintSOARecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintPTRRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintMINFORecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintMXRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintHINFORecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintNULLRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintWKSRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintAAAARecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintSRVRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintWINSRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintWINSRRecord (
    IN  PDNS_RECORD pDnsRecord );

#define MAX_NR_OF_DNS_SERVERS 3

_cdecl
main(int argc, char **argv)
{
    DWORD          Status = NO_ERROR;
    DWORD          dwOptions = DNS_QUERY_STANDARD;
    PDNS_RECORD    pDNSRecord = NULL;
    PDNS_RECORD    pTempDNSRecord = NULL;
    WORD           wType;
    LONG           cch;
    BOOL           bBadUsage = FALSE;
    UINT           uIdx;
    UINT           uPos;
    UINT           uIdx1;
    IP_ADDRESS     ipAddress[MAX_NR_OF_DNS_SERVERS];     
    PIP_ARRAY      pIpArray = NULL;

    if ( argc < 3 )
        bBadUsage = TRUE;
    else
    {
        wType = atoi( argv[2] );

        if (argc > 3)
        {
            if ( isalpha((int)argv[3][0]) )
            {
                uIdx = 4;
                uPos = 0;
                while ( !bBadUsage && uPos < strlen( argv[3] ) )
                {
                    switch (argv[3][uPos])
                    {
                        case 'b':
                        case 'B':    
                            dwOptions |= DNS_QUERY_BYPASS_CACHE;
                            break;
                        case 'a':
                        case 'A':
                            dwOptions |= DNS_QUERY_ACCEPT_PARTIAL_UDP;
                            break;
                        case 'u':
                        case 'U':
                            dwOptions |= DNS_QUERY_USE_TCP_ONLY;
                            break;
                        case 'n':
                        case 'N':
                            dwOptions |= DNS_QUERY_NO_RECURSION;
                            break;
                        case 's':
                        case 'S':
                            break;
                        default:
                            bBadUsage = TRUE;
                    }
                    uPos++;
                }
            }
            else
                uIdx = 3;

            uIdx1 = 0;

            while ( !bBadUsage &&
                    ( uIdx < (UINT) argc ) &&
                    ( uIdx1 < MAX_NR_OF_DNS_SERVERS ) )
            {
                ipAddress[uIdx1] = inet_addr(argv[uIdx++]);

                if ( INADDR_NONE != ipAddress[uIdx1] )
                    uIdx1++;
                else 
                    bBadUsage = TRUE;
            }

            if (!bBadUsage && 0 != uIdx1)
            {
                pIpArray = DnsCreateIpArray( uIdx1 );
                if ( ! pIpArray )
                {
                    printf("Error on DnsCreateIpArray\n");
                    return( ERROR_OUTOFMEMORY );
                }

                for ( uIdx = 0; uIdx < uIdx1 ; uIdx++ )
                    pIpArray->aipAddrs[uIdx] = ipAddress[uIdx];
            }
        }

    }


    if ( !bBadUsage )
    {
        printf( "\nDnsQuery_A( %s, %d, ... ) ...\n\n", argv[1], wType );

        Status = DnsQuery_A( argv[1],
                           wType,
                           dwOptions,
                           pIpArray,
                           &pDNSRecord,
                           NULL );

        if ( Status )
        {
            printf( "Dns_Query_A call failed with error: 0x%.8X\n", Status );
        }

        printf( "Query found record(s) ...\n\n" );

        pTempDNSRecord = pDNSRecord;

        while ( pTempDNSRecord )
        {
            printf( "   Record:\n" );
            printf( "   -------------------------------------\n" );
            printf( "       Name Owner  : %s\n", pTempDNSRecord->nameOwner );
            printf( "       Type        : %d\n", pTempDNSRecord->wType );
            printf( "       Data Length : %d\n", pTempDNSRecord->wDataLength );
            printf( "       Ttl (mins)  : %d\n", pTempDNSRecord->dwTtl/60 );
            printf( "       Flags       : 0x%X\n\n", pTempDNSRecord->Flags.W );

            PrintRecord( pTempDNSRecord );

            pTempDNSRecord = pTempDNSRecord->pNext;
        }

        DnsFreeRRSet( pDNSRecord, TRUE );
    }
    else        // bBadUsage
    {
        printf( "\nUsage: dnsqry <DNS Name> <Type> [<Options>] [<ServList>]\n" );
        printf( "\nWhere:\n" );
        printf( "    DNS Name   - Server_X.dbsd-test.microsoft.com\n" );
        printf( "    Type       - 1 (DNS_TYPE_A), 2 (DNS_TYPE_NS), 3 (DNS_TYPE_MD), ...\n" );
        printf( "    Options    - b (BYPASS_CACHE), a (ACCEPT_PARTIAL_UDP), u (USE_TCP_ONLY), n (NO_RECURSION)\n");
        printf( "                 Options can be combined.\n");
        printf( "    ServList   - Targeted DNS Servers IPs (e.g. 157.55.192.155 172.31.48.217)\n");
        return(-1);
    }

    return(0);
}


VOID
PrintRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    switch( pDnsRecord->wType )
    {
        case DNS_TYPE_A :
            PrintARecord( pDnsRecord );
            break;

        case DNS_TYPE_SOA :
            PrintSOARecord( pDnsRecord );
            break;

        case DNS_TYPE_PTR :
        case DNS_TYPE_NS :
        case DNS_TYPE_CNAME :
        case DNS_TYPE_MB :
        case DNS_TYPE_MD :
        case DNS_TYPE_MF :
        case DNS_TYPE_MG :
        case DNS_TYPE_MR :
            PrintPTRRecord( pDnsRecord );
            break;

        case DNS_TYPE_MINFO :
        case DNS_TYPE_RP :
            PrintMINFORecord( pDnsRecord );
            break;

        case DNS_TYPE_MX :
        case DNS_TYPE_AFSDB :
        case DNS_TYPE_RT :
            PrintMXRecord( pDnsRecord );
            break;

        case DNS_TYPE_HINFO :
        case DNS_TYPE_ISDN :
        case DNS_TYPE_TEXT :
        case DNS_TYPE_X25 :
            PrintHINFORecord( pDnsRecord );
            break;

        case DNS_TYPE_NULL :
            PrintNULLRecord( pDnsRecord );
            break;

        case DNS_TYPE_WKS :
            PrintWKSRecord( pDnsRecord );
            break;

        case DNS_TYPE_AAAA :
            PrintAAAARecord( pDnsRecord );
            break;

        case DNS_TYPE_SRV :
            PrintSRVRecord( pDnsRecord );
            break;

        case DNS_TYPE_WINS :
            PrintWINSRecord( pDnsRecord );
            break;

        case DNS_TYPE_NBSTAT :
            PrintWINSRRecord( pDnsRecord );
            break;

        default :
            printf( "Don't know how to print record type %d\n", pDnsRecord->wType );
    }
}


VOID
PrintARecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "       A record :\n" );
    printf( "                  ipAddress = %d.%d.%d.%d\n",
            ((BYTE *) &pDnsRecord->Data.A.ipAddress)[0],
            ((BYTE *) &pDnsRecord->Data.A.ipAddress)[1],
            ((BYTE *) &pDnsRecord->Data.A.ipAddress)[2],
            ((BYTE *) &pDnsRecord->Data.A.ipAddress)[3] );
    printf( "\n" );
}


VOID
PrintSOARecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "       SOA record :\n" );
    printf( "                    namePrimaryServer = %s\n",
            pDnsRecord->Data.SOA.namePrimaryServer );
    printf( "                    nameAdministrator = %s\n",
            pDnsRecord->Data.SOA.nameAdministrator );
    printf( "                    dwSerialNo        = %d\n",
            pDnsRecord->Data.SOA.dwSerialNo );
    printf( "                    dwRefresh         = %d\n",
            pDnsRecord->Data.SOA.dwRefresh );
    printf( "                    dwRetry           = %d\n",
            pDnsRecord->Data.SOA.dwRetry );
    printf( "                    dwExpire          = %d\n",
            pDnsRecord->Data.SOA.dwExpire );
    printf( "                    dwDefaultTtl      = %d\n",
            pDnsRecord->Data.SOA.dwDefaultTtl );
    printf( "\n" );
}


VOID
PrintPTRRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "       PTR, NS, CNAME, MB, MD, MF, MG, MR record :\n" );
    printf( "                    nameHost          = %s\n",
            pDnsRecord->Data.PTR.nameHost );
    printf( "\n" );
}


VOID
PrintMINFORecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "       MINFO, RP record :\n" );
    printf( "                    nameMailbox       = %s\n",
            pDnsRecord->Data.MINFO.nameMailbox );
    printf( "                    nameErrorsMailbox = %s\n",
            pDnsRecord->Data.MINFO.nameErrorsMailbox );
    printf( "\n" );
}


VOID
PrintMXRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "       MX, AFSDB, RT record :\n" );
    printf( "                    nameExchange      = %s\n",
            pDnsRecord->Data.MX.nameExchange );
    printf( "                    wPreference       = %d\n",
            pDnsRecord->Data.MX.wPreference );
    printf( "                    Pad               = %d\n",
            pDnsRecord->Data.MX.Pad );
    printf( "\n" );
}


VOID
PrintHINFORecord (
    IN  PDNS_RECORD pDnsRecord )
{
    DWORD iter;

    printf( "       HINFO, ISDN, TEXT, X25 record :\n" );
    printf( "                    dwStringCount     = %d\n",
            pDnsRecord->Data.HINFO.dwStringCount );
    for ( iter = 0; iter < pDnsRecord->Data.HINFO.dwStringCount; iter ++ )
    {
        printf( "                    pStringArray[%d] = %s\n",
                iter,
                pDnsRecord->Data.HINFO.pStringArray[iter] );
    }
    printf( "\n" );
}


VOID
PrintNULLRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "       NULL record :\n" );
    printf( "                    dwByteCount       = %d\n",
            pDnsRecord->Data.Null.dwByteCount );
    printf( "\n" );
}


VOID
PrintWKSRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "       WKS record :\n" );
    printf( "                    ipAddress = %d.%d.%d.%d\n",
            ((BYTE *) &pDnsRecord->Data.WKS.ipAddress)[0],
            ((BYTE *) &pDnsRecord->Data.WKS.ipAddress)[1],
            ((BYTE *) &pDnsRecord->Data.WKS.ipAddress)[2],
            ((BYTE *) &pDnsRecord->Data.WKS.ipAddress)[3] );
    printf( "                    chProtocol        = %d\n",
            pDnsRecord->Data.WKS.chProtocol );
    printf( "\n" );
}


VOID
PrintAAAARecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "       AAAA record :\n" );
    printf( "                    ipAddress = %d.%d.%d.%d\n",
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[0],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[1],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[2],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[3] );
    printf( "\n" );
}


VOID
PrintSRVRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "       SRV record :\n" );
    printf( "                    nameTarget        = %s\n",
            pDnsRecord->Data.SRV.nameTarget );
    printf( "                    wPriority         = %d\n",
            pDnsRecord->Data.SRV.wPriority );
    printf( "                    wWeight           = %d\n",
            pDnsRecord->Data.SRV.wWeight );
    printf( "                    wPort             = %d\n",
            pDnsRecord->Data.SRV.wPort );
    printf( "                    Pad               = %d\n",
            pDnsRecord->Data.SRV.Pad );
    printf( "\n" );
}


VOID
PrintWINSRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "       WINS record :\n" );
    printf( "                    dwMappingFlag     = %d\n",
            pDnsRecord->Data.WINS.dwMappingFlag );
    printf( "                    dwLookupTimeout   = %d\n",
            pDnsRecord->Data.WINS.dwLookupTimeout );
    printf( "                    dwCacheTimeout    = %d\n",
            pDnsRecord->Data.WINS.dwCacheTimeout );
    printf( "                    cWinsServerCount  = %d\n",
            pDnsRecord->Data.WINS.cWinsServerCount );
    printf( "\n" );
}


VOID
PrintWINSRRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "       NBSTAT record :\n" );
    printf( "                    dwMappingFlag     = %d\n",
            pDnsRecord->Data.WINSR.dwMappingFlag );
    printf( "                    dwLookupTimeout   = %d\n",
            pDnsRecord->Data.WINSR.dwLookupTimeout );
    printf( "                    dwCacheTimeout    = %d\n",
            pDnsRecord->Data.WINSR.dwCacheTimeout );
    printf( "                    nameResultDomain  = %s\n",
            pDnsRecord->Data.WINSR.nameResultDomain );
    printf( "\n" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\test\dnsrep.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dnsapi.h>


_cdecl
main(int argc, char **argv)
{
    DWORD          Status = NO_ERROR;
    PDNS_RECORD    pDNSRecord = NULL;
    WCHAR          usName[MAX_PATH];
    LPSTR          lpTemp = NULL, lpAddress = NULL;
    BYTE           Part1, Part2, Part3, Part4;
    LONG           cch;

    if ( argc != 3 )
    {
        printf( "\nUsage: dnsrep <DNS Name> <IP Address>\n" );
        printf( "\nWhere:\n" );
        printf( "    DNS Name   - Server_X.dbsd-test.microsoft.com\n" );
        printf( "    IP Address - 121.55.54.121\n" );
        printf( "           - or -\n" );
        printf( "    IP Address - 0.0.0.0 to nuke entry\n" );
        return(-1);
    }

    cch = MultiByteToWideChar(
              CP_ACP,
              0L,  
              argv[1],  
              -1,         
              usName, 
              MAX_PATH 
              );

    if (!cch) {
        return (GetLastError());
    }

    lpAddress = argv[2];

    lpTemp = strtok( lpAddress, "." );
    Part1 = (BYTE) atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    Part2 = (BYTE) atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    Part3 = (BYTE) atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    Part4 = (BYTE) atoi( lpTemp );

    printf( "\nReplacing all DNS records with:\n" );
    printf( "Name:    %S\n", usName );
    printf( "Address: %d.%d.%d.%d\n", Part1, Part2, Part3, Part4 );

    pDNSRecord = (PDNS_RECORD) LocalAlloc( LPTR, sizeof( DNS_RECORD ) );

    if ( !pDNSRecord )
    {
        
        printf( "LocalAlloc( sizeof( DNS_RECORD ) ) call failed.\n" );
        return(-1);
    }

    //
    // Prepare a DNS RRSet with a new A record to replace with ...
    //
    pDNSRecord->pNext = NULL;
    pDNSRecord->nameOwner = (DNS_NAME) usName;
    pDNSRecord->wType = DNS_TYPE_A;
    if ( Part1 || Part2 || Part3 || Part4 )
    {
        pDNSRecord->wDataLength = sizeof( DNS_A_DATA );
        // pDNSRecord->wReserved = 0;
        // pDNSRecord->Flags.W = 0;
        pDNSRecord->dwTtl = 240;
        ((BYTE *) &pDNSRecord->Data.A.ipAddress)[0] = Part1;
        ((BYTE *) &pDNSRecord->Data.A.ipAddress)[1] = Part2;
        ((BYTE *) &pDNSRecord->Data.A.ipAddress)[2] = Part3;
        ((BYTE *) &pDNSRecord->Data.A.ipAddress)[3] = Part4;
    }
    else
    {
        pDNSRecord->wDataLength = 0;
    }

    printf( "DnsReplaceRRSet( pDNSRecord ) ...\n" );

    Status = DnsReplaceRRSet( pDNSRecord, NULL );

    LocalFree( pDNSRecord );
    

    if ( Status )
    {
        printf( "DnsReplaceRRSet call failed with error: 0x%.8X\n",
                Status );
        return(-1);
    }

    printf( "DnsReplaceRRSet call succeeded!\n" );

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\test\dnsreg.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dnsapi.h>

VOID
PrintIpAddress (
    IN  DWORD dwIpAddress )
{
    printf( "   %d.%d.%d.%d\n",
            ((BYTE *) &dwIpAddress)[0],
            ((BYTE *) &dwIpAddress)[1],
            ((BYTE *) &dwIpAddress)[2],
            ((BYTE *) &dwIpAddress)[3] );
}

_cdecl
main(int argc, char **argv)
{
    DWORD          Status = NO_ERROR;
    PDNS_RECORD    pDNSRecord = NULL;
    WCHAR          usName[MAX_PATH];
    LONG           cch;
    LPSTR          lpTemp = NULL, lpAddress = NULL;
    BYTE           Part1, Part2, Part3, Part4;
    IP_ADDRESS     ip;

    if ( argc != 3 )
    {
        printf( "\nUsage: dnsreg <DNS Name> <IP Address>\n" );
        printf( "\nWhere:\n" );
        printf( "    DNS Name   - Server_X.dbsd-test.microsoft.com\n" );
        printf( "    IP Address - 121.55.54.121\n" );
        return(-1);
    }

    cch = MultiByteToWideChar(
              CP_ACP,
              0L,  
              argv[1],  
              -1,         
              usName, 
              MAX_PATH 
              );

    if (!cch)
    {
        return (GetLastError());
    }

    lpAddress = argv[2];

    lpTemp = strtok( lpAddress, "." );
    Part1 = (BYTE) atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    Part2 = (BYTE) atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    Part3 = (BYTE) atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    Part4 = (BYTE) atoi( lpTemp );

    printf( "\nRegistering DNS record with:\n" );
    printf( "Name:    %S\n", usName );
    printf( "Address: %d.%d.%d.%d\n", Part1, Part2, Part3, Part4 );

    pDNSRecord = (PDNS_RECORD) LocalAlloc( LPTR, sizeof( DNS_RECORD ) );

    if ( !pDNSRecord )
    {
        printf( "LocalAlloc( sizeof( DNS_RECORD ) ) call failed.\n" );
        return(-1);
    }

    //
    // Prepare a DNS RRSet with a new A record to add ...
    //
    pDNSRecord->pNext = NULL;
    pDNSRecord->nameOwner = (DNS_NAME) usName;
    pDNSRecord->wType = DNS_TYPE_A;
    pDNSRecord->wDataLength = sizeof( DNS_A_DATA );
    // pDNSRecord->wReserved = 0;
    // pDNSRecord->Flags.W = 0;
    pDNSRecord->dwTtl = 240;
    ((BYTE *) &pDNSRecord->Data.A.ipAddress)[0] = Part1;
    ((BYTE *) &pDNSRecord->Data.A.ipAddress)[1] = Part2;
    ((BYTE *) &pDNSRecord->Data.A.ipAddress)[2] = Part3;
    ((BYTE *) &pDNSRecord->Data.A.ipAddress)[3] = Part4;

    printf( "DnsRegisterRRSet( pDNSRecord, DNS_UPDATE_SHARED ) ...\n",
            usName );

    Status = DnsRegisterRRSet( pDNSRecord, DNS_UPDATE_SHARED, NULL );

    LocalFree( pDNSRecord );
    if ( Status )
    {
        printf( "DnsRegisterRRSet call failed with error: 0x%.8X\n",
                Status );

        return(-1);
    }

    printf( "DnsRegisterRRSet call succeeded!\n" );

    ip = DnsGetLastServerUpdateIP();

    printf( "Dns update was sent to server :" );
    PrintIpAddress( ip );

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\test\dnsrem.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dnsapi.h>


_cdecl
main(int argc, char **argv)
{
    DWORD          Status = NO_ERROR;
    PDNS_RECORD    pDNSRecord = NULL;
    WCHAR          usName[MAX_PATH];
    LPSTR          lpTemp = NULL, lpAddress = NULL;
    BYTE           Part1, Part2, Part3, Part4;
    LONG     cch;

    if ( argc != 3 )
    {
        printf( "\nUsage: dnsrem <DNS Name> <IP Address>\n" );
        printf( "\nWhere:\n" );
        printf( "    DNS Name   - Server_X.dbsd-test.microsoft.com\n" );
        printf( "    IP Address - 121.55.54.121\n" );
        return(-1);
    }

    cch = MultiByteToWideChar(
              CP_ACP,
              0L,  
              argv[1],  
              -1,         
              usName, 
              MAX_PATH 
              );

    if (!cch) {
         Status = GetLastError();
        return (Status);
    }

    lpAddress = argv[2];

    lpTemp = strtok( lpAddress, "." );
    Part1 = (BYTE) atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    Part2 = (BYTE) atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    Part3 = (BYTE) atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    Part4 = (BYTE) atoi( lpTemp );

    printf( "\nRemoving DNS record with:\n" );
    printf( "Name:    %S\n", usName );
    printf( "Address: %d.%d.%d.%d\n", Part1, Part2, Part3, Part4 );

    pDNSRecord = (PDNS_RECORD) LocalAlloc( LPTR, sizeof( DNS_RECORD ) );

    if ( !pDNSRecord )
    {
        
        printf( "LocalAlloc( sizeof( DNS_RECORD ) ) call failed.\n" );
        return(-1);
    }

    //
    // Prepare a DNS RRSet with a new A record to remove ...
    //
    pDNSRecord->pNext = NULL;
    pDNSRecord->nameOwner = (DNS_NAME) usName;
    pDNSRecord->wType = DNS_TYPE_A;
    pDNSRecord->wDataLength = sizeof( DNS_A_DATA );
    // pDNSRecord->wReserved = 0;
    // pDNSRecord->Flags.W = 0;
    // pDNSRecord->dwTtl = 0;
    ((BYTE *) &pDNSRecord->Data.A.ipAddress)[0] = Part1;
    ((BYTE *) &pDNSRecord->Data.A.ipAddress)[1] = Part2;
    ((BYTE *) &pDNSRecord->Data.A.ipAddress)[2] = Part3;
    ((BYTE *) &pDNSRecord->Data.A.ipAddress)[3] = Part4;

    printf( "DnsRemoveRRSet( pDNSRecord ) ...\n" );

    Status = DnsRemoveRRSet( pDNSRecord, NULL );

    LocalFree( pDNSRecord );
    

    if ( Status )
    {
        printf( "DnsRemoveRRSet call failed with error: 0x%.8X\n",
                Status );
        return(-1);
    }

    printf( "DnsRemoveRRSet call succeeded!\n" );

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\test\dnstest.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dnsapi.h>


_cdecl
main(int argc, char **argv)
{
    DWORD          Status = NO_ERROR;
    WCHAR          usName[MAX_PATH];
    LPSTR          lpTemp = NULL, lpAddress = NULL;
    BYTE           Part1, Part2, Part3, Part4;
    IP_ADDRESS     Address;
    LONG           cch;
    IP_ARRAY       ipArray;

#if 0
    if ( argc != 3 )
    {
        printf( "\nUsage: dnstest <DNS Name> <Server IP>\n" );
        printf( "\nWhere:\n" );
        printf( "    DNS Name   - Server_X.dbsd-test.microsoft.com\n" );
        return(-1);
    }

    lpAddress = argv[2];

    lpTemp = strtok( lpAddress, "." );
    Part1 = (BYTE) atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    Part2 = (BYTE) atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    Part3 = (BYTE) atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    Part4 = (BYTE) atoi( lpTemp );

    ((BYTE *) &Address)[0] = Part1;
    ((BYTE *) &Address)[1] = Part2;
    ((BYTE *) &Address)[2] = Part3;
    ((BYTE *) &Address)[3] = Part4;

    ipArray.cAddrCount = 1;
    ipArray.aipAddrs[0] = Address;
#endif

    cch = MultiByteToWideChar(
              CP_ACP,
              0L,  
              argv[1],  
              -1,         
              usName, 
              MAX_PATH 
              );

    if (!cch) {
        return (GetLastError());
    }

    printf( "\nTesting dynamic update for name: %S", usName );

    Status = DnsUpdateTest_W( NULL,
                              usName,
                              0, // DNS_UPDATE_TEST_USE_LOCAL_SYS_ACCT,
                              NULL ); // &ipArray );

    if ( Status )
    {
        printf( "DnsUpdateTest call returned with status: 0x%.8X\n",
                Status );
        return(-1);
    }

    printf( "DnsReplaceRRSet call succeeded!\n" );

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\test\flushdns.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dnsapi.h>

VOID
PrintIpAddress (
    IN  DWORD dwIpAddress );

_cdecl
main(int argc, char **argv)
{
    DnsFlushResolverCache();

    return(0);
}

VOID
PrintIpAddress (
    IN  DWORD dwIpAddress )
{
    printf( "   %d.%d.%d.%d\n",
            ((BYTE *) &dwIpAddress)[0],
            ((BYTE *) &dwIpAddress)[1],
            ((BYTE *) &dwIpAddress)[2],
            ((BYTE *) &dwIpAddress)[3] );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\test\getdomain.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dnsapi.h>

_cdecl
main(int argc, char **argv)
{
    LPWSTR pszDomain = NULL;

    pszDomain = DnsGetPrimaryDomainName();

    if ( pszDomain )
    {
        printf( "\n  Primary domain name (UNICODE): %S\n", pszDomain );

        LocalFree( pszDomain );
    }
    else
    {
        printf( "\n  No domain name found.\n" );
    }

    pszDomain = (LPWSTR) DnsGetPrimaryDomainName_A();

    if ( pszDomain )
    {
        printf( "\n  Primary domain name (ANSI): %s\n", (LPSTR) pszDomain );

        LocalFree( pszDomain );
    }
    else
    {
        printf( "\n  No domain name found.\n" );
    }

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\test\gethost.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dnsapi.h>

_cdecl
main(int argc, char **argv)
{
    LPWSTR pszHostName = NULL;

    pszHostName = DnsGetHostName();

    if ( pszHostName )
    {
        printf( "\n  Host name (UNICODE): %S\n", pszHostName );

        LocalFree( pszHostName );
    }
    else
    {
        printf( "\n  No host name found.\n" );
    }

    pszHostName = (LPWSTR) DnsGetHostName_A();

    if ( pszHostName )
    {
        printf( "\n  Host name (ANSI): %s\n", (LPSTR) pszHostName );

        LocalFree( pszHostName );
    }
    else
    {
        printf( "\n  No host name found.\n" );
    }

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\test\ghba.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <wsipx.h>
#include <svcguid.h>
#include <nspapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <rpc.h>
#include <rpcdce.h>


_cdecl
main(int argc, char **argv)
{
    WSADATA          wsaData;
    struct hostent * lpHostEnt;
    BYTE             AddrBuffer[1000];
    BYTE             AliasBuffer[1000];
    DWORD            AddrBufLen = 1000;
    DWORD            AliasBufLen = 1000;
    LPCSADDR_INFO    lpCSAddrInfo = (LPCSADDR_INFO) AddrBuffer;
    LPSTR            lpAliases = (LPSTR) AliasBuffer;
    GUID             dnsGuid = SVCID_DOMAIN_TCP;
    char **          ppHostAliases;
    LPSTR            lpTemp = NULL, lpAddress = NULL;
    BYTE             Part1, Part2, Part3, Part4;
    DWORD            Address;

    if ( argc != 2 )
    {
        printf( "\nUseage: ghbn <Address>\n" );
        return( -1 );
    }

    lpAddress = argv[1];

    lpTemp = strtok( lpAddress, "." );
    Part1 = atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    Part2 = atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    Part3 = atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    Part4 = atoi( lpTemp );

    ((LPBYTE) &Address)[0] = Part1;
    ((LPBYTE) &Address)[1] = Part2;
    ((LPBYTE) &Address)[2] = Part3;
    ((LPBYTE) &Address)[3] = Part4;

    WSAStartup( MAKEWORD(1, 1), &wsaData );

    lpHostEnt = gethostbyaddr( &Address, 4, 0 );

    if ( lpHostEnt )
    {
        DWORD iter = 0;

        printf( "\nHost address found for IP address %d.%d.%d.%d.\n",
                Part1, Part2, Part3, Part4 );
        printf( "Official name of host: %s\n", lpHostEnt->h_name );
        ppHostAliases = lpHostEnt->h_aliases;

        while ( *ppHostAliases )
            printf( "Alias name: %s\n", *ppHostAliases++ );

        printf( "Host address type: %d\n", lpHostEnt->h_addrtype );
        printf( "Length of addresses: %d\n", lpHostEnt->h_length );
        while ( lpHostEnt->h_addr_list[iter] )
        {
            printf( "Address %d\t: [%d.%d.%d.%d]\n",
                    iter + 1,
                    0x00FF & (WORD) lpHostEnt->h_addr_list[iter][0],
                    0x00FF & (WORD) lpHostEnt->h_addr_list[iter][1],
                    0x00FF & (WORD) lpHostEnt->h_addr_list[iter][2],
                    0x00FF & (WORD) lpHostEnt->h_addr_list[iter][3] );
            iter++;
        }
    }
    else
    {
        printf( "\nNo host found for IP address %d.%d.%d.%d.\nError: %d",
        Part1, Part2, Part3, Part4, WSAGetLastError() );
    }

    WSACleanup();

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\test\ghbnleak.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <wsipx.h>
#include <svcguid.h>
#include <nspapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <rpc.h>
#include <rpcdce.h>


_cdecl
main(int argc, char **argv)
{
    WSADATA          wsaData;
    struct hostent * lpHostEnt;
    char *           lpTemp;
    BYTE             AddrBuffer[1000];
    BYTE             AliasBuffer[1000];
    DWORD            AddrBufLen = 1000;
    DWORD            AliasBufLen = 1000;
    LPCSADDR_INFO    lpCSAddrInfo = (LPCSADDR_INFO) AddrBuffer;
    LPSTR            lpAliases = (LPSTR) AliasBuffer;
    GUID             dnsGuid = SVCID_DOMAIN_TCP;
    char **          ppHostAliases;
    DWORD            iter;

    if ( argc != 2 )
    {
        printf( "\nUseage: ghbn <Name>\n" );
        return( -1 );
    }

    WSAStartup( MAKEWORD(1, 1), &wsaData );

    system( "pause" );

    for ( iter = 0; iter < 10000; iter ++ )
    {
        lpHostEnt = gethostbyname( argv[1] );
    }

    system( "pause" );

    if ( lpHostEnt )
    {
        DWORD iter = 0;

        printf( "\nHost address found for %s.\n", argv[1] );
        printf( "Official name of host: %s\n", lpHostEnt->h_name );
        ppHostAliases = lpHostEnt->h_aliases;

        while ( *ppHostAliases )
            printf( "Alias name: %s\n", *ppHostAliases++ );

        printf( "Host address type: %d\n", lpHostEnt->h_addrtype );
        printf( "Length of addresses: %d\n", lpHostEnt->h_length );
        while ( lpHostEnt->h_addr_list[iter] )
        {
            printf( "Address %d\t: [%d.%d.%d.%d]\n",
                    iter + 1,
                    0x00FF & (WORD) lpHostEnt->h_addr_list[iter][0],
                    0x00FF & (WORD) lpHostEnt->h_addr_list[iter][1],
                    0x00FF & (WORD) lpHostEnt->h_addr_list[iter][2],
                    0x00FF & (WORD) lpHostEnt->h_addr_list[iter][3] );
            iter++;
        }
    }
    else
    {
        printf( "\nNo host found for %s.\nError: %d", argv[1], WSAGetLastError() );
    }

    WSACleanup();

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\test\ghbn.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <wsipx.h>
#include <svcguid.h>
#include <nspapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <rpc.h>
#include <rpcdce.h>


_cdecl
main(int argc, char **argv)
{
    WSADATA          wsaData;
    struct hostent * lpHostEnt;
    char *           lpTemp;
    BYTE             AddrBuffer[1000];
    BYTE             AliasBuffer[1000];
    DWORD            AddrBufLen = 1000;
    DWORD            AliasBufLen = 1000;
    LPCSADDR_INFO    lpCSAddrInfo = (LPCSADDR_INFO) AddrBuffer;
    LPSTR            lpAliases = (LPSTR) AliasBuffer;
    GUID             dnsGuid = SVCID_DOMAIN_TCP;
    char **          ppHostAliases;
    BOOL             fLoop = FALSE;

    if ( !( argc == 2 | argc == 3 ) )
    {
        printf( "\nUseage: ghbn <Name> [-l]\n" );
        return( -1 );
    }

    if ( argc == 3 )
    {
        if ( !_stricmp( argv[2], "-l" ) )
            fLoop = TRUE;
        else
        {
            printf( "\nUseage: ghbn <Name> [-l]\n" );
            return( -1 );
        }
    }

Repeat :

    WSAStartup( MAKEWORD(1, 1), &wsaData );

    if ( fLoop )
        system( "pause" );

    lpHostEnt = gethostbyname( argv[1] );

    if ( lpHostEnt )
    {
        DWORD iter = 0;

        printf( "\nHost address found for %s.\n", argv[1] );
        printf( "Official name of host: %s\n", lpHostEnt->h_name );
        ppHostAliases = lpHostEnt->h_aliases;

        while ( *ppHostAliases )
            printf( "Alias name: %s\n", *ppHostAliases++ );

        printf( "Host address type: %d\n", lpHostEnt->h_addrtype );
        printf( "Length of addresses: %d\n", lpHostEnt->h_length );
        while ( lpHostEnt->h_addr_list[iter] )
        {
            printf( "Address %d\t: [%d.%d.%d.%d]\n",
                    iter + 1,
                    0x00FF & (WORD) lpHostEnt->h_addr_list[iter][0],
                    0x00FF & (WORD) lpHostEnt->h_addr_list[iter][1],
                    0x00FF & (WORD) lpHostEnt->h_addr_list[iter][2],
                    0x00FF & (WORD) lpHostEnt->h_addr_list[iter][3] );
            iter++;
        }
    }
    else
    {
        printf( "\nNo host found for %s.\nError: %d", argv[1], WSAGetLastError() );
    }

    WSACleanup();

    if ( fLoop )
        goto Repeat;

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\test\ipqry.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dnsapi.h>

VOID
PrintIpAddress (
    IN  DWORD dwIpAddress );

_cdecl
main(int argc, char **argv)
{
    DWORD     iter;
    DWORD     Count;
    PIP_ARRAY pIpAddresses = NULL;

    printf( "Get the local IP address list\n" );

    Count = DnsGetIpAddressList( &pIpAddresses );

    if ( Count && pIpAddresses )
    {
        printf( "\n  Ip Addresses :\n" );

        for ( iter = 0; iter < pIpAddresses->cAddrCount; iter++ )
        {
            printf( "  (%d) \t", iter+1 );
            PrintIpAddress( pIpAddresses->aipAddrs[iter] );
        }

        LocalFree( pIpAddresses );
    }
    else
    {
        printf( "\n  No Ip Addresses found.\n" );
    }

    printf( "\n\nGet the local DNS server list\n" );

    Count = DnsGetDnsServerList( &pIpAddresses );

    if ( Count && pIpAddresses )
    {
        printf( "\n  Ip Addresses :\n" );

        for ( iter = 0; iter < pIpAddresses->cAddrCount; iter++ )
        {
            printf( "  (%d) \t", iter+1 );
            PrintIpAddress( pIpAddresses->aipAddrs[iter] );
        }

        LocalFree( pIpAddresses );
    }
    else
    {
        printf( "\n  No Ip Addresses found.\n" );
    }

    return(0);
}

VOID
PrintIpAddress (
    IN  DWORD dwIpAddress )
{
    printf( "   %d.%d.%d.%d\n",
            ((BYTE *) &dwIpAddress)[0],
            ((BYTE *) &dwIpAddress)[1],
            ((BYTE *) &dwIpAddress)[2],
            ((BYTE *) &dwIpAddress)[3] );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\test\ghn.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <wsipx.h>
#include <svcguid.h>
#include <nspapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <rpc.h>
#include <rpcdce.h>


_cdecl
main(int argc, char **argv)
{
    WSADATA wsaData;
    char    hostName[256];

    WSAStartup( MAKEWORD(1, 1), &wsaData );

    if ( !gethostname( hostName, 256 ) )
    {
        printf( "\nHost name is %s\n", hostName );
    }
    else
    {
        printf( "\nNo host name.\nError: %d", WSAGetLastError() );
    }

    WSACleanup();

    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\test\leaktest.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dnsapi.h>

VOID
PrintIpAddress (
    IN  DWORD dwIpAddress );

_cdecl
main(int argc, char **argv)
{
    DWORD       iter;
    PDNS_RECORD pRecord;

    system( "pause" );

    for ( iter = 0; iter < 10000; iter++ )
    {
        DnsQuery_A( "", 1, 0, NULL, &pRecord, NULL );
        DnsRecordListFree( pRecord, TRUE );
    }

    system( "pause" );

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\test\rnrdns.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <wsipx.h>
#include <svcguid.h>
#include <stdio.h>
#include <stdlib.h>
#include <rpc.h>
#include <rpcdce.h>
#include "..\..\dnslib\dnslib.h"


#define BUFFSIZE 3000


VOID
PrintIpAddress (
    IN  DWORD dwIpAddress )
{
    printf( " %d.%d.%d.%d\n",
            ((BYTE *) &dwIpAddress)[0],
            ((BYTE *) &dwIpAddress)[1],
            ((BYTE *) &dwIpAddress)[2],
            ((BYTE *) &dwIpAddress)[3] );
}

_cdecl
main(int argc, char **argv)
{
    HANDLE hLib;
    WCHAR Buffer[BUFFSIZE];
    PWSAQUERYSETW Query = (PWSAQUERYSETW)Buffer;
    HANDLE hRnr;
    DWORD dwIp;
    DWORD dwQuerySize = BUFFSIZE;
    WSADATA wsaData;
    WCHAR               UnicodeServiceName[1024];
    AFPROTOCOLS         lpAfpProtocols[3];
    // GUID                ServiceGuid = SVCID_HOSTNAME;
    GUID                ServiceGuid = SVCID_INET_HOSTADDRBYNAME;
    // GUID                ServiceGuid = SVCID_DNS(28);
    // GUID                ServiceGuid = SVCID_DNS_TYPE_SRV;
    DWORD               uLoop;
    DWORD iter;

    if ( argc != 2 )
    {
        printf( "\nUsage: lookup <Name>\n" );

        return( -1 );
    }

    Dns_NameCopy( UnicodeServiceName,
                  NULL,
                  argv[1],
                  0,
                  DnsCharSetAnsi,
                  DnsCharSetUnicode );

    WSAStartup(MAKEWORD(2, 0), &wsaData);

    memset(Query, 0, sizeof(*Query));

    Query->lpszServiceInstanceName = UnicodeServiceName;
    Query->dwSize = sizeof(*Query);
    Query->dwNameSpace = NS_ALL;
    Query->lpServiceClassId = &ServiceGuid;

    if( WSALookupServiceBeginW( Query,
                                LUP_RETURN_ADDR |
                                LUP_RETURN_ALIASES |
                                // LUP_RETURN_BLOB |
                                LUP_RETURN_NAME,
                                &hRnr ) == SOCKET_ERROR )
    {
        printf( "LookupBegin failed  %d\n", GetLastError() );
    }

    while ( WSALookupServiceNextW( hRnr,
                                   0,
                                   &dwQuerySize,
                                   Query ) == NO_ERROR )
    {
        printf( "Next got: \n" );
        printf( "   dwSize = %d\n",
                Query->dwSize );
        printf( "   dwOutputFlags = %d\n",
                Query->dwOutputFlags );
        printf( "   lpszServiceInstanceName = %S\n",
                Query->lpszServiceInstanceName );
        if ( Query->lpVersion )
        {
            printf( "   lpVersion->dwVersion = %d\n",
                    Query->lpVersion->dwVersion );
            printf( "   lpVersion->ecHow = %d\n",
                    Query->lpVersion->ecHow );
        }
        if ( Query->lpszComment )
        {
            printf( "   lpszComment = %ws\n",
                    Query->lpszComment );
        }
        printf( "   dwNameSpace = %d\n",
                Query->dwNameSpace );
        if ( Query->lpszContext )
        {
            printf( "   lpszContext = %S\n",
                    Query->lpszContext );
        }
        printf( "   dwNumberOfCsAddrs = %d\n",
                Query->dwNumberOfCsAddrs );

        for ( iter = 0; iter < Query->dwNumberOfCsAddrs; iter++ )
        {
            if ( Query->lpcsaBuffer[iter].RemoteAddr.lpSockaddr->sa_data )
            {
                printf( "   Address : " );
                PrintIpAddress( * ((DWORD*) &Query->lpcsaBuffer[iter].RemoteAddr.lpSockaddr->sa_data[2]) );
            }
        }
    }

    printf( "Next finished with %d\n", GetLastError() );

    if( WSALookupServiceEnd( hRnr ) )
    {
        printf( "ServiceEnd failed %d\n", GetLastError() );
    }

    WSACleanup();

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\test\ws2qry.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <wsipx.h>
#include <svcguid.h>
#include <stdio.h>
#include <stdlib.h>
#include <rpc.h>
#include <rpcdce.h>
#include "..\..\dnslib\dnslib.h"


VOID
PrintRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintARecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintSOARecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintPTRRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintMINFORecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintMXRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintHINFORecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintNULLRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintWKSRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintAAAARecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintSRVRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintATMARecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintWINSRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintWINSRRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintDNSFlags (
    IN  DNSREC_FLAGS Flags );

VOID
PrintIpAddress (
    IN  DWORD dwIpAddress )
{
    printf( " %d.%d.%d.%d\n",
            ((BYTE *) &dwIpAddress)[0],
            ((BYTE *) &dwIpAddress)[1],
            ((BYTE *) &dwIpAddress)[2],
            ((BYTE *) &dwIpAddress)[3] );
}


#define BUFFSIZE 3000

GUID DnsRRGuidA = SVCID_DNS_TYPE_A;
GUID DnsRRGuidNS = SVCID_DNS_TYPE_NS;
GUID DnsRRGuidMD = SVCID_DNS_TYPE_MD;
GUID DnsRRGuidMF = SVCID_DNS_TYPE_MF;
GUID DnsRRGuidCNAME = SVCID_DNS_TYPE_CNAME;
GUID DnsRRGuidSOA = SVCID_DNS_TYPE_SOA;
GUID DnsRRGuidMB = SVCID_DNS_TYPE_MB;
GUID DnsRRGuidMG = SVCID_DNS_TYPE_MG;
GUID DnsRRGuidMR = SVCID_DNS_TYPE_MR;
GUID DnsRRGuidNULL = SVCID_DNS_TYPE_NULL;
GUID DnsRRGuidWKS = SVCID_DNS_TYPE_WKS;
GUID DnsRRGuidPTR = SVCID_DNS_TYPE_PTR;
GUID DnsRRGuidHINFO = SVCID_DNS_TYPE_HINFO;
GUID DnsRRGuidMINFO = SVCID_DNS_TYPE_MINFO;
GUID DnsRRGuidMX = SVCID_DNS_TYPE_MX;
GUID DnsRRGuidTEXT = SVCID_DNS_TYPE_TEXT;
GUID DnsRRGuidRP = SVCID_DNS_TYPE_RP;
GUID DnsRRGuidAFSDB = SVCID_DNS_TYPE_AFSDB;
GUID DnsRRGuidX25 = SVCID_DNS_TYPE_X25;
GUID DnsRRGuidISDN = SVCID_DNS_TYPE_ISDN;
GUID DnsRRGuidRT = SVCID_DNS_TYPE_RT;
GUID DnsRRGuidNSAP = SVCID_DNS_TYPE_NSAP;
GUID DnsRRGuidNSAPPTR = SVCID_DNS_TYPE_NSAPPTR;
GUID DnsRRGuidSIG = SVCID_DNS_TYPE_SIG;
GUID DnsRRGuidKEY = SVCID_DNS_TYPE_KEY;
GUID DnsRRGuidPX = SVCID_DNS_TYPE_PX;
GUID DnsRRGuidGPOS = SVCID_DNS_TYPE_GPOS;
GUID DnsRRGuidAAAA = SVCID_DNS_TYPE_AAAA;
GUID DnsRRGuidLOC = SVCID_DNS_TYPE_LOC;
GUID DnsRRGuidNXT = SVCID_DNS_TYPE_NXT;
GUID DnsRRGuidSRV = SVCID_DNS_TYPE_SRV;
GUID DnsRRGuidATMA = SVCID_DNS_TYPE_ATMA;

_cdecl
main(int argc, char **argv)
{
    WCHAR         Buffer[BUFFSIZE];
    PWSAQUERYSETW Query = (PWSAQUERYSETW)Buffer;
    HANDLE        hRnr;
    DWORD         dwQuerySize = BUFFSIZE;
    WSADATA       wsaData;
    LPGUID        lpServiceGuid = NULL;
    DWORD iter;

    LONG          cch;
    DWORD         Status = NO_ERROR;
    WORD          wType;
    WCHAR         usName[1000];

    if ( argc != 3 )
    {
        printf( "\nUsage: ws2qry <DNS Name> <Type>\n" );
        printf( "\nWhere:\n" );
        printf( "    DNS Name   - Server_X.dbsd-test.microsoft.com\n" );
        printf( "    Type       - 1 | A, 2 | ns, 12 | Ptr, 33 | SRV, ...\n" );
        return(-1);
    }

    cch = MultiByteToWideChar(
              CP_ACP,
              0L,
              argv[1],
              -1,
              usName,
              1000
              );

    if (!cch)
    {
         Status = GetLastError();
        return (Status);
    }

    if ( Dns_NameCompare_A( "A", argv[2] ) )
    {
        wType = DNS_TYPE_A;
        lpServiceGuid = &DnsRRGuidA;
    }
    else if ( Dns_NameCompare_A( "NS", argv[2] ) )
    {
        wType = DNS_TYPE_NS;
        lpServiceGuid = &DnsRRGuidNS;
    }
    else if ( Dns_NameCompare_A( "MD", argv[2] ) )
    {
        wType = DNS_TYPE_MD;
        lpServiceGuid = &DnsRRGuidMD;
    }
    else if ( Dns_NameCompare_A( "MF", argv[2] ) )
    {
        wType = DNS_TYPE_MF;
        lpServiceGuid = &DnsRRGuidMF;
    }
    else if ( Dns_NameCompare_A( "CNAME", argv[2] ) )
    {
        wType = DNS_TYPE_CNAME;
        lpServiceGuid = &DnsRRGuidCNAME;
    }
    else if ( Dns_NameCompare_A( "SOA", argv[2] ) )
    {
        wType = DNS_TYPE_SOA;
        lpServiceGuid = &DnsRRGuidSOA;
    }
    else if ( Dns_NameCompare_A( "MB", argv[2] ) )
    {
        wType = DNS_TYPE_MB;
        lpServiceGuid = &DnsRRGuidMB;
    }
    else if ( Dns_NameCompare_A( "MG", argv[2] ) )
    {
        wType = DNS_TYPE_MG;
        lpServiceGuid = &DnsRRGuidMG;
    }
    else if ( Dns_NameCompare_A( "MR", argv[2] ) )
    {
        wType = DNS_TYPE_MR;
        lpServiceGuid = &DnsRRGuidMR;
    }
    else if ( Dns_NameCompare_A( "NULL", argv[2] ) )
    {
        wType = DNS_TYPE_NULL;
        lpServiceGuid = &DnsRRGuidNULL;
    }
    else if ( Dns_NameCompare_A( "WKS", argv[2] ) )
    {
        wType = DNS_TYPE_WKS;
        lpServiceGuid = &DnsRRGuidWKS;
    }
    else if ( Dns_NameCompare_A( "PTR", argv[2] ) )
    {
        wType = DNS_TYPE_PTR;
        lpServiceGuid = &DnsRRGuidPTR;
    }
    else if ( Dns_NameCompare_A( "HINFO", argv[2] ) )
    {
        wType = DNS_TYPE_HINFO;
        lpServiceGuid = &DnsRRGuidHINFO;
    }
    else if ( Dns_NameCompare_A( "MINFO", argv[2] ) )
    {
        wType = DNS_TYPE_MINFO;
        lpServiceGuid = &DnsRRGuidMINFO;
    }
    else if ( Dns_NameCompare_A( "MX", argv[2] ) )
    {
        wType = DNS_TYPE_MX;
        lpServiceGuid = &DnsRRGuidMX;
    }
    else if ( Dns_NameCompare_A( "TEXT", argv[2] ) )
    {
        wType = DNS_TYPE_TEXT;
        lpServiceGuid = &DnsRRGuidTEXT;
    }
    else if ( Dns_NameCompare_A( "RP", argv[2] ) )
    {
        wType = DNS_TYPE_RP;
        lpServiceGuid = &DnsRRGuidRP;
    }
    else if ( Dns_NameCompare_A( "AFSDB", argv[2] ) )
    {
        wType = DNS_TYPE_AFSDB;
        lpServiceGuid = &DnsRRGuidAFSDB;
    }
    else if ( Dns_NameCompare_A( "X25", argv[2] ) )
    {
        wType = DNS_TYPE_X25;
        lpServiceGuid = &DnsRRGuidX25;
    }
    else if ( Dns_NameCompare_A( "ISDN", argv[2] ) )
    {
        wType = DNS_TYPE_ISDN;
        lpServiceGuid = &DnsRRGuidISDN;
    }
    else if ( Dns_NameCompare_A( "RT", argv[2] ) )
    {
        wType = DNS_TYPE_RT;
        lpServiceGuid = &DnsRRGuidRT;
    }
    else if ( Dns_NameCompare_A( "NSAP", argv[2] ) )
    {
        wType = DNS_TYPE_NSAP;
        lpServiceGuid = &DnsRRGuidNSAP;
    }
    else if ( Dns_NameCompare_A( "NSAPPTR", argv[2] ) )
    {
        wType = DNS_TYPE_NSAPPTR;
        lpServiceGuid = &DnsRRGuidNSAPPTR;
    }
    else if ( Dns_NameCompare_A( "SIG", argv[2] ) )
    {
        wType = DNS_TYPE_SIG;
        lpServiceGuid = &DnsRRGuidSIG;
    }
    else if ( Dns_NameCompare_A( "KEY", argv[2] ) )
    {
        wType = DNS_TYPE_KEY;
        lpServiceGuid = &DnsRRGuidKEY;
    }
    else if ( Dns_NameCompare_A( "PX", argv[2] ) )
    {
        wType = DNS_TYPE_PX;
        lpServiceGuid = &DnsRRGuidPX;
    }
    else if ( Dns_NameCompare_A( "GPOS", argv[2] ) )
    {
        wType = DNS_TYPE_GPOS;
        lpServiceGuid = &DnsRRGuidGPOS;
    }
    else if ( Dns_NameCompare_A( "AAAA", argv[2] ) )
    {
        wType = DNS_TYPE_AAAA;
        lpServiceGuid = &DnsRRGuidAAAA;
    }
    else if ( Dns_NameCompare_A( "LOC", argv[2] ) )
    {
        wType = DNS_TYPE_LOC;
        lpServiceGuid = &DnsRRGuidLOC;
    }
    else if ( Dns_NameCompare_A( "NXT", argv[2] ) )
    {
        wType = DNS_TYPE_NXT;
        lpServiceGuid = &DnsRRGuidNXT;
    }
    else if ( Dns_NameCompare_A( "SRV", argv[2] ) )
    {
        wType = DNS_TYPE_SRV;
        lpServiceGuid = &DnsRRGuidSRV;
    }
    else if ( Dns_NameCompare_A( "ATMA", argv[2] ) )
    {
        wType = DNS_TYPE_ATMA;
        lpServiceGuid = &DnsRRGuidATMA;
    }
    else
    {
        wType = (WORD) atoi( argv[2] );
    }

    printf( "\nGoing to look up ( %S, %d ) ...\n\n",
            usName,
            wType );

    WSAStartup(MAKEWORD(2, 0), &wsaData);

    memset(Query, 0, sizeof(*Query));

    Query->lpszServiceInstanceName = usName;
    Query->dwSize = sizeof(*Query);
    Query->dwNameSpace = NS_DNS;
    Query->lpServiceClassId = lpServiceGuid;

    if( WSALookupServiceBeginW( Query,
                                LUP_RETURN_ADDR |
                                LUP_RETURN_ALIASES |
                                LUP_RETURN_BLOB |
                                LUP_RETURN_NAME,
                                &hRnr ) == SOCKET_ERROR )
    {
        printf( "LookupBegin failed  %d\n", GetLastError() );
    }

    while ( WSALookupServiceNextW( hRnr,
                                   0,
                                   &dwQuerySize,
                                   Query ) == NO_ERROR )
    {
        printf( "Next got: \n" );
        printf( "   dwSize = %d\n",
                Query->dwSize );
        printf( "   dwOutputFlags = %d\n",
                Query->dwOutputFlags );
        printf( "   lpszServiceInstanceName = %S\n",
                Query->lpszServiceInstanceName );
        if ( Query->lpVersion )
        {
            printf( "   lpVersion->dwVersion = %d\n",
                    Query->lpVersion->dwVersion );
            printf( "   lpVersion->ecHow = %d\n",
                    Query->lpVersion->ecHow );
        }
        if ( Query->lpszComment )
        {
            printf( "   lpszComment = %ws\n",
                    Query->lpszComment );
        }
        printf( "   dwNameSpace = %d\n",
                Query->dwNameSpace );
        if ( Query->lpszContext )
        {
            printf( "   lpszContext = %S\n",
                    Query->lpszContext );
        }
        printf( "   dwNumberOfCsAddrs = %d\n",
                Query->dwNumberOfCsAddrs );

        for ( iter = 0; iter < Query->dwNumberOfCsAddrs; iter++ )
        {
            if ( Query->lpcsaBuffer[iter].RemoteAddr.lpSockaddr->sa_data )
            {
                printf( "   Address : " );
                PrintIpAddress( * ((DWORD*) &Query->lpcsaBuffer[iter].RemoteAddr.lpSockaddr->sa_data[2]) );
            }
        }

        if ( Query->lpBlob )
        {
            PDNS_RECORD pDNSRecord = NULL;
            PDNS_RECORD pTempDNSRecord = NULL;
            PDNS_MESSAGE_BUFFER pMsg =
                (PDNS_MESSAGE_BUFFER) Query->lpBlob->pBlobData;

            SWAP_COUNT_BYTES( &pMsg->MessageHead );

            printf( "Extracting record(s) from message buffer ...\n\n" );

            Status = DnsExtractRecordsFromMessage_W( pMsg,
                                                     (WORD) Query->lpBlob->cbSize,
                                                     &pDNSRecord );

            if ( Status )
            {
                printf( "DnsExtractRecordsFromMessage_W call failed with error: 0x%.8X\n", Status );

                pDNSRecord = NULL;
            }

            pTempDNSRecord = pDNSRecord;

            while ( pTempDNSRecord )
            {
                printf( "   Record:\n" );
                printf( "   -------------------------------------\n" );
                printf( "       Name        : %S\n", pTempDNSRecord->pName );
                printf( "       Type        : %d\n", pTempDNSRecord->wType );
                printf( "       Data Length : %d\n", pTempDNSRecord->wDataLength );
                printf( "       Ttl (mins)  : %d\n", pTempDNSRecord->dwTtl/60 );
                printf( "       Flags       : 0x%X", pTempDNSRecord->Flags.DW );
                PrintDNSFlags( pTempDNSRecord->Flags.S );
                printf( "\n" );

                PrintRecord( pTempDNSRecord );

                pTempDNSRecord = pTempDNSRecord->pNext;
            }

            DnsFreeRRSet( pDNSRecord, TRUE );
        }
    }

    printf( "Next finished with %d\n", GetLastError() );

    if( WSALookupServiceEnd( hRnr ) )
    {
        printf( "ServiceEnd failed %d\n", GetLastError() );
    }

    WSACleanup();

    return(0);
}


VOID
PrintRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    switch( pDnsRecord->wType )
    {
        case DNS_TYPE_A :
            PrintARecord( pDnsRecord );
            break;

        case DNS_TYPE_SOA :
            PrintSOARecord( pDnsRecord );
            break;

        case DNS_TYPE_PTR :
        case DNS_TYPE_NS :
        case DNS_TYPE_CNAME :
        case DNS_TYPE_MB :
        case DNS_TYPE_MD :
        case DNS_TYPE_MF :
        case DNS_TYPE_MG :
        case DNS_TYPE_MR :
            PrintPTRRecord( pDnsRecord );
            break;

        case DNS_TYPE_MINFO :
        case DNS_TYPE_RP :
            PrintMINFORecord( pDnsRecord );
            break;

        case DNS_TYPE_MX :
        case DNS_TYPE_AFSDB :
        case DNS_TYPE_RT :
            PrintMXRecord( pDnsRecord );
            break;

        case DNS_TYPE_HINFO :
        case DNS_TYPE_ISDN :
        case DNS_TYPE_TEXT :
        case DNS_TYPE_X25 :
            PrintHINFORecord( pDnsRecord );
            break;

        case DNS_TYPE_NULL :
            PrintNULLRecord( pDnsRecord );
            break;

        case DNS_TYPE_WKS :
            PrintWKSRecord( pDnsRecord );
            break;

        case DNS_TYPE_AAAA :
            PrintAAAARecord( pDnsRecord );
            break;

        case DNS_TYPE_SRV :
            PrintSRVRecord( pDnsRecord );
            break;

        case DNS_TYPE_ATMA :
            PrintATMARecord( pDnsRecord );
            break;

        case DNS_TYPE_WINS :
            PrintWINSRecord( pDnsRecord );
            break;

        case DNS_TYPE_NBSTAT :
            PrintWINSRRecord( pDnsRecord );
            break;

        default :
            printf( "Don't know how to print record type %d\n",
                    pDnsRecord->wType );
    }
}


VOID
PrintARecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "       A record :\n" );
    printf( "                  ipAddress            = %d.%d.%d.%d\n",
            ((BYTE *) &pDnsRecord->Data.A.ipAddress)[0],
            ((BYTE *) &pDnsRecord->Data.A.ipAddress)[1],
            ((BYTE *) &pDnsRecord->Data.A.ipAddress)[2],
            ((BYTE *) &pDnsRecord->Data.A.ipAddress)[3] );
    printf( "\n" );
}


VOID
PrintSOARecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "       SOA record :\n" );
    printf( "                    pNamePrimaryServer = %S\n",
            pDnsRecord->Data.SOA.pNamePrimaryServer );
    printf( "                    pNameAdministrator = %S\n",
            pDnsRecord->Data.SOA.pNameAdministrator );
    printf( "                    dwSerialNo         = %d\n",
            pDnsRecord->Data.SOA.dwSerialNo );
    printf( "                    dwRefresh          = %d\n",
            pDnsRecord->Data.SOA.dwRefresh );
    printf( "                    dwRetry            = %d\n",
            pDnsRecord->Data.SOA.dwRetry );
    printf( "                    dwExpire           = %d\n",
            pDnsRecord->Data.SOA.dwExpire );
    printf( "                    dwDefaultTtl       = %d\n",
            pDnsRecord->Data.SOA.dwDefaultTtl );
    printf( "\n" );
}


VOID
PrintPTRRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "       PTR, NS, CNAME, MB, MD, MF, MG, MR record :\n" );
    printf( "                    pNameHost          = %S\n",
            pDnsRecord->Data.PTR.pNameHost );
    printf( "\n" );
}


VOID
PrintMINFORecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "       MINFO, RP record :\n" );
    printf( "                    pNameMailbox       = %S\n",
            pDnsRecord->Data.MINFO.pNameMailbox );
    printf( "                    pNameErrorsMailbox = %S\n",
            pDnsRecord->Data.MINFO.pNameErrorsMailbox );
    printf( "\n" );
}


VOID
PrintMXRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "       MX, AFSDB, RT record :\n" );
    printf( "                    pNameExchange      = %S\n",
            pDnsRecord->Data.MX.pNameExchange );
    printf( "                    wPreference        = %d\n",
            pDnsRecord->Data.MX.wPreference );
    printf( "                    Pad                = %d\n",
            pDnsRecord->Data.MX.Pad );
    printf( "\n" );
}


VOID
PrintHINFORecord (
    IN  PDNS_RECORD pDnsRecord )
{
    DWORD iter;

    printf( "       HINFO, ISDN, TEXT, X25 record :\n" );
    printf( "                    dwStringCount      = %d\n",
            pDnsRecord->Data.HINFO.dwStringCount );
    for ( iter = 0; iter < pDnsRecord->Data.HINFO.dwStringCount; iter ++ )
    {
        printf( "                    pStringArray[%d]  = %S\n",
                iter,
                pDnsRecord->Data.HINFO.pStringArray[iter] );
    }
    printf( "\n" );
}


VOID
PrintNULLRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "       NULL record :\n" );
    printf( "\n" );
}


VOID
PrintWKSRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "       WKS record :\n" );
    printf( "                    ipAddress          = %d.%d.%d.%d\n",
            ((BYTE *) &pDnsRecord->Data.WKS.ipAddress)[0],
            ((BYTE *) &pDnsRecord->Data.WKS.ipAddress)[1],
            ((BYTE *) &pDnsRecord->Data.WKS.ipAddress)[2],
            ((BYTE *) &pDnsRecord->Data.WKS.ipAddress)[3] );
    printf( "                    chProtocol         = %d\n",
            pDnsRecord->Data.WKS.chProtocol );
    printf( "                    bBitMask           = %s\n",
            pDnsRecord->Data.WKS.bBitMask );
    printf( "\n" );
}


VOID
PrintAAAARecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "       AAAA record :\n" );
    printf( "                    ipAddress          = %d.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d.%d\n",
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[0],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[1],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[2],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[3],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[4],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[5],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[6],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[7],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[8],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[9],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[10],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[11],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[12],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[13],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[14],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[15] );
    printf( "\n" );
}


VOID
PrintSRVRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "       SRV record :\n" );
    printf( "                    pNameTarget        = %S\n",
            pDnsRecord->Data.SRV.pNameTarget );
    printf( "                    wPriority          = %d\n",
            pDnsRecord->Data.SRV.wPriority );
    printf( "                    wWeight            = %d\n",
            pDnsRecord->Data.SRV.wWeight );
    printf( "                    wPort              = %d\n",
            pDnsRecord->Data.SRV.wPort );
    printf( "                    Pad                = %d\n",
            pDnsRecord->Data.SRV.Pad );
    printf( "\n" );
}


VOID
PrintATMARecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "       ATMA record :\n" );
    printf( "                    Address Type       = %d\n",
            pDnsRecord->Data.ATMA.AddressType );

    if ( pDnsRecord->Data.ATMA.Address &&
         pDnsRecord->Data.ATMA.AddressType == DNS_ATM_TYPE_E164 )
    {
        printf( "                    Address            = %s\n",
                pDnsRecord->Data.ATMA.Address );
    }
    else
    {
        DWORD iter;

        printf( "                    Address            =\n\t" );
        for ( iter = 0; iter < pDnsRecord->wDataLength; iter++ )
        {
            printf( "%02x", (UCHAR) pDnsRecord->Data.ATMA.Address[iter] );
        }

        printf( "\n" );
    }

    printf( "\n" );
}


VOID
PrintWINSRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    DWORD iter;

    printf( "       WINS record :\n" );
    printf( "                    dwMappingFlag      = %d\n",
            pDnsRecord->Data.WINS.dwMappingFlag );
    printf( "                    dwLookupTimeout    = %d\n",
            pDnsRecord->Data.WINS.dwLookupTimeout );
    printf( "                    dwCacheTimeout     = %d\n",
            pDnsRecord->Data.WINS.dwCacheTimeout );
    printf( "                    cWinsServerCount   = %d\n",
            pDnsRecord->Data.WINS.cWinsServerCount );
    printf( "                    aipWinsServers     =" );

    for ( iter = 0; iter < pDnsRecord->Data.WINS.cWinsServerCount; iter++ )
    {
        PrintIpAddress( pDnsRecord->Data.WINS.aipWinsServers[iter] );
        printf( " " );
    }

    printf( "\n\n" );
}


VOID
PrintWINSRRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "       NBSTAT record :\n" );
    printf( "                    dwMappingFlag      = %d\n",
            pDnsRecord->Data.WINSR.dwMappingFlag );
    printf( "                    dwLookupTimeout    = %d\n",
            pDnsRecord->Data.WINSR.dwLookupTimeout );
    printf( "                    dwCacheTimeout     = %d\n",
            pDnsRecord->Data.WINSR.dwCacheTimeout );
    printf( "                    pNameResultDomain  = %S\n",
            pDnsRecord->Data.WINSR.pNameResultDomain );
    printf( "\n" );
}


VOID
PrintDNSFlags (
    IN  DNSREC_FLAGS Flags )
{
    if ( Flags.Section == DNSREC_ANSWER )
    {
        printf( " Answer" );
    }

    if ( Flags.Section == DNSREC_AUTHORITY )
    {
        printf( " Authority" );
    }

    if ( Flags.Section == DNSREC_ADDITIONAL )
    {
        printf( " Additional" );
    }

    printf( "\n" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsexts\common.h ===
/*******************************************************************
*
*    File        : common.h
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 9/17/1996
*    Description : common declarations
*
*    Revisions   : <date> <name> <description>
*******************************************************************/



#ifndef COMMON_H
#define COMMON_H



#ifdef __cplusplus
extern "C" {
#endif
// include //
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#ifdef __cplusplus
}
#endif

#include <tchar.h>
#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <ntsdexts.h>
// #include <crtdbg.h>


// defines //

// defaults
#define MAXSTR			   1024
#define MAXLIST            256
#define MAX_TINY_LIST      32



// ntsd extensions
// Macros to easily access extensions helper routines for printing, etc.
// In particular, Printf() takes the same arguments as the CRT printf().
//

#define ASSIGN_NTSDEXTS_GLOBAL(api, str, proc)  \
{                                         \
   glpExtensionApis = api;                \
   glpArgumentString = str;               \
   ghCurrentProcess = proc;               \
}


extern PNTSD_EXTENSION_APIS glpExtensionApis;
extern LPSTR glpArgumentString;
extern LPVOID ghCurrentProcess;

#define Printf          (glpExtensionApis->lpOutputRoutine)
#define GetSymbol       (glpExtensionApis->lpGetSymbolRoutine)
#define GetExpr         (glpExtensionApis->lpGetExpressionRoutine)
#define CheckC          (glpExtensionApis->lpCheckControlCRoutine)



#ifdef DEBUG
#define DEBUG0(str)           Printf(str)
#define DEBUG1(format, arg1)  Printf(format, arg1)
#define DEBUG2(format, arg1, arg2)  Printf(format, arg1, arg2)
#else
#define DEBUG0(str)
#define DEBUG1(format, arg1)
#define DEBUG2(format, arg1, arg2)
#endif



#endif

/******************* EOF *********************/


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\test\dhcpreg\dhcpreg.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    adddom.c

Abstract:

    Domain Name System (DNS) Server

    Test Code for adding a Zone

Author:

    Ram Viswanathan (ramv) 14th March 1997

Revision History:

    Ram Viswanathan (ramv) 14th March 1997   Created

                           5th May 1997  Added Callback function testing
--*/



#include <windows.h>

//
// ********* CRunTime Includes
//

#include <stdlib.h>
#include <limits.h>
#include <io.h>
#include <stdio.h>
#include "dns.h"
#include "dnsapi.h"
#include "dnslib.h"


VOID 
CallBack (
    DWORD     dwStatus,
    LPVOID    pvData
    );


INT __cdecl
main (int argc, char *argv[])
{
    DWORD  dwRes;

    DWORD               iter;
    BOOL                fRegisterForwards = FALSE;
    DWORD               dwOperation = DYNDNS_ADD_ENTRY;
    DWORD               StartPart1, StartPart2, StartPart3, StartPart4;
    DWORD               EndPart1, EndPart2, EndPart3, EndPart4;
    DWORD               StartIPReversed, EndIPReversed;
    REGISTER_HOST_ENTRY HostAddr;
    LPSTR               lpTemp = NULL;
    LPSTR               pszDomainName = NULL;
    LPSTR               pszAddressStart = NULL;
    LPSTR               pszAddressEnd = NULL;
    CHAR                c;

    if ( argc < 4 )
    {
        printf( "\nUsage: dhcpreg <DNS Domain Name> <IP Address Range> [/f /d]\n" );
        printf( "\nWhere:\n" );
        printf( "    DNS Domain Name   - ntdev.microsoft.com\n" );
        printf( "    IP Address Range - 1.2.0.0 1.2.50.255\n" );
        printf( "    Options:\n" );
        printf( "       /f - Register forward addresses\n" );
        printf( "       /d - Delete registered records\n" );
        return(-1);
    }

    pszDomainName = argv[1];
    pszAddressStart = argv[2];
    pszAddressEnd = argv[3];

    if ( argc > 4 )
    {
        if ( !strcmp( argv[4], "/f" ) )
            fRegisterForwards = TRUE;
        else if ( !strcmp( argv[4], "/d" ) )
            dwOperation = DYNDNS_DELETE_ENTRY;

        if ( argc > 5 )
        {
            if ( !strcmp( argv[5], "/f" ) )
                fRegisterForwards = TRUE;
            else if ( !strcmp( argv[5], "/d" ) )
                dwOperation = DYNDNS_DELETE_ENTRY;
        }
    }

    lpTemp = strtok( pszAddressStart, "." );
    StartPart1 = atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    StartPart2 = atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    StartPart3 = atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    StartPart4 = atoi( lpTemp );

    lpTemp = strtok( pszAddressEnd, "." );
    EndPart1 = atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    EndPart2 = atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    EndPart3 = atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    EndPart4 = atoi( lpTemp );

    if ( dwOperation == DYNDNS_DELETE_ENTRY )
    {
        printf( "\nDeregistering DNS records with:\n" );
        printf( "Domain Name:    %s\n", pszDomainName );
        printf( "Address range: %d.%d.%d.%d to %d.%d.%d.%d\n",
                StartPart1, StartPart2, StartPart3, StartPart4,
                EndPart1, EndPart2, EndPart3, EndPart4 );
        printf( "Register forwards: %s\n", fRegisterForwards ? "TRUE" : "FALSE" );
    }
    else
    {
        printf( "\nRegistering DNS records with:\n" );
        printf( "Domain Name:    %s\n", pszDomainName );
        printf( "Address range: %d.%d.%d.%d to %d.%d.%d.%d\n",
                StartPart1, StartPart2, StartPart3, StartPart4,
                EndPart1, EndPart2, EndPart3, EndPart4 );
        printf( "Register forwards: %s\n", fRegisterForwards ? "TRUE" : "FALSE" );
    }

    StartIPReversed = (DWORD)(StartPart4) + (DWORD)(StartPart3 << 8) + 
                      (DWORD)(StartPart2 << 16) + (DWORD)(StartPart1 << 24);

    EndIPReversed = (DWORD)(EndPart4) + (DWORD)(EndPart3 << 8) + 
                    (DWORD)(EndPart2 << 16) + (DWORD)(EndPart1 << 24);

    //
    // set up stuff for registration
    //

    dwRes = DnsDhcpSrvRegisterInit();

    if ( dwRes )
        printf("Init failed with %x\n", dwRes);


    for ( iter = StartIPReversed; iter < EndIPReversed; iter++ )
    {
        CHAR  szName[260];
        DWORD IP = iter;
        BYTE  Temp;
        DWORD dwFlags = 0;
        LPSTR pszAddr = LocalAlloc( LPTR, 20 );

        Temp = ((LPBYTE)&IP)[3];
        ((LPBYTE)&IP)[3] = ((LPBYTE)&IP)[0];
        ((LPBYTE)&IP)[0] = Temp;

        Temp = ((LPBYTE)&IP)[2];
        ((LPBYTE)&IP)[2] = ((LPBYTE)&IP)[1];
        ((LPBYTE)&IP)[1] = Temp;

        if ( dwOperation == DYNDNS_DELETE_ENTRY )
            printf( "\nDeregistering DNS record for:\n" );
        else
            printf( "\nRegistering DNS record for:\n" );

        if ( pszAddr )
        {
            sprintf( pszAddr, "%d.%d.%d.%d",
                     ((LPBYTE)&IP)[0],
                     ((LPBYTE)&IP)[1],
                     ((LPBYTE)&IP)[2],
                     ((LPBYTE)&IP)[3] );
        }

        sprintf( szName, "%d-%d-%d-%d.%s",
                 ((LPBYTE)&IP)[0],
                 ((LPBYTE)&IP)[1],
                 ((LPBYTE)&IP)[2],
                 ((LPBYTE)&IP)[3],
                 pszDomainName );

        if ( pszAddr )
            printf( "Address: %s\n", pszAddr );

        printf( "Name:    %s\n", szName );


        HostAddr.dwOptions = REGISTER_HOST_PTR;
        HostAddr.Addr.ipAddr = IP;

        if ( fRegisterForwards )
            dwFlags = DYNDNS_REG_FORWARD;

        dwFlags |= dwOperation;

        dwRes = DnsDhcpSrvRegisterHostName_A (
                    HostAddr,
                    szName,
                    600,   //10 mins of Time to live
                    dwFlags,
                    (DHCP_CALLBACK_FN)&CallBack,
                    (PVOID) pszAddr
                    );

        if ( dwRes )
            printf("Host Name registration failed with %x\n", dwRes);

        Sleep( 1000 );
    }

    c = getchar();
    dwRes = DnsDhcpSrvRegisterTerm();

    if ( dwRes )
        printf("Termination failed with %x\n", dwRes);

    c = getchar();
error:
    return(1);

}


VOID 
CallBack (
    DWORD     dwStatus,
    LPVOID    pvData
    )

{

    //
    // callback functionality testing
    //

    LPSTR pszData = (LPSTR)pvData;

    printf("Registration of %s returned with Error Code %x \n", pszData,
           dwStatus );

    LocalFree(pszData);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsapi\test\clntreg\clntreg.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    adddom.c

Abstract:

    Domain Name System (DNS) Server

    Test Code for adding a Zone

Author:

    Ram Viswanathan (ramv) 14th March 1997

Revision History:

    Ram Viswanathan (ramv) 14th March 1997   Created

                           5th May 1997  Added Callback function testing
--*/



#include <windows.h>

//
// ********* CRunTime Includes
//

#include <stdlib.h>
#include <limits.h>
#include <io.h>
#include <stdio.h>
#include "dns.h"
#include "dnsapi.h"
#include "dnslib.h"

INT __cdecl
main (int argc, char *argv[])
{
    DWORD  dwRes;

    LPSTR  pszMapFile = NULL;
    INT    i;
    BOOL   fDownLevel =FALSE;
    DWORD  dwOperation = DYNDNS_ADD_ENTRY;
    LPSTR  lpTemp = NULL;
    DWORD   Part1, Part2, Part3, Part4;
    FILE *fp = NULL;
    CHAR   szInputString[MAX_PATH];
    CHAR   szAddr[20];
    LPSTR pszAddr = NULL;
    CHAR   szName[50];
    CHAR    c;
    DWORD dwFlags = 0;
    char seps[]=" ,\t\n";
    CHAR AdapterName[50];
    CHAR HostName[50];
    CHAR DomainName[50];
    INT  ipAddrCount;
    REGISTER_HOST_ENTRY HostAddrs[5];
    char *token;

    //
    // 1st argument is a/d (for add or delete)
    // 2nd argument is f/n (register forwards/not register forwards)
    // 3rd argument is filename

    // Note that no optional parameters are set
    //

    if (argc != 2){
        
        printf("Usage is %s filename \n", argv[0]);
        exit(-1);
    }

        
    pszMapFile  = argv[1];

    //
    // set up stuff for registration
    //

    dwRes = DnsAsyncRegisterInit(NULL);

    if (dwRes){
        printf("Init failed with %x\n", dwRes);
    }


    if (!(fp = fopen (pszMapFile, "r+"))){
        printf(" Could not open map file %s \n", pszMapFile);
    }

    while (fgets (szInputString, MAX_PATH, fp) != NULL){
        //
        // parse the input string
        //
        token = strtok(szInputString, seps);

        strcpy (AdapterName, token);

        token =strtok(NULL, seps);
        strcpy (HostName, token);
            
        token =strtok(NULL, seps);
        strcpy (DomainName, token);

        ipAddrCount = 0;

        token =strtok(NULL, seps);
        while ( token != NULL){
            strcpy (szAddr, token);

            lpTemp = strtok( szAddr, "." );
            Part1 = atoi( lpTemp );
            lpTemp = strtok( NULL, "." );
            Part2 = atoi( lpTemp );
            lpTemp = strtok( NULL, "." );
            Part3 = atoi( lpTemp );
            lpTemp = strtok( NULL, "." );
            Part4 = atoi( lpTemp );


            printf( "\nRegistering DNS record for:\n" );
            printf("AdapterName = %s\n", AdapterName);
            printf("HostName = %s\n", HostName);
            printf("DomainName = %s\n", DomainName);
            
            printf( "Address: %d.%d.%d.%d\n", Part1, Part2, Part3, Part4 );

            HostAddrs[ipAddrCount].dwOptions = REGISTER_HOST_PTR;

            HostAddrs[ipAddrCount].Addr.ipAddr = (DWORD)(Part1) + (DWORD)(Part2 << 8) + 
                (DWORD)(Part3 << 16) + (DWORD)(Part4 << 24);


            ipAddrCount++;
            token =strtok(NULL, seps);  

        }


        dwRes = DnsAsyncRegisterHostAddrs_A (
                    AdapterName,
                    HostName,
                    HostAddrs,
                    ipAddrCount,
                    NULL,
                    0,
                    DomainName,
                    NULL,
                    40,
                    0
                    );

        if (dwRes){
            printf("Host Name registration failed with %x\n", dwRes);
        }
                
    }

    fclose(fp);
    
    printf("Hit Enter to do the ipconfig /release now! \n");
    c = getchar();


    //
    // do the releases now
    //

    
    if (!(fp = fopen (pszMapFile, "r+"))){
        printf(" Could not open map file %s \n", pszMapFile);
    }

    while (fgets (szInputString, MAX_PATH, fp) != NULL){
        //
        // parse the input string
        //
        token = strtok(szInputString, seps);

        strcpy (AdapterName, token);

        token =strtok(NULL, seps);
        strcpy (HostName, token);
            
        token =strtok(NULL, seps);
        strcpy (DomainName, token);

        ipAddrCount = 0;

        token =strtok(NULL, seps);
        while ( token != NULL){
            strcpy (szAddr, token);

            lpTemp = strtok( szAddr, "." );
            Part1 = atoi( lpTemp );
            lpTemp = strtok( NULL, "." );
            Part2 = atoi( lpTemp );
            lpTemp = strtok( NULL, "." );
            Part3 = atoi( lpTemp );
            lpTemp = strtok( NULL, "." );
            Part4 = atoi( lpTemp );


            printf( "\nRegistering DNS record for:\n" );
            printf("AdapterName = %s\n", AdapterName);
            printf("HostName = %s\n", HostName);
            printf("DomainName = %s\n", DomainName);
            
            printf( "Address: %d.%d.%d.%d\n", Part1, Part2, Part3, Part4 );

            HostAddrs[ipAddrCount].dwOptions = REGISTER_HOST_PTR;

            HostAddrs[ipAddrCount].Addr.ipAddr = (DWORD)(Part1) + (DWORD)(Part2 << 8) + 
                (DWORD)(Part3 << 16) + (DWORD)(Part4 << 24);


            ipAddrCount++;
            token =strtok(NULL, seps);  

        }


        dwRes = DnsAsyncRegisterHostAddrs_A (
                    AdapterName,
                    HostName,
                    HostAddrs,
                    ipAddrCount,
                    NULL,
                    0,
                    DomainName,
                    NULL,
                    40,
                    DYNDNS_DEL_ENTRY
                    );

        if (dwRes){
            printf("Host Name registration failed with %x\n", dwRes);
        }
                
    }

    fclose(fp);     

    printf("Hit Enter to do the ipconfig /renew now! \n");
    c = getchar();



    if (!(fp = fopen (pszMapFile, "r+"))){
        printf(" Could not open map file %s \n", pszMapFile);
    }

    while (fgets (szInputString, MAX_PATH, fp) != NULL){
        //
        // parse the input string
        //
        token = strtok(szInputString, seps);

        strcpy (AdapterName, token);

        token =strtok(NULL, seps);
        strcpy (HostName, token);
            
        token =strtok(NULL, seps);
        strcpy (DomainName, token);

        ipAddrCount = 0;

        token =strtok(NULL, seps);
        while ( token != NULL){
            strcpy (szAddr, token);

            lpTemp = strtok( szAddr, "." );
            Part1 = atoi( lpTemp );
            lpTemp = strtok( NULL, "." );
            Part2 = atoi( lpTemp );
            lpTemp = strtok( NULL, "." );
            Part3 = atoi( lpTemp );
            lpTemp = strtok( NULL, "." );
            Part4 = atoi( lpTemp );


            printf( "\nRegistering DNS record for:\n" );
            printf("AdapterName = %s\n", AdapterName);
            printf("HostName = %s\n", HostName);
            printf("DomainName = %s\n", DomainName);
            
            printf( "Address: %d.%d.%d.%d\n", Part1, Part2, Part3, Part4 );

            HostAddrs[ipAddrCount].dwOptions = REGISTER_HOST_PTR;

            HostAddrs[ipAddrCount].Addr.ipAddr = (DWORD)(Part1) + (DWORD)(Part2 << 8) + 
                (DWORD)(Part3 << 16) + (DWORD)(Part4 << 24);


            ipAddrCount++;
            token =strtok(NULL, seps);  

        }


        dwRes = DnsAsyncRegisterHostAddrs_A (
                    AdapterName,
                    HostName,
                    HostAddrs,
                    ipAddrCount,
                    NULL,
                    0,
                    DomainName,
                    NULL,
                    40,
                    0
                    );

        if (dwRes){
            printf("Host Name registration failed with %x\n", dwRes);
        }
                
    }

    fclose(fp);
    
    c = getchar();
    dwRes = DnsAsyncRegisterTerm();

    if (dwRes){
        printf("Termination failed with %x\n", dwRes);
    }

    c = getchar();
error:
    return(1);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsexts\util.cxx ===
/*******************************************************************
*
*    File        : util.cxx
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 7/21/1998
*    Description :
*
*    Revisions   : <date> <name> <description>
*******************************************************************/



#ifndef UTIL_CXX
#define UTIL_CXX



// include //
#include "common.h"
#include "util.hxx"


// defines //
#define DNSEXT_CUSTOMER_CODE 0xD0000000
#define STACK_OVERFLOW     STATUS_STACK_OVERFLOW | DNSEXT_CUSTOMER_CODE


// types //


// global variables //
PVOID gAllocationStack[MAXLIST];

// local variables //
static INT iStackSize=0;


// prototypes //
PVOID
ReadMemory(
    IN PVOID  pvAddr,
    IN DWORD  dwSize);
VOID
FreeMemory(
    IN PVOID pv);







// functions //

PVOID PushMemory(
                 IN PVOID  pvAddr,
                 IN DWORD  dwSize)
/*++

Routine Description:

   Shells on read memory to remember the pointer in a local stack

Arguments:

    pvAddr - Address of memory block to read in the address space of the
        process being debugged.

    dwSize - Count of bytes to read/allocate/copy.

Return Value:

    Pointer to debugger local memory.

--*/

{

   if(iStackSize == MAXLIST-1){
      Printf("Exception: No more allocation stack memory\n");
      RaiseException(STACK_OVERFLOW, 0, 0, NULL);
   }

   PVOID pv = ReadMemory(pvAddr, dwSize);
   if(!pv){
      Printf("Exception: No memory\n");
      RaiseException(STACK_OVERFLOW, 0, 0, NULL);
   }

   return gAllocationStack[iStackSize++] = pv;

}



VOID
PopMemory(
    IN PVOID pv)

/*++

Routine Description:

    Frees memory returned by PushMemory.

Arguments:

    pv - Address of debugger local memory to free.

Return Value:

    None.

--*/

{
   FreeMemory(pv);
   if(0 == iStackSize){
      Printf("Exception: Invalid stack operation (iStackSize == 0).\n");
      RaiseException(STACK_OVERFLOW, 0, 0, NULL);
   }
   gAllocationStack[iStackSize--] = NULL;
}



VOID
CleanMemory( VOID)

/*++

Routine Description:

    Frees all stack memory returned by PushMemory.

Arguments:



Return Value:

    None.

--*/

{
   for (INT i=0; i<MAXLIST; i++) {
      if(gAllocationStack[i]){
         FreeMemory(gAllocationStack[i]);
      }
   }
}



//
// NOTE: The following mem utils were copied & modified from dsexts.dll code base
//

PVOID
ReadMemory(
    IN PVOID  pvAddr,
    IN DWORD  dwSize)

/*++

Routine Description:

    This function reads memory from the address space of the process
    being debugged and copies its contents to newly allocated memory
    in the debuggers address space.  NULL is returned on error. Returned
    memory should be deallocated via FreeMemory().

Arguments:

    pvAddr - Address of memory block to read in the address space of the
        process being debugged.

    dwSize - Count of bytes to read/allocate/copy.

Return Value:

    Pointer to debugger local memory.

--*/

{
    SIZE_T cRead;
    PVOID pv;

    DEBUG1("HeapAlloc(0x%x)\n", dwSize);

    if ( NULL == (pv = HeapAlloc(GetProcessHeap(), 0, dwSize)) )
    {
        Printf("Memory allocation error for %x bytes\n", dwSize);
        return(NULL);
    }

    DEBUG2("ReadProcessMemory(0x%x @ %p)\n", dwSize, pvAddr);

    if ( !ReadProcessMemory(ghCurrentProcess, pvAddr, pv, dwSize, &cRead) )
    {
        FreeMemory(pv);
        Printf("ReadProcessMemory error %x (%x@%p)\n",
               GetLastError(),
               dwSize,
               pvAddr);
        return(NULL);
    }

    if ( dwSize != ( DWORD ) cRead )
    {
        FreeMemory(pv);
        Printf("ReadProcessMemory size error - off by %x bytes\n",
               ( dwSize > ( DWORD ) cRead ) ?
               dwSize - ( DWORD ) cRead :
               ( DWORD ) cRead - dwSize );
        return(NULL);
    }

    return(pv);
}





VOID
FreeMemory(
    IN PVOID pv)

/*++

Routine Description:

    Frees memory returned by ReadMemory.

Arguments:

    pv - Address of debugger local memory to free.

Return Value:

    None.

--*/

{

    DEBUG1("HeapFree(%p)\n", pv);

    if ( NULL != pv )
    {
        if ( !HeapFree(GetProcessHeap(), 0, pv) )
        {
            Printf("Error %x freeing memory at %p\n", GetLastError(), pv);
        }
    }
}







#endif

/******************* EOF *********************/



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\debug.c ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    Domain Name System (DNS) Library

    Debug routines.

Author:

    Jim Gilroy (jamesg)    January 31, 1995

Revision History:

--*/


#include "local.h"


#define DNSDBG_CONTEXT_SWITCH_LOGGING   1


//
//  Debug globals
//

DNS_DEBUG_INFO  g_DnsDbgInfo = { 0 };

PDNS_DEBUG_INFO g_pDbgInfo = &g_DnsDbgInfo;

//  Redirected

BOOL    g_DbgRedirected = FALSE;

//
//  Debug flag -- exposed as pointer in dnslib.h
//
//  By default use DnsDebugFlag, but actual debug printing is
//  switched by *pDnsDebugFlag, which caller may point at local
//  flag if desired.
//

PDWORD  pDnsDebugFlag = (PDWORD)&g_DnsDbgInfo;

//
//  Note that in all functions below, we use the universal
//  check IS_DNSDBG_ON(), which is defined for debug AND retail.
//  Do NOT use any of the debug macros, as we want the code to
//  work equally well in retail versions of dnsapi.dll, so that
//  debug versions of calling modules can use these functions.
//

//
//  Print buffer sizes
//      - small default stack buffer
//      - large buffer on heap to handle any print
//
//  NOTE:  MUST have stack buffer of sufficient size to
//          handle any message we print on memory allocation
//          failure;  otherwise we get into the obvious loop
//          of alloc failure causing print, which causes attempted
//          alloc and another print
//

#define DNS_STACK_PRINT_BUFFER_LENGTH   (0x300)     // 768 covers 99%
#define DNS_HEAP_PRINT_BUFFER_LENGTH    (0x4000)    // 16K will cover anything



//
//  Public debug routines
//

VOID
Dns_Assert(
    IN      LPSTR           pszFile,
    IN      INT             LineNo,
    IN      LPSTR           pszExpr
    )
{
    DnsDbg_Printf(
        "ASSERTION FAILED: %s\n"
        "  %s, line %d\n",
        pszExpr,
        pszFile,
        LineNo );

    DnsDbg_Flush();

    //  always print to debugger, even if debugger print flag not set

    if ( ! IS_DNSDBG_ON( DEBUGGER ) )
    {
        DnsDbg_PrintfToDebugger(
            "ASSERTION FAILED: %s\n"
            "  %s, line %d\n",
            pszExpr,
            pszFile,
            LineNo );
    }

    if ( IS_DNSDBG_ON( BREAKPOINTS ) )
    {
        DebugBreak();
    }
    else
    {
        DnsDbg_Printf( "Skipping DNS_ASSERT, debug flag = %lx\n", *pDnsDebugFlag );
    }
}



#if 0
typedef struct _DnsDebugInit
{
    DWORD       Flag;
    PSTR        pszFlagFile;
    PDWORD      pDebugFlag;
    PSTR        pszLogFile;
    DWORD       WrapSize;
    BOOL        fUseGlobalFile;
    BOOL        fUseGlobalFlag;
    BOOL        fSetGlobals;
}
DNS_DEBUG_INIT, *PDNS_DEBUG_INIT;
#endif


VOID
Dns_StartDebugEx(
    IN      DWORD           DebugFlag,
    IN      PSTR            pszFlagFile,
    IN OUT  PDWORD          pDebugFlag,
    IN      PSTR            pszLogFile,
    IN      DWORD           WrapSize,
    IN      BOOL            fUseGlobalFile,
    IN      BOOL            fUseGlobalFlag,
    IN      BOOL            fSetGlobals
    )
/*++

Routine Description:

    Initialize debugging.
    Only current task is to read and set debug flags.

Arguments:

    includes:
        dwFlag      -- debug flags
        pszFlagFile -- name of file containing debug flags
        pdwFlag     -- ptr to DWORD to receive debug flags
        pszLogFile  -- log file name
        dwWrapSize  -- log file wrap size

Return Value:

    None.

--*/
{
    HANDLE  hfile;
    DWORD   freadFlag = FALSE;
    BOOL    fretry = FALSE;
    CHAR    prevName[ MAX_PATH+10 ];
    DWORD   debugFlag;

    PDNS_DEBUG_INFO     pinfoGlobal = NULL;

    //
    //  use external flag?
    //      - save ptr to it
    //
    //  allow use of external flag so callers -- eg. DNS server --
    //  can easily manipulate flag during run time and still keep
    //  their checking macros simple
    //

    if ( pDebugFlag )
    {
        pDnsDebugFlag       = pDebugFlag;
        g_DnsDbgInfo.Flag   = *pDnsDebugFlag;
    }

    //
    //  get piggyback info
    //

    if ( fUseGlobalFlag || fUseGlobalFile )
    {
        pinfoGlobal = DnsApiSetDebugGlobals( NULL );
    }

    //
    //  skip debug flag setup if piggybacking
    //      - use the existing flag value
    //      - but not safe to grab pointer which
    //          may go away on dll unload
    //
    //  DCR:  safe way to use existing flags?
    //  DCR:  need to be able to get "last" debug flag set
    //      without blowing up
    //

    if ( fUseGlobalFlag &&
         pinfoGlobal &&
         pinfoGlobal->hFile )
    {
        goto Done;
    }

    //
    //  setup debug flag
    //

    debugFlag = DebugFlag;
    if ( debugFlag )
    {
        freadFlag = TRUE;
    }
    else if ( pszFlagFile )
    {
        //  read debug flag in file

        hfile = CreateFile(
                    pszFlagFile,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );
        if ( hfile == (HANDLE)INVALID_HANDLE_VALUE )
        {
            //  if file specified and not found, then quit if explicit value
            //  not given

            if ( debugFlag == 0 )
            {
                return;
            }
        }
        else
        {
            DWORD bytesRead;
            CHAR buffer[100];

            RtlZeroMemory( buffer, sizeof(buffer) );

            if ( ReadFile( hfile, buffer, 100, &bytesRead, NULL ) )
            {
                buffer[bytesRead] = '\0';
                debugFlag = strtoul( buffer, NULL, 16 );
                freadFlag = TRUE;
            }
            else
            {
                DnsDbg_Printf( "read file failed: %ld\n", GetLastError( ) );
                if ( debugFlag == 0 )
                {
                    CloseHandle( hfile );
                    return;
                }
            }
            CloseHandle( hfile );
        }
    }

    //
    //  save any flag read
    //      - reset global (internal or external) to it
    //

    if ( freadFlag )
    {
        g_DnsDbgInfo.Flag   = debugFlag;
        *pDnsDebugFlag      = debugFlag;
    }

    //
    //  skip debug file open if piggybacking
    //
    //  two levels
    //      - only using file
    //      - using file and debug flags

    if ( fUseGlobalFile &&
         pinfoGlobal &&
         pinfoGlobal->hFile )
    {
        goto Done;
    }

    //
    //  open debug logfile
    //

    fretry = 0;

    while ( pszLogFile )
    {
        PCHAR   pnameBuf = g_DnsDbgInfo.FileName;

        //  heap may not be initialized, copy filename to static buffer
        //
        //  note:  if we fail on first pass we try again but open directly
        //      at file system root;  given simply filename, applications
        //      run from system32 and services (resolver) will attempt open
        //      in system32 and some (resolver) do not by default have
        //      permissions to create files there

        if ( fretry == 0 )
        {
            strncpy( pnameBuf, pszLogFile, MAX_PATH );
        }
        else
        {
            pnameBuf[0] = '\\';
            strncpy( pnameBuf+1, pszLogFile, MAX_PATH-1 );
        }
        pnameBuf[MAX_PATH] = 0;

#if 0
        //      jeff changes -- don't have time to fix up now
        //      file wrapping should handle this sort of thing

        //
        //  Save off the current copy as ".prev"
        //

        strcpy( prevName, DnsDebugFileName );
        strcat( prevName, ".prev" );

        MoveFileEx(
            DnsDebugFileName,
            prevName,
            MOVEFILE_REPLACE_EXISTING );

        DnsDebugFileHandle = CreateFile(
                                DnsDebugFileName,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ,
                                NULL,
                                CREATE_ALWAYS,
                                0,
                                NULL
                                );
#endif
        hfile = CreateFile(
                    pnameBuf,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ,
                    NULL,
                    CREATE_ALWAYS,
                    0,
                    NULL
                    );

        if ( !hfile && !fretry )
        {
            fretry++;
            continue;
        }

        g_DnsDbgInfo.hFile = hfile;
        g_DnsDbgInfo.FileWrapSize = WrapSize;
        break;
    }

    //
    //  initialize console
    //

    if ( IS_DNSDBG_ON( CONSOLE ) )
    {
        CONSOLE_SCREEN_BUFFER_INFO csbi;
        COORD coord;

        AllocConsole();
        GetConsoleScreenBufferInfo(
            GetStdHandle(STD_OUTPUT_HANDLE),
            &csbi
            );
        coord.X = (SHORT)(csbi.srWindow.Right - csbi.srWindow.Left + 1);
        coord.Y = (SHORT)((csbi.srWindow.Bottom - csbi.srWindow.Top + 1) * 20);
        SetConsoleScreenBufferSize(
            GetStdHandle(STD_OUTPUT_HANDLE),
            coord
            );

        g_DnsDbgInfo.fConsole = TRUE;
    }

    //
    //  set "global" debug file info
    //
    //  dnsapi.dll serves as storage for common dns client
    //  debug file if that is desired;  this lets applications
    //  push all dns debug output into a single file
    //
    //  currently push both file and debug flag value
    //  note, we don't push debug file ptr as don't know
    //  whose memory becomes invalid first
    //

    if ( fSetGlobals && g_DnsDbgInfo.hFile )
    {
        DnsApiSetDebugGlobals( 
            &g_DnsDbgInfo    // set our info as global
            );
    }

Done:

    //
    //  use "global" (dnsapi.dll) debugging
    //      - copy in our info if no existing info
    //      - set to use global info blob
    //
    //  two levels
    //      - only using file
    //      - using file and debug flags

    if ( fUseGlobalFile &&
         pinfoGlobal )
    {
        //  copy in our new info if no global info exists

        if ( !pinfoGlobal->hFile &&
             g_DnsDbgInfo.hFile )
        {
            DnsApiSetDebugGlobals( &g_DnsDbgInfo );
        }

        //  point at global info

        g_pDbgInfo = pinfoGlobal;
        g_DbgRedirected = TRUE;

        if ( fUseGlobalFlag )
        {
            pDnsDebugFlag = (PDWORD) pinfoGlobal;
        }

        //  avoid double cleanup
        //      - clear the handle in your modules blob

        g_DnsDbgInfo.hFile = NULL;
    }

    //
    //  use print locking for debug locking
    //

    DnsPrint_InitLocking( NULL );

    DNSDBG( ANY, (
        "Initialized debugging:\n"
        "\tpDbgInfo         %p\n"
        "\t&DnsDbgInfo      %p\n"
        "\tfile (param)     %s\n"
        "\thFile            %p\n"
        "\tpDbgInfo->Flag   %08x\n"
        "\tpDnsDebugFlag    %p\n"
        "\t*pDnsDebugFlag   %08x\n"
        "DnsLib compiled on %s at %s\n",
        g_pDbgInfo,
        &g_DnsDbgInfo,
        pszLogFile,
        g_pDbgInfo->hFile,
        g_pDbgInfo->Flag,
        pDnsDebugFlag,
        *pDnsDebugFlag,
        __DATE__,
        __TIME__  ));

}   //  Dns_StartDebug



#if 0
VOID
Dns_StartDebugEx(
    IN      DWORD           dwFlag,
    IN      PSTR            pszFlagFile,
    IN OUT  PDWORD          pdwFlag,
    IN      PSTR            pszLogFile,
    IN      DWORD           dwWrapSize,
    IN      BOOL            fUseGlobalFile,
    IN      BOOL            fUseGlobalFlag,
    IN      BOOL            fSetGlobals
    )
/*++

Routine Description:

    Initialize debugging.
    Only current task is to read and set debug flags.

Arguments:

    dwFlag      -- debug flags
    pszFlagFile -- name of file containing debug flags
    pdwFlag     -- ptr to DWORD to receive debug flags
    pszLogFile  -- log file name
    dwWrapSize  -- log file wrap size

Return Value:

    None.

--*/
{
    DNS_DEBUG_INIT  info;

    RtlZeroMemory
        &info,
        sizeof(info) );

    info.pszFlagFile  = pszFlagFile;
    info.DebugFlags   = dwFlag;
    info.pDebugFlags  = pdwFlag;
    info.pszLogFile   = pszLogFile;
    info.dwWrapSize   = dwWrapSize;

    info.fUseGlobalFile = fUseGlobalFile;
    info.fUseGlobalFlag = fUseGlobalFlag;
    info.fSetGlobals    = fSetGlobals;

    privateStartDebug( &info );
}
#endif



VOID
Dns_StartDebug(
    IN      DWORD           dwFlag,
    IN      PSTR            pszFlagFile,
    IN OUT  PDWORD          pdwFlag,
    IN      PSTR            pszLogFile,
    IN      DWORD           dwWrapSize
    )
/*++

Routine Description:

    Initialize debugging.
    Only current task is to read and set debug flags.

Arguments:

    dwFlag      -- debug flags
    pszFlagFile -- name of file containing debug flags
    pdwFlag     -- ptr to DWORD to receive debug flags
    pszLogFile  -- log file name
    dwWrapSize  -- log file wrap size

Return Value:

    None.

--*/
{
    Dns_StartDebugEx(
            dwFlag,
            pszFlagFile,
            pdwFlag,
            pszLogFile,
            dwWrapSize,
            FALSE,
            FALSE,
            FALSE );
}



VOID
Dns_EndDebug(
    VOID
    )
/*++

Routine Description:

    Terminate DNS debugging for shutdown.

    Close debug file.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //  close file
    //      - but only your dnslib instance
    //      - shared global file is closed by dnsapi

    if ( g_DnsDbgInfo.hFile )
    {
        CloseHandle( g_DnsDbgInfo.hFile );
        g_DnsDbgInfo.hFile = NULL;
    }
}



PDNS_DEBUG_INFO
Dns_SetDebugGlobals(
    IN OUT  PDNS_DEBUG_INFO pInfo
    )
/*++

Routine Description:

    Exposure of debug globals.

    The purpose of this is to allow dnsapi.dll to use it's globals
    to allow common debug file.  I'm using one routine for both
    get and set to mimize the interfaces.

    Note however, that this is NOT the routine that routines in
    this module use to get cross-module debugging.  They MUST call
    the actual dnsapi.dll routine so that they are attaching
    to the dnsapi's dnslib debugging globls not the ones with the
    dnslib statically linked into their module.

Arguments:

    pInfo -- local info to use as global info

Return Value:

    Ptr to global info

--*/
{
    //
    //  verify valid info coming in
    //      - must have file handle
    //


    //
    //  Implementation note:
    //
    //  There are several issues to deal with when doing this
    //      - multiple redirection
    //      getting everyone to point at same blob
    //      solutions:
    //          - either double pointer (they read dnsapi.dll
    //          pointer
    //          - copy into dnsapi.dll the info
    //      - locking
    //          - broad scale print of structs
    //      - cleanup
    //          - no double close of handle
    //          - memory sections disappearing while some dll
    //          or exe still printing
    //
    //  Approachs:
    //      1) redirect blob pointer
    //          blob could expand to include actual print locks
    //      2) copy info into single blob
    //      3) expose debug routines
    //
    //
    //  Perhaps best approach might be to expose the dnsapi.dll
    //  printing
    //      - solves locking (at detail level), doesn't prevent breakup
    //          of high level printing unless it also redirected
    //      - can be done at the private level after parsing to va_arg
    //      - solves all the cleanup
    //      - they can be dumb stubs in non-debug binary, and dnslib
    //      routines can default to self if can't call dnsapi.dll
    //      routines
    //
    //  Then redirection is simply
    //      - yes i use it -- redirection on each use
    //      - i want my file (and params) to BE used
    //

#if 1
    //
    //  copy over "i-want-to-be-global" callers context
    //
    //  note:  we're in dnsapi.dll here and should always be
    //      pointed at our own context -- we can change that
    //      later if desired
    //
    //  note
    //      - lock during copy to be safe
    //      - don't leak existing handle
    //      - protect global handle from double close
    //     

    if ( pInfo )
    {
        DnsPrint_Lock();

        DNS_ASSERT( g_pDbgInfo == &g_DnsDbgInfo );

        if ( pInfo->hFile )
        {
            HANDLE  htemp = g_pDbgInfo->hFile;

            RtlCopyMemory(
                & g_DnsDbgInfo,
                pInfo,
                sizeof(*pInfo) );

            g_pDbgInfo = &g_DnsDbgInfo;
            pDnsDebugFlag = (PDWORD)&g_DnsDbgInfo;

            CloseHandle( htemp );
        }
        DnsPrint_Unlock();
    }
#else

    //
    //  point dnsapi.dll debugging global at this context
    //  which becomes "global"
    //  note:  essential this is last writer wins, but this
    //      should be fine for our purpuse (dnsup and resolver)
    //      as these processes init the debug after the
    //      dll loads
    //
    //  problem with this approach is that folks redirected
    //      onto dnsapi.dll do not get new info when it is
    //      redirected (into dnsup)

    if ( pInfo && pInfo->hFile )
    {
        g_pDbgInfo        = pInfo;
        pDnsDebugFlag   = (PDWORD)pInfo;
    }
#endif

    return  g_pDbgInfo;
}



#if 0
VOID
privateSyncGlobalDebug(
    VOID
    )
/*++

Routine Description:

    Sync up with global debug.

    Get dnslib debugging in line with "global" debugging if
    that is desired for this dnslib instance.

Arguments:

    None.

Return Value:

    None

--*/
{
    if ( !g_DbgRedirected )
    {
        return;
    }

    //  sync with global values
}
#endif



VOID
DnsDbg_WrapLogFile(
    VOID
    )
/*++

Routine Description:

    Wrap the log file.

Arguments:

    None.

Return Value:

    None.

--*/
{
    CHAR   backupName[ MAX_PATH+10 ];

    FlushFileBuffers( g_pDbgInfo->hFile );
    CloseHandle( g_pDbgInfo->hFile );

    strcpy( backupName, g_pDbgInfo->FileName );

    if ( g_pDbgInfo->FileWrapCount == 0 )
    {
        strcat( backupName, ".first" );
    }
    else
    {
        strcat( backupName, ".last" );
    }
    MoveFileEx(
        g_pDbgInfo->FileName,
        backupName,
        MOVEFILE_REPLACE_EXISTING
        );

    g_pDbgInfo->hFile = CreateFile(
                            g_pDbgInfo->FileName,
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ,
                            NULL,
                            CREATE_ALWAYS,
                            0,
                            NULL
                            );
    g_pDbgInfo->FileWrapCount++;
    g_pDbgInfo->FileCurrentSize = 0;
}



VOID
privateDnsDebugPrint(
    IN      PBYTE           pOutputBuffer,
    IN      BOOL            fPrintContext
    )
/*++

Routine Description:

    Private DNS debug print that does actual print.

    May print to any of
        - debugger
        - console window
        - debug log file

Arguments:

    pOutputBuffer -- bytes to print

    fPrintContext
        - TRUE to print thread context
        - FALSE otherwise

Return Value:

    None.

--*/
{
    DWORD           length;
    BOOL            ret;

    //
    //  DCR:  nice to automatically shut down console print when debugging
    //      it would be cool to be able to have all flags on, and detect
    //      when in ntsd, so that we don't get duplicated output
    //

    //
    //  lock print to keep atomic even during wrap
    //      - note use Print lock, which exists even in retail builds
    //      Dbg lock is defined away
    //

    DnsPrint_Lock();

    //
    //  catch and timestamp thread context switches
    //

    if ( fPrintContext )
    {
        DWORD       threadId = GetCurrentThreadId();
        BOOL        fcontextSwitch = (g_pDbgInfo->LastThreadId != threadId);
        SYSTEMTIME  st;
        BOOL        fdoPrint = FALSE;

        //  get time
        //      - if have context switch
        //      - or putting in debug timestamps
        //
        //  DCR:  maybe have global that set to put in timestamps and
        //      can set interval
        //
        //  DCR:  lock safe timestamps
        //      better would be "lock-safe" timestamps that are printed
        //      only when take the print lock -- then they would never
        //      interrupt the a multi-part print
        //      one way might be to test recursive depth of print CS
        //      otherwise must change to lock that includes this
        //      code

        if ( fcontextSwitch
                ||
            (pDnsDebugFlag && (*pDnsDebugFlag & DNS_DBG_TIMESTAMP)) )
        {
            GetLocalTime( &st );

            if ( g_pDbgInfo->LastSecond != st.wSecond )
            {
                fdoPrint = TRUE;
            }
        }

        if ( fcontextSwitch || fdoPrint )
        {
            CHAR    printBuffer[ 200 ];
            DWORD   length;

            length = sprintf(
                        printBuffer,
                        fcontextSwitch ?
                            "\n%02d:%02d:%02d:%03d DBG switch from thread %X to thread %X\n" :
                            "%02d:%02d:%02d:%03d DBG tick\n",
                        st.wHour,
                        st.wMinute,
                        st.wSecond,
                        st.wMilliseconds,
                        g_pDbgInfo->LastThreadId,
                        threadId );

            g_pDbgInfo->LastSecond = st.wSecond;
            g_pDbgInfo->LastThreadId = threadId;

            //  print context
            //      - suppress context even through thread test
            //      would break recursion
    
            privateDnsDebugPrint(
                printBuffer,
                FALSE       // suppress context
                );
        }
    }

    //
    //  output -- to debugger, console, file
    //

    if ( IS_DNSDBG_ON( DEBUGGER ) )
    {
        OutputDebugString( pOutputBuffer );
    }

    if ( IS_DNSDBG_ON( CONSOLE ) )
    {
        if ( g_pDbgInfo->fConsole )
        {
            length = strlen( pOutputBuffer );

            ret = WriteFile(
                        GetStdHandle(STD_OUTPUT_HANDLE),
                        (PVOID) pOutputBuffer,
                        length,
                        &length,
                        NULL
                        );
#if 0
            if ( !ret )
            {
                DnsDbg_PrintfToDebugger(
                    "DnsDbg_Printf: console WriteFile failed: %ld\n",
                    GetLastError() );
            }
#endif
        }
    }

    //
    //  write to debug log
    //

    if ( IS_DNSDBG_ON( FILE ) )
    {
        if ( g_pDbgInfo->hFile != INVALID_HANDLE_VALUE )
        {
            length = strlen( pOutputBuffer );

            ret = WriteFile(
                        g_pDbgInfo->hFile,
                        (PVOID) pOutputBuffer,
                        length,
                        &length,
                        NULL
                        );
            if ( !ret )
            {
                DnsDbg_PrintfToDebugger(
                    "DnsDbg_Printf: file WriteFile failed: %ld\n",
                    GetLastError() );
            }

            //
            //  if wrapping debug log file
            //      - move current log to backup file
            //          <file>.first on first wrap
            //          <file>.last on subsequent wraps
            //      - reopen current file name
            //

            g_pDbgInfo->FileCurrentSize += length;

            if ( g_pDbgInfo->FileWrapSize  &&
                 g_pDbgInfo->FileWrapSize <= g_pDbgInfo->FileCurrentSize )
            {
                DnsDbg_WrapLogFile();
            }
            else if ( IS_DNSDBG_ON( FLUSH ) )
            {
                FlushFileBuffers( g_pDbgInfo->hFile );
            }
        }
    }

    DnsPrint_Unlock();

}   //  privateDnsDebugPrint



VOID
privateFormatAndPrintBuffer(
    IN      LPSTR           Format,
    IN      va_list         ArgList
    )
/*++

Routine Description:

    Arguments to formatted buffer print.

    This helper routine exists to avoid duplicating buffer
    overflow logic in DnsDbg_Printf() and DnsDbg_PrintRoutine()

    The overflow logic is required because the default stack size
    has been chopped down in whistler making is easy to generate
    stack expansion exceptions under stress.  And of course this
    means the stress guys send me these B.S. stress failures.

    Solution is to put a small buffer on the stack for perf, then
    allocate a larger buffer if the print doesn't fit into the
    stack buffer.

Arguments:

    Format -- standard C format string

    ArgList -- standard arg list

Return Value:

    None.

--*/
{
    CHAR    stackBuffer[ DNS_STACK_PRINT_BUFFER_LENGTH ];
    ULONG   bufLength;
    DWORD   lastError;
    INT     count;
    PCHAR   pprintBuffer;
    PCHAR   pheapBuffer = NULL;

    //
    //  save last error so any WriteFile() failures don't mess it up
    //

    lastError = GetLastError();

    //
    //  write formatted print buffer
    //
    //      - first try stack buffer
    //      - if fails, try heap buffer
    //      - use best, always NULL terminate
    //

    bufLength = DNS_STACK_PRINT_BUFFER_LENGTH;
    pprintBuffer = stackBuffer;

    do
    {
        count = _vsnprintf(
                    pprintBuffer,
                    bufLength-1,
                    Format,
                    ArgList );
    
        pprintBuffer[ bufLength-1 ] = 0;

        if ( count > 0 || pheapBuffer )
        {
            break;
        }

        //  try again with heap buffer

        pheapBuffer = ALLOCATE_HEAP( DNS_HEAP_PRINT_BUFFER_LENGTH );
        if ( !pheapBuffer )
        {
            break;
        }
        pprintBuffer = pheapBuffer;
        bufLength = DNS_HEAP_PRINT_BUFFER_LENGTH;
    }
    while( 1 );

    va_end( ArgList );

    //  do the real print

    privateDnsDebugPrint( pprintBuffer, TRUE );

    if ( pheapBuffer )
    {
        FREE_HEAP( pheapBuffer );
    }

    //  restore LastError() if changed

    if ( lastError != GetLastError() )
    {
        SetLastError( lastError );
    }
}



VOID
DnsDbg_Printf(
    IN      LPSTR           Format,
    ...
    )
/*++

Routine Description:

    DNS debug print with printf semantics.

    May print to any of
        - debugger
        - console window
        - debug log file

Arguments:

    pContext -- dummny context to match signature of PRINT_ROUTINE function

    Format -- standard C format string

    ... -- standard arg list

Return Value:

    None.

--*/
{
    va_list arglist;

    va_start( arglist, Format );

    privateFormatAndPrintBuffer(
        Format,
        arglist );

#if 0
    va_list arglist;
    CHAR    outputBuffer[ DNS_PRINT_BUFFER_LENGTH+1 ];

    va_start( arglist, Format );

    vsnprintf( outputBuffer, DNS_PRINT_BUFFER_LENGTH, Format, arglist );

    va_end( arglist );

    outputBuffer[ DNS_PRINT_BUFFER_LENGTH ] = 0;

    privateDnsDebugPrint( outputBuffer, TRUE );
#endif
}



VOID
DnsDbg_PrintRoutine(
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      LPSTR           Format,
    ...
    )
/*++

Routine Description:

    DNS debug print with PRINT_ROUTINE semantics.

Arguments:

    pContext -- dummny context to match signature of PRINT_ROUTINE function

    Format -- standard C format string

    ... -- standard arg list

Return Value:

    None.

--*/
{
    va_list arglist;

    va_start( arglist, Format );

    privateFormatAndPrintBuffer(
        Format,
        arglist );
}



VOID
DnsDbg_Flush(
    VOID
    )
/*++

Routine Description:

    Flushes DNS debug printing to disk.

Arguments:

    None

Return Value:

    None.

--*/
{
    FlushFileBuffers( g_pDbgInfo->hFile );
}



VOID
DnsDbg_PrintfToDebugger(
    IN      LPSTR           Format,
    ...
    )
/*++

Routine Description:

    Print to debugger.  Win95 has no DbgPrint().

Arguments:

    Format -- standard C format string

    ... -- standard arg list

Return Value:

    None.

--*/
{
    va_list arglist;
    CHAR    outputBuffer[ DNS_STACK_PRINT_BUFFER_LENGTH ];
    ULONG   length;
    BOOL    ret;

    va_start( arglist, Format );

    _vsnprintf( outputBuffer, DNS_STACK_PRINT_BUFFER_LENGTH, Format, arglist );

    va_end( arglist );

    outputBuffer[ DNS_STACK_PRINT_BUFFER_LENGTH ] = 0;

    OutputDebugString( outputBuffer );
}



//
//  Debug utilities
//
//  Other debug routines are coded generically as print routines (print.c)
//  and are macroed to debug routines by choosing DnsDbg_Printf() as the
//  print function.
//

#if DBG

VOID
DnsDbg_CSEnter(
    IN      PCRITICAL_SECTION   pLock,
    IN      LPSTR               pszLockName,
    IN      LPSTR               pszFile,
    IN      INT                 LineNo
    )
{
    DnsDbg_Printf(
        "\nENTERING %s lock %p in %s, line %d.\n",
        pszLockName,
        pLock,
        pszFile,
        LineNo );
    EnterCriticalSection( pLock );
    DnsDbg_Printf(
        "\nHOLDING %s lock %p in %s, line %d.\n",
        pszLockName,
        pLock,
        pszFile,
        LineNo );
}


VOID
DnsDbg_CSLeave(
    IN      PCRITICAL_SECTION   pLock,
    IN      LPSTR               pszLockName,
    IN      LPSTR               pszFile,
    IN      INT                 LineNo
    )
{
    DnsDbg_Printf(
        "\nRELEASING %s lock %p in %s, line %d.\n",
        pszLockName,
        pLock,
        pszFile,
        LineNo );
    LeaveCriticalSection( pLock );
}

#endif

//
//  End of debug.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsexts\dnsexts.cxx ===
/*******************************************************************
*
*    File        : dnsexts.cxx
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 7/14/1998
*    Description : dnsext.dll debugger extension.
*
*    Revisions   : <date> <name> <description>
*******************************************************************/



#ifndef DNSEXTS_CXX
#define DNSEXTS_CXX



// include //
// #include <dns.h>
#include "common.h"
#include "dump.hxx"
#include "util.hxx"
#include <ntverp.h>
#include <string.h>



// defines //

// types //


// global variables //

PNTSD_EXTENSION_APIS glpExtensionApis=NULL;
LPSTR glpArgumentString=NULL;
HANDLE ghCurrentProcess=NULL;
LPVOID gCurrentAllocation=NULL;

// prototypes //
INT GetDumpTableIndex(LPSTR szName);
DWORD ExceptionHandler(DWORD dwException);



// functions //

/*+++
Function   : DllAttach
Description: initializes the library upon attach
Parameters : none.
Return     :
Remarks    : none.
---*/
BOOL DllAttach(void)
{
   INT i=0;
   BOOL bRet=TRUE;

   //
   // Nothing to do yet
   //
   return bRet;
}


/*+++
Function   : DllDetach
Description: initializes the library upon attach
Parameters : none.
Return     :
Remarks    : none.
---*/
BOOL DllDetach(void)
{
   BOOL bRet=TRUE;

   //
   // Nothing to do yet
   //

   return bRet;
}


/*+++
Function   : ExceptionHandler
Description:
Parameters :
Return     :
Remarks    : none.
---*/
DWORD ExceptionHandler(DWORD dwException){

   Printf("Exception 0x%x: dnsexts exception failure\n", dwException);
   CleanMemory();

   return EXCEPTION_EXECUTE_HANDLER;
}





/*+++
Function   : help
Description: dump usage
Parameters : as specified in ntdsexts.h
Return     :
Remarks    : none.
---*/
PNTSD_EXTENSION_ROUTINE (help)(
                               HANDLE hCurrentProcess,
                               HANDLE hCurrentThread,
                               DWORD dwCurrentPc,
                               PNTSD_EXTENSION_APIS lpExtensionApis,
                               LPSTR lpArgumentString
                               )
{

   ASSIGN_NTSDEXTS_GLOBAL(lpExtensionApis, lpArgumentString, hCurrentProcess);
   Printf("dnsexts usage (version %s):\n", VER_PRODUCTVERSION_STR);
   Printf(" help: this help screen.\n");
   Printf(" dump <DATATYPE> <ADDRESS>: dumps structure at <address> in <DATATYPE> format.\n");
   Printf("---\n");

   return 0;
}



/*+++
Function   : GetDumpTableIndex
Description: Get index into dump table if the entry by that name exist
Parameters : szName: function name to find
Return     : -1 if failed, otherwise index value
Remarks    : none.
---*/
INT GetDumpTableIndex(LPSTR szName)
{
   INT i=0;

   for(i=0;i<gcbDumpTable; i++){
      if(!_stricmp(szName,gfDumpTable[i].szName)){
         return i;
      }
   }

   return -1;
}

/*+++
Function   : dump
Description: dumps give data structure
Parameters :  as specified in ntdsexts.h
Return     :
Remarks    : command line gives structure name & hex value
---*/
PNTSD_EXTENSION_ROUTINE (dump)(
                               HANDLE hCurrentProcess,
                               HANDLE hCurrentThread,
                               DWORD dwCurrentPc,
                               PNTSD_EXTENSION_APIS lpExtensionApis,
                               LPSTR lpArgumentString
                               )
{


   __try{

   INT i=0;       // generic index
   //
   // make interface availabe globally
   //

   ASSIGN_NTSDEXTS_GLOBAL(lpExtensionApis, lpArgumentString, hCurrentProcess);

   DEBUG1("DEBUG: Argstring=[%s]\n", lpArgumentString);
   //
   // process argument string
   //


   //
   // Format: DATATYPE ADDRESS
   //
   LPVOID lpVoid=0x0;
   const LPSTR cDelimiters=" \t";
   LPSTR szDataType = NULL, szAddress=NULL;

   if(NULL != (szDataType = strtok(lpArgumentString, cDelimiters)) &&
      NULL != (szAddress = strtok(NULL, cDelimiters)) &&
      NULL == strtok(NULL, cDelimiters) ||
      ((szDataType != NULL && szAddress == NULL && !_stricmp(szDataType,"HELP")))){
      //
      // Got all arguments
      //
      if(szAddress != NULL){
         lpVoid = (LPVOID)GetExpr(szAddress);
      }

      //
      // BUGBUG: DEBUG!
      //
      DEBUG1("DEBUG: szDataType=[%s]\n", szDataType);
      DEBUG1("DEBUG: szAddress=[%s]\n", szAddress);
      DEBUG1("DEBUG: lpVoid =[%p]\n", lpVoid);
      //
      // find in function table & call function
      //

      if(0 > (i = GetDumpTableIndex(szDataType))){
         Printf("Usage error: Cannot find function %s. Type dnsexts.dump help.\n", szDataType);
      }
      else{
         //
         // call function
         //
         BOOL bRet=TRUE;
         bRet = gfDumpTable[i].function(lpVoid);
         if(!bRet){
            Printf("Error: function %s failed\n", szDataType);
         }
      }
   }
   else{
      //
      // error
      //
      Printf("Usage error (2). Type dnsexts.dump help.\n");
   }


   }  // try-except
   __except(ExceptionHandler(GetExceptionCode())){
      Printf("Aborting dump funtion\n");
   }


   return 0;
}




////////////////////// ENTRY POINT //////////////////////

/*+++
Function   : DllMain
Description: <<<DLL entry point>>>
Parameters : standard DllMain
Return     : init success bool
Remarks    : none.
---*/





BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD  ul_reason_for_call,
                      LPVOID lpReserved)
{

   BOOL bRet = TRUE;

   switch( ul_reason_for_call ) {
   case DLL_PROCESS_ATTACH:
      bRet = DllAttach();
      break;

   case DLL_THREAD_ATTACH:
      break;

   case DLL_THREAD_DETACH:
      break;

   case DLL_PROCESS_DETACH:
      bRet = DllDetach();
      break;

   }


   return bRet;
}













#endif

/******************* EOF *********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\addr.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    addr.c

Abstract:

    Domain Name System (DNS) Library

    IP address routines

Author:

    Jim Gilroy (jamesg)     June 2000

Revision History:

--*/


#include "local.h"
#include "ws2atm.h"     // ATM addressing


//
//  Address info table
//

FAMILY_INFO AddrFamilyTable[] =
{
    AF_INET,
        DNS_TYPE_A,
        sizeof(IP4_ADDRESS),
        sizeof(SOCKADDR_IN),
        (DWORD) FIELD_OFFSET( SOCKADDR_IN, sin_addr ),
        //sizeof(DWORD),  

    AF_INET6,
        DNS_TYPE_AAAA,
        sizeof(IP6_ADDRESS),
        sizeof(SOCKADDR_IN6),
        (DWORD) FIELD_OFFSET( SOCKADDR_IN6, sin6_addr ),
        //(2 * sizeof(DWORD)),

    AF_ATM,
        DNS_TYPE_ATMA,
        sizeof(ATM_ADDRESS),
        sizeof(SOCKADDR_ATM),
        sizeof(DWORD),
        (DWORD) FIELD_OFFSET( SOCKADDR_ATM, satm_number ),
};



PFAMILY_INFO
FamilyInfo_GetForFamily(
    IN      DWORD           Family
    )
/*++

Routine Description:

    Get address family info for family.

Arguments:

    Family -- address family

Return Value:

    Ptr to address family info for family.
    NULL if family is unknown.

--*/
{
    PFAMILY_INFO    pinfo = NULL;

    //  switch on type

    if ( Family == AF_INET )
    {
        pinfo = pFamilyInfoIp4;
    }
    else if ( Family == AF_INET6 )
    {
        pinfo = pFamilyInfoIp6;
    }
    else if ( Family == AF_ATM )
    {
        pinfo = pFamilyInfoAtm;
    }

    return  pinfo;
}



//
//  IPUNION routines
//

BOOL
Dns_EqualIpUnion(
    IN      PIP_UNION       pIp1,
    IN      PIP_UNION       pIp2
    )
/*++

Routine Description:

    Test IP union for equality

Arguments:

    pIp1 -- IP address union

    pIp2 -- IP address union

Return Value:

    TRUE if Ip1 and Ip2 equal.
    FALSE otherwise.

--*/
{
    //
    //  DCR:  when stamp flat, can make this memory compare
    //

    //  IP4 match?

    if ( IPUNION_IS_IP4(pIp1) )
    {
        if ( IPUNION_IS_IP4(pIp2) &&
             IPUNION_GET_IP4(pIp1) == IPUNION_GET_IP4(pIp2) )
        {
            return( TRUE );
        }
    }

    //  IP6 match?

    else
    {
        if ( IPUNION_IS_IP6(pIp2) &&
             RtlEqualMemory(
                IPUNION_IP6_PTR(pIp1),
                IPUNION_IP6_PTR(pIp2),
                sizeof(IP6_ADDRESS) ) )
        {
            return( TRUE );
        }
    }

    return( FALSE );
}



//
//  Sockaddr
//

IP6_ADDRESS
Ip6AddressFromSockaddr(
    IN      PSOCKADDR       pSockaddr
    )
/*++

Routine Description:

    Get IP6 address from sockaddr.

    If IP4 sockaddr, IP6 address is mapped.

Arguments:

    pSockaddr -- any kind of sockaddr
        must have actual length for sockaddr family

Return Value:

    IP6 address corresponding to sockaddr.
    If IP4 sockaddr it's IP4_MAPPED address.
    If not IP4 or IP6 sockaddr IP6 addresss is zero.

--*/
{
    IP6_ADDRESS ip6;

    //
    //  switch on family
    //      - IP6 gets copy
    //      - IP4 gets IP4_MAPPED
    //      - bogus gets zero
    //

    switch ( pSockaddr->sa_family )
    {
    case AF_INET:

        IP6_SET_ADDR_V4MAPPED(
            & ip6,
            ((PSOCKADDR_IN)pSockaddr)->sin_addr.s_addr );
        break;

    case AF_INET6:

        RtlCopyMemory(
            &ip6,
            & ((PSOCKADDR_IN6)pSockaddr)->sin6_addr,
            sizeof(IP6_ADDRESS) );
        break;

    default:

        RtlZeroMemory(
            &ip6,
            sizeof(IP6_ADDRESS) );
        break;
    }

    return  ip6;
}



VOID
InitSockaddrWithIp6Address(
    OUT     PSOCKADDR       pSockaddr,
    IN      IP6_ADDRESS     Ip6Addr,
    IN      WORD            Port
    )
/*++

Routine Description:

    Write IP6 address (straight 6 or v4 mapped) to sockaddr.

Arguments:

    pSockaddr -- ptr to sockaddr to write to;
        must be at least size of SOCKADDR_IN6

    Ip6Addr -- IP6 addresss being written

    Port -- port in net byte order

Return Value:

    None

--*/
{
    //  zero

    RtlZeroMemory(
        pSockaddr,
        sizeof(SOCKADDR_IN6) );
        
    //
    //  determine whether IP6 or IP4
    //

    if ( IP6_IS_ADDR_V4MAPPED( &Ip6Addr ) )
    {
        PSOCKADDR_IN    psa = (PSOCKADDR_IN) pSockaddr;

        psa->sin_family = AF_INET;
        psa->sin_port   = Port;

        psa->sin_addr.s_addr = IP6_GET_V4_ADDR( &Ip6Addr );
    }
    else    // IP6
    {
        PSOCKADDR_IN6   psa = (PSOCKADDR_IN6) pSockaddr;

        psa->sin6_family = AF_INET6;
        psa->sin6_port   = Port;

        RtlCopyMemory(
            &psa->sin6_addr,
            &Ip6Addr,
            sizeof(IP6_ADDRESS) );
    }
}



DNS_STATUS
Dns_AddressToSockaddr(
    OUT     PSOCKADDR       pSockaddr,
    IN OUT  PDWORD          pSockaddrLength,
    IN      BOOL            fClearSockaddr,
    IN      PBYTE           pAddr,
    IN      DWORD           AddrLength,
    IN      DWORD           AddrFamily
    )
/*++

Routine Description:

    Convert address in ptr\family\length to sockaddr.

Arguments:

    pSockaddr -- sockaddr buffer to recv address

    pSockaddrLength -- addr with length of sockaddr buffer
        receives the actual sockaddr length

    fClearSockaddr -- start with zero buffer

    pAddr -- ptr to address

    AddrLength -- address length

    AddrFamily -- address family (AF_INET, AF_INET6)

Return Value:

    NO_ERROR if successful.
    ERROR_INSUFFICIENT_BUFFER -- if buffer too small
    WSAEAFNOSUPPORT -- if invalid family

--*/
{
    PFAMILY_INFO    pinfo;
    DWORD           lengthIn = *pSockaddrLength;
    DWORD           lengthSockAddr;


    //  clear to start

    if ( fClearSockaddr )
    {
        RtlZeroMemory(
            pSockaddr,
            lengthIn );
    }

    //  switch on type

    if ( AddrFamily == AF_INET )
    {
        pinfo = pFamilyInfoIp4;
    }
    else if ( AddrFamily == AF_INET6 )
    {
        pinfo = pFamilyInfoIp6;
    }
    else if ( AddrFamily == AF_ATM )
    {
        pinfo = pFamilyInfoAtm;
    }
    else
    {
        return  WSAEAFNOSUPPORT;
    }

    //  validate lengths

    if ( AddrLength != pinfo->LengthAddr )
    {
        return  DNS_ERROR_INVALID_IP_ADDRESS;
    }

    lengthSockAddr = pinfo->LengthSockaddr;
    *pSockaddrLength = lengthSockAddr;

    if ( lengthIn < lengthSockAddr )
    {
        return  ERROR_INSUFFICIENT_BUFFER;
    }

    //
    //  fill out sockaddr
    //      - set family
    //      - copy address to sockaddr
    //      - return length was set above
    //

    RtlCopyMemory(
        (PBYTE)pSockaddr + pinfo->OffsetToAddrInSockaddr,
        pAddr,
        AddrLength );

    pSockaddr->sa_family = (WORD)AddrFamily;

    return  NO_ERROR;
}



#if 0
//  without family info
DNS_STATUS
Dns_AddressToSockaddr(
    OUT     PSOCKADDR       pSockaddr,
    IN OUT  PDWORD          pSockaddrLength,
    IN      BOOL            fClearSockaddr,
    IN      PBYTE           pAddr,
    IN      DWORD           AddrLength,
    IN      DWORD           AddrFamily
    )
/*++

Routine Description:

    Convert address in ptr\family\length to sockaddr.

Arguments:

    pSockaddr -- sockaddr buffer to recv address

    pSockaddrLength -- addr with length of sockaddr buffer
        receives the actual sockaddr length

    fClearSockaddr -- start with zero buffer

    pAddr -- ptr to address

    AddrLength -- address length

    AddrFamily -- address family (AF_INET, AF_INET6)

Return Value:

    NO_ERROR if successful.
    ERROR_INSUFFICIENT_BUFFER -- if buffer too small
    WSAEAFNOSUPPORT -- if invalid family

--*/
{
    DWORD   lengthIn = *pSockaddrLength;
    DWORD   lengthSockAddr;
    DWORD   lengthAddr;
    PBYTE   paddrInSockaddr;


    //  clear to start

    if ( fClearSockaddr )
    {
        RtlZeroMemory(
            pSockaddr,
            lengthIn );
    }

    //  switch on type

    if ( Family == AF_INET )
    {
        lengthSockAddr  = sizeof(SOCKADDR_IN);
        lengthAddr      = sizeof(IP4_ADDRESS);
        paddrInSockaddr = (PBYTE) &((PSOCKADDR_IN)pSockaddr)->sin_addr,
    }
    else if ( Family == AF_INET6 )
    {
        lengthSockAddr  = sizeof(SOCKADDR_IN6);
        lengthAddr      = sizeof(IP6_ADDRESS);
        paddrInSockaddr = (PBYTE) &((PSOCKADDR_IN6)pSockaddr)->sin6_addr,
    }
    else
    {
        return  WSAEAFNOSUPPORT;
    }

    //  validate lengths

    if ( AddrLength != lengthAddr )
    {
        return  DNS_ERROR_INVALID_IP_ADDRESS;
    }
    if ( lengthIn < lengthSockAddr )
    {
        *pSockaddrLength = lengthSockAddr;
        return  ERROR_INSUFFICIENT_BUFFER;
    }

    //
    //  fill out sockaddr
    //      - set family
    //      - copy address to sockaddr
    //      - set return length
    //

    RtlCopyMemory(
        paddrInSockaddr,
        pAddr,
        lengthAddr );

    }
    else    // IP6
    {
        if ( length < sizeof(SOCKADDR_IN) )
        {
            return  ERROR_INSUFFICIENT_BUFFER;
        }

        RtlCopyMemory(
            & ((PSOCKADDR_IN6)pSockaddr)->sin6_addr,
            pAddr,
            AddrLength );
    }

    //  DCR:  ATM sockaddr


    pSockaddr->sa_family = Family;

    return  NO_ERROR;
}
#endif



BOOL
Dns_SockaddrToIpUnion(
    OUT     PIP_UNION       pIpUnion,
    IN      PSOCKADDR       pSockaddr
    )
/*++

Routine Description:

    Build IP union from sockaddr.

Arguments:

    pIpUnion -- ptr IP union to build

    pSockaddr -- sockaddr

Return Value:

    TRUE if successfully created IP union.
    FALSE otherwise.

--*/
{
    PFAMILY_INFO    pinfo;
    WORD            family = pSockaddr->sa_family;
    BOOL            fIs6;

    //
    //  only support IP4 and IP6
    //
    //  DCR:  could add IP_UNION support to family info
    //

    if ( family == AF_INET )
    {
        fIs6 = FALSE;
    }
    else if ( family == AF_INET6 )
    {
        fIs6 = TRUE;
    }
    else
    {
        return  FALSE;
    }

    //
    //  get family info for unitary copy
    //

    pinfo = FamilyInfo_GetForFamily( family );
    if ( !pinfo )
    {
        DNS_ASSERT( FALSE );
        return  FALSE;
    }

    RtlCopyMemory(
        (PBYTE) &pIpUnion->Addr,
        (PBYTE)pSockaddr + pinfo->OffsetToAddrInSockaddr,
        pinfo->LengthAddr );

    pIpUnion->IsIp6 = fIs6;

    return  TRUE;
}



DWORD
Family_SockaddrLength(
    IN      WORD            Family
    )
/*++

Routine Description:

    Extract info for family.

Arguments:

    Family -- address family

Return Value:

    Length of sockaddr for address family.
    Zero if unknown family.

--*/
{
    PFAMILY_INFO    pinfo;

    //  get family -- extract info

    pinfo = FamilyInfo_GetForFamily( Family );
    if ( pinfo )
    {
        return  pinfo->LengthSockaddr;
    }
    return  0;
}



DWORD
Sockaddr_Length(
    IN      PSOCKADDR       pSockaddr
    )
/*++

Routine Description:

    Get length of sockaddr.

Arguments:

    pSockaddr -- sockaddr buffer to recv address

Return Value:

    Length of sockaddr for address family.
    Zero if unknown family.

--*/
{
    return  Family_SockaddrLength( pSockaddr->sa_family );
}

//
//  End addr.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\dnssec.h ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    dnssec.h

Abstract:

    Domain Name System (DNS) Library

    Private security definitions.
    These may be able to

Author:

    Jim Gilroy (jamesg)     November 1997

Revision History:

--*/


#ifndef _DNS_DNSSEC_INCLUDED_
#define _DNS_DNSSEC_INCLUDED_

//
//  DEVNOTE:  these may be able to be put in local
//      I created this file, simply because they we're dumped in with the
//      interface definitions, yet there is no dependency on this stuff
//      in the interface it is all internal to the security functions.
//

#define SECURITY_WIN32
#include "sspi.h"
#include "issperr.h"


#define SIG_LEN              33
#define NAME_OWNER           "Root"
#define SEC_SUCCESS(Status) ((Status) >= 0)
#define PACKAGE_NAME        L"negotiate"
#define NT_DLL_NAME         "security.dll"

//
// structure storing the state of the authentication sequence
//
typedef struct _AUTH_SEQ
{
    BOOL        _fNewConversation;
    CredHandle  _hcred;
    BOOL        _fHaveCredHandle;
    BOOL        _fHaveCtxtHandle;
    BOOL        _fInitialized;
    struct _SecHandle  _hctxt;
}
AUTH_SEQ, *PAUTH_SEQ;

extern CRITICAL_SECTION  g_NodeCS;

extern DWORD    g_cbMaxToken;
extern DWORD    g_cbMaxSignature;


#endif  // _DNS_DNSSEC_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\dnslibp.h ===
/*++

Copyright (c) 1996-2001  Microsoft Corporation

Module Name:

    dnslibp.h

Abstract:

    Domain Name System (DNS) Library

    Private DNS Library Routines

Author:

    Jim Gilroy (jamesg)     December 7, 1996

Revision History:

--*/


#ifndef _DNSLIBP_INCLUDED_
#define _DNSLIBP_INCLUDED_

#include <windns.h>
#include <dnsapi.h>
#include <dnslib.h>


#ifdef __cplusplus
extern "C"
{
#endif  // __cplusplus


//  headers are screwed up
//  neither ntdef.h nor winnt.h brings in complete set, so depending
//  on whether you include nt.h or not you end up with different set

#define MINCHAR     0x80
#define MAXCHAR     0x7f
#define MINSHORT    0x8000
#define MAXSHORT    0x7fff
#define MINLONG     0x80000000
#define MAXLONG     0x7fffffff
#define MAXBYTE     0xff
#define MAXUCHAR    0xff
#define MAXWORD     0xffff
#define MAXUSHORT   0xffff
#define MAXDWORD    0xffffffff
#define MAXULONG    0xffffffff

//
//  Handy bad ptr
//

#define DNS_BAD_PTR     ((PVOID)(-1))

//
//  "Wire" char set
//
//  Explicitly create wire char set in case the ACE format
//  wins out.
//

#define DnsCharSetWire  DnsCharSetUtf8



//
//  Private DNS_RECORD Flag field structure definition and macros
//

typedef struct _PrivateRecordFlags
{
    DWORD   Section     : 2;
    DWORD   Delete      : 1;
    DWORD   CharSet     : 2;

    DWORD   Cached      : 1;        // or maybe a "Source" field
    DWORD   HostsFile   : 1;
    DWORD   Cluster     : 1;

    DWORD   Unused      : 3;
    DWORD   Matched     : 1;
    DWORD   FreeData    : 1;
    DWORD   FreeOwner   : 1;

    DWORD   Reserved    : 18;
}
PRIV_RR_FLAGS, *PPRIV_RR_FLAGS;


#define RRFLAGS( pRecord )          ((PPRIV_RR_FLAGS)&pRecord->Flags.DW)

//  Defined in dnslib.h  too late to pull now
//#define FLAG_Section( pRecord )     (RRFLAGS( pRecord )->Section)
//#define FLAG_Delete( pRecord )      (RRFLAGS( pRecord )->Delete)
//#define FLAG_CharSet( pRecord )     (RRFLAGS( pRecord )->CharSet)
//#define FLAG_FreeData( pRecord )    (RRFLAGS( pRecord )->FreeData)
//#define FLAG_FreeOwner( pRecord )   (RRFLAGS( pRecord )->FreeOwner)
//#define FLAG_Matched( pRecord )     (RRFLAGS( pRecord )->Matched)

//#define FLAG_Cached( pRecord )      (RRFLAGS( pRecord )->Cached)
#define FLAG_HostsFile( pRecord )   (RRFLAGS( pRecord )->HostsFile)
#define FLAG_Cluster( pRecord )     (RRFLAGS( pRecord )->Cluster)

//#define SET_FREE_OWNER(pRR)         (FLAG_FreeOwner(pRR) = TRUE)
//#define SET_FREE_DATA(pRR)          (FLAG_FreeData(pRR) = TRUE)
//#define SET_RR_MATCHED(pRR)         (FLAG_Matched(pRR) = TRUE)
#define SET_RR_HOSTS_FILE(pRR)      (FLAG_HostsFile(pRR) = TRUE)
#define SET_RR_CLUSTER(pRR)         (FLAG_Cluster(pRR) = TRUE)

//#define CLEAR_FREE_OWNER(pRR)       (FLAG_FreeOwner(pRR) = FALSE)
//#define CLEAR_FREE_DATA(pRR)        (FLAG_FreeData(pRR) = FALSE)
//#define CLEAR_RR_MATCHED(pRR)       (FLAG_Matched(pRR) = FALSE)

#define CLEAR_RR_HOSTS_FILE(pRR)    (FLAG_HostsFile(pRR) = FALSE)

//#define IS_FREE_OWNER(pRR)          (FLAG_FreeOwner(pRR))
//#define IS_FREE_DATA(pRR)           (FLAG_FreeData(pRR))
//#define IS_RR_MATCHED(pRR)          (FLAG_Matched(pRR))
#define IS_HOSTS_FILE_RR(pRR)       (FLAG_HostsFile(pRR))
#define IS_CLUSTER_RR(pRR)          (FLAG_Cluster(pRR))

//#define IS_ANSWER_RR(pRR)           (FLAG_Section(pRR) == DNSREC_ANSWER)
//#define IS_AUTHORITY_RR(pRR)        (FLAG_Section(pRR) == DNSREC_AUTHORITY)
//#define IS_ADDITIONAL_RR(pRR)       (FLAG_Section(pRR) == DNSREC_ADDITIONAL)



//
//  Address family info (addr.c)
//

typedef struct _AddrFamilyInfo
{
    WORD    Family;
    WORD    DnsType;
    DWORD   LengthAddr;
    DWORD   LengthSockaddr;
    DWORD   OffsetToAddrInSockaddr;
}
FAMILY_INFO, *PFAMILY_INFO;

extern  FAMILY_INFO AddrFamilyTable[];

#define FamilyInfoIp4   (AddrFamilyTable[0])
#define FamilyInfoIp6   (AddrFamilyTable[1])
#define FamilyInfoAtm   (AddrFamilyTable[2])

#define pFamilyInfoIp4  (&AddrFamilyTable[0])
#define pFamilyInfoIp6  (&AddrFamilyTable[1])
#define pFamilyInfoAtm  (&AddrFamilyTable[2])


PFAMILY_INFO
FamilyInfo_GetForFamily(
    IN      DWORD           Family
    );

#define FamilyInfo_GetForSockaddr(pSA)  \
        FamilyInfo_GetForFamily( (pSA)->sa_family )



//
//  IP Union
//
//  DCR:  probably should have just used sockaddr here
//
//  Advantages over sockaddr_in6
//      - bool test
//      - addresses pointers start in the same place for both
//          types
//      - size
//      - no munging (sockaddr_in6) needs casting to get back to IP4
//      alternatively regular sockaddr is not fixed size
//  
//  If keep this type should make it available for all address
//  operations including local IP, in which case should include
//  flag field for cluster, weird info.
//

typedef struct _DnsIpUnion
{
    BOOL    IsIp6;
    union
    {
        IP4_ADDRESS Ip4;
        IP6_ADDRESS Ip6;
    }
    Addr;
}
IP_UNION, *PIP_UNION;


#define IPUNION_IS_IP4( p )         (!(p)->IsIp6)
#define IPUNION_IS_IP6( p )         ((p)->IsIp6)

#define IPUNION_IP4_PTR( p )        (&(p)->Addr.Ip4)
#define IPUNION_IP6_PTR( p )        (&(p)->Addr.Ip6)

#define IPUNION_GET_IP4( p )        ((p)->Addr.Ip4)
#define IPUNION_GET_IP6( p )        ((p)->Addr.Ip6)

#define IPUNION_SET_IP4( p, ip4 )   \
        {                           \
            PIP_UNION pip = (p);    \
            pip->IsIp6 = FALSE;     \
            pip->Addr.Ip4 = (ip4);  \
        }

#define IPUNION_SET_IP6( p, ip6 )   \
        {                           \
            PIP_UNION pip = (p);    \
            pip->IsIp6 = TRUE;      \
            pip->Addr.Ip6 = (ip6);  \
        }

//
//  Address manipulation (addr.c)
//

BOOL
Dns_EqualIpUnion(
    IN      PIP_UNION       pIp1,
    IN      PIP_UNION       pIp2
    );

BOOL
Dns_SockaddrToIpUnion(
    OUT     PIP_UNION       pIpUnion,
    IN      PSOCKADDR       pSockaddr
    );

IP6_ADDRESS
Ip6AddressFromSockaddr(
    IN      PSOCKADDR       pSockaddr
    );

VOID
InitSockaddrWithIp6Address(
    OUT     PSOCKADDR       pSockaddr,
    IN      IP6_ADDRESS     Ip6Addr,
    IN      WORD            Port
    );

DNS_STATUS
Dns_AddressToSockaddr(
    OUT     PSOCKADDR       pSockaddr,
    IN OUT  PDWORD          pSockaddrLength,
    IN      BOOL            fClearSockaddr,
    IN      PBYTE           pAddr,
    IN      DWORD           AddrLength,
    IN      DWORD           AddrFamily
    );

DWORD
Family_SockaddrLength(
    IN      WORD            Family
    );

DWORD
Sockaddr_Length(
    IN      PSOCKADDR       pSockaddr
    );

        
//
//  String to address conversion (straddr.c)
//
//  Most of the routines are public.  These ones handle
//  non-NULL terminated strings for DNS server file load.
//

BOOL
Dns_Ip4StringToAddressEx_A(
    OUT     PIP4_ADDRESS    pIp4Addr,
    IN      PCSTR           pchString,
    IN      DWORD           StringLength
    );

BOOL
Dns_Ip6StringToAddressEx_A(
    OUT     PIP6_ADDRESS    pIp6Addr,
    IN      PCSTR           pchString,
    IN      DWORD           StringLength
    );

        
//
//  RPC-able type (record.c)
//

BOOL
Dns_IsRpcRecordType(
    IN      WORD            wType
    );


//
//  Record copy (rrcopy.c)
//

PDNS_RECORD
WINAPI
Dns_RecordCopy_W(
    IN      PDNS_RECORD     pRecord
    );

PDNS_RECORD
WINAPI
Dns_RecordCopy_A(
    IN      PDNS_RECORD     pRecord
    );

PDNS_RECORD
Dns_RecordListCopyEx(
    IN      PDNS_RECORD     pRR,
    IN      DWORD           ScreenFlag,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    );


//
//  Record list routines (rrlist.c)
//

//
//  Record screening (rrlist.c)
//

#define SCREEN_OUT_ANSWER           (0x00000001)
#define SCREEN_OUT_AUTHORITY        (0x00000010)
#define SCREEN_OUT_ADDITIONAL       (0x00000100)
#define SCREEN_OUT_NON_RPC          (0x00100000)

#define SCREEN_OUT_SECTION  \
        (SCREEN_OUT_ANSWER | SCREEN_OUT_AUTHORITY | SCREEN_OUT_ADDITIONAL)


BOOL
Dns_ScreenRecord(
    IN      PDNS_RECORD     pRR,
    IN      DWORD           ScreenFlag
    );

PDNS_RECORD
Dns_RecordListScreen(
    IN      PDNS_RECORD     pRR,
    IN      DWORD           ScreenFlag
    );

DWORD
Dns_RecordListGetMinimumTtl(
    IN      PDNS_RECORD     pRRList
    );


//
//  New free
//  DCR:  switch to dnslib.h when world builds clean
//

#undef  Dns_RecordListFree

VOID
WINAPI
Dns_RecordListFree(
    IN OUT  PDNS_RECORD     pRRList
    );


//
//  String (string.c)
//

DWORD
MultiSz_Length_A(
    IN      PCSTR           pmszString
    );

PSTR
MultiSz_NextString_A(
    IN      PCSTR           pmszString
    );

PSTR
MultiSz_Copy_A(
    IN      PCSTR           pmszString
    );


//
//  Name utilities (name.c)
//

DWORD
Dns_MakeCanonicalNameW(
    OUT     PWSTR           pBuffer,
    IN      DWORD           BufLength,
    IN      PWSTR           pwsString,
    IN      DWORD           StringLength
    );

DWORD
Dns_MakeCanonicalNameInPlaceW(
    IN      PWCHAR          pwString,
    IN      DWORD           StringLength
    );

//
//  Name checking -- server name checking levels
//

#define DNS_ALLOW_RFC_NAMES_ONLY    (0)
#define DNS_ALLOW_NONRFC_NAMES      (1)
#define DNS_ALLOW_MULTIBYTE_NAMES   (2)
#define DNS_ALLOW_ALL_NAMES         (3)

INT
Dns_DowncaseNameLabel(
    OUT     PCHAR           pchResult,
    IN      PCHAR           pchLabel,
    IN      DWORD           cchLabel,
    IN      DWORD           dwFlags
    );

PSTR
Dns_NameAppend_A(
    OUT     PCHAR           pNameBuffer,
    IN      DWORD           BufferLength,
    IN      PSTR            pszName,
    IN      PSTR            pszDomain
    );

PWSTR
Dns_NameAppend_W(
    OUT     PWCHAR          pNameBuffer,
    IN      DWORD           BufferLength,
    IN      PWSTR           pwsName,
    IN      PWSTR           pwsDomain
    );

PSTR
Dns_SplitHostFromDomainName_A(
    IN      PSTR            pszName
    );

BOOL
_fastcall
Dns_IsNameNumeric_A(
    IN      PCSTR           pszName
    );



DWORD
Dns_NameCopyWireToUnicode(
    OUT     PWCHAR          pBufferUnicode,
    IN      PCSTR           pszNameWire
    );

DWORD
Dns_NameCopyUnicodeToWire(
    OUT     PCHAR           pBufferWire,
    IN      PCWSTR          pwsNameUnicode
    );

DWORD
Dns_NameCopyStandard_W(
    OUT     PWCHAR          pBuffer,
    IN      PCWSTR          pwsNameUnicode
    );

DWORD
Dns_NameCopyStandard_A(
    OUT     PCHAR           pBuffer,
    IN      PCSTR           pszName
    );

//
//  Sting to address (straddr.c)
//
//  Need for hostent routine which doesn unicode\ANSI.
//

BOOL
Dns_StringToAddressEx(
    OUT     PCHAR           pAddrBuf,
    IN OUT  PDWORD          pBufLength,
    IN      PCSTR           pString,
    IN OUT  PDWORD          pAddrFamily,
    IN      BOOL            fUnicode,
    IN      BOOL            fReverse
    );

//
//  Special record creation (rralloc.c)
//

PDNS_RECORD
Dns_CreateFlatRecord(
    IN      PDNS_NAME       pOwnerName,
    IN      WORD            wType,
    IN      PCHAR           pData,
    IN      DWORD           DataLength,
    IN      DWORD           Ttl,
    IN      DNS_CHARSET     NameCharSet,
    IN      DNS_CHARSET     RecordCharSet
    );

PDNS_RECORD
Dns_CreatePtrTypeRecord(
    IN      PDNS_NAME       pOwnerName,
    IN      BOOL            fCopyName,
    IN      PDNS_NAME       pTargetName,
    IN      WORD            wType,
    IN      DWORD           Ttl,
    IN      DNS_CHARSET     NameCharSet,
    IN      DNS_CHARSET     RecordCharSet
    );

PDNS_RECORD
Dns_CreatePtrRecordEx(
    IN      PIP_UNION       pIp,
    IN      PDNS_NAME       pszHostName,
    IN      DWORD           Ttl,
    IN      DNS_CHARSET     NameCharSet,
    IN      DNS_CHARSET     RecordCharSet
    );

PDNS_RECORD
Dns_CreatePtrRecordExEx(
    IN      PIP_UNION       pIp,
    IN      PSTR            pszHostName,
    IN      PSTR            pszDomainName,
    IN      DWORD           Ttl,
    IN      DNS_CHARSET     NameCharSet,
    IN      DNS_CHARSET     RecordCharSet
    );

PDNS_RECORD
Dns_CreateARecord(
    IN      PDNS_NAME       pOwnerName,
    IN      IP_ADDRESS      IpAddress,
    IN      DWORD           Ttl,
    IN      DNS_CHARSET     NameCharSet,
    IN      DNS_CHARSET     RecordCharSet
    );

PDNS_RECORD
Dns_CreateAAAARecord(
    IN      PDNS_NAME       pOwnerName,
    IN      IP6_ADDRESS     Ip6Address,
    IN      DWORD           Ttl,
    IN      DNS_CHARSET     NameCharSet,
    IN      DNS_CHARSET     RecordCharSet
    );

PDNS_RECORD
Dns_CreateForwardRecord(
    IN      PDNS_NAME       pOwnerName,
    IN      PIP_UNION       pIp,
    IN      DWORD           Ttl,
    IN      DNS_CHARSET     NameCharSet,
    IN      DNS_CHARSET     RecordCharSet
    );

PDNS_RECORD
Dns_CreateForwardRecordFromSockaddr(
    IN      PDNS_NAME       pOwnerName,
    IN      PSOCKADDR       pSockaddr,
    IN      DWORD           Ttl,
    IN      DNS_CHARSET     NameCharSet,
    IN      DNS_CHARSET     RecordCharSet
    );

PDNS_RECORD
Dns_CreateRecordForIpString_W(
    IN      PCWSTR          pwsName,
    IN      WORD            wType,
    IN      DWORD           Ttl
    );


//
//  Security stuff (security.c)
//

#define SECURITY_WIN32
#include <sspi.h>

#define DNS_SPN_SERVICE_CLASS       "DNS"
#define DNS_SPN_SERVICE_CLASS_W     L"DNS"

//
//  Some useful stats
//

extern  DWORD   SecContextCreate;
extern  DWORD   SecContextFree;
extern  DWORD   SecContextQueue;
extern  DWORD   SecContextQueueInNego;
extern  DWORD   SecContextDequeue;
extern  DWORD   SecContextTimeout;
extern  DWORD   SecPackAlloc;
extern  DWORD   SecPackFree;

//  Security packet verifications

extern  DWORD   SecTkeyInvalid;
extern  DWORD   SecTkeyBadTime;
extern  DWORD   SecTsigFormerr;
extern  DWORD   SecTsigEcho;
extern  DWORD   SecTsigBadKey;
extern  DWORD   SecTsigVerifySuccess;
extern  DWORD   SecTsigVerifyOldSig;
extern  DWORD   SecTsigVerifyFailed;

//  Hacks
//  Allowing old TSIG off by default, server can turn on.
//  Big Time skew on by default

extern BOOL    SecAllowOldTsig;
extern DWORD   SecTsigVerifyOldSig;
extern DWORD   SecTsigVerifyOldFailed;
extern DWORD   SecBigTimeSkew;
extern DWORD   SecBigTimeSkewBypass;

//
//  Security globals
//      expose some of these which may be accessed by update library
//

extern BOOL     g_fSecurityPackageInitialized;
extern DWORD    g_SecurityTokenMaxLength;

//
//  Security context cache
//

VOID
Dns_TimeoutSecurityContextList(
    IN      BOOL            fClearList
    );

//
//  Security API
//

BOOL
Dns_DnsNameToKerberosTargetName(
    IN      LPSTR           pszDnsName,
    IN      LPSTR           pszKerberosTargetName
    );

DNS_STATUS
Dns_StartSecurity(
    IN      BOOL            fProcessAttach
    );

DNS_STATUS
Dns_StartServerSecurity(
    VOID
    );

DNS_STATUS
Dns_InitializeSecurityPackage(
    OUT     PDWORD          pdwMaxMessage,
    IN      BOOL            bDnsSvr
    );

VOID
Dns_TerminateSecurityPackage(
    VOID
    );

HANDLE
Dns_CreateAPIContext(
    IN      DWORD           Flags,
    IN      PVOID           Credentials,    OPTIONAL
    IN      BOOL            fUnicode
    );

VOID
Dns_FreeAPIContext(
    IN OUT  HANDLE          hContextHandle
    );

PVOID
Dns_GetApiContextCredentials(
    IN HANDLE hContextHandle
    );

DWORD
Dns_GetCurrentRid(
   VOID);

BOOL
Dns_CreateUserCredentials(
    IN      PCHAR           pszUser,
    IN      DWORD           dwUserLength,
    IN      PCHAR           pszDomain,
    IN      DWORD           dwDomainLength,
    IN      PCHAR           pszPassword,
    IN      DWORD           dwPasswordLength,
    IN      BOOL            FromWide,
    OUT     PCHAR *         ppCreds
    );


PSEC_WINNT_AUTH_IDENTITY_W
Dns_AllocateAndInitializeCredentialsW(
    IN      PSEC_WINNT_AUTH_IDENTITY_W  pAuthIn
    );

PSEC_WINNT_AUTH_IDENTITY_A
Dns_AllocateAndInitializeCredentialsA(
    IN      PSEC_WINNT_AUTH_IDENTITY_A  pAuthIn
    );

VOID
Dns_FreeAuthIdentityCredentials(
    IN      PVOID  pAuthIn
    );


DNS_STATUS
Dns_SignMessageWithGssTsig(
    IN      HANDLE          hContext,
    IN      PDNS_HEADER     pMsgHead,
    IN      PCHAR           pMsgBufEnd,
    IN OUT  PCHAR *         ppCurrent
    );

#if 1
DNS_STATUS
Dns_RefreshSSpiCredentialsHandle(
    IN      BOOL bDnsSvr,
    IN      PCHAR pCreds );
#endif

VOID
Dns_FreeSecurityContextList(
    VOID
    );


//
//  Client security routines
//

DNS_STATUS
Dns_DoSecureUpdate(
    IN      PDNS_MSG_BUF        pMsgSend,
    OUT     PDNS_MSG_BUF        pMsgRecv,
    IN OUT  PHANDLE             phContext,
    IN      DWORD               dwFlag,
    IN      PDNS_NETINFO        pNetworkInfo,
    IN      PIP_ARRAY           aipServer,
    IN      LPSTR               pszNameServer,
    IN      PCHAR               pCreds,
    IN      PCHAR               pszContext
    );

//
//  Server security routines
//

DNS_STATUS
Dns_FindSecurityContextFromAndVerifySignature(
    IN      PHANDLE         phContext,
    IN      IP_ADDRESS      ipRemote,
    IN      PDNS_HEADER     pMsgHead,
    IN      PCHAR           pMsgEnd
    );

DNS_STATUS
Dns_ServerNegotiateTkey(
    IN      IP_ADDRESS      ipRemote,
    IN      PDNS_HEADER     pMsgHead,
    IN      PCHAR           pMsgEnd,
    IN      PCHAR           pMsgBufEnd,
    IN      BOOL            fBreakOnAscFailure,
    OUT     PCHAR *         ppCurrent
    );

DNS_STATUS
Dns_SrvImpersonateClient(
    IN      HANDLE          hContext
    );

DNS_STATUS
Dns_SrvRevertToSelf(
    IN      HANDLE          hContext
    );

VOID
Dns_CleanupSessionAndEnlistContext(
    IN OUT  HANDLE          hSession
    );

DWORD
Dns_GetKeyVersion(
    IN      LPSTR           pszContext
    );

//
//  Security utilities
//

DNS_STATUS
Dns_CreateSecurityDescriptor(
    OUT     PSECURITY_DESCRIPTOR *  ppSD,
    IN      DWORD                   AclCount,
    IN      PSID *                  SidPtrArray,
    IN      DWORD *                 AccessMaskArray
    );



//
//  Security credentials
//

//  Only defined if WINNT_AUTH_IDENTITY defined

#ifdef __RPCDCE_H__

PSEC_WINNT_AUTH_IDENTITY_W
Dns_AllocateCredentials(
    IN      PWSTR           pwsUserName,
    IN      PWSTR           pwsDomain,
    IN      PWSTR           pwsPassword
    );
#endif

DNS_STATUS
Dns_ImpersonateUser(
    IN      PDNS_CREDENTIALS    pCreds
    );

VOID
Dns_FreeCredentials(
    IN      PDNS_CREDENTIALS    pCreds
    );

PDNS_CREDENTIALS
Dns_CopyCredentials(
    IN      PDNS_CREDENTIALS    pCreds
    );



//
//  Debug globals
//
//  Expose here to allow debug file sharing
//

typedef struct _DnsDebugInfo
{
    DWORD       Flag;
    HANDLE      hFile;

    DWORD       FileCurrentSize;
    DWORD       FileWrapCount;
    DWORD       FileWrapSize;

    DWORD       LastThreadId;
    DWORD       LastSecond;

    BOOL        fConsole;

    CHAR        FileName[ MAX_PATH ];
}
DNS_DEBUG_INFO, *PDNS_DEBUG_INFO;

//  WANING:  MUST ONLY be called in dnsapi.dll

PDNS_DEBUG_INFO
Dns_SetDebugGlobals(
    IN OUT  PDNS_DEBUG_INFO pInfo
    );



//
//  No DnsApi.dll
//
//  If not using dnsapi.dll, let those names be used without
//

#ifdef  NO_DNSAPI_DLL

//
//  remove DnsApi.dll function definition
//

//  timer
#undef  InitializeSecondsTimer
#undef  GetCurrentTimeInSeconds

//  IP array
#undef  DnsValidateIpAddressArray
#undef  DnsCreateIpAddressArrayCopy
#undef  DnsCreateIpArray
#undef  DnsSizeofIpArray
#undef  DnsBuildIpArray
#undef  DnsCreateIpArrayCopy
#undef  DnsIsAddressInIpArray
#undef  DnsAddIpToIpArray
#undef  DnsClearIpArray
#undef  DnsCheckAndMakeIpArraySubset
#undef  DnsDeleteIpFromIpArray
#undef  DnsRemoveZerosFromIpArray
#undef  DnsDiffOfIpArrays
#undef  DnsIntersectionOfIpArrays

//  general DNS utilities
#undef  DnsGetDomainName
#undef  DnsValidateAndCategorizeDnsName
#undef  DnsStatusString
#undef  DnsMapRcodeToStatus
#undef  DnsIsStatusRcode
#undef  DnsResponseCodeString
#undef  DnsResponseCodeExplanationString
#undef  DnsOpcodeString
#undef  DnsOpcodeCharacter
#undef  DnsSectionNameString

//  local machine info
#undef  Dns_GetIpAddresses

//  records
#undef  DnsWinsRecordFlagForString
#undef  DnsWinsRecordFlagString
#undef  DnsIsAMailboxType
#undef  DnsRecordTypeForName
#undef  DnsRecordStringForType
#undef  DnsRecordStringForWritableType
#undef  DnsIsStringCountValidForTextType
#undef  DnsIpv6StringToAddress
#undef  DnsIpv6AddressToString

//  strings
#undef  DnsCreateStringCopy
#undef  DnsGetBufferLengthForStringCopy
#undef  DnsCopyStringEx
#undef  DnsStringCopyAllocateEx
#undef  DnsWriteReverseNameStringForIpAddress
#undef  DnsCreateReverseNameStringForIpAddress
#undef  DnsValidateDnsName_UTF8
#undef  DnsValidateDnsName_W
#undef  DnsRelationalCompare_UTF8
#undef  DnsRelationalCompare_W
#undef  DnsValidateDnsString_UTF8
#undef  DnsValidateDnsString_W
#undef  DnsCreateStandardDnsNameCopy
#undef  DnsDowncaseDnsNameLabel
#undef  DnsUnicodeToUtf8
#undef  DnsUtf8ToUnicode
#undef  DnsValidateUtf8Byte

//
//  redefine DnsApi.dll function as dnslib function
//

//  timer
#define InitializeSecondsTimer()                    Dns_InitializeSecondsTimer()
#define GetCurrentTimeInSeconds()                   Dns_GetCurrentTimeInSeconds()

//  IP array
#define DnsValidateIpAddressArray(a,b,c)            Dns_ValidateIpAddressArray(a,b,c)
#define DnsCreateIpAddressArrayCopy(a,b)            Dns_CreateIpAddressArrayCopy(a,b)
#define DnsCreateIpArray(a)                         Dns_CreateIpArray(a)
#define DnsSizeofIpArray(a)                         Dns_SizeofIpArray(a)
#define DnsBuildIpArray(a,b)                        Dns_BuildIpArray((a),(b))
#define DnsCreateIpArrayCopy(a)                     Dns_CreateIpArrayCopy(a)
#define DnsIsAddressInIpArray(a,b)                  Dns_IsAddressInIpArray((a),(b))
#define DnsAddIpToIpArray(a,b)                      Dns_AddIpToIpArray((a),(b))
#define DnsClearIpArray(a)                          Dns_ClearIpArray(a)
#define DnsCheckAndMakeIpArraySubset(a,b)           Dns_CheckAndMakeIpArraySubset((a),(b))
#define DnsDeleteIpFromIpArray(a,b)                 Dns_DeleteIpFromIpArray((a),(b))
#define DnsRemoveZerosFromIpArray(a)                Dns_RemoveZerosFromIpArray(a)
#define DnsDiffOfIpArrays(a,b,c,d,e)                Dns_DiffOfIpArrays((a),(b),(c),(d),(e))
#define DnsIntersectionOfIpArrays(a,b,c)            Dns_IntersectionOfIpArrays((a),(b),(c))

//  general DNS utilities
#define DnsGetDomainName(a)                         Dns_GetDomainName(a)
#define DnsValidateAndCategorizeDnsName(a,b)        Dns_ValidateAndCategorizeDnsName(a,b)
#define DnsStatusString(a)                          Dns_StatusString(a)
#define DnsMapRcodeToStatus(a)                      Dns_MapRcodeToStatus(a)
#define DnsIsStatusRcode(a)                         Dns_IsStatusRcode(a)
#define DnsResponseCodeString(a)                    Dns_ResponseCodeString(a)
#define DnsResponseCodeExplanationString(a)         Dns_ResponseCodeExplanationString(a)
#define DnsOpcodeString(a)                          Dns_OpcodeString(a)
#define DnsOpcodeCharacter(a)                       Dns_OpcodeCharacter(a)
#define DnsSectionNameString(a,b)                   Dns_SectionNameString(a,b)

//  local machine info
#define DnsGetIpAddresses(a,b)                      Dns_GetIpAddresses(a,b)

//  records
#define DnsWinsRecordFlagForString(a,b)             Dns_WinsRecordFlagForString(a,b)
#define DnsWinsRecordFlagString(a,b)                Dns_WinsRecordFlagString(a,b)
#define DnsIsAMailboxType(a)                        Dns_IsAMailboxType(a)
#define DnsRecordTypeForName(a,b)                   Dns_RecordTypeForName(a,b)
#define DnsRecordStringForType(a)                   Dns_RecordStringForType(a)
#define DnsRecordStringForWritableType(a)           Dns_RecordStringForWritableType(a)
#define DnsIsStringCountValidForTextType(a,b)       Dns_IsStringCountValidForTextType(a,b)

//  strings
#define DnsCreateStringCopy(a,b)                    Dns_CreateStringCopy(a,b)
#define DnsGetBufferLengthForStringCopy(a,b,c,d)    Dns_GetBufferLengthForStringCopy(a,b,c,d)
#define DnsCopyStringEx(a,b,c,d,e)                  Dns_CopyStringEx(a,b,c,d,e)
#define DnsStringCopyAllocateEx(a,b,c,d)            Dns_NameCopyAllocateEx(a,b,c,d)
#define DnsValidateDnsName_UTF8(a)                  Dns_ValidateDnsName_UTF8(a)
#define DnsValidateDnsName_W(a)                     Dns_ValidateDnsName_W(a)
#define DnsRelationalCompare_UTF8(a,b,c,d)          Dns_RelationalCompare_UTF8(a,b,c,d)
#define DnsRelationalCompare_W(a,b,c,d)             Dns_RelationalCompare_W(a,b,c,d)
#define DnsValidateDnsString_UTF8(a)                Dns_ValidateDnsString_UTF8(a)
#define DnsValidateDnsString_W(a)                   Dns_ValidateDnsString_W(a)
#define DnsCreateStandardDnsNameCopy(a,b,c)         Dns_CreateStandardDnsNameCopy(a,b,c)
#define DnsDowncaseDnsNameLabel(a,b,c,d)            Dns_DowncaseDnsNameLabel(a,b,c,d)
#define DnsUnicodeToUtf8(a,b,c,d)                   Dns_UnicodeToUtf8(a,b,c,d)
#define DnsUtf8ToUnicode(a,b,c,d)                   Dns_Utf8ToUnicode(a,b,c,d)
#define DnsValidateUtf8Byte(a,b)                    Dns_ValidateUtf8Byte(a,b)

//  address\string mapping
//  some ones to make official?

#define DnsIpv6StringToAddress(a,b,c)               Dns_Ip6StringToAddressEx_A(a,b,c)
#define DnsIpv6AddressToString(a,b)                 Dns_Ip6AddressToString_A(a,b)
#define DnsWriteReverseNameStringForIpAddress(a,b)  Dns_WriteReverseNameForIp4Address(a,b)
#define DnsWriteReverseNameStringForIpAddress_W(a,b)Dns_WriteReverseNameForIp4Address_W(a,b)
#define DnsCreateReverseNameStringForIpAddress(a)   Dns_CreateReverseNameStringForIpAddress(a)

#endif  // NO_DNSAPI_DLL



//
//  Use old names
//  Covering old names with new -- done for dnsapi.dll (and associated utils)
//  This is done only for non-exported routines.
//  Exported routines must be directly covered.
//

//  IP array
#define DnsValidateIpAddressArray(a,b,c)            Dns_ValidateIpAddressArray(a,b,c)
#define DnsCreateIpAddressArrayCopy(a,b)            Dns_CreateIpAddressArrayCopy(a,b)
#define DnsCreateIpArray(a)                         Dns_CreateIpArray(a)
#define DnsSizeofIpArray(a)                         Dns_SizeofIpArray(a)
#define DnsBuildIpArray(a,b)                        Dns_BuildIpArray((a),(b))
#define DnsCreateIpArrayCopy(a)                     Dns_CreateIpArrayCopy(a)
#define DnsIsAddressInIpArray(a,b)                  Dns_IsAddressInIpArray((a),(b))
#define DnsAddIpToIpArray(a,b)                      Dns_AddIpToIpArray((a),(b))
#define DnsClearIpArray(a)                          Dns_ClearIpArray(a)
#define DnsCheckAndMakeIpArraySubset(a,b)           Dns_CheckAndMakeIpArraySubset((a),(b))
#define DnsDeleteIpFromIpArray(a,b)                 Dns_DeleteIpFromIpArray((a),(b))
#define DnsRemoveZerosFromIpArray(a)                Dns_RemoveZerosFromIpArray(a)
#define DnsDiffOfIpArrays(a,b,c,d,e)                Dns_DiffOfIpArrays((a),(b),(c),(d),(e))
#define DnsIntersectionOfIpArrays(a,b,c)            Dns_IntersectionOfIpArrays((a),(b),(c))

//  DNS configuration
#define DnsInitNetworkInfo()                        Dns_InitNetworkInfo()
#define DnsGetDnsAdapterInfo(a)                     Dns_GetDnsAdapterInfo(a)
#define DnsGetDnsNetworkInfo(a,b)                   Dns_GetDnsNetworkInfo(a,b)
#define DnsCreateAdapterInfo(a)                     Dns_CreateAdapterInfo(a)
#define DnsCreateSearchList(a,b)                    Dns_CreateSearchList(a,b)
#define DnsCreateNetworkInfo(a)                     Dns_CreateNetworkInfo(a)
#define DnsSizeofAdapterInfo(a)                     Dns_SizeofAdapterInfo(a)
#define DnsCreateAdapterInfoCopy(a)                 Dns_CreateAdapterInfoCopy(a)
#define DnsCreateSearchListCopy(a)                  Dns_CreateSearchListCopy(a)
#define DnsCreateNetworkInfoCopy(a)                 Dns_CreateNetworkInfoCopy(a)
#define DnsAddAdapterInfoToNetworkInfo(a,b)         Dns_AddAdapterInfoToNetworkInfo(a,b)
#define DnsGetNextSearchName(a,b,c)                 Dns_GetNextSearchName(a,b,c)
#define DnsConvertIpArrayToAdapterInfo(a)           Dns_ConvertIpArrayToAdapterInfo(a)
#define DnsConvertIpArrayToNetworkInfo(a,b)         Dns_ConvertIpArrayToNetworkInfo(a,b)
#define DnsConvertNetworkInfoToIpArray(a)           Dns_ConvertNetworkInfoToIpArray(a)
#define DnsFreeAdapterInfo(a)                       Dns_FreeAdapterInfo(a)
#define DnsFreeSearchList(a)                        Dns_FreeSearchList(a)
#define DnsFreeNetworkInfo(a)                       Dns_FreeNetworkInfo(a)

//  same stuff but the infamous "NetAdapter"
#define DnsConvertNetworkInfoToIpArray(a)           Dns_ConvertNetworkInfoToIpArray(a)
#define DnsFreeNetworkInfo(a)                       Dns_FreeNetworkInfo(a)
#define DnsCreateNetworkInfo(a)                     Dns_CreateNetworkInfo(a)
#define DnsCreateNetworkInfoCopy(a)                 Dns_CreateNetworkInfoCopy(a)

#define DnsCreateUpdateNetworkInfo(a,b)             Dns_CreateUpdateNetworkInfo((b),NULL,(a),0)

//  packet
#define DnsAllocateMsgBuf(a)                        Dns_AllocateMsgBuf(a)
#define DnsInitializeMsgBuf(a)                      Dns_InitializeMsgBuf(a)
#define DnsWriteDottedNameToPacket(a,b,c,d,e,f)     Dns_WriteDottedNameToPacket(a,b,c,d,e,f)
#define DnsWriteStringToPacket(a,b,c,d)             Dns_WriteStringToPacket(a,b,c,d)
#define DnsWriteQuestionToMessage(a,b,c,d)          Dns_WriteQuestionToMessage(a,b,c,d)
#define DnsWriteRecordStructureToMessage(a,b,c,d,e) Dns_WriteRecordStructureToMessage(a,b,c,d,e)
#define DnsWriteRecordStructureToPacket(a,b,c)      Dns_WriteRecordStructureToPacket(a,b,c)
#define DnsAddRecordsToMessage(a,b,c)               Dns_AddRecordsToMessage(a,b,c)
#define DnsSkipPacketName(a,b)                      Dns_SkipPacketName(a,b)
#define DnsExtractRecordsFromMessage(a,b,c)         Dns_ExtractRecordsFromMessage(a,b,c)
#define DnsReadPacketName(a,b,c,d,e,f,g)            Dns_ReadPacketName(a,b,c,d,e,f,g)

//  socket
#define DnsCreateSocket(a,b,c)                      Dns_CreateSocket(a,b,c)
#define DnsCloseSocket(a)                           Dns_CloseSocket(a)
#define DnsCloseConnection(a)                       Dns_CloseConnection(a)
#define DnsSetupGlobalAsyncSocket()                 Dns_SetupGlobalAsyncSocket()

//  send
#define DnsSend(a)                                  Dns_Send(a)
#define DnsRecv(b)                                  Dns_Recv(b)
#define DnsRecvUdp(b)                               Dns_RecvUdp(b)
#define DnsSendMultipleUdp(a,b)                     Dns_SendMultipleUdp(a,b)
#define DnsSendAndRecvUdp(a,b,c)                    Dns_SendAndRecvUdp(a,b,c)
#define DnsSendAndRecvUdpEx(a,b,c)                  Dns_SendAndRecvUdpEx(a,b,c)
#define DnsOpenTcpConnectionAndSend(a,b,c)          Dns_OpenTcpConnectionAndSend(a,b,c)
#define DnsRecvTcp(a)                               Dns_RecvTcp(a)
#define DnsSendAndRecvTcp(a,b,c)                    Dns_SendAndRecvTcp(a,b,c)
#define DnsInitializeMsgRemoteSockaddr(a,b)         Dns_InitializeMsgRemoteSockaddr(a,b)



//
//  Redefinitions to old naming
//
//  DCR:  remove once fixed
//      shouldn't be in use anywhere but DNS source tree
//

#if 0
#define DnsStartDebug(a,b,c,d,e)    Dns_StartDebug(a,b,c,d,e)
#define DnsEndDebug()               Dns_EndDebug()
#define DnsAssert(a,b,c)            Dns_Assert(a,b,c)
#define DnsDebugFlush()             DnsDbg_Flush()
#define DnsDebugCSEnter(a,b,c,d)    DnsDbg_CSEnter(a,b,c,d)
#define DnsDebugCSLeave(a,b,c,d)    DnsDbg_CSLeave(a,b,c,d)
#define DnsPrintf                   DnsDbg_Printf
#define DnsDbgPrint                 DnsDbg_PrintfToDebugger
#define DnsDebugLock()              DnsDbg_Lock()
#define DnsDebugUnlock()            DnsDbg_Unlock()
#endif


#ifdef __cplusplus
}
#endif  // __cplusplus

#endif // _DNSLIBP_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsexts\dump.cxx ===
/*******************************************************************
*
*    File        : dump.cxx
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 7/15/1998
*    Description : implentation of dump routines
*
*    Revisions   : <date> <name> <description>
*******************************************************************/



#ifndef DUMP_CXX
#define DUMP_CXX



// include //
// common
#include "common.h"
#include "util.hxx"
#include <winsock2.h>
#include <winldap.h>
#include <windns.h>
// dns structures
#include "dns.h"
#include "tree.h"
// Ignore zero sized array warnings.
#pragma warning (disable : 4200)
#include "dnsrpc.h"
#include "name.h"
#include "record.h"
#include "update.h"
#include "dpart.h"
#include "EventControl.h"
#include "zone.h"
#include "msginfo.h"
// local
#include "dump.hxx"



// types //

// BUGBUG: RE-DECLARED from lock.c !!
#define MAX_LOCKED_TIME     (300)   // 5 minutes

#define LOCK_HISTORY_SIZE   (256)

typedef struct _LockEntry
{
    LONG    Count;
    DWORD   ThreadId;
    LPSTR   File;
    DWORD   Line;
}
LOCK_ENTRY, *PLOCK_ENTRY;

typedef struct _LockTable
{
    LPSTR       pszName;
    DWORD       FailuresSinceLockFree;
    DWORD       LastFreeLockTime;
    DWORD       Index;
    LOCK_ENTRY  OffenderLock;
    LOCK_ENTRY  LockHistory[ LOCK_HISTORY_SIZE ];
}
LOCK_TABLE, * PLOCK_TABLE;


//
//  Protos for exported functions
//

DECLARE_DUMPFUNCTION( Dump_DNS_MSGINFO );
DECLARE_DUMPFUNCTION( Dump_DS_SEARCH );
DECLARE_DUMPFUNCTION( Dump_Help );
DECLARE_DUMPFUNCTION( Dump_SockAddr );
DECLARE_DUMPFUNCTION( Dump_DB_NODE );
DECLARE_DUMPFUNCTION( Dump_COUNT_NAME );
DECLARE_DUMPFUNCTION( Dump_ZONE_INFO );
DECLARE_DUMPFUNCTION( Dump_DB_RECORD );
DECLARE_DUMPFUNCTION( Dump_IP_ARRAY );
DECLARE_DUMPFUNCTION( Dump_LOCK_TABLE );
DECLARE_DUMPFUNCTION( Dump_LOCK_ENTRY );
DECLARE_DUMPFUNCTION( Dump_UPDATE );
DECLARE_DUMPFUNCTION( Dump_UPDATE_LIST );
DECLARE_DUMPFUNCTION( Dump_DNS_WIRE_QUESTION );
DECLARE_DUMPFUNCTION( Dump_LOOKUP_NAME );
DECLARE_DUMPFUNCTION( Dump_DNS_HEADER );
DECLARE_DUMPFUNCTION( Dump_HEAP_HEADER );

//
//  Private protos
//

DECLARE_DUMPFUNCTION( Dump_ADDITIONAL_INFO );
DECLARE_DUMPFUNCTION( Dump_COMPRESSION_INFO );
DECLARE_DUMPFUNCTION( Dump_Record_SOA );
DECLARE_DUMPFUNCTION( Dump_SID );

VOID
DumpBuffer(
    PVOID Buffer,
    DWORD BufferSize );


//
//  Dispatch table
//

DUMPENTRY gfDumpTable[] =
{
    "COUNT_NAME"    ,   Dump_COUNT_NAME,
    "DB_NODE"       ,   Dump_DB_NODE,
    "DB_RECORD"     ,   Dump_DB_RECORD,
    "DNS_HEADER"    ,   Dump_DNS_HEADER,
    "DNS_WIRE_QUESTION"  ,   Dump_DNS_WIRE_QUESTION,
    "DS_SEARCH"     ,   Dump_DS_SEARCH,
    "HEAP_HEADER"   ,   Dump_HEAP_HEADER,
    "HELP"          ,   Dump_Help,
    "IP_ARRAY"      ,   Dump_IP_ARRAY,
    "LOCK_TABLE"    ,   Dump_LOCK_TABLE,
    "LOCK_ENTRY"    ,   Dump_LOCK_ENTRY,
    "LOOKUP_NAME"   ,   Dump_LOOKUP_NAME,
    "MSGINFO"       ,   Dump_DNS_MSGINFO,
    "SOCKADDR"      ,   Dump_SockAddr,
    "UPDATE"        ,   Dump_UPDATE,
    "UPDATE_LIST"   ,   Dump_UPDATE_LIST,
    "ZONE_INFO"     ,   Dump_ZONE_INFO,
    "SID"           ,   Dump_SID
};

const INT gcbDumpTable = (sizeof(gfDumpTable) / sizeof(DUMPENTRY) );


// functions //

/*+++
Function   : Dump_Help
Description: print out dump usage
Parameters : none.
Return     :
Remarks    : none.
---*/

DECLARE_DUMPFUNCTION( Dump_Help)
{
    Printf( "dnsexts.dump <DATATYPE> <ADDRESS>\n  <ADDRESS> := any hex debugger valid address\n" );
    Printf( "  <DATATYPE> :=\n" );
    Printf( "\tCOUNT_NAME: Counted name definition.\n" );
    Printf( "\tDB_NODE: Tree node definition.\n" );
    Printf( "\tDB_RECORD: RR structure.\n" );
    Printf( "\tDNS_HEADER: DNS Header.\n" );
    Printf( "\tDNS_WIRE_QUESTION: DNS Question.\n" );
    Printf( "\tHEAP_HEADER: DNS heap header.\n" );
    Printf( "\tHELP: print this screen.\n" );
    Printf( "\tIP_ARRAY: IP Address Array type.\n" );
    Printf( "\tLOCK_TABLE: Debug lock tracking table.\n" );
    Printf( "\tLOCK_ENTRY: Debug lock tracking entry.\n" );
    Printf( "\tLOOKUP_NAME: Lookup name definition.\n" );
    Printf( "\tMSGINFO: DNS Server Message Info structure.\n" );
    Printf( "\tSOCKADDR: Winsock address.\n" );
    Printf( "\tUPDATE: Update list entry.\n" );
    Printf( "\tUPDATE_LIST: Update list table.\n" );
    Printf( "\tZONE_INFO: Zone information type.\n" );
    Printf( "\tSID: Dump given SID.\n" );
    Printf( "---\n" );

    return TRUE;
}

/*+++
Function   : Dump_DNS_MSGINFO
Description: dumps out message info
Parameters :
Return     :
Remarks    : none.
---*/

DECLARE_DUMPFUNCTION( Dump_DNS_MSGINFO )
{
    Printf( "DNS_MSGINFO(0x%p):\n", lpVoid );

    if ( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }

    //
    //  DNS_MSGINFO header
    //

    PDNS_MSGINFO pMsg = (PDNS_MSGINFO) PushMemory( lpVoid, sizeof(DNS_MSGINFO) );;

    Printf( " ListEntry = {Flink=0x%p, Blink=0x%p}\n", pMsg->ListEntry.Flink, pMsg->ListEntry.Blink );
    Printf( " Socket = 0x%x\n", (DWORD)pMsg->Socket );
    Printf( " RemoteAddressLength = 0x%x (%d)\n", pMsg->RemoteAddressLength, pMsg->RemoteAddressLength );
    Printf( " RemoteAddress -- " );
    Dump_SockAddr((LPVOID)&(pMsg->RemoteAddress) );
    Printf( " BufferLength = 0x%x\n", pMsg->BufferLength );
    Printf( " pBufferEnd = 0x%p\n", pMsg->pBufferEnd );
    Printf( " pCurrent = 0x%p\n", pMsg->pCurrent );
    Printf( " pnodeCurrent = 0x%p\n", pMsg->pnodeCurrent );
    Printf( " pzoneCurrent = 0x%p\n", pMsg->pzoneCurrent );
    Printf( " pnodeDelegation = 0x%p\n", pMsg->pnodeDelegation );
    Printf( " wTypeCurrent = 0x%x\n", pMsg->wTypeCurrent );
    Printf( " wOffsetCurrent = 0x%x\n", pMsg->wOffsetCurrent );
    Printf( " pNodeQuestion = 0x%p\n", pMsg->pNodeQuestion );
    Printf( " pNodeNodeQuestionClosest = 0x%p\n", pMsg->pNodeQuestionClosest );
    Printf( " pQuestion = 0x%p\n", pMsg->pQuestion );
    Printf( " wQuestionType = 0x%x\n", pMsg->wQuestionType );
    Printf( " wQueuingXid = 0x%x\n", pMsg->wQueuingXid );
    Printf( " dwQueryTime = 0x%x\n", pMsg->dwQueryTime );
    Printf( " dwQueuingTime = 0x%x\n", pMsg->dwQueuingTime );
    Printf( " dwExpireTime = 0x%x\n", pMsg->dwExpireTime );
    Printf( " pRecurseMsg = 0x%p\n", pMsg->pRecurseMsg );
    Printf( " pnodeRecurseRetry = 0x%p\n", pMsg->pnodeRecurseRetry );
    Printf( " pNsList = 0x%p\n", pMsg->pNsList );
    Printf( " pConnection = 0x%p\n", pMsg->pConnection );
    Printf( " pchRecv = 0x%p\n", pMsg->pchRecv );
    Printf( " UnionMarker = 0x%x\n", pMsg->UnionMarker );

    //
    //   Union -- should get a union tag
    //

    {
        //
        // For now, print both Nbstat & Xfr images
        //

        Printf( " Union:\n" );

        //
        //  WINS info
        //

        {
            Printf( " (U.Wins):\n" );
            Printf( " pWinsRR = 0x%x\n",        pMsg->U.Wins.pWinsRR );
            Printf( " WinsNameBuffer = 0x%x\n", RELATIVE_ADDRESS(lpVoid, pMsg, pMsg->U.Wins.pWinsRR) );
            Printf( " cchWinsName = %d\n",      pMsg->U.Wins.cchWinsName );
        }

        //
        //  Nbstat info
        //

        {
            Printf( " (U.Nbstat):\n" );
            Printf( " pRR = 0x%p\n",                pMsg->U.Nbstat.pRR );
            Printf( " pNbstat = 0x%p\n",            pMsg->U.Nbstat.pNbstat );
            Printf( " ipNbstat = 0x%x\n",           pMsg->U.Nbstat.ipNbstat );
            Printf( " dwNbtInterfaceMask = 0x%x\n", pMsg->U.Nbstat.dwNbtInterfaceMask );
            Printf( " fNbstatResponded = %s\n",     pMsg->U.Nbstat.fNbstatResponded? "TRUE" : "FALSE" );
        }

        //
        //  Xfr
        //

        {
            Printf( " (U.Xfr):\n" );
            Printf( " dwMessageNumber = 0x%x\n",    pMsg->U.Xfr.dwMessageNumber );
            Printf( " dwSecondaryVersion = 0x%x\n", pMsg->U.Xfr.dwSecondaryVersion );
            Printf( " dwMasterVersion = 0x%x\n",    pMsg->U.Xfr.dwMasterVersion );
            Printf( " dwLastSoaVersion = 0x%x\n",   pMsg->U.Xfr.dwLastSoaVersion );
            Printf( " fReceivedStartSoa = %s\n",    pMsg->U.Xfr.fReceivedStartSoa?"TRUE":"FALSE" );
            Printf( " fBindTransfer = %s\n",        pMsg->U.Xfr.fBindTransfer?"TRUE":"FALSE" );
            Printf( " fMsTransfer = %s\n",          pMsg->U.Xfr.fMsTransfer?"TRUE":"FALSE" );
            Printf( " fLastPassAdd = %s\n",         pMsg->U.Xfr.fLastPassAdd?"TRUE":"FALSE" );
        }

        //
        //  Forward
        //

        {
            Printf( " (U.Forward):\n" );
            Printf( " OriginalSocket = 0x%x\n",    pMsg->U.Forward.OriginalSocket );
            Printf( " ipOriginal = 0x%x\n",        pMsg->U.Forward.ipOriginal );
            Printf( " wOriginalPort = 0x%x\n",     pMsg->U.Forward.wOriginalPort );
            Printf( " wOriginalXid = 0x%x\n",      pMsg->U.Forward.wOriginalXid );
        }
    }

    Printf( " pLooknameQuestion = 0x%p\n",pMsg->pLooknameQuestion );
    Printf( " FlagMarker = 0x%x\n", pMsg->FlagMarker );
    Printf( " fDelete = 0x%x\n", pMsg->fDelete );
    Printf( " fTcp = 0x%x\n", pMsg->fTcp );
    Printf( " fMessageComplete = 0x%x\n", pMsg->fMessageComplete );
    Printf( " Section = %d\n", pMsg->Section );
    Printf( " fDoAdditional = 0x%x\n", pMsg->fDoAdditional );
    Printf( " fRecurseIfNecessary = 0x%x\n", pMsg->fRecurseIfNecessary );
    Printf( " fRecursePacket = 0x%x\n", pMsg->fRecursePacket );
    Printf( " fQuestionRecursed = 0x%x\n", pMsg->fQuestionRecursed );
    Printf( " fQuestionCompleted = 0x%x\n", pMsg->fQuestionCompleted );
    Printf( " fRecurseQuestionSent = 0x%x\n", pMsg->fRecurseQuestionSent );
    Printf( " fRecurseTimeoutWait = 0x%x\n", pMsg->fRecurseTimeoutWait );
    Printf( " nForwarder = 0x%x\n", pMsg->nForwarder );
    Printf( " fReplaceCname = 0x%x\n", pMsg->fReplaceCname );
    Printf( " cCnameAnswerCount = %d\n", pMsg->cCnameAnswerCount );
    Printf( " fNoCompressionWrite = 0x%x\n", pMsg->fNoCompressionWrite );
    Printf( " fWins = 0x%x\n", pMsg->fWins );
    Printf( " fQuestionWildcard = 0x%x\n", pMsg->fQuestionWildcard );

    Printf( " Additional --\n" );
    Dump_ADDITIONAL_INFO( (LPVOID)&pMsg->Additional );

    Printf( " Compression --\n" );
    Dump_COMPRESSION_INFO( (LPVOID)&pMsg->Compression );
#if DBG
    Printf( " DbgListEntry = {Flink=0x%p; Blink=0x%p}\n", pMsg->DbgListEntry.Flink, pMsg->DbgListEntry.Blink );
#endif
    Printf( " dwForceAlignment = 0x%x\n", pMsg->dwForceAlignment );
    Printf( " BytesToReceive = 0x%x\n", pMsg->BytesToReceive );
    Printf( " MessageLength = 0x%x\n", pMsg->MessageLength );

    Printf( " Head --\n" );
    Dump_DNS_HEADER((LPVOID)&pMsg->Head );

    Printf( " MessageBody -- " );
    DumpBuffer((LPVOID)RELATIVE_ADDRESS(lpVoid, pMsg, pMsg->MessageBody), pMsg->MessageLength );

    PopMemory( (PVOID)pMsg );

    return TRUE;
}



/*+++
Function   : DumpSockAddr
Description: dumps sockaddr structure
Parameters :
Return     :
Remarks    : none.
---*/
DECLARE_DUMPFUNCTION( Dump_SockAddr)
{
    Printf( "SockAddr(0x%p):\n", lpVoid );

    if( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }

    //
    //  print sockaddr structure
    //

    PSOCKADDR_IN paddr = (PSOCKADDR_IN) PushMemory( lpVoid, sizeof(SOCKADDR_IN) );;

    Printf(
        " family = %d, port = %d, address = [%d:%d:%d:%d]\n",
        paddr->sin_family, paddr->sin_port,
        paddr->sin_addr.S_un.S_un_b.s_b1,
        paddr->sin_addr.S_un.S_un_b.s_b2,
        paddr->sin_addr.S_un.S_un_b.s_b3,
        paddr->sin_addr.S_un.S_un_b.s_b4 );

    PopMemory( (PVOID)paddr );

    return TRUE;
}


/*+++
Function   : Dump_DB_NODE
Description:
Parameters :
Return     :
Remarks    : none.
---*/
DECLARE_DUMPFUNCTION( Dump_DB_NODE)
{
    Printf( "DB_NODE(0x%p):\n", lpVoid );

    if ( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }

    //
    //  print node structure
    //

    PDB_NODE pnode = (PDB_NODE) PushMemory( lpVoid, sizeof(DB_NODE) );;

    Printf( " pParent = 0x%p\n", pnode->pParent );
    Printf( " pSibUp = 0x%p\n", pnode->pSibUp );
    Printf( " pSibLeft = 0x%p\n", pnode->pSibLeft );
    Printf( " pSibRight = 0x%p\n", pnode->pSibRight );
    Printf( " cChildren = %lu\n", pnode->cChildren );
    Printf( " pChildren = 0x%p\n", pnode->pChildren );
    Printf( " pZone = 0x%p\n", pnode->pZone );
    Printf( " pRRList = 0x%p\n", pnode->pRRList );
    Printf( " dwCompare = 0x%x\n", pnode->dwCompare );
    Printf( " cReferenceCount = %lu\n", pnode->cReferenceCount );
    Printf( " wNodeFlags = 0x%x\n", pnode->wNodeFlags );
    Printf( " uchAuthority = 0x%x\n", pnode->uchAuthority );
    Printf( " uchAccessbin = %d\n", (INT)pnode->uchAccessBin );
    Printf( " cchLabelLength = %d\n", (INT)pnode->cchLabelLength );
    Printf( " szLabel -- \n" );

    //  JBUGBUG:  this looks dubious if node bad\broken

    DumpBuffer(
        (LPVOID)RELATIVE_ADDRESS( lpVoid, pnode, pnode->szLabel ),
        ((INT)pnode->cchLabelLength < DNS_MAX_LABEL_LENGTH)
            ? (INT)pnode->cchLabelLength
            : DNS_MAX_LABEL_LENGTH );

    PopMemory( (PVOID)pnode );

    return TRUE;
}

/*+++
Function   : Dump_COUNT_NAME
Description:
Parameters :
Return     :
Remarks    : none.
---*/
DECLARE_DUMPFUNCTION( Dump_COUNT_NAME)
{
    Printf( "COUNT_NAME(0x%p):\n", lpVoid );

    if ( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }

    //
    //  print count name
    //

    PCOUNT_NAME pname = (PCOUNT_NAME) PushMemory( lpVoid, sizeof(COUNT_NAME) );

    Printf( " Length = %d\n", pname->Length );
    Printf( " LabelCount = %d\n", pname->LabelCount );
    Printf( " RawName -- \n" );

    DumpBuffer(
        (LPVOID)RELATIVE_ADDRESS(lpVoid, pname, pname->RawName),
        pname->Length > DNS_MAX_NAME_LENGTH
            ? DNS_MAX_NAME_LENGTH
            : pname->Length );

    PopMemory( (PVOID)pname );

    return TRUE;
}



/*+++
Function   : Dump_ZONE_INFO
Description:
Parameters :
Return     :
Remarks    : none.
---*/

DECLARE_DUMPFUNCTION( Dump_ZONE_INFO )
{
    Printf( "ZONE_INFO(0x%p):\n", lpVoid );

    if ( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }

    //
    // print structure
    //

    PZONE_INFO pzone = (PZONE_INFO) PushMemory( lpVoid, sizeof(ZONE_INFO) );

    Printf( " ListEntry           = [Flink=%p, Blink=%p]\n",
                                                pzone->ListEntry.Flink,
                                                pzone->ListEntry.Blink );
    Printf( " pszZoneName         = %p\n",      pzone->pszZoneName );
    Printf( " pwsZoneName         = %p\n",      pzone->pwsZoneName );
    Printf( " pCountName          = %p\n",      pzone->pCountName );
    Printf( " pZoneRoot           = %p\n",      pzone->pZoneRoot );
    Printf( " pTreeRoot           = %p\n",      pzone->pTreeRoot );
    Printf( " pZoneTreeLink       = %p\n",      pzone->pZoneTreeLink );
    Printf( " pLoadZoneRoot       = %p\n",      pzone->pLoadZoneRoot );
    Printf( " pLoadTreeRoot       = %p\n",      pzone->pLoadTreeRoot );
    Printf( " pLoadOrigin         = %p\n",      pzone->pLoadOrigin );
    Printf( " pOldTree            = %p\n",      pzone->pOldTree );
    Printf( " ---\n" );
    Printf( " pszDataFile         = %p\n",      pzone->pszDataFile );
    Printf( " pwzDataFile         = %p\n",      pzone->pwsDataFile );
    Printf( " pDelayedUpdateList  = %p\n",      pzone->pDelayedUpdateList );
    Printf( " pLockTable          = %p\n",      pzone->pLockTable );
    Printf( " pSoaRR              = %p\n",      pzone->pSoaRR );
    Printf( " pWinsRR             = %p\n",      pzone->pWinsRR );
    Printf( " pLocalWInsRR        = %p\n",      pzone->pLocalWinsRR );
    Printf( " pSD                 = %p\n",      pzone->pSD );
    Printf( " ---\n" );
    Printf( " fZoneType           = %d\n",      pzone->fZoneType );
    Printf( " fDsIntegrated       = %s\n",      pzone->fDsIntegrated ? "TRUE" : "FALSE" );
    Printf( " fAllowUpdate        = %d\n",      pzone->fAllowUpdate );
    Printf( " iRRCount            = %d\n",      pzone->iRRCount );
    Printf( " ---\n" );
    Printf( " ipReverse           = 0x%x\n",    pzone->ipReverse );
    Printf( " ipReverseMask       = 0x%x\n",    pzone->ipReverseMask );
    Printf( " dwSerialNo          = %lu\n",     pzone->dwSerialNo );
    Printf( " dwLoadSerialNo      = %lu\n",     pzone->dwLoadSerialNo );
    Printf( " dwLastXfrSerialNo   = %lu\n",     pzone->dwLastXfrSerialNo );
    Printf( " dwNewSerialNo       = %lu\n",     pzone->dwNewSerialNo );
    Printf( " dwDefaultTtl        = 0x%x\n",    pzone->dwDefaultTtl );
    Printf( " dwDefTtlHostOrder   = %lu\n",     pzone->dwDefaultTtlHostOrder );
    Printf( " ---\n" );

    Printf( " Master Info:\n" );
    Printf( " aipSecondaries      = %p\n",      pzone->aipSecondaries );
    Printf( " aipNotify           = %p\n",      pzone->aipNotify );
    Printf( " aipNameServers      = %p\n",      pzone->aipNameServers );
    Printf( " ---\n" );

    Printf( " Primary Info:\n" );
    Printf( " pwzLogFile          = %p\n",      pzone->pwsLogFile );
    Printf( " hfileUpdateLog      = 0x%x\n",    pzone->hfileUpdateLog );
    Printf( " iUpdateLogCount     = %d\n",      pzone->iUpdateLogCount );
    Printf( " bAging              = %s\n",      pzone->bAging ? "TRUE" : "FALSE" );
    Printf( " dwNoRefreshInterval = %lu\n",     pzone->dwNoRefreshInterval );
    Printf( " dwRefreshInterval   = %lu\n",     pzone->dwRefreshInterval );
    Printf( " dwRefreshTime       = %lu\n",     pzone->dwRefreshTime );
    Printf( " dwAgingEnabledTime  = %lu\n",     pzone->dwAgingEnabledTime );
    Printf( " aipScavengeServers  = %p\n",      pzone->aipScavengeServers );

    Printf( " DS Primary Info:\n" );
    Printf( " pwsZoneDN           = %p\n",      pzone->pwszZoneDN );
    //  FIXME
    Printf( " llSecureUpdateTime  = %p\n",      pzone->llSecureUpdateTime );
    Printf( " fDsRelaod           = %s\n",      pzone->fDsReload ? "TRUE" : "FALSE"  );
    Printf( " fInDsWrite          = %s\n",      pzone->fInDsWrite ? "TRUE" : "FALSE"  );
    Printf( " ucDsRecordVersion   = %d\n",      pzone->ucDsRecordVersion );
    Printf( " fLogUpdates         = %d\n",      pzone->fLogUpdates ? "TRUE" : "FALSE"  );
    Printf( " szLastUsn           = %p\n",      RELATIVE_ADDRESS(lpVoid, pzone, pzone->szLastUsn) );
    Printf( " ---\n" );

    Printf( " Secondary Info:\n" );
    Printf( " aipMasters          = %p\n",      pzone->aipMasters );
    //  Printf( " MasterInfoArray     = %p\n",      pzone->MasterInfoArray );
    Printf( " pszMasterIpString   = %p\n",      pzone->pszMasterIpString );
    Printf( " ipPrimary           = 0x%x\n",    pzone->ipPrimary );
    Printf( " ipNotifier          = 0x%x\n",    pzone->ipNotifier );
    Printf( " ipFreshMaster       = 0x%x\n",    pzone->ipFreshMaster );
    Printf( " ipXfrBind           = 0x%x\n",    pzone->ipXfrBind );
    Printf( " ipLastAxfrMaster    = 0x%x\n",    pzone->ipLastAxfrMaster );
    Printf( " dwLastSoaCheckTime  = %d\n",      pzone->dwLastSoaCheckTime );
    Printf( " dwNextSoaCheckTime  = %d\n",      pzone->dwNextSoaCheckTime );
    Printf( " dwExpireTime        = %d\n",      pzone->dwExpireTime );
    Printf( " dwZoneRecvStartTime = %d\n",      pzone->dwZoneRecvStartTime );
    Printf( " dwBadMasterCount    = %d\n",      pzone->dwBadMasterCount );
    Printf( " dwNextTranserTime   = %d\n",      pzone->dwNextTransferTime  );
    Printf( " fStale              = %s\n",      pzone->fStale ? "TRUE" : "FALSE"  );
    Printf( " fNotified           = %s\n",      pzone->fNotified ? "TRUE" : "FALSE"  );
    Printf( " fNeedAxfr           = %s\n",      pzone->fNeedAxfr ? "TRUE" : "FALSE"  );
    Printf( " fSkipIxfr           = %s\n",      pzone->fSkipIxfr ? "TRUE" : "FALSE"  );
    Printf( " fSlowRetry          = %s\n",      pzone->fSlowRetry ? "TRUE" : "FALSE"  );
    Printf( " cIxfrAttempts       = %d\n",      (INT)pzone->cIxfrAttempts );
    Printf( " fEmpty              = %s\n",      pzone->fEmpty ? "TRUE" : "FALSE"  );
    Printf( " ---\n" );

    Printf( " Locking:\n" );
    Printf( " dwLockingThreadId   = 0x%x\n",    pzone->dwLockingThreadId );
    Printf( " fLocked             = %d\n",      (INT)pzone->fLocked );
    Printf( " fUpdateLock         = %d\n",      pzone->fUpdateLock );
    Printf( " fXfrRecvLock        = %d\n",      pzone->fXfrRecvLock );
    Printf( " fFileWriteLock      = %d\n",      pzone->fFileWriteLock );
    Printf( " ---\n" );

    Printf( " Flags:\n" );
    Printf( " cZoneNameLabelCount = %d\n",  (INT)pzone->cZoneNameLabelCount );
    Printf( " fReverse            = %s\n",  pzone->fReverse ? "TRUE" : "FALSE"  );
    Printf( " fAutoCreated        = %s\n",  pzone->fAutoCreated ? "TRUE" : "FALSE"  );
    Printf( " fSecureSecondaries  = %d\n",  pzone->fSecureSecondaries  );
    Printf( " fNotifyLevel        = %d\n",  pzone->fNotifyLevel  );
    Printf( " fPaused             = %s\n",  pzone->fPaused ? "TRUE" : "FALSE"  );
    Printf( " fShutdown           = %s\n",  pzone->fShutdown ? "TRUE" : "FALSE"  );
    Printf( " fDirty              = %s\n",  pzone->fDirty ? "TRUE" : "FALSE"  );
    Printf( " fRootDirty          = %s\n",  pzone->fRootDirty ? "TRUE" : "FALSE"  );
    Printf( " fLocalWins          = %s\n",  pzone->fLocalWins ? "TRUE" : "FALSE"  );
    Printf( " ---\n" );

    Printf( " UpdateList          = %p\n", pzone->UpdateList );

    PopMemory( (PVOID)pzone );

    return TRUE;
}


/*+++
Function   : Dump_DB_RECORD
Description:
Parameters :
Return     :
Remarks    : none.
---*/
DECLARE_DUMPFUNCTION( Dump_DB_RECORD)
{
    Printf( "DB_RECORD(0x%p):\n", lpVoid );

    if ( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }

    //
    //  print record
    //

    PDB_RECORD prr = (PDB_RECORD) PushMemory( lpVoid, sizeof(DB_RECORD) );

    Printf( " pRRNext       = 0x%p\n",  prr->pRRNext );
    Printf( " RecordRank    = %d\n",    prr->RecordRank );
    Printf( " Reserved      = 0x%x\n",  (BYTE)( prr->Reserved.Source|
                                                prr->Reserved.Reserved|
                                                prr->Reserved.StandardAlloc) );
    Printf( " wRRFlags      = 0x%x\n",  prr->wRRFlags );
    Printf( " wType         = 0x%x\n",  prr->wType );
    Printf( " wDataLength   = 0x%x\n",  prr->wDataLength );
    Printf( " dwTtlSeconds  = 0x%x\n",  prr->dwTtlSeconds );
    Printf( " dwTimeStamp   = %lu\n",   prr->dwTimeStamp );

    Printf( " Data ---" );
    switch (prr->wType) {

    case DNS_TYPE_A:
        Printf( " (DNS_TYPE_A):\n" );
        Printf( " IpAddr = 0x%x\n", (DWORD)prr->Data.A.ipAddress );
        break;

    case DNS_TYPE_AAAA:
        Printf( " (DNS_TYPE_AAAA):\n" );
        Printf( " IP6Addr = [%x:%x:%x:%x;%x;%x;%x;%x]\n",
            prr->Data.AAAA.Ip6Addr.IP6Word[0],
            prr->Data.AAAA.Ip6Addr.IP6Word[1],
            prr->Data.AAAA.Ip6Addr.IP6Word[2],
            prr->Data.AAAA.Ip6Addr.IP6Word[3],
            prr->Data.AAAA.Ip6Addr.IP6Word[4],
            prr->Data.AAAA.Ip6Addr.IP6Word[5],
            prr->Data.AAAA.Ip6Addr.IP6Word[6],
            prr->Data.AAAA.Ip6Addr.IP6Word[7] );
       break;

    case DNS_TYPE_SOA:
        Printf( " (DNS_TYPE_SOA):\n" );
        Dump_Record_SOA( (LPVOID)&(prr->Data.SOA) );
        break;

    case DNS_TYPE_PTR:
        Printf( " (DNS_TYPE_PTR):\n" );
        Printf( " nameTarget = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, &prr->Data.PTR.nameTarget) );
        break;

    case DNS_TYPE_NS:
        Printf( " (DNS_TYPE_NS):\n" );
        Printf( " nameTarget = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, &prr->Data.NS.nameTarget) );
        break;

    case DNS_TYPE_CNAME:
        Printf( " (DNS_TYPE_CNAME):\n" );
        Printf( " nameTarget = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, &prr->Data.CNAME.nameTarget) );
        break;

    case DNS_TYPE_MB:
        Printf( " (DNS_TYPE_MB):\n" );
        Printf( " nameTarget = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, &prr->Data.MB.nameTarget) );
        break;
    case DNS_TYPE_MD:
        Printf( " (DNS_TYPE_MD):\n" );
        Printf( " nameTarget = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, &prr->Data.MD.nameTarget) );
        break;
    case DNS_TYPE_MF:
        Printf( " (DNS_TYPE_MF):\n" );
        Printf( " nameTarget = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, &prr->Data.MF.nameTarget) );
        break;
    case DNS_TYPE_MG:
        Printf( " (DNS_TYPE_MG):\n" );
        Printf( " nameTarget = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, &prr->Data.MG.nameTarget) );
        break;
    case DNS_TYPE_MR:
        Printf( " (DNS_TYPE_MR):\n" );
        Printf( " nameTarget = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, &prr->Data.MR.nameTarget) );
        break;

    case DNS_TYPE_MINFO:
        Printf( " (DNS_TYPE_MINFO):\n" );
        Printf( " nameMailbox = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, &prr->Data.MINFO.nameMailbox) );
        break;
    case DNS_TYPE_RP:
        Printf( " (DNS_TYPE_RP):\n" );
        Printf( " nameMailbox = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, &prr->Data.RP.nameMailbox) );
        break;

    case DNS_TYPE_MX:
        Printf( " (DNS_TYPE_MX):\n" );
        Printf( " wPreference = 0x%x\n", prr->Data.MX.wPreference );
        Printf( " nameExchange = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, &prr->Data.MX.nameExchange) );
        break;
    case DNS_TYPE_AFSDB:
        Printf( " (DNS_TYPE_AFSDB):\n" );
        Printf( " wPreference = 0x%x\n", prr->Data.AFSDB.wPreference );
        Printf( " nameExchange = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, &prr->Data.AFSDB.nameExchange) );
        break;
    case DNS_TYPE_RT:
        Printf( " (DNS_TYPE_RT):\n" );
        Printf( " wPreference = 0x%x\n", prr->Data.RT.wPreference );
        Printf( " nameExchange = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, &prr->Data.RT.nameExchange) );
        break;

    case DNS_TYPE_HINFO:
        Printf( " (DNS_TYPE_HINFO):\n" );
        Printf( " chData = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, prr->Data.HINFO.chData) );
        break;
    case DNS_TYPE_ISDN:
        Printf( " (DNS_TYPE_ISDN):\n" );
        Printf( " chData = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, prr->Data.ISDN.chData) );
        break;
    case DNS_TYPE_TEXT:
        Printf( " (DNS_TYPE_TEXT):\n" );
        Printf( " chData = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, prr->Data.TXT.chData) );
        break;
    case DNS_TYPE_NULL:
        Printf( " (DNS_TYPE_NULL):\n" );
        Printf( " chData = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, prr->Data.Null.chData) );
        break;

    case DNS_TYPE_WKS:
        Printf( " (DNS_TYPE_WKS):\n" );
        Printf( " ipAddress = 0x%x\n", prr->Data.WKS.ipAddress );
        Printf( " chProtocol = 0x%x\n", prr->Data.WKS.chProtocol );
        Printf( " bBitMask = @ 0x%p\n", RELATIVE_ADDRESS(lpVoid, prr, prr->Data.WKS.bBitMask) );
        break;

    case DNS_TYPE_SIG:
        Printf( " (DNS_TYPE_SIG):\n" );
        Printf( " nameSigner = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, &prr->Data.SIG.nameSigner) );
        Printf( " wTypeCovered = 0x%x\n", prr->Data.SIG.wTypeCovered );
        Printf( " chAlgorithm = 0x%x\n", prr->Data.SIG.chAlgorithm );
        Printf( " chLabelCount = 0x%x\n", prr->Data.SIG.chLabelCount );
        Printf( " dwOriginalTtl = 0x%x\n", prr->Data.SIG.dwOriginalTtl );
        Printf( " dwSigExpiration = 0x%x\n", prr->Data.SIG.dwSigExpiration );
        Printf( " dwSigInception = 0x%x\n", prr->Data.SIG.dwSigInception );
        Printf( " wKeyTag = 0x%x\n", prr->Data.SIG.wKeyTag );
        Printf( " Signature = 0x%p\n", RELATIVE_ADDRESS(lpVoid, prr,
            ( PBYTE ) &prr->Data.SIG.nameSigner +
            DBASE_NAME_SIZE( &prr->Data.SIG.nameSigner ) ) );
        break;

    case DNS_TYPE_KEY:
        Printf( " (DNS_TYPE_KEY):\n" );
        Printf( " wFlags = 0x%x\n", prr->Data.KEY.wFlags );
        Printf( " chProtocol = 0x%x\n", prr->Data.KEY.chProtocol );
        Printf( " chAlgorithm = 0x%x\n", prr->Data.KEY.chAlgorithm );
        Printf( " Key = 0x%p\n", RELATIVE_ADDRESS(lpVoid, prr, prr->Data.KEY.Key) );
        break;

    case DNS_TYPE_LOC:
        Printf( " (DNS_TYPE_LOC):\n" );
        Printf( " wVersion = 0x%x\n", prr->Data.LOC.wVersion );
        Printf( " wSize = 0x%x\n", prr->Data.LOC.wSize );
        Printf( " wHorPrec = 0x%x\n", prr->Data.LOC.wHorPrec );
        Printf( " wVerPrec = 0x%x\n", prr->Data.LOC.wVerPrec );
        Printf( " dwLatitude = 0x%x\n", prr->Data.LOC.dwLatitude );
        Printf( " dwLongitude = 0x%x\n", prr->Data.LOC.dwLongitude );
        Printf( " dwAltitude = 0x%x\n", prr->Data.LOC.dwAltitude );
        break;

    case DNS_TYPE_NXT:
        Printf( " (DNS_TYPE_NXT):\n" );
        Printf( " nameNext = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, &prr->Data.NXT.nameNext) );
        Printf( " bTypeBitMap = @ 0x%p\n", RELATIVE_ADDRESS(lpVoid, prr, prr->Data.NXT.bTypeBitMap) );
        break;

    case DNS_TYPE_SRV:
        Printf( " (DNS_TYPE_SRV):\n" );
        Printf( " wPriority = 0x%x\n", prr->Data.SRV.wPriority );
        Printf( " wWeight = 0x%x\n", prr->Data.SRV.wWeight );
        Printf( " wPort = 0x%x\n", prr->Data.SRV.wPort );
        Printf( " nameTarget = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, &prr->Data.SRV.nameTarget) );
        break;

    case DNS_TYPE_TSIG:
        Printf( " (DNS_TYPE_TSIG):\n" );
        Printf( " dwTimeSigned = 0x%x\n", prr->Data.TSIG.dwTimeSigned );
        Printf( " dwTimeExpire = 0x%x\n", prr->Data.TSIG.dwTimeExpire );
        Printf( " wSigLength = 0x%x\n", prr->Data.TSIG.wSigLength );
        Printf( " bSignature = @ 0x%x\n", RELATIVE_ADDRESS(lpVoid, prr, prr->Data.TSIG.bSignature) );
        Printf( " nameAlgorithm = @ 0x%p\n", RELATIVE_ADDRESS(lpVoid, prr, &prr->Data.TSIG.nameAlgorithm) );
        break;

    case DNS_TYPE_TKEY:
        Printf( " (DNS_TYPE_TKEY):\n" );
        Printf( " wKeyLength = 0x%x\n", prr->Data.TKEY.wKeyLength );
        Printf( " bKey = @ 0x%p\n", RELATIVE_ADDRESS(lpVoid, prr, prr->Data.TKEY.bKey) );
        break;

    case DNS_TYPE_WINS:
        Printf( " (DNS_TYPE_WINS):\n" );
        Printf( " dwMappingFlag = 0x%x\n", prr->Data.WINS.dwMappingFlag );
        Printf( " dwLookupTimeout = 0x%x\n", prr->Data.WINS.dwLookupTimeout );
        Printf( " dwCacheTimeout = 0x%x\n", prr->Data.WINS.dwCacheTimeout );
        Printf( " cWinsServerCount = 0x%x\n", prr->Data.WINS.cWinsServerCount );
        Printf( " aipWinsServers = 0x%x\n", prr->Data.WINS.aipWinsServers );
        break;

    case DNS_TYPE_WINSR:
        Printf( " (DNS_TYPE_WINSR):\n" );
        Printf( " dwMappingFlag = 0x%x\n", prr->Data.WINSR.dwMappingFlag );
        Printf( " dwLookupTimeout = 0x%x\n", prr->Data.WINSR.dwLookupTimeout );
        Printf( " dwCacheTimeout = 0x%x\n", prr->Data.WINSR.dwCacheTimeout );
        Printf( " nameResultDomain = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, prr, &prr->Data.WINSR.nameResultDomain) );
        break;

    default:
        Printf( "\n  Error: Unknown wType value (0x%x).\n", prr->wType );
    }

    PopMemory( (PVOID)prr );

    return TRUE;
}



/*+++
Function   : Dump_IP_ARRAY
Description:
Parameters :
Return     :
Remarks    : none.
---*/
DECLARE_DUMPFUNCTION( Dump_IP_ARRAY)
{
    Printf( "IP_ARRAY(0x%p):\n", lpVoid );

    if ( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }

   //
   // print structure
   //
   PIP_ARRAY pIp = (PIP_ARRAY) PushMemory( lpVoid, sizeof(IP_ARRAY) );
   INT iMax= pIp->AddrCount > MAX_TINY_LIST ? MAX_TINY_LIST : (INT)pIp->AddrCount;

    Printf( " AddrCount = 0x%x\n", pIp->AddrCount );

   PIP_ADDRESS addr = (PIP_ADDRESS) PushMemory( (LPVOID)RELATIVE_ADDRESS(lpVoid, pIp, pIp->AddrArray), sizeof(IP_ADDRESS)*iMax );
   for(INT i=0; i< iMax; i++){
       Printf( " AddrArray[%2d] = 0x%x\n", addr[i] );
   }
   PopMemory( (PVOID)addr );

   if(pIp->AddrCount > MAX_TINY_LIST){
       Printf( " (truncated)...\n" );
   }

   PopMemory( (PVOID)pIp );

   return TRUE;
}






/*+++
Function   : Dump_LOCK_TABLE
Description:
Parameters :
Return     :
Remarks    : none.
---*/
DECLARE_DUMPFUNCTION( Dump_LOCK_TABLE)
{
    Printf( "LOCK_TABLE(0x%p):\n", lpVoid );

    if ( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }

   //
   // print structure
   //
   PLOCK_TABLE ptab = (PLOCK_TABLE) PushMemory( lpVoid, sizeof(LOCK_TABLE) );;

    Printf( " pszName = 0x%p\n", ptab );
    Printf( " FailuresSinceLockFree = 0x%x\n", ptab->FailuresSinceLockFree );
    Printf( " LastFreeLockTime = 0x%x\n", ptab->LastFreeLockTime );
    Printf( " Index = 0x%x\n", ptab->Index );
    Printf( " OffenderLock = 0x%p\n", ptab->OffenderLock );
    Printf( " LockHistory = 0x%p\n", (LPVOID)RELATIVE_ADDRESS(lpVoid, ptab, ptab->LockHistory) );

   PopMemory( (PVOID)ptab );
   return TRUE;
}


/*+++
Function   : Dump_LOCK_ENTRY
Description:
Parameters :
Return     :
Remarks    : none.
---*/
DECLARE_DUMPFUNCTION( Dump_LOCK_ENTRY)
{
    Printf( "LOCK_ENTRY(0x%p):\n", lpVoid );

    if ( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }

    PLOCK_ENTRY pe = (PLOCK_ENTRY) PushMemory( lpVoid, sizeof(LOCK_ENTRY) );

    Printf( " Count = %ld\n", pe->Count );
    Printf( " ThreadId = 0x%x\n", pe->ThreadId );
    Printf( " File = 0x%p\n", pe );
    Printf( " Line = %lu\n", pe->Line );

    PopMemory( (PVOID)pe );

    return TRUE;
}


/*+++
Function   : Dump_UPDATE
Description:
Parameters :
Return     :
Remarks    : none.
---*/
DECLARE_DUMPFUNCTION( Dump_UPDATE)
{
    Printf( "UPDATE(0x%p):\n", lpVoid );

    if ( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }
   //
   // print structure
   //
   PUPDATE p = (PUPDATE) PushMemory( lpVoid, sizeof(UPDATE) );

    Printf( " pNext = 0x%x\n", p->pNext );
    Printf( " pNode = 0x%p\n", p->pNode );
    Printf( " pAddRR = 0x%p\n", p->pAddRR );
    Printf( " pDeleteRR =0x%p\n", p->pDeleteRR );
    Printf( " dwVersion = 0x%x\n", p->dwVersion );
    Printf( " wDeleteType = 0x%x\n", p->wDeleteType );
    Printf( " wAddType = 0x%x\n", p->wAddType );

   PopMemory( (PVOID)p );

   return TRUE;
}


/*+++
Function   : Dump_UPDATE_LIST
Description:
Parameters :
Return     :
Remarks    : none.
---*/
DECLARE_DUMPFUNCTION( Dump_UPDATE_LIST)
{
    Printf( "UPDATE_LIST(0x%p):\n", lpVoid );

    if ( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }
   PUPDATE_LIST p = (PUPDATE_LIST) PushMemory( lpVoid, sizeof(UPDATE_LIST) );

    Printf( " pListHead = 0x%p\n", p->pListHead );
    Printf( " pCurrent = 0x%p\n", p->pCurrent );
    Printf( " pTempNodeList = 0x%p\n", p->pTempNodeList );
    Printf( " pNodeFailed = 0x%p\n", p->pNodeFailed );
    Printf( " pMsg = 0x%x\n", p->pMsg );
    Printf( " Flag = 0x%x\n", p->Flag );
    Printf( " dwCount = 0x%x\n", p->dwCount );
    Printf( " dwStartVersion = 0x%x\n", p->dwStartVersion );
    Printf( " dwHighDsVersion = 0x%x\n", p->dwHighDsVersion );

   PopMemory( (PVOID)p );

   return TRUE;
}





/*+++
Function   : Dump_DNS_WIRE_QUESTION
Description:
Parameters :
Return     :
Remarks    : none.
---*/
DECLARE_DUMPFUNCTION( Dump_DNS_WIRE_QUESTION)
{
    Printf( "DNS_WIRE_QUESTION(0x%p):\n", lpVoid );

    if ( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }
   PDNS_WIRE_QUESTION p = (PDNS_WIRE_QUESTION) PushMemory( lpVoid, sizeof(DNS_WIRE_QUESTION) );

    Printf( " QuestionType = 0x%x\n", p->QuestionType );
    Printf( " QuestionClass = 0x%x\n", p->QuestionClass );

   PopMemory( (PVOID)p );

   return TRUE;
}



/*+++
Function   : Dump_DNS_HEADER
Description: dumps sockaddr structure
Parameters :
Return     :
Remarks    : none.
---*/
DECLARE_DUMPFUNCTION( Dump_DNS_HEADER)
{
    Printf( "DNS_HEADER(0x%p):\n", lpVoid );

    if ( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }

    PDNS_HEADER p = (PDNS_HEADER) PushMemory( lpVoid, sizeof(DNS_HEADER) );

    Printf( " Xid = 0x%x\n", p->Xid );
    Printf( " RecursionDesired = 0x%x\n", p->RecursionDesired );
    Printf( " Truncation = 0x%x\n", p->Truncation );
    Printf( " Authoritative = 0x%x\n", p->Authoritative );
    Printf( " Opcode = 0x%x\n", p->Opcode );
    Printf( " IsResponse = 0x%x\n", p->IsResponse );
    Printf( " ResponseCode = 0x%x\n", p->ResponseCode );
    Printf( " Reserved = 0x%x\n", p->Reserved );
    Printf( " RecursionAvailable = 0x%x\n", p->RecursionAvailable );
    Printf( " QuestionCount = 0x%x\n", p->QuestionCount );
    Printf( " AnswerCount = 0x%x\n", p->AnswerCount );
    Printf( " NameServerCount = 0x%x\n", p->NameServerCount );
    Printf( " AdditionalCount = 0x%x\n", p->AdditionalCount );


   PopMemory( (PVOID)p );

   return TRUE;
}



/*+++
Function   : HEAP_HEADER
Description: dumps out additional message info
Parameters :
Return     :
Remarks    : none.
---*/
DECLARE_DUMPFUNCTION( Dump_HEAP_HEADER)
{
   // from heapdbg.h

#define HEAP_HEADER_FILE_SIZE   (16)

   struct _HEAP_HEADER
   {
        //
        //  Note, if move or add fields, MUST update list entry offset below
        //

        ULONG       HeapCodeBegin;
        ULONG       AllocCount;
        ULONG       RequestSize;
        ULONG       AllocSize;

        //
        //  Put LIST_ENTRY in middle of header
        //      - keep begin code at front
        //      - less likely to be corrupted
        //

        LIST_ENTRY  ListEntry;

        DWORD       AllocTime;
        DWORD       LineNo;
        CHAR        FileName[ HEAP_HEADER_FILE_SIZE ];

        ULONG       TotalAlloc;
        ULONG       CurrentAlloc;
        ULONG       FreeCount;
        ULONG       CurrentAllocCount;
        ULONG       HeapCodeEnd;
    };

    Printf( "HEAP_HEADER(0x%p):\n", lpVoid );

    if ( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }

    _HEAP_HEADER *p = (_HEAP_HEADER*) PushMemory( lpVoid, sizeof(_HEAP_HEADER) );

    Printf( " HeapCodeBegin = 0x%x\n", p->HeapCodeBegin );
    Printf( " AllocCount = 0x%x\n", p->AllocCount );
    Printf( " RequestSize = 0x%x\n", p->RequestSize );
    Printf( " AllocSize = 0x%x\n", p->AllocSize );

   //
   //  Put LIST_ENTRY in middle of header
   //      - keep begin code at front
   //      - less likely to be corrupted
   //

    Printf( " ListEntry = 0x%x\n", p->ListEntry );
    Printf( " AllocTime = 0x%x\n", p->AllocTime );
    Printf( " LineNo = %lu\n", p->LineNo );
    Printf( " FileName -- \n", p->FileName );
   DumpBuffer((LPVOID)RELATIVE_ADDRESS(lpVoid, p, p->FileName), HEAP_HEADER_FILE_SIZE  );
    Printf( " TotalAlloc = 0x%x\n", p->TotalAlloc );
    Printf( " CurrentAlloc = 0x%x\n", p->CurrentAlloc );
    Printf( " FreeCount = 0x%x\n", p->FreeCount );
    Printf( " CurrentAllocCount = 0x%x\n", p->CurrentAllocCount );
    Printf( " HeapCodeEnd = 0x%x\n", p->HeapCodeEnd );

   PopMemory( (PVOID)p );

   return TRUE;
}





/*+++
Function   : Dump_Record_SOA
Description:
Parameters :
Return     :
Remarks    : none.
---*/
DECLARE_DUMPFUNCTION( Dump_LOOKUP_NAME){
    Printf( "LOOKUP_NAME(0x%p):\n", lpVoid );

    if ( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }

    PLOOKUP_NAME p = (PLOOKUP_NAME) PushMemory( lpVoid, sizeof(LOOKUP_NAME) );

    Printf( " cLabelCount = %d\n", p->cLabelCount );
    Printf( " cchNameLength = %d\n", p->cchNameLength );
    Printf( " pchLabelArray --\n" );

    // if cLableCountis bad, forget about it.

    INT iMax;
    iMax  = p->cLabelCount < DNS_MAX_NAME_LABELS ? p->cLabelCount : 0;
    INT i;

    for(i=0;i<iMax;i++)
    {
        Printf( " [%d] 0x%p\n", i, p->pchLabelArray[i] );
    }
    Printf( " cchLabelArray -- \n" );
    iMax  = p->cchNameLength < DNS_MAX_NAME_LABELS ? p->cchNameLength : DNS_MAX_NAME_LABELS;
    DumpBuffer((LPVOID)RELATIVE_ADDRESS(lpVoid, p, p->cchLabelArray), iMax );

    PopMemory( (PVOID)p );

    return TRUE;
}



/*+++
Function   : Dump_SID
Description:
Parameters :
Return     :
Remarks    : none.
---*/

DECLARE_DUMPFUNCTION( Dump_SID)
{

#define MAX_SID_STR_LENGTH          1024

    Printf( "SID(0x%p):\n", lpVoid );

    if ( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }

    PSID pSid = (PSID) PushMemory( lpVoid, sizeof(SID) );
    CHAR szSid [ MAX_SID_STR_LENGTH ];
    DWORD cbSid = GetLengthSid(pSid );

    if ( !cbSid ||
         !IsValidSid(pSid) )
    {
         Printf( "Formatting aborted. Invalid SID\n" );
    }
    else
    {
        CHAR buffer[ 1024 ];

        UCHAR authCount = *GetSidSubAuthorityCount(pSid );


        strcpy ( szSid, "S-"  );

        for (INT i=0; i<(INT)authCount; i++)
        {
            DWORD dwAuth = *GetSidSubAuthority(pSid,
                                               i );
            sprintf( buffer, "%X", dwAuth  );

            if ( strlen(szSid) + strlen(buffer) > MAX_SID_STR_LENGTH - 5 )
            {
                strcat ( szSid, "..."  );
                 break;
            }
            strcat ( szSid, buffer  );
            if (i < (INT)authCount-1)
            {
                strcat ( szSid, "-"  );
            }
        }
    }

    Printf ( "SID = %s\n", szSid  );

    PopMemory( (PVOID)pSid );

    return TRUE;

#undef  MAX_SID_STR_LENGTH
}




/*+++
Function   : Dump_ADDITIONAL_INFO
Description: dumps out additional message info
Parameters :
Return     :
Remarks    : none.
---*/
DECLARE_DUMPFUNCTION( Dump_ADDITIONAL_INFO)
{
    Printf( "ADDITIONAL_INFO(0x%p):\n", lpVoid );

    if ( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }
   if(!lpVoid){
       Printf( "Cannot process [%p] pointer\n", lpVoid );
      return FALSE;
   }
   //
   // print structure
   //

   PADDITIONAL_INFO p = (PADDITIONAL_INFO) PushMemory( lpVoid, sizeof(ADDITIONAL_INFO) );
   INT i=0, iMax=0;

    Printf( "   cMaxCount = 0x%x\n", p->cMaxCount );
    Printf( "   cCount = 0x%x\n", p->cCount );
    Printf( "   iIndex = 0x%x\n", p->iIndex );

   iMax = p->cCount <= MAX_ADDITIONAL_RECORD_COUNT? p->cCount : MAX_ADDITIONAL_RECORD_COUNT;

   PDB_NAME* pnames = (PDB_NAME*) PushMemory(
                                    (LPVOID) RELATIVE_ADDRESS(lpVoid, p, p->pNameArray),
                                    sizeof(PDB_NAME)*iMax  );
   for(i=0; i<iMax; i++){
       Printf( "    pNameArray[%d] = 0x%p\n", i, pnames[i] );
   }
   PopMemory( (PVOID)pnames );
   if(i > MAX_TINY_LIST){
       Printf( "    (truncated)...\n" );
   }

   WORD* poffsets = (WORD*) PushMemory(
                                  (LPVOID)RELATIVE_ADDRESS(lpVoid, p, p->wOffsetArray),
                                  sizeof(WORD)*iMax );
   for(i=0; i<iMax; i++){
       Printf( "    wOffsetArray[%d] = 0x%x\n", i, poffsets[i] );
   }
   PopMemory( (PVOID)poffsets );
   if(i > MAX_ADDITIONAL_RECORD_COUNT){
       Printf( "    (truncated)...\n" );
   }

   PopMemory( (PVOID)p );

   return TRUE;
}




/*+++
Function   : Dump_COMPRESSION_INFO
Description: dumps out additional message info
Parameters :
Return     :
Remarks    : none.
---*/
DECLARE_DUMPFUNCTION( Dump_COMPRESSION_INFO)
{
    Printf( "COMPRESSION_INFO(0x%p):\n", lpVoid );

    if ( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }
   if(!lpVoid){
       Printf( "Cannot process [%p] pointer\n", lpVoid );
      return FALSE;
   }
   //
   // print structure
   //
   PCOMPRESSION_INFO p = (PCOMPRESSION_INFO) PushMemory( lpVoid, sizeof(COMPRESSION_INFO) );
   INT i=0, iMax=0;

    Printf( " cCount = 0x%x\n", p->cCount );

   PDB_NODE* pnodes = (PDB_NODE*) PushMemory( (LPVOID)RELATIVE_ADDRESS(lpVoid, p, p->pNodeArray), sizeof(PDB_NODE)*iMax );
   iMax = p->cCount <= MAX_COMPRESSION_COUNT? p->cCount : MAX_COMPRESSION_COUNT;
   for(i=0; i<iMax; i++){
       Printf( " pNodeArray[%d] = 0x%p\n", i, pnodes[i] );
   }
   PopMemory( (PVOID)pnodes );
   if(i > MAX_COMPRESSION_COUNT){
       Printf( " (truncated)...\n" );
   }
   WORD* poffsets = (WORD*) PushMemory( (LPVOID)RELATIVE_ADDRESS(lpVoid, p, p->wOffsetArray), sizeof(WORD)*iMax );
   for(i=0; i<iMax; i++){
       Printf( " wOffsetArray[%d] = 0x%p\n", i, poffsets[i] );
   }
   PopMemory( (PVOID)poffsets );
   if(i > MAX_COMPRESSION_COUNT){
       Printf( " (truncated)...\n" );
   }



   PopMemory( (PVOID)p );

   return TRUE;
}





/*+++
Function   : Dump_DS_SEARCH
Description:
Parameters :
Return     :
Remarks    : none.
---*/
DECLARE_DUMPFUNCTION( Dump_DS_SEARCH)
{
   // from DS.c
   struct _DnsDsEnum
   {
       PLDAPSearch     pSearchBlock;           // ldap search result on zone
       PLDAPMessage    pResultMessage;         // current page of message
       PLDAPMessage    pNodeMessage;           // message for current node
       PZONE_INFO      pZone;
       LONGLONG        SearchTime;
       LONGLONG        TombstoneExpireTime;
       DWORD           dwSearchFlag;
       DWORD           dwLookupFlag;
       DWORD           dwHighestVersion;
       DWORD           dwTotalNodes;
       DWORD           dwTotalTombstones;
       DWORD           dwTotalRecords;
   #if 0
       DWORD           dwHighUsnLength;
       CHAR            szHighUsn[ MAX_USN_LENGTH ];    // largest USN in enum
   #endif
       CHAR            szStartUsn[ MAX_USN_LENGTH ];   // USN at search start

       //  node record data

       PLDAP_BERVAL *  ppBerval;           // the values in the array
       PDB_RECORD      pRecords;
       DWORD           dwRecordCount;
       DWORD           dwNodeVersion;
       DWORD           dwTombstoneVersion;
   };


    Printf( "DS_SEARCH(0x%p):\n", lpVoid );

    if ( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }

   //
   // print structure
   //
   struct _DnsDsEnum *p = (struct _DnsDsEnum*) PushMemory( lpVoid, sizeof(struct _DnsDsEnum) );

    Printf( " pSearchBlock = 0x%p\n", p->pSearchBlock );
    Printf( " pResultMessage = 0x%p\n", p->pResultMessage );
    Printf( " pNodeMessage = 0x%p\n", p->pNodeMessage );
    Printf( " pZone = 0x%p\n", p->pZone );
    Printf( " SearchTime = 0x%x:0x%x\n", (DWORD)(p->SearchTime>>32), (DWORD)(p->SearchTime & 0x00000000ffffffff) );
    Printf( " TombstoneExpireTime = 0x%x:0x%x\n", (DWORD)(p->TombstoneExpireTime>>32),(DWORD)(p->TombstoneExpireTime & 0x00000000ffffffff) );
    Printf( " dwSearchFlag = 0x%x\n", p->dwSearchFlag );
    Printf( " dwLookupFlag = 0x%x\n", p->dwLookupFlag );
    Printf( " dwHighestVersion = 0x%x\n", p->dwHighestVersion );
    Printf( " dwTotalNodes = 0x%x\n", p->dwTotalNodes );
    Printf( " dwTotalTombstones = 0x%x\n", p->dwTotalTombstones );
    Printf( " dwTotalRecords = 0x%x\n", p->dwTotalRecords );
#if 0
    Printf( " dwHighUsnLength = 0x%x\n", p->dwHighUsnLength );
    Printf( " szHighUsn = 0x%p\n", RELATIVE_ADDRESS(lpVoid, p, p->szHighUsn) );
#endif
    Printf( " szStartUsn = 0x%p\n", RELATIVE_ADDRESS(lpVoid, p, p->szStartUsn) );

   //  node record data

    Printf( " ppBerval = 0x%p\n", p->ppBerval );
    Printf( " pRecords = 0x%p\n", p->pRecords );
    Printf( " dwRecordCount = 0x%x\n", p->dwRecordCount );
    Printf( " dwNodeVersion = 0x%x\n", p->dwNodeVersion );
    Printf( " dwTombstoneVersion = 0x%x\n", p->dwTombstoneVersion );

   PopMemory( (PVOID)p );

   return TRUE;
}

/*+++
Function   : Dump_Record_SOA
Description:
Parameters :
Return     :
Remarks    : none.
---*/
DECLARE_DUMPFUNCTION( Dump_Record_SOA)
{
    struct SOA
    {
        PDB_NODE        pnodePrimaryServer;
        PDB_NODE        pnodeZoneAdmin;
        DWORD           dwSerialNo;
        DWORD           dwRefresh;
        DWORD           dwRetry;
        DWORD           dwExpire;
        DWORD           dwMinimumTtl;
    };

    Printf( "DB_RECORD.SOA(0x%p):\n", lpVoid );

    if ( !lpVoid )
    {
        Printf( "Cannot process [%p] pointer\n", lpVoid );
        return FALSE;
    }

    struct SOA *psoa = (struct SOA*) PushMemory( lpVoid, sizeof(struct SOA) );

    Printf( " pnodePrimaryServer    = 0x%p\n",  psoa->pnodePrimaryServer );
    Printf( " pnodeZoneAdmin        = 0x%p\n",  psoa->pnodeZoneAdmin );
    Printf( " dwSerialNo            = 0x%x\n",  psoa->dwSerialNo );
    Printf( " dwRefresh             = 0x%x\n",  psoa->dwRefresh );
    Printf( " dwRetry               = 0x%x\n",  psoa->dwRetry );
    Printf( " dwExpire              = 0x%x\n",  psoa->dwExpire );
    Printf( " dwMinimumTtl          = 0x%x\n",  psoa->dwMinimumTtl );

    PopMemory( (PVOID)psoa );

    return TRUE;
}


/*++
Routine Description: Dumps the buffer content on to the debugger output.
Arguments:
    Buffer: buffer pointer.
    BufferSize: size of the buffer.
Return Value: none
Author: borrowed from MikeSw
--*/
VOID DumpBuffer(PVOID Buffer, DWORD BufferSize){
#define DUMPBUFFER_NUM_CHARS 16

    DWORD i, limit;
    CHAR TextBuffer[DUMPBUFFER_NUM_CHARS + 1];
    LPBYTE BufferPtr = (LPBYTE) PushMemory( Buffer, BufferSize );


     Printf( "----------------(0x%p)--------------\n", Buffer );

    //
    // Hex dump of the bytes
    //
    limit = ((BufferSize - 1) / DUMPBUFFER_NUM_CHARS + 1) * DUMPBUFFER_NUM_CHARS;

    for (i = 0; i < limit; i++) {

        if (i < BufferSize) {

             Printf( "%02x ", BufferPtr[i] );

            if (BufferPtr[i] < 31 ) {
                TextBuffer[i % DUMPBUFFER_NUM_CHARS] = '.';
            } else if (BufferPtr[i] == '\0') {
                TextBuffer[i % DUMPBUFFER_NUM_CHARS] = ' ';
            } else {
                TextBuffer[i % DUMPBUFFER_NUM_CHARS] = (CHAR) BufferPtr[i];
            }

        } else {

             Printf( "  " );
            TextBuffer[i % DUMPBUFFER_NUM_CHARS] = ' ';

        }

        if ((i + 1) % DUMPBUFFER_NUM_CHARS == 0) {
            TextBuffer[DUMPBUFFER_NUM_CHARS] = 0;
             Printf( "  %s\n", TextBuffer );
        }

    }

     Printf( "------------------------------------\n" );

    PopMemory( (PVOID)BufferPtr );

#define DUMPBUFFER_NUM_CHARS 16
}

#endif  // DUMP_CXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\dnsutil.c ===
/*++

Copyright (c) 1996-2001  Microsoft Corporation

Module Name:

    dnsutil.c

Abstract:

    Domain Name System (DNS) Library

    General DNS utilities.

Author:

    Jim Gilroy (jamesg)     Decemeber 1996

Revision History:

--*/


#include "local.h"



IP_ADDRESS
Dns_GetNetworkMask(
    IN      IP_ADDRESS      ipAddress
    )
/*++

Routine Description:

    Gets network mask for IP address.
    Note, this is standard IP network mask for address type,
    obviously subnetting is unknown.

Arguments:

    ipAddress -- IP to get mask for

Return Value:

    Network mask in network byte order.

--*/
{
    //  note addresses and masks are in netbyte order
    //  which we are treating as byte flipped and hence
    //  test the high bits in the low byte

    //  class A?

    if ( ! (0x80 & ipAddress) )
    {
        return( 0x000000ff );
    }

    //  class B?

    if ( ! (0x40 & ipAddress) )
    {
        return( 0x0000ffff );
    }

    //  then class C
    //  yes, there's some multicast BS out there, I don't
    //  believe it requires any special handling

    return( 0x00ffffff );
}



//
//  DNS status\error mappings
//
//  DCR:  investigate tossing error mappings
//      and have all errors in Win32 system
//

typedef struct _DnsStatusStringMap
{
    DNS_STATUS  Status;
    PCHAR       String;
}
DNS_STATUS_STRING_MAP;

#define DNS_MAP_END     ((DWORD)(-1))

#define DNS_MAP_ENTRY( _ErrorCode )   _ErrorCode, #_ErrorCode


DNS_STATUS_STRING_MAP DnsStatusStringMappings[] =
{
    //
    //  Response codes
    //

    DNS_ERROR_RCODE_NO_ERROR                ,"ERROR_SUCCESS",
    DNS_ERROR_RCODE_FORMAT_ERROR            ,"RCODE_FORMAT_ERROR",
    DNS_ERROR_RCODE_SERVER_FAILURE          ,"RCODE_SERVER_FAILURE",
    DNS_ERROR_RCODE_NAME_ERROR              ,"RCODE_NAME_ERROR",
    DNS_ERROR_RCODE_NOT_IMPLEMENTED         ,"RCODE_NOT_IMPLEMENTED",
    DNS_ERROR_RCODE_REFUSED                 ,"RCODE_REFUSED",
    DNS_ERROR_RCODE_YXDOMAIN                ,"RCODE_YXDOMAIN",
    DNS_ERROR_RCODE_YXRRSET                 ,"RCODE_YXRRSET",
    DNS_ERROR_RCODE_NXRRSET                 ,"RCODE_NXRRSET",
    DNS_ERROR_RCODE_NOTAUTH                 ,"RCODE_NOTAUTH",
    DNS_ERROR_RCODE_NOTZONE                 ,"RCODE_NOTZONE",
    DNS_ERROR_RCODE_BADSIG                  ,"RCODE_BADSIG",
    DNS_ERROR_RCODE_BADKEY                  ,"RCODE_BADKEY",
    DNS_ERROR_RCODE_BADTIME                 ,"RCODE_BADTIME",

    //
    //  Packet format
    //

    DNS_INFO_NO_RECORDS                     ,"DNS_INFO_NO_RECORDS",
    DNS_ERROR_BAD_PACKET                    ,"DNS_ERROR_BAD_PACKET",
    DNS_ERROR_NO_PACKET                     ,"DNS_ERROR_NO_PACKET",
    DNS_ERROR_RCODE                         ,"DNS_ERROR_RCODE",
    DNS_ERROR_UNSECURE_PACKET               ,"DNS_ERROR_UNSECURE_PACKET",

    //
    //  General API errors
    //

    DNS_ERROR_INVALID_NAME                  ,"ERROR_INVALID_NAME",
    DNS_ERROR_INVALID_DATA                  ,"ERROR_INVALID_DATA",
    DNS_ERROR_INVALID_TYPE                  ,"ERROR_INVALID_TYPE",
    DNS_ERROR_INVALID_IP_ADDRESS            ,"DNS_ERROR_INVALID_IP_ADDRESS",
    DNS_ERROR_INVALID_PROPERTY              ,"DNS_ERROR_INVALID_PROPERTY",
    DNS_ERROR_TRY_AGAIN_LATER               ,"DNS_ERROR_TRY_AGAIN_LATER",
    DNS_ERROR_NOT_UNIQUE                    ,"DNS_ERROR_NOT_UNIQUE",
    DNS_ERROR_NON_RFC_NAME                  ,"DNS_ERROR_NON_RFC_NAME",
    DNS_STATUS_FQDN                         ,"DNS_STATUS_FQDN",
    DNS_STATUS_DOTTED_NAME                  ,"DNS_STATUS_DOTTED_NAME",
    DNS_STATUS_SINGLE_PART_NAME             ,"DNS_STATUS_SINGLE_PART_NAME",
    DNS_ERROR_INVALID_NAME_CHAR             ,"DNS_ERROR_INVALID_NAME_CHAR",
    DNS_ERROR_NUMERIC_NAME                  ,"DNS_ERROR_NUMERIC_NAME",

    //
    //  Server errors
    //

    DNS_MAP_ENTRY( DNS_ERROR_NOT_ALLOWED_ON_ROOT_SERVER ),

    //
    //  Zone errors
    //

    DNS_ERROR_ZONE_DOES_NOT_EXIST           ,"DNS_ERROR_ZONE_DOES_NOT_EXIST",
    DNS_ERROR_NO_ZONE_INFO                  ,"DNS_ERROR_NO_ZONE_INFO",
    DNS_ERROR_INVALID_ZONE_OPERATION        ,"DNS_ERROR_INVALID_ZONE_OPERATION",
    DNS_ERROR_ZONE_CONFIGURATION_ERROR      ,"DNS_ERROR_ZONE_CONFIGURATION_ERROR",
    DNS_ERROR_ZONE_HAS_NO_SOA_RECORD        ,"DNS_ERROR_ZONE_HAS_NO_SOA_RECORD",
    DNS_ERROR_ZONE_HAS_NO_NS_RECORDS        ,"DNS_ERROR_ZONE_HAS_NO_NS_RECORDS",
    DNS_ERROR_ZONE_LOCKED                   ,"DNS_ERROR_ZONE_LOCKED",

    DNS_ERROR_ZONE_CREATION_FAILED          ,"DNS_ERROR_ZONE_CREATION_FAILED",
    DNS_ERROR_ZONE_ALREADY_EXISTS           ,"DNS_ERROR_ZONE_ALREADY_EXISTS",
    DNS_ERROR_AUTOZONE_ALREADY_EXISTS       ,"DNS_ERROR_AUTOZONE_ALREADY_EXISTS",
    DNS_ERROR_INVALID_ZONE_TYPE             ,"DNS_ERROR_INVALID_ZONE_TYPE",
    DNS_ERROR_SECONDARY_REQUIRES_MASTER_IP  ,"DNS_ERROR_SECONDARY_REQUIRES_MASTER_IP",

    DNS_MAP_ENTRY( DNS_ERROR_ZONE_REQUIRES_MASTER_IP ),
    DNS_MAP_ENTRY( DNS_ERROR_ZONE_IS_SHUTDOWN ),

    DNS_ERROR_ZONE_NOT_SECONDARY            ,"DNS_ERROR_ZONE_NOT_SECONDARY",
    DNS_ERROR_NEED_SECONDARY_ADDRESSES      ,"DNS_ERROR_NEED_SECONDARY_ADDRESSES",
    DNS_ERROR_WINS_INIT_FAILED              ,"DNS_ERROR_WINS_INIT_FAILED",
    DNS_ERROR_NEED_WINS_SERVERS             ,"DNS_ERROR_NEED_WINS_SERVERS",
    DNS_ERROR_NBSTAT_INIT_FAILED            ,"DNS_ERROR_NBSTAT_INIT_FAILED",
    DNS_ERROR_SOA_DELETE_INVALID            ,"DNS_ERROR_SOA_DELETE_INVALID",

    DNS_MAP_ENTRY( DNS_ERROR_FORWARDER_ALREADY_EXISTS ),

    //
    //  Datafile errors
    //

    DNS_ERROR_PRIMARY_REQUIRES_DATAFILE     ,"DNS_ERROR_PRIMARY_REQUIRES_DATAFILE",
    DNS_ERROR_INVALID_DATAFILE_NAME         ,"DNS_ERROR_INVALID_DATAFILE_NAME",
    DNS_ERROR_DATAFILE_OPEN_FAILURE         ,"DNS_ERROR_DATAFILE_OPEN_FAILURE",
    DNS_ERROR_FILE_WRITEBACK_FAILED         ,"DNS_ERROR_FILE_WRITEBACK_FAILED",
    DNS_ERROR_DATAFILE_PARSING              ,"DNS_ERROR_DATAFILE_PARSING",

    //
    //  Database errors
    //

    DNS_ERROR_RECORD_DOES_NOT_EXIST         ,"DNS_ERROR_RECORD_DOES_NOT_EXIST",
    DNS_ERROR_RECORD_FORMAT                 ,"DNS_ERROR_RECORD_FORMAT",
    DNS_ERROR_NODE_CREATION_FAILED          ,"DNS_ERROR_NODE_CREATION_FAILED",
    DNS_ERROR_UNKNOWN_RECORD_TYPE           ,"DNS_ERROR_UNKNOWN_RECORD_TYPE",
    DNS_ERROR_RECORD_TIMED_OUT              ,"DNS_ERROR_RECORD_TIMED_OUT",

    DNS_ERROR_NAME_NOT_IN_ZONE              ,"DNS_ERROR_NAME_NOT_IN_ZONE",
    DNS_ERROR_CNAME_LOOP                    ,"DNS_ERROR_CNAME_LOOP",
    DNS_ERROR_NODE_IS_CNAME                 ,"DNS_ERROR_NODE_IS_CNAME",
    DNS_ERROR_CNAME_COLLISION               ,"DNS_ERROR_CNAME_COLLISION",
    DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT      ,"DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT",
    DNS_ERROR_RECORD_ALREADY_EXISTS         ,"DNS_ERROR_RECORD_ALREADY_EXISTS",
    DNS_ERROR_SECONDARY_DATA                ,"DNS_ERROR_SECONDARY_DATA",
    DNS_ERROR_NO_CREATE_CACHE_DATA          ,"DNS_ERROR_NO_CREATE_CACHE_DATA",
    DNS_ERROR_NAME_DOES_NOT_EXIST           ,"DNS_ERROR_NAME_DOES_NOT_EXIST",

    DNS_WARNING_PTR_CREATE_FAILED           ,"DNS_WARNING_PTR_CREATE_FAILED",
    DNS_WARNING_DOMAIN_UNDELETED            ,"DNS_WARNING_DOMAIN_UNDELETED",

    DNS_ERROR_DS_UNAVAILABLE                ,"DNS_ERROR_DS_UNAVAILABLE",
    DNS_ERROR_DS_ZONE_ALREADY_EXISTS        ,"DNS_ERROR_DS_ZONE_ALREADY_EXISTS",

    //
    //  Operation errors
    //

    DNS_INFO_AXFR_COMPLETE                  ,"DNS_INFO_AXFR_COMPLETE",
    DNS_ERROR_AXFR                          ,"DNS_ERROR_AXFR",
    DNS_INFO_ADDED_LOCAL_WINS               ,"DNS_INFO_ADDED_LOCAL_WINS",

    //
    //  Secure update
    //
    DNS_STATUS_CONTINUE_NEEDED              ,"DNS_STATUS_CONTINUE_NEEDED",

    //
    //  Client setup errors
    //

    DNS_ERROR_NO_TCPIP                      ,"DNS_ERROR_NO_TCPIP",
    DNS_ERROR_NO_DNS_SERVERS                ,"DNS_ERROR_NO_DNS_SERVERS",

    //
    //  Directory partition errors
    //

    DNS_MAP_ENTRY( DNS_ERROR_DP_DOES_NOT_EXIST ),
    DNS_MAP_ENTRY( DNS_ERROR_DP_ALREADY_EXISTS ),
    DNS_MAP_ENTRY( DNS_ERROR_DP_NOT_ENLISTED ),
    DNS_MAP_ENTRY( DNS_ERROR_DP_ALREADY_ENLISTED ),

    //
    //  Throw in common Win32 errors
    //

    ERROR_FILE_NOT_FOUND                    ,"ERROR_FILE_NOT_FOUND",
    ERROR_ACCESS_DENIED                     ,"ERROR_ACCESS_DENIED",
    ERROR_NOT_ENOUGH_MEMORY                 ,"ERROR_NOT_ENOUGH_MEMORY",
    ERROR_BAD_FORMAT                        ,"ERROR_BAD_FORMAT",
    ERROR_INVALID_DATA                      ,"ERROR_INVALID_DATA",
    ERROR_OUTOFMEMORY                       ,"ERROR_OUTOFMEMORY",
    ERROR_SHARING_VIOLATION                 ,"ERROR_SHARING_VIOLATION",
    ERROR_NOT_SUPPORTED                     ,"ERROR_NOT_SUPPORTED",
    ERROR_INVALID_PARAMETER                 ,"ERROR_INVALID_PARAMETER",
    ERROR_INVALID_NAME                      ,"ERROR_INVALID_NAME",
    ERROR_BAD_ARGUMENTS                     ,"ERROR_BAD_ARGUMENTS",
    ERROR_BUSY                              ,"ERROR_BUSY",
    ERROR_ALREADY_EXISTS                    ,"ERROR_ALREADY_EXISTS",
    ERROR_LOCKED                            ,"ERROR_LOCKED",
    ERROR_MORE_DATA                         ,"ERROR_MORE_DATA",
    ERROR_INVALID_FLAGS                     ,"ERROR_INVALID_FLAGS",
    ERROR_FILE_INVALID                      ,"ERROR_FILE_INVALID",
    ERROR_TIMEOUT                           ,"ERROR_TIMEOUT",

    //
    // RPC error:
    //

    RPC_S_SERVER_UNAVAILABLE                ,"RPC_S_SERVER_UNAVAILABLE",
    RPC_S_INVALID_NET_ADDR                  ,"RPC_S_INVALID_NET_ADDR",

    //
    //  others:
    //

    ERROR_PATH_NOT_FOUND                    ,"ERROR_PATH_NOT_FOUND",
    ERROR_INVALID_ACCESS                    ,"ERROR_INVALID_ACCESS",
    ERROR_INVALID_DRIVE                     ,"ERROR_INVALID_DRIVE",
    ERROR_WRITE_PROTECT                     ,"ERROR_WRITE_PROTECT",
    ERROR_SHARING_VIOLATION                 ,"ERROR_SHARING_VIOLATION",
    ERROR_HANDLE_DISK_FULL                  ,"ERROR_HANDLE_DISK_FULL",
    ERROR_NOT_SUPPORTED                     ,"ERROR_NOT_SUPPORTED",
    ERROR_REM_NOT_LIST                      ,"ERROR_REM_NOT_LIST",
    ERROR_DUP_NAME                          ,"ERROR_DUP_NAME",
    ERROR_NETNAME_DELETED                   ,"ERROR_NETNAME_DELETED",
    ERROR_FILE_EXISTS                       ,"ERROR_FILE_EXISTS",
    ERROR_NET_WRITE_FAULT                   ,"ERROR_NET_WRITE_FAULT",

    //
    // winsock
    //

    WSAEINTR                     ,"WSAEINTR                   ",
    WSAEBADF                     ,"WSAEBADF                   ",
    WSAEACCES                    ,"WSAEACCES                  ",
    WSAEFAULT                    ,"WSAEFAULT                  ",
    WSAEINVAL                    ,"WSAEINVAL                  ",
    WSAEMFILE                    ,"WSAEMFILE                  ",
    WSAEWOULDBLOCK               ,"WSAEWOULDBLOCK             ",
    WSAEINPROGRESS               ,"WSAEINPROGRESS             ",
    WSAEALREADY                  ,"WSAEALREADY                ",
    WSAENOTSOCK                  ,"WSAENOTSOCK                ",
    WSAEDESTADDRREQ              ,"WSAEDESTADDRREQ            ",
    WSAEMSGSIZE                  ,"WSAEMSGSIZE                ",
    WSAEPROTOTYPE                ,"WSAEPROTOTYPE              ",
    WSAENOPROTOOPT               ,"WSAENOPROTOOPT             ",
    WSAEPROTONOSUPPORT           ,"WSAEPROTONOSUPPORT         ",
    WSAESOCKTNOSUPPORT           ,"WSAESOCKTNOSUPPORT         ",
    WSAEOPNOTSUPP                ,"WSAEOPNOTSUPP              ",
    WSAEPFNOSUPPORT              ,"WSAEPFNOSUPPORT            ",
    WSAEAFNOSUPPORT              ,"WSAEAFNOSUPPORT            ",
    WSAEADDRINUSE                ,"WSAEADDRINUSE              ",
    WSAEADDRNOTAVAIL             ,"WSAEADDRNOTAVAIL           ",
    WSAENETDOWN                  ,"WSAENETDOWN                ",
    WSAENETUNREACH               ,"WSAENETUNREACH             ",
    WSAENETRESET                 ,"WSAENETRESET               ",
    WSAECONNABORTED              ,"WSAECONNABORTED            ",
    WSAECONNRESET                ,"WSAECONNRESET              ",
    WSAENOBUFS                   ,"WSAENOBUFS                 ",
    WSAEISCONN                   ,"WSAEISCONN                 ",
    WSAENOTCONN                  ,"WSAENOTCONN                ",
    WSAESHUTDOWN                 ,"WSAESHUTDOWN               ",
    WSAETOOMANYREFS              ,"WSAETOOMANYREFS            ",
    WSAETIMEDOUT                 ,"WSAETIMEDOUT               ",
    WSAECONNREFUSED              ,"WSAECONNREFUSED            ",
    WSAELOOP                     ,"WSAELOOP                   ",
    WSAENAMETOOLONG              ,"WSAENAMETOOLONG            ",
    WSAEHOSTDOWN                 ,"WSAEHOSTDOWN               ",
    WSAEHOSTUNREACH              ,"WSAEHOSTUNREACH            ",
    WSAENOTEMPTY                 ,"WSAENOTEMPTY               ",
    WSAEPROCLIM                  ,"WSAEPROCLIM                ",
    WSAEUSERS                    ,"WSAEUSERS                  ",
    WSAEDQUOT                    ,"WSAEDQUOT                  ",
    WSAESTALE                    ,"WSAESTALE                  ",
    WSAEREMOTE                   ,"WSAEREMOTE                 ",
    WSASYSNOTREADY               ,"WSASYSNOTREADY             ",
    WSAVERNOTSUPPORTED           ,"WSAVERNOTSUPPORTED         ",
    WSANOTINITIALISED            ,"WSANOTINITIALISED          ",
    WSAEDISCON                   ,"WSAEDISCON                 ",
    WSAENOMORE                   ,"WSAENOMORE                 ",
    WSAECANCELLED                ,"WSAECANCELLED              ",
    WSAEINVALIDPROCTABLE         ,"WSAEINVALIDPROCTABLE       ",
    WSAEINVALIDPROVIDER          ,"WSAEINVALIDPROVIDER        ",
    WSAEPROVIDERFAILEDINIT       ,"WSAEPROVIDERFAILEDINIT     ",
    WSASYSCALLFAILURE            ,"WSASYSCALLFAILURE          ",
    WSASERVICE_NOT_FOUND         ,"WSASERVICE_NOT_FOUND       ",
    WSATYPE_NOT_FOUND            ,"WSATYPE_NOT_FOUND          ",
    WSA_E_NO_MORE                ,"WSA_E_NO_MORE              ",
    WSA_E_CANCELLED              ,"WSA_E_CANCELLED            ",
    WSAEREFUSED                  ,"WSAEREFUSED                ",
    WSAHOST_NOT_FOUND            ,"WSAHOST_NOT_FOUND          ",
    WSATRY_AGAIN                 ,"WSATRY_AGAIN               ",
    WSANO_RECOVERY               ,"WSANO_RECOVERY             ",
    WSANO_DATA                   ,"WSANO_DATA                 ",
    WSA_QOS_RECEIVERS            ,"WSA_QOS_RECEIVERS          ",
    WSA_QOS_SENDERS              ,"WSA_QOS_SENDERS            ",
    WSA_QOS_NO_SENDERS           ,"WSA_QOS_NO_SENDERS         ",
    WSA_QOS_NO_RECEIVERS         ,"WSA_QOS_NO_RECEIVERS       ",
    WSA_QOS_REQUEST_CONFIRMED    ,"WSA_QOS_REQUEST_CONFIRMED  ",
    WSA_QOS_ADMISSION_FAILURE    ,"WSA_QOS_ADMISSION_FAILURE  ",
    WSA_QOS_POLICY_FAILURE       ,"WSA_QOS_POLICY_FAILURE     ",
    WSA_QOS_BAD_STYLE            ,"WSA_QOS_BAD_STYLE          ",
    WSA_QOS_BAD_OBJECT           ,"WSA_QOS_BAD_OBJECT         ",
    WSA_QOS_TRAFFIC_CTRL_ERROR   ,"WSA_QOS_TRAFFIC_CTRL_ERROR ",
    WSA_QOS_GENERIC_ERROR        ,"WSA_QOS_GENERIC_ERROR      ",
    WSA_QOS_ESERVICETYPE         ,"WSA_QOS_ESERVICETYPE       ",
    WSA_QOS_EFLOWSPEC            ,"WSA_QOS_EFLOWSPEC          ",
    WSA_QOS_EPROVSPECBUF         ,"WSA_QOS_EPROVSPECBUF       ",
    WSA_QOS_EFILTERSTYLE         ,"WSA_QOS_EFILTERSTYLE       ",
    WSA_QOS_EFILTERTYPE          ,"WSA_QOS_EFILTERTYPE        ",
    WSA_QOS_EFILTERCOUNT         ,"WSA_QOS_EFILTERCOUNT       ",
    WSA_QOS_EOBJLENGTH           ,"WSA_QOS_EOBJLENGTH         ",
    WSA_QOS_EFLOWCOUNT           ,"WSA_QOS_EFLOWCOUNT         ",
    WSA_QOS_EUNKOWNPSOBJ         ,"WSA_QOS_EUNKOWNPSOBJ       ",
    WSA_QOS_EPOLICYOBJ           ,"WSA_QOS_EPOLICYOBJ         ",
    WSA_QOS_EFLOWDESC            ,"WSA_QOS_EFLOWDESC          ",
    WSA_QOS_EPSFLOWSPEC          ,"WSA_QOS_EPSFLOWSPEC        ",
    WSA_QOS_EPSFILTERSPEC        ,"WSA_QOS_EPSFILTERSPEC      ",
    WSA_QOS_ESDMODEOBJ           ,"WSA_QOS_ESDMODEOBJ         ",
    WSA_QOS_ESHAPERATEOBJ        ,"WSA_QOS_ESHAPERATEOBJ      ",
    WSA_QOS_RESERVED_PETYPE      ,"WSA_QOS_RESERVED_PETYPE    ",

    DNS_MAP_END                  ,"UNKNOWN",
};



PCHAR
_fastcall
Dns_StatusString(
    IN  DNS_STATUS  Status
    )
/*++

Routine Description:

    Map DNS error code to status string.

Arguments:

    Status -- status code to check

Return Value:

    DNS error string for error code.

--*/
{
    INT         i = 0;
    DNS_STATUS  mappedStatus;

    while ( 1 )
    {
        mappedStatus = DnsStatusStringMappings[i].Status;
        if ( mappedStatus == Status || mappedStatus == DNS_MAP_END )
        {
            return( DnsStatusStringMappings[i].String );
        }
        i++;
    }

    DNS_ASSERT( FALSE );
    return( NULL );     // make compiler happy
}



DNS_STATUS
_fastcall
Dns_MapRcodeToStatus(
    IN  BYTE    ResponseCode
    )
/*++

Routine Description:

    Map response code to DNS error code.

Arguments:

    ResponseCode - response code to get error for

Return Value:

    DNS error code for response code.

--*/
{
    if ( !ResponseCode )
    {
        return( ERROR_SUCCESS );
    }
    else
    {
        return( DNS_ERROR_MASK + ((DWORD) ResponseCode) );
    }
}



BYTE
_fastcall
Dns_IsStatusRcode(
    IN  DNS_STATUS  Status
    )
/*++

Routine Description:

    Determine if status is RCODE and if so return it.

Arguments:

    Status -- status code to check

Return Value:

    Response code corresponding to status, if found.
    Zero otherwise.

--*/
{
    if ( Status >= DNS_ERROR_RCODE_FORMAT_ERROR &&
        Status <= DNS_ERROR_RCODE_LAST )
    {
        return( (BYTE) (DNS_ERROR_MASK ^ Status) );
    }
    else
    {
        return( 0 );
    }
}



DWORD
Dns_TokenizeString(
    IN OUT  PSTR            pBuffer,
    OUT     PCHAR *         Argv,
    IN      DWORD           MaxArgs
    )
/*++

Routine Description:

    Tokenize buffer Argv/Argc form.

Arguments:

    pBuffer -- string buffer to tokenize

    Argv -- argv array

    MaxArgs -- max size of Argv array

Return Value:

    Response code corresponding to status, if found.
    Zero otherwise.

--*/
{
    DWORD   count = 0;
    PCHAR   pstring = pBuffer;

    //
    //  tokenize string
    //      - note that after the first call strtok
    //      takes NULL ptr to continue tokening same string
    //

    while ( count < MaxArgs )
    {
        PCHAR   pch;

        pch = strtok( pstring, " \t\r\n" );
        if ( !pch )
        {
            break;
        }
        Argv[ count++ ] = pch;
        pstring = NULL;
    }

    return  count;
}
                                    


DNS_STATUS
Dns_CreateTypeArrayFromMultiTypeString(
    IN      LPSTR           pchMultiTypeString,
    OUT     INT *           piTypeCount,
    OUT     PWORD *         ppwTypeArray
    )
/*++

Routine Description:

    Allocates an array of types from a string containing DNS types
    in numeric and/or string format separated by whitespace.

Arguments:

    pBuffer -- string buffer with list of numeric or alpha types

    piTypeCount -- number of types parsed written here

    ppwTypeArray -- ptr to allocated array of types written here
        this ptr must be freed even if the number of types returned
        is zero

Return Value:

    ERROR_SUCCESS

--*/
{
    PCHAR       psz;
    DWORD       argc;
    PCHAR       argv[ 50 ];
    DWORD       idx;

    ASSERT( pchMultiTypeString );
    ASSERT( piTypeCount );
    ASSERT( ppwTypeArray );

    *piTypeCount = 0;

    //
    //  Allocate array: be cheap and assume max # of types in string
    //  is twice the length of the string, e.g. "1 2 3 4 5".
    //

    *ppwTypeArray = ALLOCATE_HEAP(
        ( strlen( pchMultiTypeString ) / 2 + 2 ) * sizeof( WORD ) );
    if ( !*ppwTypeArray )
    {
        return DNS_ERROR_NO_MEMORY;
    }

    //
    //  Parse the string.
    //

    argc = Dns_TokenizeString(
                pchMultiTypeString,
                argv,
                sizeof( argv ) / sizeof( PCHAR ) );

    for ( idx = 0; idx < argc; ++idx )
    {
        if ( isdigit( argv[ idx ][ 0 ] ) )
        {
            ( *ppwTypeArray )[ *piTypeCount ] =
                ( WORD ) strtol( argv[ idx ], NULL, 0 );
        }
        else
        {
            ( *ppwTypeArray )[ *piTypeCount ] = Dns_RecordTypeForName(
                                                    argv[ idx ],
                                                    0 );    //  string length
        }
        if ( ( *ppwTypeArray )[ *piTypeCount ] != 0 )
        {
            ++*piTypeCount;
        }
    }

    return ERROR_SUCCESS;
}   //  Dns_CreateTypeArrayFromMultiTypeString
                                    


LPSTR
Dns_CreateMultiTypeStringFromTypeArray(
    IN      INT             iTypeCount,
    IN      PWORD           ppwTypeArray,
    IN      CHAR            chSeparator     OPTIONAL
    )
/*++

Routine Description:

    Allocate a string and write the types in the array in string format
    separated by the specified separator or by a space char.

Arguments:

    iTypeCount -- number of types in the array

    ppwTypeArray -- ptr to array of types 

    chSeparator -- string separator or zero for the default separator


Return Value:

    ERROR_SUCCESS

--*/
{
    LPSTR       pszTypes;
    INT         idx;
    LPSTR       psz;

    ASSERT( ppwTypeArray );

    //
    //  Allocate array: be cheap and assume 10 chars per element.
    //

    psz = pszTypes = ALLOCATE_HEAP( iTypeCount * 10 * sizeof( CHAR ) );
    if ( !psz )
    {
        return NULL;
    }

    //
    //  Output type strings.
    //

    for ( idx = 0; idx < iTypeCount; ++idx )
    {
        PCHAR   pszThisType;
        
        pszThisType = Dns_RecordStringForType( ppwTypeArray[ idx ] );
        if ( !pszThisType )
        {
            continue;
        }

        strcpy( psz, pszThisType );
        psz += strlen( pszThisType );
        *psz++ = chSeparator ? chSeparator : ' ';
    }

    *psz = '\0';    //  NULL terminate the string
    return pszTypes;
}   //  Dns_CreateMultiTypeStringFromTypeArray
                                    

//
//  End dnsutil.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\heapdbg.h ===
/*++

Copyright (c) 1995-2001 Microsoft Corporation

Module Name:

    heapdbg.h

Abstract:

    Domain Name System (DNS) Library

    Heap debugging definitions and declarations.

Author:

    Jim Gilroy (jamesg)    January 31, 1995

Revision History:

--*/


#ifndef _HEAPDBG_INCLUDED_
#define _HEAPDBG_INCLUDED_


//
//  Heap blob
//

typedef struct _HeapBlob
{
    HANDLE      hHeap;

    LIST_ENTRY  ListHead;

    //  flags
    BOOL        fCreated;
    BOOL        fHeaders;
    DWORD       Tag;
    BOOL        fDnsLib;
    BOOL        fCheckAll;
    DWORD       FailureException;
    DWORD       AllocFlags;
    DWORD       DefaultFlags;

    //  stats
    DWORD       AllocMem;
    DWORD       FreeMem;
    DWORD       CurrentMem;
    DWORD       AllocCount;
    DWORD       FreeCount;
    DWORD       CurrentCount;

    PSTR        pszDefaultFile;
    DWORD       DefaultLine;

    CRITICAL_SECTION    ListCs;
}
HEAP_BLOB, *PHEAP_BLOB;



//
//  Heap Header
//

#define HEAP_HEADER_FILE_SIZE   (16)

typedef struct _HEAP_HEADER
{
    //
    //  Note, if move or add fields, MUST update list entry offset below
    //

    ULONG       HeapCodeBegin;
    ULONG       AllocCount;
    ULONG       AllocSize;
    ULONG       RequestSize;

    //
    //  Put LIST_ENTRY in middle of header
    //      - keep begin code at front
    //      - less likely to be corrupted
    //

    LIST_ENTRY  ListEntry;

    PHEAP_BLOB  pHeap;
    PSTR        FileName;
    DWORD       LineNo;

    DWORD       AllocTime;
    ULONG       CurrentMem;
    ULONG       CurrentCount;
    ULONG       HeapCodeEnd;
}
HEAP_HEADER, * PHEAP_HEADER;

//
//  Heap Trailer
//

typedef struct _HEAP_TRAILER
{
    ULONG       HeapCodeBegin;
    ULONG       AllocCount;
    ULONG       AllocSize;
    ULONG       HeapCodeEnd;
}
HEAP_TRAILER, * PHEAP_TRAILER;


//
//  Header from list entry
//

#define HEAP_HEADER_LIST_ENTRY_OFFSET   (16)

#define HEAP_HEADER_FROM_LIST_ENTRY( pList )    \
            ( (PHEAP_HEADER)( (PCHAR)pList - HEAP_HEADER_LIST_ENTRY_OFFSET ))


//
//  Validation
//

PHEAP_HEADER
Dns_DbgHeapValidateMemory(
    IN      PVOID           pMem,
    IN      BOOL            fAtHeader
    );

VOID
Dns_DbgHeapValidateAllocList(
    IN      PHEAP_BLOB      pHeap
    );

//
//  Debug print
//

VOID
Dns_DbgHeapGlobalInfoPrint(
    IN      PHEAP_BLOB      pHeap
    );

VOID
Dns_DbgHeapHeaderPrint(
    IN      PHEAP_HEADER    h,
    IN      PHEAP_TRAILER   t
    );

VOID
Dns_DbgHeapDumpAllocList(
    IN      PHEAP_BLOB      pHeap
    );

//
//  Init\cleanup
//

VOID
Dns_HeapInitialize(
    IN OUT  PHEAP_BLOB      pHeap,
    IN      HANDLE          hHeap,
    IN      DWORD           dwCreateFlags,
    IN      BOOL            fUseHeaders,
    IN      BOOL            fResetDnslib,
    IN      BOOL            fFullHeapChecks,
    IN      DWORD           dwException,
    IN      DWORD           dwDefaultFlags,
    IN      PSTR            pszDefaultFileName,
    IN      DWORD           dwDefaultFileLine
    );

VOID
Dns_HeapCleanup(
    IN OUT  PHEAP_BLOB      pHeap
    );


//
//  Full debug heap routines
//

PVOID
Dns_DbgHeapAllocEx(
    IN OUT  PHEAP_BLOB      pHeap,
    IN      DWORD           dwFlags,
    IN      INT             iSize,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    );

PVOID
Dns_DbgHeapReallocEx(
    IN OUT  PHEAP_BLOB      pHeap,
    IN      DWORD           dwFlags,
    IN OUT  PVOID           pMem,
    IN      INT             iSize,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    );

VOID
Dns_DbgHeapFreeEx(
    IN OUT  PHEAP_BLOB      pHeap,
    IN      DWORD           dwFlags,
    IN OUT  PVOID           pMem
    );

//
//  Dnslib compatible versions of full debug versions
//

PVOID
Dns_DbgHeapAlloc(
    IN      INT             iSize
    );                      
                            
PVOID                       
Dns_DbgHeapRealloc(         
    IN OUT  PVOID           pMem,
    IN      INT             iSize
    );                      
                            
VOID                        
Dns_DbgHeapFree(            
    IN OUT  PVOID           pMem
    );



//
//  Non-debug-header versions
//
//  These allow you to use a private heap with some of the features
//  of the debug heap
//      - same initialization
//      - specifying individual heap
//      - redirection of dnslib (without building your own routines)
//      - alloc and free counts
//  but without the overhead of the headers.
//

PVOID
Dns_HeapAllocEx(
    IN OUT  PHEAP_BLOB      pHeap,
    IN      DWORD           dwFlags,
    IN      INT             iSize
    );

PVOID
Dns_HeapReallocEx(
    IN OUT  PHEAP_BLOB      pHeap,
    IN      DWORD           dwFlags,
    IN OUT  PVOID           pMem,
    IN      INT             iSize
    );

VOID
Dns_HeapFreeEx(
    IN OUT  PHEAP_BLOB      pHeap,
    IN      DWORD           dwFlags,
    IN OUT  PVOID           pMem
    );

//
//  Dnslib compatible versions of non-debug-header versions
//

PVOID
Dns_HeapAlloc(
    IN      INT             iSize
    );

PVOID
Dns_HeapRealloc(
    IN OUT  PVOID           pMem,
    IN      INT             iSize
    );

VOID
Dns_HeapFree(
    IN OUT  PVOID           pMem
    );


#endif  //  _HEAPDBG_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\flatbuf.c ===
/*++

Copyright (c) 2000-2000 Microsoft Corporation

Module Name:

    flatbuf.c

Abstract:

    Domain Name System (DNS) Library

    Flat buffer sizing routines.

Author:

    Jim Gilroy (jamesg)     December 22, 2000

Revision History:

--*/


#include "local.h"



//
//  Flat buffer routines -- argument versions
//
//  These versions have the actual code so that we can
//  easily use this stuff with existing code that has
//  independent pCurrent and BytesLeft variables.
//
//  FLATBUF structure versions just call these inline.
//

PBYTE
FlatBuf_Arg_Reserve(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      DWORD           Size,
    IN      DWORD           Alignment
    )
/*++

Routine Description:

    Reserve space in a flat buffer -- properly aligned.

Arguments:

    ppCurrent -- address of buffer current pointer
        updated with buf pointer after reservation

    pBytesLeft -- address of buf bytes left
        updated with bytes left after reservation

    Size -- size required

    Alignment -- alignment (size in bytes) required

Return Value:

    Ptr to aligned spot in buffer reserved for write.
    NULL on error.

--*/
{
    register    PBYTE   pb = *ppCurrent;
    register    INT     bytesLeft = *pBytesLeft;
    register    PBYTE   pstart;
    register    PBYTE   palign;

    //
    //  align pointer
    //

    pstart = pb;

    if ( Alignment )
    {
        Alignment--;
        pb = (PBYTE) ( (UINT_PTR)(pb + Alignment) & ~(UINT_PTR)Alignment );
    }
    palign = pb;

    //
    //  reserve space
    //

    pb += Size;

    bytesLeft -= (INT) (pb - pstart);

    *pBytesLeft = bytesLeft;
    *ppCurrent  = pb;

    //
    //  indicate space adequate\not
    //

    if ( bytesLeft < 0 )
    {
        palign = NULL;
    }
    return palign;
}



PBYTE
FlatBuf_Arg_WriteString(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      PSTR            pString,
    IN      BOOL            fUnicode
    )
/*++

Routine Description:

    Write string to flat buffer.

Arguments:

    ppCurrent -- address of buffer current pointer
        updated with buf pointer after reservation

    pBytesLeft -- address of buf bytes left
        updated with bytes left after reservation

    pString -- ptr to string to write

    fUnicode -- TRUE for unicode string

Return Value:

    Ptr to location string was written in buffer.
    NULL on error.

--*/
{
    register    PBYTE   pwrite;
    register    DWORD   length;
    register    DWORD   align;

    //
    //  determine length
    //

    if ( fUnicode )
    {
        length = (wcslen( (PWSTR)pString ) + 1) * sizeof(WCHAR);
        align = sizeof(WCHAR);
    }
    else
    {
        length = strlen( pString ) + 1;
        align = 0;
    }

    //
    //  reserve space and copy string
    //

    pwrite = FlatBuf_Arg_Reserve(
                ppCurrent,
                pBytesLeft,
                length,
                align );

    if ( pwrite )
    {
        RtlCopyMemory(
            pwrite,
            pString,
            length );
    }

    return  pwrite;
}



PBYTE
FlatBuf_Arg_CopyMemory(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      PVOID           pMemory,
    IN      DWORD           Length,
    IN      DWORD           Alignment
    )
/*++

Routine Description:

    Write memory to flat buffer.

Arguments:

    ppCurrent -- address of buffer current pointer
        updated with buf pointer after reservation

    pBytesLeft -- address of buf bytes left
        updated with bytes left after reservation

    pMemory -- memory to copy

    Length -- length to copy

    Alignment -- alignment (size in bytes) required

Return Value:

    Ptr to location string was written in buffer.
    NULL on error.

--*/
{
    register    PBYTE   pwrite;

    //
    //  reserve space and copy memory
    //

    pwrite = FlatBuf_Arg_Reserve(
                ppCurrent,
                pBytesLeft,
                Length,
                Alignment );

    if ( pwrite )
    {
        RtlCopyMemory(
            pwrite,
            pMemory,
            Length );
    }

    return  pwrite;
}


#if 0
//
//  Flatbuf inline functions -- defined in dnslib.h
//

__inline
PBYTE
FlatBuf_Arg_ReserveAlignPointer(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                ppCurrent,
                pBytesLeft,
                Size,
                sizeof(PVOID) );
}

__inline
PBYTE
FlatBuf_Arg_ReserveAlignQword(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                ppCurrent,
                pBytesLeft,
                Size,
                sizeof(QWORD) );
}

__inline
PBYTE
FlatBuf_Arg_ReserveAlignDword(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                ppCurrent,
                pBytesLeft,
                Size,
                sizeof(DWORD) );
}

__inline
PBYTE
FlatBuf_Arg_ReserveAlignWord(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                ppCurrent,
                pBytesLeft,
                Size,
                sizeof(WORD) );
}


__inline
PBYTE
FlatBuf_Arg_ReserveAlignByte(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                ppCurrent,
                pBytesLeft,
                Size,
                0 );
}



PBYTE
__inline
FlatBuf_Arg_WriteString_A(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      PSTR            pString
    )
{
    return  FlatBuf_Arg_WriteString(
                ppCurrent,
                pBytesLeft,
                pString,
                FALSE       // not unicode
                );
}


PBYTE
__inline
FlatBuf_Arg_WriteString_W(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      PWSTR           pString
    )
{
    return  FlatBuf_Arg_WriteString(
                ppCurrent,
                pBytesLeft,
                (PSTR) pString,
                TRUE        // unicode
                );
}
#endif



//
//  Flat buffer routines -- structure versions
//

VOID
FlatBuf_Init(
    IN OUT  PFLATBUF        pFlatBuf,
    IN      PBYTE           pBuffer,
    IN      INT             Size
    )
/*++

Routine Description:

    Init a FLATBUF struct with given buffer and size.

    Note, ok to init to zero for size determination.

Arguments:

    pFlatBuf -- ptr to FLATBUF to init

    pBuffer -- buffer ptr

    Size -- size required

Return Value:

    None

--*/
{
    pFlatBuf->pBuffer   = pBuffer;
    pFlatBuf->pCurrent  = pBuffer;
    pFlatBuf->pEnd      = pBuffer + Size;
    pFlatBuf->Size      = Size;
    pFlatBuf->BytesLeft = Size;
}





#if 0
//
//  Flatbuf inline functions -- defined in dnslib.h
//

__inline
PBYTE
FlatBuf_Reserve(
    IN OUT  PFLATBUF        pBuf,
    IN      DWORD           Size,
    IN      DWORD           Alignment
    )
{
    return FlatBuf_Arg_Reserve(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                Size,
                Alignment );
}

__inline
PBYTE
FlatBuf_ReserveAlignPointer(
    IN OUT  PFLATBUF        pBuf,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                Size,
                sizeof(PVOID) );
}

__inline
PBYTE
FlatBuf_ReserveAlignQword(
    IN OUT  PFLATBUF        pBuf,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                Size,
                sizeof(QWORD) );
}

__inline
PBYTE
FlatBuf_ReserveAlignDword(
    IN OUT  PFLATBUF        pBuf,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                Size,
                sizeof(DWORD) );
}

__inline
PBYTE
FlatBuf_ReserveAlignWord(
    IN OUT  PFLATBUF        pBuf,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                Size,
                sizeof(WORD) );
}

__inline
PBYTE
FlatBuf_ReserveAlignByte(
    IN OUT  PFLATBUF        pBuf,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                Size,
                0 );
}


PBYTE
__inline
FlatBuf_WriteString(
    IN OUT  PFLATBUF        pBuf,
    IN      PSTR            pString,
    IN      BOOL            fUnicode
    )
{
    return  FlatBuf_Arg_WriteString(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                pString,
                fUnicode
                );
}


PBYTE
__inline
FlatBuf_WriteString_A(
    IN OUT  PFLATBUF        pBuf,
    IN      PSTR            pString
    )
{
    return  FlatBuf_Arg_WriteString(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                pString,
                FALSE       // not unicode
                );
}


PBYTE
__inline
FlatBuf_WriteString_W(
    IN OUT  PFLATBUF        pBuf,
    IN      PWSTR           pString
    )
{
    return  FlatBuf_Arg_WriteString(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                (PSTR) pString,
                TRUE        // unicode
                );
}


PBYTE
__inline
FlatBuf_CopyMemory(
    IN OUT  PFLATBUF        pBuf,
    IN      PVOID           pMemory,
    IN      DWORD           Length,
    IN      DWORD           Alignment
    )
{
    return FlatBuf_Arg_CopyMemory(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                pMemory,
                Length,
                Alignment );
}
#endif

//
//  End flatbuf.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\heapdbg.c ===
/*++

Copyright (c) 1995-2001 Microsoft Corporation

Module Name:

    heapdbg.c

Abstract:

    Domain Name System (DNS) Library

    Heap debugging routines.

Author:

    Jim Gilroy (jamesg)    January 31, 1995

Revision History:

--*/


#include "local.h"
#include "heapdbg.h"


//
//  locking
//

#define LOCK_HEAP(p)    EnterCriticalSection( &p->ListCs )
#define UNLOCK_HEAP(p)  LeaveCriticalSection( &p->ListCs )


//
//  Heap
//
//  Debug heap routines allow heap to be specified by caller of
//  each routine, or by having heap global.
//  If global, the heap handle may be supplied to initialization
//  routine OR created internally.
//

#define HEAP_DBG_DEFAULT_CREATE_FLAGS   \
            (   HEAP_GROWABLE |                 \
                HEAP_GENERATE_EXCEPTIONS |      \
                HEAP_TAIL_CHECKING_ENABLED |    \
                HEAP_FREE_CHECKING_ENABLED |    \
                HEAP_CREATE_ALIGN_16 |          \
                HEAP_CLASS_1 )

//
//  Dnslib using this heap
//

PHEAP_BLOB  g_pDnslibHeapBlob;

HEAP_BLOB   g_DnslibHeapBlob;


//
//  Heap Header / Trailer Flags
//

#define HEAP_CODE          0xdddddddd
#define HEAP_CODE_ACTIVE   0xaaaaaaaa
#define HEAP_CODE_FREE     0xeeeeeeee

//
//  Heap Trailer from Header
//

#define HEAP_TRAILER(_head_)            \
    ( (PHEAP_TRAILER) (                 \
            (PCHAR)(_head_)             \
            + (_head_)->AllocSize       \
            - sizeof(HEAP_TRAILER) ) )


//
//  Private protos
//

VOID
DbgHeapValidateHeader(
    IN      PHEAP_HEADER    h
    );



//
//  Private utilities
//

INT
DbgHeapFindAllocSize(
    IN      INT             iRequestSize
    )
/*++

Routine Description:

    Determines actual size of debug alloc.

    Adds in sizes of DWORD aligned header and trailer.

Arguments:

    iRequestSize   - requested allocation size

Return Value:

    None

--*/
{
    register INT imodSize;

    //
    //  find DWORD multiple size of original alloc,
    //  this is required so debug trailer will be DWORD aligned
    //

    imodSize = iRequestSize % sizeof(DWORD);
    if ( imodSize )
    {
        imodSize = sizeof(DWORD) - imodSize;
    }

    imodSize += iRequestSize + sizeof(HEAP_HEADER) + sizeof(HEAP_TRAILER);

    ASSERT( ! (imodSize % sizeof(DWORD)) );

    return( imodSize );
}



PVOID
DbgHeapSetHeaderAlloc(
    IN OUT  PHEAP_BLOB      pHeap,
    IN OUT  PHEAP_HEADER    h,
    IN      INT             iSize,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Sets/Resets heap globals and heap header info.

Arguments:

    h       - ptr to new memory block

    iSize   - size allocated

Return Value:

    None

--*/
{
    PHEAP_TRAILER   t;
    INT             allocSize;

    ASSERT( iSize > 0 );

    //
    //  determine actual alloc
    //

    allocSize = DbgHeapFindAllocSize( iSize );

    //
    //  update heap info globals
    //

    pHeap->AllocMem   += allocSize;
    pHeap->CurrentMem += allocSize;
    pHeap->AllocCount++;
    pHeap->CurrentCount++;

    //
    //  fill in header
    //

    h->HeapCodeBegin    = HEAP_CODE;
    h->AllocCount       = pHeap->AllocCount;
    h->AllocSize        = allocSize;
    h->RequestSize      = iSize;

    h->LineNo           = dwLine;
    h->FileName         = pszFile;

#if 0
    allocSize = strlen(pszFile) - HEAP_HEADER_FILE_SIZE;
    if ( allocSize > 0 )
    {
        pszFile = &pszFile[ allocSize ];
    }
    strncpy(
        h->FileName,
        pszFile,
        HEAP_HEADER_FILE_SIZE );
#endif

    h->AllocTime        = GetCurrentTime();
    h->CurrentMem      = pHeap->CurrentMem;
    h->CurrentCount     = pHeap->CurrentCount;
    h->HeapCodeEnd      = HEAP_CODE_ACTIVE;

    //
    //  fill in trailer
    //

    t = HEAP_TRAILER( h );
    t->HeapCodeBegin = h->HeapCodeBegin;
    t->AllocCount    = h->AllocCount;
    t->AllocSize     = h->AllocSize;
    t->HeapCodeEnd   = h->HeapCodeEnd;

    //
    //  attach to alloc list
    //

    LOCK_HEAP(pHeap);
    InsertTailList( &pHeap->ListHead, &h->ListEntry );
    UNLOCK_HEAP(pHeap);

    //
    //  return ptr to user memory
    //      - first byte past header
    //

    return( h+1 );
}



PHEAP_HEADER
DbgHeapSetHeaderFree(
    IN OUT  PHEAP_BLOB      pHeap,
    IN OUT  PVOID           pMem
    )
/*++

Routine Description:

    Resets heap globals and heap header info for free.

Arguments:

    pMem - ptr to user memory to free

Return Value:

    Ptr to block to be freed.

--*/
{
    register PHEAP_HEADER h;

    //
    //  validate memory block -- get ptr to header
    //

    h = Dns_DbgHeapValidateMemory( pMem, TRUE );

    //
    //  get blob if not passed in
    //

    if ( !pHeap )
    {
        pHeap = h->pHeap;
    }

    //
    //  remove from current allocs list
    //

    LOCK_HEAP(pHeap);

    RemoveEntryList( &h->ListEntry );

    UNLOCK_HEAP(pHeap);

    //
    //  update heap info globals
    //

    pHeap->CurrentMem      -= h->AllocSize;
    pHeap->FreeMem    += h->AllocSize;
    pHeap->FreeCount++;
    pHeap->CurrentCount--;

    //
    //  reset header
    //

    h->HeapCodeEnd = HEAP_CODE_FREE;
    HEAP_TRAILER(h)->HeapCodeBegin = HEAP_CODE_FREE;

    //
    //  return ptr to block to be freed
    //

    return( h );
}



//
//  Heap Init\Cleanup
//

VOID
Dns_HeapInitialize(
    OUT     PHEAP_BLOB      pHeap,
    IN      HANDLE          hHeap,
    IN      DWORD           dwCreateFlags,
    IN      BOOL            fUseHeaders,
    IN      BOOL            fResetDnslib,
    IN      BOOL            fFullHeapChecks,
    IN      DWORD           dwException,
    IN      DWORD           dwDefaultFlags,
    IN      PSTR            pszDefaultFileName,
    IN      DWORD           dwDefaultFileLine
    )
/*++

Routine Description:

    Initialize heap debugging.

    MUST call this routine before using DbgHeapMessage routines.

Arguments:

    pHeap -- heap blob to setup

    hHeap -- heap to use

    dwCreateFlags   -- flags to RtlCreateHeap() if creating

    fUseHeaders     -- use headers and trailers for full debug

    fResetDnslib    -- reset dnslib heap to use these routines

    fFullHeapChecks -- flag, TRUE for full heap checks

    dwException     -- exception to raise if out of heap

    dwDefaultFlags  -- heap flags for simple alloc\free

    pszDefaultFileName -- file name for simple alloc\free

    dwDefaultFileLine -- file line# for simple alloc\free

Return Value:

    None.

--*/
{
    DNSDBG( TRACE, (
        "Dns_DbgHeapInit( %p )\n",
        pHeap ));

    //
    //  zero heap blob
    //

    RtlZeroMemory(
        pHeap,
        sizeof(*pHeap) );

    //  alloc list
    //      - alloc list head
    //      - critical section to protect list operations

    InitializeListHead( &pHeap->ListHead );
    if ( fUseHeaders )
    {
        InitializeCriticalSection( &pHeap->ListCs );
    }

    //
    //  heap
    //  can either
    //      - always get heap in each call
    //      - use heap caller supplies here
    //      - create a heap here
    //
    //  to use simple dnslib compatible calls we must have
    //  a known heap, so must get one created here
    //  DCR:  not sure this is TRUE, process heap may work
    //      g_hDnsHeap left NULL
    //

    if ( hHeap )
    {
        pHeap->hHeap = hHeap;
    }
    else
    {
        pHeap->hHeap = RtlCreateHeap(
                            dwCreateFlags
                                ? dwCreateFlags
                                : HEAP_DBG_DEFAULT_CREATE_FLAGS,
                            NULL,           // no base specified
                            0,              // default reserve size
                            0,              // default commit size
                            NULL,           // no lock
                            NULL            // no parameters
                            );

        pHeap->fCreated = TRUE;
    }
    pHeap->Tag = HEAP_CODE_ACTIVE;

    //  set globals
    //      - full heap checks before all heap operations?
    //      - raise exception on alloc failure?

    pHeap->fHeaders         = fUseHeaders;
    pHeap->fCheckAll        = fFullHeapChecks;
    pHeap->FailureException = dwException;

    //  set globals for simple allocator

    pHeap->DefaultFlags     = dwDefaultFlags;
    pHeap->pszDefaultFile   = pszDefaultFileName;
    pHeap->DefaultLine      = dwDefaultFileLine;

    //  reset dnslib heap routines to use debug heap

    if ( fResetDnslib )
    {
        if ( fUseHeaders )
        {
            Dns_LibHeapReset(
                Dns_DbgHeapAlloc,
                Dns_DbgHeapRealloc,
                Dns_DbgHeapFree );
        }
        else
        {
            Dns_LibHeapReset(
                Dns_HeapAlloc,
                Dns_HeapRealloc,
                Dns_HeapFree );
        }

        g_pDnslibHeapBlob = pHeap;
    }
}



VOID
Dns_HeapCleanup(
    IN OUT  PHEAP_BLOB      pHeap
    )
/*++

Routine Description:

    Cleanup.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DNSDBG( TRACE, ( "Dns_HeapCleanup( %p )\n", pHeap ));

    //  if not initialized -- do nothing

    if ( !pHeap )
    {
        return;
    }
    if ( pHeap->Tag != HEAP_CODE_ACTIVE )
    {
        DNS_ASSERT( pHeap->Tag == HEAP_CODE_ACTIVE );
        return;
    }
    DNS_ASSERT( pHeap->hHeap );

    //  if created heap, destroy it

    if ( pHeap->fCreated )
    {
        RtlDestroyHeap( pHeap->hHeap );
    }

    //  cleanup critical section

    if ( pHeap->fHeaders )
    {
        RtlDeleteCriticalSection( &pHeap->ListCs );
    }

    //  tag as invalid

    pHeap->Tag = HEAP_CODE_FREE;
}



//
//  Heap Validation
//

VOID
DbgHeapValidateHeader(
    IN      PHEAP_HEADER    h
    )
/*++

Routine Description:

    Validates heap header.

Arguments:

    h - ptr to header of block

Return Value:

    None.

--*/
{
    register PHEAP_TRAILER t;

    //
    //  extract trailer
    //

    t = HEAP_TRAILER( h );

    //
    //  verify header
    //

    if ( h->HeapCodeBegin != HEAP_CODE
            ||
        h->HeapCodeEnd != HEAP_CODE_ACTIVE )
    {
        DNSDBG( HEAPDBG, (
            "Invalid memory block at %p -- invalid header.\n",
            h ));

        if ( h->HeapCodeEnd == HEAP_CODE_FREE )
        {
            DNSDBG( HEAPDBG, (
                "ERROR:  Previous freed memory.\n" ));
        }
        goto Invalid;
    }

    //
    //  match header, trailer alloc number
    //

    if ( h->HeapCodeBegin != t->HeapCodeBegin
            ||
        h->AllocCount != t->AllocCount
            ||
        h->AllocSize != t->AllocSize
            ||
        h->HeapCodeEnd != t->HeapCodeEnd )
    {
        DNSDBG( HEAPDBG, (
            "Invalid memory block at %p -- header / trailer mismatch.\n",
            h ));
        goto Invalid;
    }
    return;


Invalid:

    DNSDBG( ANY, (
        "Validation failure, in heap blob %p\n",
        h->pHeap ));

    Dns_DbgHeapHeaderPrint( h, t );
    ASSERT( FALSE );
    Dns_DbgHeapGlobalInfoPrint( h->pHeap );
    Dns_DbgHeapDumpAllocList( h->pHeap );
    ASSERT( FALSE );
    return;
}



PHEAP_HEADER
Dns_DbgHeapValidateMemory(
    IN      PVOID           pMem,
    IN      BOOL            fAtHeader
    )
/*++

Routine Description:

    Validates users heap pointer, and returns actual.

    Note:  This memory MUST have been allocated by THESE MEMORY routines.

Arguments:

    pMem - ptr to memory to validate

    fAtHeader - TRUE if pMem is known to be immediately after a head header,
        otherwise this function will search backwards through memory starting
        at pMem looking for a valid heap header

Return Value:

    Pointer to actual heap pointer.

--*/
{
    register PHEAP_HEADER   pheader;

    //
    //  Get pointer to heap header.
    //

    pheader = (PHEAP_HEADER) pMem - 1;
    if ( !fAtHeader )
    {
        int     iterations = 32 * 1024;

        //
        //  Back up from pMem a DWORD at a time looking for HEAP_CODE.
        //  If we don't find one, eventually we will generate an exception,
        //  which will be interesting. This could be handled, but for now
        //  this loop will just walk to past the start of valid memory.
        //

        while ( 1 )
        {
            //
            //  Break if we've found the heap header.
            //

            if ( pheader->HeapCodeBegin == HEAP_CODE &&
                ( pheader->HeapCodeEnd == HEAP_CODE_ACTIVE ||
                    pheader->HeapCodeEnd == HEAP_CODE_FREE ) )
            {
                break;
            }

            //
            //  Sanity check: too many iterations?
            //

            if ( ( --iterations ) == 0 )
            {
                ASSERT( iterations > 0 );
                return NULL;
            }

            //
            //  Back up another DWORD.
            //

            pheader = ( PHEAP_HEADER ) ( ( PBYTE ) pheader - 4 );
        }
    }

    //
    //  Verify header and trailer.
    //

    DbgHeapValidateHeader( pheader );

    return pheader;
}



VOID
Dns_DbgHeapValidateAllocList(
    IN OUT  PHEAP_BLOB      pHeap
    )
/*++

Routine Description:

    Dumps header information for all nodes in alloc list.

Arguments:

    None

Return Value:

    None

--*/
{
    PLIST_ENTRY pentry;

    DNSDBG( TRACE, (
        "Dns_DbgHeapValidateAllocList( %p )\n",
        pHeap ));

    if ( !pHeap->fHeaders )
    {
        DNS_ASSERT( pHeap->fHeaders );
        return;
    }

    //
    //  loop through all outstanding alloc's, validating each one
    //

    LOCK_HEAP(pHeap);

    pentry = pHeap->ListHead.Flink;

    while( pentry != &pHeap->ListHead )
    {
        DbgHeapValidateHeader( HEAP_HEADER_FROM_LIST_ENTRY(pentry) );

        pentry = pentry->Flink;
    }
    UNLOCK_HEAP(pHeap);
}



//
//  Heap Printing
//

VOID
Dns_DbgHeapGlobalInfoPrint(
    IN      PHEAP_BLOB      pHeap
    )
/*++

Routine Description:

    Prints global heap info.

Arguments:

    None

Return Value:

    None

--*/
{
    DNS_PRINT((
        "Debug Heap Information:\n"
        "\tHeap Blob        = %p\n"
        "\tHandle           = %p\n"
        "\tDebug headers    = %d\n"
        "\tDnslib redirect  = %d\n"
        "\tFull checks      = %d\n"
        "\tFlags            = %08x\n"
        "\tStats ---------------\n"
        "\tMemory Allocated = %d\n"
        "\tMemory Freed     = %d\n"
        "\tMemory Current   = %d\n"
        "\tAlloc Count      = %d\n"
        "\tFree Count       = %d\n"
        "\tCurrent Count    = %d\n",

        pHeap,
        pHeap->hHeap,
        pHeap->fHeaders,
        pHeap->fDnsLib,
        pHeap->fCheckAll,
        pHeap->DefaultFlags,

        pHeap->AllocMem,
        pHeap->FreeMem,
        pHeap->CurrentMem,
        pHeap->AllocCount,
        pHeap->FreeCount,
        pHeap->CurrentCount
        ));
}



VOID
Dns_DbgHeapHeaderPrint(
    IN      PHEAP_HEADER    h,
    IN      PHEAP_TRAILER   t
    )
/*++

Routine Description:

    Prints heap header and trailer.

Arguments:

    None

Return Value:

    None

--*/
{
    if ( h )
    {
        DNSDBG( HEAPDBG, (
            "Heap Header at %p:\n"
            "\tHeapCodeBegin     = %08lx\n"
            "\tAllocCount        = %d\n"
            "\tAllocSize         = %d\n"
            "\tRequestSize       = %d\n"
            "\tHeapBlob          = %p\n"
            //"\tFileName          = %.*s\n"
            "\tFileName          = %s\n"
            "\tLineNo            = %d\n"
            "\tAllocTime         = %d\n"
            "\tCurrentMem       = %d\n"
            "\tCurrentCount      = %d\n"
            "\tHeapCodeEnd       = %08lx\n",
            h,
            h->HeapCodeBegin,
            h->AllocCount,
            h->AllocSize,
            h->RequestSize,
            h->pHeap,
            //HEAP_HEADER_FILE_SIZE,
            h->FileName,
            h->LineNo,
            h->AllocTime / 1000,
            h->CurrentMem,
            h->CurrentCount,
            h->HeapCodeEnd
            ));
    }

    if ( t )
    {
        DNSDBG( HEAPDBG, (
            "Heap Trailer at %p:\n"
            "\tHeapCodeBegin     = %08lx\n"
            "\tAllocCount        = %d\n"
            "\tAllocSize         = %d\n"
            "\tHeapCodeEnd       = %08lx\n",
            t,
            t->HeapCodeBegin,
            t->AllocCount,
            t->AllocSize,
            t->HeapCodeEnd
            ));
    }
}



VOID
Dns_DbgHeapDumpAllocList(
    IN      PHEAP_BLOB      pHeap
    )
/*++

Routine Description:

    Dumps header information for all nodes in alloc list.

Arguments:

    None

Return Value:

    None

--*/
{
    PLIST_ENTRY     pentry;
    PHEAP_HEADER    phead;

    if ( !pHeap->fHeaders )
    {
        DNSDBG( HEAPDBG, ( "Non-debug heap -- no alloc list!\n" ));
        return;
    }

    //
    //  loop through all outstanding alloc's, dumping output
    //

    LOCK_HEAP(pHeap);
    DNSDBG( HEAPDBG, ( "Dumping Alloc List:\n" ));

    pentry = pHeap->ListHead.Flink;

    while( pentry != &pHeap->ListHead )
    {
        phead = HEAP_HEADER_FROM_LIST_ENTRY( pentry );

        Dns_DbgHeapHeaderPrint(
                phead,
                HEAP_TRAILER( phead )
                );
        pentry = pentry->Flink;
    }

    DNSDBG( HEAPDBG, ( "End Dump of Alloc List.\n" ));
    UNLOCK_HEAP(pHeap);
}



//
//  Full debug heap routines
//

PVOID
Dns_DbgHeapAllocEx(
    IN OUT  PHEAP_BLOB      pHeap,
    IN      DWORD           dwFlags,
    IN      INT             iSize,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Allocates memory.

Arguments:

    iSize   - number of bytes to allocate

Return Value:

    Pointer to memory allocated.
    NULL if allocation fails.

--*/
{
    register PHEAP_HEADER h;
    INT allocSize;

    DNSDBG( HEAP2, (
        "Dns_DbgHeapAlloc( %p, %d )\n",
        pHeap, iSize ));

    //
    //  full heap check?
    //

    IF_DNSDBG( HEAP_CHECK )
    {
        Dns_DbgHeapValidateAllocList( pHeap );
    }

    if ( iSize <= 0 )
    {
        DNSDBG( ANY, ( "Invalid alloc size = %d\n", iSize ));
        DNS_ASSERT( FALSE );
        return( NULL );
    }

    //
    //  allocate memory
    //
    //  first add heap header to size
    //

    allocSize = DbgHeapFindAllocSize( iSize );

    h = (PHEAP_HEADER) RtlAllocateHeap(
                            pHeap->hHeap,
                            dwFlags
                                ? dwFlags
                                : pHeap->DefaultFlags,
                            allocSize );
    if ( ! h )
    {
        Dns_DbgHeapGlobalInfoPrint( pHeap );
        return NULL;
    }

    //
    //  setup header / globals for new alloc
    //
    //  return ptr to first byte after header
    //

    return  DbgHeapSetHeaderAlloc(
                pHeap,
                h,
                iSize,
                pszFile,
                dwLine
                );
}



PVOID
Dns_DbgHeapReallocEx(
    IN OUT  PHEAP_BLOB      pHeap,
    IN      DWORD           dwFlags,
    IN OUT  PVOID           pMem,
    IN      INT             iSize,
    IN      LPSTR           pszFile,
    IN      DWORD           dwLine
    )
/*++

Routine Description:

    Reallocates memory

Arguments:

    pMem    - ptr to existing memory to reallocated
    iSize   - number of bytes to reallocate

Return Value:

    Pointer to memory allocated.
    NULL if allocation fails.

--*/
{
    register PHEAP_HEADER h;
    INT     previousSize;
    INT     allocSize;

    //
    //  full heap check?
    //

    IF_DNSDBG( HEAP_CHECK )
    {
        Dns_DbgHeapValidateAllocList( pHeap );
    }

    if ( iSize <= 0 )
    {
        DNSDBG( HEAPDBG, ( "Invalid realloc size = %d\n", iSize ));
        return( NULL );
    }

    //
    //  validate memory
    //
    //  extract pointer to actual alloc'd block
    //  mark as free, and reset globals appropriately
    //

    h = DbgHeapSetHeaderFree( pHeap, pMem );

    //
    //  reallocate memory
    //
    //  first add heap header to size
    //

    allocSize = DbgHeapFindAllocSize( iSize );

    h = (PHEAP_HEADER) RtlReAllocateHeap(
                            pHeap->hHeap,
                            dwFlags
                                ? dwFlags
                                : pHeap->DefaultFlags,
                            h,
                            allocSize );
    if ( ! h )
    {
        Dns_DbgHeapGlobalInfoPrint( pHeap );
        return( NULL );
    }

    //
    //  setup header / globals for realloc
    //
    //  return ptr to first byte after header
    //

    return  DbgHeapSetHeaderAlloc(
                pHeap,
                h,
                iSize,
                pszFile,
                dwLine
                );
}



VOID
Dns_DbgHeapFreeEx(
    IN OUT  PHEAP_BLOB      pHeap,
    IN      DWORD           dwFlags,
    IN OUT  PVOID           pMem
    )
/*++

Routine Description:

    Frees memory

    Note:  This memory MUST have been allocated by DbgHeap routines.

Arguments:

    pMem - ptr to memory to be freed

Return Value:

    None.

--*/
{
    register PHEAP_HEADER h;

    DNSDBG( HEAP2, (
        "Dns_DbgHeapFreeEx( %p, %p )\n",
        pHeap, pMem ));

    //
    //  validate header
    //
    //  reset heap header / globals for free
    //

    h = DbgHeapSetHeaderFree( pHeap, pMem );

    //
    //  get blob
    //

    if ( !pHeap )
    {
        pHeap = h->pHeap;
    }

    //
    //  full heap check?
    //

    IF_DNSDBG( HEAP_CHECK )
    {
        Dns_DbgHeapValidateAllocList( pHeap );
    }

    RtlFreeHeap(
        pHeap->hHeap,
        dwFlags
            ? dwFlags
            : pHeap->DefaultFlags,
        h );
}



//
//  Dnslib memory compatible versions
//
//  Heap routines with simple function signature that matches
//  the dnslib routines and allows DnsLib memory routines to
//  be redirected to these routines through Dns_LibHeapReset().
//
//  Note:  to use these functions, must have specified at particular
//      heap to use.
//

PVOID
Dns_DbgHeapAlloc(
    IN      INT             iSize
    )
{
    return  Dns_DbgHeapAllocEx(
                g_pDnslibHeapBlob,
                0,
                iSize,
                NULL,
                0 );
}

PVOID
Dns_DbgHeapRealloc(
    IN OUT  PVOID           pMem,
    IN      INT             iSize
    )
{
    return  Dns_DbgHeapReallocEx(
                g_pDnslibHeapBlob,
                0,
                pMem,
                iSize,
                NULL,
                0
                );
}

VOID
Dns_DbgHeapFree(
    IN OUT  PVOID   pMem
    )
{
    Dns_DbgHeapFreeEx(
        g_pDnslibHeapBlob,
        0,
        pMem );
}




//
//  Non debug header versions
//
//  These allow you to use a private heap with some of the features
//  of the debug heap
//      - same initialization
//      - specifying individual heap
//      - redirection of dnslib (without building your own routines)
//      - alloc and free counts
//  but without the overhead of the headers.
//

PVOID
Dns_HeapAllocEx(
    IN OUT  PHEAP_BLOB      pHeap,
    IN      DWORD           dwFlags,
    IN      INT             iSize
    )
/*++

Routine Description:

    Allocates memory.

Arguments:

    pHeap   - heap to use

    dwFlags - flags

    iSize   - number of bytes to allocate

Return Value:

    Pointer to memory allocated.
    NULL if allocation fails.

--*/
{
    PVOID   p;

    DNSDBG( HEAP2, (
        "Dns_HeapAlloc( %p, %d )\n",
        pHeap, iSize ));

    //
    //  allocate memory
    //

    p = (PHEAP_HEADER) RtlAllocateHeap(
                            pHeap->hHeap,
                            dwFlags
                                ? dwFlags
                                : pHeap->DefaultFlags,
                            iSize );
    if ( p )
    {
        pHeap->AllocCount++;
        pHeap->CurrentCount++;
    }
    return  p;
}



PVOID
Dns_HeapReallocEx(
    IN OUT  PHEAP_BLOB      pHeap,
    IN      DWORD           dwFlags,
    IN OUT  PVOID           pMem,
    IN      INT             iSize
    )
/*++

Routine Description:

    Reallocates memory

Arguments:

    pMem    - ptr to existing memory to reallocated
    iSize   - number of bytes to reallocate

Return Value:

    Pointer to memory allocated.
    NULL if allocation fails.

--*/
{
    PVOID   p;
    INT     previousSize;
    INT     allocSize;

    //
    //  reallocate memory
    //
    //  first add heap header to size
    //

    p = RtlReAllocateHeap(
            pHeap->hHeap,
            dwFlags
                ? dwFlags
                : pHeap->DefaultFlags,
            pMem,
            iSize );
    if ( p )
    {
        pHeap->AllocCount++;
        pHeap->FreeCount++;
    }
    return  p;
}



VOID
Dns_HeapFreeEx(
    IN OUT  PHEAP_BLOB      pHeap,
    IN      DWORD           dwFlags,
    IN OUT  PVOID           pMem
    )
/*++

Routine Description:

    Frees memory

    Note:  This memory MUST have been allocated by DbgHeap routines.

Arguments:

    pMem - ptr to memory to be freed

Return Value:

    None.

--*/
{
    DNSDBG( HEAP2, (
        "Dns_HeapFreeEx( %p, %p )\n",
        pHeap, pMem ));

    RtlFreeHeap(
        pHeap->hHeap,
        dwFlags
            ? dwFlags
            : pHeap->DefaultFlags,
        pMem );

    pHeap->FreeCount++;
    pHeap->CurrentCount--;
}



//
//  Dnslib memory compatible versions
//
//  Heap routines with simple function signature that matches
//  the dnslib routines and allows DnsLib memory routines to
//  be redirected to these routines through Dns_LibHeapReset().
//
//  Note:  to use these functions, must have specified at particular
//      heap to use.
//

PVOID
Dns_HeapAlloc(
    IN      INT             iSize
    )
{
    return  Dns_HeapAllocEx(
                g_pDnslibHeapBlob,
                0,
                iSize );
}

PVOID
Dns_HeapRealloc(
    IN OUT  PVOID           pMem,
    IN      INT             iSize
    )
{
    return  Dns_HeapReallocEx(
                g_pDnslibHeapBlob,
                0,
                pMem,
                iSize );
}

VOID
Dns_HeapFree(
    IN OUT  PVOID   pMem
    )
{
    Dns_HeapFreeEx(
        g_pDnslibHeapBlob,
        0,
        pMem );
}

//
//  End heapdbg.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\hostent.c ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    hostent.c

Abstract:

    Domain Name System (DNS) Library

    Hostent routines.

Author:

    Jim Gilroy (jamesg)     December 4, 2000

Revision History:

--*/


#include "local.h"
#include "ws2atm.h"     // ATM address


//
//  Max number of aliases
//

#define DNS_MAX_ALIAS_COUNT     (8)

//
//  Min size of hostent address buffer
//      - enough for one address of largest type
//

#define MIN_ADDR_BUF_SIZE   (sizeof(ATM_ADDRESS))


//
//  String alignment in buffer
//
//  DCR:  string buffer alignment exposed globally
//
//  Since address and string DATA (not ptrs) can be intermixed
//  as we build, we MUST size strings for DWORD (at minimum) so
//  to that addresses may be DWORD aligned.
//  However, when we build we can pack as tightly as desired
//  though obviously unicode strings must WCHAR align.
//  

#define HOSTENT_STRING_ALIGN_DWORD(size)    DWORD_ALIGN_DWORD(size)
#define HOSTENT_STRING_ALIGN_PTR(ptr)       DWORD_ALIGN(ptr)

#define REQUIRED_HOSTENT_STRING_ALIGN_DWORD(size)   WORD_ALIGN_DWORD(size)
#define REQUIRED_HOSTENT_STRING_ALIGN_PTR(ptr)      WORD_ALIGN(ptr)


//
//  Hostent utilities
//


BOOL
Hostent_IsSupportedAddrType(
    IN      WORD            wType
    )
/*++

Routine Description:

    Is this a supported address type for hostent.

Arguments:

    wType -- type in question

Return Value:

    TRUE if type supported
    FALSE otherwise

--*/
{
    return ( wType == DNS_TYPE_A ||
             wType == DNS_TYPE_AAAA ||
             wType == DNS_TYPE_ATMA );
}



DWORD
Hostent_Size(
    IN      PHOSTENT        pHostent,
    IN      DNS_CHARSET     CharSetExisting,
    IN      DNS_CHARSET     CharSetTarget,
    IN      PDWORD          pAliasCount,
    IN      PDWORD          pAddrCount
    )
/*++

Routine Description:

    Find size of hostent.

Arguments:

    pHostent -- hostent

    CharSetExisting -- char set of pHostent

    CharSetTarget -- char set to size to

    pAliasCount -- count of aliases

    pAddrCount -- count of addrs

Return Value:

    Size in bytes of hostent.

--*/
{
    DWORD   sizeName = 0;
    DWORD   sizeAliasNames = 0;
    DWORD   sizeAliasPtr;
    DWORD   sizeAddrPtr;
    DWORD   sizeAddrs;
    DWORD   sizeTotal;
    PCHAR   palias;
    DWORD   addrCount = 0;
    DWORD   aliasCount = 0;


    DNSDBG( HOSTENT, (
        "Hostent_Size( %p, %d, %d )\n",
        pHostent,
        CharSetExisting,
        CharSetTarget ));

    //
    //  name
    //

    if ( pHostent->h_name )
    {
        sizeName = Dns_GetBufferLengthForStringCopy(
                        pHostent->h_name,
                        0,
                        CharSetExisting,
                        CharSetTarget );

        sizeName = HOSTENT_STRING_ALIGN_DWORD( sizeName );
    }

    //
    //  aliases
    //

    if ( pHostent->h_aliases )
    {
        while ( palias = pHostent->h_aliases[aliasCount] )
        {
            sizeAliasNames += Dns_GetBufferLengthForStringCopy(
                                palias,
                                0,
                                CharSetExisting,
                                CharSetTarget );
    
            sizeAliasNames = HOSTENT_STRING_ALIGN_DWORD( sizeAliasNames );
            aliasCount++;
        }
    }
    sizeAliasPtr = (aliasCount+1) * sizeof(PCHAR);

    //
    //  addresses
    //

    if ( pHostent->h_addr_list )
    {
        while ( pHostent->h_addr_list[addrCount] )
        {
            addrCount++;
        }
    }
    sizeAddrPtr = (addrCount+1) * sizeof(PCHAR);
    sizeAddrs = addrCount * pHostent->h_length;

    //
    //  calc total size
    //
    //  note:  be careful of alignment issues
    //  our layout is
    //      - hostent struct
    //      - ptr arrays
    //      - address + string data
    //
    //  since address and string DATA (not ptrs) can be intermixed
    //  as we build, we MUST size strings for DWORD (at minimum) so
    //  to that addresses may be DWORD aligned
    //
    //  in copying we can copy all addresses first and avoid intermix
    //  but DWORD string alignment is still safe
    //

    sizeTotal = POINTER_ALIGN_DWORD( sizeof(HOSTENT) ) +
                sizeAliasPtr +
                sizeAddrPtr +
                sizeAddrs +
                sizeName +
                sizeAliasNames;

    if ( pAddrCount )
    {
        *pAddrCount = addrCount;
    }
    if ( pAliasCount )
    {
        *pAliasCount = aliasCount;
    }

    DNSDBG( HOSTENT, (
        "Hostent sized:\n"
        "\tname         = %d\n"
        "\talias ptrs   = %d\n"
        "\talias names  = %d\n"
        "\taddr ptrs    = %d\n"
        "\taddrs        = %d\n"
        "\ttotal        = %d\n",
        sizeName,
        sizeAliasPtr,
        sizeAliasNames,
        sizeAddrPtr,
        sizeAddrs,
        sizeTotal ));

    return  sizeTotal;
}



PHOSTENT
Hostent_Init(
    IN OUT  PBYTE *         ppBuffer,
    //IN OUT  PINT            pBufSize,
    IN      INT             Family,
    IN      INT             AddrLength,
    IN      DWORD           AddrCount,
    IN      DWORD           AliasCount
    )
/*++

Routine Description:

    Init hostent struct.

    Assumes length is adequate.

Arguments:

    ppBuffer -- addr to ptr to buffer to write hostent;
        on return contains next location in buffer

    Family -- address family

    AddrLength -- address length

    AddrCount -- address count

    AliasCount -- alias count

Return Value:

    Ptr to hostent.

--*/
{
    PBYTE       pbuf = *ppBuffer;
    PHOSTENT    phost;
    DWORD       size;

    //
    //  hostent
    //      - must be pointer aligned
    //

    phost = (PHOSTENT) POINTER_ALIGN( pbuf );

    phost->h_name       = NULL;
    phost->h_length     = (SHORT) AddrLength;
    phost->h_addrtype   = (SHORT) Family;

    pbuf = (PBYTE) (phost + 1);

    //
    //  init alias array
    //      - set hostent ptr
    //      - clear entire alias array;
    //      since this count is often defaulted nice to clear it just
    //      to avoid junk
    //  

    pbuf = (PBYTE) POINTER_ALIGN( pbuf );
    phost->h_aliases = (PCHAR *) pbuf;

    size = (AliasCount+1) * sizeof(PCHAR);

    RtlZeroMemory(
        pbuf,
        size );

    pbuf += size;

    //
    //  init addr array
    //      - set hostent ptr
    //      - clear first address entry
    //      callers responsibility to NULL last addr pointer when done
    //

    *(PCHAR *)pbuf = NULL;
    phost->h_addr_list = (PCHAR *) pbuf;

    pbuf += (AddrCount+1) * sizeof(PCHAR);

    //
    //  return next position in buffer
    //

    *ppBuffer = pbuf;

    return  phost;
}



VOID
Dns_PtrArrayToOffsetArray(
    IN OUT  PCHAR *         PtrArray,
    IN      PCHAR           pBase
    )
/*++

Routine Description:

    Change an array of pointers into array of offsets.

    This is used to convert aliases lists to offsets.

Arguments:

    pPtrArray -- addr of ptr to array of pointers to convert to offsets
        the array must be terminated by NULL ptr

    pBase -- base address to offset from

Return Value:

    None

--*/
{
    PCHAR * pptr = PtrArray;
    PCHAR   pdata;

    DNSDBG( TRACE, ( "Dns_PtrArrayToOffsetArray()\n" ));

    //
    //  turn each pointer into offset
    //

    while( pdata = *pptr )
    {
        *pptr++ = (PCHAR)( (PCHAR)pdata - (PCHAR)pBase );
    }
}



VOID
Hostent_ConvertToOffsets(
    IN OUT  PHOSTENT        pHostent
    )
/*++

Routine Description:

    Convert hostent to offsets.

Arguments:

    pHostent -- hostent to convert to offsets

Return Value:

    None

--*/
{
    PBYTE   ptr;

    DNSDBG( TRACE, ( "Hostent_ConvertToOffsets()\n" ));

    //
    //  convert
    //      - name
    //      - alias array pointer
    //      - address array pointer
    //

    if ( ptr = pHostent->h_name )
    {
        pHostent->h_name = (PCHAR) (ptr - (PBYTE)pHostent);
    }

    //  alias array
    //      - convert array pointer
    //      - convert pointers in array

    if ( ptr = (PBYTE)pHostent->h_aliases )
    {
        pHostent->h_aliases = (PCHAR *) (ptr - (PBYTE)pHostent);

        Dns_PtrArrayToOffsetArray(
            (PCHAR *) ptr,
            (PCHAR) pHostent );
    }

    //  address array
    //      - convert array pointer
    //      - convert pointers in array

    if ( ptr = (PBYTE)pHostent->h_addr_list )
    {
        pHostent->h_addr_list = (PCHAR *) (ptr - (PBYTE)pHostent);

        Dns_PtrArrayToOffsetArray(
            (PCHAR *) ptr,
            (PCHAR) pHostent );
    }

    DNSDBG( TRACE, ( "Leave Hostent_ConvertToOffsets()\n" ));
}



PHOSTENT
Hostent_Copy(
    IN OUT  PBYTE *         ppBuffer,
    IN OUT  PINT            pBufferSize,
    OUT     PINT            pHostentSize,
    IN      PHOSTENT        pHostent,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetTarget,
    IN      BOOL            fOffsets,
    IN      BOOL            fAlloc
    )
/*++

Routine Description:

    Copy a hostent.

Arguments:

    ppBuffer -- addr with ptr to buffer to write to;
        if no buffer then hostent is allocated
        updated with ptr to position in buffer after hostent

    pBufferSize -- addr containing size of buffer;
        updated with bytes left after hostent written
        (even if out of space, it contains missing number of
        bytes as negative number)

    pHostentSize -- addr to recv total size of hostent written

    pHostent -- existing hostent to copy

    CharSetIn -- charset of existing hostent

    CharSetTarget -- charset of target hostent

    fOffsets -- write hostent with offsets

    fAlloc -- allocate copy

Return Value:

    Ptr to new hostent.
    NULL on error.  See GetLastError().

--*/
{
    PBYTE       pch;
    PHOSTENT    phost = NULL;
    DWORD       size;
    DWORD       sizeTotal;
    DWORD       bytesLeft;
    DWORD       aliasCount;
    DWORD       addrCount;
    DWORD       addrLength;
    PCHAR *     pptrArrayIn;
    PCHAR *     pptrArrayOut;
    PCHAR       pdataIn;


    DNSDBG( HOSTENT, (
        "Hostent_Copy()\n" ));

    //
    //  determine required hostent size
    //      - allow sizing skip for already allocated buffers only
    //

    sizeTotal = Hostent_Size(
                    pHostent,
                    CharSetIn,
                    CharSetTarget,
                    & aliasCount,
                    & addrCount );
    
    //
    //  alloc or reserve size in buffer
    //

    if ( fAlloc )
    {
        pch = ALLOCATE_HEAP( sizeTotal );
        if ( !pch )
        {
            goto Failed;
        }
    }
    else
    {
        pch = FlatBuf_Arg_ReserveAlignPointer(
                    ppBuffer,
                    pBufferSize,
                    sizeTotal
                    );
        if ( !pch )
        {
            goto Failed;
        }
    }

    //
    //  note:  assuming from here on down that we have adequate space
    //
    //  reason we aren't building with FlatBuf routines is that
    //      a) i wrote this first
    //      b) we believe we have adequate space
    //      c) i haven't built FlatBuf string conversion routines
    //      which we need below (for RnR unicode to ANSI)
    //
    //  we could reset buf pointers here and build directly with FlatBuf
    //  routines;  this isn't directly necessary
    //

    //
    //  init hostent struct 
    //

    addrLength = pHostent->h_length;

    phost = Hostent_Init(
                & pch,
                pHostent->h_addrtype,
                addrLength,
                addrCount,
                aliasCount );

    DNS_ASSERT( pch > (PBYTE)phost );

    //
    //  copy addresses
    //      - no need to align as previous is address
    //

    pptrArrayIn     = pHostent->h_addr_list;
    pptrArrayOut    = phost->h_addr_list;

    if ( pptrArrayIn )
    {
        while( pdataIn = *pptrArrayIn++ )
        {
            *pptrArrayOut++ = pch;

            RtlCopyMemory(
                pch,
                pdataIn,
                addrLength );

            pch += addrLength;
        }
    }
    *pptrArrayOut = NULL;

    //
    //  copy the aliases
    //

    pptrArrayIn     = pHostent->h_aliases;
    pptrArrayOut    = phost->h_aliases;

    if ( pptrArrayIn )
    {
        while( pdataIn = *pptrArrayIn++ )
        {
            pch = REQUIRED_HOSTENT_STRING_ALIGN_PTR( pch );

            *pptrArrayOut++ = pch;

            size = Dns_StringCopy(
                        pch,
                        NULL,       // infinite size
                        pdataIn,
                        0,          // unknown length
                        CharSetIn,
                        CharSetTarget
                        );
            pch += size;
        }
    }
    *pptrArrayOut = NULL;

    //
    //  copy the name
    //

    if ( pHostent->h_name )
    {
        pch = REQUIRED_HOSTENT_STRING_ALIGN_PTR( pch );

        phost->h_name = pch;

        size = Dns_StringCopy(
                    pch,
                    NULL,       // infinite size
                    pHostent->h_name,
                    0,          // unknown length
                    CharSetIn,
                    CharSetTarget
                    );
        pch += size;
    }

    //
    //  copy is complete
    //      - verify our write functions work
    //

    ASSERT( (DWORD)(pch-(PBYTE)phost) <= sizeTotal );

    if ( pHostentSize )
    {
        *pHostentSize = (INT)( pch - (PBYTE)phost );
    }

    if ( !fAlloc )
    {
        PBYTE   pnext = *ppBuffer;

        //  if we sized too small --
        //  fix up the buf pointer and bytes left

        if ( pnext < pch )
        {
            ASSERT( FALSE );
            *ppBuffer = pch;
            *pBufferSize -= (INT)(pch - pnext);
        }
    }

    IF_DNSDBG( HOSTENT )
    {
        DnsDbg_Hostent(
            "Hostent copy:",
            phost,
            (CharSetTarget == DnsCharSetUnicode) );
    }

    //
    //  convert to offsets?
    //

    if ( fOffsets )
    {
        Hostent_ConvertToOffsets( phost );
    }


Failed:

    DNSDBG( TRACE, (
        "Leave Hostent_Copy() => %p\n",
        phost ));

    return  phost;
}




DWORD
Hostent_WriteIp4Addrs(
    IN OUT  PHOSTENT        pHostent,
    OUT     PCHAR           pAddrBuf,
    IN      DWORD           MaxBufCount,
    IN      PIP4_ADDRESS    Ip4Array,
    IN      DWORD           ArrayCount,
    IN      BOOL            fScreenZero
    )
/*++

Routine Description:

    Write IP4 addresses to hostent.

Arguments:

    pHostent -- hostent

    pAddrBuf -- buffer to hold addresses

    MaxBufCount -- max IPs buffer can hold

    Ip4Array -- array of IP4 addresses

    ArrayCount -- array count

    fScreenZero -- screen out zero addresses?

Return Value:

    Count of addresses written

--*/
{
    DWORD           i = 0;
    DWORD           stopCount = MaxBufCount;
    PIP4_ADDRESS    pip = (PIP_ADDRESS) pAddrBuf;
    PIP4_ADDRESS *  pipPtr = (PIP4_ADDRESS *) pHostent->h_addr_list;

    //
    //  write IP addresses OR loopback if no IPs 
    //

    if ( Ip4Array )
    {
        if ( ArrayCount < stopCount )
        {
            stopCount = ArrayCount;
        }

        for ( i=0; i < stopCount; ++i )
        {
            IP4_ADDRESS ip = Ip4Array[i];
            if ( ip != 0  ||  !fScreenZero )
            {
                *pip = ip;
                *pipPtr++ = pip++;
            }
        }
    }
    
    *pipPtr = NULL;

    //  count of addresses written

    return( i );
}



DWORD
Hostent_WriteLocalIp4Array(
    IN OUT  PHOSTENT        pHostent,
    OUT     PCHAR           pAddrBuf,
    IN      DWORD           MaxBufCount,
    IN      PIP_ARRAY       pIpArray
    )
/*++

Routine Description:

    Write local IP list into hostent.

Arguments:

    pHostent -- hostent

    pAddrBuf -- buffer to hold addresses

    MaxBufCount -- max IPs buffer can hold

    pIpArray -- IP4 array of local addresses

Return Value:

    Count of addresses written

--*/
{
    DWORD   count = 0;

    //
    //  write array
    //

    if ( pIpArray )
    {
        count = Hostent_WriteIp4Addrs(
                    pHostent,
                    pAddrBuf,
                    MaxBufCount,
                    pIpArray->AddrArray,
                    pIpArray->AddrCount,
                    TRUE        // screen out zeros
                    );
    }

    //
    //  if no addresses written, write loopback
    //

    if ( count==0 )
    {
        pHostent->h_addr_list[0] = pAddrBuf;
        pHostent->h_addr_list[1] = NULL;
        *((IP4_ADDRESS*)pAddrBuf) = DNS_NET_ORDER_LOOPBACK;
        count = 1;
    }

    //  count of addresses written

    return( count );
}



BOOL
Hostent_SetToSingleAddress(
    IN OUT  PHOSTENT        pHostent,
    IN      PCHAR           pAddr,
    IN      DWORD           AddrLength
    )
/*++

Routine Description:

    Set address in hostent.

Arguments:

    pHostent -- hostent to check

    pAddr -- ptr to address to check

    AddrLength -- address length

Return Value:

    TRUE if address successfully copied into hostent.
    FALSE otherwise (no hostent, wrong length, hostent empty)

--*/
{
    PCHAR   paddrHostent;

    //
    //  validate
    //      - must have hostent
    //      - length must match
    //

    if ( !pHostent ||
         AddrLength != (DWORD)pHostent->h_length )
    {
        return FALSE;
    }

    //
    //  slam address in on top of existing
    //      - NULL 2nd addr pointer to terminate list
    //

    paddrHostent = pHostent->h_addr_list[0];
    if ( !paddrHostent )
    {
        return FALSE;
    }

    RtlCopyMemory(
        paddrHostent,
        pAddr,
        AddrLength );

    pHostent->h_addr_list[1] = NULL;

    return  TRUE;
}



BOOL
Hostent_IsAddressInHostent(
    IN OUT  PHOSTENT        pHostent,
    IN      PCHAR           pAddr,
    IN      DWORD           AddrLength,
    IN      INT             Family          OPTIONAL
    )
/*++

Routine Description:

    Does hostent contain this address.

Arguments:

    pHostent -- hostent to check

    pAddr -- ptr to address to check

    AddrLength -- address length

    Family -- address family

Return Value:

    TRUE if address is in hostent.
    FALSE otherwise.

--*/
{
    BOOL    freturn = FALSE;
    DWORD   i;
    PCHAR   paddrHostent;

    //
    //  validate
    //      - must have hostent
    //      - must have address
    //      - if family given, must match
    //      - length must match
    //

    if ( !pHostent ||
         !pAddr    ||
         AddrLength != (DWORD)pHostent->h_length ||
         ( Family && Family != pHostent->h_addrtype ) )
    {
        return freturn;
    }

    //
    //  search for address -- if found return TRUE
    //

    i = 0;

    while ( paddrHostent = pHostent->h_addr_list[i++] )
    {
        freturn = RtlEqualMemory(
                        paddrHostent,
                        pAddr,
                        AddrLength );
        if ( freturn )
        {
            break;
        }
    }

    return  freturn;
}



BOOL
Hostent_IsIp4AddressInHostent(
    IN OUT  PHOSTENT        pHostent,
    IN      IP4_ADDRESS     Ip4Addr
    )
/*++

Routine Description:

    Does hostent contain this address.

Arguments:

    pHostent -- hostent to check

    pAddr -- ptr to address to check

    AddrLength -- address length

    Family -- address family

Return Value:

    TRUE if address is in hostent.
    FALSE otherwise.

--*/
{
    DWORD   i;
    PCHAR   paddrHostent;

    //
    //  validate
    //      - must have hostent
    //      - length must match
    //

    if ( !pHostent ||
         sizeof(IP4_ADDRESS) != (DWORD)pHostent->h_length )
    {
        return FALSE;
    }

    //
    //  search for address -- if found return TRUE
    //

    i = 0;

    while ( paddrHostent = pHostent->h_addr_list[i++] )
    {
        if ( Ip4Addr == *(PIP4_ADDRESS)paddrHostent )
        {
            return  TRUE;
        }
    }
    return  FALSE;
}




//
//  Hostent building utilities
//

DNS_STATUS
HostentBlob_Create(
    IN OUT  PHOSTENT_BLOB * ppBlob,
    IN      PHOSTENT_INIT   pReq
    )
/*++

Routine Description:

    Initialize hostent (extending buffers as necessary)

    May allocate hostent buffer if existing too small.
    Returns required size.

Arguments:

    ppBlob -- addr containing or to recv hostent object

    pReq -- hostent init request

Return Value:

--*/
{
    PHOSTENT_BLOB   pblob = *ppBlob;
    PHOSTENT    phost;
    PCHAR       pbuf;
    BOOL        funicode = FALSE;
    DWORD       bytesLeft;
    DWORD       addrSize;
    DWORD       addrType;
    DWORD       countAlias;
    DWORD       countAddr;

    DWORD       sizeChar;
    DWORD       sizeHostent = 0;
    DWORD       sizeAliasPtr;
    DWORD       sizeAddrPtr;
    DWORD       sizeAddrs;
    DWORD       sizeName;
    DWORD       sizeAliasNames;
    DWORD       sizeTotal;

    DNSDBG( HOSTENT, ( "HostentBlob_Create()\n" ));


    //
    //  calculate required size
    //

    //  size for all char allocs
    //
    //  note, we save CharSet info, if known, but the real
    //  action in sizing or building or printing strings is simply
    //  unicode\not-unicode

    sizeChar = sizeof(CHAR);
    if ( pReq->fUnicode || pReq->CharSet == DnsCharSetUnicode )
    {
        sizeChar = sizeof(WCHAR);
        funicode = TRUE;
    }

    //  limit alias count

    countAlias = pReq->AliasCount;
    if ( countAlias > DNS_MAX_ALIAS_COUNT )
    {
        countAlias = DNS_MAX_ALIAS_COUNT;
    }
    sizeAliasPtr = (countAlias+1) * sizeof(PCHAR);

    //  size address pointer array
    //  - always size for at least one address
    //      - write PTR address after record write
    //      - write loopback or other local address
    //          into local hostent

    countAddr = pReq->AddrCount;
    if ( countAddr == 0 )
    {
        countAddr = 1;
    }
    sizeAddrPtr = (countAddr+1) * sizeof(PCHAR);

    //
    //  determine address size and type
    //      - may be specified directly
    //      - or picked up from DNS type
    //
    //  DCR:  functionalize type-to\from-family and addr size
    //

    addrType = pReq->AddrFamily;

    if ( !addrType )
    {
        WORD wtype = pReq->wType;

        if ( wtype == DNS_TYPE_A )
        {
            addrType = AF_INET;
        }
        else if ( wtype == DNS_TYPE_AAAA ||
                  wtype == DNS_TYPE_A6 )
        {
            addrType = AF_INET6;
        }
        else if ( wtype == DNS_TYPE_ATMA )
        {
            addrType = AF_ATM;
        }
    }

    if ( addrType == AF_INET )
    {
        addrSize = sizeof(IP4_ADDRESS);
    }
    else if ( addrType == AF_INET6 )
    {
        addrSize = sizeof(IP6_ADDRESS    );
    }
    else if ( addrType == AF_ATM )
    {
        addrSize = sizeof(ATM_ADDRESS);
    }
    else
    {
        //  should have type and count or neither
        DNS_ASSERT( pReq->AddrCount == 0 );
        addrSize = 0;
    }

    sizeAddrs = countAddr * addrSize;

    //  always have buffer large enough for one
    //  address of largest type

    if ( sizeAddrs < MIN_ADDR_BUF_SIZE )
    {
        sizeAddrs = MIN_ADDR_BUF_SIZE;
    }

    //
    //  namelength
    //      - if actual name use it
    //          (charset must match type we're building)
    //      - if size, use it
    //      - if absent use MAX
    //      - round to DWORD

    if ( pReq->pName )
    {
        if ( funicode )
        {
            sizeName = wcslen( (PWSTR)pReq->pName );
        }
        else
        {
            sizeName = strlen( pReq->pName );
        }
    }
    else
    {
        sizeName = pReq->NameLength;
    }

    if ( sizeName )
    {
        sizeName++;
    }
    else
    {
        sizeName = DNS_MAX_NAME_BUFFER_LENGTH;
    }
    sizeName = HOSTENT_STRING_ALIGN_DWORD( sizeChar*sizeName );

    //
    //  alias name lengths
    //      - if absent use MAX for each string
    //      - round to DWORD
    //

    sizeAliasNames = pReq->AliasNameLength;

    if ( sizeAliasNames )
    {
        sizeAliasNames += pReq->AliasCount;
    }
    else
    {
        sizeAliasNames = DNS_MAX_NAME_BUFFER_LENGTH;
    }
    sizeAliasNames = HOSTENT_STRING_ALIGN_DWORD( sizeChar*sizeAliasNames );


    //
    //  calc total size
    //
    //  note:  be careful of alignment issues
    //  our layout is
    //      - hostent struct
    //      - ptr arrays
    //      - address + string data
    //
    //  since address and string DATA (not ptrs) can be intermixed
    //  as we build, we MUST size strings for DWORD (at minimum) so
    //  to that addresses may be DWORD aligned
    //

    sizeTotal = POINTER_ALIGN_DWORD( sizeof(HOSTENT) ) +
                sizeAliasPtr +
                sizeAddrPtr +
                sizeAddrs +
                sizeName +
                sizeAliasNames;

    //
    //  if no blob, allocate one along with buffer
    //

    if ( !pblob )
    {
        pblob = (PHOSTENT_BLOB) ALLOCATE_HEAP( sizeTotal + sizeof(HOSTENT_BLOB) );
        if ( !pblob )
        {
            goto Failed;
        }
        RtlZeroMemory( pblob, sizeof(*pblob) );

        pbuf = (PCHAR) (pblob + 1);
        pblob->pBuffer = pbuf;
        pblob->BufferLength = sizeTotal;
        pblob->fAllocatedBlob = TRUE;
        pblob->fAllocatedBuf = FALSE;
    }

    //
    //  check existing buffer for size
    //      - allocate new buffer if necessary
    //

    else
    {
        pbuf = pblob->pBuffer;
    
        if ( !pbuf  ||  pblob->BufferLength < sizeTotal )
        {
            if ( pbuf && pblob->fAllocatedBuf )
            {
                FREE_HEAP( pbuf );
            }
        
            pbuf = ALLOCATE_HEAP( sizeTotal );
            pblob->pBuffer = pbuf;
        
            if ( pbuf )
            {
                pblob->BufferLength = sizeTotal;
                pblob->fAllocatedBuf = TRUE;
            }
    
            //
            //  DCR:  alloc failure handling
            //    - possibly keep previous buffers limitations
            //
    
            else    // alloc failed
            {
                pblob->fAllocatedBuf = FALSE;
                return( DNS_ERROR_NO_MEMORY );
            }
        }
    }

    //
    //  init hostent and buffer subfields
    //

    bytesLeft = pblob->BufferLength;

    //
    //  hostent
    //

    phost = (PHOSTENT) pbuf;
    pbuf += sizeof(HOSTENT);
    bytesLeft -= sizeof(HOSTENT);

    pblob->pHostent = phost;

    phost->h_name       = NULL;
    phost->h_addr_list  = NULL;
    phost->h_aliases    = NULL;
    phost->h_length     = (SHORT) addrSize;
    phost->h_addrtype   = (SHORT) addrType;

    pblob->fWroteName   = FALSE;
    pblob->AliasCount   = 0;
    pblob->AddrCount    = 0;
    pblob->CharSet      = pReq->CharSet;
    pblob->fUnicode     = funicode;
    if ( funicode )
    {
        pblob->CharSet  = DnsCharSetUnicode;
    }

    //
    //  init alias array
    //      - set hostent ptr
    //      - clear entire alias array;
    //      since this count is often defaulted nice to clear it just
    //      to avoid junk
    //
    //  

#if 0
    pwrite = FlatBuf_ReserveAlignPointer(
                & pbuf,
                & bytesLeft,
                sizeAliasPtr );
#endif

    if ( bytesLeft < sizeAliasPtr )
    {
        DNS_ASSERT( FALSE );
        goto Failed;
    }
    RtlZeroMemory(
        pbuf,
        sizeAliasPtr );

    phost->h_aliases = (PCHAR *) pbuf;

    pbuf += sizeAliasPtr;
    bytesLeft -= sizeAliasPtr;

    pblob->MaxAliasCount = countAlias;
    
    //
    //  init addr array
    //      - set hostent ptr
    //      - clear first address entry
    //      callers responsibility to NULL last addr pointer when done
    //

    if ( bytesLeft < sizeAddrPtr )
    {
        DNS_ASSERT( FALSE );
        goto Failed;
    }
    * (PCHAR *)pbuf = NULL;
    phost->h_addr_list = (PCHAR *) pbuf;

    pbuf += sizeAddrPtr;
    bytesLeft -= sizeAddrPtr;

    pblob->MaxAddrCount = countAddr;

    //
    //  set remaining buffer info
    //      - save current buffer space
    //      - save data on part of buffer available
    //      for use by data
    //

    pblob->pAvailBuffer  = pbuf;
    pblob->AvailLength   = bytesLeft;

    pblob->pCurrent      = pbuf;
    pblob->BytesLeft     = bytesLeft;

    *ppBlob = pblob;

    IF_DNSDBG( HOSTENT )
    {
        DnsDbg_HostentBlob(
            "HostentBlob After Create:",
            pblob );
    }

    return( ERROR_SUCCESS );


Failed:

    *ppBlob = pblob;

    if ( pblob && pblob->pBuffer && pblob->fAllocatedBuf )
    {
        FREE_HEAP( pblob->pBuffer );
        pblob->pBuffer = NULL;
        pblob->fAllocatedBuf = FALSE;
    }

    DNSDBG( HOSTENT, ( "Hostent Blob create failed!\n" ));

    return( DNS_ERROR_NO_MEMORY );
}



PHOSTENT_BLOB
HostentBlob_CreateAttachExisting(
    IN      PHOSTENT        pHostent,
    IN      BOOL            fUnicode
    )
/*++

Routine Description:

    Create hostent blob for existing hostent.

    This is a hack to allow existing RnR TLS hostents to
    be attached to hostent-blobs to smooth code transition.

    A full version would obviously require init structure and
    separate the sizing\init function from the creation
    function.

Arguments:

    pHostent -- existing hostent

    fUnicode -- is unicode

Return Value:

    Ptr to new hostent blob.
    NULL on alloc failure.  GetLastError() has error.

--*/
{
    PHOSTENT_BLOB   pblob;

    DNSDBG( HOSTENT, ( "HostentBlob_CreateAttachExisting()\n" ));

    //
    //  alloc
    //

    pblob = (PHOSTENT_BLOB) ALLOCATE_HEAP_ZERO( sizeof(HOSTENT_BLOB) );
    if ( !pblob )
    {
        SetLastError( DNS_ERROR_NO_MEMORY );
        return  NULL;
    }

    //
    //  attach existing hostent
    //

    pblob->pHostent = pHostent;
    pblob->fUnicode = fUnicode;

    IF_DNSDBG( HOSTENT )
    {
        DnsDbg_HostentBlob(
            "Leaving AttachExisting:",
            pblob );
    }

    return  pblob;
}



VOID
HostentBlob_Free(
    IN OUT  PHOSTENT_BLOB   pBlob
    )
/*++

Routine Description:

    Free hostent blob.

Arguments:

    pBlob -- blob to free

Return Value:

    None

--*/
{
    //
    //  free buffer?
    //

    if ( !pBlob )
    {
        return;
    }
    if ( pBlob->fAllocatedBuf )
    {
        FREE_HEAP( pBlob->pBuffer );
        pBlob->pBuffer = NULL;
        pBlob->fAllocatedBuf = FALSE;
    }

    //
    //  free blob itself?
    //

    if ( pBlob->fAllocatedBlob )
    {
        FREE_HEAP( pBlob );
    }
}



DNS_STATUS
HostentBlob_WriteAddress(
    IN OUT  PHOSTENT_BLOB   pBlob,
    IN      PVOID           pAddress,
    IN      DWORD           AddrSize,
    IN      DWORD           AddrType
    )
/*++

Routine Description:

    Write IP4 address to hostent blob.

Arguments:

    pBlob -- hostent build blob

    pAddress - address to write

    AddrSize - address size

    AddrType - address type (hostent type, e.g. AF_INET)

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_MORE_DATA if out of buffer space
    ERROR_INVALID_DATA if address doesn't match hostent

--*/
{
    DWORD       count = pBlob->AddrCount;
    PHOSTENT    phost = pBlob->pHostent;
    PCHAR       pcurrent;
    DWORD       bytesLeft;

    //  verify type
    //      - set if empty or no addresses written

    if ( phost->h_addrtype != (SHORT)AddrType )
    {
        if ( phost->h_addrtype != 0 )
        {
            return( ERROR_INVALID_DATA );
        }
        phost->h_addrtype   = (SHORT) AddrType;
        phost->h_length     = (SHORT) AddrSize;
    }

    //  verify space

    if ( count >= pBlob->MaxAddrCount )
    {
        return( ERROR_MORE_DATA );
    }

    //  align - to DWORD

    pcurrent = DWORD_ALIGN( pBlob->pCurrent );
    bytesLeft = pBlob->BytesLeft;
    bytesLeft -= (DWORD)(pcurrent - pBlob->pCurrent);

    if ( bytesLeft < AddrSize )
    {
        return( ERROR_MORE_DATA );
    }

    //  copy
    //      - copy address to buffer
    //      - set pointer in addr list
    //      NULL following pointer

    RtlCopyMemory(
        pcurrent,
        pAddress,
        AddrSize );

    phost->h_addr_list[count++] = pcurrent;
    phost->h_addr_list[count]   = NULL;
    pBlob->AddrCount = count;

    pBlob->pCurrent = pcurrent + AddrSize;
    pBlob->BytesLeft = bytesLeft - AddrSize;

    return( NO_ERROR );
}



DNS_STATUS
HostentBlob_WriteAddressArray(
    IN OUT  PHOSTENT_BLOB   pBlob,
    IN      PVOID           pAddrArray,
    IN      DWORD           AddrCount,
    IN      DWORD           AddrSize,
    IN      DWORD           AddrType
    )
/*++

Routine Description:

    Write address array to hostent blob.

Arguments:

    pBlob -- hostent build blob

    pAddrArray - address array to write

    AddrCount - address count

    AddrSize - address size

    AddrType - address type (hostent type, e.g. AF_INET)

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_MORE_DATA if out of buffer space
    ERROR_INVALID_DATA if address doesn't match hostent

--*/
{
    DWORD       count = AddrCount;
    PHOSTENT    phost = pBlob->pHostent;
    PCHAR       pcurrent;
    DWORD       totalSize;
    DWORD       i;
    DWORD       bytesLeft;

    //  verify type
    //      - set if empty or no addresses written

    if ( phost->h_addrtype != (SHORT)AddrType )
    {
        if ( phost->h_addrtype != 0 )
        {
            return( ERROR_INVALID_DATA );
        }
        phost->h_addrtype   = (SHORT) AddrType;
        phost->h_length     = (SHORT) AddrSize;
    }

    //  verify space

    if ( count > pBlob->MaxAddrCount )
    {
        return( ERROR_MORE_DATA );
    }

    //  align - to DWORD
    //
    //  note:  we are assuming that pAddrArray is internally
    //      aligned adequately, otherwise we wouldn't be
    //      getting an intact array and would have to add serially
    
    pcurrent = DWORD_ALIGN( pBlob->pCurrent );
    bytesLeft = pBlob->BytesLeft;
    bytesLeft -= (DWORD)(pcurrent - pBlob->pCurrent);

    totalSize = count * AddrSize;

    if ( bytesLeft < totalSize )
    {
        return( ERROR_MORE_DATA );
    }

    //  copy
    //      - copy address array to buffer
    //      - set pointer to each address in array
    //      - NULL following pointer

    RtlCopyMemory(
        pcurrent,
        pAddrArray,
        totalSize );

    for ( i=0; i<count; i++ )
    {
        phost->h_addr_list[i] = pcurrent;
        pcurrent += AddrSize;
    }
    phost->h_addr_list[count] = NULL;
    pBlob->AddrCount = count;

    pBlob->pCurrent = pcurrent;
    pBlob->BytesLeft = bytesLeft - totalSize;

    return( NO_ERROR );
}



DNS_STATUS
HostentBlob_WriteNameOrAlias(
    IN OUT  PHOSTENT_BLOB   pBlob,
    IN      PSTR            pszName,
    IN      BOOL            fAlias,
    IN      BOOL            fUnicode
    )
/*++

Routine Description:

    Write name or alias to hostent

Arguments:

    pBlob -- hostent build blob

    pszName -- name to write

    fAlias -- TRUE for alias;  FALSE for name

    fUnicode -- name is unicode

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_MORE_DATA if out of buffer space
    ERROR_INVALID_DATA if address doesn't match hostent

--*/
{
    DWORD       count = pBlob->AliasCount;
    PHOSTENT    phost = pBlob->pHostent;
    DWORD       length;
    PCHAR       pcurrent;
    DWORD       bytesLeft;

    //
    //  check length
    //

    if ( fUnicode )
    {
        length = (wcslen( (PCWSTR)pszName ) + 1) * sizeof(WCHAR);
    }
    else
    {
        length = strlen( pszName ) + 1;
    }

    //
    //  verify space
    //  included ptr space
    //      - skip if already written name
    //      or exhausted alias array
    //      

    if ( fAlias )
    {
        if ( count >= pBlob->MaxAliasCount )
        {
            return( ERROR_MORE_DATA );
        }
    }
    else if ( pBlob->fWroteName )
    {
        return( ERROR_MORE_DATA );
    }

    //  align
    
    pcurrent = REQUIRED_HOSTENT_STRING_ALIGN_PTR( pBlob->pCurrent );
    bytesLeft = pBlob->BytesLeft;
    bytesLeft -= (DWORD)(pcurrent - pBlob->pCurrent);

    if ( bytesLeft < length )
    {
        return( ERROR_MORE_DATA );
    }

    //  copy
    //      - copy address to buffer
    //      - set pointer in addr list
    //      NULL following pointer

    RtlCopyMemory(
        pcurrent,
        pszName,
        length );

    if ( fAlias )
    {
        phost->h_aliases[count++]   = pcurrent;
        phost->h_aliases[count]     = NULL;
        pBlob->AliasCount = count;
    }
    else
    {
        phost->h_name = pcurrent;
        pBlob->fWroteName = TRUE;
    }

    length = REQUIRED_HOSTENT_STRING_ALIGN_DWORD( length );
    pBlob->pCurrent = pcurrent + length;
    pBlob->BytesLeft = bytesLeft - length;

    return( NO_ERROR );
}



DNS_STATUS
HostentBlob_WriteRecords(
    IN OUT  PHOSTENT_BLOB   pBlob,
    IN      PDNS_RECORD     pRecords,
    IN      BOOL            fWriteName
    )
/*++

Routine Description:

    Write name or alias to hostent

Arguments:

    pBlob -- hostent build blob

    pRecords -- records to convert to hostent

    fWriteName -- write name

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_MORE_DATA if out of buffer space
    ERROR_INVALID_DATA if address doesn't match hostent

--*/
{
    DNS_STATUS  status = NO_ERROR;
    PDNS_RECORD prr = pRecords;

    DNSDBG( HOSTENT, (
        "HostentBlob_WriteRecords( %p, %p, %d )\n",
        pBlob,
        pRecords,
        fWriteName ));

    //
    //  write each record in turn to hostent
    //

    while ( prr )
    {
        WORD wtype;

        if ( prr->Flags.S.Section != DNSREC_ANSWER &&
             prr->Flags.S.Section != 0 )
        {
            prr = prr->pNext;
            continue;
        }

        wtype = prr->wType;

        switch( wtype )
        {
        case DNS_TYPE_A:

            status = HostentBlob_WriteAddress(
                            pBlob,
                            &prr->Data.A.IpAddress,
                            sizeof(IP4_ADDRESS),
                            AF_INET );
            break;

        case DNS_TYPE_AAAA:

            status = HostentBlob_WriteAddress(
                            pBlob,
                            &prr->Data.AAAA.Ip6Address,
                            sizeof(IP6_ADDRESS    ),
                            AF_INET6 );
            break;

        case DNS_TYPE_ATMA:
        {
            ATM_ADDRESS atmAddr;

            //  DCR:  functionalize ATMA to ATM conversion
            //      not sure this num of digits is correct
            //      may have to actually parse address

            atmAddr.AddressType = prr->Data.ATMA.AddressType;
            atmAddr.NumofDigits = ATM_ADDR_SIZE;
            RtlCopyMemory(
                & atmAddr.Addr,
                prr->Data.ATMA.Address,
                ATM_ADDR_SIZE );

            status = HostentBlob_WriteAddress(
                            pBlob,
                            & atmAddr,
                            sizeof(ATM_ADDRESS),
                            AF_ATM );
            break;
        }

        case DNS_TYPE_CNAME:

            //  record name is an alias

            status = HostentBlob_WriteNameOrAlias(
                        pBlob,
                        prr->pName,
                        TRUE,       // alias
                        (prr->Flags.S.CharSet == DnsCharSetUnicode)
                        );
            break;

        case DNS_TYPE_PTR:

            //  target name is the hostent name
            //  but if already wrote name, PTR target becomes alias

            status = HostentBlob_WriteNameOrAlias(
                        pBlob,
                        prr->Data.PTR.pNameHost,
                        pBlob->fWroteName
                            ? TRUE          // alias
                            : FALSE,        // name
                        (prr->Flags.S.CharSet == DnsCharSetUnicode)
                        );
            break;

        default:

            DNSDBG( ANY, (
                "Error record of type = %d while building hostent!\n",
                wtype ));
            status = ERROR_INVALID_DATA;
        }

        if ( status != ERROR_SUCCESS )
        {
            DNSDBG( ANY, (
                "ERROR:  failed writing record to hostent!\n"
                "\tprr      = %p\n"
                "\ttype     = %d\n"
                "\tstatus   = %d\n",
                prr,
                wtype,
                status ));
        }

        prr = prr->pNext;
    }

    IF_DNSDBG( HOSTENT )
    {
        DnsDbg_HostentBlob(
            "HostentBlob after WriteRecords():",
            pBlob );
    }

    return( status );
}



DNS_STATUS
HostentBlob_CreateFromRecords(
    IN OUT  PHOSTENT_BLOB * ppBlob,
    IN      PDNS_RECORD     pRecords,
    IN      BOOL            fWriteName,
    IN      INT             AddrFamily,     OPTIONAL
    IN      WORD            wType           OPTIONAL
    )
/*++

Routine Description:

    Create hostent from records

Arguments:

    ppBlob -- ptr with or to recv hostent blob

    pRecords -- records to convert to hostent

    fWriteName -- write name to hostent

    AddrFamily -- addr family use if PTR records and no addr

    wType  -- query type, if known

Return Value:

    Ptr to blob if successful.
    NULL on error;  GetLastError() has error.

--*/
{
    DNS_STATUS      status = NO_ERROR;
    PDNS_RECORD     prrFirstAddr = NULL;
    PDNS_RECORD     prr;
    DWORD           addrCount = 0;
    WORD            addrType = 0;
    HOSTENT_INIT    request;
    PHOSTENT_BLOB   pblob = *ppBlob;

    DNSDBG( HOSTENT, (
        "HostentBlob_CreateFromRecords()\n"
        "\tpblob    = %p\n"
        "\tprr      = %p\n",
        pblob,
        pRecords ));

    //
    //  count addresses
    //
    //  DCR:  fix up section hack when hosts file records get ANSWER section
    //

    prr = pRecords;

    while ( prr )
    {
        if ( ( prr->Flags.S.Section == 0 ||
               prr->Flags.S.Section == DNSREC_ANSWER )
                &&
             Hostent_IsSupportedAddrType( prr->wType ) )
        {
            addrCount++;
            if ( !prrFirstAddr )
            {
                prrFirstAddr = prr;
                addrType = prr->wType;
            }
        }
        prr = prr->pNext;
    }

    //          
    //  create or reinit hostent blob
    //

    RtlZeroMemory( &request, sizeof(request) );
    
    request.AliasCount  = DNS_MAX_ALIAS_COUNT;
    request.AddrCount   = addrCount;
    request.wType       = addrType;
    if ( !addrType )
    {
        request.AddrFamily = AddrFamily;
    }
    request.CharSet     = (pRecords)
                                ? pRecords->Flags.S.CharSet
                                : DnsCharSetUnicode;
    
    status = HostentBlob_Create(
                & pblob,
                & request );
    
    if ( status != NO_ERROR )
    {
        goto Done;
    }

    //
    //  build hostent from answer records
    //
    //  note:  if manage to extract any useful data => continue
    //  this protects against new unwriteable records breaking us
    //

    status = HostentBlob_WriteRecords(
                pblob,
                pRecords,
                TRUE        // write name
                );

    if ( status != NO_ERROR )
    {
        if ( pblob->AddrCount ||
             pblob->AliasCount ||
             pblob->fWroteName )
        {
            status = NO_ERROR;
        }
        else
        {
            goto Done;
        }
    }

    //
    //  write address from PTR record
    //      - first record PTR
    //      OR
    //      - queried for PTR and got CNAME answer, which can happen
    //      in classless reverse lookup case
    //  
    //  DCR:  add PTR address lookup to HostentBlob_WriteRecords()
    //      - natural place
    //      - but would have to figure out handling of multiple PTRs
    //

    if ( pRecords &&
         (  pRecords->wType == DNS_TYPE_PTR ||
            ( wType == DNS_TYPE_PTR &&
              pRecords->wType == DNS_TYPE_CNAME &&
              pRecords->Flags.S.Section == DNSREC_ANSWER ) ) )
    {
        IP6_ADDRESS     ip6;
        DWORD           addrLength = sizeof(IP6_ADDRESS);
        INT             family = 0;
    
        DNSDBG( HOSTENT, (
            "Writing address for PTR record %S\n",
            pRecords->pName ));
    
        //  convert reverse name to IP
    
        if ( Dns_StringToAddressEx(
                    (PCHAR) & ip6,
                    & addrLength,
                    (PCSTR) pRecords->pName,
                    & family,
                    IS_UNICODE_RECORD(pRecords),
                    TRUE            //  reverse lookup name
                    ) )
        {
            status = HostentBlob_WriteAddress(
                        pblob,
                        (PCHAR) &ip6,
                        addrLength,
                        family );

            ASSERT( status == NO_ERROR );
            status = ERROR_SUCCESS;
        }
    }

    //
    //  write name?
    //

    if ( !pblob->fWroteName &&
         fWriteName &&
         prrFirstAddr )
    {
        status = HostentBlob_WriteNameOrAlias(
                    pblob,
                    prrFirstAddr->pName,
                    FALSE,          // name
                    (prrFirstAddr->Flags.S.CharSet == DnsCharSetUnicode)
                    );
    }

    IF_DNSDBG( HOSTENT )
    {
        DnsDbg_HostentBlob(
            "HostentBlob after CreateFromRecords():",
            pblob );
    }

Done:

    if ( status != NO_ERROR  &&  pblob )
    {
        HostentBlob_Free( pblob );
        pblob = NULL;
    }

    *ppBlob = pblob;

    DNSDBG( HOSTENT, (
        "Leave HostentBlob_CreateFromRecords() => status = %d\n",
        status ));

    return( status );
}



//
//  Hostent Query
//

PHOSTENT_BLOB
HostentBlob_Query(
    IN      PWSTR           pwsName,
    IN      WORD            wType,
    IN      DWORD           Flags,
    IN OUT  PVOID *         ppMsg,      OPTIONAL
    IN      INT             AddrFamily  OPTIONAL
    )
/*++

Routine Description:

    Query DNS to create hostent.

Arguments:

    pwsName -- name to query

    wType -- query type

    Flags -- query flags

    ppMsg -- addr to recv ptr to message

    AddrType -- address type (family) to reserve space for if querying
        for PTR records

Return Value:

    Ptr to blob if successful.
    NULL on error;  GetLastError() has error.

--*/
{
    DNS_STATUS      status = NO_ERROR;
    PDNS_RECORD     prrQuery = NULL;
    PHOSTENT_BLOB   pblob = NULL;


    DNSDBG( HOSTENT, (
        "HostentBlob_Query()\n"
        "\tname     = %S\n"
        "\ttype     = %d\n"
        "\tflags    = %08x\n"
        "\tmsg out  = %p\n",
        pwsName,
        wType,
        Flags,
        ppMsg ));


    //
    //  query
    //      - if fails, dump any message before return
    //

    status = DnsQuery_W(
                pwsName,
                wType,
                Flags,
                NULL,
                &prrQuery,
                ppMsg );

    //  if failed, dump any message

    if ( status != NO_ERROR )
    {
        if ( ppMsg && *ppMsg )
        {
            DnsApiFree( *ppMsg );
            *ppMsg = NULL;
        }
        if ( status == RPC_S_SERVER_UNAVAILABLE )
        {
            status = WSATRY_AGAIN;
        }
        goto Done;
    }

    if ( !prrQuery )
    {
        ASSERT( FALSE );
        status = DNS_ERROR_RCODE_NAME_ERROR;
        goto Done;
    }

    //
    //  build hostent
    //

    status = HostentBlob_CreateFromRecords(
                & pblob,
                prrQuery,
                TRUE,       // write name from first answer
                AddrFamily,
                wType
                );
    if ( status != NO_ERROR )
    {
        goto Done;
    }

    //
    //  for address query must get answer
    //
    //  DCR:  DnsQuery() should convert to no-records on empty CNAME chain?
    //  DCR:  should we go ahead and build hostent?
    //

    if ( pblob->AddrCount == 0  &&  Hostent_IsSupportedAddrType(wType) )
    {
        status = DNS_INFO_NO_RECORDS;
    }

Done:

    if ( prrQuery )
    {
        DnsRecordListFree(
            prrQuery,
            DnsFreeRecordListDeep );
    }

    if ( status != NO_ERROR  &&  pblob )
    {
        HostentBlob_Free( pblob );
        pblob = NULL;
    }

    DNSDBG( HOSTENT, (
        "Leave HostentBlob_Query()\n"
        "\tpblob    = %p\n"
        "\tstatus   = %d\n",
        pblob,
        status ));

    SetLastError( status );

    return( pblob );
}




//
//  Special hostents
//

PHOSTENT_BLOB
HostentBlob_Localhost(
    IN      INT             Family
    )
/*++

Routine Description:

    Create hostent from records

Arguments:

    AddrFamily -- address family

Return Value:

    Ptr to blob if successful.
    NULL on error;  GetLastError() has error.

--*/
{
    DNS_STATUS      status = NO_ERROR;
    PDNS_RECORD     prrFirstAddr = NULL;
    PDNS_RECORD     prr;
    DWORD           addrCount = 0;
    DWORD           addrSize;
    CHAR            addrBuf[ sizeof(IP6_ADDRESS    ) ];
    HOSTENT_INIT    request;
    PHOSTENT_BLOB   pblob = NULL;

    DNSDBG( HOSTENT, ( "HostentBlob_Localhost()\n" ));

    //
    //  create hostent blob
    //

    RtlZeroMemory( &request, sizeof(request) );

    request.AliasCount  = 1;
    request.AddrCount   = 1;
    request.AddrFamily  = Family;
    request.fUnicode    = TRUE;

    status = HostentBlob_Create(
                & pblob,
                & request );

    if ( status != NO_ERROR )
    {
        goto Done;
    }

    //
    //  write in loopback address
    //

    if ( Family == AF_INET )
    {
        * (PIP4_ADDRESS) addrBuf = DNS_NET_ORDER_LOOPBACK;
        addrSize = sizeof(IP4_ADDRESS);
    }
    else if ( Family == AF_INET6 )
    {
        IP6_SET_ADDR_LOOPBACK( (PIP6_ADDRESS)addrBuf );
        addrSize = sizeof(IN6_ADDR);
    }
    else
    {
        status = DNS_ERROR_INVALID_DATA;
        goto Done;
    }

    status = HostentBlob_WriteAddress(
                pblob,
                addrBuf,
                addrSize,
                Family );

    if ( status != NO_ERROR )
    {
        goto Done;
    }

    //
    //  write localhost
    //

    status = HostentBlob_WriteNameOrAlias(
                pblob,
                (PSTR) L"localhost",
                FALSE,          // name
                TRUE            // unicode
                );

    IF_DNSDBG( HOSTENT )
    {
        DnsDbg_HostentBlob(
            "HostentBlob after CreateFromRecords():",
            pblob );
    }

Done:

    if ( status != NO_ERROR  &&  pblob )
    {
        HostentBlob_Free( pblob );
        pblob = NULL;
    }

    SetLastError( status );

    DNSDBG( HOSTENT, (
        "Leave Hostent_Localhost() => status = %d\n",
        status ));

    return( pblob );
}



DNS_STATUS
HostentBlob_CreateFromIpArray(
    IN OUT  PHOSTENT_BLOB * ppBlob,
    IN      INT             AddrFamily,
    IN      INT             AddrSize,
    IN      INT             AddrCount,
    IN      PCHAR           pArray,
    IN      PSTR            pName,
    IN      BOOL            fUnicode
    )
/*++

Routine Description:

    Create hostent from records

Arguments:

    ppBlob -- ptr with or to recv hostent blob

    AddrFamily -- addr family use if PTR records and no addr

    pArray -- array of addresses

    pName -- name for hostent

    fUnicode --
        TRUE if name is and hostent will be in unicode
        FALSE for narrow name and hostent

Return Value:

    Ptr to blob if successful.
    NULL on error;  GetLastError() has error.

--*/
{
    DNS_STATUS      status = NO_ERROR;
    HOSTENT_INIT    request;
    PHOSTENT_BLOB   pblob = *ppBlob;

    DNSDBG( HOSTENT, (
        "HostentBlob_CreateFromIpArray()\n"
        "\tppBlob   = %p\n"
        "\tfamily   = %d\n"
        "\tsize     = %d\n"
        "\tcount    = %d\n"
        "\tpArray   = %p\n",
        ppBlob,
        AddrFamily,
        AddrSize,
        AddrCount,
        pArray ));


    //          
    //  create or reinit hostent blob
    //

    RtlZeroMemory( &request, sizeof(request) );
    
    request.AliasCount  = DNS_MAX_ALIAS_COUNT;
    request.AddrCount   = AddrCount;
    request.AddrFamily  = AddrFamily;
    request.fUnicode    = fUnicode;
    request.pName       = pName;

    status = HostentBlob_Create(
                & pblob,
                & request );
    
    if ( status != NO_ERROR )
    {
        goto Done;
    }

    //
    //  write in array
    //

    if ( AddrCount )
    {
        status = HostentBlob_WriteAddressArray(
                    pblob,
                    pArray,
                    AddrCount,
                    AddrSize,
                    AddrFamily
                    );
        if ( status != NO_ERROR )
        {
            goto Done;
        }
    }

    //
    //  write name?
    //

    if ( pName )
    {
        status = HostentBlob_WriteNameOrAlias(
                    pblob,
                    pName,
                    FALSE,          // name not alias
                    fUnicode
                    );
    }

    IF_DNSDBG( HOSTENT )
    {
        DnsDbg_HostentBlob(
            "Leaving HostentBlob_CreateFromIpArray():",
            pblob );
    }

Done:

    if ( status != NO_ERROR  &&  pblob )
    {
        HostentBlob_Free( pblob );
        pblob = NULL;
    }

    *ppBlob = pblob;

    DNSDBG( HOSTENT, (
        "Leave HostentBlob_CreateFromIpArray() => status = %d\n",
        status ));

    return( status );
}



DNS_STATUS
HostentBlob_CreateLocal(
    IN OUT  PHOSTENT_BLOB * ppBlob,
    IN      INT             AddrFamily,
    IN      BOOL            fLoopback,
    IN      BOOL            fZero,
    IN      BOOL            fHostnameOnly
    )
/*++

Routine Description:

    Create hostent from records

Arguments:

    ppBlob -- ptr with or to recv hostent blob

    AddrFamily -- addr family use if PTR records and no addr

Return Value:

    Ptr to blob if successful.
    NULL on error;  GetLastError() has error.

--*/
{
    DNS_STATUS      status = NO_ERROR;
    PHOSTENT_BLOB   pblob = NULL;
    WORD            wtype;
    INT             size;
    IP6_ADDRESS     ip;


    DNSDBG( HOSTENT, (
        "HostentBlob_CreateLocal()\n"
        "\tppBlob       = %p\n"
        "\tfamily       = %d\n"
        "\tfLoopback    = %d\n"
        "\tfZero        = %d\n"
        "\tfHostname    = %d\n",
        ppBlob,
        AddrFamily,
        fLoopback,
        fZero,
        fHostnameOnly
        ));

    //
    //  get family info
    //      - start with override IP = 0
    //      - if loopback switch to appropriate loopback
    //

    RtlZeroMemory(
        &ip,
        sizeof(ip) );

    if ( AddrFamily == AF_INET )
    {
        wtype   = DNS_TYPE_A;
        size    = sizeof(IP4_ADDRESS);

        if ( fLoopback )
        {
            * (PIP4_ADDRESS) &ip = DNS_NET_ORDER_LOOPBACK;
        }
    }
    else if ( AddrFamily == AF_INET6 )
    {
        wtype   = DNS_TYPE_AAAA;
        size    = sizeof(IP6_ADDRESS);

        if ( fLoopback )
        {
            IP6_SET_ADDR_LOOPBACK( &ip );
        }
    }
    else
    {
        status = ERROR_INVALID_PARAMETER;
        goto Done;
    }

    //
    //  query for local host info
    //

    pblob = HostentBlob_Query(
                NULL,           // NULL name gets local host data
                wtype,
                0,              // standard query
                NULL,           // no message
                AddrFamily );
    if ( !pblob )
    {
        DNS_ASSERT( FALSE );
        status = GetLastError();
        goto Done;
    }

    //
    //  overwrite with specific address
    //

    if ( fLoopback || fZero )
    {
        if ( ! Hostent_SetToSingleAddress(
                    pblob->pHostent,
                    (PCHAR) &ip,
                    size ) )
        {
            DNS_ASSERT( pblob->AddrCount == 0 );

            pblob->AddrCount = 0;

            status = HostentBlob_WriteAddress(
                        pblob,
                        & ip,
                        size,
                        AddrFamily );
            if ( status != NO_ERROR )
            {
                DNS_ASSERT( status!=NO_ERROR );
                goto Done;
            }
        }
    }

    //
    //  for gethostname()
    //      - chop name down to just hostname
    //      - kill off aliases
    //

    if ( fHostnameOnly )
    {
        PWSTR   pname = (PWSTR) pblob->pHostent->h_name;
        PWSTR   pdomain;

        DNS_ASSERT( pname );
        if ( pname )
        {
            pdomain = Dns_GetDomainName_W( pname );
            if ( pdomain )
            {
                DNS_ASSERT( pdomain > pname+1 );
                DNS_ASSERT( *(pdomain-1) == L'.' );

                *(pdomain-1) = 0;
            }
        }                     
        pblob->pHostent->h_aliases = NULL;
    }

    IF_DNSDBG( HOSTENT )
    {
        DnsDbg_HostentBlob(
            "Leaving HostentBlob_CreateLocal():",
            pblob );
    }

Done:

    if ( status != NO_ERROR  &&  pblob )
    {
        HostentBlob_Free( pblob );
        pblob = NULL;
    }

    *ppBlob = pblob;

    DNSDBG( HOSTENT, (
        "Leave HostentBlob_CreateLocal() => status = %d\n",
        status ));

    return( status );
}


//
//  End hostent.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\local.h ===
/*++

Copyright (c) 1996-2001  Microsoft Corporation

Module Name:

    local.h

Abstract:

    Domain Name System (DNS)

    DNS Library local include file

Author:

    Jim Gilroy      December 1996

Revision History:

--*/


#ifndef _DNSLIB_LOCAL_INCLUDED_
#define _DNSLIB_LOCAL_INCLUDED_


//#pragma warning(disable:4214)
//#pragma warning(disable:4514)
//#pragma warning(disable:4152)

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <basetyps.h>
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
//#include <tchar.h>
#include <align.h>          //  Alignment macros

#include <windns.h>         //  Public DNS definitions

#define  NO_DNSAPI_DLL
//#define  DNSLIB_SECURITY
#define  DNSAPI_INTERNAL
#include "..\..\resolver\idl\resrpc.h"
#include "dnslibp.h"        //  Private DNS definitions
#include "..\dnsapi\dnsapip.h"

#include "message.h"
//#include "..\dnsapi\registry.h"
//#include "rtlstuff.h"     //  Handy macros from NT RTL


//
//  Use winsock2
//

#define DNS_WINSOCK_VERSION    (0x0202)    //  Winsock 2.2


//
//  Debugging
//

#define DNS_LOG_EVENT(a,b,c,d)


//  use DNS_ASSERT for dnslib debugging

#undef  ASSERT
#define ASSERT(expr)    DNS_ASSERT(expr)

//
//  Single async socket for internal use
//
//  If want async socket i/o then can create single async socket, with
//  corresponding event and always use it.  Requires winsock 2.2
//

extern  SOCKET      DnsSocket;
extern  OVERLAPPED  DnsSocketOverlapped;
extern  HANDLE      hDnsSocketEvent;


//
//  App shutdown flag
//

extern  BOOLEAN     fApplicationShutdown;


//
//  Heap operations
//

#define ALLOCATE_HEAP(size)         Dns_AllocZero( size )
#define REALLOCATE_HEAP(p,size)     Dns_Realloc( (p), (size) )
#define FREE_HEAP(p)                Dns_Free( p )
#define ALLOCATE_HEAP_ZERO(size)    Dns_AllocZero( size )


//
//  RPC Exception filters
//

#define DNS_RPC_EXCEPTION_FILTER                                           \
              (((RpcExceptionCode() != STATUS_ACCESS_VIOLATION) &&         \
                (RpcExceptionCode() != STATUS_DATATYPE_MISALIGNMENT) &&    \
                (RpcExceptionCode() != STATUS_PRIVILEGED_INSTRUCTION) &&   \
                (RpcExceptionCode() != STATUS_ILLEGAL_INSTRUCTION))        \
                ? 0x1 : EXCEPTION_CONTINUE_SEARCH )

// Not defined  (RpcExceptionCode() != STATUS_POSSIBLE_DEADLOCK) &&        \
// Not defined  (RpcExceptionCode() != STATUS_INSTRUCTION_MISALIGNMENT) && \




//
//  Table lookup.
//
//  Many DNS Records have human readable mnemonics for given data values.
//  These are used for data file formats, and display in nslookup or debug
//  output or cmdline tools.
//
//  To simplify this process, have a single mapping functionality that
//  supports DWORD \ LPSTR mapping tables.   Tables for indivual types
//  may then be layered on top of this.
//
//  Support two table types.
//      VALUE_TABLE_ENTRY is simple value-string mapping
//      FLAG_TABLE_ENTRY is designed for bit field flag mappings where
//          several flag strings might be contained in flag;  this table
//          contains additional mask field to allow multi-bit fields
//          within the flag
//

typedef struct
{
    DWORD   dwValue;        //  flag value
    PCHAR   pszString;      //  string representation of value
}
DNS_VALUE_TABLE_ENTRY, *PDNS_VALUE_TABLE;

typedef struct
{
    DWORD   dwFlag;         //  flag value
    DWORD   dwMask;         //  flag value mask
    PCHAR   pszString;      //  string representation of value
}
DNS_FLAG_TABLE_ENTRY, *PDNS_FLAG_TABLE;


//  Error return on unmatched string

#define DNS_TABLE_LOOKUP_ERROR (-1)


DWORD
Dns_ValueForString(
    IN      PDNS_VALUE_TABLE    Table,
    IN      BOOL                fIgnoreCase,
    IN      PCHAR               pchName,
    IN      INT                 cchNameLength
    );

PCHAR
Dns_GetStringForValue(
    IN      PDNS_VALUE_TABLE    Table,
    IN      DWORD               dwValue
    );

VOID
DnsPrint_ValueTable(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN      PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      PDNS_VALUE_TABLE    Table
    );

DWORD
Dns_FlagForString(
    IN      PDNS_FLAG_TABLE     Table,
    IN      BOOL                fIgnoreCase,
    IN      PCHAR               pchName,
    IN      INT                 cchNameLength
    );

PCHAR
Dns_WriteStringsForFlag(
    IN      PDNS_FLAG_TABLE     Table,
    IN      DWORD               dwFlag,
    IN OUT  PCHAR               pchFlag
    );


//
//  Random -- back to dnslib.h when it goes private again
//
//  DCR:  return these to dnslib.h when private
//

PCHAR
Dns_ParsePacketRecord(
    IN      PCHAR           pchPacket,
    IN      PCHAR           pchMsgEnd,
    IN OUT  PDNS_PARSED_RR  pParsedRR
    );


#endif //   _DNSLIB_LOCAL_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\iparray.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    iparray.c

Abstract:

    Domain Name System (DNS) Library

    IP Address array routines.

Author:

    Jim Gilroy (jamesg)     October 1995

Revision History:

--*/


#include "local.h"

//
//  Max IP count when doing IP array to\from string conversions
//

#define MAX_PARSE_IP    (1000)




//
//  Routines to handle actual array of IP addresses.
//

PIP_ADDRESS
Dns_CreateIpAddressArrayCopy(
    IN      PIP_ADDRESS     aipAddress,
    IN      DWORD           cipAddress
    )
/*++

Routine Description:

    Create copy of IP address array.

Arguments:

    aipAddress -- array of IP addresses
    cipAddress -- count of IP addresses

Return Value:

    Ptr to IP address array copy, if successful
    NULL on failure.

--*/
{
    PIP_ADDRESS pipArray;

    //  validate

    if ( ! aipAddress || cipAddress == 0 )
    {
        return( NULL );
    }

    //  allocate memory and copy

    pipArray = (PIP_ADDRESS) ALLOCATE_HEAP( cipAddress*sizeof(IP_ADDRESS) );
    if ( ! pipArray )
    {
        return( NULL );
    }

    memcpy(
        pipArray,
        aipAddress,
        cipAddress*sizeof(IP_ADDRESS) );

    return( pipArray );
}



BOOL
Dns_ValidateIpAddressArray(
    IN      PIP_ADDRESS     aipAddress,
    IN      DWORD           cipAddress,
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Validate IP address array.

    Current checks:
        - existence
        - non-broadcast
        - non-lookback

Arguments:

    aipAddress -- array of IP addresses

    cipAddress -- count of IP addresses

    dwFlag -- validity tests to do;  currently unused

Return Value:

    TRUE if valid IP addresses.
    FALSE if invalid address found.

--*/
{
    DWORD   i;

    //
    //  protect against bad parameters
    //

    if ( cipAddress && ! aipAddress )
    {
        return( FALSE );
    }

    //
    //  check each IP address
    //

    for ( i=0; i < cipAddress; i++)
    {
        if( aipAddress[i] == INADDR_ANY
                ||
            aipAddress[i] == INADDR_BROADCAST
                ||
            aipAddress[i] == INADDR_LOOPBACK )
        {
            return( FALSE );
        }
    }
    return( TRUE );
}



//
//  IP_ARRAY routines
//

DWORD
Dns_SizeofIpArray(
    IN      PIP_ARRAY       pIpArray
    )
/*++

Routine Description:

    Get size in bytes of IP address array.

Arguments:

    pIpArray -- IP address array to find size of

Return Value:

    Size in bytes of IP array.

--*/
{
    if ( ! pIpArray )
    {
        return 0;
    }
    return  (pIpArray->AddrCount * sizeof(IP4_ADDRESS)) + sizeof(DWORD);
}



BOOL
Dns_ProbeIpArray(
    IN      PIP_ARRAY       pIpArray
    )
/*++

Routine Description:

    Touch all entries in IP array to insure valid memory.

Arguments:

    pIpArray -- ptr to IP address array

Return Value:

    TRUE if successful.
    FALSE otherwise

--*/
{
    DWORD   i;
    BOOL    result;

    if ( ! pIpArray )
    {
        return( TRUE );
    }
    for ( i=0; i<pIpArray->AddrCount; i++ )
    {
        result = ( pIpArray->AddrArray[i] == 0 );
    }
    return( TRUE );
}


#if 0

BOOL
Dns_ValidateSizeOfIpArray(
    IN      PIP_ARRAY       pIpArray,
    IN      DWORD           dwMemoryLength
    )
/*++

Routine Description:

    Check that size of IP array, corresponds to length of memory.

Arguments:

    pIpArray -- ptr to IP address array

    dwMemoryLength -- length of IP array memory

Return Value:

    TRUE if IP array size matches memory length
    FALSE otherwise

--*/
{
    return( Dns_SizeOfIpArray(pIpArray) == dwMemoryLength );
}
#endif



PIP_ARRAY
Dns_CreateIpArray(
    IN      DWORD       AddrCount
    )
/*++

Routine Description:

    Create uninitialized IP address array.

Arguments:

    AddrCount -- count of addresses array will hold

Return Value:

    Ptr to uninitialized IP address array, if successful
    NULL on failure.

--*/
{
    PIP_ARRAY   pIpArray;

    DNSDBG( IPARRAY, ( "Dns_CreateIpArray() of count %d\n", AddrCount ));

    pIpArray = (PIP_ARRAY) ALLOCATE_HEAP_ZERO(
                        (AddrCount * sizeof(IP_ADDRESS)) + sizeof(DWORD) );
    if ( ! pIpArray )
    {
        return( NULL );
    }

    //
    //  initialize IP count
    //

    pIpArray->AddrCount = AddrCount;

    DNSDBG( IPARRAY, (
        "Dns_CreateIpArray() new array (count %d) at %p\n",
        AddrCount,
        pIpArray ));

    return( pIpArray );
}


PIP_ARRAY
Dns_BuildIpArray(
    IN      DWORD           AddrCount,
    IN      PIP_ADDRESS     pipAddrs
    )
/*++

Routine Description:

    Create IP address array structure from existing array of IP addresses.

Arguments:

    AddrCount -- count of addresses in array
    pipAddrs -- IP address array

Return Value:

    Ptr to IP address array.
    NULL on failure.

--*/
{
    PIP_ARRAY   pIpArray;

    if ( ! pipAddrs || ! AddrCount )
    {
        return( NULL );
    }

    //  create IP array of desired size
    //  then copy incoming array of addresses

    pIpArray = Dns_CreateIpArray( AddrCount );
    if ( ! pIpArray )
    {
        return( NULL );
    }
    pIpArray->AddrCount = AddrCount;

    memcpy(
        pIpArray->AddrArray,
        pipAddrs,
        AddrCount * sizeof(IP_ADDRESS) );

    return( pIpArray );
}



PIP_ARRAY
Dns_CopyAndExpandIpArray(
    IN      PIP_ARRAY       pIpArray,
    IN      DWORD           ExpandCount,
    IN      BOOL            fDeleteExisting
    )
/*++

Routine Description:

    Create expanded copy of IP address array.

Arguments:

    pIpArray -- IP address array to copy

    ExpandCount -- number of IP to expand array size by

    fDeleteExisting -- TRUE to delete existing array;
        this is useful when function is used to grow existing
        IP array in place;  note that locking must be done
        by caller

        note, that if new array creation FAILS -- then old array
        is NOT deleted

Return Value:

    Ptr to IP array copy, if successful
    NULL on failure.

--*/
{
    PIP_ARRAY   pnewArray;
    DWORD       newCount;

    //
    //  no existing array -- just create desired size
    //

    if ( ! pIpArray )
    {
        if ( ExpandCount )
        {
            return  Dns_CreateIpArray( ExpandCount );
        }
        return( NULL );
    }

    //
    //  create IP array of desired size
    //  then copy any existing addresses
    //

    pnewArray = Dns_CreateIpArray( pIpArray->AddrCount + ExpandCount );
    if ( ! pnewArray )
    {
        return( NULL );
    }

    RtlCopyMemory(
        (PBYTE) pnewArray->AddrArray,
        (PBYTE) pIpArray->AddrArray,
        pIpArray->AddrCount * sizeof(IP4_ADDRESS) );

    //
    //  delete existing -- for "grow mode"
    //

    if ( fDeleteExisting )
    {
        FREE_HEAP( pIpArray );
    }

    return( pnewArray );
}



PIP_ARRAY
Dns_CreateIpArrayCopy(
    IN      PIP_ARRAY       pIpArray
    )
/*++

Routine Description:

    Create copy of IP address array.

Arguments:

    pIpArray -- IP address array to copy

Return Value:

    Ptr to IP address array copy, if successful
    NULL on failure.

--*/
{
#if 0
    PIP_ARRAY   pIpArrayCopy;

    if ( ! pIpArray )
    {
        return( NULL );
    }

    //  create IP array of desired size
    //  then copy entire structure

    pIpArrayCopy = Dns_CreateIpArray( pIpArray->AddrCount );
    if ( ! pIpArrayCopy )
    {
        return( NULL );
    }

    memcpy(
        pIpArrayCopy,
        pIpArray,
        Dns_SizeofIpArray(pIpArray) );

    return( pIpArrayCopy );
#endif

    //
    //  call essentially "CopyEx" function
    //
    //  note, not macroing this because this may well become
    //      a DLL entry point
    //

    return  Dns_CopyAndExpandIpArray(
                pIpArray,
                0,          // no expansion
                0           // don't delete existing array
                );
}



BOOL
Dns_IsAddressInIpArray(
    IN      PIP_ARRAY       pIpArray,
    IN      IP_ADDRESS      ipAddress
    )
/*++

Routine Description:

    Check if IP array contains desired address.

Arguments:

    pIpArray -- IP address array to copy

Return Value:

    TRUE if address in array.
    Ptr to IP address array copy, if successful
    NULL on failure.

--*/
{
    DWORD i;

    if ( ! pIpArray )
    {
        return( FALSE );
    }
    for (i=0; i<pIpArray->AddrCount; i++)
    {
        if ( ipAddress == pIpArray->AddrArray[i] )
        {
            return( TRUE );
        }
    }
    return( FALSE );
}



BOOL
Dns_AddIpToIpArray(
    IN OUT  PIP_ARRAY       pIpArray,
    IN      IP_ADDRESS      NewIp
    )
/*++

Routine Description:

    Add IP address to IP array.

    Allowable "slot" in array, is any zero IP address.

Arguments:

    pIpArray -- IP address array to add to

    NewIp -- IP address to add to array

Return Value:

    TRUE if successful.
    FALSE if array full.

--*/
{
    DWORD i;

    //
    //  screen for existence
    //
    //  this check makes it easy to write code that does
    //  Add\Full?=>Expand loop without having to write
    //  startup existence\create code
    //  

    if ( !pIpArray )
    {
        return( FALSE );
    }

    for (i=0; i<pIpArray->AddrCount; i++)
    {
        if ( pIpArray->AddrArray[i] == 0 )
        {
            pIpArray->AddrArray[i] = NewIp;
            return( TRUE );
        }
        else if ( pIpArray->AddrArray[i] == NewIp )
        {
            return( TRUE );
        }
    }
    return( FALSE );
}



VOID
Dns_ClearIpArray(
    IN OUT  PIP_ARRAY       pIpArray
    )
/*++

Routine Description:

    Clear memory in IP array.

Arguments:

    pIpArray -- IP address array to clear

Return Value:

    None.

--*/
{
    //  clear just the address list, leaving count intact

    RtlZeroMemory(
        pIpArray->AddrArray,
        pIpArray->AddrCount * sizeof(IP_ADDRESS) );
}



VOID
Dns_ReverseOrderOfIpArray(
    IN OUT  PIP_ARRAY       pIpArray
    )
/*++

Routine Description:

    Reorder the list of IPs in reverse.

Arguments:

    pIpArray -- IP address array to reorder

Return Value:

    None.

--*/
{
    IP_ADDRESS  tempIp;
    DWORD       i;
    DWORD       j;

    //
    //  swap IPs working from ends to the middle
    //

    if ( pIpArray &&
         pIpArray->AddrCount )
    {
        for ( i = 0, j = pIpArray->AddrCount - 1;
              i < j;
              i++, j-- )
        {
            tempIp = pIpArray->AddrArray[i];
            pIpArray->AddrArray[i] = pIpArray->AddrArray[j];
            pIpArray->AddrArray[j] = tempIp;
        }
    }
}



BOOL
Dns_CheckAndMakeIpArraySubset(
    IN OUT  PIP_ARRAY       pIpArraySub,
    IN      PIP_ARRAY       pIpArraySuper
    )
/*++

Routine Description:

    Clear entries from IP array until it is subset of another IP array.

Arguments:

    pIpArraySub -- IP array to make into subset

    pIpArraySuper -- IP array superset

Return Value:

    TRUE if pIpArraySub is already subset.
    FALSE if needed to nix entries to make IP array a subset.

--*/
{
    DWORD   i;
    DWORD   newIpCount;

    //
    //  check each entry in subset IP array,
    //  if not in superset IP array, eliminate it
    //

    newIpCount = pIpArraySub->AddrCount;

    for (i=0; i < newIpCount; i++)
    {
        if ( ! Dns_IsAddressInIpArray(
                    pIpArraySuper,
                    pIpArraySub->AddrArray[i] ) )
        {
            //  remove this IP entry and replace with
            //  last IP entry in array

            newIpCount--;
            if ( i >= newIpCount )
            {
                break;
            }
            pIpArraySub->AddrArray[i] = pIpArraySub->AddrArray[ newIpCount ];
        }
    }

    //  if eliminated entries, reset array count

    if ( newIpCount < pIpArraySub->AddrCount )
    {
        pIpArraySub->AddrCount = newIpCount;
        return( FALSE );
    }
    return( TRUE );
}



INT
WINAPI
Dns_ClearIpFromIpArray(
    IN OUT  PIP_ARRAY       pIpArray,
    IN      IP_ADDRESS      IpDelete
    )
/*++

Routine Description:

    Clear IP address from IP array.

    Note difference between this function and Dns_DeleteIpFromIpArray()
    below.

    This function leaves list size unchanged allowing new adds.  

Arguments:

    pIpArray -- IP address array to add to

    IpDelete -- IP address to delete from array

Return Value:

    Count of instances of IpDelete in array.

--*/
{
    DWORD   found = 0;
    INT     i;
    INT     currentLast;

    i = currentLast = pIpArray->AddrCount-1;

    while ( i >= 0 )
    {
        if ( pIpArray->AddrArray[i] == IpDelete )
        {
            pIpArray->AddrArray[i] = pIpArray->AddrArray[ currentLast ];
            pIpArray->AddrArray[ currentLast ] = 0;
            currentLast--;
            found++;
        }
        i--;
    }

    return( found );
}



INT
WINAPI
Dns_DeleteIpFromIpArray(
    IN OUT  PIP_ARRAY       pIpArray,
    IN      IP_ADDRESS      IpDelete
    )
/*++

Routine Description:

    Delete IP address from IP array.

    Note difference between this function and Dns_ClearIpFromIpArray()
    above.

    This delete leaves a SMALLER array.  The IP slot is NON_RECOVERABLE.

Arguments:

    pIpArray -- IP address array to add to

    IpDelete -- IP address to delete from array

Return Value:

    Count of instances of IpDelete in array.

--*/
{
    DWORD   found;

    found = Dns_ClearIpFromIpArray( pIpArray, IpDelete );

    pIpArray->AddrCount -= found;

    return( found );
}



INT
WINAPI
Dns_CleanIpArray(
    IN OUT  PIP_ARRAY       pIpArray,
    IN      DWORD           Flag
    )
/*++

Routine Description:

    Clean IP array.

    Remove bogus stuff from IP Array:
        -- Zeros
        -- Loopback
        -- AutoNet

Arguments:

    pIpArray -- IP address array to add to

    Flag -- which cleanups to make

Return Value:

    Count of instances cleaned from array.

--*/
{
    DWORD       found = 0;
    INT         i;
    INT         currentLast;
    IP_ADDRESS  ip;

    i = currentLast = pIpArray->AddrCount-1;

    while ( i >= 0 )
    {
        ip = pIpArray->AddrArray[i];

        if (
            ( (Flag & DNS_IPARRAY_CLEAN_LOOPBACK) && ip == DNS_NET_ORDER_LOOPBACK )
                ||
            ( (Flag & DNS_IPARRAY_CLEAN_ZERO) && ip == 0 )
                ||
            ( (Flag & DNS_IPARRAY_CLEAN_AUTONET) && DNS_IS_AUTONET_IP(ip) ) )
        {
            //  remove IP from array

            pIpArray->AddrArray[i] = pIpArray->AddrArray[ currentLast ];
            currentLast--;
            found++;
        }
        i--;
    }

    pIpArray->AddrCount -= found;
    return( found );
}



DNS_STATUS
WINAPI
Dns_DiffOfIpArrays(
    IN       PIP_ARRAY      pIpArray1,
    IN       PIP_ARRAY      pIpArray2,
    OUT      PIP_ARRAY *    ppOnlyIn1,
    OUT      PIP_ARRAY *    ppOnlyIn2,
    OUT      PIP_ARRAY *    ppIntersect
    )
/*++

Routine Description:

    Computes differences and intersection of two IP arrays.

    Out arrays are allocated with Dns_Alloc(), caller must free with Dns_Free()

Arguments:

    pIpArray1 -- IP array

    pIpArray2 -- IP array

    ppOnlyIn1 -- addr to recv IP array of addresses only in array 1 (not in array2)

    ppOnlyIn2 -- addr to recv IP array of addresses only in array 2 (not in array1)

    ppIntersect -- addr to recv IP array of intersection addresses

Return Value:

    ERROR_SUCCESS if successful.
    DNS_ERROR_NO_MEMORY if unable to allocate memory for IP arrays.

--*/
{
    DWORD       j;
    DWORD       ip;
    PIP_ARRAY   intersectArray = NULL;
    PIP_ARRAY   only1Array = NULL;
    PIP_ARRAY   only2Array = NULL;

    //
    //  create result IP arrays
    //

    if ( ppIntersect )
    {
        intersectArray = Dns_CreateIpArrayCopy( pIpArray1 );
        if ( !intersectArray )
        {
            goto NoMem;
        }
        *ppIntersect = intersectArray;
    }
    if ( ppOnlyIn1 )
    {
        only1Array = Dns_CreateIpArrayCopy( pIpArray1 );
        if ( !only1Array )
        {
            goto NoMem;
        }
        *ppOnlyIn1 = only1Array;
    }
    if ( ppOnlyIn2 )
    {
        only2Array = Dns_CreateIpArrayCopy( pIpArray2 );
        if ( !only2Array )
        {
            goto NoMem;
        }
        *ppOnlyIn2 = only2Array;
    }

    //
    //  clean the arrays
    //

    for ( j=0;   j< pIpArray1->AddrCount;   j++ )
    {
        ip = pIpArray1->AddrArray[j];

        //  if IP in both arrays, delete from "only" arrays

        if ( Dns_IsAddressInIpArray( pIpArray2, ip ) )
        {
            if ( only1Array )
            {
                Dns_DeleteIpFromIpArray( only1Array, ip );
            }
            if ( only2Array )
            {
                Dns_DeleteIpFromIpArray( only2Array, ip );
            }
        }

        //  if IP not in both arrays, delete from intersection
        //      note intersection started as IpArray1

        else if ( intersectArray )
        {
            Dns_DeleteIpFromIpArray( intersectArray, ip );
        }
    }

    return( ERROR_SUCCESS );

NoMem:

    if ( intersectArray )
    {
        FREE_HEAP( intersectArray );
    }
    if ( only1Array )
    {
        FREE_HEAP( only1Array );
    }
    if ( only2Array )
    {
        FREE_HEAP( only2Array );
    }
    if ( ppIntersect )
    {
        *ppIntersect = NULL;
    }
    if ( ppOnlyIn1 )
    {
        *ppOnlyIn1 = NULL;
    }
    if ( ppOnlyIn2 )
    {
        *ppOnlyIn2 = NULL;
    }
    return( DNS_ERROR_NO_MEMORY );
}



BOOL
WINAPI
Dns_IsIntersectionOfIpArrays(
    IN       PIP_ARRAY      pIpArray1,
    IN       PIP_ARRAY      pIpArray2
    )
/*++

Routine Description:

    Determine if there's intersection of two IP arrays.

Arguments:

    pIpArray1 -- IP array

    pIpArray2 -- IP array

Return Value:

    TRUE if intersection.
    FALSE if no intersection or empty or NULL array.

--*/
{
    DWORD   count;
    DWORD   j;

    //
    //  protect against NULL
    //  this is called from the server on potentially changing (reconfigurable)
    //      IP array pointers;  this provides cheaper protection than
    //      worrying about locking
    //

    if ( !pIpArray1 || !pIpArray2 )
    {
        return( FALSE );
    }

    //
    //  same array
    //

    if ( pIpArray1 == pIpArray2 )
    {
        return( TRUE );
    }

    //
    //  test that at least one IP in array 1 is in array 2
    //

    count = pIpArray1->AddrCount;

    for ( j=0;  j < count;  j++ )
    {
        if ( Dns_IsAddressInIpArray( pIpArray2, pIpArray1->AddrArray[j] ) )
        {
            return( TRUE );
        }
    }

    //  no intersection

    return( FALSE );
}



BOOL
Dns_AreIpArraysEqual(
    IN       PIP_ARRAY      pIpArray1,
    IN       PIP_ARRAY      pIpArray2
    )
/*++

Routine Description:

    Determines if IP arrays are equal.

Arguments:

    pIpArray1 -- IP array

    pIpArray2 -- IP array

Return Value:

    TRUE if arrays equal.
    FALSE otherwise.

--*/
{
    DWORD   j;
    DWORD   count;

    //
    //  same array?  or missing array?
    //

    if ( pIpArray1 == pIpArray2 )
    {
        return( TRUE );
    }
    if ( !pIpArray1 || !pIpArray2 )
    {
        return( FALSE );
    }

    //
    //  arrays the same length?
    //

    count = pIpArray1->AddrCount;

    if ( count != pIpArray2->AddrCount )
    {
        return( FALSE );
    }

    //
    //  test that each IP in array 1 is in array 2
    //
    //  test that each IP in array 2 is in array 1
    //      - do second test in case of duplicates
    //      that fool equal-lengths check
    //

    for ( j=0;  j < count;  j++ )
    {
        if ( !Dns_IsAddressInIpArray( pIpArray2, pIpArray1->AddrArray[j] ) )
        {
            return( FALSE );
        }
    }
    for ( j=0;  j < count;  j++ )
    {
        if ( !Dns_IsAddressInIpArray( pIpArray1, pIpArray2->AddrArray[j] ) )
        {
            return( FALSE );
        }
    }

    //  equal arrays

    return( TRUE );
}



DNS_STATUS
WINAPI
Dns_UnionOfIpArrays(
    IN      PIP_ARRAY       pIpArray1,
    IN      PIP_ARRAY       pIpArray2,
    OUT     PIP_ARRAY *     ppUnion
    )
/*++

Routine Description:

    Computes the union of two IP arrays.

    Out array is allocated with Dns_Alloc(), caller must free with Dns_Free()

Arguments:

    pIpArray1 -- IP array

    pIpArray2 -- IP array

    ppUnion -- addr to recv IP array of addresses in array 1 and in array2

Return Value:

    ERROR_SUCCESS if successful.
    DNS_ERROR_NO_MEMORY if unable to allocate memory for IP array.

--*/
{
    DWORD       j;
    DWORD       ip;
    DWORD       Count = 0;
    PIP_ARRAY   punionArray = NULL;

    //
    //  create result IP arrays
    //

    if ( !ppUnion )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    punionArray = Dns_CreateIpArray( pIpArray1->AddrCount +
                                     pIpArray2->AddrCount );
    if ( !punionArray )
    {
        goto NoMem;
    }
    *ppUnion = punionArray;


    //
    //  create union from arrays
    //

    for ( j = 0; j < pIpArray1->AddrCount; j++ )
    {
        ip = pIpArray1->AddrArray[j];

        if ( !Dns_IsAddressInIpArray( punionArray, ip ) )
        {
            Dns_AddIpToIpArray( punionArray, ip );
            Count++;
        }
    }

    for ( j = 0; j < pIpArray2->AddrCount; j++ )
    {
        ip = pIpArray2->AddrArray[j];

        if ( !Dns_IsAddressInIpArray( punionArray, ip ) )
        {
            Dns_AddIpToIpArray( punionArray, ip );
            Count++;
        }
    }

    punionArray->AddrCount = Count;

    return( ERROR_SUCCESS );

NoMem:

    if ( punionArray )
    {
        FREE_HEAP( punionArray );
        *ppUnion = NULL;
    }
    return( DNS_ERROR_NO_MEMORY );
}



DNS_STATUS
Dns_CreateIpArrayFromMultiIpString(
    IN      LPSTR           pszMultiIpString,
    OUT     PIP_ARRAY *     ppIpArray
    )
/*++

Routine Description:

    Create IP array out of multi-IP string.

Arguments:

    pszMultiIpString -- string containing IP addresses;
        separator is whitespace or comma

    ppIpArray -- addr to receive ptr to allocated IP array

Return Value:

    ERROR_SUCCESS if one or more valid IP addresses in string.
    DNS_ERROR_INVALID_IP_ADDRESS if parsing error.
    DNS_ERROR_NO_MEMORY if can not create IP array.

--*/
{
    PCHAR       pch;
    CHAR        ch;
    PCHAR       pbuf;
    PCHAR       pbufStop;
    DNS_STATUS  status = ERROR_SUCCESS;
    DWORD       countIp = 0;
    IP_ADDRESS  ip;
    CHAR        buffer[ IP_ADDRESS_STRING_LENGTH+2 ];
    IP_ADDRESS  arrayIp[ MAX_PARSE_IP ];

    //  stop byte for IP string buffer
    //      - note we put extra byte pad in buffer above
    //      this allows us to write ON stop byte and use
    //      that to detect invalid-long IP string
    //

    pbufStop = buffer + IP_ADDRESS_STRING_LENGTH;

    //
    //  DCR:  use IP array builder for local IP address
    //      then need Dns_CreateIpArrayFromMultiIpString()
    //      to use count\alloc method when buffer overflows
    //      to do this we'd need to do parsing in loop
    //      and skip conversion when count overflow, but set
    //      flag to go back in again with allocated buffer
    //
    //  safer would be to tokenize-count, alloc, build from tokens
    //

    //
    //  loop until reach end of string
    //

    pch = pszMultiIpString;

    while ( countIp < MAX_PARSE_IP )
    {
        //  skip whitespace

        while ( ch = *pch++ )
        {
            if ( ch == ' ' || ch == '\t' || ch == ',' )
            {
                continue;
            }
            break;
        }
        if ( !ch )
        {
            break;
        }

        //
        //  copy next IP string into buffer
        //      - stop copy at whitespace or NULL
        //      - on invalid-long IP string, stop copying
        //      but continue parsing, so can still get any following IPs
        //      note, we actually write ON the buffer stop byte as our
        //      "invalid-long" detection mechanism
        //

        pbuf = buffer;
        do
        {
            if ( pbuf <= pbufStop )
            {
                *pbuf++ = ch;
            }
            ch = *pch++;
        }
        while ( ch && ch != ' ' && ch != ',' && ch != '\t' );

        //
        //  convert buffer into IP address
        //      - insure was valid length string
        //      - null terminate
        //

        if ( pbuf <= pbufStop )
        {
            *pbuf = 0;

            ip = inet_addr( buffer );
            if ( ip == INADDR_BROADCAST )
            {
                status = DNS_ERROR_INVALID_IP_ADDRESS;
            }
            else
            {
                arrayIp[ countIp++ ] = ip;
            }
        }
        else
        {
            status = DNS_ERROR_INVALID_IP_ADDRESS;
        }

        //  quit if at end of string

        if ( !ch )
        {
            break;
        }
    }

    //
    //  if successfully parsed IP addresses, create IP array
    //  note, we'll return what we have even if some addresses are
    //  bogus, status code will indicate the parsing problem
    //
    //  note, if explicitly passed empty string, then create
    //  empty IP array, don't error
    //

    if ( countIp == 0  &&  *pszMultiIpString != 0 )
    {
        *ppIpArray = NULL;
        status = DNS_ERROR_INVALID_IP_ADDRESS;
    }
    else
    {
        *ppIpArray = Dns_BuildIpArray(
                        countIp,
                        arrayIp );
        if ( !*ppIpArray )
        {
            status = DNS_ERROR_NO_MEMORY;
        }
        IF_DNSDBG( IPARRAY )
        {
            DnsDbg_IpArray(
                "New Parsed IP array",
                NULL,       // no name
                *ppIpArray );
        }
    }

    return( status );
}



LPSTR
Dns_CreateMultiIpStringFromIpArray(
    IN      PIP_ARRAY       pIpArray,
    IN      CHAR            chSeparator     OPTIONAL
    )
/*++

Routine Description:

    Create IP array out of multi-IP string.

Arguments:

    pIpArray    -- IP array to generate string for

    chSeparator -- separating character between strings;
        OPTIONAL, if not given, blank is used

Return Value:

    Ptr to string representation of IP array.
    Caller must free.

--*/
{
    PCHAR       pch;
    DWORD       i;
    PCHAR       pszip;
    DWORD       length;
    PCHAR       pchstop;
    CHAR        buffer[ IP_ADDRESS_STRING_LENGTH*MAX_PARSE_IP + 1 ];

    //
    //  if no IP array, return NULL string
    //  this allows this function to simply indicate when registry
    //      delete rather than write is indicated
    //

    if ( !pIpArray )
    {
        return( NULL );
    }

    //  if no separator, use blank

    if ( !chSeparator )
    {
        chSeparator = ' ';
    }

    //
    //  loop through all IPs in array, appending each
    //

    pch = buffer;
    pchstop = pch + ( IP_ADDRESS_STRING_LENGTH * (MAX_PARSE_IP-1) );
    *pch = 0;

    for ( i=0;  i < pIpArray->AddrCount;  i++ )
    {
        if ( pch >= pchstop )
        {
            break;
        }
        pszip = IP_STRING( pIpArray->AddrArray[i] );
        if ( pszip )
        {
            length = strlen( pszip );

            memcpy(
                pch,
                pszip,
                length );

            pch += length;
            *pch++ = chSeparator;
        }
    }

    //  if wrote any strings, then write terminator over last separator

    if ( pch != buffer )
    {
        *--pch = 0;
    }

    //  create copy of buffer as return

    length = (DWORD)(pch - buffer) + 1;
    pch = ALLOCATE_HEAP( length );
    if ( !pch )
    {
        return( NULL );
    }

    memcpy(
        pch,
        buffer,
        length );

    DNSDBG( IPARRAY, (
        "String representation %s of IP array at %p\n",
        pch,
        pIpArray ));

    return( pch );
}

//
//  End iparray.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\memory.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    memory.c

Abstract:

    Domain Name System (DNS) Library

    Memory allocation routines for DNS library.

Author:

    Jim Gilroy (jamesg)    January, 1997

Revision History:

--*/


#include "local.h"


//
//  Memory allocation
//
//  Some DNS library functions -- including the IP array and string utils
//  -- allocate memory.  This memory allocation defaults to routines that
//  use LocalAlloc, LocalReAlloc, LocalFree.
//
//  Dns_Api.dll users can reset the memory allocation through
//  Dns_ApiHeapReset(), which saves pointers to remote allocation functions
//  which will override default allocators.
//

//
//  Allow overide of default memory allocation
//

DNSLIB_ALLOC_FUNCTION      pDnsAllocFunction = NULL;
DNSLIB_REALLOC_FUNCTION    pDnsReallocFunction = NULL;
DNSLIB_FREE_FUNCTION       pDnsFreeFunction = NULL;



VOID
Dns_LibHeapReset(
    IN  DNSLIB_ALLOC_FUNCTION      pAlloc,
    IN  DNSLIB_REALLOC_FUNCTION    pRealloc,
    IN  DNSLIB_FREE_FUNCTION       pFree
    )
/*++

Routine Description:

    Resets heap routines used by dnsapi.dll routines.

Arguments:

    pAlloc      -- ptr to desired alloc function
    pRealloc    -- ptr to desired realloc function
    pFree       -- ptr to desired free function

Return Value:

    None.

--*/
{
    pDnsAllocFunction = pAlloc;
    pDnsReallocFunction = pRealloc;
    pDnsFreeFunction = pFree;
}



//
//  Exported public memory routines.
//
//  These use whatever the current memory allocation routines are, and
//  hence will always handle memory in the same fashion as dnsapi.dll
//  internal routines.
//

PVOID
Dns_Alloc(
    IN  INT iSize
    )
/*++

Routine Description:

    Allocates memory.

Arguments:

    iSize   - number of bytes to allocate

Return Value:

    Pointer to memory allocated.
    NULL if allocation fails.

--*/
{
    if ( pDnsAllocFunction )
    {
        return (*pDnsAllocFunction)( iSize );
    }

    //  default

    return LocalAlloc( LPTR, iSize );
}



PVOID
Dns_Realloc(
    IN OUT  PVOID   pMem,
    IN      INT     iSize
    )
/*++

Routine Description:

    Reallocates memory

Arguments:

    pMem    - ptr to existing memory to reallocated
    iSize   - number of bytes to reallocate

Return Value:

    Pointer to memory allocated.
    NULL if allocation fails.

--*/
{
    if ( pDnsReallocFunction )
    {
        return (*pDnsReallocFunction)( pMem, iSize );
    }

    //  default

    return LocalReAlloc( pMem, iSize, 0 );
}



VOID
Dns_Free(
    IN OUT  PVOID   pMem
    )
/*++

Routine Description:

    Free memory

Arguments:

    pMem    - ptr to existing memory to reallocated

Return Value:

    None

--*/
{

    if ( !pMem )
    {
        return;
    }
    if ( pDnsFreeFunction )
    {
        (*pDnsFreeFunction)( pMem );
        return;
    }

    //  default

    LocalFree( pMem );
}



PVOID
Dns_AllocZero(
    IN      INT             iSize
    )
/*++

Routine Description:

    Allocates and zeros memory.

Arguments:

    iSize   - number of bytes to allocate

Return Value:

    Pointer to memory allocated.
    NULL if allocation fails.

--*/
{
    if ( pDnsAllocFunction )
    {
        PCHAR   ptr;

        ptr = (*pDnsAllocFunction)( iSize );
        if ( !ptr )
        {
            return( NULL );
        }
        RtlZeroMemory( ptr, iSize );
        return( ptr );
    }

    //  default

    return LocalAlloc( LPTR, iSize );
}




//
//  Helpful util
//

PVOID
Dns_AllocMemCopy(
    IN      PVOID           pMem,
    IN      INT             Size
    )
/*++

Routine Description:

    Allocates and copies memory

Arguments:

    pMem   - memory to copy

    Size   - number of bytes to allocate

Return Value:

    Pointer to memory allocated.
    NULL if allocation fails.

--*/
{
    PBYTE   ptr;

    ptr = Dns_Alloc( Size );

    if ( ptr )
    {
        if ( pMem )
        {
            RtlCopyMemory(
                ptr,
                pMem,
                Size );
        }
        else
        {
            RtlZeroMemory( ptr, Size );
        }
    }
    return  ptr;
}

//
//  End of memory.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\message.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    message.h

Abstract:

    Domain Name System (DNS) Library

    DNS message and associated info buffer

Author:

    Jim Gilroy (jamesg)     January 1997

Revision History:

--*/


#ifndef _DNS_MESSAGE_INCLUDED_
#define _DNS_MESSAGE_INCLUDED_



#ifndef DNSSRV

//
//  Define size of allocations, beyond message buffer itself
//
//      - size of message info struct, outside of header
//
//  Note:  the lookname buffer is placed AFTER the message buffer.
//
//  This allows us to avoid STRICT overwrite checking for small
//  items writing RR to buffer:
//      - compressed name
//      - RR (or Question) struct
//      - IP address (MX preference, SOA fixed fields)
//
//  After RR write, we check whether we are over the end of the buffer
//  and if so, we send and do not use lookup name info again anyway.
//  Cool.
//

#define DNS_MESSAGE_INCLUDED_HEADER_LENGTH  \
            ( sizeof(DNS_MSG_BUF) \
            - sizeof(DNS_HEADER) \
            - 1 )


//
//  UDP allocation
//

#define DNS_UDP_ALLOC_LENGTH    \
            ( DNS_MESSAGE_INCLUDED_HEADER_LENGTH + DNS_UDP_MAX_PACKET_LENGTH )

//
//  DNS TCP allocation.
//
//  Key point, is this is used almost entirely for zone transfer.
//
//      - 16K is maximum compression offset (14bits) so a
//        good default size for sending AXFR packets
//
//      - realloc to get 64K message maximum.
//
//  Note:  Critical that packet lengths are DWORD aligned, as
//      lookname buffer follows message at packet length.
//

#define DNS_TCP_DEFAULT_PACKET_LENGTH   (0x4000)
#define DNS_TCP_DEFAULT_ALLOC_LENGTH    (0x4000 + \
                                        DNS_MESSAGE_INCLUDED_HEADER_LENGTH)

#define DNS_TCP_REALLOC_PACKET_LENGTH   (0xfffc)
#define DNS_TCP_REALLOC_LENGTH          (0xfffc + \
                                        DNS_MESSAGE_INCLUDED_HEADER_LENGTH)


//
//  Set fields for new query
//
//  Always clear suballocation ptr fields that are deallocated
//  by query free:
//      - pRecurse
//
//  Always default to deleting on send -- fDelete set TRUE.
//
//  For debugging purposes dwQueuingTime serves as flag to
//  indicate ON or OFF a packet queue.
//
//  Lookup name buffer follows message buffer.  See note above
//  for explanation of this.
//

#define SET_MESSAGE_FOR_UDP_RECV( pMsg ) \
    {                                           \
        (pMsg)->fTcp                = FALSE;    \
        (pMsg)->fSwapped            = FALSE;    \
        (pMsg)->Timeout             = 0;        \
    }

#define SET_MESSAGE_FOR_TCP_RECV( pMsg ) \
    {                                           \
        (pMsg)->fTcp                = TRUE;     \
        (pMsg)->fSwapped            = FALSE;    \
        (pMsg)->Timeout             = 0;        \
        (pMsg)->fMessageComplete    = FALSE;    \
        (pMsg)->MessageLength       = 0;        \
        (pMsg)->pchRecv             = NULL;     \
    }


//
//  RR count writing
//

#define CURRENT_RR_COUNT_FIELD( pMsg )    \
            (*(pMsg)->pCurrentCountField)

#define SET_CURRENT_RR_COUNT_SECTION( pMsg, section )    \
            (pMsg)->pCurrentCountField = \
                        &(pMsg)->MessageHead.QuestionCount + (section);


#define SET_TO_WRITE_QUESTION_RECORDS(pMsg) \
            (pMsg)->pCurrentCountField = &(pMsg)->MessageHead.QuestionCount;

#define SET_TO_WRITE_ANSWER_RECORDS(pMsg) \
            (pMsg)->pCurrentCountField = &(pMsg)->MessageHead.AnswerCount;

#define SET_TO_WRITE_NAME_SERVER_RECORDS(pMsg) \
            (pMsg)->pCurrentCountField = &(pMsg)->MessageHead.NameServerCount;
#define SET_TO_WRITE_AUTHORITY_RECORDS(pMsg) \
            SET_TO_WRITE_NAME_SERVER_RECORDS(pMsg)

#define SET_TO_WRITE_ADDITIONAL_RECORDS(pMsg) \
            (pMsg)->pCurrentCountField = &(pMsg)->MessageHead.AdditionalCount;


#define IS_SET_TO_WRITE_ANSWER_RECORDS(pMsg) \
            ((pMsg)->pCurrentCountField == &(pMsg)->MessageHead.AnswerCount)

#define IS_SET_TO_WRITE_AUTHORITY_RECORDS(pMsg) \
            ((pMsg)->pCurrentCountField == &(pMsg)->MessageHead.NameServerCount)

#define IS_SET_TO_WRITE_ADDITIONAL_RECORDS(pMsg) \
            ((pMsg)->pCurrentCountField == &(pMsg)->MessageHead.AdditionalCount)


#endif  // no DNSSRV


//
//  DNS Query info blob
//

typedef struct _QueryInfo
{
    PSTR            pName;
    WORD            wType;
    WORD            wRcode;

    DWORD           Flags;
    DNS_STATUS      Status;

    DWORD           MessageLength;
    PBYTE           pMessage;

    PDNS_RECORD     pRecordsAnswer;
    PDNS_RECORD     pRecordsAuthority;
    PDNS_RECORD     pRecordsAdditional;

    PIP_ARRAY       pDnsServerArray;

    //  private

    PDNS_MSG_BUF            pMsgSend;
    PDNS_MSG_BUF            pMsgRecv;

    PDNS_NETINFO            pNetworkInfo;
    PVOID                   pfnGetIpAddressInfo;

    SOCKET                  Socket;
    DWORD                   ReturnFlags;

    //  maybe fold into Status
    DNS_STATUS              NetFailureStatus;

    //  maybe fold into ReturnFlags
    BOOL                    CacheNegativeResponse;
}
QUERY_INFO; *PQUERY_INFO;



#endif  // _DNS_MESSAGE_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\packet.c ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    packet.c

Abstract:

    Domain Name System (DNS) Library

    Packet writing utilities.

Author:

    Jim Gilroy (jamesg)     October, 1996

Environment:

    User Mode - Win32

Revision History:

--*/


#include "local.h"


//
//  Global XID counter, to generate unique XIDs
//

WORD    gwTransactionId = 1;


//
//  Class values for UPDATE packets
//  (Key concept here -- designed by committee)
//
//  These arrays are indexed by
//      !wDataLength -- row
//      Delete flag -- column
//

WORD    PrereqClassArray[2][2] =
{
    DNS_RCLASS_INTERNET,    //  data != 0, no delete
    0,                      //  data != 0, delete => ERROR
    DNS_RCLASS_ANY,         //  no data, no delete
    DNS_RCLASS_NONE,        //  no data, delete
};

WORD    UpdateClassArray[2][2] =
{
    DNS_RCLASS_INTERNET,    //  data != 0, no delete
    DNS_RCLASS_NONE,        //  data != 0, delete
    0,                      //  no data, no delete => ERROR
    DNS_RCLASS_ANY,         //  no data, delete
};



PDNS_MSG_BUF
Dns_AllocateMsgBuf(
    IN      WORD    wBufferLength   OPTIONAL
    )
/*++

Routine Description:

    Allocate message buffer.

Arguments:

    wBufferLength - optional length of message buffer;  default is MAX
        UDP size

Return Value:

    Ptr to message buffer.
    NULL on error.

--*/
{
    PDNS_MSG_BUF    pmsg;
    BOOL            ftcp = FALSE;

    //
    //  default allocation to UDP max buffer length
    //

    if ( wBufferLength <= DNS_MAX_UDP_PACKET_BUFFER_LENGTH )
    {
        wBufferLength = DNS_MAX_UDP_PACKET_BUFFER_LENGTH;
    }
    else
    {
        ftcp = TRUE;
    }

    pmsg = ALLOCATE_HEAP( SIZEOF_MSG_BUF_OVERHEAD + wBufferLength );
    if ( pmsg == NULL )
    {
        return( NULL );
    }

    pmsg->BufferLength = wBufferLength;

    //
    //  limit UDP sends to classical RFC UDP limit (512 bytes)
    //  write routines use pBufferEnd to determine writeability
    //

    if ( !ftcp )
    {
        wBufferLength = DNS_RFC_MAX_UDP_PACKET_LENGTH;
    }
    pmsg->pBufferEnd = (PCHAR)&pmsg->MessageHead + wBufferLength;
    pmsg->fTcp = (BOOLEAN)ftcp;

    Dns_InitializeMsgBuf( pmsg );

    return( pmsg );
}



VOID
Dns_InitializeMsgBuf(
    IN OUT  PDNS_MSG_BUF    pMsg
    )
/*++

Routine Description:

    Allocate message buffer.

Arguments:

    wBufferLength - optional length of message buffer;  default is MAX
        UDP size

Return Value:

    Ptr to message buffer.
    NULL on error.

--*/
{
    //  setup addressing info

    pMsg->Socket = 0;
    pMsg->RemoteAddressLength = sizeof(SOCKADDR_IN);

    //  set for packet reception

    if ( pMsg->fTcp )
    {
        SET_MESSAGE_FOR_TCP_RECV( pMsg );
    }
    else
    {
        SET_MESSAGE_FOR_UDP_RECV( pMsg );
    }

    //  clear header

    RtlZeroMemory(
        &pMsg->MessageHead,
        sizeof( DNS_HEADER ) );

    //  set for rewriting

    pMsg->pCurrent = pMsg->MessageBody;
}



//
//  Writing to packet
//

PCHAR
_fastcall
Dns_WriteDottedNameToPacket(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      LPSTR           pszName,
    IN      LPSTR           pszDomain,      OPTIONAL
    IN      WORD            wDomainOffset,  OPTIONAL
    IN      BOOL            fUnicodeName
    )
/*++

Routine Description:

    Write lookup name to packet.

Arguments:

    pch -- ptr to current position in packet buffer

    pchStop -- end of packet buffer

    pszName - dotted FQDN to write

    pszDomain - domain name already in packet (OPTIONAL);  note this is
        a fragment of the SAME STRING as pszName;  i.e. ptr compare
        NOT strcmp is done to determine if at domain name

    wDomainOffset - offset in packet of domain name;  MUST include this
        if pszDomain is given

    fUnicodeName -- pszName is unicode string
        TRUE -- name is unicode
        FALSE -- name is UTF8

Return Value:

    Ptr to next position in packet buffer.
    NULL on error.

--*/
{
    CHAR    ch;
    PCHAR   pchlabelStart;
    UCHAR   countLabel = 0;
    ULONG   countName = 0;
    CHAR    nameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];
    WCHAR   nameWideBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];


    //  protect message buffer overrun

    if ( pch >= pchStop )
    {
        return( NULL );
    }

    //  allow root to be indicated by NULL

    if ( !pszName )
    {
        *pch++ = 0;
        return( pch );
    }

    //
    //  protect stack buffers from bogus names
    //

    if ( fUnicodeName )
    {
        countName = wcslen( (LPWSTR) pszName );
    }
    else
    {
        countName = strlen( pszName );
    }
    if ( countName >= DNS_MAX_NAME_BUFFER_LENGTH )
    {
        return NULL;
    }
    countName = 0;

    //
    //  UTF8 name with extended chars?
    //      - then must go up to unicode for downcasing
    //

    if ( !fUnicodeName )
    {
        if ( !Dns_IsStringAscii( pszName ) )
        {
            DWORD bufLength = DNS_MAX_NAME_BUFFER_LENGTH_UNICODE;

            if ( ! Dns_NameCopy(
                        (PCHAR) nameWideBuffer,
                        & bufLength,
                        pszName,
                        0,          // length unknown
                        DnsCharSetUtf8,
                        DnsCharSetUnicode
                        ) )
            {
                return( NULL );
            }
            pszName = (PCHAR) nameWideBuffer;
            fUnicodeName = TRUE;
        }
    }

    //
    //  convert unicode name to UTF8
    //      - if extended chars, then downcase before hit the wire
    //

    if ( fUnicodeName )
    {
        if ( !Dns_IsWideStringAscii( (PWSTR)pszName ) )
        {
            Dns_DownCaseBuffW(
                (PWCHAR) pszName,
                0 );
        }

        if ( ! Dns_NameCopy(
                    nameBuffer,
                    NULL,       // assume adequate length
                    pszName,
                    0,          // length unknown
                    DnsCharSetUnicode,
                    DnsCharSetUtf8
                    ) )
        {
            return( NULL );
        }

        pszName = nameBuffer;
    }

    //
    //  special case "." root name
    //      - allows us to fail all other zero length labels cleanly
    //

    if ( *pszName == '.' )
    {
        if ( *(pszName+1) != 0 )
        {
            return( NULL );
        }
        *pch++ = 0;
        return( pch );
    }

    //
    //  write lookup name
    //      - leave

    pchlabelStart = pch++;

    while( ch = *pszName++ )
    {
        //  out of space

        if ( pch >= pchStop )
        {
            return( NULL );
        }

        //  not at end of label -- just copy character

        if ( ch != '.' )
        {
            *pch++ = ch;
            countLabel++;
            countName++;
            continue;
        }

        //
        //  at end of label
        //      - write label count
        //      - reset counter
        //      - if reached domain name, write compression and quit
        //

        if ( countLabel > DNS_MAX_LABEL_LENGTH ||
             countLabel == 0 ||
             countName > DNS_MAX_NAME_LENGTH )
        {
            return( NULL );
        }
        *pchlabelStart = countLabel;
        countLabel = 0;
        countName++;
        pchlabelStart = pch++;

        if ( pszName == pszDomain )
        {
            if ( ++pch >= pchStop )
            {
                return( NULL );
            }
            *(UNALIGNED WORD *)pchlabelStart =
                    htons( (WORD)(wDomainOffset | (WORD)0xC000) );
            return( pch );
        }
    }

    if ( countLabel > DNS_MAX_LABEL_LENGTH ||
         countName > DNS_MAX_NAME_LENGTH )
    {
        return( NULL );
    }

    //
    //  NULL terminate
    //      - if no terminating ".", do end of label processing also
    //      - return ptr to char after terminating NULL

    if ( countLabel )
    {
        *pchlabelStart = countLabel;
        *pch++ = 0;
    }
    else
    {
        DNS_ASSERT( pch == pchlabelStart + 1 );
        *pchlabelStart = 0;
    }
    return( pch );
}



PCHAR
_fastcall
Dns_WriteStringToPacket(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      LPSTR           pszString,
    IN      BOOL            fUnicodeString
    )
/*++

Routine Description:

    Write string to packet.

Arguments:

    pch -- ptr to current position in packet buffer

    pchStop -- end of packet buffer

    pszString - string to write

    fUnicodeString -- pszString is unicode string

Return Value:

    Ptr to next position in packet buffer.
    NULL on error.

--*/
{
    DWORD    length;

    //
    //  handle NULL string
    //

    if ( !pszString )
    {
        if ( pch >= pchStop )
        {
            return( NULL );
        }
        *pch++ = 0;
        return( pch );
    }

    //
    //  get string length
    //      - get required buf length, then whack whack off space
    //      for terminating NULL
    //      - zero error case, becomes very large number and is
    //      caught by length>MAXCHAR test
    //

    length = Dns_GetBufferLengthForStringCopy(
                pszString,
                0,
                fUnicodeString ? DnsCharSetUnicode : DnsCharSetUtf8,
                DnsCharSetUtf8 );
    length--;

    //
    //  set length byte
    //

    if ( length > MAXUCHAR )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }
    *pch++ = (UCHAR) length;

    if ( pch + length > pchStop )
    {
        SetLastError( ERROR_MORE_DATA );
        return( NULL );
    }

    //
    //  copy string
    //
    //  note unicode conversion will write NULL terminator, so
    //  test again for space in packet
    //

    if ( fUnicodeString )
    {
        if ( pch + length + 1 > pchStop )
        {
            SetLastError( ERROR_MORE_DATA );
            return( NULL );
        }
        Dns_StringCopy(
            pch,
            NULL,
            pszString,
            length,
            DnsCharSetUnicode,
            DnsCharSetUtf8 );
    }
    else
    {
        memcpy(
            pch,
            pszString,
            length );
    }

    return( pch+length );
}



PCHAR
Dns_WriteQuestionToMessage(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      PDNS_NAME       pszName,
    IN      WORD            wType,
    IN      BOOL            fUnicodeName
    )
/*++

Routine Description:

    Write question to packet.

    Note:  Routine DOES NOT clear message info or message header.
    This is optimized for use immediately following Dns_CreateMessage().

Arguments:

    pMsg - message info

    pszName - DNS name of question

    wType - question type

    fUnicodeName - name is in unicode

Return Value:

    Ptr to next char in buffer, if successful.
    NULL if error writing question name.

--*/
{
    PCHAR   pch;

    //  use recursion, as default

    pMsg->MessageHead.RecursionDesired = TRUE;

    //  restart write at message header

    pch = pMsg->MessageBody;

    //  write question name

    pch = Dns_WriteDottedNameToPacket(
                pch,
                pMsg->pBufferEnd,
                pszName,
                NULL,
                0,
                fUnicodeName );
    if ( !pch )
    {
        return( NULL );
    }

    //  write question structure

    *(UNALIGNED WORD *) pch = htons( wType );
    pch += sizeof(WORD);
    *(UNALIGNED WORD *) pch = DNS_RCLASS_INTERNET;
    pch += sizeof(WORD);

    //  set question RR section count

    pMsg->MessageHead.QuestionCount = 1;

    //  header fields in host order

    pMsg->fSwapped = FALSE;

    //  reset current ptr

    pMsg->pCurrent = pch;

    IF_DNSDBG( INIT )
    {
        DnsDbg_Message(
            "Packet after question write:",
            pMsg );
    }
    return( pch );
}



DNS_STATUS
Dns_WriteRecordStructureToMessage(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      WORD            wType,
    IN      WORD            wClass,
    IN      DWORD           dwTtl,
    IN      WORD            wDataLength
    )
/*++

Routine Description:

    No data RR cases:

    This includes prereqs and deletes except for specific record cases.

Arguments:

    pch - ptr to next byte in packet buffer

    pchStop - end of packet buffer

    wClass - class

    wType - desired RR type

    dwTtl - time to live

    wDataLength - data length

Return Value:

    Ptr to next postion in buffer, if successful.
    NULL on error.

--*/
{
    PDNS_WIRE_RECORD    pdnsRR;
    PCHAR               pchdata;

    IF_DNSDBG( WRITE2 )
    {
        DNS_PRINT(( "Dns_WriteRecordStructureToMessage(%p).\n", pMsg ));
    }

    //
    //  out of space
    //

    pdnsRR = (PDNS_WIRE_RECORD) pMsg->pCurrent;
    pchdata = (PCHAR) pdnsRR + sizeof( DNS_WIRE_RECORD );

    if ( pchdata + wDataLength >= pMsg->pBufferEnd )
    {
        DNS_PRINT(( "ERROR  out of space writing record to packet.\n" ));
        return( ERROR_MORE_DATA );
    }

    //
    //  write RR wire structure
    //

    *(UNALIGNED WORD *) &pdnsRR->RecordType  = htons( wType );
    *(UNALIGNED WORD *) &pdnsRR->RecordClass = htons( wClass );
    *(UNALIGNED DWORD *) &pdnsRR->TimeToLive = htonl( dwTtl );
    *(UNALIGNED WORD *) &pdnsRR->DataLength  = htons( wDataLength );

    //
    //  update current ptr
    //

    pMsg->pCurrent = pchdata;

    return( ERROR_SUCCESS );
}



#if 0
DNS_STATUS
Dns_WriteOptToMessage(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      WORD            wPayload
    IN      DWORD           Rcode,
    IN      BYTE            Version,
    IN      PBYTE           pData,
    IN      WORD            wDataLength
    )
/*++

Routine Description:

    Write OPT record to message.

Arguments:

    pMsg        -- message

    wPayload    -- max length client can receive in UDP

    Rcode       -- RCODE, if extended some of this ends up in OPT

    Version     -- EDNS version

    pData       -- ptr to data buffer of OPT data

    wDataLength -- length of pData

Return Value:

    ERROR_SUCCESS if successfully writen.
    ErrorCode on failure.

--*/
{
}
#endif



DNS_STATUS
Dns_WriteRecordStructureToPacket(
    IN OUT  PCHAR           pchBuf,
    IN      PDNS_RECORD     pRecord,
    IN      BOOL            fUpdatePacket
    )
/*++

Routine Description:

    Write wire record structure for given record.

Arguments:

    pchBuf - ptr to next byte in packet buffer

    pRecord - record to write

    fUpdatePacket -- If TRUE, the packet is going to contain an update.
                     Therefore the section flags in the pRecords
                     should be interpreted for update. Otherwise this is
                     for a query and section flags will be interpreted for
                     query.

Return Value:

    None

--*/
{
    PDNS_WIRE_RECORD    pwireRecord;
    WORD                class;
    DWORD               ttl;

    IF_DNSDBG( WRITE2 )
    {
        DNS_PRINT((
            "Writing RR struct (%p) to packet buffer at %p.\n",
            pRecord,
            pchBuf
            ));
        DnsDbg_Record(
            "Record being written:",
            pRecord );
    }

    //
    //  get TTL, it will be set to zero for several of the update cases
    //

    ttl = pRecord->dwTtl;

    //
    //  determine class
    //      - class variable is in net order (for perf)
    //      - default is class IN, but may be ANY or NONE for certain updates
    //

    if ( fUpdatePacket )
    {
        switch( pRecord->Flags.S.Section )
        {
        case DNSREC_PREREQ:

            class = PrereqClassArray
                    [ pRecord->wDataLength == 0 ][ pRecord->Flags.S.Delete ];
            ttl = 0;
            break;

        case DNSREC_UPDATE:
        case DNSREC_ADDITIONAL:

            class = UpdateClassArray
                    [ pRecord->wDataLength == 0 ][ pRecord->Flags.S.Delete ];

            if ( class != DNS_RCLASS_INTERNET )
            {
                ttl = 0;
            }
            break;

        default:
            DNS_PRINT(( "ERROR:  invalid RR section.\n" ));
            return( ERROR_INVALID_DATA );
        }
        if ( class == 0 )
        {
            DNS_PRINT(( "ERROR:  no update class corresponding to RR flags.\n" ));
            return( ERROR_INVALID_DATA );
        }
    }
    else
    {
        class = DNS_RCLASS_INTERNET;
    }

    //
    //  write RR wire structure
    //      - zero datalength to handle no data case
    //

    pwireRecord = (PDNS_WIRE_RECORD) pchBuf;

    *(UNALIGNED WORD *) &pwireRecord->RecordType  = htons( pRecord->wType );
    *(UNALIGNED WORD *) &pwireRecord->RecordClass = class;
    *(UNALIGNED DWORD *) &pwireRecord->TimeToLive = htonl( ttl );
    *(UNALIGNED WORD *) &pwireRecord->DataLength = 0;

    return( ERROR_SUCCESS );
}



PCHAR
Dns_WriteRecordStructureToPacketEx(
    IN OUT  PCHAR           pchBuf,
    IN      WORD            wType,
    IN      WORD            wClass,
    IN      DWORD           dwTtl,
    IN      WORD            wDataLength
    )
/*++

Routine Description:

    Write wire record structure for given record.

Arguments:

    pchBuf - ptr to next byte in packet buffer

Return Value:

    Ptr to data section of record.

--*/
{
    PDNS_WIRE_RECORD    pwireRecord;

    //  DCR_PERF:  optimize RR write to packet?

    pwireRecord = (PDNS_WIRE_RECORD) pchBuf;

    *(UNALIGNED WORD *) &pwireRecord->RecordType  = htons( wType );
    *(UNALIGNED WORD *) &pwireRecord->RecordClass = htons( wClass );
    *(UNALIGNED DWORD *) &pwireRecord->TimeToLive = htonl( dwTtl );
    *(UNALIGNED WORD *) &pwireRecord->DataLength = htons( wDataLength );

    return( pchBuf + sizeof(DNS_WIRE_RECORD) );
}



VOID
Dns_SetRecordDatalength(
    IN OUT  PDNS_WIRE_RECORD    pRecord,
    IN      WORD                wDataLength
    )
/*++

Routine Description:

    Reset record datalength.

Arguments:

    pRecord - wire record to reset

    wDataLength - data length

Return Value:

    Ptr to data section of record.

--*/
{
    WORD  flippedWord;

    INLINE_WORD_FLIP( flippedWord, wDataLength );

    *(UNALIGNED WORD *) &pRecord->DataLength = flippedWord;
}




DNS_STATUS
Dns_AddRecordsToMessage(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      PDNS_RECORD     pRecord,
    IN      BOOL            fUpdateMessage
    )
/*++

Routine Description:

    Add record or list of records to message.No data RR cases:

    This includes prereqs and deletes except for specific record cases.

Arguments:

    pMsg - message buffer to write to

    pRecord - ptr to record (or first of list of records) to write to packet

    fUpdateMessage -- If TRUE, the message is going to contain an update.
                      Therefore the section flags in the pRecord
                      should be interpreted for update. Otherwise this is
                      for a query message and section flags should be
                      interpreted for query.

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PCHAR               pch = pMsg->pCurrent;
    PCHAR               pendBuffer = pMsg->pBufferEnd;
    WORD                currentSection = 0;
    WORD                section;
    PDNS_NAME           pnamePrevious = NULL;
    WORD                compressedPreviousName;
    WORD                offsetPreviousName;
    PDNS_WIRE_RECORD    pwireRecord;
    PCHAR               pchnext;
    WORD                index;
    DNS_STATUS          status = ERROR_SUCCESS;

    //
    //  write each record in list
    //

    while ( pRecord )
    {
        //
        //  determine section for record
        //      - may not write to previous section

        section = (WORD) pRecord->Flags.S.Section;
        if ( section < currentSection )
        {
            DNS_PRINT((
                "ERROR:  Attempt to write record at %p, with section %d\n"
                "\tless than previous section written %d.\n",
                pRecord,
                pRecord->Flags.S.Section,
                currentSection ));
            return( ERROR_INVALID_DATA );
        }
        else if ( section > currentSection )
        {
            currentSection = section;
            SET_CURRENT_RR_COUNT_SECTION( pMsg, section );
        }

        //
        //  write record name
        //      - if same as previous, write compressed name
        //      - if first write from pRecord
        //          - write full name
        //          - clear reserved field for offsetting
        //

        if ( pnamePrevious && !strcmp( pnamePrevious, pRecord->pName ) )
        {
            //  compression should always be BACK ptr

            DNS_ASSERT( offsetPreviousName < pch - (PCHAR)&pMsg->MessageHead );

            if ( pendBuffer <= pch + sizeof(WORD) )
            {
                return( ERROR_MORE_DATA );
            }
            if ( ! compressedPreviousName )
            {
                compressedPreviousName =
                                htons( (WORD)(0xC000 | offsetPreviousName) );
            }
            *(UNALIGNED WORD *)pch = compressedPreviousName;
            pch += sizeof( WORD );
        }
        else
        {
            offsetPreviousName = (WORD)(pch - (PCHAR)&pMsg->MessageHead);
            compressedPreviousName = 0;
            pnamePrevious = pRecord->pName;

            pch = Dns_WriteDottedNameToPacket(
                    pch,
                    pendBuffer,
                    pnamePrevious,
                    NULL,
                    0,
                    ( RECORD_CHARSET(pRecord) == DnsCharSetUnicode ) );

            if ( !pch )
            {
                //  DCR:  distinguish out of space errors from name errors during write
                return( DNS_ERROR_INVALID_NAME );
            }
        }

        //
        //  write record structure
        //

        if ( pch + sizeof(DNS_WIRE_RECORD) >= pendBuffer )
        {
            return( ERROR_MORE_DATA );
        }

        status = Dns_WriteRecordStructureToPacket(
                    pch,
                    pRecord,
                    fUpdateMessage );
        if ( status != ERROR_SUCCESS )
        {
            return( status );
        }

        pwireRecord = (PDNS_WIRE_RECORD) pch;
        pch += sizeof( DNS_WIRE_RECORD );

        //
        //  record data
        //

        if ( pRecord->wDataLength )
        {
            index = INDEX_FOR_TYPE( pRecord->wType );
            DNS_ASSERT( index <= MAX_RECORD_TYPE_INDEX );

            if ( index && RRWriteTable[ index ] )
            {
                pchnext = RRWriteTable[ index ](
                                pRecord,
                                pch,
                                pendBuffer
                                );
                if ( ! pchnext )
                {
                    status = GetLastError();
                    DNS_PRINT((
                        "ERROR:  Record write routine failure for record type %d.\n\n"
                        "\tstatus = %p\n",
                        pRecord->wType,
                        status ));
                    return( status );
                }
            }
            else
            {
                //  write unknown types -- as RAW data only

                DNS_PRINT((
                    "WARNING:  Writing unknown type %d to message\n",
                    pRecord->wType ));

                if ( pendBuffer - pch <= pRecord->wDataLength )
                {
                    return( ERROR_MORE_DATA );
                }
                memcpy(
                    pch,
                    (PCHAR) &pRecord->Data,
                    pRecord->wDataLength );
                pchnext = pch + pRecord->wDataLength;
            }

            //
            //  set packet record data length
            //

            DNS_ASSERT( (pchnext - pch) < MAXWORD );
            *(UNALIGNED WORD *) &pwireRecord->DataLength =
                                                htons( (WORD)(pchnext - pch) );
            pch = pchnext;
        }

        //  increment message record count

        CURRENT_RR_COUNT_FIELD(pMsg)++;

        pRecord = pRecord->pNext;
    }

    //
    //  resest message current ptr
    //

    pMsg->pCurrent = pch;

    IF_DNSDBG( INIT )
    {
        DnsDbg_Message(
            "Packet after adding records:",
            pMsg );
    }

    return( status );
}



//
//  Reading from packet
//

PCHAR
_fastcall
Dns_SkipPacketName(
    IN      PCHAR       pch,
    IN      PCHAR       pchEnd
    )
/*++

Routine Description:

    Skips over name in packet

Arguments:

    pch - ptr to start of name to skip

    pchEnd - ptr to byte after end of packet

Return Value:

    Ptr to next byte in buffer
    NULL if bad name

--*/
{
    register UCHAR  cch;
    register UCHAR  cflag;

    //
    //  Loop until end of name
    //

    while ( pch < pchEnd )
    {
        cch = *pch++;
        cflag = cch & 0xC0;

        //
        //  normal label
        //      - skip to next label and continue
        //      - stop only if at 0 (root) label
        //

        if ( cflag == 0 )
        {
            if ( cch )
            {
                pch += cch;
                continue;
            }
            return( pch );
        }

        //
        //  compression
        //      - skip second byte in compression and return
        //

        else if ( cflag == 0xC0 )
        {
            pch++;
            return( pch );
        }
        else
        {
            DNSDBG( READ, (
                "ERROR:  bad packet name label byte %02 at 0x%p\n",
                cch,
                pch - 1
                ));
            return( NULL );
        }
    }

    DNSDBG( READ, (
        "ERROR:  packet name at %p reads past end of packet at %p\n",
        pch,
        pchEnd
        ));

    return( NULL );
}


PCHAR
_fastcall
Dns_SkipPacketRecord(
    IN      PCHAR           pchRecord,
    IN      PCHAR           pchMsgEnd
    )
/*++

Routine Description:

    Skips over packet RR.
    This is RR structure and data, not the owner name.

Arguments:

    pchRecord - ptr to start of RR structure.

    pchMsgEnd - end of message

Return Value:

    Ptr to next record in packet.
    NULL if RR outside packet or invalid.

--*/
{
    //
    //  skip RR struct
    //

    pchRecord += sizeof(DNS_WIRE_RECORD);
    if ( pchRecord > pchMsgEnd )
    {
        return( NULL );
    }

    //  read datalength and skip data
    //  datalength field is a WORD, at end of record header

    pchRecord += InlineFlipUnalignedWord( pchRecord - sizeof(WORD) );

    if ( pchRecord > pchMsgEnd )
    {
        return( NULL );
    }

    return( pchRecord );
}



PCHAR
Dns_SkipToRecord(
    IN      PDNS_HEADER     pMsgHead,
    IN      PCHAR           pMsgEnd,
    IN      INT             iCount
    )
/*++

Routine Description:

    Skips over some number of DNS records.

Arguments:

    pMsgHead    -- ptr to begining of DNS message.

    pMsgEnd     -- ptr to end of DNS message

    iCount      -- if > 0, number of records to skip
                    if <= 0, number of records from end of packet

Return Value:

    Ptr to next
    NULL if bad packet.

--*/
{
    PCHAR   pch;
    INT     i;
    WORD    recordCount;

    //
    //  determine how many records to skip
    //

    recordCount = pMsgHead->QuestionCount
                + pMsgHead->AnswerCount
                + pMsgHead->NameServerCount
                + pMsgHead->AdditionalCount;

    //  iCount > 0 is skip count, MUST not be larger than
    //      actual count

    if ( iCount > 0 )
    {
        if ( iCount > recordCount )
        {
            return( NULL );
        }
    }

    //  iCount <= 0 then (-iCount) is number of records
    //  from the last record

    else
    {
        iCount += recordCount;
        if ( iCount < 0 )
        {
            return( NULL );
        }
    }

    //  skip message header

    pch = (PCHAR) (pMsgHead + 1);
    if ( iCount == 0 )
    {
        return( pch );
    }

    //  skip the question/zone section

    pch = Dns_SkipPacketName( pch, pMsgEnd );
    if ( !pch )
    {
        return pch;
    }
    pch += sizeof(DNS_WIRE_QUESTION);

    //
    //  skip regular records
    //

    iCount--;
    for ( i=0; i<iCount; i++ )
    {
        pch = Dns_SkipPacketName( pch, pMsgEnd );
        if ( !pch )
        {
            return pch;
        }
        pch = Dns_SkipPacketRecord( pch, pMsgEnd );
        if ( !pch )
        {
            return pch;
        }
    }

    DNSDBG( READ, (
        "Leaving SkipToRecord, current ptr = %p, offset = %04x\n"
        "\tskipped %d records\n",
        pch,
        (WORD) (pch - (PCHAR)pMsgHead),
        iCount+1 ));

    return( pch );
}



PCHAR
_fastcall
Dns_ReadPacketName(
    IN OUT  PCHAR       pchNameBuffer,
    OUT     PWORD       pwNameLength,
    IN OUT  PWORD       pwNameOffset,           OPTIONAL
    OUT     PBOOL       pfNameSameAsPrevious,   OPTIONAL
    IN      PCHAR       pchName,
    IN      PCHAR       pchStart,
    IN      PCHAR       pchEnd
    )
/*++

Routine Description:

    Reads packet name and converts it to DNS-dotted format.

Arguments:

    pchNameBuffer - buffer to write name into;  contains previous name, if any

    pwNameLength - length of name written to buffer;  does not include
        terminating NULL

    pwNameOffset - addr with previous names offset (zero if no previous name);
        on return, contains this name's offset
        OPTIONAL but must exist if fNameSameAsPrevious exists

    pfNameSameAsPrevious - addr of flag set if this name is same as previous;
        OPTIONAL but must exist if pwNameOffset exists

    pchName  - ptr to name in packet

    pchStart - start of DNS message

    pchEnd   - ptr to byte after end of DNS message

Return Value:

    Ptr to next byte in packet.
    NULL on error.

--*/
{
    register PUCHAR pch = pchName;
    register UCHAR  cch;
    register UCHAR  cflag;
    PCHAR           pchdotted;
    PCHAR           pbufferEnd;
    PCHAR           pchreturn = NULL;

    DNS_ASSERT( pch > pchStart && pchEnd > pchStart );
    DNS_ASSERT( (pwNameOffset && pfNameSameAsPrevious) ||
            (!pwNameOffset && !pfNameSameAsPrevious) );


    //
    //  read through labels and/or compression until reach end of name
    //

    pbufferEnd = pchNameBuffer + DNS_MAX_NAME_LENGTH;
    pchdotted = pchNameBuffer;

    while ( pch < pchEnd )
    {
        cch = *pch++;

        //
        //  at root label
        //      - if root name, write single '.'
        //      - otherwise strip trailing dot from last label
        //      - save length written
        //      - NULL teminate name
        //      - set same as previous FALSE
        //      - save packet offset to this name
        //      - return next byte in buffer
        //

        if ( cch == 0 )
        {
            if ( pchdotted == pchNameBuffer )
            {
                *pchdotted++ = '.';
            }
            else
            {
                pchdotted--;
            }
            *pwNameLength = (WORD)(pchdotted - pchNameBuffer);
            *pchdotted = 0;
            if ( pwNameOffset )
            {
                *pfNameSameAsPrevious = FALSE;
                *pwNameOffset = (WORD)(pchName - pchStart);
            }
            return( pchreturn ? pchreturn : pch );
        }

        cflag = cch & 0xC0;

        //
        //  regular label
        //      - copy label to buffer
        //      - jump to next label

        if ( cflag == 0 )
        {
            PCHAR   pchnext = pch + cch;

            if ( pchnext >= pchEnd )
            {
                DNS_PRINT((
                    "ERROR:  Packet name at %p extends past end of buffer\n",
                    pchName ));
                goto Failed;
            }
            if ( pchdotted + cch + 1 >= pbufferEnd )
            {
                DNS_PRINT((
                    "ERROR:  Packet name at %p exceeds max length\n",
                    pchName ));
                goto Failed;
            }
            memcpy(
                pchdotted,
                pch,
                cch );

            pchdotted += cch;
            *pchdotted++ = '.';
            pch = pchnext;
            continue;
        }

        //
        //  offset
        //      - get offset
        //      - if offset at start of name compare to previous name offset
        //      - otherwise follow offset to build new name
        //

        if ( cflag == 0xC0 )
        {
            WORD    offset;
            PCHAR   pchoffset;

            offset = (cch ^ 0xC0);
            offset <<= 8;
            offset |= *pch;
            pchoffset = --pch;

            //
            //  first offset
            //      - save return pointer
            //
            //  if name is entirely offset
            //      - same as previous offset -- done
            //      - if not still save this offset rather than offset
            //      to name itself (first answer is usually just offset
            //      to question, subsequent answer RRs continue to reference
            //      question offset, not first answer)
            //

            if ( !pchreturn )
            {
                DNS_ASSERT( pch >= pchName );
                pchreturn = pch+2;

                if ( pchoffset == pchName && pwNameOffset )
                {
                    if ( *pwNameOffset == offset )
                    {
                        *pfNameSameAsPrevious = TRUE;
                        return( pchreturn );
                    }
                    else
                    {
                        //  save offset that comprises name
                        //  then kill out copy of return ptr so don't
                        //  return offset to pchName when finish copy

                        *pwNameOffset = offset;
                        *pfNameSameAsPrevious = FALSE;
                        pwNameOffset = NULL;
                    }
                }
            }

            //
            //  make jump to new bytes and continue
            //      - verify offset is BEFORE current name
            //          and BEFORE current ptr

            pch = pchStart + offset;

            if ( pch >= pchName || pch >= pchoffset )
            {
                DNS_PRINT((
                    "ERROR:  Bogus name offset %d, encountered at %p\n"
                    "\tto location %p past current position or original name.\n",
                    offset,
                    pchoffset,
                    pch ));
                goto Failed;
            }
            continue;
        }

        //  any other label byte is bogus

        else
        {
            DNS_PRINT((
                "ERROR:  bogus name label byte %02x at %p\n",
                cch,
                pch - 1 ));
            goto Failed;
        }
    }

    DNS_PRINT((
        "ERROR:  packet name at %p reads to ptr %p past end of packet at %p\n",
        pchName,
        pch,
        pchEnd ));

    //
    //  failed
    //      - return NULL
    //      - set OUT params, keeps prefix happy on higher level calls
    //

Failed:

    *pwNameLength = 0;
    if ( pwNameOffset )
    {
        *pwNameOffset = 0;
    }
    if ( pfNameSameAsPrevious )
    {
        *pfNameSameAsPrevious = FALSE;
    }
    return ( NULL );
}



PCHAR
_fastcall
Dns_ReadPacketNameAllocate(
    IN OUT  PCHAR *         ppchName,
    OUT     PWORD           pwNameLength,
    IN OUT  PWORD           pwPrevNameOffset,       OPTIONAL
    OUT     PBOOL           pfNameSameAsPrevious,   OPTIONAL
    IN      PCHAR           pchPacketName,
    IN      PCHAR           pchStart,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Reads packet name and creates (allocates) a copy in DNS-dotted format.

Arguments:

    ppchName - addr to recv resulting name ptr

    pwNameLength - length of name written to buffer

    pwNameOffset - addr with previous names offset (zero if no previous name);
        on return, contains this name's offset
        OPTIONAL but must exist if fNameSameAsPrevious exists

    fNameSameAsPrevious - addr of flag set if this name is same as previous;
        OPTIONAL but must exist if pwNameOffset exists

    pchPacketName - pch to name in packet

    pchStart - start of DNS message

    pchEnd - ptr to byte after end of DNS message

Return Value:

    Ptr to next byte in packet.
    NULL on error.

--*/
{
    PCHAR   pch;
    PCHAR   pallocName;
    CHAR    nameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];
    WORD    nameLength = DNS_MAX_NAME_BUFFER_LENGTH;

    //
    //  read packet name into buffer
    //

    pch = Dns_ReadPacketName(
            nameBuffer,
            & nameLength,
            pwPrevNameOffset,
            pfNameSameAsPrevious,
            pchPacketName,
            pchStart,
            pchEnd );
    if ( !pch )
    {
        return( pch );
    }

    //
    //  allocate buffer for packet name
    //      - nameLength does not include terminating NULL
    //

    nameLength++;
    pallocName = (PCHAR) ALLOCATE_HEAP( nameLength );
    if ( !pallocName )
    {
        return( NULL );
    }

    RtlCopyMemory(
        pallocName,
        nameBuffer,
        nameLength );

    *ppchName = pallocName;
    *pwNameLength = --nameLength;

    DNSDBG( READ, (
        "Allocated copy of packet name %s length %d\n",
        pallocName,
        nameLength ));

    return( pch );
}



DNS_STATUS
Dns_ExtractRecordsFromMessage(
    IN      PDNS_MSG_BUF    pMsg,
    IN      BOOL            fUnicode,
    OUT     PDNS_RECORD *   ppRecord
    )
/*++

Routine Description:

    Extract records from packet.

Arguments:

    pMsg - message buffer to write to

    fUnicode - flag indicating strings in record should be unicode

Return Value:

    Ptr to parsed record list if any.
    NULL if no record list or error.

--*/
{
    PDNS_MESSAGE_BUFFER pDnsBuffer = (PDNS_MESSAGE_BUFFER) &pMsg->MessageHead;

    return Dns_ExtractRecordsFromBuffer(
                pDnsBuffer,
                pMsg->MessageLength,
                fUnicode,
                ppRecord );
}



DNS_STATUS
Dns_ExtractRecordsFromBuffer(
    IN      PDNS_MESSAGE_BUFFER pDnsBuffer,
    IN      WORD                wMessageLength,
    IN      BOOL                fUnicode,
    OUT     PDNS_RECORD *       ppRecord
    )
/*++

Routine Description:

    Extract records from packet buffer.

Arguments:

    pDnsBuffer - message buffer to read from

    fUnicode - flag indicating strings in record should be unicode

Return Value:

    Ptr to parsed record list if any.
    NULL if no record list or error.

--*/
{
    register PCHAR      pch;
    PDNS_HEADER         pwireMsg = (PDNS_HEADER) pDnsBuffer;
    PCHAR               pchpacketEnd;
    DNS_PARSED_RR       parsedRR;
    LPSTR               pnameOwner;
    LPSTR               pnameNew = NULL;
    DNS_CHARSET         outCharSet;
    WORD                countRR;
    WORD                countSection;
    WORD                typePrevious = 0;
    WORD                nameOffset = 0;
    WORD                nameLength;
    WORD                index;
    BYTE                section;
    BOOL                fnameSameAsPrevious;
    PDNS_RECORD         pnewRR;
    DNS_RRSET           rrset;
    DNS_STATUS          status;
    DNS_STATUS          rcodeStatus;
    CHAR                nameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];
    DNS_RECORD          recordTemp;
    PWORD               pCurrentCountField = NULL;

    DNSDBG( READ, (
        "Dns_ExtractRecordsFromBuffer( %p, len=%d )\n",
        pDnsBuffer,
        wMessageLength
        ));

    //
    //  error code
    //      - map RCODE to DNS error
    //      - if other than NAME_ERROR, don't bother parsing
    //

    rcodeStatus = pwireMsg->ResponseCode;
    if ( rcodeStatus != 0 )
    {
        rcodeStatus = Dns_MapRcodeToStatus( pwireMsg->ResponseCode );
        if ( rcodeStatus != DNS_ERROR_RCODE_NAME_ERROR )
        {
            DNSDBG( READ, (
                "No records extracted from response\n"
                "\tresponse code = %d\n",
                pwireMsg->ResponseCode ));
            return( rcodeStatus );
        }
    }

    DNS_RRSET_INIT( rrset );

    //
    //  detemine char set
    //

    if ( fUnicode )
    {
        outCharSet = DnsCharSetUnicode;
    }
    else
    {
        outCharSet = DnsCharSetUtf8;
    }

    //
    //  read RRs in list of records
    //
    //  loop through all resource records
    //      - skip question
    //      - build DNS_RECORD structure for other records
    //

    pchpacketEnd = (PCHAR)pwireMsg + wMessageLength;
    pch = pDnsBuffer->MessageBody;

    section = DNSREC_QUESTION;
    pCurrentCountField = &pwireMsg->QuestionCount;
    countSection = pwireMsg->QuestionCount;
    countRR = 0;

    while( 1 )
    {
        //
        //  changing sections
        //  save section number and RR count for current section
        //  note need immediate loop back to handle empty section
        //

        countRR++;
        if ( countRR > countSection )
        {
            if ( section == DNSREC_ADDITIONAL )
            {
                break;
            }
            section++;
            pCurrentCountField++;
            countSection = *(pCurrentCountField);
            countRR = 0;
            continue;
        }

        //  validity check next RR

        if ( pch >= pchpacketEnd )
        {
            DNS_PRINT((
                "ERROR:  reading bad packet %p.\n"
                "\tat end of packet length with more records to process\n"
                "\tpacket length = %ld\n"
                "\tcurrent offset = %ld\n",
                wMessageLength,
                pch - (PCHAR)pwireMsg
                ));
            goto PacketError;
        }

        //
        //  skip question
        //

        if ( section == DNSREC_QUESTION )
        {
            pch = Dns_SkipPacketName(
                        pch,
                        pchpacketEnd );
            if ( !pch )
            {
                DNS_PRINT(( "ERROR:  bad question name.\n" ));
                goto PacketError;
            }
            pch += sizeof(DNS_WIRE_QUESTION);
            if ( pch > pchpacketEnd )
            {
                DNS_PRINT(( "ERROR:  question exceeds packet length.\n" ));
                goto PacketError;
            }
            continue;
        }

        //
        //  read name, determining if same as previous name
        //

        IF_DNSDBG( READ2 )
        {
            DnsDbg_Lock();
            DNS_PRINT((
                "Reading record at offset %x\n",
                (WORD)(pch - (PCHAR)pwireMsg) ));

            DnsDbg_PacketName(
                "Record name ",
                pch,
                pwireMsg,
                pchpacketEnd,
                "\n" );
            DnsDbg_Unlock();
        }
        pch = Dns_ReadPacketName(
                    nameBuffer,
                    & nameLength,
                    & nameOffset,
                    & fnameSameAsPrevious,
                    pch,
                    (PCHAR) pwireMsg,
                    pchpacketEnd );
        if ( ! pch )
        {
            DNS_PRINT(( "ERROR:  bad packet name.\n" ));
            goto PacketError;
        }
        IF_DNSDBG( READ2 )
        {
            DNS_PRINT((
                "Owner name of record %s\n"
                "\tlength = %d\n"
                "\toffset = %d\n"
                "\tfSameAsPrevious = %d\n",
                nameBuffer,
                nameLength,
                nameOffset,
                fnameSameAsPrevious ));
        }

        //
        //  extract RR info, type, datalength
        //      - verify RR within message
        //

        pch = Dns_ReadRecordStructureFromPacket(
                   pch,
                   pchpacketEnd,
                   & parsedRR );
        if ( !pch )
        {
            DNS_PRINT(( "ERROR:  bad RR struct out of packet.\n" ));
            goto PacketError;
        }

        //
        //  on type change, always have new RR set
        //      - setup for new name
        //

        if ( parsedRR.Type != typePrevious )
        {
            fnameSameAsPrevious = FALSE;
            typePrevious = parsedRR.Type;
        }

        //
        //  make copy of new name
        //
        //  DCR_FIX0:   name same as previous
        //      flag indicates only that name not compressed to previous
        //      name (or previous compression)
        //      actually need abolute ingnore case compare
        //      with last records name to be sure that name not previous
        //

        if ( !fnameSameAsPrevious )
        {
            pnameNew = Dns_NameCopyAllocate(
                            nameBuffer,
                            (UCHAR) nameLength,
                            DnsCharSetUtf8,     // UTF8 string in
                            outCharSet
                            );
            pnameOwner = pnameNew;
            DNSDBG( READ2, (
                "Copy of owner name of record being read from packet %s\n",
                pnameOwner ));
        }
        DNS_ASSERT( pnameOwner );
        DNS_ASSERT( pnameNew || fnameSameAsPrevious );

        //
        //  TSIG record requires owner name for versioning
        //

        recordTemp.pName = pnameOwner;

        //
        //  read RR data for type
        //

        index = INDEX_FOR_TYPE( parsedRR.Type );
        DNS_ASSERT( index <= MAX_RECORD_TYPE_INDEX );

        if ( !index || !RRReadTable[ index ] )
        {
            //  unknown types -- index to NULL type to use
            //  FlatRecordRead()

            DNS_PRINT((
                "WARNING:  Reading unknown record type %d from message\n",
                parsedRR.Type ));

            index = DNS_TYPE_NULL;
        }

        pnewRR = RRReadTable[ index ](
                        &recordTemp,
                        outCharSet,
                        (PCHAR) pDnsBuffer,
                        parsedRR.pchData,
                        pch                 // end of record data
                        );
        if ( ! pnewRR )
        {
            status = GetLastError();
            ASSERT( status != ERROR_SUCCESS );

            DNS_PRINT((
                "ERROR:  RRReadTable routine failure for type %d.\n"
                "\tstatus   = %p\n"
                "\tpchdata  = %p\n"
                "\tpchend   = %p\n",
                parsedRR.Type,
                status,
                parsedRR.pchData,
                pch ));

            if ( status == ERROR_SUCCESS )
            {
                status = DNS_ERROR_NO_MEMORY;
            }
            goto Failed;
        }

        //
        //  write record info
        //      - first RR in set gets new name allocation
        //      and is responsible for cleanup
        //      - no data cleanup necessary as all data is
        //      contained in the RR allocation
        //

        pnewRR->pName = pnameOwner;
        pnewRR->wType = parsedRR.Type;
        pnewRR->dwTtl = parsedRR.Ttl;
        pnewRR->Flags.S.Section = section;
        pnewRR->Flags.S.CharSet = outCharSet;
        FLAG_FreeOwner( pnewRR ) = !fnameSameAsPrevious;
        FLAG_FreeData( pnewRR ) = FALSE;

        //  add RR to list

        DNS_RRSET_ADD( rrset, pnewRR );

        //  clear new ptr, as name now part of record
        //  this is strictly used to determine when pnameOwner
        //  must be cleaned up on failure

        pnameNew = NULL;

    }   //  end loop through packet's records

    //
    //  return parsed record list
    //      - return DNS error for RCODE
    //      - set special return code to differentiate empty response
    //
    //  DCR:  should have special REFERRAL response
    //      - could overload NOTAUTH rcode
    //  DCR:  should have special EMPTY_AUTH response
    //      - could have empty-auth overload NXRRSET
    //
    //  DCR:  best check on distinguishing EMPTY_AUTH from REFERRAL
    //

    if ( pwireMsg->AnswerCount == 0  &&  rcodeStatus == 0 )
    {
        if ( !rrset.pFirstRR || rrset.pFirstRR->wType == DNS_TYPE_SOA )
        {
            rcodeStatus = DNS_INFO_NO_RECORDS;
            DNSDBG( READ, ( "Empty-auth response at %p.\n", pwireMsg ));
        }
#if 0
        else if ( rrset.pFirstRR->wType == DNS_TYPE_NS &&
                !pwireMsg->Authoritative )
        {
            rcodeStatus = DNS_INFO_REFERRAL;
            DNSDBG( READ, ( "Referral response at %p.\n", pwireMsg ));
        }
        else
        {
            rcodeStatus = DNS_ERROR_BAD_PACKET;
            DNSDBG( READ, ( "Bogus NO_ERROR response at %p.\n", pwireMsg ));
        }
#endif
    }

    //  verify never turn RCODE result into SUCCESS

    ASSERT( pwireMsg->ResponseCode == 0 || rcodeStatus != ERROR_SUCCESS );
    ASSERT( pnameNew == NULL );

    *ppRecord = rrset.pFirstRR;

    IF_DNSDBG( RECV )
    {
        DnsDbg_RecordSet(
            "Extracted records:\n",
            *ppRecord );
    }
    return( rcodeStatus );


PacketError:

    DNS_PRINT(( "ERROR:  bad packet in buffer.\n" ));
    status = DNS_ERROR_BAD_PACKET;

Failed:

    if ( pnameNew )
    {
        FREE_HEAP( pnameNew );
    }

    Dns_RecordListFree(
        rrset.pFirstRR,
        TRUE            // free owner names also
        );

    return( status );
}


void
Dns_NormalizeAllRecordTtls(
    IN      PDNS_RECORD         pRecord
    )
/*++

Routine Description:

    Finds the lowest Ttl value in RR set and the sets all
    records to that value.

Arguments:

    pRecord - record set to normalize ttl values of.

Return Value:

    None

--*/
{
    PDNS_RECORD pTemp = pRecord;
    DWORD       dwTtl;
    WORD        wType;

    //
    // Get the Ttl of the first record (if there is one)
    //
    if ( pTemp )
    {
        dwTtl = pTemp->dwTtl;
        wType = pTemp->wType;
        pTemp = pTemp->pNext;
    }

    //
    // Walk any remaining records looking for an even lower ttl value
    //
    while ( pTemp &&
            pTemp->wType == wType &&
            pTemp->Flags.S.Section == DNSREC_ANSWER )
    {
        if ( pTemp->dwTtl < dwTtl )
        {
            dwTtl = pTemp->dwTtl;
        }

        pTemp = pTemp->pNext;
    }

    //
    // Set all records to this lowest ttl value
    //
    pTemp = pRecord;

    while ( pTemp &&
            pTemp->wType == wType &&
            pTemp->Flags.S.Section == DNSREC_ANSWER )
    {
        pTemp->dwTtl = dwTtl;
        pTemp = pTemp->pNext;
    }
}



PCHAR
Dns_ReadRecordStructureFromPacket(
    IN      PCHAR           pchPacket,
    IN      PCHAR           pchMsgEnd,
    IN OUT  PDNS_PARSED_RR  pParsedRR
    )
/*++

Routine Description:

    Read record structure from packet.

Arguments:

    pchPacket - ptr to record structure in packet

    pRecord - ptr to record structure to receive record structure
        with fields in host order (and aligned).

Return Value:

    Ptr to next record in packet -- based on datalength.
    Zero on error.

--*/
{
    DNSDBG( READ2, (
        "Dns_ReadRecordStructureFromPacket(%p).\n",
        pchPacket ));

    //
    //  verify record structure within packet
    //

    if ( pchPacket + sizeof(DNS_WIRE_RECORD) > pchMsgEnd )
    {
        DNS_PRINT((
            "ERROR:  record structure at %p is not within packet!.\n",
            pchPacket ));
        return( 0 );
    }

    //
    //  flip fields and write to aligned struct
    //

    pParsedRR->pchRR = pchPacket;

    pParsedRR->Type       = InlineFlipUnalignedWord( pchPacket );
    pchPacket += sizeof(WORD);
    pParsedRR->Class      = InlineFlipUnalignedWord( pchPacket );
    pchPacket += sizeof(WORD);
    pParsedRR->Ttl        = InlineFlipUnalignedDword( pchPacket );
    pchPacket += sizeof(DWORD);
    pParsedRR->DataLength = InlineFlipUnalignedWord( pchPacket );
    pchPacket += sizeof(WORD);

    pParsedRR->pchData = pchPacket;

    //
    //  verify datalength does not extend beyond packet end
    //

    pchPacket += pParsedRR->DataLength;
    pParsedRR->pchNextRR = pchPacket;

    if ( pchPacket > pchMsgEnd )
    {
        DNS_PRINT((
            "ERROR:  record data at %p (length %d) is not within packet!.\n",
            pchPacket - pParsedRR->DataLength,
            pParsedRR->DataLength ));
        return( 0 );
    }

    //
    //  return ptr to next record in packet
    //

    return( pchPacket );
}



PDNS_MSG_BUF
Dns_BuildPacket(
    IN      PDNS_HEADER     pHeader,
    IN      BOOL            fNoHeaderCounts,
    IN      LPSTR           pszQuestionName,
    IN      WORD            wQuestionType,
    IN      PDNS_RECORD     pRecords,
    IN      DWORD           dwFlags,
    IN      BOOL            fUpdatePacket
    )
/*++

Routine Description:

    Build packet.

Arguments:

    pHeader -- DNS header to send

    fNoHeaderCounts - do NOT include record counts in copying header

    pszName -- DNS name to query

    wType -- query type

    pRecords -- address to receive ptr to record list returned from query

    dwFlags -- query flags

    aipDnsServers -- specific DNS servers to query;
        OPTIONAL, if specified overrides normal list associated with machine

    pDnsNetAdapters -- DNS servers to query;  if NULL get current list

    fUpdatePacket -- If TRUE, the packet is going to contain an update.
                     Therefore the section flags in the pRecords
                     should be interpreted for update. Otherwise this is
                     for a query and section flags will be interpreted for
                     query.


Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PDNS_MSG_BUF    pmsg;
    DWORD           length;
    DNS_STATUS      status;

    DNSDBG( WRITE, (
        "Dns_BuildPacket()\n"
        "\tname          %s\n"
        "\ttype          %d\n"
        "\theader        %p\n"
        "\t - counts     %d\n"
        "\trecords       %p\n"
        "\tflags         %p\n"
        "\tfUpdatePacket %p\n",
        pszQuestionName,
        wQuestionType,
        pHeader,
        fNoHeaderCounts,
        pRecords,
        dwFlags,
        fUpdatePacket ));

    //
    //  allocate packet
    //      - if just a question, standard UDP will do it
    //      - if contains records, then use TCP buffer
    //

    length = 0;
    if ( pRecords )
    {
        length = DNS_TCP_DEFAULT_PACKET_LENGTH;
    }
    pmsg = Dns_AllocateMsgBuf( (WORD)length );
    if ( !pmsg )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Failed;
    }

    //
    //  write question?
    //

    if ( pszQuestionName )
    {
        if ( ! Dns_WriteQuestionToMessage(
                    pmsg,
                    pszQuestionName,
                    wQuestionType,
                    (BOOL)!!(dwFlags & DNSQUERY_UNICODE_NAME)
                    ) )
        {
            status = ERROR_INVALID_NAME;
            goto Failed;
        }
    }

    //
    //  build packet records
    //

    if ( pRecords )
    {
        status = Dns_AddRecordsToMessage(
                    pmsg,
                    pRecords,
                    fUpdatePacket );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT((
                "ERROR:  failure writing records to message.\n" ));
            goto Failed;
        }
    }

    //
    //  overwrite header?
    //

    if ( pHeader )
    {
        length = sizeof(DNS_HEADER);
        if ( fNoHeaderCounts )
        {
            length = sizeof(DWORD);
        }
        RtlCopyMemory(
            & pmsg->MessageHead,
            pHeader,
            length );
    }

    //  override recursion default, if desired

    if ( dwFlags & DNS_QUERY_NO_RECURSION )
    {
        pmsg->MessageHead.RecursionDesired = FALSE;
    }

    //  init XID if not set

    if ( pmsg->MessageHead.Xid == 0 )
    {
        pmsg->MessageHead.Xid = gwTransactionId++;
    }

    return( pmsg );

Failed:

    SetLastError( status );
    FREE_HEAP( pmsg );
    return( NULL );
}



WORD
Dns_GetRandomXid(
    IN      PVOID           pSeed
    )
/*++

Routine Description:

    Generate "random" XID.

Arguments:

    pSeed -- seed ptr;  from stack or heap, provides differentiation beyond time

Return Value:

    XID generated

--*/
{
    SYSTEMTIME  systemTime;

    //
    //  may have multiple sessions to different processes\threads
    //
    //  use system time hashed in with seed pointer
    //  ptr is first pushed down to count 64-bit boundaries, so lack of
    //      randomness in last 6bits is not preserved
    //

    GetSystemTime( &systemTime );

    //  hash millisecs with arbitrary stack location after knocking off any
    //      64-bit boundary constraints

    return  (WORD)( systemTime.wMilliseconds * (PtrToUlong(pSeed) >> 6) );
}

//
//  End packet.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\print.c ===
/*++

Copyright (c) 1997-2001 Microsoft Corporation

Module Name:

    print.c

Abstract:

    Domain Name System (DNS) Library

    Print routines.

Author:

    Jim Gilroy (jamesg)     February 8, 1997

Revision History:

--*/


#include "local.h"
#include "svcguid.h"                    // RnR guids
#include "..\dnsapi\dnsapip.h"          // Private query stuff
#include "..\resolver\idl\resrpc.h"     // Resolver interface structs


//
//  Print globals
//

CRITICAL_SECTION    DnsAtomicPrintCs;
PCRITICAL_SECTION   pDnsAtomicPrintCs = NULL;

//
//  Empty string for simple switching of UTF-8/Unicode print
//      (macros in dnslib.h)
//

DWORD   DnsEmptyString = 0;


//
//  Indenting
//
//  Serve up as many indenting tabs as indent level indicates
//

CHAR    IndentString[] = "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t";

#define INDENT_STRING( level )  (IndentString + (sizeof(IndentString) - 1 - (level)))



//
//  Print Locking
//
//  Unless caller initilizes print locking by supplying lock,
//  print locking is disabled.
//

VOID
DnsPrint_InitLocking(
    IN      PCRITICAL_SECTION   pLock
    )
/*++

Routine Description:

    Setup DNS printing to use a lock.

    Can use already initialized lock from caller, or will
    create default lock.

Arguments:

    pLock - ptr to CS to use as lock;  if NULL, create one

Return Value:

    None

--*/
{
    if ( pLock )
    {
        pDnsAtomicPrintCs = pLock;
    }
    else if ( !pDnsAtomicPrintCs )
    {
        InitializeCriticalSection( &DnsAtomicPrintCs );
        pDnsAtomicPrintCs = &DnsAtomicPrintCs;
    }
}



VOID
DnsPrint_Lock(
    VOID
    )
/*++

Routine Description:

    Lock to get atomic DNS print.

--*/
{
    if ( pDnsAtomicPrintCs )
    {
        EnterCriticalSection( pDnsAtomicPrintCs );
    }
}


VOID
DnsPrint_Unlock(
    VOID
    )
/*++

Routine Description:

    Unlock to debug print.

--*/
{
    if ( pDnsAtomicPrintCs )
    {
        LeaveCriticalSection( pDnsAtomicPrintCs );
    }
}



//
//  Print routines for general types and structures
//

VOID
DnsPrint_String(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader       OPTIONAL,
    IN      PSTR            pszString,
    IN      BOOL            fUnicode,
    IN      PSTR            pszTrailer      OPTIONAL
    )
/*++

Routine Description:

    Print DNS string given in either Unicode or UTF-8 format.

--*/
{
    if ( !pszHeader )
    {
        pszHeader = "";
    }
    if ( !pszTrailer )
    {
        pszTrailer = "";
    }

    if ( ! pszString )
    {
        PrintRoutine(
            pContext,
            "%s(NULL DNS string ptr)%s",
            pszHeader,
            pszTrailer );
    }
    else if (fUnicode)
    {
        PrintRoutine(
            pContext,
            "%s%S%s",
            pszHeader,
            (PWSTR ) pszString,
            pszTrailer );
    }
    else
    {
        PrintRoutine(
            pContext,
            "%s%s%s",
            pszHeader,
            (PSTR ) pszString,
            pszTrailer );
    }
}



VOID
DnsPrint_StringCharSet(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader       OPTIONAL,
    IN      PSTR            pszString,
    IN      DNS_CHARSET     CharSet,
    IN      PSTR            pszTrailer      OPTIONAL
    )
/*++

Routine Description:

    Print string of given CHARSET.

--*/
{
    DnsPrint_String(
        PrintRoutine,
        pContext,
        pszHeader,
        pszString,
        (CharSet == DnsCharSetUnicode),
        pszTrailer );
}



VOID
DnsPrint_UnicodeStringBytes(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PWCHAR          pUnicode,
    IN      DWORD           Length
    )
/*++

Routine Description:

    Print chars (WORDs) of unicode string.

--*/
{
    DWORD   i;

    PrintRoutine(
        pContext,
        "%s\r\n"
        "\twide string  %S\r\n"
        "\tlength       %d\r\n"
        "\tbytes        ",
        pszHeader,
        pUnicode,
        Length );

    for ( i=0; i<Length; i++ )
    {
        PrintRoutine(
            pContext,
            "%04hx ",
            pUnicode[i] );
    }
    printf( "\r\n" );
}



VOID
DnsPrint_Utf8StringBytes(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PCHAR           pUtf8,
    IN      DWORD           Length
    )
/*++

Routine Description:

    Print bytes of UTF8 string.

--*/
{
    DWORD   i;

    PrintRoutine(
        pContext,
        "%s\r\n"
        "\tUTF8 string  %s\r\n"
        "\tlength       %d\r\n"
        "\tbytes        ",
        pszHeader,
        pUtf8,
        Length );

    for ( i=0; i<Length; i++ )
    {
        PrintRoutine(
            pContext,
            "%02x ",
            (UCHAR) pUtf8[i] );
    }
    printf( "\r\n" );
}



VOID
DnsPrint_StringArray(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PSTR *          StringArray,
    IN      DWORD           Count,          OPTIONAL
    IN      BOOL            fUnicode
    )
/*++

Routine Description:

    Print string array.

--*/
{
    DWORD   i = 0;
    PCHAR   pstr;

    if ( !pszHeader )
    {
        pszHeader = "StringArray:";
    }
    if ( !StringArray )
    {
        PrintRoutine(
            pContext,
            "%s  NULL pointer!\r\n",
            pszHeader );
    }

    DnsPrint_Lock();

    if ( Count )
    {
        PrintRoutine(
            pContext,
            "%s  Count = %d\r\n",
            pszHeader,
            Count );
    }
    else
    {
        PrintRoutine(
            pContext,
            "%s\r\n",
            pszHeader );
    }

    //
    //  print args
    //      - stop at Count (if given)
    //      OR
    //      - on NULL arg (if no count given)
    //

    while ( (!Count || i < Count) )
    {
        pstr = StringArray[i++];
        if ( !pstr && !Count )
        {
            break;
        }
        PrintRoutine(
            pContext,
            (fUnicode) ? "\t%S\r\n" : "\t%s\r\n",
            pstr );
    }

    DnsPrint_Unlock();
}



VOID
DnsPrint_Argv(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      CHAR **         Argv,
    IN      DWORD           Argc,            OPTIONAL
    IN      BOOL            fUnicode
    )
/*++

Routine Description:

    Print Argv array.

--*/
{
    //
    //  this is just special case of string print
    //

    DnsPrint_StringArray(
        PrintRoutine,
        pContext,
        pszHeader
            ? pszHeader
            : "Argv:",
        Argv,
        Argc,
        fUnicode );
}



VOID
DnsPrint_DwordArray(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PSTR            pszName,
    IN      DWORD           dwCount,
    IN      PDWORD          adwArray
    )
/*++

Routine Description:

    Print DWORD array.

--*/
{
    DWORD i;

    DnsPrint_Lock();

    if ( pszHeader )
    {
        PrintRoutine(
            pContext,
            pszHeader );
    }

    if ( !pszName )
    {
        pszName = "DWORD";
    }
    PrintRoutine(
        pContext,
        "%s Array Count = %d\r\n",
        pszName,
        dwCount );

    for( i=0; i<dwCount; i++ )
    {
        PrintRoutine(
            pContext,
            "\t%s[%d] => 0x%p (%d)\r\n",
            pszName,
            i,
            adwArray[i],
            adwArray[i] );
    }

    DnsPrint_Unlock();
}



VOID
DnsPrint_IpAddressArray(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PSTR            pszName,
    IN      DWORD           dwIpAddrCount,
    IN      PIP_ADDRESS     pIpAddrs
    )
/*++

Routine Description:

    Print IP address array.

--*/
{
    DWORD i;

    DnsPrint_Lock();

    if ( !pszName )
    {
        pszName = "IP Addr";
    }
    PrintRoutine(
        pContext,
        "%s%s Count = %d\r\n",
        pszHeader ? pszHeader : "",
        pszName,
        dwIpAddrCount );

    if ( dwIpAddrCount != 0  &&  pIpAddrs != NULL )
    {
        //  print array with count
        //  use character print so works even if NOT DWORD aligned

        for( i=0; i<dwIpAddrCount; i++ )
        {
            PrintRoutine(
                pContext,
                "\t%s[%d] => %d.%d.%d.%d\r\n",
                pszName,
                i,
                * ( (PUCHAR) &pIpAddrs[i] + 0 ),
                * ( (PUCHAR) &pIpAddrs[i] + 1 ),
                * ( (PUCHAR) &pIpAddrs[i] + 2 ),
                * ( (PUCHAR) &pIpAddrs[i] + 3 ) );
        }
    }

#if 0
    //  this spins if printing zero length IP_ARRAY struct

    else if ( pIpAddrs != NULL )
    {
        //  print NULL terminated array (ex. hostents IPs)

        i = 0;
        while ( pIpAddrs[i] )
        {
            PrintRoutine(
                pContext,
                "\t%s[%d] => %s\r\n",
                pszName,
                i,
                inet_ntoa( *(struct in_addr *) &pIpAddrs[i] ) );
        }
    }
#endif

    DnsPrint_Unlock();
}



VOID
DnsPrint_IpArray(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PSTR            pszName,
    IN      PIP_ARRAY       pIpArray
    )
/*++

Routine Description:

    Print IP address array struct

    Just pass through to more generic print routine.

--*/
{
    //  protect against NULL case

    if ( !pIpArray )
    {
        PrintRoutine(
            pContext,
            "%s\tNULL IP Array.\r\n",
            pszHeader ? pszHeader : "" );
    }

    //  call uncoupled IP array routine

    else
    {
        DnsPrint_IpAddressArray(
            PrintRoutine,
            pContext,
            pszHeader,
            pszName,
            pIpArray->AddrCount,
            pIpArray->AddrArray );
    }
}



VOID
DnsPrint_DnsAddrArray(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pContext,
    IN      PSTR                pszHeader,
    IN      PDNS_ADDR_ARRAY     pAddrArray
    )
/*++

Routine Description:

    Print IP address info array.

--*/
{
    DWORD i;

    if ( !pszHeader )
    {
        pszHeader = "Addr Array";
    }
    if ( !pAddrArray )
    {
        PrintRoutine(
            pContext,
            "%s NULL AddrArray ptr.\r\n",
            pszHeader );
        return;
    }

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "%s\r\n"
        "  Ptr   = %p\r\n"
        "  Count = %d\r\n",
        pszHeader ? pszHeader : "IP Address Info",
        pAddrArray,
        pAddrArray->AddrCount );

    //
    //  print array up to count
    //
    //  DCR:  IP6 address info blob
    //

    for( i=0; i<pAddrArray->AddrCount; i++ )
    {
        IP_ADDRESS ip = pAddrArray->AddrArray[i].IpAddr;
        IP_ADDRESS subnetMask = pAddrArray->AddrArray[i].SubnetMask;

        PrintRoutine(
            pContext,
            "\tIP Address[%d] => %d.%d.%d.%d\r\n"
            "\tSubnetMask[%d] => %d.%d.%d.%d\r\n",
            i,
            (ip & 0xff),
            ((ip>>8) & 0xff),
            ((ip>>16) & 0xff),
            ((ip>>24) & 0xff),
            i,
            (subnetMask & 0xff),
            ((subnetMask>>8) & 0xff),
            ((subnetMask>>16) & 0xff),
            ((subnetMask>>24) & 0xff)
            );
    }
    
    DnsPrint_Unlock();
}



VOID
DnsPrint_Ip6Address(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pContext,
    IN      PSTR                pszHeader,
    IN      PIP6_ADDRESS        pIp6Address,
    IN      PSTR                pszTrailer
    )
/*++

Routine Description:

    Print IP6 address.

Arguments:

    PrintRoutine -- print routine to call

    pContext -- first argument to print routine

    pszHeader -- header to print
        NOTE:  unlike other print routines this routine
        requires header to contain newline,tab, etc if
        multiline print is desired;  the reason is to allow
        use of this routine for single line print

    pIp6Address -- ptr to IP6 address to print

    pszTrailer -- trailer to print
        NOTE:  again this routine is designed to allow single
        line print;  if newline required after print, send
        newline in trailer

Return Value:

    Ptr to next location in buffer (the terminating NULL).

--*/
{
    CHAR    buffer[ IP6_ADDRESS_STRING_BUFFER_LENGTH ];

    if ( !pszHeader )
    {
        pszHeader = "IP6 Address: ";
    }
    if ( !pszTrailer )
    {
        pszHeader = "\r\n";
    }

    if ( !pIp6Address )
    {
        PrintRoutine(
            pContext,
            "%s NULL IP6 address ptr.%s",
            pszHeader,
            pszTrailer );
    }

    //  convert IP6 address to string

    Dns_Ip6AddressToString_A(
           buffer,
           pIp6Address );

    PrintRoutine(
        pContext,
        "%s%s%s",
        pszHeader,
        buffer,
        pszTrailer );
}



//
//  Print routines for DNS types and structures
//

INT
Dns_WritePacketNameToBuffer(
    OUT     PCHAR           pBuffer,
    OUT     PCHAR *         ppBufferOut,
    IN      PBYTE           pMsgName,
    IN      PDNS_HEADER     pMsgHead,       OPTIONAL
    IN      PBYTE           pMsgEnd         OPTIONAL
    )
/*++

Routine Description:

    Write packet name into buffer.

Arguments:

    pBuffer -       buffer to print to,
                    bounds checking done only on each loop to limit to
                    twice DNS_MAX_NAME_LENGTH, recommend input buffer
                    of at least that length

    ppBufferOut -   ptr to terminating NULL in buffer conversion, this
                    is position at which additional printing to buffer
                    could resume

    pMsgName -      ptr to name in packet to print

    pMsgHead -      ptr to DNS message;  need for offsetting, if not given
                    names are not printed past first offset

    pMsgEnd -       ptr to end of message, specifically byte immediately after
                    message

Return Value:

    Count of bytes in packet name occupied.
    This offset from pMsgName is the next field in the packet.

    Zero return indicates error in message name.

--*/
{
    register PUCHAR pchbuf;
    register PUCHAR pchmsg;
    register UCHAR  cch;
    PCHAR           pbufStop;
    PCHAR           pnextLabel;
    UCHAR           compressionType;
    WORD            offset;
    PCHAR           pbyteAfterFirstOffset = NULL;

    //
    //  no message end specified?
    //  make it max ptr so we can do single test for ptr validity
    //  rather than testing for pMsgEnd existence first
    //

    if ( !pMsgEnd )
    {
        pMsgEnd = (PVOID)(INT_PTR)(-1);
    }

    //
    //  loop until copy as printable name, or hit compression or name error
    //

    pchbuf = pBuffer;
    pbufStop = pchbuf + DNS_MAX_NAME_LENGTH + DNS_MAX_LABEL_LENGTH;
    pchmsg = pMsgName;

    while ( 1 )
    {
        //  bounds checking to survive bad packet
        //
        //  DEVNOTE:  note this is not strictly a bad packet (could be just a
        //      heck of a lot of labels) and we could
        //          a) let packet processing proceed without printing
        //          or
        //          b) require buffer that could contain max legal DNS name
        //      but not worth the effort

        if ( pchbuf >= pbufStop )
        {
            pchbuf += sprintf(
                        pchbuf,
                        "[ERROR name exceeds safe print buffer length]\r\n" );
            pchmsg = pMsgName;
            break;
        }

        cch = (UCHAR) *pchmsg++;
        compressionType = cch & 0xC0;

        DNSDBG( OFF, (
            "byte = (%d) (0x%02x)\r\n"
            "compress flag = (%d) (0x%02x)\r\n",
            cch, cch,
            compressionType, compressionType ));

        //
        //  normal length byte
        //      - write length field
        //      - copy label to print buffer
        //

        if ( compressionType == 0 )
        {
            pchbuf += sprintf( pchbuf, "(%d)", (INT)cch );

            //  terminate at root name

            if ( ! cch )
            {
                break;
            }

            //  check that within packet

            pnextLabel = pchmsg + cch;
            if ( pnextLabel >= pMsgEnd )
            {
                pchbuf += sprintf(
                            pchbuf,
                            "[ERROR length byte: 0x%02X at %p leads outside message]\r\n",
                            cch,
                            pchmsg );

                //  force zero byte return

                pchmsg = pMsgName;
                break;
            }

            //  copy label to output string

            memcpy(
                pchbuf,
                pchmsg,
                cch );

            pchbuf += cch;
            pchmsg = pnextLabel;
            continue;
        }

        //
        //  valid compression
        //

        else if ( compressionType == (UCHAR)0xC0 )
        {
            //  check that compression word not straddling message end

            if ( pchmsg >= pMsgEnd )
            {
                pchbuf += sprintf(
                            pchbuf,
                            "[ERROR compression word at %p is outside message]\r\n",
                            pchmsg );

                //  force zero byte return

                pchmsg = pMsgName;
                break;
            }

            //  calculate offset

            offset = cch;          // high byte
            offset <<= 8;
            offset |= *pchmsg++;   // low byte

            pchbuf += sprintf(
                        pchbuf,
                        "[%04hX]",
                        offset );

            if ( pMsgHead )
            {
                //
                //  on first compression, save ptr to byte immediately after
                //      name, so can calculate next byte
                //
                //  save ptr to next byte in mess, to calculate actual length
                //      name takes up in packet
                //

                if ( ! pbyteAfterFirstOffset )
                {
                    pbyteAfterFirstOffset = pchmsg;
                }

                //
                //  jump to offset for continuation of name
                //      - clear two highest bits to get length
                //

                offset = offset ^ 0xC000;
                DNS_ASSERT( (offset & 0xC000) == 0 );

                pnextLabel = (PCHAR)pMsgHead + offset;
                if ( pnextLabel >= pchmsg - sizeof(WORD) )
                {
                    pchbuf += sprintf(
                                pchbuf,
                                "[ERROR offset at %p to higher byte in packet %p]\r\n",
                                pchmsg - sizeof(WORD),
                                pnextLabel );
                    break;
                }
                pchmsg = pnextLabel;
                continue;
            }

            //  if no ptr to message head, can not continue at offset
            //  NULL terminate previous label

            else
            {
                *pchbuf++ = 0;
                break;
            }
        }

        //
        //  invalid compression
        //      - force zero byte return to indicate error

        else
        {
            pchbuf += sprintf(
                        pchbuf,
                        "[ERROR length byte: 0x%02X]",
                        cch );
            pchmsg = pMsgName;
            break;
        }
    }

    //
    //  return ptr to next position in output buffer
    //

    if ( ppBufferOut )
    {
        *ppBufferOut = pchbuf;
    }

    //
    //  return number of bytes read from message
    //

    if ( pbyteAfterFirstOffset )
    {
        pchmsg = pbyteAfterFirstOffset;
    }
    return (INT)( pchmsg - pMsgName );
}



INT
DnsPrint_PacketName(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,      OPTIONAL
    IN      PBYTE           pMsgName,
    IN      PDNS_HEADER     pMsgHead,       OPTIONAL
    IN      PBYTE           pMsgEnd,        OPTIONAL
    IN      PSTR            pszTrailer      OPTIONAL
    )
/*++

Routine Description:

    Print DNS name given in packet format.

Arguments:

    PrintRoutine -  routine to print with

    pszHeader -     header to print

    pMsgHead -      ptr to DNS message;  need for offsetting, if not given
                    names are not printed past first offset

    pMsgName -      ptr to name in packet to print

    pMsgEnd -       ptr to end of message;  OPTIONAL, but needed to protect
                    against AV accessing bad packet names

    pszTrailer -    trailer to print after name

Return Value:

    Count of bytes in packet name occupied.
    This offset from pMsgName is the next field in the packet.

    Zero return indicates error in message name.

--*/
{
    INT     countNameBytes;

    //  name buffer, allow space for full name, plus parens on length
    //  fields plus several compression flags

    CHAR    PrintName[ 2*DNS_MAX_NAME_LENGTH ];


    if ( ! pMsgName )
    {
        PrintRoutine(
            pContext,
            "%s(NULL packet name ptr)%s\r\n",
            pszHeader ? pszHeader : "",
            pszTrailer ? pszTrailer : ""
            );
        return 0;
    }

    //
    //  build packet name into buffer, then print
    //

    countNameBytes = Dns_WritePacketNameToBuffer(
                        PrintName,
                        NULL,
                        pMsgName,
                        pMsgHead,
                        pMsgEnd
                        );
    PrintRoutine(
        pContext,
        "%s%s%s",
        pszHeader ? pszHeader : "",
        PrintName,
        pszTrailer ? pszTrailer : ""
        );

    return( countNameBytes );
}



VOID
DnsPrint_Message(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PDNS_MSG_BUF    pMsg
    )
/*++

Routine Description:

    Print DNS message buffer.
    Includes context information as well as actual DNS message.

--*/
{
    PDNS_HEADER pmsgHeader;
    PCHAR       pchRecord;
    PBYTE       pmsgEnd;
    INT         i;
    INT         isection;
    INT         cchName;
    WORD        wLength;
    WORD        wOffset;
    WORD        wXid;
    WORD        wQuestionCount;
    WORD        wAnswerCount;
    WORD        wNameServerCount;
    WORD        wAdditionalCount;
    WORD        countSectionRR;
    BOOL        fFlipped = FALSE;

    DnsPrint_Lock();

    if ( pszHeader )
    {
        PrintRoutine(
            pContext,
            "%s\r\n",
            pszHeader );
    }

    //  get message info
    //
    //  note:  length may not be correctly set while building message,
    //      so make pmsgEnd greater of given length and pCurrent ptr
    //      but allow for case where set back to pre-OPT length
    //

    wLength = pMsg->MessageLength;
    pmsgHeader = &pMsg->MessageHead;
    pmsgEnd = ((PBYTE)pmsgHeader) + wLength;

    if ( pmsgEnd < pMsg->pCurrent &&
         pmsgEnd != pMsg->pPreOptEnd )
    {
        pmsgEnd = pMsg->pCurrent;
    }

    //
    //  print header info
    //

    PrintRoutine(
        pContext,
        "%s %s info at %p\r\n"
        "  Socket = %d\r\n"
        "  Remote addr %s, port %ld\r\n"
        "  Buf length = 0x%04x\r\n"
        "  Msg length = 0x%04x\r\n"
        "  Message:\r\n",
        ( pMsg->fTcp
            ? "TCP"
            : "UDP" ),
        ( pmsgHeader->IsResponse
            ? "response"
            : "question" ),
        pMsg,
        pMsg->Socket,
        MSG_REMOTE_IP_STRING( pMsg ),
        MSG_REMOTE_IP_PORT( pMsg ),
        pMsg->BufferLength,
        wLength
        );

    PrintRoutine(
        pContext,
        "    XID       0x%04hx\r\n"
        "    Flags     0x%04hx\r\n"
        "        QR        0x%lx (%s)\r\n"
        "        OPCODE    0x%lx (%s)\r\n"
        "        AA        0x%lx\r\n"
        "        TC        0x%lx\r\n"
        "        RD        0x%lx\r\n"
        "        RA        0x%lx\r\n"
        "        Z         0x%lx\r\n"
        "        RCODE     0x%lx (%s)\r\n"
        "    QCOUNT    0x%hx\r\n"
        "    ACOUNT    0x%hx\r\n"
        "    NSCOUNT   0x%hx\r\n"
        "    ARCOUNT   0x%hx\r\n",

        pmsgHeader->Xid,
        ntohs((*((PWORD)pmsgHeader + 1))),

        pmsgHeader->IsResponse,
        (pmsgHeader->IsResponse ? "response" : "question"),
        pmsgHeader->Opcode,
        Dns_OpcodeString( pmsgHeader->Opcode ),
        pmsgHeader->Authoritative,
        pmsgHeader->Truncation,
        pmsgHeader->RecursionDesired,
        pmsgHeader->RecursionAvailable,
        pmsgHeader->Reserved,
        pmsgHeader->ResponseCode,
        Dns_ResponseCodeString( pmsgHeader->ResponseCode ),

        pmsgHeader->QuestionCount,
        pmsgHeader->AnswerCount,
        pmsgHeader->NameServerCount,
        pmsgHeader->AdditionalCount );

    //
    //  determine if byte flipped and get correct count
    //

    wXid                = pmsgHeader->Xid;
    wQuestionCount      = pmsgHeader->QuestionCount;
    wAnswerCount        = pmsgHeader->AnswerCount;
    wNameServerCount    = pmsgHeader->NameServerCount;
    wAdditionalCount    = pmsgHeader->AdditionalCount;

    if ( wQuestionCount )
    {
        fFlipped = wQuestionCount & 0xff00;
    }
    else if ( wNameServerCount )
    {
        fFlipped = wNameServerCount & 0xff00;
    }
    if ( fFlipped )
    {
        wXid                = ntohs( wXid );
        wQuestionCount      = ntohs( wQuestionCount );
        wAnswerCount        = ntohs( wAnswerCount );
        wNameServerCount    = ntohs( wNameServerCount );
        wAdditionalCount    = ntohs( wAdditionalCount );
    }

    //
    //  catch record flipping problems -- all are flipped or none at all
    //      and no record count should be > 256 EXCEPT answer count
    //      during FAST zone transfer
    //

    DNS_ASSERT( ! (wQuestionCount & 0xff00) );
    DNS_ASSERT( ! (wNameServerCount & 0xff00) );
    DNS_ASSERT( ! (wAdditionalCount & 0xff00) );

#if 0
    //
    //  stop here if WINS response -- don't have parsing ready
    //

    if ( pmsgHeader->IsResponse && IS_WINS_XID(wXid) )
    {
        PrintRoutine(
            pContext,
            "  WINS Response packet.\r\n\r\n" );
        goto Unlock;
    }
#endif

    //
    //  print questions and resource records
    //

    pchRecord = (PCHAR)(pmsgHeader + 1);

    for ( isection=0; isection<4; isection++)
    {
        PrintRoutine(
            pContext,
            "  %s Section:\r\n",
            Dns_SectionNameString( isection, pmsgHeader->Opcode ) );

        if ( isection==0 )
        {
            countSectionRR = wQuestionCount;
        }
        else if ( isection==1 )
        {
            countSectionRR = wAnswerCount;
        }
        else if ( isection==2 )
        {
            countSectionRR = wNameServerCount;
        }
        else if ( isection==3 )
        {
            countSectionRR = wAdditionalCount;
        }

        for ( i=0; i < countSectionRR; i++ )
        {
            //
            //  verify not overrunning length
            //      - check against pCurrent as well as message length
            //        so can print packets while being built
            //

            wOffset = (WORD)(pchRecord - (PCHAR)pmsgHeader);
            if ( wOffset >= wLength
                    &&
                pchRecord >= pMsg->pCurrent )
            {
                PrintRoutine(
                    pContext,
                    "ERROR:  BOGUS PACKET:\r\n"
                    "\tFollowing RR (offset %d) past packet length (%d).\r\n",
                    wOffset,
                    wLength
                    );
                goto Unlock;
            }

            //
            //  print RR name
            //

            PrintRoutine(
                pContext,
                "    Name Offset = 0x%04x\r\n",
                wOffset
                );

            cchName = DnsPrint_PacketName(
                            PrintRoutine,
                            pContext,
                            "    Name      \"",
                            pchRecord,
                            pmsgHeader,
                            pmsgEnd,
                            "\"\r\n" );
            if ( ! cchName )
            {
                PrintRoutine(
                    pContext,
                    "ERROR:  Invalid name length, stop packet print\r\n" );
                DNS_ASSERT( FALSE );
                break;
            }
            pchRecord += cchName;

            //  print question or resource record

            if ( isection == 0 )
            {
                PrintRoutine(
                    pContext,
                    "      QTYPE   %d\r\n"
                    "      QCLASS  %d\r\n",
                    FlipUnalignedWord( pchRecord ),
                    FlipUnalignedWord( pchRecord + sizeof(WORD) )
                    );
                pchRecord += sizeof( DNS_WIRE_QUESTION );
            }
            else
            {
                pchRecord += DnsPrint_PacketRecord(
                                PrintRoutine,
                                pContext,
                                NULL,
                                (PDNS_WIRE_RECORD) pchRecord,
                                pmsgHeader,
                                pmsgEnd
                                );
            }
        }
    }

    //  check that at proper end of packet

    wOffset = (WORD)(pchRecord - (PCHAR)pmsgHeader);
    if ( pchRecord < pMsg->pCurrent || wOffset < wLength )
    {
        PrintRoutine(
            pContext,
            "WARNING:  message continues beyond these records\r\n"
            "\tpch = %p, pCurrent = %p, %d bytes\r\n"
            "\toffset = %d, msg length = %d, %d bytes\r\n",
            pchRecord,
            pMsg->pCurrent,
            pMsg->pCurrent - pchRecord,
            wOffset,
            wLength,
            wLength - wOffset );
    }
    PrintRoutine(
        pContext,
        "  Message length = %04x\n\r\n",
        wOffset );

Unlock:
    DnsPrint_Unlock();


}   // DnsPrint_Message



INT
DnsPrint_PacketRecord(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pContext,
    IN      PSTR                pszHeader,
    IN      PDNS_WIRE_RECORD    pMsgRR,
    IN      PDNS_HEADER         pMsgHead,       OPTIONAL
    IN      PBYTE               pMsgEnd         OPTIONAL
    )
/*++

Routine Description:

    Print RR in packet format.

Arguments:

    pszHeader - Header message/name for RR.

    pMsgRR    - resource record to print

    pMsgHead  - ptr to DNS message;  need for offsetting, if not given
                names are not printed past first offset

    pMsgEnd   - ptr to end of message, specifically byte immediately after
                message

Return Value:

    Number of bytes in record.

--*/
{
    PCHAR   pdata = (PCHAR)(pMsgRR + 1);
    PCHAR   pdataStop;
    WORD    dlen = FlipUnalignedWord( &pMsgRR->DataLength );
    WORD    type;
    PCHAR   pRRString;

    DnsPrint_Lock();

    //
    //  print RR fixed fields
    //

    type = FlipUnalignedWord( &pMsgRR->RecordType );
    pRRString = Dns_RecordStringForType( type );

    if ( pszHeader )
    {
        PrintRoutine(
            pContext,
            "%s\r\n",
            pszHeader );
    }
    PrintRoutine(
        pContext,
        "      TYPE   %s  (%u)\r\n"
        "      CLASS  %u\r\n"
        "      TTL    %lu\r\n"
        "      DLEN   %u\r\n"
        "      DATA   ",
        pRRString,
        type,
        FlipUnalignedWord( &pMsgRR->RecordClass ),
        FlipUnalignedDword( &pMsgRR->TimeToLive ),
        dlen );

    //
    //  update records may not have data
    //

    if ( dlen == 0 )
    {
        PrintRoutine(
            pContext,
            "(none)\r\n" );
        goto Done;
    }

    //  stop byte after RR data

    pdataStop = pdata + dlen;
    if ( pMsgEnd < pdataStop )
    {
        PrintRoutine(
            pContext,
            "ERROR:  record at %p extends past end of packet!\n"
            "\tpmsg             = %p\n"
            "\tpmsgEnd          = %p\n"
            "\trecord end       = %p\n",
            pMsgRR,
            pMsgHead,
            pMsgEnd,
            pdataStop );
        goto Done;
    }

    //
    //  print RR data
    //

    switch ( type )
    {

    case DNS_TYPE_A:

        PrintRoutine(
            pContext,
            "%d.%d.%d.%d\r\n",
            * (PUCHAR)( pdata + 0 ),
            * (PUCHAR)( pdata + 1 ),
            * (PUCHAR)( pdata + 2 ),
            * (PUCHAR)( pdata + 3 )
            );
        break;

    case DNS_TYPE_AAAA:
    {
        IP6_ADDRESS ip6;

        RtlCopyMemory(
            &ip6,
            pdata,
            sizeof(ip6) );

        PrintRoutine(
            pContext,
            "%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x\n",
            ip6.IP6Word[0],
            ip6.IP6Word[1],
            ip6.IP6Word[2],
            ip6.IP6Word[3],
            ip6.IP6Word[4],
            ip6.IP6Word[5],
            ip6.IP6Word[6],
            ip6.IP6Word[7]
            );
        break;
    }

    case DNS_TYPE_PTR:
    case DNS_TYPE_NS:
    case DNS_TYPE_CNAME:
    case DNS_TYPE_MD:
    case DNS_TYPE_MB:
    case DNS_TYPE_MF:
    case DNS_TYPE_MG:
    case DNS_TYPE_MR:

        //
        //  these RRs contain single domain name
        //

        DnsPrint_PacketName(
            PrintRoutine,
            pContext,
            NULL,
            pdata,
            pMsgHead,
            pMsgEnd,
            "\r\n" );
        break;

    case DNS_TYPE_MX:
    case DNS_TYPE_RT:
    case DNS_TYPE_AFSDB:

        //
        //  these RR contain
        //      - one preference value
        //      - one domain name
        //

        PrintRoutine(
            pContext,
            "%d ",
            FlipUnalignedWord( pdata )
            );
        DnsPrint_PacketName(
            PrintRoutine,
            pContext,
            NULL,
            pdata + sizeof(WORD),
            pMsgHead,
            pMsgEnd,
            "\r\n" );
        break;

    case DNS_TYPE_SOA:

        pdata += DnsPrint_PacketName(
                        PrintRoutine,
                        pContext,
                        "\r\n\t\tPrimaryServer: ",
                        pdata,
                        pMsgHead,
                        pMsgEnd,
                        NULL );
        pdata += DnsPrint_PacketName(
                        PrintRoutine,
                        pContext,
                        "\r\n\t\tAdministrator: ",
                        pdata,
                        pMsgHead,
                        pMsgEnd,
                        "\r\n" );
        PrintRoutine(
            pContext,
            "\t\tSerialNo     = %d\r\n"
            "\t\tRefresh      = %d\r\n"
            "\t\tRetry        = %d\r\n"
            "\t\tExpire       = %d\r\n"
            "\t\tMinimumTTL   = %d\r\n",
            FlipUnalignedDword( pdata ),
            FlipUnalignedDword( (PDWORD)pdata+1 ),
            FlipUnalignedDword( (PDWORD)pdata+2 ),
            FlipUnalignedDword( (PDWORD)pdata+3 ),
            FlipUnalignedDword( (PDWORD)pdata+4 )
            );
        break;

    case DNS_TYPE_MINFO:
    case DNS_TYPE_RP:

        //
        //  these RRs contain two domain names
        //

        pdata += DnsPrint_PacketName(
                        PrintRoutine,
                        pContext,
                        NULL,
                        pdata,
                        pMsgHead,
                        pMsgEnd,
                        NULL );
        DnsPrint_PacketName(
            PrintRoutine,
            pContext,
            "  ",
            pdata,
            pMsgHead,
            pMsgEnd,
            "\r\n" );
        break;

    case DNS_TYPE_TEXT:
    case DNS_TYPE_HINFO:
    case DNS_TYPE_ISDN:
    case DNS_TYPE_X25:
    {
        //
        //  all these are simply text string(s)
        //

        PCHAR   pch = pdata;
        PCHAR   pchStop = pch + dlen;
        UCHAR   cch;

        while ( pch < pchStop )
        {
            cch = (UCHAR) *pch++;

            PrintRoutine(
                pContext,
                "\t%.*s\r\n",
                 cch,
                 pch );

            pch += cch;
        }
        if ( pch != pchStop )
        {
            PrintRoutine(
                pContext,
                "ERROR:  Bad RR.  "
                "Text strings do not add to RR length.\r\n" );
        }
        break;
    }

    case DNS_TYPE_WKS:
    {
        INT i;

        PrintRoutine(
            pContext,
            "WKS: Address %d.%d.%d.%d\r\n"
            "\t\tProtocol %d\r\n"
            "\t\tBitmask\r\n",
            * (PUCHAR)( pdata + 0 ),
            * (PUCHAR)( pdata + 1 ),
            * (PUCHAR)( pdata + 2 ),
            * (PUCHAR)( pdata + 3 ),
            * (PUCHAR)( pdata + 4 ) );

        pdata += SIZEOF_WKS_FIXED_DATA;

        for ( i=0;  i < (INT)(dlen-SIZEOF_WKS_FIXED_DATA);  i++ )
        {
            PrintRoutine(
                pContext,
                "\t\t\tbyte[%d] = %x\r\n",
                i,
                (UCHAR) pdata[i] );
        }
        break;
    }

    case DNS_TYPE_NULL:

        DnsPrint_RawOctets(
            PrintRoutine,
            pContext,
            NULL,
            "\t\t",
            pdata,
            dlen );
        break;

    case DNS_TYPE_SRV:

        //  SRV <priority> <weight> <port> <target host>

        PrintRoutine(
            pContext,
            "\t\tPriority     = %d\r\n"
            "\t\tWeight       = %d\r\n"
            "\t\tPort         = %d\r\n",
            FlipUnalignedWord( pdata ),
            FlipUnalignedWord( (PWORD)pdata+1 ),
            FlipUnalignedWord( (PWORD)pdata+2 )
            );
        DnsPrint_PacketName(
            PrintRoutine,
            pContext,
            "\t\tTarget host ",
            pdata + 3*sizeof(WORD),
            pMsgHead,
            pMsgEnd,
            "\r\n" );
        break;

    case DNS_TYPE_OPT:

        //
        //  OPT
        //      - RR class is buffer size
        //      - RR TTL contains
        //          <extended RCODE> low byte
        //          <version> second byte
        //          <flags-zero> high word
        //

        {
            BYTE    version;
            BYTE    extendedRcode;
            DWORD   fullRcode = 0;
            WORD    flags;

            extendedRcode = *( (PBYTE) &pMsgRR->TimeToLive );
            version = *( (PBYTE) &pMsgRR->TimeToLive + 1 );
            flags = *( (PWORD) &pMsgRR->TimeToLive + 1 );

            if ( pMsgHead->ResponseCode )
            {
                fullRcode = ((DWORD)extendedRcode << 4) +
                            (DWORD)pMsgHead->ResponseCode;
            }

            PrintRoutine(
                pContext,
                "\t\tBuffer Size  = %d\r\n"
                "\t\tRcode Ext    = %d (%x)\r\n"
                "\t\tRcode Full   = %d\r\n"
                "\t\tVersion      = %d\r\n"
                "\t\tFlags        = %x\r\n",
                FlipUnalignedWord( &pMsgRR->RecordClass ),
                extendedRcode, extendedRcode,
                fullRcode,
                version,
                flags );
        }
        break;

    case DNS_TYPE_TKEY:
    {
        DWORD   beginTime;
        DWORD   expireTime;
        WORD    keyLength;
        WORD    mode;
        WORD    extRcode;
        WORD    otherLength;

        otherLength = (WORD)DnsPrint_PacketName(
                                PrintRoutine,
                                pContext,
                                "\r\n\t\tAlgorithm:     ",
                                pdata,
                                pMsgHead,
                                pMsgEnd,
                                NULL );
        if ( !otherLength )
        {
            PrintRoutine(
                pContext,
                "Invalid algorithm name in TKEY RR!\r\n" );
        }
        pdata += otherLength;

        beginTime = InlineFlipUnalignedDword( pdata );
        pdata += sizeof(DWORD);
        expireTime = InlineFlipUnalignedDword( pdata );
        pdata += sizeof(DWORD);

        mode = InlineFlipUnalignedWord( pdata );
        pdata += sizeof(WORD);
        extRcode = InlineFlipUnalignedWord( pdata );
        pdata += sizeof(WORD);
        keyLength = InlineFlipUnalignedWord( pdata );
        pdata += sizeof(WORD);

        PrintRoutine(
            pContext,
            "\r\n"
            "\t\tCreate time    = %d\r\n"
            "\t\tExpire time    = %d\r\n"
            "\t\tMode           = %d\r\n"
            "\t\tExtended RCODE = %d\r\n"
            "\t\tKey Length     = %d\r\n",
            beginTime,
            expireTime,
            mode,
            extRcode,
            keyLength );

        if ( pdata + keyLength > pdataStop )
        {
            PrintRoutine(
                pContext,
                "Invalid key length:  exceeds record data!\r\n" );
            break;
        }
        DnsPrint_RawOctets(
            PrintRoutine,
            pContext,
            "\t\tKey:",
            "\t\t  ",       // line header
            pdata,
            keyLength );

        pdata += keyLength;
        if ( pdata + sizeof(WORD) > pdataStop )
        {
            break;
        }
        otherLength = InlineFlipUnalignedWord( pdata );
        pdata += sizeof(WORD);

        PrintRoutine(
            pContext,
            "\r\n"
            "\t\tOther Length   = %d\r\n",
            otherLength );

        if ( pdata + otherLength > pdataStop )
        {
            PrintRoutine(
                pContext,
                "Invalid other data length:  exceeds record data!\r\n" );
            break;
        }
        DnsPrint_RawOctets(
            PrintRoutine,
            pContext,
            "\t\tOther Data:",
            "\t\t  ",           // line header
            pdata,
            otherLength );
        break;
    }

    case DNS_TYPE_TSIG:
    {
        ULONGLONG   signTime;
        WORD        fudgeTime;
        WORD        sigLength;
        WORD        extRcode;
        WORD        wOriginalId;
        WORD        otherLength;

        otherLength = (WORD) DnsPrint_PacketName(
                                PrintRoutine,
                                pContext,
                                "\r\n\t\tAlgorithm:     ",
                                pdata,
                                pMsgHead,
                                pMsgEnd,
                                NULL );
        if ( !otherLength )
        {
            PrintRoutine(
                pContext,
                "Invalid algorithm name in TSIG RR!\r\n" );
        }
        pdata += otherLength;

        signTime = InlineFlipUnaligned48Bits( pdata );
        pdata += sizeof(DWORD) + sizeof(WORD);

        fudgeTime = InlineFlipUnalignedWord( pdata );
        pdata += sizeof(WORD);

        sigLength = InlineFlipUnalignedWord( pdata );
        pdata += sizeof(WORD);

        PrintRoutine(
            pContext,
            "\r\n"
            "\t\tSigned time    = %I64u\r\n"
            "\t\tFudge time     = %u\r\n"
            "\t\tSig Length     = %u\r\n",
            signTime,
            fudgeTime,
            sigLength );

        if ( pdata + sigLength > pdataStop )
        {
            PrintRoutine(
                pContext,
                "Invalid signature length:  exceeds record data!\r\n" );
            break;
        }
        DnsPrint_RawOctets(
            PrintRoutine,
            pContext,
            "\t\tSignature:",
            "\t\t  ",           // line header
            pdata,
            sigLength );

        pdata += sigLength;
        if ( pdata + sizeof(DWORD) > pdataStop )
        {
            break;
        }
        wOriginalId = InlineFlipUnalignedWord( pdata );
        pdata += sizeof(WORD);

        extRcode = InlineFlipUnalignedWord( pdata );
        pdata += sizeof(WORD);

        otherLength = InlineFlipUnalignedWord( pdata );
        pdata += sizeof(WORD);

        PrintRoutine(
            pContext,
            "\r\n"
            "\t\tOriginal XID   = %x\r\n"
            "\t\tExtended RCODE = %u\r\n"
            "\t\tOther Length   = %u\r\n",
            wOriginalId,
            extRcode,
            otherLength );

        if ( pdata + otherLength > pdataStop )
        {
            PrintRoutine(
                pContext,
                "Invalid other data length:  exceeds record data!\r\n" );
            break;
        }
        DnsPrint_RawOctets(
            PrintRoutine,
            pContext,
            "\t\tOther Data:",
            "\t\t  ",           // line header
            pdata,
            otherLength );
        break;
    }

    case DNS_TYPE_WINS:
    {
        DWORD   i;
        DWORD   winsFlags;
        DWORD   lookupTimeout;
        DWORD   cacheTimeout;
        DWORD   winsCount;
        CHAR    flagString[ WINS_FLAG_MAX_LENGTH ];

        //
        //  WINS
        //      - scope/domain mapping flag
        //      - lookup timeout
        //      - cache timeout
        //      - WINS server count
        //      - WINS server list
        //

        winsFlags = FlipUnalignedDword( pdata );
        pdata += sizeof(DWORD);
        lookupTimeout = FlipUnalignedDword( pdata );
        pdata += sizeof(DWORD);
        cacheTimeout = FlipUnalignedDword( pdata );
        pdata += sizeof(DWORD);
        winsCount = FlipUnalignedDword( pdata );
        pdata += sizeof(DWORD);

        Dns_WinsRecordFlagString(
            winsFlags,
            flagString );

        PrintRoutine(
            pContext,
            "\r\n"
            "\t\tWINS flags     = %s (%08x)\r\n"
            "\t\tLookup timeout = %d\r\n"
            "\t\tCaching TTL    = %d\r\n",
            flagString,
            winsFlags,
            lookupTimeout,
            cacheTimeout );

        if ( pdata + (winsCount * SIZEOF_IP_ADDRESS) > pdataStop )
        {
            PrintRoutine(
                pContext,
                "ERROR:  WINS server count leads beyond record data length!\n"
                "\tpmsg             = %p\n"
                "\tpmsgEnd          = %p\n"
                "\tpRR              = %p\n"
                "\trecord data end  = %p\n"
                "\twins count       = %d\n"
                "\tend of wins IPs  = %p\n",
                pMsgHead,
                pMsgEnd,
                pMsgRR,
                pdataStop,
                winsCount,
                pdata + (winsCount * SIZEOF_IP_ADDRESS)
                );
            goto Done;
        }

        DnsPrint_IpAddressArray(
            PrintRoutine,
            pContext,
            NULL,
            "\tWINS",
            winsCount,
            (PIP_ADDRESS) pdata );
        break;
    }

    case DNS_TYPE_WINSR:
    {
        DWORD   winsFlags;
        DWORD   lookupTimeout;
        DWORD   cacheTimeout;
        CHAR    flagString[ WINS_FLAG_MAX_LENGTH ];

        //
        //  NBSTAT
        //      - scope/domain mapping flag
        //      - lookup timeout
        //      - cache timeout
        //      - result domain -- optional
        //

        winsFlags = FlipUnalignedDword( pdata );
        pdata += sizeof(DWORD);
        lookupTimeout = FlipUnalignedDword( pdata );
        pdata += sizeof(DWORD);
        cacheTimeout = FlipUnalignedDword( pdata );
        pdata += sizeof(DWORD);

        Dns_WinsRecordFlagString(
            winsFlags,
            flagString );

        PrintRoutine(
            pContext,
            "\r\n"
            "\t\tWINS-R flags   = %s (%08x)\r\n"
            "\t\tLookup timeout = %d\r\n"
            "\t\tCaching TTL    = %d\r\n",
            flagString,
            winsFlags,
            lookupTimeout,
            cacheTimeout );

        DnsPrint_PacketName(
            PrintRoutine,
            pContext,
            "\t\tResult domain  = ",
            pdata,
            pMsgHead,
            pMsgEnd,
            "\r\n" );
        break;
    }
    
    case DNS_TYPE_KEY:
    {
        WORD    flags;
        BYTE    protocol;
        BYTE    algorithm;
        INT     keyLength;
        CHAR    szKeyFlags[ 100 ];

        keyLength = dlen - SIZEOF_KEY_FIXED_DATA;

        flags = FlipUnalignedWord( pdata );
        pdata += sizeof( WORD );
        protocol = * ( PBYTE ) pdata;
        ++pdata;
        algorithm = * ( PBYTE ) pdata;
        ++pdata;

        PrintRoutine(
            pContext,
            "\r\n"
            "\t\tKEY flags      = 0x%04x %s\r\n"
            "\t\tKEY protocol   = %s (%d)\r\n"
            "\t\tKEY algorithm  = %s (%d)\r\n",
            (INT) flags,
            Dns_KeyFlagString( szKeyFlags, flags ),
            Dns_GetKeyProtocolString( protocol ),
            (INT) protocol,
            Dns_GetDnssecAlgorithmString( algorithm ),
            (INT) algorithm );

        DnsPrint_RawOctets(
            PrintRoutine,
            pContext,
            "\t\tPublic key:",
            "\t\t  ",           // line header
            pdata,
            keyLength );
        break;
    }

    case DNS_TYPE_SIG:
    {
        WORD    typeCovered;
        BYTE    algorithm;
        BYTE    labelCount;
        DWORD   originalTTL;
        DWORD   sigInception;
        DWORD   sigExpiration;
        WORD    keyTag;
        CHAR    szSigInception[ 100 ];
        CHAR    szSigExpiration[ 100 ];
        INT     sigLength;

        typeCovered = FlipUnalignedWord( pdata );
        pdata += sizeof( WORD );
        algorithm = * ( PBYTE ) pdata;
        ++pdata;
        labelCount = * ( PBYTE ) pdata;
        ++pdata;
        originalTTL = FlipUnalignedDword( pdata );
        pdata += sizeof( DWORD );
        sigExpiration = FlipUnalignedDword( pdata );
        pdata += sizeof( DWORD );
        sigInception = FlipUnalignedDword( pdata );
        pdata += sizeof( DWORD );
        keyTag = FlipUnalignedWord( pdata );
        pdata += sizeof( WORD );

        PrintRoutine(
            pContext,
            "\r\n"
            "\t\tSIG type covered  = %s\r\n"
            "\t\tSIG algorithm     = %s (%d)\r\n"
            "\t\tSIG label count   = %d\r\n"
            "\t\tSIG original TTL  = %d\r\n"
            "\t\tSIG expiration    = %s\r\n"
            "\t\tSIG inception     = %s\r\n"
            "\t\tSIG key tag       = %d\r\n",
            Dns_RecordStringForType( typeCovered ),
            Dns_GetDnssecAlgorithmString( ( BYTE ) algorithm ),
            ( INT ) algorithm,
            ( INT ) labelCount,
            ( INT ) originalTTL,
            Dns_SigTimeString( sigExpiration, szSigExpiration ),
            Dns_SigTimeString( sigInception, szSigInception ),
            ( INT ) keyTag );

        pdata += DnsPrint_PacketName(
                        PrintRoutine,
                        pContext,
                        "\t\tSIG signer's name = ",
                        pdata,
                        pMsgHead,
                        pMsgEnd,
                        "\r\n" );

        sigLength = ( INT ) ( pdataStop - pdata );

        DnsPrint_RawOctets(
            PrintRoutine,
            pContext,
            "\t\tSignature:",
            "\t\t  ",           // line header
            pdata,
            sigLength );
        break;
    }

    case DNS_TYPE_NXT:
        {
        INT         bitmapLength;
        INT         byteIdx;
        INT         bitIdx;

        pdata += DnsPrint_PacketName(
                        PrintRoutine,
                        pContext,
                        "\r\n\t\tNXT next name      = ",
                        pdata,
                        pMsgHead,
                        pMsgEnd,
                        "\r\n" );

        bitmapLength = ( INT ) ( pdataStop - pdata );

        PrintRoutine( pContext, "\t\tNXT types covered  = " );

        for ( byteIdx = 0; byteIdx < bitmapLength; ++byteIdx )
        {
            for ( bitIdx = ( byteIdx ? 0 : 1 ); bitIdx < 8; ++bitIdx )
            {
                PCHAR   pszType;

                if ( !( pdata[ byteIdx ] & ( 1 << bitIdx ) ) )
                {
                    continue;   // Bit value is zero - do not write string.
                }
                pszType = Dns_RecordStringForType( byteIdx * 8 + bitIdx );
                if ( !pszType )
                {
                    ASSERT( FALSE );
                    continue;   // This type has no string - do not write.
                }
                PrintRoutine( pContext, "%s ", pszType );
            } 
        }

        PrintRoutine( pContext, "\r\n" );
        break;
        }

    default:

        PrintRoutine(
            pContext,
            "Unknown resource record type %d at %p.\r\n",
            type,
            pMsgRR );

        DnsPrint_RawOctets(
            PrintRoutine,
            pContext,
            NULL,
            "\t\t",
            pdata,
            dlen );
        break;
    }

Done:

    DnsPrint_Unlock();

    return( sizeof(DNS_WIRE_RECORD) + dlen );
}



//
//  Print related utilities
//


INT
Dns_WriteFormattedSystemTimeToBuffer(
    OUT     PCHAR           pBuffer,
    IN      PSYSTEMTIME     pSystemTime
    )
/*++

Routine Description:

    Write SYSTEMTIME structure to buffer.

Arguments:

    pBuffer -- buffer to write into, assumed to have at least 50
                bytes available

    pSystemTime -- system time to convert;  assumed to be local, no
                    time zone conversion is done

Return Value:

    Bytes in formatted string.

--*/
{
    PCHAR   pend = pBuffer + 60;
    PCHAR   pstart = pBuffer;
    INT     count;

    pBuffer += GetDateFormat(
                    LOCALE_SYSTEM_DEFAULT,
                    LOCALE_NOUSEROVERRIDE,
                    (PSYSTEMTIME) pSystemTime,
                    NULL,
                    pBuffer,
                    (int)(pend - pBuffer) );

    //  Replace NULL from GetDateFormat with a space.

    *( pBuffer - 1 ) = ' ';

    pBuffer += GetTimeFormat(
                    LOCALE_SYSTEM_DEFAULT,
                    LOCALE_NOUSEROVERRIDE,
                    (PSYSTEMTIME) pSystemTime,
                    NULL,
                    pBuffer,
                    (int)(pend - pBuffer) );

    if ( pBuffer <= pstart+1 )
    {
        return( 0 );
    }
    return (INT)( pBuffer - pstart );
}



//
//  Response code print
//

#define DNS_RCODE_UNKNOWN   (DNS_RCODE_BADTIME + 1)

PCHAR   ResponseCodeStringTable[] =
{
    "NOERROR",
    "FORMERR",
    "SERVFAIL",
    "NXDOMAIN",
    "NOTIMP",
    "REFUSED",
    "YXDOMAIN",
    "YXRRSET",
    "NXRRSET",
    "NOTAUTH",
    "NOTZONE",
    "11 - unknown\r\n",
    "12 - unknown\r\n",
    "13 - unknown\r\n",
    "14 - unknown\r\n",
    "15 - unknown\r\n",

    //  DNS RCODEs stop at 15 -- these extended errors are available for security

    "BADSIG",
    "BADKEY",
    "BADTIME",
    "UNKNOWN"
};


PCHAR
Dns_ResponseCodeString(
    IN      INT     ResponseCode
    )
/*++

Routine Description:

    Get string corresponding to a response code.

Arguments:

    ResponseCode - response code

Return Value:

    Ptr to string for code.

--*/
{
    if ( ResponseCode > DNS_RCODE_UNKNOWN )
    {
        ResponseCode = DNS_RCODE_UNKNOWN;
    }
    return( ResponseCodeStringTable[ ResponseCode ] );
}



//
//  More detailed RCODE strings
//

PCHAR   ResponseCodeExplanationStringTable[] =
{
    "NOERROR:  no error",
    "FORMERR:  format error",
    "SERVFAIL:  server failure",
    "NXDOMAIN:  name error",
    "NOTIMP:  not implemented",
    "REFUSED",
    "YXDOMAIN:  name exists that should not",
    "YXRRSET:  RR set exists that should not",
    "NXRRSET:  required RR set does not exist",
    "NOTAUTH:  not authoritative",
    "NOTZONE:  name not in zone",
    "11 - unknown",
    "12 - unknown",
    "13 - unknown",
    "14 - unknown",
    "15 - unknown",

    //  DNS RCODEs stop at 15 -- these extended errors are available for security

    "BADSIG:  bad signature",
    "BADKEY:  bad signature",
    "BADTIME:  invalid or expired time on signature or key",
    "UNKNOWN"
};


PCHAR
Dns_ResponseCodeExplanationString(
    IN      INT     ResponseCode
    )
/*++

Routine Description:

    Get string corresponding to a response code.
    Basically for use by packet debug routine above.

Arguments:

    ResponseCode - response code

Return Value:

    Ptr to string for code.

--*/
{
    if ( ResponseCode > DNS_RCODE_UNKNOWN )
    {
        ResponseCode = DNS_RCODE_UNKNOWN;
    }
    return( ResponseCodeExplanationStringTable[ ResponseCode ] );
}



PCHAR
Dns_KeyFlagString(
    IN OUT      PCHAR       pszBuff,
    IN          WORD        Flags
    )
/*++

Routine Description:

    Formats a human-readable string based on the flags value
    (DNSSEC KEY RR flags). See RFC2535 section 3.2.1.

Arguments:

    pszBuff - buffer to dump string into should be min 100 chars

    flags - flag value to generate string for

Return Value:

    pszBuff

--*/
{
    BOOL    fZoneKey = FALSE;

    *pszBuff = '\0';

    // "type" bits

    if ( ( Flags & 0xC000 ) == 0xC000 )
    {
        strcat( pszBuff, "NOKEY " );
    }
    else if ( ( Flags & 0xC000 ) == 0x8000 )
    {
        strcat( pszBuff, "NOAUTH " );
    }
    else if ( ( Flags & 0xC000 ) == 0x4000 )
    {
        strcat( pszBuff, "NOCONF " );
    }
    else
    {
        strcat( pszBuff, "NOAUTH NOCONF " );
    }

    //  extended bit

    if ( Flags & 0x1000 )
    {
        strcat( pszBuff, "EXTEND " );
    }

    //  name type bits

    if ( ( Flags & 0x0300 ) == 0x0300 )
    {
        strcat( pszBuff, "RESNT " );    // reserved name type
    }
    else if ( ( Flags & 0x0200 ) == 0x0100 )
    {
        strcat( pszBuff, "ENTITY " );
    }
    else if ( ( Flags & 0x0100 ) == 0x4000 )
    {
        strcat( pszBuff, "ZONE " );
        fZoneKey = TRUE;
    }
    else
    {
        strcat( pszBuff, "USER " );
    }

    //  signatory bits
    
    if ( fZoneKey )
    {
        strcat( pszBuff, ( Flags & 0x0008 ) ? "MODEA " : "MODEB " );
        if ( Flags & 0x0004 )
        {
            strcat( pszBuff, "STRONG " );
        }
        if ( Flags & 0x0002 )
        {
            strcat( pszBuff, "UNIQ " );
        }
    }
    else
    {
        if ( Flags & 0x0008 )
        {
            strcat( pszBuff, "ZCTRL " );
        }
        if ( Flags & 0x0004 )
        {
            strcat( pszBuff, "STRONG " );
        }
        if ( Flags & 0x0002 )
        {
            strcat( pszBuff, "UNIQ " );
        }
    }

    return pszBuff;
}



//
//  Opcode print
//

PCHAR   OpcodeStringTable[] =
{
    "QUERY",
    "IQUERY",
    "SRV_STATUS",
    "UNKNOWN",
    "NOTIFY",
    "UPDATE",
    "UNKNOWN?"
};

CHAR    OpcodeCharacterTable[] =
{
    'Q',
    'I',
    'S',
    'K',
    'N',
    'U',
    '?'
};

#define DNS_OPCODE_UNSPEC (DNS_OPCODE_UPDATE + 1)


PCHAR
Dns_OpcodeString(
    IN      INT     Opcode
    )
/*++

Routine Description:

    Get string corresponding to a response code.

Arguments:

    Opcode - response code

Return Value:

    Ptr to string for code.

--*/
{
    if ( Opcode > DNS_OPCODE_UNSPEC )
    {
        Opcode = DNS_OPCODE_UNSPEC;
    }
    return( OpcodeStringTable[ Opcode ] );
}



CHAR
Dns_OpcodeCharacter(
    IN      INT     Opcode
    )
/*++

Routine Description:

    Get string corresponding to an opcode.

Arguments:

    Opcode - response code

Return Value:

    Ptr to string for code.

--*/
{
    if ( Opcode > DNS_OPCODE_UNSPEC )
    {
        Opcode = DNS_OPCODE_UNSPEC;
    }
    return( OpcodeCharacterTable[ Opcode ] );
}



//
//  Section names
//
//  With update get a new set of section names.
//  Provide single interface to putting a name on them.
//

PSTR  SectionNameArray[5] =
{
    "Question",
    "Answer",
    "Authority",
    "Additional",
    "ERROR:  Invalid Section"
};

PSTR  UpdateSectionNameArray[5] =
{
    "Zone",
    "Prerequisite",
    "Update",
    "Additional",
    "ERROR:  Invalid Section"
};

PCHAR
Dns_SectionNameString(
    IN      INT     iSection,
    IN      INT     iOpcode
    )
/*++

Routine Description:

    Get string corresponding to name of RR section id.
    For use by packet debug routine above.

Arguments:

    iSection - section id (0-3 for Question-Additional)

    iOpcode - opcode

Return Value:

    Ptr to string for section name.

--*/
{
    if ( iSection >= 4 )
    {
        iSection = 4;
    }

    if ( iOpcode == DNS_OPCODE_UPDATE )
    {
        return( UpdateSectionNameArray[iSection] );
    }
    else
    {
        return( SectionNameArray[iSection] );
    }
}


VOID
DnsPrint_MessageNoContext(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PDNS_HEADER     pMsgHead,
    IN      WORD            wLength     OPTIONAL
    )
/*++

Routine Description:

    Print DNS message buffer.
    Includes context information as well as actual DNS message.

--*/
{
    PCHAR       pchRecord;
    PBYTE       pmsgEnd;
    INT         i;
    INT         isection;
    INT         cchName;
    WORD        wOffset;
    WORD        wXid;
    WORD        wQuestionCount;
    WORD        wAnswerCount;
    WORD        wNameServerCount;
    WORD        wAdditionalCount;
    WORD        countSectionRR;
    BOOL        fFlipped = FALSE;

    //
    //  processing limits
    //      - if length given set stop limit
    //      - if length not given set wLength so checks against
    //          length overrun always fail (are ok)
    //

    if ( wLength )
    {
        pmsgEnd = ((PBYTE)pMsgHead) + wLength;
    }
    else
    {
        wLength = MAXWORD;
        pmsgEnd = NULL;
    }


    DnsPrint_Lock();

    if ( pszHeader )
    {
        PrintRoutine( pContext, "%s\r\n", pszHeader );
    }

    PrintRoutine(
        pContext,
        "DNS message header at %p\r\n",
        pMsgHead );

    PrintRoutine(
        pContext,
        "    XID       0x%04hx\r\n"
        "    Flags     0x%04hx\r\n"
        "        QR        0x%lx (%s)\r\n"
        "        OPCODE    0x%lx (%s)\r\n"
        "        AA        0x%lx\r\n"
        "        TC        0x%lx\r\n"
        "        RD        0x%lx\r\n"
        "        RA        0x%lx\r\n"
        "        Z         0x%lx\r\n"
        "        RCODE     0x%lx (%s)\r\n"
        "    QCOUNT    0x%hx\r\n"
        "    ACOUNT    0x%hx\r\n"
        "    NSCOUNT   0x%hx\r\n"
        "    ARCOUNT   0x%hx\r\n",

        pMsgHead->Xid,
        ntohs((*((PWORD)pMsgHead + 1))),

        pMsgHead->IsResponse,
        (pMsgHead->IsResponse ? "response" : "question"),
        pMsgHead->Opcode,
        Dns_OpcodeString( pMsgHead->Opcode ),
        pMsgHead->Authoritative,
        pMsgHead->Truncation,
        pMsgHead->RecursionDesired,
        pMsgHead->RecursionAvailable,
        pMsgHead->Reserved,
        pMsgHead->ResponseCode,
        Dns_ResponseCodeString( pMsgHead->ResponseCode ),

        pMsgHead->QuestionCount,
        pMsgHead->AnswerCount,
        pMsgHead->NameServerCount,
        pMsgHead->AdditionalCount );

    //
    //  determine if byte flipped and get correct count
    //

    wXid                = pMsgHead->Xid;
    wQuestionCount      = pMsgHead->QuestionCount;
    wAnswerCount        = pMsgHead->AnswerCount;
    wNameServerCount    = pMsgHead->NameServerCount;
    wAdditionalCount    = pMsgHead->AdditionalCount;

    if ( wQuestionCount )
    {
        fFlipped = wQuestionCount & 0xff00;
    }
    else if ( wNameServerCount )
    {
        fFlipped = wNameServerCount & 0xff00;
    }
    if ( fFlipped )
    {
        wXid                = ntohs( wXid );
        wQuestionCount      = ntohs( wQuestionCount );
        wAnswerCount        = ntohs( wAnswerCount );
        wNameServerCount    = ntohs( wNameServerCount );
        wAdditionalCount    = ntohs( wAdditionalCount );
    }

    //
    //  catch record flipping problems -- all are flipped or none at all
    //      and no record count should be > 256 EXCEPT answer count
    //      during FAST zone transfer
    //

    DNS_ASSERT( ! (wQuestionCount & 0xff00) );
    DNS_ASSERT( ! (wNameServerCount & 0xff00) );
    DNS_ASSERT( ! (wAdditionalCount & 0xff00) );

#if 0
    //
    //  stop here if WINS response -- don't have parsing ready
    //

    if ( pMsgHead->IsResponse && IS_WINS_XID(wXid) )
    {
        PrintRoutine( pContext, "  WINS Response packet.\r\n\r\n" );
        goto Unlock;
    }
#endif

    //
    //  print questions and resource records
    //

    pchRecord = (PCHAR)(pMsgHead + 1);

    for ( isection=0; isection<4; isection++)
    {
        PrintRoutine(
            pContext,
            "  %s Section:\r\n",
            Dns_SectionNameString( isection, pMsgHead->Opcode ) );

        if ( isection==0 )
        {
            countSectionRR = wQuestionCount;
        }
        else if ( isection==1 )
        {
            countSectionRR = wAnswerCount;
        }
        else if ( isection==2 )
        {
            countSectionRR = wNameServerCount;
        }
        else if ( isection==3 )
        {
            countSectionRR = wAdditionalCount;
        }

        for ( i=0; i < countSectionRR; i++ )
        {
            //
            //  verify not overrunning length
            //      - check against pCurrent as well as message length
            //        so can print packets while being built
            //

            wOffset = (WORD)(pchRecord - (PCHAR)pMsgHead);

            if ( wOffset >= wLength )
            {
                PrintRoutine(
                    pContext,
                    "ERROR:  BOGUS PACKET:\r\n"
                    "\tFollowing RR (offset %d) past packet length (%d).\r\n",
                    wOffset,
                    wLength
                    );
                goto Unlock;
            }

            //
            //  print RR name
            //

            PrintRoutine(
                pContext,
                "    Name Offset = 0x%04x\r\n",
                wOffset
                );

            cchName = DnsPrint_PacketName(
                            PrintRoutine,
                            pContext,
                            "    Name      \"",
                            pchRecord,
                            pMsgHead,
                            pmsgEnd,
                            "\"\r\n" );
            if ( !cchName )
            {
                PrintRoutine(
                    pContext,
                    "ERROR:  Invalid name length, stop packet print\r\n" );
                DNS_ASSERT( FALSE );
                break;
            }
            pchRecord += cchName;

            //  print question or resource record

            if ( isection == 0 )
            {
                PrintRoutine(
                    pContext,
                    "      QTYPE   %d\r\n"
                    "      QCLASS  %d\r\n",
                    FlipUnalignedWord( pchRecord ),
                    FlipUnalignedWord( pchRecord + sizeof(WORD) )
                    );
                pchRecord += sizeof( DNS_WIRE_QUESTION );
            }
            else
            {
                pchRecord += DnsPrint_PacketRecord(
                                PrintRoutine,
                                pContext,
                                NULL,
                                (PDNS_WIRE_RECORD) pchRecord,
                                pMsgHead,
                                pmsgEnd
                                );
            }
        }
    }

    //  check that at proper end of packet

    wOffset = (WORD)(pchRecord - (PCHAR)pMsgHead);
    PrintRoutine(
        pContext,
        "  Message length = %04x\r\n\r\n",
        wOffset );

    //  print warning if given message length and did not end up
    //  at end of message
    //  note:  pmsgEnd test in case passed wLength==0, in which case
    //  wLength set to MAXDWORD above

    if ( pmsgEnd && wOffset < wLength )
    {
        PrintRoutine(
            pContext,
            "WARNING:  message continues beyond these records\r\n"
            "\tpch = %p\r\n"
            "\toffset = %d, msg length = %d, %d bytes\r\n",
            pchRecord,
            wOffset,
            wLength,
            wLength - wOffset );

        DnsPrint_RawOctets(
            PrintRoutine,
            pContext,
            "Remaining bytes:",
            NULL,
            pchRecord,
            (wLength - wOffset) );
    }

Unlock:
    DnsPrint_Unlock();


} // DnsPrint_MessageNoContext



DWORD
DnsStringPrint_Guid(
    OUT     PCHAR           pBuffer,
    IN      PGUID           pGuid
    )
/*++

Routine Description:

    Print GUID to buffer.

Arguments:

    pBuffer - buffer to print to
        buffer must be big enough for GUID string
        GUID_STRING_BUFFER_LENGTH covers it

    pGuid - GUID to print

Return Value:

    Count of bytes printed to string.

--*/
{
    if ( !pGuid )
    {
        *pBuffer = 0;
        return 0;
    }

    return  sprintf(
                pBuffer,
                "%08x-%04x-%04x-%04x-%02x%02x%02x%02x%02x%02x",
                pGuid->Data1,
                pGuid->Data2,
                pGuid->Data3,
                *(PWORD) &pGuid->Data4[0],
                pGuid->Data4[2],
                pGuid->Data4[3],
                pGuid->Data4[4],
                pGuid->Data4[5],
                pGuid->Data4[6],
                pGuid->Data4[7],
                pGuid->Data4[8] );
}



VOID
DnsPrint_Guid(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PGUID           pGuid
    )
/*++

Routine Description:

    Print GUID

Arguments:

    pszHeader - Header message/name for RR.

    pGuid -- ptr to GUID to print

Return Value:

    None.

--*/
{
    CHAR    guidBuffer[ GUID_STRING_BUFFER_LENGTH ];

    if ( !pszHeader )
    {
        pszHeader = "Guid";
    }
    if ( !pGuid )
    {
        PrintRoutine(
            pContext,
            "%s:  NULL GUID pointer!\r\n",
            pszHeader );
    }

    //  convert GUID to string

    DnsStringPrint_Guid(
        guidBuffer,
        pGuid );

    PrintRoutine(
        pContext,
        "%s:  (%p) %s\r\n",
        pszHeader,
        pGuid,
        guidBuffer );
}



DWORD
DnsStringPrint_RawOctets(
    OUT     PCHAR           pBuffer,
    IN      PCHAR           pchData,
    IN      DWORD           dwLength,
    IN      PSTR            pszLineHeader,
    IN      DWORD           dwLineLength
    )
/*++

Routine Description:

    Print raw octect data to sting

Arguments:

    pBuffer - buffer to print to

    pchData - data to print

    dwLength - length of data to print

    pszLineHeader - header on each line.

    dwLineLength - number of bytes to print on line;  default is 

Return Value:

    Count of bytes printed to string.

--*/
{
    INT     i;
    INT     lineCount = 0;
    PCHAR   pch = pBuffer;

    *pch = 0;

    //
    //  catch NULL pointer
    //      - return is null terminated
    //      - but indicate no bytes written
    //

    if ( !pchData )
    {
        return  0;
    }

    //
    //  write each byte in hex
    //      - if dwLineLength set break into lines with count
    //      or optional header
    //

    for ( i = 0; i < (INT)dwLength; i++ )
    {
        if ( dwLineLength  &&  (i % dwLineLength) == 0 )
        {
            if ( pszLineHeader )
            {
                pch += sprintf( pch, "\r\n%s", pszLineHeader );
            }
            else
            {
                pch += sprintf( pch, "\r\n%3d> ", i );
            }
            lineCount++;
        }

        pch += sprintf( pch, "%02x ", (UCHAR)pchData[i] );
    }

    return( (DWORD)(pch - pBuffer) );
}



VOID
DnsPrint_RawBinary(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PSTR            pszLineHeader,
    IN      PCHAR           pchData,
    IN      DWORD           dwLength,
    IN      DWORD           PrintSize
    )
/*++

Routine Description:

    Print raw data.

Arguments:

    pszHeader - Header message/name for RR.

    pszLineHeader - Header on each line.

    pchData - data to print

    dwLength - length of data to print

    PrintSize - size to print in
        size(QWORD)
        size(DWORD)
        size(WORD)
        defaults to bytes

Return Value:

    None.

--*/
{
    DWORD   i;
    DWORD   lineCount = 0;
    CHAR    buf[ 2000 ];
    PCHAR   pch = buf;
    PCHAR   pbyte;
    PCHAR   pend;

    DnsPrint_Lock();

    if ( pszHeader )
    {
        PrintRoutine(
            pContext,
            "%s",
            pszHeader );
    }

    buf[0] = 0;

    //
    //  print bytes
    //      - write 16 bytes a line
    //      - buffer up 10 lines for speed
    //
    //  note:  we'll write a partial (<16 byte) line the first
    //      time if data is unaligned with PrintSize, then we'll
    //      write at 16 a pop
    //

    if ( PrintSize == 0 )
    {
        PrintSize = 1;
    }

    i = 0;
    pch = buf;
    pend = (PBYTE)pchData + dwLength;

    while ( i < dwLength )
    {
        DWORD   lineBytes = (i%16);

        if ( lineBytes==0 || lineBytes > (16-PrintSize) )
        {
            if ( lineCount > 10 )
            {
                PrintRoutine( pContext, buf );
                lineCount = 0;
                pch = buf;
            }

            if ( pszLineHeader )
            {
                pch += sprintf( pch, "\r\n%s", pszLineHeader );
            }
            else
            {
                pch += sprintf( pch, "\r\n\t%3d> ", i );
            }
            lineCount++;

            //if ( i >= 128 && dlen > 256 )
            //{
            //    PrintRoutine( pContext, "skipping remaining bytes ...\r\n" ));
            //}
        }

        pbyte = &pchData[i];

        if ( PrintSize == sizeof(QWORD) &&
             POINTER_IS_ALIGNED( pbyte, ALIGN_QUAD ) &&
             pbyte + sizeof(QWORD) <= pend )
        {
            pch += sprintf( pch, "%I64x ", *(PQWORD)pbyte );
            i += sizeof(QWORD);
        }
        else if ( PrintSize == sizeof(DWORD) &&
                  POINTER_IS_ALIGNED( pbyte, ALIGN_DWORD ) &&
                  pbyte + sizeof(DWORD) <= pend )
        {
            pch += sprintf( pch, "%08x ", *(PDWORD)pbyte );
            i += sizeof(DWORD);
        }
        else if ( PrintSize == sizeof(WORD) &&
                  POINTER_IS_ALIGNED( pbyte, ALIGN_WORD ) &&
                  pbyte + sizeof(WORD) <= pend )
        {
            pch += sprintf( pch, "%04x ", *(PWORD)pbyte );
            i += sizeof(WORD);
        }
        else  // default to byte print
        {
            pch += sprintf( pch, "%02x ", *pbyte );
            i++;
        }
    }

    //  print remaining bytes in buffer

    PrintRoutine(
        pContext,
        "%s\r\n",
        buf );

    DnsPrint_Unlock();
}



VOID
DnsPrint_RawOctets(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PSTR            pszLineHeader,
    IN      PCHAR           pchData,
    IN      DWORD           dwLength
    )
/*++

Routine Description:

    Print raw octect data.

Arguments:

    pszHeader - Header message/name for RR.

    pszLineHeader - Header on each line.

    pchData - data to print

    dwLength - length of data to print

Return Value:

    None.

--*/
{
    INT     i;
    INT     lineCount = 0;
    CHAR    buf[ 2000 ];
    PCHAR   pch = buf;

    DnsPrint_Lock();

    if ( pszHeader )
    {
        PrintRoutine(
            pContext,
            "%s",
            pszHeader );
    }

    buf[0] = 0;

    //  buffer every 20 lines for speed

    for ( i = 0; i < (INT)dwLength; i++ )
    {
        if ( !(i%16) )
        {
            if ( lineCount > 10 )
            {
                PrintRoutine( pContext, buf );
                lineCount = 0;
                pch = buf;
            }

            if ( pszLineHeader )
            {
                pch += sprintf( pch, "\r\n%s", pszLineHeader );
            }
            else
            {
                pch += sprintf( pch, "\r\n%3d> ", i );
            }
            lineCount++;

            //if ( i >= 128 && dlen > 256 )
            //{
            //    PrintRoutine( pContext, "skipping remaining bytes ...\r\n" ));
            //}
        }

        pch += sprintf( pch, "%02x ", (UCHAR)pchData[i] );
    }

    //  print remaining bytes in buffer

    PrintRoutine(
        pContext,
        "%s\r\n",
        buf );

    DnsPrint_Unlock();
}



VOID
DnsPrint_ParsedRecord(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PDNS_PARSED_RR  pParsedRR
    )
/*++

Routine Description:

    Print parsed RR structure.

Arguments:

    pszHeader - Header message/name for RR.

    pParsedRR - parsed RR to print

Return Value:

    None.

--*/
{
    if ( !pszHeader )
    {
        pszHeader = "Parsed RR:";
    }

    if ( !pParsedRR )
    {
        PrintRoutine(
            pContext,
            "%s %s\r\n",
            pszHeader,
            "NULL ParsedRR ptr." );
        return;
    }

    PrintRoutine(
        pContext,
        "%s\r\n"
        "\tpchName      = %p\r\n"
        "\tpchRR        = %p\r\n"
        "\tpchData      = %p\r\n"
        "\tpchNextRR    = %p\r\n"
        "\twType        = %d\r\n"
        "\twClass       = %d\r\n"
        "\tTTL          = %d\r\n"
        "\twDataLength  = %d\r\n",
        pszHeader,
        pParsedRR->pchName,
        pParsedRR->pchRR,
        pParsedRR->pchData,
        pParsedRR->pchNextRR,
        pParsedRR->Type,
        pParsedRR->Class,
        pParsedRR->Ttl,
        pParsedRR->DataLength
        );
}



//
//  Winsock RnR structures
//

VOID
DnsPrint_FdSet(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      struct fd_set * pfd_set
    )
/*++

Routine Description:

    Print sockets in FD_SET.

--*/
{
    INT count;
    INT i;

    DNS_ASSERT( pfd_set );

    count = (INT) pfd_set->fd_count;

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "%s  (count = %d)\r\n",
        pszHeader ? pszHeader : "FD_SET:",
        count );

    for (i=0; i<count; i++)
    {
        PrintRoutine(
            pContext,
            "\tsocket[%d] = %d\r\n",
            i,
            pfd_set->fd_array[i] );
    }
    DnsPrint_Unlock();
}



VOID
DnsPrint_Sockaddr(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      DWORD           Indent,
    IN      PSOCKADDR       pSockaddr,
    IN      INT             iSockaddrLength
    )
/*++

Routine Description:

    Print sockaddr structure and length used in call.

--*/
{
    PSTR    pindent = INDENT_STRING( Indent );

    if ( !pszHeader )
    {
        pszHeader = "Sockaddr:";
    }

    if ( !pSockaddr )
    {
        PrintRoutine(
            pContext,
            "%s%s\tNULL Sockaddr passed to print.\r\n",
            pindent,
            pszHeader );
        return;
    }

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "%s%s\r\n"
        "%s\tpointer         = %p\r\n"
        "%s\tlength          = %d\r\n"
        "%s\tsa_family       = %d\r\n",
        pindent,    pszHeader,
        pindent,    pSockaddr,
        pindent,    iSockaddrLength,
        pindent,    pSockaddr->sa_family
        );

    switch ( pSockaddr->sa_family )
    {

    case AF_INET:
        {
            PSOCKADDR_IN    psin = (PSOCKADDR_IN) pSockaddr;
    
            PrintRoutine(
                pContext,
                "%s\tsin_port        = %04x\r\n"
                "%s\tsin_addr        = %s (%08x)\r\n"
                "%s\tsin_zero        = %08x %08x\r\n",
                pindent,    psin->sin_port,
                pindent,    inet_ntoa( psin->sin_addr ),
                            psin->sin_addr.s_addr,
                pindent,    *(PDWORD) &psin->sin_zero[0],
                            *(PDWORD) &psin->sin_zero[4]
                );
            break;
        }

    case AF_INET6:
        {
            PSOCKADDR_IN6  psin = (PSOCKADDR_IN6) pSockaddr;

            CHAR    buffer[ IP6_ADDRESS_STRING_BUFFER_LENGTH ];

            Dns_Ip6AddressToString_A(
                buffer,
                (PIP6_ADDRESS) &psin->sin6_addr );

            PrintRoutine(
                pContext,
                "%s\tsin6_port       = %04x\r\n"
                "%s\tsin6_flowinfo   = %08x\r\n"
                "%s\tsin6_addr       = %s\r\n"
                "%s\tsin6_scope_id   = %08x\r\n",
                pindent,    psin->sin6_port,
                pindent,    psin->sin6_flowinfo,
                pindent,    buffer,
                pindent,    psin->sin6_scope_id
                );
            break;
        }       
                
    default:

        //  print unknown in WORDs
        //  limit print as this is probably a busted sockaddr due to bug
        {       
            DnsPrint_RawBinary(
                PrintRoutine,
                pContext,
                "\tdata:  ",
                pindent,            // line header
                pSockaddr->sa_data,
                iSockaddrLength < 100
                    ? iSockaddrLength
                    : 100,
                sizeof(WORD)
                );
            break;
        }
    }

    DnsPrint_Unlock();
}



VOID
DnsPrint_AddrInfo(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      DWORD           Indent,
    IN      PADDRINFO       pAddrInfo
    )
/*++

Routine Description:

    Print ADDRINFO structure.

--*/
{
    PSTR    pindent = INDENT_STRING( Indent );

    if ( !pszHeader )
    {
        pszHeader = "AddrInfo:";
    }

    if ( !pAddrInfo )
    {
        PrintRoutine(
            pContext,
            "%s%s NULL AddrInfo.\r\n",
            pindent,
            pszHeader  );
        return;
    }

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "%s%s\n"
        "%s\tPtr            = %p\r\n"
        "%s\tNext Ptr       = %p\r\n"
        "%s\tFlags          = %08x\r\n"
        "%s\tFamily         = %d\r\n"
        "%s\tSockType       = %d\r\n"
        "%s\tProtocol       = %d\r\n"
        "%s\tAddrLength     = %d\r\n"
        "%s\tName           = %s\r\n",
        pindent,    pszHeader,
        pindent,    pAddrInfo,
        pindent,    pAddrInfo->ai_next,
        pindent,    pAddrInfo->ai_flags,
        pindent,    pAddrInfo->ai_family,
        pindent,    pAddrInfo->ai_socktype,
        pindent,    pAddrInfo->ai_protocol,
        pindent,    pAddrInfo->ai_addrlen,
        pindent,    pAddrInfo->ai_canonname
        );

    DnsPrint_Sockaddr(
        PrintRoutine,
        pContext,
        NULL,
        Indent + 1,
        pAddrInfo->ai_addr,
        pAddrInfo->ai_addrlen );

    DnsPrint_Unlock();
}



VOID
DnsPrint_AddrInfoList(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      DWORD           Indent,
    IN      PADDRINFO       pAddrInfo
    )
/*++

Routine Description:

    Print ADDRINFO structure.

--*/
{
    PADDRINFO   paddr = pAddrInfo;
    PSTR        pindent = INDENT_STRING( Indent );

    //
    //  list header
    //

    if ( !pszHeader )
    {
        pszHeader = "AddrInfo List:";
    }

    if ( !paddr )
    {
        PrintRoutine(
            pContext,
            "%s%s NULL AddrInfo List.\r\n",
            pindent,
            pszHeader  );
        return;
    }

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "%s%s\n",
        pindent, pszHeader
        );

    //
    //  print each ADDRINFO in list
    //

    while ( paddr )
    {
        DnsPrint_AddrInfo(
            PrintRoutine,
            pContext,
            NULL,
            Indent,
            paddr );

        paddr = paddr->ai_next;
    }

    PrintRoutine(
        pContext,
        "End of AddrInfo list\n\n"
        );

    DnsPrint_Unlock();
}



VOID
DnsPrint_SocketAddress(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      DWORD           Indent,
    IN      PSOCKET_ADDRESS pSocketAddress
    )
/*++

Routine Description:

    Print SOCKET_ADDRESS structure.

--*/
{
    PSTR    pindent = INDENT_STRING( Indent );

    if ( !pszHeader )
    {
        pszHeader = "SocketAddress:";
    }

    if ( !pSocketAddress )
    {
        PrintRoutine(
            pContext,
            "%s%s NULL SocketAddress.\r\n",
            pindent,
            pszHeader  );
        return;
    }

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "%s%s\n"
        "%s\tpSockaddr        = %p\r\n"
        "%s\tiSockaddrLength  = %d\r\n",
        pindent,    pszHeader,
        pindent,    pSocketAddress->lpSockaddr,
        pindent,    pSocketAddress->iSockaddrLength );

    DnsPrint_Sockaddr(
        PrintRoutine,
        pContext,
        NULL,
        Indent,
        pSocketAddress->lpSockaddr,
        pSocketAddress->iSockaddrLength );

    DnsPrint_Unlock();
}



VOID
DnsPrint_CsAddr(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      DWORD           Indent,
    IN      PCSADDR_INFO    pCsAddr
    )
/*++

Routine Description:

    Print CSADDR_INFO structure.

Arguments:

    PrintRoutine    - routine to print with

    pParam          - ptr to print context

    pszHeader       - header

    Indent          - indent count, for formatting CSADDR inside larger struct

    pCsAddr         - ptr to CSADDRINFO to print

Return Value:

    None.

--*/
{
    PSTR    pindent = INDENT_STRING( Indent );

    if ( !pszHeader )
    {
        pszHeader = "CSAddrInfo:";
    }

    if ( !pCsAddr )
    {
        PrintRoutine(
            pContext,
            "%s%s \tNULL CSADDR_INFO ptr.\r\n",
            pindent,    pszHeader
            );
        return;
    }

    //  print the struct

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "%s%s\r\n"
        "%s\tPtr        = %p\n"
        "%s\tSocketType = %d\n"
        "%s\tProtocol   = %d\n",
        pindent,    pszHeader,
        pindent,    pCsAddr,
        pindent,    pCsAddr->iSocketType,
        pindent,    pCsAddr->iProtocol
        );

    DnsPrint_SocketAddress(
        PrintRoutine,
        pContext,
        "LocalAddress:",
        Indent,
        & pCsAddr->LocalAddr
        );

    DnsPrint_SocketAddress(
        PrintRoutine,
        pContext,
        "RemoteAddress:",
        Indent,
        & pCsAddr->RemoteAddr
        );

    DnsPrint_Unlock();
}




VOID
DnsPrint_AfProtocolsArray(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PAFPROTOCOLS    pProtocolArray,
    IN      DWORD           ProtocolCount
    )
/*++

Routine Description:

    Print AFPROTOCOLS array.

Arguments:

    PrintRoutine - routine to print with

    pszHeader   - header

    pProtocolArray - protocols array

    ProtocolCount  - array count

Return Value:

    None.

--*/
{
    DWORD   i;

    if ( !pszHeader )
    {
        pszHeader = "AFPROTOCOLS Array:";
    }

    //  print
    //      - array + count
    //      - each protocol element

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "%s\r\n"
        "\tProtocol Array   = %p\r\n"
        "\tProtocol Count   = %d\r\n",
        pszHeader,
        pProtocolArray,
        ProtocolCount );

    if ( pProtocolArray )
    {
        for ( i=0;  i<ProtocolCount;  i++ )
        {
            PrintRoutine(
                pContext,
                "\t\tfamily = %d;  proto = %d\r\n",
                pProtocolArray[i].iAddressFamily,
                pProtocolArray[i].iProtocol );
        }
    }

    DnsPrint_Unlock();
}



VOID
DnsPrint_WsaQuerySet(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      LPWSAQUERYSET   pQuerySet,
    IN      BOOL            fUnicode
    )
/*++

Routine Description:

    Print WSAQUERYSET structure.

Arguments:

    PrintRoutine - routine to print with

    pszHeader   - header

    pQuerySet   - ptr to WSAQUERYSET to print

    fUnicode    - TRUE if WSAQUERYSET is wide (WSAQUERYSETW)
                  FALSE if ANSI

Return Value:

    None.

--*/
{
    CHAR    serviceGuidBuffer[ GUID_STRING_BUFFER_LENGTH ];
    CHAR    nameSpaceGuidBuffer[ GUID_STRING_BUFFER_LENGTH ];
    DWORD   i;


    if ( !pszHeader )
    {
        pszHeader = "WSAQuerySet:";
    }

    if ( !pQuerySet )
    {
        PrintRoutine(
            pContext,
            "%s NULL QuerySet ptr\r\n",
            pszHeader );
        return;
    }

    //  convert GUIDs to strings

    DnsStringPrint_Guid(
        serviceGuidBuffer,
        pQuerySet->lpServiceClassId
        );
    DnsStringPrint_Guid(
        nameSpaceGuidBuffer,
        pQuerySet->lpNSProviderId
        );

    //  print the struct

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "%s\r\n"
        "\tSize                 = %d\r\n"
        "\tServiceInstanceName  = %S%s\r\n"
        "\tService GUID         = (%p) %s\r\n"
        "\tWSA version          = %p %x %d\r\n"
        "\tComment              = %S%s\r\n"
        "\tName Space           = %d %s\r\n"
        "\tName Space GUID      = (%p) %s\r\n"
        "\tContext              = %S%s\r\n"
        "\tNumberOfProtocols    = %d\r\n"
        "\tProtocol Array       = %p\r\n"
        "\tQueryString          = %S%s\r\n"
        "\tCS Addr Count        = %d\r\n"
        "\tCS Addr Array        = %p\r\n"
        "\tOutput Flags         = %08x\r\n"
        "\tpBlob                = %p\r\n",

        pszHeader,
        pQuerySet->dwSize,
        DNSSTRING_WIDE( fUnicode, pQuerySet->lpszServiceInstanceName ),
        DNSSTRING_ANSI( fUnicode, pQuerySet->lpszServiceInstanceName ),
        pQuerySet->lpServiceClassId,
        serviceGuidBuffer,
        pQuerySet->lpVersion,
        ( pQuerySet->lpVersion ) ? pQuerySet->lpVersion->dwVersion : 0,
        ( pQuerySet->lpVersion ) ? pQuerySet->lpVersion->ecHow : 0,

        DNSSTRING_WIDE( fUnicode, pQuerySet->lpszComment ),
        DNSSTRING_ANSI( fUnicode, pQuerySet->lpszComment ),
        pQuerySet->dwNameSpace,
        Dns_GetRnrNameSpaceIdString( pQuerySet->dwNameSpace ),
        pQuerySet->lpNSProviderId,
        nameSpaceGuidBuffer,
        DNSSTRING_WIDE( fUnicode, pQuerySet->lpszContext ),
        DNSSTRING_ANSI( fUnicode, pQuerySet->lpszContext ),

        pQuerySet->dwNumberOfProtocols,
        pQuerySet->lpafpProtocols,
        DNSSTRING_WIDE( fUnicode, pQuerySet->lpszQueryString ),
        DNSSTRING_ANSI( fUnicode, pQuerySet->lpszQueryString ),

        pQuerySet->dwNumberOfCsAddrs,
        pQuerySet->lpcsaBuffer,
        pQuerySet->dwOutputFlags,
        pQuerySet->lpBlob
        );

    //  print address-family\protocols array

    if ( pQuerySet->lpafpProtocols )
    {
        DnsPrint_AfProtocolsArray(
            PrintRoutine,
            pContext,
            "\tAFPROTOCOLS Array:",
            pQuerySet->lpafpProtocols,
            pQuerySet->dwNumberOfProtocols );
    }

    //  print CSADDR_INFO array

    if ( pQuerySet->dwNumberOfCsAddrs &&
         pQuerySet->lpcsaBuffer )
    {
        PrintRoutine(
            pContext,
            "--- CS_ADDR array:\r\n" );

        for ( i=0;  i<pQuerySet->dwNumberOfCsAddrs;  i++ )
        {
            DnsPrint_CsAddr(
                PrintRoutine,
                pContext,
                NULL,
                1,          // indent one level
                & pQuerySet->lpcsaBuffer[i] );
        }
    }

    //  print blob (the hostent)

    //
    //  DCR_FIX0:  need some sort of test for blob type?
    //      - most blobs are hostent, but some are servent
    //

    if ( pQuerySet->lpBlob )
    {
        GUID ianaGuid = SVCID_INET_SERVICEBYNAME;

        PrintRoutine(
            pContext,
            "--- BLOB:\n"
            "\tcbSize       = %d\r\n"
            "\tpBlobData    = %p\r\n",
            pQuerySet->lpBlob->cbSize,
            pQuerySet->lpBlob->pBlobData
            );

        //  note:  can't print blob as hostent
        //      1) may not be hostent
        //      2) is passed with offsets rather than pointers

        DnsPrint_RawBinary(
            PrintRoutine,
            pContext,
            NULL,
            "\t\t",
            pQuerySet->lpBlob->pBlobData,
            pQuerySet->lpBlob->cbSize,
            sizeof(DWORD)
            );
    }

    DnsPrint_Unlock();
}



VOID
DnsPrint_WsaNsClassInfo(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PWSANSCLASSINFO pInfo,
    IN      BOOL            fUnicode
    )
/*++

Routine Description:

    Print WSACLASSINFO structure.

Arguments:

    PrintRoutine - routine to print with

    pszHeader   - header

    pInfo       - ptr to WSACLASSINFO to print

    fUnicode    - TRUE if WSACLASSINFO is wide (WSACLASSINFOW)
                  FALSE if ANSI

Return Value:

    None.

--*/
{
    if ( !pszHeader )
    {
        pszHeader = "WSANsClassInfo:";
    }

    if ( !pInfo )
    {
        PrintRoutine(
            pContext,
            "%s NULL NsClassInfo ptr\r\n",
            pszHeader );
        return;
    }

    //  print the struct

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "%s\r\n"
        "\tPtr                  = %d\r\n"
        "\tName                 = %S%s\r\n"
        "\tName Space           = %d\r\n"
        "\tValue Type           = %d\r\n"
        "\tValue Size           = %d\r\n"
        "\tpValue               = %p\r\n",
        pszHeader,
        pInfo,
        DNSSTRING_WIDE( fUnicode, pInfo->lpszName ),
        DNSSTRING_ANSI( fUnicode, pInfo->lpszName ),
        pInfo->dwNameSpace,
        pInfo->dwValueType,
        pInfo->dwValueSize,
        pInfo->lpValue
        );

    if ( pInfo->lpValue )
    {
        PrintRoutine(
            pContext,
            "--- Value:\r\n"
            );

        DnsPrint_RawBinary(
            PrintRoutine,
            pContext,
            NULL,
            "\t\t",
            pInfo->lpValue,
            pInfo->dwValueSize,
            sizeof(BYTE)        // print in bytes
            );
    }

    DnsPrint_Unlock();
}



VOID
DnsPrint_WsaServiceClassInfo(
    IN      PRINT_ROUTINE           PrintRoutine,
    IN OUT  PPRINT_CONTEXT          pContext,
    IN      PSTR                    pszHeader,
    IN      LPWSASERVICECLASSINFO   pInfo,
    IN      BOOL                    fUnicode
    )
/*++

Routine Description:

    Print WSASERVICECLASSINFO structure.

Arguments:

    PrintRoutine - routine to print with

    pszHeader   - header

    pInfo       - ptr to WSASERVICECLASSINFO to print

    fUnicode    - TRUE if WSASERVICECLASSINFO is wide (WSASERVICECLASSINFOW)
                  FALSE if ANSI

Return Value:

    None.

--*/
{
    CHAR    serviceClassGuidBuffer[ GUID_STRING_BUFFER_LENGTH ];

    if ( !pszHeader )
    {
        pszHeader = "WSAServiceClassInfo:";
    }

    if ( !pInfo )
    {
        PrintRoutine(
            pContext,
            "%s NULL ServiceClassInfo ptr\r\n",
            pszHeader );
        return;
    }

    //  convert GUID to strings

    DnsStringPrint_Guid(
        serviceClassGuidBuffer,
        pInfo->lpServiceClassId
        );

    //  print the struct

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "%s\r\n"
        "\tPtr                  = %p\r\n"
        "\tClass GUID           = (%p) %s\r\n"
        "\tClassName            = %S%s\r\n"
        "\tClass Info Count     = %d\r\n"
        "\tClass Info Array     = %p\r\n",
        pszHeader,
        pInfo,
        serviceClassGuidBuffer,
        DNSSTRING_WIDE( fUnicode, pInfo->lpszServiceClassName ),
        DNSSTRING_ANSI( fUnicode, pInfo->lpszServiceClassName ),
        pInfo->dwCount,
        pInfo->lpClassInfos
        );

    if ( pInfo->lpClassInfos )
    {
        DWORD   i;

        for ( i=0; i<pInfo->dwCount; i++ )
        {
            DnsPrint_WsaNsClassInfo(
                PrintRoutine,
                pContext,
                NULL,       // default header
                & pInfo->lpClassInfos[i],
                fUnicode
                );
        }
    }

    DnsPrint_Unlock();
}



VOID
DnsPrint_Hostent(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PHOSTENT        pHostent,
    IN      BOOL            fUnicode
    )
/*++

Routine Description:

    Print hostent structure.

Arguments:

    PrintRoutine - routine to print with

    pszHeader   - header

    pHostent    - ptr to hostent

    fUnicode    - TRUE if hostent is unicode
                  FALSE if ANSI

Return Value:

    None.

--*/
{
    DWORD   i;

    if ( !pszHeader )
    {
        pszHeader = "Hostent:";
    }

    if ( !pHostent )
    {
        PrintRoutine(
            pContext,
            "%s %s\r\n",
            pszHeader,
            "NULL Hostent ptr." );
        return;
    }

    //  print the struct

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "%s\r\n"
        "\th_name               = %p %S%s\n"
        "\th_aliases            = %p\n"
        "\th_addrtype           = %d\n"
        "\th_length             = %d\n"
        "\th_addrlist           = %p\n",
        pszHeader,
        pHostent->h_name,
        DNSSTRING_WIDE( fUnicode, pHostent->h_name ),
        DNSSTRING_ANSI( fUnicode, pHostent->h_name ),
        pHostent->h_aliases,
        pHostent->h_addrtype,
        pHostent->h_length,
        pHostent->h_addr_list
        );

    //  print the aliases

    if ( pHostent->h_aliases )
    {
        PSTR *  paliasArray = pHostent->h_aliases;
        PSTR    palias;

        while ( palias = *paliasArray++ )
        {
            PrintRoutine(
                pContext,
                "\tAlias = (%p) %S%s\n",
                palias,
                DNSSTRING_WIDE( fUnicode, palias ),
                DNSSTRING_ANSI( fUnicode, palias ) );
        }
    }

    //  print the addresses

    if ( pHostent->h_addr_list )
    {
        PCHAR * ppaddr = pHostent->h_addr_list;
        PCHAR   pip;
        INT     i = 0;
        INT     family = pHostent->h_addrtype;
        INT     addrLength = pHostent->h_length;
        CHAR    stringBuf[ IP6_ADDRESS_STRING_BUFFER_LENGTH ];

        while ( pip = ppaddr[i] )
        {
            DWORD   bufLength = IP6_ADDRESS_STRING_BUFFER_LENGTH;

            Dns_AddressToString_A(
                stringBuf,
                & bufLength,
                pip,
                addrLength,
                family );

            PrintRoutine(
                pContext,
                "\tAddr[%d] = %s \t(ptr=%p)\n",
                i,
                stringBuf,
                pip );
            i++;
        }
    }

    DnsPrint_Unlock();
}



//
//  Query print routines
//

VOID
DnsPrint_QueryBlob(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pContext,
    IN      PSTR                pszHeader,
    IN      PQUERY_BLOB         pBlob
    )
/*++

Routine Description:

    Print query blob.

Arguments:

    PrintRoutine - routine to print with

    pContext    - print context

    pszHeader   - header

    pBlob       - query info

Return Value:

    None.

--*/
{
    DWORD   i;

    if ( !pszHeader )
    {
        pszHeader = "Query Blob:";
    }

    if ( !pBlob )
    {
        PrintRoutine(
            pContext,
            "%s %s\r\n",
            pszHeader,
            "NULL Query Blob ptr." );
        return;
    }

    //  print the struct

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "\tname orig        %S\n"
        "\tname orig wire   %s\n"
        "\tname wire        %s\n"
        "\ttype             %d\n"
        "\tflags            %08x\n"

        "\tname length      %d\n"
        "\tname attributes  %08x\n"
        "\tquery count      %d\n"
        "\tname flags       %08x\n"
        "\tfappendedName    %d\n"

        "\tstatus           %d\n"
        "\trcode            %d\n"
        "\tnetfail status   %d\n"
        "\tcache negative   %d\n"
        "\tno ip local      %d\n"
        "\trecords          %p\n"
        "\tlocal records    %p\n"

        "\tnetwork info     %p\n"
        "\tserver IPs       %p\n"
        "\tpmsg             %p\n"
        "\tevent            %p\n",

        pBlob->pNameOrig,
        pBlob->pNameOrigWire,
        pBlob->pNameWire,
        pBlob->wType,
        pBlob->Flags,
    
        pBlob->NameLength,
        pBlob->NameAttributes,
        pBlob->QueryCount,
        pBlob->NameFlags,
        pBlob->fAppendedName,
    
        pBlob->Status,
        pBlob->Rcode,
        pBlob->NetFailureStatus,
        pBlob->fCacheNegative,
        pBlob->fNoIpLocal,
        pBlob->pRecords,
        pBlob->pLocalRecords,

        pBlob->pNetworkInfo,
        pBlob->pDnsServers,
        pBlob->pRecvMsg,
        pBlob->hEvent
        );

    //  DCR_FIX0:  cleanup when results in use

    DnsPrint_RecordSet(
        PrintRoutine,
        pContext,
        "Records:\n",
        pBlob->pRecords );

    //  DCR_FIX0:  use results when ready

    DnsPrint_Unlock();
}



VOID
DnsPrint_QueryResults(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pContext,
    IN      PSTR                pszHeader,
    IN      PDNS_RESULTS        pResults
    )
/*++

Routine Description:

    Print query results.

Arguments:

    PrintRoutine - routine to print with

    pContext    - print context

    pszHeader   - header

    pResults    - results info

Return Value:

    None.

--*/
{
    DWORD   i;

    if ( !pszHeader )
    {
        pszHeader = "Results:";
    }

    if ( !pResults )
    {
        PrintRoutine(
            pContext,
            "%s %s\r\n",
            pszHeader,
            "NULL Results ptr." );
        return;
    }

    //  print the struct

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "\tstatus       %d\n"
        "\trcode        %d\n"
        "\tserver       %s\n"
        "\tpanswer      %p\n"
        "\tpalias       %p\n"
        "\tpauthority   %p\n"
        "\tpadditional  %p\n"
        "\tpsig         %p\n"
        "\tpmsg         %p\n",
        pResults->Status,
        pResults->Rcode,
        IP_STRING( pResults->ServerIp ),
        pResults->pAnswerRecords,
        pResults->pAliasRecords,
        pResults->pAuthorityRecords,
        pResults->pAdditionalRecords,
        pResults->pSigRecords,
        pResults->pMessage
        );

    DnsPrint_RecordSet(
        PrintRoutine,
        pContext,
        "\tAnswer records:\n",
        pResults->pAnswerRecords );

    DnsPrint_RecordSet(
        PrintRoutine,
        pContext,
        "\tAlias records:\n",
        pResults->pAliasRecords );

    DnsPrint_RecordSet(
        PrintRoutine,
        pContext,
        "\tAuthority records:\n",
        pResults->pAuthorityRecords );

    DnsPrint_RecordSet(
        PrintRoutine,
        pContext,
        "\tAdditional records:\n",
        pResults->pAdditionalRecords );

    DnsPrint_RecordSet(
        PrintRoutine,
        pContext,
        "\tSignature records:\n",
        pResults->pSigRecords );

    DnsPrint_Unlock();
}



VOID
DnsPrint_ParsedMessage(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pContext,
    IN      PSTR                pszHeader,
    IN      PDNS_PARSED_MESSAGE pParsed
    )
/*++

Routine Description:

    Print parsed message.

Arguments:

    PrintRoutine - routine to print with

    pContext    - print context

    pszHeader   - header

    pResults       - query info

Return Value:

    None.

--*/
{
    DWORD   i;

    if ( !pszHeader )
    {
        pszHeader = "Parsed Message:";
    }

    if ( !pParsed )
    {
        PrintRoutine(
            pContext,
            "%s %s\r\n",
            pszHeader,
            "NULL Parsed Message ptr." );
        return;
    }

    //  print the struct

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "\tstatus       %d (%08x)\n"
        "\tchar set     %d\n",
        pParsed->Status, pParsed->Status,
        pParsed->CharSet
        );

    PrintRoutine(
        pContext,
        "\tquestion:\n"
        "\t\tname       %S%s\n"
        "\t\ttype       %d\n"
        "\t\tclass      %d\n",
        PRINT_STRING_WIDE_CHARSET( pParsed->pQuestionName, pParsed->CharSet ),
        PRINT_STRING_ANSI_CHARSET( pParsed->pQuestionName, pParsed->CharSet ),
        pParsed->QuestionType,
        pParsed->QuestionClass
        );

    DnsPrint_RecordSet(
        PrintRoutine,
        pContext,
        "Answer records:\n",
        pParsed->pAnswerRecords );
    
    DnsPrint_RecordSet(
        PrintRoutine,
        pContext,
        "Alias records:\n",
        pParsed->pAliasRecords );

    DnsPrint_RecordSet(
        PrintRoutine,
        pContext,
        "Authority records:\n",
        pParsed->pAuthorityRecords );

    DnsPrint_RecordSet(
        PrintRoutine,
        pContext,
        "Additional records:\n",
        pParsed->pAdditionalRecords );

    DnsPrint_RecordSet(
        PrintRoutine,
        pContext,
        "Signature records:\n",
        pParsed->pSigRecords );

    DnsPrint_Unlock();
}



VOID
DnsPrint_QueryInfo(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pContext,
    IN      PSTR                pszHeader,
    IN      PDNS_QUERY_INFO     pQueryInfo
    )
/*++

Routine Description:

    Print query info

Arguments:

    PrintRoutine - routine to print with

    pContext    - print context

    pszHeader   - header

    pQueryInfo  - query info

Return Value:

    None.

--*/
{
    DWORD   i;

    if ( !pszHeader )
    {
        pszHeader = "Query Info:";
    }

    if ( !pQueryInfo )
    {
        PrintRoutine(
            pContext,
            "%s %s\r\n",
            pszHeader,
            "NULL Query Info ptr." );
        return;
    }

    //  print the struct

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "%s\n"
        "\tpointer      %p\n"
        "\tstatus       %d (%08x)\n"
        "\tchar set     %d\n"
        "\tname         %S%s\n"
        "\tname resv.   %s\n"
        "\ttype         %d\n"
        "\trcode        %d\n"
        "\tflags        %08x\n"

        "\tpanswer      %p\n"
        "\tpalias       %p\n"
        "\tpauthority   %p\n"
        "\tpadditional  %p\n"
        //"\tpsig         %p\n"

        "\tevent        %p\n"
        "\tpDnsServers  %p\n"
        "\tpmsg         %p\n",

        pszHeader,
        pQueryInfo,
        pQueryInfo->Status, pQueryInfo->Status,
        pQueryInfo->CharSet,
        PRINT_STRING_WIDE_CHARSET( pQueryInfo->pName, pQueryInfo->CharSet ),
        PRINT_STRING_ANSI_CHARSET( pQueryInfo->pName, pQueryInfo->CharSet ),
        pQueryInfo->pReservedName,
        pQueryInfo->Type,
        pQueryInfo->Rcode,
        pQueryInfo->Flags,

        pQueryInfo->pAnswerRecords,
        pQueryInfo->pAliasRecords,
        pQueryInfo->pAuthorityRecords,
        pQueryInfo->pAdditionalRecords,
        //pQueryInfo->pSigRecords,

        pQueryInfo->hEvent,
        pQueryInfo->pDnsServers,
        pQueryInfo->pMessage
        );

    DnsPrint_RecordSet(
        PrintRoutine,
        pContext,
        "Answer records:\n",
        pQueryInfo->pAnswerRecords );
    
    DnsPrint_RecordSet(
        PrintRoutine,
        pContext,
        "Alias records:\n",
        pQueryInfo->pAliasRecords );

    DnsPrint_RecordSet(
        PrintRoutine,
        pContext,
        "Authority records:\n",
        pQueryInfo->pAuthorityRecords );

    DnsPrint_RecordSet(
        PrintRoutine,
        pContext,
        "Additional records:\n",
        pQueryInfo->pAdditionalRecords );

    //DnsPrint_RecordSet(
    //    "Signature records:\n",
    //    pQueryInfo->pSigRecords );

    DnsPrint_Unlock();
}



VOID
DnsPrint_EnvarInfo(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pContext,
    IN      PSTR                pszHeader,
    IN      PENVAR_DWORD_INFO   pEnvar
    )
/*++

Routine Description:

    Print envar data

Arguments:

    PrintRoutine - routine to print with

    pContext    - print context

    pszHeader -- header to print with

    pEnvar -- ptr to envar info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PrintRoutine(
        pContext,
        "%s\n"
        "\tId       = %d\n"
        "\tValue    = %p\n"
        "\tfFound   = %d\n",
        pszHeader ? pszHeader : "Envar Info:",
        pEnvar->Id,
        pEnvar->Value,
        pEnvar->fFound
        );
}



//
//  Network info print routines.
//

VOID
DnsPrint_NetworkInfo(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      PDNS_NETINFO        pNetworkInfo
    )
/*++

Routine Description:

    Prints and validates network info structure.
    Should also touch all the memory and AV when bogus.

Arguments:

    pNetworkInfo -- network info to print

Return Value:

    None.

--*/
{
    DWORD   i;

    if ( !pszHeader )
    {
        pszHeader = "NetworkInfo:";
    }
    if ( !pNetworkInfo )
    {
        PrintRoutine(
            pPrintContext,
            "%s NULL NetworkInfo.\n",
            pszHeader );
        return;
    }

    DnsPrint_Lock();

    PrintRoutine(
        pPrintContext,
        "%s\n"
        "\tpointer          = %p\n"
        "\tpszHostName      = %s\n"
        "\tpszDomainName    = %s\n"
        "\tpSearchList      = %p\n"
        "\tTimeStamp        = %d\n"
        "\tInfoFlags        = %08x\n"
        "\tReturnFlags      = %08x\n"
        "\tAdapterCount     = %d\n"
        "\tAdapterArraySize = %d\n",
        pszHeader,
        pNetworkInfo,
        pNetworkInfo->pszHostName,
        pNetworkInfo->pszDomainName,
        pNetworkInfo->pSearchList,
        pNetworkInfo->TimeStamp,
        pNetworkInfo->InfoFlags,
        pNetworkInfo->ReturnFlags,
        pNetworkInfo->AdapterCount,
        pNetworkInfo->MaxAdapterCount );

    //  print search list

    DnsPrint_SearchList(
        PrintRoutine,
        pPrintContext,
        "Search List: ",
        pNetworkInfo->pSearchList );

    //  print server lists

    for ( i=0; i < pNetworkInfo->AdapterCount; i++ )
    {
        CHAR    header[60];

        sprintf( header, "AdapterInfo[%d]:", i );

        DnsPrint_AdapterInfo(
            PrintRoutine,
            pPrintContext,
            header,
            pNetworkInfo->AdapterArray[i] );
    }
    PrintRoutine(
        pPrintContext,
        "\n" );

    DnsPrint_Unlock();
}



VOID
DnsPrint_AdapterInfo(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      PDNS_ADAPTER        pAdapter
    )
/*++

Routine Description:

    Prints and validates DNS adapter info.
    Should also touch all the memory and AV when bogus.

Arguments:

    pAdapter -- DNS adapter to print

Return Value:

    None.

--*/
{
    DWORD   i;

    if ( !pszHeader )
    {
        pszHeader = "Adapter Info:";
    }
    if ( !pAdapter )
    {
        PrintRoutine(
            pPrintContext,
            "%s NULL Adapter info.\n",
            pszHeader );
        return;
    }

    DnsPrint_Lock();

    PrintRoutine(
        pPrintContext,
        "%s\n"
        "\tpointer          = %p\n"
        "\tDomain           = %s\n"
        "\tGuid Name        = %s\n"
        "\tInterfaceIndex   = %d\n"
        "\tInfoFlags        = %08x\n"
        "\tStatus           = %d\n"
        "\tRunFlags         = %08x\n"
        "\tServerIndex      = %d\n"
        "\tServerCount      = %d\n"
        "\tServerArraySize  = %d\n",
        pszHeader,
        pAdapter,
        pAdapter->pszAdapterDomain,
        pAdapter->pszAdapterGuidName,
        pAdapter->InterfaceIndex,
        pAdapter->InfoFlags,
        pAdapter->Status,
        pAdapter->RunFlags,
        pAdapter->ServerIndex,
        pAdapter->ServerCount,
        pAdapter->MaxServerCount );

    //  DNS server info

    for ( i=0; i < pAdapter->ServerCount; i++ )
    {
        //  DCR:  IP6 DNS server address

        PrintRoutine(
            pPrintContext,
            "\tDNS Server [%d]:\n"
            "\t\tIpAddr     = %s\n"
            "\t\tPriority   = %d\n"
            "\t\tStatus     = %d (%08x)\n",
            i,
            IP_STRING( pAdapter->ServerArray[i].IpAddress ),
            pAdapter->ServerArray[i].Priority,
            pAdapter->ServerArray[i].Status,
            pAdapter->ServerArray[i].Status
            );
    }

    //  IP address info

    DnsPrint_IpArray(
        PrintRoutine,
        pPrintContext,
        "IP Addrs",
        "IP",
        pAdapter->pAdapterIPAddresses );

    DnsPrint_IpArray(
        PrintRoutine,
        pPrintContext,
        "IP Addr Subnets",
        "Mask",
        pAdapter->pAdapterIPSubnetMasks );

    DnsPrint_Unlock();
}



VOID
DnsPrint_SearchList(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      PSEARCH_LIST        pSearchList
    )
/*++

Routine Description:

    Prints and validates DNS search list.
    Should also touch all the memory and AV when bogus.

Arguments:

    pSearchList -- search list to print

Return Value:

    None.

--*/
{
    DWORD   i;

    if ( !pszHeader )
    {
        pszHeader = "DNS Search List:";
    }

    if ( ! pSearchList )
    {
        PrintRoutine(
            pPrintContext,
            "%s NULL search list.\n",
            pszHeader );
        return;
    }

    DnsPrint_Lock();

    PrintRoutine(
        pPrintContext,
        "%s\n"
        "\tpointer        = %p\n"
        "\tpszDomain      = %s\n"
        "\tcNameCount     = %d\n"
        "\tcTotalListSize = %d\n"
        "\tCurrentName    = %d\n"
        "\tSearchListNames:\n",
        pszHeader,
        pSearchList,
        pSearchList->pszDomainOrZoneName,
        pSearchList->NameCount,
        pSearchList->MaxNameCount,
        pSearchList->CurrentNameIndex
        );

    for ( i=0; i < pSearchList->NameCount; i++ )
    {
        PrintRoutine(
            pPrintContext,
            "\t\t%s (Flags: %08x)\n",
            pSearchList->SearchNameArray[i].pszName,
            pSearchList->SearchNameArray[i].Flags );
    }
    DnsPrint_Unlock();
}



VOID
DnsPrint_HostentBlob(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PHOSTENT_BLOB   pBlob
    )
/*++

Routine Description:

    Print hostent structure.

Arguments:

    PrintRoutine - routine to print with

    pszHeader   - header

    pBlob       - ptr to hostent blob

Return Value:

    None.

--*/
{
    DWORD   i;

    if ( !pszHeader )
    {
        pszHeader = "Hostent Blob:";
    }

    if ( !pBlob )
    {
        PrintRoutine(
            pContext,
            "%s %s\r\n",
            pszHeader,
            "NULL Hostent blob ptr." );
        return;
    }

    //  print the struct

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "%s\r\n"
        "\tPtr                  = %p\n"
        "\tpHostent             = %p\n"
        "\tfAllocatedBlob       = %d\n"
        "\tfAllocatedBuf        = %d\n"
        "\tpBuffer              = %p\n"
        "\tBufferLength         = %d\n"
        "\tAvailLength          = %d\n"
        "\tpAvailBuffer         = %p\n"
        "\tpCurrent             = %p\n"
        "\tBytesLeft            = %d\n"
        "\tMaxAliasCount        = %d\n"
        "\tAliasCount           = %d\n"
        "\tMaxAddrCount         = %d\n"
        "\tAddrCount            = %d\n"
        "\tfWroteName           = %d\n"
        "\tfUnicode             = %d\n"
        "\tCharSet              = %d\n",
        pszHeader,
        pBlob,
        pBlob->pHostent,
        pBlob->fAllocatedBlob,
        pBlob->fAllocatedBuf,
        pBlob->pBuffer,
        pBlob->BufferLength,
        pBlob->AvailLength,
        pBlob->pAvailBuffer,
        pBlob->pCurrent,
        pBlob->BytesLeft,
        pBlob->MaxAliasCount,
        pBlob->AliasCount,
        pBlob->MaxAddrCount,
        pBlob->AddrCount,
        pBlob->fWroteName,
        pBlob->fUnicode,
        pBlob->CharSet
        );

    //  print the hostent

    if ( pBlob->pHostent )
    {
        DnsPrint_Hostent(
            PrintRoutine,
            pContext,
            NULL,
            pBlob->pHostent,
            pBlob->fUnicode
            );
    }

    DnsPrint_Unlock();
}

//
//  End of print.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\name.c ===
/*++

Copyright (c) 1995-2001 Microsoft Corporation

Module Name:

    name.c

Abstract:

    Domain Name System (DNS) Library

    DNS name routines.

Author:

    Jim Gilroy (jamesg)     October 1995

Revision History:

    jamesg  Jan 1997    UTF-8, Unicode conversions

--*/


#include "local.h"


//
//  DNS name cannonicalization
//
//  Flags to form cannonical name.
//

#define DNS_CANONICALIZING_FLAGS        ( LCMAP_LOWERCASE )

//
//  Comparison flags -- args to compare string
//
//  These flags are what DS uses when calling CompareString.
//  They are defined in ntdsapi.h.
//
//  Note:  these NORM_IGNOREXYZ flags which directory uses
//  for compare, actually STOP downcasing of these in LCMapString
//  -- international folks need to give us the correct deal here
//
//  We will only use the IGNORECASE flag because this is the
//  only one which we can use in LCMapString().
//  We want to say that if two names compare equal that you
//  can register either one and lookup the other and get the
//  result.  In other words they are equal throughout the
//  client-server system.
//  

#if 0
#define DS_DEFAULT_LOCALE_COMPARE_FLAGS    (NORM_IGNORECASE     |   \
                                            NORM_IGNOREKANATYPE |   \
                                            NORM_IGNORENONSPACE |   \
                                            NORM_IGNOREWIDTH)
#endif


#define DNS_CANONICAL_COMPARE_FLAGS     ( NORM_IGNORECASE )


//
//  Locale to canonically downcase in.
//
//  Need to disambiguate to a universal standard so that every DNS
//  server interprets these the same way.
//
//  In Win2K we used US English.  
//      Sublang: US English (0x04)  Lang:  English (0x09)
//      (note sublang US english actually 0x1, but sublang starts at
//      bit 10)
//
//  #define DNS_CANONICAL_LOCALE      ( 0x0409 )
//
//  For Whistler invariant locale is created;  It is actually the
//  same as US English for downcasing -- US English has no
//  exceptions to the default case conversion table.
//

#define DNS_CANONICAL_LOCALE      ( LOCALE_INVARIANT )




//
//  DNS Character properties for validation
//
//  DCR:  combine char validation and file tables
//      Probably could be combined with file character
//      lookup, by simply merging bit fields appropriately.
//      At this point time, however, no need to disturb
//      file lookup, which is working fine.
//
//  Character attributes bitfields
//

#define B_RFC                   0x00000001
#define B_NUMBER                0x00000002
#define B_UPPER                 0x00000004
#define B_NON_RFC               0x00000008

#define B_UTF8_TRAIL            0x00000010
#define B_UTF8_FIRST_TWO        0x00000020
#define B_UTF8_FIRST_THREE      0x00000040
#define B_UTF8_PAIR             0x00000080

#define B_DOT                   0x00000800
#define B_SPECIAL               0x00001000
#define B_LEADING_ONLY          0x00004000


//
//  Generic characters
//

#define DC_RFC          (B_RFC)
#define DC_LOWER        (B_RFC)
#define DC_UPPER        (B_UPPER | B_RFC)
#define DC_NUMBER       (B_NUMBER | B_RFC)
#define DC_NON_RFC      (B_NON_RFC)

#define DC_UTF8_TRAIL   (B_UTF8_TRAIL)
#define DC_UTF8_1ST_2   (B_UTF8_FIRST_TWO)
#define DC_UTF8_1ST_3   (B_UTF8_FIRST_THREE)
#define DC_UTF8_PAIR    (B_UTF8_PAIR)

//
//  Special characters
//      * valid as single label wildcard
//      _ leading SRV record domain names
//      / in classless in-addr
//

#define DC_DOT          (B_SPECIAL | B_DOT)

#define DC_ASTERISK     (B_SPECIAL | B_LEADING_ONLY)

#define DC_UNDERSCORE   (B_SPECIAL | B_LEADING_ONLY)

#define DC_BACKSLASH    (B_SPECIAL)

//
//  More special
//  These have no special validations, but have special file
//  properties, so define to keep table in shape for merge with
//  file chars.
//

#define DC_NULL         (0)

#define DC_OCTAL        (B_NON_RFC)
#define DC_RETURN       (B_NON_RFC)
#define DC_NEWLINE      (B_NON_RFC)
#define DC_TAB          (B_NON_RFC)
#define DC_BLANK        (B_NON_RFC)
#define DC_QUOTE        (B_NON_RFC)
#define DC_SLASH        (B_NON_RFC)
#define DC_OPEN_PAREN   (B_NON_RFC)
#define DC_CLOSE_PAREN  (B_NON_RFC)
#define DC_COMMENT      (B_NON_RFC)



//
//  DNS character table
//
//  These routines handle the name conversion issues relating to
//  writing names and strings in flat ANSI files
//      -- special file characters
//      -- quoted string
//      -- character quotes for special characters and unprintable chars
//
//  The character to char properties table allows simple mapping of
//  a character to its properties saving us a bunch of compare\branch
//  instructions in parsing file names\strings.
//
//  See nameutil.h for specific properties.
//

DWORD    DnsCharPropertyTable[] =
{
    //  control chars 0-31 must be octal in all circumstances
    //  end-of-line and tab characters are special

    DC_NULL,                // zero special on read, some RPC strings NULL terminated

    DC_OCTAL,   DC_OCTAL,   DC_OCTAL,   DC_OCTAL,
    DC_OCTAL,   DC_OCTAL,   DC_OCTAL,   DC_OCTAL,

    DC_TAB,                 // tab
    DC_NEWLINE,             // line feed
    DC_OCTAL,
    DC_OCTAL,
    DC_RETURN,              // carriage return
    DC_OCTAL,
    DC_OCTAL,

    DC_OCTAL,   DC_OCTAL,   DC_OCTAL,   DC_OCTAL,
    DC_OCTAL,   DC_OCTAL,   DC_OCTAL,   DC_OCTAL,
    DC_OCTAL,   DC_OCTAL,   DC_OCTAL,   DC_OCTAL,
    DC_OCTAL,   DC_OCTAL,   DC_OCTAL,   DC_OCTAL,

    DC_BLANK,               // blank, special char but needs octal quote

    DC_NON_RFC,             // !
    DC_QUOTE,               // " always must be quoted
    DC_NON_RFC,             // #
    DC_NON_RFC,             // $
    DC_NON_RFC,             // %
    DC_NON_RFC,             // &
    DC_NON_RFC,             // '

    DC_OPEN_PAREN,          // ( datafile line extension
    DC_CLOSE_PAREN,         // ) datafile line extension
    DC_ASTERISK,            // *
    DC_NON_RFC,             // +
    DC_NON_RFC,             // ,
    DC_RFC,                 // - RFC for hostname
    DC_DOT,                 // . must quote in names
    DC_BACKSLASH,           // /

    // 0 - 9 RFC for hostname

    DC_NUMBER,  DC_NUMBER,  DC_NUMBER,  DC_NUMBER,
    DC_NUMBER,  DC_NUMBER,  DC_NUMBER,  DC_NUMBER,
    DC_NUMBER,  DC_NUMBER,

    DC_NON_RFC,             // :
    DC_COMMENT,             // ;  datafile comment
    DC_NON_RFC,             // <
    DC_NON_RFC,             // =
    DC_NON_RFC,             // >
    DC_NON_RFC,             // ?
    DC_NON_RFC,             // @

    // A - Z RFC for hostname

    DC_UPPER,   DC_UPPER,   DC_UPPER,   DC_UPPER,
    DC_UPPER,   DC_UPPER,   DC_UPPER,   DC_UPPER,
    DC_UPPER,   DC_UPPER,   DC_UPPER,   DC_UPPER,
    DC_UPPER,   DC_UPPER,   DC_UPPER,   DC_UPPER,
    DC_UPPER,   DC_UPPER,   DC_UPPER,   DC_UPPER,
    DC_UPPER,   DC_UPPER,   DC_UPPER,   DC_UPPER,
    DC_UPPER,   DC_UPPER,

    DC_NON_RFC,             // [
    DC_SLASH,               // \ always must be quoted
    DC_NON_RFC,             // ]
    DC_NON_RFC,             // ^
    DC_UNDERSCORE,          // _
    DC_NON_RFC,             // `

    // a - z RFC for hostname

    DC_LOWER,   DC_LOWER,   DC_LOWER,   DC_LOWER,
    DC_LOWER,   DC_LOWER,   DC_LOWER,   DC_LOWER,
    DC_LOWER,   DC_LOWER,   DC_LOWER,   DC_LOWER,
    DC_LOWER,   DC_LOWER,   DC_LOWER,   DC_LOWER,
    DC_LOWER,   DC_LOWER,   DC_LOWER,   DC_LOWER,
    DC_LOWER,   DC_LOWER,   DC_LOWER,   DC_LOWER,
    DC_LOWER,   DC_LOWER,

    DC_NON_RFC,             // {
    DC_NON_RFC,             // |
    DC_NON_RFC,             // }
    DC_NON_RFC,             // ~
    DC_OCTAL,               // 0x7f DEL code

    //  UTF8 trail bytes
    //      - chars   0x80 <= X < 0xc0
    //      - mask [10xx xxxx]
    //
    //  Lead UTF8 character determines count of bytes in conversion.
    //  Trail characters fill out conversion.

    DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,
    DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,
    DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,
    DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,
    DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,
    DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,
    DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,
    DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,

    DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,
    DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,
    DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,
    DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,
    DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,
    DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,
    DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,
    DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,  DC_UTF8_TRAIL,

    //  UTF8_1ST_OF_2
    //      - chars > 0xc0 to 0xdf
    //      - mask [110x xxxx]
    //
    //  Converting unicode chars > 7 bits <= 11 bits (from 0x80 to 0x7ff)
    //  consists of first of two char followed by one trail bytes

    DC_UTF8_1ST_2,  DC_UTF8_1ST_2,  DC_UTF8_1ST_2,  DC_UTF8_1ST_2,
    DC_UTF8_1ST_2,  DC_UTF8_1ST_2,  DC_UTF8_1ST_2,  DC_UTF8_1ST_2,
    DC_UTF8_1ST_2,  DC_UTF8_1ST_2,  DC_UTF8_1ST_2,  DC_UTF8_1ST_2,
    DC_UTF8_1ST_2,  DC_UTF8_1ST_2,  DC_UTF8_1ST_2,  DC_UTF8_1ST_2,
    DC_UTF8_1ST_2,  DC_UTF8_1ST_2,  DC_UTF8_1ST_2,  DC_UTF8_1ST_2,
    DC_UTF8_1ST_2,  DC_UTF8_1ST_2,  DC_UTF8_1ST_2,  DC_UTF8_1ST_2,
    DC_UTF8_1ST_2,  DC_UTF8_1ST_2,  DC_UTF8_1ST_2,  DC_UTF8_1ST_2,
    DC_UTF8_1ST_2,  DC_UTF8_1ST_2,  DC_UTF8_1ST_2,  DC_UTF8_1ST_2,

    //  UTF8_1ST_OF_3
    //      - chars > 0xe0
    //      - mask [1110 xxxx]
    //
    //  Converting unicode > 11 bits (0x7ff)
    //  consists of first of three char followed by two trail bytes

    DC_UTF8_1ST_3,  DC_UTF8_1ST_3,  DC_UTF8_1ST_3,  DC_UTF8_1ST_3,
    DC_UTF8_1ST_3,  DC_UTF8_1ST_3,  DC_UTF8_1ST_3,  DC_UTF8_1ST_3,
    DC_UTF8_1ST_3,  DC_UTF8_1ST_3,  DC_UTF8_1ST_3,  DC_UTF8_1ST_3,
    DC_UTF8_1ST_3,  DC_UTF8_1ST_3,  DC_UTF8_1ST_3,  DC_UTF8_1ST_3,
    DC_UTF8_1ST_3,  DC_UTF8_1ST_3,  DC_UTF8_1ST_3,  DC_UTF8_1ST_3,
    DC_UTF8_1ST_3,  DC_UTF8_1ST_3,  DC_UTF8_1ST_3,  DC_UTF8_1ST_3,
    DC_UTF8_1ST_3,  DC_UTF8_1ST_3,  DC_UTF8_1ST_3,  DC_UTF8_1ST_3,
    DC_UTF8_1ST_3,  DC_UTF8_1ST_3,  DC_UTF8_1ST_3,  DC_UTF8_1ST_3
};



VOID
Dns_VerifyValidFileCharPropertyTable(
    VOID
    )
/*++

Routine Description:

    Verify haven't broken lookup table.

Arguments:

    None

Return Value:

    None

--*/
{
    ASSERT( DnsCharPropertyTable[0]       == DC_NULL        );
    ASSERT( DnsCharPropertyTable['\t']    == DC_TAB         );
    ASSERT( DnsCharPropertyTable['\n']    == DC_NEWLINE     );
    ASSERT( DnsCharPropertyTable['\r']    == DC_RETURN      );
    ASSERT( DnsCharPropertyTable[' ']     == DC_BLANK       );
    ASSERT( DnsCharPropertyTable['"']     == DC_QUOTE       );
    ASSERT( DnsCharPropertyTable['(']     == DC_OPEN_PAREN  );
    ASSERT( DnsCharPropertyTable[')']     == DC_CLOSE_PAREN );
    ASSERT( DnsCharPropertyTable['*']     == DC_ASTERISK     );
    ASSERT( DnsCharPropertyTable['-']     == DC_RFC         );
    ASSERT( DnsCharPropertyTable['.']     == DC_DOT         );
    ASSERT( DnsCharPropertyTable['/']     == DC_BACKSLASH   );
    ASSERT( DnsCharPropertyTable['0']     == DC_NUMBER      );
    ASSERT( DnsCharPropertyTable['9']     == DC_NUMBER      );
    ASSERT( DnsCharPropertyTable[';']     == DC_COMMENT     );
    ASSERT( DnsCharPropertyTable['A']     == DC_UPPER       );
    ASSERT( DnsCharPropertyTable['Z']     == DC_UPPER       );
    ASSERT( DnsCharPropertyTable['\\']    == DC_SLASH       );
    ASSERT( DnsCharPropertyTable['_']     == DC_UNDERSCORE  );
    ASSERT( DnsCharPropertyTable['a']     == DC_LOWER       );
    ASSERT( DnsCharPropertyTable['z']     == DC_LOWER       );
    ASSERT( DnsCharPropertyTable[0x7f]    == DC_OCTAL       );
    ASSERT( DnsCharPropertyTable[0x80]    == DC_UTF8_TRAIL  );
    ASSERT( DnsCharPropertyTable[0xbf]    == DC_UTF8_TRAIL  );
    ASSERT( DnsCharPropertyTable[0xc0]    == DC_UTF8_1ST_2  );
    ASSERT( DnsCharPropertyTable[0xdf]    == DC_UTF8_1ST_2  );
    ASSERT( DnsCharPropertyTable[0xe0]    == DC_UTF8_1ST_3  );
    ASSERT( DnsCharPropertyTable[0xff]    == DC_UTF8_1ST_3  );
};



//
//  Validation routine flags
//

#define DNSVAL_ALLOW_LEADING_UNDERSCORE     0x00010000
#define DNSVAL_ALLOW_ASTERISK               0x00020000
#define DNSVAL_ALLOW_BACKSLASH              0x00040000

//
//  Validation bit flags
//

#define DNS_BIT_NAME_FQDN                   0x00000001
#define DNS_BIT_NAME_SINGLE_LABEL           0x00000002
#define DNS_BIT_NAME_DOTTED                 0x00000004
#define DNS_BIT_NAME_ROOT                   0x00000008

#define DNS_BIT_NAME_CONTAINS_UPPER         0x00000010
#define DNS_BIT_NAME_NUMERIC                0x00000100
#define DNS_BIT_NAME_NUMERIC_LABEL          0x00000200
#define DNS_BIT_NAME_NUMERIC_FIRST_LABEL    0x00000400

#define DNS_BIT_NAME_UNDERSCORE             0x00001000
#define DNS_BIT_NAME_WILDCARD               0x00002000
#define DNS_BIT_NAME_BACKSLASH              0x00004000
#define DNS_BIT_NAME_NON_RFC_ASCII          0x00008000
#define DNS_BIT_NAME_MULTIBYTE              0x00010000
#define DNS_BIT_NAME_BINARY_LABEL           0x00020000

#define DNS_BIT_NAME_INVALID                0x80000000




#if 0
//
//  Old validation -- retired
//
//  Downcase and validation table
//
//  DCR:  table lookup for all DNS char properties
//        especially RFC, non-RFC, invalid
//

typedef struct _Dns_ValidationChar
{
    CHAR        chDown;
    UCHAR       fNonRfc;
}
DNS_VALIDATION_CHAR;

#define NON_RFC         (1)
#define EXTENDED_CHAR   (0x80)


DNS_VALIDATION_CHAR
Dns_ValidateDowncaseChar(
    IN      CHAR            ch
    )
/*++

Routine Description:

    Validates character

Arguments:

    ch  -- character to validate

Return Value:

    Validation character -- downcased character and flag

--*/
{
    DNS_VALIDATION_CHAR     val;

    //  default to normal character

    val.chDown = ch;
    val.fNonRfc = 0;

    //
    //  break out character tests
    //      - attempt most likely to least likely
    //      - but also working down to simplify tests
    //

    if ( (UCHAR)ch >= 'a' )
    {
        if ( (UCHAR)ch <= 'z' )
        {
            return( val );
        }
        val.fNonRfc = NON_RFC;
        if ( ch & 0x80 )
        {
            val.fNonRfc = EXTENDED_CHAR;
        }
    }

    else if ( (UCHAR)ch >= 'A' )
    {
        if ( (UCHAR)ch <= 'Z' )
        {
            val.chDown = ch + 0x20;
            return( val );
        }
        val.fNonRfc = NON_RFC;
    }

    else if ( (UCHAR)ch >= '0' )
    {
        if ( (UCHAR)ch <= '9' )
        {
            return( val );
        }
        val.fNonRfc = NON_RFC;
    }

    else if ( (UCHAR)ch > ' ' )
    {
        if ( (UCHAR)ch == '-' )
        {
            return( val );
        }
        val.fNonRfc = NON_RFC;
    }

    //  blank or below is flat error

    else
    {
        val.chDown = 0;
        val.fNonRfc = NON_RFC;
    }

    return( val );
}
#endif



//
//  Name validation
//
//  DCR:  name validation by bitfield
//
//  An interesting approach to validation, would be to expose
//  a set of properties about a name.
//  Caller could then specify allowable set (we'd give packages)
//  and we'd give back actual set.
//  Low level routines would do nothing but return bit field of
//  property set.
//
//  Properties would include:
//      - RFC
//      - contains numeric
//      - contains upper
//      - all numeric
//      - first label numeric
//
//      - utf8 multibyte
//      - underscore
//      - other non-RFC
//      - unprintable
//      - non-utf8 high (i.e. requires binary label)
//
//      - FQDN
//      - single label
//      - root
//


DNS_STATUS
validateDnsNamePrivate(
    IN      LPCSTR          pszName,
    IN      DWORD           dwFlag,
    OUT     PDWORD          pLabelCount,
    OUT     PDWORD          pResultFlag
    )
/*++

Routine Description:

    Verifies name is valid DNS name.

Arguments:

    pszName -- DNS name (standard dotted form) to check

    dwFlags -- validation flags
        - DNSVAL_ALLOW_LEADING_UNDERSCORE
        - DNSVAL_ALLOW_BACKSLASH
        - DNSVAL_ALLOW_ASTERIK

    pLabelCount -- addr to recv label count

    pResultFlag -- addr to recv result flag

Return Value:

    ERROR_SUCCESS               -- completely RFC compliant name
    DNS_ERROR_NON_RFC_NAME      -- syntax valid, but not standard RFC name
    DNS_ERROR_INVALID_NAME_CHAR -- syntax valid, but invalid characters
    ERROR_INVALID_NAME          -- name completely useless, bogus, toast

--*/
{
    PUCHAR      pch = (PUCHAR)pszName;
    UCHAR       ch;
    DWORD       charProp;
    DWORD       labelCount = 0;
    DWORD       trailCount = 0;
    INT         labelCharCount = 0;
    INT         labelNumberCount = 0;
    DWORD       flag;
    BOOL        fqdn = FALSE;
    BOOL        fnonRfc = FALSE;
    BOOL        finvalidChar = FALSE;
    BOOL        fnameNonNumeric = FALSE;
    BOOL        flabelNonNumeric = FALSE;
    DNS_STATUS  status;


    DNSDBG( TRACE, ( "validateNamePrivate()\n" ));

    if ( !pch )
    {
        goto InvalidName;
    }

    //
    //  validations
    //      - name length (255)
    //      - label length (63)
    //      - UTF8 encoding correct
    //      - no unprintable characters
    //

    while ( 1 )
    {
        //  get next character and properties

        ch = *pch++;
        charProp = DnsCharPropertyTable[ ch ];

        //  inc label count
        //      - do here for simplicity, dec in "." case below

        labelCharCount++;

        //
        //  simplify UTF8 -- just get it out of the way
        //      need to do first or else need trailCount==0 checks
        //      on all other paths
        //

        if ( ch >= 0x80 )
        {
            DWORD tempStatus;

            tempStatus = Dns_ValidateUtf8Byte(
                            ch,
                            & trailCount );
            if ( tempStatus != ERROR_SUCCESS )
            {
                DNSDBG( READ, (
                    "ERROR:  Name UTF8 trail count check at %c\n", ch ));
                goto InvalidName;
            }
            fnonRfc = TRUE;
            continue;
        }

        //
        //  trail count check
        //      - all ASCII chars, must not be in middle of UTF8
        //

        if ( trailCount )
        {
            DNSDBG( READ, (
                "ERROR:  Name failed trail count check at %c\n", ch ));
            goto InvalidName;
        }

        //
        //  full RFC -- continue
        //

        if ( charProp & B_RFC )
        {
            if ( charProp & B_NUMBER )
            {
                labelNumberCount++;
            }
            continue;
        }

        //
        //  label termination:  dot or NULL
        //

        if ( ch == '.' || ch == 0 )
        {
            labelCharCount--;

            //  FQDN termination
            //      - termination with no bytes in label
            //
            //  two cases:
            //  1) terminate on NULL char
            //      - standard FQDN "foo.bar."
            //      - but empty name invalid
            //  2) terminate on dot
            //      - only "." root valid
            //      - all other ".." or ".xyz" cases invalid

            if ( labelCharCount == 0 )
            {
                fqdn = TRUE;

                if ( ch == 0 )
                {
                    if ( labelCount )
                    {
                        goto Done;
                    }
                }
                else if ( pch == pszName+1 && *pch == 0 )
                {
                    //  root
                    //      - set flags for validity
                    //      - skip final length check

                    fnameNonNumeric = TRUE;
                    flabelNonNumeric = TRUE;
                    goto DoneRoot;
                }
                DNSDBG( READ, (
                    "ERROR:  Name (%s) failed check\n",
                    pszName ));
                goto InvalidName;
            }

            //
            //  read non-empty label
            //      - label length validity
            //      - detect non-numeric labels
            //      (easier to handle numeric name check, by detecting non-numeric)
            //

            if ( labelCharCount > DNS_MAX_LABEL_LENGTH )
            {
                DNSDBG( READ, ( "ERROR:  Name failed label count check\n" ));
                goto InvalidName;
            }

            if ( labelNumberCount != labelCharCount )
            {
                fnameNonNumeric = TRUE;
                if ( labelCount == 0 )
                {
                    flabelNonNumeric = TRUE;
                }
            }

            //  count label
            //      - stop if NULL terminator
            //      - otherwise, reset for next label and continue

            labelCount++;
            if ( ch == 0 )
            {
                break;
            }
            labelCharCount = 0;
            labelNumberCount = 0;
            continue;
        }

        //
        //  non-RFC
        //      - currently accepting only "_" as allowable as part of
        //      microsoft acceptable non-RFC set
        //
        //      however DNS server must be able to read *, \, etc
        //      it gets called through Dns_CreateStandardDnsName()
        //
        //  note, could tighten this up with special flag, but since
        //  this only speeds case with invalid chars, there's not much
        //  point;  underscore is likely to see significant use
        //

        //  underscore
        //      - can be valid as part of SRV domain name
        //      - otherwise non-RFC

        if ( ch == '_' )
        {
            if ( labelCharCount == 1 &&
                 (*pch && *pch!= '.') &&
                 (dwFlag & DNSVAL_ALLOW_LEADING_UNDERSCORE) )
            {
                continue;
            }
            fnonRfc = TRUE;
            continue;
        }

        //  backslash
        //      - used to denote classless in-addr domains
        //      - so valid even as zone name on server
        //      - otherwise completely invalid

        else if ( ch == '/' )
        {
            if ( dwFlag & DNSVAL_ALLOW_BACKSLASH )
            {
                continue;
            }
        }

        //  asterisk
        //      - valid only as single-byte first label in wildcard name
        //      - otherwise completely invalid

        else if ( ch == '*' )
        {
            if ( labelCount == 0 &&
                labelCharCount == 1 &&
                 ( *pch==0 || *pch=='.') &&
                 (dwFlag & DNSVAL_ALLOW_ASTERISK) )
            {
                continue;
            }
        }

        //  anything else is complete junk
        //
        //  JENHANCE:  if desired, could break out printable\non

        fnonRfc = TRUE;
        finvalidChar = TRUE;
        DNSDBG( READ, ( "ERROR:  Name character %c failed check\n", ch ));
        continue;
    }

Done:

    //  verify total name length
    //  to fit in wire 255 limit:
    //      - FQDN can be up to 254
    //      - non-FQDN can be up to 253

    pch--;
    DNS_ASSERT( pch > pszName );
    labelCharCount = (INT)(pch - pszName);

    if ( !fqdn )
    {
        labelCharCount++;
    }
    if ( labelCharCount >= DNS_MAX_NAME_LENGTH )
    {
        DNSDBG( READ, ( "ERROR:  Name failed final length check\n" ));
        goto InvalidName;
    }

DoneRoot:

    //
    //  return flags
    //
    //  JENHANCE:  all returns from validateNamePrivate() could come
    //      as result flag;   then charset issues could be separated
    //      out by higher level routine
    //

    *pLabelCount = labelCount;

    flag = 0;
    if ( fqdn )
    {
        flag |= DNS_BIT_NAME_FQDN;
    }
    if ( ! fnameNonNumeric )
    {
        flag |= DNS_BIT_NAME_NUMERIC;
    }
    if ( ! flabelNonNumeric )
    {
        flag |= DNS_BIT_NAME_NUMERIC_FIRST_LABEL;
    }
    *pResultFlag = flag;

    //
    //  return status
    //      ERROR_SUCCESS -- full RFC name
    //      DNS_ERROR_NON_RFC_NAME -- MS extended and '_' names
    //      DNS_ERROR_INVALID_NAME_CHAR -- syntaxtically valid, but bad chars
    //      ERROR_INVALID_NAME -- syntaxtically invalid name
    //

    status = ERROR_SUCCESS;

    if ( finvalidChar )
    {
        status = DNS_ERROR_INVALID_NAME_CHAR;
    }
    else if ( fnonRfc )
    {
        status = DNS_ERROR_NON_RFC_NAME;
    }

    DNSDBG( READ, (
        "Leave validateNamePrivate(), status = %d\n",
        status ));

    return( status );


InvalidName:

    DNSDBG( READ, (
        "Leave validateNamePrivate(), status = ERROR_INVALID_NAME\n" ));

    *pLabelCount = 0;
    *pResultFlag = 0;
    return( ERROR_INVALID_NAME );
}



DNS_STATUS
Dns_ValidateName_UTF8(
    IN      LPCSTR          pszName,
    IN      DNS_NAME_FORMAT Format
    )
/*++

Routine Description:

    Verifies name is valid DNS name.

Arguments:

    pszName -- DNS name (standard dotted form) to check

    Format -- required format of DNS name

Return Value:

    ERROR_SUCCESS               -- completely RFC compliant name
    DNS_ERROR_NON_RFC_NAME      -- syntax valid, but not standard RFC name
    DNS_ERROR_NUMERIC_NAME      -- syntax valid, but numeric label violation
    DNS_ERROR_INVALID_NAME_CHAR -- syntax valid, but invalid characters
    ERROR_INVALID_NAME          -- name completely useless, bogus, toast

--*/
{
    DNS_STATUS  status;
    DWORD       labelCount;
    BOOL        isFqdn;
    DWORD       flag = 0;
    DWORD       resultFlag = 0;


    DNSDBG( TRACE, (
        "Dns_ValidateName_UTF8()\n"
        "\tname     = %s\n"
        "\tformat   = %d\n",
        pszName,
        Format
        ));

    if ( !pszName )
    {
        return( ERROR_INVALID_NAME );
    }

    //
    //  special casing?
    //
    //  SRV records can have leading underscores
    //  wildcards can have first label "*"
    //  backslash ok in classless in-addr domains
    //

    switch( Format )
    {
#if 0
    case DnsNameServerZonePrivate:

        flag = DNSVAL_ALLOW_BACKSLASH | DNSVAL_ALLOW_LEADING_UNDERSCORE;
#endif

    case DnsNameWildcard:

        flag = DNSVAL_ALLOW_ASTERISK;
        break;

    case DnsNameSrvRecord:

        flag = DNSVAL_ALLOW_LEADING_UNDERSCORE;
        break;
    }

    //
    //  do validation
    //
    //  return immediately on invalid name, so type
    //  specific returns do not overwrite this error
    //

    status = validateDnsNamePrivate(
                pszName,
                flag,
                & labelCount,
                & resultFlag
                );
    if ( status == ERROR_INVALID_NAME )
    {
        return( status );
    }

    //
    //  do name type specific validation
    //

    switch( Format )
    {
    //  domain name -- any valid non-numeric DNS name

    case DnsNameDomain:

        if ( resultFlag & DNS_BIT_NAME_NUMERIC )
        {
            return( DNS_ERROR_NUMERIC_NAME );
        }
        return( status );

    //  domain name label -- any valid single-label DNS name

    case DnsNameDomainLabel:

        if ( labelCount != 1 || resultFlag & DNS_BIT_NAME_FQDN )
        {
            return( ERROR_INVALID_NAME );
        }
        return( status );

    //  hostname full -- non-numeric hostname label

    case DnsNameHostnameFull:

        if ( resultFlag & DNS_BIT_NAME_NUMERIC_FIRST_LABEL )
        {
            return( DNS_ERROR_NUMERIC_NAME );
        }
        return( status );

    //  hostname label -- single label and non-numeric

    case DnsNameHostnameLabel:

        if ( labelCount != 1 || resultFlag & DNS_BIT_NAME_FQDN )
        {
            return( ERROR_INVALID_NAME );
        }
        if ( resultFlag & DNS_BIT_NAME_NUMERIC_FIRST_LABEL )
        {
            return( DNS_ERROR_NUMERIC_NAME );
        }
        return( status );

    //
    //  wildcard -- single "*" as first label
    //      if *.???? then must revalidate the rest of the name as
    //          "*" has probably resulted in validation error
    //      if "*" then consider this successful
    //

    case DnsNameWildcard:

        if ( *pszName == '*' )
        {
            return( status );
        }
        return( ERROR_INVALID_NAME );

    //
    //  SRV label -- validate leading underscore
    //

    case DnsNameSrvRecord:

        if ( *pszName == '_' )
        {
            return( status );
        }
        return( ERROR_INVALID_NAME );

    //
    //  unknown format validation
    //

    default:

        return( ERROR_INVALID_PARAMETER );
    }
}


DNS_STATUS
Dns_ValidateName_W(
    IN      LPCWSTR         pwszName,
    IN      DNS_NAME_FORMAT Format
    )
/*++

Routine Description:

    Verifies name is valid DNS name.

Arguments:

    pwszName -- DNS name (standard dotted form) to check

    Format -- required format of DNS name

Return Value:

    ERROR_SUCCESS -- if completely compliant name
    DNS_ERROR_NON_RFC_NAME -- if not standard RFC name
    ERROR_INVALID_NAME -- if name completely useless, bogus, toast

--*/
{
    DWORD   nameLength = MAX_PATH;
    CHAR    nameBuffer[ MAX_PATH ] = {0};   // init for prefix

    //
    //  convert name to UTF8
    //      - if can't convert, then can't fit into buffer
    //      so must be invalid name on length grounds
    //

    if ( ! Dns_NameCopy(
                nameBuffer,
                & nameLength,       // avail buf length
                (PCHAR) pwszName,
                0,                  // unknown length
                DnsCharSetUnicode,  // unicode in
                DnsCharSetUtf8      // UTF8 out
                ) )
    {
        return( ERROR_INVALID_NAME );
    }

    //
    //  validate name in UTF8 format

    return Dns_ValidateName_UTF8(
                (LPCSTR) nameBuffer,
                Format );
}



DNS_STATUS
Dns_ValidateName_A(
    IN      LPCSTR          pszName,
    IN      DNS_NAME_FORMAT Format
    )
/*++

Routine Description:

    Verifies name is valid DNS name.

Arguments:

    pszName -- DNS name (standard dotted form) to check

    Format -- required format of DNS name

Return Value:

    ERROR_SUCCESS -- if completely compliant name
    DNS_ERROR_NON_RFC_NAME -- if not standard RFC name
    ERROR_INVALID_NAME -- if name completely useless, bogus, toast

--*/
{
    DWORD   nameLength = MAX_PATH;
    CHAR    nameBuffer[ MAX_PATH ];

    //
    //  convert name to UTF8
    //      - if can't convert, then can't fit into buffer
    //      so must be invalid name on length grounds
    //

    if ( ! Dns_NameCopy(
                nameBuffer,
                & nameLength,       // avail buf length
                (PCHAR) pszName,
                0,                  // unknown length
                DnsCharSetAnsi,     // unicode in
                DnsCharSetUtf8      // UTF8 out
                ) )
    {
        return( ERROR_INVALID_NAME );
    }

    //
    //  validate name in UTF8 format

    return Dns_ValidateName_UTF8(
                (LPCSTR) nameBuffer,
                Format );
}



DNS_STATUS
Dns_ValidateDnsString_UTF8(
    IN      LPCSTR          pszString
    )
/*++

Routine Description:

    Verifies string is valid DNS string.

Arguments:

    pszString -- DNS string (standard dotted form) to check

Return Value:

    ERROR_SUCCESS -- if completely compliant string
    ERROR_INVALID_DATA -- otherwise

--*/
{
    PUCHAR      pch = (PUCHAR) pszString;
    UCHAR       ch;
    DWORD       trailCount = 0;

    DNSDBG( TRACE, ( "Dns_ValidateDnsString_UTF8()\n" ));

    if ( !pszString )
    {
        return( ERROR_INVALID_DATA );
    }

    //
    //  validations
    //      - string length (255)
    //      - UTF8 chars valid
    //      - no unprintable characters
    //

    while ( ch = *pch++ )
    {
        if ( ch & 0x80 )
        {
            DWORD status;
            status = Dns_ValidateUtf8Byte(
                        ch,
                        & trailCount );
            if ( status != ERROR_SUCCESS )
            {
                return( status );
            }
        }

        else if ( ch < ' ' )
        {
            return( ERROR_INVALID_DATA );
        }
    }

    //  verify string length ok

    if ( pch - pszString > DNS_MAX_NAME_LENGTH )
    {
        return( ERROR_INVALID_DATA );
    }
    return( ERROR_SUCCESS );
}



DNS_STATUS
Dns_ValidateDnsString_W(
    IN      LPCWSTR     pszString
    )
/*++

Routine Description:

    Verifies string is valid DNS string.

    Not sure there's any need to UNICODE string routine.

Arguments:

    pszString -- DNS string

Return Value:

    ERROR_SUCCESS -- if completely compliant string
    ERROR_INVALID_DATA -- otherwise

--*/
{
    INT     count;
    CHAR    stringUtf8[ DNS_MAX_NAME_BUFFER_LENGTH ];
    DWORD   bufLength = DNS_MAX_NAME_BUFFER_LENGTH;

    DNSDBG( TRACE, ( "Dns_ValidateDnsString_W()\n" ));

    if ( !pszString )
    {
        return( ERROR_INVALID_DATA );
    }

    //
    //  need to convert to unicode in order to test UTF8 (wire) length
    //      - buffer (twice max length) can hold any valid
    //      coversion of unicode name within max length
    //

    count = wcslen( pszString );
    if ( count > DNS_MAX_NAME_LENGTH )
    {
        return( ERROR_INVALID_DATA );
    }

    //
    //  convert, then test
    //

    if ( ! Dns_StringCopy(
                stringUtf8,
                & bufLength,
                (LPSTR) pszString,
                (WORD) count,
                DnsCharSetUnicode,  // unicode in
                DnsCharSetUtf8      // UTF8 out
                ) )
    {
        return( ERROR_INVALID_DATA );
    }

    return  Dns_ValidateDnsString_UTF8( stringUtf8 );
}



//
//  Name cannonicalization
//
//  Currently, clients downcase (when extended) in their locale to go to wire.
//  On server end however all names are cannonicalized.
//
//  DCR:  cannonicalize completely on client end?
//      Ideally client would do complete cannonicallization on its end.
//      The only issue is whether there are locale specific issues where
//      downcasing would be different and yield substaintially different result
//

#define MAX_DNS_DOWN_CASE_BUF_LEN 512



DWORD
Dns_MakeCanonicalNameW(
    OUT     PWSTR           pBuffer,
    IN      DWORD           BufLength,
    IN      PWSTR           pwsString,
    IN      DWORD           StringLength
    )
/*++

Routine Description:

    Create cannonical unicode DNS name.

    This name is downcased and ambiguities converted to standard
    DNS characters.

Arguments:

    pBuffer -- buffer to recv canon name

    BufLength -- length of buffer;  if 0, buffer MUST have adequate length

    pwsString -- ptr to string to copy

    StringLength -- string length, if known

Return Value:

    Count of characters converted INCLUDING NULL terminator.
    Zero on error.

--*/
{
    DWORD   inLength = StringLength;

    //
    //  verify adequate buffer length
    //
    //  DCR:  should allow non-null terminated canonicalizations?
    //
    //  note:  we allow and convert non-null terminated name
    //      the result will not necessarily be NULL terminated
    //      if buffer is exactly equal to string length
    //

    if ( inLength == 0 )
    {
        inLength = wcslen( pwsString );
        inLength++;
    }

    if ( BufLength < inLength )
    {
        DNSDBG( ANY, (
            "ERROR:  insufficient cannon buffer len = %d\n"
            "\tstring = %S, len = %d\n",
            BufLength,
            pwsString,
            inLength ));
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return( 0 );
    }

    //
    //  convert name
    //      - downcase with canonicalizing rules
    //

    inLength = LCMapStringW(
                    DNS_CANONICAL_LOCALE,
                    DNS_CANONICALIZING_FLAGS,
                    pwsString,
                    inLength,
                    pBuffer,
                    BufLength
                    );

#if DBG
    if ( inLength == 0 )
    {
        DNS_STATUS status = GetLastError();

        DNSDBG( ANY, (
            "Canonicalization failed => %d\n"
            "\tin  %S\n",
            status,
            pwsString ));

        SetLastError( status );
    }
    else
    {
        //
        //  DCR:  warning this print can blow on non-null terminated conversions
        //

        DNSDBG( READ, (
            "Canonicalized name at %p\n"
            "\tin   %S\n"
            "\tout  %S\n",
            pwsString,
            pwsString,
            (PWSTR) pBuffer ));
    }
#endif

    return( inLength );
}



DWORD
Dns_MakeCanonicalNameInPlaceW(
    IN      PWCHAR          pwString,
    IN      DWORD           StringLength
    )
/*++

Routine Description:

    In place cannonicalization of name.

Arguments:

    pwString -- ptr to string to copy

    StringLength -- length of string
        if zero string assumed to be NULL terminated, in this case
        canonicalization includes NULL terminator

Return Value:

    Count of characters converted -- including NULL terminator if
        StringLength is unspecified
    Zero on error.

--*/
{
    DWORD   nameLength = StringLength;
    WCHAR   tempBuffer[ DNS_MAX_NAME_BUFFER_LENGTH_UNICODE ] = { 0 };    // init for prefix

    DNSDBG( READ, (
        "Dns_MakeCanonicalNameInPlace()\n"
        "\tpwString = %S\n"
        "\tlength   = %d\n",
        pwString,
        StringLength ));

    //  if length unknown, must be NULL terminated string

    if ( nameLength == 0 )
    {
        nameLength = (DWORD) wcslen( pwString );
        nameLength++;
    }

    //
    //  cannonicalize (downcase and cleanup)
    //      - copy string to temp buffer
    //      - then cannonicalize into original buffer
    //

    if ( nameLength <= DNS_MAX_NAME_BUFFER_LENGTH_UNICODE )
    {
        wcsncpy( tempBuffer, pwString, nameLength );

        return  Dns_MakeCanonicalNameW(
                    pwString,       //  write back to original string
                    nameLength,     //  length of buffer
                    tempBuffer,     //  input is temp copy
                    nameLength      //  input length
                    );
    }

    return  0;
}



INT
Dns_DowncaseNameLabel(
    OUT     PCHAR           pchResult,
    //OUT     PDWORD          pNameProperty,
    IN      PCHAR           pchLabel,
    IN      DWORD           cchLabel,
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Create a downcased version of DNS name.

    This is UTF8 only routine for use by DNS server to
    validate and downcase label during node creation.

Arguments:

    pchResult -- resulting downcased label;
        MUST have MAX_LABEL_BUFFER_LENGTH

    //pNameProperty -- name properties of result
    //    ResultLength -- ptr to DWORD to recieve resulting length

    pchLabel -- ptr to label

    cchLabel -- count of bytes in label

    dwFlag -- flag indicating what names are acceptable
        strict RFC      => DNS_ALLOW_RFC_NAMES_ONLY
        non RFC names   => DNS_ALLOW_NONRFC_NAMES
        UTF8 extended   => DNS_ALLOW_MULTIBYTE_NAMES
        anything        => DNS_ALLOW_ALL_NAMES

Return Value:

    If extended name -- length of converted name.
    Zero if success.
    (-1) on error.

--*/
{
    UCHAR       ch;
    PUCHAR      pchout = pchResult;
    PUCHAR      pch = pchLabel;
    DWORD       count = cchLabel;
    DWORD       charProp;
    DWORD       trailCount = 0;
    DWORD       property = 0;


    DNSDBG( TRACE, (
        "Dns_DowncaseNameLabel( %.*s )\n"
        "\tflag = %08x\n",
        cchLabel,
        pchLabel,
        dwFlag ));

    if ( count == 0  ||  count > DNS_MAX_LABEL_LENGTH )
    {
        goto InvalidName;
    }

    //
    //  copy each character
    //      - downcasing upper case chars
    //      - detecting invalid chars (unprintable, blank, dot)
    //

    while ( count-- )
    {
        //  get next character and properties

        ch = *pch++;
        *pchout++ = ch;
        charProp = DnsCharPropertyTable[ ch ];

        //  trail count check
        //      check this first to avoid trail count check on all
        //      other char types
        //
        //  DEVNOTE:  note this screens binary labels

        if ( trailCount )
        {
            if ( (charProp & B_UTF8_TRAIL) )
            {
                trailCount--;
                continue;
            }

            DNSDBG( READ, (
                "ERROR:  Name failed trail count check at %c\n", ch ));
            property |= DNS_BIT_NAME_BINARY_LABEL;
        }

        //  full RFC
        //      - map upper case to lower case
        //      - continue

        if ( charProp & B_RFC )
        {
            if ( charProp & B_UPPER )
            {
                --pchout;
                *pchout++ = ch + 0x20;
            }
            continue;
        }

        //
        //  check for extended chars
        //      - trail characters should have been caught above
        //      - doing this first so can make single trailCount
        //      check for all other ASCII chars

        if ( ch >= 0x80 )
        {
            DWORD tempStatus;
            tempStatus = Dns_ValidateUtf8Byte(
                            ch,
                            & trailCount );
            if ( tempStatus != ERROR_SUCCESS )
            {
                DNSDBG( READ, (
                    "ERROR:  Name UTF8 trail count check at %c\n", ch ));
                goto InvalidName;
            }
            property |= DNS_BIT_NAME_MULTIBYTE;
            continue;
        }

        //
        //  non-RFC
        //      - currently accepting only "_" as allowable as part of
        //      microsoft acceptable non-RFC set
        //
        //      however DNS server must be able to read *, \, etc
        //      as these can be part of valid label
        //
        //  note, could tighten this up with special flag, but since
        //  this only speeds case with invalid chars, there's not much
        //  point;  underscore is likely to see significant use
        //

        //  underscore
        //      - can be valid as leading label as part of SRV domain name
        //      - otherwise non-RFC

        if ( ch == '_' )
        {
            if ( count == cchLabel - 1 )
            {
                continue;
            }
            property |= DNS_BIT_NAME_UNDERSCORE;
            continue;
        }

        //  backslash
        //      - used to denote classless in-addr domains
        //          must have leading and following chars
        //      - otherwise completely invalid

        else if ( ch == '/' )
        {
            if ( count != 0 && count != cchLabel-1 )
            {
                continue;
            }
        }

        //  asterisk
        //      - valid only as single-byte first label in wildcard name
        //      - otherwise completely invalid

        else if ( ch == '*' )
        {
            if ( count == 0 )
            {
                continue;
            }
        }

        //  anything else is complete junk
        //  currently only acceptable if allow binary labels
        //
        //  JENHANCE:  could break out non-RFC (printable\non)

        property |= DNS_BIT_NAME_BINARY_LABEL;
        DNSDBG( READ, ( "ERROR:  Name character %c failed check\n", ch ));
        continue;
    }

    //
    //  fill out name properties
    //
    //  JENHANCE:  full property fill out
    //
    //  currently only property we're returning is multibyte name issue
    //  as that's all the server needs to check
    //
    //  if save more properties then test becomes something like this
    //  if ( (property & dwFlags) != (property & SUPPORTED_CHECK_FLAGS) )
    //

#if 0
    //*pNameProperty = property;

    if ( (property & dwFlags) != property )
    {
        goto InvalidName;
    }

    if ( property & DNS_BIT_NAME_MULTIBYTE )
    {
        goto Extended;
    }
#endif

    //  standard RFC name -- skip the detail parsing

    if ( property == 0 )
    {
        goto Done;
    }

    //  other chars invalid unless allowing all

    if ( property & DNS_BIT_NAME_BINARY_LABEL )
    {
        if ( dwFlag != DNS_ALLOW_ALL_NAMES )
        {
            goto InvalidName;
        }
    }

    //  multibyte
    //      - do extended downcase if multibyte
    //      - do nothing if binary
    //      - for strict this is invalid

    if ( property & DNS_BIT_NAME_MULTIBYTE )
    {
        if ( dwFlag == DNS_ALLOW_MULTIBYTE_NAMES ||
            dwFlag == DNS_ALLOW_ALL_NAMES )
        {
            goto Extended;
        }
#if 0
        if ( dwFlag != DNS_BINARY_LABELS )
        {
            goto InvalidName;
        }
#endif
        goto InvalidName;
    }

    //  underscore valid unless completely strict

    if ( property & DNS_BIT_NAME_UNDERSCORE )
    {
        if ( dwFlag == DNS_ALLOW_RFC_NAMES_ONLY )
        {
            goto InvalidName;
        }
    }

Done:

    //
    //  NULL terminate, return success.
    //

    *pchout = 0;
    return( 0 );


Extended:

    //
    //  DCR:  better approach to extended names
    //      1) cannonicalize upfront
    //          - do whole name in one pass
    //          - no need to upcase here, similar to validateName() routine
    //      2) cannonicalize here
    //          - detect extended
    //          - cannonicalize here
    //          - single recursion into routine like validateName()
    //

    //
    //  extended character encountered
    //      - convert to unicode
    //      - downcase
    //      - convert back to UTF8
    //

    //
    //  DCR_PERF:  optimize for names where extended already downcased
    //
    //  DCR_PERF:  should wrap this code into UTF8 cannon routine
    //


    //if ( ! (dwFlags & DNS_ALLOW_ALREADY_EXTENDED_DOWN) )
    {
        DWORD   length;
        WCHAR   unicodeString[ DNS_MAX_LABEL_BUFFER_LENGTH ];
#if DBG
        WCHAR   originalName[ DNS_MAX_LABEL_BUFFER_LENGTH ];
        WCHAR   downName[ DNS_MAX_LABEL_BUFFER_LENGTH ];
        WCHAR   cannonDownName[ DNS_MAX_LABEL_BUFFER_LENGTH ];
#endif

        DNSDBG( READ, (
            "Extended character encountered downcasing string %*.s\n"
            "\tconverting to unicode for case conversion\n",
            cchLabel,
            pchLabel ));

        length = Dns_Utf8ToUnicode(
                     pchResult,
                     cchLabel,
                     unicodeString,
                     DNS_MAX_LABEL_BUFFER_LENGTH
                     );
        DNSDBG( READ, (
            "Unicode converted string %.*S\n"
            "\tlength = %d\n"
            "\tlast error = %d\n",
            length,
            unicodeString,
            length,
            GetLastError() ));

        if ( length == 0 )
        {
            DNSDBG( READ, (
                "Rejecting invalid UTF8 string %.*s\n"
                "\tFailed conversion to unicode OR conversion created\n"
                "\tinvalid unicode string\n",
                cchLabel,
                pchResult ));
            goto InvalidName;
        }

        //  no possible conversion of valid length UTF8, can
        //  overflow unicode buffer

        ASSERT( length <= DNS_MAX_LABEL_LENGTH );

        Dns_MakeCanonicalNameInPlaceW( unicodeString, length );
#if 1
        DNSDBG( READ, (
            "Canonical unicode name %.*S\n"
            "\tlength = %d\n",
            length,
            unicodeString,
            length ));
#endif

        //
        //  reconvert to UTF8
        //      - mapping to UTF8 is just math, so only error
        //      is possibly overflowing UTF8 max label buffer
        //      - catch this error is character count changes
        //      note, that also must catch case where write fills
        //      64 byte buffer eliminating NULL terminator
        //

        length = Dns_UnicodeToUtf8(
                     unicodeString,
                     length,
                     pchResult,
                     DNS_MAX_LABEL_BUFFER_LENGTH
                     );
        DNSDBG( READ, (
            "UTF8 downcased string %.*s\n"
            "\tlength = %d\n",
            length,
            pchResult,
            length ));

        if ( length != cchLabel )
        {
            DNSDBG( ANY, (
                "Downcasing UTF8 label %.*s, changed character count!\n"
                "\tfrom %d to %d\n"
                "\tResult name %.*s\n"
                "\tlast error = %d\n",
                cchLabel,
                pchLabel,
                cchLabel,
                length,
                length,
                pchResult,
                GetLastError() ));

            if ( length == 0 || length > DNS_MAX_LABEL_LENGTH )
            {
                DNSDBG( ANY, (
                    "Failed conversion of downcased unicode string %S\n"
                    "\tback into UTF8.\n",
                    unicodeString ));
                goto InvalidName;
            }
        }

        //
        //  NULL terminate, return length to indicate extended name
        //

        pchResult[ length ] = 0;
        return( (INT)length );
    }

    // no UTF8 multi-byte allowed -- drop through to invalid name return


InvalidName:

    //  return (-1) for error

    DNSDBG( READ, (
        "Dns_DowncaseNameLabel() found label to be invalid.\n"
        "\tlabel        = %.*s\n"
        "\tcount        = %d\n"
        "\tproperty     = %08x\n",
        cchLabel,
        pchLabel,
        count,
        property ));

    return( -1 );
}



LPSTR
Dns_CreateStandardDnsNameCopy(
    IN      PCHAR           pchName,
    IN      DWORD           cchName,
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Makes copy of DNS name in valid "standard form"
        - downcased
        - no trailing dot (to avoid confusing DS)

Arguments:

    pchName -- ptr DNS name in UTF8

    cchName -- count of chars in name;  may be NULL

    dwFlag  -- strict checking flags;  currently ignored

Return Value:

    Ptr to copy of DNS name.
    NULL on invalid name.

--*/
{
    PCHAR       pszcopy = NULL;
    DNS_STATUS  status;
    DWORD       length;

    DNSDBG( TRACE, ( "Dns_CreateStandardDnsName()\n" ));
    DNSDBG( READ, (
        "Dns_CreateStandardDnsName()\n"
        "\tpchName = %.*s\n"
        "\tcchName = %d\n",
        cchName,
        pchName,
        cchName ));

    if ( !pchName )
    {
        status = ERROR_INVALID_NAME;
        goto Failed;
    }

    //
    //  ASCII string?
    //

    if ( Dns_IsStringAsciiEx( pchName, cchName ) )
    {
        //
        //  make copy
        //

        pszcopy = Dns_CreateStringCopy( pchName, cchName );
        if ( !pszcopy )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Failed;
        }

        //
        //  validate, check against strict criteria
        //
        //  no validation until relax criteria
        //
        //  DCR:  name validation within Dns_CreateStandardNameCopy()
        //      accept anything except INVALID_NAME
        //      flags return FQDN info
        //
#if 0
        status = Dns_ValidateName_UTF8( pszcopy, DnsNameDomain );
        if ( status == ERROR_INVALID_NAME )
        {
            goto Failed;
        }
#endif
        //
        //  downcase
        //  remove any trailing dot, except for root name
        //

        _strlwr( pszcopy );
        length = strlen( pszcopy );
        if ( length == 0 )
        {
            status = ERROR_INVALID_NAME;
            goto Failed;
        }
        length--;
        if ( length > 0 && pszcopy[length] == '.' )
        {
            pszcopy[length] = 0;
        }

        DNSDBG( READ, (
            "Standard DNS name copy of %.*s is %s\n",
            cchName,
            pchName,
            pszcopy ));
        return( pszcopy );
    }

    //
    //  unicode name
    //

    else
    {
        WCHAR   unicodeName[ DNS_MAX_NAME_BUFFER_LENGTH ];
        WCHAR   cannonicalName[ DNS_MAX_NAME_BUFFER_LENGTH ];
        DWORD   unicodeBufferLength;

        //
        //  convert to unicode
        //      - buf length is in bytes
        //

        unicodeBufferLength = DNS_MAX_NAME_BUFFER_LENGTH * 2;

        length = Dns_NameCopy(
                    (PSTR) unicodeName,
                    & unicodeBufferLength,
                    pchName,
                    cchName,
                    DnsCharSetUtf8,
                    DnsCharSetUnicode
                    );
        if ( length == 0 )
        {
            DNSDBG( ANY, (
                "ERROR conversion of name %.*s to unicode failed!\n",
                cchName,
                pchName ));
            status = ERROR_INVALID_NAME;
            goto Failed;
        }

        //
        //  make cannonical name
        //      - buf length is in unicode characters
        //      - output length is in unicode chars

        length = Dns_MakeCanonicalNameW(
                    cannonicalName,
                    length / 2,
                    unicodeName,
                    dwFlag );

        ASSERT( length != 0 );
        if ( length == 0 )
        {
            status = ERROR_INVALID_NAME;
            goto Failed;
        }

        //
        //  allocate UTF8 converted copy
        //      - this conversion should never fail
        //      - string length is unicode chars
        //

        pszcopy = Dns_StringCopyAllocate(
                    (PSTR) cannonicalName,
                    length,
                    DnsCharSetUnicode,      // unicode in
                    DnsCharSetUtf8          // UTF8 out
                    );
        if ( !pszcopy )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Failed;
        }

        //
        //  validate, check against strict criteria
        //
        //  no validation until relax criteria
        //
        //  DCR:  name validation within Dns_CreateStandardNameCopy()
        //      accept anything except INVALID_NAME
        //      flags return FQDN info
        //
#if 0
        status = Dns_ValidateName_UTF8( pszcopy, DnsNameDomain );
        if ( status == ERROR_INVALID_NAME )
        {
            goto Failed;
        }
#endif
        return( pszcopy );
    }

Failed:

    FREE_HEAP( pszcopy );
    SetLastError( status );
    return( NULL );
}



//
//  Public compare functions
//

#if DNSWIN95

//
//  Running 9x - exposing for debug
//

#define WIN9X_FLAG_START_VAL    (0x1111)

BOOL    g_fWin9x = WIN9X_FLAG_START_VAL;


BOOL
Dns_IsWin9x(
    VOID
    )
/*++

Routine Description:

    Are we on Win9x

Arguments:

    None

Return Value:

    TRUE if on Win9x
    FALSE otherwise

--*/
{
    //
    //  if not yet queried, query for system version
    //  Win9x (and Win3.1) have high bit set, regardless of major version
    //
    //  for Win9x set locale to system default, as we'll use the CRT
    //  functions to do name comparisons (CompareStringW() is a non-implemented
    //  stub on Win9x
    //      - LC_ALL sets for all CRT functions
    //      - "" sets to system default code page
    //

    if ( g_fWin9x == WIN9X_FLAG_START_VAL )
    {
        if ( GetVersion() & 0x80000000 )
        {
            g_fWin9x = TRUE;
            setlocale( LC_ALL, "" );
        }
        else
        {
            g_fWin9x = FALSE;
        }
    }

    return( g_fWin9x );
}
#endif



BOOL
Dns_NameCompare_A(
    IN      PCSTR           pName1,
    IN      PCSTR           pName2
    )
/*++

Routine Description:

    Compare two DNS names.

    Can not use stricmp() because of the possiblity of names with
    trailing dots.

Arguments:

    pName1 - ptr to first DNS name string (dotted format)
    pName2 - ptr to second DNS name string (dotted format)

Return Value:

    TRUE if names equal.
    FALSE otherwise.

--*/
{
    INT len1;
    INT len2;
    INT result;

    //
    //  flat out match
    //      - this is possible with owner names and possibly other fields
    //

    if ( pName1 == pName2 )
    {
        return( TRUE );
    }

    if ( !pName1 || !pName2 )
    {
        return( FALSE );
    }

    //
    //  if lengths NOT equal, then
    //  they must be within one and longer string must have trailing dot
    //      - in this case save
    //

    len1 = strlen( pName1 );
    len2 = strlen( pName2 );

    if ( len2 != len1 )
    {
        if ( len2 == len1+1 )
        {
            if ( pName2[len1] != '.' )
            {
                return( FALSE );
            }
            //  len1 is comparable length
        }
        else if ( len2+1 == len1 )
        {
            if ( pName1[len2] != '.' )
            {
                return( FALSE );
            }
            //  len1 is set to comparable length
            len1 = len2;
        }
        else
        {
            return( FALSE );
        }
    }

    //
    //  compare only comparable length of string
    //

    result = CompareStringA(
                //LOCALE_SYSTEM_DEFAULT,
                DNS_CANONICAL_LOCALE,
                DNS_CANONICAL_COMPARE_FLAGS,
                pName1,
                len1,
                pName2,
                len1 );

    if ( result == CSTR_EQUAL )
    {
        return( TRUE );
    }

    //  not equal or error

    return( FALSE );
}



BOOL
Dns_NameCompare_W(
    IN      PCWSTR          pName1,
    IN      PCWSTR          pName2
    )
/*++

Routine Description:

    Compare two (Wide) DNS names.

    Note:  this is unicode aware, it assumes names in WCHAR string
    format. Can not use stricmp() because of the possiblity of names
    with trailing dots.

Arguments:

    pName1 - ptr to first DNS name string (dotted format)
    pName2 - ptr to second DNS name string (dotted format)

Return Value:

    TRUE if names equal.
    FALSE otherwise.

--*/
{
    INT len1;
    INT len2;
    INT result;

    //
    //  flat out match
    //      - this is possible with owner names and possibly other fields
    //

    if ( pName1 == pName2 )
    {
        return( TRUE );
    }

    if ( !pName1 || !pName2 )
    {
        return( FALSE );
    }

    //
    //  if lengths NOT equal, then
    //  they must be within one and longer string must have trailing dot
    //      - in this case save
    //

    len1 = wcslen( pName1 );
    len2 = wcslen( pName2 );

    if ( len2 != len1 )
    {
        if ( len2 == len1+1 )
        {
            if ( pName2[len1] != L'.' )
            {
                return( FALSE );
            }
            //  len1 is comparable length
        }
        else if ( len2+1 == len1 )
        {
            if ( pName1[len2] != L'.' )
            {
                return( FALSE );
            }
            //  len1 is set to comparable length
            len1 = len2;
        }
        else
        {
            return( FALSE );
        }
    }

    //
    //  compare only comparable length of string
    //

#if DNSWIN95
    //
    //  Win9x does not currently support CompareStringW()
    //

    if ( Dns_IsWin9x() )
    {
        return( !_wcsnicmp( pName1, pName2, len1 ) );
    }
#endif

    result = CompareStringW(
                //LOCALE_SYSTEM_DEFAULT,
                DNS_CANONICAL_LOCALE,
                DNS_CANONICAL_COMPARE_FLAGS,
                pName1,
                len1,
                pName2,
                len1 );

    if ( result == CSTR_EQUAL )
    {
        return( TRUE );
    }

    //  not equal or error

    return( FALSE );
}



BOOL
Dns_NameCompare_UTF8(
    IN      PCSTR           pName1,
    IN      PCSTR           pName2
    )
/*++

Routine Description:

    Compare two DNS names.

Arguments:

    pName1 - ptr to first DNS name string (dotted format)
    pName2 - ptr to second DNS name string (dotted format)

Return Value:

    TRUE if names equal.
    FALSE otherwise.

--*/
{
    WCHAR   nameBuffer1[ DNS_MAX_NAME_BUFFER_LENGTH ];
    WCHAR   nameBuffer2[ DNS_MAX_NAME_BUFFER_LENGTH ];
    DWORD   bufLen;

    //
    //  flat out match
    //      - this is possible with owner names and possibly other fields
    //

    if ( pName1 == pName2 )
    {
        return( TRUE );
    }

    if ( !pName1 || !pName2 )
    {
        return( FALSE );
    }

    //
    //  if strings pure ASCII, then use ANSI version
    //

    if ( Dns_IsStringAscii( (PCHAR)pName1 ) &&
         Dns_IsStringAscii( (PCHAR)pName2 ) )
    {
        return Dns_NameCompare_A( pName1, pName2 );
    }

    //
    //  otherwise must take names back to unicode to compare
    //

    bufLen = DNS_MAX_NAME_LENGTH;

    if ( ! Dns_NameCopy(
                (PCHAR) nameBuffer1,
                & bufLen,
                (PCHAR) pName1,
                0,              // length unknown
                DnsCharSetUtf8,
                DnsCharSetUnicode
                ) )
    {
        return( FALSE );
    }

    bufLen = DNS_MAX_NAME_LENGTH;

    if ( ! Dns_NameCopy(
                (PCHAR) nameBuffer2,
                & bufLen,
                (PCHAR) pName2,
                0,              // length unknown
                DnsCharSetUtf8,
                DnsCharSetUnicode
                ) )
    {
        return( FALSE );
    }

    return Dns_NameCompare_W( nameBuffer1, nameBuffer2 );
}



BOOL
Dns_NameComparePrivate(
    IN      PCSTR           pName1,
    IN      PCSTR           pName2,
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Compare two DNS names.

    This is simply helpful utility to avoid coding the wide\narrow
    test in the code in a hundred different places.

Arguments:

    pName1 - ptr to first DNS name string (dotted format)
    pName2 - ptr to second DNS name string (dotted format)

Return Value:

    TRUE if names equal.
    FALSE otherwise.

--*/
{
    if ( CharSet == DnsCharSetUnicode )
    {
        return Dns_NameCompare_W(
                    (PCWSTR) pName1,
                    (PCWSTR) pName2 );
    }
    else if ( CharSet == DnsCharSetAnsi )
    {
        return Dns_NameCompare_A(
                    pName1,
                    pName2 );
    }
    else
    {
        return Dns_NameCompare_UTF8(
                    pName1,
                    pName2 );
    }
}



//
//  Advanced name comparison
//  Includes hierarchial name relationship.
//

DNS_NAME_COMPARE_STATUS
Dns_NameCompareEx(
    IN      PCSTR           pszNameLeft,
    IN      PCSTR           pszNameRight,
    IN      DWORD           dwReserved,
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Advanced compare of DNS names, including hierarchial relationship.

Arguments:

    pszNameLeft -- left name

    pszNameRight -- right name

    dwReserved -- reserved for future use (type of comparison)

    CharSet -- char set of names

Return Value:

    DnsNameCompareInvalid       -- one of the names was invalid
    DnsNameCompareEqual         -- names are equal
    DnsNameCompareLeftParent    -- left is ancestor of right name
    DnsNameCompareRightParent   -- right is ancestor of left name
    DnsNameCompareNotEqual      -- name not equal, no hierarchial relationship

--*/
{
    DNS_NAME_COMPARE_STATUS result;
    DNS_STATUS  status;
    INT         lengthLeft;
    INT         lengthRight;
    INT         lengthDiff;
    INT         compareResult;
    DWORD       bufLength;
    WCHAR       nameLeft[ DNS_MAX_NAME_BUFFER_LENGTH ];
    WCHAR       nameRight[ DNS_MAX_NAME_BUFFER_LENGTH ];


    DNSDBG( TRACE, (
        "Dns_NameCompareEx( %s%S, %s%S )\n",
        (CharSet==DnsCharSetUnicode) ? "" : pszNameLeft,
        (CharSet==DnsCharSetUnicode) ? pszNameLeft : "",
        (CharSet==DnsCharSetUnicode) ? "" : pszNameRight,
        (CharSet==DnsCharSetUnicode) ? pszNameRight : ""
        ));

    //
    //  implementation note
    //  there's a lot of inefficiency here, because there are
    //  two different character sets required for
    //      validation -- UTF8 to check packet limits
    //      downcasing\comparison -- unicode for case insensitivity
    //
    //  obviously there are much more efficient paths through this
    //  morass for particular special cases (ASCII names:  downcase
    //  in ANSI, validate, compare);  but since this is not perf
    //  path code we'll take the approach
    //      - convert to unicode
    //      - validate (which will convert at copy to UTF8)
    //      - downcase unicode
    //      - compare unicode
    //

    //
    //  validate args
    //

    if ( ! pszNameLeft || ! pszNameRight )
    {
         goto Invalid;
    }

    //
    //  copy convert to unicode
    //      - downcasing and compare will be done in unicode
    //      - return lengths are bytes converted, convert to string lengths
    //      - Dns_NameCopy() returns zero for invalid convert
    //

    bufLength = DNS_MAX_NAME_BUFFER_LENGTH * 2;

    lengthLeft = (INT) Dns_NameCopy(
                            (PCHAR) nameLeft,
                            & bufLength,
                            (LPSTR) pszNameLeft,
                            0,                     // string NULL terminated
                            CharSet,               // char set in
                            DnsCharSetUnicode      // unicode out
                            );
    if ( lengthLeft == 0 )
    {
        goto Invalid;
    }
    lengthLeft = (lengthLeft/2) - 1;
    ASSERT( lengthLeft >= 0 );

    bufLength = DNS_MAX_NAME_BUFFER_LENGTH * 2;

    lengthRight = (INT) Dns_NameCopy(
                            (PCHAR) nameRight,
                            & bufLength,
                            (LPSTR) pszNameRight,
                            0,                     // string NULL terminated
                            CharSet,               // char set in
                            DnsCharSetUnicode      // unicode out
                            );
    if ( lengthRight == 0 )
    {
        goto Invalid;
    }
    lengthRight = (lengthRight/2) - 1;
    ASSERT( lengthRight >= 0 );

    //
    //  cannonicalize names
    //

    Dns_MakeCanonicalNameInPlaceW( nameLeft, lengthLeft );
    Dns_MakeCanonicalNameInPlaceW( nameRight, lengthRight );

    //
    //  validate names
    //      - must screen empty string or we can fault below
    //

    status = Dns_ValidateName_W( nameLeft, DnsNameDomain );
    if ( ERROR_SUCCESS != status &&
         DNS_ERROR_NON_RFC_NAME != status )
    {
        goto Invalid;
    }

    status = Dns_ValidateName_W( nameRight, DnsNameDomain );
    if ( ERROR_SUCCESS != status &&
         DNS_ERROR_NON_RFC_NAME != status )
    {
        goto Invalid;
    }

    //
    //  add trailing dots
    //
    //  we need to either add or remove trailing dots to make comparisons
    //  the advantage of adding them is that then, the root name does
    //  not require any special casing -- the root is the ancestor of
    //  every name
    //

    if ( nameLeft[ lengthLeft-1 ] != (WORD)'.')
    {
        nameLeft[ lengthLeft++ ]    = (WORD) '.';
        nameLeft[ lengthLeft ]      = (WORD) 0;
    }
    if ( nameRight[ lengthRight-1 ] != (WORD)'.')
    {
        nameRight[ lengthRight++ ]  = (WORD) '.';
        nameRight[ lengthRight ]    = (WORD) 0;
    }

    //
    //  compare equal length strings
    //

    result = DnsNameCompareNotEqual;

    lengthDiff = (INT)lengthLeft - (INT)lengthRight;

    if ( lengthLeft == lengthRight )
    {
        compareResult = wcscmp( nameLeft, nameRight );
        if ( compareResult == 0 )
        {
            result = DnsNameCompareEqual;
        }
        goto Done;
    }

    //
    //  strings not equal
    //      - compare smaller string of length X
    //      to last X characters of larger string
    //      - also must make sure starting at label boundary
    //
    //      note: strstr() is NOT useful for this work, because it
    //      compares useless for this work because it is finding the
    //      first match -- a little thought would indicate that this
    //      will fail in several obvious cases
    //

    //  right string longer
    //      - need to sign change diff to make it offset in right string

    else if ( lengthDiff < 0 )
    {
        lengthDiff = -lengthDiff;

        if ( nameRight[ lengthDiff-1 ] != L'.' )
        {
            goto Done;
        }
        compareResult = wcscmp( nameLeft, nameRight+lengthDiff );
        if ( compareResult == 0 )
        {
            result = DnsNameCompareLeftParent;
        }
        goto Done;
    }

    //  left string longer
    //      - lengthDiff is offset into left string to start compare

    else
    {
        if ( nameLeft[ lengthDiff-1 ] != L'.' )
        {
            goto Done;
        }
        compareResult = wcscmp( nameLeft+lengthDiff, nameRight );
        if ( compareResult == 0 )
        {
            result = DnsNameCompareRightParent;
        }
        goto Done;
    }

Done:

    DNSDBG( TRACE, (
        "Leave DnsNameCompareEx() result = %d\n",
        result ));

    return( result );

Invalid:

    DNSDBG( ANY, (
        "ERROR:  Invalid name to Dns_NameCompareEx()\n" ));

    return( DnsNameCompareInvalid );
}



//
//  Random name utilities
//

PCHAR
_fastcall
Dns_GetDomainName(
    IN      PCSTR           pszName
    )
/*++

Routine Description:

    Get domain name of DNS name.

    Note, this assumes name already in UTF-8

Arguments:

    pszName - standard dotted DNS name

Return Value:

    Ptr to domain name of pszName.
    NULL if pszName is in root domain.

--*/
{
    CHAR    ch;

    //
    //  find next "." in name, then return ptr to next character
    //

    while( ch = *pszName++ )
    {
        if ( ch == '.' )
        {
            if ( *pszName )
            {
                return( (PCHAR)pszName );
            }
            return( NULL );
        }
    }
    return( NULL );
}


PWSTR
_fastcall
Dns_GetDomainName_W(
    IN      PCWSTR          pwsName
    )
{
    PWSTR  pdomain;

    //
    //  find next "." in name, then return ptr to next character
    //

    pdomain = wcschr( pwsName, L'.' );

    if ( pdomain && *(++pdomain) )
    {
        return( pdomain );
    }
    return  NULL;
}



PCHAR
_fastcall
Dns_GetTldForName(
    IN      PCSTR           pszName
    )
/*++

Routine Description:

    Get domain name of DNS name.

    Note, this assumes name already in UTF-8

Arguments:

    pszName - standard dotted DNS name

Return Value:

    Ptr to domain name of pszName.
    NULL if pszName is in root domain.

--*/
{
    PSTR    pdomain = (PSTR) pszName;
    PSTR    ptld = NULL;

    //
    //  find last domain name in name
    //

    while ( pdomain = Dns_GetDomainName(pdomain) )
    {
        ptld = (PSTR) pdomain;
    }
    return  ptld;
}



BOOL
_fastcall
Dns_IsNameShort(
    IN      PCSTR           pszName
    )
/*++

Routine Description:

    Determine if a name is a multi-label DNS name.

    This is a test of whether name at least one non-terminal dot.

Arguments:

    pszName - standard dotted DNS name

Return Value:

    TRUE if multiple labels.
    FALSE otherwise.

--*/
{
    INT     nameLen;

    //  trailing domain? -- done

    if ( Dns_GetDomainName( pszName ) )
    {
        return  FALSE;
    }

    //  otherwise test for valid label

    nameLen = strlen( pszName );
    if ( nameLen <= DNS_MAX_LABEL_LENGTH )
    {
        return  TRUE;
    }
    nameLen--;
    if ( nameLen == DNS_MAX_LABEL_LENGTH &&
         pszName[nameLen] == '.')
    {
        return  TRUE; 
    }
    return  FALSE;
}

    
BOOL
_fastcall
Dns_IsNameFQDN(
    IN      PCSTR           pszName
    )
/*++

Routine Description:

    Determine if a name is a fully qualified DNS name (FQDN).

    This is a test of whether name has trailing dot.

Arguments:

    pszName - standard dotted DNS name

Return Value:

    TRUE if FQDN.
    FALSE otherwise.

--*/
{
    DWORD nameLen = strlen( pszName );

    if ( nameLen == 0 )
    {
        return FALSE;
    }

    if ( pszName[nameLen - 1] == '.' )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


DWORD
_fastcall
Dns_GetNameAttributes(
    IN      PCSTR           pszName
    )
/*++

Routine Description:

    Determine the attributes that a name has.

    Note, this assumes name already in UTF-8

Arguments:

    pszName - standard dotted DNS name

Return Value:

    DWORD with possible flags:

    DNS_NAME_IS_FQDN
    DNS_NAME_SINGLE_LABEL
    DNS_NAME_MULTI_LABEL

--*/
{
    DWORD dwAttributes = DNS_NAME_UNKNOWN;

    if ( Dns_IsNameFQDN( pszName ) )
    {
        dwAttributes = DNS_NAME_IS_FQDN;
    }

    if ( Dns_IsNameShort( pszName ) )
    {
        dwAttributes |= DNS_NAME_SINGLE_LABEL;
    }
    else
    {
        dwAttributes |= DNS_NAME_MULTI_LABEL;
    }

    return dwAttributes;
}



DNS_STATUS
Dns_ValidateAndCategorizeDnsNameEx(
    IN      PCHAR           pchName,
    IN      DWORD           cchNameLength,
    OUT     PDWORD          pLabelCount
    )
/*++

Routine Description:

    Determine type of name.

    Three types:
        1) FQDN -- dot on end, signifies full DNS name, never appended

        2) dotted -- dot in name;  probably FQDN, but may need to be appended
            (as in file store)

        3) single part -- single part name (not FQDN), always appended with zone
            or default domain name

Arguments:

    pchName         -- ptr to name

    cchNameLength   -- name length

    pLabelCount     -- address to receive label count

Return Value:

    DNS_STATUS_FQDN
    DNS_STATUS_DOTTED_NAME
    DNS_STATUS_SINGLE_PART_NAME
    DNS_ERROR_INVALID_NAME on non-DNS name

--*/
{
    register PCHAR  pch;
    register CHAR   ch;
    PCHAR           pchstop;
    BOOL            fdotted = FALSE;
    DWORD           labelCount = 0;
    DWORD           charCount = 0;
    DNS_STATUS      status = DNS_STATUS_SINGLE_PART_NAME;

    //
    //  name length for string
    //

    if ( cchNameLength == 0 )
    {
        cchNameLength = strlen( pchName );
    }
    if ( cchNameLength > DNS_MAX_NAME_LENGTH ||
         cchNameLength == 0 )
    {
        goto InvalidName;
    }

    //
    //  run through name
    //

    pch = pchName;
    pchstop = pch + cchNameLength;

    while ( pch < pchstop )
    {
        ch = *pch++;
        if ( ch == '.' )
        {
            if ( charCount > DNS_MAX_LABEL_LENGTH )
            {
                goto InvalidName;
            }
            if ( charCount > 0 )
            {
                labelCount++;
                charCount = 0;
                status = DNS_STATUS_DOTTED_NAME;
                continue;
            }
            else
            {
                //  only valid zero label name is "."
                if ( pch == pchstop &&
                     pch-1 == pchName )
                {
                    break;
                }
                goto InvalidName;
            }
        }
        else if ( ch == 0 )
        {
            DNS_ASSERT( FALSE );
            break;
        }

        //  regular character
        charCount++;
    }

    //
    //  handle last label
    //      - if count, then boost label count
    //      - if zero and previously had dot, then string
    //          ended in dot and is FQDN
    //

    if ( charCount > 0 )
    {
        if ( charCount > DNS_MAX_LABEL_LENGTH )
        {
            goto InvalidName;
        }
        labelCount++;
    }
    else if ( status == DNS_STATUS_DOTTED_NAME )
    {
        status = DNS_STATUS_FQDN;
    }

    //  return label count

    if ( pLabelCount )
    {
        *pLabelCount = labelCount;
    }

    DNSDBG( TRACE, (
        "Leave Dns_ValidateAndCategorizeNameEx()\n"
        "\tstatus       = %d\n"
        "\tlabel count  = %d\n",
        status,
        labelCount ));

    return( status );


InvalidName:

    if ( pLabelCount )
    {
        *pLabelCount = 0;
    }

    DNSDBG( TRACE, (
        "Leave Dns_ValidateAndCategorizeNameEx()\n"
        "\tstatus = ERROR_INVALID_NAME\n" ));

    return( DNS_ERROR_INVALID_NAME );
}



DWORD
Dns_NameLabelCount(
    IN      PCSTR           pszName
    )
/*++

Routine Description:

    Return name label count.

Arguments:

    pszName -- ptr to name

Return Value:

    Label count if valid name.
    Zero on root name or error.

--*/
{
    DWORD       labelCount = 0;
    DNS_STATUS  status;

    //
    //  call real routine
    //

    status = Dns_ValidateAndCategorizeDnsNameEx(
                    (PCHAR) pszName,
                    0,
                    & labelCount );

    if ( status == DNS_ERROR_INVALID_NAME )
    {
        labelCount = 0;
    }

    return( labelCount );
}



PSTR
Dns_NameAppend_A(
    OUT     PCHAR           pNameBuffer,
    IN      DWORD           BufferLength,
    IN      PSTR            pszName,
    IN      PSTR            pszDomain
    )
/*++

Routine Description:

    Write appended name to buffer (ANSI or UTF8).

Arguments:

    pNameBuffer -- name buffer to write to

    BufferLength -- buffer length

    pszName -- name to append domain to

    pszDomain -- domain name

Return Value:

    Ptr to buffer with appended domain name.
    NULL on invalid (too long) name.

--*/
{
    DWORD   length1;
    DWORD   length2;
    DWORD   totalLength;

    DNSDBG( TRACE, ( "Dns_NameAppend_A()\n" ));

    //
    //  appending NULL domain?
    //

    if ( !pszDomain )
    {
        totalLength = strlen( pszName );
        if ( totalLength >= BufferLength )
        {
            return( NULL );
        }
        RtlCopyMemory(
            pNameBuffer,
            pszName,
            totalLength );

        pNameBuffer[ totalLength ] = 0;
    
        return( pNameBuffer );
    }

    //
    //  get name lengths -- make sure we fit length
    //

    length1 = strlen( pszName );
    if ( pszName[ length1-1] == '.' )
    {
        length1--;
    }

    length2 = strlen( pszDomain );
    
    totalLength = length1 + length2 + 1;
    if ( totalLength >= BufferLength )
    {
        return( NULL );
    }

    //
    //  copy to buffer
    //

    RtlCopyMemory(
        pNameBuffer,
        pszName,
        length1 );

    pNameBuffer[ length1 ] = '.';

    RtlCopyMemory(
        & pNameBuffer[length1+1],
        pszDomain,
        length2 );

    pNameBuffer[ totalLength ] = 0;

    return( pNameBuffer );
}



PWSTR
Dns_NameAppend_W(
    OUT     PWCHAR          pNameBuffer,
    IN      DWORD           BufferLength,
    IN      PWSTR           pwsName,
    IN      PWSTR           pwsDomain
    )
/*++

Routine Description:

    Write appended name to buffer (unicode).

Arguments:

    pNameBuffer -- name buffer to write to

    BufferLength -- buffer length in WCHAR

    pwsName -- name to append domain to

    pwsDomain -- domain name

Return Value:

    Ptr to buffer with appended domain name.
    NULL on invalid (too long) name.

--*/
{
    DWORD   length1;
    DWORD   length2;
    DWORD   totalLength;

    DNSDBG( TRACE, ( "Dns_NameAppend_W()\n" ));

    //
    //  appending NULL domain?
    //

    if ( !pwsDomain )
    {
        totalLength = wcslen( pwsName );
        if ( totalLength >= BufferLength )
        {
            return( NULL );
        }
        RtlCopyMemory(
            pNameBuffer,
            pwsName,
            totalLength*sizeof(WCHAR) );

        pNameBuffer[ totalLength ] = 0;
    
        return( pNameBuffer );
    }

    //
    //  get name lengths -- make sure we fit length
    //

    length1 = wcslen( pwsName );
    if ( pwsName[ length1-1] == '.' )
    {
        length1--;
    }

    length2 = wcslen( pwsDomain );
    
    totalLength = length1 + length2 + 1;
    if ( totalLength >= BufferLength )
    {
        return( NULL );
    }

    //
    //  copy to buffer
    //

    RtlCopyMemory(
        pNameBuffer,
        pwsName,
        length1*sizeof(WCHAR) );

    pNameBuffer[ length1 ] = '.';

    RtlCopyMemory(
        & pNameBuffer[length1+1],
        pwsDomain,
        length2*sizeof(WCHAR) );

    pNameBuffer[ totalLength ] = 0;

    return( pNameBuffer );
}



PSTR
Dns_SplitHostFromDomainName_A(
    IN      PSTR            pszName
    )
/*++

Routine Description:

    Split host name from domain name.

    Combines getting domain name and splitting
    off host name.

Arguments:

    pszName - standard dotted DNS name

Return Value:

    Ptr to domain name of pszName.
    NULL if pszName is in root domain.

--*/
{
    PSTR    pnameDomain;

    //
    //  get domain name
    //  if exists, NULL terminate host name part
    //

    pnameDomain = Dns_GetDomainName( (PCSTR)pszName );
    if ( pnameDomain )
    {
        if ( pnameDomain <= pszName )
        {
            return  NULL;
        }
        *(pnameDomain-1) = 0;
    }

    return  pnameDomain;
}



BOOL
_fastcall
Dns_IsNameNumeric_A(
    IN      PCSTR           pszName
    )
/*++

Routine Description:

    Determine if numeric name.

    Note, this assumes name already in UTF-8

Arguments:

    pszName - standard dotted DNS name

Return Value:

    TRUE if all numeric.
    FALSE otherwise.

--*/
{
    CHAR    ch;
    BOOL    fnumeric = FALSE;

    //
    //  check if everything in name is numeric
    //      - dotted names can be numeric
    //      - "." not numeric
    //

    while( ch = *pszName++ )
    {
        if ( ch >= '0' && ch <= '9' )
        {
            fnumeric = TRUE;
            continue;
        }
        else if ( ch == '.' )
        {
            continue;
        }
        return  FALSE;
    }

    return  fnumeric;
}



//
//  Wrappers for most common name conversions
//

DWORD
Dns_NameCopyWireToUnicode(
    OUT     PWCHAR          pBufferUnicode,
    IN      PCSTR           pszNameWire
    )
/*++

Routine Description:

    Convert name from wire to unicode.

    Simple wrapper on Dns_NameCopy for common operation:
        - unicode to wire
        - NULL terminated name
        - standard length buffer

Arguments:

    pBufferUnicode -- unicode result buffer

    pszNameWire - name in wire format

Return Value:

    Count of bytes copied if successful.
    Zero on error -- name too long or conversion error.

--*/
{
    DWORD   bufferLength = DNS_MAX_NAME_BUFFER_LENGTH_UNICODE;

    //
    //  copy name back to unicode
    //

    return Dns_NameCopy(
                (PCHAR) pBufferUnicode,
                & bufferLength,
                (PCHAR) pszNameWire,
                0,                      // null terminated
                DnsCharSetWire,
                DnsCharSetUnicode );
}



DWORD
Dns_NameCopyUnicodeToWire(
    OUT     PCHAR           pBufferWire,
    IN      PCWSTR          pwsNameUnicode
    )
/*++

Routine Description:

    Convert name from unicode to wire.

    Simple wrapper on Dns_NameCopy for common operation:
        - unicode to wire
        - NULL terminated name
        - standard length buffer

Arguments:

    pBufferWire -- wire format result buffer

    pwsNameUnicode - name in unicode

Return Value:


    Count of bytes copied if successful.
    Zero on error -- name too long or conversion error.

--*/
{
    DWORD   bufferLength = DNS_MAX_NAME_BUFFER_LENGTH;

    //
    //  copy name to wire format
    //

    return Dns_NameCopy(
                pBufferWire,
                & bufferLength,
                (PCHAR) pwsNameUnicode,
                0,                      // null terminated
                DnsCharSetUnicode,
                DnsCharSetWire );
}



DWORD
Dns_NameCopyStandard_W(
    OUT     PWCHAR          pBuffer,
    IN      PCWSTR          pwsNameUnicode
    )
/*++

Routine Description:

    Copy unicode name.

    Simple wrapper on Dns_NameCopy for common operation:
        - unicode to unicode
        - NULL terminated name
        - standard length buffer

Arguments:

    pBuffer -- wire format result buffer

    pwsNameUnicode - name in unicode

Return Value:

    Count of bytes copied if successful.
    Zero on error -- name too long or conversion error.

--*/
{
    DWORD   bufferLength = DNS_MAX_NAME_BUFFER_LENGTH_UNICODE;

    //
    //  copy name
    //

    return Dns_NameCopy(
                (PCHAR) pBuffer,
                & bufferLength,
                (PCHAR) pwsNameUnicode,
                0,                      // null terminated
                DnsCharSetUnicode,
                DnsCharSetUnicode );
}



DWORD
Dns_NameCopyStandard_A(
    OUT     PCHAR           pBuffer,
    IN      PCSTR           pszName
    )
/*++

Routine Description:

    Convert name from unicode to wire.

    Simple wrapper on Dns_NameCopy for common operation:
        - unicode to wire
        - NULL terminated name
        - standard length buffer

Arguments:

    pBuffer -- wire format result buffer

    pszName - name in narrow char set

Return Value:

    Count of bytes copied if successful.
    Zero on error -- name too long or conversion error.

--*/
{
    DWORD   bufferLength = DNS_MAX_NAME_BUFFER_LENGTH;

    //
    //  copy name
    //

    return Dns_NameCopy(
                pBuffer,
                & bufferLength,
                (PCHAR) pszName,
                0,                      // null terminated
                DnsCharSetUtf8,
                DnsCharSetUtf8 );
}


//
//  End name.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\record.c ===
/*++

Copyright (c) 1996-2001 Microsoft Corporation

Module Name:

    record.c

Abstract:

    Domain Name System (DNS) Library

    Routines to handle resource records (RR).

Author:

    Jim Gilroy (jamesg)     December 1996

Revision History:

--*/


#include "local.h"

#include "time.h"
#include "ws2tcpip.h"   // IPv6 inaddr definitions



//
//  Type name mapping.
//
//  Unlike above general value\string mapping the type lookup
//  has property of allowing direct lookup indexing with type, so
//  it is special cased.
//

//
//  DCR:   make combined type table
//  DCR:   add property flags to type table
//      - writeability flag?
//      - record/query type?
//      - indexable type?
//
//  then function just get index for type and check flag(s)
//


TYPE_NAME_TABLE TypeTable[] =
{
    "ZERO"      , 0                 ,
    "A"         , DNS_TYPE_A        ,
    "NS"        , DNS_TYPE_NS       ,
    "MD"        , DNS_TYPE_MD       ,
    "MF"        , DNS_TYPE_MF       ,
    "CNAME"     , DNS_TYPE_CNAME    ,
    "SOA"       , DNS_TYPE_SOA      ,
    "MB"        , DNS_TYPE_MB       ,
    "MG"        , DNS_TYPE_MG       ,
    "MR"        , DNS_TYPE_MR       ,
    "NULL"      , DNS_TYPE_NULL     ,
    "WKS"       , DNS_TYPE_WKS      ,
    "PTR"       , DNS_TYPE_PTR      ,
    "HINFO"     , DNS_TYPE_HINFO    ,
    "MINFO"     , DNS_TYPE_MINFO    ,
    "MX"        , DNS_TYPE_MX       ,
    "TXT"       , DNS_TYPE_TEXT     ,

    "RP"        , DNS_TYPE_RP       ,
    "AFSDB"     , DNS_TYPE_AFSDB    ,
    "X25"       , DNS_TYPE_X25      ,
    "ISDN"      , DNS_TYPE_ISDN     ,
    "RT"        , DNS_TYPE_RT       ,

    "NSAP"      , DNS_TYPE_NSAP     ,
    "NSAPPTR"   , DNS_TYPE_NSAPPTR  ,
    "SIG"       , DNS_TYPE_SIG      ,
    "KEY"       , DNS_TYPE_KEY      ,
    "PX"        , DNS_TYPE_PX       ,
    "GPOS"      , DNS_TYPE_GPOS     ,

    "AAAA"      , DNS_TYPE_AAAA     ,
    "LOC"       , DNS_TYPE_LOC      ,
    "NXT"       , DNS_TYPE_NXT      ,
    "EID"       , DNS_TYPE_EID      ,
    "NIMLOC"    , DNS_TYPE_NIMLOC   ,
    "SRV"       , DNS_TYPE_SRV      ,
    "ATMA"      , DNS_TYPE_ATMA     ,
    "NAPTR"     , DNS_TYPE_NAPTR    ,
    "KX"        , DNS_TYPE_KX       ,
    "CERT"      , DNS_TYPE_CERT     ,
    "A6"        , DNS_TYPE_A6       ,
    "DNAME"     , DNS_TYPE_DNAME    ,
    "SINK"      , DNS_TYPE_SINK     ,
    "OPT"       , DNS_TYPE_OPT      ,
    "42"        , 0x002a            ,
    "43"        , 0x002b            ,
    "44"        , 0x002c            ,
    "45"        , 0x002d            ,
    "46"        , 0x002e            ,
    "47"        , 0x002f            ,
    "48"        , 0x0030            ,

    //
    //  NOTE:   last type indexed by type ID MUST be set
    //          as MAX_SELF_INDEXED_TYPE #define in record.h
    //          and MUST be added to function tables below,
    //          even if with NULL entry
    //

    //
    //  Pseudo record types
    //

    "TKEY"      , DNS_TYPE_TKEY     ,
    "TSIG"      , DNS_TYPE_TSIG     ,

    //
    //  MS only types
    //

    "WINS"      , DNS_TYPE_WINS     ,
    "WINSR"     , DNS_TYPE_WINSR    ,


    //  ********************************************** \\
    //
    //  NOTE:   This is the END of the type lookup table
    //          for dispatch purposes.
    //          Defined by MAX_RECORD_TYPE_INDEX in record.h.
    //          Type dispatch tables MUST be at least this size.
    //          Geyond this value table continues for string to type
    //          matching only
    //


    "UINFO"     , DNS_TYPE_UINFO    ,
    "UID"       , DNS_TYPE_UID      ,
    "GID"       , DNS_TYPE_GID      ,
    "UNSPEC"    , DNS_TYPE_UNSPEC   ,

    "WINS-R"    , DNS_TYPE_WINSR    ,
    "NBSTAT"    , DNS_TYPE_WINSR    ,

    //
    //  Query types -- only for getting strings
    //

    "ADDRS"     , DNS_TYPE_ADDRS    ,
    "TKEY"      , DNS_TYPE_TKEY     ,
    "TSIG"      , DNS_TYPE_TSIG     ,
    "IXFR"      , DNS_TYPE_IXFR     ,
    "AXFR"      , DNS_TYPE_AXFR     ,
    "MAILB"     , DNS_TYPE_MAILB    ,
    "MAILA"     , DNS_TYPE_MAILA    ,
    "MAILB"     , DNS_TYPE_MAILB    ,
    "ALL"       , DNS_TYPE_ALL      ,

    NULL,   0,
};



WORD
Dns_RecordTableIndexForType(
    IN      WORD            wType
    )
/*++

Routine Description:

    Get record table index for a given type.

Arguments:

    wType -- RR type in net byte order

Return Value:

    Ptr to RR mneumonic string.
    NULL if unknown RR type.

--*/
{
    //
    //  if type directly indexes table, directly get string
    //

    if ( wType <= MAX_SELF_INDEXED_TYPE )
    {
        return( wType );
    }

    //
    //  types not directly indexed
    //

    else
    {
        WORD i = MAX_SELF_INDEXED_TYPE + 1;

        while ( i <= MAX_RECORD_TYPE_INDEX )
        {
            if ( TypeTable[i].wType == wType )
            {
                return( i );
            }
            i++;
            continue;
        }
    }
    return( 0 );        // type not indexed
}



WORD
Dns_RecordTypeForName(
    IN      PCHAR           pchName,
    IN      INT             cchNameLength
    )
/*++

Routine Description:

    Retrieve RR corresponding to RR database name.

Arguments:

    pchName - name of record type
    cchNameLength - record name length

Return Value:

    Record type corresponding to pchName, if found.
    Otherwise zero.

--*/
{
    INT     i;
    PCHAR   recordString;
    CHAR    firstNameChar;
    CHAR    upcaseName[ MAX_RECORD_NAME_LENGTH+1 ];

    //
    //  if not given get string length
    //

    if ( !cchNameLength )
    {
        cchNameLength = strlen( pchName );
    }

    //  upcase name to optimize compare
    //  allows single character comparison and use of faster case sensitive
    //  compare routine

    if ( cchNameLength > MAX_RECORD_NAME_LENGTH )
    {
        return( 0 );
    }
    memcpy(
        upcaseName,
        pchName,
        cchNameLength );
    upcaseName[ cchNameLength ] = 0;
    _strupr( upcaseName );
    firstNameChar = *upcaseName;

    //
    //  check all supported RR types for name match
    //

    i = 0;
    while( TypeTable[++i].wType != 0 )
    {
        recordString = TypeTable[i].pszTypeName;

        if ( firstNameChar == *recordString
            &&  ! strncmp( upcaseName, recordString, cchNameLength ) )
        {
            return( TypeTable[i].wType );
        }
    }
    return( 0 );
}



PCHAR
private_StringForRecordType(
    IN      WORD            wType
    )
/*++

Routine Description:

    Get string corresponding to record type.

Arguments:

    wType -- RR type in net byte order

Return Value:

    Ptr to RR mneumonic string.
    NULL if unknown RR type.

--*/
{
    //
    //  if type directly indexes table, directly get string
    //

    if ( wType <= MAX_SELF_INDEXED_TYPE )
    {
        return( TypeTable[wType].pszTypeName );
    }

    //
    //  strings not indexed by type, walk the list
    //

    else
    {
        INT i = MAX_SELF_INDEXED_TYPE + 1;

        while( TypeTable[i].wType != 0 )
        {
            if ( wType == TypeTable[i].wType )
            {
                return( TypeTable[i].pszTypeName );
            }
            i++;
        }
    }
    return( NULL );
}



PCHAR
Dns_RecordStringForType(
    IN      WORD            wType
    )
/*++

Routine Description:

    Get type string for type.

    This routine gets pointer rather than direct access to buffer.

Arguments:

    wType -- RR type in net byte order

Return Value:

    Ptr to RR mneumonic string.
    NULL if unknown RR type.

--*/
{
    PSTR    pstr;

    pstr = private_StringForRecordType( wType );
    if ( !pstr )
    {
        pstr = "UNKNOWN";
    }
    return  pstr;
}



PCHAR
Dns_RecordStringForWritableType(
    IN      WORD            wType
    )
/*++

Routine Description:

    Retrieve RR string corresponding to the RR type -- ONLY if writable type.

Arguments:

    wType -- RR type in net byte order

Return Value:

    Ptr to RR mneumonic string.
    NULL if unknown RR type.

--*/
{
    //
    //  eliminate all supported types that are NOT writable
    //

    if ( wType == DNS_TYPE_NULL || wType == DNS_TYPE_ZERO )
    {
        return( NULL );
    }

    //
    //  otherwise return type string
    //  string is NULL if type is unknown
    //

    return( Dns_RecordStringForType(wType) );
}





BOOL
Dns_WriteStringForType_A(
    OUT     PCHAR           pBuffer,
    IN      WORD            wType
    )
/*++

Routine Description:

    Write type name string for type.

Arguments:

    wType -- RR type in net byte order

Return Value:

    TRUE if found string.
    FALSE if converted type numerically.

--*/
{
    PSTR    pstr;

    pstr = private_StringForRecordType( wType );
    if ( pstr )
    {
        sprintf( pBuffer, "%s", pstr );
    }
    else
    {
        sprintf( pBuffer, "%d", wType );
    }
    return  pstr ? TRUE : FALSE;
}


BOOL
Dns_WriteStringForType_W(
    OUT     PWCHAR          pBuffer,
    IN      WORD            wType
    )
{
    PSTR    pstr;

    pstr = private_StringForRecordType( wType );
    if ( pstr )
    {
        swprintf( pBuffer, L"%S", pstr );
    }
    else
    {
        swprintf( pBuffer, L"%d", wType );
    }
    return  pstr ? TRUE : FALSE;
}



BOOL
_fastcall
Dns_IsAMailboxType(
    IN      WORD            wType
    )
{
    return( wType == DNS_TYPE_MB ||
            wType == DNS_TYPE_MG ||
            wType == DNS_TYPE_MR );
}


BOOL
_fastcall
Dns_IsUpdateType(
    IN      WORD            wType
    )
{
    return( wType != 0 &&
            ( wType < DNS_TYPE_OPT ||
              (wType < DNS_TYPE_ADDRS && wType != DNS_TYPE_OPT) ) );
}



//
//  RPC-able record types
//

BOOL IsRpcTypeTable[] =
{
    0,      //  ZERO
    1,      //  A      
    1,      //  NS     
    1,      //  MD     
    1,      //  MF     
    1,      //  CNAME  
    1,      //  SOA    
    1,      //  MB     
    1,      //  MG     
    1,      //  MR     
    0,      //  NULL   
    0,      //  WKS    
    1,      //  PTR    
    0,      //  HINFO  
    1,      //  MINFO  
    1,      //  MX     
    0,      //  TXT

    1,      //  RP     
    1,      //  AFSDB  
    0,      //  X25    
    0,      //  ISDN   
    0,      //  RT

    0,      //  NSAP   
    0,      //  NSAPPTR
    0,      //  SIG    
    0,      //  KEY    
    0,      //  PX     
    0,      //  GPOS   
    1,      //  AAAA   
    0,      //  LOC    
    0,      //  NXT

    0,      //  EID    
    0,      //  NIMLOC 
    1,      //  SRV    
    1,      //  ATMA   
    0,      //  NAPTR  
    0,      //  KX     
    0,      //  CERT   
    0,      //  A6     
    0,      //  DNAME  
    0,      //  SINK   
    0,      //  OPT    
    0,      //  42     
    0,      //  43     
    0,      //  44     
    0,      //  45     
    0,      //  46     
    0,      //  47     
    0,      //  48     
};



BOOL
Dns_IsRpcRecordType(
    IN      WORD            wType
    )
/*++

Routine Description:

    Check if valid to RPC records of this type.

    MIDL compiler has problem with a union of types of varying
    length (no clue why -- i can write the code).  This function
    allows us to screen them out.

Arguments:

    wType -- type to check

Return Value:

    None

--*/
{
    if ( wType < MAX_SELF_INDEXED_TYPE )
    {
        return  IsRpcTypeTable[ wType ];
    }
    else
    {
        return  FALSE;
    }
}



//
//  RR type specific conversions
//

//
//  Text string type routine
//

BOOL
Dns_IsStringCountValidForTextType(
    IN      WORD            wType,
    IN      WORD            StringCount
    )
/*++

Routine Description:

    Verify a valid count of strings for the particular text
    string type.

    HINFO   -- 2
    ISDN    -- 1 or 2
    TXT     -- any number
    X25     -- 1

Arguments:

    wType -- type

    StringCount -- count of strings

Return Value:

    TRUE if string count is acceptable for type.
    FALSE otherwise.

--*/
{
    switch ( wType )
    {
    case DNS_TYPE_HINFO:

        return ( StringCount == 2 );

    case DNS_TYPE_ISDN:

        return ( StringCount == 1 || StringCount == 2 );

    case DNS_TYPE_X25:

        return ( StringCount == 1 );

    default:

        return( TRUE );
    }
}



//
//  WINS flag table
//
//  Associates a WINS flag with the string used for it in database
//  files.
//

DNS_FLAG_TABLE_ENTRY   WinsFlagTable[] =
{
    //  value               mask                    string

    DNS_WINS_FLAG_SCOPE,    DNS_WINS_FLAG_SCOPE,    "SCOPE",
    DNS_WINS_FLAG_LOCAL,    DNS_WINS_FLAG_LOCAL,    "LOCAL",
    0                  ,    0                  ,    NULL
};


DWORD
Dns_WinsRecordFlagForString(
    IN      PCHAR           pchName,
    IN      INT             cchNameLength
    )
/*++

Routine Description:

    Retrieve WINS mapping flag corresponding to string.

Arguments:

    pchName - ptr to string
    cchNameLength - length of string

Return Value:

     flag corresponding to string, if found.
     WINS_FLAG_ERROR otherwise.

--*/
{
    return  Dns_FlagForString(
                WinsFlagTable,
                TRUE,               // ignore case
                pchName,
                cchNameLength );
}



PCHAR
Dns_WinsRecordFlagString(
    IN      DWORD           dwFlag,
    IN OUT  PCHAR           pchFlag
    )
/*++

Routine Description:

    Retrieve string corresponding to a given mapping type.

Arguments:

    dwFlag -- WINS mapping type string

    pchFlag -- buffer to write flag to

Return Value:

    Ptr to mapping mneumonic string.
    NULL if unknown mapping type.

--*/
{
    return  Dns_WriteStringsForFlag(
                WinsFlagTable,
                dwFlag,
                pchFlag );
}



//
//  WKS record conversions
//

#if 0
PCHAR
Dns_GetWksServicesString(
    IN      INT     Protocol,
    IN      PBYTE   ServicesBitmask,
    IN      WORD    wBitmaskLength
    )
/*++

Routine Description:

    Get list of services in WKS record.

Arguments:

    pRR - flat WKS record being written

Return Value:

    Ptr to services string, caller MUST free.
    NULL on error.

--*/
{
    struct servent *    pServent;
    struct protoent *   pProtoent;
    INT         i;
    DWORD       length;
    USHORT      port;
    UCHAR       portBitmask;
    CHAR        buffer[ WKS_SERVICES_BUFFER_SIZE ];
    PCHAR       pch = buffer;
    PCHAR       pchstart;
    PCHAR       pchstop;

    //  protocol

    pProtoent = getprotobynumber( iProtocol );
    if ( ! pProtoent )
    {
        DNS_PRINT((
            "ERROR:  Unable to find protocol %d, writing WKS record.\n",
            (INT) pRR->Data.WKS.chProtocol
            ));
        return( NULL );
    }

    //
    //  services
    //
    //  find each bit set in bitmask, lookup and write service
    //  corresponding to that port
    //
    //  note, that since that port zero is the front of port bitmask,
    //  lowest ports are the highest bits in each byte
    //

    pchstart = pch;
    pchstop = pch + WKS_SERVICES_BUFFER_SIZE;

    for ( i = 0;
            i < wBitmaskLength
                i++ )
    {
        portBitmask = (UCHAR) ServicesBitmask[i];

        port = i * 8;

        //  write service name for each bit set in byte
        //      - get out as soon byte is empty of ports
        //      - terminate each name with blank (until last)

        while ( bBitmask )
        {
            if ( bBitmask & 0x80 )
            {
                pServent = getservbyport(
                                (INT) htons(port),
                                pProtoent->p_name );

                if ( pServent )
                {
                    INT copyCount = strlen(pServent->s_name);

                    pch++;
                    if ( pchstop - pch <= copyCount+1 )
                    {
                        return( NULL );
                    }
                    RtlCopyMemory(
                        pch,
                        pServent->s_name,
                        copyCount );
                    pch += copyCount;
                    *pch = ' ';
                }
                else
                {
                    DNS_PRINT((
                        "ERROR:  Unable to find service for port %d, "
                        "writing WKS record.\n",
                        port
                        ));
                    pch += sprintf( pch, "%d", port );
                }
            }
            port++;           // next service port
            bBitmask <<= 1;     // shift mask up to read next port
        }
    }

    //  NULL terminate services string
    //  and determine length

    *pch++ = 0;
    length = pch - pchstart;

    //  allocate copy of this string

    pch = ALLOCATE_HEAP( length );
    if ( !pch )
    {
        SetLastError( DNS_ERROR_NO_MEMORY );
        return( NULL );
    }

    RtlCopyMemory(
        pch,
        pchstart,
        length );

    return( pch );
}

#endif


#if 0
DNS_STATUS
Dns_WksRecordToStrings(
    IN      PDNS_WKS_DATA   pWksData,
    IN      WORD            wLength,
    OUT     LPSTR *         ppszIpAddress,
    OUT     LPSTR *         ppszProtocol,
    OUT     LPSTR *         ppszServices
    )
/*++

Routine Description:

    Get string representation of WKS data.

Arguments:

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    //
    //  record must contain IP and protocol
    //

    if ( wLength < SIZEOF_WKS_FIXED_DATA )
    {
        return( ERROR_INVALID_DATA );
    }

    //
    //  convert IP
    //

    if ( ppszIpAddress )
    {
        LPSTR   pszip;

        pszip = ALLOCATE_HEAP( IP_ADDRESS_STRING_LENGTH+1 );
        if ( ! pszip )
        {
            return( GetLastError() );
        }
        strcpy( pszip, IP_STRING( pWksData->ipAddress ) );
    }

    //
    //  convert protocol
    //

    pProtoent = getprotobyname( pszNameBuffer );

    if ( ! pProtoent || pProtoent->p_proto >= MAXUCHAR )
    {
        dns_LogFileParsingError(
            DNS_EVENT_UNKNOWN_PROTOCOL,
            pParseInfo,
            Argv );
        return( DNS_ERROR_INVALID_TOKEN );
    }

    //
    //  get port for each service
    //      - if digit, then use port number
    //      - if not digit, then service name
    //      - save max port for determining RR length
    //

    for ( i=1; i<Argc; i++ )
    {
        if ( dns_ParseDwordToken(
                    & portDword,
                    & Argv[i],
                    NULL ) )
        {
            if ( portDword > MAXWORD )
            {
                return( DNS_ERROR_INVALID_TOKEN );
            }
            port = (WORD) portDword;
        }
        else
        {
            if ( ! dns_MakeTokenString(
                        pszNameBuffer,
                        & Argv[i],
                        pParseInfo ) )
            {
                return( DNS_ERROR_INVALID_TOKEN );
            }
            pServent = getservbyname(
                            pszNameBuffer,
                            pProtoent->p_name );
            if ( ! pServent )
            {
                dns_LogFileParsingError(
                    DNS_EVENT_UNKNOWN_SERVICE,
                    pParseInfo,
                    & Argv[i] );
                return( DNS_ERROR_INVALID_TOKEN );
            }
            port = ntohs( pServent->s_port );
        }

        portArray[ i ] = port;
        if ( port > maxPort )
        {
            maxPort = port;
        }
    }

    //
    //  allocate required length
    //      - fixed length, plus bitmask covering max port
    //

    wbitmaskLength = maxPort/8 + 1;

    prr = RRecordAllocate(
                (WORD)(SIZEOF_WKS_FIXED_DATA + wbitmaskLength) );
    if ( !prr )
    {
        return( DNS_ERROR_NO_MEMORY );
    }

    //
    //  copy fixed fields -- IP and protocol
    //

    prr->Data.WKS.ipAddress = ipAddress;
    prr->Data.WKS.chProtocol = (UCHAR) pProtoent->p_proto;

    //
    //  build bitmask from port array
    //      - clear port array first
    //
    //  note that bitmask is just flat run of bits
    //  hence lowest port in byte, corresponds to highest bit
    //  highest port in byte, corresponds to lowest bit and
    //  requires no shift
    //

    bitmaskBytes = prr->Data.WKS.bBitMask;

    RtlZeroMemory(
        bitmaskBytes,
        (size_t) wbitmaskLength );

    for ( i=1; i<Argc; i++ )
    {
        port = portArray[ i ];
        bit  = port & 0x7;      // mod 8
        port = port >> 3;       // divide by 8
        bitmaskBytes[ port ] |= 1 << (7-bit);
    }

    //  return ptr to new WKS record

    *ppRR = prr;

    return( ERROR_SUCCESS );
}

#endif



//
//  Security KEY\SIG record routines
//

#define DNSSEC_ERROR_NOSTRING   (-1)


//
//  KEY flags table
//
//  Note that number-to-string mapping is NOT UNIQUE.
//  Zero is in the table a few times are multiple bit fields may have a
//  zero value which is given a particular mnemonic.
//

DNS_FLAG_TABLE_ENTRY   KeyFlagTable[] =
{
    //  value      mask     string

    0x0001,     0x0001,     "NOAUTH",
    0x0002,     0x0002,     "NOCONF",
    0x0004,     0x0004,     "FLAG2",
    0x0008,     0x0008,     "EXTEND",

    0x0010,     0x0010,     "FLAG4",
    0x0020,     0x0020,     "FLAG5",

    //  bits 6,7//  bits 6,7 are name type

    0x0000,     0x00c0,     "USER",
    0x0040,     0x00c0,     "ZONE",
    0x0080,     0x00c0,     "HOST",
    0x00c0,     0x00c0,     "NTPE3",

    //  bits 8-1//  bits 8-11 are reserved for future use

    0x0100,     0x0100,     "FLAG8",
    0x0200,     0x0200,     "FLAG9",
    0x0400,     0x0400,     "FLAG10",
    0x0800,     0x0800,     "FLAG11",

    //  bits 12-//  bits 12-15 are sig field

    0x0000,     0xf000,     "SIG0",
    0x1000,     0xf000,     "SIG1",
    0x2000,     0xf000,     "SIG2",
    0x3000,     0xf000,     "SIG3",
    0x4000,     0xf000,     "SIG4",
    0x5000,     0xf000,     "SIG5",
    0x6000,     0xf000,     "SIG6",
    0x7000,     0xf000,     "SIG7",
    0x8000,     0xf000,     "SIG8",
    0x9000,     0xf000,     "SIG9",
    0xa000,     0xf000,     "SIG10",
    0xb000,     0xf000,     "SIG11",
    0xc000,     0xf000,     "SIG12",
    0xd000,     0xf000,     "SIG13",
    0xe000,     0xf000,     "SIG14",
    0xf000,     0xf000,     "SIG15",

    0     ,     0     ,     NULL
};

//
//  KEY protocol table
//

DNS_VALUE_TABLE_ENTRY   KeyProtocolTable[] =
{
    0,      "NONE"      ,
    1,      "TLS"       ,
    2,      "EMAIL"     ,
    3,      "DNSSEC"    ,
    4,      "IPSEC"     ,
    0,      NULL
};

//
//  Security alogrithm table
//

DNS_VALUE_TABLE_ENTRY   DnssecAlgorithmTable[] =
{
    1,      "RSA/MD5"           ,
    2,      "DIFFIE-HELLMAN"    ,
    3,      "DSA"               ,
    253,    "NULL"              ,
    254,    "PRIVATE"           ,
    0,      NULL
};




WORD
Dns_KeyRecordFlagForString(
    IN      PCHAR           pchName,
    IN      INT             cchNameLength
    )
/*++

Routine Description:

    Retrieve KEY record flag corresponding to a particular
    string mnemonics.

Arguments:

    pchName - ptr to string
    cchNameLength - length of string

Return Value:

    flag corresponding to string, if found.
    DNSSEC_ERROR_NOSTRING otherwise.

--*/
{
    return (WORD) Dns_FlagForString(
                    KeyFlagTable,
                    FALSE,          // case sensitive (all upcase)
                    pchName,
                    cchNameLength );
}



PCHAR
Dns_KeyRecordFlagString(
    IN      DWORD           dwFlag,
    IN OUT  PCHAR           pchFlag
    )
/*++

Routine Description:

    Write mnemonics corresponding to string.

Arguments:

    dwFlag -- KEY mapping type string

    pchFlag -- buffer to write flag to

Return Value:

    Ptr to mapping mneumonic string.
    NULL if unknown mapping type.

--*/
{
    return Dns_WriteStringsForFlag(
                KeyFlagTable,
                dwFlag,
                pchFlag );
}






UCHAR
Dns_KeyRecordProtocolForString(
    IN      PCHAR           pchName,
    IN      INT             cchNameLength
    )
/*++

Routine Description:

    Retrieve KEY record protocol for string.

Arguments:

    pchName - ptr to string
    cchNameLength - length of string

Return Value:

    Protocol value corresponding to string, if found.
    DNSSEC_ERROR_NOSTRING otherwise.

--*/
{
    return (UCHAR) Dns_ValueForString(
                        KeyProtocolTable,
                        FALSE,          // case sensitive (all upcase)
                        pchName,
                        cchNameLength );
}



PCHAR
Dns_GetKeyProtocolString(
    IN      UCHAR           uchProtocol
    )
/*++

Routine Description:

    Retrieve KEY protocol string for protocol.

Arguments:

    dwProtocol  - KEY protocol to map to string

Return Value:

    Ptr to protocol mneumonic for string.
    NULL if unknown protocol.

--*/
{
    return Dns_GetStringForValue(
                KeyProtocolTable,
                (DWORD) uchProtocol );
}




UCHAR
Dns_SecurityAlgorithmForString(
    IN      PCHAR           pchName,
    IN      INT             cchNameLength
    )
/*++

Routine Description:

    Retrieve DNSSEC algorithm for string.

Arguments:

    pchName - ptr to string
    cchNameLength - length of string

Return Value:

    Algorithm value corresponding to string, if found.
    DNSSEC_ERROR_NOSTRING otherwise.

--*/
{
    return (UCHAR) Dns_ValueForString(
                        DnssecAlgorithmTable,
                        FALSE,          // case sensitive (all upcase)
                        pchName,
                        cchNameLength );
}



PCHAR
Dns_GetDnssecAlgorithmString(
    IN      UCHAR           uchAlgorithm
    )
/*++

Routine Description:

    Retrieve DNSSEC algorithm string.

Arguments:

    dwAlgorithm  -  security alogorithm to map to string

Return Value:

    Ptr to algorithm string if found.
    NULL if unknown algorithm.

--*/
{
    return Dns_GetStringForValue(
                DnssecAlgorithmTable,
                (DWORD) uchAlgorithm );
}



//
//  Security base64 conversions.
//
//  Keys and signatures are represented in base 64 mapping for human use.
//  (Why?  Why not just use give the hex representation?
//  All this for 33% compression -- amazing.)
//

#if 0
//  forward lookup table doesn't buy much, simple function actually smaller
//  and not much slower

UCHAR   DnsSecurityBase64Mapping[] =
{
    // 0-31 unprintable

    0xff,   0xff,   0xff,   0xff,
    0xff,   0xff,   0xff,   0xff,
    0xff,   0xff,   0xff,   0xff,
    0xff,   0xff,   0xff,   0xff,
    0xff,   0xff,   0xff,   0xff,
    0xff,   0xff,   0xff,   0xff,
    0xff,   0xff,   0xff,   0xff,
    0xff,   0xff,   0xff,   0xff,

    //  '0' - '9' map

    0xff,   0xff,   0xff,   0xff,
    0xff,   0xff,   0xff,   0xff,
    0xff,   0xff,   0xff,   62,         // '+' => 62
    0xff,   0xff,   0xff,   63,         // '/' => 63
    52,     53,     54,     55,         // 0-9 map to 52-61
    0xff,   0xff,   0xff,   0xff,
    0xff,   0xff,   0xff,   0xff,
    0xff,   0xff,   0xff,   0xff,
}
#endif


//
//  Security KEY, SIG 6-bit values to base64 character mapping
//

CHAR  DnsSecurityBase64Mapping[] =
{
    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
    'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
    'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
    'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
    'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
    'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
    'w', 'x', 'y', 'z', '0', '1', '2', '3',
    '4', '5', '6', '7', '8', '9', '+', '/'
};

#define SECURITY_PAD_CHAR   ('=')



UCHAR
Dns_SecurityBase64CharToBits(
    IN      CHAR            ch64
    )
/*++

Routine Description:

    Get value of security base64 character.

Arguments:

    ch64 -- character in security base64

Return Value:

    Value of character, only low 6-bits are significant, high bits zero.
    (-1) if not a base64 character.

--*/
{
    //  A - Z map to 0 -25
    //  a - z map to 26-51
    //  0 - 9 map to 52-61
    //  + is 62
    //  / is 63

    //  could do a lookup table
    //  since we can in general complete mapping with an average of three
    //  comparisons, just encode

    if ( ch64 >= 'a' )
    {
        if ( ch64 <= 'z' )
        {
            return( ch64 - 'a' + 26 );
        }
    }
    else if ( ch64 >= 'A' )
    {
        if ( ch64 <= 'Z' )
        {
            return( ch64 - 'A' );
        }
    }
    else if ( ch64 >= '0')
    {
        if ( ch64 <= '9' )
        {
            return( ch64 - '0' + 52 );
        }
        else if ( ch64 == '=' )
        {
            //*pPadCount++;
            return( 0 );
        }
    }
    else if ( ch64 == '+' )
    {
        return( 62 );
    }
    else if ( ch64 == '/' )
    {
        return( 63 );
    }

    //  all misses fall here

    return (UCHAR)(-1);
}



DNS_STATUS
Dns_SecurityBase64StringToKey(
    OUT     PBYTE           pKey,
    OUT     PDWORD          pKeyLength,
    IN      PCHAR           pchString,
    IN      DWORD           cchLength
    )
/*++

Routine Description:

    Write base64 representation of key to buffer.

Arguments:

    pchString   - base64 string to write

    cchLength   - length of string

    pKey        - ptr to key to write

Return Value:

    None

--*/
{
    DWORD   blend = 0;
    DWORD   index = 0;
    UCHAR   bits;
    PBYTE   pkeyStart = pKey;

    //
    //  mapping is essentially in 24bit blocks
    //  read three bytes of key and transform into four 64bit characters
    //

    while ( cchLength-- )
    {
        bits = Dns_SecurityBase64CharToBits( *pchString++ );
        if ( bits >= 64 )
        {
            return( ERROR_INVALID_PARAMETER );
        }
        blend <<= 6;
        blend |= bits;
        index++;

        if ( index == 4 )
        {
            index = 0;
            *pKey++ = (UCHAR)( (blend & 0x00ff0000) >> 16 );

            if ( cchLength || *(pchString-1) != SECURITY_PAD_CHAR )
            {
                *pKey++ = (UCHAR)( (blend & 0x0000ff00) >> 8 );
                *pKey++ = (UCHAR)( blend & 0x000000ff );
            }

            //  final char is padding
            //      - if two pads then already done (only needed first byte)
            //      - if one pad then need second byte

            else if ( *(pchString-2) != SECURITY_PAD_CHAR )
            {
                *pKey++ = (UCHAR)( (blend & 0x0000ff00) >> 8 );
            }
            blend = 0;
        }
    }

    //
    //  base64 representation should always be padded out
    //  calculate key length, subtracting off any padding
    //

    if ( index == 0 )
    {
        *pKeyLength = (DWORD)(pKey - pkeyStart);
        return( ERROR_SUCCESS );
    }
    return( ERROR_INVALID_PARAMETER );
}



PCHAR
Dns_SecurityKeyToBase64String(
    IN      PBYTE           pKey,
    IN      DWORD           KeyLength,
    OUT     PCHAR           pchBuffer
    )
/*++

Routine Description:

    Write base64 representation of key to buffer.

Arguments:

    pKey        - ptr to key to write

    KeyLength   - length of key in bytes

    pchBuffer   - buffer to write to (must be adequate for key length)

Return Value:

    Ptr to next byte in buffer after string.

--*/
{
    DWORD   blend = 0;
    DWORD   index = 0;

    //
    //  mapping is essentially in 24bit blocks
    //  read three bytes of key and transform into four 64bit characters
    //

    while ( KeyLength-- )
    {
        blend <<= 8;
        blend += *pKey++;
        index++;

        if ( index == 3 )
        {
            *pchBuffer++ = DnsSecurityBase64Mapping[ (blend & 0x00fc0000) >> 18 ];
            *pchBuffer++ = DnsSecurityBase64Mapping[ (blend & 0x0003f000) >> 12 ];
            *pchBuffer++ = DnsSecurityBase64Mapping[ (blend & 0x00000fc0) >> 6 ];
            *pchBuffer++ = DnsSecurityBase64Mapping[ (blend & 0x0000003f) ];
            blend = 0;
            index = 0;
        }
    }

    //
    //  key terminates on byte boundary, but not necessarily 24bit block boundary
    //  shift to fill 24bit block filling with zeros
    //  if two bytes written
    //          => write three 6-bits chars and one pad
    //  if one byte written
    //          => write two 6-bits chars and two pads
    //

    if ( index )
    {
        blend <<= (8 * (3-index));

        *pchBuffer++ = DnsSecurityBase64Mapping[ (blend & 0x00fc0000) >> 18 ];
        *pchBuffer++ = DnsSecurityBase64Mapping[ (blend & 0x0003f000) >> 12 ];
        if ( index == 2 )
        {
            *pchBuffer++ = DnsSecurityBase64Mapping[ (blend & 0x00000fc0) >> 6 ];
        }
        else
        {
            *pchBuffer++ = SECURITY_PAD_CHAR;
        }
        *pchBuffer++ = SECURITY_PAD_CHAR;
    }

    return( pchBuffer );
}



//
//  Hex digit \ Hex char mapping.
//
//  This stuff ought to be in system (CRTs) somewhere but apparently isn't.
//

UCHAR  HexCharToHexDigitTable[] =
{
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,     // 0-47 invalid
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x0,  0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,     // 0-9 chars map to 0-9
    0x08, 0x09, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

    0xff, 0xa,  0xb,  0xc,  0xd,  0xe,  0xf,  0xff,     // A-F chars map to 10-15
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

    0xff, 0xa,  0xb,  0xc,  0xd,  0xe,  0xf,  0xff,     // a-f chars map to 10-15
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,     // above 127 invalid
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
};

UCHAR  HexDigitToHexCharTable[] =
{
    '0',    '1',    '2',    '3',
    '4',    '5',    '6',    '7',
    '8',    '9',    'a',    'b',
    'c',    'd',    'e',    'f'
};


#define HexCharToHexDigit(_ch)      ( HexCharToHexDigitTable[(_ch)] )
#define HexDigitToHexChar(_d)       ( HexDigitToHexCharTable[(_d)] )





time_t
makeGMT(
    IN      struct tm *     tm
    )
/*++

Routine Description:

    This function is like mktime for GMT times. The CRT is missing such
    a function, unfortunately. Which is weird, because it does provide
    gmtime() for the reverse conversion.

    //
    //  DCR:  add makeGMT() to CRT dll?
    //

Arguments:

    tm - ptr to tm struct (tm_dst, tm_yday, tm_wday are all ignored)

Return Value:

    Returns the time_t corresponding to the time in the tm struct,
    assuming GMT.

--*/
{
    static const int daysInMonth[ 12 ] =
        { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

    time_t      gmt = 0;
    int         i;
    int         j;

    #define IS_LEAP_YEAR(x) \
                    (( ((x)%4)==0 && ((x)%100)!=0 ) || ((x)%400)==0 )
    #define SECONDS_PER_DAY (60*60*24)

    //
    //  Years
    //

    j = 0;
    for ( i = 70; i < tm->tm_year; i++ )
    {
        // j += IS_LEAP_YEAR( 1900 + i ) ? 366 : 365;  // Days in year.
        if ( IS_LEAP_YEAR( 1900 + i ) )
            j += 366;  // Days in year.
        else
            j += 365;  // Days in year.
    }
    gmt += j * SECONDS_PER_DAY;

    //
    //  Months
    //

    j = 0;
    for ( i = 0; i < tm->tm_mon; i++ )
    {
        j += daysInMonth[ i ];      // Days in month.
        if ( i == 1 && IS_LEAP_YEAR( 1900 + tm->tm_year ) )
        {
            ++j;                    // Add February 29.
        }
    }
    gmt += j * SECONDS_PER_DAY;

    //
    //  Days, hours, minutes, seconds
    //

    gmt += ( tm->tm_mday - 1 ) * SECONDS_PER_DAY;
    gmt += tm->tm_hour * 60 * 60;
    gmt += tm->tm_min * 60;
    gmt += tm->tm_sec;

    return gmt;
}

        

LONG
Dns_ParseSigTime(
    IN      PCHAR           pTimeString,
    IN      INT             cchLength
    )
/*++

Routine Description:

    Parse time string into a time_t value. The time string will be in
    the format: YYYYMMDDHHMMSS. See RFC2535 section 7.2.

    It is assumed that the time is GMT, not local time, but I have not
    found this in an RFC or other document (it just makes sense).

Arguments:

    pTimeString - pointer to time string

    cchLength - length of time string

Return Value:

    Returns -1 on failure.

--*/
{
    time_t      timeValue = -1;
    struct tm   t = { 0 };
    CHAR        szVal[ 10 ];
    PCHAR       pch = pTimeString;

    if ( cchLength == 0 )
    {
        cchLength = strlen( pch );
    }

    if ( cchLength != 14 )
    {
        goto Cleanup;
    }

    RtlCopyMemory( szVal, pch, 4 );
    szVal[ 4 ] = '\0';
    t.tm_year = atoi( szVal ) - 1900;

    RtlCopyMemory( szVal, pch + 4, 2 );
    szVal[ 2 ] = '\0';
    t.tm_mon = atoi( szVal ) - 1;

    RtlCopyMemory( szVal, pch + 6, 2 );
    t.tm_mday = atoi( szVal );

    RtlCopyMemory( szVal, pch + 8, 2 );
    t.tm_hour = atoi( szVal );

    RtlCopyMemory( szVal, pch + 10, 2 );
    t.tm_min = atoi( szVal );

    RtlCopyMemory( szVal, pch + 12, 2 );
    t.tm_sec = atoi( szVal );

    timeValue = makeGMT( &t );

    Cleanup:

    return ( LONG ) timeValue;
} // Dns_ParseSigTime



PCHAR
Dns_SigTimeString(
    IN      LONG            SigTime,
    OUT     PCHAR           pchBuffer
   )
/*++

Routine Description:

    Formats the input time in the buffer in YYYYMMDDHHMMSS format. 

    See RFC 2535 section 7.2 for spec.

Arguments:

    SigTime - time to convert to string format in HOST byte order
    pchBuffer - output buffer - must be 15 chars minimum

Return Value:

    pchBuffer

--*/
{
    time_t          st = SigTime;
    struct tm *     t;

    t = gmtime( &st );
    if ( !t )
    {
        *pchBuffer = '\0';
        goto Cleanup;
    }
    sprintf(
        pchBuffer,
        "%04d%02d%02d%02d%02d%02d",
        t->tm_year + 1900,
        t->tm_mon + 1,
        t->tm_mday,
        t->tm_hour,
        t->tm_min,
        t->tm_sec );

    Cleanup:

    return pchBuffer;
} // SigTimeString
                


//
//  ATMA record conversions
//

#define ATMA_AESA_HEX_DIGIT_COUNT   (40)
#define ATMA_AESA_RECORD_LENGTH     (21)


DWORD
Dns_AtmaAddressLengthForAddressString(
    IN      PCHAR           pchString,
    IN      DWORD           dwStringLength
    )
/*++

Routine Description:

    Find length of ATMA address corresponding to ATMA address string.

Arguments:

    pchString       - address string

    dwStringLength  - address string length

Return Value:

    Length of ATMA address -- includes the format\type byte.
    Non-zero value indicates successful conversion.
    Zero indicates bad address string.

--*/
{
    PCHAR   pchstringEnd;
    DWORD   length = 0;
    UCHAR   ch;

    DNSDBG( PARSE2, (
        "Dns_AtmaLengthForAddressString()\n"
        "\tpchString = %p\n",
        dwStringLength,
        pchString,
        pchString ));

    //
    //  get string length if not given
    //

    if ( ! dwStringLength )
    {
        dwStringLength = strlen( pchString );
    }
    pchstringEnd = pchString + dwStringLength;

    //
    //  get address length
    //
    //  E164 type
    //      ex.  +358.400.1234567
    //      - '+' to indicate E164
    //      - chars map one-to-one into address
    //      - arbitrarily placed "." separators
    //

    if ( *pchString == '+' )
    {
        pchString++;
        length++;

        while( pchString < pchstringEnd )
        {
            if ( *pchString++ != '.' )
            {
                length++;
            }
        }
        return( length );
    }

    //
    //  AESA type
    //      ex. 39.246f.123456789abcdef0123.00123456789a.00
    //      - 40 hex digits, mapping to 20 bytes
    //      - arbitrarily placed "." separators
    //

    else    // AESA format
    {
        while( pchString < pchstringEnd )
        {
            ch = *pchString++;

            if ( ch != '.' )
            {
                ch = HexCharToHexDigit(ch);
                if ( ch > 0xf )
                {
                    //  bad hex digit
                    DNSDBG( PARSE2, (
                        "ERROR:  Parsing ATMA AESA address;\n"
                        "\tch = %c not hex digit\n",
                        *(pchString-1) ));
                    return( 0 );
                }
                length++;
            }
        }

        if ( length == ATMA_AESA_HEX_DIGIT_COUNT )
        {
            return ATMA_AESA_RECORD_LENGTH;
        }
        DNSDBG( PARSE2, (
            "ERROR:  Parsing ATMA AESA address;\n"
            "\tinvalid length = %d\n",
            length ));
        return( 0 );    // bad digit count
    }
}



DNS_STATUS
Dns_AtmaStringToAddress(
    OUT     PBYTE           pAddress,
    IN OUT  PDWORD          pdwAddrLength,
    IN      PCHAR           pchString,
    IN      DWORD           dwStringLength
    )
/*++

Routine Description:

    Convert string to ATMA address.

Arguments:

    pAddress        - buffer to receive address

    pdwAddrLength   - ptr to DWORD holding buffer length (if MAX_DWORD) no length check

    pchString       - address string

    dwStringLength  - address string length

Return Value:

    ERROR_SUCCESS if converted
    ERROR_MORE_DATA if buffer too small.
    ERROR_INVALID_DATA on bum ATMA address string.

--*/
{
    UCHAR   ch;
    PCHAR   pch;
    PCHAR   pchstringEnd;
    DWORD   length;

    DNSDBG( PARSE2, (
        "Parsing ATMA address %.*s\n"
        "\tpchString = %p\n",
        dwStringLength,
        pchString,
        pchString ));

    //
    //  get string length if not given
    //

    if ( ! dwStringLength )
    {
        dwStringLength = strlen( pchString );
    }
    pchstringEnd = pchString + dwStringLength;

    //
    //  check for adequate length
    //
    //  DCR_PERF:  if have max length on ATMA, skip length check
    //      allow direct conversion, catching errors there
    //

    length = Dns_AtmaAddressLengthForAddressString(
                pchString,
                dwStringLength );
    if ( length == 0 )
    {
        return( ERROR_INVALID_DATA );
    }
    if ( length > *pdwAddrLength )
    {
        *pdwAddrLength = length;
        return( ERROR_MORE_DATA );
    }

    //
    //  read address into buffer
    //
    //  E164 type
    //      ex.  +358.400.1234567
    //      - '+' to indicate E164
    //      - chars map one-to-one into address
    //      - arbitrarily placed "." separators
    //

    pch = pAddress;

    if ( *pchString == '+' )
    {
        *pch++ = DNS_ATMA_FORMAT_E164;
        pchString++;

        while( pchString < pchstringEnd )
        {
            ch = *pchString++;
            if ( ch != '.' )
            {
                *pch++ = ch;
            }
        }
        ASSERT( pch == (PCHAR)pAddress + length );
    }

    //
    //  AESA type
    //      ex. 39.246f.123456789abcdef0123.00123456789a.00
    //      - 40 hex digits, mapping to 20 bytes
    //      - arbitrarily placed "." separators
    //

    else    // AESA format
    {
        BOOL    fodd = FALSE;

        *pch++ = DNS_ATMA_FORMAT_AESA;

        while( pchString < pchstringEnd )
        {
            ch = *pchString++;

            if ( ch != '.' )
            {
                ch = HexCharToHexDigit(ch);
                if ( ch > 0xf )
                {
                    ASSERT( FALSE );        // shouldn't hit with test above
                    return( ERROR_INVALID_DATA );
                }
                if ( !fodd )
                {
                    *pch = (ch << 4);
                    fodd = TRUE;
                }
                else
                {
                    *pch++ += ch;
                    fodd = FALSE;
                }
            }
        }
        ASSERT( !fodd );
        ASSERT( pch == (PCHAR)pAddress + length );
    }

    *pdwAddrLength = length;
    return( ERROR_SUCCESS );
}



PCHAR
Dns_AtmaAddressToString(
    OUT     PCHAR           pchString,
    IN      UCHAR           AddrType,
    IN      PBYTE           pAddress,
    IN      DWORD           dwAddrLength
    )
/*++

Routine Description:

    Convert ATMA address to string format.

Arguments:

    pchString -- buffer to hold string;  MUST be at least
        IPV6_ADDRESS_STRING_LENGTH+1 in length

    pAddress -- ATMA address to convert to string

    dwAddrLength -- length of address

Return Value:

    Ptr to next location in buffer (the terminating NULL).
    NULL on bogus ATM address.

--*/
{
    DWORD   count = 0;
    UCHAR   ch;
    UCHAR   lowDigit;

    //
    //  read address into buffer
    //
    //  E164 type
    //      ex.  +358.400.1234567
    //      - '+' to indicate E164
    //      - chars map one-to-one into address
    //      - arbitrarily placed "." separators
    //      -> write with separating dots after 3rd and 6th chars
    //

    if ( AddrType == DNS_ATMA_FORMAT_E164 )
    {
        *pchString++ = '+';

        while( count < dwAddrLength )
        {
            if ( count == 3 || count == 6 )
            {
                *pchString++ = '.';
            }
            *pchString++ = pAddress[count++];
        }
    }

    //
    //  AESA type
    //      ex. 39.246f.123456789abcdef0123.00123456789a.00
    //      - 40 hex digits, mapping to 20 bytes
    //      - arbitrarily placed "." separators
    //      -> write with separators after chars 1,3,13,19
    //          (hex digits 2,6,26,38)
    //

    else if ( AddrType == DNS_ATMA_FORMAT_AESA )
    {
        if ( dwAddrLength != DNS_ATMA_AESA_ADDR_LENGTH )
        {
            return( NULL );
        }

        while( count < dwAddrLength )
        {
            if ( count == 1 || count == 3 || count == 13 || count == 19 )
            {
                *pchString++ = '.';
            }
            ch = pAddress[count++];

            //  save low hex digit, then get and convert high digit

            lowDigit = ch & 0xf;
            ch >>= 4;
            *pchString++ = HexDigitToHexChar( ch );
            *pchString++ = HexDigitToHexChar( lowDigit );
        }
        //  could ASSERT here that have written exactly 44 chars
    }

    //  no other ATM address formats supported

    else
    {
        return( NULL );
    }

    *pchString = 0;             // NULL terminate
    return( pchString );
}


//
//  End record.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\record.h ===
/*++

Copyright(c) 1996-2000 Microsoft Corporation

Module Name:

    record.h

Abstract:

    Domain Name System (DNS) Library

    Resource record definitions.

Author:

    Jim Gilroy (jamesg)     December 1996

Revision History:

--*/


#ifndef _DNS_RECORD_INCLUDED_
#define _DNS_RECORD_INCLUDED_

//
//  Temp header while changing definition of DNS_RECORD structure
//

#undef DNS_PTR_DATA
#undef PDNS_PTR_DATA

#undef DNS_SOA_DATA
#undef PDNS_SOA_DATA

#undef DNS_MINFO_DATA
#undef PDNS_MINFO_DATA

#undef DNS_MX_DATA
#undef PDNS_MX_DATA

#undef DNS_TXT_DATA
#undef PDNS_TXT_DATA

#undef DNS_SIG_DATA
#undef PDNS_SIG_DATA

#undef DNS_KEY_DATA
#undef PDNS_KEY_DATA

#undef DNS_NXT_DATA
#undef PDNS_NXT_DATA

#undef DNS_SRV_DATA
#undef PDNS_SRV_DATA

#undef DNS_TSIG_DATA
#undef PDNS_TSIG_DATA

#undef DNS_TKEY_DATA
#undef PDNS_TKEY_DATA

#undef DNS_WINSR_DATA
#undef PDNS_WINSR_DATA

//  the big one

#undef DNS_RECORD
#undef PDNS_RECORD

//  the subs

#undef DNS_TEXT
#undef DNS_NAME


//
//  Define PDNS_NAME and PDNS_TEXT to make explicit
//

#ifdef UNICODE
typedef LPWSTR  PDNS_NAME;
#else
typedef LPSTR   PDNS_NAME;
#endif

#ifdef UNICODE
typedef LPWSTR  PDNS_TEXT;
#else
typedef LPSTR   PDNS_TEXT;
#endif

//
//  Data types
//

typedef struct
{
    PDNS_NAME   pszHost;
}
DNS_PTR_DATA, *PDNS_PTR_DATA;

typedef struct
{
    PDNS_NAME   pszPrimaryServer;
    PDNS_NAME   pszAdministrator;
    DWORD       dwSerialNo;
    DWORD       dwRefresh;
    DWORD       dwRetry;
    DWORD       dwExpire;
    DWORD       dwDefaultTtl;
}
DNS_SOA_DATA, *PDNS_SOA_DATA;

typedef struct
{
    PDNS_NAME   pszMailbox;
    PDNS_NAME   pszErrorsMailbox;
}
DNS_MINFO_DATA, *PDNS_MINFO_DATA;

typedef struct
{
    PDNS_NAME   pszExchange;
    WORD        wPreference;
    WORD        Pad;        // keep ptrs DWORD aligned
}
DNS_MX_DATA, *PDNS_MX_DATA;

typedef struct
{
    DWORD       dwStringCount;
    PDNS_TEXT   pStringArray[1];
}
DNS_TXT_DATA, *PDNS_TXT_DATA;

typedef struct
{
    PDNS_NAME   pszSigner;
    WORD        wTypeCovered;
    BYTE        chAlgorithm;
    BYTE        chLabelCount;
    DWORD       dwOriginalTtl;
    DWORD       dwSigExpiration;
    DWORD       dwSigInception;
    WORD        wKeyTag;
    WORD        Pad;        // keep byte field aligned
    BYTE        Signature[1];
}
DNS_SIG_DATA, *PDNS_SIG_DATA;

typedef struct
{
    WORD        wFlags;
    BYTE        chProtocol;
    BYTE        chAlgorithm;
    BYTE        Key[1];
}
DNS_KEY_DATA, *PDNS_KEY_DATA;

typedef struct
{
    PDNS_NAME   pszNext;
    BYTE        bTypeBitMap[1];
}
DNS_NXT_DATA, *PDNS_NXT_DATA;

typedef struct
{
    PDNS_NAME   pszTarget;
    WORD        wPriority;
    WORD        wWeight;
    WORD        wPort;
    WORD        Pad;        // keep ptrs DWORD aligned
}
DNS_SRV_DATA, *PDNS_SRV_DATA;

typedef struct
{
    PDNS_NAME   pszAlgorithm;
    PBYTE       pAlgorithmPacket;
    PBYTE       pKey;
    PBYTE       pOtherData;
    DWORD       dwCreateTime;
    DWORD       dwExpireTime;
    WORD        wMode;
    WORD        wError;
    WORD        wKeyLength;
    WORD        wOtherLength;
    UCHAR       cAlgNameLength;
    BOOLEAN     fPacketPointers;
}
DNS_TKEY_DATA, *PDNS_TKEY_DATA;

typedef struct
{
    PDNS_NAME   pszAlgorithm;
    PBYTE       pAlgorithmPacket;
    PBYTE       pSignature;
    PBYTE       pOtherData;
    LONGLONG    i64CreateTime;
    WORD        wFudgeTime;
    WORD        wError;
    WORD        wSigLength;
    WORD        wOtherLength;
    UCHAR       cAlgNameLength;
    BOOLEAN     fPacketPointers;
}
DNS_TSIG_DATA, *PDNS_TSIG_DATA;


//
//  MS only types -- only hit the wire in MS-MS zone transfer
//

typedef struct
{
    DWORD       dwMappingFlag;
    DWORD       dwLookupTimeout;
    DWORD       dwCacheTimeout;
    PDNS_NAME   pszResultDomain;
}
DNS_WINSR_DATA, *PDNS_WINSR_DATA;



//
//  Record \ RR set structure
//
//  Note:   The dwReserved flag serves to insure that the substructures
//          start on 64-bit boundaries.  Since adding the LONGLONG to
//          TSIG structure the compiler wants to start them there anyway
//          (to 64-align).  This insures that no matter what data fields
//          are present we are properly 64-aligned.
//
//          Do NOT pack this structure, as the substructures to be 64-aligned
//          for Win64.
//

typedef struct _DnsRecord
{
    struct _DnsRecord * pNext;
    PDNS_NAME           pszOwner;
    WORD                wType;
    WORD                wDataLength;
    union
    {
        DWORD           W;  // flags as dword
        DNSREC_FLAGS    S;  // flags as structure

    } Flags;

    DWORD               dwTtl;
    DWORD               dwReserved;
    union
    {
        DNS_A_DATA      A;
        DNS_SOA_DATA    SOA, Soa;
        DNS_PTR_DATA    PTR, Ptr,
                        NS, Ns,
                        CNAME, Cname,
                        MB, Mb,
                        MD, Md,
                        MF, Mf,
                        MG, Mg,
                        MR, Mr;
        DNS_MINFO_DATA  MINFO, Minfo,
                        RP, Rp;
        DNS_MX_DATA     MX, Mx,
                        AFSDB, Afsdb,
                        RT, Rt;
        DNS_TXT_DATA    HINFO, Hinfo,
                        ISDN, Isdn,
                        TXT, Txt,
                        X25;
        DNS_NULL_DATA   Null;
        DNS_WKS_DATA    WKS, Wks;
        DNS_AAAA_DATA   AAAA;
        DNS_SRV_DATA    SRV, Srv;
        DNS_TKEY_DATA   TKEY, Tkey;
        DNS_TSIG_DATA   TSIG, Tsig;
        DNS_ATMA_DATA   ATMA, Atma;
        DNS_WINS_DATA   WINS, Wins;
        DNS_WINSR_DATA  WINSR, WinsR, NBSTAT, Nbstat;

    } Data;
}
DNS_RECORD, *PDNS_RECORD;



#endif // _DNS_RECORD_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\rralloc.c ===
/*++

Copyright (c) 1996-2001  Microsoft Corporation

Module Name:

    rralloc.c

Abstract:

    Domain Name System (DNS) Library

    Resource record allocation \ creation routines.

Author:

    Jim Gilroy (jamesg)     January, 1997

Environment:

    User Mode - Win32

Revision History:

--*/


#include "local.h"

#define SET_FLAGS(Flags, value) \
            ( *(PWORD)&(Flags) = value )



PDNS_RECORD
WINAPI
Dns_AllocateRecord(
    IN      WORD            wBufferLength
    )
/*++

Routine Description:

    Allocate record structure.

Arguments:

    wBufferLength - desired buffer length (beyond structure header)

Return Value:

    Ptr to message buffer.
    NULL on error.

--*/
{
    PDNS_RECORD prr;

    prr = ALLOCATE_HEAP( SIZEOF_DNS_RECORD_HEADER + wBufferLength );
    if ( prr == NULL )
    {
        SetLastError( DNS_ERROR_NO_MEMORY );
        return( NULL );
    }
    RtlZeroMemory(
        prr,
        SIZEOF_DNS_RECORD_HEADER );

    //  as first cut, set datalength to buffer length

    prr->wDataLength = wBufferLength;
    return( prr );
}



VOID
WINAPI
Dns_RecordFree(
    IN OUT  PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Free a record

Arguments:

    pRecord -- record list to free

Return Value:

    None.

--*/
{
    DNSDBG( HEAP, ( "Dns_RecordFree( %p )\n", pRecord ));

    //  handle NULL for convenience

    if ( !pRecord )
    {
        return;
    }

    //  free owner name?

    if ( FLAG_FreeOwner( pRecord ) )
    {
        FREE_HEAP( pRecord->pName );
    }

    //
    //  free data -- but only if flag set
    //
    //  note:  even if we fix copy functions to do atomic
    //      allocations, we'll still have to have free to
    //      handle RPC allocations
    //      (unless we very cleverly, treated RPC as flat blob, then
    //      did fix up (to offsets before and afterward)
    //

    if ( FLAG_FreeData( pRecord ) )
    {
        switch( pRecord->wType )
        {
        case DNS_TYPE_A:
            break;

        case DNS_TYPE_PTR:
        case DNS_TYPE_NS:
        case DNS_TYPE_CNAME:
        case DNS_TYPE_MB:
        case DNS_TYPE_MD:
        case DNS_TYPE_MF:
        case DNS_TYPE_MG:
        case DNS_TYPE_MR:

            if ( pRecord->Data.PTR.pNameHost )
            {
                FREE_HEAP( pRecord->Data.PTR.pNameHost );
            }
            break;

        case DNS_TYPE_SOA:

            if ( pRecord->Data.SOA.pNamePrimaryServer )
            {
                FREE_HEAP( pRecord->Data.SOA.pNamePrimaryServer );
            }
            if ( pRecord->Data.SOA.pNameAdministrator )
            {
                FREE_HEAP( pRecord->Data.SOA.pNameAdministrator );
            }
            break;

        case DNS_TYPE_MINFO:
        case DNS_TYPE_RP:

            if ( pRecord->Data.MINFO.pNameMailbox )
            {
                FREE_HEAP( pRecord->Data.MINFO.pNameMailbox );
            }
            if ( pRecord->Data.MINFO.pNameErrorsMailbox )
            {
                FREE_HEAP( pRecord->Data.MINFO.pNameErrorsMailbox );
            }
            break;

        case DNS_TYPE_MX:
        case DNS_TYPE_AFSDB:
        case DNS_TYPE_RT:

            if ( pRecord->Data.MX.pNameExchange )
            {
                FREE_HEAP( pRecord->Data.MX.pNameExchange );
            }
            break;

        case DNS_TYPE_HINFO:
        case DNS_TYPE_ISDN:
        case DNS_TYPE_TEXT:
        case DNS_TYPE_X25:

            {
                DWORD   iter;
                DWORD   count = pRecord->Data.TXT.dwStringCount;

                for ( iter = 0; iter < count; iter++ )
                {
                    if ( pRecord->Data.TXT.pStringArray[iter] )
                    {
                        FREE_HEAP( pRecord->Data.TXT.pStringArray[iter] );
                    }
                }
                break;
            }

        case DNS_TYPE_SRV:

            if ( pRecord->Data.SRV.pNameTarget )
            {
                FREE_HEAP( pRecord->Data.SRV.pNameTarget );
            }
            break;

        case DNS_TYPE_WINSR:

            if ( pRecord->Data.WINSR.pNameResultDomain )
            {
                FREE_HEAP( pRecord->Data.WINSR.pNameResultDomain );
            }
            break;

        default:

            // other types -- A, AAAA, ATMA, WINS, NULL,
            // have no internal pointers

            break;
        }
    }

    //  for catching heap problems

    pRecord->pNext = DNS_BAD_PTR;
    pRecord->pName = DNS_BAD_PTR;

    FREE_HEAP( pRecord );
}



VOID
WINAPI
Dns_RecordListFree(
    IN OUT  PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Free list of records.

Arguments:

    pRecord -- record list to free

Return Value:

    None.

--*/
{
    PDNS_RECORD pnext;

    DNSDBG( TRACE, (
        "Dns_RecordListFree( %p )\n",
        pRecord ));

    //
    //  loop through and free every RR in list
    //

    while ( pRecord )
    {
        pnext = pRecord->pNext;

        Dns_RecordFree( pRecord );

        pRecord = pnext;
    }
}



VOID
WINAPI
Dns_RecordListFreeEx(
    IN OUT  PDNS_RECORD     pRecord,
    IN      BOOL            fFreeOwner
    )
/*++

Routine Description:

    Free list of records.

    DCR:  RecordListFreeEx  (no free owner option) is probably useless

    Note:  owner name is freed ONLY when indicated by flag;
        other ptrs are considered to be either
            1) internal as when records read from wire or copied
            2) external and to be freed by record creator

Arguments:

    pRecord -- record list to free

    fFreeOwner -- flag indicating owner name should be freed

Return Value:

    None.

--*/
{
    PDNS_RECORD pnext;

    DNSDBG( TRACE, (
        "Dns_RecordListFreeEx( %p, %d )\n",
        pRecord,
        fFreeOwner ));

    //
    //  loop through and free every RR in list
    //

    while ( pRecord )
    {
        pnext = pRecord->pNext;

        //  free owner name?
        //      - if "FreeOwner" flag NOT set, then don't free

        if ( !fFreeOwner )
        {
            FLAG_FreeOwner( pRecord ) = FALSE;
        }

        //  free record

        Dns_RecordFree( pRecord );

        pRecord = pnext;
    }
}



//
//  Special record type creation routines
//

PDNS_RECORD
CreateRecordBasic(
    IN      PDNS_NAME       pOwnerName,
    IN      BOOL            fCopyName,
    IN      WORD            wType,
    IN      WORD            wDataLength,
    IN      DWORD           AllocLength,
    IN      DWORD           Ttl,
    IN      DNS_CHARSET     NameCharSet,
    IN      DNS_CHARSET     RecordCharSet
    )
/*++

Routine Description:

    Create record of arbitary type.

    Helper function to wrap up
        - record alloc
        - name alloc
        - basic setup

Arguments:

    pOwnerName -- owner name

    fCopyName -- TRUE - make copy of owner name
                 FALSE - use directly

    wType -- type

    AllocLength -- allocaction length, including any imbedded data

    wDataLength -- data length to set

    Ttl -- TTL

    NameCharSet -- character set of name

    RecordCharSet -- character set for resulting record

Return Value:

    Ptr to PTR record.
    NULL on error.

--*/
{
    PDNS_RECORD precord;
    PDNS_RECORD prr;
    PCHAR       pname;
    DWORD       bufLength;

    //
    //  alloc record
    //

    prr = Dns_AllocateRecord( (WORD)AllocLength );
    if ( !prr )
    {
        return( NULL );
    }

    //
    //  copy owner name
    //

    if ( fCopyName && pOwnerName )
    {
        pname = Dns_NameCopyAllocate(
                    pOwnerName,
                    0,              // length unknown
                    NameCharSet,
                    RecordCharSet );
        if ( !pname )
        {
            FREE_HEAP( prr );
            return( NULL );
        }
    }
    else
    {
        pname = pOwnerName;
    }
    
    //
    //  set fields
    //      - name, type and charset
    //      - TTL, section left zero
    //      - FreeData is specifically off
    //

    prr->pName = pname;
    prr->wType = wType;
    prr->wDataLength = wDataLength;
    SET_FREE_OWNER(prr);
    prr->Flags.S.CharSet = RecordCharSet;
    prr->dwTtl = Ttl;

    return( prr );
}



PDNS_RECORD
Dns_CreateFlatRecord(
    IN      PDNS_NAME       pOwnerName,
    IN      WORD            wType,
    IN      PCHAR           pData,
    IN      DWORD           DataLength,
    IN      DWORD           Ttl,
    IN      DNS_CHARSET     NameCharSet,
    IN      DNS_CHARSET     RecordCharSet
    )
/*++

Routine Description:

    Create flat record.

Arguments:

    pOwnerName -- owner name

    wType -- record type

    pData -- ptr to data for record

    DataLength -- length (in bytes) of data

    Ttl -- TTL

    NameCharSet -- character set of name

    RecordCharSet -- character set for resulting record

Return Value:

    Ptr to PTR record.
    NULL on error.

--*/
{
    PDNS_RECORD prr;

    //
    //  determine record size
    //      - record buffer will include hostname
    //

    prr = CreateRecordBasic(
                pOwnerName,
                TRUE,               // copy name
                wType,
                (WORD) DataLength,  // datalength
                DataLength,         // alloc datalength
                Ttl,
                NameCharSet,
                RecordCharSet );
    if ( !prr )
    {
        return( NULL );
    }

    //
    //  copy in data
    //

    RtlCopyMemory(
        (PBYTE) &prr->Data,
        pData,
        DataLength );

    return( prr );
}



PDNS_RECORD
Dns_CreatePtrTypeRecord(
    IN      PDNS_NAME       pOwnerName,
    IN      BOOL            fCopyName,
    IN      PDNS_NAME       pTargetName,
    IN      WORD            wType,
    IN      DWORD           Ttl,
    IN      DNS_CHARSET     NameCharSet,
    IN      DNS_CHARSET     RecordCharSet
    )
/*++

Routine Description:

    Create PTR type (single-indirection) record.

    This can be used to create any "PTR-type" record:
        PTR, CNAME, NS, etc.

Arguments:

    pOwnerName -- owner name

    fCopyName -- TRUE - make copy of owner name
                 FALSE - use directly

    pTargetName -- target name

    Ttl -- TTL

    NameCharSet -- character set of name

    RecordCharSet -- character set for resulting record

Return Value:

    Ptr to PTR record.
    NULL on error.

--*/
{
    PDNS_RECORD precord;
    PDNS_RECORD prr;
    PCHAR       pname;
    DWORD       bufLength;

    //
    //  determine record size
    //      - record buffer will include hostname
    //

    bufLength = Dns_GetBufferLengthForNameCopy(
                        pTargetName,
                        0,              // length unknown
                        NameCharSet,
                        RecordCharSet );
    if ( !bufLength )
    {
        return( NULL );
    }

    //
    //  create record
    //

    prr = CreateRecordBasic(
                pOwnerName,
                fCopyName,
                wType,
                sizeof(DNS_PTR_DATA),               // data length
                (sizeof(DNS_PTR_DATA) + bufLength), // alloc length
                Ttl,
                NameCharSet,
                RecordCharSet );
    if ( !prr )
    {
        return( NULL );
    }

    //
    //  write target name into buffer, immediately following PTR data struct
    //

    prr->Data.PTR.pNameHost = (PCHAR)&prr->Data + sizeof(DNS_PTR_DATA);

    Dns_NameCopy(
        prr->Data.PTR.pNameHost,
        NULL,
        pTargetName,
        0,
        NameCharSet,
        RecordCharSet
        );

    return( prr );
}



PDNS_RECORD
Dns_CreatePtrRecordEx(
    IN      PIP_UNION       pIp,
    IN      PDNS_NAME       pszHostName,
    IN      DWORD           Ttl,
    IN      DNS_CHARSET     NameCharSet,
    IN      DNS_CHARSET     RecordCharSet
    )
/*++

Routine Description:

    Create PTR record from IP address and hostname.

Arguments:

    pIp -- IP union (IP4 or IP6)

    pszHostName -- host name, FULL FQDN

    Ttl -- TTL

    NameCharSet -- character set of name

    RecordCharSet -- character set for resulting record

Return Value:

    Ptr to PTR record.
    NULL on error.

--*/
{
    PCHAR       pname;

    //
    //  create reverse lookup name
    //      - note this is external allocation
    //

    if ( IPUNION_IS_IP4( pIp ) )
    {
        IP4_ADDRESS ip = IPUNION_GET_IP4(pIp);

        if ( RecordCharSet == DnsCharSetUnicode )
        {
            pname = (PCHAR) Dns_Ip4AddressToReverseNameAlloc_W( ip );
        }
        else
        {
            pname = Dns_Ip4AddressToReverseNameAlloc_A( ip );
        }
    }
    else
    {
        IP6_ADDRESS     ip = IPUNION_GET_IP6(pIp);

        if ( RecordCharSet == DnsCharSetUnicode )
        {
            pname = (PCHAR) Dns_Ip6AddressToReverseNameAlloc_W( ip );
        }
        else
        {
            pname = Dns_Ip6AddressToReverseNameAlloc_A( ip );
        }
    }

    if ( !pname )
    {
        return( NULL );
    }

    //
    //  build record
    //

    return  Dns_CreatePtrTypeRecord(
                pname,
                FALSE,          // don't copy IP
                pszHostName,    // target name
                DNS_TYPE_PTR,
                Ttl,
                NameCharSet,
                RecordCharSet );
}



PDNS_RECORD
Dns_CreatePtrRecordExEx(
    IN      PIP_UNION       pIp,
    IN      PSTR            pszHostName,
    IN      PSTR            pszDomainName,
    IN      DWORD           Ttl,
    IN      DNS_CHARSET     NameCharSet,
    IN      DNS_CHARSET     RecordCharSet
    )
/*++

Routine Description:

    Create PTR record from hostname and domain name.

    Helper function for DHCP registrations when hostname
    and domain name are separate and both required.

Arguments:

    pIp -- IP union (IP4 or IP6)

    pszHostName -- host name (single label)

    pszDomainName -- domain name

    Ttl -- TTL

    NameCharSet -- character set of name

    RecordCharSet -- character set for resulting record

Return Value:

    Ptr to PTR record.
    NULL on error.

--*/
{
    WCHAR   nameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];

    DNSDBG( TRACE, (
        "Dns_CreatePtrRecordExEx()\n" ));

    //
    //  build appended name
    //
    //  DCR:  could require just host name and check that
    //          either domain exists or hostname is full
    //

    if ( !pszHostName || !pszDomainName )
    {
        return  NULL;
    }

    if ( NameCharSet != DnsCharSetUnicode )
    {
        if ( ! Dns_NameAppend_A(
                    (PCHAR) nameBuffer,
                    DNS_MAX_NAME_BUFFER_LENGTH,
                    pszHostName,
                    pszDomainName ) )
        {
            DNS_ASSERT( FALSE );
            return  NULL;
        }
    }
    else
    {
        if ( ! Dns_NameAppend_W(
                    (PWCHAR) nameBuffer,
                    DNS_MAX_NAME_BUFFER_LENGTH,
                    (PWSTR) pszHostName,
                    (PWSTR) pszDomainName ) )
        {
            DNS_ASSERT( FALSE );
            return  NULL;
        }
    }

    //
    //  build record
    //

    return  Dns_CreatePtrRecordEx(
                    pIp,
                    (PCHAR) nameBuffer,
                    Ttl,
                    NameCharSet,
                    RecordCharSet
                    );
}



PDNS_RECORD
Dns_CreateARecord(
    IN      PDNS_NAME       pOwnerName,
    IN      IP_ADDRESS      Ip4Addr,
    IN      DWORD           Ttl,
    IN      DNS_CHARSET     NameCharSet,
    IN      DNS_CHARSET     RecordCharSet
    )
/*++

Routine Description:

    Create A record.

Arguments:

    pOwnerName -- owner name

    Ip4Addr -- IP address

    Ttl -- TTL

    NameCharSet -- character set of name

    RecordCharSet -- character set for resulting record

Return Value:

    Ptr to PTR record.
    NULL on error.

--*/
{
    PDNS_RECORD prr;

    //
    //  determine record size
    //      - record buffer will include hostname
    //

    prr = CreateRecordBasic(
                pOwnerName,
                TRUE,           // copy name
                DNS_TYPE_A,
                sizeof(DNS_A_DATA),
                sizeof(DNS_A_DATA),
                Ttl,
                NameCharSet,
                RecordCharSet );
    if ( !prr )
    {
        return( NULL );
    }

    //
    //  set IP
    //

    prr->Data.A.IpAddress = Ip4Addr;

    return( prr );
}



PDNS_RECORD
Dns_CreateAAAARecord(
    IN      PDNS_NAME       pOwnerName,
    IN      IP6_ADDRESS     Ip6Addr,
    IN      DWORD           Ttl,
    IN      DNS_CHARSET     NameCharSet,
    IN      DNS_CHARSET     RecordCharSet
    )
/*++

Routine Description:

    Create A record.

Arguments:

    pOwnerName -- owner name

    Ip6Addr -- IP6 address

    Ttl -- TTL

    NameCharSet -- character set of name

    RecordCharSet -- character set for resulting record

Return Value:

    Ptr to PTR record.
    NULL on error.

--*/
{
    PDNS_RECORD prr;

    //
    //  determine record size
    //      - record buffer will include hostname
    //

    prr = CreateRecordBasic(
                pOwnerName,
                TRUE,               // copy name
                DNS_TYPE_AAAA,
                sizeof(DNS_AAAA_DATA),
                sizeof(DNS_AAAA_DATA),
                Ttl,
                NameCharSet,
                RecordCharSet );
    if ( !prr )
    {
        return( NULL );
    }

    //
    //  set IP
    //

    prr->Data.AAAA.Ip6Address = Ip6Addr;

    return( prr );
}



PDNS_RECORD
Dns_CreateForwardRecord(
    IN      PDNS_NAME       pOwnerName,
    IN      PIP_UNION       pIp,
    IN      DWORD           Ttl,
    IN      DNS_CHARSET     NameCharSet,
    IN      DNS_CHARSET     RecordCharSet
    )
/*++

Routine Description:

    Create forward lookup record.

    This is just a shim to avoid duplicating selection logic.

Arguments:

    pOwnerName -- owner name

    pIp -- IP address union

    Ttl -- TTL

    NameCharSet -- character set of name

    RecordCharSet -- character set for resulting record

Return Value:

    Ptr to PTR record.
    NULL on error.

--*/
{
    //
    //  build desired type
    //
    //  DCR:  must add\choose A6
    //

    if ( IPUNION_IS_IP4( pIp ) )
    {
        return   Dns_CreateARecord(
                    pOwnerName,
                    IPUNION_GET_IP4(pIp),
                    Ttl,
                    NameCharSet,
                    RecordCharSet );
    }
    else
    {
        return   Dns_CreateAAAARecord(
                    pOwnerName,
                    IPUNION_GET_IP6(pIp),
                    Ttl,
                    NameCharSet,
                    RecordCharSet );
    }
}



PDNS_RECORD
Dns_CreateForwardRecordForSockaddr(
    IN      PDNS_NAME       pOwnerName,
    IN      PSOCKADDR       pSockaddr,
    IN      DWORD           Ttl,
    IN      DNS_CHARSET     NameCharSet,
    IN      DNS_CHARSET     RecordCharSet
    )
/*++

Routine Description:

    Create forward lookup record.

    This is just a shim to avoid duplicating selection logic.

Arguments:

    pOwnerName -- owner name

    pSockaddr -- ptr to sockaddr

    Ttl -- TTL

    NameCharSet -- character set of name

    RecordCharSet -- character set for resulting record

Return Value:

    Ptr to PTR record.
    NULL on error.

--*/
{
    PFAMILY_INFO pinfo;

    DNSDBG( TRACE, (
        "Dns_CreateForwardRecordForSockaddr()\n" ));

    pinfo = FamilyInfo_GetForSockaddr( pSockaddr );
    if ( !pinfo )
    {
        SetLastError( ERROR_INVALID_DATA );
        return  NULL;
    }

    //
    //  build flat record of desired type
    //

    return  Dns_CreateFlatRecord(
                pOwnerName,
                pinfo->DnsType,
                (PBYTE)pSockaddr + pinfo->OffsetToAddrInSockaddr,
                pinfo->LengthAddr,
                Ttl,
                NameCharSet,
                RecordCharSet );
}



PDNS_RECORD
Dns_CreateRecordForIpString_W(
    IN      PCWSTR          pwsName,
    IN      WORD            wType,
    IN      DWORD           Ttl
    )
/*++

Routine Description:

    Create record for IP string query.

Arguments:

    pwsName -- name that may be IP string query

    wType -- type of query

Return Value:

    Ptr to record for query, if query name\type is IP.
    NULL if query not for IP.

--*/
{
    IP_UNION        ipUnion;
    PDNS_RECORD     prr;


    DNSDBG( TRACE, (
        "\nDns_CreateRecordForIpString( %S, wType = %d )\n",
        pwsName,
        wType ));

    if ( !pwsName )
    {
        return  NULL;
    }

    //
    //  support A or AAAA queries for IP strings
    //      - IP4 strings must be in w.x.y.z form otherwise
    //      we convert the all numeric names also
    //
    //  DCR:  need A6 support for direct query
    //

    if ( wType == DNS_TYPE_A )
    {
        IP4_ADDRESS ip4;
        PCWSTR      pdot;
        DWORD       count;

        if ( ! Dns_Ip4StringToAddress_W(
                    & ip4,
                    (PWSTR) pwsName ) )
        {
            return  NULL;
        }

        //  verify three dot form w.x.y.z

        pdot = pwsName;
        count = 3;
        while ( count-- )
        {
            pdot = wcschr( pdot, L'.' );
            if ( !pdot || !*++pdot )
            {
                return( NULL );
            }
        }

        IPUNION_SET_IP4( &ipUnion, ip4 );
    }
    else if ( wType == DNS_TYPE_AAAA )
    {
        IP6_ADDRESS ip6;

        if ( ! Dns_Ip6StringToAddress_W(
                    & ip6,
                    (PWSTR) pwsName ) )
        {
            return  NULL;
        }
        IPUNION_SET_IP6( &ipUnion, ip6 );
    }
    else
    {
        return  NULL;
    }

    //
    //  name is IP string -- build record
    //

    prr = Dns_CreateForwardRecord(
                (PDNS_NAME) pwsName,
                & ipUnion,
                Ttl,
                DnsCharSetUnicode,
                DnsCharSetUnicode );

    DNSDBG( TRACE, (
        "Create record %p for IP string %S type %d.\n",
        prr,
        pwsName,
        wType ));

    return  prr;
}

//
//  End rralloc.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\rrbuild.c ===
/*++

Copyright (c) 1997-2001 Microsoft Corporation

Module Name:

    rrbuild.c

Abstract:

    Domain Name System (DNS) Library

    Build resource record routines.

Author:

    Jim Gilroy (jamesg)     January, 1997

Revision History:

    Jing Chen (t-jingc)     June, 1998

--*/


#include "local.h"


//
//  Type specific RR build routine prototypes
//

PDNS_RECORD
ARecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    );

PDNS_RECORD
ARecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    );

PDNS_RECORD
PtrRecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    );

PDNS_RECORD
PtrRecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    );

PDNS_RECORD
MxRecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    );

PDNS_RECORD
MxRecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    );

PDNS_RECORD
SoaRecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    );

PDNS_RECORD
SoaRecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    );

PDNS_RECORD
TxtRecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    );

PDNS_RECORD
TxtRecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *     Argv
    );

PDNS_RECORD
MinfoRecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    );

PDNS_RECORD
MinfoRecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    );

PDNS_RECORD
SrvRecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    );

PDNS_RECORD
SrvRecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    );

PDNS_RECORD
AtmaRecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    );

PDNS_RECORD
AtmaRecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    );

PDNS_RECORD
AaaaRecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    );

PDNS_RECORD
AaaaRecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    );

PDNS_RECORD
WinsRecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    );

PDNS_RECORD
WinsRecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    );

PDNS_RECORD
WinsrRecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    );

PDNS_RECORD
WinsrRecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    );

PDNS_RECORD
WksRecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    );

PDNS_RECORD
WksRecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    );

PDNS_RECORD
SigRecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    );

PDNS_RECORD
SigRecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    );

PDNS_RECORD
KeyRecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    );

PDNS_RECORD
KeyRecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    );

PDNS_RECORD
NxtRecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    );
PDNS_RECORD
NxtRecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    );



//
//  RR build routines jump table
//

RR_BUILD_FUNCTION   RRBuildTable[] =
{
    NULL,               //  ZERO
    ARecordBuild,       //  A
    PtrRecordBuild,     //  NS
    PtrRecordBuild,     //  MD
    PtrRecordBuild,     //  MF
    PtrRecordBuild,     //  CNAME
    SoaRecordBuild,     //  SOA
    PtrRecordBuild,     //  MB
    PtrRecordBuild,     //  MG
    PtrRecordBuild,     //  MR
    NULL,               //  NULL
    WksRecordBuild,     //  WKS
    PtrRecordBuild,     //  PTR
    TxtRecordBuild,     //  HINFO
    MinfoRecordBuild,   //  MINFO
    MxRecordBuild,      //  MX
    TxtRecordBuild,     //  TXT
    MinfoRecordBuild,   //  RP
    MxRecordBuild,      //  AFSDB
    TxtRecordBuild,     //  X25
    TxtRecordBuild,     //  ISDN
    MxRecordBuild,      //  RT
    NULL,               //  NSAP
    NULL,               //  NSAPPTR
    SigRecordBuild,     //  SIG
    KeyRecordBuild,     //  KEY
    NULL,               //  PX
    NULL,               //  GPOS
    AaaaRecordBuild,    //  AAAA
    NULL,               //  LOC
    NxtRecordBuild,     //  NXT
    NULL,               //  EID
    NULL,               //  NIMLOC
    SrvRecordBuild,     //  SRV
    AtmaRecordBuild,    //  ATMA
    NULL,               //  NAPTR
    NULL,               //  KX
    NULL,               //  CERT
    NULL,               //  A6
    NULL,               //  DNAME
    NULL,               //  SINK
    NULL,               //  OPT
    NULL,               //  42
    NULL,               //  43
    NULL,               //  44
    NULL,               //  45
    NULL,               //  46
    NULL,               //  47
    NULL,               //  48

    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as MAX_SELF_INDEXED_TYPE #define in record.h
    //         (see note above in record info table)

    //
    //  Pseudo record types
    //

    NULL,               //  TKEY
    NULL,               //  TSIG

    //
    //  MS only types
    //

    WinsRecordBuild,    //  WINS
    WinsrRecordBuild,   //  WINSR
};


RR_BUILD_FUNCTION_W   RRBuildTableW[] =
{
    NULL,               //  ZERO
    ARecordBuildW,      //  A
    PtrRecordBuildW,    //  NS
    PtrRecordBuildW,    //  MD
    PtrRecordBuildW,    //  MF
    PtrRecordBuildW,    //  CNAME
    SoaRecordBuildW,    //  SOA
    PtrRecordBuildW,    //  MB
    PtrRecordBuildW,    //  MG
    PtrRecordBuildW,    //  MR
    NULL,               //  NULL
    WksRecordBuildW,    //  WKS
    PtrRecordBuildW,    //  PTR
    TxtRecordBuildW,    //  HINFO
    MinfoRecordBuildW,  //  MINFO
    MxRecordBuildW,     //  MX
    TxtRecordBuildW,    //  TXT
    MinfoRecordBuildW,  //  RP
    MxRecordBuildW,     //  AFSDB
    TxtRecordBuildW,    //  X25
    TxtRecordBuildW,    //  ISDN
    MxRecordBuildW,     //  RT
    NULL,               //  NSAP
    NULL,               //  NSAPPTR
    SigRecordBuildW,    //  SIG
    KeyRecordBuildW,    //  KEY
    NULL,               //  PX
    NULL,               //  GPOS
    AaaaRecordBuildW,   //  AAAA
    NULL,               //  LOC
    NxtRecordBuildW,    //  NXT
    NULL,               //  EID   
    NULL,               //  NIMLOC
    SrvRecordBuildW,    //  SRV   
    AtmaRecordBuildW,   //  ATMA  
    NULL,               //  NAPTR 
    NULL,               //  KX    
    NULL,               //  CERT  
    NULL,               //  A6    
    NULL,               //  DNAME 
    NULL,               //  SINK  
    NULL,               //  OPT   
    NULL,               //  42
    NULL,               //  43
    NULL,               //  44
    NULL,               //  45
    NULL,               //  46
    NULL,               //  47
    NULL,               //  48

    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as MAX_SELF_INDEXED_TYPE #define in record.h
    //         (see note above in record info table)

    //
    //  Pseudo record types
    //

    NULL,               //  TKEY
    NULL,               //  TSIG

    //
    //  MS only types
    //

    WinsRecordBuildW,   //  WINS
    WinsrRecordBuildW,  //  WINSR
};



PDNS_RECORD
ARecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    )
/*++

Routine Description:

    Build A record from string data.

Arguments:

    Argc -- count of data arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;

    if ( Argc != 1 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }

    precord = Dns_AllocateRecord( sizeof(DNS_A_DATA) );
    if ( !precord )
    {
        return( NULL );
    }

    if ( ! Dns_Ip4StringToAddress_A(
                &precord->Data.A.IpAddress,
                Argv[0] ) )
    {
        Dns_RecordFree( precord );
        SetLastError( ERROR_INVALID_DATA );
        return NULL;
    }

    return( precord );
}


PDNS_RECORD
ARecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    )
/*++

Routine Description:

    Build A record from string data.

Arguments:

    Argc -- count of data arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;

    if ( Argc != 1 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }

    precord = Dns_AllocateRecord( sizeof(DNS_A_DATA) );
    if ( !precord )
    {
        return( NULL );
    }

    if ( ! Dns_Ip4StringToAddress_W(
                &precord->Data.A.IpAddress,
                Argv[0] ) )
    {
        Dns_RecordFree( precord );
        SetLastError( ERROR_INVALID_DATA );
        return NULL;
    }

    return( precord );
}



PDNS_RECORD
PtrRecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    )
/*++

Routine Description:

    Build PTR compatible record from string data.
    Includes: NS, PTR, CNAME, MB, MR, MG, MD, MF

Arguments:

    Argc -- count of data arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;

    if ( Argc != 1 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }

    precord = Dns_AllocateRecord( sizeof(DNS_PTR_DATA) );
    if ( !precord )
    {
        return( NULL );
    }
    precord->Data.PTR.pNameHost = Argv[0];

    return( precord );
}


PDNS_RECORD
PtrRecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    )
/*++

Routine Description:

    Build PTR compatible record from string data.
    Includes: NS, PTR, CNAME, MB, MR, MG, MD, MF

Arguments:

    Argc -- count of data arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;

    if ( Argc != 1 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }

    precord = Dns_AllocateRecord( sizeof(DNS_PTR_DATA) );
    if ( !precord )
    {
        return( NULL );
    }
    precord->Data.PTR.pNameHost = (PDNS_NAME) Argv[0];

    return( precord );
}



PDNS_RECORD
MxRecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    )
/*++

Routine Description:

    Build MX compatible record from string data.
    Includes: MX, RT, AFSDB

Arguments:

    Argc -- count of data arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    DWORD       temp;

    if ( Argc != 2 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }
    precord = Dns_AllocateRecord( sizeof(DNS_MX_DATA) );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  MX preference value
    //  RT preference
    //  AFSDB subtype
    //

    temp = strtoul( Argv[0], NULL, 10 );
    if ( temp > MAXWORD )
    {
        temp = MAXWORD;
    }
    precord->Data.MX.wPreference = (USHORT) temp;

    //
    //  MX exchange
    //  RT exchange
    //  AFSDB hostname
    //

    precord->Data.MX.pNameExchange = Argv[1];

    return( precord );
}


PDNS_RECORD
MxRecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    )
/*++

Routine Description:

    Build MX compatible record from string data.
    Includes: MX, RT, AFSDB

Arguments:

    Argc -- count of data arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    DWORD       temp;

    if ( Argc != 2 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }
    precord = Dns_AllocateRecord( sizeof(DNS_MX_DATA) );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  MX preference value
    //  RT preference
    //  AFSDB subtype
    //

    temp = wcstoul( Argv[0], NULL, 10 );
    if ( temp > MAXWORD )
    {
        temp = MAXWORD;
    }
    precord->Data.MX.wPreference = (USHORT) temp;

    //
    //  MX exchange
    //  RT exchange
    //  AFSDB hostname
    //

    precord->Data.MX.pNameExchange = (PDNS_NAME) Argv[1];

    return( precord );
}



PDNS_RECORD
SoaRecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    )
/*++

Routine Description:

    Build SOA record from string data.

Arguments:

    Argc -- count of data arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    PDWORD      pdword;

    if ( Argc != 7 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }
    precord = Dns_AllocateRecord( sizeof(DNS_SOA_DATA) );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  read primary server and responsible party
    //

    precord->Data.SOA.pNamePrimaryServer = Argv[0];
    Argc--;
    Argv++;
    precord->Data.SOA.pNameAdministrator = Argv[0];
    Argc--;
    Argv++;

    //
    //  read integer data
    //

    pdword = &precord->Data.SOA.dwSerialNo;

    while( Argc-- )
    {
        *pdword = strtoul( Argv[0], NULL, 10 );
        pdword++;
        Argv++;
    }

    return( precord );
}


PDNS_RECORD
SoaRecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    )
/*++

Routine Description:

    Build SOA record from string data.

Arguments:

    Argc -- count of data arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    PDWORD      pdword;

    if ( Argc != 7 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }
    precord = Dns_AllocateRecord( sizeof(DNS_SOA_DATA) );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  read primary server and responsible party
    //

    precord->Data.SOA.pNamePrimaryServer = (PDNS_NAME) Argv[0];
    Argc--;
    Argv++;
    precord->Data.SOA.pNameAdministrator = (PDNS_NAME) Argv[0];
    Argc--;
    Argv++;

    //
    //  read integer data
    //

    pdword = &precord->Data.SOA.dwSerialNo;

    while( Argc-- )
    {
        *pdword = wcstoul( Argv[0], NULL, 10 );
        pdword++;
        Argv++;
    }

    return( precord );
}



PDNS_RECORD
MinfoRecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    )
/*++

Routine Description:

    Build MINFO and RP records from string data.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;

    if ( Argc != 2 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }
    precord = Dns_AllocateRecord( sizeof(DNS_MINFO_DATA) );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  MINFO responsible mailbox
    //  RP responsible person mailbox

    precord->Data.MINFO.pNameMailbox = Argv[0];
    Argc--;
    Argv++;

    //
    //  MINFO errors to mailbox
    //  RP text RR location

    precord->Data.MINFO.pNameErrorsMailbox = Argv[0];
    Argc--;
    Argv++;

    return( precord );
}


PDNS_RECORD
MinfoRecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    )
/*++

Routine Description:

    Build MINFO and RP records from string data.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;

    if ( Argc != 2 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }
    precord = Dns_AllocateRecord( sizeof(DNS_MINFO_DATA) );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  MINFO responsible mailbox
    //  RP responsible person mailbox

    precord->Data.MINFO.pNameMailbox = (PDNS_NAME) Argv[0];
    Argc--;
    Argv++;

    //
    //  MINFO errors to mailbox
    //  RP text RR location

    precord->Data.MINFO.pNameErrorsMailbox = (PDNS_NAME) Argv[0];
    Argc--;
    Argv++;

    return( precord );
}



PDNS_RECORD
TxtRecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    )
/*++

Routine Description:

    Build TXT compatible records from string data.
    Includes: TXT, X25, HINFO, ISDN

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    WORD        dataLength;
    PCHAR *     pstringPtr;

    if ( Argc < 1 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }

    //
    //  allocate space for a pointer for each data string
    //

    precord = Dns_AllocateRecord( (WORD)DNS_TEXT_RECORD_LENGTH(Argc) );
    if ( !precord )
    {
        return( NULL );
    }
    precord->Data.TXT.dwStringCount = Argc;

    //
    //  read as many strings as we have
    //
    //  DCR_FIX:  no checking for string limits
    //      - string count limits on HINFO, X25, ISDN
    //      - 256 length on strings
    //      - 64K on overall size
    //

    pstringPtr = (PCHAR *) precord->Data.TXT.pStringArray;
    while ( Argc-- )
    {
        *pstringPtr = Argv[0];
        pstringPtr++;
        Argv++;
    }
    return( precord );
}


PDNS_RECORD
TxtRecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    )
/*++

Routine Description:

    Build TXT compatible records from string data.
    Includes: TXT, X25, HINFO, ISDN

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    WORD        dataLength;
    LPWSTR *    pstringPtr;

    if ( Argc < 1 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }

    //
    //  allocate space for a pointer for each data string
    //

    precord = Dns_AllocateRecord( (WORD)DNS_TEXT_RECORD_LENGTH(Argc) );
    if ( !precord )
    {
        return( NULL );
    }
    precord->Data.TXT.dwStringCount = Argc;

    //
    //  read as many strings as we have
    //
    //  DCR_FIX:  no checking for string limits
    //      - string count limits on HINFO, X25, ISDN
    //      - 256 length on strings
    //      - 64K on overall size
    //

    pstringPtr = (LPWSTR *) precord->Data.TXT.pStringArray;
    while ( Argc-- )
    {
        *pstringPtr = Argv[0];
        pstringPtr++;
        Argv++;
    }
    return( precord );
}



PDNS_RECORD
AaaaRecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    )
/*++

Routine Description:

    Build AAAA record from string data.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;

    if ( Argc != 1 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }
    precord = Dns_AllocateRecord( sizeof(DNS_AAAA_DATA) );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  read IP6 address
    //

    if ( ! Dns_Ip6StringToAddress_A(
                (PIP6_ADDRESS) &precord->Data.AAAA.Ip6Address,
                Argv[0] ) )
    {
        Dns_RecordFree( precord );
        SetLastError( ERROR_INVALID_DATA );
        return NULL;
    }
    return( precord );
}



PDNS_RECORD
AaaaRecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    )
/*++

Routine Description:

    Build AAAA record from string data.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD     precord;

    if ( Argc != 1 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }

    precord = Dns_AllocateRecord( sizeof(DNS_AAAA_DATA) );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  convert IPv6 string to address
    //

    if ( ! Dns_Ip6StringToAddress_W(
                &precord->Data.AAAA.Ip6Address,
                Argv[0]
                ) )
    {
        SetLastError( ERROR_INVALID_DATA );
        Dns_RecordFree( precord );
        return NULL;
    }

    return( precord );
}



PDNS_RECORD
SrvRecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    )
/*++

Routine Description:

    Build SRV record from string data.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    PWORD       pword;

    if ( Argc != 4 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }
    precord = Dns_AllocateRecord( sizeof(DNS_SRV_DATA) );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  read integer data
    //

    pword = &precord->Data.SRV.wPriority;

    while( Argc-- > 1 )
    {
        DWORD   temp;

        temp = strtoul( Argv[0], NULL, 10 );
        if ( temp > MAXWORD )
        {
            temp = MAXWORD;
        }
        *pword++ = (WORD) temp;
        Argv++;
    }

    //
    //  target host
    //

    precord->Data.SRV.pNameTarget = Argv[0];

    return( precord );
}



PDNS_RECORD
SrvRecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    )
/*++

Routine Description:

    Build SRV record from string data.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    PWORD       pword;

    if ( Argc != 4 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }
    precord = Dns_AllocateRecord( sizeof(DNS_SRV_DATA) );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  read integer data
    //

    pword = &precord->Data.SRV.wPriority;

    while( Argc-- > 1 )
    {
        DWORD   temp;

        temp = wcstoul( Argv[0], NULL, 10 );
        if ( temp > MAXWORD )
        {
            temp = MAXWORD;
        }
        *pword++ = (WORD) temp;
        Argv++;
    }

    //
    //  target host
    //

    precord->Data.SRV.pNameTarget = (PDNS_NAME) Argv[0];

    return( precord );
}



PDNS_RECORD
AtmaRecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    )
/*++

Routine Description:

    Build ATMA record from string data.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    PBYTE       pbyte;

    if ( Argc != 2 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }

    precord = Dns_AllocateRecord( sizeof(DNS_ATMA_DATA) +
                                  DNS_ATMA_MAX_ADDR_LENGTH );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  read integer data
    //

    pbyte = &precord->Data.ATMA.AddressType;

    *pbyte = (BYTE) strtoul( Argv[0], NULL, 10 );
    pbyte++;
    Argv++;

    if ( precord->Data.ATMA.AddressType == DNS_ATMA_FORMAT_E164 )
    {
        UINT length = strlen( Argv[0] );
        UINT iter;

        if ( length > DNS_ATMA_MAX_ADDR_LENGTH )
        {
            length = DNS_ATMA_MAX_ADDR_LENGTH;
        }
        for ( iter = 0; iter < length; iter++ )
        {
            precord->Data.ATMA.Address[iter] = Argv[0][iter];
        }

        precord->wDataLength = (WORD) length;
    }
    else
    {
        UINT length = strlen( Argv[0] );
        UINT iter;

        length /= 2;

        if ( length != DNS_ATMA_MAX_ADDR_LENGTH )
        {
            Dns_RecordListFree( precord );
            return NULL;
        }

        for ( iter = 0; iter < length; iter++ )
        {
            char temp[3];

            temp[0] = Argv[0][(2*iter)];
            temp[1] = Argv[0][(2*iter) + 1];
            temp[2] = 0;

            precord->Data.ATMA.Address[iter] = (char) strtoul( temp, NULL, 16 );
        }

        precord->wDataLength = (WORD) length;
    }

    return( precord );


}



PDNS_RECORD
AtmaRecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    )
/*++

Routine Description:

    Build ATMA record from string data.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    PBYTE       pbyte;
    CHAR        addrBuffer[256];
    DWORD       bufLength;

    if ( Argc != 2 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }
    precord = Dns_AllocateRecord( sizeof(DNS_ATMA_DATA) +
                                  DNS_ATMA_MAX_ADDR_LENGTH );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  read integer data
    //

    pbyte = &precord->Data.ATMA.AddressType;

    *pbyte = (BYTE) wcstoul( Argv[0], NULL, 10 );
    pbyte++;
    Argv++;

    //
    //  copy ATMA address string to wire
    //

    bufLength = DNS_ATMA_MAX_ADDR_LENGTH+1;

    if ( ! Dns_StringCopy(
                addrBuffer,
                & bufLength,
                (PCHAR) Argv[0],
                0,          // length unknown
                DnsCharSetUnicode,
                DnsCharSetWire
                ) )
    {
        Dns_RecordListFree( precord );
        SetLastError( ERROR_INVALID_DATA );
        return NULL;
    }

    //
    //  read address into record buffer
    //
    //  DCR_CLEANUP:  this is duplicate code with above function,
    //      functionalize and fix;  also remove this loop
    //      and do a memcopy
    //

    if ( precord->Data.ATMA.AddressType == DNS_ATMA_FORMAT_E164 )
    {
        UINT length = strlen( addrBuffer );
        UINT iter;

        if ( length > DNS_ATMA_MAX_ADDR_LENGTH )
        {
            length = DNS_ATMA_MAX_ADDR_LENGTH;
        }

        for ( iter = 0; iter < length; iter++ )
        {
            precord->Data.ATMA.Address[iter] = addrBuffer[iter];
        }

        precord->wDataLength = (WORD) length;
    }
    else
    {
        UINT length = strlen( addrBuffer );
        UINT iter;

        length /= 2;

        if ( length != DNS_ATMA_MAX_ADDR_LENGTH )
        {
            Dns_RecordListFree( precord );
            return NULL;
        }

        for ( iter = 0; iter < length; iter++ )
        {
            char temp[3];

            temp[0] = addrBuffer[(2*iter)];
            temp[1] = addrBuffer[(2*iter) + 1];
            temp[2] = 0;

            precord->Data.ATMA.Address[iter] = (char) strtoul( temp, NULL, 16 );
        }

        precord->wDataLength = (WORD) length;
    }

    return( precord );
}


PDNS_RECORD
WinsRecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    )
/*++

Routine Description:

    Build WINS record from string data.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD     precord;
    DWORD           ipCount = Argc - 3;
    PDWORD          pdword;
    PIP_ADDRESS     pip;

    if ( Argc < 4 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }

    precord = Dns_AllocateRecord( (WORD) DNS_WINS_RECORD_LENGTH((WORD) ipCount) );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  read integer data
    //
    //  DCR_ENHANCE:  could check for non-conversion in strtoul
    //

    pdword = &precord->Data.WINS.dwMappingFlag;

    while ( Argc > ipCount )
    {
        *pdword = (DWORD) strtoul( Argv[0], NULL, 10 );
        pdword++;
        Argv++;
        Argc--;
    }

    *pdword = ipCount;

    //
    //  convert IP addresses
    //

    pip = precord->Data.WINS.WinsServers;

    while ( Argc-- )
    {
        if ( ! Dns_Ip4StringToAddress_A(
                    pip,
                    Argv[0] ) )
        {
            Dns_RecordFree( precord );
            SetLastError( ERROR_INVALID_DATA );
            return NULL;
        }
        pip++;
        Argv++;
    }

    return( precord );
}



PDNS_RECORD
WinsRecordBuildW(
    IN      DWORD           Argc,
    IN      PWCHAR *        Argv
    )
/*++

Routine Description:

    Build WINS record from string data.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD     precord;
    DWORD           ipCount = Argc - 3;
    PDWORD          pdword;
    PIP_ADDRESS     pip;
    char            szAddr[256];

    if ( Argc < 4 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }

    precord = Dns_AllocateRecord( (WORD) DNS_WINS_RECORD_LENGTH((WORD) ipCount) );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  read integer data
    //
    //  DCR_ENHANCE:  could check for non-conversion in strtoul
    //

    pdword = &precord->Data.WINS.dwMappingFlag;

    while ( Argc-- > 1 )
    {
        *pdword = (DWORD) wcstoul( Argv[0], NULL, 10 );
        pdword++;
        Argv++;
    }

    *pdword =  ipCount;

    //
    //  convert IP addresses
    //

    pip = precord->Data.WINS.WinsServers;

    while ( Argc-- )
    {
        if ( ! Dns_Ip4StringToAddress_W(
                    pip,
                    Argv[0] ) )
        {
            Dns_RecordFree( precord );
            SetLastError( ERROR_INVALID_DATA );
            return NULL;
        }
        pip++;
        Argv++;
    }

    return( precord );
}


PDNS_RECORD
WinsrRecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    )
/*++

Routine Description:

    Build WINSR record from string data.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    PDWORD      pdword;

    if ( Argc != 4 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }

    precord = Dns_AllocateRecord( sizeof(DNS_WINSR_DATA) );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  read integer data
    //
    //  DCR_ENHANCE:  could check for non-conversion in strtoul
    //

    pdword = &precord->Data.WINSR.dwMappingFlag;

    while( Argc-- > 1 )
    {
        *pdword = (WORD) strtoul( Argv[0], NULL, 10 );
        pdword++;
        Argv++;
    }

    //
    //  result domain
    //

    precord->Data.WINSR.pNameResultDomain = Argv[0];

    return( precord );
}


PDNS_RECORD
WinsrRecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *     Argv
    )
/*++

Routine Description:

    Build WINSR record from string data.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    PDWORD      pdword;

    if ( Argc != 4 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }

    precord = Dns_AllocateRecord( sizeof(DNS_WINSR_DATA) );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  read integer data
    //
    //  DCR_ENHANCE:  could check for non-conversion in strtoul
    //

    pdword = &precord->Data.WINSR.dwMappingFlag;

    while( Argc-- > 1 )
    {
        *pdword = (WORD) wcstoul( Argv[0], NULL, 10 );
        pdword++;
        Argv++;
    }

    //
    //  result domain
    //

    precord->Data.WINSR.pNameResultDomain = (PDNS_NAME) Argv[0];

    return( precord );
}


PDNS_RECORD
WksRecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    )
/*++

Routine Description:

    Build WKS record from string data.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD         precord;
    DWORD               byteCount = 0;
    DWORD               i;
    PCHAR               pch;
    WSADATA             wsaData;
    DNS_STATUS          status;
    struct protoent *   pProtoent;


    if ( Argc < 3 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }

    i = 2;
    while ( i < Argc)
    {
        byteCount += strlen( Argv[i] ) + 1;
        i++;
    }
    byteCount++;    //bBitMasks[0] : string length

    //
    // allocate space for WKS
    //
                
    precord = Dns_AllocateRecord( (WORD)DNS_WKS_RECORD_LENGTH(byteCount) );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  get protocol number:
    //

    //  start winsock:
    //
    //  DCR:  this is busted, winsock should be started by now
    status = WSAStartup( DNS_WINSOCK_VERSION, &wsaData );
    if ( status == SOCKET_ERROR )
    {
        Dns_RecordFree( precord );
        status = WSAGetLastError();
        SetLastError( status );
        return( NULL );
    }

    pProtoent = getprotobyname( Argv[0] );

    if ( ! pProtoent || pProtoent->p_proto >= MAXUCHAR )
    {
        Dns_RecordFree( precord );
        status = WSAGetLastError();
        SetLastError( status );
        return( NULL );
    }

    precord->Data.WKS.chProtocol = (UCHAR) pProtoent->p_proto;

    //
    // get ipAddresss:
    //

    precord->Data.WKS.IpAddress = inet_addr( Argv[1] );

    //
    // get the services, put all in one string
    //

    pch = precord->Data.WKS.BitMask;

    (UCHAR) *pch = (UCHAR) byteCount-1;     //string length
    pch++;


    i = 2;
    strcpy( pch, Argv[i] );
    while ( ++i < Argc )
    {
        strcat( pch, " " );
        strcat( pch, Argv[i] );
    }

    return( precord );
}


PDNS_RECORD
WksRecordBuildW(
    IN      DWORD        Argc,
    IN      PWCHAR *     Argv
    )
/*++

Routine Description:

    Build WKS record from string data.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD         precord;
    DWORD               byteCount = 0;
    DWORD               i;
    PWCHAR              pch;
    WSADATA             wsaData;
    DNS_STATUS          status;
    struct protoent *   pProtoent;
    char                szAddr[256];
    WCHAR               tcpStr[4], udpStr[4], space[2];

    if ( Argc < 3 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }

    i = 2;
    while ( i < Argc)
    {
        byteCount += wcslen( Argv[i] ) + 1;
        i++;
    }
    byteCount++;    //bBitMasks[0] : string length

    //
    //  allocate space for WKS
    //

    precord = Dns_AllocateRecord( (WORD)DNS_WKS_RECORD_LENGTH(byteCount) );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  get protocol number
    //

    status = WSAStartup( DNS_WINSOCK_VERSION, &wsaData );
    if ( status == SOCKET_ERROR )
    {
        Dns_RecordFree( precord );
        status = WSAGetLastError();
        SetLastError( status );
        return( NULL );
    }


#if 0
    //
    //  DCR_FIX:  WKS build
    //

    if ( ! Dns_CopyStringEx( szAddr, 0, (PCHAR) Argv[0], 0, TRUE, FALSE ) )
    {
        Dns_RecordListFree( precord );
        return NULL;
    }

    pProtoent = getprotobyname( szAddr );

    if ( ! pProtoent || pProtoent->p_proto >= MAXUCHAR )
    {
        Dns_RecordFree( precord );
        status = WSAGetLastError();
        SetLastError( status );
        return( NULL );
    }

    precord->Data.WKS.chProtocol = (UCHAR) pProtoent->p_proto;

    //
    //  IP Address
    //

    if ( ! Dns_CopyStringEx( szAddr, 0, (PCHAR) Argv[0], 0, TRUE, FALSE ) )
    {
        Dns_RecordListFree( precord );
        return NULL;
    }

    precord->Data.WKS.IpAddress = inet_addr( szAddr );

    //
    //  get the services, put all in one string
    //

    pch = (PWCHAR) precord->Data.WKS.bBitMask;

    (UCHAR) *pch = (UCHAR) byteCount-1;
    pch++;

    i = 2;
    if ( ! Dns_NameCopy(
                (PBYTE) space,
                0,
                " ",
                0,
                DnsCharSetUnicode,
                DnsCharSetWire ) )
    {
        Dns_RecordListFree( precord );
        return NULL;
    }

    wcscpy( pch, Argv[i] );
    while ( ++i < Argc )
    {
        wcscat( pch, space );
        wcscat( pch, Argv[i] );
    }
#endif

    return( precord );
}



PDNS_RECORD
KeyRecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    )
/*++

Routine Description:

    Build KEY record from string data.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD     prec;
    int             keyStringLength;
    DWORD           keyLength = 0;

    if ( Argc != 4 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return NULL;
    }

    keyStringLength = strlen( Argv[ 3 ] );

    prec = Dns_AllocateRecord( ( WORD )
                sizeof( DNS_KEY_DATA ) + keyStringLength );
    if ( !prec )
    {
        return NULL;
    }

    prec->Data.KEY.wFlags = ( WORD ) strtoul( *( Argv++ ), NULL, 0 );
    prec->Data.KEY.chProtocol = ( BYTE ) strtoul( *( Argv++ ), NULL, 10 );
    prec->Data.KEY.chAlgorithm = ( BYTE ) strtoul( *( Argv++ ), NULL, 10 );
    Argc -= 3;

    Dns_SecurityBase64StringToKey(
                prec->Data.KEY.Key,
                &keyLength,
                *Argv,
                keyStringLength );
    Argc--;
    Argv++;

    prec->wDataLength = ( WORD ) ( SIZEOF_KEY_FIXED_DATA + keyLength );

    return prec;
}   //  KeyRecordBuild



PDNS_RECORD
KeyRecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    )
/*++

Routine Description:

    Build KEY record from string data.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD     prec;
    int             keyStringLength;
    DWORD           keyLength = 0;

    if ( Argc != 4 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return NULL;
    }

    keyStringLength = wcslen( Argv[ 3 ] );

    prec = Dns_AllocateRecord( ( WORD )
                sizeof( DNS_KEY_DATA ) + keyStringLength / 2 );
    if ( !prec )
    {
        return NULL;
    }

    prec->Data.KEY.wFlags = ( WORD ) wcstoul( *( Argv++ ), NULL, 0 );
    prec->Data.KEY.chProtocol = ( BYTE ) wcstoul( *( Argv++ ), NULL, 10 );
    prec->Data.KEY.chAlgorithm = ( BYTE ) wcstoul( *( Argv++ ), NULL, 10 );
    Argc -= 3;

#if 0
    //  JJW: MUST COPY BUFFER???
    Dns_SecurityBase64StringToKey(
                prec->Data.KEY.Key,
                &keyLength,
                *Argv,
                keyStringLength );
#endif
    Argc--;
    Argv++;

    prec->wDataLength = ( WORD ) ( SIZEOF_KEY_FIXED_DATA + keyLength );

    return prec;
}   //  KeyRecordBuildW



PDNS_RECORD
SigRecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    )
/*++

Routine Description:

    Build SIG record from string data.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD     prec;
    int             sigStringLength;
    DWORD           sigLength = 0;

    if ( Argc != 9 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return NULL;
    }

    sigStringLength = strlen( Argv[ 8 ] );

    prec = Dns_AllocateRecord( ( WORD )
                ( sizeof( DNS_SIG_DATA ) + sigStringLength ) );
    if ( !prec )
    {
        return NULL;
    }

    prec->Data.SIG.wTypeCovered = Dns_RecordTypeForName( *( Argv++ ), 0 );
    prec->Data.SIG.chAlgorithm = ( BYTE ) strtoul( *( Argv++ ), NULL, 10 );
    prec->Data.Sig.chLabelCount = ( BYTE ) strtoul( *( Argv++ ), NULL, 10 );
    prec->Data.SIG.dwOriginalTtl = ( DWORD ) strtoul( *( Argv++ ), NULL, 10 );
    prec->Data.SIG.dwExpiration = Dns_ParseSigTime( *( Argv++ ), 0 );
    prec->Data.SIG.dwTimeSigned = Dns_ParseSigTime( *( Argv++ ), 0 );
    prec->Data.SIG.wKeyTag = ( WORD ) strtoul( *( Argv++ ), NULL, 10 );
    prec->Data.SIG.pNameSigner = *( Argv++ );

    Argc -= 8;

    //
    //  Validate signature times.
    //

    if ( prec->Data.SIG.dwExpiration == 0 ||
        prec->Data.SIG.dwTimeSigned == 0 ||
        prec->Data.SIG.dwTimeSigned >= prec->Data.SIG.dwExpiration )
    {
        Dns_RecordFree( prec );
        SetLastError( ERROR_INVALID_DATA );
        return NULL;
    }

    //
    //  Parse signature.
    //

    if ( Dns_SecurityBase64StringToKey(
                prec->Data.SIG.Signature,
                &sigLength,
                *Argv,
                sigStringLength ) != ERROR_SUCCESS )
    {
        Dns_RecordFree( prec );
        SetLastError( ERROR_INVALID_DATA );
        return NULL;
    }

    Argc--;
    Argv++;

    prec->wDataLength = ( WORD ) ( sizeof( DNS_SIG_DATA ) - 4 + sigLength );

    return prec;
} // SigRecordBuild



PDNS_RECORD
SigRecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    )
/*++

Routine Description:

    Build SIG record from string data.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD     prec;
    int             sigStringLength;
    DWORD           sigLength = 0;
    PCHAR           pch;

    if ( Argc != 8 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return NULL;
    }

    sigStringLength = wcslen( Argv[ 7 ] );

    prec = Dns_AllocateRecord( ( WORD )
                ( sizeof( DNS_SIG_DATA ) + sigStringLength ) );
    if ( !prec )
    {
        return NULL;
    }

#if 0
    //  JJW: how to convert all args here???
    prec->Data.SIG.wTypeCovered = Dns_RecordTypeForName( *( Argv++ ), 0 );
    prec->Data.SIG.chAlgorithm = ( BYTE ) strtoul( *( Argv++ ), NULL, 10 );
    prec->Data.Sig.chLabelCount = ( BYTE ) strtoul( *( Argv++ ), NULL, 10 );
    prec->Data.SIG.dwOriginalTtl = ( DWORD ) strtoul( *( Argv++ ), NULL, 10 );
    prec->Data.SIG.dwExpiration = Dns_ParseSigTime( *( Argv++ ), 0 );
    prec->Data.SIG.dwTimeSigned = Dns_ParseSigTime( *( Argv++ ), 0 );
    prec->Data.SIG.wKeyTag = ( WORD ) strtoul( *( Argv++ ), NULL, 10 );
    prec->Data.SIG.pNameSigner = *( Argv++ );

    Argc -= 8;

    Dns_SecurityBase64StringToKey(
                prec->Data.SIG.Signature,
                &sigLength,
                *Argv,
                sigStringLength );
#endif
    Argc--;
    Argv++;

    prec->wDataLength = ( WORD ) ( sizeof( DNS_SIG_DATA ) - 4 + sigLength );

    return prec;
} // SigRecordBuildW



PDNS_RECORD
NxtRecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    )
/*++

Routine Description:

    Build NXT record from string data.

    First arg is next name, followed by list of record types at that name.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD     prec;
    int             typeIdx = 0;

    if ( Argc < 2 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return NULL;
    }
    prec = Dns_AllocateRecord( ( WORD ) (
                sizeof( LPTSTR ) + sizeof( WORD ) * Argc ) );
    if ( !prec )
    {
        return NULL;
    }

    prec->Data.NXT.pNameNext = *( Argv++ );
    --Argc;

    prec->Data.NXT.wNumTypes = 0;
    while ( Argc-- )
    {
        ++prec->Data.NXT.wNumTypes;
        prec->Data.NXT.wTypes[ typeIdx++ ] =
            Dns_RecordTypeForName( *( Argv++ ), 0 );
    }

    return prec;
} // NxtRecordBuild



PDNS_RECORD
NxtRecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    )
/*++

Routine Description:

    Build NXT record from string data.

    First arg is next name, followed by list of record types at that name.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD     prec;
    int             typeIdx = 0;

    if ( Argc < 2 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return NULL;
    }
    prec = Dns_AllocateRecord( ( WORD ) (
                sizeof( LPTSTR ) + sizeof( WORD ) * ( Argc - 1 ) ) );
    if ( !prec )
    {
        return NULL;
    }

    prec->Data.NXT.pNameNext = ( PDNS_NAME ) ( *( Argv++ ) );
    --Argc;

#if 0
    //  JJW: convert type string???
    while ( Argc-- )
    {
        prec->Data.NXT.wTypes[ typeIdx++ ] =
            Dns_RecordTypeForName( *( Argv++ ), 0 );
    }
#endif

    return prec;
} // NxtRecordBuildW



//
//  Public build routine
//

PDNS_RECORD
Dns_RecordBuild_A(
    IN OUT  PDNS_RRSET  pRRSet,
    IN      LPSTR       pszOwner,
    IN      WORD        wType,
    IN      BOOL        fAdd,
    IN      UCHAR       Section,
    IN      INT         Argc,
    IN      PCHAR *     Argv
    )
/*++

Routine Description:

    Build record from data strings.

Arguments:

    pRRSet -- ptr to RR set structure being built

    pszOwner -- DNS name of RR owner

    wType -- record type

    fAdd -- add\delete, exist\no-exist flag

    Section -- RR section for record

    Argc -- count of data strings

    Argv -- argv array of ptrs to data strings

Return Value:

    Ptr to record built.
    NULL on error.

--*/
{
    PDNS_RECORD precord;
    WORD        index;

    IF_DNSDBG( INIT )
    {
        DNS_PRINT((
            "Dns_RecordBuild()\n"
            "\trrset    = %p\n"
            "\towner    = %s\n"
            "\ttype     = %d\n"
            "\tfAdd     = %d\n"
            "\tsection  = %d\n"
            "\targc     = %d\n",
            pRRSet,
            pszOwner,
            wType,
            fAdd,
            Section,
            Argc ));
    }

    //
    //  every record MUST have owner name
    //

    if ( !pszOwner )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }

    //
    //  if no data, no dispatch required
    //

    if ( Argc == 0 )
    {
        precord = Dns_AllocateRecord( 0 );
        if ( ! precord )
        {
            return( NULL );
        }
    }

    //  have data, dispatch to type specific build routine

    else
    {
        index = INDEX_FOR_TYPE( wType );
        DNS_ASSERT( index <= MAX_RECORD_TYPE_INDEX );

        if ( !index || !RRBuildTable[ index ] )
        {
            //  can NOT build unknown types

            SetLastError( DNS_ERROR_INVALID_TYPE );
            DNS_PRINT((
                "ERROR:  can not build record of type %d\n",
                wType ));
            return( NULL );
        }

        precord = RRBuildTable[ index ](
                        Argc,
                        Argv );
        if ( ! precord )
        {
            DNS_PRINT((
                "ERROR:  Record build routine failure for record type %d.\n"
                "\tstatus = %d\n\n",
                wType,
                GetLastError() ));
            if ( !GetLastError() )
            {
                SetLastError( ERROR_INVALID_DATA );
            }
            return( NULL );
        }
    }

    //
    //  fill out record structure
    //

    precord->pName = pszOwner;
    precord->wType = wType;
    precord->Flags.S.Section = Section;
    precord->Flags.S.Delete = !fAdd;
    precord->Flags.S.CharSet = DnsCharSetAnsi;

    IF_DNSDBG( INIT )
    {
        DnsDbg_Record(
            "New record built\n",
            precord );
    }

    //
    //  link into existing RR set (if any)
    //

    if ( pRRSet )
    {
        DNS_RRSET_ADD( *pRRSet, precord );
    }
    return( precord );
}



PDNS_RECORD
Dns_RecordBuild_W(
    IN OUT  PDNS_RRSET  pRRSet,
    IN      LPWSTR      pszOwner,
    IN      WORD        wType,
    IN      BOOL        fAdd,
    IN      UCHAR       Section,
    IN      INT         Argc,
    IN      PWCHAR *    Argv
    )
/*++

Routine Description:

    Build record from data strings.

Arguments:

    pRRSet -- ptr to RR set structure being built

    pszOwner -- DNS name of RR owner

    wType -- record type

    fAdd -- add\delete, exist\no-exist flag

    Section -- RR section for record

    Argc -- count of data strings

    Argv -- argv array of ptrs to data strings

Return Value:

    Ptr to record built.
    NULL on error.

--*/
{
    PDNS_RECORD precord;
    WORD        index;

    DNSDBG( INIT, (
        "Dns_RecordBuild()\n"
        "\trrset    = %p\n"
        "\towner    = %S\n"
        "\ttype     = %d\n"
        "\tfAdd     = %d\n"
        "\tsection  = %d\n"
        "\targc     = %d\n",
        pRRSet,
        pszOwner,
        wType,
        fAdd,
        Section,
        Argc ));

    //
    //  every record MUST have owner name
    //

    if ( !pszOwner )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }

    //
    //  if no data, no dispatch required
    //

    if ( Argc == 0 )
    {
        precord = Dns_AllocateRecord( 0 );
        if ( ! precord )
        {
            return( NULL );
        }
    }

    //  have data, dispatch to type specific build routine

    else
    {
        index = INDEX_FOR_TYPE( wType );
        DNS_ASSERT( index <= MAX_RECORD_TYPE_INDEX );

        if ( !index || !RRBuildTableW[ index ] )
        {
            //  can NOT build unknown types

            SetLastError( DNS_ERROR_INVALID_TYPE );
            DNS_PRINT((
                "ERROR:  can not build record of type %d\n",
                wType ));
            return( NULL );
        }

        precord = RRBuildTableW[ index ](
                        Argc,
                        Argv );
        if ( ! precord )
        {
            DNS_PRINT((
                "ERROR:  Record build routine failure for record type %d.\n"
                "\tstatus = %d\n\n",
                wType,
                GetLastError() ));

            if ( !GetLastError() )
            {
                SetLastError( ERROR_INVALID_DATA );
            }
            return( NULL );
        }
    }

    //
    //  fill out record structure
    //

    precord->pName = (PDNS_NAME) pszOwner;
    precord->wType = wType;
    precord->Flags.S.Section = Section;
    precord->Flags.S.Delete = !fAdd;
    precord->Flags.S.CharSet = DnsCharSetUnicode;

    IF_DNSDBG( INIT )
    {
        DnsDbg_Record(
            "New record built\n",
            precord );
    }

    //
    //  link into existing RR set (if any)
    //

    if ( pRRSet )
    {
        DNS_RRSET_ADD( *pRRSet, precord );
    }
    return( precord );
}


//
//  End rrbuild.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\rrcomp.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    rrcomp.c

Abstract:

    Domain Name System (DNS) Library

    Compare resource record routines.

Author:

    Jim Gilroy (jamesg)     February, 1997

Revision History:

--*/


#include "local.h"
#include "locale.h"     // for setlocale stuff for Win9x



//
//  Type specific RR compare routine prototypes
//

BOOL
ARecordCompare(
    IN  PDNS_RECORD     pRR1,
    IN  PDNS_RECORD     pRR2
    )
/*++

Routine Description:

    Compare A records.

    All these routines assume:
        - type compare complete
        - datalength compare completed
        - NO unicode

Arguments:

    pRR1 - first record

    pRR2 -- second record

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    return( pRR1->Data.A.IpAddress == pRR2->Data.A.IpAddress );
}



BOOL
PtrRecordCompare(
    IN  PDNS_RECORD     pRR1,
    IN  PDNS_RECORD     pRR2
    )
/*++

Routine Description:

    Compare PTR compatible record.
    Includes: NS, PTR, CNAME, MB, MR, MG, MD, MF

Arguments:

    pRR1 - first record

    pRR2 -- second record

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    return Dns_NameComparePrivate(
                (LPSTR) pRR1->Data.PTR.pNameHost,
                (LPSTR) pRR2->Data.PTR.pNameHost,
                RECORD_CHARSET(pRR1) );
}



BOOL
MxRecordCompare(
    IN  PDNS_RECORD     pRR1,
    IN  PDNS_RECORD     pRR2
    )
/*++

Routine Description:

    Compare MX compatible record.
    Includes: MX, RT, AFSDB

Arguments:

    pRR1 - first record

    pRR2 -- second record

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    //  verify preference match first

    if ( pRR1->Data.MX.wPreference != pRR2->Data.MX.wPreference )
    {
        return( FALSE );
    }

    //  then result is name comparison

    return Dns_NameComparePrivate(
                (LPSTR) pRR1->Data.MX.pNameExchange,
                (LPSTR) pRR2->Data.MX.pNameExchange,
                RECORD_CHARSET(pRR1) );
}



BOOL
SoaRecordCompare(
    IN  PDNS_RECORD     pRR1,
    IN  PDNS_RECORD     pRR2
    )
/*++

Routine Description:

    Compare SOA record.

Arguments:

    pRR1 - first record

    pRR2 -- second record

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    //  verify integer data match first

    if ( memcmp( & pRR1->Data.SOA.dwSerialNo,
                 & pRR2->Data.SOA.dwSerialNo,
                 SIZEOF_SOA_FIXED_DATA ) )
    {
        return( FALSE );
    }

    //  match check names
    //      - primary name server
    //      - admin email name

    if ( ! Dns_NameComparePrivate(
                (LPSTR) pRR1->Data.SOA.pNamePrimaryServer,
                (LPSTR) pRR2->Data.SOA.pNamePrimaryServer,
                RECORD_CHARSET(pRR1) ) )
    {
        return( FALSE );
    }

    return Dns_NameComparePrivate(
                (LPSTR) pRR1->Data.SOA.pNameAdministrator,
                (LPSTR) pRR2->Data.SOA.pNameAdministrator,
                RECORD_CHARSET(pRR1) );
}



BOOL
MinfoRecordCompare(
    IN  PDNS_RECORD     pRR1,
    IN  PDNS_RECORD     pRR2
    )
/*++

Routine Description:

    Compare MINFO and RP records.

Arguments:

    pRR1 -- first record

    pRR2 -- second record

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    if ( ! Dns_NameComparePrivate(
                (LPSTR) pRR1->Data.MINFO.pNameMailbox,
                (LPSTR) pRR2->Data.MINFO.pNameMailbox,
                RECORD_CHARSET(pRR1) ) )
    {
        return( FALSE );
    }

    return Dns_NameComparePrivate(
                (LPSTR) pRR1->Data.MINFO.pNameErrorsMailbox,
                (LPSTR) pRR2->Data.MINFO.pNameErrorsMailbox,
                RECORD_CHARSET(pRR1) );
}



BOOL
TxtRecordCompare(
    IN  PDNS_RECORD     pRR1,
    IN  PDNS_RECORD     pRR2
    )
/*++

Routine Description:

    Compare TXT compatible records.
    Includes: TXT, X25, HINFO, ISDN

Arguments:

    pRR1 -- first record

    pRR2 -- second record

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    DWORD   count;
    PCHAR * pstring1;
    PCHAR * pstring2;

    //
    //  compare every string
    //  since string order DOES matter
    //      - find string count
    //      - compare each (case-sensitive)
    //

    count = pRR1->Data.TXT.dwStringCount;
    if ( count != pRR2->Data.TXT.dwStringCount )
    {
        return( FALSE );
    }

    pstring1 = (PCHAR *) pRR1->Data.TXT.pStringArray;
    pstring2 = (PCHAR *) pRR2->Data.TXT.pStringArray;

    while ( count-- )
    {
        if ( IS_UNICODE_RECORD(pRR1) )
        {
            if ( wcscmp( (LPWSTR)*pstring1++, (LPWSTR)*pstring2++ ) != 0 )
            {
                return( FALSE );
            }
        }
        else
        {
            if ( strcmp( *pstring1++, *pstring2++ ) != 0 )
            {
                return( FALSE );
            }
        }
    }
    return( TRUE );
}



BOOL
FlatRecordCompare(
    IN  PDNS_RECORD     pRR1,
    IN  PDNS_RECORD     pRR2
    )
/*++

Routine Description:

    Compare flat data records.
    Includes AAAA type.

Arguments:

    pRR1 -- first record

    pRR2 -- second record

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    if ( pRR1->wDataLength != pRR2->wDataLength )
    {
        return( FALSE );
    }
    return( !memcmp( & pRR1->Data,
                     & pRR2->Data,
                     pRR1->wDataLength ) );
}



BOOL
SrvRecordCompare(
    IN  PDNS_RECORD     pRR1,
    IN  PDNS_RECORD     pRR2
    )
/*++

Routine Description:

    Compare SRV record.

Arguments:

    pRR1 -- first record

    pRR2 -- second record

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    //  verify integer data match first

    if ( memcmp( & pRR1->Data.SRV.wPriority,
                 & pRR2->Data.SRV.wPriority,
                 SIZEOF_SRV_FIXED_DATA ) )
    {
        return( FALSE );
    }

    //  then result is compare on target host

    return Dns_NameComparePrivate(
                (LPSTR) pRR1->Data.SRV.pNameTarget,
                (LPSTR) pRR2->Data.SRV.pNameTarget,
                RECORD_CHARSET(pRR1) );
}



BOOL
AtmaRecordCompare(
    IN  PDNS_RECORD     pRR1,
    IN  PDNS_RECORD     pRR2
    )
/*++

Routine Description:

    Compare ATMA record.

Arguments:

    pRR1 -- first record

    pRR2 -- second record

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    WORD length = pRR1->wDataLength;

    if ( length > pRR2->wDataLength )
    {
        length = pRR2->wDataLength;
    }

    //  verify integer data match first

    if ( pRR1->Data.ATMA.AddressType != pRR2->Data.ATMA.AddressType )
    {
        return( FALSE );
    }

    if ( memcmp(
            pRR1->Data.ATMA.Address,
            pRR2->Data.ATMA.Address,
            length ) != 0 )
    {
        return( FALSE );
    }

    return( TRUE );
}



//
//  RR compare routines jump table
//

RR_COMPARE_FUNCTION   RRCompareTable[] =
{
    NULL,               //  ZERO
    ARecordCompare,     //  A
    PtrRecordCompare,   //  NS
    PtrRecordCompare,   //  MD
    PtrRecordCompare,   //  MF
    PtrRecordCompare,   //  CNAME
    SoaRecordCompare,   //  SOA
    PtrRecordCompare,   //  MB
    PtrRecordCompare,   //  MG
    PtrRecordCompare,   //  MR
    NULL,               //  NULL
    NULL,   //WksRecordCompare,     //  WKS
    PtrRecordCompare,   //  PTR
    TxtRecordCompare,   //  HINFO
    MinfoRecordCompare, //  MINFO
    MxRecordCompare,    //  MX
    TxtRecordCompare,   //  TXT
    MinfoRecordCompare, //  RP
    MxRecordCompare,    //  AFSDB
    TxtRecordCompare,   //  X25
    TxtRecordCompare,   //  ISDN
    MxRecordCompare,    //  RT
    NULL,               //  NSAP
    NULL,               //  NSAPPTR
    NULL,               //  SIG
    NULL,               //  KEY
    NULL,               //  PX
    NULL,               //  GPOS
    FlatRecordCompare,  //  AAAA
    NULL,               //  LOC
    NULL,               //  NXT
    NULL,               //  EID   
    NULL,               //  NIMLOC
    SrvRecordCompare,   //  SRV   
    AtmaRecordCompare,  //  ATMA  
    NULL,               //  NAPTR 
    NULL,               //  KX    
    NULL,               //  CERT  
    NULL,               //  A6    
    NULL,               //  DNAME 
    NULL,               //  SINK  
    NULL,               //  OPT   
    NULL,               //  42
    NULL,               //  43
    NULL,               //  44
    NULL,               //  45
    NULL,               //  46
    NULL,               //  47
    NULL,               //  48

    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as MAX_SELF_INDEXED_TYPE #define in record.h
    //         (see note above in record info table)

    //
    //  Pseudo record types
    //

    NULL,               //  TKEY
    NULL,               //  TSIG

    //
    //  MS only types
    //

    FlatRecordCompare,  //  WINS
    NULL,               //  WINSR
};



BOOL
WINAPI
Dns_RecordCompare(
    IN      PDNS_RECORD     pRecord1,
    IN      PDNS_RECORD     pRecord2
    )
/*++

Routine Description:

    Compare two records.

    Record compare ignores TTL and flags and section information.

Arguments:

    pRecord1 -- first record

    pRecord2 -- second record

Return Value:

    TRUE if records equal.
    FALSE otherwise.

--*/
{
    BOOL    fresult;
    WORD    type = pRecord1->wType;
    WORD    index;

    IF_DNSDBG( UPDATE )
    {
        DNS_PRINT((
            "Dns_RecordCompare()\n"
            "\tfirst    = %p\n"
            "\tfirst    = %p\n",
            pRecord1,
            pRecord2 ));
    }

    //
    //  verify that both records have same character set
    //

    if ( RECORD_CHARSET(pRecord1) != RECORD_CHARSET(pRecord2) )
    {
        DNS_PRINT(( "ERROR:  comparing records with non-matching character sets!\n" ));

        //
        // If they are different and one of them is undefined, just use
        // the defined char set of the other for each.
        //

        if ( !RECORD_CHARSET(pRecord1) && RECORD_CHARSET(pRecord2) )
        {
            RECORD_CHARSET(pRecord1) = RECORD_CHARSET(pRecord2);
        }

        if ( !RECORD_CHARSET(pRecord2) && RECORD_CHARSET(pRecord1) )
        {
            RECORD_CHARSET(pRecord2) = RECORD_CHARSET(pRecord1);
        }
    }

    //
    //  compare type
    //

    if ( type != pRecord2->wType )
    {
        DNSDBG( UPDATE, (
            "record compare failed -- type mismatch\n" ));
        return( FALSE );
    }

    //
    //  compare names
    //

    if ( ! Dns_NameComparePrivate(
                pRecord1->pName,
                pRecord2->pName,
                RECORD_CHARSET( pRecord1 )
                ) )
    {
        DNSDBG( UPDATE, (
            "record compare failed -- owner name mismatch\n" ));
        return( FALSE );
    }

    //
    //  compare data
    //

    index = INDEX_FOR_TYPE( type );
    DNS_ASSERT( index <= MAX_RECORD_TYPE_INDEX );

    if ( !index || !RRCompareTable[ index ] )
    {
        fresult = FlatRecordCompare( pRecord1, pRecord2 );
    }
    else
    {
        fresult = RRCompareTable[ index ](
                    pRecord1,
                    pRecord2 );
    }

    IF_DNSDBG( UPDATE )
    {
        DNS_PRINT((
            "Dns_RecordCompare(%p, %p) returns = %d.\n",
            pRecord1,
            pRecord2,
            fresult ));
    }
    return( fresult );
}



DNS_STATUS
buildUnmatchedRecordSet(
    OUT     PDNS_RECORD *   ppDiffRR,
    IN OUT  PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Build new list of difference records.

Arguments:

    ppDiffRR - address to recieve PTR to new set

    pRR - incoming RR set;  matched records marked wReserved TRUE

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PDNS_RECORD pcur;
    PDNS_RECORD pnew;
    DNS_RRSET   rrset;

    //  init comparison rrset

    DNS_RRSET_INIT( rrset );

    //
    //  loop through RR set, add records to either match or diff sets
    //

    pcur = pRR;

    while ( pcur )
    {
        if ( ! IS_RR_MATCHED(pcur) )
        {
            //  make copy of record

            pnew = Dns_RecordCopyEx(
                        pcur,
                        RECORD_CHARSET(pcur),
                        RECORD_CHARSET(pcur)
                        );
            if ( !pnew )
            {
                //  DCR_FIX1:  last error not set on all Dns_RecordCopy() failures
                //      Charlie Wickham was getting some random win32 error
                //
                //  DNS_STATUS status = GetLastError();

                //  assume unable to copy because of invalid data

                DNS_PRINT((
                    "ERROR:  unable to copy record at %p\n"
                    "\thence unable to build diff of set at %p\n",
                    pcur,
                    pRR ));
                Dns_RecordListFree( rrset.pFirstRR );
                *ppDiffRR = NULL;

                //return( status ? status : ERROR_INVALID_DATA );
                return( ERROR_INVALID_DATA );
            }
            DNS_RRSET_ADD( rrset, pnew );
        }
        pcur = pcur->pNext;
    }

    *ppDiffRR = rrset.pFirstRR;
    return( ERROR_SUCCESS );
}



DWORD
isUnmatchedRecordInSet(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Check if unmatched record in set.

Arguments:

    pRR - incoming RR set;  matched records marked wReserved TRUE

Return Value:

    Count of all unmatched records in set.
    Zero if all records matched.

--*/
{
    PDNS_RECORD pcur;
    DWORD       countUnmatched = 0;

    //
    //  loop through RR set check for unmatched records
    //

    pcur = pRR;

    while ( pcur )
    {
        if ( ! IS_RR_MATCHED(pcur) )
        {
            countUnmatched++;
        }
        pcur = pcur->pNext;
    }

    return( countUnmatched );
}



DNS_SET_COMPARE_RESULT
WINAPI
Dns_RecordSetCompareEx(
    IN OUT  PDNS_RECORD     pRR1,
    IN OUT  PDNS_RECORD     pRR2,
    OUT     PDNS_RECORD *   ppDiff1,    OPTIONAL
    OUT     PDNS_RECORD *   ppDiff2     OPTIONAL
    )
/*++

Routine Description:

    Compare two records.

    Record compare ignores TTL and flags and section information.

Arguments:

    pRR1 - first incoming RR set
    pRR2 - second incoming RR set

    ppDiff1 - addr to receive ptr to unmatched records from first set
    ppDiff2 - addr to receive ptr to unmatched records from second set

Return Value:

    Result indicating relationship -- or error on allocation error:
        DnsSetCompareError
        DnsSetCompareIdentical
        DnsSetCompareNoOverlap
        DnsSetCompareOneSubsetOfTwo
        DnsSetCompareTwoSubsetOfOne
        DnsSetCompareIntersection

--*/
{
    PDNS_RECORD pcur1;
    PDNS_RECORD pcur2;
    DWORD       count1 = 0;
    DWORD       count2 = 0;
    DNS_STATUS  status;
    DWORD       unmatched1;
    DWORD       unmatched2;
    DNS_SET_COMPARE_RESULT result;

    //
    //  init RR sets for compare
    //      - clear reserved field used as matched flag in compare
    //

    pcur1 = pRR1;
    while ( pcur1 )
    {
        CLEAR_RR_MATCHED(pcur1);
        pcur1 = pcur1->pNext;
        count1++;
    }
    pcur1 = pRR2;
    while ( pcur1 )
    {
        CLEAR_RR_MATCHED(pcur1);
        pcur1 = pcur1->pNext;
        count2++;
    }

    //
    //  loop through set 1
    //  attempt match of each record to all records in set 2
    //      except those already matched

    pcur1 = pRR1;

    while ( pcur1 )
    {
        pcur2 = pRR2;
        while ( pcur2 )
        {
            if ( !IS_RR_MATCHED(pcur2)  &&  Dns_RecordCompare( pcur1, pcur2 ) )
            {
                SET_RR_MATCHED(pcur1);
                SET_RR_MATCHED(pcur2);
            }
            pcur2 = pcur2->pNext;
        }
        pcur1 = pcur1->pNext;
    }

    //
    //  get diff record lists, return
    //      - if no diffs, then have match
    //
    //  tedious, but do all this error handling because it is easy for
    //  user to pass in bad records that may fail copy routines, need
    //  way to easily report info, even if only for debugging apps calling in
    //

    if ( ppDiff1 )
    {
        status = buildUnmatchedRecordSet( ppDiff1, pRR1 );
        if ( status != ERROR_SUCCESS )
        {
            goto Failed;
        }
    }
    if ( ppDiff2 )
    {
        status = buildUnmatchedRecordSet( ppDiff2, pRR2 );
        if ( status != ERROR_SUCCESS )
        {
            if ( ppDiff1 && *ppDiff1 )
            {
                Dns_RecordListFree( *ppDiff1 );
            }
            goto Failed;
        }
    }

    //
    //  determine relationship between sets
    //
    //  impl note:  the only better way i could see doing this
    //  is to map relationships directly to bit flags
    //  however, our enum type doesn't map to bit flags, so
    //  then would have to run mapping table to map flags to enum
    //
    //  note, we do compare so that NULL lists comes out the first
    //  as no-overlap rather than as subset
    //

    unmatched1 = isUnmatchedRecordInSet( pRR1 );
    unmatched2 = isUnmatchedRecordInSet( pRR2 );

    if ( unmatched1 == count1 )
    {
        ASSERT( unmatched2 == count2 );
        result = DnsSetCompareNoOverlap;
    }
    else if ( unmatched1 == 0 )
    {
        if ( unmatched2 == 0 )
        {
            result = DnsSetCompareIdentical;
        }
        else
        {
            ASSERT( unmatched2 != count2 );
            result = DnsSetCompareOneSubsetOfTwo;
        }
    }
    else if ( unmatched2 == 0 )
    {
        result = DnsSetCompareTwoSubsetOfOne;
    }
    else
    {
        ASSERT( unmatched2 != count2 );
        result = DnsSetCompareIntersection;
    }
    return( result );


Failed:

    *ppDiff1 = *ppDiff2 = NULL;
    SetLastError( status );
    return( DnsSetCompareError );
}



BOOL
WINAPI
Dns_RecordSetCompare(
    IN OUT  PDNS_RECORD     pRR1,
    IN OUT  PDNS_RECORD     pRR2,
    OUT     PDNS_RECORD *   ppDiff1,    OPTIONAL
    OUT     PDNS_RECORD *   ppDiff2     OPTIONAL
    )
/*++

Routine Description:

    Compare two records.

    Record compare ignores TTL and flags and section information.

Arguments:

    pRR1 - first incoming RR set
    pRR2 - second incoming RR set

    ppDiff1 - addr to receive ptr to unmatched records from first set
    ppDiff2 - addr to receive ptr to unmatched records from second set

Return Value:

    TRUE if record sets equal.
    FALSE otherwise.

--*/
{
    DNS_SET_COMPARE_RESULT result;

    result = Dns_RecordSetCompareEx(
                    pRR1,
                    pRR2,
                    ppDiff1,
                    ppDiff2 );

    return( result == DnsSetCompareIdentical );
}



BOOL
WINAPI
Dns_RecordSetCompareForIntersection(
    IN OUT  PDNS_RECORD     pRR1,
    IN OUT  PDNS_RECORD     pRR2
    )
/*++

Routine Description:

    Compare two record sets for intersection.

Arguments:

    pRR1 - first incoming RR set
    pRR2 - second incoming RR set

Return Value:

    TRUE if record sets intersect.
    FALSE otherwise.

--*/
{
    DNS_SET_COMPARE_RESULT result;

    result = Dns_RecordSetCompareEx(
                    pRR1,
                    pRR2,
                    NULL,
                    NULL );

    return( result == DnsSetCompareIdentical ||
            result == DnsSetCompareIntersection ||
            result == DnsSetCompareOneSubsetOfTwo ||
            result == DnsSetCompareTwoSubsetOfOne );
}

//
//  End rrcomp.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\rrprint.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    rrprint.c

Abstract:

    Domain Name System (DNS) Library

    Print resource record routines.

Author:

    Jim Gilroy (jamesg)     February, 1997

Revision History:

--*/


#include "local.h"

//
//  Private prototypes
//

VOID
printBadDataLength(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PDNS_RECORD     pRecord
    );



VOID
ARecordPrint(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Print A records.

Arguments:

    PrintRoutine -- routine to print with

    pRecord -- record to print

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    WORD    dataLength = pRecord->wDataLength;

    if ( dataLength == sizeof(IP_ADDRESS) )
    {
        PrintRoutine(
            pContext,
            "\tIP address     = %s\n",
            IP_STRING(pRecord->Data.A.IpAddress) );
    }
    else if ( dataLength % sizeof(DNS_A_DATA) )
    {
        printBadDataLength( PrintRoutine, pContext, pRecord );
    }
    else    // multiple records
    {
        PIP_ADDRESS pip = &pRecord->Data.A.IpAddress;
        DnsPrint_Lock();
        while ( dataLength )
        {
            PrintRoutine(
                pContext,
                "\tIP address     = %s\n",
                IP_STRING(*pip) );
            dataLength -= sizeof(IP_ADDRESS);
            pip++;
        }
        DnsPrint_Unlock();
    }
}



VOID
PtrRecordPrint(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Print PTR compatible record.
    Includes: NS, PTR, CNAME, MB, MR, MG, MD, MF

Arguments:

    PrintRoutine -- routine to print with

    pRecord -- record to print

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    PrintRoutine(
        pContext,
        "\tHostName       = %s%S\n",
        RECSTRING_UTF8( pRecord, pRecord->Data.PTR.pNameHost ),
        RECSTRING_WIDE( pRecord, pRecord->Data.PTR.pNameHost )
        );
}



VOID
MxRecordPrint(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Print MX compatible record.
    Includes: MX, RT, AFSDB

Arguments:

    PrintRoutine -- routine to print with

    pRecord -- record to print

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    PrintRoutine(
        pContext,
        "\tPreference     = %d\n"
        "\tExchange       = %s%S\n",
        pRecord->Data.MX.wPreference,
        RECSTRING_UTF8( pRecord, pRecord->Data.MX.pNameExchange ),
        RECSTRING_WIDE( pRecord, pRecord->Data.MX.pNameExchange )
        );
}



VOID
SoaRecordPrint(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Print SOA record.

Arguments:

    PrintRoutine -- routine to print with

    pRecord -- record to print

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    PrintRoutine(
        pContext,
        "\tPrimary        = %s%S\n"
        "\tAdmin          = %s%S\n"
        "\tSerial         = %d\n"
        "\tRefresh        = %d\n"
        "\tRetry          = %d\n"
        "\tExpire         = %d\n"
        "\tDefault TTL    = %d\n",
        RECSTRING_UTF8( pRecord, pRecord->Data.SOA.pNamePrimaryServer ),
        RECSTRING_WIDE( pRecord, pRecord->Data.SOA.pNamePrimaryServer ),
        RECSTRING_UTF8( pRecord, pRecord->Data.SOA.pNameAdministrator ),
        RECSTRING_WIDE( pRecord, pRecord->Data.SOA.pNameAdministrator ),
        pRecord->Data.SOA.dwSerialNo,
        pRecord->Data.SOA.dwRefresh,
        pRecord->Data.SOA.dwRetry,
        pRecord->Data.SOA.dwExpire,
        pRecord->Data.SOA.dwDefaultTtl );
}



VOID
MinfoRecordPrint(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Print MINFO and RP records.

Arguments:

    PrintRoutine -- routine to print with

    pRecord -- record to print

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    PrintRoutine(
        pContext,
        "\tMailbox        = %s%S\n"
        "\tErrorsMbox     = %s%S\n",
        RECSTRING_UTF8( pRecord, pRecord->Data.MINFO.pNameMailbox ),
        RECSTRING_WIDE( pRecord, pRecord->Data.MINFO.pNameMailbox ),
        RECSTRING_UTF8( pRecord, pRecord->Data.MINFO.pNameErrorsMailbox ),
        RECSTRING_WIDE( pRecord, pRecord->Data.MINFO.pNameErrorsMailbox )
        );
}



VOID
TxtRecordPrint(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Print TXT compatible records.
    Includes: TXT, X25, HINFO, ISDN

Arguments:

    PrintRoutine -- routine to print with

    pRecord -- record to print

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    LPTSTR * ppstring;
    INT     i;
    INT     count;

    count = pRecord->Data.TXT.dwStringCount;
    ppstring = pRecord->Data.TXT.pStringArray;

    DnsPrint_Lock();
    PrintRoutine(
        pContext,
        "\tStringCount    = %d\n",
        count );

    for( i=1; i<=count; i++ )
    {
        PrintRoutine(
            pContext,
            "\tString[%d]      = %s%S\n",
            i,
            RECSTRING_UTF8( pRecord, *ppstring ),
            RECSTRING_WIDE( pRecord, *ppstring )
            );
        ppstring++;
    }
    DnsPrint_Unlock();
}



VOID
AaaaRecordPrint(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Print flat data records.
    Includes AAAA type.

Arguments:

    PrintRoutine -- routine to print with

    pRecord -- record to print

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    CHAR    ip6String[ IP6_ADDRESS_STRING_LENGTH ];

    Dns_Ip6AddressToString_A(
        ip6String,
        (PDNS_IP6_ADDRESS) &pRecord->Data.AAAA.Ip6Address );

    PrintRoutine(
        pContext,
        "\tIP6 Address    = %s\n",
        ip6String );
}



VOID
SrvRecordPrint(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Print SRV record.

Arguments:

    PrintRoutine -- routine to print with

    pRecord -- record to print

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    PrintRoutine(
        pContext,
        "\tPriority       = %d\n"
        "\tWeight         = %d\n"
        "\tPort           = %d\n"
        "\tTarget Host    = %s%S\n",
        pRecord->Data.SRV.wPriority,
        pRecord->Data.SRV.wWeight,
        pRecord->Data.SRV.wPort,
        RECSTRING_UTF8( pRecord, pRecord->Data.SRV.pNameTarget ),
        RECSTRING_WIDE( pRecord, pRecord->Data.SRV.pNameTarget )
        );
}



VOID
AtmaRecordPrint(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Print ATMA record.

Arguments:

    PrintRoutine -- routine to print with

    pRecord -- record to print

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    PrintRoutine(
        pContext,
        "\tAddress type   = %d\n",
        pRecord->Data.ATMA.AddressType );

    if ( pRecord->Data.ATMA.Address &&
         pRecord->Data.ATMA.AddressType == DNS_ATMA_FORMAT_E164 )
    {
        PrintRoutine(
            pContext,
            "\tAddress        = %s\n",
            pRecord->Data.ATMA.Address );
    }
    else if ( pRecord->Data.ATMA.Address )
    {
        DnsPrint_RawOctets(
            PrintRoutine,
            pContext,
            "\tAddress        = ",
            "\t                 ",   // no line header
            pRecord->Data.ATMA.Address,
            pRecord->wDataLength - 1
            );
    }
}



VOID
TsigRecordPrint(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Print TSIG record.

Arguments:

    PrintRoutine -- routine to print with

    pRecord -- record to print

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    DnsPrint_Lock();

    if ( pRecord->Data.TSIG.bPacketPointers )
    {
        DnsPrint_PacketName(
            PrintRoutine,
            pContext,
            "\tAlgorithm      = ",
            pRecord->Data.TSIG.pAlgorithmPacket,
            NULL,       // no packet context
            NULL,
            "\n" );
    }
    else
    {
        PrintRoutine(
            pContext,
            "\tAlgorithm      = %s%S\n",
            RECSTRING_UTF8( pRecord, pRecord->Data.TSIG.pNameAlgorithm ),
            RECSTRING_WIDE( pRecord, pRecord->Data.TSIG.pNameAlgorithm )
            );
    }

    PrintRoutine(
        pContext,
        "\tSigned Time    = %I64u\n"
        "\tFudge Time     = %u\n"
        "\tSig Length     = %u\n"
        "\tSig Ptr        = %p\n"
        "\tXid            = %u\n"
        "\tError          = %u\n"
        "\tOtherLength    = %u\n"
        "\tOther Ptr      = %p\n",
        pRecord->Data.TSIG.i64CreateTime,
        pRecord->Data.TSIG.wFudgeTime,
        pRecord->Data.TSIG.wSigLength,
        pRecord->Data.TSIG.pSignature,
        pRecord->Data.TSIG.wOriginalXid,
        pRecord->Data.TSIG.wError,
        pRecord->Data.TSIG.wOtherLength,
        pRecord->Data.TSIG.pOtherData
        );

    if ( pRecord->Data.TSIG.pSignature )
    {
        DnsPrint_RawOctets(
            PrintRoutine,
            pContext,
            "Signature:",
            NULL,   // no line header
            pRecord->Data.TSIG.pSignature,
            pRecord->Data.TSIG.wSigLength
            );
    }

    if ( pRecord->Data.TSIG.pOtherData )
    {
        DnsPrint_RawOctets(
            PrintRoutine,
            pContext,
            "Other Data:",
            NULL,   // no line header
            pRecord->Data.TSIG.pOtherData,
            pRecord->Data.TSIG.wOtherLength
            );
    }

    DnsPrint_Unlock();
}



VOID
TkeyRecordPrint(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Print TKEY record.

Arguments:

    PrintRoutine -- routine to print with

    pRecord -- record to print

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    DnsPrint_Lock();

    if ( pRecord->Data.TKEY.bPacketPointers )
    {
        DnsPrint_PacketName(
            PrintRoutine,
            pContext,
            "\tAlgorithm      = ",
            pRecord->Data.TKEY.pAlgorithmPacket,
            NULL,       // no packet context
            NULL,
            "\n" );
    }
    else
    {
        PrintRoutine(
            pContext,
            "\tAlgorithm      = %s%S\n",
            RECSTRING_UTF8( pRecord, pRecord->Data.TKEY.pNameAlgorithm ),
            RECSTRING_WIDE( pRecord, pRecord->Data.TKEY.pNameAlgorithm )
            );
    }

    PrintRoutine(
        pContext,
        "\tCreate Time    = %d\n"
        "\tExpire Time    = %d\n"
        "\tMode           = %d\n"
        "\tError          = %d\n"
        "\tKey Length     = %d\n"
        "\tKey Ptr        = %p\n"
        "\tOtherLength    = %d\n"
        "\tOther Ptr      = %p\n",
        pRecord->Data.TKEY.dwCreateTime,
        pRecord->Data.TKEY.dwExpireTime,
        pRecord->Data.TKEY.wMode,
        pRecord->Data.TKEY.wError,
        pRecord->Data.TKEY.wKeyLength,
        pRecord->Data.TKEY.pKey,
        pRecord->Data.TKEY.wOtherLength,
        pRecord->Data.TKEY.pOtherData
        );

    if ( pRecord->Data.TKEY.pKey )
    {
        DnsPrint_RawOctets(
            PrintRoutine,
            pContext,
            "Key:",
            NULL,   // no line header
            pRecord->Data.TKEY.pKey,
            pRecord->Data.TKEY.wKeyLength
            );
    }

    if ( pRecord->Data.TKEY.pOtherData )
    {
        DnsPrint_RawOctets(
            PrintRoutine,
            pContext,
            "Other Data:",
            NULL,   // no line header
            pRecord->Data.TKEY.pOtherData,
            pRecord->Data.TKEY.wOtherLength
            );
    }

    DnsPrint_Unlock();
}



//
//  RR Print Dispatch Table
//

RR_PRINT_FUNCTION   RRPrintTable[] =
{
    NULL,               //  ZERO
    ARecordPrint,       //  A
    PtrRecordPrint,     //  NS
    PtrRecordPrint,     //  MD
    PtrRecordPrint,     //  MF
    PtrRecordPrint,     //  CNAME
    SoaRecordPrint,     //  SOA
    PtrRecordPrint,     //  MB
    PtrRecordPrint,     //  MG
    PtrRecordPrint,     //  MR
    NULL,               //  NULL
    NULL,   //WksRecordPrint,     //  WKS
    PtrRecordPrint,     //  PTR
    TxtRecordPrint,     //  HINFO
    MinfoRecordPrint,   //  MINFO
    MxRecordPrint,      //  MX
    TxtRecordPrint,     //  TXT
    MinfoRecordPrint,   //  RP
    MxRecordPrint,      //  AFSDB
    TxtRecordPrint,     //  X25
    TxtRecordPrint,     //  ISDN
    MxRecordPrint,      //  RT
    NULL,               //  NSAP
    NULL,               //  NSAPPTR
    NULL,               //  SIG
    NULL,               //  KEY
    NULL,               //  PX
    NULL,               //  GPOS
    AaaaRecordPrint,    //  AAAA
    NULL,               //  LOC
    NULL,               //  NXT
    NULL,               //  EID   
    NULL,               //  NIMLOC
    SrvRecordPrint,     //  SRV   
    AtmaRecordPrint,    //  ATMA  
    NULL,               //  NAPTR 
    NULL,               //  KX    
    NULL,               //  CERT  
    NULL,               //  A6    
    NULL,               //  DNAME 
    NULL,               //  SINK  
    NULL,               //  OPT   
    NULL,               //  42
    NULL,               //  43
    NULL,               //  44
    NULL,               //  45
    NULL,               //  46
    NULL,               //  47
    NULL,               //  48

    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as MAX_SELF_INDEXED_TYPE #define in record.h
    //         (see note above in record info table)

    //
    //  Pseudo record types
    //

    TkeyRecordPrint,    //  TKEY
    TsigRecordPrint,    //  TSIG

    //
    //  MS only types
    //

    NULL,               //  WINS
    NULL,               //  WINSR
};



//
//  Generic print record functions
//

VOID
DnsPrint_Record(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      LPSTR           pszHeader,
    IN      PDNS_RECORD     pRecord,
    IN      PDNS_RECORD     pPreviousRecord     OPTIONAL
    )
/*++

Routine Description:

    Print record.

Arguments:

    PrintRoutine -- routine to print with

    pszHeader -- header message

    pRecord -- record to print

    pPreviousRecord -- previous record in RR set (if any)

Return Value:

    None.

--*/
{
    WORD    type = pRecord->wType;
    WORD    dataLength = pRecord->wDataLength;
    WORD    index;

    DnsPrint_Lock();

    if ( pszHeader )
    {
        PrintRoutine(
            pContext,
            pszHeader );
    }

    if ( !pRecord )
    {
        PrintRoutine(
            pContext,
            "ERROR:  Null record ptr to print!\n" );
        goto Unlock;
    }

    //
    //  print record info
    //
    //  same as previous -- skip duplicated info
    //      must match
    //          - name ptr (or have no name)
    //          - type
    //          - flags (hence section)

    if ( pPreviousRecord &&
        (!pRecord->pName || pPreviousRecord->pName == pRecord->pName) &&
        pPreviousRecord->wType == type &&
        *(PWORD)&pPreviousRecord->Flags.DW == *(PWORD)&pRecord->Flags.DW )
    {
        PrintRoutine(
            pContext,
            "  Next record in set:\n"
            "\tPtr = %p, pNext = %p\n"
            "\tTTL        = %d\n"
            "\tDataLength = %d\n",
            pRecord,
            pRecord->pNext,
            pRecord->dwTtl,
            dataLength );
    }

    //
    //  different from previous -- full print
    //

    else
    {
        PrintRoutine(
            pContext,
            "  Record:\n"
            "\tPtr            = %p, pNext = %p\n"
            "\tOwner          = %s%S\n"
            "\tType           = %s (%d)\n"
            "\tFlags          = %hx\n"
            "\t\tSection      = %d\n"
            "\t\tDelete       = %d\n"
            "\t\tCharSet      = %d\n"
            "\tTTL            = %d\n"
            "\tDataLength     = %d\n",
            pRecord,
            pRecord->pNext,
            RECSTRING_UTF8( pRecord, pRecord->pName ),
            RECSTRING_WIDE( pRecord, pRecord->pName ),
            Dns_RecordStringForType( type ),
            type,
            pRecord->Flags.DW,
            pRecord->Flags.S.Section,
            pRecord->Flags.S.Delete,
            pRecord->Flags.S.CharSet,
            pRecord->dwTtl,
            dataLength );
    }

    //
    //  if no data -- done
    //

    if ( ! dataLength )
    {
        goto Unlock;
    }

    //
    //  print data
    //

    index = INDEX_FOR_TYPE( type );
    DNS_ASSERT( index <= MAX_RECORD_TYPE_INDEX );

    if ( index && RRPrintTable[ index ] )
    {
        RRPrintTable[ index ](
            PrintRoutine,
            pContext,
            pRecord );
    }
    else if ( !index )
    {
        PrintRoutine(
            pContext,
            "\tUnknown type:  can not print data\n" );
    }
    else
    {
        //  DCR:  should do raw bytes print
        PrintRoutine(
            pContext,
            "\tNo print routine for this type\n" );
    }

Unlock:

    DnsPrint_Unlock();
}



VOID
printBadDataLength(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Prints waring on bad data in record.

Arguments:

    PrintRoutine -- routine to print with

    pRecord -- record with bad data

Return Value:

    None.

--*/
{
    PrintRoutine(
        pContext,
        "\tERROR:  Invalid record data length for this type.\n" );
}



VOID
DnsPrint_RecordSet(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      LPSTR           pszHeader,
    IN      PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Print record set.

Arguments:

    PrintRoutine -- routine to print with

    pRecord -- record set to print

Return Value:

    None

--*/
{
    PDNS_RECORD pprevious;

    DnsPrint_Lock();
    if ( pszHeader )
    {
        PrintRoutine(
            pContext,
            pszHeader );
    }
    if ( !pRecord )
    {
        PrintRoutine(
            pContext,
            "  No Records in list.\n" );
        goto Unlock;
    }

    //
    //  print all records in set
    //

    pprevious = NULL;

    while ( pRecord )
    {
        DnsPrint_Record(
            PrintRoutine,
            pContext,
            NULL,
            pRecord,
            pprevious );

        pprevious = pRecord;
        pRecord = pRecord->pNext;
    }
    PrintRoutine(
        pContext,
        "\n" );

Unlock:

    DnsPrint_Unlock();
}

//
//  End rrprint.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\rrlist.c ===
/*++

Copyright (c) 1996-2001  Microsoft Corporation

Module Name:

    rrlist.c

Abstract:

    Domain Name System (DNS) Library

    Record list manipulation.

Author:

    Jim Gilroy (jamesg)     January, 1997

Environment:

    User Mode - Win32

Revision History:

--*/


#include "local.h"




PDNS_RECORD
Dns_RecordSetDetach(
    IN OUT  PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Detach first RR set from the rest of the list.

Arguments:

    pRR - incoming record set

Return Value:

    Ptr to first record of next RR set.
    NULL if at end of list.

--*/
{
    PDNS_RECORD prr = pRR;
    PDNS_RECORD pback;      // previous RR in set
    WORD        type;       // first RR set type
    DWORD       section;    // section of first RR set

    if ( !prr )
    {
        return( NULL );
    }

    //
    //  loop until find start of new RR set
    //      - new type or
    //      - new section or
    //      - new name
    //      note that NULL name is automatically considered
    //      previous name
    //  

    type = prr->wType;
    section = prr->Flags.S.Section;
    pback = prr;

    while ( prr = pback->pNext )
    {
        if ( prr->wType == type &&
             prr->Flags.S.Section == section &&
             ( prr->pName == NULL ||
               Dns_NameComparePrivate(
                    prr->pName,
                    pback->pName,
                    pback->Flags.S.CharSet ) ) )
        {
            pback = prr;
            continue;
        }

        //  should not be detaching nameless record
        //      - fixup for robustness

        if ( !prr->pName )
        {
            ASSERT( prr->pName );
            prr->pName = Dns_NameCopyAllocate(
                            pRR->pName,
                            0,      // length unknown
                            pRR->Flags.S.CharSet,
                            prr->Flags.S.CharSet );
            SET_FREE_OWNER( prr );
        }
        break;
    }

    //  have following RR set, NULL terminate first set

    if ( prr )
    {
        pback->pNext = NULL;
    }
    return( prr );
}



PDNS_RECORD
WINAPI
Dns_RecordListAppend(
    IN OUT  PDNS_RECORD     pHeadList,
    IN      PDNS_RECORD     pTailList
    )
/*++

Routine Description:

    Append record list onto another.

Arguments:

    pHeadList -- record list to be head

    pTailList -- record list to append to pHeadList

Return Value:

    Ptr to first record of combined RR set.
        - pHeadList UNLESS pHeadList is NULL,
        then it is pTailList.

--*/
{
    PDNS_RECORD prr = pHeadList;

    if ( !prr )
    {
        return pTailList;
    }

    //  find end of first list and append second list

    while ( prr->pNext )
    {
        prr = prr->pNext;
    }

    //  should be appending new set (with new name)
    //  or matching previous set

    DNS_ASSERT( !pTailList || pTailList->pName ||
                (pTailList->wType == prr->wType &&
                 pTailList->Flags.S.Section == prr->Flags.S.Section) );

    prr->pNext = pTailList;

    return pHeadList;
}



DWORD
Dns_RecordListCount(
    IN      PDNS_RECORD     pRRList,
    IN      WORD            wType
    )
/*++

Routine Description:

    Count records in list.

Arguments:

    pRRList - incoming record set

Return Value:

    Count of records of given type in list.

--*/
{
    DWORD   count = 0;

    //
    //  loop counting all records that match
    //      - either direct match
    //      - or if matching type is ALL
    //

    while ( pRRList )
    {
        if ( pRRList->wType == wType ||
             wType == DNS_TYPE_ALL )
        {
            count++;
        }

        pRRList = pRRList->pNext;
    }

    return( count );
}



DWORD
Dns_RecordListGetMinimumTtl(
    IN      PDNS_RECORD     pRRList
    )
/*++

Routine Description:

    Get minimum TTL of record list

Arguments:

    pRRList - incoming record set

Return Value:

    Minimum TTL of records in list.

--*/
{
    PDNS_RECORD prr = pRRList;
    DWORD       minTtl = MAXDWORD;

    DNSDBG( TRACE, (
        "Dns_RecordListGetMinimumTtl( %p )\n",
        pRRList ));

    //
    //  loop through list build minimum TTL
    //

    while ( prr )
    {
        if ( prr->dwTtl < minTtl )
        {
            minTtl = prr->dwTtl;
        }
        prr = prr->pNext;
    }

    return  minTtl;
}




//
//  Record screening
//

BOOL
Dns_ScreenRecord(
    IN      PDNS_RECORD     pRR,
    IN      DWORD           ScreenFlag
    )
/*++

Routine Description:

    Screen a record.

Arguments:

    pRR - incoming record

    ScreenFlag - screeing flag

Return Value:

    TRUE if passes screening.
    FALSE if record fails screen.

--*/
{
    BOOL    fsave = TRUE;

    DNSDBG( TRACE, (
        "Dns_ScreenRecord( %p, %08x )\n",
        pRR,
        ScreenFlag ));

    //  section screening

    if ( ScreenFlag & SCREEN_OUT_SECTION )
    {
        if ( IS_ANSWER_RR(pRR) )
        {
            fsave = !(ScreenFlag & SCREEN_OUT_ANSWER);
        }
        else if ( IS_AUTHORITY_RR(pRR) )
        {
            fsave = !(ScreenFlag & SCREEN_OUT_AUTHORITY);
        }
        else if ( IS_ADDITIONAL_RR(pRR) )
        {
            fsave = !(ScreenFlag & SCREEN_OUT_ADDITIONAL);
        }
        if ( !fsave )
        {
            return  FALSE;
        }
    }

    //  type screening

    if ( ScreenFlag & SCREEN_OUT_NON_RPC )
    {
        fsave = Dns_IsRpcRecordType( pRR->wType );
    }

    return  fsave;
}



PDNS_RECORD
Dns_RecordListScreen(
    IN      PDNS_RECORD     pRR,
    IN      DWORD           ScreenFlag
    )
/*++

Routine Description:

    Screen records from record set.

Arguments:

    pRR - incoming record set

    ScreenFlag - flag with record screening parameters

Return Value:

    Ptr to new record set, if successful.
    NULL on error.

--*/
{
    PDNS_RECORD     prr;
    PDNS_RECORD     pnext;
    DNS_RRSET       rrset;

    DNSDBG( TRACE, (
        "Dns_RecordListScreen( %p, %08x )\n",
        pRR,
        ScreenFlag ));

    //  init copy rrset

    DNS_RRSET_INIT( rrset );

    //
    //  loop through RR list
    //

    pnext = pRR;

    while ( pnext )
    {
        prr = pnext;
        pnext = prr->pNext;

        //
        //  screen
        //      - reappend record passing screen
        //      - delete record failing screen
        //

        if ( Dns_ScreenRecord( prr, ScreenFlag ) )
        {
            prr->pNext = NULL;
            DNS_RRSET_ADD( rrset, prr );
            continue;
        }
        else
        {
            Dns_RecordFree( prr );
        }
    }

    return( rrset.pFirstRR );
}

//
//  End rrlist.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\rrcopy.c ===
/*++

Copyright (c) 1997-2001 Microsoft Corporation

Module Name:

    rrcopy.c

Abstract:

    Domain Name System (DNS) Library

    Copy resource record routines.

Author:

    Jim Gilroy (jamesg)     February, 1997

Revision History:

--*/


#include "local.h"




PDNS_RECORD
ARecordCopy(
    IN      PDNS_RECORD     pRR,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
/*++

Routine Description:

    Copy A record data from packet.

Arguments:

    pRR - RR to copy

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;

    precord = Dns_AllocateRecord( sizeof(IP_ADDRESS) );
    if ( !precord )
    {
        return NULL;
    }
    precord->Data.A.IpAddress = pRR->Data.A.IpAddress;

    return precord;
}


PDNS_RECORD
PtrRecordCopy(
    IN      PDNS_RECORD     pRR,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
/*++

Routine Description:

    Copy PTR compatible record.
    Includes: NS, PTR, CNAME, MB, MR, MG, MD, MF

Arguments:

    pRR - RR to copy

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;

    precord = Dns_AllocateRecord( sizeof( DNS_PTR_DATA ) );
    if ( !precord )
    {
        return NULL;
    }

    precord->Data.PTR.pNameHost = Dns_NameCopyAllocate(
                                        pRR->Data.PTR.pNameHost,
                                        0,      // length unknown
                                        CharSetIn,
                                        CharSetOut
                                        );
    if ( ! precord->Data.PTR.pNameHost )
    {
        FREE_HEAP( precord );
        return NULL;
    }

    FLAG_FreeData( precord ) = TRUE;

    return precord;
}



PDNS_RECORD
SoaRecordCopy(
    IN      PDNS_RECORD     pRR,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
/*++

Routine Description:

    Copy SOA record.

Arguments:

    pRR - RR to copy

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    LPSTR       pname;

    precord = Dns_AllocateRecord( sizeof( DNS_SOA_DATA ) );
    if ( !precord )
    {
        return NULL;
    }

    //
    //  copy integer data
    //

    memcpy(
        & precord->Data.SOA.dwSerialNo,
        & pRR->Data.SOA.dwSerialNo,
        SIZEOF_SOA_FIXED_DATA );

    //
    //  create copy of primary and admin
    //

    pname = Dns_NameCopyAllocate(
                pRR->Data.SOA.pNamePrimaryServer,
                0,      // length unknown
                CharSetIn,
                CharSetOut
                );
    if ( !pname )
    {
        FREE_HEAP( precord );
        return NULL;
    }
    precord->Data.SOA.pNamePrimaryServer = pname;

    pname = Dns_NameCopyAllocate(
                pRR->Data.SOA.pNameAdministrator,
                0,      // length unknown
                CharSetIn,
                CharSetOut
                );
    if ( !pname )
    {
        FREE_HEAP( precord->Data.SOA.pNamePrimaryServer );
        FREE_HEAP( precord );
        return NULL;
    }
    precord->Data.SOA.pNameAdministrator = pname;

    FLAG_FreeData( precord ) = TRUE;

    return precord;
}



PDNS_RECORD
MinfoRecordCopy(
    IN      PDNS_RECORD     pRR,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
/*++

Routine Description:

    Copy MINFO and RP records from wire.

Arguments:

    pRR - RR to copy

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    LPSTR       pname;

    precord = Dns_AllocateRecord( sizeof( DNS_MINFO_DATA ) );
    if ( !precord )
    {
        return NULL;
    }

    //
    //  create copy of name fields
    //

    pname = Dns_NameCopyAllocate(
                pRR->Data.MINFO.pNameMailbox,
                0,      // length unknown
                CharSetIn,
                CharSetOut
                );
    if ( !pname )
    {
        FREE_HEAP( precord );
        return NULL;
    }
    precord->Data.MINFO.pNameMailbox = pname;

    pname = Dns_NameCopyAllocate(
                pRR->Data.MINFO.pNameErrorsMailbox,
                0,      // length unknown
                CharSetIn,
                CharSetOut
                );
    if ( !pname )
    {
        FREE_HEAP( precord->Data.MINFO.pNameMailbox );
        FREE_HEAP( precord );
        return NULL;
    }
    precord->Data.MINFO.pNameErrorsMailbox = pname;

    FLAG_FreeData( precord ) = TRUE;

    return precord;
}



PDNS_RECORD
MxRecordCopy(
    IN      PDNS_RECORD     pRR,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
/*++

Routine Description:

    Copy MX compatible record from wire.
    Includes: MX, RT, AFSDB

Arguments:

    pRR - RR to copy

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    PCHAR       pname;

    precord = Dns_AllocateRecord( sizeof( DNS_MX_DATA ) );
    if ( !precord )
    {
        return NULL;
    }

    //  MX preference value
    //  RT preference
    //  AFSDB subtype

    precord->Data.MX.wPreference = pRR->Data.MX.wPreference;

    //  MX exchange
    //  RT exchange
    //  AFSDB hostname
    //      - name immediately follows MX data struct

    pname = Dns_NameCopyAllocate(
                pRR->Data.MX.pNameExchange,
                0,      // length unknown
                CharSetIn,
                CharSetOut
                );
    if ( !pname )
    {
        FREE_HEAP( precord );
        return NULL;
    }
    precord->Data.MX.pNameExchange = pname;

    FLAG_FreeData( precord ) = TRUE;

    return precord;
}



PDNS_RECORD
TxtRecordCopy(
    IN      PDNS_RECORD     pRR,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
/*++

Routine Description:

    Copy TXT compatible records.
    Includes: TXT, X25, HINFO, ISDN

Arguments:

    pRR - RR to copy

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    WORD        bufLength = sizeof( DNS_TXT_DATA );
    INT         count = pRR->Data.TXT.dwStringCount;
    LPSTR *     ppstringIn;
    LPSTR *     ppstringNew;
    LPSTR       pstring;

    bufLength += (WORD)(sizeof(LPSTR) * count);

    precord = Dns_AllocateRecord( bufLength );
    if ( !precord )
    {
        return NULL;
    }
    precord->Data.TXT.dwStringCount = 0;

    //
    //  copy each string
    //      - first string written immediately after string ptr list
    //      - each string written immediately after previous
    //

    ppstringIn = (LPSTR *) pRR->Data.TXT.pStringArray;
    ppstringNew = (LPSTR *) precord->Data.TXT.pStringArray;

    FLAG_FreeData( precord ) = TRUE;

    while ( count-- )
    {
        pstring = Dns_StringCopyAllocate(
                        *ppstringIn,
                        0,      // length unknown
                        CharSetIn,
                        CharSetOut
                        );
        if ( ! pstring )
        {
            Dns_RecordFree( precord );
            return NULL;
        }
        *ppstringNew = pstring;

        precord->Data.TXT.dwStringCount += 1;

        ppstringIn++;
        ppstringNew++;
    }

    return precord;
}



PDNS_RECORD
FlatRecordCopy(
    IN      PDNS_RECORD     pRR,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
/*++

Routine Description:

    Copy flat data compatible record.
    Includes: AAAA

Arguments:

    pRR - RR to copy

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;

    //
    //  allocate given datalength
    //

    precord = Dns_AllocateRecord( pRR->wDataLength );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  flat copy of data
    //

    memcpy(
        & precord->Data,
        & pRR->Data,
        pRR->wDataLength );

    return( precord );
}



PDNS_RECORD
SrvRecordCopy(
    IN      PDNS_RECORD     pRR,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
/*++

Routine Description:

    Copy SRV compatible record from wire.
    Includes: SRV, RT, AFSDB

Arguments:

    pRR - RR to copy

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    PCHAR       pname;

    precord = Dns_AllocateRecord( sizeof( DNS_SRV_DATA ) );
    if ( !precord )
    {
        return NULL;
    }

    //  copy integer data

    precord->Data.SRV.wPriority = pRR->Data.SRV.wPriority;
    precord->Data.SRV.wWeight   = pRR->Data.SRV.wWeight;
    precord->Data.SRV.wPort     = pRR->Data.SRV.wPort;

    //  copy target name

    pname = Dns_NameCopyAllocate(
                pRR->Data.SRV.pNameTarget,
                0,      // length unknown
                CharSetIn,
                CharSetOut
                );
    if ( !pname )
    {
        FREE_HEAP( precord );
        return NULL;
    }
    precord->Data.SRV.pNameTarget = pname;

    SET_FREE_DATA( precord );

    return precord;
}



PDNS_RECORD
AtmaRecordCopy(
    IN      PDNS_RECORD     pRR,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
/*++

Routine Description:

    Copy Atma compatible record from wire.
    Includes:

Arguments:

    pRR - RR to copy

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    WORD        bufLength;

    //
    //  determine required buffer length and allocate
    //

    bufLength = sizeof(DNS_ATMA_DATA) +  DNS_ATMA_MAX_ADDR_LENGTH ;

    precord = Dns_AllocateRecord( bufLength );
    if ( !precord )
    {
        return( NULL );
    }

    //  copy integer data

    precord->Data.ATMA.AddressType = pRR->Data.ATMA.AddressType;

    if ( precord->Data.ATMA.AddressType == DNS_ATMA_FORMAT_E164 )
    {
        precord->wDataLength = (WORD) strlen(pRR->Data.ATMA.Address);

        if ( precord->wDataLength > DNS_ATMA_MAX_ADDR_LENGTH )
        {
            precord->wDataLength = DNS_ATMA_MAX_ADDR_LENGTH;
        }
        strncpy(
            precord->Data.ATMA.Address,
            pRR->Data.ATMA.Address,
            precord->wDataLength );
    }
    else
    {
        precord->wDataLength = DNS_ATMA_MAX_ADDR_LENGTH;

        memcpy(
            precord->Data.ATMA.Address,
            pRR->Data.ATMA.Address,
            precord->wDataLength );
    }

    return( precord );
}



//
//  RR copy jump table
//

RR_COPY_FUNCTION   RRCopyTable[] =
{
    NULL,               //  ZERO
    ARecordCopy,        //  A
    PtrRecordCopy,      //  NS
    PtrRecordCopy,      //  MD
    PtrRecordCopy,      //  MF
    PtrRecordCopy,      //  CNAME
    SoaRecordCopy,      //  SOA
    PtrRecordCopy,      //  MB
    PtrRecordCopy,      //  MG
    PtrRecordCopy,      //  MR
    NULL,               //  NULL
    NULL,   //WksRecordCopy,      //  WKS
    PtrRecordCopy,      //  PTR
    TxtRecordCopy,      //  HINFO
    MinfoRecordCopy,    //  MINFO
    MxRecordCopy,       //  MX
    TxtRecordCopy,      //  TXT
    MinfoRecordCopy,    //  RP
    MxRecordCopy,       //  AFSDB
    TxtRecordCopy,      //  X25
    TxtRecordCopy,      //  ISDN
    MxRecordCopy,       //  RT
    NULL,               //  NSAP
    NULL,               //  NSAPPTR
    NULL,               //  SIG
    NULL,               //  KEY
    NULL,               //  PX
    NULL,               //  GPOS
    FlatRecordCopy,     //  AAAA
    NULL,               //  LOC
    NULL,               //  NXT
    NULL,               //  EID   
    NULL,               //  NIMLOC
    SrvRecordCopy,      //  SRV   
    AtmaRecordCopy,     //  ATMA  
    NULL,               //  NAPTR 
    NULL,               //  KX    
    NULL,               //  CERT  
    NULL,               //  A6    
    NULL,               //  DNAME 
    NULL,               //  SINK  
    NULL,               //  OPT   
    NULL,               //  42
    NULL,               //  43
    NULL,               //  44
    NULL,               //  45
    NULL,               //  46
    NULL,               //  47
    NULL,               //  48

    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as MAX_SELF_INDEXED_TYPE #define in record.h
    //         (see note above in record info table)

    //
    //  Pseudo record types
    //

    NULL,               //  TKEY
    NULL,               //  TSIG

    //
    //  MS only types
    //

    FlatRecordCopy,     //  WINS
    NULL,               //  WINSR

};




//
//  Generic copy functions
//

PDNS_RECORD
privateRecordCopy(
    IN      PDNS_RECORD     pRecord,
    IN      PDNS_RECORD     pPrevIn,
    IN      PDNS_RECORD     pPrevCopy,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
/*++

Routine Description:

    Copy record to as member of record set.

    The previous records allow suppression of owner name copy when copying
    RR set.

Arguments:

    pRecord - record to copy

    pPrevIn - previous incoming record copied

    pPrevCopy - copy of pPrevIn in new set

    CharSetIn - input record character set;  OPTIONAL
        if zero, pRecord must have CharSet;
        if non-zero, pRecord must have zero or matching CharSet;
        allow this to be specified independently of pRecord, to handle
        conversion of user supplied records, which we do not want to
        modify

    CharSetOut - desired record character set

Return Value:

    Ptr to copy of record in desired character set.
    NULL on error.

--*/
{
    PDNS_RECORD prr;
    WORD        index;
    DNS_CHARSET recordCharSet;

    DNSDBG( TRACE, ( "privateRecordCopy( %p )\n", pRecord ));

    //
    //  input character set
    //  allow specification of input character set to handle case
    //  of user created records, but if input record has a set
    //  then it's assumed to be valid
    //  so validity check:
    //      - CharSetIn == 0 => use record's != 0 set
    //      - record's set == 0 => use CharSetIn != 0
    //      - CharSetIn == record's set
    //

    recordCharSet = RECORD_CHARSET( pRecord );

    if ( recordCharSet )
    {
        ASSERT( CharSetIn == 0 || CharSetIn == recordCharSet );
        CharSetIn = recordCharSet;
    }
    else    // record has no charset
    {
        if ( CharSetIn == 0 )
        {
            ASSERT( FALSE );
            goto Failed;
        }
    }

    //
    //  copy record data
    //

    if ( pRecord->wDataLength != 0 )
    {
        index = INDEX_FOR_TYPE( pRecord->wType );
        DNS_ASSERT( index <= MAX_RECORD_TYPE_INDEX );

        if ( !index || !RRCopyTable[ index ] )
        {
            DNS_PRINT((
                "WARNING:  No copy routine for type = %d\n"
                "\tdoing flat copy of record at %p\n",
                pRecord->wType,
                pRecord ));
            prr = FlatRecordCopy(
                        pRecord,
                        CharSetIn,
                        CharSetOut );
        }
        else
        {
            prr = RRCopyTable[ index ](
                        pRecord,
                        CharSetIn,
                        CharSetOut );
        }
    }
    else    // no data record
    {
        prr = FlatRecordCopy(
                    pRecord,
                    CharSetIn,
                    CharSetOut );
    }

    if ( !prr )
    {
        goto Failed;
    }

    //
    //  copy record structure fields
    //      - type
    //      - TTL
    //      - flags
    //

    prr->dwTtl = pRecord->dwTtl;
    prr->wType = pRecord->wType;

    prr->Flags.S.Section = pRecord->Flags.S.Section;
    prr->Flags.S.Delete  = pRecord->Flags.S.Delete;
    prr->Flags.S.CharSet = CharSetOut;

    //
    //  copy name
    //

    if ( pRecord->pName )
    {
        //
        //      - if incoming name has FreeOwner set, then always copy
        //      as never know when incoming set will be tossed
        //
        //      - then check if incoming name same as previous incoming
        //      name in which case we can use previous copied name
        //
        //      - otherwise full copy of name
        //

        if ( !FLAG_FreeOwner( pRecord ) &&
            pPrevIn && pPrevCopy &&
            pRecord->pName == pPrevIn->pName )
        {
            prr->pName = pPrevCopy->pName;
        }
        else
        {
            prr->pName = Dns_NameCopyAllocate(
                                pRecord->pName,
                                0,              // unknown length
                                CharSetIn,
                                CharSetOut
                                );
            if ( !prr->pName )
            {
                FREE_HEAP( prr );
                goto Failed;
            }
            FLAG_FreeOwner( prr ) = TRUE;
        }
    }

    DNSDBG( TRACE, (
        "Leaving privateRecordCopy(%p) = %p.\n",
        pRecord,
        prr ));
    return( prr );


Failed:

    DNSDBG( TRACE, (
        "privateRecordCopy(%p) failed\n",
        pRecord ));
    return( NULL );
}



PDNS_RECORD
WINAPI
Dns_RecordCopyEx(
    IN      PDNS_RECORD     pRecord,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
/*++

Routine Description:

    Copy record.

Arguments:

    pRecord - record to copy

    CharSetIn - incoming record's character set

    CharSetOut -- char set for resulting record

Return Value:

    Ptr to copy of record in desired character set.
    NULL on error.

--*/
{

    DNSDBG( TRACE, ( "Dns_RecordCopyEx( %p )\n", pRecord ));

    //
    //  call private copy routine
    //      - set optional ptrs to cause full owner name copy
    //

    return privateRecordCopy(
                pRecord,
                NULL,
                NULL,
                CharSetIn,
                CharSetOut );
}


PDNS_RECORD
WINAPI
Dns_RecordCopy_W(
    IN      PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Copy record.

Arguments:

    pRecord - unicode record to copy to unicode

Return Value:

    Ptr to copy of record in desired character set.
    NULL on error.

--*/
{
    DNSDBG( TRACE, ( "Dns_RecordCopy( %p )\n", pRecord ));

    //
    //  call private copy routine
    //      - set optional ptrs to cause full owner name copy
    //

    return privateRecordCopy(
                pRecord,
                NULL,
                NULL,
                DnsCharSetUnicode,
                DnsCharSetUnicode );
}


PDNS_RECORD
WINAPI
Dns_RecordCopy_A(
    IN      PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Copy record.

Arguments:

    pRecord - ANSI record to copy to ANSI

Return Value:

    Ptr to copy of record in desired character set.
    NULL on error.

--*/
{
    DNSDBG( TRACE, ( "Dns_RecordCopy( %p )\n", pRecord ));

    //
    //  call private copy routine
    //      - set optional ptrs to cause full owner name copy
    //

    return privateRecordCopy(
                pRecord,
                NULL,
                NULL,
                DnsCharSetAnsi,
                DnsCharSetAnsi );
}



//
//  Record set copy
//

PDNS_RECORD
Dns_RecordSetCopyEx(
    IN      PDNS_RECORD     pRR,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
/*++

Routine Description:

    Copy record set, converting to UTF8 if necessary.

Arguments:

    pRR - incoming record set

    CharSetIn - incoming record's character set

    CharSetOut -- char set for resulting record

Return Value:

    Ptr to new record set, if successful.
    NULL on error.

--*/
{
    return  Dns_RecordListCopyEx(
                pRR,
                0,      // no screening flags
                CharSetIn,
                CharSetOut
                );
}



PDNS_RECORD
Dns_RecordListCopyEx(
    IN      PDNS_RECORD     pRR,
    IN      DWORD           ScreenFlag,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
/*++

Routine Description:

    Screened copy of record set.

Arguments:

    pRR - incoming record set

    ScreenFlag - flag with record screening parameters

    CharSetIn - incoming record's character set

    CharSetOut -- char set for resulting record

Return Value:

    Ptr to new record set, if successful.
    NULL on error.

--*/
{
    PDNS_RECORD prr;        // most recent copied
    PDNS_RECORD prevIn;     // previous in set being copied
    DNS_RRSET   rrset;

    DNSDBG( TRACE, (
        "Dns_RecordListCopyEx( %p, %08x, %d, %d )\n",
        pRR,
        ScreenFlag,
        CharSetIn,
        CharSetOut ));

    //  init copy rrset

    DNS_RRSET_INIT( rrset );

    //
    //  loop through RR set, add records to either match or diff sets
    //

    prevIn = NULL;
    prr = NULL;

    while ( pRR )
    {
        //  skip copy on record not matching copy criteria

        if ( ScreenFlag )
        {
            if ( !Dns_ScreenRecord( pRR, ScreenFlag ) )
            {
                pRR = pRR->pNext;
                continue;
            }
        }

        prr = privateRecordCopy(
                pRR,
                prevIn,
                prr,        // previous rr copied
                CharSetIn,
                CharSetOut
                );
        if ( prr )
        {
            DNS_RRSET_ADD( rrset, prr );
            prevIn = pRR;
            pRR = pRR->pNext;
            continue;
        }

        //  if fail, toss entire new set

        Dns_RecordListFree( rrset.pFirstRR );
        return( NULL );
    }

    return( rrset.pFirstRR );
}

//
//  End rrcopy.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\rrwrite.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    rrwrite.c

Abstract:

    Domain Name System (DNS) Library

    Write resource record to packet routines.

Author:

    Jim Gilroy (jamesg)     January, 1997

Revision History:

--*/


#include "local.h"




PCHAR
ARecordWrite(
    IN OUT  PDNS_RECORD     pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Write A record data to packet.

Arguments:

    pRR - ptr to record to write

    pch - ptr to position in buffer to write

    pchEnd - end of buffer position

Return Value:

    Ptr to next byte in buffer to write.
    NULL on error.  (Error code through GetLastError())

--*/
{
    if ( pch + sizeof(IP_ADDRESS) > pchEnd )
    {
        SetLastError( ERROR_MORE_DATA );
        return( NULL );
    }

    *(UNALIGNED DWORD *) pch = pRR->Data.A.IpAddress;

    return ( pch + sizeof(IP_ADDRESS) );
}



PCHAR
PtrRecordWrite(
    IN OUT  PDNS_RECORD     pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Write PTR compatible record data to packet.
    Includes: PTR, CNAME, MB, MR, MG, MD, MF

Arguments:

    pRR - ptr to record to write

    pch - ptr to position in buffer to write

    pchEnd - end of buffer position

Return Value:

    Ptr to next byte in buffer to write.
    NULL on error.  (Error code through GetLastError())

--*/
{
    //
    //  write name to packet
    //      - no compression in data
    //

    pch = Dns_WriteDottedNameToPacket(
                pch,
                pchEnd,
                pRR->Data.PTR.pNameHost,
                NULL,
                0,
                IS_UNICODE_RECORD(pRR) );
    if ( !pch )
    {
        SetLastError( ERROR_MORE_DATA );
    }
    return( pch );
}



PCHAR
SoaRecordWrite(
    IN OUT  PDNS_RECORD     pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Write SOA compatible to wire.

Arguments:

    pRR - ptr to record to write

    pch - ptr to position in buffer to write

    pchEnd - end of buffer position

Return Value:

    Ptr to next byte in buffer to write.
    NULL on error.  (Error code through GetLastError())

--*/
{
    PCHAR   pchdone;
    PDWORD  pdword;

    //
    //  SOA names: primary server, responsible party
    //

    pch = Dns_WriteDottedNameToPacket(
                pch,
                pchEnd,
                pRR->Data.SOA.pNamePrimaryServer,
                NULL,
                0,
                IS_UNICODE_RECORD(pRR) );
    if ( !pch )
    {
        SetLastError( ERROR_MORE_DATA );
        return( NULL );
    }
    pch = Dns_WriteDottedNameToPacket(
                pch,
                pchEnd,
                pRR->Data.SOA.pNameAdministrator,
                NULL,
                0,
                IS_UNICODE_RECORD(pRR) );
    if ( !pch )
    {
        SetLastError( ERROR_MORE_DATA );
        return( NULL );
    }

    //
    //  SOA integer fields
    //

    pchdone = pch + SIZEOF_SOA_FIXED_DATA;
    if ( pchdone > pchEnd )
    {
        SetLastError( ERROR_MORE_DATA );
        return( NULL );
    }

    pdword = &pRR->Data.SOA.dwSerialNo;
    while( pch < pchdone )
    {
        *(UNALIGNED DWORD *) pch = htonl( *pdword++ );
        pch += sizeof( DWORD );
    }
    return( pch );
}



PCHAR
MxRecordWrite(
    IN OUT  PDNS_RECORD     pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Write MX compatible record to wire.
    Includes: MX, RT, AFSDB

Arguments:

    pRR - ptr to record to write

    pch - ptr to position in buffer to write

    pchEnd - end of buffer position

Return Value:

    Ptr to next byte in buffer to write.
    NULL on error.  (Error code through GetLastError())

--*/
{
    //
    //  MX preference value
    //  RT preference
    //  AFSDB subtype
    //

    if ( pch + sizeof(WORD) > pchEnd )
    {
        SetLastError( ERROR_MORE_DATA );
        return( NULL );
    }
    *(UNALIGNED WORD *) pch = htons( pRR->Data.MX.wPreference );
    pch += sizeof( WORD );

    //
    //  MX exchange
    //  RT exchange
    //  AFSDB hostname
    //

    pch = Dns_WriteDottedNameToPacket(
                pch,
                pchEnd,
                pRR->Data.MX.pNameExchange,
                NULL,
                0,
                IS_UNICODE_RECORD(pRR) );
    if ( !pch )
    {
        SetLastError( ERROR_MORE_DATA );
    }
    return( pch );
}



PCHAR
TxtRecordWrite(
    IN OUT  PDNS_RECORD     pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Write TXT compatible record to wire.
    Includes: TXT, HINFO, ISDN, X25 types.

Arguments:

    pRR - ptr to record to write

    pch - ptr to position in buffer to write

    pchEnd - end of buffer position

Return Value:

    Ptr to next byte in buffer to write.
    NULL on error.  (Error code through GetLastError())

--*/
{
    WORD    i;
    PCHAR * ppstring;

    //
    //  write all available text strings
    //

    i = (WORD) pRR->Data.TXT.dwStringCount;

    if ( ! Dns_IsStringCountValidForTextType( pRR->wType, i ) )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }

    ppstring = pRR->Data.TXT.pStringArray;
    while ( i-- )
    {
        pch = Dns_WriteStringToPacket(
                pch,
                pchEnd,
                *ppstring,
                IS_UNICODE_RECORD(pRR) );
        if ( !pch )
        {
            SetLastError( ERROR_MORE_DATA );
            break;
        }
        ppstring++;
    }
    return( pch );
}



PCHAR
HinfoRecordWrite(
    IN OUT  PDNS_RECORD     pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Write HINFO (string like) record to wire.
    Includes: HINFO, ISDN, X25 types.

Arguments:

    pRR - ptr to record to write

    pch - ptr to position in buffer to write

    pchEnd - end of buffer position

Return Value:

    Ptr to next byte in buffer to write.
    NULL on error.  (Error code through GetLastError())

--*/
{
    WORD    i;
    PCHAR * ppstring;

    //
    //  write all available text strings
    //
    //  DCR:  ISDN HINFO write -- not sure works
    //      not sure this works, because NULL may need to
    //      be written for ISDN or even HINFO
    //

    i = 2;
    if ( pRR->wType == DNS_TYPE_X25 )
    {
        i=1;
    }

    ppstring = (PSTR *) & pRR->Data.TXT;
    while ( i-- )
    {
        if ( ! *ppstring )
        {
            break;
        }
        pch = Dns_WriteStringToPacket(
                pch,
                pchEnd,
                *ppstring,
                IS_UNICODE_RECORD(pRR) );
        if ( !pch )
        {
            SetLastError( ERROR_MORE_DATA );
            break;
        }
        ppstring++;
    }
    return( pch );
}



PCHAR
MinfoRecordWrite(
    IN OUT  PDNS_RECORD     pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Write MINFO compatible to wire.
    Includes MINFO and RP types.

Arguments:

    pRR - ptr to record to write

    pch - ptr to position in buffer to write

    pchEnd - end of buffer position

Return Value:

    Ptr to next byte in buffer to write.
    NULL on error.  (Error code through GetLastError())

--*/
{
    //
    //  MINFO responsible mailbox
    //  RP responsible person mailbox

    pch = Dns_WriteDottedNameToPacket(
                pch,
                pchEnd,
                pRR->Data.MINFO.pNameMailbox,
                NULL,
                0,
                IS_UNICODE_RECORD(pRR) );
    if ( !pch )
    {
        SetLastError( ERROR_MORE_DATA );
        return( NULL );
    }

    //
    //  MINFO errors to mailbox
    //  RP text RR location

    pch = Dns_WriteDottedNameToPacket(
                pch,
                pchEnd,
                pRR->Data.MINFO.pNameErrorsMailbox,
                NULL,
                0,
                IS_UNICODE_RECORD(pRR) );
    if ( !pch )
    {
        SetLastError( ERROR_MORE_DATA );
        return( NULL );
    }

    return( pch );
}



PCHAR
FlatRecordWrite(
    IN OUT  PDNS_RECORD     pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Write flat record type data to packet.
    Flat types include:
        AAAA
        WINS

Arguments:

    pRR - ptr to record to write

    pch - ptr to position in buffer to write

    pchEnd - end of buffer position

Return Value:

    Ptr to next byte in buffer to write.
    NULL on error.  (Error code through GetLastError())

--*/
{
    WORD    length = pRR->wDataLength;

    if ( pch + length > pchEnd )
    {
        SetLastError( ERROR_MORE_DATA );
        return( NULL );
    }

    memcpy(
        pch,
        (PCHAR)&pRR->Data,
        length );

    pch += length;
    return( pch );
}



PCHAR
SrvRecordWrite(
    IN OUT  PDNS_RECORD     pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Write SRV record to wire.

Arguments:

    pRR - ptr to record to write

    pch - ptr to position in buffer to write

    pchEnd - end of buffer position

Return Value:

    Ptr to next byte in buffer to write.
    NULL on error.  (Error code through GetLastError())

--*/
{
    PCHAR   pchname;
    PWORD   pword;

    //
    //  SRV integer values
    //

    pchname = pch + SIZEOF_SRV_FIXED_DATA;
    if ( pchname > pchEnd )
    {
        SetLastError( ERROR_MORE_DATA );
        return( NULL );
    }
    pword = &pRR->Data.SRV.wPriority;
    while ( pch < pchname )
    {
        *(UNALIGNED WORD *) pch = htons( *pword++ );
        pch += sizeof(WORD);
    }

    //
    //  SRV target host
    //

    pch = Dns_WriteDottedNameToPacket(
                pch,
                pchEnd,
                pRR->Data.SRV.pNameTarget,
                NULL,
                0,
                IS_UNICODE_RECORD(pRR) );
    if ( !pch )
    {
        SetLastError( ERROR_MORE_DATA );
    }
    return( pch );
}


PCHAR
AtmaRecordWrite(
    IN OUT  PDNS_RECORD     pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Write ATMA record to wire.

Arguments:

    pRR - ptr to record to write

    pch - ptr to position in buffer to write

    pchEnd - end of buffer position

Return Value:

    Ptr to next byte in buffer to write.
    NULL on error.  (Error code through GetLastError())

--*/
{
    PBYTE  pbyte;

    //
    //  ATMA integer values
    //

    if ( ( pch + sizeof( DNS_ATMA_DATA ) + DNS_ATMA_MAX_ADDR_LENGTH ) >
         pchEnd )
    {
        SetLastError( ERROR_MORE_DATA );
        return( NULL );
    }

    pbyte = &pRR->Data.ATMA.AddressType;
    *(BYTE *) pch = *pbyte;
    pch += sizeof( BYTE );

    //
    // write ATMA address
    //
    memcpy( pch,
            (PCHAR)&pRR->Data.ATMA.Address,
            pRR->wDataLength );

    pch += pRR->wDataLength;

    return( pch );
}


//
//  stubs until read to go
//

PCHAR
TkeyRecordWrite(
    IN OUT  PDNS_RECORD     pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchEnd
    )
{
    return( NULL );
}

PCHAR
TsigRecordWrite(
    IN OUT  PDNS_RECORD     pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchEnd
    )
{
    return( NULL );
}




//
//  RR write to packet jump table
//

RR_WRITE_FUNCTION   RRWriteTable[] =
{
    NULL,               //  ZERO
    ARecordWrite,       //  A
    PtrRecordWrite,     //  NS
    PtrRecordWrite,     //  MD
    PtrRecordWrite,     //  MF
    PtrRecordWrite,     //  CNAME
    SoaRecordWrite,     //  SOA
    PtrRecordWrite,     //  MB
    PtrRecordWrite,     //  MG
    PtrRecordWrite,     //  MR
    NULL,               //  NULL
    NULL,   //WksRecordWrite,     //  WKS
    PtrRecordWrite,     //  PTR
    TxtRecordWrite,     //  HINFO
    MinfoRecordWrite,   //  MINFO
    MxRecordWrite,      //  MX
    TxtRecordWrite,     //  TXT
    MinfoRecordWrite,   //  RP
    MxRecordWrite,      //  AFSDB
    TxtRecordWrite,     //  X25
    TxtRecordWrite,     //  ISDN
    MxRecordWrite,      //  RT
    NULL,               //  NSAP
    NULL,               //  NSAPPTR
    NULL,               //  SIG
    NULL,               //  KEY
    NULL,               //  PX
    NULL,               //  GPOS
    FlatRecordWrite,    //  AAAA
    NULL,               //  LOC
    NULL,               //  NXT
    NULL,               //  EID   
    NULL,               //  NIMLOC
    SrvRecordWrite,     //  SRV   
    AtmaRecordWrite,    //  ATMA  
    NULL,               //  NAPTR 
    NULL,               //  KX    
    NULL,               //  CERT  
    NULL,               //  A6    
    NULL,               //  DNAME 
    NULL,               //  SINK  
    NULL,               //  OPT   
    NULL,               //  42
    NULL,               //  43
    NULL,               //  44
    NULL,               //  45
    NULL,               //  46
    NULL,               //  47
    NULL,               //  48

    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as MAX_SELF_INDEXED_TYPE #define in record.h
    //         (see note above in record info table)

    //
    //  Pseudo record types
    //

    TkeyRecordWrite,    //  TKEY
    TsigRecordWrite,    //  TSIG

    //
    //  MS only types
    //

    FlatRecordWrite,    //  WINS
    NULL,               //  WINSR
};

//
//  End rrwire.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\rrread.c ===
/*++

Copyright (c) 1997-2001 Microsoft Corporation

Module Name:

    rrread.c

Abstract:

    Domain Name System (DNS) Library

    Read resource record from packet routines.

Author:

    Jim Gilroy (jamesg)     January, 1997

Revision History:

--*/


#include "local.h"



PDNS_RECORD
ARecordRead(
    IN OUT  PDNS_RECORD     pRR,
    IN      DNS_CHARSET     OutCharSet,
    IN OUT  PCHAR           pchStart,
    IN      PCHAR           pchData,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Read A record data from packet.

Arguments:

    pRR - RR context

    pchStart - start of DNS message

    pchData - ptr to packet RR data

    wLength - length of RR data in packet

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;

    if ( pchEnd - pchData != sizeof(IP_ADDRESS) )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }
    precord = Dns_AllocateRecord( sizeof(IP_ADDRESS) );
    if ( !precord )
    {
        return( NULL );
    }
    precord->Data.A.IpAddress = *(UNALIGNED DWORD *) pchData;

    return( precord );
}



PDNS_RECORD
PtrRecordRead(
    IN OUT  PDNS_RECORD     pRR,
    IN      DNS_CHARSET     OutCharSet,
    IN OUT  PCHAR           pchStart,
    IN      PCHAR           pchData,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Process PTR compatible record from wire.
    Includes: NS, PTR, CNAME, MB, MR, MG, MD, MF

Arguments:

    pRR - ptr to record with RR set context

    pchStart - start of DNS message

    pchData - ptr to RR data field

    pchEnd - ptr to byte after data field

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    WORD        bufLength;
    WORD        nameLength;
    CHAR        nameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];

    //
    //  PTR data is another domain name
    //

    pchData = Dns_ReadPacketName(
                nameBuffer,
                & nameLength,
                NULL,
                NULL,
                pchData,
                pchStart,
                pchEnd );

    if ( pchData != pchEnd )
    {
        DNS_PRINT(( "ERROR:  bad packet name.\n" ));
        SetLastError( DNS_ERROR_INVALID_NAME );
        return( NULL );
    }

    //
    //  determine required buffer length and allocate
    //

    bufLength = sizeof( DNS_PTR_DATA );
    bufLength += STR_BUF_SIZE_GIVEN_UTF8_LEN( nameLength, OutCharSet );

    precord = Dns_AllocateRecord( bufLength );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  write hostname into buffer, immediately following PTR data struct
    //

    precord->Data.PTR.pNameHost = (PCHAR)&precord->Data + sizeof( DNS_PTR_DATA );

    Dns_NameCopy(
        precord->Data.PTR.pNameHost,
        NULL,                           // no buffer length
        nameBuffer,
        nameLength,
        DnsCharSetWire,
        OutCharSet
        );

    return( precord );
}



PDNS_RECORD
SoaRecordRead(
    IN OUT  PDNS_RECORD     pRR,
    IN      DNS_CHARSET     OutCharSet,
    IN OUT  PCHAR           pchStart,
    IN      PCHAR           pchData,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Read SOA record from wire.

Arguments:

    pRR - ptr to record with RR set context

    pchStart - start of DNS message

    pchData - ptr to RR data field

    pchEnd - ptr to byte after data field

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    WORD        bufLength;
    PCHAR       pchendFixed;
    PDWORD      pdword;
    WORD        nameLength1;
    WORD        nameLength2;
    CHAR        nameBuffer1[ DNS_MAX_NAME_BUFFER_LENGTH ];
    CHAR        nameBuffer2[ DNS_MAX_NAME_BUFFER_LENGTH ];

    //
    //  read DNS names
    //

    pchData = Dns_ReadPacketName(
                nameBuffer1,
                & nameLength1,
                NULL,
                NULL,
                pchData,
                pchStart,
                pchEnd );
    if ( !pchData || pchData >= pchEnd )
    {
        DNS_PRINT(( "ERROR:  bad packet name.\n" ));
        SetLastError( DNS_ERROR_INVALID_NAME );
        return( NULL );
    }
    pchData = Dns_ReadPacketName(
                nameBuffer2,
                & nameLength2,
                NULL,
                NULL,
                pchData,
                pchStart,
                pchEnd );

    pchendFixed = pchData + SIZEOF_SOA_FIXED_DATA;
    if ( pchendFixed != pchEnd )
    {
        DNS_PRINT(( "ERROR:  bad packet name.\n" ));
        SetLastError( DNS_ERROR_INVALID_NAME );
        return( NULL );
    }

    //
    //  determine required buffer length and allocate
    //

    bufLength = sizeof( DNS_SOA_DATA );
    bufLength += STR_BUF_SIZE_GIVEN_UTF8_LEN( nameLength1, OutCharSet );
    bufLength += STR_BUF_SIZE_GIVEN_UTF8_LEN( nameLength2, OutCharSet );

    precord = Dns_AllocateRecord( bufLength );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  copy fixed fields
    //

    pdword = &precord->Data.SOA.dwSerialNo;
    while ( pchData < pchendFixed )
    {
        *pdword++ = FlipUnalignedDword( pchData );
        pchData += sizeof(DWORD);
    }

    //
    //  copy names into RR buffer
    //      - primary server immediately follows SOA data struct
    //      - responsible party follows primary server
    //

    precord->Data.SOA.pNamePrimaryServer =
                (PCHAR)&precord->Data + sizeof(DNS_SOA_DATA);

    precord->Data.SOA.pNameAdministrator =
                precord->Data.SOA.pNamePrimaryServer +
                Dns_NameCopy(
                        precord->Data.SOA.pNamePrimaryServer,
                        NULL,                           // no buffer length
                        nameBuffer1,
                        nameLength1,
                        DnsCharSetWire,
                        OutCharSet );

    Dns_NameCopy(
        precord->Data.SOA.pNameAdministrator,
        NULL,                           // no buffer length
        nameBuffer2,
        nameLength2,
        DnsCharSetWire,
        OutCharSet
        );

    return( precord );
}



PDNS_RECORD
TxtRecordRead(
    IN OUT  PDNS_RECORD     pRR,
    IN      DNS_CHARSET     OutCharSet,
    IN OUT  PCHAR           pchStart,
    IN      PCHAR           pchData,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Read TXT compatible record from wire.
    Includes: TXT, X25, HINFO, ISDN

Arguments:

    pRR - ptr to record with RR set context

    pchStart - start of DNS message

    pchData - ptr to RR data field

    pchEnd - ptr to byte after data field

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    WORD        bufLength;
    WORD        length;
    INT         count;
    PCHAR       pch;
    PCHAR       pchbuffer;
    PCHAR *     ppstring;

    //
    //  determine required buffer length and allocate
    //      - allocate space for each string
    //      - and ptr for each string
    //

    bufLength = 0;
    count = 0;
    pch = pchData;

    while ( pch < pchEnd )
    {
        length = (UCHAR) *pch++;
        pch += length;
        count++;
        bufLength += STR_BUF_SIZE_GIVEN_UTF8_LEN( length, OutCharSet );
    }
    if ( pch != pchEnd )
    {
        DNS_PRINT((
            "ERROR:  Invalid packet string data.\n"
            "\tpch = %p\n"
            "\tpchEnd = %p\n"
            "\tcount = %d\n"
            "\tlength = %d\n",
            pch, pchEnd, count, length
            ));
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }

    //  allocate

    bufLength += (WORD) DNS_TEXT_RECORD_LENGTH(count);
    precord = Dns_AllocateRecord( bufLength );
    if ( !precord )
    {
        return( NULL );
    }
    precord->Data.TXT.dwStringCount = count;

    //
    //  DCR:  if separate HINFO type -- handle this here
    //      - set pointer differently
    //      - validate string count found
    //

    //
    //  go back through list copying strings to buffer
    //      - ptrs to strings are saved to argv like data section
    //          ppstring walks through this section
    //      - first string written immediately following data section
    //      - each subsequent string immediately follows predecessor
    //          pchbuffer keeps ptr to position to write strings
    //

    pch = pchData;
    ppstring = (PCHAR *) precord->Data.TXT.pStringArray;
    pchbuffer = (PBYTE)ppstring + (count * sizeof(PCHAR));

    while ( pch < pchEnd )
    {
        length = (UCHAR) *pch++;
#if DBG
        DNS_PRINT((
             "Reading text at %p (len %d), to buffer at %p\n"
            "\tsave text ptr[%d] at %p in precord (%p)\n",
            pch,
            length,
            pchbuffer,
            (PCHAR *) ppstring - (PCHAR *) precord->Data.TXT.pStringArray,
            ppstring,
            precord ));
#endif
        *ppstring++ = pchbuffer;
        pchbuffer += Dns_StringCopy(
                        pchbuffer,
                        NULL,
                        pch,
                        length,
                        DnsCharSetWire,
                        OutCharSet );
        pch += length;
#if DBG
        DNS_PRINT((
            "Read text string %s\n",
            * (ppstring - 1)
            ));
        count--;
#endif
    }
    DNS_ASSERT( pch == pchEnd && count == 0 );

    return( precord );
}



PDNS_RECORD
MinfoRecordRead(
    IN OUT  PDNS_RECORD     pRR,
    IN      DNS_CHARSET     OutCharSet,
    IN OUT  PCHAR           pchStart,
    IN      PCHAR           pchData,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Read MINFO record from wire.

Arguments:

    pRR - ptr to record with RR set context

    pchStart - start of DNS message

    pchData - ptr to RR data field

    pchEnd - ptr to byte after data field

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    WORD        bufLength;
    WORD        nameLength1;
    WORD        nameLength2;
    CHAR        nameBuffer1[ DNS_MAX_NAME_BUFFER_LENGTH ];
    CHAR        nameBuffer2[ DNS_MAX_NAME_BUFFER_LENGTH ];

    //
    //  read DNS names
    //

    pchData = Dns_ReadPacketName(
                nameBuffer1,
                & nameLength1,
                NULL,
                NULL,
                pchData,
                pchStart,
                pchEnd );

    if ( !pchData || pchData >= pchEnd )
    {
        DNS_PRINT(( "ERROR:  bad packet name.\n" ));
        SetLastError( DNS_ERROR_INVALID_NAME );
        return( NULL );
    }
    pchData = Dns_ReadPacketName(
                nameBuffer2,
                & nameLength2,
                NULL,
                NULL,
                pchData,
                pchStart,
                pchEnd );

    if ( pchData != pchEnd )
    {
        DNS_PRINT(( "ERROR:  bad packet name.\n" ));
        SetLastError( DNS_ERROR_INVALID_NAME );
        return( NULL );
    }

    //
    //  determine required buffer length and allocate
    //

    bufLength = sizeof( DNS_MINFO_DATA );
    bufLength += STR_BUF_SIZE_GIVEN_UTF8_LEN( nameLength1, OutCharSet );
    bufLength += STR_BUF_SIZE_GIVEN_UTF8_LEN( nameLength2, OutCharSet );

    precord = Dns_AllocateRecord( bufLength );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  copy names into RR buffer
    //      - primary server immediately follows MINFO data struct
    //      - responsible party follows primary server
    //

    precord->Data.MINFO.pNameMailbox =
                    (PCHAR)&precord->Data + sizeof( DNS_MINFO_DATA );

    precord->Data.MINFO.pNameErrorsMailbox =
                precord->Data.MINFO.pNameMailbox +
                Dns_NameCopy(
                        precord->Data.MINFO.pNameMailbox,
                        NULL,                           // no buffer length
                        nameBuffer1,
                        nameLength1,
                        DnsCharSetWire,
                        OutCharSet );

    Dns_NameCopy(
        precord->Data.MINFO.pNameErrorsMailbox,
        NULL,                           // no buffer length
        nameBuffer2,
        nameLength2,
        DnsCharSetWire,
        OutCharSet
        );

    return( precord );
}



PDNS_RECORD
MxRecordRead(
    IN OUT  PDNS_RECORD     pRR,
    IN      DNS_CHARSET     OutCharSet,
    IN OUT  PCHAR           pchStart,
    IN      PCHAR           pchData,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Read MX compatible record from wire.
    Includes: MX, RT, AFSDB

Arguments:

    pRR - ptr to record with RR set context

    pchStart - start of DNS message

    pchData - ptr to RR data field

    pchEnd - ptr to byte after data field

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    WORD        bufLength;
    WORD        nameLength;
    WORD        wpreference;
    CHAR        nameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];

    //  read preference value

    wpreference = FlipUnalignedWord( pchData );
    pchData += sizeof(WORD);

    //  read mail exchange

    pchData = Dns_ReadPacketName(
                nameBuffer,
                & nameLength,
                NULL,
                NULL,
                pchData,
                pchStart,
                pchEnd );

    if ( pchData != pchEnd )
    {
        DNS_PRINT(( "ERROR:  bad packet name.\n" ));
        SetLastError( DNS_ERROR_INVALID_NAME );
        return( NULL );
    }

    //
    //  determine required buffer length and allocate
    //

    bufLength = sizeof( DNS_MX_DATA );
    bufLength += STR_BUF_SIZE_GIVEN_UTF8_LEN( nameLength, OutCharSet );

    precord = Dns_AllocateRecord( bufLength );
    if ( !precord )
    {
        return( NULL );
    }

    //  copy preference

    precord->Data.MX.wPreference = wpreference;

    //
    //  write exchange name into buffer, immediately following MX data struct
    //

    precord->Data.MX.pNameExchange = (PCHAR)&precord->Data + sizeof( DNS_MX_DATA );

    Dns_NameCopy(
        precord->Data.MX.pNameExchange,
        NULL,                           // no buffer length
        nameBuffer,
        nameLength,
        DnsCharSetWire,
        OutCharSet
        );

    return( precord );
}



PDNS_RECORD
FlatRecordRead(
    IN OUT  PDNS_RECORD     pRR,
    IN      DNS_CHARSET     OutCharSet,
    IN OUT  PCHAR           pchStart,
    IN      PCHAR           pchData,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Read memory copy compatible record from wire.
    Includes AAAA type.

Arguments:

    pRR - ptr to record with RR set context

    pchStart - start of DNS message

    pchData - ptr to RR data field

    pchEnd - ptr to byte after data field

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    WORD        bufLength;

    //
    //  determine required buffer length and allocate
    //

    bufLength = (WORD)(pchEnd - pchData);

    precord = Dns_AllocateRecord( bufLength );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  copy packet data to record
    //

    memcpy(
        & precord->Data,
        pchData,
        bufLength );

    return( precord );
}



PDNS_RECORD
SrvRecordRead(
    IN OUT  PDNS_RECORD     pRR,
    IN      DNS_CHARSET     OutCharSet,
    IN OUT  PCHAR           pchStart,
    IN      PCHAR           pchData,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Read SRV record from wire.

Arguments:

    pRR - ptr to record with RR set context

    pchStart - start of DNS message

    pchData - ptr to RR data field

    pchEnd - ptr to byte after data field

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    WORD        bufLength;
    WORD        nameLength;
    PCHAR       pchstart;
    CHAR        nameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];

    //
    //  read DNS target name
    //      - name is after fixed length interger data

    pchstart = pchData;
    pchData += SIZEOF_SRV_FIXED_DATA;

    pchData = Dns_ReadPacketName(
                nameBuffer,
                & nameLength,
                NULL,
                NULL,
                pchData,
                pchStart,
                pchEnd );

    if ( pchData != pchEnd )
    {
        DNS_PRINT(( "ERROR:  bad packet name.\n" ));
        SetLastError( DNS_ERROR_INVALID_NAME );
        return( NULL );
    }

    //
    //  determine required buffer length and allocate
    //

    bufLength = sizeof( DNS_SRV_DATA );
    bufLength += STR_BUF_SIZE_GIVEN_UTF8_LEN( nameLength, OutCharSet );

    precord = Dns_AllocateRecord( bufLength );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  copy integer fields
    //

    precord->Data.SRV.wPriority = FlipUnalignedWord( pchstart );
    pchstart += sizeof( WORD );
    precord->Data.SRV.wWeight = FlipUnalignedWord( pchstart );
    pchstart += sizeof( WORD );
    precord->Data.SRV.wPort = FlipUnalignedWord( pchstart );

    //
    //  copy target host name into RR buffer
    //      - write target host immediately following SRV data struct
    //

    precord->Data.SRV.pNameTarget = (PCHAR)&precord->Data + sizeof( DNS_SRV_DATA );

    Dns_NameCopy(
        precord->Data.SRV.pNameTarget,
        NULL,                           // no buffer length
        nameBuffer,
        nameLength,
        DnsCharSetWire,
        OutCharSet
        );

    return( precord );
}


PDNS_RECORD
AtmaRecordRead(
    IN OUT  PDNS_RECORD     pRR,
    IN      DNS_CHARSET     OutCharSet,
    IN OUT  PCHAR           pchStart,
    IN      PCHAR           pchData,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Read ATMA record from wire.

Arguments:

    pRR - ptr to record with RR set context

    pchStart - start of DNS message

    pchData - ptr to RR data field

    pchEnd - ptr to byte after data field

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    PCHAR       pchstart;
    WORD        wLen = (WORD) (pchEnd - pchData);

    pchstart = pchData;

    precord = Dns_AllocateRecord( sizeof( DNS_ATMA_DATA ) +
                                  DNS_ATMA_MAX_ADDR_LENGTH );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  copy ATMA integer fields
    //

    precord->Data.ATMA.AddressType = *pchstart;
    pchstart += sizeof( BYTE );

    if ( precord->Data.ATMA.AddressType == DNS_ATMA_FORMAT_E164 )
    {
        precord->wDataLength = wLen;

        if ( precord->wDataLength > DNS_ATMA_MAX_ADDR_LENGTH )
            precord->wDataLength = DNS_ATMA_MAX_ADDR_LENGTH;
    }
    else
    {
        precord->wDataLength = DNS_ATMA_MAX_ADDR_LENGTH;
    }

    //
    //  copy ATMA address field
    //
    memcpy( (PCHAR)&precord->Data.ATMA.Address,
            pchstart,
            precord->wDataLength - sizeof( BYTE ) );

    return( precord );
}



PDNS_RECORD
WksRecordRead(
    IN OUT  PDNS_RECORD     pRR,
    IN      DNS_CHARSET     OutCharSet,
    IN OUT  PCHAR           pchStart,
    IN      PCHAR           pchData,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Read Wks record data from packet.

Arguments:

    pRR - RR context

    pchStart - start of DNS message

    pchData - ptr to packet RR data field

    pchEnd - ptr to end of the data field

Return Value:

    Ptr to new record if successful.
    NULL on failure.

Author:
        Cameron Etezadi (camerone) - 1 May 1997
                        - for NS Lookup purposes, must add this function

NOTE:
        NONE of the getXXXbyYYY calls return unicode in their
        structures!  If we want the returned record to be unicode,
        then we must translate.  I am leaving it as char* for now,
        can go back later and fix this.
--*/
{
    PDNS_RECORD         pRecord;
    WORD                wLength;
    PCHAR               pStart;
    UCHAR               cProto;
    struct protoent *   proto;
    struct servent  *   serv;
    IP_ADDRESS          ipAddress;
    char *              szListOfServices;
    int                 nSize;
    char *              szProtoName;
    BYTE                cMask = 0x80;         // is this right?  Left to right?
    BYTE                cByteToCheck;
    int                 i;
    int                 j = 0;
    int                 nPortNumToQuery;
    int                 nCurLength = 1;
    char *              szTemp;

    pStart = pchData;
    if (! pStart)
    {
        DNS_PRINT(( "ERROR:  WKS did not get a record.\n" ));
        SetLastError( ERROR_INVALID_DATA );
        return(NULL);
    }

    //
    // Check size.  Must at least be an IP Address + a protocol
    //

    if ((pchEnd - pchData) < (sizeof(IP_ADDRESS) + sizeof(UCHAR)))
    {
        DNS_PRINT(( "ERROR:  WKS packet was too small for any data.\n" ));
        SetLastError( ERROR_INVALID_DATA );
        return(NULL);
    }

    //
    // Fill in the ip and protocol
    //

    ipAddress = *(UNALIGNED DWORD *)pStart;
    pStart += sizeof(IP_ADDRESS);
    cProto = *(UCHAR *)pStart;
    pStart += sizeof(UCHAR);

    //
    // Redefined the WKS structure to contain a listing
    // of space separated monikers for the services
    //
    // Get the protocol
    //

    proto = getprotobynumber(cProto);
    if (!proto)
    {
    DNS_PRINT(( "ERROR:  WKS failed to resolve protocol number to name.\n" ));
            SetLastError(ERROR_INVALID_DATA);
            return(NULL);
    }

    nSize = strlen(proto->p_name);
    szProtoName = ALLOCATE_HEAP((nSize + 1) * sizeof(char));

    if (!szProtoName)
    {
            DNS_PRINT(( "ERROR:  WKS could not allocate space for proto name\n"));
            SetLastError(ERROR_OUTOFMEMORY);
            return(NULL);
    }
    strcpy(szProtoName, proto->p_name);

    //
    // Now, the tricky part.  This is a bitmask.
    // I must translate to a string for each bit marked in the bitmask
    //

    DNS_PRINT(( "Now checking bitmask bits.\n"));

    szTemp = NULL;

    szListOfServices = ALLOCATE_HEAP(sizeof(char));
    if (!szListOfServices)
    {
            DNS_PRINT(( "ERROR:  WKS could not allocate space for services name\n"));
            SetLastError(ERROR_OUTOFMEMORY);
            FREE_HEAP(szProtoName);
            return(NULL);
    }
    else
    {
            *szListOfServices = '\0';
    }

    while (pStart < pchEnd)
    {
            cByteToCheck = *(BYTE *)pStart;

            for (i = 0; i < 8; i++)
            {
                    if (cByteToCheck & cMask)
                    {
                            // This is a service that is valid
                            nPortNumToQuery = i + (8 * j);
                            serv = getservbyport(htons((USHORT)nPortNumToQuery), szProtoName);
                            if (! serv)
                            {
                                    DNS_PRINT(( "ERROR: WKS found a port that could not be translated\n"));
                                    SetLastError(ERROR_INVALID_DATA);
                                    FREE_HEAP(szProtoName);
                                    FREE_HEAP(szListOfServices);
                                    return(NULL);
                            }
                            nSize = strlen(serv->s_name);
                            nCurLength = nCurLength + nSize + 1;

                            //
                            // Allocate more memory.  We need the + 1 here
                            // because we will overwrite the existing null with a strcat
                            // (removing the need) but use a space to separate items
                            //

                            szTemp = ALLOCATE_HEAP( nCurLength);

                            if (! szTemp)
                            {
                                    DNS_PRINT(( "ERROR:  WKS alloc space for services name\n" ));
                                    SetLastError(ERROR_OUTOFMEMORY);
                                    FREE_HEAP(szProtoName);
                                    FREE_HEAP(szListOfServices);
                                    return(NULL);
                            }
                            else
                            {
                                strcpy( szTemp, szListOfServices );
                                FREE_HEAP( szListOfServices );
                                szListOfServices = szTemp;
                                szTemp = NULL;
                            }

                            //
                            // Append the retrieved service name to the end of the list
                            //

                            strcat(szListOfServices, serv->s_name);
                            strcat(szListOfServices, " ");
                    }
                    cByteToCheck <<= 1;
            }

            //
            // Increment the "how many bytes have we done" offset counter
            //

            j++;
            pStart += sizeof(BYTE);
    }
    FREE_HEAP(szProtoName);

    //
    // Allocate a record and fill it in.
    //

    wLength = (WORD)(sizeof(IP_ADDRESS) + sizeof(UCHAR) + sizeof(int)
                    + (sizeof(char) * ++nCurLength));

    pRecord = Dns_AllocateRecord(wLength);
    if (! pRecord)
    {
            DNS_PRINT(( "ERROR: WKS failed to allocate record\n" ));
            SetLastError(ERROR_OUTOFMEMORY);
            FREE_HEAP(szListOfServices);
            return(NULL);
    }

    pRecord->Data.WKS.IpAddress = ipAddress;
    pRecord->Data.WKS.chProtocol = cProto;

    strcpy((char *)pRecord->Data.WKS.BitMask, szListOfServices);
    FREE_HEAP(szListOfServices);

    return(pRecord);
}



PDNS_RECORD
TkeyRecordRead(
    IN OUT  PDNS_RECORD     pRR,
    IN      DNS_CHARSET     OutCharSet,
    IN OUT  PCHAR           pchStart,
    IN      PCHAR           pchData,
    IN      PCHAR           pchEnd
    )
{
    PCHAR       pch;
    PDNS_RECORD prr;
    WORD        bufLength;
    WORD        keyLength;
    PCHAR       pchstart;
    CHAR        nameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];

    //
    //  allocate record
    //

    bufLength = sizeof( DNS_TKEY_DATA );

    prr = Dns_AllocateRecord( bufLength );
    if ( !prr )
    {
        return( NULL );
    }
    prr->wType = DNS_TYPE_TKEY;

    //
    //  algorithm name
    //

    pch = Dns_SkipPacketName(
                pchData,
                pchEnd );
    if ( !pch )
    {
        goto Formerr;
    }
    prr->Data.TKEY.pAlgorithmPacket = (PDNS_NAME) pchData;
    prr->Data.TKEY.cAlgNameLength = (UCHAR)(pch - pchData);
    prr->Data.TKEY.pNameAlgorithm = NULL;

#if 0
    //
    //  DEVNOTE:  currently not allocating data for TKEY, using internal pointers
    //
    //  allocated version
    //      note for this we won't have compression pointer which is fine
    //          since no name compression in data
    //      however function may need dummy to do the right thing
    //      should perhaps just pass in pchStart which can be dummy to
    //      real header
    //

    pch = Dns_ReadPacketNameAllocate(
                & prr->Data.TKEY.pNameAlgorithm,
                & nameLength,
                NULL,           // no previous name
                NULL,           // no previous name
                pchData,
                //pchStart,   // have no packet context
                NULL,
                pchEnd );
    if ( !pch )
    {
        DNSDBG( SECURITY, (
            "WARNING:  invalid TKEY algorithm name at %p.\n",
            pch ));
        goto Formerr;
    }
#endif

    //
    //  read fixed fields
    //

    if ( pch + SIZEOF_TKEY_FIXED_DATA >= pchEnd )
    {
        goto Formerr;
    }
    prr->Data.TKEY.dwCreateTime = InlineFlipUnalignedDword( pch );
    pch += sizeof(DWORD);
    prr->Data.TKEY.dwExpireTime = InlineFlipUnalignedDword( pch );
    pch += sizeof(DWORD);
    prr->Data.TKEY.wMode = InlineFlipUnalignedWord( pch );
    pch += sizeof(WORD);
    prr->Data.TKEY.wError = InlineFlipUnalignedWord( pch );
    pch += sizeof(WORD);
    prr->Data.TKEY.wKeyLength = keyLength = InlineFlipUnalignedWord( pch );
    pch += sizeof(WORD);

    //  now have key and other length to read

    if ( pch + keyLength + sizeof(WORD) > pchEnd )
    {
        goto Formerr;
    }

    //
    //  save ptr to key
    //

    prr->Data.TKEY.pKey = pch;
    pch += keyLength;

#if 0
    //
    //  copy key
    //

    pkey = ALLOCATE_HEAP( keyLength );
    if ( !pkey )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Failed;
    }

    RtlCopyMemory(
        pkey,
        pch,
        keyLength );

    pch += keyLength;
#endif

    //
    //  other data
    //

    prr->Data.TKEY.wOtherLength = keyLength = InlineFlipUnalignedWord( pch );
    pch += sizeof(WORD);

    if ( pch + keyLength > pchEnd )
    {
        goto Formerr;
    }
    if ( !keyLength )
    {
        prr->Data.TKEY.pOtherData = NULL;
    }
    else
    {
        prr->Data.TKEY.pOtherData = pch;
    }

    //  DCR_ENHANCE:  TKEY end-of-data verification

    //  returning TKEY with packet pointers as only point is processing

    prr->Data.TKEY.bPacketPointers = TRUE;

    //
    //  DCR_ENHANCE:  copied subfields, best to get here with stack record, then
    //      allocate RR containing subfields and copy everything

    return( prr );

Formerr:

    DNSDBG( ANY, (
        "ERROR:  FOMERR processing TKEY at %p in message\n",
        pchData ));

    //  free record
    //      if switch to allocated subfields need

    FREE_HEAP( prr );
    return( NULL );
}



PDNS_RECORD
TsigRecordRead(
    IN OUT  PDNS_RECORD     pRR,
    IN      DNS_CHARSET     OutCharSet,
    IN OUT  PCHAR           pchStart,
    IN      PCHAR           pchData,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Read SRV record from wire.

Arguments:

    pRR - ptr to record with RR set context

    pchStart - [OLD SEMANTICS, UNUSED] start of DNS message

     OVERLOAD pchStart!!
     Since we're stuck w/ this function signature, we'll overload
     the unused param pchStart to get the iKeyVersion.

    pchData - ptr to RR data field

    pchEnd - ptr to byte after data field


Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PCHAR       pch;
    PDNS_RECORD prr;
    WORD        bufLength;
    WORD        sigLength;
    PCHAR       pchstart;
    CHAR        nameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];

#if 0
    //  currently do not need versioning info
    //      if had to do again, should extract version then pass
    //      in another pRR field;  or send entire packet context
    //
    //  extract current TSIG version (from key string)
    //

    ASSERT( pRR );
    iKeyVersion = Dns_GetKeyVersion( pRR->pName );
#endif

    //
    //  allocate record
    //

    bufLength = sizeof( DNS_TSIG_DATA );

    prr = Dns_AllocateRecord( bufLength );
    if ( !prr )
    {
        return( NULL );
    }
    prr->wType = DNS_TYPE_TSIG;

    //
    //  algorithm name
    //

    pch = Dns_SkipPacketName(
                pchData,
                pchEnd );
    if ( !pch )
    {
        DNSDBG( SECURITY, (
            "WARNING:  invalid TSIG RR algorithm name.\n" ));
        goto Formerr;
    }

    prr->Data.TSIG.pAlgorithmPacket = (PDNS_NAME) pchData;
    prr->Data.TSIG.cAlgNameLength = (UCHAR)(pch - pchData);

#if 0
    //  allocated version
    //      note for this we won't have compression pointer which is fine
    //          since no name compression in data
    //      however function may need dummy to do the right thing
    //      should perhaps just pass in pchStart which can be dummy
    //      to real header
    //

    pch = Dns_ReadPacketNameAllocate(
                & prr->Data.TSIG.pNameAlgorithm,
                & nameLength,
                NULL,           // no previous name
                NULL,           // no previous name
                pchData,
                //pchStart,   // have no packet context
                NULL,
                pchEnd );
    if ( !pch )
    {
        DNSDBG( SECURITY, (
            "WARNING:  invalid TSIG RR algorithm name at %p.\n",
            pch ));
        goto Formerr;
    }
#endif

    //
    //  read fixed fields
    //

    if ( pch + SIZEOF_TSIG_FIXED_DATA >= pchEnd )
    {
        DNSDBG( SECURITY, (
            "ERROR:  TSIG has inadequate length for fixed fields.\n" ));
        goto Formerr;
    }

    //
    //  read time fields
    //      - 48 bit create time
    //      - 16 bit fudge
    //

    prr->Data.TSIG.i64CreateTime = InlineFlipUnaligned48Bits( pch );
    pch += sizeof(DWORD) + sizeof(WORD);

    prr->Data.TSIG.wFudgeTime = InlineFlipUnalignedWord( pch );
    pch += sizeof(WORD);

    //
    //  save sig length and sig pointer
    //

    prr->Data.TSIG.wSigLength = sigLength = InlineFlipUnalignedWord( pch );
    pch += sizeof(WORD);

    prr->Data.TSIG.pSignature = pch;
    pch += sigLength;

    //
    //  verify rest of fields within packet
    //      - signature
    //      - original XID
    //      - extended RCODE
    //      - other data length field
    //      - other data
    //

    if ( pch + SIZEOF_TSIG_POST_SIG_FIXED_DATA > pchEnd )
    {
        DNSDBG( SECURITY, (
            "ERROR:  TSIG has inadequate length for post-sig fixed fields.\n" ));
        goto Formerr;
    }

#if 0
    //
    //  note:  if this activated, would need to validate length pull
    //      sig ptr thing above and change validation to include sig length
    //
    //  copy sig
    //

    psig = ALLOCATE_HEAP( sigLength );
    if ( !psig )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Failed;
    }

    RtlCopyMemory(
        psig,
        pch,
        sigLength );

    pch += sigLength;
#endif

    //  original XID
    //      - leave in net order, as just replace in message for signing

    prr->Data.TSIG.wOriginalXid = READ_PACKET_NET_WORD( pch );
    pch += sizeof(WORD);

    DNSDBG( SECURITY, (
        "Read original XID <== 0x%x.\n",
        prr->Data.TSIG.wOriginalXid ));

    //  error field

    prr->Data.TSIG.wError = InlineFlipUnalignedWord( pch );
    pch += sizeof(WORD);

    //
    //  other data
    //

    prr->Data.TSIG.wOtherLength = sigLength = InlineFlipUnalignedWord( pch );
    pch += sizeof(WORD);

    if ( pch + sigLength > pchEnd )
    {
        DNSDBG( SECURITY, (
            "WARNING:  invalid TSIG RR sigLength %p.\n",
            pch ));
        goto Formerr;
    }
    if ( !sigLength )
    {
        prr->Data.TSIG.pOtherData = NULL;
    }
    else
    {
        prr->Data.TSIG.pOtherData = pch;
    }

    //  DCR_ENHANCE:  TSIG end-of-data verification

    //  returning TSIG with packet pointers as only point is processing

    prr->Data.TSIG.bPacketPointers = TRUE;

    //
    //  DCR_ENHANCE:  copied subfields, best to get here with stack record, then
    //      allocate RR containing subfields and copy everything

    return( prr );

Formerr:

    DNSDBG( ANY, (
        "ERROR:  FOMERR processing TSIG in message at %p\n" ));

    //  free record
    //      if switch to allocated subfields need

    FREE_HEAP( prr );

    return( NULL );
}


PDNS_RECORD
WinsRecordRead(
    IN OUT  PDNS_RECORD     pRR,
    IN      DNS_CHARSET     OutCharSet,
    IN OUT  PCHAR           pchStart,
    IN      PCHAR           pchData,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Read WINS record from wire.

Arguments:

    pRR - ptr to record with RR set context

    pchStart - start of DNS message

    pchData - ptr to RR data field

    pchEnd - ptr to byte after data field

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    WORD        bufLength;

    //
    //  determine required buffer length and allocate
    //

    bufLength = (WORD)(pchEnd - pchData);

    precord = Dns_AllocateRecord( bufLength );

    if ( !precord )
    {
        return( NULL );
    }

    //
    //  copy packet data to record
    //

    memcpy(
        & precord->Data,
        pchData,
        bufLength );

    precord->Data.WINS.dwMappingFlag =
        FlipUnalignedDword( &precord->Data.Wins.dwMappingFlag );
    precord->Data.WINS.dwLookupTimeout =
        FlipUnalignedDword( &precord->Data.Wins.dwLookupTimeout );
    precord->Data.WINS.dwCacheTimeout =
        FlipUnalignedDword( &precord->Data.Wins.dwCacheTimeout );
    precord->Data.WINS.cWinsServerCount =
        FlipUnalignedDword( &precord->Data.Wins.cWinsServerCount );

    return( precord );
}



//
//  RR read to packet jump table
//

RR_READ_FUNCTION   RRReadTable[] =
{
    NULL,               //  ZERO
    ARecordRead,        //  A
    PtrRecordRead,      //  NS
    PtrRecordRead,      //  MD
    PtrRecordRead,      //  MF
    PtrRecordRead,      //  CNAME
    SoaRecordRead,      //  SOA
    PtrRecordRead,      //  MB
    PtrRecordRead,      //  MG
    PtrRecordRead,      //  MR
    FlatRecordRead,     //  NULL
    WksRecordRead,      //  WKS
    PtrRecordRead,      //  PTR
    TxtRecordRead,      //  HINFO
    MinfoRecordRead,    //  MINFO
    MxRecordRead,       //  MX
    TxtRecordRead,      //  TXT
    MinfoRecordRead,    //  RP
    MxRecordRead,       //  AFSDB
    TxtRecordRead,      //  X25
    TxtRecordRead,      //  ISDN
    MxRecordRead,       //  RT
    NULL,               //  NSAP
    NULL,               //  NSAPPTR
    NULL,               //  SIG
    NULL,               //  KEY
    NULL,               //  PX
    NULL,               //  GPOS
    FlatRecordRead,     //  AAAA
    NULL,               //  LOC
    NULL,               //  NXT
    NULL,               //  EID   
    NULL,               //  NIMLOC
    SrvRecordRead,      //  SRV   
    AtmaRecordRead,     //  ATMA  
    NULL,               //  NAPTR 
    NULL,               //  KX    
    NULL,               //  CERT  
    NULL,               //  A6    
    NULL,               //  DNAME 
    NULL,               //  SINK  
    NULL,               //  OPT   
    NULL,               //  42
    NULL,               //  43
    NULL,               //  44
    NULL,               //  45
    NULL,               //  46
    NULL,               //  47
    NULL,               //  48

    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as MAX_SELF_INDEXED_TYPE #define in record.h
    //         (see note above in record info table)

    //
    //  Pseudo record types
    //

    TkeyRecordRead,     //  TKEY
    TsigRecordRead,     //  TSIG

    //
    //  MS only types
    //

    WinsRecordRead,     //  WINS
    NULL,               //  WINSR

};

//
//  End rrread.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\rrsort.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    rrsort.c

Abstract:

    Domain Name System (DNS) Library

    Copy resource record routines.

Author:

    Glenn Curtis (glennc)   December, 1997

Revision History:

    Jim Gilroy (jamesg)     March 2000 -- prioritize fix ups

--*/


#include "local.h"



BOOL
Dns_CompareIpAddresses(
    IN  IP_ADDRESS addr1,
    IN  IP_ADDRESS addr2,
    IN  IP_ADDRESS subnetMask
    )
{
    if ( subnetMask == INADDR_NONE ||
         subnetMask == INADDR_ANY )
    {
        if ( ((LPBYTE)&addr1)[0] == ((LPBYTE)&addr2)[0] )
        {
            if ( ((LPBYTE)&addr1)[1] == ((LPBYTE)&addr2)[1] )
            {
                if ( ((LPBYTE)&addr1)[2] == ((LPBYTE)&addr2)[2] )
                    return TRUE;
            }
        }
    }
    else
    {
        IP_ADDRESS MaskedAddr1 = addr1 & subnetMask;
        IP_ADDRESS MaskedAddr2 = addr2 & subnetMask;

        if ( ( addr1 & subnetMask ) == ( addr2 & subnetMask ) )
            return TRUE;
    }

    return FALSE;
}



PDNS_RECORD
Dns_PrioritizeSingleRecordSet(
    IN OUT  PDNS_RECORD         pRecordSet,
    IN      PDNS_ADDR_INFO      aAddressInfo,
    IN      DWORD               cAddressInfo
    )
/*++

Routine Description:

    Prioritize records in record set.

    Note:  REQUIRES single record set.
    Caller should use Dns_PrioritizeRecordList() for multiple lists.

Arguments:

    pRecordSet -- record set to prioritize

    aAddressInfo -- local address info to prioritize against

    cAddressInfo -- count of address info structs

Return Value:

    Ptr to prioritized set.
    Set is NOT new, but is same set as pRecordSet, with records shuffled.

--*/
{
    PDNS_RECORD     prr;
    PDNS_RECORD     pprevRR;
    PDNS_RECORD     prrUnmatched;
    DWORD           iter;
    DNS_LIST        listPrioritized;

    //
    //  DCR_FIX:  this whole routine is bogus
    //      - it lets you do no intermediate ranking
    //      it's binary and in order of IPs in list
    //
    //  need
    //      - knowledge of fast\slow interfaces (WAN for example)
    //  then
    //      - do best match on each RR in turn (rank it)
    //      - then arrange in rank order
    //

    //
    //  verify A records
    //
    //  DCR_ENHANCE:  prioritize A6 records
    //

    if ( !pRecordSet || pRecordSet->wType != DNS_TYPE_A )
    {
        return( pRecordSet );
    }

    //  init prioritized list

    DNS_LIST_STRUCT_INIT( listPrioritized );


    //
    //  loop through IP addresses to finding best matches
    //

    prrUnmatched = pRecordSet;

    for ( iter = 0; iter < cAddressInfo; iter++ )
    {
        pprevRR = NULL;
        prr = prrUnmatched;

        //
        //  loop through all RRs in set
        //

        while ( prr )
        {
            //  NOTE: no RR set check, we assume caller passes in single
            //  record set, so we don't have to call detach twice

            ASSERT( prr->wType == DNS_TYPE_A );

            if ( Dns_CompareIpAddresses(
                        aAddressInfo[iter].IpAddr,
                        prr->Data.A.IpAddress,
                        aAddressInfo[iter].SubnetMask ) )
            {
                //  found a match
                //      - cut from old list
                //      - add to new list

                PDNS_RECORD pnext = prr->pNext;

                prr->pNext = NULL;
                DNS_LIST_STRUCT_ADD( listPrioritized, prr );

                //  fix up old list

                if ( pprevRR )
                {
                    pprevRR->pNext = pnext;
                }
                else
                {
                    prrUnmatched = pnext;
                }
                prr = pnext;
            }
            else
            {
                pprevRR = prr;
                prr = prr->pNext;
            }
        }
    }

    //
    //  get matched list -- quick return if nothing matched
    //

    prr = (PDNS_RECORD) listPrioritized.pFirst;

    if ( !prr )
    {
        return( prrUnmatched );
    }

    //
    //  matched -- make sure first record has name
    //      - copy the name from the original first record
    //

    if ( !prr->pName  ||  !FLAG_FreeOwner(prr) )
    {
        PBYTE pnameCopy = NULL;

        pnameCopy = Dns_NameCopyAllocate(
                        pRecordSet->pName,
                        0,              // length unknown
                        RECORD_CHARSET( prr ),
                        RECORD_CHARSET( prr )
                        );
        if ( pnameCopy )
        {
            prr->pName = pnameCopy;
            FLAG_FreeOwner( prr ) = TRUE;
        }

        //  DCR_FIX0:  alloc failure leaves blank name
        //      best idea is
        //          - do single RR set
        //          - just grab (move) name from original first RR
        //          only check is must be external name
    }

    //
    //  tack unmatched records on end
    //

    DNS_LIST_STRUCT_ADD( listPrioritized, prrUnmatched );

    //
    //  return prioritized list
    //

    return  prr;
}



PDNS_RECORD
Dns_PrioritizeRecordSet(
    IN OUT  PDNS_RECORD         pRecordList,
    IN      PDNS_ADDR_INFO      aAddressInfo,
    IN      DWORD               cAddressInfo
    )
/*++

Routine Description:

    Prioritize records in record list.

    Record list may contain multiple record sets.
    Note, currently only prioritize A records, but may
    later do A6 also.

Arguments:

    pRecordList -- record list to prioritize

    aAddressInfo -- local address info to prioritize against

    cAddressInfo -- count of address info structs

Return Value:

    Ptr to prioritized list.
    List is NOT new, but is same list as pRecordList, with records shuffled.

--*/
{
    DNS_LIST        listPrioritized;
    PDNS_RECORD     prr;
    PDNS_RECORD     prrNextSet;

    if ( cAddressInfo == 0 ||
         ! pRecordList )
    {
        return pRecordList;
    }

    //  init prioritized list

    DNS_LIST_STRUCT_INIT( listPrioritized );

    //
    //  loop through all record sets prioritizing
    //      - whack off each RR set in turn
    //      - prioritize it (if possible)
    //      - pour it back into full list
    //      
    //

    prr = pRecordList;

    while ( prr )
    {
        prrNextSet = Dns_RecordSetDetach( prr );

        prr = Dns_PrioritizeSingleRecordSet(
                    prr,
                    aAddressInfo,
                    cAddressInfo );

        while ( prr )
        {
            register PDNS_RECORD pnextRR;

            pnextRR = prr->pNext; 
            DNS_LIST_STRUCT_ADD( listPrioritized, prr );
            prr = pnextRR;
        }

        prr = prrNextSet;
    }

    return  (PDNS_RECORD) listPrioritized.pFirst;
}



PDNS_RECORD
Dns_PrioritizeRecordSetEx(
    IN OUT  PDNS_RECORD         pRecordList,
    IN      PDNS_ADDR_ARRAY     pAddrArray
    )
/*++

Routine Description:

    Prioritize records in record list.

    Record list may contain multiple record sets.
    Note, currently only prioritize A records, but may
    later do A6 also.

Arguments:

    pRecordList -- record list to prioritize

    pAddrArray -- addr info array

Return Value:

    Ptr to prioritized list.
    List is NOT new, but is same list as pRecordList, with records shuffled.

--*/
{
    return   Dns_PrioritizeRecordSet(
                    pRecordList,
                    pAddrArray->AddrArray,
                    pAddrArray->AddrCount );
}

//
//  End rrsort.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\secutil.c ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    secutil.c

Abstract:

    Domain Name System (DNS) Library

    DNS secure update API.

Author:

    Jim Gilroy (jamesg)         January, 1998

Revision History:

--*/

#include "local.h"

//  security headers

//#define SECURITY_WIN32
//#include "sspi.h"
//#include "issperr.h"
//#include "rpc.h"
//#include "rpcndr.h"
//#include "ntdsapi.h"



//
//  Security utilities
//

DNS_STATUS
Dns_CreateSecurityDescriptor(
    OUT     PSECURITY_DESCRIPTOR *  ppSD,
    IN      DWORD                   AclCount,
    IN      PSID *                  SidPtrArray,
    IN      DWORD *                 AccessMaskArray
    )
/*++

Routine Description:

    Build security descriptor.

Arguments:

    ppSD -- addr to receive SD created

    AclCount -- number of ACLs to add

    SidPtrArray -- array of SIDs to create ACLs for

    AccessMaskArray -- array of access masks corresponding to SIDs

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    DNS_STATUS              status;
    DWORD                   i;
    DWORD                   lengthAcl;
    PSECURITY_DESCRIPTOR    psd = NULL;
    PACL                    pacl;

    //
    //  calculate space for SD
    //

    lengthAcl = sizeof(ACL);

    for ( i=0;  i<AclCount;  i++ )
    {
        if ( SidPtrArray[i] && AccessMaskArray[i] )
        {
            lengthAcl += GetLengthSid( SidPtrArray[i] ) + sizeof(ACCESS_ALLOWED_ACE);
        }
        ELSE
        {
            DNS_PRINT((
                "ERROR:  SD building with SID (%p) and mask (%p)\n",
                SidPtrArray[i],
                AccessMaskArray[i] ));
        }
    }

    //
    //  allocate SD
    //

    psd = (PSECURITY_DESCRIPTOR) ALLOCATE_HEAP(
                                    SECURITY_DESCRIPTOR_MIN_LENGTH + lengthAcl );
    if ( !psd )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Failed;
    }

    DNSDBG( INIT, (
        "Allocated SecurityDesc at %p of length %d\n",
        psd,
        SECURITY_DESCRIPTOR_MIN_LENGTH + lengthAcl ));

    //
    //  build ACL, adding ACE with desired access for each SID
    //

    pacl = (PACL) ((PBYTE)psd + SECURITY_DESCRIPTOR_MIN_LENGTH);

    if ( !InitializeAcl(
            pacl,
            lengthAcl,
            ACL_REVISION ) )
    {
        status = GetLastError();
        goto Failed;
    }

    for ( i=0;  i<AclCount;  i++ )
    {
        if ( SidPtrArray[i] && AccessMaskArray[i] )
        {
            if ( !AddAccessAllowedAce(
                    pacl,
                    ACL_REVISION,
                    AccessMaskArray[i],
                    SidPtrArray[i] ) )
            {
                status = GetLastError();
                DNSDBG( ANY, (
                    "ERROR:  failed adding ACE for SID %p, mask %p\n",
                    SidPtrArray[i],
                    AccessMaskArray[i] ));
                goto Failed;
            }
        }
    }

    //
    //  setup SD with ACL
    //

    if ( !InitializeSecurityDescriptor(
            psd,
            SECURITY_DESCRIPTOR_REVISION ))
    {
        status = GetLastError();
        goto Failed;
    }

    if ( !SetSecurityDescriptorDacl(
                psd,
                TRUE,       // ACL present
                pacl,
                FALSE       // explicit ACL, not defaulted
                ))
    {
        status = GetLastError();
        goto Failed;
    }

    *ppSD = psd;

    return( ERROR_SUCCESS );


Failed:

    ASSERT( status != ERROR_SUCCESS );
    *ppSD = NULL;
    FREE_HEAP( psd );

    return( status );
}



//
//  Credential utilities
//

PSEC_WINNT_AUTH_IDENTITY_W
Dns_AllocateAndInitializeCredentialsW(
    IN      PSEC_WINNT_AUTH_IDENTITY_W  pAuthIn
    )
/*++

Description:

    Allocates auth identity info and initializes pAuthIn info

Parameters:

    pAuthIn -- auth identity info

Return:

    Ptr to newly create credentials.
    NULL on failure.

--*/
{
    PSEC_WINNT_AUTH_IDENTITY_W pauthCopy = NULL;

    DNSDBG( SECURITY, (
        "Call Dns_AllocateAndInitializeCredentialsW\n" ));

    if ( !pAuthIn )
    {
        return NULL;
    }
    ASSERT( pAuthIn->Flags == SEC_WINNT_AUTH_IDENTITY_UNICODE );

    //
    //  allocate credentials struct
    //      - zero for simple cleanup on subfield alloc failures
    //

    pauthCopy = ALLOCATE_HEAP_ZERO( sizeof(SEC_WINNT_AUTH_IDENTITY_W) );
    if ( !pauthCopy )
    {
        return NULL;
    }

    //
    //  copy subfields
    //

    //  user

    pauthCopy->UserLength = pAuthIn->UserLength;
    if ( pAuthIn->UserLength )
    {
        ASSERT( pAuthIn->UserLength == wcslen(pAuthIn->User) );

        pauthCopy->User = ALLOCATE_HEAP( (pAuthIn->UserLength + 1) * sizeof(WCHAR) );
        if ( ! pauthCopy->User )
        {
            goto Failed;
        }
        wcscpy( pauthCopy->User, pAuthIn->User );
    }

    //  password
    //      - must allow zero length password

    pauthCopy->PasswordLength = pAuthIn->PasswordLength;

    if ( pAuthIn->PasswordLength  ||  pAuthIn->Password )
    {
        ASSERT( pAuthIn->PasswordLength == wcslen(pAuthIn->Password) );

        pauthCopy->Password = ALLOCATE_HEAP( (pAuthIn->PasswordLength + 1) * sizeof(WCHAR) );
        if ( ! pauthCopy->Password )
        {
            goto Failed;
        }
        wcscpy( pauthCopy->Password, pAuthIn->Password );
    }

    //  domain

    pauthCopy->DomainLength = pAuthIn->DomainLength;
    if ( pAuthIn->DomainLength )
    {
        ASSERT( pAuthIn->DomainLength == wcslen(pAuthIn->Domain) );

        pauthCopy->Domain = ALLOCATE_HEAP( (pAuthIn->DomainLength + 1) * sizeof(WCHAR) );
        if ( ! pauthCopy->Domain )
        {
            goto Failed;
        }
        wcscpy( pauthCopy->Domain, pAuthIn->Domain );
    }

    pauthCopy->Flags = pAuthIn->Flags;

    DNSDBG( SECURITY, (
        "Exit Dns_AllocateAndInitializeCredentialsW()\n" ));

    return pauthCopy;


Failed:

    //  allocation failure
    //      - cleanup what was allocated and get out

    Dns_FreeAuthIdentityCredentials( pauthCopy );
    return( NULL );
}



PSEC_WINNT_AUTH_IDENTITY_A
Dns_AllocateAndInitializeCredentialsA(
    IN      PSEC_WINNT_AUTH_IDENTITY_A  pAuthIn
    )
/*++

Description:

    Allocates auth identity info and initializes pAuthIn info

    Note:  it is more work to convert to unicode and call previous
        function than to call this one

Parameters:

    pAuthIn -- auth identity info

Return:

    Ptr to newly create credentials.
    NULL on failure.

--*/
{
    PSEC_WINNT_AUTH_IDENTITY_A pauthCopy = NULL;

    DNSDBG( SECURITY, (
        "Call Dns_AllocateAndInitializeCredentialsA\n" ));

    //
    //  allocate credentials struct
    //      - zero for simple cleanup on subfield alloc failures
    //

    if ( !pAuthIn )
    {
        return NULL;
    }
    ASSERT( pAuthIn->Flags == SEC_WINNT_AUTH_IDENTITY_ANSI );

    //
    //  allocate credentials struct
    //      - zero for simple cleanup on subfield alloc failures
    //

    pauthCopy = ALLOCATE_HEAP_ZERO( sizeof(SEC_WINNT_AUTH_IDENTITY_A) );
    if ( !pauthCopy )
    {
        return NULL;
    }

    //
    //  copy subfields
    //

    //  user

    pauthCopy->UserLength = pAuthIn->UserLength;
    if ( pAuthIn->UserLength )
    {
        ASSERT( pAuthIn->UserLength == strlen(pAuthIn->User) );

        pauthCopy->User = ALLOCATE_HEAP( (pAuthIn->UserLength + 1) * sizeof(CHAR) );
        if ( ! pauthCopy->User )
        {
            goto Failed;
        }
        strcpy( pauthCopy->User, pAuthIn->User );
    }

    //  password
    //      - must allow zero length password

    pauthCopy->PasswordLength = pAuthIn->PasswordLength;

    if ( pAuthIn->PasswordLength  ||  pAuthIn->Password )
    {
        ASSERT( pAuthIn->PasswordLength == strlen(pAuthIn->Password) );

        pauthCopy->Password = ALLOCATE_HEAP( (pAuthIn->PasswordLength + 1) * sizeof(CHAR) );
        if ( ! pauthCopy->Password )
        {
            goto Failed;
        }
        strcpy( pauthCopy->Password, pAuthIn->Password );
    }

    //  domain

    pauthCopy->DomainLength = pAuthIn->DomainLength;
    if ( pAuthIn->DomainLength )
    {
        ASSERT( pAuthIn->DomainLength == strlen(pAuthIn->Domain) );

        pauthCopy->Domain = ALLOCATE_HEAP( (pAuthIn->DomainLength + 1) * sizeof(CHAR) );
        if ( ! pauthCopy->Domain )
        {
            goto Failed;
        }
        strcpy( pauthCopy->Domain, pAuthIn->Domain );
    }

    pauthCopy->Flags = pAuthIn->Flags;

    DNSDBG( SECURITY, (
        "Exit Dns_AllocateAndInitializeCredentialsA()\n" ));

    return pauthCopy;


Failed:

    //  allocation failure
    //      - cleanup what was allocated and get out

    Dns_FreeAuthIdentityCredentials( pauthCopy );
    return( NULL );
}



VOID
Dns_FreeAuthIdentityCredentials(
    IN OUT  PVOID           pAuthIn
    )
/*++

Routine Description (Dns_FreeAuthIdentityCredentials):

    Free's structure given

Arguments:

    pAuthIn -- in param to free

Return Value:

    None

--*/
{
    register PSEC_WINNT_AUTH_IDENTITY_W pauthId;

    pauthId = (PSEC_WINNT_AUTH_IDENTITY_W) pAuthIn;
    if ( !pauthId )
    {
        return;
    }

    //
    //  assuming _W and _A structs are equivalent except
    //      for string types
    //

    ASSERT( sizeof( SEC_WINNT_AUTH_IDENTITY_W ) ==
            sizeof( SEC_WINNT_AUTH_IDENTITY_A ) );

    if ( pauthId->User )
    {
        FREE_HEAP ( pauthId->User );
    }
    if ( pauthId->Password )
    {
        FREE_HEAP ( pauthId->Password );
    }
    if ( pauthId->Domain )
    {
        FREE_HEAP ( pauthId->Domain );
    }

    FREE_HEAP ( pauthId );
}



PSEC_WINNT_AUTH_IDENTITY_W
Dns_AllocateCredentials(
    IN      PWSTR           pwsUserName,
    IN      PWSTR           pwsDomain,
    IN      PWSTR           pwsPassword
    )
/*++

Description:

    Allocates auth identity info and initializes pAuthIn info

Parameters:

    pwsUserName -- user name

    pwsDomain   -- domain name

    pwsPassword -- password

Return:

    Ptr to newly create credentials.
    NULL on failure.

--*/
{
    PSEC_WINNT_AUTH_IDENTITY_W  pauth = NULL;
    DWORD   length;
    PWSTR   pstr;


    DNSDBG( SECURITY, (
        "Enter Dns_AllocateCredentials()\n"
        "\tuser     = %S\n"
        "\tdomain   = %S\n"
        "\tpassword = %S\n",
        pwsUserName,
        pwsDomain,
        pwsPassword ));

    //
    //  allocate credentials struct
    //      - zero for simple cleanup on subfield alloc failures
    //

    pauth = ALLOCATE_HEAP_ZERO( sizeof(SEC_WINNT_AUTH_IDENTITY_W) );
    if ( !pauth )
    {
        return NULL;
    }

    //  copy user

    length = wcslen( pwsUserName );

    pstr = ALLOCATE_HEAP( (length + 1) * sizeof(WCHAR) );
    if ( ! pstr )
    {
        goto Failed;
    }
    wcscpy( pstr, pwsUserName );

    pauth->User = pstr;
    pauth->UserLength = length;

    //  copy domain

    length = wcslen( pwsDomain );

    pstr = ALLOCATE_HEAP( (length + 1) * sizeof(WCHAR) );
    if ( ! pstr )
    {
        goto Failed;
    }
    wcscpy( pstr, pwsDomain );

    pauth->Domain = pstr;
    pauth->DomainLength = length;

    //  copy password

    length = wcslen( pwsPassword );

    pstr = ALLOCATE_HEAP( (length + 1) * sizeof(WCHAR) );
    if ( ! pstr )
    {
        goto Failed;
    }
    wcscpy( pstr, pwsPassword );

    pauth->Password = pstr;
    pauth->PasswordLength = length;

    //  set to unicode

    pauth->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    DNSDBG( SECURITY, (
        "Exit Dns_AllocateCredentialsW( %p )\n",
        pauth ));

    return pauth;


Failed:

    //  allocation failure
    //      - cleanup what was allocated and get out

    Dns_FreeAuthIdentityCredentials( pauth );
    return( NULL );
}



//
//  DNS Credential utilities (unused)
//

DNS_STATUS
Dns_ImpersonateUser(
    IN      PDNS_CREDENTIALS    pCreds
    )
/*++

Routine Description:

    Impersonate a user.

Arguments:

    pCreds -- credentials of user to impersonate

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    DNS_STATUS  status = NO_ERROR;
    HANDLE      htoken;
    
    //
    //  attempt logon
    //

    if ( ! LogonUserW(
                pCreds->pUserName,
                pCreds->pDomain,
                pCreds->pPassword,
                LOGON32_LOGON_SERVICE,
                LOGON32_PROVIDER_WINNT50,
                &htoken ) )
    {
        status = GetLastError();
        if ( status == NO_ERROR )
        {
            status = ERROR_CANNOT_IMPERSONATE;
            DNS_ASSERT( FALSE );
        }

        DNSDBG( SECURITY, (
            "LogonUser() failed => %d\n"
            "\tuser     = %S\n"
            "\tdomain   = %S\n"
            "\tpassword = %S\n",
            status,
            pCreds->pUserName,
            pCreds->pDomain,
            pCreds->pPassword
            ));

        return status;
    }

    //
    //  impersonate
    //

    if ( !ImpersonateLoggedOnUser( htoken ) )
    {
        status = GetLastError();
        if ( status == NO_ERROR )
        {
            status = ERROR_CANNOT_IMPERSONATE;
            DNS_ASSERT( FALSE );
        }

        DNSDBG( SECURITY, (
            "ImpersonateLoggedOnUser() failed = %d\n",
            status ));
    }
    
    CloseHandle( htoken );

    DNSDBG( SECURITY, (
        "%s\n"
        "\tuser     = %S\n"
        "\tdomain   = %S\n"
        "\tpassword = %S\n",
        (status == NO_ERROR)
            ? "Successfully IMPERSONATING!"
            : "Failed IMPERSONATION!",
        pCreds->pUserName,
        pCreds->pDomain,
        pCreds->pPassword ));

    return  status;
}



VOID
Dns_FreeCredentials(
    IN      PDNS_CREDENTIALS    pCreds
    )
/*++

Routine Description:

    Free DNS credentials.

Arguments:

    pCreds -- credentials to free

Return Value:

    None

--*/
{
    //
    //  free subfields, then credentials
    //

    if ( !pCreds )
    {
        return;
    }

    if ( pCreds->pUserName )
    {
        FREE_HEAP( pCreds->pUserName );
    }
    if ( pCreds->pDomain )
    {
        FREE_HEAP( pCreds->pDomain );
    }
    if ( pCreds->pPassword )
    {
        FREE_HEAP( pCreds->pPassword );
    }
    FREE_HEAP( pCreds );
}



PDNS_CREDENTIALS
Dns_CopyCredentials(
    IN      PDNS_CREDENTIALS    pCreds
    )
/*++

Routine Description:

    Create copy of DNS credentials.

Arguments:

    pCreds -- credentials of user to copy

Return Value:

    Ptr to allocated copy of credentials.

--*/
{
    PDNS_CREDENTIALS    pnewCreds = NULL;
    PWSTR               pfield;

    //
    //  allocate credentials
    //      - copy of subfields
    //

    pnewCreds = (PDNS_CREDENTIALS) ALLOCATE_HEAP_ZERO( sizeof(*pnewCreds) );
    if ( !pnewCreds )
    {
        return( NULL );
    }

    pfield = (PWSTR) Dns_CreateStringCopy_W( pCreds->pUserName );
    if ( !pfield )
    {
        goto Failed;
    }
    pnewCreds->pUserName = pfield;

    pfield = (PWSTR) Dns_CreateStringCopy_W( pCreds->pDomain );
    if ( !pfield )
    {
        goto Failed;
    }
    pnewCreds->pDomain = pfield;

    pfield = (PWSTR) Dns_CreateStringCopy_W( pCreds->pPassword );
    if ( !pfield )
    {
        goto Failed;
    }
    pnewCreds->pPassword = pfield;

    return( pnewCreds );

Failed:

    Dns_FreeCredentials( pnewCreds );
    return( NULL );
}
    
//
//  End secutil.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\security.c ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    security.c

Abstract:

    Domain Name System (DNS) Library

    DNS secure update API.

Author:

    Jim Gilroy (jamesg)         January, 1998

Revision History:

--*/

#include "local.h"

#include "time.h"       // time() function

//  security headers

#define SECURITY_WIN32
#include "sspi.h"
#include "issperr.h"
#include "rpc.h"
#include "rpcndr.h"
#include "ntdsapi.h"

//  security definitions

#define SIG_LEN                 33
#define NAME_OWNER              "."         // root node
#define SEC_SUCCESS(Status)     ((Status) >= 0)
#define PACKAGE_NAME            L"negotiate"
#define NT_DLL_NAME             "security.dll"


//
//  Maximum length of data signed
//      - full packet, length, and sig
//
//  If a problem can use packet buffer length and sig length and allocate that
//

#define MAX_SIGNING_SIZE    (0x11000)


//
//  Global Sspi credentials handle
//

SECURITY_INTEGER g_SspiCredentialsLifetime = { 0, 0 };

CredHandle  g_hSspiCredentials;
TimeStamp   g_SspiCredentialsLifetime;

#define SSPI_INVALID_HANDLE(x)  \
        ( ((PSecHandle) (x))->dwLower == (ULONG_PTR) -1 && \
          ((PSecHandle) (x))->dwUpper == (ULONG_PTR) -1 )


//
//  DEV_NOTE:   Security ticket expiration
//
//  Security team is yet unsure about how to use the expiration time &
//  currently tix are valid forever. If it becomes invalid accept/init context
//  will re-nego a new one for us underneath so we should concern ourselves
//  at this point. Still, in principal they say we may need to worry about it
//  in the future...
//

#define SSPI_EXPIRED_HANDLE( x )           ( FALSE )

//
//  Currently only negotiate kerberos
//
//  DCR:  tie this to regkey, then set in init function
//

BOOL    g_NegoKerberosOnly = TRUE;


//
//  Context "key" for TKEYs
//

typedef struct _DNS_SECCTXT_KEY
{
    IP4_ADDRESS IpRemote;
    PSTR        pszTkeyName;
    PSTR        pszClientContext;
    PWSTR       pwsCredKey;
}
DNS_SECCTXT_KEY, *PDNS_SECCTXT_KEY;

//
//  Context name uniqueness
//
//  Tick helps insure uniqueness of context name

LONG    g_ContextCount = 0;

//  UUID insures uniqueness across IP reuse

CHAR    g_ContextUuid[ GUID_STRING_BUFFER_LENGTH ] = {0};


//
//  Security context request blob
//

typedef struct _DNS_SECCTXT_REQUEST
{
    LPSTR       pszServerName;
    PCHAR       pCredentials;
    LPSTR       pszContext;
    DWORD       dwFlag;
    IP_ADDRESS  ipServer;
    PIP_ARRAY   aipServer;
}
DNS_SECCTXT_REQUEST, *PDNS_SECCTXT_REQUEST;


//
//  Security context
//

typedef struct _DnsSecurityContext
{
    struct _DnsSecurityContext * pNext;

    struct _SecHandle   hSecHandle;

    DNS_SECCTXT_KEY     Key;
    CredHandle          CredHandle;

    //  context info

    DWORD               Version;
    WORD                TkeySize;

    //  context state

    BOOL                fNewConversation;
    BOOL                fNegoComplete;
    BOOL                fEchoToken;
    BOOL                fHaveSecHandle;
    BOOL                fHaveCredHandle;
    BOOL                fClient;

    //  timeout

    DWORD               dwCreateTime;
    DWORD               dwCleanupTime;
    DWORD               dwExpireTime;
}
SEC_CNTXT, *PSEC_CNTXT;


//
//  Security session info.
//  Held only during interaction, not cached
//

typedef struct _SecPacketInfo
{
    PSEC_CNTXT          pSecContext;

    SecBuffer           RemoteBuf;
    SecBuffer           LocalBuf;

    PDNS_HEADER         pMsgHead;
    PCHAR               pMsgEnd;

    PDNS_RECORD         pTsigRR;
    PDNS_RECORD         pTkeyRR;
    PCHAR               pszContextName;

    DNS_PARSED_RR       ParsedRR;

    //  client must save signature of query to verify sig on response

    PCHAR               pQuerySig;
    WORD                QuerySigLength;

    WORD                ExtendedRcode;

    //  version on TKEY \ TSIG

    DWORD               TkeyVersion;
}
SECPACK, *PSECPACK;


//
//  DNS API context
//

typedef struct _DnsAPIContext
{
    DWORD       Flags;
    PVOID       Credentials;
    PSEC_CNTXT  pSecurityContext;
}
DNS_API_CONTEXT, *PDNS_API_CONTEXT;


//
//  TCP timeout
//

#define DEFAULT_TCP_TIMEOUT         10
#define SECURE_UPDATE_TCP_TIMEOUT   (15)


//
//  Public security globals (exposed in dnslib.h)
//

BOOL    g_fSecurityPackageInitialized = FALSE;


//
//  Private security globals
//

HINSTANCE                   g_hLibSecurity;
PSecurityFunctionTableW     g_pSecurityFunctionTable;

DWORD   g_SecurityTokenMaxLength = 0;
DWORD   g_SignatureMaxLength = 0;


//
//  Security context caching
//

PSEC_CNTXT SecurityContextListHead = NULL;

CRITICAL_SECTION    SecurityContextListCS;

DWORD   SecContextCreate = 0;
DWORD   SecContextFree = 0;
DWORD   SecContextQueue = 0;
DWORD   SecContextQueueInNego = 0;
DWORD   SecContextDequeue = 0;
DWORD   SecContextTimeout = 0;

//
//  Security packet info memory tracking
//

DWORD   SecPackAlloc = 0;
DWORD   SecPackFree = 0;

//
//  Security packet verifications
//

DWORD   SecTkeyInvalid          = 0;
DWORD   SecTkeyBadTime          = 0;

DWORD   SecTsigFormerr          = 0;
DWORD   SecTsigEcho             = 0;
DWORD   SecTsigBadKey           = 0;
DWORD   SecTsigVerifySuccess    = 0;
DWORD   SecTsigVerifyFailed     = 0;

//
//  Hacks
//

//  Allowing old TSIG off by default, server can turn on.

BOOL    SecAllowOldTsig         = 0;    // 1 to allow old sigs, 2 any sig

DWORD   SecTsigVerifyOldSig     = 0;
DWORD   SecTsigVerifyOldFailed  = 0;


//
// TIME values
//
// (in seconds)
#define TIME_WEEK_S         604800
#define TIME_DAY_S          86400
#define TIME_10_HOUR_S      36000
#define TIME_8_HOUR_S       28800
#define TIME_4_HOUR_S       14400
#define TIME_HOUR_S         3600
#define TIME_10_MINUTE_S    600
#define TIME_5_MINUTE_S     300
#define TIME_3_MINUTE_S     160
#define TIME_MINUTE_S       60


//  Big Time skew on by default


DWORD   SecBigTimeSkew          = TIME_DAY_S;
DWORD   SecBigTimeSkewBypass    = 0;


//
//  TSIG - GSS alogrithm
//

#define W2K_GSS_ALGORITHM_NAME_PACKET           ("\03gss\011microsoft\03com")
#define W2K_GSS_ALGORITHM_NAME_PACKET_LENGTH    (sizeof(W2K_GSS_ALGORITHM_NAME_PACKET))

#define GSS_ALGORITHM_NAME_PACKET               ("\010gss-tsig")
#define GSS_ALGORITHM_NAME_PACKET_LENGTH        (sizeof(GSS_ALGORITHM_NAME_PACKET))

PCHAR   g_pAlgorithmNameW2K     = W2K_GSS_ALGORITHM_NAME_PACKET;
PCHAR   g_pAlgorithmNameCurrent = GSS_ALGORITHM_NAME_PACKET;

//
//  TKEY context name
//

#define MAX_CONTEXT_NAME_LENGTH     DNS_MAX_NAME_BUFFER_LENGTH

//
//  TKEY/TSIG versioning
//
//  Win2K shipped with some deviations from current the GSS-TSIG RFC.
//  Specifically
//      - client sent TKEY query in Answer section instead of addtional
//      - alg name was "gss.microsoft.com", new name is "gss-tsig"
//      - client would reuse context based on process id, rather than
//          forcing unique context
//      - signing didn't include length when including previous sig
//
//  Defining versioning -- strictly internal to this module
//

#define TKEY_VERSION_W2K            3
#define TKEY_VERSION_WHISTLER_BETA  4
#define TKEY_VERSION_XP_BAD_SIG     5
#define TKEY_VERSION_XP_RC1         6
#define TKEY_VERSION_XP             7

#define TKEY_VERSION_CURRENT        TKEY_VERSION_XP


//
//  TKEY expiration
//      - cleanup if inactive for 3 minutes
//      - max kept alive four hours then must renego
//

#define TKEY_CLEANUP_INTERVAL       (TIME_3_MINUTE_S)

//
//  DCR_FIX:  Nego time issue (GM vs local time)
//
//  Currently netlogon seems to run in GM time, so we limit our time
//  check to one day. Later on, we should move it back to 1 hour.
//

#define TKEY_EXPIRE_INTERVAL        (TIME_DAY_S)
#define TSIG_EXPIRE_INTERVAL        (TIME_10_HOUR_S)

#define TKEY_MAX_EXPIRE_INTERVAL    (TIME_4_HOUR_S)

#define MAX_TIME_SKEW               (TIME_DAY_S)


//
//  ntdsapi.dll loading
//      - for making SPN for DNS server
//

#define NTDSAPI_DLL_NAMEW   L"ntdsapi.dll"
#define MAKE_SPN_FUNC       "DsClientMakeSpnForTargetServerW"

FARPROC g_pfnMakeSpn = NULL;

HMODULE g_hLibNtdsa = NULL;


//
//  Private protos
//

VOID
DnsPrint_SecurityContextList(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PSEC_CNTXT      pListHead
    );

VOID
DnsPrint_SecurityContext(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PSEC_CNTXT      pSecCtxt
    );

VOID
DnsPrint_SecurityPacketInfo(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PSECPACK        pSecPack
    );


#if DBG

#define DnsDbg_SecurityContextList(a,b) DnsPrint_SecurityContextList(DnsPR,NULL,a,b)
#define DnsDbg_SecurityContext(a,b)     DnsPrint_SecurityContext(DnsPR,NULL,a,b)
#define DnsDbg_SecurityPacketInfo(a,b)  DnsPrint_SecurityPacketInfo(DnsPR,NULL,a,b)

#else

#define DnsDbg_SecurityContextList(a,b)
#define DnsDbg_SecurityContext(a,b)
#define DnsDbg_SecurityPacketInfo(a,b)

#endif

#define Dns_FreeSecurityPacketInfo(p)   Dns_CleanupSecurityPacketInfoEx((p),TRUE)
#define Dns_ResetSecurityPacketInfo(p)  Dns_CleanupSecurityPacketInfoEx((p),FALSE)



DNS_STATUS
Dns_LoadNtdsapiProcs(
    VOID
    );

PWSTR
MakeCredKey(
    IN      PCHAR           pCreds
    );

BOOL
CompareCredKeys(
    IN      PWSTR           pwsCredKey1,
    IN      PWSTR           pwsCredKey2
    );

DNS_STATUS
Dns_AcquireCredHandle(
    OUT     PCredHandle     pCredHandle,
    IN      BOOL            fDnsServer,
    IN      PCHAR           pCreds
    );


//
//  Security session packet info
//

PSECPACK
Dns_CreateSecurityPacketInfo(
    VOID
    )
/*++

Routine Description:

    Create security packet info structure.

Arguments:

    None.

Return Value:

    Ptr to new zeroed security packet info.

--*/
{
    PSECPACK    psecPack;

    psecPack = (PSECPACK) ALLOCATE_HEAP_ZERO( sizeof(SECPACK) );
    if ( !psecPack )
    {
        return( NULL );
    }
    SecPackAlloc++;

    return( psecPack );
}



VOID
Dns_InitSecurityPacketInfo(
    OUT     PSECPACK        pSecPack,
    IN      PSEC_CNTXT      pSecCtxt
    )
/*++

Routine Description:

    Init security packet info for given context

Arguments:
    
Return Value:

    None.

--*/
{
    //  clear previous info

    RtlZeroMemory(
        pSecPack,
        sizeof(SECPACK) );

    //  set context ptr

    pSecPack->pSecContext = pSecCtxt;
}



VOID
Dns_CleanupSecurityPacketInfoEx(
    IN OUT  PSECPACK        pSecPack,
    IN      BOOL            fFree
    )
/*++

Routine Description:

    Cleans up security packet info.

Arguments:

    pSecPack -- ptr to security packet info to clean up

Return Value:

    None.

--*/
{
    if ( !pSecPack )
    {
        return;
    }

    if ( pSecPack->pszContextName )
    {
        FREE_HEAP( pSecPack->pszContextName );
    }

    if ( pSecPack->pTsigRR )
    {
        FREE_HEAP( pSecPack->pTsigRR );
        //Dns_RecordFree( pSecPack->pTsigRR );
    }
    if ( pSecPack->pTkeyRR )
    {
        FREE_HEAP( pSecPack->pTkeyRR );
        //Dns_RecordFree( pSecPack->pTkeyRR );
    }

    if ( pSecPack->pQuerySig )
    {
        FREE_HEAP( pSecPack->pQuerySig );
    }
    if ( pSecPack->LocalBuf.pvBuffer )
    {
        FREE_HEAP( pSecPack->LocalBuf.pvBuffer );
    }

    if ( fFree )
    {
        FREE_HEAP( pSecPack );
        SecPackFree++;
    }
    else
    {
        RtlZeroMemory(
            pSecPack,
            sizeof(SECPACK) );
    }
}



VOID
DnsPrint_SecurityPacketInfo(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PSECPACK        pSecPack
    )
{
    if ( !pSecPack )
    {
        PrintRoutine(
            pPrintContext,
            "%s NULL security context\n",
            pszHeader ? pszHeader : "" );
        return;
    }

    DnsPrint_Lock();

    PrintRoutine(
        pPrintContext,
        "%s\n"
        "\tptr              = %p\n"
        "\tpSec Context     = %p\n"
        "\tContext Name     = %s\n"
        "\tVersion          = %d\n"
        "\tpTsigRR          = %p\n"
        "\tpTkeyRR          = %p\n"
        "\tExt RCODE        = %d\n"
        "\tremote buf       = %p\n"
        "\t  length         = %d\n"
        "\tlocal buf        = %p\n"
        "\t  length         = %d\n",
        pszHeader ? pszHeader : "Security packet info:",
        pSecPack,
        pSecPack->pSecContext,
        pSecPack->pszContextName,
        pSecPack->TkeyVersion,
        pSecPack->pTsigRR,
        pSecPack->pTkeyRR,
        pSecPack->ExtendedRcode,
        pSecPack->RemoteBuf.pvBuffer,
        pSecPack->RemoteBuf.cbBuffer,
        pSecPack->LocalBuf.pvBuffer,
        pSecPack->LocalBuf.cbBuffer
        );

    DnsPrint_ParsedRecord(
        PrintRoutine,
        pPrintContext,
        "Parsed Security RR",
        & pSecPack->ParsedRR
        );

    if ( pSecPack->pTsigRR )
    {
        DnsPrint_Record(
            PrintRoutine,
            pPrintContext,
            "TSIG RR",
            pSecPack->pTsigRR,
            NULL                // no previous record
            );
    }
    if ( pSecPack->pTkeyRR )
    {
        DnsPrint_Record(
            PrintRoutine,
            pPrintContext,
            "TKEY RR",
            pSecPack->pTkeyRR,
            NULL                // no previous record
            );
    }

    if ( pSecPack->pSecContext )
    {
        DnsPrint_SecurityContext(
            PrintRoutine,
            pPrintContext,
            "Associated Security Context",
            pSecPack->pSecContext
            );
    }

    DnsPrint_Unlock();
}



//
//  Security context routines
//

PSEC_CNTXT
Dns_CreateSecurityContext(
    VOID
    )
/*++

Routine Description:

    Allocate a new security context blob.

Arguments:

    None.

Return Value:

    Ptr to new context.
    NULL on alloc failure.

--*/
{
    PSEC_CNTXT psecCtxt;

    psecCtxt = (PSEC_CNTXT) ALLOCATE_HEAP_ZERO( sizeof(SEC_CNTXT) );
    if ( !psecCtxt )
    {
        return( NULL );
    }
    psecCtxt->fNewConversation = TRUE;
    SecContextCreate++;

    return( psecCtxt );
}



VOID
Dns_FreeSecurityContext(
    IN OUT  PSEC_CNTXT          pSecCtxt
    )
/*++

Routine Description:

    Cleans up security session data.

Arguments:

    pSecCtxt -- handle to context to clean up

Return Value:

    TRUE if successful
    FALSE otherwise

--*/
{
    PSEC_CNTXT   psecCtxt = (PSEC_CNTXT)pSecCtxt;

    if ( !psecCtxt )
    {
        return;
    }

    if ( psecCtxt->Key.pszTkeyName )
    {
        FREE_HEAP( psecCtxt->Key.pszTkeyName );
    }
    if ( psecCtxt->Key.pszClientContext )
    {
        FREE_HEAP( psecCtxt->Key.pszClientContext );
    }
    if ( psecCtxt->Key.pwsCredKey )
    {
        FREE_HEAP( psecCtxt->Key.pwsCredKey );
    }
    if ( psecCtxt->fHaveSecHandle )
    {
        g_pSecurityFunctionTable->DeleteSecurityContext( &psecCtxt->hSecHandle );
    }
    if ( psecCtxt->fHaveCredHandle )
    {
        g_pSecurityFunctionTable->FreeCredentialsHandle( &psecCtxt->CredHandle );
    }
    FREE_HEAP( psecCtxt );

    SecContextFree++;
}



//
//  Security context list routines
//
//  Server side may have multiple security sessions active and does
//      not maintain client state on a thread's stack, so must have
//      a list to hold previous session info.
//

PSEC_CNTXT
Dns_DequeueSecurityContextByKey(
    IN      DNS_SECCTXT_KEY     Key,
    IN      BOOL                fComplete
    )
/*++

Routine Description:

    Get security session context from session list based on key.

Arguments:

    Key -- session key

    fComplete -- TRUE if need fully negotiated context
                 FALSE if still in negotiation

Return Value:

    Handle to security session context, if found.
    NULL if no context for key.

--*/
{
    PSEC_CNTXT  pcur;
    PSEC_CNTXT  pback;
    DWORD       currentTime = Dns_GetCurrentTimeInSeconds();

    DNSDBG( SECURITY, (
        "DequeueSecurityContext()\n"
        "\tIP           = %s\n"
        "\tTKEY name    = %s\n"
        "\tcontext name = %s\n"
        "\tcred string  = %S\n",
        IP_STRING( Key.IpRemote ),
        Key.pszTkeyName,
        Key.pszClientContext,
        Key.pwsCredKey ));

    EnterCriticalSection( &SecurityContextListCS );
    IF_DNSDBG( SECURITY )
    {
        DnsDbg_SecurityContextList(
            "Before Get",
            SecurityContextListHead );
    }

    pback = (PSEC_CNTXT) &SecurityContextListHead;

    while ( pcur = pback->pNext )
    {
        //  if context is stale -- delete it

        if ( pcur->dwCleanupTime < currentTime )
        {
            pback->pNext = pcur->pNext;
            SecContextTimeout++;
            Dns_FreeSecurityContext( pcur );
            continue;
        }

        //  match context to key
        //      - must match IP
        //      - server side must match TKEY name
        //      - client side must match context key

        if ( Key.IpRemote == pcur->Key.IpRemote
                &&
             (  ( Key.pszTkeyName &&
                  Dns_NameCompare_UTF8(
                        Key.pszTkeyName,
                        pcur->Key.pszTkeyName ))
                    ||
                ( Key.pszClientContext &&
                  Dns_NameCompare_UTF8(
                        Key.pszClientContext,
                        pcur->Key.pszClientContext )) )
                &&
             CompareCredKeys(
                Key.pwsCredKey,
                pcur->Key.pwsCredKey ) )
        {
            //  if expect completed context, ignore incomplete
            //
            //  DCR:  should dump once RFC compliant

            if ( fComplete && !pcur->fNegoComplete )
            {
                DNSDBG( ANY, (
                    "WARNING:  Requested dequeue security context still in nego!\n"
                    "\tmatching key         %s %s\n"
                    "\tcontext complete     = %d\n"
                    "\trequest fComplete    = %d\n",
                    Key.pszTkeyName,
                    IP_STRING( Key.IpRemote ),
                    pcur->fNegoComplete,
                    fComplete ));

                pback = pcur;
                continue;
            }

            //  detach context
            //  DCR:  could ref count context and leave in
            //      not sure this adds much -- how many process do MT
            //      updates in same security context

            pback->pNext = pcur->pNext;
            SecContextDequeue++;
            break;
        }

        //  not found -- continue search

        pback = pcur;
    }

    IF_DNSDBG( SECURITY )
    {
        DnsDbg_SecurityContextList(
            "After Dequeue",
            SecurityContextListHead );
    }
    LeaveCriticalSection( &SecurityContextListCS);

    return( pcur );
}



PSEC_CNTXT
Dns_FindOrCreateSecurityContext(
    IN      DNS_SECCTXT_KEY    Key
    )
/*++

Routine Description:

    Find and extract existing security context from list,
        OR
    create a new one.

Arguments:

    Key -- key for context

Return Value:

    Ptr to security context.

--*/
{
    PSEC_CNTXT  psecCtxt;


    DNSDBG( SECURITY, (
        "Dns_FindOrCreateSecurityContext()\n" ));

    //  find existing context

    psecCtxt = Dns_DequeueSecurityContextByKey( Key, FALSE );
    if ( psecCtxt )
    {
        return  psecCtxt;
    }

    //
    //  create context
    //
    //  server's will come with complete TKEY name from packet
    //  client's will come with specific context name, we must
    //      generate globally unique name
    //          - context count
    //          - tick count
    //          - UUID
    //
    //  implementation notes:
    //  -   UUID to make sure we're unique across IP reuse
    //
    //  -   UUID and timer enforce uniqueness across process shutdown
    //      and restart (even if generation UUID fails, you'll be at
    //      a different tick count)
    //
    //  -   context count enforces uniqueness within process
    //      - interlock allows us to eliminate thread id
    //      - even with thread id, we'd still need this anyway
    //      (without interlock) to back up timer since GetTickCount()
    //      is "chunky" and a thread could concievably not "tick"
    //      between contexts on the same thread if they were dropped
    //      before going to the wire
    //
    //

    psecCtxt = Dns_CreateSecurityContext();
    if ( psecCtxt )
    {
        PSTR    pstr;
        PSTR    pnameTkey;
        CHAR    nameBuf[ DNS_MAX_NAME_BUFFER_LENGTH ];

        pnameTkey = Key.pszTkeyName;

        if ( Key.pszClientContext )
        {
            LONG  count = InterlockedIncrement( &g_ContextCount );

            //
            //  Note: it is important that this string is in canonical
            //  form as per RFC 2535 section 8.1 - basically this means
            //  lower case.
            //

            _snprintf(
                nameBuf,
                MAX_CONTEXT_NAME_LENGTH,    
                "%s.%d-%x.%s",
                Key.pszClientContext,
                count,
                GetTickCount(),
                g_ContextUuid );
    
            nameBuf[ DNS_MAX_NAME_BUFFER_LENGTH ] = 0;
            pnameTkey = nameBuf;

            pstr = Dns_CreateStringCopy_A( Key.pszClientContext );
            if ( !pstr )
            {
                goto Failed;
            }
            psecCtxt->Key.pszClientContext = pstr;
        }

        //  remote IP

        psecCtxt->Key.IpRemote = Key.IpRemote;

        //  TKEY name

        pstr = Dns_CreateStringCopy_A( pnameTkey );
        if ( !pstr )
        {
            goto Failed;
        }
        psecCtxt->Key.pszTkeyName = pstr;

        //  cred key

        if ( Key.pwsCredKey )
        {
            pstr = (PSTR) Dns_CreateStringCopy_W( Key.pwsCredKey );
            if ( !pstr )
            {
                goto Failed;
            }
            psecCtxt->Key.pwsCredKey = (PWSTR) pstr;
        }
    }

    IF_DNSDBG( SECURITY )
    {
        DnsDbg_SecurityContextList(
            "New security context:",
            psecCtxt );
    }
    return( psecCtxt );


Failed:

    //  memory allocation failure
    
    Dns_FreeSecurityContext( psecCtxt );
    return  NULL;
}



VOID
Dns_EnlistSecurityContext(
    IN OUT  PSEC_CNTXT          pSecCtxt
    )
/*++

Routine Description:

    Enlist a security context.
    Note this does NOT create the context it simply enlists a current one.

Arguments:

    Key -- key for context

Return Value:

    Handle to security context.

--*/
{
    PSEC_CNTXT  pnew = (PSEC_CNTXT)pSecCtxt;
    DWORD       currentTime;

    //
    //  catch queuing up some bogus blob
    //

    ASSERT( pnew->fNewConversation == TRUE || pnew->fNewConversation == FALSE );
    ASSERT( pnew->dwCreateTime < pnew->dwCleanupTime || pnew->dwCleanupTime == 0 );
    ASSERT( pnew->Key.pszTkeyName );
    ASSERT( pnew->Key.IpRemote );

    //
    //  reset expire time so keep context active if in use
    //
    //  DCR_FIX:  need expire time to use min of TKEY and fixed hard timeout
    //

    currentTime = Dns_GetCurrentTimeInSeconds();
    if ( !pnew->dwCreateTime )
    {
        pnew->dwCreateTime = currentTime;
    }
    if ( !pnew->dwExpireTime )
    {
        pnew->dwExpireTime = currentTime + TKEY_MAX_EXPIRE_INTERVAL;
    }

    //
    //  cleanup after interval not used
    //  unconditionally maximum of cleanup interval.
    //

    pnew->dwCleanupTime = currentTime + TKEY_CLEANUP_INTERVAL;

    EnterCriticalSection( &SecurityContextListCS );

    pnew->pNext = SecurityContextListHead;
    SecurityContextListHead = pnew;

    SecContextQueue++;
    if ( !pnew->fNegoComplete )
    {
        SecContextQueueInNego++;
    }

    IF_DNSDBG( SECURITY )
    {
        DnsDbg_SecurityContextList(
            "After add",
            SecurityContextListHead );
    }
    LeaveCriticalSection( &SecurityContextListCS );
}



VOID
Dns_TimeoutSecurityContextList(
    IN      BOOL            fClearList
    )
/*++

Routine Description:

    Eliminate old session data.

Arguments:

    fClearList -- TRUE to delete all, FALSE to timeout

Return Value:

    None.

--*/
{
    PSEC_CNTXT  pcur;
    PSEC_CNTXT  pback;
    DWORD       currentTime;

    if ( fClearList )
    {
        currentTime = MAXDWORD;
    }
    else
    {
        currentTime = Dns_GetCurrentTimeInSeconds();
    }

    EnterCriticalSection( &SecurityContextListCS );

    pback = (PSEC_CNTXT) &SecurityContextListHead;

    while ( pcur = pback->pNext )
    {
        //  if haven't reached cleanup time, keep in list

        if ( pcur->dwCleanupTime > currentTime )
        {
            pback = pcur;
            continue;
        }

        //  entry has expired
        //      - cut from list
        //      - free the session context

        pback->pNext = pcur->pNext;

        SecContextTimeout++;
        Dns_FreeSecurityContext( pcur );
    }

    ASSERT( !fClearList || SecurityContextListHead==NULL );

    LeaveCriticalSection( &SecurityContextListCS );
}



VOID
Dns_FreeSecurityContextList(
    VOID
    )
/*++

Routine Description ():

    Free all security contexts in global list

Arguments:

    None

Return Value:

    None

--*/
{
    PSEC_CNTXT  pcur;
    PSEC_CNTXT  ptmp;
    INT         countDelete = 0;

    DNSDBG( SECURITY, (
        "Dns_FreeSecurityContextList()\n" ));

    EnterCriticalSection( &SecurityContextListCS );

    IF_DNSDBG( SECURITY )
    {
        DnsDbg_SecurityContextList(
            "Before Get",
            SecurityContextListHead );
    }

    //  if empty list -- done

    if ( !SecurityContextListHead )
    {
        DNSDBG( SECURITY, (
            "Attempt to free empty SecurityCOntextList.\n" ));
        goto Done;
    }

    //
    // Cycle through list & free all entries
    //

    pcur = SecurityContextListHead->pNext;

    while( pcur )
    {
        ptmp = pcur;
        pcur = pcur->pNext;
        Dns_FreeSecurityContext( ptmp );
        countDelete++;
    }

Done:

    SecContextDequeue += countDelete;

    LeaveCriticalSection( &SecurityContextListCS );

    DNSDBG( SECURITY, (
        "Dns_FreeSecurityContextList emptied %d entries\n",
        countDelete ));
}



VOID
DnsPrint_SecurityContext(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PSEC_CNTXT      pSecCtxt
    )
{
    PSEC_CNTXT   pctxt = (PSEC_CNTXT)pSecCtxt;

    if ( !pSecCtxt )
    {
        PrintRoutine(
            pPrintContext,
            "%s NULL security context\n",
            pszHeader ? pszHeader : "" );
        return;
    }

    DnsPrint_Lock();

    PrintRoutine(
        pPrintContext,
        "%s\n"
        "\tptr          = %p\n"
        "\tpnext        = %p\n"
        "\tkey          = %s %s %s\n"
        "\tversion      = %d\n"
        "\tCred Handle  = %p %p\n"
        "\tSec Handle   = %p %p\n"
        "\tcreate time  = %d\n"
        "\texpire time  = %d\n"
        "\tcleanup time = %d\n"
        "\thave cred    = %d\n"
        "\thave sec     = %d\n"
        "\tnew con      = %d\n"
        "\tinitialized  = %d\n"
        "\techo token   = %d\n",
        pszHeader ? pszHeader : "Security context:",
        pctxt,
        pctxt->pNext,
        IP_STRING(pctxt->Key.IpRemote),
            pctxt->Key.pszTkeyName,
            pctxt->Key.pszClientContext,
        pctxt->Version,
        pctxt->CredHandle.dwUpper,
        pctxt->CredHandle.dwLower,
        pctxt->hSecHandle.dwUpper,
        pctxt->hSecHandle.dwLower,
        pctxt->dwCreateTime,
        pctxt->dwExpireTime,
        pctxt->dwCleanupTime,
        pctxt->fHaveCredHandle,
        pctxt->fHaveSecHandle,
        pctxt->fNewConversation,
        pctxt->fNegoComplete,
        pctxt->fEchoToken
        );

    if ( !pctxt->fHaveCredHandle )
    {
        PrintRoutine(
            pPrintContext,
            "Global cred handle\n"
            "\tCred Handle  = %p %p\n",
            g_hSspiCredentials.dwUpper,
            g_hSspiCredentials.dwLower );
    }

    DnsPrint_Unlock();
}



VOID
DnsPrint_SecurityContextList(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PSEC_CNTXT      pList
    )
{
    PSEC_CNTXT   pcur;

    EnterCriticalSection( &SecurityContextListCS );
    DnsPrint_Lock();

    pcur = pList;

    PrintRoutine(
        pPrintContext,
        "Security context list %s\n"
        "\tList ptr = %p\n"
        "%s",
        pszHeader,
        pList,
        pcur ? "" : "\tList EMPTY\n" );

    while ( pcur != NULL )
    {
        DnsPrint_SecurityContext(
            PrintRoutine,
            pPrintContext,
            NULL,
            pcur );
        pcur = pcur->pNext;
    }
    PrintRoutine(
        pPrintContext,
        "*** End security context list ***\n" );

    DnsPrint_Unlock();
    LeaveCriticalSection( &SecurityContextListCS );
}



//
//  Security utils
//

DNS_STATUS
MakeKerberosName(
    OUT     PWSTR           pwsKerberosName,
    IN      PSTR            pszDnsName,
    IN      BOOL            fTrySpn
    )
/*++

Routine Description:

    Map DNS name to kerberos name for security lookup.

Arguments:

    pszDnsName -- DNS name

    pwsKerberosName -- buffer to recv kerb name

    fSPNFormat -- use SPN format

Return Value:

    ERROR_SUCCESS successful.
    ErrorCode on failure.

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;
    WCHAR       nameBuf[ DNS_MAX_NAME_BUFFER_LENGTH ];
    INT         nameLength;
    PWCHAR      pwMachine;
    PWCHAR      pwDomain;
    PWCHAR      pwTmp;


    DNSDBG( SECURITY, (
        "MakeKerberosName(%s, %p, %d)\n",
        pszDnsName,
        pwsKerberosName,
        fTrySpn
        ));

    if ( !pszDnsName ||  !pwsKerberosName )
    {
       DNS_ASSERT( FALSE );
       return ERROR_INVALID_PARAMETER;
    }

    //
    //  convert to wide char
    //      - note, function returns byte count, not status
    //

    if ( ! Dns_NameCopyWireToUnicode(
                nameBuf,
                pszDnsName ) )
    {
        status = GetLastError();
        DNSDBG( SECURITY, (
            "ERROR:  Bad DNS name %s failed conversion to unicode\n",
            pszDnsName ));
        DNS_ASSERT( FALSE );
        goto Cleanup;
    }

    //
    //  build SPN name
    //

    if ( fTrySpn  &&  g_pfnMakeSpn )
    {
        nameLength = MAX_PATH;

        status = (DNS_STATUS) g_pfnMakeSpn(
                                    DNS_SPN_SERVICE_CLASS_W,
                                    nameBuf,
                                    & nameLength,
                                    pwsKerberosName );
        DNSDBG( SECURITY, (
            "Translated (via DsSpn) %s into Kerberos name: %S\n",
            pszDnsName,
            pwsKerberosName ));
        goto Cleanup;
    }

    //
    //  no SPN -- build kerberos name
    //      - convert FQDN to domain\machine$
    //      compatible with old servers that did not register SPNs.
    //

    {
        PWSTR   pdomain;
        PWSTR   pdump;

        //
        //  break into host\domain name pieces
        //
    
        pdomain = Dns_GetDomainName_W( nameBuf );
        if ( !pdomain )
        {
            status = ERROR_INVALID_DATA;
            goto Cleanup;
        }
        *(pdomain-1) = 0;
    
        //  break off single label domain name
    
        pdump = Dns_GetDomainName_W( pdomain );
        if ( !pdump )
        {
            status = ERROR_INVALID_DATA;
            goto Cleanup;
        }
        *(pdump-1) = 0;
    
        //  format as <domain>\<machine>$
    
        wcscpy( pwsKerberosName, pdomain );
        wcscat( pwsKerberosName, L"\\" );
        wcscat( pwsKerberosName, nameBuf );
        wcscat( pwsKerberosName, L"$" );
    
        //
        //  note:  tried this and got linker error
        //

        wsprintfW(
            pwsKerberosName,
            L"%S\\%ws$",
            pdomain,
            nameBuf );
    }

    DNSDBG( SECURITY, (
        "Translated %s into Kerberos name: %S\n",
        pszDnsName,
        pwsKerberosName ));

Cleanup:

    return status;
}



DNS_STATUS
Dns_LoadNtdsapiProcs(
    VOID
    )
/*++

Routine Description:

    Dynamically loads SPN function from Ntdsapi.dll

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    HMODULE     hlib = NULL;
    DNS_STATUS  status = ERROR_SUCCESS;

    //
    //  Note, function assumes MT safe.
    //  At single thread startup or protected by CS
    //

    //
    //  return if module already loaded
    //

    if ( g_hLibNtdsa )
    {
        ASSERT( g_pfnMakeSpn );
        return  ERROR_SUCCESS;
    }

    //
    //  load ntdsapi.dll -- for getting SPNs
    //

    hlib = LoadLibraryExW(
                  NTDSAPI_DLL_NAMEW,
                  NULL,
                  0 );          // Previously used: DONT_RESOLVE_DLL_REFERENCES
    if ( !hlib )
    {
        return  GetLastError();
    }

    //
    //  get SPN function
    //

    g_pfnMakeSpn = GetProcAddress( hlib, MAKE_SPN_FUNC );
    if ( !g_pfnMakeSpn )
    {
        status = GetLastError();
        FreeLibrary( hlib );
    }
    else
    {
        g_hLibNtdsa = hlib;
    }

    return ERROR_SUCCESS;
}



DNS_STATUS
Dns_StartSecurity(
    IN      BOOL        fProcessAttach
    )
/*++

Routine Description:

    Initialize the security package for dynamic update.

    Note, this function is self-initializing, BUT is not
    MT safe, unless called at process attach.

Parameters:

    fProcessAttach - TRUE if called during process attach
        in that case we initialize only the CS
        otherwise we initialize completely

Return Value:

    TRUE if successful.
    FALSE otherwise, error code available from GetLastError().

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;
    static BOOL     fcsInitialized = FALSE;

    //
    //  DCR_PERF:  ought to have one CS for dnslib, initialized on a DnsLib
    //      init function;  then it is always valid and can be used
    //      whenever necessary
    //

    if ( fProcessAttach || !fcsInitialized )
    {
        fcsInitialized = TRUE;
        InitializeCriticalSection( &SecurityContextListCS );
        SecInvalidateHandle( &g_hSspiCredentials );
        g_fSecurityPackageInitialized = FALSE;
    }

    //
    //  do full security package init
    //

    if ( !fProcessAttach )
    {
        EnterCriticalSection( &SecurityContextListCS );

        if ( !g_fSecurityPackageInitialized )
        {
            status = Dns_InitializeSecurityPackage(
                            &g_SecurityTokenMaxLength,
                            FALSE   // client, not DNS server
                            );
            if ( status == ERROR_SUCCESS )
            {
                g_fSecurityPackageInitialized = TRUE;

                //  load ntdsapi.dll for SPN building

                status = Dns_LoadNtdsapiProcs();
                ASSERT( ERROR_SUCCESS == status );
            }
        }

        LeaveCriticalSection( &SecurityContextListCS );
    }

    return( status );
}



DNS_STATUS
Dns_StartServerSecurity(
    VOID
    )
/*++

Routine Description:

    Startup server security.

    Note this function is NOT MT-safe.
    Call it once on load, or protect call with a CS.

Arguments:

    None.

Return Value:

    TRUE if security is initialized.
    FALSE if security initialization failure.

--*/
{
    DNS_STATUS  status;

    if ( g_fSecurityPackageInitialized )
    {
        return( ERROR_SUCCESS );
    }

    //
    //  init globals
    //      - this protects us on server restart
    //

    g_SecurityTokenMaxLength = 0;
    g_SignatureMaxLength = 0;

    SecurityContextListHead = NULL;
    g_pfnMakeSpn = NULL;

    //
    // CS is initialized before init sec pak in order to
    // have it done similarly to the client code.
    //

    InitializeCriticalSection( &SecurityContextListCS );

    status = Dns_InitializeSecurityPackage(
                    &g_SecurityTokenMaxLength,
                    TRUE
                    );
    if ( status == ERROR_SUCCESS )
    {
        g_fSecurityPackageInitialized = TRUE;
    }
    else
    {
        ASSERT ( g_fSecurityPackageInitialized == FALSE );
        DeleteCriticalSection( &SecurityContextListCS );
    }
    return( status );
}



DNS_STATUS
Dns_InitializeSecurityPackage(
    OUT     PDWORD          pdwMaxMessage,
    IN      BOOL            fDnsServer
    )
/*++

Routine Description:

    Load and initialize the security package.

    Note, call this function at first UPDATE.
    MUST NOT call this function at DLL init, this becomes possibly cyclic.

Parameters:

    pdwMaxMessage - addr to recv max security token length

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    SECURITY_STATUS status;
    FARPROC         psecurityEntry;
    PSecPkgInfoW    pkgInfo;
    UUID            uuid;

    //
    //  init SSPI credentials handle (regardless of package state)
    //

    SecInvalidateHandle( &g_hSspiCredentials );

    //
    //  load and initialize the appropriate SSP
    //

    g_hLibSecurity = LoadLibrary( NT_DLL_NAME );
    if ( !g_hLibSecurity )
    {
        status = GetLastError();
        DNS_PRINT(( "Couldn't load dll: %u\n", status ));
        goto Failed;
    }

    psecurityEntry = GetProcAddress( g_hLibSecurity, SECURITY_ENTRYPOINTW );
    if ( !psecurityEntry )
    {
        status = GetLastError();
        DNS_PRINT(( "Couldn't get sec init routine: %u\n", status ));
        goto Failed;
    }

    g_pSecurityFunctionTable = (PSecurityFunctionTableW) psecurityEntry();
    if ( !g_pSecurityFunctionTable )
    {
        status = ERROR_DLL_INIT_FAILED;
        DNS_PRINT(( "ERROR:  unable to get security function table.\n"));
        goto Failed;
    }

    //  Get info for security package (negotiate)
    //      - need max size of tokens

    status = g_pSecurityFunctionTable->QuerySecurityPackageInfoW( PACKAGE_NAME, &pkgInfo );
    if ( !SEC_SUCCESS(status) )
    {
        DNS_PRINT((
            "Couldn't query package info for %s, error %u\n",
            PACKAGE_NAME,
            status ));
        goto Failed;
    }

    g_SecurityTokenMaxLength = pkgInfo->cbMaxToken;

    g_pSecurityFunctionTable->FreeContextBuffer( pkgInfo );

    //
    //  Note: This is the maximum addition to the size of the
    //  DNS update packet. (excluding the signature)
    //
    //  DCR_CLEANUP:  what is the point of this?  as we have set a global
    //

    if ( pdwMaxMessage)
    {
        *pdwMaxMessage = g_SecurityTokenMaxLength;
    }

    //
    //  Acquire process credentials handle from SSPI
    //

    status = Dns_RefreshSSpiCredentialsHandle(
                    fDnsServer,
                    NULL );

    if ( !SEC_SUCCESS(status) )
    {
        DNSDBG( SECURITY, (
           "Error 0xX: Cannot acquire credentials handle\n",
            status ));
        ASSERT ( FALSE );
        goto Failed;
    }

    //
    //  Get a unique id
    //      - even if call fails, just take what's in stack
    //      and make a string out of it -- we just want the string
    //

    UuidCreateSequential( &uuid );

    DnsStringPrint_Guid(
        g_ContextUuid,
        & uuid );

    DNSDBG( SECURITY, (
        "Started security package (%S)\n"
        "\tmax token = %d\n",
        PACKAGE_NAME,
        g_SecurityTokenMaxLength ));

    return( ERROR_SUCCESS );

Failed:

    if ( status == ERROR_SUCCESS )
    {
        status = ERROR_DLL_INIT_FAILED;
    }
    return( status );
}



VOID
Dns_TerminateSecurityPackage(
    VOID
    )
/*++

Routine Description:

    Terminate security package on shutdown.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD status=ERROR_SUCCESS;

    if ( g_fSecurityPackageInitialized )
    {

#if 0
//
// it turns out that the security lib get unloaded before in some cases
// us for some reason (alhtough we explicity tells it to unload
// after us).
// We will never alloc over ourselves anyway (see startup).
//
        if ( !SSPI_INVALID_HANDLE ( &g_hSspiCredentials ) )
        {
            //
            // Free previously allocated handle
            //

            status = g_pSecurityFunctionTable->FreeCredentialsHandle(
                                                   &g_hSspiCredentials );
            if ( !SEC_SUCCESS(status) )
            {
                DNSDBG( SECURITY, (
                    "Error <0x%x>: Cannot free credentials handle\n",
                    status ));
            }
        }

        // continue regardless.
        SecInvalidateHandle( &g_hSspiCredentials );

        Dns_FreeSecurityContextList();
#endif

        if ( g_hLibSecurity )
        {
            FreeLibrary( g_hLibSecurity );
        }
        if ( g_hLibNtdsa )
        {
            FreeLibrary( g_hLibNtdsa );
        }
    }

    DeleteCriticalSection( &SecurityContextListCS );
}



DNS_STATUS
Dns_InitClientSecurityContext(
    IN OUT  PSECPACK        pSecPack,
    IN      LPSTR           pszNameServer,
    OUT     PBOOL           pfDoneNegotiate
    )
/*++

Routine Description:

    Initialize client security context building security token to send.

    On first pass, creates context blob (and returns handle).
    On second pass, uses server context to rebuild negotiated token.

Arguments:

    pSecPack -- ptr to security info for packet

    pszNameServer -- DNS server to nego with

    pCreds -- credentials (if given)

    pfDoneNegotiate -- addr to set if done with negotiation
        TRUE if done with nego
        FALSE if continuing

Return Value:

    ERROR_SUCCESS -- if done
    DNS_STATUS_CONTINUE_NEEDED -- if continue respone to client is needed
    ErrorCode on failure.

--*/
{
    //PSECPACK            pSecPack = (PSECPACK)hSecPack;
    SECURITY_STATUS     status;
    PSEC_CNTXT          psecCtxt;
    BOOL                fcreatedContext = FALSE;
    TimeStamp           lifetime;
    SecBufferDesc       outBufDesc;
    SecBufferDesc       inBufDesc;
    ULONG               contextAttributes = 0;
    WCHAR               wszKerberosName[ MAX_PATH ];
    PCredHandle         pcredHandle;

    DNSDBG( SECURITY, ( "Enter InitClientSecurityContext()\n" ));
    IF_DNSDBG( SECURITY )
    {
        DnsDbg_SecurityPacketInfo(
            "InitClientSecurityContext() at top.\n",
            pSecPack );
    }

    //
    //  if not existing context, create new one
    //
    //  note:  if want to create new here, then need context key
    //

    psecCtxt = pSecPack->pSecContext;
    if ( !psecCtxt )
    {
        DNSDBG( SECURITY, (
           "ERROR: Called into Dns_InitClientSecurityContext w/ no security context!!\n" ));
        ASSERT ( FALSE );
        return( DNS_ERROR_NO_MEMORY );
    }

    //
    //  client completed initialization
    //      - if server sent back token, should be echo of client's token
    //

    if ( psecCtxt->fNegoComplete )
    {
        if ( pSecPack->LocalBuf.pvBuffer &&
            pSecPack->LocalBuf.cbBuffer == pSecPack->RemoteBuf.cbBuffer &&
            RtlEqualMemory(
                pSecPack->LocalBuf.pvBuffer,
                pSecPack->RemoteBuf.pvBuffer,
                pSecPack->LocalBuf.cbBuffer
                ) )
        {
            return( ERROR_SUCCESS );
        }
        DNSDBG( ANY, (
            "InitClientSecurityContext() on already negotiated context %p\n"
            "\tserver buffer is NOT echo of buffer sent!\n",
            psecCtxt ));

        return( DNS_ERROR_RCODE_BADKEY );
    }


    //
    //  prepare output buffer, allocate if necessary
    //      - security token will be written to this buffer
    //

    if ( !pSecPack->LocalBuf.pvBuffer )
    {
        PCHAR   pbuf;

        ASSERT( g_SecurityTokenMaxLength );
        pbuf = (PVOID) ALLOCATE_HEAP( g_SecurityTokenMaxLength );
        if ( !pbuf )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Failed;
        }
        pSecPack->LocalBuf.pvBuffer     = pbuf;
        pSecPack->LocalBuf.BufferType   = SECBUFFER_TOKEN;
        //pSecPack->LocalBuf.cbBuffer     = g_SecurityTokenMaxLength;
    }

    //  set\reset buffer length

    pSecPack->LocalBuf.cbBuffer = g_SecurityTokenMaxLength;

    outBufDesc.ulVersion    = 0;
    outBufDesc.cBuffers     = 1;
    outBufDesc.pBuffers     = &pSecPack->LocalBuf;

    //  DCR_PERF:  zeroing buffer is unnecessary -- remove

    RtlZeroMemory(
        pSecPack->LocalBuf.pvBuffer,
        pSecPack->LocalBuf.cbBuffer );

    //
    //  if have response from server, then send as input buffer
    //

    if ( pSecPack->RemoteBuf.pvBuffer )
    {
        ASSERT( !psecCtxt->fNewConversation );
        ASSERT( pSecPack->RemoteBuf.cbBuffer );
        ASSERT( pSecPack->RemoteBuf.BufferType == SECBUFFER_TOKEN );

        inBufDesc.ulVersion    = 0;
        inBufDesc.cBuffers     = 1;
        inBufDesc.pBuffers     = & pSecPack->RemoteBuf;
    }
    ELSE_ASSERT( psecCtxt->fNewConversation );

    //
    //  get server in SPN format
    //
    //  DCR_PERF:  SPN name lookup duplicated on second pass
    //      - if know we are synchronous could keep
    //      - or could save to packet stuct (but then would have to alloc)

    status = MakeKerberosName(
                wszKerberosName,
                pszNameServer,
                TRUE
                );
    if ( status != ERROR_SUCCESS )
    {
        status = ERROR_INVALID_DATA;
        goto Failed;
    }

    IF_DNSDBG( SECURITY )
    {
        DNS_PRINT((
            "Before InitClientSecurityContextW().\n"
            "\ttime (ms) = %d\n"
            "\tkerb name = %S\n",
            GetCurrentTime(),
            wszKerberosName ));
        DnsDbg_SecurityPacketInfo(
            "Before call to InitClientSecurityContextW().\n",
            pSecPack );
    }

    //
    //  cred handle
    //

    pcredHandle = &g_hSspiCredentials;
    if ( psecCtxt->fHaveCredHandle )
    {
        pcredHandle = &psecCtxt->CredHandle;
    }

    status = g_pSecurityFunctionTable->InitializeSecurityContextW(
                    pcredHandle,
                    psecCtxt->fNewConversation
                        ?   NULL
                        :   &psecCtxt->hSecHandle,
                    wszKerberosName,
                    ISC_REQ_REPLAY_DETECT |
                        ISC_REQ_DELEGATE |
                        ISC_REQ_MUTUAL_AUTH,            // context requirements
                    0,                                  // reserved1
                    SECURITY_NATIVE_DREP,
                    psecCtxt->fNewConversation
                        ?   NULL
                        :   &inBufDesc,
                    0,                                  // reserved2
                    & psecCtxt->hSecHandle,
                    & outBufDesc,
                    & contextAttributes,
                    & lifetime
                    );

    DNSDBG( SECURITY, (
        "After InitClientSecurityContextW().\n"
        "\ttime (ms)    = %d\n"
        "\tkerb name    = %S\n"
        "\tcontext attr = %08x\n"
        "\tstatus       = %d (%08x)\n",
        GetCurrentTime(),
        wszKerberosName,
        contextAttributes,
        status, status ));

    //
    //  failed?
    //      - if unable to get kerberos (mutual auth) then bail
    //      this eliminates trying to do nego when in workgroup
    //

    if ( !SEC_SUCCESS(status) ||
        ( status == SEC_E_OK &&
            !(contextAttributes & ISC_REQ_MUTUAL_AUTH) ) )
    {
        DNS_PRINT((
            "InitializeSecurityContextW() failed: %08x %u\n"
            "\tContext Attributes   = %p\n"
            "\tTokenMaxLength       = %d\n"
            "\tSigMaxLength         = %d\n"
            "\tPackageInitialized   = %d\n"
            "\tlifetime             = %d\n",
            status, status,
            contextAttributes,
            g_SecurityTokenMaxLength,
            g_SignatureMaxLength,
            g_fSecurityPackageInitialized,
            lifetime
            ));

        //
        //  DCR:  security error codes on local function failures:
        //      - key's no good
        //      - sigs no good
        //      RCODE errors are fine for sending back to remote, but don't
        //      convey the correct info locally
        //

        status = DNS_ERROR_RCODE_BADKEY;
        goto Failed;
    }
    psecCtxt->fHaveSecHandle = TRUE;

    DNSDBG( SECURITY, (
        "Finished InitializeSecurityContext():\n"
        "\tstatus       = %08x (%d)\n"
        "\thandle       = %p\n"
        "\toutput buffers\n"
        "\t\tcBuffers   = %d\n"
        "\t\tpBuffers   = %p\n"
        "\tlocal buffer\n"
        "\t\tptr        = %p\n"
        "\t\tlength     = %d\n",
        status, status,
        & psecCtxt->hSecHandle,
        outBufDesc.cBuffers,
        outBufDesc.pBuffers,
        pSecPack->LocalBuf.pvBuffer,
        pSecPack->LocalBuf.cbBuffer
        ));

    ASSERT( status == SEC_E_OK ||
            status == SEC_I_CONTINUE_NEEDED ||
            status == SEC_I_COMPLETE_AND_CONTINUE );

    //
    //  determine signature length
    //
    //  note:  not safe to do just once on start of process, as can fail
    //          to locate DC and end up ntlm on first pass then locate
    //          DC later and need a larger sig;  so many potential client's
    //          under services, it is dangerous not to calculate each time
    //

    if ( status == SEC_E_OK )
    {
        SecPkgContext_Sizes Sizes;

        status = g_pSecurityFunctionTable->QueryContextAttributesW(
                         & psecCtxt->hSecHandle,
                         SECPKG_ATTR_SIZES,
                         (PVOID) &Sizes
                         );
        if ( !SEC_SUCCESS(status) )
        {
            //  DEVNOTE:   this will leave us will valid return but
            //      potentially unset sig max length
            goto Failed;
        }
        if ( Sizes.cbMaxSignature > g_SignatureMaxLength )
        {
            g_SignatureMaxLength = Sizes.cbMaxSignature;
        }

        DNSDBG( SECURITY, (
            "Signature max length = %d\n",
            g_SignatureMaxLength
            ));
    }

    //
    //  now have context, flag for next pass
    //

    psecCtxt->fNewConversation = FALSE;

    //
    //  completed -- have key
    //      - if just created, then need to send back to server
    //      - otherwise done
    //

    if ( status == ERROR_SUCCESS )
    {
        psecCtxt->fNegoComplete = TRUE;
        ASSERT( pSecPack->LocalBuf.pvBuffer );

        if ( pSecPack->LocalBuf.cbBuffer )
        {
            //ASSERT( pSecPack->LocalBuf.cbBuffer != pSecPack->RemoteBuf.cbBuffer );
            status = DNS_STATUS_CONTINUE_NEEDED;
        }
    }

    //
    //  continue needed? -- use single return code
    //

    else
    {
        ASSERT( status == SEC_I_CONTINUE_NEEDED ||
                status == SEC_I_COMPLETE_AND_CONTINUE );

        DNSDBG( SECURITY, (
            "Initializing client context continue needed.\n"
            "\tlocal complete = %d\n",
            ( status == SEC_I_COMPLETE_AND_CONTINUE )
            ));
        //psecCtxt->State = DNSGSS_STATE_CONTINUE;
        status = DNS_STATUS_CONTINUE_NEEDED;
        psecCtxt->fNegoComplete = FALSE;
    }

    *pfDoneNegotiate = psecCtxt->fNegoComplete;
    ASSERT( status == ERROR_SUCCESS || status == DNS_STATUS_CONTINUE_NEEDED );

Failed:

    IF_DNSDBG( SECURITY )
    {
        DnsPrint_Lock();
        DNSDBG( SECURITY, (
            "Leaving InitClientSecurityContext().\n"
            "\tstatus       = %08x (%d)\n",
            status, status ));

        DnsDbg_SecurityContext(
            "Security Context",
            psecCtxt );
        DnsDbg_SecurityPacketInfo(
            "Security Session Packet Info",
            pSecPack );

        DnsPrint_Unlock();
    }

#if 0
    //
    //  security context (the struct) is NEVER created in this function
    //      so no need to determine cleanup issue on failure
    //      caller determines action if
    //

    if ( status == ERROR_SUCCESS || status == DNS_STATUS_CONTINUE_NEEDED )
    {
        return( status );
    }

    //
    //  DEVNOTE:  should we attempt to preserve a context on failure?
    //      - could be a potential security attack to crash negotiation contexts,
    //          by sending garbage
    //      - however don't want bad context to stay around and block all future
    //          attempts to renegotiate
    //
    //  delete any locally create context
    //  caller will be responsible for making determination about recaching or
    //      deleting context for passed in context
    //

    if ( fcreatedContext )
    {
        Dns_FreeSecurityContext( psecCtxt );
        pSecPack->pSecContext = NULL;
    }
    else
    {
        Dns_EnlistSecurityContext( (PSEC_CNTXT)psecCtxt );
    }
#endif

    return( status );
}



DNS_STATUS
Dns_ServerAcceptSecurityContext(
    IN OUT  PSECPACK        pSecPack,
    IN      BOOL            fBreakOnAscFailure
    )
/*++

Routine Description:

    Initialized server's security context for session with client.

    This is called with newly created context on first client packet,
    then called again with previously initialized context, after client
    responds to negotiation.

Arguments:

    pSecPack -- security context info for server's session with client

Return Value:

    ERROR_SUCCESS -- if done
    DNS_STATUS_CONTINUE_NEEDED -- if continue respone to client is needed
    ErrorCode on failure.

--*/
{
    PSEC_CNTXT          psecCtxt;
    SECURITY_STATUS     status;
    TimeStamp           lifetime;
    SecBufferDesc       outBufDesc;
    SecBufferDesc       inBufDesc;
    ULONG               contextAttributes = 0;

    DNSDBG( SECURITY, (
        "ServerAcceptSecurityContext(%p, fBreak=%d)\n",
        pSecPack,
        fBreakOnAscFailure ));

    IF_DNSDBG( SECURITY )
    {
        DnsDbg_SecurityPacketInfo(
            "Entering ServerAcceptSecurityContext()",
            pSecPack );
    }

    //
    //  get context
    //

    psecCtxt = pSecPack->pSecContext;
    if ( !psecCtxt )
    {
        DNSDBG( SECURITY, (
            "ERROR: ServerAcceptSecurityContext called with no security context\n" ));
        ASSERT( FALSE );
        return( DNS_ERROR_NO_MEMORY );
    }

    //
    //  already initialized
    //      - echo of previous token is legitimate
    //      - if client still thinks it's negotiating => problem
    //
    //  DCR_CLEAN:  need clear story here on how to handle this -- do these
    //      "mistaken" clients cause context to be scrapped from cache?
    //

    if ( psecCtxt->fNegoComplete )
    {
        if ( psecCtxt->TkeySize == pSecPack->RemoteBuf.cbBuffer )
        {
            return( ERROR_SUCCESS );
        }
#if 0
        //  DCR_FIX:
        //  NOTE:  couldn't do buf compare as not MT
        //      safe when allow context\buffer cleanup
        //  QUESTION:  how can this be dumped while in use

        if ( pSecPack->LocalBuf.pvBuffer &&
            psecCtxt->TkeySize == pSecPack->RemoteBuf.cbBuffer &&
            pSecPack->LocalBuf.cbBuffer == pSecPack->RemoteBuf.cbBuffer &&
            RtlEqualMemory(
                pSecPack->LocalBuf.pvBuffer,
                pSecPack->RemoteBuf.pvBuffer,
                pSecPack->LocalBuf.cbBuffer
                ) )
        {
            return( ERROR_SUCCESS );
        }
#endif
        DNSDBG( ANY, (
            "WARNING:  Server receiving new or incorrect TKEY on already\n"
            "\tnegotiated context %p;\n"
            "\tserver buffer is NOT echo of buffer sent!\n",
            psecCtxt ));

        return( DNS_ERROR_RCODE_BADKEY );
    }

    //  refresh SSPI credentials if expired

    if ( SSPI_EXPIRED_HANDLE( g_SspiCredentialsLifetime ) )
    {
        status = Dns_RefreshSSpiCredentialsHandle( TRUE, NULL );
        if ( !SEC_SUCCESS(status) )
        {
            DNS_PRINT((
                "Error <0x%x>: Cannot refresh Sspi Credentials Handle\n",
                status ));
        }
    }

    //
    //  accept security context
    //
    //  allocate local token buffer if doesn't exists
    //  note, the reason I do this is so I won't have the memory of
    //  a large buffer sitting around during a two pass security session
    //      and hence tied up until I time out
    //
    //  DCR_PERF:  security token buffer allocation
    //      since context will be verified before queued, is this approach
    //      sensible?
    //      if can delete when TCP connection fails, or on short timeout, then
    //      ok to append to SEC_CNTXT and save an allocation
    //

    if ( !pSecPack->LocalBuf.pvBuffer )
    {
        PCHAR   pbuf;
        pbuf = (PVOID) ALLOCATE_HEAP( g_SecurityTokenMaxLength );
        if ( !pbuf )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Failed;
        }
        pSecPack->LocalBuf.pvBuffer     = pbuf;
        pSecPack->LocalBuf.cbBuffer     = g_SecurityTokenMaxLength;
        pSecPack->LocalBuf.BufferType   = SECBUFFER_TOKEN;
    }

    pSecPack->LocalBuf.cbBuffer = g_SecurityTokenMaxLength;

    outBufDesc.ulVersion   = 0;
    outBufDesc.cBuffers    = 1;
    outBufDesc.pBuffers    = &pSecPack->LocalBuf;

    //  DCR_PERF:  zeroing nego buffer is unnecessary

    RtlZeroMemory(
        pSecPack->LocalBuf.pvBuffer,
        pSecPack->LocalBuf.cbBuffer );

    //  prepare input buffer with client token

    inBufDesc.ulVersion    = 0;
    inBufDesc.cBuffers     = 1;
    inBufDesc.pBuffers     = & pSecPack->RemoteBuf;

    status = g_pSecurityFunctionTable->AcceptSecurityContext(
                & g_hSspiCredentials,
                psecCtxt->fNewConversation
                    ?   NULL
                    :   & psecCtxt->hSecHandle,
                & inBufDesc,
                ASC_REQ_REPLAY_DETECT
                        | ASC_REQ_DELEGATE
                        | ASC_REQ_MUTUAL_AUTH,      // context requirements
                SECURITY_NATIVE_DREP,
                & psecCtxt->hSecHandle,
                & outBufDesc,
                & contextAttributes,
                & lifetime
                );

    if ( fBreakOnAscFailure &&
        ( status != SEC_E_OK &&
            status != SEC_I_CONTINUE_NEEDED &&
            status != SEC_I_COMPLETE_AND_CONTINUE ) )
    {
        DNS_PRINT(( "HARD BREAK: BreakOnAscFailure status=%d\n",
            status ));
        DebugBreak();
    }

    if ( !SEC_SUCCESS(status) )
    {
        DNS_PRINT((
            "ERROR:  Accept security context failed status = %d (%08x)\n",
            status, status ));
        goto Failed;
    }

    psecCtxt->fHaveSecHandle = TRUE;

    DNSDBG( SECURITY, (
        "Finished AcceptSecurityContext():\n"
        "\tstatus       = %08x (%d)\n"
        "\thandle       = %p\n"
        "\toutput buffers\n"
        "\t\tcBuffers   = %d\n"
        "\t\tpBuffers   = %p\n"
        "\tlocal buffer\n"
        "\t\tptr        = %p\n"
        "\t\tlength     = %d\n"
        "\tlifetime     = %ld %ld\n"
        "\tcontext flag = 0x%lx\n",
        status, status,
        & psecCtxt->hSecHandle,
        outBufDesc.cBuffers,
        outBufDesc.pBuffers,
        pSecPack->LocalBuf.pvBuffer,
        pSecPack->LocalBuf.cbBuffer,
        lifetime.HighPart,
        lifetime.LowPart,
        contextAttributes
        ));

    ASSERT( status == SEC_E_OK ||
            status == SEC_I_CONTINUE_NEEDED ||
            status == SEC_I_COMPLETE_AND_CONTINUE );

    //
    //  compute the size of signature if you are done with initializing
    //  the security context and haven't done it before
    //

    if ( status == SEC_E_OK )
    {
        SecPkgContext_Sizes     Sizes;

        //
        //  reject NULL sessions
        //  NTLM security will establish NULL sessions to non-domain clients,
        //      even if ASC_REQ_ALLOW_NULL_SESSION is not set
        //  note, context has been created, but will be cleaned up in normal
        //      failure path
        //

        if ( contextAttributes & ASC_RET_NULL_SESSION )
        {
            DNSDBG( SECURITY, (
                "Rejecting NULL session from AcceptSecurityContext()\n" ));
            status = DNS_ERROR_RCODE_BADKEY;
            goto Failed;
        }

        status = g_pSecurityFunctionTable->QueryContextAttributesW(
                             &psecCtxt->hSecHandle,
                             SECPKG_ATTR_SIZES,
                             (PVOID)& Sizes
                             );
        if ( !SEC_SUCCESS(status) )
        {
            DNS_PRINT(( "Query context attribtues failed\n" ));
            ASSERT( FALSE );
            goto Failed;
        }

        //
        //  we should use the largest signature there is among all
        //  packages
        //
        //  DCR_FIX:  signature length stuff bogus???
        //
        //  when packet is signed, the length is assumed to be g_SignatureMaxLength
        //      if this is not the signature length for the desired package, does
        //      this still work properly???
        //
        //  DCR_FIX:  potential very small timing window where two clients
        //      getting different packages could cause this to miss highest
        //      value -- potential causing a signing failure?
        //

        if ( Sizes.cbMaxSignature > g_SignatureMaxLength )
        {
            g_SignatureMaxLength = Sizes.cbMaxSignature;
        }

        //
        //  finished negotiation
        //      - set flag
        //      - save final TKEY data length, so can recognize response
        //
        //  this is valid only on new conversation, shouldn't have
        //  no sig second time through
        //

        psecCtxt->fNegoComplete = TRUE;
        psecCtxt->TkeySize = (WORD) pSecPack->LocalBuf.cbBuffer;

        //
        //  need token response from server
        //  some protocols (kerberos) complete in one pass, but hence require
        //      non-echo response from server for mutual-authentication
        //

        if ( psecCtxt->TkeySize )
        {
            DNSDBG( SECURITY, (
                "Successful security context accept, but need server reponse\n"
                "\t-- doing continue.\n" ));
            status = DNS_STATUS_CONTINUE_NEEDED;
        }

#if 0
        if ( !psecCtxt->pTsigRR  &&  psecCtxt->fNewConversation )
        {
            DNSDBG( SECURITY, (
                "Successful security context accept, without sig, doing continue\n" ));
            status = DNS_STATUS_CONTINUE_NEEDED;
        }
#endif
    }

    //
    //  continue needed?
    //      - single status code returned for continue needed
    //

    else if ( status == SEC_I_CONTINUE_NEEDED  ||  status == SEC_I_COMPLETE_AND_CONTINUE )
    {
        DNSDBG( SECURITY, (
            "Initializing server context, continue needed.\n"
            "\tlocal complete = %d\n",
            ( status == SEC_I_COMPLETE_AND_CONTINUE )
            ));
        psecCtxt->fNegoComplete = FALSE;
        status = DNS_STATUS_CONTINUE_NEEDED;
    }

    psecCtxt->fNewConversation = FALSE;

Failed:

    IF_DNSDBG( SECURITY )
    {
        DNSDBG( SECURITY, (
            "Leaving ServerAcceptSecurityContext().\n"
            "\tstatus       = %d %08x\n",
            status, status ));

        DnsDbg_SecurityContext(
            "Security Session Context leaving ServerAcceptSecurityContext()",
            psecCtxt );
    }
    return( status );
}



DNS_STATUS
Dns_SrvImpersonateClient(
    IN      HANDLE          hSecPack
    )
/*++

Routine Description:

    Make server impersonate client.

Parameters:

    hSecPack -- session context handle

Return Value:

    ERROR_SUCCESS if successful impersonation.
    ErrorCode on failue.

--*/
{
    PSEC_CNTXT      psecCtxt;

    //  get security context

    psecCtxt = ((PSECPACK)hSecPack)->pSecContext;
    if ( !psecCtxt )
    {
        DNS_PRINT(( "ERROR:  Dns_SrvImpersonateClient without context!!!\n" ));
        ASSERT( FALSE );
        return( DNS_ERROR_RCODE_BADKEY );
    }

    return  g_pSecurityFunctionTable->ImpersonateSecurityContext( &psecCtxt->hSecHandle );
}



DNS_STATUS
Dns_SrvRevertToSelf(
    IN      HANDLE          hSecPack
    )
/*++

Routine Description:

    Return server context to itself.

Parameters:

    hSecPack -- session context handle

Return Value:

    ERROR_SUCCESS if successful impersonation.
    ErrorCode on failue.

--*/
{
    PSEC_CNTXT      psecCtxt;

    //  get security context

    psecCtxt = ((PSECPACK)hSecPack)->pSecContext;
    if ( !psecCtxt )
    {
        DNS_PRINT(( "ERROR:  Dns_SrvRevertToSelf without context!!!\n" ));
        ASSERT( FALSE );
        return( DNS_ERROR_RCODE_BADKEY );
    }

    return  g_pSecurityFunctionTable->RevertSecurityContext( &psecCtxt->hSecHandle );
}



//
//  Security record packet write
//

DNS_STATUS
Dns_WriteGssTkeyToMessage(
    IN      PSECPACK        pSecPack,
    IN      PDNS_HEADER     pMsgHead,
    IN      PCHAR           pMsgBufEnd,
    IN OUT  PCHAR *         ppCurrent,
    IN      BOOL            fIsServer
    )
/*++

Routine Description:

    Write security record into packet, and optionally sign.

Arguments:

    hSecPack    -- security session handle

    pMsgHead    -- ptr to start of DNS message

    pMsgEnd     -- ptr to end of message buffer

    ppCurrent   -- addr to recv ptr to end of message

    fIsServer   -- performing this operation as DNS server?

Return Value:

    ERROR_SUCCESS on success
    ErrorCode of failure to accomodate or sign message.

--*/
{
    DNS_STATUS      status = ERROR_INVALID_DATA;
    PSEC_CNTXT      psecCtxt;
    PCHAR           pch;
    DWORD           expireTime;
    WORD            keyLength;
    WORD            keyRecordDataLength;
    PCHAR           precordData;
    PCHAR           pnameAlg;
    WORD            lengthAlg;

    DNSDBG( SECURITY, ( "Dns_WriteGssTkeyToMessage( %p )\n", pSecPack ));

    //
    //  get security context
    //

    psecCtxt = pSecPack->pSecContext;
    if ( !psecCtxt )
    {
        DNS_PRINT(( "ERROR:  attempted signing without security context!!!\n" ));
        ASSERT( FALSE );
        return( DNS_ERROR_RCODE_BADKEY );
    }

    //
    //  peal packet back to question section
    //

    pMsgHead->AnswerCount = 0;
    pMsgHead->NameServerCount = 0;
    pMsgHead->AdditionalCount = 0;

    //  go to end of packet to insert TKEY record

    pch = Dns_SkipToRecord(
                pMsgHead,
                pMsgBufEnd,
                0           // go to end of packet
                );
    if ( !pch )
    {
        DNS_ASSERT( FALSE );
        DNS_PRINT(("Dns_SkipToSecurityRecord failed!\n" ));
        goto Exit;
    }

    //
    //  reset section count where the TKEY RR will be written
    //
    //  for client section depends on version
    //      W2K -> answer
    //      later -> additional
    //

    if ( fIsServer )
    {
        pMsgHead->AnswerCount = 1;

        //  for server set client TKEY version in context
        //      - if not learned on previous pass

        if ( psecCtxt->Version == 0 )
        {
            psecCtxt->Version = pSecPack->TkeyVersion;
        }
    }
    else
    {
        if ( psecCtxt->Version == TKEY_VERSION_W2K )
        {
            pMsgHead->AnswerCount = 1;
        }
        else
        {
            pMsgHead->AdditionalCount = 1;
        }
    }

    //
    //  write TKEY owner
    //      - this is context "name"
    //

    pch = Dns_WriteDottedNameToPacket(
                pch,
                pMsgBufEnd,
                psecCtxt->Key.pszTkeyName,
                NULL,       // FQDN, no domain
                0,          // no domain offset
                FALSE       // not unicode
                );
    if ( !pch )
    {
        goto Exit;
    }

    //
    //  TKEY record
    //      - algorithm owner
    //      - time
    //      - expire time
    //      - key length
    //      - key
    //

    if ( psecCtxt->Version == TKEY_VERSION_W2K )
    {
        pnameAlg  = g_pAlgorithmNameW2K;
        lengthAlg = W2K_GSS_ALGORITHM_NAME_PACKET_LENGTH;
    }
    else
    {
        //DNS_ASSERT( psecCtxt->Version == TKEY_VERSION_CURRENT );
        pnameAlg  = g_pAlgorithmNameCurrent;
        lengthAlg = GSS_ALGORITHM_NAME_PACKET_LENGTH;
    }

    keyLength = (WORD) pSecPack->LocalBuf.cbBuffer;

    keyRecordDataLength = keyLength + SIZEOF_TKEY_FIXED_DATA + lengthAlg;

    if ( pch + sizeof(DNS_WIRE_RECORD) + keyRecordDataLength > pMsgBufEnd )
    {
        DNS_PRINT(( "Dns_WriteGssTkeyToMessage() failed! -- insufficient length\n" ));
        DNS_ASSERT( FALSE );
        status = ERROR_INVALID_PARAMETER;
        goto Exit;
    }
    pch = Dns_WriteRecordStructureToPacketEx(
                pch,
                DNS_TYPE_TKEY,
                DNS_CLASS_ANY,
                0,
                keyRecordDataLength );

    //  write algorithm name

    precordData = pch;
    RtlCopyMemory(
        pch,
        pnameAlg,
        lengthAlg );

    pch += lengthAlg;

    //  time signed and expire time
    //      give ten minutes before expiration

    expireTime = (DWORD) time( NULL );
    INLINE_WRITE_FLIPPED_DWORD( pch, expireTime );
    pch += sizeof(DWORD);

    expireTime += TKEY_EXPIRE_INTERVAL;
    INLINE_WRITE_FLIPPED_DWORD( pch, expireTime );
    pch += sizeof(DWORD);

    //  mode

    INLINE_WRITE_FLIPPED_WORD( pch, DNS_TKEY_MODE_GSS );
    pch += sizeof(WORD);

    //  extended RCODE -- report back to caller

    INLINE_WRITE_FLIPPED_WORD( pch, pSecPack->ExtendedRcode );
    pch += sizeof(WORD);

    //  key length

    INLINE_WRITE_FLIPPED_WORD( pch, keyLength );
    pch += sizeof(WORD);

    //  write key token

    RtlCopyMemory(
        pch,
        pSecPack->LocalBuf.pvBuffer,
        keyLength );

    pch += keyLength;

    DNSDBG( SECURITY, (
        "Wrote TKEY to packet at %p\n"
        "\tlength = %d\n"
        "\tpacket end = %p\n",
        pMsgHead,
        keyLength,
        pch ));

    ASSERT( pch < pMsgBufEnd );

    //  other length

    WRITE_UNALIGNED_WORD( pch, 0 );
    pch += sizeof(WORD);

    ASSERT( pch < pMsgBufEnd );
    ASSERT( pch - precordData == keyRecordDataLength );

    *ppCurrent = pch;
    status = ERROR_SUCCESS;

Exit:

    return( status );
}



DNS_STATUS
Dns_SignMessageWithGssTsig(
    IN      HANDLE          hSecPackCtxt,
    IN      PDNS_HEADER     pMsgHead,
    IN      PCHAR           pMsgBufEnd,
    IN OUT  PCHAR *         ppCurrent
    )
/*++

Routine Description:

    Write GSS TSIG record to packet.

Arguments:

    hSecPackCtxt -- packet security context

    pMsgHead    -- ptr to start of DNS message

    pMsgEnd     -- ptr to end of message buffer

    ppCurrent   -- addr to recv ptr to end of message

Return Value:

    ERROR_SUCCESS on success
    ErrorCode of failure to accomodate or sign message.

--*/
{
    PSECPACK        pSecPack = (PSECPACK) hSecPackCtxt;
    PSEC_CNTXT      psecCtxt;
    DNS_STATUS      status = ERROR_INVALID_DATA;
    PCHAR           pch;            //  ptr to walk through TSIG record during build
    PCHAR           ptsigRRHead;
    PCHAR           ptsigRdataBegin;
    PCHAR           ptsigRdataEnd;
    PCHAR           pbufStart = NULL;   //  signing buf
    PCHAR           pbuf;               //  ptr to walk through signing buf
    PCHAR           psig = NULL;        //  query signature
    WORD            sigLength;
    DWORD           length;
    DWORD           createTime;
    SecBufferDesc   outBufDesc;
    SecBuffer       outBuffs[2];
    WORD            netXid;
    PCHAR           pnameAlg;
    DWORD           lengthAlg;

    DNSDBG( SECURITY, (
        "Dns_SignMessageWithGssTsig( %p )\n",
        pMsgHead ));

    //
    //  get security context
    //

    psecCtxt = pSecPack->pSecContext;
    if ( !psecCtxt )
    {
        DNS_PRINT(( "ERROR:  attempted signing without security context!!!\n" ));
        ASSERT( FALSE );
        return( DNS_ERROR_RCODE_BADKEY );
    }

    //
    //  peal off existing TSIG (if any)
    //

    if ( pMsgHead->AdditionalCount )
    {
        DNS_PARSED_RR   parsedRR;

        pch = Dns_SkipToRecord(
                    pMsgHead,
                    pMsgBufEnd,
                    (-1)        // go to last record
                    );
        if ( !pch )
        {
            DNS_ASSERT( FALSE );
            DNS_PRINT(("Dns_SkipToRecord() failed!\n" ));
            goto Exit;
        }

        pch = Dns_ParsePacketRecord(
                    pch,
                    pMsgBufEnd,
                    &parsedRR );
        if ( !pch )
        {
            DNS_ASSERT( FALSE );
            DNS_PRINT(("Dns_ParsePacketRecord failed!\n" ));
            goto Exit;
        }

        if ( parsedRR.Type == DNS_TYPE_TSIG )
        {
            DNSDBG( SECURITY, (
                "Erasing existing TSIG before resigning packet %p\n",
                pMsgHead ));
            pMsgHead->AdditionalCount--;
        }

        //  note could save end-of-message here (pch)
        //  for non-TSIG case instead of redoing skip
    }

    //  go to end of packet to insert TSIG record

    pch = Dns_SkipToRecord(
                pMsgHead,
                pMsgBufEnd,
                0           // go to end of packet
                );
    if ( !pch )
    {
        DNS_ASSERT( FALSE );
        DNS_PRINT(("Dns_SkipToSecurityRecord failed!\n" ));
        goto Exit;
    }

    //
    //  write TSIG owner
    //      - this is context "name"
    //

    pch = Dns_WriteDottedNameToPacket(
                pch,
                pMsgBufEnd,
                psecCtxt->Key.pszTkeyName,
                NULL,       // FQDN, no domain
                0,          // no domain offset
                FALSE       // not unicode
                );
    if ( !pch )
    {
        goto Exit;
    }

    //
    //  TSIG record
    //      - algorithm owner
    //      - time
    //      - expire time
    //      - original XID
    //      - sig length
    //      - sig
    //

    if ( psecCtxt->Version == TKEY_VERSION_W2K )
    {
        pnameAlg  = g_pAlgorithmNameW2K;
        lengthAlg = W2K_GSS_ALGORITHM_NAME_PACKET_LENGTH;
    }
    else
    {
        //DNS_ASSERT( psecCtxt->Version == TKEY_VERSION_CURRENT );
        pnameAlg  = g_pAlgorithmNameCurrent;
        lengthAlg = GSS_ALGORITHM_NAME_PACKET_LENGTH;
    }

    if ( pch +
            sizeof(DNS_WIRE_RECORD) +
            SIZEOF_TSIG_FIXED_DATA +
            lengthAlg +
            g_SignatureMaxLength > pMsgBufEnd )
    {
        DNS_PRINT(( "Dns_WriteTsigToMessage() failed! -- insufficient length\n" ));
        DNS_ASSERT( FALSE );
        status = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    //  write record structure

    ptsigRRHead = pch;
    pch = Dns_WriteRecordStructureToPacketEx(
                pch,
                DNS_TYPE_TSIG,
                DNS_CLASS_ANY,      // per TSIG-04 draft
                0,
                0 );

    //  write algorithm name
    //      - save ptr to RDATA as all is directly signable in packet
    //      format up to SigLength field

    ptsigRdataBegin = pch;

    RtlCopyMemory(
        pch,
        pnameAlg,
        lengthAlg );

    pch += lengthAlg;

    //
    //  set time fields
    //      - signing time seconds since 1970 in 48 bit
    //      - expire time
    //
    //  DCR_FIX: not 2107 safe
    //      have 48 bits on wire, but setting with 32 bit time
    //

    RtlZeroMemory( pch, sizeof(WORD) );
    pch += sizeof(WORD);
    createTime = (DWORD) time( NULL );
    INLINE_WRITE_FLIPPED_DWORD( pch, createTime );
    pch += sizeof(DWORD);

    INLINE_WRITE_FLIPPED_WORD( pch, TSIG_EXPIRE_INTERVAL );
    pch += sizeof(WORD);

    ptsigRdataEnd = pch;

    //
    //  create signing buffer
    //      - everything signed must fit into message
    //

    pbuf = ALLOCATE_HEAP( MAX_SIGNING_SIZE );
    if ( !pbuf )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Exit;
    }
    pbufStart = pbuf;

    //
    //  sign
    //      - query signature (if exists)
    //      (note, W2K improperly left out query sig length)
    //      - message up to TSIG
    //      - TSIG owner name
    //      - TSIG header
    //          - class
    //          - TTL
    //      - TSIG RDATA
    //          - everything before SigLength
    //          - original id
    //          - other data length and other data
    //

    if ( pMsgHead->IsResponse )
    {
        if ( pSecPack->pQuerySig )
        {
            WORD    sigLength = pSecPack->QuerySigLength;

            ASSERT( sigLength != 0 );
            DNS_ASSERT( psecCtxt->Version != 0 );

            if ( psecCtxt->Version >= TKEY_VERSION_XP_RC1 )
            {
                DNSDBG( SECURITY, (
                    "New signing including query sig length =%x\n",
                    sigLength ));
                INLINE_WRITE_FLIPPED_WORD( pbuf, sigLength );
                pbuf += sizeof(WORD);
            }
            RtlCopyMemory(
                pbuf,
                pSecPack->pQuerySig,
                sigLength );

            pbuf += sigLength;
        }

        //  if server has just completed TKEY nego, it may sign response without query
        //  otherwise no query sig is invalid for response

        else if ( !pSecPack->pTkeyRR )
        {
            DNS_PRINT((
                "ERROR: no query sig available when signing response at %p!!!\n",
                pMsgHead ));
            ASSERT( FALSE );
            status = DNS_ERROR_RCODE_SERVER_FAILURE;
            goto Exit;
        }
        DNSDBG( SECURITY, (
            "Signing TKEY response without query sig.\n" ));
    }

    //
    //  copy message
    //      - go right through, TSIG owner name
    //      - message header MUST be in network order
    //      - save XID in netorder, it is included in TSIG RR
    //

    DNS_BYTE_FLIP_HEADER_COUNTS( pMsgHead );
    length = (DWORD)(ptsigRRHead - (PCHAR)pMsgHead);

    netXid = pMsgHead->Xid;

    RtlCopyMemory(
        pbuf,
        (PCHAR) pMsgHead,
        length );

    pbuf += length;
    DNS_BYTE_FLIP_HEADER_COUNTS( pMsgHead );

    //  copy TSIG class (ANY) and TTL (0)

    WRITE_UNALIGNED_WORD( pbuf, DNS_RCLASS_ANY );
    pbuf += sizeof(WORD);
    WRITE_UNALIGNED_DWORD( pbuf, 0 );
    pbuf += sizeof(DWORD);

    //  copy TSIG RDATA through sig

    length = (DWORD)(ptsigRdataEnd - ptsigRdataBegin);

    RtlCopyMemory(
        pbuf,
        ptsigRdataBegin,
        length );

    pbuf += length;

    //  copy extended RCODE -- report back to caller

    INLINE_WRITE_FLIPPED_WORD( pbuf, pSecPack->ExtendedRcode );
    pbuf += sizeof(WORD);

    //  copy other data length and other data
    //      - currently just zero length field

    *pbuf++ = 0;
    *pbuf++ = 0;

    length = (DWORD)(pbuf - pbufStart);

    DNSDBG( SECURITY, (
        "Copied %d bytes to TSIG signing buffer.\n",
        length ));

    //
    //  sign the packet
    //      buf[0] is data
    //      buf[1] is signature
    //
    //  note:  we write signature DIRECTLY into the real packet buffer
    //

    ASSERT( pch + g_SignatureMaxLength <= pMsgBufEnd );

    outBufDesc.ulVersion    = 0;
    outBufDesc.cBuffers     = 2;
    outBufDesc.pBuffers     = outBuffs;

    outBuffs[0].pvBuffer    = pbufStart;
    outBuffs[0].cbBuffer    = length;
    outBuffs[0].BufferType  = SECBUFFER_DATA; // | SECBUFFER_READONLY;

    outBuffs[1].pvBuffer    = pch + sizeof(WORD);
    outBuffs[1].cbBuffer    = g_SignatureMaxLength;
    outBuffs[1].BufferType  = SECBUFFER_TOKEN;

    status = g_pSecurityFunctionTable->MakeSignature(
                    & psecCtxt->hSecHandle,
                    0,
                    & outBufDesc,
                    0               // sequence detection
                    );

    if ( status != SEC_E_OK  &&
         status != SEC_E_CONTEXT_EXPIRED  &&
             status != SEC_E_QOP_NOT_SUPPORTED )
    {
        DNS_PRINT(( "MakeSignature() failed status = %08x (%d)\n", status, status ));
        goto Exit;
    }

    IF_DNSDBG( SECURITY )
    {
        DnsPrint_Lock();
        DnsDbg_MessageNoContext(
            "Signed packet",
            pMsgHead,
            (WORD) (pch - (PCHAR)pMsgHead) );

        DNS_PRINT((
            "Signing info:\n"
            "\tsign data buf    %p\n"
            "\t  length         %d\n"
            "\tsignature buf    %p (in packet)\n"
            "\t  length         %d\n",
            outBuffs[0].pvBuffer,
            outBuffs[0].cbBuffer,
            outBuffs[1].pvBuffer,
            outBuffs[1].cbBuffer
            ));
        DnsDbg_RawOctets(
            "Signing buffer:",
            NULL,
            outBuffs[0].pvBuffer,
            outBuffs[0].cbBuffer
            );
        DnsDbg_RawOctets(
            "Signature:",
            NULL,
            outBuffs[1].pvBuffer,
            outBuffs[1].cbBuffer
            );
        DnsPrint_Unlock();
    }

    //
    //  continue building packet TSIG RDATA
    //      - siglength
    //      - signature
    //      - original id
    //      - error code
    //      - other length
    //      - other data

    //
    //  get signature length
    //  set sig length in packet
    //
    //  if this is query SAVE signature, to verify response
    //

    sigLength = (WORD) outBuffs[1].cbBuffer;

    INLINE_WRITE_FLIPPED_WORD( pch, sigLength );
    pch += sizeof(WORD);

    //
    //  client saves off signature sent, to use in hash on response
    //      - server using client's sig in hash, blocks some attacks
    //

    if ( !pMsgHead->IsResponse )
    {
        ASSERT( !pSecPack->pQuerySig );

        psig = ALLOCATE_HEAP( sigLength );
        if ( !psig )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Exit;
        }
        RtlCopyMemory(
            psig,
            pch,
            sigLength );

        pSecPack->pQuerySig = psig;
        pSecPack->QuerySigLength = sigLength;
    }

    //  jump over signature -- it was directly written to packet

    pch += sigLength;

    //  original id follows signature

    WRITE_UNALIGNED_WORD( pch, netXid );
    //RtlCopyMemory( pch, (PCHAR)&netXid, sizeof(WORD) );
    pch += sizeof(WORD);

    //  extended RCODE -- report back to caller

    INLINE_WRITE_FLIPPED_WORD( pch, pSecPack->ExtendedRcode );
    pch += sizeof(WORD);

    //  other length

    WRITE_UNALIGNED_WORD( pch, 0 );
    pch += sizeof(WORD);

    //  set TSIG record datalength

    Dns_SetRecordDatalength(
        (PDNS_WIRE_RECORD) ptsigRRHead,
        (WORD) (pch - ptsigRdataBegin) );

    //  increment AdditionalCount

    pMsgHead->AdditionalCount++;

    DNSDBG( SECURITY, (
        "Signed packet at %p with GSS TSIG.\n"
        "\tsig length           = %d\n"
        "\tTSIG RR header       = %p\n"
        "\tTSIG RDATA           = %p\n"
        "\tTSIG RDATA End       = %p\n"
        "\tTSIG RDATA length    = %d\n",
        pMsgHead,
        sigLength,
        ptsigRRHead,
        ptsigRdataBegin,
        pch,
        (WORD) (pch - ptsigRdataBegin)
        ));

    *ppCurrent = pch;
    status = ERROR_SUCCESS;

Exit:

    //  free signing buffer
    //  note:  no cleanup of allocated pQuerySig is needed;  from point
    //          of allocation there is no failure scenario

    if ( pbufStart )
    {
        FREE_HEAP( pbufStart );
    }
    return( status );
}



//
//  Security record reading
//

DNS_STATUS
Dns_ExtractGssTsigFromMessage(
    IN OUT  PSECPACK            pSecPack,
    IN      PDNS_HEADER         pMsgHead,
    IN      PCHAR               pMsgEnd
    )
/*++

Routine Description:

    Extracts a TSIG from packet and loads into security context.

Arguments:

    pSecPack    - security info for packet

    pMsgHead    - msg to extract security context from

    pMsgEnd     - end of message

Return Value:

    ERROR_SUCCESS if successful.
    DNS_ERROR_FORMERR if badly formed TSIG
    DNS_STATUS_PACKET_UNSECURE if security context in response is same as query's
        indicating non-security aware partner
    RCODE or extended RCODE on failure.

--*/
{
    DNS_STATUS      status = ERROR_INVALID_DATA;
    PCHAR           pch;
    PCHAR           pnameOwner;
    WORD            nameLength;
    WORD            extRcode;
    WORD            sigLength;
    DWORD           currentTime;
    PDNS_PARSED_RR  pparsedRR;
    PDNS_RECORD     ptsigRR;
    DNS_RECORD      ptempRR;
    PCHAR           psig;

    DNSDBG( SECURITY, (
        "ExtractGssTsigFromMessage( %p )\n", pMsgHead ));

    //  clear any previous TSIG

    if ( pSecPack->pTsigRR || pSecPack->pszContextName )
    //    if ( pSecPack->pTsigRR || pSecPack->pszContextName )
    {
        // Dns_RecordFree( pSecPack->pTsigRR );
        FREE_HEAP( pSecPack->pTsigRR );
        FREE_HEAP( pSecPack->pszContextName );

        pSecPack->pTsigRR = NULL;
        pSecPack->pszContextName = NULL;
    }

    //  set message pointers

    pSecPack->pMsgHead = pMsgHead;
    pSecPack->pMsgEnd = pMsgEnd;

    //
    //  if no additional record, don't bother, not a secure message
    //

    if ( pMsgHead->AdditionalCount == 0 )
    {
        status = DNS_STATUS_PACKET_UNSECURE;
        goto Failed;
    }

    //
    //  skip to security record (last record in packet)
    //

    pch = Dns_SkipToRecord(
                pMsgHead,
                pMsgEnd,
                (-1)           // goto last record
                );
    if ( !pch )
    {
        status = DNS_ERROR_RCODE_FORMAT_ERROR;
        goto Failed;
    }

    //
    //  read TSIG owner name
    //

    pparsedRR = &pSecPack->ParsedRR;

    pparsedRR->pchName = pch;

    pch = Dns_ReadPacketNameAllocate(
            & pSecPack->pszContextName,
            & nameLength,
            0,
            0,
            pch,
            (PCHAR)pMsgHead,
            pMsgEnd );
    if ( !pch )
    {
        DNSDBG( SECURITY, (
            "WARNING:  invalid TSIG RR owner name at %p.\n",
            pch ));
        status = DNS_ERROR_RCODE_FORMAT_ERROR;
        goto Failed;              
    }

    //
    //  parse record structure
    //

    pch = Dns_ReadRecordStructureFromPacket(
                pch,
                pMsgEnd,
                pparsedRR );
    if ( !pch )
    {
        DNSDBG( SECURITY, (
            "ERROR:  invalid security RR in packet at %p.\n"
            "\tstructure or data not withing packet\n",
            pMsgHead ));
        status = DNS_ERROR_RCODE_FORMAT_ERROR;
        goto Failed;
    }
    if ( pparsedRR->Type != DNS_TYPE_TSIG )
    {
        status = DNS_STATUS_PACKET_UNSECURE;
        goto Failed;
    }

    if ( pch != pMsgEnd )
    {
        DNSDBG( SECURITY, (
            "WARNING:  security RR does NOT end at packet end.\n"
            "\tRR end offset    = %04x\n"
            "\tmsg end offset   = %04x\n",
            pch - (PCHAR)pMsgHead,
            pMsgEnd - (PCHAR)pMsgHead ));
    }

    //
    //  extract TSIG record
    //
    //  TsigReadRecord() requires RR owner name for versioning
    //      - pass TSIG name in temp RR
    //

    ptsigRR = TsigRecordRead(
                NULL,
                DnsCharSetWire,
                NULL,
                pparsedRR->pchData,
                pparsedRR->pchNextRR
                );
    if ( !ptsigRR )
    {
        DNSDBG( ANY, (
            "ERROR:  invalid TSIG RR in packet at %p.\n"
            "\tstructure or data not withing packet\n",
            pMsgHead ));
        status = DNS_ERROR_RCODE_FORMAT_ERROR;
        DNS_ASSERT( FALSE );
        goto Failed;
    }
    pSecPack->pTsigRR = ptsigRR;

    //
    //  currently callers expect error on Extract when ext RCODE is set
    //

    if ( ptsigRR->Data.TSIG.wError )
    {
        DNSDBG( SECURITY, (
            "Leaving ExtractGssTsig(), TSIG had extended RCODE = %d\n",
            ptsigRR->Data.TSIG.wError ));
        status = DNS_ERROR_FROM_RCODE( ptsigRR->Data.TSIG.wError );
        goto Failed;
    }

    //
    //  Server side:
    //  if query, save off signature for signing response
    //

    sigLength = ptsigRR->Data.TSIG.wSigLength;

    if ( !pMsgHead->IsResponse )
    {
        ASSERT( !pSecPack->pQuerySig );
        if ( pSecPack->pQuerySig )
        {
            FREE_HEAP( pSecPack->pQuerySig );
            pSecPack->pQuerySig = NULL;
        }

        psig = ALLOCATE_HEAP( sigLength );
        if ( !psig )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Failed;
        }
        RtlCopyMemory(
            psig,
            ptsigRR->Data.TSIG.pSignature,
            sigLength );

        pSecPack->pQuerySig = psig;
        pSecPack->QuerySigLength = sigLength;
    }

    //
    //  Client side:
    //  check for security record echo on response
    //
    //  if we signed and got echo signature back, then may have security unaware
    //  server or lost\timed out key condition
    //

    else
    {
        if ( pSecPack->pQuerySig &&
            pSecPack->QuerySigLength == sigLength &&
            RtlEqualMemory(
                ptsigRR->Data.TSIG.pSignature,
                pSecPack->pQuerySig,
                sigLength ) )
        {
            status = DNS_STATUS_PACKET_UNSECURE;
            goto Failed;
        }
    }

    status = ERROR_SUCCESS;

Failed:

    if ( status != ERROR_SUCCESS )
    {
        DNS_ASSERT( status != DNS_ERROR_RCODE_FORMAT_ERROR );

        ( status == DNS_STATUS_PACKET_UNSECURE )
            ?   (SecTsigEcho++)
            :   (SecTsigFormerr++);
    }

    DNSDBG( SECURITY, (
        "Leave ExtractGssTsigFromMessage()\n"
        "\tpMsgHead     = %p\n"
        "\tsig length   = %d\n"
        "\tpsig         = %p\n"
        "\tOriginalXid  = 0x%x\n",
        "\tpQuerySig    = %p\n"
        "\tQS length    = %d\n",
        pMsgHead,
        sigLength,
        ptsigRR->Data.TSIG.pSignature,
        ptsigRR->Data.TSIG.wOriginalXid,
        pSecPack->pQuerySig,
        pSecPack->QuerySigLength ));

    return( status );
}



DNS_STATUS
Dns_ExtractGssTkeyFromMessage(
    IN OUT  PSECPACK            pSecPack,
    IN      PDNS_HEADER         pMsgHead,
    IN      PCHAR               pMsgEnd,
    IN      BOOL                fIsServer
    )
/*++

Routine Description:

    Extracts a TKEY from packet and loads into security context.

Arguments:

    pSecPack    - security info for packet

    pMsgHead    - msg to extract security context from

    pMsgEnd     - end of message

    fIsServer   - performing this operation as DNS server?

Return Value:

    ERROR_SUCCESS if successful.
    DNS_ERROR_FORMERR if badly formed TKEY
    DNS_STATUS_PACKET_UNSECURE if security context in response is same as query's
        indicating non-security aware partner
    RCODE or extended RCODE on failure.

--*/
{
    DNS_STATUS      status = ERROR_INVALID_DATA;
    PCHAR           pch;
    PCHAR           pnameOwner;
    WORD            nameLength;
    DWORD           currentTime;
    PDNS_PARSED_RR  pparsedRR;
    PDNS_RECORD     ptkeyRR;
    WORD            returnExtendedRcode = 0;
    DWORD           version;

    DNSDBG( SECURITY, (
        "ExtractGssTkeyFromMessage( %p )\n", pMsgHead ));

    //
    //  free any previous TKEY
    //      - may have one from previous pass in two pass negotiation
    //
    //  DCR:  name should be attached to TKEY\TSIG record
    //      then lookup made with IP\name pair against context key
    //      no need for pszContextName field
    //

    if ( pSecPack->pTkeyRR || pSecPack->pszContextName )
    {
        // Dns_RecordFree( pSecPack->pTkeyRR );
        FREE_HEAP( pSecPack->pTkeyRR );
        FREE_HEAP( pSecPack->pszContextName );

        pSecPack->pTkeyRR = NULL;
        pSecPack->pszContextName = NULL;
    }

    //  set message pointers

    pSecPack->pMsgHead = pMsgHead;
    pSecPack->pMsgEnd = pMsgEnd;

    //
    //  skip to TKEY record (second record in packet)
    //

    pch = Dns_SkipToRecord(
                 pMsgHead,
                 pMsgEnd,
                 (1)            // skip question only
                 );
    if ( !pch )
    {
        status = DNS_ERROR_RCODE_FORMAT_ERROR;
        goto Failed;
    }

    //
    //  read TKEY owner name
    //

    pparsedRR = &pSecPack->ParsedRR;

    pparsedRR->pchName = pch;

    pch = Dns_ReadPacketNameAllocate(
            & pSecPack->pszContextName,
            & nameLength,
            0,
            0,
            pch,
            (PCHAR)pMsgHead,
            pMsgEnd );
    if ( !pch )
    {
        DNSDBG( SECURITY, (
            "WARNING:  invalid TKEY RR owner name at %p.\n",
            pch ));
        status = DNS_ERROR_RCODE_FORMAT_ERROR;
        goto Failed;
    }

    //
    //  parse record structure
    //

    pch = Dns_ReadRecordStructureFromPacket(
                pch,
                pMsgEnd,
                pparsedRR );
    if ( !pch )
    {
        DNSDBG( SECURITY, (
            "ERROR:  invalid security RR in packet at %p.\n"
            "\tstructure or data not withing packet\n",
            pMsgHead ));
        status = DNS_ERROR_RCODE_FORMAT_ERROR;
        goto Failed;
    }
    if ( pparsedRR->Type != DNS_TYPE_TKEY )
    {
        status = DNS_ERROR_RCODE_FORMAT_ERROR;
        DNS_ASSERT( status != DNS_ERROR_RCODE_FORMAT_ERROR );
        goto Failed;
    }
    if ( pch != pMsgEnd  &&  pMsgHead->AdditionalCount == 0 )
    {
        DNSDBG( SECURITY, (
            "WARNING:  TKEY RR does NOT end at packet end and no TSIG is present.\n"
            "\tRR end offset    = %04x\n"
            "\tmsg end offset   = %04x\n",
            pch - (PCHAR)pMsgHead,
            pMsgEnd - (PCHAR)pMsgHead ));
    }

    //
    //  extract TKEY record
    //

    ptkeyRR = TkeyRecordRead(
                NULL,
                DnsCharSetWire,
                NULL,                   // message buffer unknown
                pparsedRR->pchData,
                pparsedRR->pchNextRR
                );
    if ( !ptkeyRR )
    {
        DNSDBG( ANY, (
            "ERROR:  invalid TKEY RR data in packet at %p.\n",
            pMsgHead ));
        status = DNS_ERROR_RCODE_FORMAT_ERROR;
        goto Failed;
    }
    pSecPack->pTkeyRR = ptkeyRR;

    //
    //  verify GSS algorithm and mode name
    //
    //  if server, save off version for later responses
    //

    if ( RtlEqualMemory(
            ptkeyRR->Data.TKEY.pAlgorithmPacket,
            g_pAlgorithmNameCurrent,
            GSS_ALGORITHM_NAME_PACKET_LENGTH ) )
    {
        version = TKEY_VERSION_CURRENT;
    }
    else if ( RtlEqualMemory(
                ptkeyRR->Data.TKEY.pAlgorithmPacket,
                g_pAlgorithmNameW2K,
                W2K_GSS_ALGORITHM_NAME_PACKET_LENGTH ) )
    {
        version = TKEY_VERSION_W2K;
    }
    else
    {
        DNSDBG( ANY, (
            "ERROR:  TKEY record is NOT GSS alogrithm.\n" ));
        returnExtendedRcode = DNS_RCODE_BADKEY;
        goto Failed;
    }

    //  save client version
    //  need additional check on TKEY_VERSION_CURRENT as Whistler
    //  beta clients had fixed AlgorithmName but were still not
    //  generating unique keys, so need separate version to handle them

    if ( fIsServer )
    {
        if ( version == TKEY_VERSION_CURRENT )
        {
            version = Dns_GetKeyVersion( pSecPack->pszContextName );
            if ( version == 0 )
            {
                //  note, this essentially means unknown non-MS client

                DNSDBG( SECURITY, (
                    "Non-MS TKEY client.\n"
                    "\tkey name = %s\n",
                    pSecPack->pszContextName ));
                version = TKEY_VERSION_CURRENT;
            }
        }
        pSecPack->TkeyVersion = version;
    }

    //  mode

    if ( ptkeyRR->Data.TKEY.wMode != DNS_TKEY_MODE_GSS )
    {
        DNSDBG( SECURITY, (
            "ERROR:  non-GSS mode (%d) in TKEY\n",
            ptkeyRR->Data.TKEY.wMode ));
        returnExtendedRcode = DNS_RCODE_BADKEY;
        goto Failed;
    }

    //
    //  allow small time slew, otherwise must have fresh key
    //

    currentTime = (DWORD) time(NULL);

    if ( ptkeyRR->Data.TKEY.dwCreateTime > ptkeyRR->Data.TKEY.dwExpireTime ||
        ptkeyRR->Data.TKEY.dwExpireTime + MAX_TIME_SKEW < currentTime )
    {
        DNSDBG( ANY, (
            "ERROR:  TKEY failed expire time check.\n"
            "\tcreate time  = %d\n"
            "\texpire time  = %d\n"
            "\tcurrent time = %d\n",
            ptkeyRR->Data.TKEY.dwCreateTime,
            ptkeyRR->Data.TKEY.dwExpireTime,
            currentTime ));

        if ( !SecBigTimeSkew ||
            ptkeyRR->Data.TKEY.dwExpireTime + SecBigTimeSkew < currentTime )
        {
            returnExtendedRcode = DNS_RCODE_BADTIME;
            SecTkeyBadTime++;
            goto Failed;
        }

        DNSDBG( ANY, (
            "REPRIEVED:  TKEY Time slew %d withing %d allowable slew!\n",
            currentTime - ptkeyRR->Data.TKEY.dwCreateTime,
            SecBigTimeSkew ));

        SecBigTimeSkewBypass++;
    }

    //
    //  currently callers expect error on Extract when ext RCODE is set
    //

    if ( ptkeyRR->Data.TKEY.wError )
    {
        DNSDBG( SECURITY, (
            "Leaving ExtractGssTkey(), TKEY had extended RCODE = %d\n",
            ptkeyRR->Data.TKEY.wError ));
        status = DNS_ERROR_FROM_RCODE( ptkeyRR->Data.TKEY.wError );
        goto Failed;
    }

#if 0
    //
    //  check for security record echo on response
    //
    //  if we get echo of TKEY back, then probably simple, no-secure server
    //
#endif

    //
    //  pack key token into GSS security token buffer
    //      do this here simply to avoid doing in both client and server routines
    //

    pSecPack->RemoteBuf.pvBuffer     = ptkeyRR->Data.TKEY.pKey;
    pSecPack->RemoteBuf.cbBuffer     = ptkeyRR->Data.TKEY.wKeyLength;
    pSecPack->RemoteBuf.BufferType   = SECBUFFER_TOKEN;

    status = ERROR_SUCCESS;

Failed:

    if ( status != ERROR_SUCCESS )
    {
        SecTkeyInvalid++;
    }

    //  if failed with extended RCODE, set for return

    if ( returnExtendedRcode )
    {
        pSecPack->ExtendedRcode = returnExtendedRcode;
        status = DNS_ERROR_FROM_RCODE( returnExtendedRcode );
    }

    DNSDBG( SECURITY, (
        "Leave ExtractGssTkeyFromMessage()\n"
        "\tstatus       = %08x (%d)\n"
        "\tpMsgHead     = %p\n"
        "\tpkey         = %p\n"
        "\tlength       = %d\n",
        status, status,
        pMsgHead,
        pSecPack->RemoteBuf.pvBuffer,
        pSecPack->RemoteBuf.cbBuffer ));

    return( status );
}



PCHAR
Dns_CopyAndCanonicalizeWireName(
    IN      PCHAR       pszInput,
    OUT     PCHAR       pszOutput,
    OUT     DWORD       dwOutputSize
    )
/*++

Routine Description:

    Copy a UTF-8 uncompressed DNS wire packet name performing
    canonicalization during the copy.

Arguments:

    pszInput -- pointer to input buffer
    pszOutput -- pointer to output buffer
    dwOutputSize -- number of bytes available at output buffer

Return Value:

    Returns a pointer to the byte after the last byte written into
    the output buffer or NULL on error.

--*/
{
    UCHAR   labelLength;
    WCHAR   wszlabel[ DNS_MAX_LABEL_BUFFER_LENGTH + 1 ];
    DWORD   bufLength;
    DWORD   outputCharsRemaining = dwOutputSize;
    DWORD   dwtemp;
    PCHAR   pchlabelLength;

    while ( ( labelLength = *pszInput++ ) != 0 )
    {

        //
        //  Error if this label is too long or if the output buffer can't
        //  hold at least as many chars as in the uncanonicalized buffer.
        //

        if ( labelLength > DNS_MAX_LABEL_LENGTH ||
             outputCharsRemaining < labelLength )
        {
            goto Error;
        }

        //
        //  Copy this UTF-8 label to a Unicode buffer.
        //

        bufLength = DNS_MAX_NAME_BUFFER_LENGTH_UNICODE;

        if ( !Dns_NameCopy(
                    ( PCHAR ) wszlabel,
                    &bufLength,
                    pszInput,
                    labelLength,
                    DnsCharSetUtf8,
                    DnsCharSetUnicode ) )
        {
            goto Error;
        }

        pszInput += labelLength;

        //
        //  Canonicalize the buffer.
        //

        dwtemp = Dns_MakeCanonicalNameInPlaceW(
                            wszlabel,
                            ( DWORD ) labelLength );
        if ( dwtemp == 0 || dwtemp > DNS_MAX_LABEL_LENGTH )
        {
            goto Error;
        }
        labelLength = ( UCHAR ) dwtemp;

        //
        //  Copy the label to the output buffer.
        //

        pchlabelLength = pszOutput++;       //  Reserve byte for label length.

        dwtemp = outputCharsRemaining;
        if ( !Dns_NameCopy(
                    pszOutput,
                    &dwtemp,
                    ( PCHAR ) wszlabel,
                    labelLength,
                    DnsCharSetUnicode,
                    DnsCharSetUtf8 ) )
        {
            goto Error;
        }

        outputCharsRemaining -= dwtemp;

        --dwtemp;   //  Don't include NULL in label length.

        *pchlabelLength = ( UCHAR ) dwtemp;
        pszOutput += dwtemp;
    }
    
    //
    //  Add name terminator.
    //

    *pszOutput++ = 0;

    return pszOutput;

    Error:

    return NULL;
}   //  Dns_CopyAndCanonicalizeWireName



DNS_STATUS
Dns_VerifySignatureOnPacket(
    IN      PSECPACK        pSecPack
    )
/*++

Routine Description:

    Verify signature on packet contained in security record.

Arguments:

    pSecPack - security packet session info

Return Value:

    ERROR_SUCCESS on success
    DNS_ERROR_BADSIG if sig doesn't exist or doesn't verify
    DNS_ERROR_BADTIME if sig expired
    Extended RCODE from caller if set.

--*/
{
    PSEC_CNTXT      psecCtxt;
    PDNS_HEADER     pmsgHead = pSecPack->pMsgHead;
    PCHAR           pmsgEnd = pSecPack->pMsgEnd;
    PDNS_RECORD     ptsigRR;
    PDNS_PARSED_RR  pparsedRR;
    DWORD           currentTime;
    PCHAR           pbufStart = NULL;
    PCHAR           pbuf;
    DNS_STATUS      status;
    DWORD           length;
    WORD            returnExtendedRcode = 0;
    SecBufferDesc   bufferDesc;
    SecBuffer       buffer[2];
    WORD            msgXid;
    DWORD           version;
    BOOL            fcanonicalizeTsigOwnerName;


    DNSDBG( SECURITY, (
        "VerifySignatureOnPacket( %p )\n", pmsgHead ));

    //
    //  get security context
    //

    psecCtxt = pSecPack->pSecContext;
    if ( !psecCtxt )
    {
        DNS_PRINT(( "ERROR:  attempted signing without security context!!!\n" ));
        ASSERT( FALSE );
        return( DNS_ERROR_RCODE_BADKEY );
    }

    //
    //  if no signature extracted from packet, we're dead
    //

    pparsedRR = &pSecPack->ParsedRR;
    ptsigRR = pSecPack->pTsigRR;
    if ( !ptsigRR )
    {
        returnExtendedRcode = DNS_RCODE_BADSIG;
        goto Exit;
    }

    //
    //  validity check GSS-TSIG
    //      - GSS algorithm
    //      - valid time
    //      - extract extended RCODE
    //
    //  DCR_ENHANCE:  check tampering on bad TSIG?
    //      - for tampered algorithm all we can do is immediate return
    //      - but can check signature and detect tampering
    //          before excluding or basis or time or believing ext RCODE
    //

    //  check algorithm name

    if ( RtlEqualMemory(
            ptsigRR->Data.TKEY.pAlgorithmPacket,
            g_pAlgorithmNameCurrent,
            GSS_ALGORITHM_NAME_PACKET_LENGTH ) )
    {
        version = TKEY_VERSION_CURRENT;
    }
    else if ( RtlEqualMemory(
                ptsigRR->Data.TKEY.pAlgorithmPacket,
                g_pAlgorithmNameW2K,
                W2K_GSS_ALGORITHM_NAME_PACKET_LENGTH ) )
    {
        version = TKEY_VERSION_W2K;
    }
    else
    {
        DNSDBG( ANY, (
            "ERROR:  TSIG record is NOT GSS alogrithm.\n" ));
        returnExtendedRcode = DNS_RCODE_BADSIG;
        goto Exit;
    }

    //
    //  set version if server
    //      - if don't know our version, must be server
    //      note:  alternative is fIsServer flag or IsServer to SecPack
    //

    if ( psecCtxt->Version == 0 )
    {
        psecCtxt->Version = version;
    }

    //
    //  time check
    //      - should be within specified fudge of signing time
    //

    currentTime = (DWORD) time(NULL);

    if ( (LONGLONG)currentTime >
         ptsigRR->Data.TSIG.i64CreateTime +
         (LONGLONG)ptsigRR->Data.TSIG.wFudgeTime
            ||
        (LONGLONG)currentTime <
         ptsigRR->Data.TSIG.i64CreateTime -
         (LONGLONG)ptsigRR->Data.TSIG.wFudgeTime )
    {
        DNSDBG( ANY, (
            "ERROR:  TSIG failed fudge time check.\n"
            "\tcreate time  = %I64d\n"
            "\tfudge time  = %d\n"
            "\tcurrent time = %d\n",
            ptsigRR->Data.TSIG.i64CreateTime,
            ptsigRR->Data.TSIG.wFudgeTime,
            currentTime ));

        //
        //  DCR_FIX:  currently not enforcing time check
        //      in fact have ripped out the counter to track failures
        //      within some allowed skew
    }

    //
    //  extended RCODE -- follows signature
    //      - if set, report back to caller
    //

    if ( ptsigRR->Data.TSIG.wError )
    {
        DNSDBG( SECURITY, (
            "Leaving ExtractGssTsig(), TSIG had extended RCODE = %d\n",
            ptsigRR->Data.TSIG.wError ));
        status = DNS_ERROR_FROM_RCODE( ptsigRR->Data.TSIG.wError );
        goto Exit;
    }

    //
    //  create signing buffer
    //      - everything signed must fit into message
    //

    pbuf = ALLOCATE_HEAP( MAX_SIGNING_SIZE );
    if ( !pbuf )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Exit;
    }
    pbufStart = pbuf;

    //
    //  verify signature over:
    //      - query signature (if exists)
    //      - message
    //          - without TSIG in Additional count
    //          - with original XID
    //      - TSIG owner name
    //      - TSIG header
    //          - class
    //          - TTL
    //      - TSIG RDATA
    //          - everything before SigLength
    //          - other data length and other data
    //

    if ( pmsgHead->IsResponse )
    {
        if ( pSecPack->pQuerySig )
        {
            WORD    sigLength = pSecPack->QuerySigLength;

            ASSERT( sigLength );
            DNS_ASSERT( psecCtxt->Version != 0 );

            if ( psecCtxt->Version >= TKEY_VERSION_XP_RC1 )
            {
                DNSDBG( SECURITY, (
                    "New verify sig including query sig length =%x\n",
                    sigLength ));
                INLINE_WRITE_FLIPPED_WORD( pbuf, sigLength );
                pbuf += sizeof(WORD);
            }
            RtlCopyMemory(
                pbuf,
                pSecPack->pQuerySig,
                sigLength );

            pbuf += sigLength;
        }

        //  if server has just completed TKEY nego, it may sign response without query
        //  so client need not have query sig
        //  in all other cases client must have query sig to verify response

        else if ( !pSecPack->pTkeyRR )
        {
            DNS_PRINT((
                "ERROR:  verify on response at %p without having QUERY signature!\n",
                pmsgHead ));
            ASSERT( FALSE );
            returnExtendedRcode = DNS_RCODE_BADSIG;
            goto Exit;
        }
        DNSDBG( SECURITY, (
            "Verifying TSIG on TKEY response without query sig.\n" ));
    }

    //
    //  copy message
    //      - go right through, TSIG owner name
    //      - message header MUST be in network order
    //      - does NOT include TSIG record in additional count
    //      - must have orginal XID in place
    //      (save existing XID and replace with orginal, then
    //      restore after copy)
    //

    ASSERT( pmsgHead->AdditionalCount );

    pmsgHead->AdditionalCount--;
    msgXid = pmsgHead->Xid;

    DNS_BYTE_FLIP_HEADER_COUNTS( pmsgHead );

    //
    //  If need to canonicalize the TSIG owner name, copy to the start
    //  of the name; else copy to the end of the name.
    //

    fcanonicalizeTsigOwnerName = !psecCtxt->fClient &&
                                 psecCtxt->Version >= TKEY_VERSION_CURRENT;

    length = ( DWORD ) ( ( fcanonicalizeTsigOwnerName
                                ? pparsedRR->pchName 
                                : pparsedRR->pchRR ) -
                           ( PCHAR ) pmsgHead );

    //  restore original XID

    pmsgHead->Xid = ptsigRR->Data.TSIG.wOriginalXid;

    RtlCopyMemory(
        pbuf,
        (PCHAR) pmsgHead,
        length );

    pbuf += length;

    DNS_BYTE_FLIP_HEADER_COUNTS( pmsgHead );
    pmsgHead->AdditionalCount++;
    pmsgHead->Xid = msgXid;

    //
    //  If the TSIG owner name needs to be canonicalized, write it out
    //  to the signing buffer in canonical form (lower case).
    //

    if ( fcanonicalizeTsigOwnerName )
    {
        pbuf = Dns_CopyAndCanonicalizeWireName(
                    pparsedRR->pchName,
                    pbuf,
                    MAXDWORD );

        if ( pbuf == NULL )
        {
            DNSDBG( SECURITY, (
                "Unable to canonicalize TSIG owner name at %p",
                pparsedRR->pchName ));
            returnExtendedRcode = DNS_RCODE_BADSIG;
            goto Exit;
        }
    }

    //  copy TSIG class and TTL
    //      - currently always zero

    INLINE_WRITE_FLIPPED_WORD( pbuf, pparsedRR->Class );
    pbuf += sizeof(WORD);
    INLINE_WRITE_FLIPPED_DWORD( pbuf, pparsedRR->Ttl );
    pbuf += sizeof(DWORD);

    //  copy TSIG RDATA up to signature length

    length = (DWORD)(ptsigRR->Data.TSIG.pSignature - sizeof(WORD) - pparsedRR->pchData);

    ASSERT( (INT)length < (pparsedRR->DataLength - ptsigRR->Data.TSIG.wSigLength) );

    RtlCopyMemory(
        pbuf,
        pparsedRR->pchData,
        length );

    pbuf += length;

    //  copy extended RCODE -- report back to caller

    INLINE_WRITE_FLIPPED_WORD( pbuf, ptsigRR->Data.TSIG.wError );
    pbuf += sizeof(WORD);

    //  copy other data length and other data
    //      - currently just zero length field

    INLINE_WRITE_FLIPPED_WORD( pbuf, ptsigRR->Data.TSIG.wOtherLength );
    pbuf += sizeof(WORD);

    length = ptsigRR->Data.TSIG.wOtherLength;
    if ( length )
    {
        RtlCopyMemory(
            pbuf,
            ptsigRR->Data.TSIG.pOtherData,
            length );
        pbuf += length;
    }

    //  calculate total length signature is over

    length = (DWORD)(pbuf - pbufStart);

    //
    //  verify signature
    //      buf[0] is data
    //      buf[1] is signature
    //
    //  signature is verified directly in packet buffer
    //

    bufferDesc.ulVersion  = 0;
    bufferDesc.cBuffers   = 2;
    bufferDesc.pBuffers   = buffer;

    //  signature is over everything up to signature itself

    buffer[0].pvBuffer     = pbufStart;
    buffer[0].cbBuffer     = length;
    buffer[0].BufferType   = SECBUFFER_DATA;

    //  sig MUST be pointed to by remote buffer
    //
    //  DCR:  can pull copy when eliminate retry below
    //
    //  copy packet signature as signing is destructive
    //      and want to allow for retry
    //

    buffer[1].pvBuffer     = ptsigRR->Data.TSIG.pSignature;
    buffer[1].cbBuffer     = ptsigRR->Data.TSIG.wSigLength;
    buffer[1].BufferType   = SECBUFFER_TOKEN;

    IF_DNSDBG( SECURITY )
    {
        DnsPrint_Lock();
        DNS_PRINT((
            "Doing VerifySignature() on packet %p.\n"
            "\tpSecPack     = %p\n"
            "\tpSecCntxt    = %p\n",
            pmsgHead,
            pSecPack,
            psecCtxt
            ));
        DNS_PRINT((
            "Verify sig info:\n"
            "\tsign data buf    %p\n"
            "\t  length         %d\n"
            "\tsignature buf    %p (in packet)\n"
            "\t  length         %d\n",
            buffer[0].pvBuffer,
            buffer[0].cbBuffer,
            buffer[1].pvBuffer,
            buffer[1].cbBuffer
            ));
        DnsDbg_RawOctets(
            "Signing buffer:",
            NULL,
            buffer[0].pvBuffer,
            buffer[0].cbBuffer
            );
        DnsDbg_RawOctets(
            "Signature:",
            NULL,
            buffer[1].pvBuffer,
            buffer[1].cbBuffer
            );
        DnsDbg_SecurityContext(
            "Verify context",
            psecCtxt );
        DnsPrint_Unlock();
    }

    status = g_pSecurityFunctionTable->VerifySignature(
                    & psecCtxt->hSecHandle,
                    & bufferDesc,
                    0,
                    NULL
                    );

    if ( status != SEC_E_OK )
    {
        IF_DNSDBG( SECURITY )
        {
            DnsPrint_Lock();
            DNS_PRINT((
                "ERROR:  TSIG does not match on packet %p.\n"
                "\tVerifySignature() status = %d (%08x)\n"
                "\tpSecPack     = %p\n"
                "\tpSecCntxt    = %p\n"
                "\thSecHandle   = %p\n",
                pmsgHead,
                status, status,
                pSecPack,
                psecCtxt,
                & psecCtxt->hSecHandle
                ));
            DNS_PRINT((
                "Verify sig info:\n"
                "\tsign data buf    %p\n"
                "\t  length         %d\n"
                "\tsignature buf    %p (in packet)\n"
                "\t  length         %d\n",
                buffer[0].pvBuffer,
                buffer[0].cbBuffer,
                buffer[1].pvBuffer,
                buffer[1].cbBuffer
                ));
            DnsDbg_RawOctets(
                "Signing buffer:",
                NULL,
                buffer[0].pvBuffer,
                buffer[0].cbBuffer
                );
            DnsDbg_RawOctets(
                "Signature:",
                NULL,
                buffer[1].pvBuffer,
                buffer[1].cbBuffer
                );
            DnsDbg_SecurityContext(
                "Verify failed context",
                psecCtxt );
            DnsDbg_MessageNoContext(
                "Message TSIG verify failed on:",
                pmsgHead,
                0 );
            DnsPrint_Unlock();
        }
        SecTsigVerifyFailed++;
        returnExtendedRcode = DNS_RCODE_BADSIG;
        goto Exit;
    }

    SecTsigVerifySuccess++;

Exit:

    //  free signing data buffer

    FREE_HEAP( pbufStart );

    //  if failed with extended RCODE, set for return

    if ( returnExtendedRcode )
    {
        pSecPack->ExtendedRcode = returnExtendedRcode;
        status = DNS_ERROR_FROM_RCODE( returnExtendedRcode );
    }

    DNSDBG( SECURITY, (
        "Leave VerifySignatureOnPacket( %p )\n"
        "\tstatus       %d (%08x)\n"
        "\text RCODE    %d\n",
        pmsgHead,
        status, status,
        pSecPack->ExtendedRcode ));

    return( status );
}



//
//  Client session routines
//

DNS_STATUS
Dns_NegotiateTkeyWithServer(
    OUT     PHANDLE         phContext,
    IN      DWORD           dwFlag,
    IN      LPSTR           pszNameServer,
    IN      PIP_ARRAY       aipServer,
    IN      PCHAR           pCreds,         OPTIONAL
    IN      PCHAR           pszContext,     OPTIONAL
    IN      DWORD           Version
    )
/*++

Routine Description:

    Negotiate TKEY with a DNS server.

Arguments:

    phContext -- addr to recv context (SEC_CNTXT) negotiated

    dwFlags -- flags

    pszNameServer -- server to update

    apiServer -- server to update

    pCreds -- credentials;  if not given use default process creds

    pszContext -- security context name;  name for unique negotiated security
        session between client and server;  if not given create made up
        server\pid name for context

    Version -- verion

Return Value:

    ERROR_SUCCESS if successful.
    Error status on failure.

--*/
{
    DNS_STATUS      status;
    PSEC_CNTXT      psecCtxt = NULL;
    SECPACK         secPack;
    PCHAR           pch;
    PWSTR           pcredKey = NULL;
    DNS_SECCTXT_KEY key;
    DWORD           i;
    BOOL            fdoneNegotiate = FALSE;
    PDNS_MSG_BUF    pmsgSend = NULL;
    PDNS_MSG_BUF    pmsgRecv = NULL;
    WORD            length;
    IP_ADDRESS      serverIp = aipServer->AddrArray[0];
    CHAR            defaultContextBuffer[64];
    BOOL            fserverW2K = FALSE;
    DWORD           recvCount;
    PCHAR           pcurrentAfterQuestion;


    DNSDBG( SECURITY, (
        "Enter Dns_NegotiateTkeyWithServer()\n"
        "\tflags        = %08x\n"
        "\tserver IP    = %s\n"
        "\tserver name  = %s\n"
        "\tpCreds       = %p\n"
        "\tcontext      = %s\n",
        dwFlag,
        IP_STRING( serverIp ),
        pszNameServer,
        pCreds,
        pszContext
        ));

    DNS_ASSERT( pszNameServer ); // it better be there!

    //  init first so all error paths are safe

    Dns_InitSecurityPacketInfo( &secPack, NULL );

    //  start security

    status = Dns_StartSecurity( FALSE );
    if ( status != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    //
    //  build key
    //

    RtlZeroMemory(
        &key,
        sizeof(key) );

    //
    //  if have creds, create a "cred key" to uniquely identify
    //

    if ( pCreds )
    {
        pcredKey = MakeCredKey( pCreds );
        if ( !pcredKey )
        {
            DNSDBG( ANY, (
                "Failed cred key alloc -- failing nego!\n" ));
            status = DNS_ERROR_NO_MEMORY;
            goto Cleanup;
        }
        key.pwsCredKey = pcredKey;
    }

    //
    //  context name
    //      - if no context name, concatentate
    //          - process ID
    //          - current user's domain-relative ID
    //      this makes ID unique to process\security context
    //      (IP handles issue of different machines)
    //
    //  versioning note:
    //      - it is NOT necessary to version using the KEY name
    //      - the point is to allow us to easily interoperate with previous
    //      client versions which may have bugs relative to the final spec
    //
    //  versions so far
    //      - W2K beta2 (-02) included XID
    //      - W2K (-03) sent TKEY in answer and used "gss.microsoft.com"
    //          as algorithm name
    //      - SP1(or2) and whistler beta2 (-MS-04) used "gss-tsig"
    //      - XP post beta 2 (-MS-05) generates unique context name to
    //          avoid client collisions
    //      - XP RC1 (-MS-06) RFC compliant signing with query sig length included
    //      - XP RC2+ canonicalization of TSIG name in signing buffer
    //
    //  server version use:
    //      - the Win2K server does detect version 02 and fixup the XID
    //      signing to match client
    //      - current (whistler) server does NOT use the version field
    //
    //      however to enable server to detect whistler beta2 client --
    //      just in case there's another problem relative to the spec --
    //      i'm maintaining field;
    //      however note that the field will be 04, even if the client
    //      realizes it is talking to a W2K server and falls back to W2K
    //      client behavior;  in other words NEW server will see 04, but
    //      W2K server only knows it is NOT talking to 02 server which is
    //      all it cares about;
    //
    //      key idea:  this can be used to detect a particular MS client
    //          when there's a behavior question ... but it is NOT a spec'd
    //          versioning mechanism and other clients will come in with
    //          no version tag and must be treated per spec
    //
    //  Key string selection: it is important that the key string be
    //  in "canonical" form as per RFC 2535 section 8.1 - basically this
    //  means lower case. Since the key string is canonical it doesn't
    //  matter if the server does or doesn't canonicalize the string
    //  when building the signing buffer.
    //

    if ( Version == 0 )
    {
        Version = TKEY_VERSION_CURRENT;
    }

    if ( !pszContext )
    {
        sprintf(
            defaultContextBuffer,
            "%d-ms-%d",
            //Dns_GetCurrentRid(),
            GetCurrentProcessId(),
            Version );

        pszContext = defaultContextBuffer;

        DNSDBG( SECURITY, (
            "Generated secure update key context %s\n",
            pszContext ));
    }
    key.pszClientContext = pszContext;

    //
    //  check for negotiated security context
    //      - check for context to any of server IPs
    //      - dump, if partially negotiated or forcing renegotiated
    //

    for( i=0; i<aipServer->AddrCount; i++ )
    {
        key.IpRemote = aipServer->AddrArray[i];

        psecCtxt = Dns_DequeueSecurityContextByKey( key, TRUE );
        if ( psecCtxt )
        {
            if ( !psecCtxt->fNegoComplete ||
                  (dwFlag & DNS_UPDATE_FORCE_SECURITY_NEGO) )
            {
                DNSDBG( ANY, (
                    "Warning:  Deleting context to negotiate a new one.\n"
                    "\tKey: [%s, %s]\n"
                    "\tReason: %s\n",
                    IP_STRING( key.IpRemote ),
                    key.pszTkeyName,
                    psecCtxt->fNegoComplete
                        ? "User specified FORCE_SECURITY_NEGO flag."
                        : "Incomplete negotiation key exists." ));

                Dns_FreeSecurityContext( psecCtxt );
            }
            else    // have valid context -- we're done!
            {
                ASSERT( psecCtxt->fNegoComplete );
                DNSDBG( SECURITY, (
                    "Returning existing negotiated context at %p\n",
                    psecCtxt ));
                goto Cleanup;
            }
        }
    }

    //
    //  create new context and security packet info
    //      - use first server IP in key
    //

    key.IpRemote = serverIp;
    psecCtxt = Dns_FindOrCreateSecurityContext( key );
    if ( !psecCtxt )
    {
        status = DNS_RCODE_SERVER_FAILURE;
        goto Cleanup;
    }
    secPack.pSecContext = psecCtxt;
    psecCtxt->Version = Version;

    //
    //  have creds -- get cred handle
    //

    if ( pCreds )
    {
        status = Dns_AcquireCredHandle(
                    &psecCtxt->CredHandle,
                    FALSE,          // client
                    pCreds );

        if ( status != ERROR_SUCCESS )
        {
            DNSDBG( SECURITY, (
                "Failed AcquireCredHandle -- failing nego!\n" ));
            goto Cleanup;
        }
        psecCtxt->fHaveCredHandle = TRUE;
    }

    //  allocate message buffers

    length = DNS_TCP_DEFAULT_ALLOC_LENGTH;

    pmsgSend= Dns_AllocateMsgBuf( length );
    if ( !pmsgSend)
    {
        DNS_PRINT(( "ERROR:  failed allocation.\n" ));
        status = GetLastError();
        goto Cleanup;
    }
    pmsgRecv = Dns_AllocateMsgBuf( length );
    if ( !pmsgRecv )
    {
        DNS_PRINT(( "ERROR:  failed allocation.\n"));
        status = GetLastError();
        goto Cleanup;
    }

    //  init remote sockaddr and socket
    //  setup receive buffer for TCP

    DnsInitializeMsgRemoteSockaddr(
        pmsgSend,
        serverIp );

    pmsgSend->Socket = 0;
    pmsgSend->fTcp = TRUE;

    SET_MESSAGE_FOR_TCP_RECV( pmsgRecv );
    pmsgRecv->Timeout = SECURE_UPDATE_TCP_TIMEOUT;

    //
    //  build packet
    //      - query opcode
    //      - leave non-recursive (so downlevel server doesn't recurse query)
    //      - write TKEY question
    //      - write TKEY itself
    //

    pch = Dns_WriteQuestionToMessage(
                pmsgSend,
                psecCtxt->Key.pszTkeyName,
                DNS_TYPE_TKEY,
                FALSE           // not unicode
                );
    if ( !pch )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    pcurrentAfterQuestion = pch;

    pmsgSend->MessageHead.RecursionDesired = 0;
    pmsgSend->MessageHead.Opcode = DNS_OPCODE_QUERY;

    //
    //  init XID to something fairly random
    //

    pmsgSend->MessageHead.Xid = Dns_GetRandomXid( pmsgSend );


    //
    //  for given server send in a loop
    //      - write TKEY context to packet
    //      - send \ recv
    //      - may have multiple sends until negotiate a TKEY
    //

    while ( 1 )
    {
        //  setup session context
        //  on first pass this just builds our context,
        //  on second pass we munge in servers response

        status = Dns_InitClientSecurityContext(
                        &secPack,
                        pszNameServer,
                        & fdoneNegotiate
                        );

        //  always recover context pointer, as bad context may be deleted

        psecCtxt = secPack.pSecContext;
        ASSERT( psecCtxt ||
                (status != ERROR_SUCCESS && status != DNS_STATUS_CONTINUE_NEEDED) );

        if ( status == ERROR_SUCCESS )
        {
            DNSDBG( SECURITY, ( "Successfully negotiated TKEY.\n" ));
            ASSERT( psecCtxt->fNegoComplete );

            //
            //  if completed and remote packet had SIG -- verify SIG
            //

            status = Dns_ExtractGssTsigFromMessage(
                        &secPack,
                        & pmsgRecv->MessageHead,
                        DNS_MESSAGE_END( pmsgRecv )
                        );
            if ( status == ERROR_SUCCESS )
            {
                status = Dns_VerifySignatureOnPacket( &secPack );
                if ( status != ERROR_SUCCESS )
                {
                    DNSDBG( SECURITY, (
                        "Verify signature failed on TKEY nego packet %p.\n"
                        "\tserver   = %s\n"
                        "\tstatus   = %d (%08x)\n"
                        "\treturning BADSIG\n",
                        pmsgRecv,
                        IP_STRING( serverIp ),
                        status, status ));
                    status = DNS_ERROR_RCODE_BADSIG;
                }
            }
            else if ( status == DNS_STATUS_PACKET_UNSECURE )
            {
                DNSDBG( SECURITY, (
                    "WARNING:  Unsigned final TKEY nego response packet %p.\n"
                    "\tfrom server %s\n",
                    pmsgRecv,
                    IP_STRING( serverIp ) ));
                status = ERROR_SUCCESS;
            }

            //  nego is done, break out of nego loop
            //  any other error on TSIG, falls through as failure

            break;
        }

        //
        //  if not complete, then anything other than continue is failure
        //

        else if ( status != DNS_STATUS_CONTINUE_NEEDED )
        {
            goto Cleanup;
        }

        //
        //  loop for sign and send
        //
        //  note this is only in a loop to enable backward compatibility
        //  with "TKEY-in-answer" bug in Win2000 DNS server
        //

        recvCount = 0;

        while ( 1 )
        {
            //
            //  backward compatibility with Win2000 TKEY
            //      - set version to write like W2K
            //      - reset packet to just-wrote-question state
            //

            if ( fserverW2K  &&  recvCount == 0 )
            {
                psecCtxt->Version = TKEY_VERSION_W2K;

                pmsgSend->pCurrent = pcurrentAfterQuestion;
                pmsgSend->MessageHead.AdditionalCount = 0;
                pmsgSend->MessageHead.AnswerCount = 0;

                Dns_CloseConnection( pmsgSend->Socket );
                pmsgSend->Socket = 0;
            }

            //
            //  write security record with context into packet
            //
            //  note:  fNeedTkeyInAnswer determines whether write
            //          to Answer or Additional section
    
            status = Dns_WriteGssTkeyToMessage(
                        (HANDLE) &secPack,
                        & pmsgSend->MessageHead,
                        pmsgSend->pBufferEnd,
                        & pmsgSend->pCurrent,
                        FALSE                   // client
                        );
            if ( status != ERROR_SUCCESS )
            {
                goto Cleanup;
            }

            //
            //  if finished negotiation -- sign
            //
            
            if ( fdoneNegotiate )
            {
                DNSDBG( SECURITY, (
                    "Signing TKEY packet at %p, after successful nego.\n",
                    pmsgSend ));
            
                status = Dns_SignMessageWithGssTsig(
                            & secPack,
                            & pmsgSend->MessageHead,
                            pmsgSend->pBufferEnd,
                            & pmsgSend->pCurrent
                            );
                if ( status != ERROR_SUCCESS )
                {
                    DNSDBG( SECURITY, (
                        "ERROR:  Failed signing TKEY packet at %p, after successful nego.\n"
                        "\tsending without TSIG ...\n",
                        pmsgSend ));
                }
            }
            
            //
            //  if already connected, send
            //  if first pass, try server IPs, until find one to can connect to
            //
            
            if ( pmsgSend->Socket )
            {
                status = DnsSend( pmsgSend );
            }
            else
            {
                for( i=0; i<aipServer->AddrCount; i++ )
                {
                    serverIp = aipServer->AddrArray[i];
            
                    status = Dns_OpenTcpConnectionAndSend(
                                     pmsgSend,
                                     serverIp,
                                     TRUE );
                    if ( status != ERROR_SUCCESS )
                    {
                        if ( pmsgSend->Socket )
                        {
                            Dns_CloseSocket( pmsgSend->Socket );
                            pmsgSend->Socket = 0;
                        }
                        continue;
                    }
                    psecCtxt->Key.IpRemote = serverIp;
                    break;
                }
            }
            if ( status != ERROR_SUCCESS )
            {
                goto Done;
            }
            
            //
            //  receive response
            //      - if successful receive, done
            //      - if timeout continue
            //      - other errors indicate some setup or system level
            //          problem
            //
            
            pmsgRecv->Socket = pmsgSend->Socket;
            
            status = Dns_RecvTcp( pmsgRecv );
            if ( status != ERROR_SUCCESS )
            {
                //  W2K server may "eat" bad TKEY packet
                //  if just got a connection, and then timed out, good
                //  chance the problem is W2K server

                if ( status == ERROR_TIMEOUT &&
                     recvCount == 0 &&
                     !fserverW2K )
                {
                    DNS_PRINT(( "Timeout on TKEY nego -- retry with W2K protocol.\n" ));
                    fserverW2K = TRUE;
                    recvCount = 0;
                    continue;
                }

                //  indicate error only with this server by setting RCODE
                pmsgRecv->MessageHead.ResponseCode = DNS_RCODE_SERVER_FAILURE;
                goto Done;
            }
            recvCount++;
            
            //
            //  verify XID match
            //
            
            if ( pmsgRecv->MessageHead.Xid != pmsgSend->MessageHead.Xid )
            {
                DNS_PRINT(( "ERROR:  Incorrect XID in response. Ignoring.\n" ));
                goto Done;
            }

            //
            //  RCODE failure
            //
            //  special case Win2K gold DNS server accepting only TKEY
            //  in Answer section
            //      - rcode FORMERR
            //      - haven't already switched to Additional (prevent looping)
            //      

            if ( pmsgRecv->MessageHead.ResponseCode != DNS_RCODE_NO_ERROR )
            {
                if ( pmsgRecv->MessageHead.ResponseCode == DNS_RCODE_FORMERR &&
                     ! fserverW2K &&
                     recvCount == 1 )
                {
                    DNS_PRINT(( "Formerr TKEY nego -- retry with W2K protocol.\n" ));
                    fserverW2K = TRUE;
                    recvCount = 0;
                    continue;
                }

                //  done with this server, may be able to continue with others
                //  depending on RCODE

                goto Done;
            }

            //  successful send\recv

            break;
        }

        //
        //  not yet finished negotiation
        //  use servers security context to reply to server
        //  if server replied with original context then it is unsecure
        //      => we're done
        //

        status = Dns_ExtractGssTkeyFromMessage(
                    (HANDLE) &secPack,
                    &pmsgRecv->MessageHead,
                    DNS_MESSAGE_END( pmsgRecv ),
                    FALSE               //  fIsServer
                    );
        if ( status != ERROR_SUCCESS )
        {
            if ( status == DNS_STATUS_PACKET_UNSECURE )
            {
                DNSDBG( SECURITY, (
                    "Unsecure update response from server %s.\n"
                    "\tupdate considered successful, quiting.\n",
                    IP_STRING( aipServer->AddrArray[i] ) ));
                status = ERROR_SUCCESS;
                ASSERT( FALSE );
                goto Cleanup;
            }
            break;
        }
    }

Done:

    //
    //  check response code
    //      - consider some response codes
    //

    switch( status )
    {
    case ERROR_SUCCESS:
        status = Dns_MapRcodeToStatus( pmsgRecv->MessageHead.ResponseCode );
        break;

    case ERROR_TIMEOUT:

        DNS_PRINT((
            "ERROR:  connected to server at %s\n"
            "\tbut no response to packet at %p\n",
            MSG_REMOTE_IP_STRING( pmsgSend ),
            pmsgSend
            ));
        break;

    default:

        DNS_PRINT((
            "ERROR:  connected to server at %s to send packet %p\n"
            "\tbut error %d (%08x) encountered on receive.\n",
            MSG_REMOTE_IP_STRING( pmsgSend ),
            pmsgSend,
            status, status
            ));
        break;
    }

Cleanup:

    DNSDBG( SECURITY, (
        "Leaving Dns_NegotiateTkeyWithServer() status = %08x (%d)\n",
        status, status ));

    //
    //  if successful return context handle
    //  if not returned or cached, clean up
    //

    if ( status == ERROR_SUCCESS )
    {
        if ( phContext )
        {
            *phContext = (HANDLE) psecCtxt;
            psecCtxt = NULL;
        }
        else if ( dwFlag & DNS_UPDATE_CACHE_SECURITY_CONTEXT )
        {
            Dns_EnlistSecurityContext( psecCtxt );
            psecCtxt = NULL;
        }
    }

    if ( psecCtxt )
    {
        Dns_FreeSecurityContext( psecCtxt );
    }

    //  cleanup session info

    Dns_CleanupSecurityPacketInfoEx( &secPack, FALSE );

    //  close connection

    if ( pmsgSend && pmsgSend->Socket )
    {
        Dns_CloseConnection( pmsgSend->Socket );
    }

    //
    //  DCR_CLEANUP:  what's the correct screening here for error codes?
    //      possibly should take all security errors to
    //          status = DNS_ERROR_RCODE_BADKEY;
    //      or some to some status that means unsecure server
    //          and leave BADKEY for actual negotiations that yield bad token
    //

    FREE_HEAP( pmsgRecv );
    FREE_HEAP( pmsgSend );
    FREE_HEAP( pcredKey );

    return( status );
}



DNS_STATUS
Dns_DoSecureUpdate(
    IN      PDNS_MSG_BUF        pMsgSend,
    OUT     PDNS_MSG_BUF        pMsgRecv,
    IN OUT  PHANDLE             phContext,
    IN      DWORD               dwFlag,
    IN      PDNS_NETINFO        pNetworkInfo,
    IN      PIP_ARRAY           aipServer,
    IN      LPSTR               pszNameServer,
    IN      PCHAR               pCreds,         OPTIONAL
    IN      PCHAR               pszContext      OPTIONAL
    )
/*++

Routine Description:

    Main client routine to do secure update.

Arguments:

    pMsgSend - message to send

    ppMsgRecv - and reuse

    aipServer -- IP array DNS servers

    pNetworkInfo -- network info blob for update

    pszNameServer -- name server name

    pCreds -- credentials;  if not given use default process creds

    pszContext -- name for security context;  this is unique name for
        session between this process and this server with these creds

Return Value:

    ERROR_SUCCESS if successful.
    Error status on failure.

--*/
{
#define FORCE_VERSION_OLD   ("Force*Version*Old")

    DNS_STATUS  status = ERROR_SUCCESS;
    PSEC_CNTXT  psecCtxt = NULL;
    DWORD       i;
    INT         retry;
    IP_ADDRESS  serverIp = aipServer->AddrArray[0];
    SECPACK     secPack;
#if 0
    DWORD       version;
#endif


    DNS_ASSERT( pMsgSend->MessageHead.Opcode == DNS_OPCODE_UPDATE );
    DNS_ASSERT( serverIp && pszNameServer );    // it better be there!

    DNSDBG( SEND, (
        "Enter Dns_DoSecureUpdate()\n"
        "\tsend msg at  %p\n"
        "\tsec context  %p\n"
        "\tserver name  %s\n"
        "\tserver IP    %s\n"
        "\tpCreds       %p\n"
        "\tcontext      %s\n",
        pMsgSend,
        phContext ? *phContext : NULL,
        pszNameServer,
        IP_STRING( serverIp ),
        pCreds,
        pszContext
        ));

    //
    //  version setting
    //
    //  note:  to set different version we'd need some sort of tag
    //      like pszContext (see example)
    //  but a better way to do this would be tail recursion in just
    //  NegotiateTkey -- unless there's a reason to believe the nego
    //  would be successful with old version, but the update still fail
    //

#if 0
    iversion = TKEY_CURRENT_VERSION;

    if ( pszContext && strcmp(pszContext, FORCE_VERSION_OLD) == 0 )
    {
        iversion = TKEY_VERSION_OLD;
        pszContext = NULL;
    }
#endif

    //  init security packet info

    Dns_InitSecurityPacketInfo( &secPack, NULL );

    //
    //  loop
    //      - get valid security context
    //      - connect to server
    //      - do update
    //
    //  loop to allow retry with new security context if server
    //  rejects existing one
    //

    retry = 0;

    while ( 1 )
    {
        //  clean up any previous connection
        //  cache security context if negotiated one

        if ( retry )
        {
            if ( pMsgSend->fTcp )
            {
                DnsCloseConnection( pMsgSend->Socket );
            }
            if ( psecCtxt )
            {
                Dns_EnlistSecurityContext( psecCtxt );
                psecCtxt = NULL;
            }
        }
        retry++;

        //
        //  passed in security context?
        //

        if ( phContext )
        {
            psecCtxt = *phContext;
        }

        //
        //  no existing security context
        //      - see if one is cached
        //      - otherwise, negotiate one with server
        //

        if ( !psecCtxt )
        {
            status = Dns_NegotiateTkeyWithServer(
                        & psecCtxt,
                        dwFlag,
                        pszNameServer,
                        aipServer,
                        pCreds,
                        pszContext,
                        0                   // use current version
                        //iversion          // if need versioning
                        );
            if ( status != ERROR_SUCCESS )
            {
                //  note:  if failed we could do a version retry here

                goto Cleanup;
            }
            ASSERT( psecCtxt );
        }

        //
        //  init XID to something fairly random
        //

        pMsgSend->MessageHead.Xid = Dns_GetRandomXid( psecCtxt );

        //
        //  DCR_PERF:  nego should try UDP, if doesn't fit (attaching TSIG) TCP
        //      especially useful down the road with OPT and large packets
        //

        //
        //  init remote sockaddr and socket
        //  setup receive buffer for TCP
        //  set timeout and receive
        //

        DnsInitializeMsgRemoteSockaddr(
            pMsgSend,
            serverIp );

        pMsgSend->Socket = 0;

        SET_MESSAGE_FOR_TCP_RECV( pMsgRecv );

        if ( pMsgRecv->Timeout == 0 )
        {
            pMsgRecv->Timeout = SECURE_UPDATE_TCP_TIMEOUT;
        }

        //
        //  write security record with context into packet
        //

        Dns_ResetSecurityPacketInfo( &secPack );

        secPack.pSecContext = psecCtxt;

        status = Dns_SignMessageWithGssTsig(
                    & secPack,
                    & pMsgSend->MessageHead,
                    pMsgSend->pBufferEnd,
                    & pMsgSend->pCurrent
                    );
        if ( status != ERROR_SUCCESS )
        {
            goto Cleanup;
        }

        //
        //  need TCP
        //

        if ( DNS_MESSAGE_CURRENT_OFFSET(pMsgSend) > DNS_RFC_MAX_UDP_PACKET_LENGTH )
        {
            //
            //  connect and send
            //  try server IPs, until find one to can connect to
            //

            pMsgSend->fTcp = TRUE;

            for( i=0; i<aipServer->AddrCount; i++ )
            {
                serverIp = aipServer->AddrArray[i];

                status = Dns_OpenTcpConnectionAndSend(
                                 pMsgSend,
                                 serverIp,
                                 TRUE );
                if ( status != ERROR_SUCCESS )
                {
                    if ( pMsgSend->Socket )
                    {
                        Dns_CloseSocket( pMsgSend->Socket );
                        pMsgSend->Socket = 0;
                        continue;
                    }
                }
                psecCtxt->Key.IpRemote = serverIp;
                break;
            }
            pMsgRecv->Socket = pMsgSend->Socket;

            //  receive response
            //      - if successful receive, done
            //      - if timeout continue
            //      - other errors indicate some setup or system level
            //          problem

            status = Dns_RecvTcp( pMsgRecv );

            if ( status != ERROR_SUCCESS )
            {
                //  indicate error only with this server by setting RCODE
                pMsgRecv->MessageHead.ResponseCode = DNS_RCODE_SERVER_FAILURE;
                goto Cleanup;
            }
        }

        //
        //  use UDP
        //

        else
        {
            pMsgSend->fTcp = FALSE;
            SET_MESSAGE_FOR_UDP_RECV( pMsgRecv );

            status = Dns_SendAndRecvUdp(
                        pMsgSend,
                        pMsgRecv,
                        0,
                        NULL,
                        pNetworkInfo );
            if ( status != ERROR_SUCCESS )
            {
                goto Cleanup;
            }
        }

        //
        //  verify XID match
        //

        if ( pMsgRecv->MessageHead.Xid != pMsgSend->MessageHead.Xid )
        {
            DNS_PRINT(( "ERROR:  Incorrect XID in response. Ignoring.\n" ));
            goto Cleanup;
        }

        //
        //  check RCODE,  if REFUSED and TSIG extended error, then may simply
        //      need to refresh the TKEY
        //

        if ( pMsgRecv->MessageHead.ResponseCode != DNS_RCODE_NO_ERROR )
        {
            if ( pMsgRecv->MessageHead.ResponseCode == DNS_RCODE_REFUSED )
            {
                status = Dns_ExtractGssTsigFromMessage(
                            & secPack,
                            & pMsgRecv->MessageHead,
                            DNS_MESSAGE_END(pMsgRecv)
                            );
                if ( status != ERROR_SUCCESS )
                {
                    if ( secPack.pTsigRR && secPack.pTsigRR->Data.TSIG.wError && retry==1 )
                    {
                        DNSDBG( SECURITY, (
                            "TSIG signed query (%p) rejected with %d and\n"
                            "\textended RCODE = %d\n"
                            "\tretrying rebuilding new TKEY\n",
                            pMsgSend,
                            pMsgRecv->MessageHead.ResponseCode,
                            secPack.pTsigRR->Data.TSIG.wError
                            ));

                        pMsgSend->MessageHead.AdditionalCount = 0;
                        IF_DNSDBG( SECURITY )
                        {
                            DnsDbg_Message(
                                "Update message after reset for retry:",
                                pMsgSend );
                        }
                        Dns_FreeSecurityContext( psecCtxt );
                        psecCtxt = NULL;
                        continue;
                    }
                }
            }

            //  if TSIG done, no point in checking signature
            goto Cleanup;
        }

        //  extract TSIG record
        //      shouldn't get any error

        status = Dns_ExtractGssTsigFromMessage(
                    & secPack,
                    & pMsgRecv->MessageHead,
                    DNS_MESSAGE_END(pMsgRecv)
                    );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT((
                "ERROR:  TSIG parse failed on NO_ERROR response!\n" ));
            //ASSERT( FALSE );
            break;
        }

        //  verify server signature

        status = Dns_VerifySignatureOnPacket( &secPack );
        if ( status != ERROR_SUCCESS )
        {
            //  DCR_LOG:  log event -- been hacked or misbehaving server
            //      or bad bytes in transit

            DNS_PRINT((
                "ERROR:  signature verification failed on update\n"
                "\tto server %s\n",
                IP_STRING( serverIp ) ));
        }
        break;
    }

    //
    //  check response code
    //      - consider some response codes
    //

    switch( status )
    {
    case ERROR_SUCCESS:
        status = Dns_MapRcodeToStatus( pMsgRecv->MessageHead.ResponseCode );
        break;

    case ERROR_TIMEOUT:

        DNS_PRINT((
            "ERROR:  connected to server at %s\n"
            "\tbut no response to packet at %p\n",
            MSG_REMOTE_IP_STRING( pMsgSend ),
            pMsgSend
            ));
        break;

    default:

        DNS_PRINT((
            "ERROR:  connected to server at %s to send packet %p\n"
            "\tbut error %d encountered on receive.\n",
            MSG_REMOTE_IP_STRING( pMsgSend ),
            pMsgSend,
            status
            ));
        break;
    }

Cleanup:

    //
    //  save security context?
    //

    if ( psecCtxt )
    {
        if ( dwFlag & DNS_UPDATE_CACHE_SECURITY_CONTEXT )
        {
            Dns_EnlistSecurityContext( psecCtxt );
            if ( phContext )
            {
                *phContext = NULL;
            }
        }
        else if ( phContext )
        {
            *phContext = (HANDLE) psecCtxt;
        }
        else
        {
            Dns_FreeSecurityContext( psecCtxt );
        }
    }

    if ( pMsgSend->fTcp )
    {
        DnsCloseConnection( pMsgSend->Socket );
    }

    //
    //  free security packet session sub-allocations
    //      - structure itself is on the stack

    Dns_CleanupSecurityPacketInfoEx( &secPack, FALSE );

#if 0
    //
    //  versioning failure retry?
    //  if failed, reenter function forcing old version
    //

    if ( status != ERROR_SUCCESS &&
        status != DNS_ERROR_RCODE_NOT_IMPLEMENTED &&
        iversion != TKEY_VERSION_OLD )
    {
        DNS_PRINT((
            "SecureUpdate failed with status == %d\n"
            "\tRetrying forcing version %d signing.\n",
            status,
            TKEY_VERSION_OLD ));

        status = Dns_DoSecureUpdate(
                    pMsgSend,
                    pMsgRecv,
                    phContext,
                    dwFlag,
                    pNetworkInfo,
                    aipServer,
                    pszNameServer,
                    pCreds,
                    FORCE_VERSION_OLD
                    );
    }
#endif

    return( status );
}



//
//  Server security session routines
//

DNS_STATUS
Dns_FindSecurityContextFromAndVerifySignature(
    OUT     PHANDLE         phContext,
    IN      IP_ADDRESS      IpRemote,
    IN      PDNS_HEADER     pMsgHead,
    IN      PCHAR           pMsgEnd
    )
/*++

Routine Description:

    Find security context associated with TSIG and verify
    the signature.

Arguments:

    phContext -- addr to receive context handle

    IpRemote -- IP of remote machine

    pMsgHead -- ptr to message head

    pMsgEnd -- ptr to message end (byte past end)
    
Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNS_STATUS      status;
    DNS_SECCTXT_KEY key;
    PSEC_CNTXT      psecCtxt = NULL;
    PSECPACK        psecPack = NULL;

    DNSDBG( SECURITY, (
        "Dns_FindSecurityContextFromAndVerifySignature()\n"
        ));

    //  security must already be running to have negotiated a TKEY

    if ( !g_fSecurityPackageInitialized )
    {
        status = Dns_StartServerSecurity();
        if ( status != ERROR_SUCCESS )
        {
            return( DNS_RCODE_SERVER_FAILURE );
        }
    }

    //
    //  read TSIG from packet
    //

    psecPack = Dns_CreateSecurityPacketInfo();
    if ( !psecPack )
    {
        return( DNS_RCODE_SERVER_FAILURE );
    }
    status = Dns_ExtractGssTsigFromMessage(
                psecPack,
                pMsgHead,
                pMsgEnd
                );
    if ( status != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    //
    //  find existing security context
    //      - TSIG name node
    //      - client IP
    //  together specify context
    //

    RtlZeroMemory(
        &key,
        sizeof(key) );

    key.pszTkeyName = psecPack->pszContextName;
    key.IpRemote = IpRemote;

    psecCtxt = Dns_DequeueSecurityContextByKey( key, TRUE );
    if ( !psecCtxt )
    {
        DNSDBG( SECURITY, (
            "Desired security context %s %s is NOT cached.\n"
            "\treturning BADKEY\n",
            key.pszTkeyName,
            IP_STRING( key.IpRemote ) ));
        status = DNS_ERROR_RCODE_BADKEY;
        SecTsigBadKey++;
        goto Cleanup;
    }

    //  attach context to session info

    psecPack->pSecContext = psecCtxt;

    //
    //  verify signature
    //

    status = Dns_VerifySignatureOnPacket( psecPack );
    if ( status != ERROR_SUCCESS )
    {
        DNSDBG( SECURITY, (
            "Verify signature failed %08x %d.\n"
            "\treturning BADSIG\n",
            status, status ));
        status = DNS_ERROR_RCODE_BADSIG;
        goto Cleanup;
    }

Cleanup:

    //  return security info blob
    //  if failed delete session info,
    //      - return security context to cache if failure is just TSIG
    //      being invalid

    if ( status == ERROR_SUCCESS )
    {
        *phContext = psecPack;
    }
    else
    {
        Dns_FreeSecurityPacketInfo( psecPack );
        if ( psecCtxt )
        {
            DNSDBG( SECURITY, (
                "Re-enlisting security context at %p after TSIG verify failure.\n",
                psecCtxt ));
            Dns_EnlistSecurityContext( psecCtxt );
        }
    }
    return( status );
}



DNS_STATUS
Dns_ServerNegotiateTkey(
    IN      IP_ADDRESS      IpRemote,
    IN      PDNS_HEADER     pMsgHead,
    IN      PCHAR           pMsgEnd,
    IN      PCHAR           pMsgBufEnd,
    IN      BOOL            fBreakOnAscFailure,
    OUT     PCHAR *         ppCurrent
    )
/*++

Routine Description:

    Negotiate TKEY with client.

Arguments:

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

    DCR_CLEANUP:  note this is currently returning RCODEs not status.

--*/
{
    DNS_STATUS      status;
    SECPACK         secPack;
    DNS_SECCTXT_KEY key;
    PSEC_CNTXT      psecCtxt = NULL;
    PSEC_CNTXT      ppreviousContext = NULL;
    WORD            extRcode = 0;


    DNSDBG( SECURITY, (
        "Dns_ServerNegotiateTkey()\n"
        ));

    //  security must already be running to have negotiated a TKEY

    if ( !g_fSecurityPackageInitialized )
    {
        return( DNS_RCODE_REFUSED );
    }

    //
    //  read TKEY from packet
    //

    Dns_InitSecurityPacketInfo( &secPack, NULL );

    status = Dns_ExtractGssTkeyFromMessage(
                & secPack,
                pMsgHead,
                pMsgEnd,
                TRUE );         //  fIsServer

    if ( status != ERROR_SUCCESS )
    {
        DNSDBG( SECURITY, (
            "TKEY Extract failed for msg at %p\n"
            "\tstatus = %d (%08x)\n",
            pMsgHead, status, status ));
        goto Cleanup;
    }

    //
    //  find existing security context from this client
    //      - client IP
    //      - TKEY record
    //  together specify context
    //
    //  if previously negotiated context, doesn't match key length from
    //  new TKEY, then renegotiate
    //

    RtlZeroMemory(
        &key,
        sizeof(key) );

    key.IpRemote    = IpRemote;
    key.pszTkeyName = secPack.pszContextName;

    psecCtxt = Dns_DequeueSecurityContextByKey( key, FALSE );
    if ( psecCtxt )
    {
        ppreviousContext = psecCtxt;

        DNSDBG( SECURITY, (
            "Found security context matching TKEY %s %s.\n",
            key.pszTkeyName,
            IP_STRING( key.IpRemote ) ));

        //
        //  previously negotiated key?
        //
        //  DCR_QUESTION:  no client comeback after server side nego complete?
        //      treating client coming back on server side negotiated context
        //      as NEW context -- not sure this is correct, client may complete
        //      and become negotiated and want to echo
        //
        //  to fix we'd need to hold this issue open and see if got "echo"
        //  in accept
        //

        if ( psecCtxt->fNegoComplete )
        {
            DNSDBG( SECURITY, (
               "WARNING:  Client nego request on existing negotiated context:\n"
               "\tTKEY  %s\n"
               "\tIP    %s\n",
               key.pszTkeyName,
               IP_STRING( key.IpRemote ) ));

            //
            //  for Win2K (through whistler betas) allow clobbering nego
            //
            //  DCR:  pull Whistler Beta support for Win2001 server ship?
            //      against would be JDP deployed whister client\servers
            //      with this?  should be zero by server ship
            //

            if ( psecCtxt->Version == TKEY_VERSION_W2K ||
                 psecCtxt->Version == TKEY_VERSION_WHISTLER_BETA )
            {
                DNSDBG( SECURITY, (
                   "WIN2K context -- overwriting negotiated security context\n"
                   "\twith new negotiation.\n" ));
                psecCtxt = NULL;
            }

            //  post-Win2K clients should ALWAYS send with a new name
            //  nego attempts on negotiated context are attacks
            //
            //  DCR:  again client echo issue here

            else
            {
                DNSDBG( SECURITY, (
                   "ERROR:  post-Win2K client nego request on existing key.\n"
                   "\terroring with BADKEY!\n" ));

                DNS_ASSERT( FALSE );
                psecCtxt = NULL;
                status = DNS_ERROR_RCODE_BADKEY;
                extRcode = DNS_RCODE_BADKEY;
                goto Cleanup;
            }
        }
    }

    //
    //  if context not found, create one
    //      - tag it with version of TKEY found
    //

    if ( !psecCtxt )
    {
        psecCtxt = Dns_FindOrCreateSecurityContext( key );
        if ( !psecCtxt )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Cleanup;
        }
        psecCtxt->Version = secPack.TkeyVersion;
    }

    //
    //  have context -- attach to security session
    //

    secPack.pSecContext = psecCtxt;

    //
    //  accept this security context
    //  if continue needed, then write response TKEY using
    //
    //  DCR_ENHANCE:  in COMPLETE_AND_CONTINUE case should be adding TSIG signing
    //      need to break out this response from ServerAcceptSecurityContext
    //

    status = Dns_ServerAcceptSecurityContext(
                    &secPack,
                    fBreakOnAscFailure );

    if ( status != ERROR_SUCCESS )
    {
        if ( status != DNS_STATUS_CONTINUE_NEEDED )
        {
            DNSDBG( ANY, (
                "FAILURE: ServerAcceptSecurityContext failed status=%d\n",
                status ));
            status = DNS_ERROR_RCODE_BADKEY;
            goto Cleanup;
        }
        status = Dns_WriteGssTkeyToMessage(
                    &secPack,
                    pMsgHead,
                    pMsgBufEnd,
                    ppCurrent,
                    TRUE );             //  fIsServer
        if ( status != ERROR_SUCCESS )
        {
            status = DNS_RCODE_SERVER_FAILURE;
            goto Cleanup;
        }

        //
        //  sign packet if we are now completed
        //

        if ( psecCtxt->fNegoComplete )
        {
            goto Sign;
        }
        goto Cleanup;
    }

    //
    //  verify signature, if present
    //

    status = Dns_ExtractGssTsigFromMessage(
                &secPack,
                pMsgHead,
                pMsgEnd
                );
    if ( status == ERROR_SUCCESS )
    {
        status = Dns_VerifySignatureOnPacket( &secPack );
        if ( status != ERROR_SUCCESS )
        {
            DNSDBG( SECURITY, (
                "Verify signature failed on TKEY nego packet %p.\n"
                "\tstatus = %d (%08x)\n"
                "\treturning BADSIG\n",
                pMsgHead,
                status, status ));
            status = DNS_ERROR_RCODE_BADSIG;
            extRcode = DNS_RCODE_BADSIG;
        }
    }
    else if ( status == DNS_STATUS_PACKET_UNSECURE )
    {
        status = ERROR_SUCCESS;
    }
    else
    {
        extRcode = DNS_RCODE_BADSIG;
    }

    //
    //  sign server's response
    //

Sign:

    DNSDBG( SECURITY, (
        "Signing TKEY nego packet at %p after nego complete\n"
        "\tstatus = %d (%08x)\n"
        "\textRcode = %d\n",
        pMsgHead,
        status, status,
        extRcode ));

    pMsgHead->IsResponse = TRUE;

    status = Dns_SignMessageWithGssTsig(
                &secPack,
                pMsgHead,
                pMsgBufEnd,
                ppCurrent );

    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT((
            "ERROR: failed to sign successful TKEY nego packet at %p\n"
            "\tstatus = %d (%08x)\n",
            pMsgHead,
            status, status ));

        status = ERROR_SUCCESS;
    }

Cleanup:

    //
    //  if failed, respond in in TKEY extended error field
    //
    //  if extended RCODE not set above
    //      - default to BADKEY
    //      - unless status is extended RCODE
    //

    if ( status != ERROR_SUCCESS )
    {
        if ( !secPack.pTkeyRR )
        {
            status = DNS_RCODE_FORMERR;
        }
        else
        {
            if ( secPack.ExtendedRcode == 0 )
            {
                if ( extRcode == 0 )
                {
                    extRcode = DNS_RCODE_BADKEY;
                    if ( status > DNS_ERROR_RCODE_BADSIG &&
                        status < DNS_ERROR_RCODE_LAST )
                    {
                        extRcode = (WORD)(status - DNS_ERROR_MASK);
                    }
                }

                //  write extended RCODE directly into TKEY extRCODE field
                //      - it is a DWORD (skipping KeyLength) before Key itself

                INLINE_WRITE_FLIPPED_WORD(
                    ( secPack.pTkeyRR->Data.TKEY.pKey - sizeof(DWORD) ),
                    extRcode );
            }
            status = DNS_RCODE_REFUSED;
        }
    }

    //
    //  if successful
    //      - whack any previous context with new context
    //  if failed
    //      - restore any previous context, if any
    //      - dump any new failed context
    //
    //  this lets us clients retry in any state they like, yet preserves
    //  any existing negotiation, if this attempt was security attack or bad data
    //  but if client successful in this negotiation, then any old context is
    //      dumped
    //

    if ( status == ERROR_SUCCESS )
    {
        ASSERT( secPack.pSecContext == psecCtxt );

        if ( ppreviousContext != psecCtxt )
        {
            Dns_FreeSecurityContext( ppreviousContext );
        }
        DNSDBG( SECURITY, (
            "Re-enlisting security context at %p\n",
            psecCtxt ));
        Dns_EnlistSecurityContext( psecCtxt );
    }
    else
    {
        DNSDBG( SECURITY, (
            "Failed nego context at %p\n"
            "\tstatus           = %d\n"
            "\text RCODE        = %d\n"
            "\tclient IP        = %s\n"
            "\tTKEY name        = %s\n"
            "\tnego complete    = %d\n",
            psecCtxt,
            status,
            extRcode,
            psecCtxt ? IP_STRING( psecCtxt->Key.IpRemote ) : "NULL",
            psecCtxt ? psecCtxt->Key.pszTkeyName : "NULL",
            psecCtxt ? psecCtxt->fNegoComplete : 0 ));

        //  free any new context that failed in nego -- if any

        if ( psecCtxt )
        {
            Dns_FreeSecurityContext( psecCtxt );
        }

        //
        //  reenlist any previously negotiated context
        //
        //  the reenlistment protects against denial of service attack
        //  that spoofs client and attempts to trash their context,
        //  either during nego or after completed
        //
        //  however, must dump Win2K contexts as clients can reuse
        //  the TKEY name and may NOT have saved the context;  this
        //  produces BADKEY from AcceptSecurityContext() and must
        //  cause server to dump to reopen TKEY name to client
        //

        //  DCR_QUESTION:  is it possible to "reuse" partially nego'd context
        //      that fails further negotiation
        //      in other words can we protect against DOS attack in the middle
        //      of nego that tries to message with nego, by requeuing the context
        //      so real nego can complete?
        

        if ( ppreviousContext &&
             ppreviousContext != psecCtxt )
        {
            DNS_ASSERT( ppreviousContext->fNegoComplete );

            DNSDBG( ANY, (
                "WARNING:  reenlisting security context %p after failed nego\n"
                "\tthis indicates client problem OR security attack!\n"
                "\tclient IP        = %s\n"
                "\tTKEY name        = %s\n"
                "\tnego complete    = %d\n",
                ppreviousContext,
                IP_STRING( ppreviousContext->Key.IpRemote ),
                ppreviousContext->Key.pszTkeyName,
                ppreviousContext->fNegoComplete ));
    
            Dns_EnlistSecurityContext( ppreviousContext );
        }
    }

    //  cleanup security packet info
    //      - parsed records, buffers, etc
    //      - stack struct, no free

    Dns_CleanupSecurityPacketInfoEx( &secPack, FALSE );

    return( status );
}



VOID
Dns_CleanupSessionAndEnlistContext(
    IN OUT  HANDLE          hSession
    )
/*++

Routine Description:

    Cleanup security session and return context to cache.

Arguments:

    hSession -- session handle (security packet info)

Return Value:

    None

--*/
{
    PSECPACK        psecPack = (PSECPACK) hSession;

    DNSDBG( SECURITY, (
        "Dns_CleanupSessionAndEnlistContext( %p )\n", psecPack ));

    //  reenlist security context

    Dns_EnlistSecurityContext( psecPack->pSecContext );

    //  cleanup security packet info
    //      - parsed records, buffers, etc
    //      - since handle based, this is free structure

    Dns_CleanupSecurityPacketInfoEx( psecPack, TRUE );
}


//
//  API calling context
//

HANDLE
Dns_CreateAPIContext(
    IN      DWORD           Flags,
    IN      PVOID           Credentials     OPTIONAL,
    IN      BOOL            fUnicode
    )
/*++

 Routine Description:

    Initializes a DNS API context possibly associated with a
    particular set of credentials.

    Flags - Type of credentials pointed to by Credentials

    Credentials - a pointer to a SEC_WINNT_AUTH_IDENTITY structure
                  that contains the user, domain, and password
                  that is to be associated with update security contexts

    fUnicode - ANSI is FALSE, UNICODE is TRUE to indicate version of
               SEC_WINNT_AUTH_IDENTITY structure in Credentials

 Return Value:

    Returns context handle successful; otherwise NULL is returned.


    Structure defined at top of file looks like:

        typedef struct _DnsAPIContext
        {
            DWORD  Flags;
            PVOID  Credentials;
            struct _DnsSecurityContext * pSecurityContext;
        }
        DNS_API_CONTEXT, *PDNS_API_CONTEXT;

 --*/
{
    PDNS_API_CONTEXT pcontext;

    pcontext = (PDNS_API_CONTEXT) ALLOCATE_HEAP_ZERO( sizeof(DNS_API_CONTEXT) );
    if ( !pcontext )
    {
        return( NULL );
    }

    pcontext->Flags = Flags;
    if ( fUnicode )
    {
        pcontext->Credentials = Dns_AllocateAndInitializeCredentialsW(
                                    (PSEC_WINNT_AUTH_IDENTITY_W)Credentials
                                    );
    }
    else
    {
        pcontext->Credentials = Dns_AllocateAndInitializeCredentialsA(
                                    (PSEC_WINNT_AUTH_IDENTITY_A)Credentials
                                    );
    }
    pcontext->pSecurityContext = NULL;

    return( (HANDLE)pcontext );
}


VOID
Dns_FreeAPIContext(
    IN OUT  HANDLE          hContextHandle
    )
/*++

Routine Description:

    Cleans up DNS API context data.

Arguments:

    hContext -- handle to context to clean up

Return Value:

    TRUE if successful
    FALSE otherwise


    Structure defined at top of file looks like:

        typedef struct _DnsAPIContext
        {
            DWORD  Flags;
            PVOID  Credentials;
            struct _DnsSecurityContext * pSecurityContext;
        }
        DNS_API_CONTEXT, *PDNS_API_CONTEXT;

--*/
{
    PDNS_API_CONTEXT pcontext = (PDNS_API_CONTEXT)hContextHandle;

    if ( !pcontext )
    {
        return;
    }

    if ( pcontext->Credentials )
    {
        Dns_FreeAuthIdentityCredentials( pcontext->Credentials );
    }

    if ( pcontext->pSecurityContext )
    {
        Dns_FreeSecurityContext( pcontext->pSecurityContext );
        pcontext->pSecurityContext = NULL;
    }

    FREE_HEAP( pcontext );
}

PVOID
Dns_GetApiContextCredentials(
    IN      HANDLE          hContextHandle
    )
/*++

Routine Description:

    returns pointer to credentials in context handle

Arguments:

    hContext -- handle to context to clean up

Return Value:

    TRUE if successful
    FALSE otherwise


    Structure defined at top of file looks like:

        typedef struct _DnsAPIContext
        {
            DWORD  Flags;
            PVOID  Credentials;
            struct _DnsSecurityContext * pSecurityContext;
        }
        DNS_API_CONTEXT, *PDNS_API_CONTEXT;

--*/
{
    PDNS_API_CONTEXT pcontext = (PDNS_API_CONTEXT)hContextHandle;

    return pcontext ? pcontext->Credentials : NULL;
}




DWORD
Dns_GetCurrentRid(
    VOID
    )
/*++

Routine Description:

    Get RID.  This is used as unique ID for tagging security context.

Arguments:

    None

Return Value:

    Current RID if successful.
    (-1) on error.

--*/
{
    BOOL        bstatus;
    DNS_STATUS  status = ERROR_SUCCESS;
    HANDLE      hToken = NULL;
    PTOKEN_USER puserToken = NULL;
    DWORD       size;
    UCHAR       SubAuthCount;
    DWORD       rid = (DWORD)-1;

    //
    //  get thread/process token
    //

    bstatus = OpenThreadToken(
                    GetCurrentThread(),   // thread pseudo handle
                    TOKEN_QUERY,          // query info
                    TRUE,                 // open as self
                    & hToken );           // returned handle
    if ( !bstatus )
    {
        DNSDBG( SECURITY, (
            "Note <%lu>: failed to open thread token\n",
            GetLastError()));

        //
        //  attempt to open process token
        //      - if not impersonating, this is fine
        //

        bstatus = OpenProcessToken(
                         GetCurrentProcess(),
                         TOKEN_QUERY,
                         & hToken );
        if ( !bstatus )
        {
            status = GetLastError();
            DNSDBG( SECURITY, (
                "Error <%lu>: failed to open process token\n",
                status ));
            ASSERT( FALSE );
            goto Cleanup;
        }
    }

    //
    //  get length required for TokenUser
    //      - specify buffer length of 0
    //

    bstatus = GetTokenInformation(
                    hToken,
                    TokenUser,
                    NULL,
                    0,
                    & size );

    status = GetLastError();
    if ( bstatus  ||  status != ERROR_INSUFFICIENT_BUFFER )
    {
        DNSDBG( SECURITY, (
                "Error <%lu>: unexpected error for token info\n",
                status ));
        ASSERT( FALSE );
        goto Cleanup;
    }

    //
    //  allocate user token
    //

    puserToken = (PTOKEN_USER) ALLOCATE_HEAP( size );
    if ( !puserToken )
    {
        status = GetLastError();
        DNSDBG( SECURITY, (
            "Error <%lu>: failed to allocate memory\n",
            status ));
        ASSERT( FALSE );
        goto Cleanup;
    }

    //
    //  get SID of process token.
    //

    bstatus = GetTokenInformation(
                    hToken,
                    TokenUser,
                    puserToken,
                    size,
                    & size );
    if ( !bstatus )
    {
        status = GetLastError();
        DNSDBG( SECURITY, (
            "Error <%lu>: failed to get user info\n",
            status));
        ASSERT( FALSE );
        goto Cleanup;
    }

    //
    //  calculate the size of the domain sid
    //

    SubAuthCount = *GetSidSubAuthorityCount( puserToken->User.Sid );

    status = GetLastError();

    if ( status != ERROR_SUCCESS  ||  SubAuthCount < 1 )
    {
        DNSDBG( SECURITY, (
            "Error <%lu>: Invalid sid.\n",
            status));
        ASSERT( FALSE );
        goto Cleanup;
    }
    size = GetLengthSid( puserToken->User.Sid );

    //
    //  get rid from the account sid
    //

    rid = *GetSidSubAuthority(
                   puserToken->User.Sid,
                   SubAuthCount-1 );

    status = GetLastError();
    if ( status != ERROR_SUCCESS )
    {
        DNSDBG( SECURITY, (
            "Error <%lu>: Invalid sid.\n",
             status ));
        ASSERT( FALSE );
        goto Cleanup;
    }

Cleanup:

    if ( hToken )
    {
        CloseHandle( hToken );
    }
    if ( puserToken )
    {
        FREE_HEAP( puserToken );
    }

    return rid;
}



DWORD
Dns_GetKeyVersion(
    IN      PSTR            pszTkeyName
    )
/*++

Routine Description:

    Get TKEY\TSIG version corresponding to a context.

Arguments:

    pszTkeyName -- context (TSIG\TKEY owner name)

Return Value:

    Version if found.
    Zero if unable to read version.

--*/
{
    LONGLONG    clientId = 0;
    DWORD       version = 0;
    INT         iscan;

    if ( !pszTkeyName )
    {
        DNSDBG( ANY, ( "ERROR:  no context to Dns_GetKeyVersion()!\n" ));
        ASSERT( FALSE );
        return( 0 );
    }

    //
    //  Versioned contexts have format <64bits>-ms-<version#>
    //

    iscan = sscanf(
                pszTkeyName,
                "%I64d-ms-%d",
                & clientId,
                & version );
    if ( iscan != 2 )
    {
        //
        //  Clients before Whistler RC2 use "MS" instead of "ms".
        //

        iscan = sscanf(
                    pszTkeyName,
                    "%I64d-MS-%d",
                    & clientId,
                    & version );
    }

    if ( iscan == 2 )
    {
        DNSDBG( SECURITY, (
            "Dns_GetKeyVersion() extracted version %d\n",
            version ));
    }
    else
    {
        DNSDBG( SECURITY, (
            "Dns_GetKeyVersion() unable to extract version from %s\n"
            "\treturning 0 as version\n",
            pszTkeyName ));
        version = 0;
    }

    return version;
}



DNS_STATUS
BuildCredsForPackage(
    OUT     PSEC_WINNT_AUTH_IDENTITY_EXW    pAuthOut,
    IN      PWSTR                           pPackageName,
    IN      PSEC_WINNT_AUTH_IDENTITY_W      pAuthIn
    )
/*++

Description:

    Builds auth identity info blob with specific package.

    The purpose of this is to let us ONLY negotiate kerberos and
    avoid wasting bandwidth negotiating NTLM.

Parameters:

    pAuthOut -- auth identity info

    pPackageName -- name of package

    pAuthIn -- existing package

Return:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNSDBG( SECURITY, (
        "BuildCredsForPackage( %p, %S )\n",
        pAuthOut,
        pPackageName ));

    //
    //  currently don't limit passed in creds to kerberos
    //

    if ( pAuthIn )
    {
        return  ERROR_INVALID_PARAMETER;
    }

    //
    //  auth-id with default creds
    //      - user, domain, password all zero
    //      - set length and version
    //      - set package
    //      - set flag to indicate unicode
    //

    RtlZeroMemory(
        pAuthOut,
        sizeof(*pAuthOut) );

    pAuthOut->Version           = SEC_WINNT_AUTH_IDENTITY_VERSION;
    pAuthOut->Length            = sizeof(*pAuthOut);
    pAuthOut->Flags             = SEC_WINNT_AUTH_IDENTITY_UNICODE;
    pAuthOut->PackageList       = pPackageName;
    pAuthOut->PackageListLength = wcslen( pPackageName );

    return  ERROR_SUCCESS;
}



DNS_STATUS
Dns_AcquireCredHandle(
    OUT     PCredHandle     pCredHandle,
    IN      BOOL            fDnsServer,
    IN      PCHAR           pCreds
    )
/*++

Routine Description:

    Acquire credentials handle.

    Cover to handle issues like kerberos restriction.

Arguments:

    fDnsServer -- TRUE if DNS server process;  FALSE otherwise

    pCreds -- credentials

Return Value:

    success: ERROR_SUCCESS

--*/
{
    SEC_WINNT_AUTH_IDENTITY_EXW clientCreds;
    SECURITY_STATUS             status = ERROR_SUCCESS;
    PVOID                       pauthData = pCreds;


    DNSDBG( SECURITY, (
       "Dns_AcquireCredHandle( %p, server=%d, pcred=%p )\n",
       pCredHandle,
       fDnsServer,
       pCreds ));

    //
    //  kerberos for client
    //
    //  if passed in creds
    //      - just append package (if possible)
    //
    //  no creds
    //      - build creds with kerb package and all else NULL
    //

    if ( !fDnsServer && g_NegoKerberosOnly )
    {
        if ( !pCreds )
        {
            status = BuildCredsForPackage(
                        & clientCreds,
                        L"kerberos",
                        NULL );

            DNS_ASSERT( status == NO_ERROR );
            if ( status == NO_ERROR )
            {
                pauthData = &clientCreds;
            }
        }
    }

    //
    //  acquire cred handle
    //

    status = g_pSecurityFunctionTable->AcquireCredentialsHandleW(
                    NULL,                   // principal
                    PACKAGE_NAME,
                    fDnsServer ?
                        SECPKG_CRED_INBOUND :
                        SECPKG_CRED_OUTBOUND,
                    NULL,                   // LOGON id
                    pauthData,              // auth data
                    NULL,                   // get key fn
                    NULL,                   // get key arg
                    pCredHandle,            // out credentials
                    NULL                    // valid forever
                    );

    if ( !SEC_SUCCESS(status) )
    {
        DNSDBG( ANY, (
            "ERROR:  AcquireCredentialHandle failed!\n"
            "\tstatus   = %08x %d\n"
            "\tpauthId  = %p\n",
            status, status,
            pauthData ));
    }

    DNSDBG( SECURITY, (
       "Leave  Dns_AcquireCredHandle() => %08x\n",
       status ));

    return (DNS_STATUS) status;
}



DNS_STATUS
Dns_RefreshSSpiCredentialsHandle(
    IN      BOOL            fDnsServer,
    IN      PCHAR           pCreds
    )
/*++

Routine Description:

    Refreshes the global credentials handle if it is expired.
    Calls into SSPI to acquire a new handle.

Arguments:

    fDnsServer -- TRUE if DNS server process;  FALSE otherwise

    pCreds -- credentials

Return Value:

    success: ERROR_SUCCESS

--*/
{
    SECURITY_STATUS status = ERROR_SUCCESS;

    DNSDBG( SECURITY, (
       "RefreshSSpiCredentialsHandle( %d, pcreds=%p )\n",
       fDnsServer,
       pCreds ));

    EnterCriticalSection( &SecurityContextListCS );

    //
    //  DCR:  need check -- if handle for same credentials and still valid
    //      no need to fix up
    //

    if ( !SSPI_INVALID_HANDLE( &g_hSspiCredentials ) )
    {
        //
        // Free previously allocated handle
        //

        status = g_pSecurityFunctionTable->FreeCredentialsHandle(
                                               &g_hSspiCredentials );
        if ( !SEC_SUCCESS(status) )
        {
            DNSDBG( ANY, (
                "ERROR <%08x>: Cannot free credentials handle\n",
                status ));
        }
        // continue regardless.
        SecInvalidateHandle( &g_hSspiCredentials );
    }

    ASSERT( SSPI_INVALID_HANDLE( &g_hSspiCredentials ) );

    //
    //  Acquire credentials
    //

    status = Dns_AcquireCredHandle(
                & g_hSspiCredentials,
                fDnsServer,
                pCreds );

    if ( !SEC_SUCCESS(status) )
    {
        DNS_PRINT((
            "ERROR (0x%x):  AcquireCredentialHandle failed: %u %p\n",
            status ));
        SecInvalidateHandle( &g_hSspiCredentials );
    }

    LeaveCriticalSection( &SecurityContextListCS );

    DNSDBG( SECURITY, (
       "Exit <0x%x>: RefreshSSpiCredentialsHandle()\n",
       status ));

    return (DNS_STATUS) status;
}



//
//  Cred utils
//

PWSTR
MakeCredKeyFromStrings(
    IN      PWSTR           pwsUserName,
    IN      PWSTR           pwsDomain,
    IN      PWSTR           pwsPassword
    )
/*++

Description:

    Allocates auth identity info and initializes pAuthIn info

Parameters:

    pwsUserName -- user name

    pwsDomain   -- domain name

    pwsPassword -- password

Return:

    Ptr to newly create credentials.
    NULL on failure.

--*/
{
    DWORD   length;
    PWSTR   pstr;

    DNSDBG( SECURITY, (
        "Enter MakeCredKeyFromStrings()\n"
        "\tuser     = %S\n"
        "\tdomain   = %S\n"
        "\tpassword = %S\n",
        pwsUserName,
        pwsDomain,
        pwsPassword ));

    //
    //  determine length and allocate
    //

    length  = wcslen( pwsUserName );
    length  += wcslen( pwsDomain );
    length  += wcslen( pwsPassword );

    length  += 3;   // two separators and NULL terminator

    pstr = ALLOCATE_HEAP( length * sizeof(WCHAR) );
    if ( ! pstr )
    {
        return  NULL;
    }

    //
    //  build cred info
    //

    wcscat( pstr, pwsDomain );
    wcscat( pstr, L"\\" );
    wcscpy( pstr, pwsUserName );
    wcscat( pstr, L"\\" );
    wcscat( pstr, pwsPassword );

    DNSDBG( SECURITY, (
        "Created cred string %S\n",
        pstr ));

    return  pstr;
}



PWSTR
MakeCredKey(
    IN      PCHAR           pCreds
    )
/*++

Description:

    Allocates auth identity info and initializes pAuthIn info

Parameters:

    pCreds  -- credentials

Return:

    Ptr to newly create credentials.
    NULL on failure.

--*/
{
    PSEC_WINNT_AUTH_IDENTITY_EXW    pauth = NULL;
    SEC_WINNT_AUTH_IDENTITY_EXW     dummyAuth;
    PWSTR   pstr = NULL;
    DWORD   length;


    DNSDBG( SECURITY, (
        "MakeCredKey( %p )\n",
        pCreds ));

    //
    //  determine AUTH_EX or old style credentials
    //      - if old style dummy up new version
    //

    pauth = (PSEC_WINNT_AUTH_IDENTITY_EXW) pCreds;

    if ( pauth->Length == sizeof(*pauth) &&
         pauth->Version < 0x10000 )
    {
        DNSDBG( SECURITY, (
            "Creds at %p are new AuthEx creds.\n",
            pCreds ));
    }
    else
    {
        DNSDBG( SECURITY, (
            "Creds at %p are old style.\n",
            pCreds ));

        RtlCopyMemory(
            (PBYTE) &dummyAuth.User,
            pCreds,
            sizeof(SEC_WINNT_AUTH_IDENTITY_W) );

        pauth = &dummyAuth;
    }

    //
    //  sum lengths and allocate string
    //

    length  =   pauth->UserLength;
    length  +=  pauth->DomainLength;
    length  +=  pauth->PasswordLength;
    length  +=  3;

    pstr = ALLOCATE_HEAP( length * sizeof(WCHAR) );
    if ( ! pstr )
    {
        return  NULL;
    }

    //
    //  determine unicode \ ANSI -- write string
    //
    //  it appears that with wprint functions the meaning of
    //  %s and %S is reversed
    //

    if ( pauth->Flags & SEC_WINNT_AUTH_IDENTITY_UNICODE )
    {
        swprintf(
            pstr,
            //L"%S\\%S\\%S",
            L"%s\\%s\\%s",
            pauth->Domain,
            pauth->User,
            pauth->Password );
    
        DNSDBG( SECURITY, (
            "Created cred string %S from unicode\n",
            pstr ));
    }
    else
    {
        swprintf(
            pstr,
            //L"%s\\%s\\%s",
            L"%S\\%S\\%S",
            pauth->Domain,
            pauth->User,
            pauth->Password );

        DNSDBG( SECURITY, (
            "Created cred string %S from ANSI\n",
            pstr ));
    }
    return  pstr;
}



BOOL
CompareCredKeys(
    IN      PWSTR           pwsCredKey1,
    IN      PWSTR           pwsCredKey2
    )
/*++

Description:

    Compare cred strings for matching security contexts.

Parameters:

    pwsCredKey1 -- cred string

    pwsCredKey2 -- cred string

Return:

    TRUE if match.
    FALSE if no match.

--*/
{
    DNSDBG( SECURITY, (
        "CompareCredKeys( %S, %S )\n",
        pwsCredKey1,
        pwsCredKey2 ));

    //
    //  most common case -- no creds
    //

    if ( !pwsCredKey1 || !pwsCredKey2 )
    {
        return( pwsCredKey2==pwsCredKey1 );
    }

    //
    //  cred strings are wide character strings
    //      - just string compare
    //

    return( wcscmp( pwsCredKey1, pwsCredKey2 ) == 0 );
}

//
//  End security.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\timer.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    timer.c

Abstract:

    Domain Name System (DNS) Server

    Wrap proof timer routines.

    The purpose of this module is to create a timer function which
    returns a time in seconds and eliminates all timer wrapping issues.

    These routines are non-DNS specific and may be picked up
    cleanly by any module.

    For DNS the added instructions are well worth the cost in that it
    eliminates any issue involving cleaning packet queues or resetting
    cache timeouts when millisecond timer (GetCurrentTime) wraps.

Author:

    Jim Gilroy (jamesg)     9-Sep-1995

Revision History:

--*/


#include "local.h"

//  Note:  this modules requires only windows.h.
//      local.h is included only to allow precompiled header

#include <windows.h>


#if 1

//
//  GetTickCount() timer routines
//

//
//  Timer globals
//

BOOL                g_InitializedTimerCs = FALSE;
BOOL                g_TimerInitInProgress = FALSE;
CRITICAL_SECTION    csTimerWrap;

DWORD   g_WrapTime = 0;
DWORD   g_PreviousTopBit = 0;



VOID
Dns_InitializeSecondsTimer(
    VOID
    )
/*++

Routine Description:

    Initialize DNS timer.

    This will be done automatically, but allow caller to do it explicitly.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    //  protect CS init with interlock
    //      - first thread through does CS init
    //      - any others racing, are not released until init
    //          completes
    //

    if ( !g_InitializedTimerCs )
    {
        if ( InterlockedIncrement( &g_TimerInitInProgress ) == 1 )
        {
            InitializeCriticalSection( &csTimerWrap );
            g_InitializedTimerCs = TRUE;
        }
        else
        {
            while ( !g_InitializedTimerCs )
            {
                Sleep( 10 );
            }
        }
    }
}



DWORD
Dns_GetCurrentTimeInSeconds(
    VOID
    )
/*++

Routine Description:

    Get current time in seconds.

Arguments:

    None.

Return Value:

    Time since boot in seconds.

--*/
{
    DWORD   currentTime;
    DWORD   topBit;
    DWORD   preWrapTime;
    DWORD   postWrapTime;

    //
    //  get time
    //
    //  read wrap time on either side so we can detect and handle
    //  a wrap occuring (handled by another thread) while we are
    //  in this function
    //

    preWrapTime = g_WrapTime;

    currentTime = GetCurrentTime();

    postWrapTime = g_WrapTime;

    //
    //  check for timer wrap
    //
    //  need to detect when timer flips from large to small DWORD;
    //
    //  i first did this by keeping a previous time global, but
    //  setting this global must also be carefully locked around timer
    //  wrap to avoid race conditions resulting in double wrap
    //
    //  to avoid locking all the time we can set previous time only
    //  when it "substantively" changes for our purposes -- this is
    //  when it changes its top bit;   by saving it twice a wrap
    //  we have enough info to detect the wrap (the change from
    //  top bit set to clear), yet still only need to lock a few
    //  times every wrap
    //
    //  algorithm:
    //      - top bit same as previous => done
    //      - top bit changed
    //          - take lock
    //          - test again
    //              - no change => no-op
    //          - changed to top bit set
    //              - just save new bit setting
    //          - changed to top bit clear
    //              - save new bit setting
    //              - add one cycle to wrap time
    //          

    topBit = currentTime & 0x80000000;

    if ( topBit != g_PreviousTopBit )
    {
        //
        //  possible wrap or "half-wrap"
        //
        //  not intializing lock until actually need it
        //      - lock init is MT safe (see above)
        //

        Dns_InitializeSecondsTimer();

        EnterCriticalSection( &csTimerWrap );

        //
        //  timer wrap
        //      - recheck inequality as another thread might have beaten
        //      us to the lock and handled wrap already
        //      - topBit must be clear (time is now low DWORD)
        //

        if ( topBit != g_PreviousTopBit  &&  topBit == 0 )
        {
            g_WrapTime += (MAXDWORD / 1000);
        }

        //  reset previous top bit
        //      - not necessary in equality case, but a no-op

        g_PreviousTopBit = topBit;

        LeaveCriticalSection( &csTimerWrap );
    }

    //
    //  return time
    //      - current time + any wrap time
    //      - if pre\post wrap times use topBit to determine which is valid
    //          - if our time was snapshot right before wrap, use pre time
    //          - otherwise post time ok
    //
    //  note this is done completely without globals, so no race
    //

    if ( preWrapTime != postWrapTime )
    {
        if ( topBit )
        {
             postWrapTime = preWrapTime;
        }
    }

    return ( currentTime / 1000 + postWrapTime );
}



#else
//
//  FILETIME timer routines
//
//  Unfortunately these don't work because FILETIME moves
//  around when clock reset -- it is not monotonically increasing
//

//
//  Timer globals
//

LONGLONG  g_TimerBaseTime = 0;

//
//  File time timer in 100ns intervals
//      (10 million to second)
//

#define FILE_TIME_INTERVALS_IN_SECOND   (10000000)

//
//  File time base to avoid starting timer at zero
//  Give roughly a day to avoid any startup issues.
//

#define FILE_TIME_BASE_OFFSET           (1000000000000)


DWORD
Dns_GetCurrentTimeInSeconds(
    VOID
    )
/*++

Routine Description:

    Get current time in seconds.
    Time is relative to first call to the timer.

Arguments:

    None.

Return Value:

    Time since first timer call in seconds.

--*/
{
    LONGLONG    time64;

    GetSystemTimeAsFileTime( (PFILETIME) &time64 );

    //
    //  convert to seconds
    //      - file time is in 100ns intervals (since Jan 1, 1601)
    //
    //  if first call, save 64-bit base time;
    //  this allows us to run a DWORD of seconds ~137 years
    //
    //  repeated calls are offset from base time
    //

    if ( g_TimerBaseTime == 0 )
    {
        g_TimerBaseTime = time64 - FILE_TIME_BASE_OFFSET;
    }

    time64 -= g_TimerBaseTime;
    time64 = time64 / FILE_TIME_INTERVALS_IN_SECOND;

    return  (DWORD)time64;
}



VOID
Dns_InitializeSecondsTimer(
    VOID
    )
/*++

Routine Description:

    Initialize DNS timer.

    Note, this is not a reset -- it's just backward compatibility
    for old timer routines.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    //  call the timer, for uninitialized timer that makes time
    //      now

    Dns_GetCurrentTimeInSeconds();

    //
    //  note if want a timer reset, then zero base, however
    //  this is NOT MT safe -- thread in function could get
    //  huge bogus time
    //
}

#endif

//
//  End of timer.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\string.c ===
/*++

Copyright (c) 1995-2001 Microsoft Corporation

Module Name:

    string.c

Abstract:

    Domain Name System (DNS) Library

    DNS string routines.

Author:

    Jim Gilroy (jamesg)     October 1995

Revision History:

    jamesg  Jan 1997    UTF-8, Unicode conversions

--*/


#include "local.h"



PSTR
Dns_CreateStringCopy(
    IN      PCHAR           pchString,
    IN      DWORD           cchString
    )
/*++

Routine Description:

    Create copy of string.

Arguments:

    pchString -- ptr to string to copy

    cchString -- length of string, if unknown;  if NOT given, then pchString
                    MUST be NULL terminated

Return Value:

    Ptr to string copy, if successful
    NULL on failure.

--*/
{
    LPSTR   pstringNew;

    DNSDBG( TRACE, ( "Dns_CreateStringCopy()\n" ));

    if ( !pchString )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return( NULL );
    }

    //  determine string length, if not given

    if ( !cchString )
    {
        cchString = strlen( pchString );
    }

    //  allocate memory

    pstringNew = (LPSTR) ALLOCATE_HEAP( cchString+1 );
    if ( !pstringNew )
    {
        SetLastError( DNS_ERROR_NO_MEMORY );
        return( NULL );
    }

    //  copy and NULL terminate

    RtlCopyMemory(
        pstringNew,
        pchString,
        cchString );

    pstringNew[cchString] = 0;

    return( pstringNew );
}



DWORD
Dns_GetBufferLengthForStringCopy(
    IN      PCHAR           pchString,
    IN      DWORD           cchString,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
/*++

Routine Description:

    Determing length required for copy of string.

Arguments:

    pchString -- ptr to string to get buffer length for

    cchString -- length of string, if known;
        - if CharSetIn is unicode, then this is length in wide characters
        - if NOT given, then pchString MUST be NULL terminated

    CharSetIn -- incoming character set

    CharSetOut -- result character set

Return Value:

    Buffer length (bytes) required for string, includes space for terminating NULL.
    Zero on invalid\unconvertible string.  GetLastError() set to ERROR_INVALID_DATA.

--*/
{
    INT     length;

    DNSDBG( TRACE, ( "Dns_GetBufferLengthForStringCopy()\n" ));

    if ( !pchString )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return( 0 );
    }

    //
    //  incoming Unicode
    //

    if ( CharSetIn == DnsCharSetUnicode )
    {
        if ( !cchString )
        {
            cchString = (WORD) wcslen( (PWCHAR)pchString );
        }

        //  unicode to unicode

        if ( CharSetOut == DnsCharSetUnicode )
        {
            return( (cchString+1) * 2 );
        }

        //  unicode to UTF8
        //
        //  use private unicode\utf8 conversion functions
        //      - superior to public ones (faster, more robust)
        //      - Win95 does not support CP_UTF8
        //
        //  for unicode-UTF8 there's no invalid string possible

        else if ( CharSetOut == DnsCharSetUtf8 )
        {
#if 0
            length = WideCharToMultiByte(
                        CP_UTF8,
                        0,          // no flags
                        (PWCHAR) pchString,
                        (INT) cchString,
                        NULL,
                        0,          // call determines required buffer length
                        NULL,
                        NULL );
#endif
            length = Dns_UnicodeToUtf8(
                         (PWCHAR) pchString,
                         (INT) cchString,
                         NULL,
                         0
                         );
            ASSERT( length != 0 || cchString == 0 );
            return( length + 1 );
        }

        //  unicode to ANSI
        //      - some chars will NOT convert

        else if ( CharSetOut == DnsCharSetAnsi )
        {
            length = WideCharToMultiByte(
                        CP_ACP,
                        0,          // no flags
                        (PWCHAR) pchString,
                        (INT) cchString,
                        NULL,
                        0,          // call determines required buffer length
                        NULL,
                        NULL
                        );
            if ( length == 0 && cchString != 0 )
            {
                goto Failed;
            }
            return( length + 1 );
        }

        //  bad CharSetOut drops to Failed
    }

    //
    //  incoming UTF8
    //

    else if ( CharSetIn == DnsCharSetUtf8 )
    {
        if ( !cchString )
        {
            cchString = strlen( pchString );
        }

        //  UTF8 to UTF8

        if ( CharSetOut == DnsCharSetUtf8 )
        {
            return( cchString + 1 );
        }

        //  UTF8 to unicode
        //
        //  use private unicode\utf8 conversion functions
        //      - superior to public ones (faster, more robust)
        //      - Win95 does not support CP_UTF8
        //
        //  for UTF8 string can be invalid, catch and return error

        else if ( CharSetOut == DnsCharSetUnicode )
        {
#if 0
            length = MultiByteToWideChar(
                        CP_UTF8,
                        0,          // no flags
                        pchString,
                        (INT) cchString,
                        NULL,
                        0           // call determines required buffer length
                        );
#endif
            length = Dns_Utf8ToUnicode(
                         pchString,
                         (INT) cchString,
                         NULL,
                         0
                         );
            if ( length == 0 && cchString != 0 )
            {
                ASSERT( GetLastError() == ERROR_INVALID_DATA );
                return( 0 );
            }
            return( (length+1)*2 );
        }

        //  UTF8 to ANSI
        //      - note, result length here is actually buffer length

        else if ( CharSetOut == DnsCharSetAnsi )
        {
            return Dns_Utf8ToAnsi(
                        pchString,
                        cchString,
                        NULL,
                        0 );
        }

        //  bad CharSetOut drops to Failed
    }

    //
    //  incoming ANSI
    //

    else if ( CharSetIn == DnsCharSetAnsi )
    {
        if ( !cchString )
        {
            cchString = strlen( pchString );
        }

        //  ANSI to ANSI

        if ( CharSetOut == DnsCharSetAnsi )
        {
            return( cchString + 1 );
        }

        //  ANSI to unicode
        //      - should always succeed

        else if ( CharSetOut == DnsCharSetUnicode )
        {
            length = MultiByteToWideChar(
                        CP_ACP,
                        0,          // no flags
                        pchString,
                        (INT) cchString,
                        NULL,
                        0           // call determines required buffer length
                        );
            if ( length == 0 && cchString )
            {
                ASSERT( FALSE );
                ASSERT( GetLastError() == ERROR_INVALID_DATA );
                goto Failed;
            }
            return( (length+1) * 2 );
        }

        //  ANSI to UTF8
        //      - note, result length here is actually buffer length

        else if ( CharSetOut == DnsCharSetUtf8 )
        {
            return Dns_AnsiToUtf8(
                        pchString,
                        cchString,
                        NULL,
                        0 );
        }

        //  bad CharSetOut drops to Failed
    }

    //  all unhandled cases are failures

Failed:

    DNSDBG( ANY, (
        "ERROR:  Dns_GetBufferLengthForStringCopy() failed!\n"
        "\tpchString    = %p (%*s)\n"
        "\tcchString    = %d\n"
        "\tCharSetIn    = %d\n"
        "\tCharSetOut   = %d\n",
        pchString,
        cchString, pchString,
        cchString,
        CharSetIn,
        CharSetOut ));

    SetLastError( ERROR_INVALID_DATA );
    return( 0 );
}



DWORD
Dns_StringCopy(
    OUT     PBYTE           pBuffer,
    IN OUT  PDWORD          pdwBufLength,
    IN      PCHAR           pchString,
    IN      DWORD           cchString,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
/*++

Routine Description:

    Create copy of DNS string.

Arguments:

    pBuffer -- buffer to copy to

    pdwBufLength -- ptr to length of buffer in bytes;
        if NULL, buffer MUST have adequate length
        if exists, then copy only completed if *pdwBufLength is adequate
            to hold converted result

    pchString -- ptr to string to copy

    cchString -- length of string, if known;
        - if CharSetIn is unicode, then this is length in wide characters
        - if NOT given, then pchString MUST be NULL terminated

    CharSetIn -- incoming character set

    CharSetOut -- result character set

Return Value:

    Count of bytes written to buffer (includes terminating NULL).
    Zero on error.  GetLastError() for status.

--*/
{
    INT     length;
    DWORD   bufLength;

    DNSDBG( TRACE, ( "Dns_StringCopy()\n" ));
    DNSDBG( STRING, (
        "Dns_StringCopy()\n"
        "\tpBuffer      = %p\n"
        "\tpdwBufLen    = %p\n"
        "\tbuf length   = %d\n"
        "\tpchString    = %p\n"
        "\tcchString    = %d\n"
        "\tCharSetIn    = %d\n"
        "\tCharSetOut   = %d\n",
        pBuffer,
        pdwBufLength,
        pdwBufLength ? *pdwBufLength : 0,
        pchString,
        cchString,
        CharSetIn,
        CharSetOut ));

    if ( !pchString )
    {
        DNS_ASSERT( FALSE );
        SetLastError( ERROR_INVALID_PARAMETER );
        return( 0 );
    }

    //
    //  find string length
    //  do this here so don't do it twice if must calculate required buffer length
    //

    if ( cchString == 0 )
    {
        if ( CharSetIn == DnsCharSetUnicode )
        {
            cchString = (WORD) wcslen( (PWCHAR)pchString );
        }
        else
        {
            cchString = strlen( pchString );
        }
    }

    //
    //  verify adequate buffer length
    //
    //  DCR_PERF:  ideally make direct copy to buffer and fail if
    //      over length, rather than effectively having to convert
    //      twice
    //

    if ( pdwBufLength )
    {
        bufLength = Dns_GetBufferLengthForStringCopy(
                        pchString,
                        cchString,
                        CharSetIn,
                        CharSetOut );

        if ( bufLength == 0 )
        {
            SetLastError( ERROR_INVALID_DATA );
            *pdwBufLength = 0;
            return( 0 );
        }
        if ( bufLength > *pdwBufLength )
        {
            SetLastError( ERROR_MORE_DATA );
            *pdwBufLength = bufLength;
            return( 0 );
        }

        *pdwBufLength = bufLength;
    }

    //
    //  incoming unicode string
    //

    if ( CharSetIn == DnsCharSetUnicode )
    {
        //  unicode to unicode straight copy
        //      - correct for length in wide characters

        if ( CharSetOut == DnsCharSetUnicode )
        {
            ((PWORD)pBuffer)[ cchString ] = 0;
            cchString *= 2;
            RtlCopyMemory(
                pBuffer,
                pchString,
                cchString );

            return( cchString+2 );
        }

        //  unicode => UTF8
        //
        //  use private unicode\utf8 conversion functions
        //      - superior to public ones (faster, more robust)
        //      - Win95 does not support CP_UTF8
        //
        //  for unicode-UTF8 there's no invalid string possible

        else if ( CharSetOut == DnsCharSetUtf8 )
        {
#if 0
            length = WideCharToMultiByte(
                        CP_UTF8,
                        0,              // no flags
                        (PWCHAR) pchString,
                        (INT) cchString,
                        pBuffer,
                        MAXWORD,        // assuming adequate length
                        NULL,
                        NULL );
#endif
            length = Dns_UnicodeToUtf8(
                        (LPWSTR) pchString,
                        cchString,
                        pBuffer,
                        MAXWORD        // assuming adequate length
                        );
            ASSERT( length != 0 || cchString == 0 );

            pBuffer[ length ] = 0;
            return( length + 1 );
        }

        //  unicode => ANSI
        //      - this conversion can fail

        else if ( CharSetOut == DnsCharSetAnsi )
        {
            length = WideCharToMultiByte(
                        CP_ACP,
                        0,              // no flags
                        (PWCHAR) pchString,
                        (INT) cchString,
                        pBuffer,
                        MAXWORD,        // assuming adequate length
                        NULL,
                        NULL );

            if ( length == 0 && cchString != 0 )
            {
                goto Failed;
            }
            pBuffer[ length ] = 0;
            return( length + 1 );
        }

        //  bad CharSetOut drops to Failed
    }

    //
    //  incoming UTF8
    //

    if ( CharSetIn == DnsCharSetUtf8 )
    {
        //  UTF8 to UTF8 straight copy

        if ( CharSetOut == DnsCharSetUtf8 )
        {
            memcpy(
                pBuffer,
                pchString,
                cchString );

            pBuffer[cchString] = 0;
            return( cchString + 1 );
        }

        //  UTF8 to unicode conversion
        //
        //  use private unicode\utf8 conversion functions
        //      - superior to public ones (faster, more robust)
        //      - Win95 does not support CP_UTF8
        //
        //  UTF8 strings can be invalid, and since sending in "infinite"
        //      buffer, this is only possible error

        else if ( CharSetOut == DnsCharSetUnicode )
        {
#if 0
            length = MultiByteToWideChar(
                        CP_UTF8,
                        0,                  // no flags
                        (PCHAR) pchString,
                        (INT) cchString,
                        (PWCHAR) pBuffer,
                        MAXWORD             // assuming adequate length
                        );
#endif
            length = Dns_Utf8ToUnicode(
                        pchString,
                        cchString,
                        (LPWSTR) pBuffer,
                        MAXWORD
                        );
            if ( length == 0 && cchString != 0 )
            {
                ASSERT( GetLastError() == ERROR_INVALID_DATA );
                goto Failed;
            }
            ((PWORD)pBuffer)[length] = 0;
            return( (length+1) * 2 );
        }

        //  UTF8 to ANSI
        //      - note, result length here is actually buffer length

        else if ( CharSetOut == DnsCharSetAnsi )
        {
            length = Dns_Utf8ToAnsi(
                        pchString,
                        cchString,
                        pBuffer,
                        MAXWORD );
            if ( length == 0 )
            {
                goto Failed;
            }
            return( length );
        }

        //  bad CharSetOut drops to Failed
    }

    //
    //  incoming ANSI
    //

    if ( CharSetIn == DnsCharSetAnsi )
    {
        //  ANSI to ANSI straight copy

        if ( CharSetOut == DnsCharSetAnsi )
        {
            memcpy(
                pBuffer,
                pchString,
                cchString );

            pBuffer[cchString] = 0;
            return( cchString + 1 );
        }

        //  ANSI to unicode conversion
        //      - ANSI to unicode should not fail

        else if ( CharSetOut == DnsCharSetUnicode )
        {
            length = MultiByteToWideChar(
                        CP_ACP,
                        0,                  // no flags
                        (PCHAR) pchString,
                        (INT) cchString,
                        (PWCHAR) pBuffer,
                        MAXWORD             // assuming adequate length
                        );
            if ( length == 0 && cchString )
            {
                ASSERT( FALSE );
                ASSERT( GetLastError() == ERROR_INVALID_DATA );
                goto Failed;
            }
            ((PWORD)pBuffer)[length] = 0;
            return( (length+1) * 2 );
        }

        //  ANSI to UTF8
        //      - note, result length here is actually buffer length

        else if ( CharSetOut == DnsCharSetUtf8 )
        {
            length = Dns_AnsiToUtf8(
                        pchString,
                        cchString,
                        pBuffer,
                        MAXWORD );
            if ( length == 0 )
            {
                goto Failed;
            }
            return( length );
        }

        //  bad CharSetOut drops to Failed
    }

    //  all unhandled cases are failures

Failed:

    DNSDBG( ANY, (
        "ERROR:  Dns_StringCopy() failed!\n"
        "\tpBuffer      = %p\n"
        "\tpdwBufLen    = %p\n"
        "\tbuf length   = %d\n"
        "\tpchString    = %p (%*s)\n"
        "\tcchString    = %d\n"
        "\tCharSetIn    = %d\n"
        "\tCharSetOut   = %d\n",
        pBuffer,
        pdwBufLength,
        pdwBufLength ? *pdwBufLength : 0,
        pchString,
        cchString, pchString,
        cchString,
        CharSetIn,
        CharSetOut ));

    SetLastError( ERROR_INVALID_DATA );
    return( 0 );
}



PVOID
Dns_StringCopyAllocate(
    IN      PCHAR           pchString,
    IN      DWORD           cchString,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
/*++

Routine Description:

    Create copy of DNS string

Arguments:

    pchString -- ptr to string to copy

    cchString -- length of string, if known;
        - if CharSetIn, then this is length in wide characters
        - if NOT given, then pchString MUST be NULL terminated

    CharSetIn -- flag indicates incoming string is unicode

    CharSetOut -- flag indicates copy will be in unicode format

Return Value:

    Ptr to string copy, if successful
    NULL on failure.

--*/
{
    PCHAR   pnew;
    DWORD   length;

    DNSDBG( TRACE, ( "Dns_StringCopyAllocate()\n" ));
    DNSDBG( STRING, (
        "Dns_StringCopyAllocate( %.*s )\n"
        "\tpchString    = %p\n"
        "\tcchString    = %d\n"
        "\tUnicodeIn    = %d\n"
        "\tUnicodeOut   = %d\n",
        cchString,
        pchString,
        pchString,
        cchString,
        CharSetIn,
        CharSetOut ));

    if ( !pchString )
    {
        DNS_ASSERT( FALSE );
        SetLastError( ERROR_INVALID_PARAMETER );
        return( NULL );
    }

    //
    //  determine incoming string length
    //  do this explicitly to avoid doing string length operations twice
    //

    if ( !cchString )
    {
        if ( CharSetIn == DnsCharSetUnicode )
        {
            cchString = (WORD) wcslen( (PWCHAR)pchString );
        }
        else
        {
            cchString = strlen( pchString );
        }
    }

    //
    //  determine required buffer length and allocate
    //

    length = Dns_GetBufferLengthForStringCopy(
                pchString,
                cchString,
                CharSetIn,
                CharSetOut );
    if ( length == 0 )
    {
        ASSERT( CharSetIn && CharSetOut && GetLastError() == ERROR_INVALID_DATA );
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }
    pnew = (PVOID) ALLOCATE_HEAP( length );
    if ( !pnew )
    {
        SetLastError( DNS_ERROR_NO_MEMORY );
        return( NULL );
    }

    //
    //  copy \ convert string
    //      - can fail if conversion not valid
    //      (ex. bogus UTF8 string, or attempting
    //      conversion from ANSI to UTF8)
    //

    if ( ! Dns_StringCopy(
                pnew,
                NULL,
                pchString,
                cchString,
                CharSetIn,
                CharSetOut ) )
    {
        FREE_HEAP( pnew );
        return( NULL );
    }

    return( pnew );
}



//
//  Simple create string copy utilities.
//

PSTR
Dns_CreateStringCopy_A(
    IN      PCSTR           pszString
    )
/*++

Routine Description:

    Create copy of string.

    Simple wrapper to handle
        - sizing
        - memory allocation
        - copy of string

Arguments:

    pszString -- ptr to string to copy

Return Value:

    Ptr to string copy, if successful
    NULL on failure.

--*/
{
    PSTR    pnew;
    DWORD   length;

    DNSDBG( TRACE, ( "Dns_CreateStringCopy_A( %s )\n", pszString ));

    if ( !pszString )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return( NULL );
    }

    //  determine string length, if not given

    length = strlen( pszString ) + 1;

    //  allocate memory

    pnew = (LPSTR) ALLOCATE_HEAP( length );
    if ( !pnew )
    {
        SetLastError( DNS_ERROR_NO_MEMORY );
        return( NULL );
    }

    //  copy and NULL terminate

    RtlCopyMemory(
        pnew,
        pszString,
        length );

    return( pnew );
}



PWSTR
Dns_CreateStringCopy_W(
    IN      PCWSTR          pwsString
    )
{
    PWSTR   pnew;
    DWORD   length;

    DNSDBG( TRACE, ( "Dns_CreateStringCopy_W( %S )\n", pwsString ));

    if ( !pwsString )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return( NULL );
    }

    //  allocate memory

    length = (wcslen( pwsString ) + 1) * sizeof(WCHAR);

    pnew = (PWSTR) ALLOCATE_HEAP( length );
    if ( !pnew )
    {
        SetLastError( DNS_ERROR_NO_MEMORY );
        return( NULL );
    }

    //  copy and NULL terminate

    RtlCopyMemory(
        pnew,
        pwsString,
        length );

    return( pnew );
}



PWSTR
Dns_CreateConcatenatedString_W(
    IN      PCWSTR *        pStringArray
    )
/*++

Routine Description:

    Create concatenated string.

Arguments:

    pStringArray -- array of string pointers to concat
        NULL pointer terminates array

Return Value:

    Ptr to concantenated string copy, if successful
    NULL on failure.

--*/
{
    PWSTR   pnew;
    PCWSTR  pwstr;
    DWORD   length;
    DWORD   iter;


    DNSDBG( TRACE, ( "Dns_CreateConcatenatedString_W()\n" ));

    if ( !pStringArray )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return( NULL );
    }

    //
    //  loop determining required length
    //

    length = 1;
    iter = 0;

    while ( pwstr = pStringArray[iter++] )
    {
        length += wcslen( pwstr );
    }

    //
    //  allocate
    //

    pnew = (PWSTR) ALLOCATE_HEAP( length*sizeof(WCHAR) );
    if ( !pnew )
    {
        SetLastError( DNS_ERROR_NO_MEMORY );
        return  NULL;
    }

    //
    //  write concatented string
    //

    pnew[0] = 0;
    iter = 0;

    while ( pwstr = pStringArray[iter++] )
    {
        wcscat( pnew, pwstr );
    }

    DNSDBG( TRACE, ( "Concatented string = %S\n", pnew ));
    return  pnew;
}



//
//  MULTI_SZ routines
//

DWORD
MultiSz_Length_A(
    IN      PCSTR           pmszString
    )
/*++

Routine Description:

    Determine length (size) of MULTI_SZ string.

Arguments:

    pmszString -- ptr to string to size

Return Value:

    Size of MULTI_SZ string (in bytes).
    Includes terminating double NULL.

--*/
{
    PSTR    pnext;
    DWORD   lengthTotal = 0;
    DWORD   length;

    DNSDBG( TRACE, ( "MultiSz_Length_A( %s )\n", pmszString ));

    //
    //  loop until read at end of strings
    //
    //  when we reach the end, we'll be pointing at the second
    //  zero in the double null terminator;  strlen() will return
    //  zero, and we'll add that to our count as 1 and exit
    //

    pnext = (PSTR) pmszString;

    while ( pnext )
    {
        length = strlen( pnext ) + 1;
        lengthTotal += length;

        if ( length == 1 )
        {
            break;
        }
        pnext += length;
    }

    return  lengthTotal;
}



PSTR
MultiSz_NextString_A(
    IN      PCSTR           pmszString
    )
/*++

Routine Description:

    Find next string in MULTI_SZ string

Arguments:

    pmszString -- ptr to multi string

Return Value:

    Next string in MULTI_SZ string.
    NULL if no strings left.

--*/
{
    PSTR    pnext;
    DWORD   length;

    DNSDBG( TRACE, ( "MultiSz_NextString_A( %s )\n", pmszString ));

    //
    //  find next string in multi-string
    //      - find length of current string
    //      - hop over it (inc. null)
    //      - if pointing at terminating double-null return
    //          NULL to signal end
    //

    pnext = (PSTR) pmszString;
    if ( !pnext )
    {
        return  NULL;
    }

    length = strlen( pnext );
    if ( length == 0 )
    {
        DNSDBG( ANY, (
            "ERROR:  MultiSz_Next(%p) called on terminator!\n",
            pmszString ));
        return  NULL;
    }

    pnext += length + 1;
    if ( *pnext == 0 )
    {
        return  NULL;
    }

    return  pnext;
}



PSTR
MultiSz_Copy_A(
    IN      PCSTR           pmszString
    )
/*++

Routine Description:

    Create copy of MULTI_SZ string.

    Simple wrapper to handle
        - sizing
        - memory allocation
        - copy of string

Arguments:

    pmszString -- ptr to string to copy

Return Value:

    Ptr to string copy, if successful
    NULL on failure.

--*/
{
    PSTR    pnew;
    DWORD   length;

    DNSDBG( TRACE, ( "MultiSz_Copy_A( %s )\n", pmszString ));

    if ( !pmszString )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return( NULL );
    }

    //  determine string length, if not given

    length = MultiSz_Length_A( pmszString );

    //  allocate memory

    pnew = (LPSTR) ALLOCATE_HEAP( length );
    if ( !pnew )
    {
        SetLastError( DNS_ERROR_NO_MEMORY );
        return( NULL );
    }

    //  copy and NULL terminate

    RtlCopyMemory(
        pnew,
        pmszString,
        length );

    return( pnew );
}



//
//  Random
//

INT
wcsicmp_ThatWorks(
    IN      PWSTR           pString1,
    IN      PWSTR           pString2
    )
/*++

Routine Description:

    A version of wcsicmp that actually works.

    This is just a wrapped on CompareStringW, to hide all the detail
    and give an interface identical to wcsicmp().

    It uses US English to standardize the comparison.

Arguments:

    pString1 -- first string;  must be NULL terminated

    pString2 -- first second;  must be NULL terminated

Return Value:

    -1  -- if string 1 less than string 2
    0   -- strings are equal
    1   -- if string 1 greater than string 2

--*/
{
    INT result;

    //
    //  compare
    //      - case conversion done in default DNS locale -- US English
    //      this locale correctly matches most non-locale sensitive
    //      upper-lower characters
    //

    result = CompareStringW(
                DNS_DEFAULT_LOCALE,
                NORM_IGNORECASE,
                pString1,
                (-1),       // NULL terminated
                pString2,
                (-1)        // NULL terminated
                );

    if ( result == CSTR_EQUAL )
    {
        result = 0;
    }
    else if ( result == CSTR_LESS_THAN )
    {
        result = -1;
    }
    else  // greater than or error
    {
        result = 1;
    }

    return( result );
}



LPWSTR
Dns_GetResourceString(
    IN      DWORD           dwStringId,
    IN OUT  LPWSTR          pwszBuffer,
    IN      DWORD           cbBuffer
    )
/*++

Routine Description:

    Loads a string (defined in dnsmsg.mc) from current module

Arguments:

    dwStringId -- The ID of the string to be fetched

Return Value:

    DCR:  kill off eyal function
    DEVNOTE:  don't understand the value of this return
        -- it's essentially a BOOL, we already know what the ptr is
            it's the buffer passed in
        -- ptr to next byte is useful in continuous write situation
            (ugly and useless in others)
        -- better would just be the same return as LoadString, so we
             both get the success\failure indication and also know
             how many bytes forward we must push our buffer ptr if
             we want to write more

    Error: NULL
    Success: a pointer to the loaded string

--*/
{
    LPWSTR  pStr = NULL;
    DWORD   status;
    HANDLE  hMod;

    DNSDBG( TRACE, (
        "Dns_GetStringResource()\n" ));

    // Get module handle-- No need to close handle, it is just a ptr w/o increment on ref count.
    hMod = GetModuleHandle( NULL );
    if ( !hMod )
    {
        ASSERT( hMod );
        return NULL;
    }

    status = LoadStringW(
                 hMod,
                 dwStringId,
                 pwszBuffer,
                 cbBuffer );

    if ( status != 0 )
    {
        pStr = pwszBuffer;
    }
    ELSE
    {
        // LoadString returns # of bytes loaded, convert to error.
        status = GetLastError();
        DNSDBG( TRACE, (
            "Error <%lu>: Failed to load string %d\n",
            status, dwStringId ));
        ASSERT ( FALSE );
    }

    DNSDBG( TRACE, (
        "Exit <0x%p> Dns_GetStringResource\n",
        pStr ));

    return pStr;
}

//
//  End string.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\utf8.c ===
/*++

Copyright (c) 1997-2001 Microsoft Corporation

Module Name:

    utf8.c

Abstract:

    Domain Name System (DNS) Library

    UTF8 to\from unicode and ANSI conversions

    The UTF8\unicode routines are similar to the generic ones floating
    around the NT group, but a heck of a lot cleaner and more robust,
    including catching the invalid UTF8 string case on the utf8 to unicode
    conversion.

    The UTF8\ANSI routines are optimized for the 99% case where all the
    characters are <128 and no conversions is actually required.

Author:

    Jim Gilroy (jamesg)     March 1997

Revision History:

--*/


#include "local.h"


//
//  Macros to simplify UTF8 conversions
//

#define UTF8_1ST_OF_2     0xc0      //  110x xxxx
#define UTF8_1ST_OF_3     0xe0      //  1110 xxxx
#define UTF8_1ST_OF_4     0xf0      //  1111 xxxx
#define UTF8_TRAIL        0x80      //  10xx xxxx

#define UTF8_2_MAX        0x07ff    //  max unicode character representable in
                                    //  in two byte UTF8

#define BIT7(ch)        ((ch) & 0x80)
#define BIT6(ch)        ((ch) & 0x40)
#define BIT5(ch)        ((ch) & 0x20)
#define BIT4(ch)        ((ch) & 0x10)
#define BIT3(ch)        ((ch) & 0x08)

#define LOW6BITS(ch)    ((ch) & 0x3f)
#define LOW5BITS(ch)    ((ch) & 0x1f)
#define LOW4BITS(ch)    ((ch) & 0x0f)

#define HIGHBYTE(wch)   ((wch) & 0xff00)

//
//  Surrogate pair support
//  Two unicode characters may be linked to form a surrogate pair.
//  And for some totally unknown reason, someone thought they
//  should travel in UTF8 as four bytes instead of six.
//  No one has any idea why this is true other than to complicate
//  the code.
//

#define HIGH_SURROGATE_START  0xd800
#define HIGH_SURROGATE_END    0xdbff
#define LOW_SURROGATE_START   0xdc00
#define LOW_SURROGATE_END     0xdfff


//
//  Max "normal conversion", make space for MAX_PATH,
//  this covers all valid DNS names and strings.
//

#define TEMP_BUFFER_LENGTH  (2*MAX_PATH)



DNS_STATUS
_fastcall
Dns_ValidateUtf8Byte(
    IN      BYTE            chUtf8,
    IN OUT  PDWORD          pdwTrailCount
    )
/*++

Routine Description:

    Verifies that byte is valid UTF8 byte.

Arguments:

Return Value:

    ERROR_SUCCESS -- if valid UTF8 given trail count
    ERROR_INVALID_DATA -- if invalid

--*/
{
    DWORD   trailCount = *pdwTrailCount;

    DNSDBG( TRACE, ( "Dns_ValidateUtf8Byte()\n" ));

    //
    //  if ASCII byte, only requirement is no trail count
    //

    if ( (UCHAR)chUtf8 < 0x80 )
    {
        if ( trailCount == 0 )
        {
            return( ERROR_SUCCESS );
        }
        return( ERROR_INVALID_DATA );
    }

    //
    //  trail byte
    //      - must be in multi-byte set
    //

    if ( BIT6(chUtf8) == 0 )
    {
        if ( trailCount == 0 )
        {
            return( ERROR_INVALID_DATA );
        }
        --trailCount;
    }

    //
    //  multi-byte lead byte
    //      - must NOT be in existing multi-byte set
    //      - verify valid lead byte

    else
    {
        if ( trailCount != 0 )
        {
            return( ERROR_INVALID_DATA );
        }

        //  first of two bytes (110xxxxx)

        if ( BIT5(chUtf8) == 0 )
        {
            trailCount = 1;
        }

        //  first of three bytes (1110xxxx)

        else if ( BIT4(chUtf8) == 0 )
        {
            trailCount = 2;
        }

        //  first of four bytes (surrogate character) (11110xxx)

        else if ( BIT3(chUtf8) == 0 )
        {
            trailCount = 3;
        }

        else
        {
            return( ERROR_INVALID_DATA );
        }
    }

    //  reset caller's trail count

    *pdwTrailCount = trailCount;
    return( ERROR_SUCCESS );
}



//
//  UTF8 to unicode conversions
//
//  For some reason UTF8 is not supported in Win9x.
//  AND the implementation itself is not careful about
//  validating UTF8.
//

DWORD
_fastcall
Dns_UnicodeToUtf8(
    IN      PWCHAR          pwUnicode,
    IN      DWORD           cchUnicode,
    OUT     PCHAR           pchResult,
    IN      DWORD           cchResult
    )
/*++

Routine Description:

    Convert unicode characters to UTF8.

    Result is NULL terminated if sufficient space in result
    buffer is available.

Arguments:

    pwUnicode   -- ptr to start of unicode buffer

    cchUnicode  -- length of unicode buffer

    pchResult   -- ptr to start of result buffer for UTF8 chars

    cchResult   -- length of result buffer

Return Value:

    Count of UTF8 characters in result, if successful.
    0 on error.  GetLastError() has error code.

--*/
{
    WCHAR   wch;                // current unicode character being converted
    DWORD   lengthUtf8 = 0;     // length of UTF8 result string
    WORD    lowSurrogate;
    DWORD   surrogateDword;


    DNSDBG( TRACE, (
        "Dns_UnicodeToUtf8( %.*S )\n",
        cchUnicode,
        pwUnicode ));

    //
    //  loop converting unicode chars until run out or error
    //

    while ( cchUnicode-- )
    {
        wch = *pwUnicode++;

        //
        //  ASCII character (7 bits or less) -- converts to directly
        //

        if ( wch < 0x80 )
        {
            lengthUtf8++;

            if ( pchResult )
            {
                if ( lengthUtf8 >= cchResult )
                {
                    goto OutOfBuffer;
                }
                *pchResult++ = (CHAR)wch;
            }
            continue;
        }

        //
        //  wide character less than 0x07ff (11bits) converts to two bytes
        //      - upper 5 bits in first byte
        //      - lower 6 bits in secondar byte
        //

        else if ( wch <= UTF8_2_MAX )
        {
            lengthUtf8 += 2;

            if ( pchResult )
            {
                if ( lengthUtf8 >= cchResult )
                {
                    goto OutOfBuffer;
                }
                *pchResult++ = UTF8_1ST_OF_2 | wch >> 6;
                *pchResult++ = UTF8_TRAIL    | LOW6BITS( (UCHAR)wch );
            }
            continue;
        }

        //
        //  surrogate pair
        //      - if have high surrogate followed by low surrogate then
        //          process as surrogate pair
        //      - otherwise treat character as ordinary unicode "three-byte"
        //          character, by falling through to below
        //

        else if ( wch >= HIGH_SURROGATE_START &&
                  wch <= HIGH_SURROGATE_END &&
                  cchUnicode &&
                  (lowSurrogate = *pwUnicode) &&
                  lowSurrogate >= LOW_SURROGATE_START &&
                  lowSurrogate <= LOW_SURROGATE_END )
        {
            //  have a surrogate pair
            //      - suck up next unicode character (low surrogate of pair)
            //      - make full DWORD surrogate pair
            //      - then lay out four UTF8 bytes
            //          1st of four, then three trail bytes
            //              0x1111xxxx
            //              0x10xxxxxx
            //              0x10xxxxxx
            //              0x10xxxxxx

            DNSDBG( TRACE, (
                "Have surrogate pair %hx : %hx\n",
                wch,
                lowSurrogate ));

            pwUnicode++;
            cchUnicode--;
            lengthUtf8 += 4;

            if ( pchResult )
            {
                if ( lengthUtf8 >= cchResult )
                {
                    goto OutOfBuffer;
                }
                surrogateDword = (((wch-0xD800) << 10) + (lowSurrogate - 0xDC00) + 0x10000);

                *pchResult++ = UTF8_1ST_OF_4 | (UCHAR) (surrogateDword >> 18);
                *pchResult++ = UTF8_TRAIL    | (UCHAR) LOW6BITS(surrogateDword >> 12);
                *pchResult++ = UTF8_TRAIL    | (UCHAR) LOW6BITS(surrogateDword >> 6);
                *pchResult++ = UTF8_TRAIL    | (UCHAR) LOW6BITS(surrogateDword);

                DNSDBG( TRACE, (
                    "Converted surrogate -- DWORD = %08x\n"
                    "\tconverted %x %x %x %x\n",
                    surrogateDword,
                    (UCHAR) *(pchResult-3),
                    (UCHAR) *(pchResult-2),
                    (UCHAR) *(pchResult-1),
                    (UCHAR) *pchResult ));
            }
        }

        //
        //  wide character (non-zero in top 5 bits) converts to three bytes
        //      - top 4 bits in first byte
        //      - middle 6 bits in second byte
        //      - low 6 bits in third byte
        //

        else
        {
            lengthUtf8 += 3;

            if ( pchResult )
            {
                if ( lengthUtf8 >= cchResult )
                {
                    goto OutOfBuffer;
                }
                *pchResult++ = UTF8_1ST_OF_3 | (wch >> 12);
                *pchResult++ = UTF8_TRAIL    | LOW6BITS( wch >> 6 );
                *pchResult++ = UTF8_TRAIL    | LOW6BITS( wch );
            }
        }
    }

    //
    //  NULL terminate buffer
    //  return UTF8 character count
    //

    if ( pchResult && lengthUtf8 < cchResult )
    {
        *pchResult = 0;
    }
    return( lengthUtf8 );

OutOfBuffer:

    SetLastError( ERROR_INSUFFICIENT_BUFFER );
    return( 0 );
}




DWORD
_fastcall
Dns_Utf8ToUnicode(
    IN      PCHAR           pchUtf8,
    IN      DWORD           cchUtf8,
    OUT     PWCHAR          pwResult,
    IN      DWORD           cwResult
    )
/*++

Routine Description:

    Convert UTF8 characters to unicode.

    Result is NULL terminated if sufficient space in result
    buffer is available.

Arguments:

    pwResult    -- ptr to start of result buffer for unicode chars

    cwResult    -- length of result buffer in WCHAR

    pwUtf8      -- ptr to start of UTF8 buffer

    cchUtf8     -- length of UTF8 buffer

Return Value:

    Count of unicode characters in result, if successful.
    0 on error.  GetLastError() has error code.

--*/
{
    CHAR    ch;                     // current UTF8 character
    WCHAR   wch;                    // current unicode character
    DWORD   trailCount = 0;         // count of UTF8 trail bytes to follow
    DWORD   lengthUnicode = 0;      // length of unicode result string
    BOOL    bsurrogatePair = FALSE;
    DWORD   surrogateDword;


    //
    //  loop converting UTF8 chars until run out or error
    //

    while ( cchUtf8-- )
    {
        ch = *pchUtf8++;

        //
        //  ASCII character -- just copy
        //

        if ( BIT7(ch) == 0 )
        {
            lengthUnicode++;
            if ( pwResult )
            {
                if ( lengthUnicode >= cwResult )
                {
                    goto OutOfBuffer;
                }
                *pwResult++ = (WCHAR)ch;
            }
            continue;
        }

        //
        //  UTF8 trail byte
        //      - if not expected, error
        //      - otherwise shift unicode character 6 bits and
        //          copy in lower six bits of UTF8
        //      - if last UTF8 byte, copy result to unicode string
        //

        else if ( BIT6(ch) == 0 )
        {
            if ( trailCount == 0 )
            {
                goto InvalidUtf8;
            }

            if ( !bsurrogatePair )
            {
                wch <<= 6;
                wch |= LOW6BITS( ch );

                if ( --trailCount == 0 )
                {
                    lengthUnicode++;
                    if ( pwResult )
                    {
                        if ( lengthUnicode >= cwResult )
                        {
                            goto OutOfBuffer;
                        }
                        *pwResult++ = wch;
                    }
                }
                continue;
            }

            //  surrogate pair
            //      - same as above EXCEPT build two unicode chars
            //      from surrogateDword

            else
            {
                surrogateDword <<= 6;
                surrogateDword |= LOW6BITS( ch );

                if ( --trailCount == 0 )
                {
                    lengthUnicode += 2;

                    if ( pwResult )
                    {
                        if ( lengthUnicode >= cwResult )
                        {
                            goto OutOfBuffer;
                        }
                        surrogateDword -= 0x10000;
                        *pwResult++ = (WCHAR) ((surrogateDword >> 10) + HIGH_SURROGATE_START);
                        *pwResult++ = (WCHAR) ((surrogateDword & 0x3ff) + LOW_SURROGATE_START);
                    }
                    bsurrogatePair = FALSE;
                }
            }

        }

        //
        //  UTF8 lead byte
        //      - if currently in extension, error

        else
        {
            if ( trailCount != 0 )
            {
                goto InvalidUtf8;
            }

            //  first of two byte character (110xxxxx)

            if ( BIT5(ch) == 0 )
            {
                trailCount = 1;
                wch = LOW5BITS(ch);
                continue;
            }

            //  first of three byte character (1110xxxx)

            else if ( BIT4(ch) == 0 )
            {
                trailCount = 2;
                wch = LOW4BITS(ch);
                continue;
            }

            //  first of four byte surrogate pair (11110xxx)

            else if ( BIT3(ch) == 0 )
            {
                trailCount = 3;
                surrogateDword = LOW4BITS(ch);
                bsurrogatePair = TRUE;
            }

            else
            {
                goto InvalidUtf8;
            }
        }
    }

    //  catch if hit end in the middle of UTF8 multi-byte character

    if ( trailCount )
    {
        goto InvalidUtf8;
    }

    //
    //  NULL terminate buffer
    //  return the number of Unicode characters written.
    //

    if ( pwResult  &&  lengthUnicode < cwResult )
    {
        *pwResult = 0;
    }
    return( lengthUnicode );

OutOfBuffer:

    SetLastError( ERROR_INSUFFICIENT_BUFFER );
    return( 0 );

InvalidUtf8:

    SetLastError( ERROR_INVALID_DATA );
    return( 0 );
}




//
//  UTF8 \ ANSI conversions
//

DWORD
Dns_Utf8ToOrFromAnsi(
    OUT     PCHAR           pchResult,
    IN      DWORD           cchResult,
    IN      PCHAR           pchIn,
    IN      DWORD           cchIn,
    IN      DNS_CHARSET     InCharSet,
    IN      DNS_CHARSET     OutCharSet
    )
/*++

Routine Description:

    Convert UTF8 characters to ANSI or vice versa.

    Note:  this function appears to call string functions (string.c)
        which call back to it.  However, this calls those functions
        ONLY for conversions to\from unicode which do NOT call back
        to these functions.  Ultimately need to check if LCMapString
        can handle these issues.

Arguments:

    pchResult   -- ptr to start of result buffer for ansi chars

    cchResult   -- length of result buffer

    pchIn       -- ptr to start of input string

    cchIn       -- length of input string

    InCharSet   -- char set of input string (DnsCharSetAnsi or DnsCharSetUtf8)

    OutCharSet  -- char set for result string (DnsCharSetUtf8 or DnsCharSetAnsi)

Return Value:

    Count of bytes in result (including terminating NULL).
    0 on error.  GetLastError() has error code.

--*/
{
    DWORD       unicodeLength;
    DWORD       resultLength;
    CHAR        tempBuffer[ TEMP_BUFFER_LENGTH ];
    PCHAR       ptemp = tempBuffer;
    DNS_STATUS  status;

    DNSDBG( TRACE, (
        "Dns_Utf8ToOrFromAnsi()\n"
        "\tbuffer       = %p\n"
        "\tbuf length   = %d\n"
        "\tpchString    = %p (%*s)\n"
        "\tcchString    = %d\n"
        "\tCharSetIn    = %d\n"
        "\tCharSetOut   = %d\n",
        pchResult,
        cchResult,
        pchIn,
        cchIn, pchIn,
        cchIn,
        InCharSet,
        OutCharSet ));

    //
    //  validate charsets
    //

    ASSERT( InCharSet != OutCharSet );
    ASSERT( InCharSet == DnsCharSetAnsi || InCharSet == DnsCharSetUtf8 );
    ASSERT( OutCharSet == DnsCharSetAnsi || OutCharSet == DnsCharSetUtf8 );

    //
    //  if length not given, calculate
    //

    if ( cchIn == 0 )
    {
        cchIn = strlen( pchIn );
    }

    //
    //  string completely ASCII
    //      - simple memcopy suffices
    //      - note result must have terminating NULL
    //

    if ( Dns_IsStringAsciiEx(
                pchIn,
                cchIn ) )
    {
        if ( !pchResult )
        {
            return( cchIn + 1 );
        }

        if ( cchResult <= cchIn )
        {
            status = ERROR_INSUFFICIENT_BUFFER;
            goto Failed;
        }
        memcpy(
            pchResult,
            pchIn,
            cchIn );

        pchResult[ cchIn ] = 0;

        return( cchIn+1 );
    }

    //
    //  non-ASCII
    //      - convert to unicode, then to result character set
    //
    //  DCR_PERF:  LCMapStringA() might be able to handle all this
    //          haven't figured out how yet
    //

    unicodeLength = Dns_GetBufferLengthForStringCopy(
                        pchIn,
                        cchIn,
                        InCharSet,
                        DnsCharSetUnicode
                        );

    if ( unicodeLength > TEMP_BUFFER_LENGTH )
    {
        //  can't use static buffer, must allocate

        ptemp = Dns_StringCopyAllocate(
                    pchIn,
                    cchIn,
                    InCharSet,
                    DnsCharSetUnicode
                    );
        if ( !ptemp )
        {
            status = ERROR_INVALID_DATA;
            goto Failed;
        }
    }
    else
    {
        if ( unicodeLength == 0 )
        {
            status = ERROR_INVALID_DATA;
            goto Failed;
        }

        //  copy into temporary buffer

        resultLength = Dns_StringCopy(
                        ptemp,
                        NULL,       // adequate buffer length
                        pchIn,
                        cchIn,
                        InCharSet,
                        DnsCharSetUnicode
                        );
        if ( !resultLength )
        {
            status = ERROR_INVALID_DATA;
            goto Failed;
        }
        ASSERT( resultLength == unicodeLength );
    }

    //
    //  conversion to result char set
    //      - if have result buffer, convert into it
    //      - should have at least ONE two byte character
    //          otherwise should have taken fast path above
    //

    if ( pchResult )
    {
        resultLength = Dns_StringCopy(
                            pchResult,
                            & cchResult,        // result buffer length
                            ptemp,
                            0,
                            DnsCharSetUnicode,
                            OutCharSet
                            );
        if ( resultLength == 0 )
        {
            status = ERROR_INSUFFICIENT_BUFFER;
            goto Failed;
        }
        ASSERT( resultLength <= cchResult );
        ASSERT( pchResult[resultLength-1] == 0 );
        ASSERT( resultLength >= unicodeLength/2 );
    }

    else
    {
        resultLength = Dns_GetBufferLengthForStringCopy(
                            ptemp,
                            0,
                            DnsCharSetUnicode,
                            OutCharSet
                            );
        ASSERT( resultLength >= unicodeLength/2 );
    }

    //
    //  final mapping from unicode to result character set
    //

    if ( ptemp != tempBuffer )
    {
        FREE_HEAP( ptemp );
    }

    return( resultLength );


Failed:

    SetLastError( status );

    if ( ptemp != tempBuffer )
    {
        FREE_HEAP( ptemp );
    }

    return( 0 );
}



DWORD
Dns_AnsiToUtf8(
    IN      PCHAR           pchAnsi,
    IN      DWORD           cchAnsi,
    OUT     PCHAR           pchResult,
    IN      DWORD           cchResult
    )
/*++

Routine Description:

    Convert ANSI characters to UTF8.

Arguments:

    pchAnsi   -- ptr to start of ansi buffer

    cchAnsi  -- length of ansi buffer

    pchResult   -- ptr to start of result buffer for UTF8 chars

    cchResult   -- length of result buffer

Return Value:

    Count of UTF8 characters in result, if successful.
    0 on error.  GetLastError() has error code.

--*/
{
    return  Dns_Utf8ToOrFromAnsi(
                pchResult,          // result buffer
                cchResult,
                pchAnsi,            // in string
                cchAnsi,
                DnsCharSetAnsi,     // ANSI in
                DnsCharSetUtf8      // UTF8 out
                );
}



DWORD
Dns_Utf8ToAnsi(
    IN      PCHAR           pchUtf8,
    IN      DWORD           cchUtf8,
    OUT     PCHAR           pchResult,
    IN      DWORD           cchResult
    )
/*++

Routine Description:

    Convert UTF8 characters to ANSI.

Arguments:

    pchResult   -- ptr to start of result buffer for ansi chars

    cchResult   -- length of result buffer

    pwUtf8      -- ptr to start of UTF8 buffer

    cchUtf8     -- length of UTF8 buffer

Return Value:

    Count of ansi characters in result, if successful.
    0 on error.  GetLastError() has error code.

--*/
{
    return  Dns_Utf8ToOrFromAnsi(
                pchResult,          // result buffer
                cchResult,
                pchUtf8,            // in string
                cchUtf8,
                DnsCharSetUtf8,     // UTF8 in
                DnsCharSetAnsi      // ANSI out
                );
}



BOOL
_fastcall
Dns_IsStringAscii(
    IN      LPSTR           pszString
    )
/*++

Routine Description:

    Check if string is ASCII.

    This is equivalent to saying
        - is ANSI string already in UTF8
        or
        - is UTF8 string already in ANSI

    This allows you to optimize for the 99% case where just
    passing ASCII strings.

Arguments:

    pszString -- ANSI or UTF8 string to check for ASCIIhood

Return Value:

    TRUE if string is all ASCII (characters all < 128)
    FALSE if non-ASCII characters.

--*/
{
    register UCHAR   ch;

    //
    //  loop through until hit non-ASCII character
    //

    while ( ch = (UCHAR) *pszString++ )
    {
        if ( ch < 0x80 )
        {
            continue;
        }
        return( FALSE );
    }

    return( TRUE );
}



BOOL
_fastcall
Dns_IsStringAsciiEx(
    IN      PCHAR           pchString,
    IN      DWORD           cchString
    )
/*++

Routine Description:

    Check if ANSI (or UTF8) string is ASCII.

    This is equivalent to saying
        - is ANSI string already in UTF8
        or
        - is UTF8 string already in ANSI

    This allows you to optimize for the 99% case where just
    passing ASCII strings.

Arguments:

    pchString   -- ptr to start of ansi buffer

    cchString  -- length of ansi buffer

Return Value:

    TRUE if string is all ASCII (characters all < 128)
    FALSE if non-ASCII characters.

--*/
{
    //
    //  loop through until hit non-ASCII character
    //

    while ( cchString-- )
    {
        if ( (UCHAR)*pchString++ < 0x80 )
        {
            continue;
        }
        return( FALSE );
    }

    return( TRUE );
}



BOOL
_fastcall
Dns_IsWideStringAscii(
    IN      PWCHAR          pwszString
    )
/*++

Routine Description:

    Check if unicode string is ASCII.
    This means all characters < 128.

    Strings without extended characters need NOT be downcased
    on the wire.  This allows us to optimize for the 99% case
    where just passing ASCII strings.

Arguments:

    pwszString -- ptr to unicode string

Return Value:

    TRUE if string is all ASCII (characters all < 128)
    FALSE if non-ASCII characters.

--*/
{
    register USHORT ch;

    //
    //  loop through until hit non-ASCII character
    //

    while ( ch = (USHORT) *pwszString++ )
    {
        if ( ch < 0x80 )
        {
            continue;
        }
        return( FALSE );
    }

    return( TRUE );
}

//
//  End utf8.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\table.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    table.c

Abstract:

    Domain Name System (DNS) Library

    Routines to handle general table lookup.

Author:

    Jim Gilroy (jamesg)     December 1996

Revision History:

--*/


#include "local.h"

#include "time.h"


//
//  Comparison function
//

typedef INT (__cdecl * COMPARISON_FUNCTION)(
                            const CHAR *,
                            const CHAR *, 
                            size_t );



//
//  Table lookup.
//
//  Many DNS Records have human readable mnemonics for given data values.
//  These are used for data file formats, and display in nslookup or debug
//  output or cmdline tools.
//
//  To simplify this process, have a single mapping functionality that
//  supports DWORD \ LPSTR mapping tables.   Tables for indivual types
//  may then be layered on top of this.
//
//  Support two table types.
//      VALUE_TABLE_ENTRY is simple value-string mapping
//      FLAG_TABLE_ENTRY is designed for bit field flag mappings where
//          several flag strings might be contained in flag;  this table
//          contains additional mask field to allow multi-bit fields
//          within the flag
//

#if 0
//
//  Defined in local.h here only for reference
//
typedef struct
{
    DWORD   dwValue;        //  flag value
    PCHAR   pszString;      //  string representation of value
}
DNS_VALUE_TABLE_ENTRY;

typedef struct
{
    DWORD   dwFlag;         //  flag value
    DWORD   dwMask;         //  flag value mask
    PCHAR   pszString;      //  string representation of value
}
DNS_FLAG_TABLE_ENTRY;

//  Error return on unmatched string

#define DNS_TABLE_LOOKUP_ERROR (-1)

#endif



DWORD
Dns_ValueForString(
    IN      DNS_VALUE_TABLE_ENTRY * Table,
    IN      BOOL                    fIgnoreCase,
    IN      PCHAR                   pchName,
    IN      INT                     cchNameLength
    )
/*++

Routine Description:

    Retrieve value for given string.

Arguments:

    Table           - table with value\string mapping

    fIgnoreCase     - TRUE if case-insensitive string lookup

    pchName         - ptr to string

    cchNameLength   - length of string

Return Value:

    Flag value corresponding to string, if found.
    DNS_TABLE_LOOKUP_ERROR otherwise.

--*/
{
    INT     i = 0;
    //    INT     (* pcompareFunction)( const char *, const char *, size_t );
    COMPARISON_FUNCTION  pcompareFunction;


    //
    //  if not given get string length
    //

    if ( !cchNameLength )
    {
        cchNameLength = strlen( pchName );
    }

    //
    //  determine comparison routine
    //

    if ( fIgnoreCase )
    {
        pcompareFunction = _strnicmp;
    }
    else
    {
        pcompareFunction = strncmp;
    }

    //
    //  find value matching name
    //

    while( Table[i].pszString != NULL )
    {
        if ( pcompareFunction( pchName, Table[i].pszString, cchNameLength ) == 0 )
        {
            return( Table[i].dwValue );
        }
        i++;
    }

    return( (DWORD)DNS_TABLE_LOOKUP_ERROR );
}



PCHAR
Dns_GetStringForValue(
    IN      DNS_VALUE_TABLE_ENTRY * Table,
    IN      DWORD                   dwValue
    )
/*++

Routine Description:

    Retrieve string representation of given value.

Arguments:

    Table   - table with value\string mapping

    dwValue - value to map to strings

Return Value:

    Ptr to mapping mneumonic string.
    NULL if unknown mapping type.

--*/
{
    INT i = 0;

    //
    //  check all supported values for match
    //

    while( Table[i].pszString != NULL )
    {
        if ( dwValue == Table[i].dwValue )
        {
            return( Table[i].pszString );
        }
        i++;
    }
    return( NULL );
}



DWORD
Dns_FlagForString(
    IN      DNS_FLAG_TABLE_ENTRY *  Table,
    IN      BOOL                    fIgnoreCase,
    IN      PCHAR                   pchName,
    IN      INT                     cchNameLength
    )
/*++

Routine Description:

    Retrieve flag value for given string.

    This may be called repeatedly with additional strings and OR the result
    together to build flag with independent bit settings.

Arguments:

    Table           - table with value\string mapping

    fIgnoreCase     - TRUE if case-insensitive string lookup

    pchName         - ptr to string

    cchNameLength   - length of string

Return Value:

    Flag value corresponding to string, if found.
    DNS_TABLE_LOOKUP_ERROR otherwise.

--*/
{
    INT i = 0;

    //
    //  if not given get string length
    //

    if ( !cchNameLength )
    {
        cchNameLength = strlen( pchName );
    }

    //
    //  check all supported values for name match
    //

    if ( fIgnoreCase )
    {
        while( Table[i].pszString != NULL )
        {
            if ( cchNameLength == (INT)strlen( Table[i].pszString )
                    &&
                ! _strnicmp( pchName, Table[i].pszString, cchNameLength ) )
            {
                return( Table[i].dwFlag );
            }
            i++;
        }
    }
    else
    {
        while( Table[i].pszString != NULL )
        {
            if ( cchNameLength == (INT)strlen( Table[i].pszString )
                    &&
                ! strncmp( pchName, Table[i].pszString, cchNameLength ) )
            {
                return( Table[i].dwFlag );
            }
            i++;
        }
    }

    return( (DWORD) DNS_TABLE_LOOKUP_ERROR );
}



VOID
DnsPrint_ValueTable(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN      PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      PDNS_VALUE_TABLE    Table
    )
/*++

Routine Description:

    Print value table.

Arguments:

    PrintRoutine    - routine to print with

    pPrintContext   - print context

    pszHeader       - header to print

    Table           - value table to print

Return Value:

    None

--*/
{
    DWORD   i = 0;

    if ( !pszHeader )
    {
        pszHeader = "Table";
    }

    if ( ! pszHeader )
    {
        PrintRoutine(
            pPrintContext,
            "%s NULL value table to print",
            pszHeader );
    }

    //
    //  print each value in table
    //

    DnsPrint_Lock();

    PrintRoutine(
        pPrintContext,
        "%s\n",
        pszHeader );

    while( Table[i].pszString != NULL )
    {
        PrintRoutine(
            pPrintContext,
            "\t%40s\t\t%08x\n",
            Table[i].pszString,
            Table[i].dwValue );
        i++;
    }

    DnsPrint_Unlock();
}



PCHAR
Dns_WriteStringsForFlag(
    IN      DNS_FLAG_TABLE_ENTRY *  Table,
    IN      DWORD                   dwFlag,
    IN OUT  PCHAR                   pchFlag
    )
/*++

Routine Description:

    Retrieve flag string(s) corresponding to a given flag value.

    This function is specifically for mapping a flag value into the
    corresponding flag mnemonics.

    No attempt is made to insure that every bit of dwValue is mapped,
    nor are bits eliminated as they are mapped.  Every value in table
    that exactly matches bits in the table is returned.

Arguments:

    Table   - table with value\string mapping

    dwFlag  - flag value to map to strings

    pchFlag - buffer to write flag to

Return Value:

    Ptr to next location in pchFlag buffer.
    If this is same as input, then no strings were written.

--*/
{
    INT i = 0;

    //  init buffer for no-match

    DNS_ASSERT( pchFlag != NULL );
    *pchFlag = 0;

    //
    //  check all supported flags types for name match
    //      - note comparing flag within mask to allow match of multi-bit
    //      flags
    //

    while( Table[i].pszString != NULL )
    {
        if ( (dwFlag & Table[i].dwMask) == Table[i].dwFlag )
        {
            pchFlag += sprintf( pchFlag, "%s ", Table[i].pszString );
        }
        i++;
    }
    return( pchFlag );
}





//
//  Specific simple tables
//

//
//  RnR Flag mappings
//

DNS_VALUE_TABLE_ENTRY  RnrLupFlagTable[] =
{
    LUP_DEEP                    ,   "LUP_DEEP"                ,
    LUP_CONTAINERS              ,   "LUP_CONTAINERS"          ,
    LUP_NOCONTAINERS            ,   "LUP_NOCONTAINERS"        ,
    LUP_RETURN_NAME             ,   "LUP_RETURN_NAME"         ,
    LUP_RETURN_TYPE             ,   "LUP_RETURN_TYPE"         ,
    LUP_RETURN_VERSION          ,   "LUP_RETURN_VERSION"      ,
    LUP_RETURN_COMMENT          ,   "LUP_RETURN_COMMENT"      ,
    LUP_RETURN_ADDR             ,   "LUP_RETURN_ADDR"         ,
    LUP_RETURN_BLOB             ,   "LUP_RETURN_BLOB"         ,
    LUP_RETURN_ALIASES          ,   "LUP_RETURN_ALIASES"      ,
    LUP_RETURN_QUERY_STRING     ,   "LUP_RETURN_QUERY_STRING" ,
    LUP_RETURN_ALL              ,   "LUP_RETURN_ALL"          ,
    LUP_RES_SERVICE             ,   "LUP_RES_SERVICE"         ,
    LUP_FLUSHCACHE              ,   "LUP_FLUSHCACHE"          ,
    LUP_FLUSHPREVIOUS           ,   "LUP_FLUSHPREVIOUS"       ,

    0,  NULL,
};                                  



DWORD
Dns_RnrLupFlagForString(
    IN      PCHAR           pchName,
    IN      INT             cchNameLength
    )
/*++

Routine Description:

    Retrieve RnR LUP flag corresponding to string.

Arguments:

    pchName - ptr to string
    cchNameLength - length of string

Return Value:

    Flag corresponding to string, if found.
    Zero otherwise.

--*/
{
    return  Dns_ValueForString(
                RnrLupFlagTable,
                FALSE,              // always upper case
                pchName,
                cchNameLength );
}



PCHAR
Dns_GetRnrLupFlagString(
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Get string corresponding to a given RnR LUP flag.

Arguments:

    dwFlag -- flag

Return Value:

    Ptr to flag mneumonic string.
    NULL if unknown flag.

--*/
{
    return  Dns_GetStringForValue(
                RnrLupFlagTable,
                dwFlag );
}


//
//  RnR Name Space ID mappings
//

DNS_VALUE_TABLE_ENTRY  RnrNameSpaceMappingTable[] =
{
    NS_ALL              ,   "NS_ALL"            ,  
    //NS_DEFAULT          ,   "NS_DEFAULT"        ,
    NS_SAP              ,   "NS_SAP"            ,  
    NS_NDS              ,   "NS_NDS"            ,  
    NS_PEER_BROWSE      ,   "NS_PEER_BROWSEE"   ,  
    NS_SLP              ,   "NS_SLP"            ,  
    NS_DHCP             ,   "NS_DHCP"           ,  
    NS_TCPIP_LOCAL      ,   "NS_TCPIP_LOCAL"    ,  
    NS_TCPIP_HOSTS      ,   "NS_TCPIP_HOSTS"    ,  
    NS_DNS              ,   "NS_DNS"            ,  
    NS_NETBT            ,   "NS_NETBT"          ,  
    NS_WINS             ,   "NS_WINS"           ,  
    NS_NLA              ,   "NS_NLA"            ,  
    NS_NBP              ,   "NS_NBP"            ,  
    NS_MS               ,   "NS_MS"             ,  
    NS_STDA             ,   "NS_STDA"           ,  
    NS_NTDS             ,   "NS_NTDS"           ,  
    NS_X500             ,   "NS_X500"           ,  
    NS_NIS              ,   "NS_NIS"            ,  
    NS_NISPLUS          ,   "NS_NISPLUS"        ,  
    NS_WRQ              ,   "NS_WRQ"            ,  
    NS_NETDES           ,   "NS_NETDES"         ,  

    0,  NULL,
};                                  


DWORD
Dns_RnrNameSpaceIdForString(
    IN      PCHAR           pchName,
    IN      INT             cchNameLength
    )
/*++

Routine Description:

    Retrieve RnR Name Space Id corresponding to string.

Arguments:

    pchName - ptr to string
    cchNameLength - length of string

Return Value:

    Name space ID corresponding to string, if found.
    Zero otherwise.

--*/
{
    return  Dns_ValueForString(
                RnrNameSpaceMappingTable,
                FALSE,              // always upper case
                pchName,
                cchNameLength );
}



PCHAR
Dns_GetRnrNameSpaceIdString(
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Get string corresponding to a given RnR name space id.

Arguments:

    dwFlag -- flag

Return Value:

    Ptr to name space mneumonic string.
    NULL if unknown flag.

--*/
{
    return  Dns_GetStringForValue(
                RnrNameSpaceMappingTable,
                dwFlag );
}

//
//  End table.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\update.c ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    update.c

Abstract:

    Domain Name System (DNS) Library

    Update client routines.

Author:

    Jim Gilroy (jamesg)     October, 1996

Environment:

    User Mode - Win32

Revision History:

--*/


#include "local.h"

//
//  Update Timeouts
//
//  note, max is a little longer than might be expected as DNS server
//  may have to contact primary and wait for primary to do update (inc.
//  disk access) then response
//

#define INITIAL_UPDATE_TIMEOUT  (4)     // 4 seconds
#define MAX_UPDATE_TIMEOUT      (60)    // 60 seconds



PCHAR
Dns_WriteNoDataUpdateRecordToMessage(
    IN      PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      WORD            wClass,
    IN      WORD            wType
    )
/*++

Routine Description:

    No data RR cases:

    This includes prereqs and deletes except for specific record cases.

Arguments:

    pch - ptr to next byte in packet buffer

    pchStop - end of packet buffer

    wClass - class

    wType - desired RR type

Return Value:

    Ptr to next postion in buffer, if successful.
    NULL on error.

--*/
{
    PDNS_WIRE_RECORD    pdnsRR;

    DNSDBG( WRITE, (
        "Writing update RR to packet buffer at %p.\n",
        pch ));

    //
    //  out of space
    //

    pdnsRR = (PDNS_WIRE_RECORD) pch;
    pch += sizeof( DNS_WIRE_RECORD );
    if ( pch >= pchStop )
    {
        DNS_PRINT(( "ERROR  out of space writing record to packet.\n" ));
        return( NULL );
    }

    //
    //  set type and class
    //

    *(UNALIGNED WORD *) &pdnsRR->RecordType  = htons( wType );
    *(UNALIGNED WORD *) &pdnsRR->RecordClass = htons( wClass );

    //
    //  TTL and datalength zero for all no data cases
    //      - prereqs except specific record delete
    //      - deletes except specific record delete
    //

    *(UNALIGNED DWORD *) &pdnsRR->TimeToLive = 0;
    *(UNALIGNED WORD *) &pdnsRR->DataLength = 0;

    return( pch );
}



PCHAR
Dns_WriteDataUpdateRecordToMessage(
    IN      PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      WORD            wClass,
    IN      WORD            wType,
    IN      DWORD           dwTtl,
    IN      WORD            wDataLength
    )
/*++

Routine Description:

    No data RR cases:

    This includes prereqs and deletes except for specific record cases.

Arguments:

    pch - ptr to next byte in packet buffer

    pchStop - end of packet buffer

    wClass - class

    wType - desired RR type

    dwTtl - time to live

    wDataLength - data length

Return Value:

    Ptr to next postion in buffer, if successful.
    NULL on error.

--*/
{
    PDNS_WIRE_RECORD    pdnsRR;

    DNSDBG( WRITE2, (
        "Writing RR to packet buffer at %p.\n",
        pch ));

    //
    //  out of space
    //

    pdnsRR = (PDNS_WIRE_RECORD) pch;
    pch += sizeof( DNS_WIRE_RECORD );
    if ( pch + wDataLength >= pchStop )
    {
        DNS_PRINT(( "ERROR  out of space writing record to packet.\n" ));
        return( NULL );
    }

    //
    //  set type and class
    //

    *(UNALIGNED WORD *) &pdnsRR->RecordType  = htons( wType );
    *(UNALIGNED WORD *) &pdnsRR->RecordClass = htons( wClass );

    //
    //  TTL and datalength zero for all no data cases
    //      - prereqs except specific record delete
    //      - deletes except specific record delete
    //

    *(UNALIGNED DWORD *) &pdnsRR->TimeToLive = htonl( dwTtl );
    *(UNALIGNED WORD *) &pdnsRR->DataLength = htons( wDataLength );

    return( pch );
}



//
//  Host update routines
//

#if 0
PDNS_MSG_BUF
Dns_BuildHostUpdateMessage(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      LPSTR           pszZone,
    IN      LPSTR           pszName,
    IN      PIP_ARRAY       aipAddresses,
    IN      DWORD           dwTtl
    )
/*++

Routine Description:

    Build server update message.

Arguments:

    pMsg -- existing message buffer, to use;  NULL to allocate new one

    pszZone -- zone name for update

    pszName -- full DNS hostname being updated

    aipAddresses -- IP addresses to be updated

Return Value:

    ERROR_SUCCESS if successful.
    Error status on failure.

--*/
{
    PDNS_HEADER     pdnsMsg;
    PCHAR           pch;
    PCHAR           pchstop;
    DWORD           i;
    WORD            nameOffset;

    IF_DNSDBG( UPDATE )
    {
        DNS_PRINT((
            "Enter Dns_BuildHostUpdateMessage()\n"
            "\tpMsg     = %p\n"
            "\tpszZone  = %s\n"
            "\tpszName  = %s\n"
            "\tdwTtl    = %d\n",
            pMsg,
            pszZone,
            pszName,
            dwTtl ));
        DnsDbg_IpArray(
            "\tHost IP array\n",
            "host",
            aipAddresses );
    }

    //
    //  create message buffer
    //

    if ( !pMsg )
    {
        DNS_PRINT(( "Allocating new UPDATE message buffer.\n" ));

        pMsg = ALLOCATE_HEAP( DNS_UDP_ALLOC_LENGTH );
        if ( !pMsg )
        {
            return( NULL );
        }
        RtlZeroMemory(
            pMsg,
            DNS_UDP_ALLOC_LENGTH );

        pMsg->BufferLength = DNS_UDP_MAX_PACKET_LENGTH;
        pMsg->pBufferEnd = (PCHAR)&pMsg->MessageHead + pMsg->BufferLength;

        //
        //  set default sockaddr info
        //      - caller MUST choose remote IP address

        pMsg->RemoteAddress.sin_family = AF_INET;
        pMsg->RemoteAddress.sin_port = NET_ORDER_DNS_PORT;
        pMsg->RemoteAddressLength = sizeof( SOCKADDR_IN );

        //  set header for update

        pMsg->MessageHead.Opcode = DNS_OPCODE_UPDATE;
    }

    //
    //  existing message, just verify
    //

    ELSE_ASSERT( pMsg->MessageHead.Opcode == DNS_OPCODE_UPDATE );

    //
    //  reset current pointer after header
    //      - note:  send length is set based on this ptr
    //

    pMsg->pCurrent = pMsg->MessageBody;


    //
    //  build message
    //

    pch = pMsg->pCurrent;
    pchstop = pMsg->pBufferEnd;

    //
    //  zone section
    //

    pMsg->MessageHead.QuestionCount = 1;
    pch = Dns_WriteDottedNameToPacket(
            pch,
            pchstop,
            pszZone,
            NULL,
            0,
            FALSE );
    if ( !pch )
    {
        return( NULL );
    }
    *(UNALIGNED WORD *) pch = DNS_RTYPE_SOA;
    pch += sizeof(WORD);
    *(UNALIGNED WORD *) pch = DNS_RCLASS_INTERNET;
    pch += sizeof(WORD);

    //
    //  prerequisites -- no records
    //

    pMsg->MessageHead.AnswerCount = 0;

    //
    //  update
    //      - delete A records at name
    //      - add new A records
    //

    //  save offset to host name for future writes

    nameOffset = (WORD)(pch - (PCHAR) &pMsg->MessageHead);

    pch = Dns_WriteDottedNameToPacket(
                pch,
                pchstop,
                pszName,
                pszZone,
                DNS_OFFSET_TO_QUESTION_NAME,
                FALSE );
    if ( !pch )
    {
        DNS_PRINT(( "ERROR writing dotted name to packet.\n" ));
        return( NULL );
    }
    pch = Dns_WriteNoDataUpdateRecordToMessage(
                pch,
                pchstop,
                DNS_CLASS_ALL,  //  delete all
                DNS_TYPE_A     //  A records
                );
    DNS_ASSERT( pch );

    //
    //  add A record for each address in array
    //      - use offset for name
    //      - write IP

    for ( i=0; i<aipAddresses->AddrCount; i++ )
    {
        *(UNALIGNED WORD *) pch = htons( (WORD)(nameOffset|(WORD)0xC000) );
        pch += sizeof( WORD );
        pch = Dns_WriteDataUpdateRecordToMessage(
                    pch,
                    pchstop,
                    DNS_CLASS_INTERNET,
                    DNS_TYPE_A,        //  A records
                    dwTtl,
                    sizeof(IP_ADDRESS)
                    );
        DNS_ASSERT( pch );
        *(UNALIGNED DWORD *) pch = aipAddresses->AddrArray[i];
        pch += sizeof(DWORD);
    }

    //  total update sections RRs
    //      one delete RR, plus one for each new IP

    pMsg->MessageHead.NameServerCount = (USHORT)(aipAddresses->AddrCount + 1);

    //
    //  additional section - no records
    //

    pMsg->MessageHead.AdditionalCount = 0;

    //
    //  reset current ptr -- need for send routine
    //

    pMsg->pCurrent = pch;

    IF_DNSDBG( SEND )
    {
        DnsDbg_Message(
            "UPDATE packet built",
            pMsg );
    }
    return( pMsg );
}
#endif



PDNS_RECORD
Dns_HostUpdateRRSet(
    IN      LPSTR           pszHostName,
    IN      PIP_ARRAY       AddrArray,
    IN      DWORD           dwTtl
    )
/*++

Routine Description:

    Create records for host update:
        -- whack of all A records
        -- add of all A records in new set

Arguments:

    pszHostName -- host name, FULL FQDN

    AddrArray -- new IPs of host

    dwTtl -- TTL for records

Return Value:

    Ptr to record list.
    NULL on error.

--*/
{
    DNS_RRSET   rrset;
    PDNS_RECORD prr;
    DWORD       i;

    //
    //  create whack
    //

    prr = Dns_AllocateRecord( 0 );
    if ( ! prr )
    {
        return( NULL );
    }
    prr->pName = pszHostName;
    prr->wType = DNS_TYPE_A;
    prr->Flags.S.Section = DNSREC_UPDATE;
    prr->Flags.S.Delete = TRUE;

    //
    //  create update record for each address
    //

    if ( !AddrArray )
    {
        return( prr );
    }
    DNS_RRSET_INIT( rrset );
    DNS_RRSET_ADD( rrset, prr );

    for ( i=0; i<AddrArray->AddrCount; i++ )
    {
        prr = Dns_AllocateRecord( sizeof(DNS_A_DATA) );
        if ( ! prr )
        {
            Dns_RecordListFree( rrset.pFirstRR, FALSE );
            return( NULL );
        }
        prr->pName = pszHostName;
        prr->wType = DNS_TYPE_A;
        prr->Flags.S.Section = DNSREC_UPDATE;
        prr->dwTtl = dwTtl;
        prr->Data.A.IpAddress = AddrArray->AddrArray[i];

        DNS_RRSET_ADD( rrset, prr );
    }

    //  return ptr to first record in list

    return( rrset.pFirstRR );
}



//
//  DCR:  dead code, remove
//
DNS_STATUS
Dns_UpdateHostAddrs(
    IN      LPSTR           pszName,
    IN      PIP_ARRAY       aipAddresses,
    IN      PIP_ARRAY       aipServers,
    IN      DWORD           dwTtl
    )
/*++

Routine Description:

    Updates client's A records registered with DNS server.

Arguments:

    pszName -- name (FQDN) of client to update

    aipAddresses -- counted array of new client IP addrs

    aipServers -- counted array of DNS server IP addrs

    dwTtl -- TTL for new A records

Return Value:

    ERROR_SUCCESS if successful.
    Error status on failure.

--*/
{
    PDNS_RECORD prr;
    DNS_STATUS  status;

    IF_DNSDBG( UPDATE )
    {
        DNS_PRINT((
            "Enter Dns_UpdateHostAddrs()\n"
            "\tpszName  = %s\n"
            "\tdwTtl    = %d\n",
            pszName,
            dwTtl ));
        DnsDbg_IpArray(
            "\tHost IP array\n",
            "\tHost",
            aipAddresses );
        DnsDbg_IpArray(
            "\tNS IP array\n",
            "\tNS",
            aipServers );
    }

    //
    //  never let anyone set a TTL longer than 1 hour
    //
    //  DCR:  define policy on what our clients should use for TTL
    //      one hour is not bad
    //      could key off type of address
    //          RAS -- 15 minutes (as may be back up again quickly)
    //          DHCP -- one hour (may move)
    //          static -- one day (machines may be reconfigured)
    //

    if ( dwTtl > 3600 )
    {
        dwTtl = 3600;
    }

    //
    //  build update RR set
    //

    prr = Dns_HostUpdateRRSet(
            pszName,
            aipAddresses,
            dwTtl );
    if ( ! prr )
    {
        status = GetLastError();
        DNS_ASSERT( status == DNS_ERROR_NO_MEMORY );
        return status;
    }

    //
    //  do the update
    //

    status = Dns_UpdateLib(
                prr,
                0,          // no flags
                NULL,       // no adapter list
                NULL,       // use default credentials
                NULL        // response not desired
                );

    Dns_RecordListFree( prr, FALSE );

    DNSDBG( UPDATE, (
        "Leave Dns_UpdateHostAddrs() status=%p %s\n",
        status,
        Dns_StatusString(status) ));

    return( status );
}



DNS_STATUS
Dns_UpdateLib(
    IN      PDNS_RECORD         pRecord,
    IN      DWORD               dwFlags,
    IN      PDNS_NETINFO        pNetworkInfo,
    IN      HANDLE              hCreds          OPTIONAL,
    OUT     PDNS_MSG_BUF *      ppMsgRecv       OPTIONAL
    )
/*++

Routine Description:

    Send DNS update.

Arguments:

    pRecord -- list of records to send in update

    dwFlags -- update flags;  primarily security

    pNetworkInfo -- adapter list with necessary info for update
                        - zone name
                        - primary name server name
                        - primary name server IP

    ppMsgRecv -- OPTIONAL addr to recv ptr to response message

Return Value:

    ERROR_SUCCESS if successful.
    Error status on failure.

--*/
{
    PDNS_MSG_BUF    pmsgSend = NULL;
    PDNS_MSG_BUF    pmsgRecv = NULL;
    DNS_STATUS      status = NO_ERROR;
    WORD            length;
    PIP_ARRAY       parrayServers = NULL;
    LPSTR           pszzone;
    LPSTR           pszserverName;
    BOOL            fsecure = FALSE;
    BOOL            fswitchToTcp = FALSE;
    DNS_HEADER      header;
    PCHAR           pCreds=NULL;

    DNSDBG( UPDATE, (
        "Dns_UpdateLib()\n"
        "\tflags        = %p\n"
        "\tpRecord      = %p\n"
        "\t\towner      = %s\n",
        dwFlags,
        pRecord,
        pRecord ? pRecord->pName : NULL ));

    //
    //  if not a UPDATE compatibile adapter list -- no action
    //

    if ( !IS_UPDATE_NETWORK_INFO(pNetworkInfo) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    //  suck info from adapter list
    //

    pszzone = pNetworkInfo->pSearchList->pszDomainOrZoneName;

    parrayServers = Dns_ConvertNetworkInfoToIpArray( pNetworkInfo );

    pszserverName = pNetworkInfo->aAdapterInfoList[0]->pszAdapterDomain;

    DNS_ASSERT( pszzone && parrayServers );

    //
    //  build recv message buffer
    //      - must be big enough for TCP
    //

    pmsgRecv = Dns_AllocateMsgBuf( DNS_TCP_DEFAULT_PACKET_LENGTH );
    if ( !pmsgRecv )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Cleanup;
    }

    //
    //  build update packet
    //  note currently this function allocates TCP sized buffer if records
    //      given;  if this changes need to alloc TCP buffer here
    //

    CLEAR_DNS_HEADER_FLAGS_AND_XID( &header );
    header.Opcode = DNS_OPCODE_UPDATE;

    pmsgSend = Dns_BuildPacket(
                    &header,        // copy header
                    TRUE,           //  ... but not header counts
                    pszzone,        // question zone\type SOA
                    DNS_TYPE_SOA,
                    pRecord,
                    0,              // no other flags
                    TRUE            // building an update packet
                    );
    if ( !pmsgSend)
    {
        DNS_PRINT(( "ERROR:  failed send buffer allocation.\n" ));
        status = DNS_ERROR_NO_MEMORY;
        goto Cleanup;
    }

    //
    //  try non-secure first unless explicitly secure only
    //

    fsecure = (dwFlags & DNS_UPDATE_SECURITY_ONLY);

    if ( !fsecure )
    {
        status = Dns_SendAndRecv(
                    pmsgSend,
                    & pmsgRecv,
                    NULL,           // no response records
                    dwFlags,
                    parrayServers,
                    pNetworkInfo );

        if ( status == ERROR_SUCCESS )
        {
            status = Dns_MapRcodeToStatus( pmsgRecv->MessageHead.ResponseCode );
        }

        if ( status != DNS_ERROR_RCODE_REFUSED ||
            dwFlags & DNS_UPDATE_SECURITY_OFF )
        {
            goto Cleanup;
        }

        DNSDBG( UPDATE, (
            "Failed unsecure update, switching to secure!\n"
            "\tcurrent time (ms) = %d\n",
            GetCurrentTime() ));
        fsecure = TRUE;
    }

    //
    //  security
    //      - must have server name
    //      - must start package
    //

    if ( fsecure )
    {
        if ( !pszserverName )
        {
            status = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
        status = Dns_StartSecurity( FALSE );
        if ( status != ERROR_SUCCESS )
        {
            goto Cleanup;
        }

        pCreds = Dns_GetApiContextCredentials(hCreds);


        status = Dns_DoSecureUpdate(
                    pmsgSend,
                    pmsgRecv,
                    NULL,
                    dwFlags,
                    pNetworkInfo,
                    parrayServers,
                    pszserverName,
                    pCreds,         // initialized in DnsAcquireContextHandle
                    NULL            // default context name
                    );
        if ( status == ERROR_SUCCESS )
        {
            status = Dns_MapRcodeToStatus( pmsgRecv->MessageHead.ResponseCode );
        }
    }


Cleanup:

    //  free server array sucked from adapter list

    if ( parrayServers )
    {
        FREE_HEAP( parrayServers );
    }

    //  return recv message buffer

    if ( ppMsgRecv )
    {
        *ppMsgRecv = pmsgRecv;
    }
    else
    {
        FREE_HEAP( pmsgRecv );
    }
    FREE_HEAP( pmsgSend);

    DNSDBG( UPDATE, (
        "Dns_UpdateLib() completed, status = %p %s.\n",
        status,
        Dns_StatusString(status) ));

    return( status );
}



DNS_STATUS
Dns_UpdateLibEx(
    IN      PDNS_RECORD         pRecord,
    IN      DWORD               dwFlags,
    IN      PDNS_NAME           pszZone,
    IN      PDNS_NAME           pszServerName,
    IN      PIP_ARRAY           aipServers,
    IN      HANDLE              hCreds          OPTIONAL,
    OUT     PDNS_MSG_BUF *      ppMsgRecv       OPTIONAL
    )
/*++

Routine Description:

    Send DNS update.

    This routine builds an UPDATE compatible pNetworkInfo from the
    information given.  Then calls Dns_Update().

Arguments:

    pRecord -- list of records to send in update

    pszZone -- zone name for update

    pszServerName -- server name

    aipServers -- DNS servers to send update to

    hCreds -- Optional Credentials info

    ppMsgRecv -- addr for ptr to recv buffer, if desired

Return Value:

    ERROR_SUCCESS if successful.
    Error status on failure.

--*/
{
    PDNS_NETINFO        pNetworkInfo;
    DNS_STATUS          status = NO_ERROR;

    //
    //  convert params into UPDATE compatible adapter list
    //

    pNetworkInfo = Dns_CreateUpdateNetworkInfo(
                        pszZone,
                        pszServerName,
                        aipServers,
                        0 );

    if ( !pNetworkInfo )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    //  call real update function
    //

    status = Dns_UpdateLib(
                pRecord,
                dwFlags,
                pNetworkInfo,
                hCreds,
                ppMsgRecv );

    Dns_FreeNetworkInfo( pNetworkInfo );

    return status;
}

//
//  End update.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\straddr.c ===
/*++

Copyright (c) 1996-2001 Microsoft Corporation

Module Name:

    straddr.c

Abstract:

    Domain Name System (DNS) Library

    Routines to string to\from address conversions.

Author:

    Jim Gilroy (jamesg)     December 1996

Revision History:

    jamesg      June 2000       New IP6 parsing.
    jamesg      Oct 2000        Created this module.

--*/


#include "local.h"
#include "ws2tcpip.h"   // IP6 inaddr definitions



//
//  String to address
//

BOOL
Dns_Ip6StringToAddress_A(
    OUT     PIP6_ADDRESS    pIp6Addr,
    IN      PCSTR           pString
    )
/*++

Routine Description:

    Convert string to IP6 address.

Arguments:

    pAddress -- ptr to IP6 address to be filled in

    pString -- string with IP6 address

Return Value:

    TRUE if successful.
    FALSE otherwise.

--*/
{
    DNS_STATUS  status;
    PCHAR       pstringEnd = NULL;


    DNSDBG( PARSE2, (
        "Dns_Ip6StringToAddress_A( %s )\n",
        pString ));

    //
    //  convert to IP6 address
    //

    status = RtlIpv6StringToAddressA(
                pString,
                & pstringEnd,
                (PIN6_ADDR) pIp6Addr );

    return( status == NO_ERROR  &&  *pstringEnd==0 );
}



BOOL
Dns_Ip6StringToAddressEx_A(
    OUT     PIP6_ADDRESS    pIp6Addr,
    IN      PCSTR           pchString,
    IN      DWORD           dwStringLength
    )
/*++

Routine Description:

    Convert string to IP6 address.

    This version handles non-NULL-terminated strings
    for DNS server file load.

Arguments:

    pAddress -- ptr to IP6 address to be filled in

    pchString -- string with IP6 address

    dwStringLength -- string length

Return Value:

    TRUE if successful.
    FALSE otherwise.

--*/
{
    CHAR        tempBuf[ IP6_ADDRESS_STRING_BUFFER_LENGTH ];
    PCSTR       pstring;
    
    DNSDBG( PARSE2, (
        "Dns_Ip6StringToAddressEx_A( %.*s )\n"
        "\tpchString = %p\n",
        dwStringLength,
        pchString,
        pchString ));

    //
    //  copy string if given length
    //  if no length assume NULL terminated
    //

    pstring = pchString;

    if ( dwStringLength )
    {
        DWORD   bufLength = IP6_ADDRESS_STRING_BUFFER_LENGTH;

        if ( ! Dns_StringCopy(
                    tempBuf,
                    & bufLength,
                    (PCHAR) pstring,
                    dwStringLength,
                    DnsCharSetAnsi,
                    DnsCharSetAnsi ) )
        {
            return( FALSE );
        }
        pstring = tempBuf;
    }

    //  convert to IP6 address

    return  Dns_Ip6StringToAddress_A(
                pIp6Addr,
                pstring );
}



BOOL
Dns_Ip6StringToAddress_W(
    OUT     PIP6_ADDRESS    pIp6Addr,
    IN      PCWSTR          pwString
    )
/*++

Routine Description:

    Build IP6 address from wide string.

Arguments:

    pwString -- unicode IP6 string

    pIp6Addr -- addr to recv IP6 address

Return Value:

    TRUE if successful conversion.
    FALSE on bad string.

--*/
{
    DNS_STATUS  status;
    PWCHAR      pstringEnd = NULL;

    DNSDBG( PARSE2, (
        "Dns_Ip6StringToAddress_W( %S )\n",
        pwString ));

    //
    //  convert to IP6 address
    //

    status = RtlIpv6StringToAddressW(
                pwString,
                & pstringEnd,
                (PIN6_ADDR) pIp6Addr );

    return( status == NO_ERROR  &&  *pstringEnd==0 );
}



BOOL
Dns_Ip4StringToAddress_A(
    OUT     PIP4_ADDRESS    pIp4Addr,
    IN      PCSTR           pString
    )
/*++

Routine Description:

    Build IP4 address from narrow string.

Arguments:

    pIp4Addr -- addr to recv IP6 address

    pString -- unicode IP4 string

Return Value:

    TRUE if successful conversion.
    FALSE on bad string.

--*/
{
    IP4_ADDRESS ip;

    //  if inet_addr() returns error, verify then error out

    ip = inet_addr( pString );

    if ( ip == INADDR_BROADCAST &&
        strcmp( pString, "255.255.255.255" ) != 0 )
    {
        return( FALSE );
    }

    *pIp4Addr = ip;

    return( TRUE );
}



BOOL
Dns_Ip4StringToAddressEx_A(
    OUT     PIP4_ADDRESS    pIp4Addr,
    IN      PCSTR           pchString,
    IN      DWORD           dwStringLength
    )
/*++

Routine Description:

    Build IP4 address from narrow string.

    This version handles non-NULL terminated strings

Arguments:

    pIp4Addr -- addr to recv IP6 address

    pString -- unicode IP4 string

    dwStringLength -- string length; 0 if NULL terminated

Return Value:

    TRUE if successful conversion.
    FALSE on bad string.

--*/
{
    CHAR        tempBuf[ IP4_ADDRESS_STRING_BUFFER_LENGTH ];
    PCSTR       pstring;
    
    DNSDBG( PARSE2, (
        "Dns_Ip4StringToAddressEx_A( %.*s )\n"
        "\tpchString = %p\n",
        dwStringLength,
        pchString,
        pchString ));

    //
    //  copy string if given length
    //  if no length assume NULL terminated
    //

    pstring = pchString;

    if ( dwStringLength )
    {
        DWORD   bufLength = IP4_ADDRESS_STRING_BUFFER_LENGTH;

        if ( ! Dns_StringCopy(
                    tempBuf,
                    & bufLength,
                    (PCHAR) pstring,
                    dwStringLength,
                    DnsCharSetAnsi,
                    DnsCharSetAnsi ) )
        {
            return( FALSE );
        }
        pstring = tempBuf;
    }

    return  Dns_Ip4StringToAddress_A(
                pIp4Addr,
                pstring );
}



BOOL
Dns_Ip4StringToAddress_W(
    OUT     PIP4_ADDRESS    pIp4Addr,
    IN      PCWSTR          pwString
    )
/*++

Routine Description:

    Build IP4 address from wide string.

Arguments:

    pIp4Addr -- addr to recv IP6 address

    pwString -- unicode IP6 string

Return Value:

    TRUE if successful conversion.
    FALSE on bad string.

--*/
{
    CHAR        bufAddr[ IP4_ADDRESS_STRING_BUFFER_LENGTH ];
    DWORD       bufLength = IP4_ADDRESS_STRING_BUFFER_LENGTH;

    //  convert to narrow string
    //      - UTF8 quicker and just fine for numeric

    if ( ! Dns_StringCopy(
                bufAddr,
                & bufLength,
                (PCHAR) pwString,
                0,          // length unknown
                DnsCharSetUnicode,
                DnsCharSetUtf8
                ) )
    {
        return( FALSE );
    }

    return  Dns_Ip4StringToAddress_A(
                pIp4Addr,
                bufAddr );
}



//
//  Combined IP4/IP6 string-to-address
//

BOOL
Dns_StringToAddress_W(
    OUT     PCHAR           pAddrBuf,
    IN OUT  PDWORD          pBufLength,
    IN      PCWSTR          pString,
    IN OUT  PDWORD          pAddrFamily
    )
/*++

Routine Description:

    Build address (IP4 or IP6) from address string.

Arguments:

    pAddrBuf -- buffer to receive address

    pBufLength -- ptr to address length
        input   - length of buffer
        output  - length of address found

    pString -- address string

    pAddrFamily -- ptr to address family
        input   - zero for any family or particular family to check
        output  - family found;  zero if no conversion

Return Value:

    TRUE if successful.
    FALSE on error.  GetLastError() for status.

--*/
{
    return  Dns_StringToAddressEx(
                pAddrBuf,
                pBufLength,
                (PCSTR) pString,
                pAddrFamily,
                TRUE,       // unicode
                FALSE       // forward
                );
}

BOOL
Dns_StringToAddress_A(
    OUT     PCHAR           pAddrBuf,
    IN OUT  PDWORD          pBufLength,
    IN      PCSTR           pString,
    IN OUT  PDWORD          pAddrFamily
    )
{
    return  Dns_StringToAddressEx(
                pAddrBuf,
                pBufLength,
                pString,
                pAddrFamily,
                FALSE,      // ANSI
                FALSE       // forward
                );
}



//
//  Address to string
//

PWCHAR
Dns_Ip6AddressToString_W(
    OUT     PWCHAR          pwString,
    IN      PIP6_ADDRESS    pIp6Addr
    )
/*++

Routine Description:

    Convert IP6 address to string format.

Arguments:

    pwString -- buffer to hold string;  MUST be at least
        IPV6_ADDRESS_STRING_LENGTH+1 in length

    pAddress -- IP6 address to convert to string

Return Value:

    Ptr to next location in buffer (the terminating NULL).

--*/
{
    //  DCR:  could be macro

    return  RtlIpv6AddressToStringW(
                (PIN6_ADDR) pIp6Addr,
                pwString );
}



PCHAR
Dns_Ip6AddressToString_A(
    OUT     PCHAR           pchString,
    IN      PIP6_ADDRESS    pIp6Addr
    )
/*++

Routine Description:

    Convert IP6 address to string format.

Arguments:

    pchString -- buffer to hold string;  MUST be at least
        IPV6_ADDRESS_STRING_LENGTH+1 in length

    pAddress -- IP6 address to convert to string

Return Value:

    Ptr to next location in buffer (the terminating NULL).

--*/
{
    //  DCR:  could be macro

    return  RtlIpv6AddressToStringA(
                (PIN6_ADDR) pIp6Addr,
                pchString );
}



//
//  Address to string -- IP4
//

PWCHAR
Dns_Ip4AddressToString_W(
    OUT     PWCHAR          pwString,
    IN      PIP4_ADDRESS    pIp4Addr
    )
/*++

Routine Description:

    Convert IP4 address to string format.

Arguments:

    pwString -- buffer to hold string;  MUST be at least
        IPV6_ADDRESS_STRING_LENGTH+1 in length

    pAddress -- IP4 address to convert to string

Return Value:

    Ptr to next location in buffer (the terminating NULL).

--*/
{
    IP4_ADDRESS ip = *pIp4Addr;

    //
    //  convert IP4 address to string
    //      - address is in net order, lead byte in low memory
    //

    pwString += wsprintfW(
                    pwString,
                    L"%u.%u.%u.%u",
                    (UCHAR) (ip & 0x000000ff),
                    (UCHAR) ((ip & 0x0000ff00) >> 8),
                    (UCHAR) ((ip & 0x00ff0000) >> 16),
                    (UCHAR) ((ip & 0xff000000) >> 24)
                    );

    return( pwString );
}



PCHAR
Dns_Ip4AddressToString_A(
    OUT     PCHAR           pString,
    IN      PIP4_ADDRESS    pIp4Addr
    )
/*++

Routine Description:

    Convert IP4 address to string format.

Arguments:

    pchString -- buffer to hold string;  MUST be at least
        IPV6_ADDRESS_STRING_LENGTH+1 in length

    pAddress -- IP4 address to convert to string

Return Value:

    Ptr to next location in buffer (the terminating NULL).

--*/
{
    IP4_ADDRESS ip = *pIp4Addr;

    //
    //  convert IP4 address to string
    //      - address is in net order, lead byte in low memory
    //

    pString += sprintf(
                    pString,
                    "%u.%u.%u.%u",
                    (UCHAR) (ip & 0x000000ff),
                    (UCHAR) ((ip & 0x0000ff00) >> 8),
                    (UCHAR) ((ip & 0x00ff0000) >> 16),
                    (UCHAR) ((ip & 0xff000000) >> 24)
                    );

    return( pString );
}



//
//  Address-to-string -- combined IP4/6
//

PCHAR
Dns_AddressToString_A(
    OUT     PCHAR           pchString,
    IN OUT  PDWORD          pStringLength,
    IN      PBYTE           pAddr,
    IN      DWORD           AddrLength,
    IN      DWORD           AddrFamily
    )
/*++

Routine Description:

    Convert address to string format.

Arguments:

    pchString -- buffer to hold string;  MUST be at least
        IPV6_ADDRESS_STRING_LENGTH+1 in length

    pStringLength -- string buffer length

    pAddr -- ptr to address

    AddrLength -- address length

    AddrFamily -- address family (AF_INET, AF_INET6)

Return Value:

    Ptr to next location in buffer (the terminating NULL).
    NULL if no conversion.

--*/
{
    DWORD   length = *pStringLength;

    //  dispatch to conversion routine for this type

    if ( AddrFamily == AF_INET )
    {
        if ( length < IP_ADDRESS_STRING_LENGTH+1 )
        {
            length = IP_ADDRESS_STRING_LENGTH+1;
            goto Failed;
        }
        return  Dns_Ip4AddressToString_A(
                    pchString,
                    (PIP4_ADDRESS) pAddr );
    }

    if ( AddrFamily == AF_INET6 )
    {
        if ( length < IP6_ADDRESS_STRING_LENGTH+1 )
        {
            length = IP6_ADDRESS_STRING_LENGTH+1;
            goto Failed;
        }
        return  Dns_Ip6AddressToString_A(
                    pchString,
                    (PIP6_ADDRESS) pAddr );
    }

Failed:

    *pStringLength = length;

    return  NULL;
}



//
//  Reverse lookup address-to-name IP4
//

PCHAR
Dns_Ip4AddressToReverseName_A(
    OUT     PCHAR           pBuffer,
    IN      IP_ADDRESS      IpAddress
    )
/*++

Routine Description:

    Write reverse lookup name, given corresponding IP

Arguments:

    pBuffer -- ptr to buffer for reverse lookup name;
        MUST contain at least DNS_MAX_REVERSE_NAME_BUFFER_LENGTH bytes

    IpAddress -- IP address to create

Return Value:

    Ptr to next location in buffer.

--*/
{
    DNSDBG( TRACE, ( "Dns_Ip4AddressToReverseName_A()\n" ));

    //
    //  write digits for each octect in IP address
    //      - note, it is in net order so lowest octect, is in highest memory
    //

    pBuffer += sprintf(
                    pBuffer,
                    "%u.%u.%u.%u.in-addr.arpa.",
                    (UCHAR) ((IpAddress & 0xff000000) >> 24),
                    (UCHAR) ((IpAddress & 0x00ff0000) >> 16),
                    (UCHAR) ((IpAddress & 0x0000ff00) >> 8),
                    (UCHAR) (IpAddress & 0x000000ff) );

    return( pBuffer );
}



PWCHAR
Dns_Ip4AddressToReverseName_W(
    OUT     PWCHAR          pBuffer,
    IN      IP_ADDRESS      IpAddress
    )
/*++

Routine Description:

    Write reverse lookup name, given corresponding IP

Arguments:

    pBuffer -- ptr to buffer for reverse lookup name;
        MUST contain at least DNS_MAX_REVERSE_NAME_BUFFER_LENGTH wide chars

    IpAddress -- IP address to create

Return Value:

    Ptr to next location in buffer.

--*/
{
    DNSDBG( TRACE, ( "Dns_Ip4AddressToReverseName_W()\n" ));

    //
    //  write digits for each octect in IP address
    //      - note, it is in net order so lowest octect, is in highest memory
    //

    pBuffer += wsprintfW(
                    pBuffer,
                    L"%u.%u.%u.%u.in-addr.arpa.",
                    (UCHAR) ((IpAddress & 0xff000000) >> 24),
                    (UCHAR) ((IpAddress & 0x00ff0000) >> 16),
                    (UCHAR) ((IpAddress & 0x0000ff00) >> 8),
                    (UCHAR) (IpAddress & 0x000000ff) );

    return( pBuffer );
}



PCHAR
Dns_Ip4AddressToReverseNameAlloc_A(
    IN      IP_ADDRESS      IpAddress
    )
/*++

Routine Description:

    Create reverse lookup name string, given corresponding IP.

    Caller must free the string.

Arguments:

    IpAddress -- IP address to create

Return Value:

    Ptr to new reverse lookup string.

--*/
{
    PCHAR   pch;
    PCHAR   pchend;

    DNSDBG( TRACE, ( "Dns_Ip4AddressToReverseNameAlloc_A()\n" ));

    //
    //  allocate space for string
    //

    pch = ALLOCATE_HEAP( DNS_MAX_REVERSE_NAME_BUFFER_LENGTH );
    if ( !pch )
    {
        return( NULL );
    }

    //
    //  write string for IP
    //

    pchend = Dns_Ip4AddressToReverseName_A( pch, IpAddress );
    if ( !pchend )
    {
        FREE_HEAP( pch );
        return( NULL );
    }

    return( pch );
}



PWCHAR
Dns_Ip4AddressToReverseNameAlloc_W(
    IN      IP_ADDRESS      IpAddress
    )
/*++

Routine Description:

    Create reverse lookup name string, given corresponding IP.

    Caller must free the string.

Arguments:

    IpAddress -- IP address to create

Return Value:

    Ptr to new reverse lookup string.

--*/
{
    PWCHAR   pch;
    PWCHAR   pchend;

    DNSDBG( TRACE, ( "Dns_Ip4AddressToReverseNameAlloc_W()\n" ));

    //
    //  allocate space for string
    //

    pch = ALLOCATE_HEAP( DNS_MAX_REVERSE_NAME_BUFFER_LENGTH * sizeof(WCHAR) );
    if ( !pch )
    {
        return( NULL );
    }

    //
    //  write string for IP
    //

    pchend = Dns_Ip4AddressToReverseName_W( pch, IpAddress );
    if ( !pchend )
    {
        FREE_HEAP( pch );
        return( NULL );
    }

    return( pch );
}



//
//  Reverse lookup address-to-name -- IP6
//

PCHAR
Dns_Ip6AddressToReverseName_A(
    OUT     PCHAR           pBuffer,
    IN      IP6_ADDRESS     Ip6Addr
    )
/*++

Routine Description:

    Write reverse lookup name, given corresponding IP6 address

Arguments:

    pBuffer -- ptr to buffer for reverse lookup name;
        MUST contain at least DNS_MAX_IP6_REVERSE_NAME_BUFFER_LENGTH bytes

    Ip6Addr -- IP6 address to create reverse string for

Return Value:

    Ptr to next location in buffer.

--*/
{
    DWORD   i;

    DNSDBG( TRACE, ( "Dns_Ip6AddressToReverseName_A()\n" ));

    //
    //  write digit for each nibble in IP6 address
    //
    //  note we are reversing net order here
    //      since address is in net order and we are filling
    //      in least to most significant order
    //      - go DOWN through DWORDS
    //      - go DOWN through the BYTES
    //      - but we must put the lowest (least significant) nibble
    //          first as our bits are not in "bit net order"
    //          which is sending the highest bit in the byte first
    //

#if 0
    i = 4;

    while ( i-- )
    {
        DWORD thisDword = Ip6Address.IP6Dword[i];

        pBuffer += sprintf(
                        pBuffer,
                        "%u.%u.%u.%u.%u.%u.%u.%u.",
                        (thisDword & 0x0f000000) >> 24,
                        (thisDword & 0xf0000000) >> 28,
                        (thisDword & 0x000f0000) >> 16,
                        (thisDword & 0x00f00000) >> 20,
                        (thisDword & 0x00000f00) >>  8,
                        (thisDword & 0x0000f000) >> 12,
                        (thisDword & 0x0000000f)      ,
                        (thisDword & 0x000000f0) >>  4
                        );
    }
#endif
    i = 16;

    while ( i-- )
    {
        BYTE thisByte = Ip6Addr.IP6Byte[i];

        pBuffer += sprintf(
                        pBuffer,
                        "%x.%x.",
                        (thisByte & 0x0f),
                        (thisByte & 0xf0) >> 4
                        );
    }

    pBuffer += sprintf(
                    pBuffer,
                    "ip6.int." );

    return( pBuffer );
}



PWCHAR
Dns_Ip6AddressToReverseName_W(
    OUT     PWCHAR          pBuffer,
    IN      IP6_ADDRESS     Ip6Addr
    )
/*++

Routine Description:

    Write reverse lookup name, given corresponding IP6 address

Arguments:

    pBuffer -- ptr to buffer for reverse lookup name;
        MUST contain at least DNS_MAX_IP6_REVERSE_NAME_BUFFER_LENGTH wide chars

    Ip6Addr -- IP6 address to create reverse string for

Return Value:

    Ptr to next location in buffer.

--*/
{
    DWORD   i;

    DNSDBG( TRACE, ( "Dns_Ip6AddressToReverseName_W()\n" ));

    //
    //  write digit for each nibble in IP6 address
    //      - in net order so lowest nibble is in highest memory
    //

    i = 16;

    while ( i-- )
    {
        BYTE thisByte = Ip6Addr.IP6Byte[i];

        pBuffer += wsprintfW(
                        pBuffer,
                        L"%x.%x.",
                        (thisByte & 0x0f),
                        (thisByte & 0xf0) >> 4
                        );
    }

    pBuffer += wsprintfW(
                    pBuffer,
                    L"ip6.int." );

    return( pBuffer );
}



PCHAR
Dns_Ip6AddressToReverseNameAlloc_A(
    IN      IP6_ADDRESS     Ip6Addr
    )
/*++

Routine Description:

    Create reverse lookup name given corresponding IP.

    Caller must free the string.

Arguments:

    Ip6Addr -- IP6 address to create reverse name for

Return Value:

    Ptr to new reverse lookup name string.

--*/
{
    PCHAR   pch;
    PCHAR   pchend;

    DNSDBG( TRACE, ( "Dns_Ip6AddressToReverseNameAlloc_A()\n" ));

    //
    //  allocate space for string
    //

    pch = ALLOCATE_HEAP( DNS_MAX_IP6_REVERSE_NAME_BUFFER_LENGTH );
    if ( !pch )
    {
        return( NULL );
    }

    //
    //  write string for IP
    //

    pchend = Dns_Ip6AddressToReverseName_A( pch, Ip6Addr );
    if ( !pchend )
    {
        FREE_HEAP( pch );
        return( NULL );
    }

    return( pch );
}



PWCHAR
Dns_Ip6AddressToReverseNameAlloc_W(
    IN      IP6_ADDRESS     Ip6Addr
    )
/*++

Routine Description:

    Create reverse lookup name given corresponding IP.

    Caller must free the string.

Arguments:

    Ip6Addr -- IP6 address to create reverse name for

Return Value:

    Ptr to new reverse lookup name string.

--*/
{
    PWCHAR  pch;
    PWCHAR  pchend;

    DNSDBG( TRACE, ( "Dns_Ip6AddressToReverseNameAlloc_W()\n" ));

    //
    //  allocate space for string
    //

    pch = (PWCHAR) ALLOCATE_HEAP(
                    DNS_MAX_IP6_REVERSE_NAME_BUFFER_LENGTH * sizeof(WCHAR) );
    if ( !pch )
    {
        return( NULL );
    }

    //
    //  write string for IP
    //

    pchend = Dns_Ip6AddressToReverseName_W( pch, Ip6Addr );
    if ( !pchend )
    {
        FREE_HEAP( pch );
        return( NULL );
    }

    return( pch );
}



//
//  Reverse name-to-address -- IP4
//

BOOL
Dns_Ip4ReverseNameToAddress_A(
    OUT     PIP4_ADDRESS    pIp4Addr,
    IN      PCSTR           pszName
    )
/*++

Routine Description:

    Get IP for reverse lookup name.

Arguments:

    pIp4Addr -- addr to receive IP address if found

    pszName -- name to lookup

Return Value:

    TRUE -- if reverse lookup name converted to IP
    FALSE -- if not IP4 reverse lookup name

--*/
{
#define SIZE_IP4REV  (sizeof(".in-addr.arpa")-1)

    CHAR        nameBuffer[ DNS_MAX_IP4_REVERSE_NAME_BUFFER_LENGTH+1 ];
    DWORD       nameLength;
    IP_ADDRESS  ip;
    PCHAR       pch;
    DWORD       i;
    DWORD       byte;

    DNSDBG( TRACE, (
        "Dns_Ip4ReverseNameToAddress_A( %s )\n",
        pszName ));

    //
    //  validate name
    //  fail if
    //      - too long
    //      - too short
    //      - not in in-addr.arpa domain
    //

    nameLength = strlen( pszName );

    if ( nameLength > DNS_MAX_IP4_REVERSE_NAME_BUFFER_LENGTH )
    {
        return( FALSE );
    }
    if ( pszName[nameLength-1] == '.' )
    {
        nameLength--;
    }
    if ( nameLength <= SIZE_IP4REV )
    {
        return( FALSE );
    }
    nameLength -= SIZE_IP4REV;

    if ( _strnicmp( ".in-addr.arpa", &pszName[nameLength], SIZE_IP4REV ) != 0 )
    {
        return( FALSE );
    }

    //
    //  copy reverse dotted decimal piece of name
    //

    RtlCopyMemory(
        nameBuffer,
        pszName,
        nameLength );

    nameBuffer[nameLength] = 0;

    //
    //  read digits
    //

    ip = 0;
    i = 0;

    pch = nameBuffer + nameLength;

    while ( 1 )
    {
        --pch;

        if ( *pch == '.' )
        {
            *pch = 0;
            pch++;
        }
        else if ( pch == nameBuffer )
        {
        }
        else
        {
            continue;
        }

        //  convert byte

        byte = strtoul( pch, NULL, 10 );
        if ( byte > 255 )
        {
            return( FALSE );
        }
        if ( i > 3 )
        {
            return( FALSE );
        }
        ip |= byte << (8*i);

        //  terminate at string beginning
        //  or continue back up string

        if ( pch == nameBuffer )
        {
            break;
        }
        i++;
        pch--;
    }

    *pIp4Addr = ip;

    DNSDBG( TRACE, (
        "Success on Dns_Ip4ReverseNameToAddress_A( %s ) => %s\n",
        pszName,
        IP_STRING(ip) ));

    return( TRUE );
}



BOOL
Dns_Ip4ReverseNameToAddress_W(
    OUT     PIP4_ADDRESS    pIp4Addr,
    IN      PCWSTR          pwsName
    )
/*++

Routine Description:

    Get IP for reverse lookup name.

Arguments:

    pIp4Addr -- addr to receive IP address if found

    pszName -- name to lookup

Return Value:

    TRUE -- if reverse lookup name converted to IP
    FALSE -- if not IP4 reverse lookup name

--*/
{
    CHAR        nameBuffer[ DNS_MAX_IP4_REVERSE_NAME_BUFFER_LENGTH+1 ];
    DWORD       bufLength;
    DWORD       nameLengthUtf8;


    DNSDBG( TRACE, (
        "Dns_Ip4ReverseNameToAddress_W( %S )\n",
        pwsName ));

    //
    //  convert to UTF8
    //      - use UTF8 since conversion to it is trivial and it
    //      is identical to ANSI for all reverse lookup names
    //

    bufLength = DNS_MAX_IP4_REVERSE_NAME_BUFFER_LENGTH + 1;

    nameLengthUtf8 = Dns_StringCopy(
                        nameBuffer,
                        & bufLength,
                        (PCHAR) pwsName,
                        0,          // NULL terminated
                        DnsCharSetUnicode,
                        DnsCharSetUtf8 );
    if ( nameLengthUtf8 == 0 )
    {
        return  FALSE;
    }

    //
    //  call ANSI routine to do conversion
    //

    return  Dns_Ip4ReverseNameToAddress_A(
                pIp4Addr,
                (PCSTR) nameBuffer );
}



//
//  Reverse name-to-address -- IP6
//

BOOL
Dns_Ip6ReverseNameToAddress_A(
    OUT     PIP6_ADDRESS    pIp6Addr,
    IN      PCSTR           pszName
    )
/*++

Routine Description:

    Get IP6 address for reverse lookup name.

Arguments:

    pIp6Addr -- addr to receive IP address if found

    pszName -- name to lookup

Return Value:

    TRUE -- if reverse lookup name converted to IP
    FALSE -- if not IP4 reverse lookup name

--*/
{
#define SIZE_IP6REV  (sizeof(".ip6.int")-1)

    CHAR            nameBuffer[ DNS_MAX_IP6_REVERSE_NAME_BUFFER_LENGTH+1 ];
    DWORD           nameLength;
    PCHAR           pch;
    BYTE            byteArray[16];
    DWORD           byteCount;
    DWORD           nibble;
    DWORD           highNibble;
    BOOL            fisLow;

    DNSDBG( TRACE, ( "Dns_Ip6ReverseNameToAddress_A()\n" ));

    //
    //  validate name
    //  fail if
    //      - too long
    //      - too short
    //      - not in in6.int domain
    //

    nameLength = strlen( pszName );

    if ( nameLength > DNS_MAX_IP6_REVERSE_NAME_BUFFER_LENGTH )
    {
        return( FALSE );
    }
    if ( pszName[nameLength-1] == '.' )
    {
        nameLength--;
    }
    if ( nameLength <= SIZE_IP6REV )
    {
        return( FALSE );
    }
    nameLength -= SIZE_IP6REV;

    if ( _strnicmp( ".ip6.int", &pszName[nameLength], SIZE_IP6REV ) != 0 )
    {
        return( FALSE );
    }

    //
    //  copy name
    //

    RtlCopyMemory(
        nameBuffer,
        pszName,
        nameLength );

    nameBuffer[nameLength] = 0;

    //
    //  clear IP6 address
    //      - need for partial reverse lookup name
    //

    RtlZeroMemory(
        byteArray,
        sizeof(byteArray) );

    //
    //  read digits
    //

    byteCount = 0;
    fisLow = FALSE;

    pch = nameBuffer + nameLength;

    while ( 1 )
    {
        if ( byteCount > 15 )
        {
            return( FALSE );
        }

        --pch;

        if ( *pch == '.' )
        {
            *pch = 0;
            pch++;
        }
        else if ( pch == nameBuffer )
        {
        }
        else
        {
            //  DCR:   multi-digit nibbles in reverse name -- error?
            continue;
        }

        //  convert nibble
        //      - zero test special as
        //      A) faster
        //      B) strtoul() uses for error case

        if ( *pch == '0' )
        {
            nibble = 0;
        }
        else
        {
            nibble = strtoul( pch, NULL, 16 );
            if ( nibble == 0 || nibble > 15 )
            {
                return( FALSE );
            }
        }

        //  save high nibble
        //  on low nibble, write byte to IP6 address

        if ( !fisLow )
        {
            highNibble = nibble;
            fisLow = TRUE;
        }
        else
        {
            //byteArray[byteCount++] = (BYTE) (lowNibble | (nibble << 4));

            pIp6Addr->IP6Byte[byteCount++] = (BYTE) ( (highNibble<<4) | nibble );
            fisLow = FALSE;
        }

        //  terminate at string beginning
        //  or continue back up string

        if ( pch == nameBuffer )
        {
            break;
        }
        pch--;
    }

    //*pIp6Addr = *(PIP6_ADDRESS) byteArray;

    DNSDBG( TRACE, (
        "Success on Dns_Ip6ReverseNameToAddress_A( %s )\n",
        pszName ));

    return( TRUE );
}



BOOL
Dns_Ip6ReverseNameToAddress_W(
    OUT     PIP6_ADDRESS    pIp6Addr,
    IN      PCWSTR          pwsName
    )
/*++

Routine Description:

    Get IP for reverse lookup name.

Arguments:

    pIp6Addr -- addr to receive IP address if found

    pszName -- name to lookup

Return Value:

    TRUE -- if reverse lookup name converted to IP
    FALSE -- if not IP6 reverse lookup name

--*/
{
    CHAR        nameBuffer[ DNS_MAX_IP6_REVERSE_NAME_BUFFER_LENGTH+1 ];
    DWORD       bufLength;
    DWORD       nameLengthUtf8;


    DNSDBG( TRACE, (
        "Dns_Ip6ReverseNameToAddress_W( %S )\n",
        pwsName ));

    //
    //  convert to UTF8
    //      - use UTF8 since conversion to it is trivial and it
    //      is identical to ANSI for all reverse lookup names
    //

    bufLength = DNS_MAX_IP6_REVERSE_NAME_BUFFER_LENGTH + 1;

    nameLengthUtf8 = Dns_StringCopy(
                        nameBuffer,
                        & bufLength,
                        (PCHAR) pwsName,
                        0,          // NULL terminated
                        DnsCharSetUnicode,
                        DnsCharSetUtf8 );
    if ( nameLengthUtf8 == 0 )
    {
        return  FALSE;
    }

    //
    //  call ANSI routine to do conversion
    //

    return  Dns_Ip6ReverseNameToAddress_A(
                pIp6Addr,
                (PCSTR) nameBuffer );
}



//
//  Combined IP4/IP6 reverse-name-to-address
//

BOOL
Dns_ReverseNameToAddress_W(
    OUT     PCHAR           pAddrBuf,
    IN OUT  PDWORD          pBufLength,
    IN      PCWSTR          pString,
    IN OUT  PDWORD          pAddrFamily
    )
/*++

Routine Description:

    Build address (IP4 or IP6) from reverse lookup name.

Arguments:

    pAddrBuf -- buffer to receive address

    pBufLength -- ptr to address length
        input   - length of buffer
        output  - length of address found

    pString -- address string

    pAddrFamily -- ptr to address family
        input   - zero for any family or particular family to check
        output  - family found;  zero if no conversion

Return Value:

    TRUE if successful.
    FALSE on error.  GetLastError() for status.

--*/
{
    return  Dns_StringToAddressEx(
                pAddrBuf,
                pBufLength,
                (PCSTR) pString,
                pAddrFamily,
                TRUE,       // unicode
                TRUE        // reverse
                );
}

BOOL
Dns_ReverseNameToAddress_A(
    OUT     PCHAR           pAddrBuf,
    IN OUT  PDWORD          pBufLength,
    IN      PCSTR           pString,
    IN OUT  PDWORD          pAddrFamily
    )
{
    return  Dns_StringToAddressEx(
                pAddrBuf,
                pBufLength,
                pString,
                pAddrFamily,
                FALSE,      // ANSI
                TRUE        // reverse
                );
}




//
//  Combined string-to-address private workhorse
//

BOOL
Dns_StringToAddressEx(
    OUT     PCHAR           pAddrBuf,
    IN OUT  PDWORD          pBufLength,
    IN      PCSTR           pString,
    IN OUT  PDWORD          pAddrFamily,
    IN      BOOL            fUnicode,
    IN      BOOL            fReverse
    )
/*++

Routine Description:

    Build address (IP4 or IP6 from string)

    This routine is capable of all string-to-address
    conversions and is the backbone of all the
    combined string-to-address conversion routines.

Arguments:

    pAddrBuf -- buffer to receive address

    pBufLength -- ptr to address length
        input   - length of buffer
        output  - length of address found

    pString -- address string

    pAddrFamily -- ptr to address family
        input   - zero for any family or particular family to check
        output  - family found;  zero if no conversion

    fUnicode -- unicode string

    fReverse -- reverse lookup string

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    DNS_STATUS  status = NO_ERROR;
    DWORD       length = 0;
    INT         family = *pAddrFamily;
    DWORD       bufLength = *pBufLength;
    BOOL        fconvert;
    PCSTR       preverseString;
    CHAR        nameBuffer[ DNS_MAX_REVERSE_NAME_BUFFER_LENGTH+1 ];

    DNSDBG( TRACE, (
        "Dns_StringToAddressEx( %S%s )\n",
        fUnicode ? pString : "",
        fUnicode ? "" : pString ));

    //
    //  convert reverse to ANSI
    //  
    //  reverse lookups are done in ANSI;  convert here to avoid
    //  double string conversion to check both IP4 and IP6
    //

    if ( fReverse )
    {
        preverseString = pString;

        if ( fUnicode )
        {
            DWORD   bufLength = DNS_MAX_REVERSE_NAME_BUFFER_LENGTH;

            if ( ! Dns_StringCopy(
                        nameBuffer,
                        & bufLength,
                        (PCHAR) pString,
                        0,          // NULL terminated
                        DnsCharSetUnicode,
                        DnsCharSetUtf8 ) )
            {
                return  FALSE;
            }
            preverseString = nameBuffer;
        }
    }

    //
    //  check IP4
    //

    if ( family == 0 ||
         family == AF_INET )
    {
        IP4_ADDRESS ip;

        if ( fReverse )
        {
            fconvert = Dns_Ip4ReverseNameToAddress_A(
                            & ip,
                            preverseString );
        }
        else
        {
            if ( fUnicode )
            {
                fconvert = Dns_Ip4StringToAddress_W(
                                & ip,
                                (PCWSTR)pString );
            }
            else
            {
                fconvert = Dns_Ip4StringToAddress_A(
                                & ip,
                                pString );
            }
        }
        if ( fconvert )
        {
            length = sizeof(IP4_ADDRESS);
            family = AF_INET;

            if ( bufLength < length )
            {
                status = ERROR_MORE_DATA;
            }
            else
            {
                * (PIP4_ADDRESS) pAddrBuf = ip;
            }

            DNSDBG( INIT2, (
                "Converted string to IP4 address %s\n",
                IP_STRING(ip) ));
            goto Done;
        }
    }

    //
    //  check IP6
    //

    if ( family == 0 ||
         family == AF_INET6 )
    {
        IP6_ADDRESS ip;

        if ( fReverse )
        {
            fconvert = Dns_Ip6ReverseNameToAddress_A(
                            & ip,
                            preverseString );
        }
        else
        {
            if ( fUnicode )
            {
                fconvert = Dns_Ip6StringToAddress_W(
                                & ip,
                                (PCWSTR)pString );
            }
            else
            {
                fconvert = Dns_Ip6StringToAddress_A(
                                & ip,
                                pString );
            }
        }
        if ( fconvert )
        {
            length = sizeof(IP6_ADDRESS);

            if ( bufLength < length )
            {
                status = ERROR_MORE_DATA;
            }
            else
            {
                family = AF_INET6;
                * (PIP6_ADDRESS) pAddrBuf = ip;
            }

            IF_DNSDBG( INIT2 )
            {
                DnsDbg_Ip6Address(
                    "Converted string to IP6 address: ",
                    (PIP6_ADDRESS) pAddrBuf,
                    "\n" );
            }
            goto Done;
        }
    }

    length = 0;
    family = 0;
    status = DNS_ERROR_INVALID_IP_ADDRESS;

Done:

    if ( status )
    {
        SetLastError( status );
    }

    *pAddrFamily = family;
    *pBufLength = length;

    DNSDBG( TRACE, (
        "Leave Dns_StringToAddressEx()\n"
        "\tstatus   = %d\n"
        "\tptr      = %p\n"
        "\tlength   = %d\n"
        "\tfamily   = %d\n",
        status,
        pAddrBuf,
        length,
        family ));

    return( status==ERROR_SUCCESS );
}


//
//  End straddr.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\test\adpleak.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dnsapi.h>
#include "..\dnslib.h"


VOID
PrintIpAddress (
    IN  DWORD dwIpAddress )
{
    printf( "%d.%d.%d.%d\n",
            ((BYTE *) &dwIpAddress)[0],
            ((BYTE *) &dwIpAddress)[1],
            ((BYTE *) &dwIpAddress)[2],
            ((BYTE *) &dwIpAddress)[3] );
}

VOID
PrintServerInfo (
    IN  DNS_NAME_SERVER_INFO ServerInfo )
{
    printf( "         ipAddress : " );
    PrintIpAddress( ServerInfo.ipAddress );
    printf( "         Priority  : %d\n", ServerInfo.Priority );
    printf( "         Status    : %d\n\n", ServerInfo.Status );
}

VOID
PrintAdapterInfo (
    IN  PDNS_ADAPTER_INFO pAdapterInfo )
{
    DWORD             iter;

    printf( "      pszAdapterDomain : %s\n", pAdapterInfo->pszAdapterDomain );
    printf( "      Status           : 0x%x\n", pAdapterInfo->Status );
    printf( "      ReturnFlags      : 0x%x\n", pAdapterInfo->ReturnFlags );
    printf( "      ipLastSend       : " );
    PrintIpAddress( pAdapterInfo->ipLastSend );
    printf( "      cServerCount     : %d\n", pAdapterInfo->cServerCount );
    printf( "      cTotalListSize   : %d\n\n", pAdapterInfo->cTotalListSize );

    for ( iter = 0; iter < pAdapterInfo->cServerCount; iter++ )
    {
        printf( "      Server Info (%d)\n", iter + 1 );
        printf( "      ___________________\n" );
        PrintServerInfo( pAdapterInfo->aipServers[iter] );
    }

    printf( "\n" );
}

_cdecl
main(int argc, char **argv)
{
    PDNS_NETWORK_INFO pNetworkInfo = NULL;
    DWORD             sysVersion;
    DWORD             iter;

    Dns_InitNetworkInfo();

    sysVersion = GetVersion();

    printf( "System version is : 0x%x\n", sysVersion );

    pNetworkInfo = Dns_GetDnsNetworkInfo( TRUE, TRUE );

    if ( !pNetworkInfo )
    {
        printf( "Dns_GetDnsNetworkInfo call failed\n" );
        return(0);
    }

    printf( "Dns_GetDnsNetworkInfo returned ...\n\n" );
    printf( "   pNetworkInfo->ReturnFlags    : 0x%x\n", pNetworkInfo->ReturnFlags );
    printf( "   pNetworkInfo->pszName        : %s\n", pNetworkInfo->pszName );
    printf( "   pNetworkInfo->cAdapterCount  : %d\n", pNetworkInfo->cAdapterCount );
    printf( "   pNetworkInfo->cTotalListSize : %d\n", pNetworkInfo->cTotalListSize );

    for ( iter = 0; iter < pNetworkInfo->cAdapterCount; iter++ )
    {
        printf( "   Adapter Info (%d)\n", iter + 1 );
        printf( "   ____________________________________\n" );
        PrintAdapterInfo( pNetworkInfo->aAdapterInfoList[iter] );
    }

    system( "pause" );

    for ( iter = 0; iter < 100000; iter++ )
    {
        PDNS_NETWORK_INFO pTempNetworkInfo = pNetworkInfo;

        pNetworkInfo = Dns_CreateNetworkInfoCopy( pTempNetworkInfo );
        Dns_FreeNetworkInfo( pTempNetworkInfo );
    }

    system( "pause" );

    Dns_FreeNetworkInfo( pNetworkInfo );

    system( "pause" );

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\test\rrbld.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dnsapi.h>
#include "..\dnslib.h"

_cdecl
main(int argc, char **argv)
{
    PDNS_RECORD pRRSet1 = NULL;
    PDNS_RECORD pRRSet2 = NULL;

    Dns_StartDebug( DNS_DBG_CONSOLE, NULL, NULL, NULL, 0 );

    pRRSet1 = Dns_RecordBuild_A( NULL,
                                 argv[1],
                                 (WORD) strtoul( argv[2], NULL, 10 ),
                                 0,
                                 0,
                                 argc - 3,
                                 &argv[3] );

    pRRSet2 = Dns_RecordCopyEx( pRRSet1, DnsCharSetUtf8, DnsCharSetUtf8 );

    Dns_RecordCompare( pRRSet1, pRRSet2 );

    DnsDbg_Record( "",
                   pRRSet2 );

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\test\ipleak.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dnsapi.h>
#include "..\dnslib.h"


VOID
PrintIpAddress (
    IN  DWORD dwIpAddress )
{
    printf( "%d.%d.%d.%d\n",
            ((BYTE *) &dwIpAddress)[0],
            ((BYTE *) &dwIpAddress)[1],
            ((BYTE *) &dwIpAddress)[2],
            ((BYTE *) &dwIpAddress)[3] );
}

_cdecl
main(int argc, char **argv)
{
    DWORD            sysVersion;
    DWORD            iter;
    DWORD            Count;
    DNS_ADDRESS_INFO ipInfoArray[256];

    system( "pause" );

    for ( iter = 0; iter < 100000; iter++ )
    {
        Count = Dns_GetIpAddresses( ipInfoArray, 256 );
    }

    system( "pause" );

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\lib\dnslib.c ===
#include "windows.h"
#include "dnsapi.h"

DWORD   check;

VOID
OneDummyFunction(
    VOID
    )
{
    check = 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\test\listadp.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dnsapi.h>
#include "..\dnslib.h"


VOID
PrintIpAddress (
    IN  DWORD dwIpAddress )
{
    printf( "%d.%d.%d.%d\n",
            ((BYTE *) &dwIpAddress)[0],
            ((BYTE *) &dwIpAddress)[1],
            ((BYTE *) &dwIpAddress)[2],
            ((BYTE *) &dwIpAddress)[3] );
}

VOID
PrintSearchList (
    IN PDNS_SEARCH_LIST pSearchList )
{
    DWORD iter;

    printf( "\n   DNS Search List :\n" );

    for ( iter = 0; iter < pSearchList->cNameCount; iter++ )
    {
        printf( "      %s\n", pSearchList->aSearchListNames[iter] );
    }

    printf( "\n" );

    if ( pSearchList->pszDomainOrZoneName )
        printf( "   Primary domain name :\n      %s\n\n",
                pSearchList->pszDomainOrZoneName );
}

VOID
PrintServerInfo (
    IN  DNS_NAME_SERVER_INFO ServerInfo )
{
    printf( "         ipAddress : " );
    PrintIpAddress( ServerInfo.ipAddress );
    printf( "         Priority  : %d\n", ServerInfo.Priority );
    printf( "         Status    : %d\n\n", ServerInfo.Status );
}

VOID
PrintAdapterInfo (
    IN  PDNS_ADAPTER_INFO pAdapter )
{
    DWORD             iter;

    printf( "      %s\n", pAdapter->pszAdapterGuidName );
    printf( "   ----------------------------------------------------\n" );
    printf( "      pszAdapterDomain       : %s\n", pAdapter->pszAdapterDomain );
    if ( pAdapter->pAdapterIPAddresses )
    {
        PIP_ARRAY pIp = pAdapter->pAdapterIPAddresses;

        printf( "      Adapter Ip Address(es) :\n" );
        for ( iter = 0; iter < pIp->cAddrCount; iter++ )
        {
            printf( "                               (%d) \t", iter+1 );
            PrintIpAddress( pIp->aipAddrs[iter] );
        }
    }

    if ( pAdapter->pAdapterIPSubnetMasks )
    {
        PIP_ARRAY pMask = pAdapter->pAdapterIPSubnetMasks;

        printf( "      Adapter Ip Subnet Mask(s) :\n" );
        for ( iter = 0; iter < pMask->cAddrCount; iter++ )
        {
            printf( "                               (%d) \t", iter+1 );
            PrintIpAddress( pMask->aipAddrs[iter] );
        }
    }

    printf( "      Status                 : 0x%x\n", pAdapter->Status );
    printf( "      InfoFlags              : 0x%x\n", pAdapter->InfoFlags );
    printf( "      ReturnFlags            : 0x%x\n", pAdapter->ReturnFlags );
    printf( "      ipLastSend             : " );
    PrintIpAddress( pAdapter->ipLastSend );
    printf( "      cServerCount           : %d\n", pAdapter->cServerCount );
    printf( "      cTotalListSize         : %d\n\n", pAdapter->cTotalListSize );

    for ( iter = 0; iter < pAdapter->cServerCount; iter++ )
    {
        printf( "      ------------------------\n" );
        printf( "        DNS Server Info (%d)\n", iter + 1 );
        printf( "      ------------------------\n" );
        PrintServerInfo( pAdapter->aipServers[iter] );
    }

    printf( "\n" );
}

_cdecl
main(int argc, char **argv)
{
    PDNS_NETWORK_INFO pNetworkInfo = NULL;
    DWORD             sysVersion;
    DWORD             iter;

    DnsStartDebug( 0,
                   "listadp.flag",
                   NULL,
                   NULL,
                   0 );

    Dns_InitNetworkInfo();

    sysVersion = GetVersion();

    printf( "System version is : 0x%x\n", sysVersion );

    pNetworkInfo = Dns_GetDnsNetworkInfo( TRUE, TRUE );

    if ( !pNetworkInfo )
    {
        printf( "Dns_GetDnsNetworkInfo call failed\n" );
        return(0);
    }

    printf( "Dns_GetDnsNetworkInfo returned ...\n\n" );
    printf( "   pNetworkInfo->ReturnFlags    : 0x%x\n", pNetworkInfo->ReturnFlags );
    printf( "   pNetworkInfo->pszName        : %s\n", pNetworkInfo->pszName );

    if ( pNetworkInfo->pSearchList )
        PrintSearchList( pNetworkInfo->pSearchList );

    printf( "   pNetworkInfo->cAdapterCount  : %d\n", pNetworkInfo->cAdapterCount );
    printf( "   pNetworkInfo->cTotalListSize : %d\n\n\n", pNetworkInfo->cTotalListSize );

    for ( iter = 0; iter < pNetworkInfo->cAdapterCount; iter++ )
    {
        printf( "   ----------------------------------------------------\n" );
        printf( "   Adapter Info (%d)\n\n", iter + 1 );
        PrintAdapterInfo( pNetworkInfo->aAdapterInfoList[iter] );
    }


    Dns_FreeNetworkInfo( pNetworkInfo );

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\resolver\client\dnsrslvr_c_stub.c ===
#include "dnsrslvr_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnslib\test\listip.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dnsapi.h>
#include "..\dnslib.h"

BOOL DisplaySystemVersion();

VOID
PrintIpAddress (
    IN  DWORD dwIpAddress )
{
    printf( " %d.%d.%d.%d\n",
            ((BYTE *) &dwIpAddress)[0],
            ((BYTE *) &dwIpAddress)[1],
            ((BYTE *) &dwIpAddress)[2],
            ((BYTE *) &dwIpAddress)[3] );
}

VOID
PrintAddressInfo (
    IN  DNS_ADDRESS_INFO AddressInfo )
{
    printf( " ipAddress  : " );
    PrintIpAddress( AddressInfo.ipAddress );
    printf( "      subnetMask : " );
    PrintIpAddress( AddressInfo.subnetMask );
    printf( "\n" );
}

_cdecl
main(int argc, char **argv)
{
    DNS_ADDRESS_INFO AddressInfoList[256];
    DWORD            Count;
    DWORD            sysVersion;
    DWORD            iter;
    PIP_ARRAY        pIp = NULL;

    DisplaySystemVersion();

    DnsStartDebug( 0,
                   "listadp.flag",
                   NULL,
                   NULL,
                   0 );

    Dns_InitNetworkInfo();

    sysVersion = GetVersion();

    printf( "System version is : 0x%x\n", sysVersion );

    printf( "\n   Calling Dns_GetLocalIpAddressArray . . . \n" );
    pIp = Dns_GetLocalIpAddressArray();

    for ( iter = 0; iter < pIp->cAddrCount; iter++ )
    {
        printf( "(%d)  ", iter+1 );
        PrintIpAddress( pIp->aipAddrs[iter] );
    }

    printf( "\n   Calling Dns_GetIpAddresses . . . \n" );
    Count = Dns_GetIpAddresses( AddressInfoList, 256 );

    if ( !Count )
    {
        printf( "\n   Dns_GetIpAddresses call failed\n" );
        return(0);
    }

    for ( iter = 0; iter < Count; iter++ )
    {
        printf( "(%d)  ", iter+1 );
        PrintAddressInfo( AddressInfoList[iter] );
    }

    return(0);
}


BOOL DisplaySystemVersion()
{
    OSVERSIONINFOEX osvi;
    BOOL bOsVersionInfoEx;

    // Try calling GetVersionEx using the OSVERSIONINFOEX structure,
    // which is supported on Windows 2000.
    //
    // If that fails, try using the OSVERSIONINFO structure.

    ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

    if( !(bOsVersionInfoEx = GetVersionEx ((OSVERSIONINFO *) &osvi)) )
    {
        // If OSVERSIONINFOEX doesn't work, try OSVERSIONINFO.

        osvi.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
        if (! GetVersionEx ( (OSVERSIONINFO *) &osvi) ) 
        { 
            printf( "GetVersionEx function call failed, might be Win9x?\n" );
            return FALSE;
        }
    }

    switch (osvi.dwPlatformId)
    {
       case VER_PLATFORM_WIN32_NT:

       // Test for the product.

          if ( osvi.dwMajorVersion <= 4 )
             printf( "Microsoft Windows NT ");

          if ( osvi.dwMajorVersion == 5 )
             printf ("Microsoft Windows 2000 ");

          if ( osvi.dwMajorVersion > 5 )
             printf ("Microsoft Windows (9x?) ");

       // Test for workstation versus server.

          if( bOsVersionInfoEx )
          {
             printf( "psvi.wPtroductType: %x\n", osvi.wProductType );
             if ( osvi.wProductType == VER_NT_WORKSTATION )
                printf ( "Professional " );

             if ( osvi.wProductType == VER_NT_SERVER )
                printf ( "Server " );

             if ( osvi.wProductType == VER_NT_DOMAIN_CONTROLLER )
                printf ( "Domain Controller " );
          }
          else
          {
             HKEY hKey;
             char szProductType[80];
             DWORD dwBufLen;

             RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                "SYSTEM\\CurrentControlSet\\Control\\ProductOptions",
                0, KEY_QUERY_VALUE, &hKey );
             RegQueryValueEx( hKey, "ProductType", NULL, NULL,
                (LPBYTE) szProductType, &dwBufLen);
             RegCloseKey( hKey );
             if ( lstrcmpi( "WINNT", szProductType) == 0 )
                printf( "Workstation " );
             if ( lstrcmpi( "SERVERNT", szProductType) == 0 )
                printf( "Server " );
          }

       // Display version, service pack (if any), and build number.

          printf ("version %d.%d %s (Build %d)\n",
             osvi.dwMajorVersion,
             osvi.dwMinorVersion,
             osvi.szCSDVersion,
             osvi.dwBuildNumber & 0xFFFF);

          break;

       case VER_PLATFORM_WIN32_WINDOWS:

          if ((osvi.dwMajorVersion > 4) || 
             ((osvi.dwMajorVersion == 4) && (osvi.dwMinorVersion > 0)))
          {
              printf ("Microsoft Windows 98 ");
          } 
          else printf ("Microsoft Windows 95 ");

          break;

       case VER_PLATFORM_WIN32s:

          printf ("Microsoft Win32s ");
          break;
    }
    return TRUE; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\resolver\client\bind.c ===
/*++

Copyright (c) 2001-2001 Microsoft Corporation

Module Name:

    bind.c

Abstract:

    Domain Name System (DNS) Resolver

    Client RPC bind\unbind routines.
    MIDL memory allocation routines.

Author:

    Jim Gilroy      (jamesg)    April 2001

Revision History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <dnsrslvr.h>
#include "..\..\dnslib\local.h"     // for memory routines


//
//  Bind to remote machine
//
//  Note, there's one obvious problem with binding to a remote
//  resolver -- you have to finding the machine and this is
//  the resolver that finds the machine!!!
//
//  That pretty much suggests this would have to be TCPIP only
//  situation where you specify an IP address which would be
//  resolved in process before RPC'ing to the resolver -- otherwise
//  you're in an infinite loop.
//  Note, that doesn't mean the RPC protocol couldn't be named
//  pipes, only that the string sent in would have to be a TCPIP
//  string, so no name resolution had to take place.
//

LPWSTR  NetworkAddress = NULL;


handle_t
DNS_RPC_HANDLE_bind(
    IN      DNS_RPC_HANDLE      Reserved
    )

/*++

Routine Description:

    This routine is called from the Workstation service client stubs when
    it is necessary create an RPC binding to the server end with
    identification level of impersonation.

Arguments:

    Reserved - RPC string handle;  will be NULL unless allow remote
        access to network name

Return Value:

    The binding handle is returned to the stub routine.  If the bind is
    unsuccessful, a NULL will be returned.

--*/
{
    LPWSTR      binding = NULL;
    handle_t    bindHandle = NULL;
    RPC_STATUS  status = RPC_S_INVALID_NET_ADDR;

    //
    //  default is LPC binding
    //

    if ( !Reserved )
    {
        status = RpcStringBindingComposeW(
                        0,
                        L"ncalrpc",
                        NULL,
                        RESOLVER_RPC_LPC_ENDPOINT_W,
                        NULL,   // no security
                        //L"Security=Impersonation Dynamic False",
                        //L"Security=Impersonation Static True",
                        &binding );
    }

    //  LPC fails -- try named pipe

    if ( status != NO_ERROR )
    {
        DNSDBG( ANY, ( "Binding using named pipes\n" ));

        status = RpcStringBindingComposeW(
                        0,
                        L"ncacn_np",
                        (LPWSTR) NetworkAddress,
                        RESOLVER_RPC_PIPE_NAME_W,
                        NULL,   // no security
                        //L"Security=Impersonation Dynamic False",
                        //L"Security=Impersonation Static True",
                        &binding );
    }

    if ( status != RPC_S_OK )
    {
        return NULL;
    }

    status = RpcBindingFromStringBindingW( binding, &bindHandle );
    if ( status != RPC_S_OK )
    {
        bindHandle = NULL;
    }

    if ( binding )
    {
        RpcStringFreeW( &binding );
    }

    return bindHandle;
}


VOID
DNS_RPC_HANDLE_unbind(
    IN      DNS_RPC_HANDLE      Reserved,
    IN OUT  handle_t            BindHandle
    )

/*++

Routine Description:

    This routine unbinds the identification generic handle.

Arguments:

    Reserved - RPC string handle;  will be NULL unless allow remote
        access to network name

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    None.

--*/
{
    RpcBindingFree( &BindHandle );
}


//
//  RPC memory routines
//
//  Use dnsapi memory routines.
//

PVOID
WINAPI
MIDL_user_allocate(
    IN      size_t          dwBytes
    )
{
    // return( ALLOCATE_HEAP( dwBytes ) );

    return  DnsApiAlloc( dwBytes );
}

VOID
WINAPI
MIDL_user_free(
    IN OUT  PVOID           pMem
    )
{
    //FREE_HEAP( pMem );

    DnsApiFree( pMem );
}

//
//  End bind.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\dnsup\dnsup.c ===
/*++

Copyright (c) 1996-2001  Microsoft Corporation

Module Name:

    dnsup.c

Abstract:

    Domain Name System (DNS) Update Client

    Main program.

Author:

    Jim Gilroy (jamesg)     October, 1996

Environment:

    User Mode - Win32

Revision History:

--*/

#include "..\dnsapi\local.h"
#if 0
#include <windows.h>
#include <winsock2.h>
#include <stdlib.h>
#include <stdio.h>      //  printf()
#include <string.h>     //  strtoul()

#include <windns.h>
#include <dnsapi.h>

#include "dnslib.h"
#include "..\resolver\idl\resrpc.h"
#include "dnsapip.h"
#include "dnslibp.h"
#endif

#include "svcguid.h"    // RnR guids


//  Use dnslib memory routines
#if 0
#define ALLOCATE_HEAP(iSize)            Dns_Alloc(iSize)
#define ALLOCATE_HEAP_ZERO(iSize)       Dns_AllocZero(iSize)
#define REALLOCATE_HEAP(pMem,iSize)     Dns_Realloc((pMem),(iSize))
#define FREE_HEAP(pMem)                 Dns_Free(pMem)
#endif

//  Debug flag

DWORD   LocalDebugFlag;

//
//  Printing
//

#define dnsup_PrintRoutine  ((PRINT_ROUTINE) fprintf)

#define dnsup_PrintContext  ((PPRINT_CONTEXT) stdout)

//
//  Special names and buffers
//

PCHAR   SingleLongName = "longname";
CHAR    SeLongName[] = "longname";

PCHAR   LongName = ( "longname"
                    ".label22222222222222222222222222222222222222222222222222"
                    ".label33333333333333333333333333333333333333333333333333"
                    ".label44444444444444444444444444444444444444444444444444"
                    ".label55555555555555555555555555555555555555555555555555"
                    ".label66666666666666666666666666666666666666666666666666.");

#define LONG_LABEL_NAME ("longlabel" \
        ".longlabel2222222222222222222222222222222222222222222222222222222222")

CHAR    NameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];

CHAR    AddressBuffer[ sizeof(DNS_IP6_ADDRESS) ];


//
//  Quit or Exit status
//

#define ERROR_DNSUP_QUIT    ((DNS_STATUS)(0x87654321))



//
//  Command table setup
//

typedef DNS_STATUS (* COMMAND_FUNCTION)( DWORD Argc, CHAR** Argv);

typedef struct _COMMAND_INFO
{
    PSTR                pszCommandName;
    PSTR                pszDescription;
    COMMAND_FUNCTION    pCommandFunction;
}
COMMAND_INFO, *LPCOMMAND_INFO;

//
//  Note, command table is at bottom of file to
//  avoid need for prototyping all the functions
//

extern COMMAND_INFO GlobalCommandInfo[];




COMMAND_FUNCTION
GetCommandFunction(
    IN      PSTR            pszCommandName
    )
{
    DWORD i;

    //
    //  find command in list matching string
    //

    i = 0;
    while( GlobalCommandInfo[i].pszCommandName )
    {
        if( _stricmp(
                pszCommandName,
                GlobalCommandInfo[i].pszCommandName ) == 0 )
        {
            return( GlobalCommandInfo[i].pCommandFunction );
        }
        i++;
    }
    return( NULL );
}



//
//  Print utils
//

VOID
PrintCommands(
    VOID
    )
{
    DWORD i;

    //
    //  print all commands in list
    //

    i = 0;
    while( GlobalCommandInfo[i].pszCommandName )
    {
        printf(
            "    %10s  (%s)\n",
            GlobalCommandInfo[i].pszCommandName,
            GlobalCommandInfo[i].pszDescription );
        i++;
    }
}


VOID
PrintDnsQueryFlags(
    VOID
    )
{
    DWORD i;

    //
    //  print query flags
    //

    printf(
        "DNS Query flags:\n"
        "\tDNS_QUERY_STANDARD               = 0x%x\n"
        "\tDNS_QUERY_ACCEPT_PARTIAL_UDP     = 0x%x\n"
        "\tDNS_QUERY_USE_TCP_ONLY           = 0x%x\n"
        "\tDNS_QUERY_NO_RECURSION           = 0x%x\n"
        "\tDNS_QUERY_BYPASS_CACHE           = 0x%x\n"
        "\tDNS_QUERY_NO_WIRE_QUERY          = 0x%x\n"
        "\tDNS_QUERY_NO_HOSTS_FILE          = 0x%x\n"
        "\tDNS_QUERY_NO_LOCAL_NAME          = 0x%x\n",
        DNS_QUERY_STANDARD              ,
        DNS_QUERY_ACCEPT_PARTIAL_UDP    ,
        DNS_QUERY_USE_TCP_ONLY          ,
        DNS_QUERY_NO_RECURSION          ,
        DNS_QUERY_BYPASS_CACHE          ,
        DNS_QUERY_NO_WIRE_QUERY         ,
        DNS_QUERY_NO_HOSTS_FILE         ,
        DNS_QUERY_NO_LOCAL_NAME     
        );
}



//
//  Optional DNS server list to use
//
//  Overides default list on this client for some commands
//

PIP_ARRAY pDnsServerArray = NULL;

DNS_STATUS
readNameServers(
    IN  PIP_ARRAY * ppIpServers,
    IN  DWORD *     pArgc,
    IN  PSTR  **    pArgv
    )
{
    DWORD       argc = *pArgc;
    PCHAR *     argv = *pArgv;
    PCHAR *     startArgv;
    PCHAR       arg;
    CHAR        ch;
    IP_ADDRESS  ipserver;
    PIP_ARRAY   aipservers = NULL;
    DWORD       countServers = 0;
    DWORD       i;

    //
    //  -n / -N denotes DNS server
    //  server IP immediate follows (in same arg)
    //

    startArgv = argv;

    while ( argc )
    {
        arg = argv[0];
        if ( '-' == *arg++ )
        {
            ch = *arg++;
            if ( ch == 'n' || ch == 'N' )
            {
                countServers++;
                argc--;
                argv++;
                continue;
            }
        }
        break;
    }

    //
    //  found servers
    //      - allocate IP array
    //      - parse servers into it
    //      - reset callers Argc, Argv
    //

    if ( countServers )
    {
        *pArgc = argc;
        *pArgv = argv;
        argv = startArgv;

        aipservers = DnsCreateIpArray( countServers );
        if ( ! aipservers )
        {
            return( ERROR_OUTOFMEMORY );
        }

        for (i=0; i<(INT)countServers; i++)
        {
            arg = (*argv++) + 2;
            if ( *arg == '.' )
            {
                arg = "127.0.0.1";
            }
            ipserver = inet_addr( arg );
            if ( ipserver == INADDR_NONE )
            {
                printf( "ERROR: name server IP (in arg %s) is bogus\n", arg );
                return( ERROR_INVALID_PARAMETER );
            }
            IF_DNSDBG( INIT )
            {
                DNS_PRINT((
                    "Read name server address from arg %s.\n",
                    arg ));
            }
            aipservers->AddrArray[i] = ipserver;
        }

        DnsDbg_IpArray(
            "Name servers to register with\n",
            NULL,
            aipservers );
    }

    *ppIpServers = aipservers;
    return( ERROR_SUCCESS );
}



DNS_STATUS
ProcessCommandLine(
    IN      INT             Argc,
    IN      CHAR **         Argv
    )
/*++

Routine Description:

    Process command in Argc\Argv form.

Arguments:

    Argc -- arg count

    Argv -- argument list
        Argv[0] -- dnsup
        Argv[1] -- Command to execute
        Argv[2...] -- arguments to command

Return Value:

    Return from the desired command.
    Usually a pass through of the return code from DNS Update API call.

--*/
{
    DNS_STATUS          status;
    COMMAND_FUNCTION    pcommandFunction;
    PCHAR               pcommand;

    if ( Argc < 1 )
    {
        goto Usage;
    }
    DNS_PRINT(( "Argc = %d\n", Argc ));

    //
    //  check for server list
    //

    status = readNameServers(
                & pDnsServerArray,
                & Argc,
                & Argv );
    if ( status != ERROR_SUCCESS )
    {
        goto Usage;
    }

    //
    //  next param is command
    //      - optionally decorated with leading "-"
    //  

    if ( Argc < 1 )
    {
        goto Usage;
    }
    pcommand = Argv[0];
    if ( *pcommand == '-' )
    {
        pcommand++;
    }

    pcommandFunction = GetCommandFunction( pcommand );
    if ( ! pcommandFunction )
    {
        status = ERROR_INVALID_PARAMETER;
        printf( "Unknown Command Specified -- type dnsup -?.\n" );
        goto Usage;
    }

    //
    //  dispatch to processor for this command
    //      - skip over command argv

    Argc--;
    Argv++;
    status = pcommandFunction( Argc, Argv );
    
    if ( status == ERROR_SUCCESS ||
         status == ERROR_DNSUP_QUIT )
    {
        printf( "Command successfully completed.\n" );
    }
    else
    {
        printf( "Command failed, %d (%ul)\n", status, status );
    }
    return( status );

Usage:

    printf(
        "DnsUp command line:\n"
        "\t[-n<Server IP List>] -<Command> [Command Parameters].\n"
        "\t<Server IP List> is a list of one or more DNS server IP addresses\n"
        "\t\toverriding the default list on this client\n"
        "Commands:\n"
        );
    PrintCommands();
    return( ERROR_INVALID_PARAMETER );
}



VOID
InteractiveLoop(
    VOID
    )
/*++

Routine Description:

    Interactive loop.

Arguments:

    None

Return Value:

    None

--*/
{
#define MAX_ARG_COUNT   50

    DNS_STATUS  status;
    INT         argc;
    CHAR *      argv[ MAX_ARG_COUNT ];
    CHAR        lineBuffer[500];


    //
    //  loop taking command params
    //

    while ( 1 )
    {
        printf( "\n> " );

        //  read next command line

        gets( lineBuffer );

        argc = Dns_TokenizeString(
                    lineBuffer,
                    argv,
                    MAX_ARG_COUNT );

        DNS_PRINT(( "argc = %d\n", argc ));

        IF_DNSDBG( INIT )
        {
            DnsDbg_Argv(
                NULL,
                argv,
                argc,
                FALSE   // not unicode
                );
        }

        //  process next command line

        status = ProcessCommandLine(
                    argc,
                    argv );

        if ( status == ERROR_DNSUP_QUIT )
        {
            break;
        }
    }
}



LONG
__cdecl
main(
    IN      INT             Argc,
    IN      CHAR **         Argv
    )
/*++

Routine Description:

    DnsUp program entry point.

    Executes specified command corresponding to a DNS update API operation.

Arguments:

    Argc -- arg count

    Argv -- argument list
        Argv[0] -- dnsup
        Argv[1] -- Command to execute
        Argv[2...] -- arguments to command

Return Value:

    Zero if successful.
    1 on error.

--*/
{
    DNS_STATUS          status;

    //
    //  initialize debug
    //

    Dns_StartDebugEx(
        0,                  //  no flag value
        "dnsup.flag",       //  read flag from file
        NULL,   //&LocalDebugFlag,
        "dnsup.log",        //  log to file
        0,                  //  no wrap limit
        FALSE,              //  don't use existing global
        FALSE,
        TRUE                //  make this file global
        );

    DNS_PRINT(( "*pDnsDebugFlag = %08x\n", *pDnsDebugFlag ));
    //DNS_PRINT(( "LocalDebugFlag = %08x\n", LocalDebugFlag ));

    if ( Argc < 1 )
    {
        goto Usage;
    }
    DNS_PRINT(( "Argc = %d\n", Argc ));

    //  skip "dnsup" argument 

    Argc--;
    Argv++;

    //
    //  interactive mode?
    //      - if no command, just open interactively
    //

    if ( Argc == 0 )
    {
        InteractiveLoop();
        status = ERROR_SUCCESS;
    }
    else
    {
        status = ProcessCommandLine(
                    Argc,
                    Argv );
    }

    Dns_EndDebug();

    return( status != ERROR_SUCCESS );

Usage:

    Dns_EndDebug();
    printf(
        "usage:  DnsUp [-n<Server IP List>] -<Command> [Command Parameters].\n"
        "\t<Server IP List> is a list of one or more DNS server IP addresses\n"
        "\t\toverriding the default list on this client\n"
        "Commands:\n"
        );
    PrintCommands();
    return(1);
}




//
//  Command processing
//

PDNS_RECORD
buildRecordList(
    IN      DWORD           Argc,
    IN      PSTR  *         Argv
    )
/*++

Routine Description:

    Build record list from Argc \ Argv list.

Arguments:

    Argc -- arg count

    Argv -- argument list

Return Value:

    Ptr to list of records built.
    NULL on parsing error.

--*/
{
    PCHAR           arg;
    PCHAR           pszname;
    WORD            type;
    BOOLEAN         fadd;
    BOOLEAN         section;
    CHAR            ch;
    PDNS_RECORD     prr;
    DNS_RRSET       rrset;
    INT             recordArgc;
    PCHAR *         recordArgv;

    //
    //  loop through remaining arguments building appropriate record types
    //

    DNS_RRSET_INIT( rrset );
    recordArgc = (-3);
    pszname = NULL;

    while ( Argc-- && (arg = *Argv++) )
    {
        //
        //  if previous arg started new record, first parameter is name
        //

        if ( recordArgc == (-2) )
        {
            pszname = arg;
            type = 0;
            recordArgc++;
            continue;
        }

        //
        //  second parameter is type
        //

        else if ( recordArgc == (-1) )
        {
            type = DnsRecordTypeForName( arg, 0 );
            if ( type == 0 )
            {
                printf( "ERROR:  unknown type %s.\n", arg );
                goto Failed;
            }
            recordArgc++;
            continue;
        }

        //
        //  check for end of existing record \ start of new record
        //

        ch = *arg;

        if ( ch == '+' || ch == '-' )
        {
            //  build old record (if any)

            if ( pszname != NULL )
            {
                prr = Dns_RecordBuild_A(
                        & rrset,
                        pszname,
                        type,
                        fadd,
                        section,
                        recordArgc,
                        recordArgv );
                if ( !prr )
                {
                    printf( "ERROR:  building record.\n" );
                    goto Failed;
                }
                if ( fadd && section == DNSREC_UPDATE )
                {
                    prr->dwTtl = 3600;
                }
            }

            fadd = ( ch == '+' );
            recordArgc = (-2);

            //
            //  second character in new arg, indicates section
            //      - for update ADD records use 3600 TTL instead of zero
            //

            ch = *++arg;
            if ( ch == 0 )
            {
                section = DNSREC_QUESTION;
            }
            else if ( ch == 'p' )
            {
                section = DNSREC_PREREQ;
            }
            else if ( ch == 'u' )
            {
                section = DNSREC_UPDATE;
            }
            else if ( ch == 'a' )
            {
                section = DNSREC_ADDITIONAL;
            }
            else
            {
                printf( "ERROR:  unknown section id %d.\n", ch );
                goto Failed;
            }
            continue;
        }

        //  catch bad starting record (no +/-)

        else if ( recordArgc < 0 )
        {
            printf( "ERROR:  bad start of record arg %s\n", arg );
            goto Failed;
        }

        //
        //  anything else is data, save in argv format
        //      - save starting point
        //      - count records

        else if ( recordArgc == 0 )
        {
            recordArgv = --Argv;
            Argv++;
        }
        recordArgc++;
        continue;
    }

    //
    //  build any final record
    //

    if ( pszname != NULL )
    {
        prr = Dns_RecordBuild_A(
                & rrset,
                pszname,
                type,
                fadd,
                section,
                recordArgc,
                recordArgv );
        if ( !prr )
        {
            printf( "ERROR:  building record.\n" );
            goto Failed;
        }
        if ( fadd && section == DNSREC_UPDATE )
        {
            prr->dwTtl = 3600;
        }
    }
    IF_DNSDBG( INIT )
    {
        DnsDbg_RecordSet(
            "Record set:\n",
            rrset.pFirstRR );
    }

    return( rrset.pFirstRR );

Failed:

    printf( "ERROR:  building records from arguments.\n" );
    SetLastError( ERROR_INVALID_PARAMETER );
    return( NULL );
}



PCHAR
getNamePointer(
    IN      PSTR            pszName
    )
/*++

Routine Description:

    Get name pointer.

    This may be legit pointer or tag
    Tags:
        - null
        - blank
        - badptr
        - badname
        - longname
        - longlabel
        - buffer

Arguments:

    Argc -- arg count

    Argv -- argument list

Return Value:

    Ptr to list of records built.
    NULL on parsing error.

--*/
{
    PCHAR   pname = pszName;

    //
    //  check special case names
    //

    if ( _stricmp( pname, "null" ) == 0 )
    {
        pname = NULL;
    }
    else if ( _stricmp( pname, "blank" ) == 0 )
    {
        pname = "";
    }
    else if ( _stricmp( pname, "badname" ) == 0 )
    {
        pname = "..badname..";
    }
    else if ( _stricmp( pname, "longname" ) == 0 )
    {
        //pname = LONG_NAME;
        pname = LongName;
    }
    else if ( _stricmp( pname, "longlabel" ) == 0 )
    {
        pname = LONG_LABEL_NAME;
    }
    else if ( _stricmp( pname, "badptr" ) == 0 )
    {
        pname = (PCHAR) (-1);
    }
    else if ( _stricmp( pname, "buffer" ) == 0 )
    {
        pname = (PCHAR) NameBuffer;
    }

    return( pname );
}



BOOL
getAddressPointer(
    IN      PSTR            pAddrString,
    OUT     PCHAR *         ppAddr,
    OUT     PDWORD          pLength,
    OUT     PDWORD          pFamily
    )
/*++

Routine Description:

    Get address from address string argument.

    Wraps up special arguments (NULL, badptr), with string
    to address conversion.

Arguments:

    pAddrString -- address as string

    pAddr   -- ptr to recv address

    pLength -- ptr to recv length of returned address

    pFamily -- ptr to recv family (socket family) of returned address

Return Value:

    TRUE if valid address converted.
    FALSE if special ptr or pass through.

--*/
{
    PCHAR   paddr;
    INT     length = sizeof(IP4_ADDRESS);
    INT     family = AF_INET;
    BOOL    result = FALSE;

    //
    //  first check for special cases
    //      - default to AF_INET
    //

    if ( _stricmp( pAddrString, "null" ) == 0 )
    {
        paddr = NULL;
    }
    else if ( _stricmp( pAddrString, "blank" ) == 0 )
    {
        paddr = "";
        length = 0;
    }
    else if ( _stricmp( pAddrString, "badptr" ) == 0 )
    {
        paddr = (PCHAR) (-1);
    }

    //
    //  not-special -- treat as address string
    //      - use type and length on successful conversion
    //      - just return pAddrString and it's length if not successful
    //

    else 
    {
        family = 0;     // any family
        length = sizeof(AddressBuffer);

        result = Dns_StringToAddress_A(
                        AddressBuffer,
                        & length,
                        pAddrString,
                        & family );
        if ( result )
        {
            paddr = AddressBuffer;
        }
        else
        {
            paddr = pAddrString;
            length = strlen( pAddrString );
            family = AF_INET;
        }
    }

    *ppAddr  = paddr;
    *pLength = length;
    *pFamily = family;

    return( result );
}



BOOL
getSockaddrFromString(
    IN OUT  PSOCKADDR *     ppSockaddr,
    IN OUT  PDWORD          pSockaddrLength,
    IN      PSTR            pAddrString
    )
/*++

Routine Description:

    Get sockaddr from address string argument.

    Wraps up special arguments (NULL, badptr), with string
    to address conversion.

Arguments:

    ppSockaddr -- addr of ptr to sockaddr buffer
        on return may be set to point at dummy sockaddr

    pSockaddrLength -- addr with sockaddr buffer length
        receives sockaddr length

    pAddrString -- address as string

Return Value:

    TRUE if parsed sockaddr string
        Note this does not mean it is a valid sockaddr.
    FALSE if special ptr or pass through.

--*/
{
    PCHAR       paddr = NULL;
    DWORD       addrLength;
    DWORD       family;
    DWORD       flags = 0;
    DNS_STATUS  status;

    //
    //  convert address string
    //
    //  if valid string => write into given sockaddr
    //  if invalid => set sockaddr ptr to dummy sockaddr
    //

    if ( getAddressPointer(
                pAddrString,
                & paddr,
                & addrLength,
                & family ) )
    {
        status = Dns_AddressToSockaddr(
                        *ppSockaddr,
                        pSockaddrLength,
                        TRUE,       // clear sockaddr
                        paddr,
                        addrLength,
                        family );

        if ( status != NO_ERROR )
        {
            DNS_ASSERT( FALSE );
            return  FALSE;
        }
    }
    else    // special bogus address, use it directly
    {
        *ppSockaddr = (PSOCKADDR) paddr;
    }
    return  TRUE;
}




//
//  Command functions
//

DNS_STATUS
ProcessQuit(
    IN      DWORD           Argc,
    IN      PSTR  *         Argv
    )
{
    //
    //  alert command processor to break iteractive loop
    //

    return( ERROR_DNSUP_QUIT );
}




//
//  Update routines
//
//  DCR:  could add context handle interface to update routines
//

DNS_STATUS
ProcessUpdate(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    DNS_STATUS      status;
    DWORD           flags = 0;
    PCHAR           arg;
    PDNS_RECORD     prr = NULL;
    PDNS_MSG_BUF    pmsgRecv = NULL;
    HANDLE          hCreds=NULL;

    //
    //  flags?
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }
    arg = Argv[0];
    if ( strncmp( arg, "-f", 2 ) == 0 )
    {
        flags = strtoul( arg+2, NULL, 16 );
        Argc--;
        Argv++;
    }

    //
    //  build update packet RRs
    //

    prr = buildRecordList(
                Argc,
                Argv );
    if ( !prr )
    {
        status = GetLastError();
        if ( status != ERROR_SUCCESS )
        {
            printf( "ERROR:  building records from arguments\n" );
            goto Usage;
        }
    }

    //
    //  build \ send update
    //

    status = DnsUpdate(
                prr,
                flags,
                NULL,       // no UPDATE adapter list specified
                hCreds,
                &pmsgRecv
                );
    if ( pmsgRecv )
    {
        DnsPrint_Message(
            dnsup_PrintRoutine,
            dnsup_PrintContext,
            "Update response:\n",
            pmsgRecv );
    }

    Dns_RecordListFree( prr );

    FREE_HEAP( pmsgRecv );

    if ( status != ERROR_SUCCESS )
    {
        printf(
            "DnsUpdate failed, %x %s.\n",
            status,
            DnsStatusString(status) );
    }
    else
    {
        printf( "Update successfully completed.\n" );
    }
    return( status );

Usage:

    Dns_RecordListFree( prr );

    printf(
        "DnsUpdate\n"
        "usage:\n"
        "  DnsUp -u [-f<Flags>] [<Record> | ...]\n"
        "   <Record> record for update packet\n"
        "   <Record> == (-,+)(p,u,a) <Name> <Type> [Data | ...]\n"
        "       (-,+)   - add or delete, exist or no-exist flag\n"
        "       (p,u,a) - prereq, update or additional section\n"
        "       <Name>  - RR owner name\n"
        "       <Type>  - record type (ex A, SRV, PTR, TXT, CNAME, etc.)\n"
        "       <Data>  - data strings (type specific), if any\n"
        );
    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessUpdateTest(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    DNS_STATUS      status;
    DWORD           flags = 0;
    PCHAR           pszzone = NULL;
    PCHAR           arg;
    PDNS_RECORD     prr = NULL;
    PDNS_MSG_BUF    pmsg = NULL;
    PDNS_MSG_BUF    pmsgRecv = NULL;
    IP_ADDRESS      ipserver;
    PIP_ARRAY       aipservers = NULL;
    PSTR            pszserverName = NULL;
    HANDLE          hCreds = NULL;

    //
    //  optional name server to query?
    //

    aipservers = pDnsServerArray;
    if ( !aipservers )
    {
        aipservers = DnsQueryConfigAlloc(
                        DnsConfigDnsServerList,
                        NULL );
    }
    if ( !aipservers )
    {
        printf( "Update failed:  no DNS server list available.\n" );
        return( GetLastError() );
    }

    //
    //  flags?
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }
    arg = Argv[0];
    if ( strncmp( arg, "-f", 2 ) == 0 )
    {
        flags = strtoul( arg+2, NULL, 16 );
        Argc--;
        Argv++;
    }

    //
    //  security -- then need target server name
    //      presence of server name automatically turns on security
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }
    arg = Argv[0];
    if ( strncmp( arg, "-s", 2 ) == 0 )
    {
        pszserverName = arg+2;
        flags |= DNS_UPDATE_SECURITY_ONLY;
        Argc--;
        Argv++;
    }

    //
    //  name of zone to update
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }
    arg = Argv[0];
    if ( *arg != '-' && *arg != '+' )
    {
        pszzone = arg;
        DNSDBG( INIT, (
            "Read update zone name %s\n",
            pszzone ));
        Argc--;
        Argv++;
    }

    //
    //  build update packet RRs
    //

    prr = buildRecordList(
                Argc,
                Argv );
    if ( !prr )
    {
        status = GetLastError();
        if ( status != ERROR_SUCCESS )
        {
            printf( "ERROR:  building records from arguments\n" );
            goto Usage;
        }
    }

    //
    //  build \ send update
    //

    status = Dns_UpdateLibEx(
                prr,
                flags,
                pszzone,
                pszserverName,
                aipservers,
                NULL,
                &pmsgRecv
                );
    if ( pmsgRecv )
    {
        DnsPrint_Message(
            dnsup_PrintRoutine,
            dnsup_PrintContext,
            "Update response:\n",
            pmsgRecv );
    }

    DnsApiFree( aipservers );
    Dns_RecordListFree( prr );
    FREE_HEAP( pmsg );
    FREE_HEAP( pmsgRecv );

    if( status != ERROR_SUCCESS )
    {
        printf(
            "DnsUpdateEx failed, %x %s.\n",
            status,
            DnsStatusString(status) );
    }
    else
    {
        printf( "Update successfully completed.\n" );
    }
    return( status );

Usage:

    FREE_HEAP( aipservers );
    Dns_RecordListFree( prr );
    FREE_HEAP( pmsg );
    FREE_HEAP( pmsgRecv );

    printf(
        "UpdateTest -- Dns_UpdateLibEx\n"
        "usage:\n"
        "  DnsUp [-n<DNS IP>|...] -ut [-f<Flags>] [-s<ServerName>] [<ZoneName>] [<Record> | ...]\n"
        "   <DNS IP> optional IP address of server to send update to.\n"
        "   <ServerName> name of DNS server we are sending update to;\n"
        "       presence of server name automatically turns on update security\n"
        "   <ZoneName> name of zone to update\n"
        "   <Record> record for update packet\n"
        "   <Record> == (-,+)(p,u,a) <Name> <Type> [Data | ...]\n"
        "       (-,+)   - add or delete, exist or no-exist flag\n"
        "       (p,u,a) - prereq, update or additional section\n"
        "       <Name>  - RR owner name\n"
        "       <Type>  - record type (ex A, SRV, PTR, TXT, CNAME, etc.)\n"
        "       <Data>  - data strings (type specific), if any\n"
        );
    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessDhcpTest(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    DNS_STATUS              status;
    REGISTER_HOST_ENTRY     hostEntry;
    REGISTER_HOST_STATUS    hostStatus;
    HANDLE                  doneEvent;

    //
    //  create completion event
    //

    doneEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

    //
    //  build dumpy DHCP update
    //

    hostEntry.Addr.ipAddr = 0x01010101;
    hostEntry.dwOptions = REGISTER_HOST_A;
    hostStatus.hDoneEvent = doneEvent;

    //
    //  send to DHCP DynDNS update routine
    //

    status = DnsAsyncRegisterHostAddrs(
                L"El59x1",
                L"testdhcpname",
                &hostEntry,
                1,              // address count
                NULL, // no regkey with previous
                0,
                L"nttest.microsoft.com",
                & hostStatus,
                60,        // TTL
                0
                );

    if( status != ERROR_SUCCESS )
    {
        printf(
            "DnsAsynRegisterHostAddrs_W() %s.\n",
            status,
            DnsStatusString(status) );
        return( status );
    }

    printf( "DHCP DynDNS registration successfully completed.\n" );

    WaitForSingleObject(
        doneEvent,
        INFINITE );

    return( status );
}



//
//  Query routines
//

DNS_STATUS
ProcessQueryEx(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    DNS_STATUS      status;
    PCHAR           pszname;
    WORD            type;
    DWORD           flags = 0;
    PDNS_MSG_BUF    pmsgRecv = NULL;
    HANDLE          hevent = NULL;
    DNS_QUERY_INFO  queryInfo;

    //
    //  name to query
    //

    if ( Argc < 2 || Argc > 4 )
    {
        goto Usage;
    }
    pszname = Argv[0];
    Argc--;
    Argv++;

    //
    //  type
    //

    type = DnsRecordTypeForName( Argv[0], 0 );
    if ( type == 0 )
    {
        goto Usage;
    }
    Argc--;
    Argv++;

    //
    //  flags and options
    //

    while ( Argc )
    {
        if ( _stricmp( Argv[0], "-a" ) == 0 )
        {
            hevent = CreateEvent( NULL, FALSE, FALSE, NULL );
        }
        else
        {
            flags = strtoul( Argv[0], NULL, 16 );
        }
        Argc--;
        Argv++;
    }

    //
    //  query
    //

    RtlZeroMemory(
        & queryInfo,
        sizeof(queryInfo) );

    queryInfo.pName         = pszname;
    queryInfo.Type          = type;
    queryInfo.Flags         = flags;
    queryInfo.pDnsServers   = pDnsServerArray;
    queryInfo.hEvent        = hevent;

    status = DnsQueryEx( &queryInfo );

    if ( status == ERROR_IO_PENDING )
    {
        printf(
            "DnsQueryEx() running asynchronously.\n"
            "\tEvent = %p\n",
            hevent );

        WaitForSingleObject( hevent, INFINITE );

        printf( "DnsQueryEx() async completion.\n" );

        status = queryInfo.Status;
    }

    if ( status == ERROR_SUCCESS ||
         status == DNS_ERROR_RCODE_NAME_ERROR ||
         status == DNS_INFO_NO_RECORDS )
    {
        printf(
            "DnsQueryEx() completed => %s.\n"
            "\tstatus = %d\n",
            DnsStatusString( status ),
            status );

        DnsPrint_QueryInfo(
            dnsup_PrintRoutine,
            dnsup_PrintContext,
            "DnsQueryEx() result",
            &queryInfo );
    }
    else
    {
        printf(
            "DnsQueryEx() failed, %x %s.\n",
            status,
            DnsStatusString(status) );

        DNS_ASSERT( !queryInfo.pAnswerRecords );
        DNS_ASSERT( !queryInfo.pAliasRecords );
        DNS_ASSERT( !queryInfo.pAdditionalRecords );
        DNS_ASSERT( !queryInfo.pAuthorityRecords );
    }

    return( status );

Usage:

    printf(
        "DnsQueryEx\n"
        "usage:\n"
        "  DnsUp [-n<DNS IP>|...] -qex <Name> <Type> <Flags> [-a]\n"
        "   <DNS IP> optional IP address of DNS server to query.\n"
        "   <Name> DNS name to query\n"
        "   <Type> type of query\n"
        "   <Flags> flags to use in query (in hex)\n"
        "   -a to indicate asynchronous operation\n"
        );
    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessQueryCompare(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    DNS_STATUS      status;
    PCHAR           pszname;
    WORD            type;
    PIP_ARRAY       aipservers;
    PDNS_MSG_BUF    pmsgRecv = NULL;
    PDNS_RECORD     prrQuery;
    PDNS_RECORD     prrParsed;
    PDNS_RECORD     prrQueryDiff;
    PDNS_RECORD     prrParsedDiff;

    //
    //  optional name server to query?
    //

    aipservers = pDnsServerArray;

    //
    //  name to query
    //

    if ( Argc < 2 )
    {
        goto Usage;
    }
    pszname = Argv[0];
    Argc--;
    Argv++;

    //
    //  type
    //

    type = DnsRecordTypeForName( Argv[0], 0 );
    if ( type == 0 )
    {
        goto Usage;
    }
    Argc--;
    Argv++;

    //
    //  build expected RR set
    //

    prrParsed = buildRecordList(
                    Argc,
                    Argv );
    if ( !prrParsed )
    {
        status = GetLastError();
        if ( status != ERROR_SUCCESS )
        {
            printf( "ERROR:  building records from arguments\n" );
            goto Usage;
        }
    }
    DnsPrint_RecordSet(
        dnsup_PrintRoutine,
        dnsup_PrintContext,
        "Parsed comparison record list:\n",
        prrParsed );

    //
    //  query
    //
    //  DCR:  waiting for new DnsQueryEx()
    //

    return( ERROR_CALL_NOT_IMPLEMENTED );

#if 0
    status = DnsQueryEx(
                & pmsgRecv,
                & prrQuery,
                pszname,
                type,
                0,          // currently no flag support
                aipservers,
                NULL
                );

    if( status != ERROR_SUCCESS )
    {
        printf(
            "DnsQueryEx() failed, %x %s.\n",
            status,
            DnsStatusString(status) );
        if ( DnsIsStatusRcode(status) )
        {
            DnsPrint_Message(
                dnsup_PrintRoutine,
                dnsup_PrintContext,
                "Query response:\n",
                pmsgRecv );
        }
        return( status );
    }
    DnsPrint_RecordSet(
        dnsup_PrintRoutine,
        dnsup_PrintContext,
        "Query response records:\n",
        prrQuery );


    //
    //  compare with records received
    //

    DnsRecordSetCompare(
        prrQuery,
        prrParsed,
        & prrQueryDiff,
        & prrParsedDiff );

    DnsPrint_RecordSet(
        dnsup_PrintRoutine,
        dnsup_PrintContext,
        "Unmatch records in query response:\n",
        prrQueryDiff );

    DnsPrint_RecordSet(
        dnsup_PrintRoutine,
        dnsup_PrintContext,
        "Unmatch records in parsed list:\n",
        prrParsedDiff );

    return( ERROR_SUCCESS );
#endif

Usage:

    printf(
        "Query compare\n"
        "usage:\n"
        "  DnsUp [-n<DNS IP>|...] -qc <Name> <Type> [<Record> | ...]\n"
        "   <DNS IP> optional IP address of DNS server to update.\n"
        "   <Name> DNS name to query\n"
        "   <Type> type of query\n"
        "   <Record> record in list to compare\n"
        "   <Record> == (-,+) <Name> <Type> [Data | ...]\n"
        "       (-,+) - add or delete, exist or no-exist flag\n"
        "       <Name> - RR owner name\n"
        "       <Type> - record type\n"
        "       <Data> - data strings (type specific), if any\n"
        );
    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessQuery(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    DNS_STATUS      status;
    PCHAR           pszname;
    WORD            type;
    DWORD           flags = 0;
    PDNS_RECORD     precord = NULL;
    PDNS_MSG_BUF    pmsgRecv = NULL;
    PDNS_MSG_BUF *  ppmsgRecv = NULL;
    PIP_ARRAY       aipservers = NULL;

    //
    //  name to query
    //

    if ( Argc < 2 || Argc > 3 )
    {
        goto Usage;
    }

    pszname = getNamePointer( Argv[0] );
    Argc--;
    Argv++;

    //
    //  type
    //

    type = DnsRecordTypeForName( Argv[0], 0 );
    if ( type == 0 )
    {
        goto Usage;
    }
    Argc--;
    Argv++;

    //
    //  flags
    //

    if ( Argc )
    {
        flags = strtoul( Argv[0], NULL, 16 );
        Argc--;
        Argv++;
    }
    if ( Argc )
    {
        goto Usage;
    }

    //
    //  only if flag has BYPASS_CACHE set can we
    //      1) send to specific servers
    //      2) receive message buffer itself
    //

    aipservers = pDnsServerArray;

    if ( flags & DNS_QUERY_BYPASS_CACHE )
    {
        ppmsgRecv = & pmsgRecv;
    }

    //
    //  query
    //

    status = DnsQuery(
                pszname,
                type,
                flags,
                aipservers,
                & precord,
                ppmsgRecv );

    if( status != ERROR_SUCCESS )
    {
        printf(
            "DnsQuery() failed, %x %s.\n",
            status,
            DnsStatusString(status) );
        if ( DnsIsStatusRcode(status) && pmsgRecv )
        {
            DnsPrint_Message(
                dnsup_PrintRoutine,
                dnsup_PrintContext,
                "Query response:\n",
                pmsgRecv );
        }
    }
    else
    {
        printf( "DnsQuery() successfully completed.\n" );
        if ( pmsgRecv )
        {
            DnsPrint_Message(
                dnsup_PrintRoutine,
                dnsup_PrintContext,
                "Query response:\n",
                pmsgRecv );
        }
        DnsPrint_RecordSet(
            dnsup_PrintRoutine,
            dnsup_PrintContext,
            "Query response records:\n",
            precord );
    }

    DnsRecordListFree( precord, DnsFreeRecordListDeep );
    return( status );

Usage:

    printf(
        "DnsQuery\n"
        "usage:\n"
        "  DnsUp [-n<DNS IP>|...] -q <Name> <Type> [<Flags>]\n"
        "   <DNS IP> optional IP address of DNS server to query.\n"
        "   <Name> DNS name to query\n"
        "   <Type> type of query\n"
        "   <Flags> flags to use in query (in hex)\n"
        "\n"
        "  Note for DnsQuery() to use specific server or to return\n"
        "  a DNS message buffer, BYPASS_CACHE flag MUST be set.\n"
        );
    PrintDnsQueryFlags();

    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessQueryMultiple(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    DNS_STATUS      status;
    PCHAR           pszname1;
    WORD            type1;
    PCHAR           pszname2;
    WORD            type2;
    DWORD           flags = 0;
    PDNS_RECORD     precord = NULL;
    PDNS_MSG_BUF    pmsgRecv = NULL;
    PDNS_MSG_BUF *  ppmsgRecv = NULL;
    PIP_ARRAY       aipservers = NULL;

    //
    //  optional name server to query?
    //

    if ( Argc < 4 || Argc > 5 )
    {
        goto Usage;
    }

    //
    //  first name to query
    //

    pszname1 = Argv[0];
    Argc--;
    Argv++;

    //
    //  first type
    //

    type1 = DnsRecordTypeForName( Argv[0], 0 );
    if ( type1 == 0 )
    {
        goto Usage;
    }
    Argc--;
    Argv++;

    //
    //  second name to query
    //

    pszname2 = Argv[0];
    Argc--;
    Argv++;

    //
    //  second type
    //

    type2 = DnsRecordTypeForName( Argv[0], 0 );
    if ( type2 == 0 )
    {
        goto Usage;
    }
    Argc--;
    Argv++;

    //
    //  flags
    //

    if ( Argc )
    {
        flags = strtoul( Argv[0], NULL, 16 );
        Argc--;
        Argv++;
    }
    if ( Argc )
    {
        goto Usage;
    }

    //
    //  only if flag has BYPASS_CACHE set can we
    //      1) send to specific servers
    //      2) receive message buffer itself
    //

    if ( flags & DNS_QUERY_BYPASS_CACHE )
    {
        aipservers = pDnsServerArray;
        ppmsgRecv = & pmsgRecv;
    }

    //
    //  make first query
    //

    status = DnsQuery(
                pszname1,
                type1,
                flags,
                aipservers,
                & precord,
                ppmsgRecv );

    if( status != ERROR_SUCCESS )
    {
        printf(
            "DnsQuery() failed, %x %s.\n",
            status,
            DnsStatusString(status) );
        if ( DnsIsStatusRcode(status) && pmsgRecv )
        {
            DnsPrint_Message(
                dnsup_PrintRoutine,
                dnsup_PrintContext,
                "Query response:\n",
                pmsgRecv );
        }
    }
    else
    {
        printf( "DnsQuery() successfully completed.\n" );
        if ( pmsgRecv )
        {
            DnsPrint_Message(
                dnsup_PrintRoutine,
                dnsup_PrintContext,
                "Query response:\n",
                pmsgRecv );
        }
        DnsPrint_RecordSet(
            dnsup_PrintRoutine,
            dnsup_PrintContext,
            "Query response records:\n",
            precord );
    }
    DnsRecordListFree( precord, DnsFreeRecordListDeep );

    //
    //  make second query
    //

    status = DnsQuery(
                pszname2,
                type2,
                flags,
                aipservers,
                & precord,
                ppmsgRecv );

    if( status != ERROR_SUCCESS )
    {
        printf(
            "DnsQuery() failed, %x %s.\n",
            status,
            DnsStatusString(status) );
        if ( DnsIsStatusRcode(status) && pmsgRecv )
        {
            DnsPrint_Message(
                dnsup_PrintRoutine,
                dnsup_PrintContext,
                "Query response:\n",
                pmsgRecv );
        }
    }
    else
    {
        printf( "DnsQuery() successfully completed.\n" );
        if ( pmsgRecv )
        {
            DnsPrint_Message(
                dnsup_PrintRoutine,
                dnsup_PrintContext,
                "Query response:\n",
                pmsgRecv );
        }
        DnsPrint_RecordSet(
            dnsup_PrintRoutine,
            dnsup_PrintContext,
            "Query response records:\n",
            precord );
    }
    DnsRecordListFree( precord, DnsFreeRecordListDeep );
    return( status );

Usage:

    printf(
        "Multiple DnsQuery()s\n"
        "usage:\n"
        "  DnsUp [-n<DNS IP>|...] -qm <Name1> <Type1> <Name2> <Type2> [<Flags>]\n"
        "   <DNS IP> optional IP address of DNS server to query.\n"
        "   <Name1> DNS name to query\n"
        "   <Type1> type of query\n"
        "   <Name2> DNS name to query\n"
        "   <Type2> type of query\n"
        "   <Flags> flags to use in query (in hex)\n"
        "\n"
        "  Note for DnsQuery() to use specific server or to return\n"
        "  a DNS message buffer, BYPASS_CACHE flag MUST be set.\n"
        );
    PrintDnsQueryFlags();
    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessQueryTest(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    DNS_STATUS      status;
    PCHAR           pszname;
    WORD            type;
    DWORD           flags = 0;
    PDNS_RECORD     precord = NULL;
    PDNS_MSG_BUF    pmsgRecv = NULL;
    PIP_ARRAY       aipservers = NULL;

    //
    //  optional name server to query?
    //

    aipservers = pDnsServerArray;

    //
    //  name to query
    //

    if ( Argc < 2 || Argc > 3 )
    {
        goto Usage;
    }
    pszname = Argv[0];
    Argc--;
    Argv++;

    //
    //  type
    //

    type = DnsRecordTypeForName( Argv[0], 0 );
    if ( type == 0 )
    {
        goto Usage;
    }
    Argc--;
    Argv++;

    //
    //  flags
    //

    if ( Argc )
    {
        flags = strtoul( Argv[0], NULL, 16 );
        Argc--;
        Argv++;
    }
    if ( Argc )
    {
        goto Usage;
    }

    //
    //  query
    //

    status = QueryDirectEx(
                & pmsgRecv,
                & precord,
                NULL,       // no header
                0,          // no header counts
                pszname,
                type,
                NULL,       // no records
                flags,
                aipservers,
                NULL
                );

    if( status != ERROR_SUCCESS )
    {
        printf(
            "QueryDirectEx() failed, %x %s.\n",
            status,
            DnsStatusString(status) );
        if ( DnsIsStatusRcode(status) )
        {
            DnsPrint_Message(
                dnsup_PrintRoutine,
                dnsup_PrintContext,
                "Query response:\n",
                pmsgRecv );
        }
    }
    else
    {
        printf( "QueryDirectEx() successfully completed.\n" );
        DnsPrint_Message(
            dnsup_PrintRoutine,
            dnsup_PrintContext,
            "Query response:\n",
            pmsgRecv );
        DnsPrint_RecordSet(
            dnsup_PrintRoutine,
            dnsup_PrintContext,
            "Query response records:\n",
            precord );
    }
    DnsRecordListFree( precord, DnsFreeRecordListDeep );
    return( status );

Usage:

    printf(
        "QueryDirectEx()\n"
        "usage:\n"
        "  DnsUp [-n<DNS IP>|...] -qt <Name> <Type> [<Flags>]\n"
        "   QueryTest -- uses dnslib.lib QueryDirectEx()\n"
        "   <DNS IP> optional IP address of DNS server to query.\n"
        "   <Name> DNS name to query\n"
        "   <Type> type of query\n"
        "   <Flags> flags to use in query (in hex)\n"
        );
    return( ERROR_INVALID_PARAMETER );
}

#if 0

DNS_STATUS
ProcessUpdateMultiple(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    DNS_STATUS      status;
    DWORD           flags = 0;
    PCHAR           pszzone = NULL;
    PCHAR           pszname = NULL;
    IP_ADDRESS      ip;
    IP_ADDRESS      hostIp;
    DWORD           countIp;
    DWORD           i;
    PCHAR           arg;
    PDNS_RECORD     prr = NULL;
    PDNS_MSG_BUF    pmsg = NULL;
    PDNS_MSG_BUF    pmsgRecv = NULL;
    IP_ADDRESS      ipserver;
    PIP_ARRAY       aipservers = NULL;
    PIP_ARRAY       ipArray = NULL;
    PSTR            pszserverName = NULL;
    HANDLE          hCreds=NULL;

    //
    //  optional name server to query?
    //

    aipservers = pDnsServerArray;
    if ( !aipservers )
    {
        aipservers = Dns_GetDnsServerList( FALSE );
    }
    if ( !aipservers )
    {
        printf( "Update failed:  no DNS server list available.\n" );
        return( GetLastError() );
    }

    //
    //  flags?
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }
    arg = Argv[0];
    if ( strncmp( arg, "-f", 2 ) == 0 )
    {
        flags = strtoul( arg+2, NULL, 16 );
        Argc--;
        Argv++;
    }

    //
    //  security -- then need target server name
    //      presence of server name automatically turns on security
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }
    arg = Argv[0];
    if ( strncmp( arg, "-s", 2 ) == 0 )
    {
        pszserverName = arg+2;
        flags |= DNS_UPDATE_SECURITY_ON;
        Argc--;
        Argv++;
    }

    //
    //  name of zone to update
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }
    pszzone = Argv[0];
    DNSDBG( INIT, (
        "Read update zone name %s\n",
        pszzone ));
    Argc--;
    Argv++;

    //
    //  name to update
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }
    pszname = Argv[0];
    DNSDBG( INIT, (
        "Read update host name %s\n",
        pszname ));
    Argc--;
    Argv++;

    //
    //  start IP
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }
    ip = inet_addr( Argv[0] );
    if ( ip == (-1) )
    {
        goto Usage;
    }
    Argc--;
    Argv++;

    //
    //  IP count
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }
    countIp = strtoul( Argv[0], NULL, 10 );
    Argc--;
    Argv++;

    //
    //  build update record list
    //      - allocate and generate IP array
    //      - then create DNS records
    //

    ipArray = Dns_CreateIpArray( countIp );
    if ( !ipArray )
    {
        status = GetLastError();
        if ( status != ERROR_SUCCESS )
        {
            printf( "ERROR:  creating IP array\n" );
            goto Usage;
        }
        goto Usage;
    }

    hostIp = ntohl( ip );

    for ( i=0; i<countIp; i++ )
    {
        ipArray->AddrArray[i] = htonl( hostIp );
        hostIp++;
    }

    prr = Dns_HostUpdateRRSet(
            pszname,
            ipArray,
            3600 );
    if ( !prr )
    {
        status = GetLastError();
        if ( status != ERROR_SUCCESS )
        {
            printf( "ERROR:  building records from arguments\n" );
            goto Usage;
        }
    }

    //
    //  build \ send update
    //

    status = Dns_UpdateLibEx(
                prr,
                flags,
                pszzone,
                pszserverName,
                aipservers,
                hCreds,
                &pmsgRecv
                );
    if ( pmsgRecv )
    {
        DnsPrint_Message(
            dnsup_PrintRoutine,
            dnsup_PrintContext,
            "Update response:\n",
            pmsgRecv );
    }

    FREE_HEAP( aipservers );
    Dns_RecordListFree( prr );
    FREE_HEAP( pmsg );
    FREE_HEAP( pmsgRecv );

    if( status != ERROR_SUCCESS )
    {
        printf(
            "Dns_UpdateLibEx failed, %x %s.\n",
            status,
            DnsStatusString(status) );
    }
    else
    {
        printf( "Update successfully completed.\n" );
    }
    return( status );

Usage:

    FREE_HEAP( aipservers );
    Dns_RecordListFree( prr );
    FREE_HEAP( pmsg );
    FREE_HEAP( pmsgRecv );

    printf(
        "usage:\n"
        "  DnsUp [-n<DNS IP>|...] -um [-f<Flags>] [-s<ServerName>] <ZoneName>\n"
        "        <HostName> <Starting IP> <IP Count>\n"
        "   <DNS IP> optional IP address of server to send update to.\n"
        "   <ServerName> name of DNS server we are sending update to;\n"
        "       presence of server name automatically turns on update security\n"
        "   <ZoneName> name of zone to update\n"
        "   <HostName> name of host to update\n"
        "   <Starting IP> first IP (in dotted decimal) in range to update\n"
        "   <IP Count> count of IPs to send in update;  IP address in update will\n"
        "       be the next <IP count> after <Starting IP>\n"
        );
    return( ERROR_INVALID_PARAMETER );
}
#endif



DNS_STATUS
ProcessIQuery(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    DNS_STATUS      status;
    DWORD           flags = 0;
    PCHAR           arg;
    PDNS_RECORD     prr = NULL;
    PDNS_MSG_BUF    pmsg = NULL;
    PDNS_MSG_BUF    pmsgRecv = NULL;
    IP_ADDRESS      ipserver;
    PIP_ARRAY       aipservers = NULL;
    DNS_HEADER      header;

    //
    //  setup header
    //      - zero flags

    *(PDWORD) &header = 0;
    header.Xid = (WORD) GetCurrentTimeInSeconds();
    header.Opcode = DNS_OPCODE_IQUERY;

    //
    //  optional name server to query?
    //

    aipservers = pDnsServerArray;
    if ( !aipservers )
    {
        aipservers = DnsQueryConfigAlloc(
                        DnsConfigDnsServerList,
                        NULL );
    }
    if ( !aipservers )
    {
        printf( "Update failed:  no DNS server list available.\n" );
        return( GetLastError() );
    }

    //
    //  flags?
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }
    arg = Argv[0];
    if ( strncmp( arg, "-f", 2 ) == 0 )
    {
        flags = strtoul( arg+2, NULL, 16 );
        Argc--;
        Argv++;
    }

    //
    //  build update packet RRs
    //

    prr = buildRecordList(
                Argc,
                Argv );
    if ( !prr )
    {
        status = GetLastError();
        if ( status != ERROR_SUCCESS )
        {
            printf( "ERROR:  building records from arguments\n" );
            goto Usage;
        }
    }

    //
    //  build \ send update
    //

    status = QueryDirectEx(
                & pmsgRecv,
                NULL,           // no response records
                & header,       // header with IQUERY set
                TRUE,           // no copy header count fields
                NULL,           // no question
                0,              // no question type
                prr,            // record list built
                0,              // flags
                aipservers,     // server IP list
                NULL            // no adapter list
                );
    if ( pmsgRecv )
    {
        DnsPrint_Message(
            dnsup_PrintRoutine,
            dnsup_PrintContext,
            "IQUERY response:\n",
            pmsgRecv );
    }

    FREE_HEAP( aipservers );
    Dns_RecordListFree( prr );
    FREE_HEAP( pmsg );
    FREE_HEAP( pmsgRecv );

    if( status != ERROR_SUCCESS )
    {
        printf(
            "QueryDirectExEx failed, %x %s.\n",
            status,
            DnsStatusString(status) );
    }
    else
    {
        printf( "IQUERY successfully completed.\n" );
    }
    return( status );

Usage:

    FREE_HEAP( aipservers );
    Dns_RecordListFree( prr );
    FREE_HEAP( pmsg );
    FREE_HEAP( pmsgRecv );

    printf(
        "usage:\n"
        "  DnsUp [-n<DNS IP>|...] -iq [-f<Flags>] [<Record> | ...]\n"
        "   <DNS IP> optional IP address of server to send update to.\n"
        "   <ServerName> name of DNS server we are sending update to;\n"
        "       presence of server name automatically turns on update security\n"
        "   <ZoneName> name of zone to update\n"
        "   <Record> record for update packet\n"
        "   <Record> == (-,+)(p,u,a) <Name> <Type> [Data | ...]\n"
        "       (-,+) - add or delete, exist or no-exist flag\n"
        "       (p,u,a) - prereq, update or additional section\n"
        "       <Name> - RR owner name\n"
        "       <Type> - record type\n"
        "       <Data> - data strings (type specific), if any\n"
        );
    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessValidateName(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    DNS_STATUS      status;
    PCHAR           pszname;
    DWORD           format;

    //
    //  name to validate
    //

    if ( Argc != 2 )
    {
        goto Usage;
    }
    pszname = Argv[0];
    Argc--;
    Argv++;

    //
    //  name format
    //

    if ( Argc )
    {
        format = strtoul( Argv[0], NULL, 10 );
    }

    //
    //  validate
    //

    status = DnsValidateName_A(
                pszname,
                format );

    printf(
        "DnsValidateName( %s, %d ) status = %d %s.\n",
        pszname,
        format,
        status,
        DnsStatusString(status) );

    return( status );

Usage:

    printf(
        "DnsValidateName\n"
        "usage:\n"
        "  DnsUp -vn <Name> <Format>\n"
        "   <Name> DNS name to validate\n"
        "   <Format> format of name\n"
        "\tDomainName       -- %d\n"
        "\tDomainLabel      -- %d\n"
        "\tHostnameFull     -- %d\n"
        "\tHostnameLabel    -- %d\n"
        "\tWildcard         -- %d\n"
        "\tSrvRecord        -- %d\n",
        DnsNameDomain,
        DnsNameDomainLabel,
        DnsNameHostnameFull,
        DnsNameHostnameLabel,
        DnsNameWildcard,
        DnsNameSrvRecord
        );
    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessNameCompare(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    BOOL    result;
    PCHAR   pszname1;
    PCHAR   pszname2;

    //
    //  names to compare
    //

    if ( Argc != 2 )
    {
        goto Usage;
    }
    pszname1 = Argv[0];
    pszname2 = Argv[1];

    //
    //  compare
    //

    result = DnsNameCompare_A(
                pszname1,
                pszname2 );

    printf(
        "DnsNameCompare( %s, %s ) result = %s.\n",
        pszname1,
        pszname2,
        result ? "TRUE" : "FALSE"
        );

    return( ERROR_SUCCESS );

Usage:

    printf(
        "DnsNameCompare\n"
        "usage:\n"
        "  DnsUp -nc <Name1> <Name2>\n"
        "   <Name1> <Name2> DNS names to compare.\n"
        );
    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessNameCompareEx(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    DNS_STATUS      status;
    PCHAR           pszname1;
    PCHAR           pszname2;

    //
    //  names to compare
    //

    if ( Argc != 2 )
    {
        goto Usage;
    }
    pszname1 = Argv[0];
    pszname2 = Argv[1];

    //
    //  compare
    //

    status = DnsNameCompareEx_A(
                pszname1,
                pszname2,
                0 );

    printf(
        "DnsNameCompareEx( %s, %s ) result = %d.\n",
        pszname1,
        pszname2,
        status
        );

    return( ERROR_SUCCESS );

Usage:

    printf(
        "DnsNameCompareEx\n"
        "usage:\n"
        "  DnsUp -cnx <Name1> <Name2>\n"
        "   <Name1> <Name2> DNS names to compare.\n"
        "Compare Result:\n"
        "\tNot Equal            -- %d\n"
        "\tEqual                -- %d\n"
        "\tLeft is Ancestor     -- %d\n"
        "\tRight is Ancestor    -- %d\n"
        "\tInvalid Name         -- %d\n",
        DnsNameCompareNotEqual,
        DnsNameCompareEqual,
        DnsNameCompareLeftParent,
        DnsNameCompareRightParent,
        DnsNameCompareInvalid
        );
    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessStringTranslate(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    DNS_STATUS      status;
    WCHAR           unicodeString[ DNS_MAX_NAME_LENGTH ];
    WCHAR           unicodeStandard[ DNS_MAX_NAME_LENGTH ];
    BYTE            utf8Standard[ DNS_MAX_NAME_LENGTH ];
    PWCHAR          punicode;
    PCHAR           putf8;
    DWORD           unicodeLength;
    DWORD           utf8Length;
    DWORD           unicodeLengthStandard;


    //
    //  string translate
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }

    //
    //  read in unicode characters
    //

    unicodeLength = 0;
    while ( Argc )
    {
        unicodeString[ unicodeLength++] = (WORD) strtoul( Argv[0], NULL, 16 );
        Argc--;
        Argv++;
    }
    unicodeString[ unicodeLength ] = 0;

    DnsPrint_UnicodeStringBytes(
        dnsup_PrintRoutine,
        dnsup_PrintContext,
        "DnsStringTranslate().\n"
        "Input string",
        unicodeString,
        unicodeLength );

    //
    //  convert to UTF8 -- my way and their way
    //

    putf8 = Dns_StringCopyAllocate(
                (PCHAR) unicodeString,
                0,
                DnsCharSetUnicode,
                DnsCharSetUtf8 );
    if ( !putf8 )
    {
        return( DNS_ERROR_NO_MEMORY );
    }

    utf8Length = WideCharToMultiByte(
                    CP_UTF8,
                    0,                  // no flags
                    (PWCHAR) unicodeString,
                    (-1),               // null terminated
                    utf8Standard,
                    MAXWORD,            // assuming adequate length
                    NULL,
                    NULL );

    DnsPrint_Utf8StringBytes(
        dnsup_PrintRoutine,
        dnsup_PrintContext,
        "My UTF8",
        putf8,
        strlen(putf8) );

    DnsPrint_Utf8StringBytes(
        dnsup_PrintRoutine,
        dnsup_PrintContext,
        "Standard UTF8",
        utf8Standard,
        strlen(utf8Standard) );

    //
    //  convert back to unicode
    //

    punicode = Dns_StringCopyAllocate(
                    (PCHAR) utf8Standard,
                    0,
                    DnsCharSetUtf8,
                    DnsCharSetUnicode );

    unicodeLengthStandard = MultiByteToWideChar(
                                CP_UTF8,
                                0,                  // no flags
                                (PCHAR) utf8Standard,
                                (-1),               // null terminated
                                (PWCHAR) unicodeStandard,
                                MAXWORD             // assuming adequate length
                                );

    DnsPrint_UnicodeStringBytes(
        dnsup_PrintRoutine,
        dnsup_PrintContext,
        "My unicode",
        punicode,
        wcslen(punicode) );

    DnsPrint_UnicodeStringBytes(
        dnsup_PrintRoutine,
        dnsup_PrintContext,
        "Standard unicode",
        unicodeStandard,
        wcslen(unicodeStandard) );

    status = ERROR_SUCCESS;
    return( status );

Usage:

    printf(
        "usage:\n"
        "  DnsUp -s [unicode chars in hex]\n"
        );
    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessQueryConfig(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
#define CONFIG_BUF_SIZE  (100)

    DNS_STATUS      status;
    DNS_CONFIG_TYPE config;
    PCHAR           psznext;
    PCHAR           pendString;
    PWSTR           pwsadapter = NULL;
    DWORD           flag = 0;
    BOOL            ballocated = FALSE;
    BOOL            bsleep = FALSE;
    DWORD           bufLength = 0;
    DWORD           sentBufLength;
    PBYTE           pbuffer = NULL;
    PBYTE           pallocResult;
    BYTE            buffer[ CONFIG_BUF_SIZE ];


    //
    //  query config
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }

    //  config value

    config = strtoul( Argv[0], &pendString, 10 );
    Argc--;
    Argv++;

    //  flag?

    while ( Argc )
    {
        psznext = Argv[0];

        //  flag

        if ( !_stricmp( psznext, "-f" ) ||
             !_stricmp( psznext, "/f" ) )
        {
            Argc--;
            Argv++;
            flag = strtoul( Argv[0], &pendString, 16 );
            Argc--;
            Argv++;

            if ( flag & DNS_CONFIG_FLAG_ALLOC )
            {
                bufLength = sizeof(PVOID);
                pbuffer = buffer;
            }
            continue;
        }

        //  length input

        if ( !_stricmp( psznext, "-l" ) ||
             !_stricmp( psznext, "/l" ) )
        {
            Argc--;
            Argv++;
            bufLength = strtoul( Argv[0], &pendString, 16 );
            Argc--;
            Argv++;
            continue;
        }

        //  sleep?

        if ( !_stricmp( psznext, "-s" ) ||
             !_stricmp( psznext, "/s" ) )
        {
            Argc--;
            Argv++;
            bsleep = TRUE;
            continue;
        }

        //  buffer

        if ( !_stricmp( psznext, "-b" ) ||
             !_stricmp( psznext, "/b" ) )
        {
            Argc--;
            Argv++;
            pbuffer = buffer;
            bufLength = CONFIG_BUF_SIZE;
            continue;
        }

        //  adapter name

        else
        {
            pwsadapter = DnsStringCopyAllocateEx(
                            Argv[0],
                            0,
                            DnsCharSetAnsi,         // ANSI in
                            DnsCharSetUnicode       // unicode out
                            );
            continue;
        }
    }

    //
    //  query DNS config
    //

    sentBufLength = bufLength;

    status = DnsQueryConfig(
                config,
                flag,
                pwsadapter,
                NULL,
                pbuffer,
                & bufLength );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DnsQueryConfig() successful.\n"
            "\tflag             = 0x%.8X\n"
            "\tadapter          = %s\n"
            "\tsent length      = %d\n"
            "\tlength required  = %d\n",
            flag,
            pwsadapter,
            sentBufLength,
            bufLength );

        if ( !pbuffer )
        {
            return( status );
        }

        printf(
            "\tbuffer = %02x %02x %02x %02x ...\n",
            pbuffer[0],
            pbuffer[1],
            pbuffer[2],
            pbuffer[3] );

        if ( flag & DNS_CONFIG_FLAG_ALLOC )
        {
            pbuffer = * (PVOID *) pbuffer;
        }

        switch( config )
        {

        case DnsConfigPrimaryDomainName_W:

            printf(
                "Primary domain name = %S\n",
                pbuffer );
            break;

        case DnsConfigPrimaryDomainName_A:
        case DnsConfigPrimaryDomainName_UTF8:

            printf(
                "Primary domain name = %s\n",
                pbuffer );
            break;

        case DnsConfigDnsServerList:

            DnsPrint_IpArray(
                dnsup_PrintRoutine,
                dnsup_PrintContext,
                "DNS server list",
                NULL,
                (PIP_ARRAY) pbuffer );
            break;

        case DnsConfigPrimaryHostNameRegistrationEnabled:

            printf(
                "Is Primary registration enabled = %d\n",
                *(PBOOL)pbuffer );
            break;

        case DnsConfigAdapterHostNameRegistrationEnabled:

            printf(
                "Is Adapter registration enabled = %d\n",
                *(PBOOL)pbuffer );
            break;

        case DnsConfigAddressRegistrationMaxCount:

            printf(
                "Max IP registration count = %d\n",
                *(PDWORD)pbuffer );
            break;

        default:

            printf( "Unknown config %d", config );
        }
    }

    else if ( status == ERROR_MORE_DATA )
    {
        printf(
            "DnsQueryConfig() ERROR_MORE_DATA.\n"
            "\tsent length     = %d\n"
            "\tlength required = %d\n",
            sentBufLength,
            bufLength );
    }
    else
    {
        printf(
            "DnsQueryConfig() failed status = %d (0x%.8X).\n",
            status, status );
    }

    if ( bsleep )
    {
        printf( "Sleeping" );
        Sleep( MAXDWORD );
    }
    return( status );

Usage:

    printf(
        "usage:\n"
        "  DnsUp -config <Config> [-f <flag>] [-b] [-l <length>] [<adapter name>]\n"
        );

    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessReplaceRecordSet(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    DNS_STATUS      status;
    DWORD           flags = 0;
    PCHAR           arg;
    PDNS_RECORD     prr = NULL;
    HANDLE          hCreds=NULL;

    //
    //  flags?
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }
    arg = Argv[0];
    if ( strncmp( arg, "-f", 2 ) == 0 )
    {
        flags = strtoul( arg+2, NULL, 16 );
        Argc--;
        Argv++;
    }

    //
    //  build update packet RRs
    //

    prr = buildRecordList(
                Argc,
                Argv );
    if ( !prr )
    {
        status = GetLastError();
        if ( status != ERROR_SUCCESS )
        {
            printf( "ERROR:  building records from arguments\n" );
            goto Usage;
        }
    }

    //
    //  build \ send update
    //

    status = DnsReplaceRecordSetA(
                prr,
                flags,
                hCreds,
                NULL,       // no adapter list specified
                NULL        // reserved
                );

    Dns_RecordListFree( prr );

    if ( status != ERROR_SUCCESS )
    {
        printf(
            "DnsReplaceRecordSet failed, %x %s.\n",
            status,
            DnsStatusString(status) );
    }
    else
    {
        printf( "ReplaceRecordSet successfully completed.\n" );
    }
    return( status );

Usage:

    Dns_RecordListFree( prr );

    printf(
        "usage:\n"
        "  DnsUp -rs [-f<Flags>] [<Record> | ...]\n"
        "   <Record> record for update packet\n"
        "   <Record> == (+)(u) <Name> <Type> [Data | ...]\n"
        "       <Name>  - RR owner name\n"
        "       <Type>  - record type (ex A, SRV, PTR, TXT, CNAME, etc.)\n"
        "       <Data>  - data strings (type specific), if any\n"
        );
    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessModifyRecordsInSet(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    DNS_STATUS      status;
    DWORD           flags = 0;
    PCHAR           arg;
    PDNS_RECORD     prr;
    PDNS_RECORD     prrAdd = NULL;
    PDNS_RECORD     prrDelete = NULL;
    HANDLE          hCreds=NULL;
    INT             addCount;
    DNS_RRSET       rrsetDelete;
    DNS_RRSET       rrsetAdd;

    DNS_RRSET_INIT( rrsetAdd );
    DNS_RRSET_INIT( rrsetDelete );

    //
    //  flags?
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }

    //  flag?

    arg = Argv[0];
    if ( strncmp( arg, "-f", 2 ) == 0 )
    {
        flags = strtoul( arg+2, NULL, 16 );
        Argc--;
        Argv++;
    }

    //
    //  build update add RRs
    //

    prr = buildRecordList(
                Argc,
                Argv );
    if ( !prr )
    {
        status = GetLastError();
        if ( status != ERROR_SUCCESS )
        {
            printf( "ERROR:  building records from arguments\n" );
            goto Usage;
        }
    }

    //
    //  build separate Add and Delete lists
    //

    while ( prr )
    {
        if ( prr->Flags.S.Delete )
        {
            DNS_RRSET_ADD( rrsetDelete, prr );
        }
        else
        {
            DNS_RRSET_ADD( rrsetAdd, prr );
        }
        prr = prr->pNext;
    }

    DNS_RRSET_TERMINATE( rrsetAdd );
    DNS_RRSET_TERMINATE( rrsetDelete );

    //
    //  build \ send update
    //

    status = DnsModifyRecordsInSet_A(
                rrsetAdd.pFirstRR,
                rrsetDelete.pFirstRR,
                flags,
                hCreds,
                NULL,       // no adapter list specified
                NULL        // reserved
                );

    Dns_RecordListFree( rrsetAdd.pFirstRR );
    Dns_RecordListFree( rrsetDelete.pFirstRR );

    if ( status != ERROR_SUCCESS )
    {
        printf(
            "DnsModifyRecordsInSet failed, %x %s.\n",
            status,
            DnsStatusString(status) );
    }
    else
    {
        printf( "ModifyRecordsInSet successfully completed.\n" );
    }
    return( status );

Usage:

    Dns_RecordListFree( rrsetAdd.pFirstRR );
    Dns_RecordListFree( rrsetDelete.pFirstRR );

    printf(
        "usage:\n"
        "  DnsUp -mr [-f<Flags>] [<Record> | ...]\n"
        "   <Record> == (-,+)(u) <Name> <Type> [Data | ...]\n"
        "       (-,+)   - add or delete, exist or no-exist flag\n"
        "       <Name>  - RR owner name\n"
        "       <Type>  - record type (ex A, SRV, PTR, TXT, CNAME, etc.)\n"
        "       <Data>  - data strings (type specific), if any\n"
        );
    return( ERROR_INVALID_PARAMETER );
}



//
//  Winsock \ RnR
//

//
//  Protocol array for WSAQUERYSET
//
//  DCR:  may want to default to NULL instead?
//

AFPROTOCOLS g_ProtocolArray[2] =
{
    {   AF_INET,    IPPROTO_UDP },
    {   AF_INET,    IPPROTO_TCP }
};

//
//  Service GUIDs
//

GUID HostNameGuid       = SVCID_HOSTNAME;
GUID HostAddrByNameGuid = SVCID_INET_HOSTADDRBYNAME;
GUID AddressGuid        = SVCID_INET_HOSTADDRBYINETSTRING;
GUID IANAGuid           = SVCID_INET_SERVICEBYNAME;

typedef struct _GuidStringMap
{
    LPGUID      pGuid;
    LPSTR       pString;
};

struct _GuidStringMap GuidMapTable[] =
{
    & HostNameGuid          ,   "HostName"               ,
    & HostAddrByNameGuid    ,   "AddrByName"             ,
    & HostAddrByNameGuid    ,   "HostAddrByName"         ,
    & AddressGuid           ,   "HostAddrByInetString"   ,
    & IANAGuid              ,   "ServiceByName"          ,
    & IANAGuid              ,   "Iana"                   ,
    NULL                    ,   "NULL"                   ,
    NULL                    ,   NULL                     ,
};


PGUID
guidForString(
    IN      PSTR            pszGuidName
    )
/*++

Routine Description:

    Get GUID for string.

    This is to allow simple specification of command line for GUIDs.

Arguments:

    pszGuidName -- name of desired GUID
        (see table above for current names of common guids)

Return Value:

    Ptr to desired GUID if found.
    Errors default to hostname (host lookup) GUID.

--*/
{
    DWORD   i;
    PCHAR   pname;

    //
    //  if no guid name, use host name guid
    //

    if ( !pszGuidName )
    {
        return  &HostNameGuid;
    }

    //
    //  find guid matching name in table
    //

    i = 0;

    while ( pname = GuidMapTable[i].pString )
    {
        if ( _stricmp( pname, pszGuidName ) == 0 )
        {
            return  GuidMapTable[i].pGuid;
        }
        i++;
    }

    //  default to HostName guid

    return  &HostNameGuid;
}



//
//  Parsing utility
//

typedef struct _RnRParseBlob
{
    HANDLE          Handle;
    PCHAR           pBuffer;
    PWSAQUERYSET    pQuerySet;
    PGUID           pGuid;
    PSTR            pName;
    DWORD           Flags;
    DWORD           NameSpace;
    DWORD           BufferLength;
}
RNR_PARSE_BLOB, *PRNR_PARSE_BLOB;


VOID
printRnRArgHelp(
    VOID
    )
/*++

Routine Description:

    Print RnR argument usage.

Arguments:

    None

Return Value:

    None

--*/
{
    //
    //  describe standard RnR lookup arguements
    //
    //  DCR:  add flag, ptr validity check
    //  DCR:  add "already set" check for names and guids
    //  DCR:  fix zero flag case below
    //

    printf(
        "\tRnR Arguments:\n"
        "\t\t-h<handle>     --  ptr in hex to lookup handle\n"
        "\t\t-b<buffer>     --  ptr in hex to result buffer to use\n"
        "\t\t-l<buf length> --  buffer length to use\n"
        "\t\t-f<flag>       --  RnR control flag in hex or LUP_X mneumonic\n"
        "\t\t                   may be multiple flags specified\n"
        "\t\t-q<query set>  --  ptr in hex to existing WSAQUERYSET struct\n"
        "\t\t-i<name space> --  name space id NS_X mneumonic\n"
        "\t\t-a<name>       --  ANSI lookup name\n"
        "\t\t-g<guid>       --  NS GUID mneumonic:\n"
        "\t\t                       HostName\n"           
        "\t\t                       HostAddrByName\n"
        "\t\t                       HostAddrByInetString\n"
        "\t\t                       ServiceByName\n"
        );
}



DNS_STATUS
parseForRnr(
    IN      DWORD           Argc,
    IN      PSTR  *         Argv,
    OUT     PRNR_PARSE_BLOB pBlob
    )
/*++

Routine Description:

    Parse RnR routine command line params.

    This is to simplify avoid duplicate parsing for various RnR
    functions.

Arguments:

    Argc -- argc

    Argv -- argument array

    pBlob -- ptr to RnR parsing blob to be filled by function

Return Value:

    ERROR_SUCCESS if successful parsing.
    ErrorCode on parsing error.
    (Note, currently errors are ignored and whatever parsing is possible
    is completed.)

--*/
{
    PCHAR   parg;

    //
    //  init parse blob
    //

    RtlZeroMemory(
        pBlob,
        sizeof(RNR_PARSE_BLOB) );

    //
    //  read arguments
    //
    //  DCR:  add flag, ptr validity check
    //  DCR:  add "already set" check for names and guids
    //  DCR:  fix zero flag case below
    //

    while ( Argc )
    {
        parg = Argv[0];

        if ( strncmp( parg, "-h", 2 ) == 0 )
        {
            pBlob->Handle = (PVOID) (ULONG_PTR) strtoul( parg+2, NULL, 16 );
        }
        else if ( strncmp( parg, "-f", 2 ) == 0 )
        {
            DWORD   thisFlag;

            thisFlag = strtoul( parg+2, NULL, 16 );
            if ( thisFlag == 0 )
            {
                thisFlag = Dns_RnrLupFlagForString( parg+2, 0 );
            }
            pBlob->Flags |= thisFlag;
        }
        else if ( strncmp( parg, "-b", 2 ) == 0 )
        {
            pBlob->pBuffer = (PBYTE) (ULONG_PTR) strtoul( parg+2, NULL, 16 );
        }
        else if ( strncmp( parg, "-l", 2 ) == 0 )
        {
            pBlob->BufferLength = strtoul( parg+2, NULL, 10 );
        }
        else if ( strncmp( parg, "-a", 2 ) == 0 )
        {
            pBlob->pName = parg+2;
        }
        else if ( strncmp( parg, "-g", 2 ) == 0 )
        {
            pBlob->pGuid = guidForString( parg+2 );
        }
        else if ( strncmp( parg, "-i", 2 ) == 0 )
        {
            pBlob->NameSpace = Dns_RnrNameSpaceIdForString(
                                    parg+2,
                                    0       // length unknown
                                    );
        }
        else if ( strncmp( parg, "-q", 2 ) == 0 )
        {
            pBlob->pQuerySet = (PWSAQUERYSET) (ULONG_PTR) strtoul( parg+2, NULL, 16 );
        }
        else if ( *parg=='?' || strncmp( parg, "-?", 2 ) == 0 )
        {
            goto Usage;
        }
        else
        {
            printf( "Unknown Arg = %s\n", parg );
            goto Usage;
        }
        Argc--;
        Argv++;
    }

    return( ERROR_SUCCESS );

Usage:

    printRnRArgHelp();

    return( ERROR_INVALID_PARAMETER );
}



PWSAQUERYSET
buildWsaQuerySet(
    IN      PRNR_PARSE_BLOB pBlob
    )
/*++

Routine Description:

    Create (allocate) a query set.

Arguments:

    pBlob -- ptr to blob of parsing info

Return Value:

    Ptr to new WSAQUERYSET struct.
    NULL on allocation failure.

--*/
{
    PWSAQUERYSET    pwsaq;

    //
    //  allocate
    //

    pwsaq = ALLOCATE_HEAP_ZERO( sizeof(WSAQUERYSET) );
    if ( !pwsaq )
    {
        return( NULL );
    }

    //
    //  basic
    //      - default GUID to hostname lookup
    //

    pwsaq->dwSize                   = sizeof(WSAQUERYSET);
    pwsaq->dwNumberOfProtocols      = 2;
    pwsaq->lpafpProtocols           = g_ProtocolArray;
    pwsaq->lpServiceClassId         = & HostNameGuid;

    //
    //  tack on info from blob
    //      - keep parsing generic by casting name to TSTR
    // 

    if ( pBlob )
    {
        pwsaq->dwNameSpace              = pBlob->NameSpace;
        pwsaq->lpszServiceInstanceName  = (LPTSTR) pBlob->pName;
        pwsaq->lpServiceClassId         = pBlob->pGuid;
    }

    return  (PWSAQUERYSET) pwsaq;
}



DNS_STATUS
ProcessLookupServiceBegin(
    IN      DWORD           Argc,
    IN      PSTR  *         Argv
    )
{
    DNS_STATUS      status;
    HANDLE          handle = NULL;
    PWSAQUERYSET    pquerySet = NULL;
    PWSAQUERYSET    pquerySetLocal = NULL;
    RNR_PARSE_BLOB  blob;

    //
    //  WSALookupServiceBegin 
    //

    //
    //  parse args
    //

    status = parseForRnr( Argc, Argv, &blob );

    if ( status != ERROR_SUCCESS )
    {
        goto Usage;
    }

    //
    //  setup query set
    //

    pquerySet = blob.pQuerySet;

    if ( !pquerySet )
    {
        pquerySet = buildWsaQuerySet( &blob );
        pquerySetLocal = pquerySet;
    }

    IF_DNSDBG( INIT )
    {
        DnsDbg_WsaQuerySet(
            "Query set to WLSBegin",
            pquerySet,
            FALSE           // currently ANSI
            );
    }

    DnsPrint_WsaQuerySet(
        dnsup_PrintRoutine,
        dnsup_PrintContext,
        "QuerySet to LookupServiceBegin",
        (PWSAQUERYSET) pquerySet,
        FALSE           // ANSI call
        );

    //
    //  force winsock start
    //

    Dns_InitializeWinsock();

    //
    //  call 
    //

    status = WSALookupServiceBeginA(
                pquerySet,
                blob.Flags,
                & handle );

    if ( status != ERROR_SUCCESS )
    {
        status = GetLastError();

        printf(
            "WSALookupServiceBegin( %p, %08x, %p ) failed, %d %s.\n",
            pquerySet,
            blob.Flags,
            & handle,
            status,
            DnsStatusString(status) );

        if ( pquerySetLocal )
        {
            FREE_HEAP( pquerySetLocal );
        }
    }
    else
    {
        printf(
            "WSALookupServiceBegin() succeeded.\n"
            "\thandle   = %p\n"
            "\tqueryset = %p\n",
            handle,
            pquerySet );
    }
    return( status );

Usage:

    printf(
        "WSALookupServiceBegin\n"
        "usage:\n"
        "  DnsUp -lsb [RnR args]\n"
        "       note handle arg does not apply\n"
        );

    printRnRArgHelp();

    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessLookupServiceNext(
    IN      DWORD           Argc,
    IN      PSTR  *         Argv
    )
{
    DNS_STATUS      status;
    HANDLE          handle = NULL;
    PCHAR           pbuf = NULL;
    PCHAR           pbufLocal = NULL;
    DWORD           bufLength;
    RNR_PARSE_BLOB  blob;

    //
    //  WSALookupServiceNext 
    //

    //
    //  parse args
    //

    status = parseForRnr( Argc, Argv, &blob );
    if ( status != ERROR_SUCCESS )
    {
        goto Usage;
    }

    //
    //  if no handle need to do WLSBegin
    //

    handle = blob.Handle;
    if ( !handle )
    {
        goto Usage;
    }

    //
    //  setup buffer
    //

    bufLength = blob.BufferLength;
    pbuf = blob.pBuffer;

    if ( !pbuf && bufLength )
    {
        pbuf = ALLOCATE_HEAP( blob.BufferLength );
        if ( !pbuf )
        {
            status = DNS_ERROR_NO_MEMORY;
        }
        pbufLocal = pbuf;
    }

    //
    //  call 
    //

    printf(
        "Enter WSALookupServiceNext()\n"
        "\thandle   = %p\n"
        "\tflag     = %08x\n"
        "\tlength   = %p (%d)\n"
        "\tbuffer   = %p\n",
        handle,
        blob.Flags,
        &bufLength, bufLength,
        pbuf );

    status = WSALookupServiceNextA(
                handle,
                blob.Flags,
                & bufLength,
                (PWSAQUERYSETA) pbuf );

    if ( status != ERROR_SUCCESS )
    {
        status = GetLastError();

        printf(
            "WSALookupServiceNext( h=%p, f=%08x, len=%d, buf=%p ) failed, %d %s.\n",
            handle,
            blob.Flags,
            bufLength,
            pbuf,
            status,
            DnsStatusString(status) );

        if ( pbufLocal )
        {
            FREE_HEAP( pbufLocal );
        }
    }
    else
    {
        printf(
            "WSALookupServiceNext() succeeded.\n"
            "\thandle       = %p\n"
            "\tbuf length   = %d\n"
            "\tpbuffer      = %p\n",
            handle,
            bufLength,
            pbuf );

        if ( pbuf )
        {
            DnsPrint_WsaQuerySet(
                dnsup_PrintRoutine,
                dnsup_PrintContext,
                "Result from LookupServiceNext",
                (PWSAQUERYSET) pbuf,
                FALSE           // ANSI call
                );
        }
    }
    return( status );

Usage:

    printf(
        "WSALookupServiceNext\n"
        "usage:\n"
        "  DnsUp -lsn [RnR args]\n"
        "       valid WSALookupServiceNext args:\n"
        "           <handle> <flags> <buffer> <buf length>\n"
        "       <handle> is required, call WSALookupServiceBegin\n"
        "           to get handle to use with this function\n"
        );

    printRnRArgHelp();

    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessLookupServiceEnd(
    IN      DWORD           Argc,
    IN      PSTR  *         Argv
    )
{
    DNS_STATUS      status;
    HANDLE          handle;

    //
    //  WSALookupServiceEnd <handle>
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }

    //  read handle
    //
    //  DCR:  need QWORD read to handle win64 case

    handle = (HANDLE) (UINT_PTR) strtoul( Argv[0], NULL, 16 );

    //
    //  call 
    //

    status = WSALookupServiceEnd( handle );
    if ( status != ERROR_SUCCESS )
    {
        printf(
            "WSALookupServiceEnd( %p ) failed, %d %s.\n",
            handle,
            status,
            DnsStatusString(status) );
    }
    else
    {
        printf(
            "WSALookupServiceEnd( %p ) succeeded.\n",
            handle );
    }

    Dns_CleanupWinsock();

    return( status );

Usage:

    printf(
        "WSALookupServiceEnd\n"
        "usage:\n"
        "  DnsUp -lse -h<handle>\n"
        "       <handle>  - lookup handle to close in hex.\n"
        "           handle is from prior WSALookupServiceBegin call.\n"
        );
    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessGetHostName(
    IN      DWORD           Argc,
    IN      PSTR  *         Argv
    )
{
    DNS_STATUS      status;
    CHAR            nameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];
    DWORD           length = DNS_MAX_NAME_BUFFER_LENGTH;
    PCHAR           pname = nameBuffer;
    INT             result;

    //
    //  gethostname [-n<name>] [-l<length>]
    //

    if ( Argc > 2 )
    {
        goto Usage;
    }

    //
    //  get optional name or length
    //      - defaults to full size buffer above
    //

    while ( Argc )
    {
        PCHAR   arg = Argv[0];

        if ( strncmp( arg, "-n", 2 ) == 0 )
        {
            pname = getNamePointer( arg+2 );
            Argc--;
            Argv++;
        }
        else if ( strncmp( arg, "-l", 2 ) == 0 )
        {
            length = strtoul( arg+2, NULL, 10 );
            Argc--;
            Argv++;
        }
        else
        {
            goto Usage;
        }
    }

    //
    //  force winsock start
    //

    Dns_InitializeWinsock();

    //
    //  call 
    //

    result = gethostname( (PSTR)pname, length );

    if ( result != 0 )
    {
        status = GetLastError();

        printf(
            "gethostname(), %d (%x) %s.\n",
            status, status,
            DnsStatusString(status) );
    }
    else
    {
        printf(
            "gethostname() successfully completed.\n"
            "\tname = %s\n",
            pname );
    }
    return( status );

Usage:

    printf(
        "gethostname\n"
        "usage:\n"
        "  DnsUp -ghn [-n<Name>] [-l<length>]\n"
        "       <Name>   - one of special names.\n"
        "       <Length> - buffer length to pass in\n"
        "       Defaults to valid name buffer of full DNS name length\n"
        );
    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessGetHostByName(
    IN      DWORD           Argc,
    IN      PSTR  *         Argv
    )
{
    DNS_STATUS      status;
    PCHAR           pname;
    PHOSTENT        phost;

    //
    //  gethostbyname <name>
    //

    if ( Argc != 1 )
    {
        goto Usage;
    }

    //  name

    pname = getNamePointer( Argv[0] );

    //
    //  force winsock start
    //

    Dns_InitializeWinsock();

    //
    //  call 
    //

    phost = gethostbyname( (PCSTR)pname );

    status = GetLastError();

    if ( !phost )
    {
        printf(
            "gethostbyname(), %x %s.\n",
            status,
            DnsStatusString(status) );
    }
    else
    {
        printf( "gethostbyname successfully completed.\n" );

        DnsPrint_Hostent(
            dnsup_PrintRoutine,
            dnsup_PrintContext,
            NULL,       // default header
            phost,
            FALSE       // ANSI
            );
    }
    return( status );

Usage:

    printf(
        "gethostbyname\n"
        "usage:\n"
        "  DnsUp -ghbn <Name>\n"
        "       <Name>  - DNS name to query.\n"
        "           \"NULL\" for null input.\n"
        "           \"blank\" for blank (empty string)\n"
        );
    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessGetHostByAddr(
    IN      DWORD           Argc,
    IN      PSTR  *         Argv
    )
{
    DNS_STATUS      status;
    PCHAR           pname;
    PCHAR           paddr;
    PHOSTENT        phost;
    IP6_ADDRESS     ip6;
    INT             length;
    INT             family;

    //
    //  gethostbyaddr <ip> [len] [family]
    //

    if ( Argc < 1 || Argc > 3 )
    {
        goto Usage;
    }

    //
    //  address
    //

    pname = getNamePointer( Argv[0] );
    Argc--;
    Argv++;

    length = sizeof(IP6_ADDRESS);
    family = 0;

    if ( pname
            &&
         Dns_StringToAddress_A(
                (PCHAR) & ip6,
                & length,
                pname,
                & family ) )
    {
        paddr = (PCHAR) &ip6;
    }
    else
    {
        paddr = pname;
        length = sizeof(IP4_ADDRESS);
        family = AF_INET;
    }

    //  length -- optional

    if ( Argc )
    {
        length = strtoul( Argv[0], NULL, 10 );
        Argc--;
        Argv++;
    }

    //  family -- optional

    if ( Argc )
    {
        family = strtoul( Argv[0], NULL, 10 );
        Argc--;
        Argv++;
    }

    //
    //  force winsock start
    //

    Dns_InitializeWinsock();

    //
    //  call 
    //

    printf(
        "calling gethostbyaddr( %p, %d, %d )\n",
        paddr,
        length,
        family );

    phost = gethostbyaddr(
                (PSTR)paddr,
                length,
                family );

    status = GetLastError();

    if ( !phost )
    {
        printf(
            "gethostbyaddr(), %d %s.\n",
            status,
            DnsStatusString(status) );
    }
    else
    {
        printf( "gethostbyaddr successfully completed.\n" );

        DnsPrint_Hostent(
            dnsup_PrintRoutine,
            dnsup_PrintContext,
            NULL,       // default header
            phost,
            FALSE       // ANSI
            );
    }
    return( status );

Usage:

    printf(
        "gethostbyaddr\n"
        "usage:\n"
        "  DnsUp -ghba <Address> [<length>] [<family>]\n"
        "       <Name>  - DNS name to query.\n"
        "           \"null\" for null input.\n"
        "           \"blank\" for blank (empty string)\n"
        "       [length] - length of address\n"
        "           defaults to sizeof(IP_ADDRESS)\n"
        "       [family] - address family\n"
        "           AF_INET     = %d\n"
        "           AF_INET6    = %d\n"
        "           AF_ATM      = %d\n"
        "           defaults to AF_INET\n",
        AF_INET,
        AF_INET6,
        AF_ATM );

    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessGetAddrInfo(
    IN      DWORD           Argc,
    IN      PSTR  *         Argv
    )
{
    DNS_STATUS      status;
    PCHAR           pname;
    PSTR            pservice = NULL;
    PADDRINFO       phint = NULL;
    PADDRINFO       paddrInfo = NULL;
    ADDRINFO        hintAddrInfo;
    BOOL            fhint = FALSE;
    INT             result;

    //
    //  getaddrinfo <name> [service] [hints]
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }

    //
    //  name
    //

    pname = getNamePointer( Argv[0] );
    Argc--;
    Argv++;

    //
    //  setup hints
    //      - default flags to include canonnical name
    //

    RtlZeroMemory(
        & hintAddrInfo,
        sizeof(hintAddrInfo) );

    hintAddrInfo.ai_flags = AI_CANONNAME;


    //
    //  get optional service name or hints
    //

    while ( Argc )
    {
        PCHAR   arg = Argv[0];

        if ( strncmp( arg, "-s", 2 ) == 0 )
        {
            pservice = getNamePointer( arg+2 );
            Argc--;
            Argv++;
        }
        if ( strncmp( arg, "-h", 2 ) == 0 )
        {
            fhint = TRUE;
            Argc--;
            Argv++;
        }
        else if ( strncmp( arg, "-f", 2 ) == 0 )
        {
            hintAddrInfo.ai_flags = strtoul( arg+2, NULL, 16 );
            fhint = TRUE;
            Argc--;
            Argv++;
        }
        else if ( strncmp( arg, "-m", 2 ) == 0 )
        {
            hintAddrInfo.ai_family = strtoul( arg+2, NULL, 10 );
            fhint = TRUE;
            Argc--;
            Argv++;
        }
        else if ( strncmp( arg, "-t", 2 ) == 0 )
        {
            hintAddrInfo.ai_socktype = strtoul( arg+2, NULL, 10 );
            fhint = TRUE;
            Argc--;
            Argv++;
        }
        else if ( strncmp( arg, "-p", 2 ) == 0 )
        {
            hintAddrInfo.ai_protocol = strtoul( arg+2, NULL, 10 );
            fhint = TRUE;
            Argc--;
            Argv++;
        }
        else if ( strncmp( arg, "-l", 2 ) == 0 )
        {
            hintAddrInfo.ai_addrlen = strtoul( arg+2, NULL, 10 );
            fhint = TRUE;
            Argc--;
            Argv++;
        }
        else
        {
            goto Usage;
        }
    }

    //
    //  setup hints
    //

    if ( fhint )
    {
        phint = &hintAddrInfo;
    }

    //
    //  force winsock start
    //

    Dns_InitializeWinsock();

    //
    //  call 
    //

    printf(
        "calling getaddrinfo()\n"
        "\tpname            = %s\n"
        "\tpservice         = %s\n"
        "\tphint            = %p\n"
        "\tpaddrinfo buf    = %p\n",
        pname,
        pservice,
        phint,
        paddrInfo );

    if ( phint )
    {
        DnsPrint_AddrInfo(
            dnsup_PrintRoutine,
            dnsup_PrintContext,
            "hint addrinfo",
            1,          // indent
            phint
            );
    }

    result = getaddrinfo(
                pname,
                pservice,
                phint,
                & paddrInfo );

    status = GetLastError();

    if ( result != NO_ERROR )
    {
        printf(
            "getaddrinfo(), %x %s.\n",
            status,
            DnsStatusString(status) );
    }
    else
    {
        printf( "getaddrinfo successfully completed.\n" );

        DnsPrint_AddrInfo(
            dnsup_PrintRoutine,
            dnsup_PrintContext,
            NULL,       // default header
            0,          // no indent
            paddrInfo
            );

        freeaddrinfo( paddrInfo );
    }
    return( status );

Usage:

    printf(
        "getaddrinfo\n"
        "usage:\n"
        "  DnsUp -gai <Name> [-s<Service>] [-h] [-f<flags>] [-m<family>]\n"
        "                    [-p<Protocol>] [-t<SockType>] [-l<length>]\n"
        "       <Name>  - DNS name to query.\n"
        "           \"null\" for null input.\n"
        "           \"blank\" for blank (empty string)\n"
        "       <Service>  - service name to query for.\n"
        "       [-h] - use hints (this allows empty hint buffer\n"
        "       <flags> - hint flags\n"
        "           AI_PASSIVE      = %0x\n"
        "           AI_CANONNAME    = %0x\n"
        "           AI_NUMERICHOST  = %0x\n"
        "       <family> - hint family\n"
        "           AF_INET         = %d\n"
        "           AF_INET6        = %d\n"
        "           AF_ATM          = %d\n"
        "       <socktype>  - hint socket type\n"
        "       <protocol>  - hint protocol\n"
        "       <length>    - hint address length\n",

        AI_PASSIVE,
        AI_CANONNAME,
        AI_NUMERICHOST,

        AF_INET,
        AF_INET6,
        AF_ATM );

    return( ERROR_INVALID_PARAMETER );
}



DNS_STATUS
ProcessGetNameInfo(
    IN      DWORD           Argc,
    IN      PSTR  *         Argv
    )
{
    DNS_STATUS      status;
    BOOL            result;
    PCHAR           paddr = NULL;
    DWORD           addrLength;
    DWORD           family;
    DWORD           flags = 0;

    SOCKADDR_IN6    sockaddr;
    CHAR            hostBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];
    CHAR            serviceBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];

    PSOCKADDR_IN6   psockaddr = &sockaddr;
    PCHAR           pservice = serviceBuffer;
    PCHAR           phost = hostBuffer;
    DWORD           sockaddrLength = sizeof(sockaddr);
    DWORD           serviceLength = sizeof(hostBuffer);
    DWORD           hostLength = DNS_MAX_NAME_BUFFER_LENGTH;


    //
    //  getnameinfo <address> [sockaddr fields | args]
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }

    //
    //  address
    //

    RtlZeroMemory(
        psockaddr,
        sizeof(*psockaddr) );

#if 0
    if ( getAddressPointer(
                Argv[0],
                & paddr,
                & addrLength,
                & family ) )
    {
        sockaddr.sin6_family = (SHORT) family;

        if ( family == AF_INET )
        {
            RtlCopyMemory(
                & ((PSOCKADDR_IN)psockaddr)->sin_addr,
                paddr,
                addrLength );

            sockaddrLength = sizeof(SOCKADDR_IN);
        }
        else    // IP6
        {
            RtlCopyMemory(
                & psockaddr->sin6_addr,
                paddr,
                addrLength );

            sockaddrLength = sizeof(SOCKADDR_IN6);
        }
    }
    else    // special bogus address, use it directly
    {
        psockaddr = (PSOCKADDR_IN6) paddr;
    }
#endif
    if ( getAddressPointer(
                Argv[0],
                & paddr,
                & addrLength,
                & family ) )
    {
        status = Dns_AddressToSockaddr(
                        (PSOCKADDR) &sockaddr,
                        & sockaddrLength,
                        TRUE,       // clear
                        paddr,
                        addrLength,
                        family );

        if ( status != NO_ERROR )
        {
            goto Usage;
        }
    }
    else    // special bogus address, use it directly
    {
        psockaddr = (PSOCKADDR_IN6) paddr;
    }

    Argc--;
    Argv++;

    //
    //  get sockaddr fields or optional arguments
    //      - note, if using bogus sockaddr, the sockaddr tweaks are lost
    //

    while ( Argc )
    {
        PCHAR   arg = Argv[0];

        //  flags

        if ( strncmp( arg, "-f", 2 ) == 0 )
        {
            flags = strtoul( arg+2, NULL, 16 );
            Argc--;
            Argv++;
        }

        //  sockaddr subfields

        else if ( strncmp( arg, "-m", 2 ) == 0 )
        {
            sockaddr.sin6_family = (SHORT) strtoul( arg+2, NULL, 10 );
            Argc--;
            Argv++;
        }
        else if ( strncmp( arg, "-p", 2 ) == 0 )
        {
            sockaddr.sin6_port = (SHORT) strtoul( arg+2, NULL, 10 );
            Argc--;
            Argv++;
        }

        //  tweak out params

        else if ( strncmp( arg, "-sl", 3 ) == 0 )
        {
            serviceLength = strtoul( arg+3, NULL, 10 );
            Argc--;
            Argv++;
        }
        else if ( _strnicmp( arg, "-snull", 5 ) == 0 )
        {
            pservice = NULL;
            Argc--;
            Argv++;
        }
        else if ( strncmp( arg, "-hl", 3 ) == 0 )
        {
            hostLength = strtoul( arg+3, NULL, 10 );
            Argc--;
            Argv++;
        }
        else if ( _strnicmp( arg, "-hnull", 5 ) == 0 )
        {
            phost = NULL;
            Argc--;
            Argv++;
        }
        else
        {
            goto Usage;
        }
    }

    //
    //  force winsock start
    //

    Dns_InitializeWinsock();

    //
    //  call 
    //

    printf(
        "Calling getnameinfo()\n"
        "\tsockaddr         %p\n"
        "\tsockaddr len     %d\n"
        "\thost buffer      %p\n"
        "\thost buflen      %d\n"
        "\tservice buffer   %p\n"
        "\tservice buflen   %d\n"
        "\tflags            %08x\n",
        psockaddr,
        sockaddrLength,
        phost,
        hostLength,
        pservice,
        serviceLength,
        flags );

    DnsPrint_Sockaddr(
        dnsup_PrintRoutine,
        dnsup_PrintContext,
        "\n\tsockaddr",
        1,      // indent
        (PSOCKADDR) psockaddr,
        sockaddrLength );

    result = getnameinfo(
                (PSOCKADDR) psockaddr,
                sockaddrLength,
                phost,
                hostLength,
                pservice,
                serviceLength,
                flags );

    status = GetLastError();

    if ( result != NO_ERROR )
    {
        printf(
            "getnameinfo(), %x %s.\n",
            status,
            DnsStatusString(status) );
    }
    else
    {
        printf(
            "getnameinfo successfully completed.\n"
            "\thost     = %s\n"
            "\tservice  = %s\n",
            phost,
            pservice );
    }
    return( status );

Usage:

    printf(
        "getnameinfo\n"
        "usage:\n"
        "  DnsUp -gni <Address> [-s<Service>] [-f<flags>] [-m<family>]\n"
        "               [-p<port>] [-sl<length>] [-snull] [-hl<length>] [-hnull]\n"
        "       <Address>  - Address string to query name for.\n"
        "           \"null\" for null input.\n"
        "           \"blank\" for blank (empty string)\n"
        "       <flags> - hint flags\n"
        "           AI_PASSIVE      = %0x\n"
        "           AI_CANONNAME    = %0x\n"
        "           AI_NUMERICHOST  = %0x\n"
        "       <family> - sockaddr family, overrides default for address;\n"
        "           AF_INET         = %d\n"
        "           AF_INET6        = %d\n"
        "           AF_ATM          = %d\n"
        "       <port> - port to set in sockaddr;  defaults to zero\n"
        "       <length> - length of out buffer\n"
        "           -sl<length> - length of service name buffer\n"
        "           -hl<length> - length of host name buffer\n"
        "       [-snull] - server buffer ptr NULL\n"
        "       [-hnull] - host buffer ptr NULL\n",

        AI_PASSIVE,
        AI_CANONNAME,
        AI_NUMERICHOST,

        AF_INET,
        AF_INET6,
        AF_ATM );

    return( ERROR_INVALID_PARAMETER );
}




DNS_STATUS
ProcessClusterIp(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    SOCKADDR_IN6    sockaddr;
    PSOCKADDR       psockaddr = (PSOCKADDR) &sockaddr;
    DWORD           sockaddrLength = sizeof(sockaddr);
    IP_ADDRESS      ip;
    BOOL            fadd = TRUE;
    PWSTR           pname = NULL;
    DNS_STATUS      status;

    //
    //  -ci <Name> <IP> [-d]
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }

    //
    //  name
    //

    pname = (PWSTR) Dns_StringCopyAllocate(
                        Argv[0],
                        0,              // unknown length
                        DnsCharSetAnsi,
                        DnsCharSetUnicode );
    Argc--;
    Argv++;

    //
    //  cluster IP
    //

#if 0
    ip = inet_addr( Argv[0] );
    if ( ip == (-1) )
    {
        goto Usage;
    }
    Argc--;
    Argv++;
#endif

    if ( !getSockaddrFromString(
                & psockaddr,
                & sockaddrLength,
                Argv[0] ) )
    {
        goto Usage;  
    }
    Argc--;
    Argv++;

    //
    //  optional delete flag
    //

    if ( Argc > 0 )
    {
        if ( strncmp( Argv[0], "-d", 2 ) == 0 )
        {
            fadd = FALSE;
            Argc--;
            Argv++;
        }
        if ( Argc != 0 )
        {
            goto Usage;
        }
    }

    //
    //  notify resolver
    //

    status = DnsRegisterClusterAddress(
                0xd734453d,
                pname,
                psockaddr,
                fadd );

    FREE_HEAP( pname );
    return( status );

Usage:

    printf(
        "Set Cluster IP\n"
        "usage:\n"
        "  DnsUp [-ci] <Name> <IP> [-d]\n"
        "   <Name> is cluster name\n"
        "   <IP> is cluster IP\n"
        "   [-d] to indicate delete of cluster IP\n"
        );

    FREE_HEAP( pname );
    return( ERROR_INVALID_PARAMETER );
}



#if 0
DNS_STATUS
ProcessAddIp(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    IP_ADDRESS      ip;
    BOOL            fadd = TRUE;

    //
    //  -addip <IP>
    //

    if ( Argc < 1 )
    {
        goto Usage;
    }

    //
    //  IP to add
    //

    ip = inet_addr( Argv[0] );
    if ( ip == (-1) )
    {
        goto Usage;
    }
    Argc--;
    Argv++;

    //
    //  optional delete flag
    //

    if ( Argc > 0 )
    {
        if ( strncmp( Argv[0], "-d", 2 ) == 0 )
        {
            fadd = FALSE;
            Argc--;
            Argv++;
        }
        if ( Argc != 0 )
        {
            goto Usage;
        }
    }

    //
    //  notify resolver
    //

    DnsNotifyResolverClusterIp(
        ip,
        fadd );

    return( ERROR_SUCCESS );

Usage:

    printf(
        "usage:\n"
        "  DnsUp [-ci] <IP> [-d]\n"
        "   <IP> is cluster IP\n"
        "   [-d] to indicate delete of cluster IP\n"
        );
    return( ERROR_INVALID_PARAMETER );
}
#endif



DNS_STATUS
ProcessSetEnvironmentVariable(
    IN      DWORD           Argc,
    IN      PSTR *          Argv
    )
{
    //
    //  setenv <name> <value>
    //

    if ( Argc < 1 || Argc > 2 )
    {
        goto Usage;
    }

    SetEnvironmentVariableA(
        Argv[0],
        (Argc == 2) ? Argv[1] : NULL );

    return( ERROR_SUCCESS );

Usage:

    printf(
        "Set environment variable\n"
        "usage:\n"
        "  DnsUp [-setenv] <name> [<value>]\n"
        "   <name> name of environment variable\n"
        "   <value> value of environment variable, if missing\n"
        "     then environment variable is deleted\n"
        );
    return( ERROR_INVALID_PARAMETER );
}



//
//  Command Table
//
//  Keep this down here to avoid having prototypes for
//  all these functions.
//

COMMAND_INFO GlobalCommandInfo[] =
{
    //  query

    { "qex"     ,   "QueryEx"               ,   ProcessQueryEx          },
    { "qc"      ,   "QueryCompare"          ,   ProcessQueryCompare     },
    { "q"       ,   "Query"                 ,   ProcessQuery            },
    { "qm"      ,   "QueryMulitple"         ,   ProcessQueryMultiple    },
    { "qt"      ,   "QueryTest"             ,   ProcessQueryTest        },
    { "iq"      ,   "IQuery"                ,   ProcessIQuery           },

    //  update

    { "u"       ,   "Update"                ,   ProcessUpdate               },
    { "ut"      ,   "UpdateTest"            ,   ProcessUpdateTest           },
    //{ "um"      ,   "UpdateMultiple"        ,   ProcessUpdateMultiple       },
    { "dt"      ,   "DhcpTest"              ,   ProcessDhcpTest             },
    { "mr"      ,   "ModifyRecordsInSet"    ,   ProcessModifyRecordsInSet   },
    { "rs"      ,   "ReplaceRecordSet"      ,   ProcessReplaceRecordSet     },

    //  utility

    { "vn"      ,   "ValidateName"          ,   ProcessValidateName         },
    { "s"       ,   "StringTranslate"       ,   ProcessStringTranslate      },
    { "cn"      ,   "NameCompare"           ,   ProcessNameCompare          },
    { "cnx"     ,   "NameCompareEx"         ,   ProcessNameCompareEx        },
    { "config"  ,   "QueryConfig"           ,   ProcessQueryConfig          },

    //  config

    { "setenv"  ,   "SetEnvironmentVariable",   ProcessSetEnvironmentVariable   },

    //  resolver

    { "ci"      ,   "ClusterIp"             ,   ProcessClusterIp            },

    //  RnR

    { "ghn"     ,   "gethostname"           ,   ProcessGetHostName          },
    { "ghbn"    ,   "gethostbyname"         ,   ProcessGetHostByName        },
    { "ghba"    ,   "gethostbyaddr"         ,   ProcessGetHostByAddr        },
    { "gai"     ,   "getaddrinfo"           ,   ProcessGetAddrInfo          },
    { "gni"     ,   "getnameinfo"           ,   ProcessGetNameInfo          },
    { "lsb"     ,   "LookupServiceBegin"    ,   ProcessLookupServiceBegin   },
    { "lsn"     ,   "LookupServiceNext"     ,   ProcessLookupServiceNext    },
    { "lse"     ,   "LookupServiceEnd"      ,   ProcessLookupServiceEnd     },

    //  quit

    { "quit"    ,   "Quit"                  ,   ProcessQuit             },
    { "exit"    ,   "Quit"                  ,   ProcessQuit             },

    { NULL, NULL, NULL },
};

//
//  End dnsup.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\resolver\client\rslvrcli.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    rslvrcli.h

Abstract:

    Common header for Workstation client-side code.

Author:

    Glenn Curtis    (glennc)    01-Mar-1997

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _RSLVRCLI_INCLUDED_
#define _RSLVRCLI_INCLUDED_


#endif // _RSLVRCLI_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\resolver\client\test\dns_cache.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dnsrslvr.h>

extern LPWSTR NetworkAddress;

#define COMPUTE_STRING_HASH_2( _String, _ulHashTableSize, _lpulHash ) \
        {                                           \
            PWCHAR _p = _String;                    \
            PWCHAR _ep = _p + wcslen( _String );    \
            ULONG  h = 0;                           \
                                                    \
            while( _p < _ep )                       \
            {                                       \
                h <<= 1;                            \
                h ^= *_p++;                         \
            }                                       \
                                                    \
            *_lpulHash = h % _ulHashTableSize;      \
        }


VOID
GetStringA( char * );

VOID
GetStringW( WCHAR * );

VOID
PrintMenu( VOID );

VOID
DoFlushCache( VOID );

VOID
DoFlushCacheEntry( VOID );

VOID
DoFlushCacheEntryForType( VOID );

VOID
DoTrimCache( VOID );

VOID
DoReadCacheEntry( VOID );

VOID
DoQuery( VOID );

VOID
DoQueryThenCache( VOID );

VOID
DoDisplayCache( VOID );

VOID
DoGetAdapterInfo( VOID );

VOID
DoGetSearchList( VOID );

VOID
DoGetPrimaryDomainName( VOID );

VOID
DoGetIpAddressList( VOID );

VOID
DoGetHashTableStats( VOID );

VOID
DoGetHashTableIndex( VOID );

VOID
DoUpdateTest( VOID );

VOID
PrintServerInfo( PDNS_RPC_SERVER_INFO );

VOID
PrintIpAddress ( DWORD IpAddress );

VOID
PrintRecords (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintARecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintSOARecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintPTRRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintMINFORecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintMXRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintHINFORecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintNULLRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintWKSRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintAAAARecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintSRVRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintWINSRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintWINSRRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
GetCachedData(
    IN  LPWSTR Name,
    IN  WORD   Type );

_cdecl
main(int argc, char **argv)
{
    char  String[256];
    WCHAR usNetName[100];
    LONG  cch;
    DWORD Status = NO_ERROR;

    if ( argc == 2 )
    {
        cch = MultiByteToWideChar( CP_ACP,
                                   0L,
                                   argv[1],
                                   -1,
                                   usNetName,
                                   100 );

        if ( !cch )
        {
             Status = GetLastError();
             printf("Error %ux in MultiByteToWideChar\n", Status );
             return (Status);
        }

        NetworkAddress = usNetName;
    }

Menu :

    PrintMenu();
    GetStringA( String );
    printf( "\n" );

    switch( atoi( String ) )
    {
        case 1 :
            DoFlushCache();
            break;

        case 2 :
            DoFlushCacheEntry();
            break;

        case 3 :
            DoFlushCacheEntryForType();
            break;

        case 4 :
            DoTrimCache();
            break;

        case 5 :
            DoReadCacheEntry();
            break;

        case 6 :
            DoQuery();
            break;

        case 7 :
            DoQueryThenCache();
            break;

        case 8 :
            DoDisplayCache();
            break;

        case 9 :
            DoUpdateTest();
            break;

        case 10 :
            DoGetAdapterInfo();
            break;

        case 11 :
            DoGetSearchList();
            break;

        case 12 :
            DoGetPrimaryDomainName();
            break;

        case 13 :
            DoGetIpAddressList();
            break;

        case 14 :
            DoGetHashTableStats();
            break;

        case 15 :
            DoGetHashTableIndex();
            break;

        case 16 :
            return( -1 );

        default :
            printf( "Invalid option\n" );
    }

    goto Menu;
}


VOID
GetStringA( char * String )
{
    WORD iter = 0;
    char ch = getchar();

    while ( ch != 0x0a )
    {
        String[iter] = ch;
        ch = getchar();
        iter++;
    }

    String[iter] = 0;
}


VOID
GetStringW( WCHAR * String )
{
    WORD  iter = 0;
    WCHAR ch = getchar();

    while ( ch != 0x0a )
    {
        String[iter] = ch;
        ch = getchar();
        iter++;
    }

    String[iter] = 0;
}


VOID
PrintMenu( VOID )
{
    printf( "\n" );
    printf( "------------------------------------------------------\n" );
    printf( "|         DNS Caching Resolver Service Client        |\n" );
    printf( "------------------------------------------------------\n" );
    printf( "|                                                    |\n" );
    printf( "| 1)  Flush cache                                    |\n" );
    printf( "| 2)  Flush a specific cache entry                   |\n" );
    printf( "| 3)  Flush a specific record set from a cache entry |\n" );
    printf( "| 4)  Trim cache (gets rid of records with old ttls) |\n" );
    printf( "| 5)  Read a cache entry's record set                |\n" );
    printf( "| 6)  Query records for a DNS name and type          |\n" );
    printf( "| 7)  Query records then CacheRecordSet              |\n" );
    printf( "| 8)  Display cache contents                         |\n" );
    printf( "| 9)  Perform update test with local machine account |\n" );
    printf( "| 10) Get the net adapter info for this machine      |\n" );
    printf( "| 11) Get the DNS search list for this machine       |\n" );
    printf( "| 12) Get the Primary Domain Name for this machine   |\n" );
    printf( "| 13) Get the list of IP addresses for this machine  |\n" );
    printf( "| 14) Get the DNS resolver cache statistics          |\n" );
    printf( "| 15) Compute the hash table index for a name        |\n" );
    printf( "| 16) Quit                                           |\n" );
    printf( "|                                                    |\n" );
    printf( ">>> " );
}


VOID
PrintIpAddress ( DWORD IpAddress )
{
    printf( "   %d.%d.%d.%d\n",
            ((BYTE *) &IpAddress)[0],
            ((BYTE *) &IpAddress)[1],
            ((BYTE *) &IpAddress)[2],
            ((BYTE *) &IpAddress)[3] );
}


VOID
DoFlushCache( VOID )
{
    DWORD Status = NO_ERROR;

    RpcTryExcept
    {
        CRrFlushCache( NULL );
    }
    RpcExcept(1)
    {
        Status = RpcExceptionCode();
    }
    RpcEndExcept

    if ( Status == RPC_S_SERVER_UNAVAILABLE ||
         Status == RPC_S_UNKNOWN_IF )
    {
        printf( "Error: DNS Caching Resolver Service is not running\n" );
        return;
    }
}


VOID
DoFlushCacheEntry( VOID )
{
    DWORD Status = NO_ERROR;
    WCHAR Name[256];

    printf( "Name: " );
    GetStringW( Name );
    printf( "\n" );

    RpcTryExcept
    {
        CRrFlushCacheEntry( NULL, Name );
    }
    RpcExcept(1)
    {
        Status = RpcExceptionCode();
    }
    RpcEndExcept

    if ( Status == RPC_S_SERVER_UNAVAILABLE ||
         Status == RPC_S_UNKNOWN_IF )
    {
        printf( "Error: DNS Caching Resolver Service is not running\n" );
        return;
    }
}


VOID
DoFlushCacheEntryForType( VOID )
{
    DWORD Status = NO_ERROR;
    WCHAR Name[256];
    char  TypeStr[25];
    WORD  Type;

    printf( "Name: " );
    GetStringW( Name );
    printf( "\n" );

    printf( "Type (0, 1, 2, etc): " );
    GetStringA( TypeStr );
    printf( "\n" );
    Type = atoi( TypeStr );

    RpcTryExcept
    {
        CRrFlushCacheEntryForType( NULL, Name, Type );
    }
    RpcExcept(1)
    {
        Status = RpcExceptionCode();
    }
    RpcEndExcept

    if ( Status == RPC_S_SERVER_UNAVAILABLE ||
         Status == RPC_S_UNKNOWN_IF )
    {
        printf( "Error: DNS Caching Resolver Service is not running\n" );
        return;
    }
}


VOID
DoTrimCache( VOID )
{
    DWORD Status = NO_ERROR;

    RpcTryExcept
    {
        CRrTrimCache( NULL );
    }
    RpcExcept(1)
    {
        Status = RpcExceptionCode();
    }
    RpcEndExcept

    if ( Status == RPC_S_SERVER_UNAVAILABLE ||
         Status == RPC_S_UNKNOWN_IF )
    {
        printf( "Error: DNS Caching Resolver Service is not running\n" );
        return;
    }
}


VOID
DoReadCacheEntry( VOID )
{
    DNS_STATUS  DnsStatus = NO_ERROR;
    WCHAR       Name[256];
    char        TypeStr[25];
    WORD        Type;
    PDNS_RECORD pDNSRecord = NULL;

    printf( "Name: " );
    GetStringW( Name );
    printf( "\n" );

    printf( "Type (0, 1, 2, etc): " );
    GetStringA( TypeStr );
    printf( "\n" );
    Type = atoi( TypeStr );

    RpcTryExcept
    {
        DnsStatus = CRrReadCacheEntry( NULL, Name, Type, &pDNSRecord );
    }
    RpcExcept(1)
    {
        DnsStatus = RpcExceptionCode();
    }
    RpcEndExcept

    if ( DnsStatus == RPC_S_SERVER_UNAVAILABLE ||
         DnsStatus == RPC_S_UNKNOWN_IF )
    {
        printf( "Error: DNS Caching Resolver Service is not running\n" );
        return;
    }

    if ( DnsStatus )
    {
        LPSTR ErrorString = DnsStatusToErrorString_A( DnsStatus );

        printf( "Error: 0x%.8x (%s)\n",
                DnsStatus, ErrorString );
        return;
    }

    PrintRecords ( ( PDNS_RECORD ) pDNSRecord );

    DnsFreeRRSet( (PDNS_RECORD) pDNSRecord, TRUE );
}


VOID
DoQuery( VOID )
{
    DNS_STATUS  DnsStatus = NO_ERROR;
    WCHAR       Name[256];
    char        TypeStr[25];
    WORD        Type;
    PDNS_RECORD pDNSRecord = NULL;

    printf( "Name: " );
    GetStringW( Name );
    printf( "\n" );

    printf( "Type (0, 1, 2, etc): " );
    GetStringA( TypeStr );
    printf( "\n" );
    Type = atoi( TypeStr );

    RpcTryExcept
    {
        DnsStatus = CRrQuery( NULL,
                              Name,
                              Type,
                              0,
                              &pDNSRecord );
    }
    RpcExcept(1)
    {
        DnsStatus = RpcExceptionCode();
    }
    RpcEndExcept

    if ( DnsStatus == RPC_S_SERVER_UNAVAILABLE ||
         DnsStatus == RPC_S_UNKNOWN_IF )
    {
        printf( "Error: DNS Caching Resolver Service is not running\n" );
        return;
    }

    if ( DnsStatus )
    {
        LPSTR ErrorString = DnsStatusToErrorString_A( DnsStatus );

        printf( "Error: 0x%.8x (%s)\n",
                DnsStatus, ErrorString );
        return;
    }

    PrintRecords ( ( PDNS_RECORD ) pDNSRecord );

    DnsFreeRRSet( (PDNS_RECORD) pDNSRecord, TRUE );
}


VOID
DoQueryThenCache( VOID )
{
    DNS_STATUS  DnsStatus = NO_ERROR;
    WCHAR       Name[256];
    char        TypeStr[25];
    WORD        Type;
    PDNS_RECORD pDNSRecord = NULL;

    printf( "Name: " );
    GetStringW( Name );
    printf( "\n" );

    printf( "Type (0, 1, 2, etc): " );
    GetStringA( TypeStr );
    printf( "\n" );
    Type = atoi( TypeStr );

    RpcTryExcept
    {
        DnsStatus = CRrQuery( NULL,
                              Name,
                              Type,
                              0,
                              &pDNSRecord );
    }
    RpcExcept(1)
    {
        DnsStatus = RpcExceptionCode();
    }
    RpcEndExcept

    if ( DnsStatus == RPC_S_SERVER_UNAVAILABLE ||
         DnsStatus == RPC_S_UNKNOWN_IF )
    {
        printf( "Error: DNS Caching Resolver Service is not running\n" );
        return;
    }

    if ( DnsStatus )
    {
        LPSTR ErrorString = DnsStatusToErrorString_A( DnsStatus );

        printf( "CRrQuery returned error: 0x%.8x (%s)\n",
                DnsStatus, ErrorString );
        return;
    }

    PrintRecords ( ( PDNS_RECORD ) pDNSRecord );

    RpcTryExcept
    {
        DnsStatus = CRrCacheRecordSet( NULL,
                                       Name,
                                       Type,
                                       0,
                                       pDNSRecord );
    }
    RpcExcept(1)
    {
        DnsStatus = RpcExceptionCode();
    }
    RpcEndExcept

    if ( DnsStatus == RPC_S_SERVER_UNAVAILABLE ||
         DnsStatus == RPC_S_UNKNOWN_IF )
    {
        printf( "Error: DNS Caching Resolver Service is not running\n" );
        return;
    }

    if ( DnsStatus )
    {
        LPSTR ErrorString = DnsStatusToErrorString_A( DnsStatus );

        printf( "CRrCacheRecordSet returned error: 0x%.8x (%s)\n",
                DnsStatus, ErrorString );
        return;
    }

    DnsFreeRRSet( (PDNS_RECORD) pDNSRecord, TRUE );
}


VOID
DoDisplayCache( VOID )
{
    DNS_STATUS      DnsStatus = NO_ERROR;
    WCHAR           Name[256];
    char            TypeStr[25];
    WORD            Type;
    PDNS_RPC_CACHE_TABLE pDNSCacheTable = NULL;
    PDNS_RPC_CACHE_TABLE pTempDNSCacheTable = NULL;

    RpcTryExcept
    {
        DnsStatus = CRrReadCache( NULL,
                                  &pDNSCacheTable );
    }
    RpcExcept(1)
    {
        DnsStatus = RpcExceptionCode();
    }
    RpcEndExcept

    if ( DnsStatus == RPC_S_SERVER_UNAVAILABLE ||
         DnsStatus == RPC_S_UNKNOWN_IF )
    {
        printf( "Error: DNS Caching Resolver Service is not running\n" );
        return;
    }

    if ( DnsStatus )
    {
        LPSTR ErrorString = DnsStatusToErrorString_A( DnsStatus );

        printf( "Error: 0x%.8x (%s)\n",
                DnsStatus, ErrorString );
        return;
    }

    pTempDNSCacheTable = pDNSCacheTable;

    while ( pTempDNSCacheTable )
    {
        PDNS_RPC_CACHE_TABLE pNext = pTempDNSCacheTable->pNext;

        printf( "   %S\n", pTempDNSCacheTable->Name );
        printf( "   ------------------------------------------------------\n" );

        if ( pTempDNSCacheTable->Type1 != DNS_TYPE_ZERO )
        {
            printf( "      Type: %d\n", pTempDNSCacheTable->Type1 );
            GetCachedData( pTempDNSCacheTable->Name,
                           pTempDNSCacheTable->Type1 );
            printf( "\n" );
        }

        if ( pTempDNSCacheTable->Type2 != DNS_TYPE_ZERO )
        {
            printf( "      Type: %d\n", pTempDNSCacheTable->Type2 );
            GetCachedData( pTempDNSCacheTable->Name,
                           pTempDNSCacheTable->Type2 );
            printf( "\n" );
        }

        if ( pTempDNSCacheTable->Type3 != DNS_TYPE_ZERO )
        {
            printf( "      Type: %d\n", pTempDNSCacheTable->Type3 );
            GetCachedData( pTempDNSCacheTable->Name,
                           pTempDNSCacheTable->Type3 );
            printf( "\n" );
        }

        if ( pTempDNSCacheTable->Name )
            LocalFree( pTempDNSCacheTable->Name );

        LocalFree( pTempDNSCacheTable );

        pTempDNSCacheTable = pNext;
    }
}


VOID
DoUpdateTest( VOID )
{
    DNS_STATUS  DnsStatus = NO_ERROR;
    WCHAR       Name[256];
    char        lpAddress[256];
    char        TypeStr[25];
    WORD        Type;
    PDNS_RECORD pDNSRecord = NULL;
    PDNS_RECORD pTempDNSRecord = NULL;
    BYTE        Part1, Part2, Part3, Part4;
    IP_ADDRESS  Address;
    LPSTR       lpTemp = NULL;

    printf( "Name: " );
    GetStringW( Name );
    printf( "\n" );

    printf( "Server IP: " );
    GetStringA( lpAddress );
    printf( "\n" );

    lpTemp = strtok( lpAddress, "." );
    Part1 = atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    Part2 = atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    Part3 = atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    Part4 = atoi( lpTemp );

    ((BYTE *) &Address)[0] = Part1;
    ((BYTE *) &Address)[1] = Part2;
    ((BYTE *) &Address)[2] = Part3;
    ((BYTE *) &Address)[3] = Part4;

    printf( "\n  Sendine update test for name (%S) to server (%d.%d.%d.%d) ...\n\n",
            Name,
            Part1,
            Part2,
            Part3,
            Part4 );

    RpcTryExcept
    {
        DnsStatus = CRrUpdateTest( NULL,
                                   Name,
                                   0,
                                   Address );
    }
    RpcExcept(1)
    {
        DnsStatus = RpcExceptionCode();
    }
    RpcEndExcept

    if ( DnsStatus == RPC_S_SERVER_UNAVAILABLE ||
         DnsStatus == RPC_S_UNKNOWN_IF )
    {
        printf( "Error: DNS Caching Resolver Service is not running\n" );
        return;
    }

    if ( DnsStatus )
    {
        LPSTR ErrorString = DnsStatusToErrorString_A( DnsStatus );

        printf( "Error: 0x%.8x (%s)\n",
                DnsStatus, ErrorString );
        return;
    }
}


VOID
DoGetAdapterInfo( VOID )
{
    DNS_STATUS      DnsStatus = NO_ERROR;
    PDNS_RPC_ADAPTER_INFO pAdapterInfo = NULL;
    PDNS_RPC_ADAPTER_INFO pTempAdapterInfo;
    DWORD           iter = 1;

    RpcTryExcept
    {
        CRrGetAdapterInfo( NULL, &pAdapterInfo );
    }
    RpcExcept(1)
    {
        DnsStatus = RpcExceptionCode();
    }
    RpcEndExcept

    if ( DnsStatus == RPC_S_SERVER_UNAVAILABLE ||
         DnsStatus == RPC_S_UNKNOWN_IF )
    {
        printf( "Error: DNS Caching Resolver Service is not running\n" );
        return;
    }

    if ( DnsStatus )
    {
        LPSTR ErrorString = DnsStatusToErrorString_A( DnsStatus );

        printf( "Error: 0x%.8x (%s)\n",
                DnsStatus, ErrorString );
        return;
    }

    pTempAdapterInfo = pAdapterInfo;

    while ( pTempAdapterInfo )
    {
        printf( "   Net Adapter Info (%d):\n", iter );
        printf( "   -------------------------------------\n" );
        printf( "      pszAdapterDomainName : %s\n",
                pTempAdapterInfo->pszAdapterDomainName );
        printf( "      Flags : %d\n",
                pTempAdapterInfo->Flags );
        if ( pTempAdapterInfo->pServerInfo )
            PrintServerInfo( pTempAdapterInfo->pServerInfo );
        pTempAdapterInfo = pTempAdapterInfo->pNext;
        iter++;
    }
}


VOID
DoGetSearchList( VOID )
{
    DNS_STATUS           DnsStatus = NO_ERROR;
    PDNS_RPC_SEARCH_LIST pSearchList = NULL;
    PDNS_RPC_SEARCH_LIST pTempSearchList;

    RpcTryExcept
    {
        CRrGetSearchList( NULL, &pSearchList );
    }
    RpcExcept(1)
    {
        DnsStatus = RpcExceptionCode();
    }
    RpcEndExcept

    if ( DnsStatus == RPC_S_SERVER_UNAVAILABLE ||
         DnsStatus == RPC_S_UNKNOWN_IF )
    {
        printf( "Error: DNS Caching Resolver Service is not running\n" );
        return;
    }

    if ( DnsStatus )
    {
        LPSTR ErrorString = DnsStatusToErrorString_A( DnsStatus );

        printf( "Error: 0x%.8x (%s)\n",
                DnsStatus, ErrorString );
        return;
    }

    pTempSearchList = pSearchList;

    printf( "   Search List:\n" );
    printf( "   -------------------------------------\n" );
    while ( pTempSearchList )
    {
        printf( "       pszName :       %s\n", pTempSearchList->pszName );
        pTempSearchList = pTempSearchList->pNext;
    }
}


VOID
DoGetPrimaryDomainName( VOID )
{
    DNS_STATUS DnsStatus = NO_ERROR;
    LPSTR      PrimaryDomainName = NULL;

    RpcTryExcept
    {
        CRrGetPrimaryDomainName( NULL, &PrimaryDomainName );
    }
    RpcExcept(1)
    {
        DnsStatus = RpcExceptionCode();
    }
    RpcEndExcept

    if ( DnsStatus == RPC_S_SERVER_UNAVAILABLE ||
         DnsStatus == RPC_S_UNKNOWN_IF )
    {
        printf( "Error: DNS Caching Resolver Service is not running\n" );
        return;
    }

    if ( DnsStatus )
    {
        LPSTR ErrorString = DnsStatusToErrorString_A( DnsStatus );

        printf( "Error: 0x%.8x (%s)\n",
                DnsStatus, ErrorString );
        return;
    }

    printf( "   Primary Domain Name : %s\n", PrimaryDomainName );
}


VOID
DoGetIpAddressList( VOID )
{
    DNS_STATUS DnsStatus = NO_ERROR;
    PDNS_IP_ADDR_LIST pIpAddrList = NULL;
    DWORD      Count;
    DWORD      iter;

    RpcTryExcept
    {
        Count = CRrGetIpAddressList( NULL, &pIpAddrList );
    }
    RpcExcept(1)
    {
        DnsStatus = RpcExceptionCode();
    }
    RpcEndExcept

    if ( DnsStatus == RPC_S_SERVER_UNAVAILABLE ||
         DnsStatus == RPC_S_UNKNOWN_IF )
    {
        printf( "Error: DNS Caching Resolver Service is not running\n" );
        return;
    }

    if ( DnsStatus )
    {
        LPSTR ErrorString = DnsStatusToErrorString_A( DnsStatus );

        printf( "Error: 0x%.8x (%s)\n",
                DnsStatus, ErrorString );
        return;
    }

    if ( Count && pIpAddrList )
    {
        printf( "%d Ip Addresses returned :\n", Count );

        for ( iter = 0; iter < Count; iter++ )
        {
            printf( "(%d) \t", iter+1 );
            PrintIpAddress( pIpAddrList->AddressArray[iter].ipAddress );
            printf( "    \t" );
            PrintIpAddress( pIpAddrList->AddressArray[iter].subnetMask );
        }

        LocalFree( pIpAddrList );
    }
    else
    {
        printf( "No Ip Addresses found.\n" );
    }
}


VOID
DoGetHashTableStats( VOID )
{
    DNS_STATUS       Status = NO_ERROR;
    DWORD            CacheHashTableSize;
    DWORD            CacheHashTableBucketSize;
    DWORD            NumberOfCacheEntries;
    DWORD            NumberOfRecords;
    DWORD            NumberOfExpiredRecords;
    PDNS_STATS_TABLE pStatsTable = NULL;
    PDNS_STATS_TABLE pTempRow = NULL;

    RpcTryExcept
    {
        Status = CRrGetHashTableStats( NULL,
                                       &CacheHashTableSize,
                                       &CacheHashTableBucketSize,
                                       &NumberOfCacheEntries,
                                       &NumberOfRecords,
                                       &NumberOfExpiredRecords,
                                       &pStatsTable );
    }
    RpcExcept(1)
    {
        Status = RpcExceptionCode();
    }
    RpcEndExcept

    if ( Status == RPC_S_SERVER_UNAVAILABLE ||
         Status == RPC_S_UNKNOWN_IF )
    {
        printf( "Error: DNS Caching Resolver Service is not running\n" );
        return;
    }

    if ( Status )
    {
        LPSTR ErrorString = DnsStatusToErrorString_A( Status );

        printf( "Error: 0x%.8x (%s)\n",
                Status, ErrorString );
        return;
    }

    printf( "   DNS Cache Hash Table Statistics\n" );
    printf( "   -------------------------------------\n" );
    printf( "       Cache hash table size        : %d\n",
            CacheHashTableSize );
    printf( "       Cache hash table bucket size : %d\n",
            CacheHashTableBucketSize );
    printf( "       Number of cache entries      : %d\n",
            NumberOfCacheEntries );
    printf( "       Number of RR sets            : %d\n",
            NumberOfRecords );
    printf( "       Number of expired RR sets    : %d\n",
            NumberOfExpiredRecords );
    printf( "\n   DNS Cache Hast Table Histogram\n" );
    printf( "   -------------------------------------\n" );

    pTempRow = pStatsTable;

    while ( pTempRow )
    {
        PDWORD_LIST_ITEM pTempItem = pTempRow->pListItem;
        DWORD            count = 0;
        DWORD            iter;

        printf( "  |" );

        while ( pTempItem )
        {
            for ( iter = 0; iter < pTempItem->Value2; iter++ )
                printf( "x" );

            count += pTempItem->Value1 - pTempItem->Value2;
            pTempItem = pTempItem->pNext;
        }

        for ( iter = 0; iter < count; iter++ )
            printf( "*" );

        printf( "\n" );

        pTempRow = pTempRow->pNext;
    }
}


VOID
DoGetHashTableIndex( VOID )
{
    DWORD            Status = NO_ERROR;
    WCHAR            Name[256];
    DWORD            index;
    DWORD            CacheHashTableSize;
    DWORD            CacheHashTableBucketSize;
    DWORD            NumberOfCacheEntries;
    DWORD            NumberOfRecords;
    DWORD            NumberOfExpiredRecords;
    PDNS_STATS_TABLE pStatsTable = NULL;
    PDNS_STATS_TABLE pTempRow = NULL;

    RpcTryExcept
    {
        Status = CRrGetHashTableStats( NULL,
                                       &CacheHashTableSize,
                                       &CacheHashTableBucketSize,
                                       &NumberOfCacheEntries,
                                       &NumberOfRecords,
                                       &NumberOfExpiredRecords,
                                       &pStatsTable );
    }
    RpcExcept(1)
    {
        Status = RpcExceptionCode();
    }
    RpcEndExcept

    if ( Status == RPC_S_SERVER_UNAVAILABLE ||
         Status == RPC_S_UNKNOWN_IF )
    {
        printf( "Error: DNS Caching Resolver Service is not running\n" );
        return;
    }

    if ( Status )
    {
        LPSTR ErrorString = DnsStatusToErrorString_A( Status );

        printf( "Error: 0x%.8x (%s)\n",
                Status, ErrorString );
        return;
    }

    printf( "   CacheHashTableSize : %d\n", CacheHashTableSize );
    printf( "   CacheHashTableBucketSize : %d\n", CacheHashTableBucketSize );
    printf( "   NumberOfCacheEntries : %d\n", NumberOfCacheEntries );
    printf( "   NumberOfRecords : %d\n", NumberOfRecords );
    printf( "   NumberOfExpiredRecords : %d\n", NumberOfExpiredRecords );

    printf( "Name: " );
    GetStringW( Name );
    printf( "\n" );

    COMPUTE_STRING_HASH_2( Name, CacheHashTableSize, &index );

    printf( "   Hash table index for %S is : %d\n",
            Name,
            index );

    pTempRow = pStatsTable;
}


VOID
PrintServerInfo( IN  PDNS_RPC_SERVER_INFO pServerInfo )
{
    PDNS_RPC_SERVER_INFO pTempServerInfo = pServerInfo;
    DWORD                iter = 1;

    while ( pTempServerInfo )
    {
        printf( "       Server Info (%d):\n", iter );
        printf( "       -------------------------------------\n" );
        printf( "           ipAddress : %d.%d.%d.%d\n",
                ((BYTE *) &pTempServerInfo->ipAddress)[0],
                ((BYTE *) &pTempServerInfo->ipAddress)[1],
                ((BYTE *) &pTempServerInfo->ipAddress)[2],
                ((BYTE *) &pTempServerInfo->ipAddress)[3] );
        printf( "           Status : 0x%x\n", pTempServerInfo->Status );
        printf( "           Priority : %d\n", pTempServerInfo->Priority );
        pTempServerInfo = pTempServerInfo->pNext;
        iter++;
    }
}


VOID
PrintRecords (
    IN  PDNS_RECORD pDnsRecord )
{
    PDNS_RECORD pTemp = pDnsRecord;

    while ( pTemp )
    {
        PrintRecord( pTemp );
        pTemp = pTemp->pNext;
    }
}


VOID
PrintRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    if ( ! pDnsRecord )
        return;

    printf( "      Record Name :  %S\n", pDnsRecord->pName );
    printf( "      Record Type :  %d\n", pDnsRecord->wType );
    printf( "      Time To Live : %d (seconds)\n", pDnsRecord->dwTtl );
    printf( "      Data Length :  %d\n", pDnsRecord->wDataLength );

    if ( pDnsRecord->Flags.S.Section == DNSREC_QUESTION )
        printf( "      Section :      Question Record\n" );
    else if ( pDnsRecord->Flags.S.Section == DNSREC_ANSWER )
        printf( "      Section :      Answer Record\n" );
    else if ( pDnsRecord->Flags.S.Section == DNSREC_AUTHORITY )
        printf( "      Section :      Authority Record\n" );
    else
        printf( "      Section :      Additional Record\n" );

    switch( pDnsRecord->wType )
    {
        case DNS_TYPE_A :
            PrintARecord( pDnsRecord );
            break;

        case DNS_TYPE_SOA :
            PrintSOARecord( pDnsRecord );
            break;

        case DNS_TYPE_PTR :
        case DNS_TYPE_NS :
        case DNS_TYPE_CNAME :
        case DNS_TYPE_MB :
        case DNS_TYPE_MD :
        case DNS_TYPE_MF :
        case DNS_TYPE_MG :
        case DNS_TYPE_MR :
            PrintPTRRecord( pDnsRecord );
            break;

        case DNS_TYPE_MINFO :
        case DNS_TYPE_RP :
            PrintMINFORecord( pDnsRecord );
            break;

        case DNS_TYPE_MX :
        case DNS_TYPE_AFSDB :
        case DNS_TYPE_RT :
            PrintMXRecord( pDnsRecord );
            break;

        case DNS_TYPE_HINFO :
        case DNS_TYPE_ISDN :
        case DNS_TYPE_TEXT :
        case DNS_TYPE_X25 :
            PrintHINFORecord( pDnsRecord );
            break;

        case DNS_TYPE_NULL :
            PrintNULLRecord( pDnsRecord );
            break;

        case DNS_TYPE_WKS :
            PrintWKSRecord( pDnsRecord );
            break;

        case DNS_TYPE_AAAA :
            PrintAAAARecord( pDnsRecord );
            break;

        case DNS_TYPE_SRV :
            PrintSRVRecord( pDnsRecord );
            break;

        case DNS_TYPE_WINS :
            PrintWINSRecord( pDnsRecord );
            break;

        case DNS_TYPE_NBSTAT :
            PrintWINSRRecord( pDnsRecord );
            break;

        default :
            printf( "Don't know how to print record type %d\n", pDnsRecord->wType );
    }
}


VOID
PrintARecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "      A record :\n" );
    printf( "                     ipAddress = %d.%d.%d.%d\n",
            ((BYTE *) &pDnsRecord->Data.A.ipAddress)[0],
            ((BYTE *) &pDnsRecord->Data.A.ipAddress)[1],
            ((BYTE *) &pDnsRecord->Data.A.ipAddress)[2],
            ((BYTE *) &pDnsRecord->Data.A.ipAddress)[3] );
    printf( "\n" );
}


VOID
PrintSOARecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "      SOA record :\n" );
    printf( "                     pNamePrimaryServer = %S\n",
            pDnsRecord->Data.SOA.pNamePrimaryServer );
    printf( "                     pNameAdministrator = %S\n",
            pDnsRecord->Data.SOA.pNameAdministrator );
    printf( "                     dwSerialNo        = %d\n",
            pDnsRecord->Data.SOA.dwSerialNo );
    printf( "                     dwRefresh         = %d\n",
            pDnsRecord->Data.SOA.dwRefresh );
    printf( "                     dwRetry           = %d\n",
            pDnsRecord->Data.SOA.dwRetry );
    printf( "                     dwExpire          = %d\n",
            pDnsRecord->Data.SOA.dwExpire );
    printf( "                     dwDefaultTtl      = %d\n",
            pDnsRecord->Data.SOA.dwDefaultTtl );
    printf( "\n" );
}


VOID
PrintPTRRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "      PTR, NS, CNAME, MB, MD, MF, MG, MR record :\n" );
    printf( "                     nameHost          = %S\n",
            pDnsRecord->Data.PTR.pNameHost );
    printf( "\n" );
}


VOID
PrintMINFORecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "      MINFO, RP record :\n" );
    printf( "                     pNameMailbox       = %S\n",
            pDnsRecord->Data.MINFO.pNameMailbox );
    printf( "                     pNameErrorsMailbox = %S\n",
            pDnsRecord->Data.MINFO.pNameErrorsMailbox );
    printf( "\n" );
}


VOID
PrintMXRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "      MX, AFSDB, RT record :\n" );
    printf( "                     pNameExchange      = %S\n",
            pDnsRecord->Data.MX.pNameExchange );
    printf( "                     wPreference       = %d\n",
            pDnsRecord->Data.MX.wPreference );
    printf( "                     Pad               = %d\n",
            pDnsRecord->Data.MX.Pad );
    printf( "\n" );
}


VOID
PrintHINFORecord (
    IN  PDNS_RECORD pDnsRecord )
{
    DWORD iter;

    printf( "      HINFO, ISDN, TEXT, X25 record :\n" );
    printf( "                     dwStringCount     = %d\n",
            pDnsRecord->Data.HINFO.dwStringCount );
    for ( iter = 0; iter < pDnsRecord->Data.HINFO.dwStringCount; iter ++ )
    {
        printf( "                     pStringArray[%d] = %S\n",
                iter,
                pDnsRecord->Data.HINFO.pStringArray[iter] );
    }
    printf( "\n" );
}


VOID
PrintNULLRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "      NULL record :\n" );
    printf( "\n" );
}


VOID
PrintWKSRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "      WKS record :\n" );
    printf( "                     ipAddress = %d.%d.%d.%d\n",
            ((BYTE *) &pDnsRecord->Data.WKS.ipAddress)[0],
            ((BYTE *) &pDnsRecord->Data.WKS.ipAddress)[1],
            ((BYTE *) &pDnsRecord->Data.WKS.ipAddress)[2],
            ((BYTE *) &pDnsRecord->Data.WKS.ipAddress)[3] );
    printf( "                     chProtocol        = %d\n",
            pDnsRecord->Data.WKS.chProtocol );
    printf( "\n" );
}


VOID
PrintAAAARecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "      AAAA record :\n" );
    printf( "                     ipAddress = %d.%d.%d.%d\n",
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[0],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[1],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[2],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[3] );
    printf( "\n" );
}


VOID
PrintSRVRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "      SRV record :\n" );
    printf( "                     pNameTarget        = %S\n",
            pDnsRecord->Data.SRV.pNameTarget );
    printf( "                     wPriority         = %d\n",
            pDnsRecord->Data.SRV.wPriority );
    printf( "                     wWeight           = %d\n",
            pDnsRecord->Data.SRV.wWeight );
    printf( "                     wPort             = %d\n",
            pDnsRecord->Data.SRV.wPort );
    printf( "                     Pad               = %d\n",
            pDnsRecord->Data.SRV.Pad );
    printf( "\n" );
}


VOID
PrintWINSRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "      WINS record :\n" );
    printf( "                     dwMappingFlag     = %d\n",
            pDnsRecord->Data.WINS.dwMappingFlag );
    printf( "                     dwLookupTimeout   = %d\n",
            pDnsRecord->Data.WINS.dwLookupTimeout );
    printf( "                     dwCacheTimeout    = %d\n",
            pDnsRecord->Data.WINS.dwCacheTimeout );
    printf( "                     cWinsServerCount  = %d\n",
            pDnsRecord->Data.WINS.cWinsServerCount );
    printf( "\n" );
}


VOID
PrintWINSRRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "      NBSTAT record :\n" );
    printf( "                     dwMappingFlag     = %d\n",
            pDnsRecord->Data.WINSR.dwMappingFlag );
    printf( "                     dwLookupTimeout   = %d\n",
            pDnsRecord->Data.WINSR.dwLookupTimeout );
    printf( "                     dwCacheTimeout    = %d\n",
            pDnsRecord->Data.WINSR.dwCacheTimeout );
    printf( "                     pNameResultDomain  = %S\n",
            pDnsRecord->Data.WINSR.pNameResultDomain );
    printf( "\n" );
}


VOID
GetCachedData(
    IN  LPWSTR Name,
    IN  WORD   Type )
{
    PDNS_RECORD pDNSRecord = NULL;
    DNS_STATUS  DnsStatus = NO_ERROR;

    RpcTryExcept
    {
        DnsStatus = CRrReadCacheEntry( NULL, Name, Type, &pDNSRecord );
    }
    RpcExcept(1)
    {
        DnsStatus = RpcExceptionCode();
    }
    RpcEndExcept

    if ( DnsStatus == RPC_S_SERVER_UNAVAILABLE ||
         DnsStatus == RPC_S_UNKNOWN_IF )
    {
        printf( "Error: DNS Caching Resolver Service is not running\n" );
        return;
    }

    if ( DnsStatus )
    {
        LPSTR ErrorString = DnsStatusToErrorString_A( DnsStatus );

        printf( "Error: 0x%.8x (%s)\n",
                DnsStatus, ErrorString );
        return;
    }

    PrintRecords ( ( PDNS_RECORD ) pDNSRecord );

    DnsFreeRRSet( (PDNS_RECORD) pDNSRecord, TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\resolver\client\rpcmem.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    rpcmem.c

Abstract:

    Domain Name System (DNS) Resolver

    Header for RPC interface to resolver.
    Domain Name System (DNS) Library

    Copy resource record routines.

Author:

    Ram Viswanathan(ramv)      April, 1997

Revision History:

    Ram Viswanathan    April 28 Created
    
    Win95 and WinNT unification. Yippee!
    Contains functions that map MIDL_user_allocate
    and MIDL_user_free

--*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\resolver\idl\imports.h ===
#include <windef.h>

#ifdef MIDL_PASS
#define LPSTR   [string] char *
#define LPCSTR  [string] const char *
#define LPWSTR  [string] wchar_t *

#define LPTSTR  LPWSTR
#define PWSTR   LPWSTR
#define PSTR    LPSTR

#define PVOID   void *
#define VOID    void
#endif

#include <stdarg.h>
#include <winbase.h>
#include <wingdi.h>
#include <winspool.h>
#define _INC_WINDOWS
#include <winsock2.h>
#include <wsipx.h>
#include <nspapi.h>
#include <dnsapi.h>
#include <resrpc.h>
#include "..\..\dnsapi\registry.h"
//#include <rpc.h>
//#include <rpcndr.h>
//#include <rpcasync.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\resolver\idl\resrpc.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    resrpc.h

Abstract:

    Domain Name System (DNS) Resolver

    Header for RPC interface to resolver.

Author:

    Jim Gilroy (jamesg)         July 2000

Revision History:

--*/


#ifndef _RESRPC_INCLUDED_
#define _RESRPC_INCLUDED_


#ifndef _DNSAPI_INCLUDE_
#include <dnsapi.h>
#endif


//
//  Resolver service info
//
//  Note:  this stuff is not required for MIDL pass generation
//      but it is a convenient place to put information
//      that will be used on both server and client sides.
//

#define DNS_RESOLVER_SERVICE            L"dnscache"

#define RESOLVER_DLL                    TEXT("dnsrslvr.dll")
#define RESOLVER_INTERFACE_NAME_A       "DNSResolver"
#define RESOLVER_INTERFACE_NAME_W       L"DNSResolver"

#define RESOLVER_RPC_PIPE_NAME_W        (L"\\PIPE\\DNSRESOLVER")
#define RESOLVER_RPC_LPC_ENDPOINT_W     (L"DNSResolver")
#define RESOLVER_RPC_TCP_PORT_W         (L"")

#define RESOLVER_RPC_USE_LPC            0x1
#define RESOLVER_RPC_USE_NAMED_PIPE     0x2
#define RESOLVER_RPC_USE_TCPIP          0x4
#define RESOLVER_RPC_USE_ALL_PROTOCOLS  0xffffffff


//
//  Resolver proxy name (NULL by default).
//
//  This is used in client stuffs for binding and
//  referenced (and settable) in dnsapi.dll caller.
//

#ifndef MIDL_PASS
extern  LPWSTR  NetworkAddress;
#endif



//
//  DNS_RECORD
//
//  Note: defintion in windns.h is not MIDL_PASS compliant
//  because MIDL does not like union with variable lenght types
//

//
//  MIDL is not happy about unions
//  Define the union explicitly with the switch
//

#ifdef MIDL_PASS

typedef [switch_type(WORD)] union _DNS_RECORD_DATA_TYPES
{
    [case(DNS_TYPE_A)]      DNS_A_DATA     A;

    [case(DNS_TYPE_SOA)]    DNS_SOA_DATA   SOA;

    [case(DNS_TYPE_PTR,
          DNS_TYPE_NS,
          DNS_TYPE_CNAME,
          DNS_TYPE_MB,
          DNS_TYPE_MD,
          DNS_TYPE_MF,
          DNS_TYPE_MG,
          DNS_TYPE_MR)]     DNS_PTR_DATA   PTR;

    [case(DNS_TYPE_MINFO,
          DNS_TYPE_RP)]     DNS_MINFO_DATA MINFO;

    [case(DNS_TYPE_MX,
          DNS_TYPE_AFSDB,
          DNS_TYPE_RT)]     DNS_MX_DATA    MX;

#if 0
    //  RPC is not able to handle a proper TXT record definition
    //  note:  that if other types are needed they are fixed
    //      (or semi-fixed) size and may be accomodated easily
    [case(DNS_TYPE_HINFO,
          DNS_TYPE_ISDN,
          DNS_TYPE_TEXT,
          DNS_TYPE_X25)]    DNS_TXT_DATA   TXT;

    [case(DNS_TYPE_NULL)]   DNS_NULL_DATA  Null;
    [case(DNS_TYPE_WKS)]    DNS_WKS_DATA   WKS;
    [case(DNS_TYPE_TKEY)]   DNS_TKEY_DATA  TKEY;
    [case(DNS_TYPE_TSIG)]   DNS_TSIG_DATA  TSIG;
    [case(DNS_TYPE_WINS)]   DNS_WINS_DATA  WINS;
    [case(DNS_TYPE_NBSTAT)] DNS_WINSR_DATA WINSR;
#endif

    [case(DNS_TYPE_AAAA)]   DNS_AAAA_DATA  AAAA;
    [case(DNS_TYPE_SRV)]    DNS_SRV_DATA   SRV;
    [case(DNS_TYPE_ATMA)]   DNS_ATMA_DATA  ATMA;

    //
    //  DCR_QUESTION:  need default block in record data def?
    //
    //[default] ;
}
DNS_RECORD_DATA_TYPES;


//
//  Record \ RR set structure
//
//  Note:   The dwReserved flag serves to insure that the substructures
//          start on 64-bit boundaries.  Since adding the LONGLONG to
//          TSIG structure the compiler wants to start them there anyway
//          (to 64-align).  This insures that no matter what data fields
//          are present we are properly 64-aligned.
//
//          Do NOT pack this structure, as the substructures to be 64-aligned
//          for Win64.
//

#undef  PDNS_RECORD

typedef struct _DnsRecord
{
    struct _DnsRecord * pNext;
    LPTSTR              pName;
    WORD                wType;
    WORD                wDataLength; // Not referenced for DNS record types
                                     // defined above.
    DWORD               Flags;
    DWORD               dwTtl;
    DWORD               dwReserved;
    [switch_is(wType)] DNS_RECORD_DATA_TYPES Data;
}
DNS_RECORD, *PDNS_RECORD;

//
//  Header or fixed size of DNS_RECORD
//

#define DNS_RECORD_FIXED_SIZE       FIELD_OFFSET( DNS_RECORD, Data )
#define SIZEOF_DNS_RECORD_HEADER    DNS_RECORD_FIXED_SIZE

#endif  // MIDL_PASS



//
//  RPC-able DNS type definitions
//
//  In addition to windns.h \ dnsapi.h types.
//  See note below, we do have some multiple definition
//  problems with dnslib.h types.
//

//
//  Net adapter list structures
//

#ifndef ADDR_INFO_DEFINED

typedef struct _DnsAddrInfo
{
    IP4_ADDRESS     IpAddr;
    IP4_ADDRESS     SubnetMask;
}
DNS_ADDR_INFO, *PDNS_ADDR_INFO;

typedef struct _DnsAddrArray
{
    DWORD                               AddrCount;
#ifdef MIDL_PASS
    [size_is(AddrCount)] DNS_ADDR_INFO  AddrArray[];
#else
    DNS_ADDR_INFO                       AddrArray[0];
#endif
}
DNS_ADDR_ARRAY, *PDNS_ADDR_ARRAY;

#define ADDR_INFO_DEFINED 1
#endif

#define SIZE_FOR_ADDR_ARRAY(count) \
        (sizeof(DNS_ADDR_ARRAY) + (count * sizeof(DNS_ADDR_INFO)))


//
//  IP union
//

typedef struct _RpcIpUnion
{
    BOOL        IsIp6;
    IP6_ADDRESS Addr;
}
RPC_IP_UNION, *PRPC_IP_UNION;


//
//  Cache stuff -- left over from Glenn
//

typedef struct _DWORD_LIST_ITEM_
{
    struct _DWORD_LIST_ITEM_ * pNext;
    DWORD                      Value1;
    DWORD                      Value2;
}
DWORD_LIST_ITEM, *PDWORD_LIST_ITEM;


typedef struct _DNS_STATS_TABLE_
{
    struct _DNS_STATS_TABLE_ * pNext;
    PDWORD_LIST_ITEM           pListItem;
}
DNS_STATS_TABLE, *PDNS_STATS_TABLE;


typedef struct _DNS_RPC_CACHE_TABLE_
{
    struct _DNS_RPC_CACHE_TABLE_ * pNext;
    LPWSTR                         Name;
    WORD                           Type1;
    WORD                           Type2;
    WORD                           Type3;
}
DNS_RPC_CACHE_TABLE, *PDNS_RPC_CACHE_TABLE;


//
//  Most of the resolver interface is poorly designed or
//  useless.  For instance there is NO reason to have
//  turned any of the above into linked lists.
//
//  We simply need definitions that are MIDL_PASS aware.
//  This should sit in a common header and be picked up
//  by dnslib.h.   This must wait until dnslib.h is
//  private again OR we separate out the private stuff
//  like this in some fashion.
//
//  Note, taking this private should also involve rename,
//  the PUBLIC structs are obviously the one's that should
//  have the "DNS" tag.  (Amazing.)
//


//
//  Network Info
//
//  DCR:  these merge with defs in dnslib.h (take private)
//

typedef struct _RpcDnsServerInfo
{
    DNS_STATUS      Status;
    DWORD           Priority;
    IP_ADDRESS      IpAddress;
    DWORD           AddressPad[3];
}
RPC_DNS_SERVER_INFO, *PRPC_DNS_SERVER_INFO;

typedef struct _RpcDnsAdapter
{
    PSTR            pszAdapterGuidName;
    PSTR            pszAdapterDomain;
    PIP_ARRAY       pAdapterIPAddresses;
    PIP_ARRAY       pAdapterIPSubnetMasks;
    DWORD           InterfaceIndex;
    DWORD           InfoFlags;
    DWORD           Reserved;
    DWORD           Status;
    DWORD           RunFlags;
    DWORD           ServerIndex;
    DWORD           ServerCount;
    DWORD           MaxServerCount;

#ifdef MIDL_PASS
    [size_is(MaxServerCount)] RPC_DNS_SERVER_INFO ServerArray[];
#else
    RPC_DNS_SERVER_INFO    ServerArray[1];
#endif
}
RPC_DNS_ADAPTER, *PRPC_DNS_ADAPTER;

typedef struct _SearchName
{
    PSTR            pszName;
    DWORD           Flags;
}
RPC_SEARCH_NAME, *PRPC_SEARCH_NAME;

typedef struct _RpcSearchList
{
    PSTR            pszDomainOrZoneName;
    DWORD           NameCount;          // Zero for FindAuthoritativeZone
    DWORD           MaxNameCount;       // Zero for FindAuthoritativeZone
    DWORD           CurrentNameIndex;   // 0 for pszDomainOrZoneName
                                        // 1 for first name in array below
                                        // ...
#ifdef MIDL_PASS
    [size_is(MaxNameCount)] RPC_SEARCH_NAME SearchNameArray[];
#else
    RPC_SEARCH_NAME SearchNameArray[1];
#endif
}
RPC_SEARCH_LIST, *PRPC_SEARCH_LIST;

typedef struct _RpcDnsNetInfo
{
    PSTR                pszDomainName;
    PSTR                pszHostName;
    PRPC_SEARCH_LIST    pSearchList;
    DWORD               TimeStamp;
    DWORD               InfoFlags;
    DWORD               Tag;
    DWORD               ReturnFlags;
    DWORD               AdapterCount;
    DWORD               MaxAdapterCount;

#ifdef MIDL_PASS
    [size_is(MaxAdapterCount)] PRPC_DNS_ADAPTER  AdapterArray[];
#else
    PRPC_DNS_ADAPTER  AdapterArray[1];
#endif
}
RPC_DNS_NETINFO, *PRPC_DNS_NETINFO;


//
//  Environment variable reading (dnsapi\envar.c)
//

typedef struct _EnvarDwordInfo
{
    DWORD   Id;
    DWORD   Value;
    BOOL    fFound;
}
ENVAR_DWORD_INFO, *PENVAR_DWORD_INFO;

//
//  Query blob
//

typedef struct _RpcQueryBlob
{
    PWSTR           pName;
    WORD            wType;
    DWORD           Flags;
    DNS_STATUS      Status;
    PDNS_RECORD     pRecords;
}
RPC_QUERY_BLOB, *PRPC_QUERY_BLOB;

//
//  Cache Enumeration
//

typedef struct
{
    DWORD           EnumTag;
    DWORD           MaxCount;
    WORD            Type;
    DWORD           Flags;
    PWSTR           pName;
    PWSTR           pNameFilter;
}
DNS_CACHE_ENUM_REQUEST, *PDNS_CACHE_ENUM_REQUEST;

typedef struct _DnsCacheEntry
{
    PWSTR           pName;
    PDNS_RECORD     pRecords;
    DWORD           Flags;
    WORD            wType;
    WORD            wPad;
}
DNS_CACHE_ENTRY, *PDNS_CACHE_ENTRY;

typedef struct _DnsCacheEnum
{
    DWORD               TotalCount;
    DWORD               EnumTagStart;
    DWORD               EnumTagStop;
    DWORD               EnumCount;
#ifdef MIDL_PASS
    [size_is(EnumCount)]    DNS_CACHE_ENTRY EntryArray[];
#else
    DNS_CACHE_ENTRY     EntryArray[1];
#endif
}
DNS_CACHE_ENUM, *PDNS_CACHE_ENUM;


#endif // _RESRPC_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\resolver\server\config.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    config.c

Abstract:

    DNS Resolver Service.

    Network configuration info

Author:

    Jim Gilroy  (jamesg)    March 2000

Revision History:

--*/


#include "local.h"


//
//  Network info
//

PDNS_NETINFO        g_NetworkInfo = NULL;
DWORD               g_TimeOfLastPnPUpdate;
DWORD               g_NetInfoTag = 0;
DWORD               g_ResetServerPriorityTime = 0;

//
//  Network failure caching
//

DWORD               g_NetFailureTime;
DNS_STATUS          g_NetFailureStatus;
DWORD               g_TimedOutAdapterTime;
BOOL                g_fTimedOutAdapter;
DNS_STATUS          g_PreviousNetFailureStatus;
DWORD               g_MessagePopupStrikes;
DWORD               g_NumberOfMessagePopups;

//
//  Config globals
//
//  DCR:  eliminate useless config globals
//

DWORD   g_HashTableSize;
DWORD   g_MaxSOACacheEntryTtlLimit;
DWORD   g_NegativeSOACacheTime;
DWORD   g_NetFailureCacheTime;
DWORD   g_MessagePopupLimit;


//
//  Network Info reread time
//      - currently fifteen minutes
//

#define NETWORK_INFO_REREAD_TIME        (900)




//
//  Network info configuration
//

VOID
UpdateNetworkInfo(
    IN      PDNS_NETINFO    pNetInfo     OPTIONAL
    )
/*++

Routine Description:

    Update network info global.

Arguments:

    pNetInfo -- desired network info;  if NULL clear cached copy

Return Value:

    None

--*/
{
    PDNS_NETINFO    poldInfo = NULL;

    DNSDBG( TRACE, (
        "UpdateNetworkInfo( %p )\n",
        pNetInfo ));

    LOCK_NET_LIST();

    //
    //  cache previous netinfo to pickup server priority changes
    //      - don't cache if not same version
    //          - kills copy that was created before last build
    //          - kills copy that was before last PnP (cache clear)
    //      - don't cache if never reset priorities
    //

    if ( pNetInfo )
    {
        if ( pNetInfo->Tag != g_NetInfoTag )
        {
            DNSDBG( INIT, (
                "Skip netinfo update -- previous version"
                "\tptr              = %p\n"
                "\tversion          = %d\n"
                "\tcurrent version  = %d\n",
                pNetInfo,
                pNetInfo->Tag,
                g_NetInfoTag ));
            poldInfo = pNetInfo;
            DNS_ASSERT( pNetInfo->Tag < g_NetInfoTag );
            goto Cleanup;
        }

        if ( g_ServerPriorityTimeLimit == 0 )
        {
            DNSDBG( INIT, (
                "Skip netinfo update -- no priority reset!\n" ));
            poldInfo = pNetInfo;
            goto Cleanup;
        }

        NetInfo_Clean(
            pNetInfo,
            CLEAR_LEVEL_QUERY
            );
    }

    //
    //  no netinfo means clear cached copy
    //      - push up tag count, so no copy out for update can
    //      come back and be reused through path above

    else
    {
        g_NetInfoTag++;
    }

    //
    //  swap -- caches copy or clears
    //

    poldInfo = g_NetworkInfo;
    g_NetworkInfo = pNetInfo;


Cleanup:

    UNLOCK_NET_LIST();
    
    NetInfo_Free( poldInfo );
}



PDNS_NETINFO         
GrabNetworkInfo(
    VOID
    )
/*++

Routine Description:

    Get copy of network info.

    Named it "Grab" to avoid confusion with GetNetworkInfo()
    in dnsapi.dll.

Arguments:

    None

Return Value:

    Ptr to copy of network info (caller must free).
    NULL on error.

--*/
{
    PDNS_NETINFO    poldInfo = NULL;
    PDNS_NETINFO    pnewInfo = NULL;
    DWORD           currentTime = Dns_GetCurrentTimeInSeconds();

    DNSDBG( TRACE, ( "GrabNetworkInfo()\n" ));

    //
    //  check for valid network info global
    //      - within forced reread time
    //      - reset server priorities if 
    //

    LOCK_NET_LIST();

    if ( g_NetworkInfo &&
         g_NetworkInfo->TimeStamp + NETWORK_INFO_REREAD_TIME > currentTime )
    {
        if ( g_ResetServerPriorityTime < currentTime )
        {
            NetInfo_ResetServerPriorities( g_NetworkInfo, TRUE );
            g_ResetServerPriorityTime = currentTime + g_ServerPriorityTimeLimit;
        }
    }

    //
    //  current global expired
    //      - build new netinfo
    //      - tag it with unique monotonically increasing id
    //          this makes sure we never use older version
    //      - push forward priorities reset time
    //      - make newinfo the global copy
    //
    //  Do not hold lock during build
    //      - IpHlpApi doing routing info call RPCs to router which can
    //      depend on PnP notifications, which in turn can be causing calls
    //      back into resolver indicating config change;  overall the loss
    //      of control is too large
    //
    //
    //  Two separate issues:
    //
    //  There are ways to make the config change issue go away (ex setting
    //  some sort of "invalid" flag under interlock), but they basically boil
    //  down to introducing some other sort of lock. 
    //
    //  The bottom line is there are two separate issues here:
    //      1)  Access to cache netinfo, which may be invalidated.
    //      2)  Single build of netinfo for perf.
    //
    //  Implementation wise, you can have the invalidation\clear under a
    //  separate interlock, and thus have a single lock for copy-access\build,
    //  but the reality is the same.
    //
    //
    //  Solution
    //      - get our tag first
    //      - clear lock
    //      - make build call
    //      - on return check that tag is still valid, if not we can
    //          USE the result, but we don't cache it, as the global tag
    //          could be higher because of config change, and in any case
    //          we let the last builder win
    //
    //  DCR:  netinfo build lock for perf, independent of protecting global
    //      could have "timed-lock" using event that waits for a short interval to
    //      to try to allow first guy to complete
    //

    else
    {
        DWORD   newTag = ++g_NetInfoTag;

        UNLOCK_NET_LIST();

        pnewInfo = NetInfo_Build( TRUE );
        if ( !pnewInfo )
        {
            DNSDBG( ANY, ( "ERROR:  GrabNetworkInfo() failed -- no netinfo blob!\n" ));
            goto Done;
        }

        LOCK_NET_LIST();

        pnewInfo->Tag = newTag;
        if ( newTag != g_NetInfoTag )
        {
            DNS_ASSERT( newTag < g_NetInfoTag );
            DNSDBG( ANY, (
                "WARNING:  New netinfo uncacheable -- tag is old!\n"
                "\tour tag      = %d\n"
                "\tcurrent tag  = %d\n",
                newTag,
                g_NetInfoTag ));
            goto Unlock;
        }

        //  if tag still current cache this new netinfo

        g_ResetServerPriorityTime = currentTime + g_ServerPriorityTimeLimit;
        g_TimedOutAdapterTime = 0;
        g_fTimedOutAdapter = FALSE;

        poldInfo = g_NetworkInfo;
        g_NetworkInfo = pnewInfo;
    }

    //
    //  make copy of global (new or reset)
    //

    pnewInfo = NetInfo_Copy( g_NetworkInfo );

Unlock:

    UNLOCK_NET_LIST();

    NetInfo_Free( poldInfo );

Done:

    return pnewInfo;
}



VOID
ZeroNetworkConfigGlobals(
    VOID
    )
/*++

Routine Description:

    Zero init network globals.

Arguments:

    None

Return Value:

    None

--*/
{
    //  net failure

    g_NetFailureTime = 0;
    g_NetFailureStatus = NO_ERROR;
    g_PreviousNetFailureStatus = NO_ERROR;

    g_fTimedOutAdapter = FALSE;
    g_TimedOutAdapterTime = 0;

    g_MessagePopupStrikes = 0;
    g_NumberOfMessagePopups = 0;

    //  network info

    g_TimeOfLastPnPUpdate = 0;
    g_NetworkInfo = NULL;
}



VOID
CleanupNetworkInfo(
    VOID
    )
/*++

Routine Description:

    Cleanup network info.

Arguments:

    None

Return Value:

    None

--*/
{
    LOCK_NET_LIST();

    if ( g_NetworkInfo )
    {
        NetInfo_Free( g_NetworkInfo );
        g_NetworkInfo = NULL;
    }

    UNLOCK_NET_LIST();
}



//
//  General configuration
//

VOID
ReadRegistryConfig(
    VOID
    )
{
    //
    //  re-read full DNS registry info
    //

    Reg_ReadGlobalsEx( 0, NULL );

    //
    //  set "we are the resolver" global
    //

    g_InResolver = TRUE;

    //
    //  just default old config globals until remove
    //
    //  DCR:  status of old config globals?
    //

    g_MaxSOACacheEntryTtlLimit  = DNS_DEFAULT_MAX_SOA_TTL_LIMIT;
    g_NegativeSOACacheTime      = DNS_DEFAULT_NEGATIVE_SOA_CACHE_TIME;

    g_NetFailureCacheTime       = DNS_DEFAULT_NET_FAILURE_CACHE_TIME;
    g_HashTableSize             = DNS_DEFAULT_HASH_TABLE_SIZE;
    g_MessagePopupLimit         = DNS_DEFAULT_MESSAGE_POPUP_LIMIT;
}



VOID
HandleConfigChange(
    IN      PSTR            pszReason,
    IN      BOOL            fCacheFlush
    )
/*++

Routine Description:

    Response to configuration change.

Arguments:

    fCache_Flush -- flush if config change requires cache flush

Return Value:

    None

--*/
{
    DNSDBG( INIT, (
        "\n"
        "HandleConfigChange() => %s\n"
        "\tflush = %d\n",
        pszReason,
        fCacheFlush ));

    //
    //  lock out all work while tear down everything
    //      - lock with no start option so if we are already torn
    //          down we don't rebuild
    //      - optionally flush cache
    //      - dump IP list
    //      - dump network info
    //

    LOCK_CACHE_NO_START();

    //
    //  cache flush?
    //  
    //  all config changes don't necessarily require cache flush;
    //  if not required just rebuild local list and config
    //

    if ( fCacheFlush )
    {
        Cache_Flush();
    }
    else
    {
        ClearLocalAddrArray();
    }

    //
    //  clear network info
    //  save PnP time
    //  clear net failure flags
    //

    UpdateNetworkInfo( NULL );
    g_TimeOfLastPnPUpdate = Dns_GetCurrentTimeInSeconds();
    g_NetFailureTime = 0;
    g_NetFailureStatus = NO_ERROR;

    DNSDBG( INIT, (
        "Leave HandleConfigChange() => %s\n"
        "\tflush = %d\n\n",
        pszReason,
        fCacheFlush ));

    UNLOCK_CACHE();
}




//
//  Remote APIs
//

VOID
R_ResolverGetConfig(
    IN      DNS_RPC_HANDLE      Handle,
    IN      DWORD               Cookie,
    OUT     PRPC_DNS_NETINFO *  ppNetInfo,
    OUT     PDNS_GLOBALS_BLOB * ppGlobals
    )
/*++

Routine Description:

    Make the query to remote DNS server.

Arguments:

    Handle -- RPC handle

    Cookie -- cookie of last succesful config transfer
        zero indicates no previous successful transfer

    ppNetInfo -- addr to receive ptr to network info

    ppGlobals -- addr to receive ptr to globals blob

Return Value:

    None

--*/
{
    PDNS_GLOBALS_BLOB   pblob;

    DNSLOG_F1( "R_ResolverGetConfig" );

    DNSDBG( RPC, (
        "R_ResolverGetConfig\n"
        "\tcookie   = %p\n",
        Cookie ));

    if ( !ppNetInfo || !ppGlobals )
    {
        return;
    }

    //
    //  DCR:  config cookie check
    //      - no need to get data if client has current copy
    //

    //
    //  copy network info global
    //
    //  note:  currently RPC is using same allocator (dnslib)
    //          as GrabNetworkInfo();  so we are ok just passing
    //          NETINFO blob as is
    //
    //  note:  could build on "no-global" but since we create on
    //         cache start we should always have global or be
    //         just starting
    //

    *ppNetInfo = (PRPC_DNS_NETINFO) GrabNetworkInfo();

    pblob = (PDNS_GLOBALS_BLOB) RPC_HEAP_ALLOC( sizeof(*pblob) );
    if ( pblob )
    {
        RtlCopyMemory(
            pblob,
            & DnsGlobals,
            sizeof(DnsGlobals) );

        //  clear "in resolver" flag

        pblob->InResolver = FALSE;
    }
    *ppGlobals = pblob;

    DNSDBG( RPC, ( "Leave R_ResolverGetConfig\n\n" ));
}



VOID
R_ResolverPoke(
    IN      DNS_RPC_HANDLE      Handle,
    IN      DWORD               Cookie,
    IN      DWORD               Id
    )
/*++

Routine Description:

    Test interface to poke resolver to update.

Arguments:

    Handle -- RPC handle

    Cookie -- cookie

    Id -- operation Id

Return Value:

    None

--*/
{
    DNSLOG_F1( "R_ResolverPoke" );

    DNSDBG( RPC, (
        "R_ResolverPoke\n"
        "\tcookie = %08x\n"
        "\tid     = %d\n",
        Cookie,
        Id ));

    //
    //  do operation for particular id
    //      - update netinfo clears cached copy

    if ( Id == POKE_OP_UPDATE_NETINFO )
    {
        if ( Cookie == POKE_COOKIE_UPDATE_NETINFO )
        {
            UpdateNetworkInfo( NULL );
        }
    }
}

//
//  End config.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\resolver\idl\rpcstrcs.h ===
/*++

Copyright (c) 1996-1197  Microsoft Corporation

Module Name:

    rpcstrcs.h

Abstract:

    Domain Name System (DNS)

    DNS Caching Resolver Structures

Author:

    Glenn Curtis (glennc)     January 11, 1997

Revision History:

--*/


#ifndef _RPCSTRCS_INCLUDED_
#define _RPCSTRCS_INCLUDED_


#ifndef _DNSAPI_INCLUDE_
#include <dnsapi.h>
#endif


#ifdef  MIDL_PASS
#define LPSTR [string] char *
#define LPCSTR [string] const char *
#endif


//
// Net adapter list structures
//

typedef struct _DNS_IP_ADDR_LIST_
{
    DWORD              dwAddressCount;
#ifdef MIDL_PASS
    [size_is(dwAddressCount)] DNS_ADDRESS_INFO AddressArray[];
#else  // MIDL_PASS
    DNS_ADDRESS_INFO   AddressArray[1];
#endif // MIDL_PASS
}
DNS_IP_ADDR_LIST, *PDNS_IP_ADDR_LIST;


typedef struct _DWORD_LIST_ITEM_
{
    struct _DWORD_LIST_ITEM_ * pNext;
    DWORD                      Value1;
    DWORD                      Value2;
}
DWORD_LIST_ITEM, *PDWORD_LIST_ITEM;


typedef struct _DNS_STATS_TABLE_
{
    struct _DNS_STATS_TABLE_ * pNext;
    PDWORD_LIST_ITEM           pListItem;
}
DNS_STATS_TABLE, *PDNS_STATS_TABLE;


typedef struct _DNS_RPC_CACHE_TABLE_
{
    struct _DNS_RPC_CACHE_TABLE_ * pNext;
    LPWSTR                         Name;
    WORD                           Type1;
    WORD                           Type2;
    WORD                           Type3;
}
DNS_RPC_CACHE_TABLE, *PDNS_RPC_CACHE_TABLE;


//
//  Most of the resolver interface is poorly designed or
//  useless.  For instance there is NO reason to have
//  turned any of the above into linked lists.
//
//  We simply need definitions that are MIDL_PASS aware.
//  This should sit in a common header and be picked up
//  by dnslib.h.   This must wait until dnslib.h is
//  private again OR we separate out the private stuff
//  like this in some fashion.
//
//  Note, taking this private should also involve rename,
//  the PUBLIC structs are obviously the one's that should
//  have the "DNS" tag.  (Amazing.)
//


typedef struct _NameServerInfo
{
    IP_ADDRESS      ipAddress;
    DWORD           Priority;
    DNS_STATUS      Status;
}
NAME_SERVER_INFO, *PNAME_SERVER_INFO;

typedef struct _AdapterInfo
{
    LPSTR           pszAdapterGuidName;
    LPSTR           pszAdapterDomain;
    PIP_ARRAY       pAdapterIPAddresses;
    PIP_ARRAY       pAdapterIPSubnetMasks;
    DWORD           Status;
    DWORD           InfoFlags;
    DWORD           ReturnFlags;
    DWORD           ipLastSend;
    DWORD           cServerCount;
    DWORD           cTotalListSize;

#ifdef MIDL_PASS
    [size_is(cTotalListSize)] NAME_SERVER_INFO aipServers[];
#else
    NAME_SERVER_INFO    aipServers[1];
#endif
}
ADAPTER_INFO, *PADAPTER_INFO;

typedef struct _SearchName
{
    LPSTR           pszName;
    DWORD           Flags;
}
SEARCH_NAME, *PSEARCH_NAME;

typedef struct _RpcSearchList
{
    LPSTR           pszDomainOrZoneName;
    DWORD           cNameCount;         // Zero for FindAuthoritativeZone
    DWORD           cTotalListSize;     // Zero for FindAuthoritativeZone
    DWORD           CurrentName;        // 0 for pszDomainOrZoneName
                                        // 1 for first name in array below
                                        // ...
#ifdef MIDL_PASS
    [size_is(cTotalListSize)] SEARCH_NAME aSearchListNames[];
#else
    SEARCH_NAME     aSearchListNames[1];
#endif
}
RPC_SEARCH_LIST, *PRPC_SEARCH_LIST;

typedef struct _NetworkInfo
{
    DWORD               ReturnFlags;
    DWORD               InfoFlags;
    PRPC_SEARCH_LIST    pSearchList;
    DWORD               cAdapterCount;
    DWORD               cTotalListSize;

#ifdef MIDL_PASS
    [size_is(cTotalListSize)] PADAPTER_INFO aAdapterInfoList[];
#else
    PADAPTER_INFO   aAdapterInfoList[1];
#endif
}
NETWORK_INFO, *PNETWORK_INFO;


#endif // _RPCSTRCS_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\resolver\server\cache.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    cache.c

Abstract:

    DNS Resolver Service

    Cache routines

Author:

    Glenn Curtis (glennc)   March 1997

Revision History:

    Jim Gilroy (jamesg)     February 2000       cleanup

--*/


#include "local.h"


//
//  Global Declarations
//

#define IS_STATIC_TTL_RECORD(prr)   IS_HOSTS_FILE_RR(prr)


//
//  Cache hash table
//

extern  PCACHE_ENTRY *      g_HashTable;
extern  DWORD               g_CacheEntryCount;
extern  DWORD               g_CacheRecordSetCount;
extern  DWORD               g_CurrentCacheTime;

#define INITIAL_CACHE_HEAP_SIZE     (16*1024)


//
// Compute a hash table index value for a string
//

#define EOS     (L'\0')

#define COMPUTE_STRING_HASH_1( _String, _ulHashTableSize, _lpulHash ) \
        {                                               \
            PWCHAR p;                                   \
            ULOND  h = 0, g;                            \
                                                        \
            for ( p = _String; *p != EOS; p = p + 1 )   \
            {                                           \
                h = ( h << 4 ) + (DWORD) (*p);          \
                if ( g = h&0xf0000000 )                 \
                {                                       \
                    h = h ^ ( g >> 24 );                \
                    h = h ^ g;                          \
                }                                       \
            }                                           \
            *_lpulHash = h % _ulHashTableSize;          \
        }


//
// Compute a hash table index value for a string
// which is invairant to case
//
#define COMPUTE_STRING_HASH_2( _String, _ulHashTableSize, _lpulHash ) \
        {                                           \
            PWCHAR _p = _String;                    \
            PWCHAR _ep = _p + wcslen( _String );    \
            ULONG  h = 0;                           \
                                                    \
            while( _p < _ep )                       \
            {                                       \
                h <<= 1;                            \
                h ^= *_p++;                         \
            }                                       \
                                                    \
            *_lpulHash = h % _ulHashTableSize;      \
        }


//
//  Private prototypes
//

BOOL
IsInvalidNegativeCacheEntry(
    IN  PDNS_RECORD
    );

PDNS_RECORD
BuildDNSServerRecord(
    IN  IP_ADDRESS Address
    );

PDNS_RECORD
BuildLocalAddressRecords(
    IN  PSTR  Name
    );

BOOL
IsLocalAddress(
    IN  IP_ADDRESS Ip
    );

//
//  From ncache.c
//

BOOL
makeCannonicalCacheName(
    OUT     PWCHAR          pNameBuffer,
    IN      DWORD           BufferLength,
    IN      PWSTR           pName,
    IN      DWORD           NameLength      OPTIONAL
    );

DWORD
getHashIndex(
    IN      PWSTR           pName,
    IN      DWORD           NameLength  OPTIONAL
    );

//
//  Define to new routine
//

#define PrepareRecordSetForRpc(prr)     Cache_RestoreRecordListForRpc(prr)

#define IsCacheTtlStillValid(prr)       Cache_IsRecordTtlValid(prr)

#define GetCacheLock()      LOCK_CACHE()
#define ReleaseCacheLock()  UNLOCK_CACHE()



//
//  Cache entry routines
//

PCACHE_ENTRY
CreateCacheEntry(
    IN      PWSTR           pName,
    IN      BOOL            fLoadingHostsFile
    )
/*++

Routine Description:

    Create cache entry, including allocation.

Arguments:

    pName -- name to create entry for

    fLoadingHostsFile -- TRUE if loading from host file;  FALSE otherwise

Return Value:

    Ptr to newly allocated cache entry.
    NULL on error.

--*/
{
    ULONG           index = 0;
    PCACHE_ENTRY    pentry = NULL;
    DWORD           nameLength;
    PWCHAR          pnameCache = NULL;

    DNSDBG( TRACE, (
        "CreateCacheEntry( %S, hostfile=%d )\n",
        pName,
        fLoadingHostsFile ));

    if ( !pName || !g_HashTable )
    {
        return NULL;
    }

    //
    //  build cache entry
    //
    //  DCR_PERF:  alloc for name within entry?
    //

    pentry = (PCACHE_ENTRY) CACHE_HEAP_ALLOC_ZERO( sizeof(CACHE_ENTRY) );
    if ( !pentry )
    {
        goto Fail;
    }

    //
    //  build the name
    //

    nameLength = wcslen( pName );

    pnameCache = CACHE_HEAP_ALLOC_ZERO( sizeof(WCHAR) * (nameLength + 1) );
    if ( !pnameCache )
    {
        goto Fail;
    }

    if ( !makeCannonicalCacheName(
            pnameCache,
            nameLength+1,
            pName,
            nameLength ) )
    {
        goto Fail;
    }

    pentry->pName = pnameCache;

    pentry->fHostsFileEntry = fLoadingHostsFile;

    //
    //  insert cache entry into cache -- first entry in bucket
    //

    index = getHashIndex( pnameCache, 0 );
    pentry->pNext = g_HashTable[ index ];
    g_HashTable[ index ] = pentry;
    g_CacheEntryCount++;


    if ( fLoadingHostsFile )
    {
        ResizeCacheBucket( index, &g_CacheHashTableBucketSize );
    }
    else
    {
        //
        // Trim the hash bucket to keep the number of entries below
        // g_CacheHashTableBucketSize.
        //
        //  DCR:  goofy cache limit
        //  DCR:  cache limit should be total size above hosts file
        //          not individual buckets
        //      monitor thread should just wake up and and clear dead
        //      wood from cache
        //

        TrimCacheBucket( index, g_CacheHashTableBucketSize, TRUE );
    }

    return pentry;


Fail:

    //  dump entry

    if ( pentry )
    {
        CACHE_HEAP_FREE( pentry );
    }
    if ( pnameCache )
    {
        CACHE_HEAP_FREE( pnameCache );
    }
    return NULL;
}


//raw
VOID
FreeCacheEntry(
    IN OUT  PCACHE_ENTRY    pEntry
    )
/*++

Routine Description:

    Free cache entry.

Arguments:

    pEntry -- cache entry to free

Globals:

    g_CacheEntryCount -- decremented appropriately

    g_NumberOfRecordsInCache -- decremented appropriately

Return Value:

    None

--*/
{
    register INT iter;

    DNSDBG( TRACE, (
        "FreeCacheEntry( %p )\n",
        pEntry ));

    //
    //  free entry
    //      - name
    //      - records
    //      - entry itself
    //
    //  QUESTION:  are global counters safe?  should lock?
    //

    if ( pEntry )
    {
        for ( iter = 0;
              iter < BASE_NUMBER_OF_RECORDS;
              iter++ )
        {
            if ( pEntry->Records[iter] )
            {
                Dns_RecordListFree( pEntry->Records[iter] );
                g_CacheRecordSetCount--;
            }
        }

        if ( pEntry->pName )
        {
            CACHE_HEAP_FREE( pEntry->pName );
        }

#if 0
        if ( pEntry->pNext )
        {
            DNSLOG_F1( "FreeCacheEntry is deleting an entry that still points to other entries!" );
        }
#endif

        CACHE_HEAP_FREE( pEntry );
        g_CacheEntryCount--;
    }
}


//raw
VOID
AddRecordToCacheEntry(
    IN OUT  PCACHE_ENTRY    pEntry,
    IN      PDNS_RECORD     pRecord,
    IN      BOOL            fFlushExisting,
    IN      BOOL            fLoadingHostsFile
    )
{
    WORD    iter;
    WORD    type = pRecord->wType;


    DNSDBG( TRACE, (
        "AddRecordToCacheEntry( e=%p, rr=%p, type=%d )\n",
        pEntry,
        pRecord,
        type ));

    //
    //  don't overwrite host file entries
    //

    if ( !fLoadingHostsFile &&
         pEntry->fHostsFileEntry &&
         ( type == DNS_TYPE_A ||
           type == DNS_TYPE_PTR ) )
    {
        return;
    }

    //
    //  clean up existing records at node
    //      - remove stale records
    //      - remove records of same type UNLESS not flushing existing
    //

    for ( iter = 0;
          iter < BASE_NUMBER_OF_RECORDS;
          iter++ )
    {
        PDNS_RECORD prrExistSet = pEntry->Records[iter];

        //
        //  skip sets of different type that are still valid
        //

        if ( !prrExistSet ||
             ( prrExistSet->wType != type &&
               IsCacheTtlStillValid( prrExistSet ) ) )
        {
            continue;
        }

        //
        //  dump
        //      - stale records
        //      - records of same type (when flush existing)
        //
        //  note, that previous test means we're here with same
        //      type record OR record is invalid
        //

        if ( fFlushExisting ||
             pEntry->Records[iter]->wType != type )
        {
            Dns_RecordListFree( prrExistSet );
            pEntry->Records[iter] = NULL;
            g_CacheRecordSetCount--;
            continue;
        }

        //
        //  NOT flushing AND matching type -- host file load case
        //      => add new record to list
        //
        //  the way this works
        //      - start at "record" which is addr of record ptr entry
        //      making pNext field the actual pointer
        //      - delete duplicates
        //      - tack new RR on end
        //      - blow away new RR name if existing record
        //
        //
        //  DCR:  should have simple "make cache RR set" function that
        //      handles name and TTL issues
        //
        //  DCR:  broken if non-flush load hits wire data;  wire data
        //      may have multiple RR sets
        //

        else
        {
            PDNS_RECORD prr;
            PDNS_RECORD prrPrev = (PDNS_RECORD) &pEntry->Records[iter];

            while ( prr = prrPrev->pNext )
            {
                //  matches existing record?
                //      - cut existing record from list and free

                if ( Dns_RecordCompare( prr, pRecord ) )
                {
                    prrPrev->pNext = prr->pNext;
                    prr->pNext = NULL;
                    Dns_RecordListFree( prr );
                }
                else
                {
                    prrPrev = prr;    
                }
            }

            //
            //  tack entry on to end
            //      - if existing records of type delete name
            //

            if ( prrPrev != (PDNS_RECORD)&pEntry->Records[iter] )
            {
                if ( IS_FREE_OWNER(pRecord) )
                {
                    RECORD_HEAP_FREE( pRecord->pName );
                    pRecord->pName = NULL;
                }
            }
            prrPrev->pNext = pRecord;
            return;
        }
    }

    //
    //  put record into cache entry
    //      - note record list may now contain pre-existing records
    //      from above
    //

    for ( iter = 0;
          iter < BASE_NUMBER_OF_RECORDS;
          iter++ )
    {
        if ( pEntry->Records[iter] == NULL )
        {
            pEntry->Records[iter] = pRecord;
            g_CacheRecordSetCount++;
            return;
        }
    }

    //
    //  must find free spot in list -- get rid of last one
    //
    //  DCR:  realloc and push out if need more space
    //

    Dns_RecordListFree( pEntry->Records[BASE_NUMBER_OF_RECORDS-1] );
    pEntry->Records[BASE_NUMBER_OF_RECORDS-1] = pRecord;

    return;
}



VOID
FlushCacheEntry(
    IN      PWSTR           pName
    )
/*++

Routine Description:

    Flush cache entry corresponding to a name.

Arguments:

    pName -- name to delete from the cache

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    ULONG           index = 0;
    PCACHE_ENTRY    pentry = NULL;
    PCACHE_ENTRY    pprevEntry = NULL;
    WCHAR           hashName[ DNS_MAX_NAME_BUFFER_LENGTH+4 ];


    DNSDBG( TRACE, (
        "FlushCacheEntry( %S )\n",
        pName ));
    
    if ( !g_HashTable )
    {
        return;
    }

    //
    //  build cache name
    //

    if ( !makeCannonicalCacheName(
            hashName,
            DNS_MAX_NAME_BUFFER_LENGTH,
            pName,
            0 ) )
    {
        return;
    }


    //
    //  find entry in cache
    //
    //  DCR:  consider a find routine that lets us cut
    //      - return prev pointer
    //      - or know we're at front of list and have index
    //

    index = getHashIndex( hashName, 0 );

    GetCacheLock();

    pentry = g_HashTable[ index ];

    while( pentry )
    {
        if ( DnsNameCompare_W( hashName, pentry->pName ) )
        {
            //
            // Can't purge cache entries that hold records that were
            // read in from the hosts file . . .
            //
            if ( pentry->fHostsFileEntry )
            {
                goto Done;
            }

            //
            // Found it!
            //
            if ( pprevEntry )
            {
                //
                // There is an entry in front of the one we found
                // in the list.
                //
                pprevEntry->pNext = pentry->pNext;
            }
            else
            {
                //
                // There isn't an entry in front of the one we found.
                //
                g_HashTable[ index ] = pentry->pNext;
            }

            pentry->pNext = NULL;
            FreeCacheEntry( pentry );
            goto Done;
        }

        pprevEntry = pentry;
        pentry = pentry->pNext;
    }

Done:

    ReleaseCacheLock();
}



VOID
FlushCacheEntryRecord(
    IN      PWSTR           pName,
    IN      WORD            Type
    )
/*++

Routine Description:

    Flush cached records corresponding to a name and type.

Arguments:

    pName -- name of records to delete

    Type -- type of records to delete

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    WORD            iter;
    PCACHE_ENTRY    pentry;

    DNSDBG( TRACE, (
        "FlushCacheEntryRecord( %S, %d )\n",
        pName,
        Type ));

    //
    //  find entry in cache
    //

    GetCacheLock();

    pentry = FindCacheEntry( pName );
    if ( !pentry )
    {
        goto Done;
    }

    //
    //  free records for entry
    //      - not from hosts file
    //      - matches type
    //      - or type zero (for deleting ALL records)
    //      - or name error
    //

    for ( iter = 0;
          iter < BASE_NUMBER_OF_RECORDS;
          iter++ )
    {
        PDNS_RECORD prr = pentry->Records[iter];

        if ( prr &&
             ! IS_HOSTS_FILE_RR(prr) &&
             ( prr->wType == Type ||
               Type == 0 ||
               ( prr->wType == DNS_TYPE_ANY &&
                 prr->wDataLength == 0 ) ) )
        {
            Dns_RecordListFree( prr );
            pentry->Records[iter] = NULL;
            g_CacheRecordSetCount--;
        }
    }

Done:

    ReleaseCacheLock();
}


//raw
VOID
TrimCache(
    VOID
    )
/*++

Routine Description:

    Trim back cache.  Trim every bucket in cache.

Arguments:

    None

Return Value:

    None

--*/
{
    WORD  hashIter;

    if ( !g_HashTable )
        return;

    for ( hashIter = 0;
          hashIter < g_CacheHashTableSize;
          hashIter++ )
    {
        TrimCacheBucket( hashIter,
                         g_CacheHashTableBucketSize,
                         FALSE );
    }
}


//raw
VOID
TrimCacheBucket(
    IN      ULONG           Index,
    IN      DWORD           dwBucketSize,
    IN      BOOL            fSkipFirst
    )
/*++

Routine Description:

    Trim back cache bucket.

Arguments:

    Index -- Index of hash bucket to trim.

    dwBucketSize -- size to trim bucket to

    fSkipFirst -- skip first entry while triming

Return Value:

    None

--*/
{
    PCACHE_ENTRY pentry = g_HashTable[ Index ];
    PCACHE_ENTRY pprevEntry = NULL;
    DWORD EntryCount = 0;


    //
    //  skip first entry in bucket
    //

    if ( pentry && fSkipFirst )
    {
        pprevEntry = pentry;
        pentry = pentry->pNext;
        EntryCount++;
    }

    while ( pentry )
    {
        PCACHE_ENTRY pnextEntry = pentry->pNext;
        WORD             recordCount = 0;
        WORD             iter;

        for ( iter = 0;
              iter < BASE_NUMBER_OF_RECORDS;
              iter++ )
        {
            //
            //  delete stale entries
            //      - not from host file
            //      - TTL expired
            //
            
            if ( ! pentry->fHostsFileEntry &&
                 pentry->Records[iter] &&
                 !IsCacheTtlStillValid( pentry->Records[iter] ) )
            {
                Dns_RecordListFree( pentry->Records[iter] );
                pentry->Records[iter] = NULL;
                g_CacheRecordSetCount--;
                recordCount++;
            }
            else if ( !pentry->Records[iter] )
            {
                recordCount++;
            }
        }

        //
        //  if entry is empty -- delete
        //

        if ( recordCount == BASE_NUMBER_OF_RECORDS )
        {
            if ( pprevEntry )
                pprevEntry->pNext = pentry->pNext;
            else
                g_HashTable[ Index ] = pentry->pNext;

            pentry->pNext = NULL;

            FreeCacheEntry( pentry );
        }
        else
        {
            pprevEntry = pentry;
            EntryCount++;
        }

        pentry = pnextEntry;
    }

    //
    //  if still too many entries we need to delete
    //
    //  DCR:  cache size limitation is weak
    //      - ideally time out based on query, for instances pick an interval
    //      say ten minutes and time out all older stuff
    //      - or better yet do LRU timeout
    //

    if ( EntryCount >= dwBucketSize )
    {
        PCACHE_ENTRY pPrevPurgeEntry = NULL;
        PCACHE_ENTRY pPurgeEntry = NULL;


        pentry = g_HashTable[ Index ];
        pprevEntry = NULL;

        //
        //  skip first when required
        //

        if ( pentry && fSkipFirst )
        {
            pprevEntry = pentry;
            pentry = pentry->pNext;
        }

        //
        // Loop through all cache entries looking for potential ones
        // to get rid of, the last one in the list will be the one that
        // is purged (Least Recently Used).
        //
        while ( pentry )
        {
            if ( ! pentry->fHostsFileEntry )
            {
                //
                // Found a potential entry to purge
                //
                pPrevPurgeEntry = pprevEntry;
                pPurgeEntry = pentry;
            }

            pprevEntry = pentry;
            pentry = pentry->pNext;
        }

        //
        //  Now get rid of the entry that was found
        //
        //  FIXME:  how many times are we going to clone this code???
        //

        if ( pPurgeEntry )
        {
            WORD iter;

            if ( pPrevPurgeEntry )
            {
                pPrevPurgeEntry->pNext = pPurgeEntry->pNext;
            }
            else
            {
                g_HashTable[ Index ] = pPurgeEntry->pNext;
            }

            pPurgeEntry->pNext = NULL;

            FreeCacheEntry( pPurgeEntry );
        }
    }
}


//raw
VOID
ResizeCacheBucket(
    IN      ULONG           Index,
    IN      PDWORD          pdwBucketSize
    )
{
    PCACHE_ENTRY pentry = g_HashTable[ Index ];
    DWORD            Count = 0;

    while ( pentry )
    {
        Count++;
        pentry = pentry->pNext;
    }

    if ( (*pdwBucketSize - Count) < 10 )
    {
        *pdwBucketSize += 10;
    }
}


//raw
PCACHE_ENTRY
FindCacheEntry(
    IN      PWSTR           pName
    )
{
    ULONG           index;
    PCACHE_ENTRY    pentry;
    PCACHE_ENTRY    pprevEntry = NULL;
    WCHAR           hashName[ DNS_MAX_NAME_BUFFER_LENGTH+4 ];

    if ( !g_HashTable )
    {
        return NULL;
    }
    if ( !pName )
    {
        DNS_ASSERT( FALSE );
        return NULL;
    }

    DNSDBG( TRACE, (
        "FindCacheEntry( %S )\n",
        pName ));

    //
    //  build cache name
    //      - if invalid (too long) bail
    //

    if ( !makeCannonicalCacheName(
            hashName,
            DNS_MAX_NAME_BUFFER_LENGTH,
            pName,
            0 ) )
    {
        return  NULL;
    }

    //
    //  find entry in cache
    //

    index = getHashIndex( hashName, 0 );

    pentry = g_HashTable[ index ];


    DNSDBG( TRACE, (
        "in FindCacheEntry\n"
        "\tname     = %S\n"
        "\tindex    = %d\n"
        "\tpentry   = %p\n",
        hashName,
        index,
        pentry ));

    while( pentry )
    {
        if ( DnsNameCompare_W( hashName, pentry->pName ) )
        {
            //
            //  found entry
            //      - move to front, if not already there

            if ( pprevEntry )
            {
                pprevEntry->pNext = pentry->pNext;
                pentry->pNext = g_HashTable[ index ];
                g_HashTable[ index ] = pentry;
            }
            break;
        }
        ELSE
        {
            DNSDBG( OFF, (
                "in FindCacheEntry -- failed name compare\n"
                "\tout name = %S\n"
                "\tpentry   = %p\n"
                "\tname     = %S\n",
                hashName,
                pentry,
                pentry->pName ));
        }

        pprevEntry = pentry;
        pentry = pentry->pNext;
    }

    DNSDBG( TRACE, (
        "Leave FindCacheEntry\n"
        "\tname     = %S\n"
        "\tindex    = %d\n"
        "\tpentry   = %p\n",
        hashName,
        index,
        pentry ));

    return pentry;
}




PCACHE_ENTRY
FindOrCreateCacheEntry(
    IN      PWSTR           pName,
    IN      BOOL            fHostsFile
    )
/*++

Routine Description:

    Find or create entry for name in cache.

Arguments:

    pName -- name to find

Return Value:

    Ptr to cache entry -- if successful.
    NULL on failure.

--*/
{
    PCACHE_ENTRY    pentry;

    DNSDBG( TRACE, (
        "FindOrCreateCacheEntry( %S, hosts=%d )\n",
        pName,
        fHostsFile ));

    //
    //  find entry?
    //

    pentry = FindCacheEntry( pName );
    if ( !pentry )
    {
        pentry = CreateCacheEntry(
                    pName,
                    fHostsFile
                    );
    }

    DNSDBG( TRACE, (
        "Leave FindOrCreateCacheEntry( %S, hosts=%d ) => %p\n",
        pName,
        fHostsFile,
        pentry ));

    return pentry;
}




PDNS_RECORD
FindCacheEntryRecord(
    IN      PCACHE_ENTRY    pEntry,
    IN      WORD            Type
    )
/*++

Routine Description:

    Find entry in cache.

Arguments:

    pEntry -- cache entry to check

    Type -- record type to find

Return Value:

    Ptr to record set of desired type -- if found.
    NULL if not found.

--*/
{
    WORD        iter;
    PDNS_RECORD prr;

    DNSDBG( TRACE, (
        "FindCacheEntryRecord( %p, type=%d )\n",
        pEntry,
        Type ));

    //
    //  check all the records at the cache entry  
    //

    for ( iter = 0;
          iter < BASE_NUMBER_OF_RECORDS;
          iter++ )
    {
        prr = pEntry->Records[iter];

        if ( prr &&
             ( prr->wType == Type ||
               prr->wType == DNS_TYPE_CNAME ||
               ( prr->wType == DNS_TYPE_ANY &&
                 prr->wDataLength == 0 ) ) )
        {
            //
            //  if expired dump RR list
            //
            //  DCR:  if different RR sets in list, then TTL check here not sufficient
            //
            //  DCR:  functionalize this
            //

            if ( !IsCacheTtlStillValid( prr ) ||
                 IsInvalidNegativeCacheEntry( prr ) )
            {
                DNSDBG( TRACE, (
                    "Whacking timed out record %p at cache entry %p\n",
                    prr,
                    pEntry ));
                Dns_RecordListFree( prr );
                pEntry->Records[iter] = NULL;
                g_CacheRecordSetCount--;
                prr = NULL;
                goto Done;
            }

            //
            // If the cached record is a CNAME, walk the record
            // list to see if the CNAME chain points to a record
            // that is the type we are looking for.
            //

            if ( prr->wType == DNS_TYPE_CNAME &&
                 Type != DNS_TYPE_CNAME )
            {
                PDNS_RECORD prrChain = prr->pNext;

                while ( prrChain )
                {
                    if ( prrChain->wType == Type )
                    {
                        //  chain to desired type -- take RR set
                        goto Done;
                    }
                    prrChain = prrChain->pNext;
                }
                prr = NULL;
                goto Done;
            }

            //  take RR set
            goto Done;
        }
    }
    //  type not found
    prr = NULL;

Done:

    DNSDBG( TRACE, (
        "Leave FindCacheEntryRecord() => %p\n",
        prr ));

    return prr;
}



PDNS_RECORD
FindCacheRecords(
    IN      PWSTR           pwsName,
    IN      WORD            wType
    )
/*++

Routine Description:

    Find records of given name and type in cache.

Arguments:

    pwsName -- name

    Type -- record type to find

Return Value:

    Ptr to record set of desired type -- if found.
    NULL if not found.

--*/
{
    PCACHE_ENTRY    pentry;
    PDNS_RECORD     prr = NULL;

    DNSDBG( TRACE, (
        "FindCacheRecords( %S, type=%d )\n",
        pwsName,
        wType ));

    pentry = FindCacheEntry( pwsName );
    if ( pentry )
    {
        prr = FindCacheEntryRecord(
                    pentry,
                    wType );
    }

    DNSDBG( TRACE, (
        "Leave FindCacheRecords( %S, type=%d ) => %p\n",
        pwsName,
        wType,
        prr ));

    return  prr;
}


//raw
VOID
CacheAnyAdditionalRecords(
    IN OUT  PDNS_RECORD     pRecord,
    IN      BOOL            fHostFile
    )
{
    BOOL            fcnameAnswer = FALSE;
    PCACHE_ENTRY    pentry = NULL;
    PDNS_RECORD     pnextRR = pRecord;
    PDNS_RECORD     prr;


    DNSDBG( TRACE, (
        "CacheAnyAdditionalRecords( rr=%p, hosts=%d )\n",
        pRecord,
        fHostFile ));

    //
    //  cache "additional" records
    //
    //  this is really cache additional OR
    //  cache the answer records for a CNAME at that CNAME
    //
    //  background:  Glenn's caching paradigm was to cache all answer
    //  data at the queried name in the API call (name might be short).
    //  However, not caching the CNAME data can cause problems, so this
    //  was tacked on.
    //
    //  For CNAME caching we throw away the CNAMEs themselves and just
    //  cache the actually data (address) records at the CNAME node.
    //

    //
    //  cache additional records
    //  

    while ( prr = pnextRR )
    {
        BOOL    fcacheSet = FALSE;

        pnextRR = Dns_RecordSetDetach( prr );

        //
        //  do NOT cache
        //      - answer records for queried name (not CNAME)
        //      - CNAME records when doing caching of answer data under CNAME
        //      - authority section records (NS, SOA, etc)
        //      - OPT records
        //
        //  DCR:  have some sort of "cacheable type" test
        //      which would screen out any transactional records
        //

        if ( fHostFile )
        {
            fcacheSet = TRUE;
        }
        else if ( prr->Flags.S.Section == DNSREC_ANSWER )
        {
            if ( prr->wType == DNS_TYPE_CNAME )
            {
                fcnameAnswer = TRUE;
            }
            else if ( fcnameAnswer )
            {
                fcacheSet = TRUE;
            }
        }
        else if ( prr->Flags.S.Section == DNSREC_ADDITIONAL )
        {
            if ( prr->wType != DNS_TYPE_OPT )
            {
                fcacheSet = TRUE;
            }
        }

        if ( !fcacheSet )
        {
            Dns_RecordListFree( prr );
            continue;
        }

        //
        //  cache the set
        //
        //  flip the section field to "Answer" section
        //
        //  DCR:  section caching?
        //
        //  note:  section fields in cache indicate whether
        //      answer data (or additional) once out of
        //      cache;
        //      this is necessary since we cache everything
        //      at node and return it in one RR list;  we'd
        //      to change must
        //          - return in different lists with some indication
        //              in cache of what's what
        //          OR
        //          - another indication of what's what
        //

        pentry = FindOrCreateCacheEntry(
                        prr->pName,
                        fHostFile
                        );
        if ( !pentry )
        {
            Dns_RecordListFree( prr );
        }
        else
        {
            //if ( !fHostFile )
            //  currently HostFile entries get answer too
            {
                PDNS_RECORD ptemp = prr;
                while ( ptemp )
                {
                    ptemp->Flags.S.Section = DNSREC_ANSWER;
                    ptemp = ptemp->pNext;
                }
            }
    
            PrepareRecordSetForCache( prr );
    
            AddRecordToCacheEntry(
                pentry,
                prr,
                ! fHostFile,    // flush if NOT hostfile load
                fHostFile
                );
        }
    }

    DNSDBG( TRACE, ( "Leave CacheAnyAdditionalRecords()\n" ));
}


//raw
BOOL
IsInvalidNegativeCacheEntry(
    IN      PDNS_RECORD     pRecord
    )
{
    DWORD  cacheTime;

    if ( pRecord->wDataLength != 0 )
    {
        return  FALSE;
    }

    //
    //  recover record cache time
    //

    cacheTime = g_MaxNegativeCacheTtl;
    if ( pRecord->wType == DNS_TYPE_SOA )
    {
        cacheTime = g_NegativeSOACacheTime;
    }

    //  should NEVER have absolute time less than time we cached for

    ASSERT( cacheTime <= pRecord->dwTtl );

    //
    //  check if last PnP AFTER this record was cached
    //

    DNSDBG( TRACE, (
        "IsInvalidNegativeCacheEntry( rr=%p ) => %d\n",
        pRecord,
        ( g_TimeOfLastPnPUpdate > (pRecord->dwTtl - cacheTime))
        ));

    return( g_TimeOfLastPnPUpdate > (pRecord->dwTtl - cacheTime) );
}

//
//  End cache.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\resolver\server\dnsmsg.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    dnsmsg.h

Abstract:

    DNS Resolver Service

    Message box string identifier definitions.

Author:

    Glenn Curtis (glennc)   April 1997

Revision History:

--*/


#ifndef _DNSMSG_INCLUDED_
#define _DNSMSG_INCLUDED_

//
// Message box string identifiers
//

#define DNS_CACHE_MSG_SERVICE           0x00001001
#define DNS_CACHE_MSG_NETSLOW           0x00001002
#define DNS_CACHE_MSG_DESCRIPTION       0x00001003


#endif // _DNSMSG_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\resolver\server\dnsrslvr.c ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    dnsrslvr.c

Abstract:

    DNS Resolver Service

    Main service module.

Author:

    Glenn Curtis    (glennc)    25-Feb-1997

Revision History:

    Jim Gilroy  (jamesg)        March 2000      cleanup
    Jim Gilroy  (jamesg)        Nov 2000        rewrite

--*/


#include "local.h"

#ifdef  BUILD_W2K
#include <services.h>
#else
#include <svcs.h>
#endif


//
//  Service control
//

SERVICE_STATUS              ServiceStatus;
SERVICE_STATUS_HANDLE       ServiceStatusHandle = (SERVICE_STATUS_HANDLE) 0;

#ifdef  BUILD_W2K
PSVCS_GLOBAL_DATA           g_pSvchostData;
#else
PSVCHOST_GLOBAL_DATA        g_pSvchostData;
#endif


HANDLE      g_hStopEvent;
BOOL        g_StopFlag;

BOOL        g_fServiceControlHandled;

//
//  Service state
//

#define RES_STATUS_BEGIN                0x0cc00000
#define RES_STATUS_ZERO_INIT            0x0cc00001
#define RES_STATUS_CREATED_CS           0x0cc00002
#define RES_STATUS_CREATED_EVENT        0x0cc00003
#define RES_STATUS_READ_REGISTRY        0x0cc00004
#define RES_STATUS_ALLOC_CACHE          0x0cc00005
#define RES_STATUS_START_NOTIFY         0x0cc00006
#define RES_STATUS_START_IP_LIST        0x0cc00007
#define RES_STATUS_START_RPC            0x0cc00008
#define RES_STATUS_REG_CONTROL          0x0cc00009
#define RES_STATUS_RUNNING              0x0cc00100
                                        
#define RES_STATUS_STOPPING             0x0cc00300
#define RES_STATUS_SIGNALED_STOP        0x0cc00301
#define RES_STATUS_STOP_RPC             0x0cc00302
#define RES_STATUS_STOP_NOTIFY          0x0cc00303
#define RES_STATUS_STOP_IP_LIST         0x0cc00304
#define RES_STATUS_FREE_CACHE           0x0cc00305
#define RES_STATUS_FREE_NET_INFO        0x0cc00306
#define RES_STATUS_FREE_IP_LIST         0x0cc00307
#define RES_STATUS_FREE_SERVICE_NOTIFY  0x0cc00308
#define RES_STATUS_DEL_EVENT            0x0cc00309
#define RES_STATUS_DEL_CS               0x0cc00310
#define RES_STATUS_END                  0x0cc00400

DWORD       g_ResolverStatus = RES_STATUS_BEGIN;

//
//  Initialization cleanup\state
//
//  Track what we intialized for safer\faster cleanup
//

#define INITFLAG_CS_CREATED             0x00000001
#define INITFLAG_WINSOCK                0x00000002
#define INITFLAG_EVENTS_CREATED         0x00000004
#define INITFLAG_CACHE_CREATED          0x00000008
#define INITFLAG_NOTIFY_STARTED         0x00000010
#define INITFLAG_IP_LIST_CREATED        0x00000020
#define INITFLAG_RPC_SERVER_STARTED     0x00000100

DWORD       g_InitState;


//
//  Critical sections used
//

CRITICAL_SECTION    CacheCritSec;
CRITICAL_SECTION    NetworkListCritSec;
CRITICAL_SECTION    NetworkFailureCritSec;


//
//  Logging control
//

BOOL        g_LogTraceInfo = TRUE;


//
//  Private protos
//

DWORD
ResolverInitialize(
    VOID
    );

VOID
ResolverShutdown(
    IN      DWORD           ErrorCode
    );

VOID
ResolverControlHandler(
    IN      DWORD           Opcode
    );

DWORD
ResolverUpdateStatus(
    VOID
    );


//
//  Service routines
//

//
//  NT5 version -- inside services.exe
//

#ifdef  BUILD_W2K

VOID
SVCS_ENTRY_POINT(
    DWORD               NumArgs,
    LPTSTR *            ArgsArray,
    PSVCS_GLOBAL_DATA   pSvcsGlobalData,
    HANDLE              SvcRefHandle
    )
/*++

Routine Description:

    Main main entry point of resolver service

Arguments:

    NumArgs - number of arguments to service start call

    ArgsArray - array of ptrs to arguments in service start call

Return Value:

    None

--*/
{
    //
    //  save pointer to service data block
    //

    g_pSvchostData = pSvcsGlobalData;

    ResolverInitialize();
}


#else
//
//  Whistler+ version -- in svchost.exe process
//

VOID
SvchostPushServiceGlobals(
    PSVCHOST_GLOBAL_DATA    pGlobals
    )
{
    g_pSvchostData = pGlobals;
}


VOID
ServiceMain(
    IN      DWORD           NumArgs,
    IN      LPTSTR *        ArgsArray
    )
/*++

Routine Description:

    Main entry point of resolver service.

Arguments:

    NumArgs - number of strings specified in ArgsArray.

    ArgsArray - array of ptrs to arguments in service start call

Return Value:

    None

--*/
{
    //
    //  Make sure svchost.exe gave us global data
    //

    ASSERT( g_pSvchostData != NULL );

    //
    //  Startup service, then exit
    //

    ResolverInitialize();
}

#endif  // NT4 \ Whistler+ switch



VOID
ResolverInitFailure(
    IN      DNS_STATUS      Status,
    IN      DWORD           EventId,
    IN      DWORD           MemEventId,
    IN      PSTR            pszDebugString
    )
/*++

Routine Description:

    Handle resolver init failure.

    Function exists to avoid duplicate code.

Arguments:

Return Value:

    None

--*/
{
    WCHAR   numberString[16];
    PWSTR   eventStrings[1];

    DNSLOG_TIME();
    DNSLOG_F1( "Resolver Init Failure" );
    DNSLOG_F2( "    Failure = %s", pszDebugString );
    DNSLOG_F2( "    Status  = %d", Status );
    DNSLOG_F1( "" );

    DNSDBG( ANY, (
        "Resolver Init FAILED!\n"
        "\tname         = %s\n"
        "\tstatus       = %d\n"
        "\tevent id     = %d\n"
        "\tmem event    = %08x\n",
        pszDebugString,
        Status,
        EventId,
        MemEventId ));

    DnsDbg_PrintfToDebugger(
        "ResolverInitialize - Returning status %d 0x%08x\n"
        "\tname = %s\n",
        Status, Status,
        pszDebugString );

    //
    //  log in memory event
    //

    LogEventInMemory( MemEventId, Status );

    //
    //  log event
    //      - convert status to string
    //

    wsprintfW( numberString, L"0x%.8X", Status );
    eventStrings[0] = numberString;

    ResolverLogEvent(
        EventId,
        EVENTLOG_ERROR_TYPE,
        1,
        eventStrings,
        Status );

    //  clean up

    ResolverShutdown( Status );
}



DWORD
ResolverInitialize(
    VOID
    )
/*++

Routine Description:

    This function initializes the DNS Caching Resolver service.

Arguments:

    InitState - Returns a flag to indicate how far we got with
                        initializing the service before an error occurred.

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNS_STATUS  status = NO_ERROR;

    //
    //  init service state
    //

    g_ResolverStatus = RES_STATUS_BEGIN;
    g_InitState = 0;
    g_StopFlag = FALSE;
    g_hStopEvent = NULL;
    g_fServiceControlHandled = FALSE;

    //
    //  initialize logging
    //

    DNSLOG_INIT();
    DNSLOG_F1( "DNS Caching Resolver Service - ResolverInitialize" );

#if DBG
#if 0
    Dns_StartDebug(
        0,
        "dnsres.flag",
        NULL,
        "dnsres.log",
        0 );
#endif
    Dns_StartDebugEx(
        0,                  //  no flag value
        "dnsres.flag",
        NULL,               //  no external flag
        "dnsres.log",
        0,                  //  no wrap limit
        FALSE,              //  don't use existing global
        FALSE,
        TRUE                //  make this file global
        );
#endif

    DNSDBG( INIT, ( "DNS resolver startup.\n" ));
    IF_DNSDBG( START_BREAK )
    {
        //  since resolver moved to NetworkServices permissions do
        //  not properly bring up ntsd;  instead just give time
        //  to attach debugger

        Sleep( 20000 );
    }

    //
    //  initialize service status block
    //      

    ServiceStatusHandle = (SERVICE_STATUS_HANDLE) 0;

    ServiceStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
    ServiceStatus.dwCurrentState = SERVICE_START_PENDING;
    ServiceStatus.dwControlsAccepted = 0;
    ServiceStatus.dwCheckPoint = 0;
    ServiceStatus.dwWaitHint = 5000;
    ServiceStatus.dwWin32ExitCode = NO_ERROR;
    ServiceStatus.dwServiceSpecificExitCode = 0;

    ResolverUpdateStatus();

    //
    //  init globals to zero
    //

    ZeroInitIpListGlobals();
    ZeroNetworkConfigGlobals();
    g_ResolverStatus = RES_STATUS_ZERO_INIT;

    //
    //  initialize all our critical sections as soon as we can
    //

    LogEventInMemory( RES_EVENT_INITCRIT_START, 0 );
    InitializeCriticalSection( & CacheCritSec );
    InitializeCriticalSection( & NetworkListCritSec );
    InitializeCriticalSection( & NetworkFailureCritSec );
    LogEventInMemory( RES_EVENT_INITCRIT_END,0  );

    //
    //  init our dnslib heap to use dnsapi heap
    //
    //  this is important because we currently mix and match records
    //  created inside dnsapi (hosts file and query) with a few that
    //  we roll on our own;  need this to be common
    //

    Dns_LibHeapReset( DnsApiAlloc, DnsApiRealloc, DnsApiFree );

    //
    //  init winsock
    //

    Dns_InitializeWinsock();
    g_InitState |= INITFLAG_WINSOCK;

    //
    //  shutdown event
    //

    g_hStopEvent = CreateEvent(
                        NULL,       // no security descriptor
                        TRUE,       // do not use automatic reset
                        FALSE,      // initial state: not signalled
                        NULL        // no name
                        );
    if ( !g_hStopEvent )
    {
        status = GetLastError();

        ResolverInitFailure(
            status,
            0,
            0,
            "CreateEvent() failed" );
        return status;
    }
    g_InitState |= INITFLAG_EVENTS_CREATED;
    g_ResolverStatus = RES_STATUS_CREATED_EVENT;

    ResolverUpdateStatus();

    //
    //  initialize our global registry values
    //      - force this just once on startup so we have the
    //      relevant cache params;  after that read only on
    //      demand when building netinfo blobs

    ReadRegistryConfig();

    //
    //  Set the query timeouts to be used from defaults or registry
    //

    Dns_InitQueryTimeouts();

    //
    //  init socket caching
    //      - improves perf and prevents socket DOS attack
    //      - default cache to 10 sockets
    //
    //  DCR:  create global for socket caching
    //
    
    Dns_CacheSocketInit( 10 );

#if 0
    //
    //  start cache on demand now
    //

    //
    //  initialize cache
    //

    status = Cache_Initialize();

    LogEventInMemory( RES_EVENT_INITCACHE, status );

    if ( status != NO_ERROR )
    {
        ResolverInitFailure(
            status,
            EVENT_DNS_CACHE_START_FAILURE_NO_CONTROL,
            0,
            "Cache_Initialize() failed" );
        return status;
    }
    g_InitState |= INITFLAG_CACHE_CREATED;
    g_ResolverStatus = RES_STATUS_ALLOC_CACHE;
    ResolverUpdateStatus();
#endif

    //
    //  notification thread (host file and registry)
    //

    StartNotify();
    g_InitState |= INITFLAG_NOTIFY_STARTED;
    g_ResolverStatus = RES_STATUS_START_NOTIFY;
    ResolverUpdateStatus();

    //
    //  IP notification thread
    //

    status = InitIpListAndNotification();
    if ( status != ERROR_SUCCESS )
    {
        ResolverInitFailure(
            status,
            0,
            0,
            "IP list init failed" );
        return status;
    }
    g_InitState |= INITFLAG_IP_LIST_CREATED;
    g_ResolverStatus = RES_STATUS_START_IP_LIST;
    ResolverUpdateStatus();

    //
    //  register control handler
    //  allows us to receive service requests
    //

    ServiceStatusHandle = RegisterServiceCtrlHandlerW(
                                DNS_RESOLVER_SERVICE,
                                ResolverControlHandler
                                );
    if ( !ServiceStatusHandle )
    {
        status = GetLastError();
        ResolverInitFailure(
            status,
            EVENT_DNS_CACHE_START_FAILURE_LOW_MEMORY,
            RES_EVENT_REGISTER_SCH,
            "Call to RegisterServiceCtrlHandlerW failed!"
            );
        return status;
    }
    g_ResolverStatus = RES_STATUS_REG_CONTROL;
    ResolverUpdateStatus();

    //
    //  initialize RPC interfaces
    //      - bump our requested stack size up to 8K
    //      (RPC uses 1800 bytes before we get the stack,
    //      the new() operator followed by the heap code uses
    //      another 1200 -- leaving only about a 1000 for
    //      DNS)
    //

    LogEventInMemory( RES_EVENT_STARTRPC, 0 );

#if 0
    //  should not be necessary
    //  default for all svchost instances has been increased
    if ( status != NO_ERROR )
    {
        DNSDBG( ANY, (
            "RpcMgmtSetServerStackSize( 2000 ) = %d\n",
            status ));
    }
#endif

    status = Rpc_Initialize();
#if 0
    status = g_pSvchostData->StartRpcServer(
                                SERVER_INTERFACE_NAME_W,
                                DnsResolver_ServerIfHandle );
#endif
    if ( status != NO_ERROR )
    {
        LogEventInMemory( RES_EVENT_STATUS, status );

        if ( status == RPC_S_TYPE_ALREADY_REGISTERED ||
             status == RPC_NT_TYPE_ALREADY_REGISTERED )
        {
            DNSLOG_TIME();
            DNSLOG_F1( "   Call to StartRpcServer returned warning that" );
            DNSLOG_F1( "   the service is already running!" );
            DNSLOG_F2( "   RpcPipeName : %S", RESOLVER_INTERFACE_NAME_W );
            DNSLOG_F1( "   Going to just continue running . . ." );
            DNSLOG_F1( "" );

            DnsDbg_PrintfToDebugger(
                "DNS Client (dnsrslvr.dll) - Call to StartRpcServer\n"
                "returned warning that the service is already running!\n"
                "RpcPipeName : %S"
                "Going to just continue running . . .\n",
                RESOLVER_INTERFACE_NAME_W );

            status = NO_ERROR;
        }
        else
        {
            DNSDBG( ANY, (
                "RPC init FAILED!  status = %d\n"
                "\tpipe name = %s\n",
                status,
                RESOLVER_INTERFACE_NAME_W ));

            ResolverInitFailure(
                status,
                EVENT_DNS_CACHE_START_FAILURE_NO_RPC,
                0,
                "Call to StartRpcServer failed!"
                );
            return status;
        }
    }

    g_ResolverStatus = RES_STATUS_START_RPC;
    g_InitState |= INITFLAG_RPC_SERVER_STARTED;

    //
    //  successful startup
    //      - indicate running
    //      - indicate what service control messages we want to get
    //

    ServiceStatus.dwCurrentState = SERVICE_RUNNING;
    ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |
                                        SERVICE_ACCEPT_PARAMCHANGE |
                                        SERVICE_ACCEPT_NETBINDCHANGE;
    ServiceStatus.dwWaitHint = 0;
    ServiceStatus.dwWin32ExitCode = NO_ERROR;

    ResolverUpdateStatus();

    g_ResolverStatus = RES_STATUS_RUNNING;

    DNSLOG_F1( "ResolverInitialize - Successful" );
    DNSLOG_F1( "" );
    return NO_ERROR;
}



VOID
ResolverShutdown(
    IN      DWORD           ErrorCode
    )
/*++

Routine Description:

    This function shuts down the DNS cache service.

Arguments:

    ErrorCode - Supplies the error code of the failure

Return Value:

    None.

--*/
{
    DWORD   status = NO_ERROR;
    LONG    existingStopFlag;

    DNSLOG_TIME();
    DNSLOG_F1( "DNS Caching Resolver Service - ResolverShutdown" );
    DnsDbg_PrintfToDebugger( "DNS Client - ResolverShutdown!\n" );

    //
    //  indicate shutdown
    //      - but interlock to avoid dual shutdown
    //

    existingStopFlag = InterlockedExchange(
                            &g_StopFlag,
                            (LONG) TRUE );
    if ( existingStopFlag )
    {
        DNS_ASSERT( FALSE );
        return;
    }
    DNS_ASSERT( g_StopFlag );

    //
    //  indicate stop in progress
    //

    ServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
    ServiceStatus.dwCheckPoint = 1;
    ServiceStatus.dwWaitHint = 60000;
    ResolverUpdateStatus();

    g_ResolverStatus = RES_STATUS_STOPPING;

    //
    //  wakeup threads to shut down
    //

    g_StopFlag = TRUE;
    if ( g_hStopEvent )
    {
        if ( !SetEvent(g_hStopEvent) )
        {
            DnsDbg_PrintfToDebugger(
                "DNSCACHE: Error setting g_hStopEvent %lu\n",
                GetLastError());
            DNS_ASSERT( FALSE );
        }
    }
    g_ResolverStatus = RES_STATUS_SIGNALED_STOP;

    //
    //  cleanup RPC
    //

    if ( g_InitState & INITFLAG_RPC_SERVER_STARTED )
    {
        LogEventInMemory( RES_EVENT_STOPRPC, 0 );

        Rpc_Shutdown();
#if 0
        //status = g_pSvchostData->StopRpcServer( DnsResolver_ServerIfHandle );
#endif
        LogEventInMemory( RES_EVENT_STATUS, status );
    }
    g_ResolverStatus = RES_STATUS_STOP_RPC;

    //
    //  re-signal stop within lock
    //

    LOCK_CACHE_NO_START();
    g_StopFlag = TRUE;
    if ( g_hStopEvent )
    {
        if ( !SetEvent(g_hStopEvent) )
        {
            DnsDbg_PrintfToDebugger(
                "DNSCACHE: Error setting g_hStopEvent %lu\n",
                GetLastError());
            DNS_ASSERT( FALSE );
        }
    }
    UNLOCK_CACHE();

    //
    //  stop notify thread
    //

    if ( g_InitState & INITFLAG_NOTIFY_STARTED )
    {
        ShutdownNotify();
    }
    g_ResolverStatus = RES_STATUS_STOP_NOTIFY;

    //
    //  stop IP notify thread
    //

    if ( g_InitState & INITFLAG_IP_LIST_CREATED )
    {
        ShutdownIpListAndNotify();
    }
    g_ResolverStatus = RES_STATUS_STOP_IP_LIST;

    //
    //  cleanup cache
    //

    Cache_Shutdown();
    g_ResolverStatus = RES_STATUS_FREE_CACHE;

    //
    //  cleanup service notification list
    //

    //CleanupServiceNotification();
    //g_ResolverStatus = RES_STATUS_FREE_SERVICE_NOTIFY;

    //
    //  cleanup network info globals
    //

    CleanupNetworkInfo();
    g_ResolverStatus = RES_STATUS_FREE_NET_INFO;

    //
    //  cleanup winsock
    //  cleanup socket caching also
    //      - this is irrelevant for other services running in
    //      our process so we shouldn't leave the handles open
    //  

    if ( g_InitState & INITFLAG_WINSOCK )
    {
        Dns_CacheSocketCleanup();
        Dns_CleanupWinsock();
    }

    //
    //  cleanup main shutdown event
    //

    if ( g_InitState & INITFLAG_EVENTS_CREATED )
    {
        if ( g_hStopEvent )
        {
            CloseHandle(g_hStopEvent);
            g_hStopEvent = NULL;
        }
    }
    g_ResolverStatus = RES_STATUS_DEL_EVENT;

    //
    //  delete critical sections
    //

    if ( g_InitState & INITFLAG_CS_CREATED )
    {
        LogEventInMemory( RES_EVENT_DELCRIT_START, 0 );
        DeleteCriticalSection( &CacheCritSec );
        DeleteCriticalSection( &NetworkListCritSec );
        DeleteCriticalSection( &NetworkFailureCritSec );
        LogEventInMemory( RES_EVENT_DELCRIT_END, 0 );
    }
    g_ResolverStatus = RES_STATUS_DEL_CS;

    //
    //  cleanup complete
    //  tell Service Controller that we are stopped
    //

    ServiceStatus.dwCurrentState = SERVICE_STOPPED;
    ServiceStatus.dwControlsAccepted = 0;
    ServiceStatus.dwWin32ExitCode = ErrorCode;
    ServiceStatus.dwServiceSpecificExitCode = 0;
    ServiceStatus.dwCheckPoint = 0;
    ServiceStatus.dwWaitHint = 0;

    ResolverUpdateStatus();

    g_ResolverStatus = RES_STATUS_END;

    DNSLOG_F1( "ResolverShutdown - Finished" );
    DNSLOG_F1( "" );
}



BOOL
GetServiceControlLock(
    VOID
    )
/*++

Routine Description:

    Get exclusive access handling service control message.

Arguments:

    None

Return Value:

    TRUE -- have exclusive access to handle SCM, other threads locked out
    FALSE -- another thread still handling SCM

--*/
{
    BOOL    fresult;

    //
    //  set handled flag, if not previously set
    //  if not previous set -> we have exclusive access
    //

    fresult = InterlockedCompareExchange(
                    &g_fServiceControlHandled,
                    (LONG) TRUE,    // new value
                    (LONG) 0        // previous value to do exchange
                    );

    return  !fresult;
}


VOID
ReleaseServiceControlLock(
    VOID
    )
/*++

Routine Description:

    Release service control exclusive access.

Arguments:

    None

Return Value:

    None

--*/
{
    //
    //  clear handled flag
    //      - since GetServiceControlLock() uses CompareExchange
    //      we can just clear without interlock
    //  

    DNS_ASSERT( g_fServiceControlHandled );
    g_fServiceControlHandled = FALSE;
}




VOID
ResolverControlHandler(
    IN      DWORD           Opcode
    )
/*++

Routine Description:

    Service control handler for DNS cache service.

Arguments:

    Opcode - specifies service action

Return Value:

    None.

--*/
{
    LogEventInMemory( RES_EVENT_SCH, Opcode );

    DNSLOG_TIME();
    DNSLOG_F2( "ResolverControlHandler - Recieved opcode %d", Opcode );

    DNSDBG( ANY, (
        "\n\n"
        "ResolverControlHandler()  Opcode = %d\n",
        Opcode ));

    //
    //  handle various service control codes
    //

    switch( Opcode )
    {

    case SERVICE_CONTROL_STOP:

        ResolverShutdown( NO_ERROR );
        break;

    case SERVICE_CONTROL_PARAMCHANGE :

        DNSLOG_F1( "  Handle Paramchange" );
        DNSLOG_F1( "" );

        if ( !GetServiceControlLock() )
        {
            return;
        }

        //
        //  rebuild -- with cache flush
        //

        HandleConfigChange(
            "SC -- ParamChange",
            TRUE        // flush cache
            );

        //
        //  signal other services about PnP
        //
        // SendServiceNotifications();

        ReleaseServiceControlLock();
        break;

    case SERVICE_CONTROL_NETBINDENABLE:
    case SERVICE_CONTROL_NETBINDDISABLE:

        DNSLOG_F1( "  Handle NetBindEnable\\Disable" );
        DNSLOG_F1( "" );

        if ( !GetServiceControlLock() )
        {
            return;
        }

        //
        //  rebuild -- with cache flush
        //

        HandleConfigChange(
            "SC -- NetBind",
            TRUE        // flush cache
            );

        ReleaseServiceControlLock();
        break;

    case SERVICE_CONTROL_INTERROGATE:
    case SERVICE_CONTROL_NETBINDADD:
    case SERVICE_CONTROL_NETBINDREMOVE:
    default:

        DNSLOG_F1( "    This is an unknown opcode, ignoring ..." );
        DNSLOG_F1( "" );
        break;
    }

    //
    //  update service status
    //

    ResolverUpdateStatus();

    DNSLOG_F2( "Resolver Controll Handler (opcode = %d) -- returning", Opcode );

    DNSDBG( ANY, (
        "Leaving ResolverControlHandler( %d )\n\n\n",
        Opcode ));
}



DWORD
ResolverUpdateStatus(
    VOID
    )
/*++

Routine Description:

    Update service controller with current service status.

Arguments:

    None.

Return Value:

    Return code from SetServiceStatus.

--*/
{
    DWORD status = NO_ERROR;

    DNSDBG( TRACE, ( "ResolverUpdateStatus()\n" ));

    //
    //  bump the checkpoint
    //  if status, set it

    ServiceStatus.dwCheckPoint++;
#if 0
    if ( Status )
    {
        ServiceStatus.dwWin32ExitCode = Status;
    }
#endif

    //
    //  DCR_FIX:  this doesn't do much
    //      usually people write something like this that sets the service
    //      state AND does the update
    //
    //  QUESTION:  what's up with the LogEventInMemory?
    //

    if ( ServiceStatusHandle == (SERVICE_STATUS_HANDLE) 0 )
    {
        LogEventInMemory( RES_EVENT_UPDATE_STATUS, ERROR_INVALID_HANDLE );
        return ERROR_INVALID_HANDLE;
    }

    LogEventInMemory( RES_EVENT_UPDATE_STATUS, ServiceStatus.dwWin32ExitCode );

    if ( ! SetServiceStatus( ServiceStatusHandle, &ServiceStatus ) )
    {
        status = GetLastError();
    }

    LogEventInMemory( RES_EVENT_UPDATE_STATUS, status );

    return status;
}



//
//  Event logging
//

VOID
ResolverLogEvent(
    IN      DWORD           MessageId,
    IN      WORD            EventType,
    IN      DWORD           StringCount,
    IN      PWSTR *         StringArray,
    IN      DWORD           ErrorCode
    )
/*++

Routine Description:

    Log to eventlog.

Arguments:

    MessageId -- event message id

    EventType -- event type (error, warning, info, etc.)

    StringCount -- string arg count

    StringArray -- imbedded strings

    ErrorCode -- error code for data section of event

Return Value:

    None

--*/
{
    HANDLE  hlog;
    PVOID   pdata = NULL;

    //
    //  open resolver as event source
    //
    //  note:  we don't keep log open because events are few
    //

    hlog = RegisterEventSourceW(
                    NULL,
                    DNS_RESOLVER_SERVICE );

    if ( hlog == NULL )
    {
        return;
    }

    if ( ErrorCode != NO_ERROR )
    {
        pdata = &ErrorCode;
    }

    //
    //  Write to event log
    //
    //  DCR:  should get suppression technology here
    //

    ReportEventW(
        hlog,
        EventType,
        0,            // event category
        MessageId,
        (PSID) NULL,
        (WORD) StringCount,
        sizeof(DWORD),
        StringArray,
        (PVOID) pdata );
    
    DeregisterEventSource( hlog );
}


//
//  End dnsrslvr.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\resolver\server\ip.c ===
/*++

Copyright (c) 2000-2000  Microsoft Corporation

Module Name:

    ip.c

Abstract:

    DNS Resolver Service.

    IP list and change notification.

Author:

    Jim Gilroy  (jamesg)    November 2000

Revision History:

--*/


#include "local.h"
#include "iphlpapi.h"


//
//  IP notify thread globals
//

HANDLE          g_IpNotifyThread;
DWORD           g_IpNotifyThreadId;

HANDLE          g_IpNotifyEvent;
HANDLE          g_IpNotifyHandle;
OVERLAPPED      g_IpNotifyOverlapped;


//
//  IP Address list values
//

PDNS_ADDR_ARRAY     g_LocalAddrArray;

PIP_ARRAY           g_ClusterIpArray;
IP_ADDRESS          g_OldClusterIp;


//
//  Cluster record TTLs -- use max TTL
//

#define CLUSTER_RECORD_TTL  (g_MaxCacheTtl)


//
//  Shutdown\close locking
//
//  Since GQCS and GetOverlappedResult() don't directly wait
//  on StopEvent, we need to be able to close notification handle
//  and port in two different threads.
//
//  Note:  this should probably be some general CS that is
//  overloaded to do service control stuff.
//  I'm not using the server control CS because it's not clear
//  that the functions it does in dnsrslvr.c even need locking.
//

#define LOCK_IP_NOTIFY_HANDLE()     EnterCriticalSection( &NetworkFailureCritSec )
#define UNLOCK_IP_NOTIFY_HANDLE()   LeaveCriticalSection( &NetworkFailureCritSec )

CRITICAL_SECTION        g_IpListCS;

#define LOCK_IP_LIST()     EnterCriticalSection( &g_IpListCS );
#define UNLOCK_IP_LIST()   LeaveCriticalSection( &g_IpListCS );



//
//  Cluster Tag
//

#define CLUSTER_TAG     0xd734453d



VOID
CloseIpNotifyHandle(
    VOID
    )
/*++

Routine Description:

    Close IP notify handle.

    Wrapping up code since this close must be MT
    safe and is done in several places.

Arguments:

    None

Return Value:

    None

--*/
{
    LOCK_IP_NOTIFY_HANDLE();
    if ( g_IpNotifyHandle )
    {
        //CloseHandle( g_IpNotifyHandle );
        PostQueuedCompletionStatus(
            g_IpNotifyHandle,
            0,      // no bytes
            0,      // no key
            & g_IpNotifyOverlapped );

        g_IpNotifyHandle = NULL;
    }
    UNLOCK_IP_NOTIFY_HANDLE();
}



DNS_STATUS
IpNotifyThread(
    IN      LPVOID  pvDummy
    )
/*++

Routine Description:

    IP notification thread.

Arguments:

    pvDummy -- unused

Return Value:

    NO_ERROR on normal service shutdown
    Win32 error on abnormal termination

--*/
{
    DNS_STATUS      status;
    DWORD           bytesRecvd;
    BOOL            fstartedNotify;
    BOOL            fhaveIpChange = FALSE;
    BOOL            fsleep = FALSE;
    HANDLE          notifyHandle;


    DNSDBG( INIT, ( "\nStart IpNotifyThread.\n" ));

    g_IpNotifyHandle = NULL;

    //
    //  wait in loop on notifications
    //

    while ( !g_StopFlag )
    {
        //
        //  spin protect
        //      - if error in previous NotifyAddrChange or
        //      GetOverlappedResult do short sleep to avoid
        //      chance of hard spin
        //

        if ( fsleep )
        {
            WaitForSingleObject(
               g_hStopEvent,
               60000 );
            fsleep = FALSE;
            continue;
        }

        //
        //  start notification
        //
        //  do this before checking result as we want notification
        //  down BEFORE we read so we don't leave window where
        //  IP change is not picked up
        //
    
        RtlZeroMemory(
            &g_IpNotifyOverlapped,
            sizeof(OVERLAPPED) );

        if ( g_IpNotifyEvent )
        {
            g_IpNotifyOverlapped.hEvent = g_IpNotifyEvent;
            ResetEvent( g_IpNotifyEvent );
        }
        notifyHandle = 0;
        fstartedNotify = FALSE;

        status = NotifyAddrChange(
                    & notifyHandle,
                    & g_IpNotifyOverlapped );

        if ( status == ERROR_IO_PENDING )
        {
            DNSDBG( INIT, (
                "NotifyAddrChange()\n"
                "\tstatus           = %d\n"
                "\thandle           = %d\n"
                "\toverlapped event = %d\n",
                status,
                notifyHandle,
                g_IpNotifyOverlapped.hEvent ));

            g_IpNotifyHandle = notifyHandle;
            fstartedNotify = TRUE;
        }
        else
        {
            DNSDBG( ANY, (
                "NotifyAddrChange() FAILED\n"
                "\tstatus           = %d\n"
                "\thandle           = %d\n"
                "\toverlapped event = %d\n",
                status,
                notifyHandle,
                g_IpNotifyOverlapped.hEvent ));

            fsleep = TRUE;
        }

        if ( g_StopFlag )
        {
            goto Done;
        }

        //
        //  previous notification -- refresh data
        //
        //  FlushCache currently include local IP list
        //  sleep keeps us from spinning in this loop
        //
        //  DCR:  better spin protection;
        //      if hit X times then sleep longer?
        //
    
        if ( fhaveIpChange )
        {
            DNSDBG( ANY, ( "\nIP notification, flushing cache and restarting.\n" ));
            HandleConfigChange(
                "IP-notification",
                TRUE        // flush cache
                );
            fhaveIpChange = FALSE;
        }

        //
        //  starting --
        //  clear list to force rebuild of IP list AFTER starting notify
        //  so we can know that we don't miss any changes;
        //  need this on startup, but also to protect against any
        //  NotifyAddrChange failues
        //

        else if ( fstartedNotify )
        {
            ClearLocalAddrArray();
        }

        //
        //  anti-spin protection
        //      - 15 second sleep between any notifications
        //

        WaitForSingleObject(
           g_hStopEvent,
           15000 );

        if ( g_StopFlag )
        {
            goto Done;
        }

        //
        //  wait on notification
        //      - save notification result
        //      - sleep on error, but never if notification
        //

        if ( fstartedNotify )
        {
            fhaveIpChange = GetOverlappedResult(
                                g_IpNotifyHandle,
                                & g_IpNotifyOverlapped,
                                & bytesRecvd,
                                TRUE        // wait
                                );
            fsleep = !fhaveIpChange;

            status = NO_ERROR;
            if ( !fhaveIpChange )
            {
                status = GetLastError();
            }
            DNSDBG( ANY, (
                "GetOverlappedResult() => %d.\n"
                "\t\tstatus = %d\n",
                fhaveIpChange,
                status ));
        }
    }

Done:

    DNSDBG( ANY, ( "Stop IP Notify thread on service shutdown.\n" ));

    CloseIpNotifyHandle();

    return( status );
}



VOID
ZeroInitIpListGlobals(
    VOID
    )
/*++

Routine Description:

    Zero-init IP globals just for failure protection.

    The reason to have this is there is some interaction with
    the cache from the notify thread.  To avoid that being a
    problem we start the cache first.

    But just for safety we should at least zero init these
    globals first to protect us from cache touching them.

Arguments:

Return Value:

    NO_ERROR on normal service shutdown
    Win32 error on abnormal termination

--*/
{
    //
    //  clear out globals to smoothly handle failure cases
    //

    g_LocalAddrArray    = NULL;
    g_ClusterIpArray    = NULL;
    g_OldClusterIp      = 0;

    g_IpNotifyThread    = NULL;
    g_IpNotifyThreadId  = 0;
    g_IpNotifyEvent     = NULL;
    g_IpNotifyHandle    = NULL;
}



DNS_STATUS
InitIpListAndNotification(
    VOID
    )
/*++

Routine Description:

    Start IP notification thread.

Arguments:

    None

Globals:

    Initializes IP list and notify thread globals.

Return Value:

    NO_ERROR on normal service shutdown
    Win32 error on abnormal termination

--*/
{
    DNS_STATUS  status = NO_ERROR;

    DNSDBG( TRACE, ( "InitIpListAndNotification()\n" ));

    //
    //  CS for IP list access
    //

    InitializeCriticalSection( &g_IpListCS );

    //
    //  create event for overlapped I/O
    //

    g_IpNotifyEvent = CreateEvent(
                        NULL,       //  no security descriptor
                        TRUE,       //  manual reset event
                        FALSE,      //  start not signalled
                        NULL        //  no name
                        );
    if ( !g_IpNotifyEvent )
    {
        status = GetLastError();
        DNSDBG( ANY, ( "\nFAILED IpNotifyEvent create.\n" ));
        goto Done;
    }

    //
    //  fire up IP notify thread
    //

    g_IpNotifyThread = CreateThread(
                            NULL,
                            0,
                            (LPTHREAD_START_ROUTINE) IpNotifyThread,
                            NULL,
                            0,
                            & g_IpNotifyThreadId
                            );
    if ( !g_IpNotifyThread )
    {
        status = GetLastError();
        DNSDBG( ANY, (
            "FAILED to create IP notify thread = %d\n",
            status ));
    }

Done:

    //  not currently stopping on init failure

    return( ERROR_SUCCESS );
}



VOID
ShutdownIpListAndNotify(
    VOID
    )
/*++

Routine Description:

    Stop IP notify thread.

    Note:  currently this is blocking call, we'll wait until
        thread shuts down.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DNSDBG( TRACE, ( "ShutdownIpListAndNotify()\n" ));

    //
    //  MUST be stopping
    //      - if not thread won't wake
    //

    ASSERT( g_StopFlag );

    g_StopFlag = TRUE;

    //
    //  close IP notify handles -- waking thread if still running
    //

    if ( g_IpNotifyEvent )
    {
        SetEvent( g_IpNotifyEvent );
    }
    CloseIpNotifyHandle();

    //
    //  wait for thread to stop
    //

    ThreadShutdownWait( g_IpNotifyThread );
    g_IpNotifyThread = NULL;

    //
    //  cleanup IP lists
    //

    if ( g_LocalAddrArray )
    {
        GENERAL_HEAP_FREE( g_LocalAddrArray );
        g_LocalAddrArray = NULL;
    }
    if ( g_ClusterIpArray )
    {
        GENERAL_HEAP_FREE( g_ClusterIpArray );
        g_ClusterIpArray = NULL;
        g_OldClusterIp = 0;
    }

    //
    //  close event
    //

    CloseHandle( g_IpNotifyEvent );
    g_IpNotifyEvent = NULL;

    //
    //  kill off CS
    //

    DeleteCriticalSection( &g_IpListCS );
}



//
//  IP list routines
//

DWORD
SizeForAddrArray(
    IN      DWORD           AddrCount
    )
/*++

Routine Description:

    Determine size for addr array of given count.

Arguments:

    AddrCount -- count of addresses

Return Value:

    Size in bytes required for addr array.

--*/
{
    return  sizeof(DNS_ADDR_ARRAY) + (AddrCount * sizeof(DNS_ADDR_INFO));
}



PDNS_ADDR_ARRAY
CopyAddrArray(
    IN      PDNS_ADDR_ARRAY     pAddrArray
    )
/*++

Routine Description:

    Create copy of address info array.

Arguments:

    pAddrArray -- ptr to addr info array to copy

Return Value:

    Ptr to new addr array.

--*/
{
    PDNS_ADDR_ARRAY pnew;
    DWORD           size;

    DNSDBG( TRACE, ( "CopyAddrArray()\n" ));

    //
    //  alloc memory and copy
    //

    size = SizeForAddrArray( pAddrArray->AddrCount );

    pnew = (PDNS_ADDR_ARRAY) GENERAL_HEAP_ALLOC( size );
    if ( pnew )
    {
        RtlCopyMemory(
            pnew,
            pAddrArray,
            size
            );
    }

    return pnew;
}



VOID
ClearLocalAddrArray(
    VOID
    )
/*++

Routine Description:

    Clear the IP list data.

Arguments:

    None.

Globals:

    Updates IP list globals.

Return Value:

    None.

--*/
{
    PDNS_ADDR_ARRAY     poldArray;

    DNSDBG( TRACE, ( "ClearLocalAddrArray()\n" ));

    //
    //  clear new list
    //
    //  must go through lock even if no list, in case another
    //  thread started building new list before our call
    //

    LOCK_IP_LIST();

    poldArray = g_LocalAddrArray;
    g_LocalAddrArray = NULL;

    UNLOCK_IP_LIST();

    //  free old list

    if ( poldArray )
    {
        GENERAL_HEAP_FREE( poldArray );
    }
}



PDNS_ADDR_ARRAY
GetLocalAddrArray(
    VOID
    )
/*++

Routine Description:

    Get copy of local IP address info list.

    Note:  caller must free list.

    //
    //  DCR:  just direct return of counted array
    //      - include IPv6
    //

Arguments:

    None

Globals:

    May update IP list globals.

Return Value:

    Ptr to local addr info array.   Caller must free.
    NULL on allocation failure.

--*/
{
    PDNS_ADDR_ARRAY pnew = NULL;
    DWORD           size;

    DNSDBG( TRACE, ( "GetLocalAddrArray()\n" ));

    LOCK_IP_LIST();

    //
    //  if no current list -- try to get one
    //

    if ( !g_LocalAddrArray )
    {
        g_LocalAddrArray = DnsGetLocalAddrArrayDirect();
        if ( !g_LocalAddrArray )
        {
            goto Unlock;
        }
        IF_DNSDBG( INIT )
        {
            DnsDbg_DnsAddrArray(
                "New IP address info:",
                g_LocalAddrArray
                );
        }
    }

    //
    //  alloc memory and copy
    //

    pnew = CopyAddrArray( g_LocalAddrArray );

Unlock:

    UNLOCK_IP_LIST();

    return pnew;
}



VOID
RegisterClusterIp4Address(
    IN      IP_ADDRESS      ClusterIp,
    IN      BOOL            fAdd
    )
/*++

Routine Description:

    Register IP4 cluster IP.

Arguments:

    ClusterIp -- IP of cluster

    fAdd -- TRUE if adding cluster IP, FALSE if deleting

Return Value:

    None

--*/
{
    DNSLOG_F1( "RegisterClusterIp4Address" );

    DNSDBG( RPC, (
        "RegisterClusterIp4Address\n"
        "\tClusterIp = %s\n"
        "\tfAdd = %d\n",
        IP_STRING( ClusterIp ),
        fAdd ));

    LOCK_IP_LIST();

    //
    //  adding, add to exclusion list
    //      

    if ( fAdd )
    {
        //  put IP in cluster array
        //      - if array is full (or nonexistant), allocate bigger one
        //          and slap IP in again

        if ( ! Dns_AddIpToIpArray(
                    g_ClusterIpArray,
                    ClusterIp ) )
        {
            g_ClusterIpArray = Dns_CopyAndExpandIpArray(
                                    g_ClusterIpArray,
                                    25,     // expand by 20 slots
                                    TRUE    // delete existing copy
                                    );
            Dns_AddIpToIpArray(
                 g_ClusterIpArray,
                 ClusterIp );
        }
    }

    //
    //  deleting remove from exclusion list
    //      - but save old cluster IP as global until we are
    //      sure it is gone
    //

    else
    {
        g_OldClusterIp = ClusterIp;

        if ( !g_ClusterIpArray )
        {
            goto Refresh;
        }
        Dns_ClearIpFromIpArray(
            g_ClusterIpArray,
            ClusterIp );
    }

Refresh:

    //  no need to clear local array
    //      
    //  IP help gives us notification of cluster IP change;  since
    //  cluster calls us after making change, we've probably already
    //  been notified and done reread;  since we don't keep a global
    //  filtered list there's no need to dump it
    //

    //  ClearLocalAddrArray();

    IF_DNSDBG( INIT )
    {
        DnsDbg_IpArray(
            "Cluster Exclusion Array:",
            NULL,
            g_ClusterIpArray
            );
        DnsDbg_Printf(
            "Old Cluster IP = %s\n",
            IP_STRING( g_OldClusterIp ) );
    }

    UNLOCK_IP_LIST();
}



DWORD
RemoveClusterIpFromAddrArray(
    IN OUT  PDNS_ADDR_ARRAY     pAddrArray
    )
/*++

Routine Description:

    Screen cluster addresses from IP list.

    Note, assumes caller has network info locked.

Arguments:

    pAddrArray -- array with unscreened address info

    AddrCount -- count of addresses

Return Value:

    Count after screening

--*/
{
    DWORD       loadIndex = 0;
    DWORD       testIndex;
    IP_ADDRESS  ip;
    BOOL        fexclusion = FALSE;
    BOOL        fexcludeOldCluster = FALSE;


    DNSDBG( TRACE, (
        "RemoveClusterIpFromAddrArray()\n" ));

    //
    //  screen IP address list for cluster IPs
    //
    //  note, we do a push down here because we want to maintain order
    //      or remaining IP addresses
    //
    //  note, we could have this function do a copy from source to
    //      destination, so we aren't copying twice in this case;
    //      i don't see this as a big win
    //

    for ( testIndex = 0;
          testIndex < pAddrArray->AddrCount;
          testIndex++ )
    {
        ip = pAddrArray->AddrArray[testIndex].IpAddr;

        if ( ip == g_OldClusterIp )
        {
            DNSDBG( INIT, (
                "Screened old cluster IP %s from local list.\n",
                IP_STRING(ip) ));
            fexclusion = TRUE;
            fexcludeOldCluster = TRUE;
            continue;
        }
        if ( Dns_IsAddressInIpArray( g_ClusterIpArray, ip ) )
        {
            DNSDBG( INIT, (
                "Screened cluster IP %s from local list.\n",
                IP_STRING(ip) ));
            fexclusion = TRUE;
            continue;
        }

        //  once have exclusion must push down addresses

        if ( fexclusion )
        {
            RtlCopyMemory(
                & pAddrArray->AddrArray[loadIndex],
                & pAddrArray->AddrArray[testIndex],
                sizeof(DNS_ADDR_INFO)
                );
        }
        loadIndex++;
    }

    pAddrArray->AddrCount = loadIndex;

    //  clear old cluster IP, if no longer in local list
    //      - keep excluding until it doesn't show up anymore
    //      if it shows up after that then it is legitimate address

    if ( !fexcludeOldCluster )
    {
        g_OldClusterIp = 0;
    }

    return( loadIndex );
}



PDNS_ADDR_ARRAY
GetLocalAddrArrayFiltered(
    VOID
    )
/*++

Routine Description:

    Get filtered addr info array.

Arguments:

    None.

Globals:

    May update IP list globals.

Return Value:

    Ptr to local addr info array.   Caller must free.
    NULL on allocation failure.

--*/
{
    PDNS_ADDR_ARRAY pnew = NULL;
    DWORD           count;

    DNSDBG( TRACE, ( "GetLocalAddrArrayFiltered()\n" ));

    LOCK_IP_LIST();

    //
    //  create cluster filtered list
    //
    //      - created copy of full list
    //      - screen out cluster IPs
    //      - note NET lock protects use of cluster list also
    //
    //  note:  if filter alloc fails, treats as no filtering avail
    //

    pnew = GetLocalAddrArray();
    if ( !pnew )
    {
        goto Unlock;
    }

    RemoveClusterIpFromAddrArray( pnew );

Unlock:

    UNLOCK_IP_LIST();

    IF_DNSDBG( INIT )
    {
        DnsDbg_DnsAddrArray(
            "Filtered IP address info:",
            pnew
            );
    }

    return  pnew;
}



//
//  Remote IP list routines
//

VOID
R_ResolverGetLocalAddrInfoArray(
    IN      DNS_RPC_HANDLE      Reserved,
    OUT     PDNS_ADDR_ARRAY *   ppAddrArray,
    IN      ENVAR_DWORD_INFO    FilterInfo
    )
/*++

Routine Description:

    Get local IP address list from resolver.

Arguments:

    Reserved -- RPC handle

    ppIpAddrList -- addr to recv ptr to array

    FilterInfo -- FilterClusterIp environment variable info
    
Return Value:

    Count of IP addresses returned

--*/
{
    PDNS_ADDR_ARRAY     preturnList = NULL;

    DNSLOG_F1( "R_ResolverGetLocalAddrInfoArray()" );
    DNSDBG( RPC, ( "R_ResolverGetLocalAddrInfoArray()\n" ));

    //
    //  validate
    //

    if ( !ppAddrArray )
    {
        return;     //  ERROR_INVALID_PARAMETER;
    }
    if ( ClientThreadNotAllowedAccess() )
    {
        DNSLOG_F1( "R_ResolverGetLocalAddrInfoArray() - ERROR_ACCESS_DENIED" );
        goto Done;
    }

    //
    //  determine if need to filter
    //
    //  default is don't filter unless environment variable is
    //      explicitly set
    //

    if ( FilterInfo.fFound && FilterInfo.Value )
    {
        preturnList = GetLocalAddrArrayFiltered();
    }
    else
    {
        preturnList = GetLocalAddrArray();
    }

Done:

    *ppAddrArray = preturnList;

    DNSDBG( RPC, ( "Leave R_ResolverGetLocalAddrInfoArray()\n" ));
}


VOID
R_ResolverRegisterClusterIp(
    IN      DNS_RPC_HANDLE  Handle,
    IN      IP_ADDRESS      ClusterIp,
    IN      DWORD           Tag,
    IN      BOOL            fAdd
    )
/*++

Routine Description:

    Make the query to remote DNS server.

Arguments:

    Handle -- RPC handle

    ClusterIp -- IP of cluster

    fAdd -- TRUE if adding cluster IP, FALSE if deleting

Return Value:

    None

--*/
{
    DNSLOG_F1( "R_ResolverRegisterClusterIp" );

    DNSDBG( RPC, (
        "R_ResolverRegisterClusterIp\n"
        "\tClusterIp = %s\n"
        "\tfAdd = %d\n",
        IP_STRING( ClusterIp ),
        fAdd ));

    //
    //  DCR:  should have security
    //

    if ( ClientThreadNotAllowedAccess() )
    {
        DNSLOG_F1( "R_ResolverFlushCache - ERROR_ACCESS_DENIED" );
        return;
    }
    if ( Tag != CLUSTER_TAG )
    {
        return;
    }

    RegisterClusterIp4Address(
        ClusterIp,
        fAdd );
}



//
//  Cluster IP manipulation.
//

#if 0
BOOL
Resolver_IsClusterIpCallback(
    IN      PIP_UNION       pIpUnion,
    IN      BOOL            fCopyName,
    OUT     PWCHAR *        ppName
    )
/*++

Routine Description:

    Detect cluster address.

Arguments:

    pIpUnion -- address to test

    fCopyName -- want the name back

    ppName -- addr to recv ptr to name

Return Value:

    TRUE if cluster IP
    FALSE if regular IP

--*/
{
    IP4_ADDRESS ip;


    DNSDBG( TRACE, (
        "Resolver_IsClusterIpCallback()\n" ));

    //
    //  no IP6 support yet
    //

    *ppName = NULL;

    //
    //  DCR:  keep cluster as combo IP list with ptr to cluster name
    //

    if ( pIpUnion->IsIp6 )
    {
        return  FALSE;
    }

    ip = pIpUnion.Ip4;

    if ( ip == g_OldClusterIp )
    {
        DNSDBG( INIT, (
            "IP is old cluster IP %s.\n",
            IP_STRING(ip) ));
        return  TRUE;
    }

    LOCK_IP_LIST();

    fresult = Dns_IsAddressInIpArray( g_ClusterIpArray, ip );

    UNLOCK_IP_LIST();
    if ( fresult )
    {
        DNSDBG( INIT, (
            "IP is current cluster IP %s.\n",
            IP_STRING(ip) ));
        return TRUE;
    }

    //  not cluster IP

    return  FALSE;
}
#endif



//
//  Cluster filtering callback routines
//

BOOL
IsClusterIp4Addr(
    IN      IP4_ADDRESS     IpAddr
    )
/*++

Routine Description:

    Check if cluster address.

Arguments:

    IpAddr -- IP4 address

Return Value:

    TRUE if cluster IP.
    FALSE otherwise.

--*/
{
    DNSDBG( TRACE, (
        "IsClusterIp4Addr( %08x )\n", IpAddr ));

    if ( Dns_IsAddressInIpArray( g_ClusterIpArray, IpAddr ) )
    {
        DNSDBG( INIT, (
            "IP %s is cluster address.\n",
            IP_STRING(IpAddr) ));
        return  TRUE;
    }
    return  FALSE;
}



BOOL
IsClusterAddress(
    IN OUT  PQUERY_BLOB     pBlob,
    IN      PIP_UNION       pIpUnion
    )
/*++

Routine Description:

    Cluster filtering callback.

Arguments:

Return Value:

    TRUE if cluster IP.
    FALSE otherwise.

--*/
{
    IP4_ADDRESS ip4;

    DNSDBG( TRACE, (
        "IsClusterAddress( %p, %p )\n",
        pBlob,
        pIpUnion ));

    if ( !g_ClusterIpArray )
    {
        return  FALSE;
    }

    //
    //  determine if cluster address
    //
    //  DCR:  create cluster IP records
    //      - match cluster name and create forward record
    //      - match IP and create reverse record to cluster name
    //

    if ( IPUNION_IS_IP4(pIpUnion) )
    {
        BOOL        fresult;
        IP4_ADDRESS ip4;

        ip4 = IPUNION_GET_IP4( pIpUnion );

        LOCK_IP_LIST();
        fresult = Dns_IsAddressInIpArray( g_ClusterIpArray, ip4 );
        UNLOCK_IP_LIST();

        return  fresult;
    }

    //  DCR:  no IP6 cluster support yet

    return  FALSE;
}



DNS_STATUS
R_ResolverRegisterCluster(
    IN      DNS_RPC_HANDLE  Handle,
    IN      DWORD           Tag,
    IN      PWSTR           pwsName,
    IN      PRPC_IP_UNION   pIpUnion,
    IN      DWORD           Flag
    )
/*++

Routine Description:

    Make the query to remote DNS server.

Arguments:

    Handle -- RPC handle

    Tag -- RPC API tag

    pwsName -- name of cluster

    pIpUnion -- IP union

    Flag -- registration flag
        DNS_CLUSTER_ADD
        DNS_CLUSTER_DELETE_NAME
        DNS_CLUSTER_DELETE_IP

Return Value:

    None

--*/
{
    PDNS_RECORD     prrAddr = NULL;
    PDNS_RECORD     prrPtr = NULL;
    WORD            wtype;
    PIP_UNION       pip = (PIP_UNION) pIpUnion;
    DNS_STATUS      status;
    BOOL            fadd;


    DNSLOG_F1( "R_ResolverRegisterCluster" );

    ASSERT( sizeof(IP_UNION) == sizeof(RPC_IP_UNION) );

    DNSDBG( RPC, (
        "R_ResolverRegisterCluster()\n"
        "\tpName        = %s\n"
        "\tpIpUnion     = %p\n"
        "\tFlag         = %08x\n",
        pwsName,
        pip,
        Flag ));

    //
    //  DCR:  should have security
    //

    if ( ClientThreadNotAllowedAccess() )
    {
        DNSLOG_F1( "R_ResolverRegisterClusterIp - ERROR_ACCESS_DENIED" );
        return  ERROR_ACCESS_DENIED;
    }
    if ( Tag != CLUSTER_TAG )
    {
        return  ERROR_ACCESS_DENIED;
    }

    //
    //  get type
    //

    wtype = DNS_TYPE_A;
    if ( IPUNION_IS_IP6(pip) )
    {
        wtype = DNS_TYPE_AAAA;
    }
    fadd = (Flag == DNS_CLUSTER_ADD);

    //
    //  cluster add -- cache cluster records
    //      - forward and reverse
    //

    if ( !pwsName )
    {
        DNSDBG( ANY, ( "WARNING:  no cluster name given!\n" ));
        goto AddrList;
    }

    //
    //  build records
    //      - address and corresponding PTR
    //

    prrAddr = Dns_CreateForwardRecord(
                pwsName,
                pip,
                CLUSTER_RECORD_TTL,
                DnsCharSetUnicode,
                DnsCharSetUnicode );

    if ( !prrAddr )
    {
        status = GetLastError();
        if ( status == ERROR_SUCCESS )
        {
            status = ERROR_INVALID_DATA;
        }
        return  status;
    }
    SET_RR_CLUSTER( prrAddr );

    prrPtr = Dns_CreatePtrRecordEx(
                pip,
                pwsName,
                CLUSTER_RECORD_TTL,
                DnsCharSetUnicode,
                DnsCharSetUnicode );
    if ( prrPtr )
    {
        SET_RR_CLUSTER( prrPtr );
    }

    //
    //  add records to cache
    //

    if ( Flag == DNS_CLUSTER_ADD )
    {
        Cache_RecordSetAtomic(
            NULL,       // record name
            0,          // record type
            prrAddr );

        if ( prrPtr )
        {
            Cache_RecordSetAtomic(
                NULL,       // record name
                0,          // record type
                prrPtr );
        }
        prrAddr = NULL;
        prrPtr = NULL;
    }

    //
    //  if delete cluster, flush cache entries for name\type
    //
    //  DCR:  don't have way to STRONG flush a name and type
    //      assume cluster name goes away wholesale
    //
    //  DCR:  need delete of cluster PTR record
    //      must be name specific
    //
    //  DCR:  build reverse name independently so whack works
    //      even without cluster name
    //

    else if ( Flag == DNS_CLUSTER_DELETE_NAME )
    {
        Cache_FlushRecords(
            pwsName,
            FLUSH_LEVEL_STRONG,
            0 );

        //  delete record matching PTR
    }

    else if ( Flag == DNS_CLUSTER_DELETE_IP )
    {
        Cache_FlushRecords(
            pwsName,
            FLUSH_LEVEL_STRONG,
            0 );

        Cache_FlushRecords(
            prrPtr->pName,
            FLUSH_LEVEL_STRONG,
            0 );
    }

    //
    //  IP4 address list backcompat processing
    //
    //  note:  could use sockaddr to IP6 routine here
    //  if want list of IP6 addrs;  if build combined
    //  type then should have conversion routine
    //
    //  my take here is that IP6 cluster addresses won't show
    //  up period
    //

AddrList:

    if ( wtype == DNS_TYPE_A )
    {
        IP4_ADDRESS ip4 = IPUNION_GET_IP4(pip);

        if ( !fadd &&
             Flag != DNS_CLUSTER_DELETE_IP )
        {
            goto Done;
        }

        RegisterClusterIp4Address(
            ip4,
            fadd );
    }

Done:

    //  cleanup uncached records

    Dns_RecordFree( prrAddr );
    Dns_RecordFree( prrPtr );

    return  ERROR_SUCCESS;
}


//
//  End ip.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\resolver\server\dnsrslvr_s_stub.c ===
#include "local.h"
#include "dnsrslvr_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\resolver\server\hostfile.c ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    hostfile.c

Abstract:

    Reads host file into DNS cache.

Author:

    Glenn Curtis (glennc)   Picked up from winsock.

Revision History:

    Jim Gilroy (jamesg)     Feb 2000    Cleanup

--*/


#include "local.h"

#define HOSTS_FILE_DIRECTORY            L"\\drivers\\etc"


#if 0
//
//  Sockets hosts file stuff
//

#define HOSTDB_SIZE     (_MAX_PATH + 8)   // 8 == strlen("\\hosts") + 1
#define MAXALIASES      35



//
//  Globals
//
//  Note: that none of this is MT safe.  We assume that all these
//  functions are called only from a single thread (at startup) or
//  that some higher level locking is enabled.
//

FILE *          g_HostFile = NULL;
CHAR            g_HostFileName[ HOSTDB_SIZE ];
CHAR            g_HostLineBuf[ BUFSIZ+1 ];

PCHAR           g_pHostName;
PCHAR           g_AliasArray[ MAXALIASES ];
BOOL            g_IsIp6;
IP_ADDRESS      g_Ip4Address;
DNS_IP6_ADDRESS g_Ip6Address;



VOID
_setfile(
    VOID
    )
/*++

Routine Description:

    Open hosts file.

Arguments:

    None.

Globals:

    g_HostFile -- host file ptr, tested and set

Return Value:

    None.

--*/
{
    if ( g_HostFile == NULL )
    {
        g_HostFile = SockOpenNetworkDataBase(
                        "hosts",
                        g_HostFileName,
                        HOSTDB_SIZE,
                        "r" );
    }
    else
    {
        rewind( g_HostFile );
    }
}



VOID
_endfile(
    VOID
    )
/*++

Routine Description:

    Close hosts file.

Arguments:

    None.

Globals:

    g_HostFile -- host file ptr, tested and cleared

Return Value:

    None.

--*/
{
    if ( g_HostFile )
    {
        fclose( g_HostFile );
        g_HostFile = NULL;
    }
}



BOOL
_gethost(
    VOID
    )
/*++

Routine Description:

    Reads an entry from hosts file.

Arguments:

    None.

Globals:

    g_HostFile      -- host file ptr, tested and set
    g_pHostName     -- name ptr is set
    g_AliasArray    -- alias ptr array is filled
    g_Ip4Address    -- IP4 address is set
    g_Ip6Address    -- IP6 address is set
    g_IsIp6         -- IP4\IP6 flag is set

Return Value:

    TRUE if successfully reads a host entry.
    FALSE if on EOF or no hosts file found.

--*/
{
    char *p;
    register char *cp, **q;

    //
    //  open hosts file if not open
    //

    if ( g_HostFile == NULL  &&
        (g_HostFile = fopen(g_HostFileName, "r" )) == NULL )
    {
        return FALSE;
    }

    //
    //  loop until successfully read IP address
    //

    while( 1 )
    {
        //  quit on EOF

        if ((p = fgets(g_HostLineBuf, BUFSIZ, g_HostFile)) == NULL)
        {
            return FALSE;
        }

        //  comment line -- skip

        if ( *p == '#' )
        {
            continue;
        }

        //  null address terminate at EOL or comment

        cp = strpbrk( p, "#\n" );
        if ( cp != NULL )
        {
            *cp = '\0';
        }

        //  all whitespace -- skip

        cp = strpbrk( p, " \t" );
        if ( cp == NULL )
        {
            continue;
        }

        //  NULL terminate address string

        *cp++ = '\0';

        //
        //  read address
        //      - try IP4
        //      - try IP6
        //      - otherwise skip
        //
    
        g_Ip4Address = inet_addr(p);

        if ( g_Ip4Address != INADDR_NONE ||
             _strnicmp( "255.255.255.255", p, 15 ) == 0 )
        {
            g_IsIp6 = FALSE;
            break;
        }

        //  not valid IP4 -- check IP6

        g_IsIp6 = Dns_Ipv6StringToAddress(
                        & g_Ip6Address,
                        p,
                        0   //  null terminated string
                        );
        if ( g_IsIp6 )
        {
            break;
        }

        //  invalid address, ignore line

        DNSDBG( INIT, (
            "Error parsing host file address %s\n",
            p ));

        continue;
    }

    //
    //  find name
    //      - skip leading whitespace
    //      - set global name ptr
    
    while( *cp == ' ' || *cp == '\t' )
    {
        cp++;
    }
    g_pHostName = cp;

    //  stop at trailing whitespace, NULL terminate

    cp = strpbrk(cp, " \t");
    if ( cp != NULL )
    {
        *cp++ = '\0';
    }

    //  read aliases

    q = g_AliasArray;
    while ( cp && *cp )
    {
        //  skip leading whitespace

        if ( *cp == ' ' || *cp == '\t' )
        {
            cp++;
            continue;
        }

        //  save alias name to alias array

        if ( q < &g_AliasArray[MAXALIASES - 1] )
        {
            *q++ = cp;
        }
        cp = strpbrk( cp, " \t" );
        if ( cp != NULL )
        {
            *cp++ = '\0';
        }
    }
    *q = NULL;

    //  successful entry read

    return TRUE;
}


VOID
LoadHostFile(
    VOID
    )
/*++

Routine Description:

    Read hosts file into cache.

Arguments:

    None.

Globals:

    g_HostFile      -- host file ptr, tested and set then cleared
    g_pHostName     -- name ptr is read
    g_AliasArray    -- alias ptr array is read
    g_Ip4Address    -- IP4 address is read
    g_Ip6Address    -- IP6 address is read
    g_IsIp6         -- IP4\IP6 flag is read

Return Value:

    None.

--*/
{
    register PCHAR * cp;

    DNSDBG( INIT, ( "Enter  LoadHostFile\n" ));

    //
    //  read entries from host file until exhausted
    //      - cache A record for each name and alias
    //      - cache PTR to name
    //

    _setfile();

    while ( _gethost() )
    {
        if ( g_pHostName )
        {
            if ( g_IsIp6 )
            {
                CacheAAAARecord( g_pHostName, g_Ip6Address );
            }
            else
            {
                CacheARecord( g_pHostName, g_Ip4Address );
                CachePtrRecord( g_Ip4Address, g_pHostName );
            }
        }

        for ( cp = g_AliasArray; *cp != 0; cp++ )
        {
            if ( g_IsIp6 )
            {
                CacheAAAARecord( *cp, g_Ip6Address );
            }
            else
            {
                CacheARecord( *cp, g_Ip4Address );
            }
        }
    }

    _endfile();

    DNSDBG( INIT, ( "Leave  LoadHostFile\n" ));
}
#endif



VOID
HostsFileMonitorThread(
    VOID
    )
/*++

Routine Description:

    Main thread that waits on and reads host file changes.

Arguments:

    None.

Globals:

    g_hShutdownEvent -- waits on shutdown even

Return Value:

    None.

--*/
{
    BOOL        bquitting = FALSE;
    HANDLE      fileChangeHandle;
    DWORD       waitResult;
    HANDLE      changeHandles[2];
    DWORD       lockFlag = NO_LOCK;
    LPWSTR      psystemDirectory = NULL;
    UINT        len;
    WCHAR       hostDirectory[ MAX_PATH*2 ];

    DNSDBG( INIT, (
        "Enter HostFileMonitorThread\n" ));

    //
    //  build host file name
    //

    len = GetSystemDirectory( hostDirectory, MAX_PATH );
    if ( !len || len>MAX_PATH )
    {
        DNSLOG_F1( "Error:  Failed to get system directory" );
        DNSLOG_F1( "HostsFileMonitorThread exiting." );
        return;
    }

    wcscat( hostDirectory, HOSTS_FILE_DIRECTORY );

    //
    //  drop change notify on host file directory
    //

    fileChangeHandle = FindFirstChangeNotification(
                            hostDirectory,
                            FALSE,
                            FILE_NOTIFY_CHANGE_FILE_NAME |
                                FILE_NOTIFY_CHANGE_LAST_WRITE );

    if ( fileChangeHandle == INVALID_HANDLE_VALUE )
    {
        DNSLOG_F1( "HostsFileMonitorThread failed to get handle from" );
        DNSLOG_F2( "FindFirstChangeNotification. Error code: <0x%.8X>",
                   GetLastError() );
        DNSLOG_F1( "HostsFileMonitorThread exiting." );
        return;
    }

    //
    //  wait on file notify OR shutdown
    //      - on host file change rebuild cache and restart wait
    //      - on shutdown, exit
    //

    changeHandles[0] = g_hShutdownEvent;
    changeHandles[1] = fileChangeHandle;

    while( 1 )
    {
        waitResult = WaitForMultipleObjects(
                            2,
                            changeHandles,
                            FALSE,
                            INFINITE );

        switch( waitResult )
        {
        case WAIT_OBJECT_0 :

            //  shutdown event -- exit

            DNSLOG_F1( "HostsFileMonitorThread: Got event" );
            DNSLOG_F1( "HostsFileMonitorStopEvent." );
            goto ThreadExit;

        case WAIT_OBJECT_0 + 1 :

            //  change notify -- flush cache and reload

            DNSLOG_F1( "HostsFileMonitorThread: Got HOSTS file" );
            DNSLOG_F1( "directory change event." );

            //  reset notification -- BEFORE reload

            if ( !FindNextChangeNotification( fileChangeHandle ) )
            {
                DNSLOG_F1( "HostsFileMonitorThread failed to get handle" );
                DNSLOG_F1( "from FindNextChangeNotification." );
                DNSLOG_F2( "Error code: <0x%.8X>", GetLastError() );
                goto ThreadExit;
            }

            FlushCache( TRUE );     // flush and reload
            break;

        default:

            DNSLOG_F1( "HostsFileMonitorThread failed to get handle" );
            goto ThreadExit;
            break;
        }
    }

ThreadExit:

    //  close change\notify handle

    CloseHandle( fileChangeHandle );

    DNSDBG( INIT, (
        "HostFileMonitorThread exit\n" ));
    DNSLOG_F1( "HostsFileMonitorThread exiting." );
}



VOID
LoadHostFileIntoCache(
    IN      PSTR            pFileName
    )
/*++

Routine Description:

    Read hosts file into cache.

Arguments:

    pFileName -- file name to load

Return Value:

    None.

--*/
{
    HOST_FILE_INFO  hostInfo;

    DNSDBG( INIT, ( "Enter  LoadHostFile\n" ));

    //
    //  read entries from host file until exhausted
    //      - cache A record for each name and alias
    //      - cache PTR to name
    //

    RtlZeroMemory(
        &hostInfo,
        sizeof(hostInfo) );

    if ( !Dns_OpenHostFile( &hostInfo ) )
    {
        return;
    }
    hostInfo.fBuildRecords = TRUE;

    while ( Dns_ReadHostFileLine( &hostInfo ) )
    {
        //  cache all the records we sucked out
        //
        //  DCR:  cache answer data with CNAME data

        CacheAnyAdditionalRecords( hostInfo.pForwardRR, TRUE );
        CacheAnyAdditionalRecords( hostInfo.pReverseRR, TRUE );
        CacheAnyAdditionalRecords( hostInfo.pAliasRR, TRUE );
    }

    Dns_CloseHostFile( &hostInfo );

    DNSDBG( INIT, ( "Leave  LoadHostFile\n" ));
}

//
//  End hostfile.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\resolver\server\local.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    local.h

Abstract:

    DNS Resolver.

    DNS Resolver service local include file.

Author:

    Jim Gilroy  (jamesg)        March 2000

Revision History:

--*/


#ifndef _LOCAL_INCLUDED_
#define _LOCAL_INCLUDED_


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <stdlib.h>
#ifndef _WINSOCK2API_
#include <winsock2.h>
#endif
#include <sockreg.h>
#include <windns.h>
#include <netevent.h>       // DNS events

#define  DNS_NEW_DEFS 1     // QFE builds use new definitions

#include "dnsrslvr.h"
#include <dnslibp.h>
#include "registry.h"
#include "dnsapip.h"

#define  ENABLE_DEBUG_LOGGING 1
#include "logit.h"
#include "dnsmsg.h"
#include "heapdbg.h"


//
//  Resolver debug flags
//

#define DNS_DBG_CACHE       DNS_DBG_QUERY


//
//  Cache definitions
//

#define NO_LOCK                 0
#define LOCKED                  1

#define ONE_YEAR_IN_SECONDS     60*60*24*365


//
//  Bypassing cache completely check
//

#define COMBINED_BYPASS_CACHE_FLAG  (DNS_QUERY_BYPASS_CACHE | DNS_QUERY_NO_HOSTS_FILE)

#define SKIP_CACHE_LOOKUP(Flags)    \
        ( ((Flags) & COMBINED_BYPASS_CACHE_FLAG) == COMBINED_BYPASS_CACHE_FLAG )


//
//  Cache defintion
//
//  Should be private to cache but is currently
//  exposed in enum routines
//

typedef struct _CacheEntry
{
    struct _CacheEntry *    pNext;
    PWSTR                   pName;
    DWORD                   Reserved;
    DWORD                   MaxCount;
    PDNS_RECORD             Records[ 1 ];
}
CACHE_ENTRY, *PCACHE_ENTRY;


//
//  Socket context 
//

typedef struct _SocketContext
{
    struct _SocketContext * pNext;
    SOCKET                  Socket;
    IP_ADDRESS              IpAddress;
    OVERLAPPED              Overlapped;
    PDNS_MSG_BUF            pMsg;
}
SOCKET_CONTEXT, * PSOCKET_CONTEXT;
        

#if 1
//
//  Config
//
//  Saved NT5 registry stuff.
//  In typical fashsion this was packed away in a few different places.
//  Keeping around until all of this is properly put to bed.
//
//
//  Registry value routine prototypes
//
#define DNS_DEFAULT_HASH_TABLE_SIZE                211      // A prime number
#define DNS_DEFAULT_NEGATIVE_SOA_CACHE_TIME        10       // 10 seconds
#define DNS_DEFAULT_NET_FAILURE_CACHE_TIME         30       // 30 seconds
#define DNS_DEFAULT_ADAPTER_TIMEOUT_CACHE_TIME     2*60     // 2 minutes
#define DNS_DEFAULT_MESSAGE_POPUP_LIMIT            0        // Don't allow!
#define DNS_DEFAULT_MAX_SOA_TTL_LIMIT              5*60     // 5 minutes
#define DNS_DEFAULT_RESET_SERVER_PRIORITIES_TIME   5*60     // 5 minutes
#endif


//
//  Event tags
//  Make recognizable DWORD tags for in memory log.
//

#define FOUR_CHARACTER_CONSTANT(a,b,c,d) \
        ((((DWORD)d) << 24) + (((DWORD)c) << 16) + (((DWORD)b) << 8) + ((DWORD)a))

#define RES_EVENT_INITNET_START        FOUR_CHARACTER_CONSTANT('N','e','t','+')
#define RES_EVENT_INITNET_END          FOUR_CHARACTER_CONSTANT('N','e','t','-')
#define RES_EVENT_INITCACHE            FOUR_CHARACTER_CONSTANT('C','a','c','+')
#define RES_EVENT_REGISTER_SCH         FOUR_CHARACTER_CONSTANT('S','c','h','+')
#define RES_EVENT_CREATEEVENT          FOUR_CHARACTER_CONSTANT('E','v','t','+')
#define RES_EVENT_STARTRPC             FOUR_CHARACTER_CONSTANT('R','p','c','+')
#define RES_EVENT_STOPRPC              FOUR_CHARACTER_CONSTANT('R','p','c','-')
#define RES_EVENT_STATUS               FOUR_CHARACTER_CONSTANT('s','t','a','t')
#define RES_EVENT_SCH                  FOUR_CHARACTER_CONSTANT('S','c','h',' ')
#define RES_EVENT_UPDATE_STATUS        FOUR_CHARACTER_CONSTANT('U','p','d',' ')
#define RES_EVENT_INITCRIT_START       FOUR_CHARACTER_CONSTANT('I','C','S','+')
#define RES_EVENT_INITCRIT_END         FOUR_CHARACTER_CONSTANT('I','C','S','-')
#define RES_EVENT_DELCRIT_START        FOUR_CHARACTER_CONSTANT('D','C','S','+')
#define RES_EVENT_DELCRIT_END          FOUR_CHARACTER_CONSTANT('D','C','S','-')
#define RES_EVENT_SHUTDOWN             FOUR_CHARACTER_CONSTANT('S','h','u','t')
#define RES_EVENT_FLUSH_CACHE          FOUR_CHARACTER_CONSTANT('F','l','s','h')
#define RES_EVENT_PNP_START            FOUR_CHARACTER_CONSTANT('P','n','P','+')
#define RES_EVENT_PNP_END              FOUR_CHARACTER_CONSTANT('P','n','P','-')


//
//  Service
//

extern  HANDLE      g_hStopEvent;
extern  BOOL        g_StopFlag;
extern  BOOL        g_WakeFlag;
extern  BOOL        g_GarbageCollectFlag;

extern  BOOL        g_LogTraceInfo;

//
//  Config (config.c) 
//

extern  DWORD       g_MaxSOACacheEntryTtlLimit;
extern  DWORD       g_NegativeSOACacheTime;
extern  DWORD       g_MessagePopupLimit;
extern  DWORD       g_NetFailureCacheTime;

//
//  Config info (config.c)
//

extern  PDNS_NETINFO    g_NetworkInfo;
extern  DWORD           g_TimeOfLastPnPUpdate;

//
//  Cache (cache.c)
//

extern  PCACHE_ENTRY *  g_HashTable;
extern  DWORD           g_HashTableSize;
extern  DWORD           g_EntryCount;
extern  DWORD           g_RecordSetCount;

//
//  Local IP info (ip.c)
//

extern  PDNS_ADDR_ARRAY     g_LocalAddrArray;

//
//  Network failure caching
//

extern  DWORD       g_NetFailureTime;
extern  DNS_STATUS  g_NetFailureStatus;
extern  DWORD       g_TimedOutAdapterTime;
extern  DWORD       g_ResetServerPrioritiesTime;
extern  BOOL        g_fTimedOutAdapter;
extern  DNS_STATUS  g_PreviousNetFailureStatus;
extern  DWORD       g_MessagePopupStrikes;
extern  DWORD       g_NumberOfMessagePopups;

//
//  Multicast globals (mcast.c) 
//

extern  HANDLE      g_hMulticastThread;
extern  BOOL        g_MulticastStop;


//
//  Locking
//

extern  CRITICAL_SECTION        CacheCritSec;
extern  CRITICAL_SECTION        NetworkListCritSec;
extern  CRITICAL_SECTION        NetworkFailureCritSec;


#define LOCK_CACHE()            Cache_Lock( 0 )
#define LOCK_CACHE_NO_START()   Cache_Lock( 1 )
#define UNLOCK_CACHE()          Cache_Unlock()

#define LOCK_NET_LIST()         EnterCriticalSection( &NetworkListCritSec )
#define UNLOCK_NET_LIST()       LeaveCriticalSection( &NetworkListCritSec )

#define LOCK_NET_FAILURE()      EnterCriticalSection( &NetworkFailureCritSec )
#define UNLOCK_NET_FAILURE()    LeaveCriticalSection( &NetworkFailureCritSec )


//
//  Cache flush levels
//
//  Note, these aren't bit flags, just made them that way for
//  easy reading.
//

#define FLUSH_LEVEL_NORMAL      (0)
#define FLUSH_LEVEL_INVALID     (1)
#define FLUSH_LEVEL_WIRE        (2)
#define FLUSH_LEVEL_STRONG      (4)
#define FLUSH_LEVEL_CLEANUP     (8)

#define FLUSH_LEVEL_GARBAGE     (FLUSH_LEVEL_WIRE)


//
//  Cache memory
//
//  Note, heap global doesn't need exposure if functionalize
//

extern  HANDLE g_CacheHeap;

#define CACHE_HEAP_ALLOC_ZERO(size) \
        HeapAlloc( g_CacheHeap, HEAP_ZERO_MEMORY, (size) )

#define CACHE_HEAP_ALLOC(size) \
        HeapAlloc( g_CacheHeap, 0, (size) )

#define CACHE_HEAP_FREE(p) \
        HeapFree( g_CacheHeap, 0, (p) )


//
//  Record and RPC memory:
//
//  Note:  most records are created by dnsapi heap -- from
//  query or hosts file routines.  However, we do create
//  name error caching records ourselves using dnslib routines.
//
//  This means -- until we either
//      - extend query or dnslib record creation interfaces to
//        include heap parameter
//      - explicitly free and recreate
//      - tag records (dnsapi\not) somehow (flags field)
//  that
//  dnsapi and dnslib heaps MUST be the same.
//  With dnsapi now potentially having it's own heap, this means
//  dnslib should use dnsapi heap.
//
//  So we'll put off using the debug heap for dnslib.
//

//
//  Resolver allocators
//

PVOID
Res_Alloc(
    IN      DWORD           Length,
    IN      DWORD           Tag,
    IN      PSTR            pszFile,
    IN      DWORD           LineNo
    );

PVOID
Res_AllocZero(
    IN      DWORD           Length,
    IN      DWORD           Tag,
    IN      PSTR            pszFile,
    IN      DWORD           LineNo
    );

VOID
Res_Free(
    IN OUT  PVOID           pMemory,
    IN      DWORD           Tag
    );

#define RESHEAP_TAG_GENERAL     0
#define RESHEAP_TAG_RECORD      1
#define RESHEAP_TAG_RPC         2
#define RESHEAP_TAG_MCAST       3


//
//  General memory
//

#define GENERAL_HEAP_ALLOC(Size)    \
        Res_Alloc(                  \
            Size,                   \
            RESHEAP_TAG_GENERAL,    \
            __FILE__,               \
            __LINE__ )

#define GENERAL_HEAP_ALLOC_ZERO(Size)   \
        Res_AllocZero(              \
            Size,                   \
            RESHEAP_TAG_GENERAL,    \
            __FILE__,               \
            __LINE__ )

#define GENERAL_HEAP_FREE(pMem)     \
        Res_Free(                   \
            pMem,                   \
            RESHEAP_TAG_GENERAL )


//
//  RPC allocs
//

#define RPC_HEAP_ALLOC(Size)        \
        Res_Alloc(                  \
            Size,                   \
            RESHEAP_TAG_RPC,        \
            __FILE__,               \
            __LINE__ )

#define RPC_HEAP_ALLOC_ZERO(Size)   \
        Res_AllocZero(              \
            Size,                   \
            RESHEAP_TAG_RPC,        \
            __FILE__,               \
            __LINE__ )

#define RPC_HEAP_FREE(pMem)         \
        Res_Free(                   \
            pMem,                   \
            RESHEAP_TAG_RPC )


//
//  Record heap routines
//

#define RECORD_HEAP_ALLOC(Size)     \
        Res_Alloc(                  \
            Size,                   \
            RESHEAP_TAG_RECORD,     \
            __FILE__,               \
            __LINE__ )

#define RECORD_HEAP_ALLOC_ZERO(Size)    \
        Res_AllocZero(              \
            Size,                   \
            RESHEAP_TAG_RECORD,     \
            __FILE__,               \
            __LINE__ )

#define RECORD_HEAP_FREE(pMem)      \
        Res_Free(                   \
            pMem,                   \
            RESHEAP_TAG_RECORD )

//
//  Mcast heap routines
//

#define MCAST_HEAP_ALLOC(Size)      \
        Res_Alloc(                  \
            Size,                   \
            RESHEAP_TAG_MCAST,      \
            __FILE__,               \
            __LINE__ )

#define MCAST_HEAP_ALLOC_ZERO(Size)    \
        Res_AllocZero(              \
            Size,                   \
            RESHEAP_TAG_MCAST,      \
            __FILE__,               \
            __LINE__ )

#define MCAST_HEAP_FREE(pMem)       \
        Res_Free(                   \
            pMem,                   \
            RESHEAP_TAG_MCAST )


//
//  RECORD Access control
//

BOOL
ClientThreadNotAllowedAccess(
    VOID
    );


#if 0
//
//  Old cache routines (cache.c)
//

VOID
FlushCacheEntry(
    IN      PWSTR           pName
    );

VOID
FlushCacheEntryRecord(
    IN      PWSTR           pName,
    IN      WORD            Type
    );

VOID
TrimCache(
    VOID
    );

VOID
TrimCacheBucket(
    IN      ULONG           ulIndex,
    IN      DWORD           dwBucketSize,
    IN      BOOL            fSkipFirst
    );

VOID
ResizeCacheBucket(
    IN      ULONG           ulIndex,
    IN      PDWORD          pdwBucketSize
    );

PCACHE_ENTRY
CreateCacheEntry(
    IN      PWSTR           pName,
    IN      BOOL            fLoadingHostsFile
    );

VOID
FreeCacheEntry(
    IN OUT  PCACHE_ENTRY    pCacheEntry
    );

VOID
AddRecordToCacheEntry(
    IN OUT  PCACHE_ENTRY    pCacheEntry,
    IN      PDNS_RECORD     pRecordList,
    IN      BOOL            fFlushExisting,
    IN      BOOL            fLoadingHostsFile
    );

VOID
CacheAnyAdditionalRecords(
    IN OUT  PDNS_RECORD     pRecordList,
    IN      BOOL            fHostFile
    );

PCACHE_ENTRY
FindCacheEntry(
    IN      PWSTR           pName
    );

PCACHE_ENTRY
FindOrCreateCacheEntry(
    IN      PWSTR           pName,
    IN      BOOL            fHostsFile
    );

PDNS_RECORD
FindCacheEntryRecord(
    IN      PCACHE_ENTRY    pEntry,
    IN      WORD            Type
    );

PDNS_RECORD
FindCacheRecords(
    IN      PWSTR           pwsName,
    IN      WORD            wType
    );

#define PrepareRecordSetForRpc(prr)     Cache_RestoreRecordListForRpc(prr)

#define PrepareRecordSetForCache(prr)   Cache_PrepareRecordList(prr)
#endif

//
//  Cache routines (ncache.c)
//

VOID
Cache_Lock(
    IN      BOOL            fNoStart
    );

VOID
Cache_Unlock(
    VOID
    );

DNS_STATUS
Cache_Initialize(
    VOID
    );

DNS_STATUS
Cache_Shutdown(
    VOID
    );

DNS_STATUS
Cache_Flush(
    VOID
    );

VOID
Cache_FlushRecords(
    IN      PWSTR           pName,
    IN      DWORD           FlushLevel,
    IN      WORD            Type
    );

BOOL
Cache_IsRecordTtlValid(
    IN      PDNS_RECORD     pRecord
    );

//
//  Cache operations routines (cache.c)
//

BOOL
Cache_ReadResults(
    OUT     PDNS_RESULTS    pResults,
    IN      PWSTR           pwsName,
    IN      WORD            wType
    );

VOID
Cache_PrepareRecordList(
    IN OUT  PDNS_RECORD     pRecordList
    );

VOID
Cache_RestoreRecordListForRpc(
    IN OUT  PDNS_RECORD     pRecordList
    );

VOID
Cache_RecordList(
    IN OUT  PDNS_RECORD     pRecordList
    );

VOID
Cache_RecordSetAtomic(
    IN      PWSTR           pwsName,
    IN      WORD            wType,
    IN      PDNS_RECORD     pRecordSet
    );

VOID
Cache_GarbageCollect(
    IN      DWORD           Flag
    );

DNS_STATUS
Cache_QueryResponse(
    IN OUT  PQUERY_BLOB     pBlob
    );

BOOL
Cache_GetRecordsForRpc(
    OUT     PDNS_RECORD *   ppRecordList,
    OUT     PDNS_STATUS     pStatus,
    IN      PWSTR           pwsName,
    IN      WORD            wType,
    IN      DWORD           Flags
    );

//
//  Multicast routines (mcast.c)
//

VOID
MulticastThread(
    VOID
    );

VOID
MulticastThreadSignalStop(
    VOID
    );


//
//  Host file routines (notify.c)
//

VOID
InitCacheWithHostFile(
    VOID
    );


//
//  Notification (notify.c)
//

VOID
ThreadShutdownWait(
    IN      HANDLE          hThread
    );

HANDLE
CreateHostsFileChangeHandle(
    VOID
    );

VOID
NotifyThread(
    VOID
    );

VOID
StartNotify(
    VOID
    );

VOID
ShutdownNotify(
    VOID
    );


//
//  Config -- Network info (config.c)
//

VOID
UpdateNetworkInfo(
    IN OUT  PDNS_NETINFO    pNetworkInfo
    );

PDNS_NETINFO         
GrabNetworkInfo(
    VOID
    );

VOID
ZeroNetworkConfigGlobals(
    VOID
    );

VOID
CleanupNetworkInfo(
    VOID
    );

BOOL
IsKnownNetFailure(
    VOID
    );

VOID
SetKnownNetFailure(
    IN      DNS_STATUS      Status
    );


VOID
ReadRegistryConfig(
    VOID
    );

VOID
HandleConfigChange(
    IN      PSTR            pszReason,
    IN      BOOL            fCache_Flush
    );


//
//  Net config (still remote.c)
//

#define THREE_MINUTES_FROM_SYSTEM_BOOT  180
#define MAX_DNS_NOTIFICATION_LIST_SIZE  1000
#define PNP_REFRESH_UPDATE_WINDOW       60

BOOL
IsKnownTimedOutAdapter(
    VOID
    );

BOOL
IsTimeToResetServerPriorities(
    VOID
    );


//
//  Service notification (notesrv.c)
//

VOID
SendServiceNotifications(
    VOID
    );

VOID
CleanupServiceNotification(
    VOID
    );

//
//  In memory logging (memlog.c)
//

VOID
LogEventInMemory(
    IN      DWORD           Checkpoint,
    IN      DWORD           Data
    );

//
//  Event logging (dnsrslvr.c)
//

VOID
ResolverLogEvent (
    IN      DWORD           MessageId,
    IN      WORD            EventType,
    IN      DWORD           StringCount,
    IN      PWSTR *         StringArray,
    IN      DWORD           ErrorCode
    );

//
//  IP list and notification (ip.c)
//

DNS_STATUS
IpNotifyThread(
    IN      LPVOID  pvDummy
    );

VOID
ZeroInitIpListGlobals(
    VOID
    );

DNS_STATUS
InitIpListAndNotification(
    VOID
    );

VOID
ShutdownIpListAndNotify(
    VOID
    );

VOID
ClearLocalAddrArray(
    VOID
    );

PDNS_ADDR_ARRAY
GetLocalAddrArray(
    VOID
    );

DWORD
RemoveClusterIpFromAddrArray(
    IN OUT  PDNS_ADDR_ARRAY     pAddrArray
    );

PDNS_ADDR_ARRAY
GetLocalAddrArrayFiltered(
    VOID
    );

BOOL
IsClusterAddress(
    IN OUT  PQUERY_BLOB     pBlob,
    IN      PIP_UNION       pIpUnion
    );


//
//  Resolver log (logit.c)
//
//  Special type routines for resolver logging.
//  General log open\print routines defined in logit.h.
//

VOID
PrintNetworkInfoToLog(
    IN      PDNS_NETINFO        pNetworkInfo
    );

VOID
PrintIpAddressListToLog (
    IN      PDNS_ADDRESS_INFO   AddressInfoList,
    IN      DWORD               AddressInfoListCount
    );


//
//  RPC server (rpc.c)
//

DNS_STATUS
Rpc_Initialize(
    VOID
    );

VOID
Rpc_Shutdown(
    VOID
    );


#endif // _LOCAL_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\resolver\server\logit.h ===
/*
 -  L O G I T . H
 -
 *  Purpose:
 *      Function and Macro definitions for logging module activity.
 *
 *  Author: Glenn A. Curtis
 *
 *  Comments:
 *      10/28/93    glennc     original file.
 *
 */

#ifndef LOGIT_H
#define LOGIT_H

#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include <time.h>

// #if DBG
   void  LogInit(void);
   void  CDECL LogIt( char *, ... );
   void  LogTime(void);
   DWORD LogIn( char * );
   void  LogOut( char *, DWORD );
// #else
// #undef ENABLE_DEBUG_LOGGING
// #endif // DBG

#ifdef ENABLE_DEBUG_LOGGING
#define DNSLOG_INIT() LogInit()
#else
#define DNSLOG_INIT() 
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define DNSLOG_TIME() LogTime()
#else
#define DNSLOG_TIME() 
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define DNSLOG_F1( a ) LogIt( a )
#else
#define DNSLOG_F1( a )
#endif                 

#ifdef ENABLE_DEBUG_LOGGING
#define DNSLOG_F2( a, b ) LogIt( a, b )
#else
#define DNSLOG_F2( a, b )
#endif                 

#ifdef ENABLE_DEBUG_LOGGING
#define DNSLOG_F3( a, b, c ) LogIt( a, b, c )
#else
#define DNSLOG_F3( a, b, c )
#endif                 

#ifdef ENABLE_DEBUG_LOGGING
#define DNSLOG_F4( a, b, c, d ) LogIt( a, b, c, d )
#else
#define DNSLOG_F4( a, b, c, d ) 
#endif                 

#ifdef ENABLE_DEBUG_LOGGING
#define DNSLOG_F5( a, b, c, d, e ) LogIt( a, b, c, d, e )
#else
#define DNSLOG_F5( a, b, c, d, e ) 
#endif                 

#ifdef ENABLE_DEBUG_LOGGING
#define DNSLOG_F6( a, b, c, d, e, f ) LogIt( a, b, c, d, e, f )
#else
#define DNSLOG_F6( a, b, c, d, e, f )
#endif                 

#ifdef ENABLE_DEBUG_LOGGING
#define LOG_IN( a ) LogIn( a )
#else
#define LOG_IN( a )
#endif                 

#ifdef ENABLE_DEBUG_LOGGING
#define LOG_OUT( a, b ) LogOut( a, b )
#else
#define LOG_OUT( a, b )
#endif                 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\resolver\server\logit.c ===
/*****************************************\
 *        Data Logging -- Debug only      *
\*****************************************/

//
//  Need local header ONLY to allow precompiled header.
//  Nothing in this module depends on specific DNS resolver
//  definitions.
//
#include "local.h"

//
// NT Headers
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//
// Windows Headers
//
#include <windows.h>

#pragma  hdrstop

#include "logit.h"


// #if DBG

int LoggingMode;
time_t  long_time;      // has to be in DS, assumed by time() funcs
int LineCount;

char * month[] =
{
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
} ;


/*
 -  LogInit
 -
 *  Purpose:
 *  Determines if logging is desired and if so, adds a header to log file.
 *
 *  Parameters:
 *
 */
void LogInit()
{
    FILE    *fp;
    struct  tm  *newtime;
    char    am_pm[] = "a.m.";

    LoggingMode = 0;
    LineCount = 0;

    if ( fp = fopen( "dnsrslvr.log", "r+" ) )
    {
        LoggingMode = 1;
        fclose( fp );

        // Get time and date information

        long_time = time( NULL);        /* Get time as long integer. */
        newtime = localtime( &long_time ); /* Convert to local time. */

        if( newtime->tm_hour > 12 )    /* Set up extension. */
            am_pm[0] = 'p';
        if( newtime->tm_hour > 12 )    /* Convert from 24-hour */
            newtime->tm_hour -= 12;    /*   to 12-hour clock.  */
        if( newtime->tm_hour == 0 )    /*Set hour to 12 if midnight. */
            newtime->tm_hour = 12;

        // Write out a header to file

        fp = fopen("dnsrslvr.log", "w" );
        if ( !fp )
        {
            return;
        }

        fprintf( fp, "Logging information for DNS Caching Resolver service\n" );
        fprintf( fp, "****************************************************\n" );
        fprintf( fp, "\tTime: %d:%02d %s\n\tDate: %s %d, 19%d\n", 
                 newtime->tm_hour, newtime->tm_min, am_pm,
                 month[newtime->tm_mon], newtime->tm_mday,
                 newtime->tm_year );
        fprintf( fp, "****************************************************\n\n" );
        fclose( fp );
    }
}


/*
 -  LogIt
 -
 *  Purpose:
 *  Formats a string and prints it to a log file with handle hLog.
 *
 *  Parameters:
 *  LPSTR - Pointer to string to format
 *  ...   - variable argument list
 */

#ifdef WIN32
#define S16
#else
#define S16 static
#endif

void CDECL LogIt( char * lpszFormat, ... )
{
    FILE *fp;
#ifndef _ALPHA_
    va_list pArgs = NULL;       // reference to quiet compiler
#else
    va_list pArgs = {NULL,0};
#endif
    S16 char    szLogStr[1024];    
    int     i;

    if ( !LoggingMode )
        return;
    
#ifdef WIN32        // parse parameters and insert in string
    va_start( pArgs, lpszFormat);
    vsprintf(szLogStr, lpszFormat, pArgs);
    va_end(pArgs);

    i = lstrlenA( szLogStr);
#else              // parsing doesn't work, just give them string.
    _fstrcpy( szLogStr, lpszFormat);
    i = _fstrlen( szLogStr);
#endif
    szLogStr[i] = '\n';
    szLogStr[i+1] = '\0';


    if ( LineCount > 50000 )
    {
        fp = fopen( "dnsrslvr.log", "w" );
        LineCount = 0;
    }
    else
    {
        fp = fopen( "dnsrslvr.log", "a" );
    }
    if( fp )
    {
        fprintf( fp, szLogStr );
        LineCount++;
        fclose( fp );
    }
}


void LogTime()
{
    struct  tm  *newtime;
    char    am_pm[] = "a.m.";

    if ( !LoggingMode )
        return;

    // Get time and date information

    long_time = time( NULL);        /* Get time as long integer. */
    newtime = localtime( &long_time ); /* Convert to local time. */

    if ( !newtime )
        return;

    if( newtime->tm_hour > 12 )    /* Set up extension. */
        am_pm[0] = 'p';
    if( newtime->tm_hour > 12 )    /* Convert from 24-hour */
        newtime->tm_hour -= 12;    /*   to 12-hour clock.  */
    if( newtime->tm_hour == 0 )    /*Set hour to 12 if midnight. */
        newtime->tm_hour = 12;

    // Write out a header to file

    LogIt( "DNS Caching Resolver service" );
    LogIt( "System Time Information" );
    LogIt( "****************************************************" );
    LogIt( "\tTime: %d:%02d %s\n\tDate: %s %d, 19%d",
           newtime->tm_hour, newtime->tm_min, am_pm,
           month[newtime->tm_mon], newtime->tm_mday,
           newtime->tm_year );
    LogIt( "****************************************************" );
    LogIt( "" );
}


DWORD LogIn( char * string )
{
    LogIt( "%s", string );
    return GetTickCount();
}


void LogOut( char * string, DWORD InTime )
{
    LogIt( "%s  ---  Duration: %ld milliseconds", string, GetTickCount() - InTime );
}


// #endif




//
//  Special logging routines
//

//
//  ENHANCE:  print routines here are really log routines
//      - they are really log routines
//      - should print generically so can be hooked to any print duty
//      - and have macros to log desired structure
//

VOID
PrintIpAddress(
    IN      DWORD           dwIpAddress
    )
{
    DNSLOG_F5(
        "                %d.%d.%d.%d",
        ((BYTE *) &dwIpAddress)[0],
        ((BYTE *) &dwIpAddress)[1],
        ((BYTE *) &dwIpAddress)[2],
        ((BYTE *) &dwIpAddress)[3] );
}


VOID
PrintAddressInfo(
    IN      DNS_ADDRESS_INFO    AddressInfo
    )
{
    DNSLOG_F1( "        ipAddress  : " );
    PrintIpAddress( AddressInfo.ipAddress );
    DNSLOG_F1( "        subnetMask : " );
    PrintIpAddress( AddressInfo.subnetMask );
    DNSLOG_F1( "" );
}


VOID
PrintSearchList(
    IN      PSEARCH_LIST    pSearchList
    )
{
    DWORD iter;

    DNSLOG_F1( "" );
    DNSLOG_F1( "    DNS Search List :" );

    for ( iter = 0; iter < pSearchList->cNameCount; iter++ )
    {
        DNSLOG_F3( "        %s (Flags: 0x%X)",
                   pSearchList->SearchNameArray[iter].pszName,
                   pSearchList->SearchNameArray[iter].Flags );
    }

    DNSLOG_F1( "" );

    if ( pSearchList->pszDomainOrZoneName )
        DNSLOG_F2( "    Primary domain name : %s",
                   pSearchList->pszDomainOrZoneName );

    DNSLOG_F1( "" );
}


VOID
PrintServerInfo(
    IN      DNS_SERVER_INFO     ServerInfo
    )
{
    DNSLOG_F1( "            IpAddress : " );
    PrintIpAddress( ServerInfo.IpAddress );
    DNSLOG_F2( "            Priority  : %d", ServerInfo.Priority );
    DNSLOG_F2( "            status    : %d", ServerInfo.Status );
    DNSLOG_F1( "" );
}


VOID
PrintAdapterInfo(
    IN      PDNS_ADAPTER    pAdapter
    )
{
    DWORD iter;

    DNSLOG_F2( "        %s", pAdapter->pszAdapterGuidName );
    DNSLOG_F1( "    ----------------------------------------------------" );
    DNSLOG_F2( "        pszAdapterDomain       : %s", pAdapter->pszAdapterDomain );
    if ( pAdapter->pAdapterIPAddresses )
    {
        PIP_ARRAY pIp = pAdapter->pAdapterIPAddresses;

        DNSLOG_F1( "        Adapter Ip Address(es) :" );
        for ( iter = 0; iter < pIp->AddrCount; iter++ )
        {
            PrintIpAddress( pIp->AddrArray[iter] );
        }
    }

    if ( pAdapter->pAdapterIPSubnetMasks )
    {
        PIP_ARRAY pMask = pAdapter->pAdapterIPSubnetMasks;

        DNSLOG_F1( "        Adapter Ip Subnet Mask(s) :" );
        for ( iter = 0; iter < pMask->AddrCount; iter++ )
        {
            PrintIpAddress( pMask->AddrArray[iter] );
        }
    }

    DNSLOG_F2( "        Status                 : 0x%x", pAdapter->Status );
    DNSLOG_F2( "        InfoFlags              : 0x%x", pAdapter->InfoFlags );
    DNSLOG_F2( "        ReturnFlags            : 0x%x", pAdapter->ReturnFlags );
    DNSLOG_F1( "        IpLastSend             : " );
    PrintIpAddress( pAdapter->IpLastSend );
    DNSLOG_F2( "        cServerCount           : %d", pAdapter->cServerCount );
    DNSLOG_F2( "        cTotalListSize         : %d", pAdapter->cTotalListSize );
    DNSLOG_F1( "" );

    for ( iter = 0; iter < pAdapter->cServerCount; iter++ )
    {
        DNSLOG_F1( "        ------------------------" );
        DNSLOG_F2( "          DNS Server Info (%d)", iter + 1 );
        DNSLOG_F1( "        ------------------------" );
        PrintServerInfo( pAdapter->ServerArray[iter] );
    }

    DNSLOG_F1( "" );
}


VOID
PrintNetworkInfoToLog(
    IN      PDNS_NETINFO    pNetworkInfo
    )
{
    DWORD iter;

    if ( pNetworkInfo )
    {
        DNSLOG_F1( "Current network adapter information is :" );
        DNSLOG_F1( "" );
        DNSLOG_F2( "    pNetworkInfo->ReturnFlags    : 0x%x", pNetworkInfo->ReturnFlags );

        if ( pNetworkInfo->pSearchList )
            PrintSearchList( pNetworkInfo->pSearchList );

        DNSLOG_F2( "    pNetworkInfo->cAdapterCount  : %d", pNetworkInfo->cAdapterCount );
        DNSLOG_F2( "    pNetworkInfo->cTotalListSize : %d", pNetworkInfo->cTotalListSize );
        DNSLOG_F1( "" );

        for ( iter = 0; iter < pNetworkInfo->cAdapterCount; iter++ )
        {
            DNSLOG_F1( "    ----------------------------------------------------" );
            DNSLOG_F2( "      Adapter Info (%d)", iter + 1 );
            DNSLOG_F1( "" );
            PrintAdapterInfo( pNetworkInfo->AdapterArray[iter] );
        }
    }
    else
    {
        DNSLOG_F1( "Current network adapter information is empty" );
        DNSLOG_F1( "" );
    }
}


VOID
PrintIpAddressListToLog (
    IN      PDNS_ADDRESS_INFO   AddressInfoList,
    IN      DWORD               AddressInfoListCount
    )
{
    DWORD iter;

    if ( AddressInfoList && AddressInfoListCount )
    {
        DNSLOG_F1( "Current IP address list is :" );

        for ( iter = 0; iter < AddressInfoListCount; iter++ )
        {
            PrintAddressInfo( AddressInfoList[iter] );
        }
        DNSLOG_F1( "" );
    }
    else
    {
        DNSLOG_F1( "Current IP address list is empty" );
        DNSLOG_F1( "" );
    }
}

//
//  End of logit.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\resolver\server\memory.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    memory.c

Abstract:

    DNS Resolver Service

    Memory management.

Author:

    James Gilroy (jamesg)       March 2000

Revision History:

--*/


#include "local.h"


//
//  Note:  most records are created by dnsapi heap -- from
//  query or hosts file routines.  However, we do create
//  name error caching records ourselves using dnslib routines.
//
//  This means -- until we either
//      - extend query or dnslib record creation interfaces to
//        include heap parameter
//      - explicitly free and recreate
//      - tag records (dnsapi\not) somehow (flags field)
//  that
//  dnsapi and dnslib heaps MUST be the same.
//  With dnsapi now potentially having it's own heap, this means
//  dnslib should use dnsapi heap.
//
//  So we'll put off using the debug heap for dnslib.
//
//
//  Note the ideal solution:
//      - dnsapi (query and hosts file) creates records in
//          the cache heap (by passed heap handle)
//      - we create our NAME_ERROR records locally in that
//          heap also (our functionalize to dnsapi)
//      - copy for RPC can be in separate heap used only by MIDL
//      - we have a separate heap for other random crap in the process
//          


//
//  Counters for heap debugging
//

DWORD   g_ResAllocCount     = 0;
DWORD   g_ResAllocMemory    = 0;
DWORD   g_ResFreeCount      = 0;

DWORD   g_MidlAllocCount    = 0;
DWORD   g_MidlAllocMemory   = 0;
DWORD   g_MidlFreeCount     = 0;




//
//  RPC memory routines
//
//  These are called by the stub code generated by MIDL.
//

PVOID
WINAPI
MIDL_user_allocate(
    IN      size_t          Size
    )
{
    DNSDBG( HEAP, (
        "MIDL_user_allocate( %d )\n",
        Size ));

    g_MidlAllocCount++;
    g_MidlAllocMemory += Size;

    // return( ALLOCATE_HEAP( Size ) );
    // return  DnsApiAlloc( Size );

    return  Dns_Alloc( Size );
}

VOID
WINAPI
MIDL_user_free(
    IN OUT  PVOID           pMem
    )
{
    DNSDBG( HEAP, (
        "MIDL_user_free( %p )\n",
        pMem ));

    g_MidlFreeCount++;

    // FREE_HEAP( pMem );
    // DnsApiFree( pMem );

    Dns_Free( pMem );
}



//
//  Resolver heap routines
//
//  Currently (see note above) everything RPC, record allocs
//  and general allocs are in the same heap.
//  However the Tag field sets us up to dispatch to different
//  heaps.  The file and line info allow us to later use
//  debug heap routines.
//  

PVOID
Res_Alloc(
    IN      DWORD           Length,
    IN      DWORD           Tag,
    IN      PSTR            pszFile,
    IN      DWORD           LineNo
    )
{
    DNSDBG( HEAP, (
        "Res_Alloc( %d, tag=%d )\n",
        Length,
        Tag ));

    g_ResAllocCount++;
    g_ResAllocMemory += Length;

    return  Dns_Alloc( Length );
}


PVOID
Res_AllocZero(
    IN      DWORD           Length,
    IN      DWORD           Tag,
    IN      PSTR            pszFile,
    IN      DWORD           LineNo
    )
{
    return  Dns_AllocZero( Length );
}


VOID
Res_Free(
    IN OUT  PVOID           pMemory,
    IN      DWORD           Tag
    )
{
    DNSDBG( HEAP, (
        "Res_Free( %p, tag=%d )\n",
        pMemory,
        Tag ));

    g_ResFreeCount++;

    Dns_Free( pMemory );
}

//
//  End memory.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\resolver\server\ncache.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    ncache.c

Abstract:

    DNS Resolver Service

    Cache routines

Author:

    Jim Gilroy (jamesg)     April 2001

Revision History:

--*/


#include "local.h"


//
//  Heap corruption tracking
//

#define HEAPPROB    1

#define BAD_PTR     (PVOID)(-1)


//
//  Cache entry definitions
//
//  Starting cache record count
//

#define CACHE_DEFAULT_SET_COUNT  3

#if 0
//  Should be private but is exposed in remote
//  cache enum routines.

typedef struct _CacheEntry
{
    struct _CacheEntry *    pNext;
    PWSTR                   pName;
    DWORD                   Reserved;
    DWORD                   MaxCount;
    PDNS_RECORD             Records[ 1 ];
}
CACHE_ENTRY, *PCACHE_ENTRY;
#endif

//
//  Cache heap
//

HANDLE  g_CacheHeap = NULL;

//
//  Cache hash table
//

PCACHE_ENTRY *  g_HashTable = NULL;

#define INITIAL_CACHE_HEAP_SIZE     (16*1024)


//
//  Runtime globals
//

DWORD   g_CurrentCacheTime;

DWORD   g_RecordSetCount;
DWORD   g_RecordSetCountLimit;
DWORD   g_RecordSetCountThreshold;

DWORD   g_RecordSetCache;
DWORD   g_RecordSetFree;

DWORD   g_EntryCount;
DWORD   g_EntryAlloc;
DWORD   g_EntryFree;

BOOL    g_fLoadingHostsFile;

//
//  Garbage collection
//

BOOL    g_GarbageCollectFlag = FALSE;

DWORD   g_NextGarbageIndex = 0;
DWORD   g_NextGarbageTime = 0;

#define GARBAGE_LOCKOUT_INTERVAL    (600)   // no more then every ten minutes


//
//  Wakeup flag
//

BOOL    g_WakeFlag = FALSE;

//
//  Cache limits
//      - min count of records to hold
//      - size of band in which garbage collection occurs
//

#if DBG
#define MIN_DYNAMIC_RECORD_COUNT        (20)
#define CLEANUP_RECORD_COUNT_BAND       (5)
#else
#define MIN_DYNAMIC_RECORD_COUNT        (50)
#define CLEANUP_RECORD_COUNT_BAND       (30)
#endif


//
//  Static records (hosts file)
//

#define IS_STATIC_RR(prr)   (IS_HOSTS_FILE_RR(prr) || IS_CLUSTER_RR(prr))



//
// Compute a hash table index value for a string
//

#define EOS     (L'\0')

#define COMPUTE_STRING_HASH_1( _String, _ulHashTableSize, _lpulHash ) \
        {                                               \
            PWCHAR p;                                   \
            ULOND  h = 0, g;                            \
                                                        \
            for ( p = _String; *p != EOS; p = p + 1 )   \
            {                                           \
                h = ( h << 4 ) + (DWORD) (*p);          \
                if ( g = h&0xf0000000 )                 \
                {                                       \
                    h = h ^ ( g >> 24 );                \
                    h = h ^ g;                          \
                }                                       \
            }                                           \
            *_lpulHash = h % _ulHashTableSize;          \
        }


//
// Compute a hash table index value for a string
// which is invairant to case
//
#define COMPUTE_STRING_HASH_2( _String, _ulHashTableSize, _lpulHash ) \
        {                                           \
            PWCHAR _p = _String;                    \
            PWCHAR _ep = _p + wcslen( _String );    \
            ULONG  h = 0;                           \
                                                    \
            while( _p < _ep )                       \
            {                                       \
                h <<= 1;                            \
                h ^= *_p++;                         \
            }                                       \
                                                    \
            *_lpulHash = h % _ulHashTableSize;      \
        }


//
//  Private prototypes
//

BOOL
Cache_FlushEntryRecords(
    IN OUT  PCACHE_ENTRY    pEntry,
    IN      DWORD           Level,
    IN      WORD            wType
    );

VOID
Cache_FlushBucket(
    IN      ULONG           Index,
    IN      WORD            FlushLevel
    );

//
//  Cache Implementation
//
//  Cache is implemented as a hash on name, with chaining in the individual
//  buckets.  Individual name entries are blocks with name pointer and array
//  of up to 3 RR set pointers.  The new names\entries are put at the front of
//  the bucket chain, so the oldest are at the rear.
//
//
//  Cleanup:
//
//  The cleanup strategy is to time out all RR sets and cleanup everything
//  possible as a result.  Then entries beyond a max bucket size (a resizable
//  global) are deleted, the oldest queries deleted first.
//
//  Ideally, we'd like to keep the most useful entries in the cache while
//  being able to limit the overall cache size.
//
//  A few observations:
//
//  1) max bucket size is worthless;  if sufficient for pruning, it would be
//  too small to allow non-uniform distributions
//
//  2) LRU should be required;  on busy cache shouldn't prune something queried
//  "a while" ago that is being used all the time;  that adds much more traffic
//  than something recently queried but then unused;
//
//  3) if necessary an LRU index could be kept;  but probably some time bucket
//  counting to know how "deep" pruning must be is adequate
//
//
//  Memory:
//
//  Currently hash itself and hash entries come from private resolver heap.
//  However, RR sets are built by record parsing of messages received in dnsapi.dll
//  and hence are built by the default dnsapi.dll allocator.  We must match it.
//
//  The downside of this is twofold:
//  1) By being in process heap, we are exposed (debug wise) to any poor code
//  in services.exe.  Hopefully, there are getting better, but anything that
//  trashes memory is likely to cause us to have to debug, because we are the highest
//  use service.
//  2) Flush \ cleanup is easy.  Just kill the heap.
//
//  There are several choices:
//
//  0) Copy the records.  We are still susceptible to memory corruption ... but the
//  interval is shorter, since we don't keep anything in process heap.
//
//  1) Query can directly call dnslib.lib query routines.  Since dnslib.lib is
//  explicitly compiled in, it's global for holding the allocators is modules, rather
//  than process specific.
//
//  2) Add some parameter to query routines that allows pass of allocator down to
//  lowest level.  At high level this is straightforward.  At lower level it maybe
//  problematic.   There may be a way to do it with a flag where the allocator is
//  "optional" and used only when a flag is set.
//




//
//  Cache functions
//

VOID
Cache_Lock(
    IN      BOOL            fNoStart
    )
/*++

Routine Description:

    Lock the cache

Arguments:

    None.

Return Value:

    None -- cache is locked.

--*/
{
    DNSDBG( LOCK, ( "Enter Cache_Lock() ..." ));

    EnterCriticalSection( &CacheCritSec );

    DNSDBG( LOCK, (
        "through lock  (r=%d)\n",
        CacheCritSec.RecursionCount ));

    //  update global time (for TTL set and timeout)
    //
    //  this allows us to eliminate multiple time calls
    //  within cache

    g_CurrentCacheTime = Dns_GetCurrentTimeInSeconds();

    //
    //  if cache not loaded -- load
    //  this allows us to avoid load on every PnP until we
    //      are actually queried
    //

    if ( !fNoStart && !g_HashTable )
    {
        DNSDBG( ANY, (
            "No hash table when took lock -- initializing!\n" ));
        Cache_Initialize();
    }
}


VOID
Cache_Unlock(
    VOID
    )
/*++

Routine Description:

    Unlock the cache

Arguments:

    None.

Return Value:

    None.

--*/
{
    DNSDBG( LOCK, (
        "Cache_Unlock() r=%d\n",
        CacheCritSec.RecursionCount ));

    LeaveCriticalSection( &CacheCritSec );
}



DNS_STATUS
Cache_Initialize(
    VOID
    )
/*++

Routine Description:

    Initialize the cache.
    Create events and locks and setup basic hash.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNS_STATUS  status;
    DWORD       carryCount;

    DNSDBG( INIT, ( "Cache_Initialize()\n" ));

    //
    //  lock -- with "no-start" set to avoid recursion
    // 

    LOCK_CACHE_NO_START();

    //
    //  create cache heap
    //
    //  want to have own heap
    //      1) to simplify flush\shutdown
    //      2) keep us from "entanglements" with poor services
    //

    g_CacheHeap = HeapCreate( 0, INITIAL_CACHE_HEAP_SIZE, 0 );
    if ( !g_CacheHeap )
    {
        status = ERROR_NOT_ENOUGH_MEMORY;
        g_HashTable = NULL;
        goto Done;
    }

    g_HashTable = CACHE_HEAP_ALLOC_ZERO(
                                    sizeof(PCACHE_ENTRY) * g_HashTableSize );
    if ( !g_HashTable )
    {
        status = ERROR_NOT_ENOUGH_MEMORY;
        HeapDestroy( g_CacheHeap );
        g_CacheHeap = NULL;
        goto Done;
    }

    g_WakeFlag      = FALSE;

    g_EntryCount    = 0;
    g_EntryAlloc    = 0;
    g_EntryFree     = 0;

    g_RecordSetCount = 0;
    g_RecordSetCache = 0;
    g_RecordSetFree  = 0;

    //  eliminate cache size checks during hosts file load

    g_RecordSetCountLimit       = MAXDWORD;
    g_RecordSetCountThreshold   = MAXDWORD;

    //
    //  load hosts file into cache
    //

    g_fLoadingHostsFile = TRUE;
    InitCacheWithHostFile();
    g_fLoadingHostsFile = FALSE;

    //
    //  set cache size limit
    //      - above what loaded from hosts file
    //      - always allow some dynamic space regardless of
    //          g_MaxCacheSize
    //      - create slightly higher threshold value for kicking
    //          off cleanup so cleanup not running all the time
    //

    carryCount = g_MaxCacheSize;
    if ( carryCount < MIN_DYNAMIC_RECORD_COUNT )
    {
        carryCount = MIN_DYNAMIC_RECORD_COUNT;
    }
    g_RecordSetCountLimit     = g_RecordSetCount + carryCount;
    g_RecordSetCountThreshold = g_RecordSetCountLimit + CLEANUP_RECORD_COUNT_BAND;


Done:

    UNLOCK_CACHE();

    return NO_ERROR;
}



DNS_STATUS
Cache_Shutdown(
    VOID
    )
/*++

Routine Description:

    Shutdown the cache.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNSDBG( INIT, ( "Cache_Shutdown()\n" ));

    //
    //  clean out cache and delete cache heap
    //       - currently Cache_Flush() does just this
    //

    return Cache_Flush();
}



DNS_STATUS
Cache_Flush(
    VOID
    )
/*++

Routine Description:

    Flush the cache.

    This flushes all the cache data and rereads host file but does NOT
    shut down and restart cache threads (host file monitor or multicast).

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on rebuild failure.

--*/
{
    DWORD   status = ERROR_SUCCESS;
    WORD    ihash;
    WORD    RecordIter;

    DNSDBG( ANY, ( "\nCache_Flush()\n" ));

    //
    //  wake\stop garbage collection
    //

    g_WakeFlag = TRUE;

    //
    //  lock with "no start" flag
    //      - avoids creating cache structs if they don't exist
    //

    LOCK_CACHE_NO_START();

    DNSLOG_F1( "Flushing DNS Cache" );
    DNSLOG_F3(
        "   Before Cache_Flush():  entries %d, record %d",
        g_EntryCount,
        g_RecordSetCount );

    //
    //  clear entries in each hash bucket
    //

    if ( g_HashTable )
    {
        for ( ihash = 0;
              ihash < g_HashTableSize;
              ihash++ )
        {
            Cache_FlushBucket(
                ihash,
                FLUSH_LEVEL_CLEANUP );
        }
    }

    DNSDBG( CACHE, (
        "After flushing cache:\n"
        "\trecord count  = %d\n"
        "\tentry count   = %d\n",
        g_RecordSetCount,
        g_EntryCount ));

    DNS_ASSERT( g_RecordSetCount == 0 );
    DNS_ASSERT( g_EntryCount == 0 );

    DNSLOG_F3(
        "   After Cache_Flush() flush:  entries %d, record %d",
        g_EntryCount,
        g_RecordSetCount );


    //
    //  Note:  can NOT delete the cache without stopping mcast
    //      thread which currently uses cache heap

    //
    //  DCR:  have all data in cache in single heap
    //          - protected
    //          - single destroy cleans up
      
    //  once cleaned up, delete heap

    if ( g_CacheHeap )
    {
        HeapDestroy( g_CacheHeap );
        g_CacheHeap = NULL;
    }
    g_HashTable = NULL;

    //
    //  dump local IP list
    //      - not dumping on shutdown as the IP cleanup happens
    //      first and takes away the CS;
    //
    //  note to reviewer:
    //      this is equivalent to the previous behavior where
    //      Cache_Flush() FALSE was shutdown and
    //      everything else used TRUE (for restart) which did a
    //      RefreshLocalAddrArray() to rebuild IP list
    //      now we simply dump the IP list rather than rebuilding
    //      

    if ( !g_StopFlag )
    {
        ClearLocalAddrArray();
    }

    DNSDBG( ANY, ( "Leave Cache_Flush()\n\n" ));

    UNLOCK_CACHE();

    return( status );
}



//
//  Cache utilities
//

BOOL
Cache_IsRecordTtlValid(
    IN      PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Check if TTL is still valid (or has timed out).

Arguments:

    pRecord -- record to check

Return Value:

    TRUE -- if TTL is still valid
    FALSE -- if TTL has timed out

--*/
{
    //
    //  static or TTL not timed out => valid
    //
    //  note:  currently flushing all records on PnP, but this is
    //      not strickly necessary;  if stop this then MUST change
    //      this to whack negative cache entries that are older
    //      than last PnP time
    //

    if ( IS_STATIC_RR(pRecord) )
    {
        return( TRUE );
    }
    else
    {
        return( (LONG)(pRecord->dwTtl - g_CurrentCacheTime) > 0 );
    }
}



//
//  Cache entry routines
//

DWORD
getHashIndex(
    IN      PWSTR           pName,
    IN      DWORD           NameLength  OPTIONAL
    )
/*++

Routine Description:

    Create cannonical cache form of name.

    Note:  no test for adequacy of buffer is done.

Arguments:

    pName -- name

    NameLength -- NameLength, OPTIONAL

Return Value:

    None

--*/
{
    register PWCHAR     pstring;
    register WCHAR      wch;
    register DWORD      hash = 0;

    //
    //  build hash by XORing characters
    //

    pstring = pName;

    while ( wch = *pstring++ )
    {
        hash <<= 1;
        hash ^= wch;
    }

    //
    //  mod over hash table size
    //

    return( hash % g_HashTableSize );
}



BOOL
makeCannonicalCacheName(
    OUT     PWCHAR          pNameBuffer,
    IN      DWORD           BufferLength,
    IN      PWSTR           pName,
    IN      DWORD           NameLength      OPTIONAL
    )
/*++

Routine Description:

    Create cannonical cache form of name.

Arguments:

    pNameBuffer -- buffer to hold cache name

    BufferLength -- length of buffer

    pName -- ptr to name string

    NameLength -- optional, saves wsclen() call if known

Return Value:

    TRUE if successful.
    FALSE on bogus name.

--*/
{
    INT count;

    DNSDBG( TRACE, (
        "makeCannonicalCacheName( %S )\n",
        pName ));

    //
    //  get length if not specified
    //

    if ( NameLength == 0 )
    {
        NameLength = wcslen( pName );
    }

    //
    //  copy and downcase string
    //      - "empty" buffer for prefix happiness
    //

    *pNameBuffer = (WCHAR) 0;

    count = Dns_MakeCanonicalNameW(
                pNameBuffer,
                BufferLength,
                pName,
                NameLength+1    // convert null terminator
                );
    if ( count == 0 )
    {
        ASSERT( GetLastError() == ERROR_INSUFFICIENT_BUFFER );
        return( FALSE );
    }

    ASSERT( count == (INT)NameLength+1 );

    //
    //  whack any trailing dot
    //      - except for root node
    //

    count--;    //  account for null terminator
    DNS_ASSERT( count == NameLength );

    if ( count > 1 &&
         pNameBuffer[count - 1] == L'.' )
    {
        pNameBuffer[count - 1] = 0;
    }

    return( TRUE );
}



PCACHE_ENTRY
Cache_CreateEntry(
    IN      PWSTR           pName,
    IN      BOOL            fCanonical
    )
/*++

Routine Description:

    Create cache entry, including allocation.

Arguments:

    pName -- name

    fCanonical -- TRUE if name already in cannonical form

Return Value:

    Ptr to newly allocated cache entry.
    NULL on error.

--*/
{
    ULONG           index = 0;
    PCACHE_ENTRY    pentry = NULL;
    DWORD           nameLength;
    DWORD           fixedLength;
    PWCHAR          pnameCache = NULL;

    DNSDBG( TRACE, (
        "Cache_CreateEntry( %S )\n",
        pName ));

    if ( !pName || !g_HashTable )
    {
        return NULL;
    }

    //
    //  alloc
    //

    nameLength = wcslen( pName );

    fixedLength = sizeof(CACHE_ENTRY) +
                    (sizeof(PDNS_RECORD) * (CACHE_DEFAULT_SET_COUNT-1));

    pentry = (PCACHE_ENTRY) CACHE_HEAP_ALLOC_ZERO(
                                fixedLength +
                                sizeof(WCHAR) * (nameLength+1) );
    if ( !pentry )
    {
        goto Fail;
    }
    pentry->MaxCount = CACHE_DEFAULT_SET_COUNT;

    pnameCache = (PWSTR) ((PBYTE)pentry + fixedLength);

    //
    //  build the name
    //

    if ( fCanonical )
    {
        wcscpy( pnameCache, pName );
    }
    else
    {
        if ( !makeCannonicalCacheName(
                pnameCache,
                nameLength+1,
                pName,
                nameLength ) )
        {
            goto Fail;
        }
    }
    pentry->pName = pnameCache;

    //
    //  insert cache entry into cache -- first entry in bucket
    //

    index = getHashIndex( pnameCache, nameLength );
    pentry->pNext = g_HashTable[ index ];
    g_HashTable[ index ] = pentry;
    g_EntryCount++;
    g_EntryAlloc++;

    //
    //  DCR:  need overload detection
    //

    return pentry;

Fail:

    //  dump entry

    if ( pentry )
    {
        CACHE_HEAP_FREE( pentry );
    }
    return NULL;
}



VOID
Cache_FreeEntry(
    IN OUT  PCACHE_ENTRY    pEntry
    )
/*++

Routine Description:

    Free cache entry.

Arguments:

    pEntry -- cache entry to free

Globals:

    g_EntryCount -- decremented appropriately

    g_NumberOfRecordsInCache -- decremented appropriately

Return Value:

    None

--*/
{
    INT iter;

    DNSDBG( TRACE, (
        "Cache_FreeEntry( %p )\n",
        pEntry ));

    //
    //  free entry
    //      - records
    //      - name
    //      - entry itself
    //

    if ( pEntry )
    {
        Cache_FlushEntryRecords(
            pEntry,
            FLUSH_LEVEL_CLEANUP,
            0 );

#if 0
        if ( pEntry->pNext )
        {
            DNSLOG_F1( "Cache_FreeEntry is deleting an entry that still points to other entries!" );
        }
#endif
#if HEAPPROB
        pEntry->pNext = DNS_BAD_PTR;
#endif
        CACHE_HEAP_FREE( pEntry );
        g_EntryFree--;
        g_EntryCount--;
    }
}



PCACHE_ENTRY
Cache_FindEntry(
    IN      PWSTR           pName,
    IN      BOOL            fCreate
    )
/*++

Routine Description:

    Find or create entry for name in cache.

Arguments:

    pName -- name to find

    fCreate -- TRUE to create if not found

Return Value:

    Ptr to cache entry -- if successful.
    NULL on failure.

--*/
{
    ULONG           index;
    PCACHE_ENTRY    pentry;
    PCACHE_ENTRY    pprevEntry = NULL;
    WCHAR           hashName[ DNS_MAX_NAME_BUFFER_LENGTH+4 ];

    if ( !g_HashTable )
    {
        return NULL;
    }
    if ( !pName )
    {
        DNS_ASSERT( FALSE );
        return NULL;
    }

    DNSDBG( TRACE, (
        "Cache_FindEntry( %S, create=%d )\n",
        pName,
        fCreate ));

    //
    //  build cache name
    //      - if invalid (too long) bail
    //

    if ( !makeCannonicalCacheName(
            hashName,
            DNS_MAX_NAME_BUFFER_LENGTH,
            pName,
            0 ) )
    {
        return  NULL;
    }

    //
    //  find entry in cache
    //

    LOCK_CACHE();

    index = getHashIndex( hashName, 0 );

    pentry = g_HashTable[ index ];

    DNSDBG( OFF, (
        "in Cache_FindEntry\n"
        "\tname     = %S\n"
        "\tindex    = %d\n"
        "\tpentry   = %p\n",
        hashName,
        index,
        pentry ));

    while( pentry )
    {
        if ( DnsNameCompare_W( hashName, pentry->pName ) )
        {
            //
            //  found entry
            //      - move to front, if not already there

            if ( pprevEntry )
            {
                pprevEntry->pNext = pentry->pNext;
                pentry->pNext = g_HashTable[ index ];
                g_HashTable[ index ] = pentry;
            }
            break;
        }
        ELSE
        {
            DNSDBG( OFF, (
                "in Cache_FindEntry -- failed name compare\n"
                "\tout name = %S\n"
                "\tpentry   = %p\n"
                "\tname     = %S\n",
                hashName,
                pentry,
                pentry->pName ));
        }

        pprevEntry = pentry;
        pentry = pentry->pNext;
    }

    //
    //  if not found -- create? 
    //
    //  DCR:  optimize for create
    //

    if ( !pentry && fCreate )
    {
        pentry = Cache_CreateEntry(
                    hashName,
                    TRUE        // name already canonical
                    );
    }

    DNS_ASSERT( !pentry || g_HashTable[ index ] == pentry );
    UNLOCK_CACHE();

    DNSDBG( TRACE, (
        "Leave Cache_FindEntry\n"
        "\tname     = %S\n"
        "\tindex    = %d\n"
        "\tpentry   = %p\n",
        hashName,
        index,
        pentry ));

    return pentry;
}



PDNS_RECORD
Cache_FindEntryRecords(
    IN      PCACHE_ENTRY    pEntry,
    IN      WORD            wType
    )
/*++

Routine Description:

    Find entry in cache.

Arguments:

    pEntry -- cache entry to check

    Type -- record type to find

Return Value:

    Ptr to record set of desired type -- if found.
    NULL if not found.

--*/
{
    WORD            iter;
    PDNS_RECORD     prr;

    DNSDBG( TRACE, (
        "Cache_FindEntryRecords %p, type=%d )\n",
        pEntry,
        wType ));

    //
    //  check all the records at the cache entry  
    //

    for ( iter = 0;
          iter < pEntry->MaxCount;
          iter++ )
    {
        prr = pEntry->Records[iter];

        if ( !prr )
        {
            continue;
        }
        if ( !Cache_IsRecordTtlValid( prr ) )
        {
            DNSDBG( TRACE, (
                "Whacking timed out record %p at cache entry %p\n",
                prr,
                pEntry ));
            Dns_RecordListFree( prr );
            pEntry->Records[iter] = NULL;
            g_RecordSetCount--;
            g_RecordSetFree--;
            continue;
        }

        //  
        //  find matching type
        //      - direct type match
        //      - NAME_ERROR
        //

        if ( prr->wType == wType ||
            ( prr->wType == DNS_TYPE_ANY &&
              prr->wDataLength == 0 ) )
        {
            goto Done;
        }

        //
        //  CNAME match
        //      - walk list and determine if for matching type

        if ( prr->wType == DNS_TYPE_CNAME &&
             wType != DNS_TYPE_CNAME )
        {
            PDNS_RECORD prrChain = prr->pNext;

            while ( prrChain )
            {
                if ( prrChain->wType == wType )
                {
                    //  chain to desired type -- take RR set
                    goto Done;
                }
                prrChain = prrChain->pNext;
            }
        }

        //  records for another type -- continue
    }

    //  type not found

    prr = NULL;

Done:

    DNSDBG( TRACE, (
        "Leave Cache_FindEntryRecords) => %p\n",
        prr ));

    return prr;
}



BOOL
Cache_FlushEntryRecords(
    IN OUT  PCACHE_ENTRY    pEntry,
    IN      DWORD           Level,
    IN      WORD            wType
    )
/*++

Routine Description:

    Free cache entry.

Arguments:

    pEntry -- cache entry to flush

    FlushLevel -- flush level
        FLUSH_LEVEL_NORMAL  -- flush matching type, invalid, NAME_ERROR
        FLUSH_LEVEL_WIRE    -- to flush all wire data, but leave hosts and cluster
        FLUSH_LEVEL_INVALID -- flush only invalid records
        FLUSH_LEVEL_STRONG  -- to flush all but hosts file
        FLUSH_LEVEL_CLEANUP -- to flush all records for full cache flush

    wType -- flush type for levels with type
        DNS type -- to flush specifically this type

Globals:

    g_EntryCount -- decremented appropriately

    g_NumberOfRecordsInCache -- decremented appropriately

Return Value:

    TRUE if entry flushed completely.
    FALSE if records left.

--*/
{
    INT     iter;
    BOOL    recordsLeft = FALSE;

    DNSDBG( TRACE, (
        "Cache_FlushEntryRecords( %p, %08x, %d )\n",
        pEntry,
        Level,
        wType ));

    //
    //  loop through records sets -- flush where appropriate
    //
    //  CLEANUP flush
    //      - everything
    //
    //  STRONG (user initiated) flush
    //      - all cached records, including cluster
    //      but hostsfile saved
    //
    //  WIRE flush
    //      - all wire cached records
    //      hosts file AND cluster saved
    //
    //  INVALID flush
    //      - timedout only
    //
    //  NORMAL flush (regular flush done on caching)
    //      - timed out records
    //      - records of desired type
    //      - NAME_ERROR
    //

    for ( iter = 0;
          iter < (INT)pEntry->MaxCount;
          iter++ )
    {
        PDNS_RECORD prr = pEntry->Records[iter];
        BOOL        flush;

        if ( !prr )
        {
            continue;
        }

        //
        //  switch on flush type
        //      yes there are optimizations, but this is simple
        //

        if ( Level == FLUSH_LEVEL_NORMAL )
        {
            flush = ( !IS_STATIC_RR(prr)
                            &&
                      ( prr->wType == wType ||
                        ( prr->wType == DNS_TYPE_ANY &&
                          prr->wDataLength == 0 ) ) );
        }
        else if ( Level == FLUSH_LEVEL_WIRE )
        {
            flush = !IS_STATIC_RR(prr);
        }
        else if ( Level == FLUSH_LEVEL_INVALID )
        {
            flush = !Cache_IsRecordTtlValid(prr);
        }
        else if ( Level == FLUSH_LEVEL_CLEANUP )
        {
            flush = TRUE;
        }
        else
        {
            DNS_ASSERT( Level == FLUSH_LEVEL_STRONG );
            flush = !IS_HOSTS_FILE_RR(prr);
        }

        if ( flush )
        {
            pEntry->Records[iter] = NULL;
            Dns_RecordListFree( prr );
            g_RecordSetCount--;
            g_RecordSetFree--;
        }
        else
        {
            recordsLeft = TRUE;
        }
    }

    return  !recordsLeft;
}
            


VOID
Cache_FlushBucket(
    IN      ULONG           Index,
    IN      WORD            FlushLevel
    )
/*++

Routine Description:

    Cleanup cache bucket.

Arguments:

    Index -- Index of hash bucket to trim.

    FlushLevel -- level of flush desired
        see Cache_FlushEntryRecords() for description of
        flush levels

Return Value:

    None

--*/
{
    PCACHE_ENTRY    pentry;
    PCACHE_ENTRY    pprev;
    INT             countCompleted;

    DNSDBG( CACHE, (
        "Cache_FlushBucket( %d, %08x )\n",
        Index,
        FlushLevel ));

    //
    //  flush entries in this bucket
    //
    //  note:  using hack here that hash table pointer can
    //      be treated as cache entry for purposes of accessing
    //      it's next pointer (since it's the first field in
    //      a CACHE_ENTRY)
    //      if this changes, must explicitly fix up "first entry"
    //      case or move to double-linked list that can free
    //      empty penty without regard to it's location
    //

    if ( !g_HashTable )
    {
        return;
    }

    //
    //  flush entries
    //
    //  avoid holding lock too long by handling no more then
    //  fifty entries at a time
    //  note:  generally 50 entries will cover entire bucket but
    //  can still be completed in reasonable time;
    //
    //  DCR:  smarter flush -- avoid lock\unlock
    //          peer into CS and don't unlock when no one waiting
    //          if waiting unlock and give up timeslice
    //  DCR:  some LRU flush for garbage collection
    //

    countCompleted = 0;

    while ( 1 )
    {
        INT count = 0;
        INT countStop = countCompleted + 50;

        LOCK_CACHE_NO_START();
        if ( !g_HashTable )
        {
            UNLOCK_CACHE();
            break;
        }
    
        DNSDBG( CACHE, (
            "locked for bucket flush -- completed=%d, stop=%d\n",
            count,
            countStop ));

        pprev = (PCACHE_ENTRY) &g_HashTable[ Index ];
    
        while ( pentry = pprev->pNext )
        {
            //  bypass any previously checked entries

            if ( count++ < countCompleted )
            {
                pprev = pentry;
                continue;
            }
            if ( count > countStop )
            {
                break;
            }

            //  flush -- if successful cut from list and
            //      drop counts so countCompleted used in bypass
            //      will be correct and won't skip anyone

            if ( Cache_FlushEntryRecords(
                    pentry,
                    FlushLevel,
                    0 ) )
            {
                pprev->pNext = pentry->pNext;
                Cache_FreeEntry( pentry );
                count--;
                countStop--;
                continue;
            }
            pprev = pentry;
        }

        UNLOCK_CACHE();
        countCompleted = count;

        //  stop when
        //      - cleared all the entries in the bucket
        //      - shutdown, except exempt the shutdown flush itself

        if ( !pentry ||
             (g_StopFlag && FlushLevel != FLUSH_LEVEL_CLEANUP) )
        {
            break;
        }
    }

    DNSDBG( CACHE, (
        "Leave Cache_FlushBucket( %d, %08x )\n"
        "\trecord count  = %d\n"
        "\tentry count   = %d\n",
        Index,
        FlushLevel,
        g_RecordSetCount,
        g_EntryCount ));
}



//
//  Cache interface routines
//

VOID
Cache_PrepareRecordList(
    IN OUT  PDNS_RECORD     pRecordList
    )
/*++

Routine Description:

    Prepare record list for cache.

Arguments:

    pRecordList - record list to put in cache

Return Value:

    Ptr to screened, prepared record list.

--*/
{
    PDNS_RECORD     prr = pRecordList;
    PDNS_RECORD     pnext;
    DWORD           ttl;
    DWORD           maxTtl;

    DNSDBG( TRACE, (
        "Cache_PrepareRecordList( rr=%p )\n",
        prr ));

    if ( !prr )
    {
        return;
    }

    //
    //  static (currently host file) TTL records
    //
    //  currently no action required -- records come one
    //  at a time and no capability to even to the pName=NULL
    //  step
    //

    if ( IS_STATIC_RR(prr) )
    {
        return;
    }

    //
    //  wire records get relative TTL
    //      - compute minimum TTL for set
    //      - save TTL as timeout (offset by TTL from current time)
    //
    //  DCR:  TTL still not per set
    //      - but this is at least better than Win2K where
    //      multiple sets and did NOT find minimum
    //

    maxTtl = g_MaxCacheTtl;
    if ( prr->wType == DNS_TYPE_SOA )
    {
        maxTtl = g_MaxSOACacheEntryTtlLimit;
    }

    //
    //  get caching TTL
    //      - minimum TTL in set
    //      - offset from current time

    ttl = Dns_RecordListGetMinimumTtl( prr );
    if ( ttl > maxTtl )
    {
        ttl = maxTtl;
    }

    ttl += g_CurrentCacheTime;

#if 0
    //  screening done at higher level now
    //
    //  screen records
    //      - no non-RPCable types
    //      - no Authority records
    //

    if ( prr->wType != 0 )
    {
        prr = Dns_RecordListScreen(
                prr,
                SCREEN_OUT_AUTHORITY | SCREEN_OUT_NON_RPC );
    
        DNS_ASSERT( prr );
    }
#endif

    //
    //  set timeout on all records in set
    //
    //  note:  FreeOwner handling depends on leading record
    //      in having owner name set, otherwise this produces
    //      bogus name owner fields
    //
    //  DCR:  set record list TTL function in dnslib
    //

    pnext = prr;

    while ( pnext )
    {
        pnext->dwTtl = ttl;

        if ( !FLAG_FreeOwner( pnext ) )
        {
            pnext->pName = NULL;
        }
        pnext = pnext->pNext;
    }
}



VOID
Cache_RestoreRecordListForRpc(
    IN OUT  PDNS_RECORD     pRecordList
    )
/*++

Routine Description:

    Restore cache record list for RPC.

Arguments:

    pRecordList - record list to put in cache

Return Value:

    None

--*/
{
    PDNS_RECORD prr = pRecordList;
    DWORD       currentTime;

    DNSDBG( TRACE, (
        "Cache_RestoreRecordListForRpc( rr=%p )\n",
        prr ));

    if ( !prr )
    {
        DNS_ASSERT( FALSE );
        return;
    }

    //
    //  static TTL records need no action
    //

    if ( IS_STATIC_RR(prr) )
    {
        return;
    }

    //
    //  turn timeouts back into TTLs
    //

    currentTime = g_CurrentCacheTime;

    while ( prr )
    {
        DWORD   ttl = prr->dwTtl - currentTime;

        if ( (LONG)ttl < 0 )
        {
            ttl = 0;
        }
        prr->dwTtl = ttl;
        prr = prr->pNext;
    }
}



VOID
Cache_RecordSetAtomic(
    IN      PWSTR           pwsName,
    IN      WORD            wType,
    IN      PDNS_RECORD     pRecordSet
    )                
/*++

Routine Description:

    Cache record set atomically at entry.

    Cache_RecordList() handles breakup of record list
    and appropriate placing of records.  This does caching
    of single blob at particular location.

Arguments:

    pRecordSet -- record list to add

Globals:

    g_EntryCount -- decremented appropriately

    g_NumberOfRecordsInCache -- decremented appropriately

Return Value:

    None

--*/
{
    INT             iter;
    WORD            wtype;
    PWSTR           pname;
    BOOL            fstatic;
    PCACHE_ENTRY    pentry;
    BOOL            fretry;
    WORD            flushLevel;


    DNSDBG( TRACE, (
        "Cache_RecordSetAtomic( %S, type=%d, rr=%p )\n",
        pwsName,
        wType,
        pRecordSet ));

    if ( !pRecordSet )
    {
        return;
    }
    fstatic = IS_STATIC_RR(pRecordSet);

    DNS_ASSERT( !fstatic ||
                pRecordSet->pNext == NULL ||
                (pRecordSet->wType==DNS_TYPE_CNAME) )

    //
    //  determine caching type
    //      - specified OR from records
    //      CNAMEs will be at the head of a lookup from another type
    //

    wtype = wType;
    if ( !wtype )
    {
        wtype = pRecordSet->wType;
    }

    //
    //  if name specified use it, otherwise use from records
    //

    pname = pwsName;
    if ( !pname )
    {
        pname = pRecordSet->pName;
    }

    //
    //  prepare RR set for cache
    //

    Cache_PrepareRecordList( pRecordSet );

    //
    //  find\create cache entry and cache
    //

    LOCK_CACHE();

    pentry = Cache_FindEntry(
                pname,
                TRUE    // create
                );
    if ( !pentry )
    {
        goto Failed;
    }

    //
    //  clean up existing records at node
    //      - remove stale records
    //      - remove records of same type
    //      - if NAME_ERROR caching remove everything
    //      from wire
    //

    flushLevel = FLUSH_LEVEL_NORMAL;

    if ( wtype == DNS_TYPE_ALL &&
         pRecordSet->wDataLength == 0 )
    {
        flushLevel = FLUSH_LEVEL_WIRE;
    }

    Cache_FlushEntryRecords(
        pentry,
        flushLevel,
        wtype );

    //
    //  check for matching record type still there
    //

    for ( iter = 0;
          iter < (INT)pentry->MaxCount;
          iter++ )
    {
        PDNS_RECORD     prrExist = pentry->Records[iter];

        if ( !prrExist ||
             prrExist->wType != wtype )
        {
            continue;
        }

        //  matching type still there after flush
        //      - if trying to cache wire set at hostfile entry, fail

        DNS_ASSERT( IS_STATIC_RR(prrExist) );

        if ( !fstatic )
        {
            DNSDBG( ANY, (
                "ERROR:  attempted caching at static (hosts file) record data!\n"
                "\tpRecord  = %p\n"
                "\tName     = %S\n"
                "\tType     = %d\n"
                "\t-- Dumping new cache record list.\n",
                pRecordSet,
                pRecordSet->pName,
                pRecordSet->wType ));
            goto Failed;
        }

        //
        //  append host file records
        //      - start at "record" which is addr of record ptr entry
        //      making pNext field the actual pointer
        //      - delete duplicates
        //      - tack new RR on end
        //      - blow away new RR name if existing record
        //
        //  DCR:  should have simple "make cache RR set" function that
        //      handles name and TTL issues
        //
        //  DCR:  broken if non-flush load hits wire data;  wire data
        //      may have multiple RR sets
        //

        else
        {
            PDNS_RECORD prr;
            PDNS_RECORD prrPrev = (PDNS_RECORD) &pentry->Records[iter];

            while ( prr = prrPrev->pNext )
            {
                //  matches existing record?
                //      - cut existing record from list and free

                if ( Dns_RecordCompare( prr, pRecordSet ) )
                {
                    prrPrev->pNext = prr->pNext;
                    Dns_RecordFree( prr );
                }
                else
                {
                    prrPrev = prr;    
                }
            }

            //
            //  tack entry on to end
            //      - if existing records of type delete name
            //

            if ( prrPrev != (PDNS_RECORD)&pentry->Records[iter] )
            {
                if ( IS_FREE_OWNER(pRecordSet) )
                {
                    RECORD_HEAP_FREE( pRecordSet->pName );
                    pRecordSet->pName = NULL;
                }
            }
            prrPrev->pNext = pRecordSet;
            goto Done;
        }
    }

    //
    //  put record into cache entry
    //
    //  if no slot is available, switch to a harder scrub
    //
    //  DCR:  realloc if out of slots
    //

    fretry = FALSE;

    while ( 1 )
    {
        for ( iter = 0;
              iter < (INT)pentry->MaxCount;
              iter++ )
        {
            if ( pentry->Records[iter] == NULL )
            {
                pentry->Records[iter] = pRecordSet;
                g_RecordSetCount++;
                g_RecordSetCache++;
                goto Done;
            }
        }

        if ( !fretry )
        {
            DNSDBG( QUERY, (
                "No slots caching RR set %p at entry %p\n"
                "\tdoing strong flush to free slot.\n",
                pRecordSet,
                pentry ));
    
            Cache_FlushEntryRecords(
                pentry,
                FLUSH_LEVEL_WIRE,
                0 );
    
            fretry = TRUE;
            continue;
        }

        DNSDBG( ANY, (
            "ERROR:  Failed to cache set %p at entry %p\n",
            pRecordSet,
            pentry ));
        goto Failed;
    }

Failed:

    DNSDBG( TRACE, ( "Cache_RecordSetAtomic() => failed\n" ));
    Dns_RecordListFree( pRecordSet );

Done:

    UNLOCK_CACHE();
    DNSDBG( TRACE, ( "Leave Cache_RecordSetAtomic()\n" ));
    return;
}



VOID
Cache_RecordList(
    IN OUT  PDNS_RECORD     pRecordList
    )
/*++

Routine Description:

    Cache record list.

    This is cache routine for "oddball" records -- not caching under
    queried name.
        - hostfile
        - answer records at CNAME
        - additional data at additional name

Arguments:

    pRecordList -- record list to cache

Return Value:

    None

--*/
{
    BOOL            fcnameAnswer = FALSE;
    PDNS_RECORD     pnextRR = pRecordList;
    PDNS_RECORD     prr;
    BOOL            fstatic;


    DNSDBG( TRACE, (
        "Cache_RecordList( rr=%p )\n",
        pRecordList ));

    if ( !pRecordList )
    {
        return;
    }
    fstatic = IS_STATIC_RR(pRecordList);

    //
    //  cache records:
    //      - cache additional records in query
    //      - cache CNAME data from query
    //      - cache host file data
    //
    //  background:  Glenn's caching paradigm was to cache all answer
    //  data at the queried name in the API call (name might be short).
    //  However, not caching the CNAME data can cause problems, so this
    //  was tacked on.
    //
    //  For CNAME caching we throw away the CNAMEs themselves and just
    //  cache the actually data (address) records at the CNAME node.
    //

    //
    //  cache additional records
    //  

    while ( prr = pnextRR )
    {
        BOOL    fcacheSet = FALSE;

        pnextRR = Dns_RecordSetDetach( prr );

        //
        //  host file data -- always cache
        //
        //  for CNAME want CNAME AND associated answer data
        //      - detach to get new next set
        //      - append answer data back on to CNAME for caching
        //      - next RR set (if exists) will be another CNAME
        //          to the same address data
        //
        //  DCR:  follow CNAMEs in cache
        //      then could pull this hack
        //      and avoid double building of answer data in dnsapi
        //

        if ( fstatic )
        {
            fcacheSet = TRUE;

            if ( prr->wType == DNS_TYPE_CNAME &&
                 pnextRR &&
                 pnextRR->wType != DNS_TYPE_CNAME )
            {
                PDNS_RECORD panswer = pnextRR;

                pnextRR = Dns_RecordSetDetach( panswer );

                Dns_RecordListAppend( prr, panswer );
            }
        }

        //
        //  wire data -- do NOT cache:
        //      - answer records for queried name (not CNAME)
        //      - CNAME records when doing caching of answer data under CNAME
        //      - authority section records (NS, SOA, etc)
        //      - OPT records
        //

        else if ( prr->Flags.S.Section == DNSREC_ANSWER )
        {
            if ( prr->wType == DNS_TYPE_CNAME )
            {
                fcnameAnswer = TRUE;
            }
            else if ( fcnameAnswer )
            {
                fcacheSet = TRUE;
            }
        }
        else if ( prr->Flags.S.Section == DNSREC_ADDITIONAL )
        {
            if ( prr->wType != DNS_TYPE_OPT )
            {
                fcacheSet = TRUE;
            }
        }

        if ( !fcacheSet )
        {
            Dns_RecordListFree( prr );
            continue;
        }

        //
        //  cache the set
        //
        //  flip the section field to "Answer" section
        //
        //  DCR:  section caching?
        //
        //  note:  section fields in cache indicate whether
        //      answer data (or additional) once out of
        //      cache;
        //      this is necessary since we cache everything
        //      at node and return it in one RR list;  we'd
        //      to change must
        //          - return in different lists with some indication
        //              in cache of what's what
        //          OR
        //          - another indication of what's what
        //

        //if ( !fstatic )
        //  currently HostFile entries get answer too
        {
            PDNS_RECORD ptemp = prr;
            while ( ptemp )
            {
                ptemp->Flags.S.Section = DNSREC_ANSWER;
                ptemp = ptemp->pNext;
            }
        }

        Cache_RecordSetAtomic(
            NULL,
            0,
            prr );
    }

    DNSDBG( TRACE, ( "Leave Cache_RecordList()\n" ));
}



VOID
Cache_FlushRecords(
    IN      PWSTR           pName,
    IN      DWORD           Level,
    IN      WORD            Type
    )
/*++

Routine Description:

    Flush cached records corresponding to a name and type.

Arguments:

    pName -- name of records to delete

    Level -- flush level

    Type -- type of records to delete;
        0 to flush all records at name

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    WORD            iter;
    PCACHE_ENTRY    pentry = NULL;
    PCACHE_ENTRY    pprevEntry = NULL;


    DNSDBG( TRACE, (
        "Cache_FlushRecords( %S, %d )\n",
        pName,
        Type ));

    //
    //  lock with no-start
    //      - bail if no cache
    //
    //  need this as PnP release notifications will attempt to
    //  flush local cache entries;  this avoids rebuilding when
    //  already down
    //

    LOCK_CACHE_NO_START();
    if ( !g_HashTable )
    {
        goto Done;
    }

    //
    //  find entry in cache
    //
    pentry = Cache_FindEntry(
                pName,
                FALSE       // no create
                );
    if ( !pentry )
    {
        goto Done;
    }

    //
    //  flush records of type
    //      - zero type will flush all
    //
    //  note:  Cache_FindEntry() always moves the found entry
    //      to the front of the hash bucket list;  this allows
    //      us to directly whack the entry
    //

    if ( Cache_FlushEntryRecords(
            pentry,
            Level,
            Type ) )
    {
        DWORD   index = getHashIndex(
                            pentry->pName,
                            0 );

        DNS_ASSERT( pentry == g_HashTable[index] );
        if ( pentry == g_HashTable[index] )
        {
            g_HashTable[ index ] = pentry->pNext;
            Cache_FreeEntry( pentry );
        }
    }

Done:

    UNLOCK_CACHE();
}



#if 0
BOOL
ReadCachedResults(
    OUT     PDNS_RESULTS    pResults,
    IN      PWSTR           pwsName,
    IN      WORD            wType
    )
/*++

Routine Description:

    Find records of given name and type in cache.

Arguments:

    pResults -- addr to receive results

    pwsName -- name

    wType -- record type to find

Return Value:

    TRUE if results found.
    FALSE if no cached data for name and type.

--*/
{
    PDNS_RECORD     prr;
    DNS_STATUS      status;
    BOOL            found = FALSE;

    //
    //  clear results
    //

    RtlZeroMemory( pResults, sizeof(*pResults) );

    //  get cache results


    //  break out into results buffer

    if ( found )
    {
        BreakRecordsIntoBlob(
            pResults,
            prr,
            wType );
    
        pResults->Status = status;
    }

    return( found );
}
#endif



//
//  Cache utilities for remote routines
//

PDNS_RECORD
Cache_FindRecordsPrivate(
    IN      PWSTR           pwsName,
    IN      WORD            wType
    )
/*++

Routine Description:

    Find records of given name and type in cache.

Arguments:

    pwsName -- name

    Type -- record type to find

Return Value:

    Ptr to record set of desired type -- if found.
    NULL if not found.

--*/
{
    PCACHE_ENTRY    pentry;
    PDNS_RECORD     prr = NULL;

    DNSDBG( TRACE, (
        "Cache_FindRecordsPrivate( %S, type=%d )\n",
        pwsName,
        wType ));

    LOCK_CACHE();

    pentry = Cache_FindEntry(
                pwsName,
                FALSE );
    if ( pentry )
    {
        prr = Cache_FindEntryRecords(
                    pentry,
                    wType );
    }

    UNLOCK_CACHE();

    DNSDBG( TRACE, (
        "Leave Cache_FindRecordsPrivate( %S, type=%d ) => %p\n",
        pwsName,
        wType,
        prr ));

    return  prr;
}



BOOL
Cache_GetRecordsForRpc(
    OUT     PDNS_RECORD *   ppRecordList,
    OUT     PDNS_STATUS     pStatus,
    IN      PWSTR           pwsName,
    IN      WORD            wType,
    IN      DWORD           Flags
    )
/*++

Routine Description:

    Find records of given name and type in cache.

Arguments:

    ppRecordList -- addr to receive pointer to record list

    pStatus -- addr to get status return

    pwsName -- name

    Type -- record type to find

    Flags -- query flags

Return Value:

    TRUE if cache hit.  OUT params are valid.
    FALSE if cache miss.  OUT params are unset.

--*/
{
    PDNS_RECORD prr;
    PDNS_RECORD prrResult = NULL;
    DNS_STATUS  status = NO_ERROR;

    DNSDBG( RPC, (
        "Cache_GetRecordsForRpc( %S, t=%d )\n",
        pwsName,
        wType ));

    if ( (Flags & DNS_QUERY_BYPASS_CACHE) &&
         (Flags & DNS_QUERY_NO_HOSTS_FILE) )
    {
        return  FALSE;
    }

    LOCK_CACHE();

    //
    //  check cache for name and type
    //      - if name or type missing, jump to wire lookup
    //

    prr = Cache_FindRecordsPrivate(
                pwsName,
                wType );
    if ( !prr )
    {
        goto Failed;
    }

    //
    //  cache hit
    //
    //  if only interested in host file data ignore
    //

    if ( IS_HOSTS_FILE_RR(prr) )
    {
        if ( Flags & DNS_QUERY_NO_HOSTS_FILE )
        {
            goto Failed;
        }
    }
    else    // cache data
    {
        if ( Flags & DNS_QUERY_BYPASS_CACHE )
        {
            goto Failed;
        }
    }

    //
    //  build response from cache data
    //      - cached NAME_ERROR or empty
    //      - cached records
    //
    
    if ( prr->wDataLength == 0 )
    {
        status = (prr->wType == DNS_TYPE_ANY)
                    ? DNS_ERROR_RCODE_NAME_ERROR
                    : DNS_INFO_NO_RECORDS;
    }
    else
    {
        //  for CNAME query, get only the CNAME record itself
        //      not the data at the CNAME
        //
        //  DCR:  CNAME handling should be optional -- not given
        //      for cache display purposes
        //
    
        if ( wType == DNS_TYPE_CNAME &&
             prr->wType == DNS_TYPE_CNAME &&
             prr->Flags.S.Section == DNSREC_ANSWER )
        {
            prrResult = Dns_RecordCopyEx(
                                prr,
                                DnsCharSetUnicode,
                                DnsCharSetUnicode );
        }
        else
        {
            prrResult = Dns_RecordSetCopyEx(
                                prr,
                                DnsCharSetUnicode,
                                DnsCharSetUnicode );
        }

        if ( prrResult )
        {
            Cache_RestoreRecordListForRpc( prrResult );
            status = ERROR_SUCCESS;
        }
        else
        {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    UNLOCK_CACHE();

    //  set return values

    *ppRecordList = prrResult;
    *pStatus = status;

    return  TRUE;


Failed:

    UNLOCK_CACHE();
    return  FALSE;
}



//
//  Garbage collection
//

VOID
Cache_SizeCheck(
    VOID
    )
/*++

Routine Description:

    Check cache size.

Arguments:

    Flag -- flag, currently unused

Return Value:

    None

--*/
{
    //
    //  ok -- don't signal for garbage collect
    //
    //      - below threshold
    //      - already in garbage collection
    //      - collected recently
    //

    if ( g_RecordSetCount < g_RecordSetCountThreshold ||
         g_GarbageCollectFlag ||
         g_NextGarbageTime > GetCurrentTimeInSeconds() )
    {
        return;
    }

    DNSDBG( CACHE, (
        "Cache_SizeCheck() over threshold!\n"
        "\tRecordSetCount       = %d\n"
        "\tRecordSetCountLimit  = %d\n"
        "\tStarting garbage collection ...\n",
        g_RecordSetCount,
        g_RecordSetCountThreshold ));

    //
    //  signal within lock, so that service thread
    //      can do signal within lock and avoid race on StopFlag check
    //      obviously better to simply not overload lock
    //

    LOCK_CACHE();
    if ( !g_StopFlag )
    {
        g_GarbageCollectFlag = TRUE;
        SetEvent( g_hStopEvent );
    }
    UNLOCK_CACHE();
}



VOID
Cache_GarbageCollect(
    IN      DWORD           Flag
    )
/*++

Routine Description:

    Garbage collect cache.

Arguments:

    Flag -- flag, currently unused

Return Value:

    None

--*/
{
    DWORD   iter;
    DWORD   index;
    WORD    flushLevel;
    DWORD   passCount;

    DNSDBG( CACHE, (
        "Cache_GarbageCollect()\n"
        "\tNextIndex            = %d\n"
        "\tRecordSetCount       = %d\n"
        "\tRecordSetLimit       = %d\n"
        "\tRecordSetThreshold   = %d\n",
        g_NextGarbageIndex,
        g_RecordSetCount,
        g_RecordSetCountLimit,
        g_RecordSetCountThreshold
        ));

    if ( !g_HashTable )
    {
        return;
    }

    //
    //  collect timed out data in cache
    //
    //  DCR:  smart garbage detect
    //      - cleans until below limit
    //      - first pass invalid
    //      - then the hard stuff
    //  use restartable index so get through the cach
    //

    passCount = 0;
    while ( 1 )
    {
        if ( passCount == 0 )
        {
            flushLevel = FLUSH_LEVEL_INVALID;
        }
        else if ( passCount == 1 )
        {
            flushLevel = FLUSH_LEVEL_GARBAGE;
        }
        else
        {
            break;
        }
        passCount++;

        //
        //  flush all hash bins at current flush level
        //  until
        //      - service stop
        //      - push cache size below limit
        //

        for ( iter = 0;
              iter < g_HashTableSize;
              iter++ )
        {
            index = (iter + g_NextGarbageIndex) % g_HashTableSize;

            if ( g_StopFlag ||
                 g_WakeFlag ||
                 g_RecordSetCount < g_RecordSetCountLimit )
            {
                passCount = MAXDWORD;
                break;
            }

            Cache_FlushBucket(
                index,
                flushLevel );
        }
    
        index++;
        if ( index >= g_HashTableSize )
        {
            index = 0;
        }
        g_NextGarbageIndex = index;
    }

    //
    //  reset garbage globals
    //      - lockout for interval
    //      - clear signal flag
    //      - reset event (if not shuttting down)
    //
    //  note:  reset signal within lock, so that service thread
    //  can do signal within lock and avoid race on StopFlag check
    //  obviously better to simply not overload lock
    //

    g_NextGarbageTime = GetCurrentTimeInSeconds() + GARBAGE_LOCKOUT_INTERVAL;

    LOCK_CACHE();
    if ( !g_StopFlag )
    {
        g_GarbageCollectFlag = FALSE;
        ResetEvent( g_hStopEvent );
    }
    UNLOCK_CACHE();

    DNSDBG( CACHE, (
        "Leave Cache_GarbageCollect()\n"
        "\tNextIndex            = %d\n"
        "\tNextTime             = %d\n"
        "\tRecordSetCount       = %d\n"
        "\tRecordSetLimit       = %d\n"
        "\tRecordSetThreshold   = %d\n",
        g_NextGarbageIndex,
        g_NextGarbageTime,
        g_RecordSetCount,
        g_RecordSetCountLimit,
        g_RecordSetCountThreshold
        ));
}



//
//  Hostfile load stuff
//

VOID
LoadHostFileIntoCache(
    IN      PSTR            pszFileName
    )
/*++

Routine Description:

    Read hosts file into cache.

Arguments:

    pFileName -- file name to load

Return Value:

    None.

--*/
{
    HOST_FILE_INFO  hostInfo;

    DNSDBG( INIT, ( "Enter  LoadHostFileIntoCache\n" ));

    //
    //  read entries from host file until exhausted
    //      - cache A record for each name and alias
    //      - cache PTR to name
    //

    RtlZeroMemory(
        &hostInfo,
        sizeof(hostInfo) );

    hostInfo.pszFileName = pszFileName;

    if ( !Dns_OpenHostFile( &hostInfo ) )
    {
        return;
    }
    hostInfo.fBuildRecords = TRUE;

    while ( Dns_ReadHostFileLine( &hostInfo ) )
    {
        //  cache all the records we sucked out

        Cache_RecordList( hostInfo.pForwardRR );
        Cache_RecordList( hostInfo.pReverseRR );
        Cache_RecordList( hostInfo.pAliasRR );
    }

    Dns_CloseHostFile( &hostInfo );

    DNSDBG( INIT, ( "Leave  LoadHostFileIntoCache\n" ));
}



VOID
InitCacheWithHostFile(
    VOID
    )
/*++

Routine Description:

    Initialize cache with host(s) file.

    This handles regular cache file and ICS file if it
    exists.

Arguments:

    None

Return Value:

    None.

--*/
{
    DNSDBG( INIT, ( "Enter  InitCacheWithHostFile\n" ));

    //
    //  load host file into cache
    //

    LoadHostFileIntoCache( NULL );

    //
    //  if running ICS, load it's file also
    //

    LoadHostFileIntoCache( "hosts.ics" );

    DNSDBG( INIT, ( "Leave  InitCacheWithHostFile\n\n\n" ));
}



DNS_STATUS
Cache_QueryResponse(
    IN OUT  PQUERY_BLOB     pBlob
    )
/*++

Routine Description:

    Find records of given name and type in cache.

Arguments:

    pBlob -- query blob

    Uses:
        pwsName
        wType
        Status
        pRecords
        fCacheNegativeResponse

    Sets:
        pRecords - may be reset to exclude non-RPCable records

Return Value:

    ErrorStatus -- same as query status, unless processing error during caching

--*/
{
    DNS_STATUS      status = pBlob->Status;
    PWSTR           pname = pBlob->pNameOrig;
    WORD            wtype = pBlob->wType;
    PDNS_RECORD     presultRR = pBlob->pRecords;


    DNSDBG( RPC, (
        "\nCache_QueryResponse( %S, type %d )\n",
        pname,
        wtype ));

    //
    //  successful response
    //      - make copy of records to return to caller
    //      - cache actual query record set
    //      - make copy to cache any additional data
    //

    if ( status == ERROR_SUCCESS  &&  presultRR )
    {
        DWORD           copyFlag;
        PDNS_RECORD     prrCache;

        //  cleanup for RPC and caching

        prrCache = Dns_RecordListScreen(
                        presultRR,
                        SCREEN_OUT_AUTHORITY | SCREEN_OUT_NON_RPC );

        //
        //  make copy for return
        //      - don't include authority records
        //
        //  NOTE:  IMPORTANT
        //  we return (RPC) a COPY of the wire set and cache the
        //  wire set;  this is because the wire set has imbedded data
        //  (the data pointers are not actual heap allocations) and
        //  and hence can not be RPC'd (without changing the RPC
        //  definition to flat data)
        //
        //  if we later want to return authority data on first query,
        //  then
        //      - clean non-RPC only
        //          - including owner name fixups
        //      - copy for result set
        //      - clean original for authority -- cache
        //      - clean any additional -- cache
        //  
        //  note:  do name pointer fixup by making round trip into cache format
        //
        //  DCR:  shouldn't have external name pointers anywhere
        //  DCR:  do RPC-able cleanup on original set before copy
        //      OR
        //  DCR:  have "cache state" on record
        //      then could move original results to cache state and caching
        //      routines could detect state and avoid double TTLing

        presultRR = Dns_RecordListCopyEx(
                        prrCache,
                        0,
                        // SCREEN_OUT_AUTHORITY
                        DnsCharSetUnicode,
                        DnsCharSetUnicode );

        pBlob->pRecords = presultRR;
        if ( !presultRR )
        {
            Dns_RecordListFree( prrCache );
            status = DNS_ERROR_NO_MEMORY;
            goto Done;
        }

        //  name pointer fixup

        Cache_PrepareRecordList( presultRR );
        Cache_RestoreRecordListForRpc( presultRR );

        //
        //  do NOT cache local records
        //
        //  note:  we went through this function only to get
        //      PTR records and CNAME records in RPC format
        //      (no imbedded pointers)
        //

        if ( pBlob->pLocalRecords )
        {
            Dns_RecordListFree( prrCache );
            goto Done;
        }

        //
        //  cache original data
        //

        if ( prrCache )
        {
            Cache_RecordSetAtomic(
                pname,
                wtype,
                prrCache );
        }

        //
        //  extra records
        //      - additional data
        //      - CNAME answer data to cache at CNAME itself
        //      in CNAME case must include ANSWER data, but
        //      skip the CNAME itself
        //
        //  Cache_RecordList() breaks records into RR sets before caching
        //  

        prrCache = presultRR;
        copyFlag = SCREEN_OUT_ANSWER | SCREEN_OUT_AUTHORITY;

        if ( prrCache->wType == DNS_TYPE_CNAME )
        {
            prrCache = prrCache->pNext;
            copyFlag = SCREEN_OUT_AUTHORITY;
        }

        prrCache = Dns_RecordListCopyEx(
                        prrCache,
                        copyFlag,
                        DnsCharSetUnicode,
                        DnsCharSetUnicode );
        if ( prrCache )
        {
            Cache_RecordList( prrCache );
        }
    }

    //
    //  negative response
    //

    else if ( status == DNS_ERROR_RCODE_NAME_ERROR ||
              status == DNS_INFO_NO_RECORDS )
    {
        DWORD           ttl;
        PDNS_RECORD     prr;

        if ( !pBlob->fCacheNegative )
        {
            DNSDBG( QUERY, (
                "No negative caching for %S, type=%d\n",
                pname, wtype ));
            goto Done;
        }

        //
        //  create negative cache entry
        //
        //  DCR:  should use TTL returned in SOA
        //

        prr = Dns_AllocateRecord( 0 );
        if ( !prr )
        {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto Done;
        }

        prr->pName = (PWSTR) Dns_StringCopyAllocate(
                                (PCHAR) pname,
                                0,      // NULL terminated
                                DnsCharSetUnicode,
                                DnsCharSetUnicode );
        if ( prr->pName )
        {
            SET_FREE_OWNER( prr );
        }

        prr->wDataLength = 0;
        ttl = g_MaxNegativeCacheTtl;

        if ( wtype == DNS_TYPE_SOA
                &&
             ttl > g_NegativeSOACacheTime )
        {
            ttl = g_NegativeSOACacheTime;
        }
        prr->dwTtl = ttl;
        prr->Flags.S.CharSet = DnsCharSetUnicode;
        prr->Flags.S.Section = DNSREC_ANSWER;
        prr->Flags.DW |= DNSREC_NOEXIST;

        if ( status == DNS_ERROR_RCODE_NAME_ERROR )
        {
            prr->wType = DNS_TYPE_ANY;
        }
        else
        {
            prr->wType = wtype;
        }

        Cache_RecordSetAtomic(
            NULL,   // default name
            0,      // default type
            prr );
    }

    //  failure return from query
    //      - nothing to cache

    else
    {
        DNSDBG( QUERY, (
            "Uncacheable error code %d -- no caching for %S, type=%d\n",
            status,
            pname,
            wtype ));
    }

Done:

    //
    //  check cache size to see if garbage collect necessary
    //
    //  note we do this only on query caching;  this avoids
    //      - jamming ourselves in hosts file load
    //      - wakeup and grabbing lock between separate sets of query response
    //

    Cache_SizeCheck();

    return  status;
}

//
//  End ncache.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\resolver\server\memlog.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    memlog.c

Abstract:

    DNS Resolver Service

    In memory logging.

Author:

    Glenn Curtis    (glennc)    Feb 1998

Revision History:

    Jim Gilroy  (jamesg)        March 2000      cleanup
    Jim Gilroy  (jamesg)        Nov 2000        create this module

--*/


#include "local.h"


//
//  Memory event array
//

typedef struct _InMemoryEvent
{
    DWORD           Thread;
    DWORD           Ticks;
    DWORD           Checkpoint;
    DWORD           Data;
}
MEM_EVENT, *PMEM_EVENT;


#define MEM_EVENT_ARRAY_SIZE    200

PMEM_EVENT  g_pEventArray = NULL;

LONG        g_EventArrayLength = MEM_EVENT_ARRAY_SIZE;
LONG        g_EventIndex = 0;



VOID
LogEventInMemory(
    IN      DWORD           Checkpoint,
    IN      DWORD           Data
    )
{
    DWORD   index;

    //
    //  allocate event table
    //      - use interlock to insure only done once
    //

    if ( !g_pEventArray )
    {
        PMEM_EVENT  ptemp = (PMEM_EVENT)
                                HeapAlloc(
                                    GetProcessHeap(),
                                    HEAP_ZERO_MEMORY,
                                    g_EventArrayLength * sizeof(MEM_EVENT) );
        if ( !ptemp )
        {
            return;
        }
        if ( InterlockedCompareExchangePointer(
                (PVOID *) &g_pEventArray,
                ptemp,
                0) != 0 )
        {
            HeapFree(GetProcessHeap(), 0, ptemp);
        }
    }

    //
    //  write event to memory
    //

    index = InterlockedIncrement( &g_EventIndex );

    index %= g_EventArrayLength;

    g_pEventArray[index].Ticks      = GetTickCount();
    g_pEventArray[index].Checkpoint = Checkpoint;
    g_pEventArray[index].Thread     = (short) GetCurrentThreadId();
    g_pEventArray[index].Data       = Data;
}

//
//  memlog.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\resolver\server\mcast.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    mcast.c

Abstract:

    DNS Resolver Service

    Multicast routines.

Author:

    Glenn Curtis (glennc)       December 1999

Revision History:

    James Gilroy (jamesg)       February 2000       cleanup

--*/


#include "local.h"


//
//  Globals
//

HANDLE              g_hMulticastThread = NULL;

BOOL                g_MulticastStop = FALSE;
SOCKET              g_MulticastUnicastSocket = 0;
PSOCKET_CONTEXT     g_MulticastIoContextList = NULL;

HANDLE              g_MulticastCompletionPort = NULL;

//
//  Should be read from netinfo blob
//
PSTR                g_HostName = NULL;


//
//  Multicast config globals
//
//  DCR:  regkeys for multicast values
//

#define DNS_DEFAULT_ALLOW_MULTICAST_RESOLVER_OPERATION 0    // Off
#define DNS_DEFAULT_ALLOW_MULTICAST_RESOLVER_AS_PROXY  0    // Off
#define DNS_DEFAULT_ALLOW_MULTICAST_DNS_SRV_RECORD 0        // Off
#define DNS_DEFAULT_MULTICAST_RESOLVER_RECORD_TTL  10*60    // 10 minutes

DWORD   g_MulticastRecordTTL            = DNS_DEFAULT_MULTICAST_RESOLVER_RECORD_TTL;
BOOL    g_AllowMulticastAsProxy         = FALSE;
BOOL    g_AllowMulticastDnsSrvRecord    = FALSE;



//
//  Private prototypes
//

BOOL
IsLocalMachineQuery(
    IN      LPSTR           pName,
    IN      WORD            Type,
    OUT     PDNS_RECORD *   ppRecord
    );

VOID
FixupNameOwnerPointers(
    IN OUT  PDNS_RECORD     pRecord
    );

PDNS_RECORD
BuildPTR(
    IN      LPSTR           pName,
    IN      LPSTR           pHostname,
    IN      LPSTR           pDomain,
    IN      LPSTR           pPrimaryDomain
    );

PDNS_RECORD
BuildARecord(
    IN  LPSTR      Name,
    IN  IP_ADDRESS Address );

PDNS_RECORD
BuildDNSServerRecord(
    IN  IP_ADDRESS Address );

PDNS_RECORD
BuildLocalAddressRecords(
    IN  LPSTR Name );

BOOL
IsLocalAddress(
    IN  IP_ADDRESS Ip );

PSOCKET_CONTEXT
AllocateIoContext(
    IN  IP_ADDRESS ipAddr );

VOID
FreeIoContextList(
    IN  PSOCKET_CONTEXT pContext,
    IN  BOOL            fIssueSocketShutdown );

VOID
DropReceive(
    IN  PSOCKET_CONTEXT pContext );





VOID
MulticastThread(
    VOID
    )
/*++

Routine Description:

    Multicast response thread.

    Runs while cache is running, responding to multicast queries.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DNS_STATUS          status = NO_ERROR;
    PDNS_NETINFO        ptempNetInfo = NULL;
    PSOCKET_CONTEXT     pcontext;
    DWORD               iter;
    DWORD               bytesRecvd;
    LPOVERLAPPED        poverlapped;

    //
    //  init globals for safe cleanup on failure
    //

    g_MulticastStop = FALSE;
    g_MulticastCompletionPort = NULL;
    g_MulticastUnicastSocket = 0;
    g_MulticastIoContextList = NULL;

    //
    // We are going to create a completion port with
    // socket contexts for each of the primary IP addresses of each
    // adapter on the system.
    //

    //
    // Get a copy of the network adapter information
    //

    ptempNetInfo = GrabNetworkInfo();
    if ( ! ptempNetInfo )
    {
        goto Cleanup;
    }

    //
    //  create multicast completion port
    //

    g_MulticastCompletionPort = CreateIoCompletionPort(
                                            INVALID_HANDLE_VALUE,
                                            NULL,
                                            0,
                                            0 );
    if ( ! g_MulticastCompletionPort )
    {
        DNSLOG_F1( "Error: Failed to create io completion port." );
        goto Cleanup;
    }

    // We create two sockets here, one for multicast receives and
    // one for the unicast response. This shouldn't be necessary;
    // there should be nothing preventing us from responding via
    // unicast even with a socket that's joined to a multicast address.
    // In most cases, it does in fact work; but it seems that
    // packets sent to the local address do not arrive if they are
    // sent from a socket that is configured for multicast receive.
    // Apparently, such a socket sends all packets onto the wire
    // without checking the destination address. I imagine this is
    // a bug in the TCP stack, perhaps, but for now, creating two
    // separate sockets is a simple workaround. - tbrown 10/19/99

    g_MulticastUnicastSocket = Dns_CreateSocket(
                                    SOCK_DGRAM,
                                    INADDR_ANY,
                                    DNS_PORT_NET_ORDER );

    if ( g_MulticastUnicastSocket == 0 ||
         g_MulticastUnicastSocket == INVALID_SOCKET )
    {
        DNSLOG_F1( "Error: Failed to create unicast socket." );
        goto Cleanup;
    }

    //
    //  build context list
    //      - create socket\context for each adapters first IP
    //      - associate socket with completion port
    //

    g_MulticastIoContextList = NULL;
    pcontext = NULL;

    for ( iter = 0; iter < ptempNetInfo->cAdapterCount; iter++ )
    {
        PIP_ARRAY pipArray;

        pipArray = ptempNetInfo->AdapterArray[iter]->pAdapterIPAddresses;

        if ( pipArray &&
             pipArray->AddrCount )
        {
            PSOCKET_CONTEXT pnewContext;

            pnewContext = AllocateIoContext( pipArray->AddrArray[0] );
            if ( pnewContext )
            {
                HANDLE hport = NULL;

                if ( pcontext )
                {
                    pcontext->pNext = pnewContext;
                    pcontext = pnewContext;
                }
                else
                {
                    g_MulticastIoContextList = pnewContext;
                    pcontext = pnewContext;
                }

                hport = CreateIoCompletionPort(
                            (HANDLE) pnewContext->Socket,
                            g_MulticastCompletionPort,
                            (UINT_PTR) pnewContext,
                            0 );

                if ( !hport )
                {
                    DNSLOG_F1( "Error: Failed to add socket to io completion port." );
                    goto Cleanup;
                }
            }
        }
    }

    //
    //  if no sockets -- done
    //

    if ( ! g_MulticastIoContextList )
    {
        goto Cleanup;
    }

    //
    //  drop listen on sockets
    //

    pcontext = g_MulticastIoContextList;
    while ( pcontext )
    {
        DropReceive( pcontext );
        pcontext = pcontext->pNext;
    }

    //
    //  main listen loop
    //

    do
    {
        if ( g_LogTraceInfo )
        {
            DNSLOG_F1( "    Multicast Resolver: Going to listen for message." );
            DNSLOG_F1( "" );
        }

        if ( GetQueuedCompletionStatus(
                    g_MulticastCompletionPort,
                    & bytesRecvd,
                    & (ULONG_PTR) pcontext,
                    & poverlapped,
                    INFINITE ) )
        {
            //
            // We received notice that something happened on a given
            // completion port, get the socket from the context and
            // do a receive to see what we got.
            //

            if ( pcontext && bytesRecvd )
            {
                WORD        Xid;
                IP4_ADDRESS Ip;
                BYTE        Opcode;
                WORD        QuestionCount;
                WORD        AnswerCount;
                WORD        NameServerCount;
                WORD        AdditionalCount;

                Ip              = MSG_REMOTE_IP4( pcontext->pMsg );
                Xid             = pcontext->pMsg->MessageHead.Xid;
                Opcode          = pcontext->pMsg->MessageHead.Opcode;
                QuestionCount   = pcontext->pMsg->MessageHead.QuestionCount;
                AnswerCount     = pcontext->pMsg->MessageHead.AnswerCount;
                NameServerCount = pcontext->pMsg->MessageHead.NameServerCount;
                AdditionalCount = pcontext->pMsg->MessageHead.AdditionalCount;

                if ( g_LogTraceInfo )
                {
                    DNSLOG_F1( "  Multicast Resolver: Received DNS message." );
                    DNSLOG_F1( "  Message contained . . ." );
                    DNSLOG_F2( "  Xid                 : 0x%x", Xid );
                    DNSLOG_F2( "  IP Address          : %s", IP_STRING( Ip ) );
                    DNSLOG_F2( "  Opcode              : 0x%x", Opcode );
                    DNSLOG_F1( "" );
                }

                if ( g_MulticastStop )
                {
                    DNSLOG_F1( "  Multicast Resolver detected stop signal." );
                    DNSLOG_F1( "  Will not process last received message." );
                    DNSLOG_F1( "" );
                    continue;
                }

                if ( IsLocalAddress( Ip ) )
                {
                    if ( g_LogTraceInfo )
                    {
                        DNSLOG_F1( "  Multicast Resolver: Skip query from local machine." );
                        DNSLOG_F1( "" );
                    }
                    continue;
                }

                if ( Opcode == DNS_OPCODE_QUERY &&
                     QuestionCount == 1 &&
                     AnswerCount == 0 &&
                     NameServerCount == 0 &&
                     AdditionalCount == 0 )
                {
                    char        QuestionName[ DNS_MAX_NAME_BUFFER_LENGTH ];
                    WORD        QuestionNameLength = DNS_MAX_NAME_BUFFER_LENGTH;
                    PCHAR       pch;
                    WORD        QuestionType = 0;
                    WORD        QuestionClass = 0;
                    PDNS_RECORD pRecord = NULL;

                    pch = (PCHAR) &pcontext->pMsg->MessageBody;

                    //
                    // Get DNS Question name from packet
                    //
                    pch = Dns_ReadPacketName(
                                QuestionName,
                                &QuestionNameLength,
                                0,
                                0,
                                pch,
                                (PCHAR) &pcontext->pMsg->MessageHead,
                                pcontext->pMsg->pBufferEnd );

                    if ( !pch )
                    {
                        DNSLOG_F1( "  Multicast Resolver: Dns_ReadPacketName failed" );
                        DNSLOG_F2( "  with error: 0x%x" , DNS_RCODE_FORMAT_ERROR );
                        DNSLOG_F1( "" );
                        continue;
                    }

                    //
                    // Get DNS Question type from packet
                    //
                    QuestionType = ntohs( *(UNALIGNED WORD *) pch );
                    pch += sizeof( WORD );

                    //
                    // Get DNS Question class from packet
                    //
                    QuestionClass = ntohs( *(UNALIGNED WORD *) pch );
                    pch += sizeof( WORD );

                    DNSLOG_F1( "    Multicast Resolver - Valid query for . . ." );
                    DNSLOG_F2( "      Name  : %s", QuestionName );
                    DNSLOG_F2( "      Type  : %d", QuestionType );
                    DNSLOG_F2( "      Class : %d", QuestionClass );
                    DNSLOG_F1( "" );

                    //
                    // Set pCurrent so that question section is included
                    // in response packet.
                    //
                    pcontext->pMsg->pCurrent = pch;

                    pcontext->pMsg->MessageHead.IsResponse = TRUE;
                    pcontext->pMsg->MessageHead.ResponseCode = 0;
                    pcontext->pMsg->MessageHead.RecursionAvailable = 0;
                    pcontext->pMsg->MessageHead.Authoritative = 0;

                    if ( IsLocalMachineQuery( QuestionName,
                                              QuestionType,
                                              &pRecord ) )
                    {
                        DNSLOG_F1( "    Multicast Resolver: Got valid local machine query" );
                        pcontext->pMsg->MessageHead.Authoritative = TRUE;

                        status = Dns_AddRecordsToMessage( pcontext->pMsg,
                                                          pRecord,
                                                          FALSE );

                        Dns_RecordListFree( pRecord );

                        // Switch to the unicast socket
                        pcontext->pMsg->Socket = g_MulticastUnicastSocket;

                        Dns_Send( pcontext->pMsg );
                    }
                    else if ( g_AllowMulticastAsProxy )
                    {
                        LPSTR lpTempName = NULL;
                        WORD  wNameLen;

                        DNSLOG_F1( "    Multicast Resolver: Going to proxy query for client" );

                        wNameLen = (WORD) strlen( QuestionName );

                        lpTempName = MCAST_HEAP_ALLOC_ZERO(
                                                (wNameLen + 1) * sizeof(WCHAR) );

                        if ( lpTempName == NULL )
                        {
                            DNSLOG_F1( "    Multicast Resolver: HeapAlloc failed" );
                            continue;
                        }

                        Dns_NameCopy( lpTempName,
                                      NULL,
                                      QuestionName,
                                      wNameLen,
                                      DnsCharSetUtf8,
                                      DnsCharSetUnicode );

                        status = R_ResolverQuery(
                                            NULL,
                                            (LPWSTR) lpTempName,
                                            QuestionType,
                                            0,
                                            &pRecord );

                        MCAST_HEAP_FREE( lpTempName );

                        if ( status == DNS_ERROR_RCODE_NAME_ERROR )
                        {
                            DNSLOG_F1( "    Multicast Resolver: returning DNS_RCODE_NAME_ERROR" );
                            pcontext->pMsg->MessageHead.ResponseCode = DNS_RCODE_NAME_ERROR;

                            // Switch to the unicast socket
                            pcontext->pMsg->Socket = g_MulticastUnicastSocket;

                            Dns_Send( pcontext->pMsg );
                        }
                        else if ( status == DNS_ERROR_NAME_DOES_NOT_EXIST )
                        {
                            DNSLOG_F1( "    Multicast Resolver: returning DNS_RCODE_NXDOMAIN" );
                            pcontext->pMsg->MessageHead.ResponseCode = DNS_RCODE_NXDOMAIN;

                            // Switch to the unicast socket
                            pcontext->pMsg->Socket = g_MulticastUnicastSocket;

                            Dns_Send( pcontext->pMsg );
                        }
                        else if ( status == DNS_ERROR_RCODE_NXRRSET )
                        {
                            DNSLOG_F1( "    Multicast Resolver: returning DNS_RCODE_NXRRSET" );
                            pcontext->pMsg->MessageHead.ResponseCode = DNS_RCODE_NXRRSET;

                            // Switch to the unicast socket
                            pcontext->pMsg->Socket = g_MulticastUnicastSocket;

                            Dns_Send( pcontext->pMsg );
                        }
                        else if ( status == NO_ERROR )
                        {
                            if ( pRecord )
                            {
                                FixupNameOwnerPointers( pRecord );

                                status = Dns_AddRecordsToMessage(
                                                         pcontext->pMsg,
                                                         pRecord,
                                                         FALSE );

                                Dns_RecordListFree( pRecord );

                                if ( status != ERROR_SUCCESS )
                                {
                                    DNSLOG_F1( "    Multicast Resolver: Dns_AddRecordsToMessage failed" );
                                    DNSLOG_F2( "                     with error: 0x%x" , status );
                                    continue;
                                }

                                // Switch to the unicast socket
                                pcontext->pMsg->Socket = g_MulticastUnicastSocket;

                                Dns_Send( pcontext->pMsg );
                            }
                        }
                        else if ( pRecord )
                        {
                            DNSLOG_F1( "    Multicast Resolver: Nothing to return" );
                            Dns_RecordListFree( pRecord );
                        }
                    }
                    else
                    {
                        DNSLOG_F1( "    Multicast Resolver: Nothing can be done for this client query" );
                    }

                    DNSLOG_F1( "" );
                }

                //
                // Now send down another receive request to wait on.
                //
                DropReceive( pcontext );
            }
            else
            {
                DNSLOG_F1( "    Multicast Resolver: GQCP returned no context!" );
                DNSLOG_F1( "    Could be terminating resolver service?" );
                DNSLOG_F1( "" );
            }
        }
        else
        {
            //
            // GQCP failed, see what the failure was and handle accordingly
            //
            status = GetLastError();

            if ( !pcontext )
            {
                continue;
            }

            //
            // Now send down another receive request to wait on.
            //
            DropReceive( pcontext );
        }
    }
    while( !g_MulticastStop );


Cleanup :

    //
    //  cleanup multicast stuff
    //      - sockets, contexts, i/o completion port
    //

    NetInfo_Free( ptempNetInfo );

    if ( g_MulticastUnicastSocket )
    {
        Dns_CloseSocket( g_MulticastUnicastSocket );
        g_MulticastUnicastSocket = 0;
    }

    FreeIoContextList( g_MulticastIoContextList, FALSE );
    g_MulticastIoContextList = NULL;

    if ( g_MulticastCompletionPort )
    {
        CloseHandle( g_MulticastCompletionPort );
        g_MulticastCompletionPort = 0;
    }

    DNSLOG_F1( "MulticastThread exiting." );
}



VOID
MulticastThreadSignalStop(
    VOID
    )
/*++

Routine Description:

    Stop the multicast thread.

    Note, not synchronous, simply signals shutdown.

Arguments:

    None.

Return Value:

    None

--*/
{
    g_MulticastStop = TRUE;

    PostQueuedCompletionStatus(
        g_MulticastCompletionPort,
        0,
        0,
        NULL );
}



BOOL
IsLocalMachineQuery(
    IN      LPSTR           pName,
    IN      WORD            Type,
    OUT     PDNS_RECORD *   ppRecord
    )
{
    PDNS_NETINFO    ptempNetworkInfo = NULL;
    LPSTR           pszPrimaryDomain = NULL;
    DWORD           iter;
    DWORD           iter2;
    PDNS_RECORD     presultRecords = NULL;


    //
    //  if no hostname -- bail
    //
    //  note:  MUST INSURE hostname is never NULL afterwards or
    //      (preferred) take local copy under lock
    //     

    if ( !g_HostName )
    {
        return FALSE;
    }

    //
    //  get local copy of network info
    //
    //  DCR_FIX:  cleanup net-info creation
    //

    ptempNetworkInfo = GrabNetworkInfo();
    if ( ! ptempNetworkInfo )
    {
        return FALSE;
    }

    //  get primary domain name -- if any

    if ( ptempNetworkInfo->pSearchList )
    {
        pszPrimaryDomain = ptempNetworkInfo->pSearchList->pszDomainOrZoneName;
    }


    //
    //  A record query
    //

    if ( Type == DNS_TYPE_A )
    {
        char testName[DNS_MAX_NAME_LENGTH * 2];

        //
        //  host name with PDN if available
        //

        strcpy( testName, g_HostName );
        if ( pszPrimaryDomain )
        {
            strcat( testName, "." );
            strcat( testName, pszPrimaryDomain );
        }

        //  name matches hostname -- return name (with PDN if available)

        if ( Dns_NameCompare_UTF8( pName, g_HostName ) )
        {
            presultRecords = BuildLocalAddressRecords( testName );
            goto Done;
        }

        //  name matches full PDN -- return full PDN

        if ( pszPrimaryDomain &&
             Dns_NameCompare_UTF8( pName, testName ) )
        {
            presultRecords = BuildLocalAddressRecords( testName );
            goto Done;
        }

        //
        //  is name ".local" query
        //

        strcpy( testName, g_HostName );
        strcat( testName, "." );
        strcat( testName, MULTICAST_DNS_LOCAL_DOMAIN );

        if ( Dns_NameCompare_UTF8( pName, testName ) )
        {
            presultRecords = BuildLocalAddressRecords( testName );
            goto Done;
        }

        //
        //  see if name matches any adapter name
        //

        for ( iter = 0; iter < ptempNetworkInfo->cAdapterCount; iter++ )
        {
            PIP_ARRAY pipArray = ptempNetworkInfo->AdapterArray[iter]->
                                                    pAdapterIPAddresses;
            LPSTR     pszDomain = ptempNetworkInfo->AdapterArray[iter]->
                                      pszAdapterDomain;

            if ( pszDomain )
            {
                strcpy( testName, g_HostName );
                strcat( testName, "." );
                strcat( testName, pszDomain );

                if ( pipArray &&
                     Dns_NameCompare_UTF8( pName, testName ) )
                {
                    PDNS_RECORD pPrev = NULL;

                    for ( iter2 = 0; iter2 < pipArray->AddrCount; iter2++ )
                    {
                        PDNS_RECORD pNew = BuildARecord(
                                                testName,
                                                pipArray->AddrArray[iter2] );
                        if ( pNew )
                        {
                            if ( pPrev )
                                pPrev->pNext = pNew;
                            else
                                presultRecords = pNew;

                            pPrev = pNew;
                        }
                    }
                }
            }
        }
        goto Done;
    }

    //
    //  PTR query
    //

    else if ( Type == DNS_TYPE_PTR )
    {
        //
        //  check for loopback
        //  Dnslib uses this address to 'ping' adapters, must always respond
        //

        if ( Dns_NameCompare_UTF8( pName, "1.0.0.127.in-addr.arpa." ) )
        {
            presultRecords = BuildPTR(
                                    pName,
                                    g_HostName,
                                    NULL,
                                    pszPrimaryDomain );
            goto Done;
        }

        //
        //  check all IPs on box (one adapter at a time)
        //

        for ( iter = 0; iter < ptempNetworkInfo->cAdapterCount; iter++ )
        {
            PIP_ARRAY pipArray = ptempNetworkInfo ->
                                   AdapterArray[iter] ->
                                     pAdapterIPAddresses;
            LPSTR     pszDomain = ptempNetworkInfo ->
                                    AdapterArray[iter] ->
                                      pszAdapterDomain;

            if ( pipArray )
            {
                //  check if query matches IP for this adapter
                //
                //  ENHANCE:  this is backwards;  ought to covert query to IP
                //      and then check IPs, rather than turning every IP into
                //      reverse name;  then could even use standard routines
                //      to build PTR

                for ( iter2 = 0; iter2 < pipArray->AddrCount; iter2++ )
                {
                    CHAR        reverseName[DNS_MAX_REVERSE_NAME_BUFFER_LENGTH];
                    IP4_ADDRESS ip = pipArray->AddrArray[iter2];

                    Dns_Ip4AddressToReverseName_A(
                            reverseName,
                            ip );

                    if ( Dns_NameCompare_UTF8( pName, reverseName ) )
                    {
                        presultRecords = BuildPTR(
                                            pName,
                                            g_HostName,
                                            pszDomain,
                                            pszPrimaryDomain );
                        goto Done;          
                    }
                }
            }
        }
    }

    //
    //  SRV query
    //

    else if ( Type == DNS_TYPE_SRV )
    {
        //
        //  check if ".local" query
        //

        if ( Dns_NameCompare_UTF8( pName, MULTICAST_DNS_SRV_RECORD_NAME ) )
        {
            if ( g_AllowMulticastDnsSrvRecord &&
                 ptempNetworkInfo->cAdapterCount &&
                 ptempNetworkInfo->AdapterArray[0]->cServerCount )
            {
                presultRecords = BuildDNSServerRecord(
                                    ptempNetworkInfo->
                                        AdapterArray[0]->
                                            ServerArray[0].IpAddress );
                goto Done;
            }
        }
    }

Done:

    //  cleanup
    //  return records
    //  if found records TRUE;  otherwise FALSE

    NetInfo_Free( ptempNetworkInfo );

    *ppRecord = presultRecords;

    return( presultRecords != NULL );
}


VOID
FixupNameOwnerPointers(
    IN OUT  PDNS_RECORD     pRpcRecord
    )
{
    PDNS_RECORD pTempRecord = pRpcRecord;
    LPWSTR      lpNameOwner = pRpcRecord->pName;

    DNSDBG( TRACE, ( "FixupNameOwnerPointers()\n" ));

    while ( pTempRecord )
    {
        if ( pTempRecord->pName == NULL )
            pTempRecord->pName = lpNameOwner;
        else
            lpNameOwner = pTempRecord->pName;

        pTempRecord = pTempRecord->pNext;
    }
}


PDNS_RECORD
BuildPTR(
    IN      LPSTR           pName,
    IN      LPSTR           pHostname,
    IN      LPSTR           pDomain,
    IN      LPSTR           pPrimaryDomain
    )
{
    PDNS_RECORD     prr1 = NULL;
    PDNS_RECORD     prr2 = NULL;
    LPSTR           pdata1 = NULL;
    LPSTR           pdata2 = NULL;
    LPSTR           pnameOwner = NULL;
    DWORD           length;

    //
    //  DCR_FIX:  duplicates a lot of Dns_CreatePtrRecord
    //
    //  DCR_FIX:  build generic name-appending counter and
    //              builder
    //
    //  DCR_FIX0:  records are not unicode is this ok?
    //

    prr1 = Dns_AllocateRecord( sizeof( DNS_PTR_DATA ) );
    if ( !prr1 )
    {
        return( NULL );
    }

    //
    //  create owner name
    //  create data name
    //

    pnameOwner = RECORD_HEAP_ALLOC( strlen(pName) + 1 );
    if ( !pnameOwner )
    {
        goto Failed;
    }
    strcpy( pnameOwner, pName );

    //
    //  create PTR data
    //

    length = strlen( pHostname ) + 2;
    if ( pDomain )
    {
        length += strlen( pDomain ) + 2;
    }
    strcpy( pdata1, pHostname );
    strcat( pdata1, "." );
    if ( pDomain )
    {
        strcat( pdata1, pDomain );
    }

    //
    //  create, fill-in record
    //

    pdata1 = RECORD_HEAP_ALLOC( length );
    if ( !pdata1 )
    {
        goto Failed;
    }

    prr1->pNext = NULL;
    prr1->pName = (PDNS_NAME) pnameOwner;
    prr1->wType = DNS_TYPE_PTR;
    prr1->Flags.S.Section = DNSREC_ANSWER;
    SET_FREE_DATA( prr1 );
    SET_FREE_OWNER( prr1 );
    prr1->dwTtl = g_MulticastRecordTTL;
    prr1->Data.Ptr.pNameHost = (PDNS_NAME) pdata1;

    //
    //  build record for primary domain name
    //      - if exists and different from domain name
    //

    if ( pPrimaryDomain &&
         ! Dns_NameCompare_UTF8( pDomain, pPrimaryDomain ) )
    {
        pdata2 = RECORD_HEAP_ALLOC(
                    strlen( pHostname ) + strlen( pPrimaryDomain ) + 2 );
        if ( !pdata2 )
        {
            goto Failed;
        }
        strcpy( pdata2, pHostname );
        strcat( pdata2, "." );
        strcat( pdata2, pPrimaryDomain );

        prr2 = Dns_AllocateRecord( sizeof( DNS_PTR_DATA ) );
        if ( !prr2 )
        {
            goto Failed;
        }
        prr2->pNext = NULL;
        prr2->pName = (PDNS_NAME) pnameOwner;
        prr2->wType = DNS_TYPE_PTR;
        prr2->Flags.S.Section = DNSREC_ANSWER;
        SET_FREE_DATA( prr2 );
        prr2->dwTtl = g_MulticastRecordTTL;
        prr2->Data.Ptr.pNameHost = (PDNS_NAME) pdata2;
    }

    //
    //  set next field
    //      - appends record for primary name (if any)
    //      - or sets pNext=NULL
    //

    prr1->pNext = prr2;

    return prr1;


Failed:

    RECORD_HEAP_FREE( prr1 );
    RECORD_HEAP_FREE( pnameOwner );
    RECORD_HEAP_FREE( pdata1 );
    RECORD_HEAP_FREE( prr2 );
    RECORD_HEAP_FREE( pdata2 );
    return NULL;
}


PDNS_RECORD
BuildARecord(
    IN      LPSTR           pName,
    IN      IP_ADDRESS      IpAddress
    )
{
    PDNS_RECORD prr;
    LPSTR       pnameOwner;

    prr = Dns_AllocateRecord( sizeof(DNS_A_DATA) );
    if ( !prr )
    {
        return  NULL;
    }

    pnameOwner = RECORD_HEAP_ALLOC( strlen(pName) + 1 );
    if ( ! pnameOwner )
    {
        goto Failed;
    }

    strcpy( pnameOwner, pName );

    prr->pNext = NULL;
    prr->pName = (PDNS_NAME) pnameOwner;
    prr->wType = DNS_TYPE_A;
    prr->dwTtl = g_MulticastRecordTTL;
    prr->Flags.S.Section = DNSREC_ANSWER;
    SET_FREE_OWNER( prr );
    SET_FREE_DATA( prr );
    prr->Data.A.IpAddress = IpAddress;

    return prr;


Failed:

    RECORD_HEAP_FREE( prr );
    return NULL;
}


PDNS_RECORD
BuildDNSServerRecord(
    IN      IP_ADDRESS      IpAddress
    )
{
    PDNS_RECORD prr = NULL;
    PDNS_RECORD prrAdditional = NULL;
    LPSTR       pnameOwner = NULL;
    LPSTR       pnameTarget = NULL;


    //
    //  DCR_FIX:  where to start?  geez
    //
    //  DCR_FIX:  character set issue -- what's the paradigm here?
    //

    //
    //  build additional record
    //

    prrAdditional = BuildARecord( MULTICAST_DNS_A_RECORD_NAME, IpAddress );
    if ( ! prrAdditional )
    {
        goto Failed;
    }
    prrAdditional->Flags.S.Section = DNSREC_ADDITIONAL;


    //
    //  build SRV record
    //

    prr = Dns_AllocateRecord( sizeof( DNS_SRV_DATA ) );
    if ( !prr )
    {
        return( NULL );
    }

    pnameOwner = RECORD_HEAP_ALLOC( strlen(MULTICAST_DNS_SRV_RECORD_NAME) + 1 );
    if ( !pnameOwner )
    {
        goto Failed;
    }
    strcpy( pnameOwner, MULTICAST_DNS_SRV_RECORD_NAME );

    prr->pNext = prrAdditional;
    prr->pName = (PDNS_NAME) pnameOwner;
    prr->Flags.S.Section = DNSREC_ANSWER;
    SET_FREE_OWNER( prr );
    prr->wType = DNS_TYPE_SRV;
    prr->dwTtl = g_MulticastRecordTTL;
    prr->Data.SRV.pNameTarget = RECORD_HEAP_ALLOC(
                                    strlen( MULTICAST_DNS_A_RECORD_NAME ) + 1 );
    if ( ! pnameTarget )
    {
        goto Failed;
    }
    strcpy(
        pnameTarget,
        MULTICAST_DNS_A_RECORD_NAME );

    prr->Data.SRV.wPriority = 0;
    prr->Data.SRV.wWeight = 0;
    prr->Data.SRV.wPort = DNS_PORT_HOST_ORDER;
    prr->Data.SRV.pNameTarget = (PDNS_NAME) pnameTarget;
    SET_FREE_DATA( prr );

    return prr;
    

Failed:

    //  cleanup
    //      - additional rr done wholesale
    //      - SRV record done in pieces

    Dns_RecordFree( prrAdditional );
    RECORD_HEAP_FREE( pnameOwner );
    RECORD_HEAP_FREE( pnameTarget );
    RECORD_HEAP_FREE( prr );
    return NULL;
}



PDNS_RECORD
BuildLocalAddressRecords(
    IN  LPSTR Name )
{
    return  NULL;

#if 0
    PDNS_RECORD pList = NULL;
    PDNS_RECORD pPrev = NULL;
    DWORD       iter;

    EnterCriticalSection( &NetworkListCritSec );

    if ( g_IpAddressList &&
         g_IpAddressListCount )
    {
        for ( iter = 0; iter < g_IpAddressListCount; iter++ )
        {
            PDNS_RECORD pNew = BuildARecord( Name,
                                             g_IpAddressList[iter].ipAddress );

            if ( pNew )
            {
                if ( pPrev )
                    pPrev->pNext = pNew;
                else
                    pList = pNew;

                pPrev = pNew;
            }
        }
    }

    LeaveCriticalSection( &NetworkListCritSec );

    return pList;
#endif
}


BOOL
IsLocalAddress(
    IN      IP_ADDRESS      IpAddress
    )
{
    return( FALSE );

#if 0
    DWORD iter;
    BOOL  bisLocal = FALSE;

    EnterCriticalSection( &NetworkListCritSec );

    if ( g_IpAddressList )
    {
        for ( iter = 0; iter < g_IpAddressListCount; iter++ )
        {
            if ( IpAddress == g_IpAddressList[iter].ipAddress )
            {
                bisLocal = TRUE;
                break;
            }
        }
    }

    LeaveCriticalSection( &NetworkListCritSec );

    return bisLocal;
#endif
}


PSOCKET_CONTEXT
AllocateIoContext(
    IN      IP_ADDRESS      IpAddr
    )
{
    PSOCKET_CONTEXT     pcontext;
    SOCKET              socket = 0;


    //  allocate and clear context

    pcontext = MCAST_HEAP_ALLOC_ZERO( sizeof(SOCKET_CONTEXT) );
    if ( !pcontext )
    {
        DNSLOG_F1( "Error: Failed to allocate multicast socket context." );
        return NULL;
    }

    //  create multicast socket
    //      - bound to this address and DNS port

    socket = Dns_CreateMulticastSocket(
                    SOCK_DGRAM,
                    IpAddr,
                    DNS_PORT_NET_ORDER,
                    FALSE,
                    TRUE );

    if ( socket == 0 || socket == INVALID_SOCKET )
    {
        DNSLOG_F1( "Error: Failed to create multicast socket." );
        goto Failed;
    }

    //  create message buffer for socket

    pcontext->pMsg = Dns_AllocateMsgBuf( 0 );
    if ( !pcontext->pMsg )
    {
        DNSLOG_F1( "Error: Failed to allocate message buffer." );
        goto Failed;
    }

    pcontext->Socket = socket;
    pcontext->IpAddress = IpAddr;
    pcontext->pMsg->fTcp = FALSE;

    return pcontext;

Failed:

    if ( socket )
    {
        Dns_CloseSocket( socket );
    }
    MCAST_HEAP_FREE( pcontext );
    return  NULL;
}


VOID
FreeIoContextList(
    IN OUT  PSOCKET_CONTEXT pContext,
    IN      BOOL            fIssueSocketShutdown
    )
{
    PSOCKET_CONTEXT     ptempContext;

    //
    //  cleanup context list
    //      - shutdown socket
    //      - close socket
    //      - free message buffer
    //      - free context
    //

    while ( pContext )
    {
        ptempContext = pContext;
        pContext = pContext->pNext;

        if ( fIssueSocketShutdown )
        {
            shutdown( ptempContext->Socket, SD_BOTH );
        }

        Dns_CloseSocket( ptempContext->Socket );

        if ( ptempContext->pMsg )
        {
            Dns_Free( ptempContext->pMsg );
        }

        //  QUESTION:  should we tag memory free?

        MCAST_HEAP_FREE( ptempContext );
    }
}


VOID
DropReceive(
    IN OUT  PSOCKET_CONTEXT pContext
    )
/*++

Routine Description:

    Drop down UDP receive request.

Arguments:

    pContext -- context for socket being recieved

Return Value:

    None

--*/
{
    DNS_STATUS      status;
    WSABUF          WsaBuf;
    DWORD           bytesRecvd;
    DWORD           dwFlags = 0;

    if ( !pContext->pMsg )
    {
        return;
    }

    WsaBuf.len = DNS_MAX_UDP_PACKET_BUFFER_LENGTH;
    WsaBuf.buf = (PCHAR) (&pContext->pMsg->MessageHead);

    pContext->pMsg->Socket = pContext->Socket;

    //
    //  loop until successful WSARecvFrom() is down
    //
    //  this loop is only active while we continue to recv
    //  WSAECONNRESET or WSAEMSGSIZE errors, both of which
    //  cause us to dump data and retry;
    //
    //  note loop rather than recursion (to this function) is
    //  required to aVOID possible stack overflow from malicious
    //  send
    //
    //  normal returns from WSARecvFrom() are
    //      SUCCESS -- packet was waiting, GQCS will fire immediately
    //      WSA_IO_PENDING -- no data yet, GQCS will fire when ready
    //

    while ( 1 )
    {
        status = WSARecvFrom(
                    pContext->Socket,
                    & WsaBuf,
                    1,
                    & bytesRecvd,
                    & dwFlags,
                    (PSOCKADDR) & pContext->pMsg->RemoteAddress,
                    & pContext->pMsg->RemoteAddressLength,
                    & pContext->Overlapped,
                    NULL );

        if ( status == ERROR_SUCCESS )
        {
            return;
        }

        status = GetLastError();
        if ( status == WSA_IO_PENDING )
        {
            return;
        }

        //
        //  when last send ICMP'd
        //      - set flag to indicate retry and repost send
        //      - if over some reasonable number of retries, assume error
        //          and fall through recv failure code
        //

        if ( status == WSAECONNRESET )
        {
            continue;
        }

        if ( status == WSAEMSGSIZE )
        {
            continue;
        }

        return;
    }
}

//
//  End mcast.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\resolver\server\notify.c ===
/*++

Copyright (c) 2000-2000  Microsoft Corporation

Module Name:

    notify.c

Abstract:

    DNS Resolver Service.

    Notification thread
        - host file changes
        - registry config changes

Author:

    Jim Gilroy  (jamesg)    November 2000

Revision History:

--*/


#include "local.h"

//
//  Host file directory
//

#define HOSTS_FILE_DIRECTORY            L"\\drivers\\etc"

//
//  Notify globals
//

DWORD   g_NotifyThreadId = 0;
HANDLE  g_hNotifyThread = NULL;

HANDLE  g_hHostFileChange = NULL;
HANDLE  g_hRegistryChange = NULL;




HANDLE
CreateHostsFileChangeHandle(
    VOID
    )
/*++

Routine Description:

    Create hosts file change handle.

Arguments:

    None.

Return Value:

    None.

--*/
{
    HANDLE      changeHandle;
    PWSTR       psystemDirectory = NULL;
    UINT        len;
    WCHAR       hostDirectory[ MAX_PATH*2 ];

    DNSDBG( INIT, ( "CreateHostsFileChangeHandle\n" ));

    //
    //  build host file name
    //

    len = GetSystemDirectory( hostDirectory, MAX_PATH );
    if ( !len || len>MAX_PATH )
    {
        DNSLOG_F1( "Error:  Failed to get system directory" );
        DNSLOG_F1( "NotifyThread exiting." );
        return( NULL );
    }

    wcscat( hostDirectory, HOSTS_FILE_DIRECTORY );

    //
    //  drop change notify on host file directory
    //

    changeHandle = FindFirstChangeNotification(
                        hostDirectory,
                        FALSE,
                        FILE_NOTIFY_CHANGE_FILE_NAME |
                            FILE_NOTIFY_CHANGE_LAST_WRITE );

    if ( changeHandle == INVALID_HANDLE_VALUE )
    {
        DNSLOG_F1( "NotifyThread failed to get handle from" );
        DNSLOG_F2(
            "Failed to get hosts file change handle.\n"
            "Error code: <0x%.8X>",
            GetLastError() );
        return( NULL );
    }

    return( changeHandle );
}




VOID
ThreadShutdownWait(
    IN      HANDLE          hThread
    )
/*++

Routine Description:

    Wait on thread shutdown.

Arguments:

    hThread -- thread handle that is shutting down

Return Value:

    None.

--*/
{
    DWORD   waitResult;

    if ( !hThread )
    {
        return;
    }

    DNSDBG( ANY, (
        "Waiting on shutdown of thread %d (%p)\n",
        hThread, hThread ));

    waitResult = WaitForSingleObject(
                    hThread,
                    10000 );

    switch( waitResult )
    {
    case WAIT_OBJECT_0:

        break;

    default:

        //  thread didn't stop -- need to kill it

        ASSERT( waitResult == WAIT_TIMEOUT );

        DNSLOG_F2( "Shutdown:  thread %d not stopped, terminating", hThread );
        TerminateThread( hThread, 1 );
        break;
    }

    //  close thread handle

    CloseHandle( hThread );
}



VOID
NotifyThread(
    VOID
    )
/*++

Routine Description:

    Main notify thread.

Arguments:

    None.

Globals:

    g_hStopEvent -- waits on shutdown even

Return Value:

    None.

--*/
{
    DWORD       handleCount;
    DWORD       waitResult;
    HANDLE      handleArray[3];

    DNSDBG( INIT, (
        "\nStart NotifyThread\n" ));

    //
    //  get file change handle
    //

    g_hHostFileChange = CreateHostsFileChangeHandle();

    //
    //  wait on
    //      - host file change => flush+rebuild cache
    //      - registry change => reread config info
    //      - shutdown => exit
    //

    handleArray[0] = g_hStopEvent;
    handleCount = 1;

    if ( g_hHostFileChange )
    {
        handleArray[handleCount++] = g_hHostFileChange;
    }
    if ( g_hRegistryChange )
    {
        handleArray[handleCount++] = g_hRegistryChange;
    }

    if ( handleCount == 1 )
    {
        DNSDBG( ANY, (
            "No change handles -- exit notify thread.\n" ));
        goto ThreadExit;
    }


    while( 1 )
    {
        waitResult = WaitForMultipleObjects(
                            handleCount,
                            handleArray,
                            FALSE,
                            INFINITE );

        switch( waitResult )
        {
        case WAIT_OBJECT_0:

            //  shutdown event
            //      - if stopping exit
            //      - do garbage collection if required
            //      - otherwise short wait to avoid spin if screwup
            //      and not get thrashed by failed garbage collection

            DNSLOG_F1( "NotifyThread:  Shutdown Event" );
            if ( g_StopFlag )
            {
                goto ThreadExit;
            }
            else if ( g_GarbageCollectFlag )
            {
                Cache_GarbageCollect( 0 );
            }
            ELSE_ASSERT_FALSE;

            Sleep( 1000 );
            if ( g_StopFlag )
            {
                goto ThreadExit;
            }
            continue;

        case WAIT_OBJECT_0 + 1:

            //  host file change -- flush cache

            DNSLOG_F1( "NotifyThread:  Host file change event" );

            //  reset notification -- BEFORE reload

            if ( !FindNextChangeNotification( g_hHostFileChange ) )
            {
                DNSLOG_F1( "NotifyThread failed to get handle" );
                DNSLOG_F1( "from FindNextChangeNotification." );
                DNSLOG_F2( "Error code: <0x%.8X>", GetLastError() );
                goto ThreadExit;
            }

            Cache_Flush();
            break;

        case WAIT_OBJECT_0 + 2:

            //  registry change notification -- flush cache and reload

            DNSLOG_F1( "NotifyThread:  Registry change event" );
            break;


        default:

            ASSERT( g_StopFlag );
            if ( g_StopFlag )
            {
                goto ThreadExit;
            }
            Sleep( 5000 );
            continue;
        }
    }

ThreadExit:

    DNSDBG( INIT, (
        "NotifyThread exit\n" ));
    DNSLOG_F1( "NotifyThread exiting." );
}



VOID
StartNotify(
    VOID
    )
/*++

Routine Description:

    Start notify thread.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    //
    //  clear
    //

    g_NotifyThreadId = 0;
    g_hNotifyThread = NULL;
    
    g_hHostFileChange = NULL;
    g_hRegistryChange = NULL;


    //
    //  host file write monitor thread
    //  keeps cache in sync when write made to host file
    //

    g_hNotifyThread = CreateThread(
                            NULL,
                            0,
                            (LPTHREAD_START_ROUTINE) NotifyThread,
                            NULL,
                            0,
                            &g_NotifyThreadId );
    if ( !g_hNotifyThread )
    {
        DNS_STATUS  status = GetLastError();

        DNSLOG_F1( "ERROR: InitializeCache function failed to create" );
        DNSLOG_F1( "       HOSTS file monitor thread." );
        DNSLOG_F2( "       Error code: <0x%.8X>", status );
        DNSLOG_F1( "       NOTE: Resolver service will continue to run." );

        DNSDBG( ANY, (
            "FAILED Notify thread start!\n"
            "\tstatus = %d\n",
            status ));
    }
}



VOID
ShutdownNotify(
    VOID
    )
/*++

Routine Description:

    Shutdown notify thread.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DWORD waitResult;

    DNSDBG( INIT, ( "NotifyShutdown()\n" ));

    //
    //  wait for notify thread to stop
    //
    
    ThreadShutdownWait( g_hNotifyThread );
    g_hNotifyThread = NULL;

    //
    //  close notification handles
    //

    if ( g_hRegistryChange )
    {
        CloseHandle( g_hRegistryChange );
    }
    if ( g_hHostFileChange )
    {
        CloseHandle( g_hHostFileChange );
    }

    //  clear globals

    g_NotifyThreadId = 0;
    g_hNotifyThread = NULL;
    
    g_hHostFileChange = NULL;
    g_hRegistryChange = NULL;
}

//
//  End notify.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\resolver\server\notesrv.c ===
/*++

Copyright (c) 2000-2000  Microsoft Corporation

Module Name:

    notesrv.c

Abstract:

    DNS Resolver Service

    Notifications to other services.

Author:

    Glenn Curtis    (glennc)    Feb 1998

Revision History:

    Jim Gilroy  (jamesg)        March 2000      cleanup
    Jim Gilroy  (jamesg)        Nov 2000        created this module

--*/


#include "local.h"
#include <svcs.h>


//
//  DCR:  eliminate this module
//      entirely unclear why we should be notifying remote
//      services of PnP -- weird idea
//      only actual DNS events should be in our charter
//

//
//  Notification list entry
//

typedef struct _SERVICE_NOTIFICATION_
{
    struct _SERVICE_NOTIFICATION_ * pNext;
    PWSTR                           pszServiceName;
    DWORD                           dwControl;
}
SERVICE_NOTIFICATION, * PSERVICE_NOTIFICATION;


//
//  Service notification list
//  Services we should notify if DNS config changes.
//

PSERVICE_NOTIFICATION   g_ServiceNotificationList = NULL;

//
//  Locking on service control list
//      - overload net failure
//

#define LOCK_SERVICE_LIST()     LOCK_NET_FAILURE()
#define UNLOCK_SERVICE_LIST()   UNLOCK_NET_FAILURE()




//
//  Routines
//

DWORD
SendServiceControlCode(
    IN      LPWSTR          pszServiceName,
    IN      DWORD           dwControl
    )
{
    DWORD          status = NO_ERROR;
    SC_HANDLE      scManagerHandle = NULL;
    SC_HANDLE      scServiceHandle = NULL;
    SERVICE_STATUS serviceStatus;


    DNSDBG( TRACE, (
        "SendServiceControlCode( %S, %d )\n",
        pszServiceName,
        dwControl ));

    //
    //  DCR_FIX:  identical to routine in dnsapi.dll
    //      so either expose OR dnslib it
    //
    //
    //  DCR_FIX0:  service notification probably not working
    //      i don't believe this is working because no longer
    //      local system, probably can't open with this access
    //

    scManagerHandle = OpenSCManagerW( NULL,
                                      NULL,
                                      SC_MANAGER_ALL_ACCESS );

    if ( !scManagerHandle )
    {
        DNSDBG( ANY, (
            "OpenSCManagerW( %S ) -- FAILED! %d\n",
            pszServiceName,
            GetLastError() ));
        return GetLastError();
    }

    scServiceHandle = OpenServiceW( scManagerHandle,
                                    pszServiceName,
                                    SERVICE_ALL_ACCESS );
    if ( !scServiceHandle )
    {
        CloseServiceHandle( scManagerHandle );
        return GetLastError();
    }

    if ( !ControlService( scServiceHandle,
                          dwControl,
                          &serviceStatus ) )
    {
        status = GetLastError();
    }

    CloseServiceHandle( scServiceHandle );
    CloseServiceHandle( scManagerHandle );

    return status;
}



VOID
ServiceNotificationCallback(
    IN      PVOID           pContext
    )
{
    PSERVICE_NOTIFICATION pserviceNot;

    UNREFERENCED_PARAMETER( pContext );

    DNSLOG_F1( "   Inside callback function ServiceNotificationCallback" );

    //
    //  Send PnP to any registered services
    //

    LOCK_SERVICE_LIST();

    for ( pserviceNot = g_ServiceNotificationList;
          pserviceNot != NULL;
          pserviceNot = pserviceNot->pNext
        )
    {
        DNSLOG_F3( "   Sending PnP notification to %S with control %d",
                   pserviceNot->pszServiceName,
                   pserviceNot->dwControl );

        SendServiceControlCode(
            pserviceNot->pszServiceName,
            pserviceNot->dwControl );
    }
    UNLOCK_SERVICE_LIST();

    //
    //  always indicate PnP to DNS server
    //

    DNSLOG_F2(
        "   Sending PnP notification to DNS server with control %d",
        SERVICE_CONTROL_PARAMCHANGE );

    SendServiceControlCode(
        L"dns",
        SERVICE_CONTROL_PARAMCHANGE );

    DNSLOG_F1( "   Leaving callback function ServiceNotificationCallback" );
    DNSLOG_F1( "" );
}



VOID
SendServiceNotifications(
    VOID
    )
/*++

Routine Description:

    Send service notifications.

Arguments:

    None

Return Value:

    None

--*/
{
    DNSDBG( ANY, ( "SendServiceNotifications()\n" ));

    DNSLOG_F1( "Notify any other services of the PnP event" );

    //
    //  DCR:  cheesy hack to notify DNS server of paramchange
    //

    if ( g_IsDnsServer )
    {
        SendServiceControlCode(
            L"Dns",
            SERVICE_CONTROL_PARAMCHANGE );
    }

    //
    //  notify other services by queuing callback
    //      - callback function then notifies services
    //

    RtlQueueWorkItem(
        ServiceNotificationCallback,    // callback
        NULL,                           // context data
        WT_EXECUTEONLYONCE );           // flags
}



VOID
CleanupServiceNotification(
    VOID
    )
/*++

Routine Description:

    Cleanup service notification list.

Arguments:

    None

Return Value:

    None

--*/
{
    PSERVICE_NOTIFICATION pnext;
    PSERVICE_NOTIFICATION pfree;

    LOCK_SERVICE_LIST();

    pnext = g_ServiceNotificationList;
    while ( pnext )
    {
        PSERVICE_NOTIFICATION pfree = pnext;

        pnext = pnext->pNext;
        GENERAL_HEAP_FREE( pfree );
    }
    g_ServiceNotificationList = NULL;

    UNLOCK_SERVICE_LIST();
}



//
//  Remote API for registration\deregistraion
//

BOOL
CRrRegisterParamChange(
    IN      DNS_RPC_HANDLE  Reserved,
    IN      LPWSTR          pszServiceName,
    IN      DWORD           dwControl
    )
/*++

Routine Description:


Arguments:

    pszServiceName -- name of service to register

    dwControl -- control to send

Return Value:

    TRUE if success
    FALSE on error

--*/
{
    PSERVICE_NOTIFICATION   pprevService = NULL;
    PSERVICE_NOTIFICATION   pservice;
    DWORD                   countService = 0;

    UNREFERENCED_PARAMETER(Reserved);

    DNSLOG_F1( "DNS Caching Resolver Service - CRrRegisterParamChange" );
    DNSLOG_F2( "Going to try register service notification entry for %S",
               pszServiceName );
    DNSLOG_F2( "Control: %d", dwControl );

    DNSDBG( RPC, (
        "CRrRegisterParamChange( %S, control=%d )\n",
        pszServiceName,
        dwControl ));

    //
    //  access check
    //  refuse setting check on resolver service itself
    //

    if ( ClientThreadNotAllowedAccess() )
    {
        DNSLOG_F1( "CRrRegisterParamChange - ERROR_ACCESS_DENIED" );
        return FALSE;
    }

    if ( !pszServiceName ||
         ! wcsicmp_ThatWorks( DNS_RESOLVER_SERVICE, pszServiceName ) )
    {
        DNSLOG_F1( "CRrRegisterParamChange - ERROR_INVALID_PARAMETER" );
        return FALSE;
    }

    //
    //  search service list for service
    //      - if service exists, bail
    //      - if too many services, bail
    //

    LOCK_SERVICE_LIST();

    pservice = g_ServiceNotificationList;

    while ( pservice )
    {
        if ( ! wcsicmp_ThatWorks(
                    pservice->pszServiceName,
                    pszServiceName ) )
        {
            pservice->dwControl = dwControl;
            UNLOCK_SERVICE_LIST();

            DNSLOG_F2(
                "Service already registered, resetting control %d\n"
                "Returning SUCCESS",
                dwControl );
            return TRUE;
        }

        pprevService = pservice;
        pservice = pservice->pNext;
        countService++;
    }

    if ( countService > MAX_DNS_NOTIFICATION_LIST_SIZE )
    {
        UNLOCK_SERVICE_LIST();

        DNSLOG_F2(
            "Registered service %S, returning error.\n"
            "\tThere are too many services alreadyin the notification list!",
            pszServiceName );
        return FALSE;
    }

    //
    //  service not found -- add it
    //      - alloc single blob
    //      - name of service will follow structure
    //
    //  DCR:  if always doing single blob, why have pointer?  duh
    //

    pservice = GENERAL_HEAP_ALLOC(
                    sizeof(SERVICE_NOTIFICATION)
                    + ((wcslen(pszServiceName) + 1) * sizeof(WCHAR)) );
    if ( !pservice )
    {
        UNLOCK_SERVICE_LIST();
        DNSLOG_F1( "Could not allocate memory to register service," );
        DNSLOG_F1( "returning FAILURE" );
        return FALSE;
    }

    pservice->pNext     = NULL;
    pservice->dwControl = dwControl;
    pservice->pszServiceName = (LPWSTR) ( (LPBYTE) pservice +
                                            sizeof(SERVICE_NOTIFICATION) );
    wcscpy(
        pservice->pszServiceName,
        pszServiceName );


    if ( pprevService )
    {
        pprevService->pNext = pservice;
    }
    else
    {
        g_ServiceNotificationList = pservice;
    }

    UNLOCK_SERVICE_LIST();
    DNSLOG_F2(
        "Registered service %S, returning SUCCESS",
        pszServiceName );
    return TRUE;
}



BOOL
CRrDeregisterParamChange(
    IN      DNS_RPC_HANDLE  Reserved,
    IN      LPWSTR          pszServiceName
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    PSERVICE_NOTIFICATION   pprevService = NULL;
    PSERVICE_NOTIFICATION   pservice;

    UNREFERENCED_PARAMETER(Reserved);


    DNSLOG_F1( "DNS Caching Resolver Service - CRrDeregisterParamChange" );
    DNSLOG_F2( "Going to try remove service notification entry for %S",
               pszServiceName );

    DNSDBG( RPC, (
        "CRrDeregisterParamChange( %S )\n",
        pszServiceName ));

    if ( ClientThreadNotAllowedAccess() )
    {
        DNSLOG_F1( "CRrDeregisterParamChange - ERROR_ACCESS_DENIED" );
        return FALSE;
    }

    //
    //  search service list for desired service
    //      - delete entry if found
    //

    LOCK_SERVICE_LIST();

    pservice = g_ServiceNotificationList;

    while ( pservice )
    {
        if ( ! wcsicmp_ThatWorks(
                    pservice->pszServiceName,
                    pszServiceName ) )
        {
            //  service found, cut from list

            if ( pprevService )
            {
                pprevService->pNext = pservice->pNext;
            }
            else
            {
                g_ServiceNotificationList = pservice->pNext;
            }
            UNLOCK_SERVICE_LIST();

            GENERAL_HEAP_FREE( pservice );
            DNSLOG_F1( "Found entry, returning SUCCESS" );
            return TRUE;
        }

        pprevService = pservice;
        pservice = pservice->pNext;
    }

    UNLOCK_SERVICE_LIST();
    DNSLOG_F1( "Did not find entry, returning FAILURE" );
    return FALSE;
}

//
//  End notesrv.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\resolver\server\ops.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    ops.c

Abstract:

    DNS Resolver Service.

    Remote APIs to resolver service.

Author:

    Jim Gilroy (jamesg)     November 2000

Revision History:

--*/


#include "local.h"


//
//  Max number to enum at a time
//

#define MAX_CACHE_ENUM_COUNT    (500)




//
//  Enum operations
//
//  Tag is DWORD with
//      - high word the hash bucket index
//      - low word the entry count
//

#define MakeEnumTag(h,e)            MAKEDWORD( (WORD)e, (WORD)h )

#define HashBucketFromEnumTag(t)    HIWORD(t)
#define EntryIndexFromEnumTag(t)    LOWORD(t)

#define GetRpcRecords(p,t,pi)       (NULL)
#define AllocRpcName( s )           Dns_StringCopyAllocate_W( (s), 0 )




DNS_STATUS
R_ResolverEnumCache(
    IN      DNS_RPC_HANDLE          Handle,
    IN      PDNS_CACHE_ENUM_REQUEST pRequest,
    OUT     PDNS_CACHE_ENUM *       ppEnum
    )
/*++

Routine Description:

    Enumerate entries in cache.

Arguments:

    RpcHandle -- RPC handle

    pRequest -- ptr to Enum request

    ppEnum -- addr to recv pointer to enumeration

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure to enum.

--*/
{
    DNS_STATUS          status      = ERROR_SUCCESS;
    PDNS_CACHE_ENUM     penum       = NULL;
    BOOL                flocked     = FALSE;
    DWORD               count       = 0;
    DWORD               maxCount    = 0;
    DWORD               entryCount  = 0;
    DWORD               entryStart;
    WORD                typeRequest = 0;
    DWORD               hashStart;
    DWORD               ihash;
    PDNS_RECORD         prr;
    PDNS_CACHE_ENTRY    prpcEntry;


    DNSDBG( RPC, ( "\nR_ResolverEnumCache\n" ));
    DNSLOG_F1( "Resolver - R_ResolverEnumCache" );

    if ( !ppEnum || !pRequest )
    {
        return ERROR_INVALID_PARAMETER;
    }
    *ppEnum = NULL;

    if ( ClientThreadNotAllowedAccess() )
    {
        status = ERROR_ACCESS_DENIED;
        goto Done;
    }

    //
    //  allocate desired space
    //

    maxCount = pRequest->MaxCount;
    if ( maxCount > MAX_CACHE_ENUM_COUNT )
    {
        maxCount = MAX_CACHE_ENUM_COUNT;
    }

    penum = (PDNS_CACHE_ENUM)
                RPC_HEAP_ALLOC_ZERO(
                    sizeof(DNS_CACHE_ENUM) +
                    (maxCount * sizeof(DNS_CACHE_ENTRY)) );
    if ( !penum )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    //
    //  read entries starting from EnumTag
    //

    LOCK_CACHE();
    flocked = TRUE;
    count = 0;
    typeRequest = pRequest->Type;

    hashStart = HashBucketFromEnumTag( pRequest->EnumTag );
    entryStart = EntryIndexFromEnumTag( pRequest->EnumTag );

    //
    //  enum next DCR:  issue of CNAME here?
    //

    for ( ihash = hashStart; ihash < g_HashTableSize; ihash++ )
    {
        PCACHE_ENTRY    pentry = g_HashTable[ihash];
        entryCount = 0;

        while ( pentry )
        {
            DWORD   index = 0;

            //  skip any entries in previous enum

            if ( ihash == hashStart &&
                 entryCount < entryStart )
            {
                pentry = pentry->pNext;
                entryCount++;
                continue;
            }

            //  write enum entries matching criteria

            while( count < maxCount )
            {
                prr = GetRpcRecords(
                            pentry,
                            typeRequest,
                            & index );
                if ( !prr )
                {
                    break;
                }

                prpcEntry = &penum->EntryArray[count];

                prpcEntry->pName = AllocRpcName( pentry->pName );
                prpcEntry->wType = typeRequest;
                count++;
            }

            pentry = pentry->pNext;
            entryCount++;
        }
    }

    //
    //  set return params
    //      if exhaust cache -- success
    //      if more data, set termination tag to restart
    //

    penum->TotalCount = g_EntryCount;
    penum->EnumCount = count;
    penum->EnumTagStart = pRequest->EnumTag;

    if ( ihash == g_HashTableSize )
    {
        status = ERROR_SUCCESS;
    }
    else
    {
        status = ERROR_MORE_DATA;
        penum->EnumTagStop = (DWORD) MAKELONG( entryCount, ihash );
    }

    *ppEnum = penum;

Done:

    UNLOCK_CACHE();

    DNSDBG( RPC, (
        "Leave R_ResolverEnumCache()\n"
        "\tstatus       = %d\n"
        "\ttotal count  = %d\n"
        "\ttag start    = %p\n"
        "\ttag end      = %p\n"
        "\tcount        = %d\n\n",
        status,
        penum->TotalCount,
        penum->EnumTagStart,
        penum->EnumTagStop,
        penum->EnumCount ));

    return( status );
}



//
//  Cache operations
//

DNS_STATUS
R_ResolverFlushCache(
    IN      DNS_RPC_HANDLE  Handle
    )
/*++

Routine Description:

    Flush resolver cache.

Arguments:

    Handle -- RPC handle

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_ACCESS_DENIED if unable to flush.

--*/
{
    DNSDBG( RPC, ( "\nR_ResolverFlushCache\n" ));

    //
    //  DCR:  flush should have security
    //

    if ( ClientThreadNotAllowedAccess() )
    {
        DNSLOG_F1( "R_ResolverFlushCache - ERROR_ACCESS_DENIED" );
        return  ERROR_ACCESS_DENIED;
    }

    //
    //  flush cache
    //
    
    Cache_Flush();

    DNSDBG( RPC, ( "Leave R_ResolverFlushCache\n\n" ));
    return  ERROR_SUCCESS;
}



DNS_STATUS
R_ResolverFlushCacheEntry(
    IN      DNS_RPC_HANDLE  Handle,
    IN      PWSTR           pwsName,
    IN      WORD            wType
    )
/*++

Routine Description:

    Flush data from resolver cache.

Arguments:

    Handle -- RPC handle

    pwsName -- name to flush (if NULL flush entire cache)

    wType -- type to flush; if zero, flush entire entry for name

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_ACCESS_DENIED if unable to flush.

--*/
{
    DNSLOG_F1( "R_ResolverFlushCacheEntry" );
    DNSLOG_F2( "    Name  : %S", pwsName );
    DNSLOG_F2( "    Type  : %d", wType );

    DNSDBG( RPC, (
        "R_ResolverFlushCacheEntry\n"
        "\tName = %p %S\n"
        "\tType = %d\n",
        pwsName, pwsName,
        wType ));

    if ( !pwsName )
    {
        return  ERROR_INVALID_PARAMETER;
    }

    //
    //  two levels
    //      1) - no type => flush the whole name entry
    //      2) - name and type => flush on particular RR set
    //

    Cache_FlushRecords(
        pwsName,
        wType
            ? FLUSH_LEVEL_NORMAL
            : FLUSH_LEVEL_WIRE,
        wType
        );

    DNSDBG( RPC, ( "Leave R_ResolverFlushCacheEntry\n\n" ));

    return  ERROR_SUCCESS;
}



//
//  Query API utilities
//

DNS_STATUS
ResolverQuery(
    IN OUT  PQUERY_BLOB     pBlob
    )
/*++

Routine Description:

    Make the query to DNS server.

Arguments:

    pBlob -- query blob

Return Value:

    ERROR_SUCCESS if successful response.
    DNS_INFO_NO_RECORDS on no records for type response.
    DNS_ERROR_RCODE_NAME_ERROR on name error.
    DNS_ERROR_INVALID_NAME on bad name.
    None

--*/
{
    DNS_STATUS          status = ERROR_SUCCESS;
    PDNS_NETINFO        pnetInfo = NULL;
    BOOL                fadapterTimedOut = FALSE;
    DNS_STATUS          statusNetFailure = ERROR_SUCCESS;


    DNSDBG( TRACE, (
        "ResolverQuery( %S, type=%d, f=%08x )\n",
        pBlob->pNameOrig,
        pBlob->wType,
        pBlob->Flags ));

    //
    //  skip query -- timeouts -- entirely if net down
    //

    if ( IsKnownNetFailure() )
    {
        status = GetLastError();
        DNSLOG_F2(
            "Not going query since there is a known net failure: 0x%.8X",
            status );
        DNSDBG( ANY, (
            "WARNING:  known net failure %d, suppressing queries!\n",
            status ));
        return status;
    }

    //
    //  get valid network info
    //

    pnetInfo = GrabNetworkInfo();
    if ( ! pnetInfo )
    {
        DNSDBG( ANY, ( "ERROR:  GrabNetworkInfo() failed!\n" ));
        return DNS_ERROR_NO_DNS_SERVERS;
    }
    pBlob->pNetworkInfo = pnetInfo;

    //
    //  cluster filtering setup
    //

    if ( g_IsServer )
    {
        pBlob->pfnIsClusterIp = IsClusterAddress;
    }

    //
    //  query
    //  includes
    //      - local name check
    //      - wire query
    //

    status = Query_Main( pBlob );

    statusNetFailure = pBlob->NetFailureStatus;

#if 0
    //
    //  DCR:  missing catching intermediate failures
    //

        //
        //  reset server priorities on failures
        //  do here to avoid washing out info in retry with new name
        //

        if ( status != ERROR_SUCCESS &&
             pnetInfo->ReturnFlags & DNS_FLAG_RESET_SERVER_PRIORITY )
        {
            if ( g_AdapterTimeoutCacheTime &&
                 Dns_DisableTimedOutAdapters( pnetInfo ) )
            {
                fadapterTimedOut = TRUE;
                SetKnownTimedOutAdapter();
            }
        }
#endif


    //
    //  success
    //      - drop message popup count
    //

    if ( status == ERROR_SUCCESS )
    {
#if 0
        //  don't see any point in locking for this crap
        //  as long as don't decrement anywhere, and even
        //  then success reset should make it ok
        LOCK_NET_FAILURE();
        if ( g_MessagePopupStrikes > 0 )
            g_MessagePopupStrikes--;
        UNLOCK_NET_FAILURE();
#endif
        g_MessagePopupStrikes = 0;
    }

    //
    //  network failure condition
    //      - anything but ERROR_TIMEOUT is net failure
    //
    //  timeout error indicates possible net down condition
    //      - ping DNS servers
    //      if down shutdown queries for short interval; this
    //      eliminates long timeouts in boot up during netdown
    //      condition
    //
    //  DCR:  this is stupid -- ping especially
    //
    //      should just keep a count, if count rises back off;
    //      why we should do useless query (ping) is beyond me
    //      rather than just doing another query;  only advantage
    //      of ping is that it should succeed immediately
    //
    //      furthermore any tracking for this that we do do should
    //      be in single routine saving the network info
    //

    else if ( statusNetFailure )
    {
        if ( statusNetFailure == ERROR_TIMEOUT )
        {
#if 0
            DWORD           iter;
            BOOL            fping = FALSE;
            PDNS_ADAPTER    padapter;
        
            for ( iter = 0; iter < pnetInfo->cAdapterCount; iter++ )
            {
                padapter = pnetInfo->AdapterArray[iter];
        
                if ( padapter &&
                     g_NetFailureCacheTime &&
                     Dns_PingAdapterServers( padapter ) )
                {
                    fping = TRUE;
                    break;
                }
            }
            if ( !fping )
            {
                SetKnownNetFailure( status );
            }
#endif
        }
        else
        {
            SetKnownNetFailure( status );
        }
    }

    //
    //  save change in adapter priority
    //

    if ( pnetInfo->ReturnFlags & RUN_FLAG_RESET_SERVER_PRIORITY )
    {
        UpdateNetworkInfo( pnetInfo );
    }
    else
    {
        NetInfo_Free( pnetInfo );
    }
    pBlob->pNetworkInfo = NULL;

    DNSDBG( QUERY, (
        "Leave ResolverQuery() => %d\n",
        status ));

    IF_DNSDBG( QUERY )
    {
        DnsDbg_QueryBlob(
            "Blob leaving ResolverQuery()",
            pBlob );
    }
    return status;
}



//
//  Query API
//  

#ifdef DNS_TRY_ASYNC
VOID
R_ResolverQueryAsync(
    IN      PRPC_ASYNC_STATE    AsyncHandle,
    IN      DNS_RPC_HANDLE      Handle,
    IN OUT  PRPC_QUERY_BLOB     pBlob
    )
/*++

Routine Description:

    Query the resolver.

Arguments:

    pBlob -- ptr to query info and results buffer

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode (including DNS RCODE) on failure.

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;
    PDNS_RECORD     prr = NULL;
    PDNS_RECORD     prrQuery = NULL;
    PDNS_RECORD     presultRR = NULL;
    PCACHE_ENTRY    pentry = NULL;
    BOOL            locked = FALSE;
    BOOL            fcacheNegativeResponse = FALSE;
    CHAR            nameUtf8[ DNS_MAX_NAME_BUFFER_LENGTH+1 ];
    DWORD           nameBufLength = DNS_MAX_NAME_BUFFER_LENGTH;

    //  DCR_CLEANUP:  make local
    //  quickie define to old args
    PWSTR           pwsName = pBlob->pName;
    WORD            Type = pBlob->wType;
    DWORD           Flags = pBlob->Flags;


    DNSLOG_F1( "R_ResolverQuery" );
    DNSLOG_F1( "   Arguments:" );
    DNSLOG_F2( "      Name             : %S", pwsName );
    DNSLOG_F2( "      Type             : %d", Type );
    DNSLOG_F2( "      Flags            : 0x%x", Flags );

    DNSDBG( RPC, (
        "\nR_ResolverQuery( %S, t=%d, f=%08x )\n",
        pwsName,
        Type,
        Flags ));


    //
    //  cacheable response
    //

Done:

    //
    //  put results in blob
    //

    pBlob->pRecords = presultRR;
    pBlob->Status = status;

    DNSLOG_F3(
        "R_ResolverQuery - status    : 0x%.8X\n\t%s",
        status,
        Dns_StatusString( status ) );
    DNSLOG_F1( "" );

    DNSDBG( RPC, (
        "Leave R_ResolverQuery( %S, t=%d, f=%08x )\n\n",
        pwsName,
        Type,
        Flags ));
}
#endif



BOOL
ResolverCacheQueryCallback(
    IN OUT  PQUERY_BLOB     pBlob
    )
/*++

Routine Description:

    Check cache for name.

    This is callback to check appended names.

Arguments:

    pBlob -- query blob

Return Value:

    TRUE if name and type found.
    FALSE otherwise.

--*/
{
    //
    //  check cache for name and type
    //

    if ( SKIP_CACHE_LOOKUP(pBlob->Flags) )
    {
        return  FALSE;
    }

    //
    //  copy name back to unicode
    //

    if ( ! Dns_NameCopyWireToUnicode(
                pBlob->NameBufferWide,
                pBlob->pNameWire ) )
    {
        DNSDBG( ANY, (
            "Invalid name %s.\n",
            pBlob->pNameWire ));
        DNS_ASSERT( FALSE );
        return  FALSE;
    }

    //
    //  lookup in cache
    //

    return  Cache_GetRecordsForRpc(
                & pBlob->pRecords,
                & pBlob->Status,
                pBlob->NameBufferWide,
                pBlob->wType,
                pBlob->Flags
                );
}



DNS_STATUS
R_ResolverQuery(
    IN      DNS_RPC_HANDLE  Handle,
    IN      PWSTR           pwsName,
    IN      WORD            wType,
    IN      DWORD           Flags,
    OUT     PDNS_RECORD *   ppResultRecords
    )
/*++

Routine Description:

    Simple query to resolver.

Arguments:


Return Value:

    ERROR_SUCCESS if query successful.
    ErrorCode on failure.

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;
    PDNS_RECORD     prrReturn = NULL;
    QUERY_BLOB      blob;


    DNSLOG_F1( "DNS Caching Resolver Service - R_ResolverQuery" );
    DNSLOG_F1( "   Arguments:" );
    DNSLOG_F2( "      Name             : %S", pwsName );
    DNSLOG_F2( "      Type             : %d", wType );
    DNSLOG_F2( "      Flags            : 0x%x", Flags );

    DNSDBG( RPC, (
        "\nR_ResolverQuery( %S, t=%d, f=%08x )\n",
        pwsName,
        wType,
        Flags ));

    if ( !ppResultRecords )
    {
        return ERROR_INVALID_PARAMETER;
    }

    if ( ClientThreadNotAllowedAccess() )
    {
        DNSLOG_F1( "R_ResolverQuery - ERROR_ACCESS_DENIED" );
        status = ERROR_ACCESS_DENIED;
        goto Done;
    }

    //
    //  check cache for name and type
    //
    //  DCR:  functionalize to take QUERY_BLOB
    //

    if ( !(Flags & DNS_QUERY_BYPASS_CACHE) )
    {
        if ( Cache_GetRecordsForRpc(
                & prrReturn,
                & status,
                pwsName,
                wType,
                Flags ) )
        {
            goto Done;
        }
    }

    //
    //  setup query blob
    //

    RtlZeroMemory(
        & blob,
        sizeof(blob) );

    blob.pNameOrig      = pwsName;
    blob.wType          = wType;
    blob.Flags          = Flags | DNSQUERY_UNICODE_OUT;

    //  callbacks
    //      - address info func for prioritize
    //      - cache query for intermediate names

    blob.pfnGetAddrArray = GetLocalAddrArray;
    blob.pfnQueryCache   = ResolverCacheQueryCallback;

    //
    //  do query
    //      - local lookup
    //      - then wire query
    //

    status = ResolverQuery( &blob );

    if ( status != ERROR_SUCCESS &&
         status != DNS_ERROR_RCODE_NAME_ERROR &&
         status != DNS_INFO_NO_RECORDS )
    {
        goto Done;
    }
    prrReturn = blob.pRecords;

    //
    //  local results
    //      - not cached
    //      but note that still going through Cache_QueryResponse()
    //      to get proper RPC preparation

#if 0
    if ( blob.pLocalRecords )
    {
    }
#endif

    //
    //  cache results
    //      - don't cache local lookup records
    //
    //  DCR:  should have simple "CacheResults" flag
    //
    //  note:  even local records are going through here
    //      now to clean them up for RPC;  they are not
    //      cached
    //

    status = Cache_QueryResponse( &blob );
    prrReturn = blob.pRecords;
    

Done:

    //  dump any unused query records

    if ( prrReturn && status != ERROR_SUCCESS )
    {
        Dns_RecordListFree( prrReturn );
        prrReturn = NULL;
    }

    //  set out pointer

    *ppResultRecords = prrReturn;

    DNSLOG_F3(
        "   R_ResolverQuery - Returning status    : 0x%.8X\n\t%s",
        status,
        Dns_StatusString(status) );
    DNSLOG_F1( "" );

    IF_DNSDBG( RPC )
    {
        DnsDbg_RecordSet(
            "R_ResolverQuery Result List:",
            prrReturn );
    }
    DNSDBG( RPC, (
        "Leave R_ResolverQuery( %S, t=%d, f=%08x )\n\n"
        "\tstatus = %d\n\n",
        pwsName,
        wType,
        Flags,
        status ));

    return status;
}

//
//  End ops.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\dns\resolver\server\remote.c ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    remote.c

Abstract:

    DNS Resolver Service.

    Remote APIs to resolver service.

Author:

    Glenn Curtis  (glennc)  Feb 1997

Revision History:

    Jim Gilroy (jamesg)     March 2000      cleanup

--*/


#include "local.h"


//
//  Local Definitions
//

typedef struct  _POPUP_MSG_PARMS
{
     LPWSTR                Message;
     LPWSTR                Title;
}
POPUP_MSG_PARMS, *PPOPUP_MSG_PARMS;


//
//  Private protos
//

DNS_STATUS
RslvrQueryToDnsServer(
    OUT    PDNS_RECORD *    ppRecord,
    IN     PWSTR            pwsName,
    IN     WORD             wType,
    IN     DWORD            Flags,
    OUT    PBOOL            pfCacheNegativeResponse
    );

BOOL
IsKnownTimedOutAdapter(
    VOID
    );

VOID
SetKnownTimedOutAdapter(
    VOID
    );

BOOL
IsTimeToResetServerPriorities(
    VOID
    );

DWORD
PopupMessageThread(
    IN  PPOPUP_MSG_PARMS );


PDNS_RPC_CACHE_TABLE
CreateCacheTableEntry(
    IN  LPWSTR Name
    );

VOID
FreeCacheTableEntryList(
    IN  PDNS_RPC_CACHE_TABLE pCacheTableList
    );

BOOL
IsEmptyDnsResponse(
    IN  PDNS_RECORD
    );



//
//  Operations
//

DNS_STATUS
CRrReadCache(
    IN      DNS_RPC_HANDLE          Reserved,
    OUT     PDNS_RPC_CACHE_TABLE *  ppCacheTable
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/ // CRrReadCache
{
    DNS_STATUS           status = ERROR_SUCCESS;
    PDNS_RPC_CACHE_TABLE pprevRpcEntry = NULL;
    DWORD                iter;
    DWORD                countEntries = 0;

#define MAX_RPC_CACHE_ENTRY_COUNT   (300)


    UNREFERENCED_PARAMETER(Reserved);

    DNSDBG( RPC, ( "CRrReadCache\n" ));

    if ( !ppCacheTable )
    {
        return ERROR_INVALID_PARAMETER;
    }

    *ppCacheTable = NULL;

    DNSLOG_F1( "DNS Caching Resolver Service - CRrReadCache" );

    if ( ClientThreadNotAllowedAccess() )
    {
        DNSLOG_F1( "CRrReadCache - ERROR_ACCESS_DENIED" );
        return ERROR_ACCESS_DENIED;
    }

    LOCK_CACHE();

    DNSLOG_F2( "   Current number of entries in cache : %d",
               g_EntryCount );
    DNSLOG_F2( "   Current number of RR sets in cache : %d",
               g_RecordSetCount );

    //
    // Loop through all hash table slots looking for cache entries
    // to return.
    //

    for ( iter = 0; iter < g_HashTableSize; iter++ )
    {
        PCACHE_ENTRY    pentry = g_HashTable[iter];
        DWORD           iter2;

        while ( pentry &&
                countEntries < MAX_RPC_CACHE_ENTRY_COUNT )
        {
            PDNS_RPC_CACHE_TABLE prpcEntry;

            prpcEntry = CreateCacheTableEntry( pentry->pName );
            if ( ! prpcEntry )
            {
                //  only failure is memory alloc

                FreeCacheTableEntryList( *ppCacheTable );
                *ppCacheTable = NULL;
                status = ERROR_NOT_ENOUGH_MEMORY;
                goto ErrorExit;
            }

            //
            // insert new entry at end of current list
            //

            if ( pprevRpcEntry )
                pprevRpcEntry->pNext = prpcEntry;
            else
                *ppCacheTable = prpcEntry;

            pprevRpcEntry = prpcEntry;

            countEntries++;

            //
            //  fill in entry with current cached types
            //

            for ( iter2 = 0; iter2 < pentry->MaxCount; iter2++ )
            {
                PDNS_RECORD prr = pentry->Records[iter2];
                WORD        type;

                if ( !prr )
                {
                    continue;
                }

                //  DCR -- goofy, just make sure the same and index (or limit?)

                type = prr->wType;

                if ( ! prpcEntry->Type1 )
                    prpcEntry->Type1 = type;
                else if ( ! prpcEntry->Type2 )
                    prpcEntry->Type2 = type;
                else
                    prpcEntry->Type3 = type;
            }
            
            pentry = pentry->pNext;
        }

        if ( countEntries > MAX_RPC_CACHE_ENTRY_COUNT )
        {
            break;
        }
    }

ErrorExit:

    UNLOCK_CACHE();

    DNSLOG_F3( "   CRrReadCache - Returning status : 0x%.8X\n\t%s",
            