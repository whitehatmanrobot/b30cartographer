                                   (      _fChecked
                                                ||  ChkRadioGroup(GetAAname()) == S_FALSE)
                                            );
        }
        break;

    case NTYPE_ELEMENT_SETFOCUS:
        switch (type)
        {
        case    htmlInputRadio:
        case    htmlInputCheckbox:
            _fLastValue = _fChecked;
            // fall through
        case    htmlInputButton:
        case    htmlInputReset:
        case    htmlInputSubmit:
            _wBtnStatus = BTN_SETSTATUS(_wBtnStatus, FLAG_HASFOCUS);
            break;
        case    htmlInputFile:
            {
                CSetFocus * pSetFocus       = (CSetFocus *)pNF->DataAsPtr();
                CMessage *  pMessage        = pSetFocus->_pMessage;
                unsigned    fButtonHadFocus = _fButtonHasFocus;

                if ( pMessage && 
                    ( (pMessage->message == WM_LBUTTONDOWN) || 
                      (pMessage->message == WM_RBUTTONDOWN) ) )
                {
                    CRect rc;
                    DYNCAST(CInputFileLayout, GetUpdatedLayout())->GetButtonRect(&rc);
                    _fButtonHasFocus = rc.Contains(pMessage->ptContent);
                }
                //  if the button helper is requesting or we come in with a BackTab
                if ( _fBtnHelperRequestsCurrency ||
                     pMessage &&
                     pMessage->message == WM_KEYDOWN &&
                     pMessage->wParam == VK_TAB &&
                     pMessage->dwKeyState & FSHIFT )
                {
                    BtnHelperSetFocus();
                }
                else if ( fButtonHadFocus && !_fButtonHasFocus)
                {
                    BtnHelperKillFocus();
                }
            }
            break;
        }
        break;

    case NTYPE_ELEMENT_EXITTREE_1:
        switch (type)
        {
        case htmlInputImage :
        case htmlInputSubmit :
            if( pNF->DataAsDWORD() & EXITTREE_DESTROY )
            {
                Doc()->_pElemDefault = NULL;
            }
            else
            {
                SetDefaultElem(TRUE);
            }
            break;
        case htmlInputFile :
            if (_icfButton != -1)
            {
                TLS(_pCharFormatCache)->ReleaseData( _icfButton ); _icfButton = -1;
            }
            break;
        case htmlInputRadio :
            if (_fChecked && !(pNF->DataAsDWORD() & EXITTREE_DESTROY))
            {
                DelRadioGroup(GetAAname());
            }
            break;
        }
        break;

    case NTYPE_DELAY_LOAD_HISTORY:

        switch (type)
        {
        case    htmlInputFile:
        case    htmlInputText:
        case    htmlInputHidden:
            hr = THR(LoadHistoryValue());
            if (!OK(hr))
            {
                // See comments for _cstrLastValue in inputtxt.hxx
                if (_cstrLastValue == NULL && htmlInputHidden == type)
                    SetValueHelper(_T("  "), 2);
    
                hr = S_OK;
            }
            break;
        case    htmlInputRadio:
            hr = THR(LoadHistoryValue());
            _fDeferClearGroup = FALSE;
            break;
        case    htmlInputCheckbox:
            hr = THR(LoadHistoryValue());
            break;
        }
        break;
        
    case NTYPE_SAVE_HISTORY_1:
        switch (type)
        {
        case htmlInputText :
        case htmlInputHidden :
        case htmlInputFile :
        case htmlInputCheckbox :
        case htmlInputRadio :
            pNF->SetSecondChanceRequested();
        }

        break;

    case NTYPE_SAVE_HISTORY_2:
        Assert(    type == htmlInputText || type == htmlInputHidden || type == htmlInputFile
                || type == htmlInputCheckbox || type == htmlInputRadio );
        {
            CDataStream         ds;
            CHistorySaveCtx *   phsc;
            DWORD               dwHistoryIndex =    0x80000000
                                                |   (DWORD)_iHistoryIndex
                                                &   0x0FFFF;

            pNF->Data((void **)&phsc);
            hr = THR(phsc->BeginSaveStream(dwHistoryIndex, HistoryCode(), &pStream));
            if (hr)
                goto Cleanup;

            ds.Init(pStream);

            if (!IsOptionButton())
            {
                Assert (IsTextOrFile());

                hr = THR(ds.SaveDword(_fChangingEncoding ? 1 : 0));
                if (hr)
                    goto Cleanup;
                if (!_fChangingEncoding)
                {
                    // save value
                    hr = THR(GetValueHelper(&cstrVal));
                    if (hr)
                        goto Cleanup;
                    hr = THR(ds.SaveCStr(&cstrVal));
                    if (hr)
                        goto Cleanup;
                    
                    // save _fTextChanged
                    hr = THR(ds.SaveDword(_fTextChanged ? 1 : 0));
                    if (hr)
                        goto Cleanup;
                }
            }
            else
            {
                hr = THR(ds.SaveDword((DWORD)_fChecked));
                if (hr)
                    goto Cleanup;
            }

            hr = THR(phsc->EndSaveStream());
            if (hr)
                goto Cleanup;
        }
        break;

    case NTYPE_ELEMENT_ENTERTREE:
        EnterTree();
        break;

    case NTYPE_BASE_URL_CHANGE:
        // send onpropertychange calls for all properties that are
        // effected by this change
        OnPropertyChange( DISPID_CInput_src, 
                          ((PROPERTYDESC *)&s_propdescCInputsrc)->GetdwFlags(),
                          (PROPERTYDESC *)&s_propdescCInputsrc);
        OnPropertyChange( DISPID_CInput_dynsrc, 
                          ((PROPERTYDESC *)&s_propdescCInputdynsrc)->GetdwFlags(),
                          (PROPERTYDESC *)&s_propdescCInputdynsrc);
        OnPropertyChange( DISPID_CInput_lowsrc, 
                          ((PROPERTYDESC *)&s_propdescCInputlowsrc)->GetdwFlags(),
                          (PROPERTYDESC *)&s_propdescCInputlowsrc);
        break;        

    case NTYPE_SET_CODEPAGE:
        if (IsTextOrFile())
        {
            _fChangingEncoding = TRUE;
        }
        break;
    }

Cleanup:
    ReleaseInterface(pStream);
    return;
}


#ifndef NO_DATABINDING
class CDBindMethodsRadio : public CDBindMethodsSimple
{
    typedef CDBindMethodsSimple super;
    
public:
    CDBindMethodsRadio() : super(VT_BSTR) {}
    ~CDBindMethodsRadio()   {}

    virtual HRESULT BoundValueToElement(CElement *pElem, LONG id,
                    BOOL fHTML, LPVOID pvData) const;
                    
    virtual HRESULT BoundValueFromElement(CElement *pElem, LONG id,
                     BOOL fHTML, LPVOID pvData) const;

};

class CDBindMethodsInputTxtBase : public CDBindMethodsText
{
    typedef CDBindMethodsText super;
public:
    CDBindMethodsInputTxtBase() : super(0)   {}
    ~CDBindMethodsInputTxtBase()    {}

    virtual HRESULT BoundValueToElement(CElement *pElem, LONG id,
                                        BOOL fHTML, LPVOID pvData) const;
    virtual HRESULT BoundValueFromElement(CElement *pElem, LONG id,
                                         BOOL fHTML, LPVOID pvData) const;
};

class CDBindMethodsCheckbox : public CDBindMethodsSimple
{
    typedef CDBindMethodsSimple super;

public:
    CDBindMethodsCheckbox() : super(VT_BOOL) {}
    ~CDBindMethodsCheckbox()    {}

    virtual HRESULT BoundValueToElement(CElement *pElem, LONG id,
                                        BOOL fHTML, LPVOID pvData) const;

    virtual HRESULT BoundValueFromElement(CElement *pElem, LONG id,
                                          BOOL fHTML, LPVOID pvData) const;

};


//+----------------------------------------------------------------------------
//
//  Function: BoundValueToElement, CDBindMethods
//
//  Synopsis: Transfer data into bound checkbox.  Only called if DBindKind
//            allows databinding.
//
//  Arguments:
//            [id]      - ID of binding point.  For the checkbox, is always
//                        DISPID_VALUE.
//            [pvData]  - pointer to data to transfer, in this case a boolean.
//
//-----------------------------------------------------------------------------
HRESULT
CDBindMethodsCheckbox::BoundValueToElement(CElement *pElem,
                                           LONG,
                                           BOOL,
                                           LPVOID pvData) const
{
    CInput *pCheckbox = DYNCAST(CInput, pElem);

    Assert( pCheckbox->GetType() == htmlInputCheckbox || pCheckbox->GetType() == htmlInputRadio );

    HRESULT hr = THR(pCheckbox->SetChecked(*(VARIANT_BOOL *)pvData,
                                  FALSE /* don't SaveData */));
    if (!hr)
        Verify(!pElem->OnPropertyChange(DISPID_CInput_checked, 
                                        0, 
                                        (PROPERTYDESC *)&s_propdescCInputchecked));
    RRETURN(hr);
}

HRESULT
CDBindMethodsCheckbox::BoundValueFromElement(CElement *pElem,
                                             LONG,
                                             BOOL,
                                             LPVOID pvData) const
{
    CInput *pCheckbox = DYNCAST(CInput, pElem);

    RRETURN(pCheckbox->GetChecked((VARIANT_BOOL *)pvData));
}

static const CDBindMethodsInputTxtBase DBindMethodsInputTxtBase;
static const CDBindMethodsCheckbox DBindMethodsCheckbox;
static const CDBindMethodsRadio DBindMethodsRadio;

const CDBindMethods *
CInput::GetDBindMethods()
{
    htmlInput type = GetType();

    switch(type)
    {
    case htmlInputPassword:
    case htmlInputHidden:
    case htmlInputText:
    case htmlInputFile:
    case htmlInputReset:
    case htmlInputSubmit:
    case htmlInputButton:
        return (CDBindMethods *)&DBindMethodsInputTxtBase;
    case htmlInputCheckbox:
        return (CDBindMethods *)&DBindMethodsCheckbox;
    case htmlInputRadio:
        return (CDBindMethods *)&DBindMethodsRadio; 
    default:
        return NULL;
    }
}


//+----------------------------------------------------------------------------
//
//  Function: BoundValueToElement, CDBindMethods
//
//  Synopsis: Transfer data into bound radio button group.  Only called if 
//            DBindKind allows databinding.
//
//  Arguments:
//            [id]      - ID of binding point.  For the checkbox, is always
//                        DISPID_VALUE.
//            [pvData]  - pointer to data to transfer, in this case a bstr
//
//-----------------------------------------------------------------------------
HRESULT
CDBindMethodsRadio::BoundValueToElement(CElement *pElem,
                    LONG,
                    BOOL,
                    LPVOID pvData) const
{
    // Search for a radio button with value equal to pcData
    HRESULT hr;
    CInput *pRadio = DYNCAST(CInput, pElem);
    LPCTSTR lpName=pRadio->GetAAname();         // NAME= field from INPUT tag

    if (lpName)
    {
        // Clear the currently set radiobutton.
        IGNORE_HR(pRadio->TraverseGroup( 
                    lpName, 
                    VISIT_METHOD(CInput, Clear, clear),
                    0,
                    TRUE));

        // check the button whose value appears in the data
        hr = THR(pRadio->TraverseGroup( lpName,
                    VISIT_METHOD(CInput, SetByValue, setbyvalue),
                    (DWORD_PTR) pvData,
                    TRUE));
    }
    else
    {
        // the user forgot the NAME field, bind to just this button.
        hr = pRadio->SetByValue((DWORD_PTR)pvData);
        
        // If there's no NAME field, then this is just a single button, so
        // if binding doesn't match, we must shut the button off ourselves.
        // Can't depend on mutual exclusion to do it.
        if (hr == S_FALSE)
        {
            IGNORE_HR(pRadio->SetChecked(VB_FALSE, FALSE /* don't SaveData */));
            Verify(!pElem->OnPropertyChange(DISPID_CInput_checked, 
                                            0, 
                                            (PROPERTYDESC *)&s_propdescCInputchecked));
        }
    }

    // failure to find a matching NAME is not a failure
    if (hr == S_FALSE)
        hr = S_OK;
    
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  Function: BoundValueFromElement, CDBindMethods
//
//  Synopsis: Transfer data from bound radio button group.  Only called if 
//            DBindKind allows databinding.
//
//  Arguments:
//            [id]      - ID of binding point.  For the checkbox, is always
//                        DISPID_VALUE.
//            [pvData]  - pointer to data to transfer, in this case a bstr
//
//  Returns:  S_OK      no problems
//            S_FALSE   No radio button was checked!
//                      BEWARE! This is a very possible state for a bound
//                      radio button to be in, if the value in the database
//                      did not match any of the Value fields of radio buttons.
//
//-----------------------------------------------------------------------------
HRESULT
CDBindMethodsRadio::BoundValueFromElement(CElement *pElem,
                      LONG,
                      BOOL,
                      LPVOID pvData) const
{
    // Get the value form the radio button in this group that is set.
    HRESULT hr;
    CInput *pRadio = DYNCAST(CInput, pElem);
    LPCTSTR lpName=pRadio->GetAAname();         // NAME= field from INPUT tag
    * (BSTR *) pvData = NULL;

    if (lpName)
    {
        hr = THR(pRadio->TraverseGroup( lpName,
                    VISIT_METHOD(CInput, GetValue, getvalue),
                    (DWORD_PTR) pvData,
                    TRUE));
    }
    else
    {
        // the user forgot the NAME field, look at just this button
        hr = pRadio->GetValue((DWORD_PTR)pvData);
    }

    RRETURN1(hr, S_FALSE);
}


HRESULT
CDBindMethodsInputTxtBase::BoundValueFromElement(CElement * pElem,
                                                 LONG       id,
                                                 BOOL       fHTML,
                                                 LPVOID     pvData) const
{
    HRESULT     hr;
    CStr        cstr;
    BSTR *      pBstr   = (BSTR *) pvData;

    Assert(pBstr);
    // shouldn't be called for one-way bindings
    Assert((_dwTransfer & DBIND_ONEWAY) == 0);

#if DBG==1
    {
        DBINFO dbi;

        Assert(id == ID_DBIND_DEFAULT);
        Assert(DBindKind(pElem, id, &dbi) > DBIND_NONE);
        Assert(dbi._vt == VT_BSTR);
    }
#endif // DBG == 1

    hr = THR(DYNCAST(CInput, pElem)->GetValueHelper(&cstr));
    if (hr)
        goto Cleanup;

    hr = cstr.AllocBSTR(pBstr);

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Function: BoundValueToElement, CDBindMethods
//
//  Synopsis: transfer bound data to input text element.  We need to override
//            the CElement implementation to remember the value being
//            transferred as the "last value".  This keeps the onchange event
//            from firing simply because the value is databound.
//
//  Arguments:
//            [id]      - ID of binding point.
//            [fHTML]   - is HTML-formatted data called for?
//            [pvData]  - pointer to data to transfer, in the expected data
//                        type.  For text-based transfers, must be BSTR.
//
//-----------------------------------------------------------------------------

HRESULT
CDBindMethodsInputTxtBase::BoundValueToElement ( CElement *pElem,
                                                 LONG id,
                                                 BOOL fHTML,
                                                 LPVOID pvData ) const
{
    CInput *    pInput = DYNCAST(CInput, pElem);
    BSTR *      pBstr = (BSTR *) pvData;
    HRESULT     hr;


    hr = THR(pInput->SetValueHelper((TCHAR *) *pBstr, FormsStringLen(*pBstr)));
    if (hr)
        goto Cleanup;

    // Remember the value
    // Call GetValueHelper instead of using pvData directly. This is because
    // the control may modify the given value (e.g. CR-LF munging - bug 3763).
    hr = THR(pInput->GetValueHelper(&pInput->_cstrLastValue));

    // We should call pInput->SetValueHelper with fOM set to FALSE
    // in order to fire onpropertychange, since we have to
    // call onpropertychange anyway for the cases where layout is not
    // created or not listening, we prefer do it here.
    Verify(!pElem->OnPropertyChange(DISPID_A_VALUE, 0, (PROPERTYDESC *)&s_propdescCInputvalue));

Cleanup:
    RRETURN(hr);
}
#endif // ndef NO_DATABINDING


//+---------------------------------------------------------------------------
//
//  Member:     CInput::createTextRange
//
//----------------------------------------------------------------------------
HRESULT
CInput::createTextRange( IHTMLTxtRange * * ppDisp )
{
    HRESULT         hr = S_OK;
    CAutoRange *    pAutoRange = NULL;
    CMarkup *       pMarkupSlave;
    CElement *      pElemSlave;

    if (!ppDisp)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!HasSlavePtr())
        goto Cleanup;
    
    pElemSlave = GetSlavePtr();
    pMarkupSlave = pElemSlave->GetMarkup();
    pAutoRange = new CAutoRange( pMarkupSlave, pElemSlave );

    if (!pAutoRange)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Set the lookaside entry for this range
    pAutoRange->SetNext( pMarkupSlave->DelTextRangeListPtr() );
    hr = THR( pMarkupSlave->SetTextRangeListPtr( pAutoRange ) );
    if (hr)
        goto Cleanup;

    hr = THR( pAutoRange->Init() );

    if (hr)
        goto Cleanup;

    Assert( GetSlavePtr() == pElemSlave && GetSlavePtr()->GetMarkup() == pMarkupSlave );

    hr = THR_NOTRACE( pAutoRange->SetTextRangeToElement( pElemSlave ) );

    Assert( hr != S_FALSE );

    if (hr)
        goto Cleanup;

    *ppDisp = pAutoRange;
    pAutoRange->AddRef();

Cleanup:
    if (pAutoRange)
    {
        pAutoRange->Release();
    }

    RRETURN( SetErrorInfo( hr ) );
}


void
CInput::BtnHelperSetFocus(void)
{
    CDoc *  pDoc = Doc();

    Assert (GetType() == htmlInputFile);

    _fButtonHasFocus = TRUE;

    _wBtnStatus = BTN_SETSTATUS(_wBtnStatus, FLAG_HASFOCUS);
    ChangePressedLook();

    pDoc->GetView()->SetFocus(this, 0);

    // Hide the caret
    if (pDoc->_pCaret)
    {
        pDoc->_pCaret->Hide();
    }
}

void
CInput::BtnHelperKillFocus(void)
{
    Assert (GetType() == htmlInputFile);
    BTN_RESETSTATUS(_wBtnStatus);
    ChangePressedLook();
    _fButtonHasFocus = FALSE;
    Doc()->GetView()->SetFocus(this, 0);
}


HRESULT
CInput::DoClickCheckbox(CMessage * pMessage /*=NULL*/, CTreeNode *pNodeContext /*=NULL*/,
                          BOOL fFromLabel /*=FALSE*/, EVENTINFO* pEvtInfo /*= NULL*/ )
{
    HRESULT hr          = S_OK;
    BOOL    fOldChecked = !!_fChecked;
    WORD    wOldStatus  = _wBtnStatus;

    if (!IsEnabled() && !IsEditable(TRUE))
        goto Cleanup;

    if(!pNodeContext)
        pNodeContext = GetFirstBranch();

    if(!pNodeContext)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    Assert(pNodeContext && pNodeContext->Element() == this);

    if (!TestLock(ELEMENTLOCK_CLICK))
    {
        CLock     Lock(this, ELEMENTLOCK_CLICK);
        CTreeNode::CLock NodeLock;

        hr = THR( NodeLock.Init(pNodeContext) );
        if( hr )
            goto Cleanup;

        // Set check before firing onclick (Netscape Compat.)
        IGNORE_HR(ClickAction(pMessage));
        if (Fire_onclick(pNodeContext, -1, pEvtInfo ))
            goto Cleanup;

        // Click event was cancelled, so restore old value (Netscape Compat.)
        if (fOldChecked == !!_fChecked)
        {
            _wBtnStatus = wOldStatus;
            GetUpdatedLayout()->Invalidate();
        }
        else
        {
            put_checked(_fChecked ? VB_FALSE : VB_TRUE);
        }
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CInput::Getchecked, Setchecked
//
//  Synopsis:   Functions that are called by the vtable when properties
//              are requested.
//
//--------------------------------------------------------------------------

HRESULT
CInput::put_checked(VARIANT_BOOL checked)
{
    HRESULT hr;

    hr = SetErrorInfo(SetChecked(checked));
    if (FAILED(hr))
        goto Cleanup;

    if (!_fChecked)
    {
        CFormElement    * pForm = GetParentForm();

        if (pForm)
        {
            if (!pForm->_fInTraverseGroup)
                DelRadioGroup(GetAAname());
        }
        else
        {
            CMarkup     * pMarkup = GetMarkup();

            if (pMarkup && !pMarkup->_fInTraverseGroup)
                DelRadioGroup(GetAAname());
        }
    }

    Verify(!OnPropertyChange(DISPID_CInput_checked, 
                             0, 
                             (PROPERTYDESC *)&s_propdescCInputchecked));

Cleanup:
    RRETURN(hr);
}

HRESULT
CInput::get_checked(VARIANT_BOOL * pchecked)
{
    if ( !pchecked )
        return ( SetErrorInfo(E_INVALIDARG));

    return(SetErrorInfo(GetChecked(pchecked)));
}

HRESULT
CInput::put_status(VARIANT status)
{
    switch(status.vt)
    {
        case VT_NULL:
        _vStatus.vt = VT_NULL;
        break;
        case VT_BOOL:
        _vStatus.vt = VT_BOOL;
        V_BOOL(&_vStatus) = V_BOOL(&status);
        break;
        default:
        _vStatus.vt = VT_BOOL;
        V_BOOL(&_vStatus) = VB_TRUE;
    }

    Verify(S_OK==OnPropertyChange(DISPID_CInput_status, 
                                  0, 
                                  (PROPERTYDESC *)&s_propdescCInputstatus));

    RRETURN(S_OK);
}

HRESULT
CInput::get_status(VARIANT * pStatus)
{
    if (_vStatus.vt==VT_NULL)
    {
        pStatus->vt = VT_NULL;
    }
    else
    {
        pStatus->vt = VT_BOOL;
        V_BOOL(pStatus) = V_BOOL(&_vStatus);
    }
RRETURN(S_OK);
}


// status is an altternative NS name for "checked"
HRESULT
CInput::put_status(VARIANT_BOOL checked)
{
   RRETURN(SetErrorInfo(put_checked(checked)));
}

HRESULT
CInput::get_status(VARIANT_BOOL * pchecked)
{
    if ( !pchecked )
        return ( SetErrorInfo(E_INVALIDARG));
    return(GetChecked(pchecked));
}

//+-------------------------------------------------------------------------
//
//  Method:     CInput::GetChecked, SetChecked
//
//  Synopsis:   Helper properties that are implemented for CBtnHelper
//
//--------------------------------------------------------------------------


HRESULT
CInput::SetChecked(VARIANT_BOOL checked, BOOL fSaveData)
{
    HRESULT hr            = S_OK;
    unsigned fCheckedOrig = _fChecked;
    BOOL fIsRadio         = (GetType() == htmlInputRadio);
    BOOL fIsInMarkup      = IsInMarkup();

    if (fIsRadio)
    {
        // if there a state change or the setting is to Off...
        //  just call the super. otherwise we have to turn off
        //  any other radiobuttons in our group which are on.
        if (checked == -(VARIANT_BOOL)_fChecked)
            goto Cleanup;

        // if fSaveData is FALSE, we're being called on behalf of BoundValueToElement,
        // and so the current group is already cleared.

        if (checked && fSaveData && fIsInMarkup)
        {
            // if only if multiple default checked radios need traversegroup
            // if (AddRadioGroup(GetAAname()) == S_FALSE && !_fDeferClearGroup)

            LPCTSTR     lpGroupName = GetAAname();

            if (AddRadioGroup(lpGroupName) == S_FALSE || !_fDeferClearGroup)
            {
                // Clear the currently set radiobutton.
                IGNORE_HR(TraverseGroup(lpGroupName,
                                        VISIT_METHOD(CInput, Clear, clear),
                                        0,
                                        TRUE));
            }
        }
    }

    _fChecked = checked;

#ifndef NO_DATABINDING
    if (fSaveData && fIsInMarkup)
    {
        hr = SaveDataIfChanged(ID_DBIND_DEFAULT);
        if (SUCCEEDED(hr))
        {
            hr = S_OK;
        }
        else                    // if we can't save bound value, ignore change
        {
            DBMEMBERS * pdbm = GetDBMembers();
            if (fIsRadio && pdbm)
            {
                // we have to set all the buttons in the group back to their
                // original state (bug 61432).  The simplest way to do this
                // is to just reread the value from the database.
                IGNORE_HR(pdbm->TransferFromSrc(this, ID_DBIND_DEFAULT));
            }
            else
            {
                _fChecked = fCheckedOrig;
            }
        }
    }
#endif

    if (IsEditable(TRUE))
        put_BoolHelper(-(VARIANT_BOOL)_fChecked, (PROPERTYDESC *)&s_propdescCInputdefaultChecked);

    if (_fChecked != fCheckedOrig && fIsInMarkup && IsOptionButton() && HasLayoutPtr())
    {
        GetLayoutPtr()->Invalidate();
    }

Cleanup:
    RRETURN(hr);
}

HRESULT
CInput::GetChecked(VARIANT_BOOL * pchecked)
{
    *pchecked = _fChecked ? VB_TRUE : VB_FALSE;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Member:      CInput::SaveCheckbox
//
// Synopsis:    saves the checkbox/radiobutton
//

//----------------------------------------------------------------------------
HRESULT CInput::SaveCheckbox(CStreamWriteBuff * pStreamWrBuff, BOOL fEnd )
{
    // in run mode the CHECKED and DEFAULTCHECKED properties are
    // not insync, which is intentional to allow the reset functionallity
    // if we save in run we allways want to save the current state
    // (e.g. for printing) therefore we temporarly set the default checked
    // value and then reset it again after saving...
    HRESULT hr;
    VARIANT_BOOL bCurstate = GetAAdefaultChecked();
    DWORD dwIgnore;

    if( !_fChecked )
    {
        (*GetAttrArray())->FindSimpleInt4AndDelete( DISPID_CInput_defaultChecked, &dwIgnore );
    }
    else
    {
        SetAAdefaultChecked(_fChecked);
    }

    hr = super::Save(pStreamWrBuff, fEnd);

    if( !bCurstate )
    {
        (*GetAttrArray())->FindSimpleInt4AndDelete( DISPID_CInput_defaultChecked, &dwIgnore );
    }
    else
    {
        SetAAdefaultChecked(bCurstate);
    }

    RRETURN(hr);

}

//+---------------------------------------------------------------------------
//
// Member:      CInput::HandleCheckboxMessage
//
// Synopsis:    Handle window message
//
//----------------------------------------------------------------------------

HRESULT BUGCALL
CInput::HandleCheckboxMessage(CMessage * pMessage)
{
    HRESULT hr = S_FALSE;
                            
    BOOL    fRunMode = !IsEditable(TRUE) && ! IsMasterParentEditable() ;
                           
    if (GetType() == htmlInputRadio)
    {
        BOOL    fAlt = pMessage->dwKeyState & FALT;
        BOOL    fCtrl = pMessage->dwKeyState & FCONTROL;

        if (fRunMode && !fAlt && !fCtrl && pMessage->message == WM_KEYDOWN)
        {
            // try to handle the message right here
            switch(pMessage->wParam)
            {
            case VK_LEFT:
            case VK_UP:
                BTN_RESETSTATUS(_wBtnStatus);
                NavigateToNext(pMessage, FALSE);
                hr = S_OK;
                break;

            case VK_RIGHT:
            case VK_DOWN:
                BTN_RESETSTATUS(_wBtnStatus);
                NavigateToNext(pMessage, TRUE);
                hr = S_OK;
                break;
            }
        }

        if (hr != S_FALSE)
            goto Cleanup;
    }

    if (IsEnabled() && ( fRunMode || 
                        ( Doc()->_pElemCurrent == this && pMessage->htc != HTC_BEHAVIOR ) ))
    {
        hr = BtnHandleMessage(pMessage);
        if (hr != S_FALSE)
            goto Cleanup;
    }

    hr = super::HandleMessage(pMessage);

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CInput::RenderGlyph
//
//  Synopsis:   renders the glyph for the button
//
//  Arguments:  [hdc] -- HDC to render into
//              [prc] -- rect to render info
//
//  Returns:    HRESULT
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT
CInput::RenderGlyph(CFormDrawInfo * pDI, LPRECT prc)
{
    UINT            dfcs     = 0;
    VARIANT_BOOL    checked;
    HTHEME          hTheme = GetTheme(GetInputThemeClsId());

    Assert(IsOptionButton());

    if (hTheme)
    {
        XHDC            hdc    = pDI->GetDC(TRUE);        
        if (hdc.DrawThemeBackground(    hTheme,
                                        (GetType() == htmlInputRadio)
                                            ? BP_RADIOBUTTON
                                            : BP_CHECKBOX,
                                        GetThemeState(),
                                        prc,
                                        0))
            return S_OK;
    }

    GetChecked(&checked);
    if (checked)
        dfcs |= DFCS_CHECKED;

    if(BTN_PRESSED(_wBtnStatus))
        dfcs |= DFCS_PUSHED;

    if (!IsEnabled())
        dfcs |= DFCS_INACTIVE;

    switch (BtnStyle())
    {
    case GLYPHSTYLE_NONE:
        Assert(0);
        break;

    case GLYPHSTYLE_CHECK:
        dfcs |= DFCS_BUTTONCHECK;
        if (BTN_GETSTATUS(_wBtnStatus, FLAG_TRISTATE))
        {
            dfcs |= DFCS_CHECKED | DFCS_BUTTON3STATE;
        }

        break;

    case GLYPHSTYLE_OPTION:
        dfcs |= DFCS_BUTTONRADIO;
        break;
    }

    FormsDrawGlyph(pDI, prc, DFC_BUTTON, dfcs);

    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     CInput::FInSameGroup
//
//  Synopsis:   Check if the given site another radio button in the same
//              group as this one.
//
//-------------------------------------------------------------------------

BOOL
CInput::FInSameGroup(CElement * pElem)
{
    // Make sure pSite is a radio button
    Assert(pElem);
    if (!(pElem->Tag() == ETAG_INPUT &&
        DYNCAST(CInput, pElem)->GetAAtype() == htmlInputRadio))
    {
        return FALSE;
    }

    // Make sure they are in the same scope
    if (GetParentForm() != pElem->GetParentForm())
        return FALSE;

    LPCTSTR pnameThis = GetAAname();
    LPCTSTR pnameOther = DYNCAST(CInput, pElem)->GetAAname();

    return (pnameThis
        &&  pnameOther
        &&  FormsStringICmp(pnameThis, pnameOther) == 0);
}

//+------------------------------------------------------------------------
//
//  Member:     CInput::ClearGroup
//
//  Synopsis:   Clear the other radio buttons in the same group (if deferred
//              in Init2()).
//
//-------------------------------------------------------------------------
HRESULT
CInput::ClearGroup ( CRadioGroupAry * pRadioGroupArray )
{
    HRESULT             hr          = S_OK;
    LPCTSTR             pchName     = GetAAname();
    CFormElement *      pForm       = GetParentForm();
    RadioGroupEntry *   pEntry;
    int                 i;
    BOOL                fAddEntry;

    Assert(GetType() == htmlInputRadio);

    if (!pchName)
    goto Cleanup;

    Assert( pRadioGroupArray );

    // search for this group
    fAddEntry = TRUE;
    for (i = pRadioGroupArray->Size(), pEntry = *pRadioGroupArray; i > 0; i--, pEntry++)
    {
        if (pEntry->_pParentForm == pForm &&
            0 == FormsStringICmp(pEntry->_pRadio->GetAAname(), pchName))
        {
            if (_fChecked)
            {
                // Clear the previous button
                if (pEntry->_pRadio->_fChecked)
                    pEntry->_pRadio->put_checked(FALSE);

                pEntry->_pRadio = this;
            }
            else
            {
            }
            fAddEntry = FALSE;
                break;
        }
    }

    if (fAddEntry)
    {
        hr = THR(pRadioGroupArray->Grow(pRadioGroupArray->Size() + 1));
        if (hr)
            goto Cleanup;
        pEntry = &pRadioGroupArray->Item(pRadioGroupArray->Size() - 1);
        pEntry->_pRadio = this;
        pEntry->_pParentForm = pForm;
        if (hr)
            goto Cleanup;     
    }
Cleanup:
    RRETURN(hr);            
}


//+--------------------------------------------------------
//
//  Member:     CInput::Clear
//
//  Synopsis:   CCheckbox override, since CRadioElements are mutually exclusive
//
//-------------------------------------------------------------------------

HRESULT 
CInput::Clear(DWORD_PTR dw)
{
    HRESULT hr = S_FALSE;

    if (BaseDesc() == (const CBase::CLASSDESC *) &s_classdescCheckbox)
    {
        put_checked(FALSE);
    }
    RRETURN1(hr, S_FALSE);
}

//+----------------------------------------------------------------------------
//
//  Function: GetElementDataBound, CElement
//
//  Synopsis: For the given site, find whichever site handles its databinding.
//            (Note that the returned site might not have any databinding
//            specified at all.)  This method allows one bound radio button
//            to act as a binding proxy for all of the buttons in a group.
//
//  Return:   either site itself, or else some other bound radiobutton in the
//            same group.
//
//-----------------------------------------------------------------------------
CElement *
CInput::GetElementDataBound()
{
    CElement *pElement = this;

    if (GetType() == htmlInputRadio)
    {
        IGNORE_HR(TraverseGroup(
            GetAAname(),
            VISIT_METHOD(CInput, FindBoundRadioElement, findboundradioelement),
            (DWORD_PTR) &pElement,
            TRUE));
    }
    else
    {
        pElement = super::GetElementDataBound();
    }

    return pElement;
}

HRESULT
CInput::FindBoundRadioElement(DWORD_PTR dw)
{
    HRESULT hr = S_FALSE;

#ifndef NO_DATABINDING   
    if (BaseDesc() == (const CBase::CLASSDESC *) &s_classdescCheckbox)
    {
        if (GetDBMembers() != NULL)
        {
            * (CElement **) dw = this;
            hr = S_OK;
        }
    }
#endif // ndef NO_DATABINDING

    RRETURN1(hr, S_FALSE);
}
    

//+--------------------------------------------------------
//
//  Member:     CInput::SetByValue
//
//  Synopsis:   CCheckbox override, sice CRadioElements are mutually exclusive
//
//-------------------------------------------------------------------------

HRESULT 
CInput::SetByValue(DWORD_PTR dw)
{
    HRESULT hr = S_FALSE;

    if (BaseDesc() == (const CBase::CLASSDESC *) &s_classdescCheckbox)
    {
        CStr    cstrValue;
        HRESULT hr1 = GetValueHelper(&cstrValue);

        if (hr1)
        {
            hr = hr1;
            goto Cleanup;
        }
        
        if (FormsStringCmpLoc(*(BSTR *) dw, cstrValue) == 0)
        {
            // (sambent) SetByValue is only called from BoundValueToElement
            // so call SetChecked with the flag that suppresses the call to
            // SaveDataIfChanged.  This avoids redundant fetching from the database.
            hr = THR(SetChecked(VB_TRUE, FALSE /* don't SaveData */));
            Verify(!OnPropertyChange(DISPID_CInput_checked, 
                                     0, 
                                     (PROPERTYDESC *)&s_propdescCInputchecked));
        }
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+--------------------------------------------------------
//
//  Member:     CInput::GetValue
//
//  Synopsis:   CCheckbox override, sice CRadioElements are mutually exclusive
//
//-------------------------------------------------------------------------

HRESULT
CInput::GetValue(DWORD_PTR dw)
{
    HRESULT hr = S_FALSE;

    if (BaseDesc() == (const CBase::CLASSDESC *) &s_classdescCheckbox)
    {
        if (_fChecked)
            hr = THR(get_PropertyHelper((BSTR *) dw, (PROPERTYDESC *)&s_propdescCInputvalue));
    }
    RRETURN1(hr, S_FALSE);
}


//+--------------------------------------------------------
//
//  Member:     CInput::NavigateToNext
//
//  Synopsis:   Make the radio element after this one current.
//
//-------------------------------------------------------------------------

void
CInput::NavigateToNext(CMessage * pMessage, BOOL fForward)
{
    CElement *     pElement = NULL;

    TraverseGroup( 
        GetAAname(), 
        VISIT_METHOD(CInput, GetNext, getnext),
        (DWORD_PTR) &pElement,
        fForward);

    if (pElement)
    {
        IGNORE_HR(pElement->BecomeCurrentAndActive());
        IGNORE_HR(pElement->ScrollIntoView());
        IGNORE_HR(pElement->DoClick(pMessage));
    }
}


HRESULT
CInput::GetNext(DWORD_PTR dw)
{
    HRESULT hr = S_FALSE;

    if (BaseDesc() == (const CBase::CLASSDESC *) &s_classdescCheckbox)
    {
        CElement ** ppElement = (CElement **) dw;

        if (*ppElement)
        {
            *ppElement = this;
            hr = S_OK;
        }            
        else if (this == Doc()->_pElemCurrent)
            *ppElement = this;
    }
    RRETURN1(hr, S_FALSE);
}


HRESULT CInput::GetHeight(long *pl)
{
    VARIANT v;
    HRESULT hr;

    Assert(GetType() == htmlInputImage);
    hr = THR(s_propdescCInputheight.a.HandleUnitValueProperty(
            HANDLEPROP_VALUE | (PROPTYPE_VARIANT << 16),
            &v,
            this,
            CVOID_CAST(GetAttrArray())));
    if (hr)
        goto Cleanup;

    Assert(V_VT(&v) == VT_I4);
    Assert(pl);

    *pl = V_I4(&v);

Cleanup:
    RRETURN(hr);
}

HRESULT CInput::putHeight(long l)
{
    VARIANT v;

    if ( l < 0 )
        l = 0;

    V_VT(&v) = VT_I4;
    V_I4(&v) = l;

    RRETURN(s_propdescCInputheight.a.HandleUnitValueProperty(
            HANDLEPROP_SET | HANDLEPROP_AUTOMATION | HANDLEPROP_DONTVALIDATE | (PROPTYPE_VARIANT << 16),
            &v,
            this,
            CVOID_CAST(GetAttrArray())));
}

HRESULT CInput::GetWidth(long *pl)
{
    VARIANT v;
    HRESULT hr;

    Assert(GetType() == htmlInputImage);
    hr = THR(s_propdescCInputwidth.a.HandleUnitValueProperty(
            HANDLEPROP_VALUE | (PROPTYPE_VARIANT << 16),
            &v,
            this,
            CVOID_CAST(GetAttrArray())));
    if (hr)
        goto Cleanup;

    Assert(V_VT(&v) == VT_I4);
    Assert(pl);

    *pl = V_I4(&v);

Cleanup:
    RRETURN(hr);
}

HRESULT CInput::putWidth(long l)
{
    VARIANT v;

    Assert(GetType() == htmlInputImage);
    if ( l < 0 )
        l = 0;

    V_VT(&v) = VT_I4;
    V_I4(&v) = l;

    RRETURN(s_propdescCInputwidth.a.HandleUnitValueProperty(
            HANDLEPROP_SET | HANDLEPROP_DONTVALIDATE | HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
            &v,
            this,
            CVOID_CAST(GetAttrArray())));
}


STDMETHODIMP CInput::put_height(long l)
{
    RRETURN(SetErrorInfoPSet(putHeight(g_uiDisplay.DeviceFromDocPixelsY(l)), DISPID_CInput_height));
}

STDMETHODIMP CInput::get_height(long *p)
{
    HRESULT hr = S_OK;

    if ( !p )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if ((GetType() == htmlInputImage && _pImage))
        RRETURN (_pImage->get_height(p));

Cleanup:
    RRETURN(SetErrorInfoPGet(hr, DISPID_CInput_height));
}

STDMETHODIMP CInput::put_align(BSTR bstrAlign)
{
    RRETURN(s_propdescCInputalign.b.SetEnumStringProperty(
                bstrAlign,
                this,
                (CVoid *)(void *)(GetAttrArray()) ));
}

STDMETHODIMP CInput::get_align(BSTR *p)
{
    HRESULT hr = S_OK;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *p = NULL;

    if (GetType() != htmlInputImage)
        goto Cleanup;

    hr = s_propdescCInputalign.b.GetEnumStringProperty(
                p,
                this,
                (CVoid *)(void *)(GetAttrArray()) );

Cleanup:
    RRETURN(hr);
}

STDMETHODIMP CInput::put_width(long l)
{
    RRETURN(SetErrorInfoPSet(putWidth(g_uiDisplay.DeviceFromDocPixelsX(l)), DISPID_CInput_width));
}

STDMETHODIMP CInput::get_width(long *p)
{
    HRESULT hr = S_OK;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *p = NULL;

    if ((GetType() == htmlInputImage && _pImage))
        hr = _pImage->get_width(p);

Cleanup:
    RRETURN(SetErrorInfoPGet(hr, DISPID_CInput_width));
}

STDMETHODIMP
CInput::get_src(BSTR * pstrFullSrc)
{
    HRESULT hr = S_OK;

    if (!pstrFullSrc)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *pstrFullSrc = NULL;

    if ((GetType() == htmlInputImage && _pImage))
    {
        hr = _pImage->get_src(pstrFullSrc);
    }
    else
    {
        hr = s_propdescCInputsrc.b.GetUrlProperty(pstrFullSrc, this, CVOID_CAST(GetAttrArray()));
    }

Cleanup:
    RRETURN(SetErrorInfoPGet(hr, DISPID_CInput_src));
}

//+------------------------------------------------------------------
//
//  member : put_src
//
//  sysnopsis : impementation of the interface src property set
//          since this is a URL property we want the crlf striped out
//
//-------------------------------------------------------------------

STDMETHODIMP
CInput::put_src(BSTR bstrSrc)
{
    RRETURN(SetErrorInfo(s_propdescCInputsrc.b.SetUrlProperty(bstrSrc,
                    this,
                    (CVoid *)(void *)(GetAttrArray()))));
}

/*

HRESULT STDMETHODCALLTYPE CInput::put_ie4vtblslot(BSTR)
{
    Assert(GetType() == htmlInputImage);
    return (E_ACCESSDENIED);
}
*/

//+----------------------------------------------------------------------------
//
// Methods:     get/set_hspace
//
// Synopsis:    hspace for aligned images is 3 pixels by default, so we need
//              a method to identify if a default value is specified.
//
//-----------------------------------------------------------------------------

STDMETHODIMP CInput::put_hspace(long v)
{
    RRETURN(s_propdescCInputhspace.b.SetNumberProperty(v, this, CVOID_CAST(GetAttrArray())));
}

STDMETHODIMP CInput::get_hspace(long * p)
{
    HRESULT hr = S_OK;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *p = NULL;

    if ((GetType() == htmlInputImage && _pImage))
    {
        HRESULT hr = s_propdescCInputhspace.b.GetNumberProperty(p, this, CVOID_CAST(GetAttrArray()));

        if(!hr)
            *p = *p == -1 ? 0 : *p;
    }

Cleanup:
    RRETURN(SetErrorInfoPGet(hr, DISPID_CInput_hspace));
}

//+----------------------------------------------------------------------------
//
//  Member : [get_/put_] onload
//
//  synopsis : store in this element's propdesc
//
//+----------------------------------------------------------------------------

HRESULT
CInput:: put_onload(VARIANT v)
{
    HRESULT hr = S_OK;

    if ((GetType() == htmlInputImage && _pImage))
    {
        hr = THR(s_propdescCInputonload .a.HandleCodeProperty(
                HANDLEPROP_SET | HANDLEPROP_AUTOMATION |
                (PROPTYPE_VARIANT << 16),
                &v,
                this,
                CVOID_CAST(GetAttrArray())));
    }

    RRETURN( SetErrorInfo( hr ));
}

HRESULT
CInput:: get_onload(VARIANT *p)
{
    HRESULT hr = S_OK;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    p->vt = VT_NULL;

    if ((GetType() == htmlInputImage && _pImage))
    {
        hr = THR(s_propdescCInputonload.a.HandleCodeProperty(
                    HANDLEPROP_AUTOMATION | (PROPTYPE_VARIANT << 16),
                    p,
                    this,
                    CVOID_CAST(GetAttrArray())));
    }
Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

//+----------------------------------------------------------------------------
//
//  Member:     CInput:get_strReadyState
//
//
//+------------------------------------------------------------------------------

HRESULT
CInput::get_readyState(BSTR * p)
{
    HRESULT hr = S_OK;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    *p = NULL;

    if (GetType() != htmlInputImage)
    {
        goto Cleanup;
    }

    hr=THR(s_enumdeschtmlReadyState.StringFromEnum(_pImage->_readyStateFired, p));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CInput::get_readyState(VARIANT * pVarRes)
{
    HRESULT hr = S_OK;

    if (!pVarRes)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    hr = get_readyState(&V_BSTR(pVarRes));
    if (!hr)
        V_VT(pVarRes) = VT_BSTR;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CInput::get_readyStateValue(long *plRetValue)
{
    HRESULT     hr = S_OK;

    if (!plRetValue)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *plRetValue = _pImage->_readyStateFired;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+------------------------------------------------------------------------
//
//  Member:     InvokeExReady
//
//  Synopsis  :this is only here to handle readyState queries, everything
//      else is passed on to the super
//
//+------------------------------------------------------------------------

#ifdef USE_STACK_SPEW
#pragma check_stack(off)
#endif

STDMETHODIMP
CInput::ContextThunk_InvokeExReady(DISPID dispid,
                        LCID lcid,
                        WORD wFlags,
                        DISPPARAMS *pdispparams,
                        VARIANT *pvarResult,
                        EXCEPINFO *pexcepinfo,
                        IServiceProvider *pSrvProvider)
{
    IUnknown * pUnkContext;

    // Magic macro which pulls context out of nowhere (actually eax)
    CONTEXTTHUNK_SETCONTEXT

    HRESULT  hr = S_OK;

    if (GetType() == htmlInputImage)
    {
        Assert(_pImage);

        hr = THR(ValidateInvoke(pdispparams, pvarResult, pexcepinfo, NULL));
        if (hr)
            goto Cleanup;

        hr = THR_NOTRACE(ReadyStateInvoke(
                                            dispid,
                                            wFlags,
                                            _pImage->_readyStateFired,
                                            pvarResult));
    }
    hr = THR_NOTRACE(super::ContextInvokeEx(
                                dispid,
                                lcid,
                                wFlags,
                                pdispparams,
                                pvarResult,
                                pexcepinfo,
                                pSrvProvider,
                                pUnkContext ? pUnkContext : (IUnknown*)this));

Cleanup:
    RRETURN(hr);
}

#ifdef USE_STACK_SPEW
#pragma check_stack(on)
#endif

//+-------------------------------------------------------------------------
//
//  Method:     CInput::ShowTooltip
//
//  Synopsis:   Displays the tooltip for the site.
//
//  Arguments:  [pt]    Mouse position in container window coordinates
//              msg     Message passed to tooltip for Processing
//
//--------------------------------------------------------------------------

HRESULT
CInput::ShowTooltip(CMessage *pmsg, POINT pt)
{
    HRESULT hr = S_FALSE;
    CDoc *pDoc = Doc();

    if (pDoc->_pInPlace == NULL)
        goto Cleanup;

    // check to see if tooltip should display the title property
    //
    hr = THR(super::ShowTooltip(pmsg, pt));
    if (hr == S_OK || GetType() != htmlInputImage)
        goto Cleanup;

    Assert(_pImage);
    hr = _pImage->ShowTooltip(pmsg, pt);

Cleanup:
    RRETURN1 (hr, S_FALSE);
}

void
CInput::Passivate()
{
    if (_pImage)
    {
        _pImage->Passivate();
        delete _pImage;
        _pImage = NULL;
    }

    switch (GetType())
    {
    case htmlInputButton:
    case htmlInputSubmit:
    case htmlInputReset:
    case htmlInputFile:
    case htmlInputText:
    case htmlInputPassword:
    case htmlInputHidden:
        if (HasSlavePtr())
        {
            CElement * pElemSlave = GetSlavePtr();

            // Stop listening to events on the slave
            SetupSlaveEventSink(FALSE, pElemSlave);
        }
        break;
    }

    super::Passivate();
}

HRESULT
CInput::PrivateInit2()
{
    HRESULT     hr = S_OK;
    htmlInput   type = GetType();
    UINT    uiBtnDefault    = IDS_BUTTONCAPTION_SUBMIT;
    TCHAR   pszCaption[128];
    int     c;

    switch (type)
    {
    case htmlInputReset:
        uiBtnDefault = IDS_BUTTONCAPTION_RESET;
        // fall through
    case htmlInputSubmit:
        if (_fHasInitValue || TLS(nUndoState) != UNDO_BASESTATE)
            break;
        c = LoadString(GetResourceHInst(),
                   uiBtnDefault, pszCaption, ARRAY_SIZE(pszCaption));
        if (c)
        {
            hr = THR(SetValueHelper(pszCaption, c));
            if (hr)
                goto Cleanup;
        }
        break;
    case htmlInputFile:
        {
            //remove initital value from input file
            // set value to a empty string
            // ascii only
            // not OM
            if (TLS(nUndoState) == UNDO_BASESTATE)
                hr = SetValueHelperReal(_T(""), 0, TRUE, FALSE);
        }
        // fall through
    case htmlInputText:
    case htmlInputPassword:
        _fReadOnly = !!GetAAreadOnly();
        break;
    }

    // Do we need to create a inner element?
    if (!IsOptionButton() && type != htmlInputImage && !HasSlavePtr())
    {
        hr = THR(CreateSlave());
        if (hr)
            goto Cleanup;
    }

    // If we are in the middle of an undo operation, trust that the undo
    // queue has enough information to restore the value.
    if (!_fHasMorphed && _fHasInitValue && TLS(nUndoState) == UNDO_BASESTATE)
    {
        hr = SetValueHelper((TCHAR *) _cstrDefaultValue,
                            _cstrDefaultValue.Length(), FALSE);
        if (hr)
            goto Cleanup;
    }

    _fTextChanged = FALSE;

Cleanup:

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CInput::CreateSlave
//
//  Synopsis:   Creates the slave element for the input
//
//--------------------------------------------------------------------------
HRESULT
CInput::CreateSlave()
{
    CMarkup *       pInputMarkup = NULL;
    CElement  *     pElemSlave = NULL;
    CDoc *          pDoc = Doc();
    HRESULT         hr = S_OK;

    Assert(!HasSlavePtr());

    hr = THR(pDoc->CreateMarkup( &pInputMarkup, GetWindowedMarkupContext(), TRUE));
    if (hr)
        goto Cleanup;
    pElemSlave = pInputMarkup->Root();
    SetViewSlave(pElemSlave);
    pInputMarkup->Release();
    pInputMarkup = NULL;

    // Transfer ownership of the owns runs bit from element-owner to element-content
    pElemSlave->_fOwnsRuns = _fOwnsRuns;
    _fOwnsRuns = FALSE;

    // Listen to all events on the slave
    SetupSlaveEventSink(TRUE, pElemSlave);

Cleanup:
    if( pInputMarkup )
        pInputMarkup->Release();

    RRETURN(hr);
}

//HACKHACK 47681 : ignore height/width for inputs/no image
//+-------------------------------------------------------------------------
//
//  Method:     CInput::GetDispID
//
//  Synopsis:   need to ignore height and width
//
//--------------------------------------------------------------------------

STDMETHODIMP
CInput::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT         hr = S_OK;
    STRINGCOMPAREFN pfnCompareString = (grfdex & fdexNameCaseSensitive)
                                                   ? StrCmpC : StrCmpIC;

    if (GetType() != htmlInputImage &&
        (pfnCompareString(s_propdescCInputheight.a.pstrName, bstrName) == 0 ||
        pfnCompareString(s_propdescCInputwidth.a.pstrName, bstrName) == 0))
    {
        // ignore height and width
        if (grfdex & fdexNameEnsure)
        {
            hr = AddExpando(bstrName, pid);
        }
        else
        {
            *pid = DISPID_UNKNOWN;
            hr  = DISP_E_UNKNOWNNAME;
        }
    }
    else
    {
        hr = THR_NOTRACE(super::GetDispID(bstrName, grfdex, pid));
    }
    
    RRETURN(hr);
}

// end of HACKHACK 47681 -> remmeber removing map to in inputtxt.pdl

//+--------------------------------------------------------------
//
//  Member:     CInput::AddRadioGroup(LPCTSTR lpstrGrpName);
//
//  Synopsis:   Add a new radio group name,
//
//              S_OK:       name added
//              S_FALSE:    the name is already there
//
//---------------------------------------------------------------
HRESULT
CInput::AddRadioGroup(LPCTSTR lpstrGrpName)
{
    CFormElement *pForm      = GetParentForm();
    CMarkup      *pMarkup    = GetMarkup(); Assert(pMarkup);
    RADIOGRPNAME *pGroupName = pForm ? pForm->_pRadioGrpName : pMarkup->GetRadioGroupName();
    RADIOGRPNAME *pNew;
    RADIOGRPNAME *pPrev = 0;
    int          iCompResult = 1;

    if (!lpstrGrpName || !lpstrGrpName[0])
        return S_FALSE;

    while (pGroupName)
    {
        iCompResult = FormsStringICmp(lpstrGrpName, pGroupName->lpstrName);
        if (iCompResult == 0)
            return S_FALSE;

        // the new one should be inserted in the order
        if (iCompResult < 0)
            break;

        pPrev = pGroupName;
        pGroupName = pGroupName->_pNext;
    }

    pNew = new RADIOGRPNAME();
    if (!pNew)
        return E_OUTOFMEMORY;

    pNew->lpstrName =SysAllocString(lpstrGrpName);
    if (!pNew->lpstrName)
    {
        delete pNew;
        return E_OUTOFMEMORY;
    }

    if (pPrev)
    {
        pPrev->_pNext = pNew;
    }
    else
    {
        if (pForm)
        {
            pForm->_pRadioGrpName = pNew;
        }
        else
        {
            pMarkup->SetRadioGroupName(pNew);
        }
    }

    pNew->_pNext = pGroupName;

    return S_OK;
}

//+--------------------------------------------------------------
//
//  Member:     CInput::DelRadioGroup(LPCTSTR lpstrGrpName);
//
//  Synopsis:   delete a radio group name,
//
//              S_OK:       name deleted
//              S_FALSE:    name not found
//
//---------------------------------------------------------------
HRESULT
CInput::DelRadioGroup(LPCTSTR lpstrGrpName)
{
    CMarkup      *pMarkup    = GetMarkup(); Assert(pMarkup);
    CFormElement *pForm      = GetParentForm();
    RADIOGRPNAME *pGroupName = pForm ? pForm->_pRadioGrpName : pMarkup->GetRadioGroupName();
    RADIOGRPNAME *pPrev      = 0;
    int          iCompResult = 1;

    if (!lpstrGrpName || !lpstrGrpName[0])
        return S_FALSE;

    while (pGroupName)
    {
        iCompResult = FormsStringICmp(lpstrGrpName, pGroupName->lpstrName);
        if (iCompResult == 0)
        {
            if (pPrev)
            {
                pPrev->_pNext = pGroupName->_pNext;
            }
            else
            {
                if (pForm)
                {
                    pForm->_pRadioGrpName = pGroupName->_pNext;
                }
                else
                {
                    pMarkup->SetRadioGroupName(pGroupName->_pNext);
                }
            }
            SysFreeString((BSTR)pGroupName->lpstrName);
            delete pGroupName;
            return S_OK;
        }

        if (iCompResult < 0)
            return S_FALSE;

        pPrev = pGroupName;
        pGroupName = pGroupName->_pNext;
    }

    return S_FALSE;
}


//+--------------------------------------------------------------
//
//  Member:     CInput::ChkRadioGroup(LPCTSTR lpstrGrpName);
//
//  Synopsis:   Check to see if the radio group is already there
//
//              S_OK:       yes
//              S_FALSE:    no
//
//---------------------------------------------------------------
HRESULT
CInput::ChkRadioGroup(LPCTSTR lpstrGrpName)
{
    CMarkup      *pMarkup    = GetMarkup(); Assert(pMarkup);
    CFormElement *pForm      = GetParentForm();
    RADIOGRPNAME *pGroupName = pForm ? pForm->_pRadioGrpName : pMarkup->GetRadioGroupName();
    int          iCompResult = 1;

    if (!lpstrGrpName || !lpstrGrpName[0])
        return S_OK;

    while (pGroupName)
    {
        iCompResult = FormsStringICmp(lpstrGrpName, pGroupName->lpstrName);
        if (iCompResult == 0)
            return S_OK;

        if (iCompResult < 0)
            return S_FALSE;
        pGroupName = pGroupName->_pNext;
    }

    return S_FALSE;
}


HRESULT
CInput::TraverseGroup(LPCTSTR strGroupName, PFN_VISIT pfn, DWORD_PTR dw, BOOL fForward)
{
    HRESULT hr = S_OK;

    // get the form this lives on
    //
    CFormElement * pForm = GetParentForm();

    if (pForm)
    {
        hr = THR(pForm->FormTraverseGroup(strGroupName, pfn, dw, fForward));
    }
    else
    {
        // Let the markup handle it
        
        CMarkup * pMarkup = GetMarkup();

        if (pMarkup)
            hr = THR(pMarkup->MarkupTraverseGroup(strGroupName, pfn, dw, fForward));
    }
    RRETURN1(hr, S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CInput::SetIndeterminateHelper, GetIndeterminateHelper
//
//  Synopsis:   Helper function to get/set Indeterminate
//
//--------------------------------------------------------------------------

HRESULT
CInput::SetIndeterminateHelper(long indeterminate)
{
    _wBtnStatus = (indeterminate==VB_TRUE)?
                    BTN_SETSTATUS(_wBtnStatus, FLAG_TRISTATE) :
                    BTN_RESSTATUS(_wBtnStatus, FLAG_TRISTATE);

    if ((GetType() == htmlInputCheckbox) && !TLS(fInInitAttrBag))
    {
        GetUpdatedLayout()->Invalidate();
    }

    return S_OK;
}

HRESULT
CInput::GetIndeterminateHelper(long * pindeterminate)
{
    *pindeterminate = BTN_GETSTATUS(_wBtnStatus, FLAG_TRISTATE)?VB_TRUE:VB_FALSE;

    return S_OK;
}

void
CInput::SetupSlaveEventSink(BOOL fAdvise, CElement * pElemSlave)
{
    Assert(pElemSlave);
    Assert(!fAdvise || pElemSlave == GetSlavePtr());

    if (fAdvise)
    {
        pElemSlave->DoAdvise(DIID_HTMLElementEvents, DISPID_A_EVENTSINK, &_SinkSlaveEvent, NULL, NULL);
        pElemSlave->SetEventsShouldFire();
    }
    else
    {
        pElemSlave->DoUnadvise(&_SinkSlaveEvent, DISPID_A_EVENTSINK);
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////
/// CSinkSlaveEvent
///

HRESULT
CSinkSlaveEvent::Invoke(
                        DISPID dispidMember,
                        REFIID riid,
                        LCID lcid,
                        WORD wFlags,
                        DISPPARAMS * pdispparams,
                        VARIANT * pvarResult,
                        EXCEPINFO * pexcepinfo,
                        UINT * puArgErr)
{
    HRESULT                 hr              = S_OK;
    CElement *              pElemMaster     = CONTAINING_RECORD(this, CInput, _SinkSlaveEvent);
    CTreeNode *             pNodeMaster     = pElemMaster->GetFirstBranch();
    CElement *              pElemSlave      = pElemMaster->GetSlavePtr();

    Assert(pElemMaster->HasSlavePtr());

    CTreeNode *             pNodeSlave      = pElemSlave->GetFirstBranch();
    EVENTPARAM *            pParam          = pElemMaster->Doc()->_pparam;
    CStr                    strEventName;
    const PROPERTYDESC *    pPropDesc       = NULL;

    if (!pNodeMaster)
        goto Cleanup;

    hr = strEventName.Set(_T("on"));
    if (hr)
        goto Cleanup;

    Assert(pParam);
    hr = strEventName.Append(pParam->GetType());
    if (hr)
        goto Cleanup;

    pPropDesc = pElemMaster->FindPropDescForName(strEventName);

    // Don't fire the mouse transition events; these are taken care
    // of by the general viewlink logic in FireStdEventOnMessage for
    // WM_MOUSEOVER and WM_MOUSELEAVE
    switch (pPropDesc->GetDispid())
    {
    case DISPID_EVPROP_ONMOUSEOVER:
    case DISPID_EVPROP_ONMOUSEOUT:
    case DISPID_EVPROP_ONMOUSEENTER:
    case DISPID_EVPROP_ONMOUSELEAVE:
        goto Cleanup;
    }

    // Transform the event paramater from slave to master
    pParam->SetNodeAndCalcCoordinates(pNodeMaster, TRUE);
    if (pParam->_pNodeFrom == pNodeSlave)
    {
        pParam->_pNodeFrom = pNodeMaster;
    }
    if (pParam->_pNodeTo == pNodeSlave)
    {
        pParam->_pNodeTo = pNodeMaster;
    }
    if (pParam->_pElement)
    {
        pParam->_pElement->SubRelease();
        pParam->_pElement = pElemMaster;
        pElemMaster->SubAddRef();
    }

    // Fire the event on the master
    hr = pElemMaster->FireEvent(
            // SRamani says that this cast is "safe"
            (const PROPERTYDESC_BASIC *)pPropDesc,
            FALSE,
            pNodeMaster,
            0);

    V_VT(pvarResult) = VT_BOOL;
    V_BOOL(pvarResult) = (hr == S_FALSE) ? VB_TRUE : VB_FALSE;

Cleanup:
    RRETURN1(hr, S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\builtin\inputbtn.cxx ===
//+---------------------------------------------------------------------
//
//   File:      inputbtn.cxx
//
//  Contents:   InputBtn element class, etc..
//
//  Classes:    CButton, etc..
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_POSTDATA_HXX_
#define X_POSTDATA_HXX_
#include "postdata.hxx"
#endif

#ifndef X_BTNHLPER_HXX_
#define X_BTNHLPER_HXX_
#include "btnhlper.hxx"
#endif

#ifndef X_INPUTBTN_HXX_
#define X_INPUTBTN_HXX_
#include "inputbtn.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_BTNHLPER_HXX_
#define X_BTNHLPER_HXX_
#include "btnhlper.hxx"
#endif

#ifndef X_INPUTLYT_HXX_
#define X_INPUTLYT_HXX_
#include "inputlyt.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_IRANGE_HXX_
#define X_IRANGE_HXX_
#include "irange.hxx"
#endif

#ifndef X_EFORM_HXX_
#define X_EFORM_HXX_
#include "eform.hxx"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef X_BTNLYT_H_
#define X_BTNLYT_H_
#include <btnlyt.hxx>
#endif

#define _cxx_
#include "inputbtn.hdl"

MtDefine(CButton, Elements, "CButton")

const CElement::CLASSDESC CButton::s_classdescButtonReset =
{
    {
        &CLSID_HTMLButtonElement,       // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_CANCEL |            // _dwFlags, button/reset is a cancel button
        ELEMENTDESC_NOTIFYENDPARSE |
        ELEMENTDESC_NOANCESTORCLICK |
        ELEMENTDESC_NEVERSCROLL     |   // don't scroll a button
        ELEMENTDESC_HASDEFDESCENT,
        &IID_IHTMLButtonElement,        // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLButtonElement,   // _pfnTearOff
    NULL                                // _pAccelsRun
};

const CElement::CLASSDESC CButton::s_classdescButtonSubmit =
{
    {
        &CLSID_HTMLButtonElement,       // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_DEFAULT |           // _dwFlags, button/submit is a default button
        ELEMENTDESC_NOTIFYENDPARSE |
        ELEMENTDESC_NOANCESTORCLICK |
        ELEMENTDESC_NEVERSCROLL     |   // don't scroll a button
        ELEMENTDESC_HASDEFDESCENT,
        &IID_IHTMLButtonElement,        // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLButtonElement,   // _pfnTearOff
    NULL                                // _pAccelsRun
};

const CElement::CLASSDESC CButton::s_classdescTagButton =
{
    {
        &CLSID_HTMLButtonElement,       // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_NOTIFYENDPARSE |    // _dwFlags
        ELEMENTDESC_NOANCESTORCLICK |
        ELEMENTDESC_NEVERSCROLL     |   // don't scroll a button
        ELEMENTDESC_HASDEFDESCENT,
        &IID_IHTMLButtonElement,        // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLButtonElement,   // _pfnTearOff
    NULL                                // _pAccelsRun
};

const CBase::CLASSDESC *
CButton::GetClassDesc() const
{
    switch (GetAAtype())
    {
        case htmlInputReset:
            return (CBase::CLASSDESC *)&s_classdescButtonReset;

        case htmlInputSubmit:
            return (CBase::CLASSDESC *)&s_classdescButtonSubmit;

        default:
            return (CBase::CLASSDESC *)&s_classdescTagButton;
    }
}

#ifndef NO_DATABINDING
#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

const CDBindMethods *
CButton::GetDBindMethods()
{
    return &DBindMethodsTextRichRO;
}
#endif

HRESULT
CButton::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(ppElement);

    *ppElement = new CButton(pht->GetTag(), pDoc);

    RRETURN ( (*ppElement) ? S_OK : E_OUTOFMEMORY);
}

HRESULT
CButton::Init2(CInit2Context * pContext)
{
    HRESULT     hr = S_OK;
    htmlInput   type = GetAAtype();

    if (type!=htmlInputReset  && type!=htmlInputSubmit)
    {
        SetAAtype(htmlInputButton);
    }

    hr = THR(super::Init2(pContext));
    if (!OK(hr))
        goto Cleanup;

Cleanup:

    RRETURN1(hr, S_INCOMPLETE);
}



 //+----------------------------------------------------------------------------
//
//  Method:     GetSubmitInfo
//
//  Synopsis:   returns the submit info string if checked
//              (name && value pair)
//
//  Returns:    S_OK if successful
//              S_FALSE if not applicable for current element
//
//-----------------------------------------------------------------------------
HRESULT
CButton::GetSubmitInfo(CPostData * pSubmitData)
{
    CStr            cstrValue;
    const TCHAR *   pchName = GetAAsubmitname();
    HRESULT         hr      = GetSubmitValueHelper(&cstrValue);
    if (hr)
        goto Cleanup;


    hr = THR(pSubmitData->AppendNameValuePair(pchName, cstrValue, GetMarkup()));

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CButton::GetEnabled
//
//  Synopsis:   return not disabled
//
//----------------------------------------------------------------------------

STDMETHODIMP
CButton::GetEnabled(VARIANT_BOOL * pfEnabled)
{
    if (!pfEnabled)
        RRETURN(E_INVALIDARG);

    *pfEnabled = !GetAAdisabled();
    return S_OK;
}

DWORD
CButton::GetNonThemedBorderInfo(
    CDocInfo * pdci,
    CBorderInfo *pborderinfo,
    BOOL fAll,
    BOOL fAllPhysical FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    DWORD   nBorders;

    pborderinfo->abStyles[SIDE_TOP]    =
    pborderinfo->abStyles[SIDE_RIGHT]  =
    pborderinfo->abStyles[SIDE_BOTTOM] =
    pborderinfo->abStyles[SIDE_LEFT]   = BTN_PRESSED(_wBtnStatus)
                                                ? fmBorderStyleSunken
                                                : fmBorderStyleRaised;
    nBorders = super::GetBorderInfo( pdci, pborderinfo, fAll, TRUE FCCOMMA FCPARAM);

    {
        int xyFlatX = 1;
        int xyFlatY = 1;
        if (pdci)
        {
            xyFlatX = pdci->DeviceFromDocPixelsX(xyFlatX);
            xyFlatY = pdci->DeviceFromDocPixelsY(xyFlatY);
        }
        pborderinfo->aiWidths[SIDE_TOP]    += xyFlatY;
        pborderinfo->aiWidths[SIDE_RIGHT]  += xyFlatX;
        pborderinfo->aiWidths[SIDE_BOTTOM] += xyFlatY;
        pborderinfo->aiWidths[SIDE_LEFT]   += xyFlatX;
    }

    if (!fAllPhysical && HasVerticalLayoutFlow())
    {
        pborderinfo->FlipBorderInfo();
    }
    return nBorders;
}

DWORD
CButton::GetBorderInfo(CDocInfo * pdci, CBorderInfo *pborderinfo, BOOL fAll, BOOL fAllPhysical FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    HTHEME  hTheme = GetTheme(THEME_BUTTON);    
    RECT rc;

    if (hTheme)
    {
        if (hTheme && !GetThemeBackgroundExtent(hTheme, NULL, EP_EDITTEXT, ETS_NORMAL, &g_Zero.rc, &rc))
        {            
            pborderinfo->aiWidths[SIDE_LEFT]   = pdci->DeviceFromDocPixelsX(-rc.left);
            pborderinfo->aiWidths[SIDE_RIGHT]  = pdci->DeviceFromDocPixelsX(rc.right);
            pborderinfo->aiWidths[SIDE_TOP]    = pdci->DeviceFromDocPixelsY(-rc.top);
            pborderinfo->aiWidths[SIDE_BOTTOM] = pdci->DeviceFromDocPixelsY(rc.bottom);

            return(DISPNODEBORDER_SIMPLE);
        }

            
    }

    return GetNonThemedBorderInfo( pdci, pborderinfo, fAll, fAllPhysical FCCOMMA FCPARAM);
}


void
CButton::Notify(CNotification *pNF)
{
    super::Notify(pNF);
    switch (pNF->Type())
    {
    case NTYPE_ELEMENT_SETFOCUS:
        _wBtnStatus = BTN_SETSTATUS(_wBtnStatus, FLAG_HASFOCUS);
        break;

    case NTYPE_ELEMENT_ENTERTREE:
        Layout()->SetDisplayWordWrap(FALSE);
        if (GetAAtype() == htmlInputSubmit)
        {
            SetDefaultElem();
        }
        break;

    case NTYPE_ELEMENT_EXITTREE_1:
        if (GetAAtype() == htmlInputSubmit)
        {
            if( pNF->DataAsDWORD() & EXITTREE_DESTROY )
            {
                Doc()->_pElemDefault = NULL;
            }
            else
            {
                SetDefaultElem(TRUE);
            }
        }
        break;
    } 
}


HRESULT
CButton::YieldCurrency(CElement *pElemNew)
{
    HRESULT hr;

    hr = THR(super::YieldCurrency(pElemNew));
    if (hr)
        goto Cleanup;

    _wBtnStatus = BTN_RESSTATUS(_wBtnStatus, FLAG_HASFOCUS);

    // IE bug 33042, see comments in CButtonLayout::GetFocusShape
    if (GetTheme(THEME_BUTTON))
        GetUpdatedLayout(GUL_USEFIRSTLAYOUT)->GetElementDispNode(this)->Invalidate();


Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CButton::GetFocusShape
//
//  Synopsis:   Returns the shape of the focus outline that needs to be drawn
//              when this element has focus. This function creates a new
//              CShape-derived object. It is the caller's responsibility to
//              release it.
//
//----------------------------------------------------------------------------

HRESULT
CButton::GetFocusShape(long lSubDivision, CDocInfo * pdci, CShape ** ppShape)
{
    RRETURN1(Layout()->GetFocusShape(lSubDivision, pdci, ppShape), S_FALSE);
}



HRESULT BUGCALL
CButton::HandleMessage(CMessage * pMessage)
{
    HRESULT hr = S_FALSE;

    if (!CanHandleMessage())
        goto Cleanup;

    if (!IsEditable(TRUE))
    {
        if (!IsEnabled())
        {
            goto Cleanup;
        }

        hr = BtnHandleMessage(pMessage);
        if (hr == S_FALSE)
        {
            hr = super::HandleMessage(pMessage);
        }
    }
    else
    {
        if (pMessage->message == WM_CONTEXTMENU)
        {
            hr = THR(OnContextMenu(
                    (short)LOWORD(pMessage->lParam),
                    (short)HIWORD(pMessage->lParam),
                    CONTEXT_MENU_CONTROL));
        }
        if (hr == S_FALSE)
            hr = super::HandleMessage(pMessage);
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}



HRESULT
CButton::ClickAction(CMessage * pMessage)
{
    HRESULT         hr = S_OK;
    CFormElement *  pForm;

    pForm = GetParentForm();
    if (pForm)
    {
        switch (GetAAtype())
        {
            case htmlInputReset:
                pForm->DoReset(TRUE);
                break;

            case htmlInputSubmit:
                pForm->DoSubmit(this, TRUE);
                break;
        }
    }
    RRETURN1(hr, S_FALSE);
}

int
CButton::GetThemeState()
{
    if (!IsEnabled())
    {
        return PBS_DISABLED;
    }
    else if (Pressed())
    {
        return PBS_PRESSED;
    }
    else if (MouseOver())
    {
        return PBS_HOT;
    }
    else
    {
        CDoc *pDoc = Doc();

        if (    pDoc 
            &&  _fDefault
            &&  pDoc->HasFocus())
        {
            return PBS_DEFAULTED;
        }
    }
    return PBS_NORMAL;
}


HRESULT
CButton::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    HRESULT hr = S_OK;
    LOGFONT lf;
    CUnitValue uvBorder;
    DWORD dwRawValue;
    BYTE i;
    CDoc * pDoc = Doc();
    CUnitValue cuvBorderWidth;
    HTHEME hTheme = GetMarkup()->GetTheme(THEME_BUTTON);
    
    pCFI->PrepareCharFormat();
    pCFI->PrepareFancyFormat();

    // Set default color and let super override it with the use style
    pCFI->_cf()._ccvTextColor.SetSysColor(COLOR_BTNTEXT);
    pCFI->_ff()._ccvBackColor.SetSysColor(COLOR_BTNFACE);

    // our intrinsics shouldn't inherit the cursor property. they have a 'default'
    pCFI->_cf()._bCursorIdx = styleCursorAuto;

    DefaultFontInfoFromCodePage( GetMarkup()->GetCodePage(), &lf, pDoc );
    pCFI->_cf()._wWeight = 400;
    pCFI->_cf()._yHeight = 200; // 10 * 20 twips NS compatibility

    pCFI->_cf()._fBold = FALSE;
    pCFI->_cf()._bCharSet = lf.lfCharSet;
    pCFI->_cf().SetFaceName( lf.lfFaceName);
    pCFI->_cf()._fNarrow = IsNarrowCharSet(pCFI->_cf()._bCharSet);
    if (pCFI->_cf().NeedAtFont())
    {
        ApplyAtFontFace(&pCFI->_cf(), pDoc, GetMarkup());
    }

    pCFI->_bBlockAlign     = htmlBlockAlignCenter;

    // Border info
    uvBorder.SetValue( 2, CUnitValue::UNIT_PIXELS );
    dwRawValue = uvBorder.GetRawValue();

    pCFI->_ff()._bd._ccvBorderColorLight.SetSysColor(COLOR_BTNFACE);
    pCFI->_ff()._bd._ccvBorderColorDark.SetSysColor(COLOR_3DDKSHADOW);
    pCFI->_ff()._bd._ccvBorderColorHilight.SetSysColor(COLOR_BTNHIGHLIGHT);
    pCFI->_ff()._bd._ccvBorderColorShadow.SetSysColor(COLOR_BTNSHADOW);

    // Since its the same value to which X and Y are being set, logical/physical does not matter here.
    pCFI->_ff().SetOverflowX(styleOverflowHidden);
    pCFI->_ff().SetOverflowY(styleOverflowHidden);

    if (pCFI->_cf()._fVisibilityHidden || pCFI->_cf()._fDisplayNone)
        _fButtonWasHidden = TRUE;

    cuvBorderWidth.SetRawValue(dwRawValue);
    for (i = 0; i < SIDE_MAX; i++)
    {
        pCFI->_ff()._bd.SetBorderWidth(i, cuvBorderWidth);
    }

    pCFI->_ff()._bd._bBorderSoftEdges = TRUE;
    // End Border info

    pCFI->UnprepareForDebug();

    hr = THR(super::ApplyDefaultFormat(pCFI));
    if(hr)
        goto Cleanup;
    
    pCFI->PrepareCharFormat();
    pCFI->PrepareFancyFormat();

    if (hTheme && !pCFI->_ff().IsThemeDisabled()) // the control is themed
    {        
        // set theme defaults for properties not already set

        if (!pCFI->_fFontSet && !GetThemeFont(hTheme, NULL, BP_PUSHBUTTON, PBS_NORMAL, TMT_FONT, &lf))
        {
            long twips;

            if (!pCFI->_fFontWeightSet)
                pCFI->_cf()._wWeight = lf.lfWeight;

            if (!pCFI->_fFontHeightSet)
            {
                twips = MulDivQuick( lf.lfHeight, TWIPS_PER_INCH, g_sizePixelsPerInch.cy );

                if(twips < 0)
                    twips = - twips;

                pCFI->_cf().SetHeightInTwips( twips );
            }
        }
    }

    pCFI->_cf().SetHeightInNonscalingTwips( pCFI->_pcf->_yHeight );

    pCFI->UnprepareForDebug();

Cleanup:
    RRETURN(hr);
}

HRESULT
CButton::put_status(VARIANT status)
{
    switch(status.vt)
    {
    case VT_NULL:
        _vStatus.vt = VT_NULL;
        break;
    case VT_BOOL:
        _vStatus.vt = VT_BOOL;
        V_BOOL(&_vStatus) = V_BOOL(&status);
        break;
    default:
        _vStatus.vt = VT_BOOL;
        V_BOOL(&_vStatus) = VB_TRUE;
    }

    Verify(S_OK==OnPropertyChange(DISPID_CButton_status, 
                                  0,
                                  (PROPERTYDESC *)&s_propdescCButtonstatus));

    RRETURN(S_OK);
}

HRESULT
CButton::get_status(VARIANT * pStatus)
{
    HRESULT hr = S_OK;

    if ( !pStatus )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (_vStatus.vt==VT_NULL)
    {
        pStatus->vt = VT_NULL;
    }
    else
    {
        pStatus->vt = VT_BOOL;
        V_BOOL(pStatus) = V_BOOL(&_vStatus);
    }
Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CButton::GetSubmitValueHelper(CStr *pstr)
{
    HRESULT hr = S_OK;
    BSTR    bStrValue;

    hr = THR(GetText(&bStrValue, WBF_NO_WRAP|WBF_NO_TAG_FOR_CONTEXT));
    if (hr)
        goto Cleanup;

    Assert(pstr);
    hr = pstr->SetBSTR(bStrValue);
    FormsFreeString(bStrValue);

Cleanup:
    RRETURN(hr);
}

HRESULT
CButton::GetValueHelper(CStr *pstr)
{
    HRESULT hr = S_OK;
    BSTR    bStrValue = NULL;

    hr = THR(GetText(&bStrValue, WBF_NO_WRAP|WBF_NO_TAG_FOR_CONTEXT));
    if (hr)
        goto Cleanup;

    // HACK: if it is an empty string or null, see if value is set as an expando attribute
    // since value is only a property and not an attribute, it gets set as an expando
    // declaratively.
    if ((!bStrValue || !*bStrValue) && _pAA)
    {
        DISPID dispid;
        hr = THR(GetExpandoDISPID(_T("value"), &dispid, 0));
        if (!hr)
        {
            LPTSTR pchValue = NULL;
            _pAA->FindString(dispid, (LPCTSTR *)&pchValue, CAttrValue::AA_Expando);
            pstr->Set(pchValue);
            goto Cleanup;
        }
    }

    Assert(pstr);
    hr = pstr->SetBSTR(bStrValue);

Cleanup:
    FormsFreeString(bStrValue);
    RRETURN(hr);
}

HRESULT
CButton::SetValueHelper(CStr *pstr)
{
    HRESULT hr = S_OK;
    
    Assert( pstr );

    hr = THR( Inject( Inside, TRUE, *pstr, pstr->Length() ) );

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CButton::createTextRange
//
//----------------------------------------------------------------------------

HRESULT
CButton::createTextRange( IHTMLTxtRange * * ppDisp )
{
    HRESULT hr = S_OK;

    hr = THR( EnsureInMarkup() );
    
    if (hr)
        goto Cleanup;

    hr = THR( GetMarkup()->createTextRange( ppDisp, this ) );
    
    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( SetErrorInfo( hr ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\builtin\tableom.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       tableom.cxx
//
//  Contents:   CTable object model and interface implementations
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include <formkrnl.hxx>
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_LTROW_HXX_
#define X_LTROW_HXX_
#include "ltrow.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include <treepos.hxx>
#endif

#ifndef X_CLRNGPRS_HXX_
#define X_CLRNGPRS_HXX_
#include <clrngprs.hxx>
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_UNDO_HXX_
#define X_UNDO_HXX_
#include "undo.hxx"
#endif

#if defined(_M_ALPHA)
#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif
#endif

//+---------------------------------------------------------------------------
//
//  Member: IHTMLTable::createTHead
//
//  Synopsis:   Table OM method implementation
//
//  Arguments:  ppHead - return value
//
//----------------------------------------------------------------------------

HRESULT
CTable::createTHead(IDispatch** ppHead)
{
    HRESULT     hr = S_OK;

    if (ppHead)
    {
        *ppHead = NULL;
    }

    if (IsDataboundInBrowseMode())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    hr = TableLayoutCache()->createTHead(ppHead);

Cleanup:

    RRETURN(SetErrorInfo( hr ));
}



//+---------------------------------------------------------------------------
//
//  Member: IHTMLTable::deleteTHead
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTable::deleteTHead()
{
    HRESULT     hr = S_OK;

    if (IsDataboundInBrowseMode())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    hr = TableLayoutCache()->deleteTHead();

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}



//+---------------------------------------------------------------------------
//
//  Member: IHTMLTable::createTFoot
//
//  Synopsis:   Table OM method implementation
//
//  Arguments:  ppFoot - return value
//
//----------------------------------------------------------------------------

HRESULT
CTable::createTFoot(IDispatch** ppFoot)
{
    HRESULT     hr = S_OK;

    if (ppFoot)
    {
        *ppFoot = NULL;
    }

    if (IsDataboundInBrowseMode())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    hr = TableLayoutCache()->createTFoot(ppFoot);

Cleanup:

    RRETURN(SetErrorInfo( hr ));
}


//+---------------------------------------------------------------------------
//
//  Member: IHTMLTable::deleteTFoot
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTable::deleteTFoot()
{
    HRESULT     hr = S_OK;

    if (IsDataboundInBrowseMode())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    hr = TableLayoutCache()->deleteTFoot();

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+---------------------------------------------------------------------------
//
//  Member: IHTMLTable :: createCaption
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTable::createCaption(IHTMLTableCaption** ppCaption)
{
    HRESULT         hr = S_OK;

    if (ppCaption)
    {
        *ppCaption = NULL;
    }

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    hr = TableLayoutCache()->createCaption(ppCaption);

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}



//+---------------------------------------------------------------------------
//
//  Member: IHTMLTable :: deleteCaption
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTable::deleteCaption()
{
    HRESULT         hr;

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    hr = TableLayoutCache()->deleteCaption();

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+---------------------------------------------------------------------------
//
//  Member: IHTMLTable::get_tHead
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTable::get_tHead(IHTMLTableSection** ppHead)
{
    CTableLayout * pTableLayout;
    HRESULT hr;

    if (!ppHead)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppHead = NULL;

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    pTableLayout = TableLayoutCache();
    hr = pTableLayout->EnsureTableLayoutCache();

    if (hr)
        goto Cleanup;

    if (pTableLayout->_pHead)
    {
        hr = pTableLayout->_pHead->QueryInterface(IID_IHTMLTableSection, (void **)ppHead);
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+---------------------------------------------------------------------------
//
//  Member: IHTMLTable::get_tFoot
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTable::get_tFoot(IHTMLTableSection ** ppFoot)
{
    CTableLayout * pTableLayout = TableLayoutCache();
    HRESULT hr = S_OK;

    if (!ppFoot)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppFoot = NULL;

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    hr = pTableLayout->EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    if (pTableLayout->_pFoot)
    {
        hr = pTableLayout->_pFoot->QueryInterface(IID_IHTMLTableSection, (void **)ppFoot);
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+---------------------------------------------------------------------------
//
//  Member: IHTMLTable::get_rows
//
//  Synopsis:   Table OM method implementation. Return the rows collection
//
//----------------------------------------------------------------------------

HRESULT
CTable::get_rows(IHTMLElementCollection ** ppRows)
{
    HRESULT hr;

    if (!ppRows)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppRows = NULL;

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    // Create a collection cache if we don't already have one.
    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->EnsureAry(TABLE_ROWS_COLLECTION));
    if ( hr )
        goto Cleanup;

    hr = THR(_pCollectionCache->GetDisp(TABLE_ROWS_COLLECTION, (IDispatch **)ppRows));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member: IHTMLTable::get_tBodies
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTable::get_tBodies(IHTMLElementCollection ** ppSections)
{
    HRESULT hr;

    if (!ppSections)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    *ppSections = NULL;

    // Create a collection cache if we don't already have one.
    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->EnsureAry(TABLE_BODYS_COLLECTION));
    if ( hr )
        goto Cleanup;

    hr = THR(_pCollectionCache->GetDisp(TABLE_BODYS_COLLECTION, (IDispatch **)ppSections));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}



//+---------------------------------------------------------------------------
//
//  Member: IHTMLTable::get_caption
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTable::get_caption(IHTMLTableCaption **ppCaption)
{
    HRESULT     hr = S_OK;
    CTableCaption * pCaption;
    CTableLayout *  pTableLayout;

    if (!ppCaption)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppCaption = NULL;

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    pTableLayout = TableLayoutCache();
    hr = pTableLayout->EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    pCaption = pTableLayout->GetFirstCaption();

    if (pCaption)
    {
        hr = THR(pCaption->QueryInterface(IID_IHTMLTableCaption ,(void **)ppCaption));
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+---------------------------------------------------------------------------
//
//  Member: IHTMLTableSection::get_rows
//
//  Synopsis:   Table OM method implementation. Return the rows collection
//
//----------------------------------------------------------------------------

HRESULT
CTableSection::get_rows(IHTMLElementCollection ** ppRows)
{
    HRESULT hr;

    if (!ppRows)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppRows = NULL;

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    // Create a collection cache if we don't already have one.
    hr = THR(EnsureCollectionCache(ROWS_COLLECTION));
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->GetDisp(ROWS_COLLECTION, (IDispatch **)ppRows));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+---------------------------------------------------------------------------
//
//  Member: IHTMLTable2::cells
//
//  Synopsis:   Table OM 
//
//----------------------------------------------------------------------------

HRESULT
CTable::get_cells(IHTMLElementCollection ** ppCells)
{
    HRESULT hr;

    if (!ppCells)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppCells = NULL;

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    // do the work to get the Cells Collection
    // Create a collection cache if we don't already have one.
    hr = THR(EnsureCollectionCache());  // TABLE_CELL_COLLECTION
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->GetDisp(TABLE_CELLS_COLLECTION, (IDispatch**)ppCells));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}



//+---------------------------------------------------------------------------
//
//  Member: IHTMLTable2::cells
//
//  Synopsis:   Table OM method implementation. Return the cells collection
//
//----------------------------------------------------------------------------

HRESULT
CTable::cells(BSTR szRange, IHTMLElementCollection ** ppCells)
{
    HRESULT hr;
    CStr                    strNormRange;

    if (!ppCells)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppCells = NULL;

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    if(_tcslen(szRange) == 0)
    {

        // Return the whole collection
        hr = THR(_pCollectionCache->GetDisp(TABLE_CELLS_COLLECTION, (IDispatch**)ppCells));
    }
    else
    {
        CCellRangeParser        cellRangeParser(szRange);
        RECT                    rectRange;

        if(cellRangeParser.Failed())
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        strNormRange.Set(cellRangeParser.GetNormalizedRangeName());

        // do the work to get the Cells Collection
        // Create a collection cache if we don't already have one.
        hr = THR(EnsureCollectionCache());
        if (hr)
            goto Cleanup;

        cellRangeParser.GetRangeRect(&rectRange);

        hr = THR(_pCollectionCache->EnsureAry(TABLE_CELLS_COLLECTION));
        if (hr)
            goto Cleanup;

        hr = THR(_pCollectionCache->GetDisp(TABLE_CELLS_COLLECTION,  strNormRange,
                        CacheType_CellRange, (IDispatch**)ppCells, FALSE, &rectRange));
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+---------------------------------------------------------------------------
//
//  Member:     IHTMLTable::insertRow
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTable::insertRow(long iRow, IDispatch **ppRow)
{
    HRESULT         hr;
    CTableSection * pSection;
    CTableLayout *  pTableLayout = TableLayoutCache();
    int             cRows;

    if (ppRow)
    {
        *ppRow = NULL;
    }

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    hr = pTableLayout->EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    cRows = pTableLayout->GetRows();

    if (iRow < - 1 || iRow > cRows)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    if (IsDataboundInBrowseMode())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (iRow == -1 || iRow == cRows)
    {
        hr = pTableLayout->ensureTBody();
        if (hr)
            goto Cleanup;

        if (!pTableLayout->HasBody())
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        pSection = pTableLayout->_aryBodys[max(0, (pTableLayout->_aryBodys.Size() - 1))];

        if (cRows && pTableLayout->_pFoot)
        {
            pSection = pTableLayout->_pFoot;
        }

        if (!pSection)
        {
            hr = S_OK;
            goto Cleanup;
        }

        iRow = pSection->_cRows;    // insert after the last row
    }
    else
    {
        iRow = pTableLayout->VisualRow2Index(iRow);
        pSection = pTableLayout->GetRow(iRow)->Section();
        if (!pSection)
        {
            hr = S_OK;
            goto Cleanup;
        }
        iRow -= pSection->_iRow;    // relative to the section row index
    }

    Assert(pSection);
    hr = pSection->insertRow(iRow, ppRow);

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+---------------------------------------------------------------------------
//
//  Member:     IHTMLTable::deleteRow
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTable::deleteRow(long iRow)
{
    CTableRow *     pRowDelete;
    CTableLayout *  pTableLayout = TableLayoutCache();
    int             cRows;
    HRESULT         hr;
    BOOL            fIncrementalUpdatePossible;

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    hr = pTableLayout->EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    cRows = pTableLayout->GetRows();

    if (iRow == -1)
    {
        iRow = pTableLayout->GetRows() - 1;
    }

    if (iRow < 0 || iRow >= cRows)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (IsDataboundInBrowseMode())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    iRow = pTableLayout->VisualRow2Index(iRow);

    pRowDelete = pTableLayout->_aryRows[iRow];
    Assert (pRowDelete);

    fIncrementalUpdatePossible = !pRowDelete->_fCrossingRowSpan       && 
                                  pTableLayout->_fAllRowsSameShape    && 
                                  pTableLayout->_aryRows.Size() != 1  && 
                                 !pRowDelete->_fParentOfTC;

    hr = pTableLayout->deleteElement(pRowDelete, fIncrementalUpdatePossible);

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+---------------------------------------------------------------------------
//
//  Member:     IHTMLTable2::moveRow, moveRowHelper
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTable::moveRow(long iRow, long iRowTarget, IDispatch **ppRow)
{
    RRETURN(moveRowHelper(iRow, iRowTarget, ppRow));
}

HRESULT
CTable::moveRowHelper(long iRow, long iRowTarget, IDispatch **ppRow, BOOL fConvertRowIndices)
{
    CTableLayout    * pTableLayout;
    CTableRow       * pRowMoving = NULL;
    CTableRow       * pRowNeighbor;
    IHTMLElement    * pElemMoving = NULL;
    IHTMLElement    * pElemNeighbor = NULL;
    IMarkupServices * pMarkupServices = NULL;
    CDoc            * pDoc;
    IMarkupPointer  * pmpRowMovingBegin = NULL;
    IMarkupPointer  * pmpRowMovingEnd = NULL;
    IMarkupPointer  * pmpRowTarget = NULL;
    int               cRows;
    BOOL              fMoveToEnd = FALSE;
    HRESULT           hr = S_OK;

    if (IsDataboundInBrowseMode())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (ppRow)
    {
        *ppRow = NULL;
    }

    if (iRow == iRowTarget)
        goto Cleanup;

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    pTableLayout = TableLayoutCache();
    hr = pTableLayout->EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    cRows = pTableLayout->GetRows();

    if (iRow == -1)
        iRow = cRows-1;
    if (iRowTarget == -1)
        iRowTarget = cRows-1;

    if (   iRow < 0 || iRow >= cRows
        || iRowTarget < 0 || iRowTarget >= cRows)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (iRow == iRowTarget)
        goto Cleanup;

    // If row is moved down and since it is to become row number iRowTarget,
    // we need to add the number of rows disappearing to the bottom index.
    if (iRow < iRowTarget)
        iRowTarget += 1; // c

    if (iRowTarget >= cRows)
    {
        fMoveToEnd = TRUE;
        iRowTarget = cRows-1;
    }

    // Convert visual row index to internal row index.
    if (fConvertRowIndices)
    {
        iRow = pTableLayout->VisualRow2Index(iRow);
        iRowTarget = pTableLayout->VisualRow2Index(iRowTarget);
    }

    pRowMoving = pTableLayout->GetRow(iRow);
    pRowNeighbor = pTableLayout->GetRow(iRowTarget);
    pDoc = Doc();

    Assert(pRowMoving && pRowNeighbor && pDoc);

    hr = THR(pDoc->QueryInterface(IID_IMarkupServices, (LPVOID *) &pMarkupServices));
    if (hr)
        goto Cleanup;

    hr = THR(pMarkupServices->CreateMarkupPointer(&pmpRowMovingBegin));
    if (hr)
        goto Cleanup;

    hr = THR(pMarkupServices->CreateMarkupPointer(&pmpRowMovingEnd));
    if (hr)
        goto Cleanup;

    hr = THR(pMarkupServices->CreateMarkupPointer(&pmpRowTarget));
    if (hr)
        goto Cleanup;

    hr = THR(pRowMoving->QueryInterface(IID_IHTMLElement, (LPVOID *) &pElemMoving));
    if (hr)
        goto Cleanup;

    hr = THR(pRowNeighbor->QueryInterface(IID_IHTMLElement, (LPVOID *) &pElemNeighbor));
    if (hr)
        goto Cleanup;

    hr = THR(pmpRowMovingBegin->MoveAdjacentToElement(pElemMoving, ELEM_ADJ_BeforeBegin));
    if (hr)
        goto Cleanup;

    hr = THR(pmpRowMovingEnd->MoveAdjacentToElement(pElemMoving, ELEM_ADJ_AfterEnd));
    if (hr)
        goto Cleanup;

    hr = THR(pmpRowTarget->MoveAdjacentToElement(pElemNeighbor, fMoveToEnd?ELEM_ADJ_AfterEnd:ELEM_ADJ_BeforeBegin));
    if (hr)
        goto Cleanup;

    hr = THR(pTableLayout->moveElement(pMarkupServices, pmpRowMovingBegin, pmpRowMovingEnd, pmpRowTarget));

Cleanup:

    if (!hr && ppRow && pRowMoving)
    {
        hr = THR(pRowMoving->QueryInterface(IID_IDispatch, (LPVOID *) ppRow));
    }

    ReleaseInterface(pElemMoving);
    ReleaseInterface(pElemNeighbor);
    ReleaseInterface(pMarkupServices);

    ReleaseInterface(pmpRowMovingBegin);
    ReleaseInterface(pmpRowMovingEnd);
    ReleaseInterface(pmpRowTarget);

    RRETURN(hr);
}


//*********************************************************************
// CTable::GetDispID, IDispatch
//
//*********************************************************************

STDMETHODIMP
CTable::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT         hr;
    LONG            lDisp;

    // Now let CBase to search for the dispid
    hr = THR_NOTRACE(super::GetDispID(bstrName, grfdex, pid));

    if(hr == DISP_E_UNKNOWNNAME)
    {
        // This may be a tbl["a3:c6"] syntax, check of presence of the : or ..
        if(_tcschr(bstrName, _T(':')) || _tcsstr(bstrName, _T("..")))
        {
            // Create an atom to pass the string to the Invoke
            CAtomTable * pTable = GetAtomTable();
            hr = THR_NOTRACE(pTable->AddNameToAtomTable(bstrName, &lDisp));
            if(hr)
                goto Cleanup;
            lDisp += DISPID_COLLECTION_MIN;
            *pid = lDisp;
        }
    }

Cleanup:
    RRETURN1(hr, DISP_E_UNKNOWNNAME);
}


#ifdef USE_STACK_SPEW
#pragma check_stack(off)
#endif

HRESULT
CTable::ContextThunk_InvokeEx (DISPID dispid, LCID lcid, WORD wFlags, DISPPARAMS *    pdispparams,
    VARIANT * pvarResult, EXCEPINFO *pexcepinfo, IServiceProvider *pSrvProvider)
{
    IUnknown * pUnkContext;
    HRESULT    hr;

    // Magic macro which pulls context out of nowhere (actually eax)
    CONTEXTTHUNK_SETCONTEXT

    if(dispid >= DISPID_COLLECTION_MIN && 
       dispid <= DISPID_COLLECTION_MAX)
    {
        CAtomTable * pTable = GetAtomTable();
        IHTMLElementCollection * pCol;
        const TCHAR            * pProrName;
        BSTR                     bstrName;
        
        hr = THR(pTable->GetNameFromAtom (dispid - DISPID_COLLECTION_MIN, &pProrName));
        if(hr)
            goto Cleanup;
        hr = THR(FormsAllocString(pProrName, &bstrName));
        if(hr)
            goto Cleanup;
        hr = THR(cells(bstrName, &pCol));
        FormsFreeString(bstrName);
        if(hr)
            goto Cleanup;
        V_VT(pvarResult) = VT_DISPATCH;
        V_DISPATCH(pvarResult) = pCol;
    }
    else
    {          
        hr = THR_NOTRACE(super::ContextInvokeEx (dispid, lcid, wFlags, pdispparams, pvarResult,
                       pexcepinfo, pSrvProvider, pUnkContext ? pUnkContext : (IUnknown*)this));
    }
        
Cleanup:
    RRETURN(hr);
}

#ifdef USE_STACK_SPEW
#pragma check_stack(on)
#endif


//+---------------------------------------------------------------------------
//
//  Member:     IHTMLTableSection::insertRow
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTableSection::insertRow(long iRow, IDispatch** ppRow)
{
    CElement      * pNewElement = NULL;
    CElement      * pAdjacentElement = NULL;
    HRESULT         hr;
    Where           where;
    BOOL            fIncrementalUpdatePossible;
    CTable        * pTable;
    CTableLayout  * pTableLayout;

    if (ppRow)
        *ppRow = NULL;

    pTable = Table();
    if (!pTable)
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    pTableLayout = pTable->TableLayoutCache();
    hr = pTableLayout->EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    if (iRow < -1 || iRow > _cRows)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    if (pTable->IsDataboundInBrowseMode())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR( Doc()->CreateElement( ETAG_TR, & pNewElement ) );
    
    if (hr)
        goto Cleanup;

    Assert (pNewElement);

    // OM: iRow == -1                    means add the row at the end of the rows collection
    // OM: iRow == sizeof the collection means the same as iRow == -1
    // OM: iRow == good                  means insert as a row (iRow)

    where = BeforeBegin;                // insert the row before the "iRow"
    if (iRow == -1 || iRow == _cRows)
    {
        if (_cRows)
        {
            where = AfterEnd;           // insert after the last row
            iRow = _cRows - 1;
        }
        else
        {
            where = AfterBegin;         // insert After <TBODY> tag
            iRow = 0;
            pAdjacentElement = this;
        }
    }

    if (!pAdjacentElement)
    {
        Assert (iRow >= 0 && iRow < _cRows);
        pAdjacentElement = pTableLayout->_aryRows[_iRow + iRow];
        Assert (pAdjacentElement);
    }
    
    fIncrementalUpdatePossible = !_cRows                             ||     // in case of empty section, OR
                                  (where == AfterBegin && iRow == 0) ||     // in case of inserting first row to the section, OR
                                                                            // in case next row doesn't cross rowspans
                                  !pTableLayout->_aryRows[_iRow + iRow]->_fCrossingRowSpan;

    if (fIncrementalUpdatePossible)
        pTableLayout->_iInsertRowAt = _iRow + iRow + (where == AfterEnd? 1 : 0);
    hr = pTableLayout->insertElement(pAdjacentElement, pNewElement, where, fIncrementalUpdatePossible);
    pTableLayout->_iInsertRowAt = -1;
    if (hr)
        goto Cleanup;

    Assert(pNewElement->Tag() == ETAG_TR);
    DYNCAST(CTableRow, pNewElement)->_fCompleted = TRUE;

    if (ppRow)
    {
        hr = pNewElement->QueryInterface(IID_IHTMLTableRow, (void **)ppRow);
    }

Cleanup:
    CElement::ReleasePtr(pNewElement);

    RRETURN(SetErrorInfo( hr ));
}


//+---------------------------------------------------------------------------
//
//  Member: IHTMLTableSection::deleteRow
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTableSection::deleteRow(long iRow)
{
    CTableRow     * pRowDelete;
    CTableLayout  * pTableLayout;
    CTable        * pTable;
    HRESULT         hr;
    BOOL            fIncrementalUpdatePossible;

    pTable = Table();
    if (!pTable)
    {
        hr = S_OK;
        goto Cleanup;
    }

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    pTableLayout = pTable->TableLayoutCache();
    hr = pTableLayout->EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    if (iRow == -1)
    {
        iRow = _cRows - 1;
    }

    if (iRow < 0 || iRow >= _cRows)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    if (pTable->IsDataboundInBrowseMode())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pRowDelete = pTableLayout->_aryRows[iRow + _iRow];
    Assert (pRowDelete);

    fIncrementalUpdatePossible = !pRowDelete->_fCrossingRowSpan       && 
                                  pTableLayout->_fAllRowsSameShape    && 
                                  pTableLayout->_aryRows.Size() != 1  &&
                                 !pRowDelete->_fParentOfTC;

    hr = pTableLayout->deleteElement(pRowDelete, fIncrementalUpdatePossible);

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+---------------------------------------------------------------------------
//
//  Member:     IHTMLTableSection2::moveRow
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTableSection::moveRow(long iRow, long iRowTarget, IDispatch **ppRow)
{
    CTable * pTable = Table();
    HRESULT  hr;

    if (!pTable)
    {
        hr = E_PENDING;
        goto Cleanup;
    }

    if (   iRow < -1 || iRow >= _cRows
        || iRowTarget < -1 || iRow >= _cRows )
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    if (iRow == -1)
        iRow = _cRows-1;
    if (iRowTarget == -1)
        iRowTarget = _cRows-1;

    hr = THR(pTable->moveRowHelper(iRow + _iRow, iRowTarget + _iRow, ppRow, FALSE));

Cleanup:

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     IHTMLTableRow::get_rowIndex
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTableRow::get_rowIndex(long *plIndex)
{
    CTableLayout    * pTableLayout;
    CTable          * pTable;
    CTableRowLayout * pRowLayout;
    long              cRowsHead;
    long              cRowsFoot;
    HRESULT           hr;

    if (!plIndex)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    pTable = Table();
    if (!pTable)
    {
        *plIndex = -1;
        hr = S_OK;
        goto Cleanup;
    }

    *plIndex = 0;

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    pTableLayout = pTable->TableLayoutCache();
    pRowLayout = RowLayoutCache();

    hr = pTableLayout->EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    cRowsHead = (pTableLayout->_pHead ? pTableLayout->_pHead->_cRows : 0);
    cRowsFoot = (pTableLayout->_pFoot ? pTableLayout->_pFoot->_cRows : 0);

    //
    // THEAD rows are first in the table
    //

    if (pRowLayout->RowPosition() < cRowsHead)
    {
        *plIndex = pRowLayout->RowPosition();
    }

    //
    // TBODY rows are after the THEAD, but before the TFOOT
    //

    else if (pRowLayout->RowPosition() >= (cRowsHead + cRowsFoot))
    {
        *plIndex = pRowLayout->RowPosition() - cRowsFoot;
    }

    //
    // TFOOT rows are after the THEAD and TBODY
    //

    else
    {
        Assert(pRowLayout->RowPosition() >= cRowsHead && pRowLayout->RowPosition() < (cRowsHead + cRowsFoot));
        *plIndex = pTableLayout->GetRows() - cRowsFoot + pRowLayout->RowPosition() - cRowsHead;
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+---------------------------------------------------------------------------
//
//  Member:     IHTMLTableRow::get_sectionRowIndex
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTableRow::get_sectionRowIndex(long *plIndex)
{
    HRESULT hr = S_OK;
    CTableSection *pSection;
    CTable        *pTable;
    CTableLayout  *pTableLayout;

    if (!plIndex)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    pTable = Table();
    if (!pTable)
        goto Cleanup;

    pTableLayout = pTable->TableLayoutCache();

    hr = pTableLayout->EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    pSection = Section();
    if (pSection)
    {
        *plIndex = _iRow - pSection->_iRow;
    }
    else
    {
        *plIndex = -1;
        hr = S_OK;
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+---------------------------------------------------------------------------
//
//  Member: IHTMLTableRow::get_cells
//
//  Synopsis:   Table OM method implementation. Return the cells collection
//
//----------------------------------------------------------------------------

HRESULT
CTableRow::get_cells(IHTMLElementCollection ** ppCells)
{
    HRESULT hr;

    if (!ppCells)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppCells = NULL;

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    // do the work to get the Cells Collection
    // Create a collection cache if we don't already have one.
    hr = THR(EnsureCollectionCache(CELLS_COLLECTION));
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->GetDisp(CELLS_COLLECTION, (IDispatch**)ppCells));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+---------------------------------------------------------------------------
//
//  Member: IHTMLTableRow::insertCell
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTableRow::insertCell(long iCell, IDispatch** ppCell)
{
    CElement    *pNewElement = NULL;
    CTableCell  *pCell = NULL;
    CElement    *pAdjacentElement = NULL;
    HRESULT      hr;
    Where        where;
    int          i, iRealCell  = 0;
    int          cAryCellsSize = 0;
    int          cCells        = 0;;
    CTable      *pTable;
    CTableLayout *pTableLayout;
    BOOL        fIncrementalUpdatePossible, fLastCell = FALSE;
    CTableRowLayout *pRowLayout = RowLayoutCache();

    Assert (pRowLayout);

    if (ppCell)
    {
        *ppCell = NULL;
    }

    // do the work to get the Cells Collection
    // Create a collection cache if we don't already have one.
    // this needs to be done since our collection may not be uptodate
    hr = THR(EnsureCollectionCache(CELLS_COLLECTION));
    if (hr)
        goto Cleanup;

    // OM: iCell == -1                    means add the cell at the end of the cells collection
    // OM: iCell == sizeof the collection means the same as iCell == -1
    // OM: iCell == good                  means insert as a cell (iCell)

    cAryCellsSize = pRowLayout->_aryCells.Size();
    cCells        = pRowLayout->_cRealCells;

    if (iCell < -1 || iCell > cCells)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    pTable = Table();
    if (!pTable)
    {
        hr = S_OK;
        goto Cleanup;
    }

    if (pTable->IsDataboundInBrowseMode())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    pTableLayout = pTable->TableLayoutCache();

    hr = pTableLayout->EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    hr = Doc()->CreateElement(ETAG_TD, &pNewElement);
    if (hr)
        goto Cleanup;

    Assert (pNewElement);

    where = BeforeBegin;                // insert the row before the "iCell"
    if (iCell == -1 || iCell == cCells)
    {
        if (cCells)
        {
            where = AfterEnd;           // insert after the last cell
            iCell = cCells - 1;
        }
        else
        {
            where = AfterBegin;         // insert After <TR> tag
            pAdjacentElement = this;
        }
        fLastCell = TRUE;
    }

    if (!pAdjacentElement)
    {
        Assert (iCell >= 0 && iCell < cCells);
        for (i = 0; i < cAryCellsSize; i++)
        {
            pCell = pRowLayout->_aryCells[i];
            if (IsReal(pCell) && iCell == iRealCell)
            {
                fLastCell = FALSE;
                break;
            }
            if (IsReal(pCell))
            {
                iRealCell++;
                Assert (iRealCell < cCells);
            }
        }

        //  (bug # 111131) It valid for IsReal(pCell) to retun false here
        //  when the cell is empty due to display:none. But Cell() should 
        //  always be used in subsequent checks and assignings.

        // Assert (IsReal(pCell));

        pAdjacentElement = Cell(pCell);
        if (!Cell(pCell))
        {
            // insert the cell before the </TR> tag
            pAdjacentElement = this;
            where = BeforeEnd;
            fLastCell = FALSE;
        }
    }

    fIncrementalUpdatePossible =  !_fCrossingRowSpan && fLastCell && (cCells + 1 <= cAryCellsSize || pTableLayout->_aryRows.Size() == 1);

    hr = pTableLayout->insertElement(pAdjacentElement, pNewElement, where, fIncrementalUpdatePossible);

    if (hr)
    {
        goto Cleanup;
    }

    if (pTableLayout)
        pTableLayout->MarkTableLayoutCacheDirty();

    if (ppCell)
    {
        hr = pNewElement->QueryInterface(IID_IHTMLTableCell, (void **)ppCell);
    }

Cleanup:
    CElement::ReleasePtr(pNewElement);

    RRETURN(SetErrorInfo( hr ));
}



//+---------------------------------------------------------------------------
//
//  Member: IHTMLTableRow::deleteCell
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTableRow::deleteCell(long iCell)
{
    HRESULT         hr = S_OK;
    CTableCell **   ppCell;
    CTableCell *    pCellDelete;
    long            cCells, iReal;
    CTableRowLayout * pRowLayout;
    CTable          * pTable;
    CTableLayout    * pTableLayout;

    pTable = Table();
    if (!pTable)
    {
        hr = S_OK;
        goto Cleanup;
    }

    if (pTable->IsDataboundInBrowseMode())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    pTableLayout = pTable->TableLayoutCache();
    hr = pTableLayout->EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    pRowLayout = RowLayoutCache();
    if (iCell < -1 || iCell >= pRowLayout->_aryCells.Size())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    iReal       = -1;
    pCellDelete = NULL;
    for (ppCell = pRowLayout->_aryCells, cCells = pRowLayout->_aryCells.Size();
        cCells > 0;
        ppCell++, cCells--)
    {
        if (IsReal(*ppCell))
        {
            iReal++;
            pCellDelete = *ppCell;

            if (iReal == iCell)
                break;
        }
    }

    if (    iReal < 0
        ||  (   iCell >= 0
            &&  iCell != iReal))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    Assert(pCellDelete);
    Assert(IsReal(pCellDelete));

    hr = pTable->TableLayoutCache()->deleteElement(pCellDelete);

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+---------------------------------------------------------------------------
//
//  Member: IHTMLTableCell::get_index
//
//  Synopsis:   Table OM method implementation
//
//----------------------------------------------------------------------------

HRESULT
CTableCell::get_cellIndex(long *plIndex)
{
    HRESULT     hr = S_OK;
    CTableRow * pRow;
    CTableRowLayout *pRowLayout;
    int         i;
    int         iRealCell = 0;
    CTableCell *pCell;
    CTable       * pTable;
    CTableLayout * pTableLayout;

    if (!plIndex)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    pRow = Row();
    if (!pRow)
    {
        iRealCell = -1;
        hr = S_OK;
        goto Cleanup;
    }

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    pTable = Table();
    if (pTable)
    {
        pTableLayout = pTable->TableLayoutCache();
        hr = pTableLayout->EnsureTableLayoutCache();
        if (hr)
            goto Cleanup;
    }

    pRowLayout = pRow->RowLayoutCache();
    for (i = 0; i < pRowLayout->_aryCells.Size(); i++)
    {
        pCell = pRowLayout->_aryCells[i];
        if (Cell(pCell) == this)
        {
            break;
        }
        if (IsReal(pCell))
        {
            iRealCell++;
        }
    }

    Assert (iRealCell < pRowLayout->_cRealCells);
  

Cleanup:
    if (plIndex)
        *plIndex = iRealCell;

    RRETURN(SetErrorInfo( hr ));
}


//+------------------------------------------------------------------------
//
//  Member:     put_colSpan, IHTMLTable
//
//  Synopsis:   change the colSpan
//
//  Arguments:  cColSpan       new col span
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
STDMETHODIMP
CTableCell::put_colSpan(long cColSpan)
{
    CTable * pTable = Table();
    HRESULT hr = S_OK;
    long    cOldColSpan = ColSpan();

    if (cColSpan < 1)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (pTable && pTable->IsDataboundInBrowseMode())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (cColSpan > MAX_COL_SPAN && cOldColSpan == MAX_COL_SPAN)
    {
        goto Cleanup;   // nothing to do
    }

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;


    {   // Just do it, and be ready do undo it...
        CParentUndo pu(Doc());
        
        if( IsEditable(/*fCheckContainerOnly*/FALSE) )
            pu.Start( IDS_UNDOPROPCHANGE );

        // this is a fancy way of calling the base implementation
        hr = s_propdescCTableCellcolSpan.b.SetNumberProperty(cColSpan, this, CVOID_CAST(GetAttrArray()));
        if (!hr && pTable)
        {
            pTable->TableLayoutCache()->Fixup(FALSE);
        }

        pu.Finish( hr );
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+------------------------------------------------------------------------
//
//  Member:     get_colSpan, IHTMLTable
//
//  Synopsis:   return the colSpan
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
STDMETHODIMP
CTableCell::get_colSpan(long * p)
{
    if (p)
    {
        *p = ColSpan();
    }
    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     put_rowSpan, IHTMLTable
//
//  Synopsis:   change the rowSpan
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
STDMETHODIMP
CTableCell::put_rowSpan(long cRowSpan)
{
    CTable * pTable = Table();
    HRESULT hr;

   if (cRowSpan < 1)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    if (pTable && pTable->IsDataboundInBrowseMode())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    {   // Just do it, and be ready do undo it...
        CParentUndo pu(Doc());
        
        if( IsEditable(/*fCheckContainerOnly*/FALSE) )
            pu.Start( IDS_UNDOPROPCHANGE );

        // this is a fancy way of calling the base implementation
        hr = s_propdescCTableCellrowSpan.b.SetNumberProperty(cRowSpan, this, CVOID_CAST(GetAttrArray()));
        if (!hr && pTable)
        {
            pTable->TableLayoutCache()->Fixup(FALSE);
        }

        pu.Finish( hr );
    }

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+------------------------------------------------------------------------
//
//  Member:     get_rowSpan, IHTMLTable
//
//  Synopsis:   return the rowSpan
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
STDMETHODIMP
CTableCell::get_rowSpan(long * p)
{
    HRESULT        hr = S_OK;
    int            iRowSpan = 1;
    CTable       * pTable;
    CTableLayout * pTableLayout;

    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    pTable = Table();
    if (pTable)
    {
        pTableLayout = pTable->TableLayoutCache();
        hr = pTableLayout->EnsureTableLayoutCache();
        if (!hr)
            iRowSpan = RowSpan();
    }
    
    if (p)
    {
        *p = iRowSpan;
    }

Cleanup:
    RRETURN (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\builtin\tcalc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       tcalc.cxx
//
//  Contents:   CTable and related classes.
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include <formkrnl.hxx>
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include <download.hxx>
#endif

#ifndef X__DISP_H_
#define X__DISP_H_
#include <_disp.h>
#endif


//+-------------------------------------------------------------------------
//
//  Method:     AdjustForCell
//
//  Synopsis:   Promote the cell width into the column (if certain
//              criteria are met)
//
//  Arguments:  pTable  - Table pointer
//              iPixels - user specified pixel width of the cell (0 if none)
//              puvWidth- user specifed Unit Value
//                             BOOL                   fUnsizedColumn,
//                             BOOL                   fFirstRow,
//                             CCalcInfo *            pci,
//                             int                    xMin,
//                             int                    xMax
//
//--------------------------------------------------------------------------

void
CTableColCalc::AdjustForCell(CTableLayout *         pTableLayout,
                             int                    iPixels,
                             const CWidthUnitValue *puvWidth,
                             BOOL                   fUnsizedColumn,
                             BOOL                   fFirstRow,
                             CCalcInfo *            pci,
                             int                    xMin,
                             int                    xMax)
{

    // cache width attribute in column (if appropriate)
    Assert (pTableLayout);

    if ((fUnsizedColumn || fFirstRow) && puvWidth->IsSpecified())
    {
        // set column unit width if smaller then the cell width
        if (!IsWidthSpecified())
        {
            if(!_fDontSetWidthFromCell)
            {
                // NETSCAPE: DON'T propagate the PIXEL width of the cell to the column if there are more then
                // 1 cell in that column
                if (puvWidth->IsSpecifiedInPixel())
                {
                    if (iPixels)    // bugfix: if width is set through style width:0px, then it will be ignored.
                    {
                        _uvWidth = *puvWidth;
                        SetPixelWidth(pci, iPixels);
                        _fWidthFromCell = TRUE;
                    }
                }
                else
                {
                    _uvWidth = *puvWidth;
                    _fWidthFromCell = TRUE;
                }
            }
        }
        else if (puvWidth->IsSpecifiedInPercent())
        {
            if (IsWidthSpecifiedInPercent())
            {
                // set it if smaller
                if (GetWidthUnitValue() < puvWidth->GetUnitValue())
                {
                    _uvWidth = *puvWidth;
                }
            }
            else
            {
                // percent has precedence over normal width
                _uvWidth = *puvWidth;
            }
        }
        else if (!IsWidthSpecifiedInPercent())
        {
            // set if smaller
            if (GetPixelWidth(pci, pTableLayout->ElementOwner()) < iPixels)
            {
                _uvWidth = *puvWidth;
                SetPixelWidth(pci, iPixels);
            }
        }
    }

    // adjust column width

    if (fUnsizedColumn || fFirstRow || pTableLayout->_fAlwaysMinMaxCells)
    {
        if (_xMax < xMax)
        {
            _xMax = xMax;

            //NETSCAPE: if the new MAX is greater and the column width was set from the cell,
            //          don't propagate the user's width to the column.
            if (_fWidthFromCell && IsWidthSpecifiedInPixel() && !puvWidth->IsSpecified())
            {
                // reset the column uvWidth
                _fDontSetWidthFromCell = TRUE;
                ResetWidth();
            }
            if (!fUnsizedColumn && !puvWidth->IsSpecifiedInPercent())
            {
                _xMin   =
                _xWidth = _xMax;
            }
        }
        if (_xMin < xMin)
        {
            _xMin = xMin;
        }

        // this will adjust col max to user setting
        AdjustMaxToUserWidth(pci, pTableLayout);

        // use col max
        // xMax = _xMax;
    }

    _fAdjustedForCell = TRUE;
    return;
}


//+-------------------------------------------------------------------------
//
//  Method:     AdjustForCol
//
//  Synopsis:   Promote the cell width into the column (if certain
//              criteria are met)
//
//  Arguments:  pTable  - Table pointer
//              iPixels - user specified pixel width of the cell (0 if none)
//              pci     - CalcInfo,
//
//--------------------------------------------------------------------------

void
CTableColCalc::AdjustForCol(const CWidthUnitValue *puvWidth,
                            int                    iColWidth,
                            CCalcInfo             *pci,
                            int                    cColumns)
{
    _uvWidth = *puvWidth;

    if (IsWidthSpecifiedInPixel())
    {
        SetPixelWidth(pci, iColWidth);
        _xMin = _xMax = _xWidth = iColWidth;
    }
    else
    {
        if (cColumns != 1)
        {
            int ip = GetPercentWidth();
            SetPercentWidth(ip/cColumns);
        }
        _xMin = 1;
        _xMax = pci->_sizeParent.cx;
        _xWidth = iColWidth;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\builtin\marquee.cxx ===
//+---------------------------------------------------------------------
//
//   File:      inputtxt.cxx
//
//  Contents:   InputTxt element class, etc..
//
//  Classes:    CInputTxtBase, etc..
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CGUID_H_
#define X_CGUID_H_
#include <cguid.h>
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_TASKMAN_HXX_
#define X_TASKMAN_HXX_
#include "taskman.hxx"
#endif

#ifndef X_MARQUEE_HXX_
#define X_MARQUEE_HXX_
#include "marquee.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_MARQLYT_HXX_
#define X_MARQLYT_HXX_
#include "marqlyt.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_EFORM_HXX_
#define X_EFORM_HXX_
#include "eform.hxx"
#endif

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

#ifndef X_PROPS_HXX_
#define X_PROPS_HXX_
#include "props.hxx"
#endif

#ifndef X_DISPDEFS_HXX_
#define X_DISPDEFS_HXX_
#include "dispdefs.hxx"
#endif

#define _cxx_
#include "marquee.hdl"

DeclareTag(tagMarquee,          "Marquee", "Trace Marquee Ticks")
MtDefine(CMarquee, Elements, "CMarquee")
MtDefine(CMarqueeTask, CMarquee, "CMarqueeTask")

//+-------------------------------------------------------------------
// CMarqueeTask methods
//---------------------------------------------------------------------

CMarqueeTask::CMarqueeTask(CMarquee *pMarquee)
{
    _pMarquee = pMarquee;
}

void
CMarqueeTask::OnRun(DWORD dwTimeout)
{
    _pMarquee->OnRun(dwTimeout);
}



#ifndef NO_PROPERTY_PAGE
const CLSID * const CMarquee::s_apclsidPages[] =
{
    // Browse-time pages
    NULL,
    // Edit-time pages
#if DBG==1    
    &CLSID_CCDGenericPropertyPage,
    &CLSID_CInlineStylePropertyPage,
#endif // DBG==1    
    NULL
};
#endif // NO_PROPERTY_PAGE

const CElement::CLASSDESC CMarquee::s_classdesc =
{
    {
        &CLSID_HTMLMarqueeElement,      // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_NOTIFYENDPARSE |
        ELEMENTDESC_TEXTSITE       |
        ELEMENTDESC_CANSCROLL      |
        ELEMENTDESC_ANCHOROUT      |
        ELEMENTDESC_NOBKGRDRECALC,      // _dwFlags
        &IID_IHTMLMarqueeElement,       // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLMarqueeElement,  // _pfnTearOff
    &CTxtSite::s_AccelsTxtSiteRun       // _pAccelsRun
};

HRESULT
CMarquee::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(ppElement);

    *ppElement = new CMarquee(pht->GetTag(), pDoc);

    RRETURN ( (*ppElement) ? S_OK : E_OUTOFMEMORY);
}


HRESULT
CMarquee::Init2(CInit2Context * pContext)
{
    HRESULT hr = S_OK;

    Doc()->_fBroadcastInteraction = TRUE;

    hr = THR(super::Init2(pContext));

    _pMarqueeTask  = NULL;

    if (!OK(hr))
        goto Cleanup;

    Layout()->_fContentsAffectSize = TRUE;

    // These we do not set inside InitScrollParam
    _fStop = FALSE;
    _fDone = FALSE;
    _fFirstRun = TRUE;
    _fIsVisible = TRUE;

    _direction = GetAAdirection();
    InitScrollParams();

Cleanup:
    RRETURN1(hr, S_INCOMPLETE);
}

void
CMarquee::InitScrollParams()
{
    _lLoop = GetAAloop();

    _fSwitch = GetAAbehavior() == htmlMarqueeBehavioralternate;
    _fSlide = GetAAbehavior() == htmlMarqueeBehaviorslide;
    _lScrollBy = GetAAscrollAmount();
    _lScrollDelay = GetAAscrollDelay();
    _fTrueSpeed = GetAAtrueSpeed();

    if (_lScrollDelay < 60 && !_fTrueSpeed)
    {
        _lScrollDelay = 60;
    }

    Assert(_lScrollDelay > 0);

    if (_lLoop > 0 &&
        !_fSwitch &&
        !_fSlide &&
        (_direction == htmlMarqueeDirectionright ||
         _direction == htmlMarqueeDirectiondown))
    {
        // THe way we do scrolling we're going to lose
        // one loop in the right and down case
        _lLoop++;
    }

    // In the new layout world wordwrap is set when the marquee is
    // inserted in the tree.

    // We were asked to allow looping on slide behavior. The default loop value though is -1
    // which usually means loop for ever. But this is not good for Slide so we have to
    // make a special case here
    if (_fSlide && _lLoop < 0)
    {
        _lLoop = 1;
    }
}



void
CMarquee::OnRun(DWORD dwTimeout)
{
    long    lScrollDelta;
    long    lSwitchPoint;
    long    *plPos;
    long    *plPos2;       
    long    lScroll;
    long    lText;
    long    lMargin;
    long    lMargin2;

    long    lPosStart;
    long    lPosEnd;

    BOOL    fTooBig;

    BOOL    fShouldSwitch;
    BOOL    fPassedEdge;

    BOOL    fLeftOrUp       = TRUE;
    BOOL    fLeftOrRight    = TRUE;
    BOOL    fClearFirstRun  = TRUE;
    htmlMarqueeDirection    dirOpposite = _direction;
    htmlMarqueeBehavior     behavior;

    #if DBG==1
    __int64 t1, t2, tfrq;
    QueryPerformanceCounter((LARGE_INTEGER *)&t1);
    QueryPerformanceCounter((LARGE_INTEGER *)&t2);
    QueryPerformanceFrequency((LARGE_INTEGER *)&tfrq);
    #endif


    // we should stop the Task under these conditions
    if (_fDone || _fStop || _lLoop == 0 || IsEditable(TRUE))
        return;
    if (0 == _dwOldTimeout)
    {
        _dwOldTimeout = dwTimeout;
    }


    DWORD dwTimeDelta = dwTimeout - _dwOldTimeout;


    if (dwTimeout > _dwOldTimeout)
    {
        lScrollDelta = MulDivQuick(_lScrollBy, dwTimeDelta, _lScrollDelay); //GetAAscrollDelay());
    }
    else
    {
        // overflow case
        lScrollDelta = _lScrollBy;
    }

    TraceTag((tagMarquee, "OnRun: trueSpeed=%ld Delay %ld last %ld tks ago Amount %ld Delta %ld", _fTrueSpeed ? 1 : 0,_lScrollDelay, dwTimeout - _dwOldTimeout, _lScrollBy, lScrollDelta));

    _dwOldTimeout = dwTimeout;

    if (_fFirstRun)
    {
        Fire_onstart();
    }

    switch (_direction)
    {
    case    htmlMarqueeDirectionleft:
            fLeftOrUp       = TRUE;
            dirOpposite     = htmlMarqueeDirectionright;
            break;
    case    htmlMarqueeDirectionright:
            fLeftOrUp       = FALSE;
            dirOpposite     = htmlMarqueeDirectionleft;
            break;
    case    htmlMarqueeDirectionup:
            fLeftOrRight    = FALSE;
            dirOpposite     = htmlMarqueeDirectiondown;
            break;
    case    htmlMarqueeDirectiondown:
            fLeftOrUp       = FALSE;
            fLeftOrRight    = FALSE;
            dirOpposite     = htmlMarqueeDirectionup;
            break;
    default:
            AssertSz(0, "Wrong htmlMarqueeDirection enum value");
    }


    plPos       = fLeftOrRight ? &_lXPos : &_lYPos;
    plPos2      = fLeftOrRight ? &_lYPos : &_lXPos;
    lScroll     = fLeftOrRight ? _sizeScroll.cx : _sizeScroll.cy;

    if (!lScroll)
        goto Cleanup;

    lMargin     = fLeftOrRight ? _lXMargin : _lYMargin;
    lMargin2    = fLeftOrRight ? _lYMargin : _lXMargin;
    lText       = lScroll - 2*lMargin;

    lPosStart   = fLeftOrUp ? 0 : lScroll - lMargin;
    lPosEnd     = fLeftOrUp ? lScroll - lMargin : 0;

    if (fLeftOrRight)
    {
        fTooBig = fLeftOrUp ? _fToBigForSwitch : !_fToBigForSwitch;
    }
    else
    {
        fTooBig = !fLeftOrUp;
    }

    behavior = GetAAbehavior();
    switch (behavior)
    {
    case    htmlMarqueeBehaviorslide:
            if (_fFirstRun)
            {
                *plPos = lPosStart;
            }
    case    htmlMarqueeBehavioralternate:
            lSwitchPoint = fTooBig ?  lText : lMargin;
            if (behavior == htmlMarqueeBehavioralternate && _fFirstRun)
            {
                *plPos = fTooBig ? lMargin : lText;
            }
            else
            {
                fShouldSwitch = fLeftOrUp ? (*plPos >= lSwitchPoint) : (*plPos <= lSwitchPoint);
                if (fShouldSwitch)
                {
                    // Count this scroll, if we have an active loop count
                    if (_lLoop > 0)
                    {
                        _lLoop--;
                        if (_lLoop == 0)
                        {
                            _fDone = TRUE;
                            if (!Fire_onfinish())
                            {
                                _lLoop=-1; // On finish was cancelled so we continue for ever.
                            }
                            goto Cleanup;
                        }
                    }

                    if (behavior == htmlMarqueeBehaviorslide)
                    {
                        *plPos = 0;
                        Fire_onstart();
                    }
                    else    // alternate
                    {
                        *plPos = lSwitchPoint ;
                        Fire_onbounce();
                        _direction = dirOpposite;
                        goto Cleanup;
                    }
                }
                else
                {
                    *plPos += fLeftOrUp ? lScrollDelta : -lScrollDelta;
                    fPassedEdge = fLeftOrUp ? *plPos > lSwitchPoint : *plPos < lSwitchPoint;
                    if (fPassedEdge)
                    {   
                        // Dont baunce behind the edge
                        *plPos = lSwitchPoint;
                    }
                }
            }
            break;
    default:
            {
                BOOL    fGoToofar = fLeftOrUp ? (*plPos >= lPosEnd) : (*plPos <= lPosEnd);
                if (fGoToofar)
                {
                    *plPos = lPosStart;
                    Fire_onstart();
                    // Count this scroll, if we have an active loop count
                    if (_lLoop > 0)
                    {
                        _lLoop--;
                        if (_lLoop == 0)
                        {
                            if (!Fire_onfinish())
                            {
                                _lLoop=-1; // On finish was cancelled so we continue for ever.
                            }
                            goto Cleanup;
                        }
                    }
                }
                *plPos += fLeftOrUp ? lScrollDelta : -lScrollDelta;
            }
    }

    *plPos2 = lMargin2;

    if (Doc()->State() >= OS_INPLACE)
    {
        // clear _fFirstRun before scrolling, since scrolling can call out to
        // external code and cause (this) to be deleted [IE6 36161]
        _fFirstRun = FALSE;
        fClearFirstRun = FALSE;
        Layout()->ScrollTo(_lXPos, _lYPos);
    }

#if DBG==1
    QueryPerformanceCounter((LARGE_INTEGER *)&t2);
    TraceTag((tagMarquee, "OnRun: ScrollView took %ld ticks", GetTickCount() - dwTimeout));
    TraceTag((tagMarquee, "ScrollView done in %ld", (LONG)(((t2 - t1) * 1000000) / tfrq)));
#endif

Cleanup:
    if (fClearFirstRun)
        _fFirstRun = FALSE;

    return;
}


#ifdef NEVER
TXTBACKSTYLE
CMarquee::GetBackStyle() const
{
    return ((CMarquee *) this)->GetCascadedbackgroundColor().IsDefined() ? TXTBACK_OPAQUE : TXTBACK_TRANSPARENT;
}
#endif


HRESULT BUGCALL
CMarquee::stop()
{
    _fStop = TRUE;
    // this will cause the OnRun to start from where it stopped
    _dwOldTimeout = 0;
    return S_OK;
}

HRESULT BUGCALL
CMarquee::start()
{
    _fStop = FALSE;
    return S_OK;
}

void
CMarquee::SetMarqueeTask(void)
{
    CDoc * pDoc = Doc();
    CMarkup * pMarkup = GetMarkup();

    if (    pMarkup
        &&  !pMarkup->IsPrintMedia()
        &&  !IsDisplayNone()
        &&  pDoc->_fEnableInteraction
        &&  IsConnectedToPrimaryWindow())
    {
        if (_pMarqueeTask == NULL)
        {
            _pMarqueeTask = new CMarqueeTask(this);
            if (_pMarqueeTask)
            {
                _pMarqueeTask->SetInterval(_lScrollDelay);
            }
        }
    }
    else
    {
        if (_pMarqueeTask)
        {
            _pMarqueeTask->Terminate();
            _pMarqueeTask->Release();
            _pMarqueeTask = NULL;
        }
    }

}


void
CMarquee::Passivate()
{
    SetMarqueeTask();
    super::Passivate();
}

//+------------------------------------------------------------------------
//
//  Member:     CMarquee::Notify
//
//  Synopsis:   Listen for inplace (de)activation so we can turn on/off
//              Scrolling
//
//-------------------------------------------------------------------------

void
CMarquee::Notify(CNotification *pNF)
{
    super::Notify(pNF);
    switch (pNF->Type())
    {
    case NTYPE_ELEMENT_EXITTREE_1:
        if (_pMarqueeTask)
        {
            _pMarqueeTask->Terminate();
            _pMarqueeTask->Release();
            _pMarqueeTask = NULL;
        }
        break;
    case NTYPE_ELEMENT_ENTERTREE:
    case NTYPE_ELEMENT_ENTERVIEW_1:
    case NTYPE_ENABLE_INTERACTION_1:
    case NTYPE_DOC_STATE_CHANGE_1:
        SetMarqueeTask();
        break;
    }
}


#ifndef NO_DATABINDING
class CDBindMethodsMarquee : public CDBindMethodsText
{
    typedef CDBindMethodsText super;
public:
    CDBindMethodsMarquee() : super(DBIND_ONEWAY|DBIND_HTMLOK) {}
    ~CDBindMethodsMarquee()     {}

    virtual HRESULT BoundValueToElement(CElement *pElem, LONG id,
                                        BOOL fHTML, LPVOID pvData) const;
};

static const CDBindMethodsMarquee DBindMethodsMarquee;

const CDBindMethods *
CMarquee::GetDBindMethods()
{
    return &DBindMethodsMarquee;
}

//+---------------------------------------------------------------------------
//
//  Function: BoundValueToElement, CDBindMethods
//
//  Synopsis: Transfer data into bound marquee.
//
//  Arguments:
//            [id]      - ID of binding point.  For the select, is always
//                        DISPID_VALUE.
//            [pvData]  - pointer to data to transfer. must be BSTR.
//
//----------------------------------------------------------------------------

HRESULT
CDBindMethodsMarquee::BoundValueToElement(CElement *pElem,
                                          LONG id,
                                          BOOL fHTML,
                                          LPVOID pvData) const
{
    HRESULT hr;

    hr = THR(super::BoundValueToElement(pElem, id, fHTML, pvData));
    if (hr)
        goto Cleanup;

    pElem->ResizeElement();

Cleanup:
    RRETURN(hr);
}
#endif // ndef NO_DATABINDING


//+------------------------------------------------------------------------
//
//  Member:     OnPropertyChange
//
//  Note:       Called after a property has changed to notify derived classes
//              of the change.  All properties (except those managed by the
//              derived class) are consistent before this call.
//
//              Also, fires a property change notification to the site.
//
//-------------------------------------------------------------------------

HRESULT
CMarquee::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr = S_OK;

    switch (dispid)
    {

    case DISPID_CMarquee_direction:
        {
            _direction = GetAAdirection();

            // We need a full recalc since margins are direction dependent
            // and we need to update the display to have the correct scroll
            // params
            ResizeElement();
            break;
        } 
    case DISPID_CMarquee_behavior:
    case DISPID_CMarquee_loop:
        {
            _fStop = FALSE;
            _fDone = FALSE;
            _fFirstRun = TRUE;
            // Fall through
        }
    case DISPID_CMarquee_scrollDelay:
    case DISPID_CMarquee_scrollAmount:
    case DISPID_CMarquee_width:
    case DISPID_CMarquee_height:
            // InitScrollParams will be called later
            break;
    }

    if (OK(hr))
        hr = THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc));

    if (OK(hr))
    {
        InitScrollParams();
        SetMarqueeTask();
    }

    RRETURN(hr);    
}


HRESULT
CMarquee::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    HRESULT hr = S_OK;

    // we inherit everything
    // In order to avoid inheriting the code below should be compiled

    // override parent's format to default on all formats, so we get only styles
//    pCFI->_cf.InitDefault(Doc()->_pOptionSettings, FALSE);
//    pCFI->_pf.InitDefault();
//    pCFI->_ff.InitDefault();

    pCFI->_bCtrlBlockAlign = pCFI->_bBlockAlign;
    pCFI->_bBlockAlign     = htmlBlockAlignNotSet;

    // our intrinsics shouldn't inherit the cursor property. they have a 'default'
    pCFI->PrepareCharFormat();
    pCFI->_cf()._bCursorIdx = styleCursorAuto;
    pCFI->UnprepareForDebug();

    hr = THR(super::ApplyDefaultFormat(pCFI));

    pCFI->PrepareFancyFormat();
    if (!pCFI->_pcf->HasVerticalLayoutFlow())
    {
        pCFI->_ff().SetOverflowX(styleOverflowHidden);
        pCFI->_ff().SetOverflowY(styleOverflowVisible);
    }
    else
    {
        pCFI->_ff().SetOverflowY(styleOverflowHidden);
        pCFI->_ff().SetOverflowX(styleOverflowVisible);
    }
    pCFI->UnprepareForDebug();

    // Default to percent width (element's coordinate system).
    pCFI->PrepareFancyFormat();
    if (pCFI->_pcf->HasVerticalLayoutFlow())
    {
        pCFI->_ff().SetHeightPercent(pCFI->_ff().IsHeightPercent() | pCFI->_ff().GetHeight().IsNullOrEnum());
    }
    else
    {
        pCFI->_ff().SetWidthPercent(pCFI->_ff().IsWidthPercent() | pCFI->_ff().GetWidth().IsNullOrEnum());
    }
    pCFI->UnprepareForDebug();
    // TODO: should consider doing this with DISPLAY_CHANGE/VISIBILITY_CHANGE
    pCFI->PrepareCharFormat();
    if (!pCFI->_cf()._fVisibilityHidden && !pCFI->_cf()._fDisplayNone)
    {
        if (!_fIsVisible && GetMarkup() && !GetMarkup()->IsPrintMedia())
        {
            _fIsVisible = TRUE;
            if (_pMarqueeTask == NULL)
            {
                _pMarqueeTask = new CMarqueeTask(this);
                if (_pMarqueeTask)
                {
                    _pMarqueeTask->SetInterval(_lScrollDelay);
                }
            }
        }
    }
    else
    {
        _fIsVisible = FALSE;
    }
    pCFI->UnprepareForDebug();

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\builtin\tdata.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       tdata.cxx
//
//  Contents:   CTable and related classes.
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include <formkrnl.hxx>
#endif

#ifndef X_SAVER_HXX_
#define X_SAVER_HXX_
#include <saver.hxx>
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_LTROW_HXX_
#define X_LTROW_HXX_
#include "ltrow.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include <treepos.hxx>
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include <download.hxx>
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include <othrguid.h>
#endif

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include <binder.hxx>
#endif

#ifndef X_DETAIL_HXX_
#define X_DETAIL_HXX_
#include <detail.hxx>
#endif

#ifndef X_ROWBIND_HXX_
#define X_ROWBIND_HXX_
#include <rowbind.hxx>
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

ExternTag(tagTableRecalc);

#ifndef NO_DATABINDING
#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

class CDBindMethodsTable : public CDBindMethods
{
    typedef CDBindMethods super;

public:
    CDBindMethodsTable()    {}
    ~CDBindMethodsTable()   {}

    virtual HRESULT BoundValueToElement(CElement *pElem, LONG id,
                                        BOOL fHTML, LPVOID pvData) const;

    virtual HRESULT BoundValueFromElement(CElement *pElem, LONG id,
                                         BOOL fHTML, LPVOID pvData) const;

    // Notification that data is ready (or not ready)
    virtual void    OnDataReady ( CElement *pElem, BOOL fReady ) const;

    // Notification that the source instance has changed
    virtual HRESULT InstanceChanged(CElement *pElem, CInstance *pSrcInstance) const;

protected:
    virtual DBIND_KIND DBindKindImpl(CElement *pElem,
                                     LONG id,
                                     DBINFO *pdbi) const;
    virtual BOOL    IsReadyImpl(CElement *pElem) const;
};

static const CDBindMethodsTable DBindMethodsTable;

const CDBindMethods *
CTable::GetDBindMethods()
{
    return &DBindMethodsTable;
}

//+----------------------------------------------------------------------------
//
//  Function: DBindKindImpl, CDBindMethods
//
//  Synopsis: Indicate whether or not element is or can be databound, and
//            optionally return additional info about binding -- a DISPID
//            or other ID used for transfer, and the desired data type
//            to be used for transfer.
//  Arguments:
//            [id]    - bound id
//            [pdbi]  - pointer to struct to get data type and ID;
//                      may be NULL
//
//  Returns:  Binding status: one of
//              DBIND_NONE
//              DBIND_SINGLEVALUE
//              DBIND_ICURSOR
//              DBIND_IROWSET
//              DBIND_TABLE
//            For Table, returns DBIND_NONE or DBIND_TABLE.
//
//-----------------------------------------------------------------------------
DBIND_KIND
CDBindMethodsTable::DBindKindImpl(CElement *pElem, LONG id, DBINFO *pdbi) const
{
    DBIND_KIND dbk = DBIND_NONE;    // pdbi, if any, initialized by wrapper

    Assert(pElem->Tag() == ETAG_TABLE);

    if (id == ID_DBIND_DEFAULT)
    {
        dbk = DBIND_TABLE;
        if (pdbi)
        {
            pdbi->_vt = DBTYPE_HCHAPTER;
            pdbi->_dwTransfer = DBIND_NOTIFYONLY | DBIND_ONEWAY;
        }
    }

    return dbk;
}

//+----------------------------------------------------------------------------
//
//  Function: IsReadyImpl, CDBindMethods
//
//  Synopsis: Indicate whether or element is ready to be bound.
//
//  Arguments:  pEleme  table element being queried
//
//-----------------------------------------------------------------------------
BOOL
CDBindMethodsTable::IsReadyImpl(CElement *pElem) const
{
    return TRUE;
}


//+----------------------------------------------------------------------------
//
//  Function: InstanceChanged, CDBindMethods
//
//  Synopsis: Notification that the source instance has a new HROW.
//
//  Arguments:  pElem           table element being queried
//              pSrcInstance    its source instance (holds the HROW)
//
//-----------------------------------------------------------------------------
HRESULT
CDBindMethodsTable::InstanceChanged(CElement *pElem, CInstance *pSrcInstance) const
{
    HRESULT hr;
    CTable *pTable = DYNCAST(CTable, pElem);

    // We're only supposed to get here for inner tables in a hierarchy
    Assert(!FormsIsEmptyString(pTable->GetAAdataFld()));

    // ReplaceProvider(NULL) just queues up a ReBind request with the dbtask
    hr = THR(pTable->GetDBMembers()->GetBinder(ID_DBIND_DEFAULT)->ReplaceProvider(NULL));

    RRETURN(hr);
}

#endif // ndef NO_DATABINDING

//+------------------------------------------------------------------------
//
//  Member:     CTable::Save
//
//  Synopsis:   Save the element to the stream
//
//-------------------------------------------------------------------------

HRESULT
CTable::Save(CStreamWriteBuff *pStmWrBuff, BOOL fEnd)
{
    HRESULT hr;

    if (!fEnd)
    {
        // remember whether stream is building the repeating template
        _fBuildingTemplate = !!pStmWrBuff->TestFlag(WBF_DATABIND_MODE);

        // turn off "building-template" mode;  this allows nested tables to inject
        // their header/footer/caption into the template
        pStmWrBuff->ClearFlags(WBF_DATABIND_MODE);
    }

    hr = THR(super::Save(pStmWrBuff, fEnd));

    if (fEnd)
    {
        // restore the original value of "building-template" mode
        if (_fBuildingTemplate)
            pStmWrBuff->SetFlags(WBF_DATABIND_MODE);
        else
            pStmWrBuff->ClearFlags(WBF_DATABIND_MODE);
    }

    RRETURN(hr);
}


#ifndef NO_DATABINDING
//+---------------------------------------------------------------------------
//
//  Member:     OnDataReady
//
//  Synopsis:   Notification that datasource is ready to provide data
//
//  Retruns:    nothing
//
//----------------------------------------------------------------------------

void
CDBindMethodsTable::OnDataReady(CElement *pElem, BOOL fReady) const
{
    CTable *pTable = DYNCAST(CTable, pElem);
    CTableLayout *pTableLayout = pTable->TableLayoutCache();

    Assert(pTableLayout);
    
    if (fReady)
    {
        IGNORE_HR(pTableLayout->Populate());
    }
    else
    {
        CDetailGenerator *pDG = pTableLayout->_pDetailGenerator;

        if (pDG)
        {
            if (pTable->_fEnableDatabinding)
            {
                IGNORE_HR(pTableLayout->DeleteGeneratedRows());
                IGNORE_HR(pDG->RestoreTemplate());
            }

            pTableLayout->_pDetailGenerator = NULL;
            pTableLayout->_fRefresh = FALSE;
            pTableLayout->ResetMinMax();
            
            pDG->Detach();
            delete pDG;
        }
    }
}

HRESULT
CDBindMethodsTable::BoundValueToElement(CElement *, LONG, BOOL, LPVOID) const
{
    Assert(FALSE);
    return E_UNEXPECTED;
}

HRESULT
CDBindMethodsTable::BoundValueFromElement(CElement *, LONG, BOOL, LPVOID) const
{
    Assert(FALSE);
    return E_UNEXPECTED;
}
#endif // ndef NO_DATABINDING

//+---------------------------------------------------------------------------
//
//  Member:     Refresh (regenerate)
//
//  Synopsis:   Populate the table with repeated rows when setting the new
//              RepeatSrc property.
//
//  Retruns:    HRESULT
//
//----------------------------------------------------------------------------
STDMETHODIMP
CTable::refresh()
{
    HRESULT hr = S_OK;

#ifndef NO_DATABINDING
    // Table delegates refresh to table layout.
    hr = TableLayoutCache()->refresh();
#endif // ndef NO_DATABINDING
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     nextPage (public, callable from script code)
//
//  Synopsis:   Only for repeated data-bound tables that have a specified
//              pageSize parameter, display the next pageSize data records.
//
//  Retruns:    HRESULT
//
//----------------------------------------------------------------------------
STDMETHODIMP
CTable::nextPage()
{
    HRESULT hr = E_FAIL;
#ifndef NO_DATABINDING
    CTableLayout *pTableLayout = TableLayoutCache();
    Assert(pTableLayout);

    if (pTableLayout->_pDetailGenerator)
        hr = pTableLayout->_pDetailGenerator->nextPage();
#endif
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     previousPage (public, callable from script code)
//
//  Synopsis:   Only for repeated data-bound tables that have a specified
//              pageSize parameter, display the previous pageSize data records.
//
//  Retruns:    HRESULT
//
//----------------------------------------------------------------------------
STDMETHODIMP
CTable::previousPage()
{
    HRESULT hr = E_FAIL;
#ifndef NO_DATABINDING
    CTableLayout *pTableLayout = TableLayoutCache();
    Assert(pTableLayout);

    if (pTableLayout->_pDetailGenerator)
        hr = pTableLayout->_pDetailGenerator->previousPage();
#endif
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     firstPage (public, callable from script code)
//
//  Synopsis:   Only for repeated data-bound tables that have a specified
//              pageSize parameter, display the first pageSize data records.
//
//  Retruns:    HRESULT
//
//----------------------------------------------------------------------------
STDMETHODIMP
CTable::firstPage()
{
    HRESULT hr = E_FAIL;
#ifndef NO_DATABINDING
    CTableLayout *pTableLayout = TableLayoutCache();
    Assert(pTableLayout);

    if (pTableLayout->_pDetailGenerator)
        hr = pTableLayout->_pDetailGenerator->firstPage();
#endif
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     lastPage (public, callable from script code)
//
//  Synopsis:   Only for repeated data-bound tables that have a specified
//              pageSize parameter, display the last pageSize data records.
//
//  Retruns:    HRESULT
//
//----------------------------------------------------------------------------
STDMETHODIMP
CTable::lastPage()
{
    HRESULT hr = E_FAIL;
#ifndef NO_DATABINDING
    CTableLayout *pTableLayout = TableLayoutCache();
    Assert(pTableLayout);

    if (pTableLayout->_pDetailGenerator)
        hr = pTableLayout->_pDetailGenerator->lastPage();
#endif
    RRETURN(SetErrorInfo(hr));
}



//+------------------------------------------------------------------------
//
//  Member:     put_dataPageSize, IHTMLTable
//
//  Synopsis:   change the page size
//
//  Arguments:  v       new page size
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
STDMETHODIMP
CTable::put_dataPageSize(long v)
{
    HRESULT hr;
    CTableLayout *pTableLayout;

    // sanitize
    if (v < 0)
        v = 0;
    
    // set the new page size
    hr = s_propdescCTabledataPageSize.b.SetNumberProperty(v, this, CVOID_CAST(GetAttrArray()));

    // tell the repetition agent
    pTableLayout = TableLayoutCache();
    Assert(pTableLayout);

    if (!hr && pTableLayout->_pDetailGenerator)
        IGNORE_HR(pTableLayout->_pDetailGenerator->SetPageSize(v));

    RRETURN(SetErrorInfo(hr));
}


//+------------------------------------------------------------------------
//
//  Member:     get_dataPageSize, IHTMLTable
//
//  Synopsis:   return the page size
//
//  Arguments:  v       where to store page size
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
STDMETHODIMP
CTable::get_dataPageSize(long * p)
{
        return s_propdescCTabledataPageSize.b.GetNumberProperty(p, this, CVOID_CAST(GetAttrArray()));
}

//+------------------------------------------------------------------------
//
//  Member:     FindRepeatingContext, public
//
//  Synopsis:   find the enclosing repeated element with the given dataSrc
//              and dataFld attributes
//
//  Arguments:  strDataSrc  look for an element with this dataSrc attribute
//              strDataFld     ... and this dataFld attribute
//              ppElement   enclosing element
//              ppInstance  instance of repetition that contains me
//
//  Returns:    S_OK        found it
//              S_FALSE     found a syntactically enclosing element, but it's not
//                          repeating, *ppInstance will be NULL
//              E_FAIL      couldn't find an enclosing element

HRESULT
CTable::GetInstanceForRow(CTableRow *pRow, CRecordInstance **ppInstance)
{
    HRESULT hr;
    Assert(pRow);
    
#ifndef NO_DATABINDING
    CTableLayout *pTableLayout = TableLayoutCache();
    Assert(pTableLayout);

    if (pTableLayout->IsRepeating())
    {
        CDetailGenerator *pDG = pTableLayout->_pDetailGenerator;
        CRecordInstance *pRecInstance = pDG->GetInstanceForRow(pRow->_iRow);

        *ppInstance = pRecInstance;
        hr = (pRecInstance)? S_OK : E_FAIL;
    }
    else
#endif
    {
        hr = S_FALSE;
    }

    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CTable::IsRepeating
//
//----------------------------------------------------------------------------

BOOL
CTable::IsRepeating()
{
    CDetailGenerator *pDG = TableLayoutCache()->_pDetailGenerator;
    return pDG ? pDG->IsRepeating() : FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CTable::GetDataSrc
//
//----------------------------------------------------------------------------

LPCTSTR
CTable::GetDataSrc()
{
    CDetailGenerator *pDG = TableLayoutCache()->_pDetailGenerator;
    return pDG ? pDG->GetDataSrc() : NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CTable::GetDataFld
//
//----------------------------------------------------------------------------

LPCTSTR
CTable::GetDataFld()
{
    CDetailGenerator *pDG = TableLayoutCache()->_pDetailGenerator;
    return pDG ? pDG->GetDataFld() : NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CTable::IsFieldKnown
//
//----------------------------------------------------------------------------

BOOL
CTable::IsFieldKnown(LPCTSTR strField)
{
    CDetailGenerator *pDG = TableLayoutCache()->_pDetailGenerator;
    return pDG ? pDG->IsFieldKnown(strField) : FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CTable::AddDataboundElement
//
//----------------------------------------------------------------------------

HRESULT
CTable::AddDataboundElement(CElement *pElement, LONG id,
                                CTableRow *pRowContaining, LPCTSTR strField)
{
    CDetailGenerator *pDG = TableLayoutCache()->_pDetailGenerator;
    AssertSz(pDG, "Can't add databound element to a non-repeating table");
    return pDG->AddDataboundElement(pElement, id, pRowContaining, strField);
}


//+---------------------------------------------------------------------------
//
//  Member:     CTable::GetProvider
//
//----------------------------------------------------------------------------

CDataSourceProvider *
CTable::GetProvider()
{
    return GetDBMembers()->GetBinder(ID_DBIND_DEFAULT)->GetProvider();
}


//+---------------------------------------------------------------------------
//
//  Member:     CTable::OnReadyStateChange
//
//----------------------------------------------------------------------------

void
CTable::OnReadyStateChange()
{   // do not call super::OnReadyStateChange here - we handle firing the event ourselves
    SetReadyStateTable(_readyStateTable);
}

//+------------------------------------------------------------------------
//
//  Member:     CTable::SetReadyStateTable
//
//  Synopsis:   Use this to set the ready state;
//              it fires onreadystate change if needed.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CTable::SetReadyStateTable(long readyStateTable)
{
    long readyState;

    _readyStateTable = readyStateTable;

    readyState = min ((long)_readyStateTable, super::GetReadyState());

    if ((long)_readyStateFired != readyState)
    {
        _readyStateFired = readyState;

        if (_readyStateTable == READYSTATE_INTERACTIVE)
        {
            // now, we are about to populate the table, we can use incremental recalc
            Assert(ShouldHaveLayout());
            TableLayoutCache()->ResetIncrementalRecalc();
        }

        // if the readystate is changing because we're leaving the tree
        // (and hence detaching the detail generator), don't fire any
        // events.  It's too late, anyway.  (IE6 bug 25897)
        if (!_fExittreePending)
        {
            Fire_onreadystatechange();
        }
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CTable:get_readyState
//
//  Synopsis:  this is for the OM and uses the long _lReadyState
//      to determine the string returned.
//
//+------------------------------------------------------------------------------

HRESULT
CTable::get_readyState(BSTR * p)
{
    HRESULT hr = S_OK;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR(s_enumdeschtmlReadyState.StringFromEnum(_readyStateTable, p));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CTable::get_readyState(VARIANT * pVarRes)
{
    HRESULT hr = S_OK;

    if (!pVarRes)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = get_readyState(&V_BSTR(pVarRes));
    if (!hr)
        V_VT(pVarRes) = VT_BSTR;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\builtin\table.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       table.cxx
//
//  Contents:   CTable and related classes.
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include <formkrnl.hxx>
#endif

#ifndef X_TABLE_HXX_
#define X_TABLE_HXX_
#include "table.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include <download.hxx>
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include <othrguid.h>
#endif

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include <binder.hxx>
#endif

#ifndef X_DETAIL_HXX_
#define X_DETAIL_HXX_
#include <detail.hxx>
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include <treepos.hxx>
#endif

#ifndef X_PROPS_HXX_
#define X_PROPS_HXX_
#include "props.hxx"
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include <ltable.hxx>
#endif

#ifndef X_LTROW_HXX_
#define X_LTROW_HXX_
#include <ltrow.hxx>
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#define _cxx_
#include "table.hdl"

MtDefine(CTable, Elements, "CTable")
MtDefine(BldRowsCol, PerfPigs, "Build CTable::TABLE_ROWS_COLLECTION")
MtDefine(BldBodysCol, PerfPigs, "Build CTable::TABLE_BODYS_COLLECTION")
MtDefine(BldCellsCol, PerfPigs, "Build CTable::TABLE_CELLS_COLLECTOIN")

ExternTag(tagTableRecalc);
extern void __cdecl WriteHelp(HANDLE hFile, TCHAR *format, ...);
extern void WriteString(HANDLE hFile, TCHAR *pszStr);


const ELEMENT_TAG s_atagTSection[] = {ETAG_TBODY, ETAG_THEAD, ETAG_TFOOT, ETAG_NULL};

#ifndef NO_PROPERTY_PAGE
const CLSID * const CTable::s_apclsidPages[] =
{
    // Browse-time pages
    NULL,
    // Edit-time pages
#if DBG==1    
    &CLSID_CCDGenericPropertyPage,
    &CLSID_CInlineStylePropertyPage,
#endif // DBG==1    
    NULL
};
#endif // NO_PROPERTY_PAGE


const CElement::CLASSDESC CTable::s_classdesc =
{
    {
        &CLSID_HTMLTable,               // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_NEVERSCROLL    |
        ELEMENTDESC_NOTIFYENDPARSE |
        ELEMENTDESC_NOPCTRESIZE,        // _dwFlags
        &IID_IHTMLTable,                // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLTable,         // _pfnTearOff
    NULL                                // _pAccelsRun
};


HRESULT
CTable::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(pht->Is(ETAG_TABLE));
    Assert(ppElement);

    *ppElement = new CTable(pDoc);
    RRETURN( (*ppElement) ? S_OK : E_OUTOFMEMORY);
}


CTable::CTable(CDoc *pDoc)
    : super(ETAG_TABLE, pDoc)
{
    _fOwnsRuns    = TRUE;
}


//+------------------------------------------------------------------------
//
//  Member:     CTable::destructor, CBase
//
//  Note:       The collection cache must be deleted in the destructor, and
//              not in Passivate, because collection objects we've handed out
//              (via get_rows) merely SubAddRef the table.
//-------------------------------------------------------------------------

CTable::~CTable()
{
    delete _pCollectionCache;

}


//+------------------------------------------------------------------------
//
//  Member:     CTable::Notify
//
//  Synopsis:   Catch the leave-tree notification
//
//-------------------------------------------------------------------------

void
CTable::Notify(CNotification *pNF)
{
    CTableLayout *  pTableLayout;
    HRESULT         hr;
    DWORD           dw;

    pTableLayout = TableLayoutCache();
    Assert(pTableLayout);

    if (pNF->IsType(NTYPE_ELEMENT_EXITTREE_1))
    {
        _fEnableDatabinding = FALSE;
    }

    super::Notify(pNF);

    switch (pNF->Type())
    {
    case NTYPE_ELEMENT_ENTERTREE:
        dw = pNF->DataAsDWORD();
        if (!(dw & ENTERTREE_PARSE))
        {
            pTableLayout->_fDontSaveHistory = TRUE;
        }
        if (!(dw & ENTERTREE_PARSE) && !(dw & ENTERTREE_MOVE))  // if the element cretead NOT via PARSing nor MOVing HTML
        {
            pTableLayout->_fCompleted = TRUE; // we are not going to have NTYPE_END_PARSE notification to set the _fCompleted bit
        }
        _fEnableDatabinding = TRUE;

        // Load the history stream
        // TODO (jbeda) this should probably happen during NTYPE_DELAY_LOAD_HISTORY
        IGNORE_HR(GetMarkup()->GetLoadHistoryStream(GetSourceIndex(), 
                                                    HistoryCode(), 
                                                    &_pStreamHistory));

        _iDocDotWriteVersionEnterTree = Doc()->_iDocDotWriteVersion;
        break;

    case NTYPE_ELEMENT_EXITTREE_1:
        pTableLayout->ClearTopTableLayoutCache(); // Don't hold refs to the tree after our element leaves it

        // Whenever we clear the TLC, we have to mark it dirty in case the element
        // reenters the tree at some point.
        pTableLayout->MarkTableLayoutCacheDirty();

        // 47172: Make sure we don't think we're hanging on to the caption dispnode.
        pTableLayout->_fHasCaptionDispNode = FALSE;
        if (pTableLayout->GetTableBorderRenderer())
            pTableLayout->GetTableBorderRenderer()->_pDispNode = NULL;

        ClearInterface(&_pStreamHistory);
        break;

        break;

    case NTYPE_END_PARSE:
        Assert (!pTableLayout->_fCompleted && "NTYPE_END_PARSE notification happened more then once");

        if (_iDocDotWriteVersionEnterTree != Doc()->_iDocDotWriteVersion)
        {
            // there were document.write in between <TABLE> and </TABLE> parsing
            pTableLayout->_fDontSaveHistory = TRUE;
            ClearInterface(&_pStreamHistory);     // don't use history
            if (pTableLayout->_fUsingHistory)     // if we are already using History
            {
                if(pTableLayout->_fCompleted)
                    pTableLayout->Resize();       // then, ensure full resize.
            }
        }
        if (!pTableLayout->_fCompleted)           // (even with the above Assert), make sure we don't do this more then ONCE
        {
            hr = pTableLayout->EnsureCells();
            if (hr)
                return;

            hr = pTableLayout->ensureTBody();
            if (hr)
                return;

            pTableLayout->_fCompleted = TRUE;     // loading/parsing of the table is complete.

    #ifndef NO_DATABINDING
            DBMEMBERS * pdbm = GetDBMembers();
            if (pdbm)
            {
                pdbm->MarkReadyToBind();
            }
    #endif // ndef NO_DATABINDING

            ResizeElement();
        }
        break;

    case NTYPE_SAVE_HISTORY_1:
        if (   !pTableLayout->_fDontSaveHistory  
            && pTableLayout->_fCompleted
            && pTableLayout->_fCalcedOnce
            && !pTableLayout->_fTLCDirty
            && pTableLayout->_aryRows.Size() >= 1
            && pTableLayout->GetCols() >= 1
            && !pTableLayout->IsFixed() 
            && !IsDatabound())
        {
            pNF->SetSecondChanceRequested();
        }
        break;

    case NTYPE_SAVE_HISTORY_2:
        // Do not save history for small tables or for tables that are already using "fixed" style
        //  or for tables that haven't been finished being parsed (bug 57537)
        if (   !pTableLayout->_fDontSaveHistory  
            && pTableLayout->_fCompleted
            && pTableLayout->_fCalcedOnce
            && !pTableLayout->_fTLCDirty
            && pTableLayout->_aryRows.Size() >= 1
            && pTableLayout->GetCols() >= 1
            && !pTableLayout->IsFixed() 
            && !IsDatabound())
        {
            CHistorySaveCtx *   phsc;

            pNF->Data((void **)&phsc);
            hr = pTableLayout->SaveHistoryValue(phsc);
        }

        break;
    }

    return;
}


//+----------------------------------------------------------------------------
//
//  Member:     CTable::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-----------------------------------------------------------------------------

HRESULT
CTable::PrivateQueryInterface ( REFIID iid, void ** ppv )
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_INHERITS2(this, IUnknown, IHTMLTable)
        QI_HTML_TEAROFF(this, IHTMLElement2, NULL)
        QI_HTML_TEAROFF(this, IHTMLTable, NULL)
        QI_TEAROFF(this, IHTMLTable2, NULL)
        QI_HTML_TEAROFF(this, IHTMLTable3, NULL)
        QI_TEAROFF_DISPEX(this, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CTable::Init2(), CElement
//
//  Synopsis:   called after calls to: Init(), InitAttrBag()
//
//-------------------------------------------------------------------------

HRESULT
CTable::Init2(CInit2Context * pContext)
{
    HRESULT hr;

    hr = THR(super::Init2(pContext));
    if (!OK(hr))
        goto Cleanup;

    _readyStateTable = FormsIsEmptyString(GetAAdataSrc()) ? READYSTATE_COMPLETE : READYSTATE_LOADING;

Cleanup:
    RRETURN(hr);
}



//+------------------------------------------------------------------------
//
//  Member:     ApplyDefaultFormat
//
//  Synopsis:   Applies default formatting properties for that element to
//              the char and para formats passed in
//
//  Arguments:  pCF - charformat to apply default properties on
//              pPF - paraformat to apply default properties on
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CTable::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    const CCharFormat * pCF;
    CColorValue ccvBorderColor;
    CTreeNode * pNodeBody;
    BOOL        fVisibilityHidden;
    BOOL        fDisplayNone;
    BOOL        fHasBgImage;
    BOOL        fHasBgColor;
    BOOL        fDisabled;
    BOOL        fEditable;
    BOOL        fRelative;
    BOOL        fNoBreak;
    BOOL        fHaveBorderColor = FALSE;
    LONG        fRTL;
    LONG        lCursorIndex;
    COLORREF    cr;
    BYTE        i;
    HRESULT     hr = S_OK;
    CTableLayout *pTableLayout = TableLayoutCache();
    CMarkup *   pMarkup;
    CDoc *      pDoc = Doc();
    BYTE        uLayoutGridModeInner;
    BYTE        uLayoutGridMode;
    BYTE        wLayoutFlow;
    BOOL        fHasInlineBg;
    BOOL        fWritingModeUsed;


    pCFI->PrepareCharFormat();
    pCFI->PrepareFancyFormat();

    // cache the values before init default
    fVisibilityHidden = pCFI->_cf()._fVisibilityHidden;
    fDisplayNone      = pCFI->_cf()._fDisplayNone;
    fRTL              = pCFI->_cf()._fRTL;
    fHasBgColor       = pCFI->_cf()._fHasBgColor;
    fHasBgImage       = pCFI->_cf()._fHasBgImage;
    fDisabled         = pCFI->_cf()._fDisabled;
    fEditable         = pCFI->_cf()._fEditable;
    fRelative         = pCFI->_cf()._fRelative;
    lCursorIndex      = pCFI->_cf()._bCursorIdx;
    fNoBreak          = pCFI->_cf()._fNoBreak;
  
    uLayoutGridModeInner    = pCFI->_cf()._uLayoutGridModeInner;
    uLayoutGridMode         = pCFI->_cf()._uLayoutGridMode;
    wLayoutFlow             = pCFI->_cf()._wLayoutFlow;
    fHasInlineBg            = pCFI->_cf()._fHasInlineBg;
    fWritingModeUsed        = pCFI->_cf()._fWritingModeUsed;

    pMarkup = GetMarkupPtr();
    
    if (    !pMarkup
        ||  !pMarkup->PaintBackground() )
    {
        cr = 0;
        ccvBorderColor.SetValue(cr, FALSE);
    }
    else
    {
        ccvBorderColor = GetAAborderColor();
        if (ccvBorderColor.IsDefined())
        {
            fHaveBorderColor = TRUE;

            cr = ccvBorderColor.GetColorRef();
        }
        else
        {
            CLayout * pParentLayout = GetUpdatedParentLayout(GUL_USEFIRSTLAYOUT);
            cr = GetSysColorQuick(COLOR_BTNHIGHLIGHT);
            if (pParentLayout && (0x00FFFFFF & pParentLayout->ElementOwner()->GetInheritedBackgroundColor()) == (0x00FFFFFF & cr))
            {
                cr = GetSysColorQuick(COLOR_BTNFACE);
            }

            ccvBorderColor.SetValue(cr, FALSE);
        }

        pCFI->_ff()._bd._ccvBorderColorLight   =
        pCFI->_ff()._bd._ccvBorderColorHilight = GetAAborderColorLight();
        pCFI->_ff()._bd._ccvBorderColorDark    =
        pCFI->_ff()._bd._ccvBorderColorShadow  = GetAAborderColorDark();
    }

    for (i = 0; i < SIDE_MAX; i++)
    {
        pCFI->_ff()._bd.SetBorderColor(i, ccvBorderColor);
    }

    if (!pCFI->_ff()._bd._ccvBorderColorLight.IsDefined())
        pCFI->_ff()._bd._ccvBorderColorLight.SetValue(cr, FALSE);
    if (!pCFI->_ff()._bd._ccvBorderColorHilight.IsDefined())
        pCFI->_ff()._bd._ccvBorderColorHilight.SetValue(cr, FALSE);

    if (    pMarkup
        &&  pMarkup->PaintBackground()
        &&  !fHaveBorderColor )
    {
        cr = GetSysColorQuick(COLOR_BTNSHADOW);
    }

    if (!pCFI->_ff()._bd._ccvBorderColorDark.IsDefined())
        pCFI->_ff()._bd._ccvBorderColorDark.SetValue(cr, FALSE);
    if (!pCFI->_ff()._bd._ccvBorderColorShadow.IsDefined())
        pCFI->_ff()._bd._ccvBorderColorShadow.SetValue(cr, FALSE);

    // Tables don't allow any character formatting information to leak through
    // except for font names & inline style display, and layout grid
    // However this does not apply for Strict CSS1 Document

    // the logic: 
    // if no markup available - behave like in non CSS1 compat mode;
    // if there is a markup - check it for CSS1 flag;
    
    if (    !pMarkup // (olego 02/15/02) fix for Windows Bug # 542527
        ||  !pMarkup->IsStrictCSS1Document()) 
    {
        pCFI->_cf().InitDefault(
            pDoc->_pOptionSettings,
            pMarkup ? pMarkup->GetCodepageSettings() : NULL,
            pCFI->_cf()._fExplicitFace);


        // restore of init default
        pCFI->_cf()._fVisibilityHidden = fVisibilityHidden;
        pCFI->_cf()._fDisplayNone      = fDisplayNone;
        pCFI->_cf()._fRTL              = fRTL;
        pCFI->_cf()._fHasBgColor       = fHasBgColor;
        pCFI->_cf()._fHasBgImage       = fHasBgImage;
        pCFI->_cf()._fDisabled         = fDisabled;
        pCFI->_cf()._fEditable         = fEditable;
        pCFI->_cf()._fRelative         = fRelative;
        pCFI->_cf()._bCursorIdx        = lCursorIndex;
        pCFI->_cf()._fNoBreak          = fNoBreak;
        pCFI->_cf()._uLayoutGridModeInner   = uLayoutGridModeInner;
        pCFI->_cf()._uLayoutGridMode        = uLayoutGridMode;
        pCFI->_cf()._wLayoutFlow       = wLayoutFlow;
        pCFI->_cf()._fHasInlineBg      = fHasInlineBg;
        pCFI->_cf()._fWritingModeUsed  = fWritingModeUsed;

        // if we do not want text alignment to be inheritted by the table
        // from its parent
        pCFI->_bCtrlBlockAlign  = pCFI->_bBlockAlign;
        pCFI->_bBlockAlign      = htmlBlockAlignNotSet;

        // Now get the text color default value from the body tag.
        // We do it this way because color attribute values don't leak into
        // tables.
        pNodeBody = GetFirstBranch()->SearchBranchToRootForTag( ETAG_BODY );
        if (pNodeBody)
        {
            pCF = pNodeBody->GetCharFormat();
            pCFI->_cf()._ccvTextColor = pCF->_ccvTextColor;
        }
    }

    // This is where to put the code to inherit character attributes created by
    // styles.
    /* */

    pCFI->PrepareParaFormat();

    // set up for potential EMs, ENs, and ES Conversions
    pCFI->_pf()._lFontHeightTwips = pCFI->_cf().GetHeightInTwips( pDoc );
    if (pCFI->_pf()._lFontHeightTwips <=0)
        pCFI->_pf()._lFontHeightTwips = 1;

    // Tables don't inherit vertical alignment from containing tables.
    pCFI->_pf()._bTableVAlignment = htmlCellVAlignNotSet;

    // iniitalize the default paragraph property for PRE, if we are inside PRE it shouldn't effect the cells
    pCFI->_pf()._fPre      = FALSE;
    pCFI->_pf()._fPreInner = FALSE;
    pCFI->_pf()._cuvTextIndent = 0;

    pCFI->UnprepareForDebug();

    hr = super::ApplyDefaultFormat( pCFI );

    pCFI->PrepareFancyFormat();

    // TODO (olego IE6 20201) cleanup initialization of table related layouts' data at the 
    // time other when calculating layout (like these below). This 1) forces table / table 
    // row layout to have the same lifetime as corresponding elements; 2) is buggy because 
    // it does not check for different compute formats modes and sometime picks up bits 
    // from uninitialized fields of formats. 3) Etc... 

    if (!(pCFI->_eExtraValues & ComputeFormatsType_GetValue))   // IE6 15607
    {
        // This initialization should be done at compute format time 
        // because it is used as early as at table construction (AddRow, AddCell, etc). 
        pTableLayout->_fFixed = pCFI->_ff()._bTableLayout;
        pTableLayout->_fCollapse = pCFI->_ff()._bd._bBorderCollapse;
    }

    // Clear the border default and the cache on table.
    pCFI->_ff()._bd._fOverrideTablewideBorderDefault = FALSE;
    pTableLayout->_fBorderInfoCellDefaultCached = FALSE;

    pCFI->UnprepareForDebug();

    RRETURN( hr );
}



//+------------------------------------------------------------------------
//
//  Collection cache items implementation for TABLE collection
//
//-------------------------------------------------------------------------

class CTableRowsCollectionCacheItem : public CTableCollectionCacheItem
{
    typedef CTableCollectionCacheItem super;

protected:
#if NEED_A_SOURCE_ORDER_ITERATOR
    unsigned    _fAryRowsInSourceOrder: 1;
#else
    int         _iRow;  // index to _aryRows array for _lCurrentIndex
#endif

public:
    DECLARE_MEMCLEAR_NEW_DELETE(Mt(BldRowsCol))
    CTableRowsCollectionCacheItem(CTable *pTable) {_pTableLayout = pTable->TableLayoutCache(); }
    CElement *GetNext (void);
    CElement *GetAt ( long lIndex );
    long Length ( void );
};

class CTableBodysCollectionCacheItem : public CTableCollectionCacheItem
{
    typedef CTableCollectionCacheItem super;

public:
    DECLARE_MEMCLEAR_NEW_DELETE(Mt(BldBodysCol))
    CTableBodysCollectionCacheItem(CTable *pTable) {_pTableLayout = pTable->TableLayoutCache(); }
    CElement *GetAt ( long lIndex );
    long Length ( void );
};

//+------------------------------------------------------------------------
//
//  Generic TABLE collection (abstract class)
//
//-------------------------------------------------------------------------
CElement *
CTableCollectionCacheItem::GetNext ( void )
{
    return GetAt ( _lCurrentIndex++ );
}

CElement *
CTableCollectionCacheItem::MoveTo ( long lIndex )
{
    _lCurrentIndex = lIndex;
    return GetAt(lIndex);
}

//+------------------------------------------------------------------------
//
//  TABLE ROWS collection
//
//-------------------------------------------------------------------------

CElement *
CTableRowsCollectionCacheItem::GetNext ( void )
{
    if (_lCurrentIndex++ < _pTableLayout->_aryRows.Size())
    {
        CTableRow * pRow = _pTableLayout->_aryRows[_iRow];
        _iRow = _pTableLayout->GetNextRow(_iRow);
        return pRow;
    }
    return NULL;
}

CElement *
CTableRowsCollectionCacheItem::GetAt ( long lIndex )
{
    Assert ( lIndex >= 0 );
    if (lIndex < _pTableLayout->_aryRows.Size())
    {
#if NEED_A_SOURCE_ORDER_ITERATOR
        return _fAryRowsInSourceOrder
            ? _pTableLayout->_aryRows[lIndex] 
            : _pTableLayout->GetRowInSourceOrder(lIndex)
#else
        _iRow = _pTableLayout->VisualRow2Index(lIndex);
        _lCurrentIndex = lIndex;
        return _pTableLayout->_aryRows[_iRow];
#endif
    }
    return NULL;
}

long 
CTableRowsCollectionCacheItem::Length ( void )
{
#if NEED_A_SOURCE_ORDER_ITERATOR
    _fAryRowsInSourceOrder = _pTableLayout->IsAryRowsInSourceOrder();
#endif
    return _pTableLayout->_aryRows.Size();
}

//+------------------------------------------------------------------------
//
//  TABLE BODYS collection
//
//-------------------------------------------------------------------------

CElement *
CTableBodysCollectionCacheItem::GetAt ( long lIndex )
{
    Assert ( lIndex >= 0 );
    return (lIndex < _pTableLayout->_aryBodys.Size())?_pTableLayout->_aryBodys[lIndex] : NULL;
}

long 
CTableBodysCollectionCacheItem::Length ( void )
{
    return _pTableLayout->_aryBodys.Size();
}


//+------------------------------------------------------------------------
//
//  TABLE CELLS collection
//
//-------------------------------------------------------------------------

CElement *
CTableCellsCollectionCacheItem::MoveTo ( long lIndex )
{
    int iRowIndex;

    _lCurrentCellIndex = lIndex;
    iRowIndex = SetCurrentRowAndGetRowIndex(lIndex);
    if (iRowIndex >= 0)
    {
        return super::MoveTo(iRowIndex);
    }
    return NULL;
}

CElement *
CTableCellsCollectionCacheItem::GetNext ( void )
{
    _lCurrentCellIndex++;
    if (_pRowLayout && _lCurrentIndex < _pRowLayout->_cRealCells)
    {
        return super::GetNext();
    }
    else
    {
        int iRow = _pRowLayout? _pTableLayout->GetNextRowSafe(_pRowLayout->RowPosition()) : _pTableLayout->GetFirstRow();  // get next row in visual order
        while (iRow < _pTableLayout->_aryRows.Size())
        {
            CTableRowLayout *pRowLayout = _pTableLayout->_aryRows[iRow]->RowLayoutCache();
            if (pRowLayout)
            {
                _pRowLayout = pRowLayout;
                if (CTableRowCellsCollectionCacheItem::MoveTo(0))   // if there are cells in this row 
                    return CTableRowCellsCollectionCacheItem::GetNext();    //then return the 0 and prepare for the next
                else
                    iRow = _pTableLayout->GetNextRowSafe(_pRowLayout->RowPosition());
            }
        }
    }
    return NULL;
}


CElement *
CTableCellsCollectionCacheItem::GetAt ( long lIndex )
{
    int iRowIndex = SetCurrentRowAndGetRowIndex(lIndex);
    if (iRowIndex >= 0)
    {
        return super::GetAt(iRowIndex);
    }
    return NULL;
}

int  
CTableCellsCollectionCacheItem::SetCurrentRowAndGetRowIndex(int lIndex)
{
    int cRows = _pTableLayout->_aryRows.Size();
    if (cRows)
    {
        int cR, iRow;
        int cRealCells = 0;
        for (cR = cRows, iRow = _pTableLayout->GetFirstRow();
            cR > 0;
            cR--, iRow = _pTableLayout->GetNextRow(iRow))   // get next row in visual order
        {
            _pRowLayout = _pTableLayout->_aryRows[iRow]->RowLayoutCache();
            if (lIndex < cRealCells + _pRowLayout->_cRealCells)
            {
                break;
            }
            cRealCells += _pRowLayout->_cRealCells;
        }

        return lIndex - cRealCells;   // relative to the row index
    }
    return -1;
}

long 
CTableCellsCollectionCacheItem::Length ( void )
{
    int i, cRows;
    int cRealCells = 0;
    cRows = _pTableLayout->_aryRows.Size();
    for (i = 0; i < cRows; i++)
    {
        cRealCells += _pTableLayout->_aryRows[i]->RowLayoutCache()->_cRealCells;
    }
    return cRealCells;
}

//+------------------------------------------------------------------------
//
//  Member:     EnsureCollectionCache
//
//  Synopsis:   Create the table's collection cache if needed.
//
//-------------------------------------------------------------------------

HRESULT
CTable::EnsureCollectionCache()
{
    HRESULT hr = S_OK;

    hr = TableLayoutCache()->EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    if (!_pCollectionCache)
    {
        _pCollectionCache = new CCollectionCache(
                this,          // double cast needed for Win16.
                GetWindowedMarkupContext(),
                ENSURE_METHOD(CTable, EnsureCollections, ensurecollections));
        if (!_pCollectionCache)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(_pCollectionCache->InitReservedCacheItems(NUMBER_OF_TABLE_COLLECTION, NUMBER_OF_TABLE_COLLECTION));
        if (hr)
            goto Error;

        CTableRowsCollectionCacheItem *pRowsCollection = new CTableRowsCollectionCacheItem(this);
        if ( !pRowsCollection )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(_pCollectionCache->InitCacheItem ( TABLE_ROWS_COLLECTION, pRowsCollection ));
        if (hr)
            goto Cleanup;

        CTableBodysCollectionCacheItem *pBodysCollection = new CTableBodysCollectionCacheItem(this);
        if ( !pBodysCollection )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(_pCollectionCache->InitCacheItem ( TABLE_BODYS_COLLECTION, pBodysCollection ));
        if (hr)
            goto Cleanup;

        CTableCellsCollectionCacheItem *pCellsCollection = new CTableCellsCollectionCacheItem(this);
        if ( !pCellsCollection )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(_pCollectionCache->InitCacheItem ( TABLE_CELLS_COLLECTION, pCellsCollection ));
        if (hr)
            goto Cleanup;
        
        //
        // Collection cache now owns this item & is responsible for freeing it
        //
    }

Cleanup:
    RRETURN(hr);

Error:
    delete _pCollectionCache;
    _pCollectionCache = NULL;
    goto Cleanup;
}


//+------------------------------------------------------------------------
//
//  Member:     EnsureCollections
//
//  Synopsis:   Refresh the table rows collection, if needed.
//
//-------------------------------------------------------------------------

HRESULT
CTable::EnsureCollections(long lIndex, long * plCollectionVersion)
{
    Assert ( lIndex < NUMBER_OF_TABLE_COLLECTION  && plCollectionVersion); // parameter validation

    HRESULT hr = S_OK;

    CTableLayout *pTableLayout = TableLayoutCache();
    if ( pTableLayout)
    {
        hr = pTableLayout->EnsureTableLayoutCache();
        *plCollectionVersion = pTableLayout->_iCollectionVersion;   // to mark it done
    }

    RRETURN (hr);
}



//+---------------------------------------------------------------------------
//
//  Member: CTable::GetInfo
//
//  Params: [gi]: The GETINFO enumeration.
//
//  Descr:  Returns the information requested in the enum
//
//----------------------------------------------------------------------------
DWORD
CTable::GetInfo(GETINFO gi)
{
    switch (gi)
    {
    case GETINFO_ISCOMPLETED:
        return (TableLayoutCache()->_fCompleted ? TRUE : FALSE);
    }

    return super::GetInfo(gi);
}


#if DBG == 1
TCHAR g_achTabs[] = _T("\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t");
#define PRINTLN(f) WriteHelp(pF, _T("<0s>")_T(##f)_T("\n"), &g_achTabs[ARRAY_SIZE(g_achTabs) - iTabs]


void
CTableCol::Print(HANDLE pF, int iTabs)
{
    TCHAR           achBuf[30];
    const TCHAR *   psz;

    PRINTLN("\n*** COL ***\n") );
    psz = GetAAid();
    if (psz)
        PRINTLN("ID: <1s>"), psz);
    psz = GetAAname();
    if (psz)
        PRINTLN("NAME: <1s>"), psz);
    PRINTLN("_iCol: <1d>"), _iCol);
    PRINTLN("_cCols: <1d>"), _cCols);
    PRINTLN("CELLS = <1s>"), achBuf);

    GetFirstBranch()->GetCascadedwidth().FormatBuffer(achBuf, ARRAY_SIZE(achBuf), &s_propdescCTableColwidth.a);
    PRINTLN("WIDTH = <1s>"), achBuf);
}

void
CTableColCalc::Print(HANDLE pF, int iTabs)
{
    TCHAR achBuf[30];

    PRINTLN("\n*** COLCALC ***\n") );
    PRINTLN("_xMin: <1d>"), _xMin); // Moved to ColCalc
    PRINTLN("_xMax: <1d>"), _xMax);
    PRINTLN("_xWidth: <1d>"), _xWidth);
    _uvWidth.FormatBuffer(achBuf, ARRAY_SIZE(achBuf), &s_propdescCTableColwidth.a);
}


#endif // DBG == 1


//+------------------------------------------------------------------------
//
//  Member :    InvalidateCollections()
//
//  Synopsis :  invalidate the table's and documents collection caches
//
//-------------------------------------------------------------------------


void CTable::InvalidateCollections()
{
    CTableLayout * pTableLayout = TableLayoutCache();

    if (pTableLayout)
    {
        int i;

        pTableLayout->_iCollectionVersion++;  // this will tell the cache collection manager that our collection is updated

        if (_pCollectionCache)
            _pCollectionCache->Invalidate();  // this will reset collection version number

        for (i=0; i < pTableLayout->_aryBodys.Size(); i++)
        {
            pTableLayout->_aryBodys[i]->InvalidateCollections(this);
        }

        if (pTableLayout->_pHead)
        {
            pTableLayout->_pHead->InvalidateCollections(this);
        }
        if (pTableLayout->_pFoot)
        {
            pTableLayout->_pFoot->InvalidateCollections(this);
        }

        for (i=0; i<pTableLayout->_aryRows.Size(); i++)
        {
            pTableLayout->_aryRows[i]->InvalidateCollections();
        }
    }
}


HRESULT
CTable::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT        hr;
    CTableCaption *pCaption;
    CTableCaption **ppCaption;
    int            cC;
    CTableLayout  *pTableLayout = TableLayoutCache();

    switch(dispid)
    {
    case DISPID_CTable_cellSpacing: 
        // note, the cellSpacing is a part of the padding for the captions,
        // so we need make sure we remeasure them

        for (cC = pTableLayout->_aryCaptions.Size(), ppCaption = pTableLayout->_aryCaptions;
             cC > 0;
             cC--, ppCaption++)
        {

            pCaption = (*ppCaption);
            if (pCaption->Tag() == ETAG_CAPTION)
            {
                pCaption->RemeasureElement(0);
            }
        }
        pTableLayout->ResetMinMax();

        // Make sure super is asking for a layout.
        Assert(dwFlags | ELEMCHNG_SIZECHANGED);
        break;
         
    case DISPID_CTable_cellPadding: // "
        dwFlags |= ELEMCHNG_REMEASUREALLCONTENTS;

    case DISPID_A_BORDERWIDTH:      // CalculateBorderAndSpacing
    case DISPID_A_BORDERTOPWIDTH:   // "
    case DISPID_A_BORDERRIGHTWIDTH: // "
    case DISPID_A_BORDERBOTTOMWIDTH:// "
    case DISPID_A_BORDERLEFTWIDTH:  // "
    case DISPID_CTable_border:      // "

        // Whenever a table (border) property change has the ability
        // to toggle table cell borders on and off, we need to
        // remeasure all contents, so that the dispnodes can be updated.
        // If the table is collapsing borders and the borders on the
        // table are toggled on or off, this affects cell layouts
        // because their borders along the table edges be deactivated
        // or activated.  (45145, 50744)
        if (pTableLayout->CollapseBorders() || DISPID_CTable_border == dispid)
            dwFlags |= ELEMCHNG_REMEASUREALLCONTENTS;

        // fall through
    case DISPID_CTable_width:       // because Calc'MinMax sets MM to xWidth.
    case DISPID_A_BORDERCOLLAPSE:   // because every cell minmax will change

        pTableLayout->ResetMinMax();

        // Make sure super is asking for a layout.
        Assert(dwFlags | ELEMCHNG_SIZECHANGED);
        break;
    }

    hr = THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc));

    RRETURN(hr);
}

void CTableRow::DataTransferRequested() 
{ 
    Assert(Table());
    Assert(Table()->TableLayoutCache());

    // only allow a post dataTransferRequest if
    // 1. we are in a table
    // 2. we are not in the middle (bug 91460)
    if (   _iRow != -1         
        && _iRow+1 == Table()->TableLayoutCache()->GetRows())    
    {
        _fNeedDataTransfer = TRUE; 
    }
}

CTableRow *CTableCell::Row() const
{
    return DYNCAST(CTableRow, GetParentAncestorSafe(ETAG_TR));
}

CTableSection *CTableCell::Section() const
{
    return DYNCAST(CTableSection, GetParentAncestorSafe(s_atagTSection));
}

CTable *CTableCell::Table() const
{
    return DYNCAST(CTable, GetParentAncestorSafe(ETAG_TABLE));
}

CTable *CTableRow::Table() const
{
    return DYNCAST(CTable, GetParentAncestorSafe(ETAG_TABLE));
}

CTableSection *CTableRow::Section() const
{
    return DYNCAST(CTableSection, GetParentAncestorSafe(s_atagTSection));
}

CTable *CTableSection::Table() const
{
    return DYNCAST(CTable, GetParentAncestorSafe(ETAG_TABLE));
}

CTable *CTableCol::Table() const
{
    return DYNCAST(CTable, GetParentAncestorSafe(ETAG_TABLE));
}

CTableCalcInfo::CTableCalcInfo(CCalcInfo * pci, CTable *pTable, CTableLayout *pTableLayoutCache)
{
    Init(pci);
    _dwFlags            = 0;
    _pme                = NULL;
    _pTable             = pTable;
    _pTableLayoutCache  = pTableLayoutCache;
    _pTableLayout       = pci->GetLayoutContext() == NULL ? _pTableLayoutCache 
        : (CTableLayoutBlock *)_pTable->GetUpdatedLayout(pci->GetLayoutContext());
    Assert(_pTableLayout);
    _fTableCalcInfo     = TRUE;

    if (pci->_fTableCalcInfo)
    {
        _cNestedCalcs = ((CTableCalcInfo *)pci)->_cNestedCalcs + 1; 
        _cGlobalNestedCalcs = ((CTableCalcInfo *)pci)->_cGlobalNestedCalcs + 1; 
        _fGlobalNormalCalc = ((CTableCalcInfo *)pci)->_fGlobalNormalCalc; 
        _fGlobalSetCalc = ((CTableCalcInfo *)pci)->_fGlobalSetCalc; 
    }
    else
    {
        _cNestedCalcs = 0;
        _cGlobalNestedCalcs = 0;
    }

    //  table should start with clear _fIgnorePercentChild 
    _fIgnorePercentChild = FALSE;
}

CTableCalcInfo::CTableCalcInfo(CTable *pTable, CTableLayoutBlock *pTableLayoutBlock)
        :CCalcInfo (pTableLayoutBlock)
{
    Assert(GetLayoutContext() == pTableLayoutBlock->LayoutContext());
    _dwFlags            = 0;
    _pme                = NULL;
    _pTable             = pTable;
    _pTableLayoutCache  = pTable->TableLayoutCache();
    _pTableLayout       = pTableLayoutBlock;
    _fTableCalcInfo     = TRUE;
    Assert (_pTableLayoutCache && _pTableLayoutCache->_cNestedLevel != - 1);
    _cNestedCalcs       = _pTableLayoutCache->_cNestedLevel; 
    _cGlobalNestedCalcs = _pTableLayoutCache->_cNestedLevel; 

    //  table should start with clear _fIgnorePercentChild 
    _fIgnorePercentChild = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\builtin\tcell.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       tcell.cxx
//
//  Contents:   CTableCell and related classes.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_TABLE_HXX_
#define X_TABLE_HXX_
#include "table.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include "ltcell.hxx"
#endif

#ifndef X_LTROW_HXX_
#define X_LTROW_HXX_
#include "ltrow.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_SWITCHES_HXX_
#define X_SWITCHES_HXX_
#include "switches.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_MSHTMDID_H_
#define X_MSHTMDID_H_
#include "mshtmdid.h"
#endif

MtDefine(CTableCell, Elements, "CTableCell")
MtDefine(CTableCaption, Elements, "CTableCaption")
MtExtern(CharFormatSteal)
MtExtern(ParaFormatSteal)
MtExtern(FancyFormatSteal)

ExternTag(tagTableRecalc);
ExternTag(tagTableCalc);
ExternTag(tagFormatCaches);

CElement::ACCELS CTableCell::s_AccelsTCellRun    = CElement::ACCELS (&CTxtSite::s_AccelsTxtSiteRun,    IDR_ACCELS_TCELL_RUN);

#ifndef NO_PROPERTY_PAGE
const CLSID * const CTableCell::s_apclsidPages[] =
{
    // Browse-time pages
    NULL,
    // Edit-time pages
#if DBG==1
    &CLSID_CCDGenericPropertyPage,
    &CLSID_CInlineStylePropertyPage,
#endif
    NULL
};
#endif // NO_PROPERTY_PAGE


const CElement::CLASSDESC CTableCell::s_classdesc =
{
    {
        &CLSID_HTMLTableCell,           // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_NEVERSCROLL    |
        ELEMENTDESC_TEXTSITE       |
        ELEMENTDESC_NOOFFSETCTX    |
        ELEMENTDESC_NOBKGRDRECALC  |
        ELEMENTDESC_TABLECELL,          // _dwFlags
        &IID_IHTMLTableCell,            // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLTableCell,     // _pfnTearOff
    &s_AccelsTCellRun                   // _pAccelsRun
};


HRESULT
CTableCell::CreateElement(CHtmTag *pht,
                  CDoc *pDoc, CElement **ppElement)
{
    Assert(ppElement);

    *ppElement = new CTableCell(pht->GetTag(), pDoc);
    RRETURN ((*ppElement) ? S_OK : E_OUTOFMEMORY);
}

//+------------------------------------------------------------------------
//
//  Member:     CTableCell::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CTableCell::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_HTML_TEAROFF(this, IHTMLTableCell2, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CTableCell::EnterTree, CElement
//
//  Synopsis:   Add the cell to the table.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CTableCell::EnterTree()
{
    HRESULT hr = S_OK;

    if (!GetMarkup()->_fInnerHTMLMarkup)
    {
        CTable *pTable = Table();
        CTableLayout * pTableLayout = pTable? pTable->TableLayoutCache() : NULL;

        // Only maintain the table layout cache incrementally until the table
        // has finished parsing.
        if (pTableLayout && (!pTableLayout->IsCompleted() || pTableLayout->_fTableOM))
        {
            if (IsCaption(Tag()))
            {
                CTableCaption * pCaption = DYNCAST(CTableCaption, this);

                Assert(pTableLayout);
                hr = pTableLayout->AddCaption(pCaption);
            }
            else
            {
                CTableRow *pRow = Row();
                if (pRow)
                {
                    CTableRowLayout * pRowLayout = pRow->RowLayoutCache();

                    Assert(pRowLayout);
                    hr = pRowLayout->AddCell(this);
                }
                else
                {
                    if (pTableLayout)
                        pTableLayout->MarkTableLayoutCacheDirty();
                }
            }
        }
    }

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CTableCell::OnPropertyChange
//
//  Synopsis:   Process property changes on the cell
//
//-------------------------------------------------------------------------

HRESULT
CTableCell::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr;
    CTableCellLayout * pCellLayout = Layout();

    if (pCellLayout)
    {
        switch (dispid)
        {
        case DISPID_A_POSITION:
        // case DISPID_A_DISPLAY:   // this will be handled by ::Notify
            pCellLayout->HandlePositionDisplayChange();
            break;

        case DISPID_A_BORDERWIDTH:
        case DISPID_A_BORDERTOPWIDTH:
        case DISPID_A_BORDERRIGHTWIDTH:
        case DISPID_A_BORDERBOTTOMWIDTH:
        case DISPID_A_BORDERLEFTWIDTH:
            pCellLayout->ResetMinMax();
            break;

        case DISPID_IHTMLTABLECELL_ROWSPAN/*(DISPID_TABLECELL+1)*/:
        case DISPID_IHTMLTABLECELL_COLSPAN/*(DISPID_TABLECELL+2)*/: 
            {
                CTable           * pTable = Table();
                CTableLayout     * pTableLayout = pTable ? pTable->TableLayoutCache() : NULL;

                if (pTableLayout) 
                {
                    pTableLayout->Fixup();
                }
            }
            break;
        }
    }

    hr = THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc));

    RRETURN(hr);
}

                    
//+------------------------------------------------------------------------
//
//  Member:     CTableCell::Save
//
//  Synopsis:   Save the cell to the stream
//
//-------------------------------------------------------------------------

HRESULT
CTableCell::Save(CStreamWriteBuff *pStmWrBuff, BOOL fEnd)
{
    HRESULT hr;

    hr = super::Save(pStmWrBuff, fEnd);
    if (hr)
        goto Cleanup;

    if (fEnd && pStmWrBuff->TestFlag(WBF_FORMATTED_PLAINTEXT))
    {
        // Save a space between <TD> tags duing plaintext save.
        hr = pStmWrBuff->Write(_T(" "));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CTableCell::RowSpan, CTableCell
//
//  Synopsis:   Returns number of rows cell spans
//
//  Returns:    rows
//
//-------------------------------------------------------------------------

int
CTableCell::RowSpanHelper(int cRowSpan)
{
#if DBG==1
    CTableLayout * pTableLayout = Table()->TableLayoutCache();
#endif
    Assert(pTableLayout->IsTableLayoutCacheCurrent());

    CTableSection * pSection = Section();
    int iRowIdx = max(RowIndex(), 0);
    int cRowsLeftInSection   = pSection->_iRow + pSection->_cRows - iRowIdx;

    if (!cRowsLeftInSection)
    {
        // this can happen when a cell is cut out of a tree (treestress bug 72131)
        // and it winds up getting notifications in the process
        return 1;
    }

    // Rows left in sections include this table cell's row.
    Assert(cRowsLeftInSection >= 1 && cRowsLeftInSection <= pSection->_cRows);

    // Don't return a span going past the end of the section (or the number
    // of rows in the table for that matter).
    if (cRowSpan > cRowsLeftInSection)
    {
        // Section sanity check.
        Assert(pSection->_iRow + pSection->_cRows <= pTableLayout->GetRows());
        return cRowsLeftInSection;
    }
    else
    {
        // Since we are within the section we know we didn't pass the end
        // of the table.  Assert that.
        Assert(iRowIdx + cRowSpan <= pTableLayout->_aryRows.Size());

        return cRowSpan;
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CTableCell::ApplyCellFormat
//
//  Synopsis:   Apply attributes
//
//  Arguments:  pCFI - Format Info needed for cascading
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CTableCell::ApplyCellFormat(CFormatInfo *pCFI)
{
    CColorValue ccvBorderColor;
    CUnitValue  cuvZeroPoints, cuvZeroPercent, cuvInheritedWidth;
    LONG        lZeroPoints, lZeroPercent;
    BYTE        i;
    HRESULT     hr;

    BOOL fComputeFFOnly = pCFI->_pNodeContext->_iCF != -1;

    // Dont inherit down the no-break bit
    if (pCFI->_pcf->_fNoBreakInner)
    {
        pCFI->PrepareCharFormat();
        pCFI->_cf()._fNoBreakInner = FALSE;
        pCFI->UnprepareForDebug();
    }
    
    cuvZeroPoints.SetPoints(0);
    lZeroPoints = cuvZeroPoints.GetRawValue();
    cuvZeroPercent.SetValue(0, CUnitValue::UNIT_PERCENT);
    lZeroPercent = cuvZeroPercent.GetRawValue();

    if (!fComputeFFOnly)
    {
        if (Tag() == ETAG_TH)
        {
            pCFI->PrepareCharFormat();
            pCFI->_cf()._fBold = TRUE;
            pCFI->_cf()._wWeight = 700;
            pCFI->UnprepareForDebug();
        }
    }

    // Override inherited colors as necessary
    ccvBorderColor = GetAAborderColor();
    if (ccvBorderColor.IsDefined())
    {
        pCFI->PrepareFancyFormat();

        for (i = 0; i < SIDE_MAX; i++)
        {
            pCFI->_ff()._bd.SetBorderColor(i, ccvBorderColor);
        }

        pCFI->_ff()._bd._ccvBorderColorLight   =
        pCFI->_ff()._bd._ccvBorderColorHilight =
        pCFI->_ff()._bd._ccvBorderColorDark    =
        pCFI->_ff()._bd._ccvBorderColorShadow  = ccvBorderColor;
        pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;

        pCFI->UnprepareForDebug();
    }

    ccvBorderColor = GetAAborderColorLight();
    if (ccvBorderColor.IsDefined())
    {
        pCFI->PrepareFancyFormat();
        pCFI->_ff()._bd._ccvBorderColorLight   =
        pCFI->_ff()._bd._ccvBorderColorHilight = ccvBorderColor;
        pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
        pCFI->UnprepareForDebug();
    }

    ccvBorderColor = GetAAborderColorDark();
    if (ccvBorderColor.IsDefined())
    {
        pCFI->PrepareFancyFormat();
        pCFI->_ff()._bd._ccvBorderColorDark    =
        pCFI->_ff()._bd._ccvBorderColorShadow  = ccvBorderColor;
        pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
        pCFI->UnprepareForDebug();
    }

    if (pCFI->_pff->_bd._bBorderColorsSetUnique)
    {
        pCFI->PrepareFancyFormat();
        pCFI->_ff()._bd._bBorderColorsSetUnique = FALSE;
        pCFI->UnprepareForDebug();
    }

    CUnitValue cuvNull; cuvNull.SetNull();
    for (i = 0; i < SIDE_MAX; i++)
    {
        if (    !pCFI->_pff->_bd.GetBorderWidth(i).IsNull()
            ||  pCFI->_pff->_bd.GetBorderStyle(i) != (BYTE)-1)
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff()._bd.SetBorderWidth(i, cuvNull);
            pCFI->_ff()._bd.SetBorderStyle(i, (BYTE)-1);
            pCFI->UnprepareForDebug();
        }
    }

    if (!fComputeFFOnly)
    {
        // Don't inherit blockquote indentation for all of the cells.

        if (    pCFI->_ppf->_cuvLeftIndentPoints.GetRawValue() != lZeroPoints
            ||  pCFI->_ppf->_cuvLeftIndentPercent.GetRawValue() != lZeroPercent
            ||  pCFI->_ppf->_cuvRightIndentPoints.GetRawValue() != lZeroPoints
            ||  pCFI->_ppf->_cuvRightIndentPercent.GetRawValue() != lZeroPercent
            ||  pCFI->_ppf->_cuvOffsetPoints.GetRawValue() != lZeroPoints
            ||  pCFI->_ppf->_cuvNonBulletIndentPoints.GetRawValue() != lZeroPoints
            ||  !pCFI->_ppf->_cListing.IsReset())
        {
            pCFI->PrepareParaFormat();
            pCFI->_pf()._cuvLeftIndentPoints = cuvZeroPoints;
            pCFI->_pf()._cuvLeftIndentPercent = cuvZeroPercent;
            pCFI->_pf()._cuvRightIndentPoints = cuvZeroPoints;
            pCFI->_pf()._cuvRightIndentPercent = cuvZeroPercent;
            pCFI->_pf()._cuvOffsetPoints = cuvZeroPoints;
            pCFI->_pf()._cuvNonBulletIndentPoints = cuvZeroPoints;
            pCFI->_pf()._cListing.Reset();
            pCFI->UnprepareForDebug();
        }
    }

    //
    // Save and clear out any inherited width
    //


    cuvInheritedWidth = pCFI->_pff->GetWidth();
    if (!cuvInheritedWidth.IsNull())
    {
        pCFI->PrepareFancyFormat();
        pCFI->_ff().ClearWidth();
        pCFI->UnprepareForDebug();
    }

    //
    // Apply standard formats
    //

    Assert(pCFI->_pNodeContext && SameScope(pCFI->_pNodeContext, this));
    hr = THR( ApplyDefaultFormat(pCFI) );
    if (hr)
        goto Cleanup;

    //
    // Clear all margin values
    // NOTE: Margins are not supported on cells or captions
    //

    if (    pCFI->_pff->_cuvSpaceBefore.GetRawValue() != lZeroPoints
        ||  pCFI->_pff->_cuvSpaceAfter.GetRawValue() != lZeroPoints
        ||  !pCFI->_pff->GetMargin(SIDE_TOP).IsNull()
        ||  !pCFI->_pff->GetMargin(SIDE_RIGHT).IsNull()
        ||  !pCFI->_pff->GetMargin(SIDE_BOTTOM).IsNull()
        ||  !pCFI->_pff->GetMargin(SIDE_LEFT).IsNull())
    {
        //
        // Note: (srinib) when margins are implemented  on table cell's,
        // verify ApplyInnerOuterFormats for margins.
        //
        CUnitValue uvNull(0, CUnitValue::UNIT_NULLVALUE);

        pCFI->PrepareFancyFormat();
        pCFI->_ff()._cuvSpaceBefore = cuvZeroPoints;
        pCFI->_ff()._cuvSpaceAfter = cuvZeroPoints;
        pCFI->_ff().SetExplicitMargin(SIDE_TOP, FALSE);
        pCFI->_ff().SetExplicitMargin(SIDE_RIGHT, FALSE);
        pCFI->_ff().SetExplicitMargin(SIDE_BOTTOM, FALSE);
        pCFI->_ff().SetExplicitMargin(SIDE_LEFT, FALSE);
        pCFI->_ff().SetMargin(SIDE_TOP, uvNull);
        pCFI->_ff().SetMargin(SIDE_RIGHT, uvNull);
        pCFI->_ff().SetMargin(SIDE_BOTTOM, uvNull);
        pCFI->_ff().SetMargin(SIDE_LEFT, uvNull);
        pCFI->_ff()._fHasMargins = FALSE;
        pCFI->UnprepareForDebug();
    }

    //
    // If there was no explicit width on the cell, use the inherited width
    //

    if (pCFI->_pff->GetWidth().IsNull())
    {
        _fInheritedWidth = TRUE;

        pCFI->PrepareFancyFormat();
        pCFI->_ff().SetWidth(cuvInheritedWidth);
        pCFI->UnprepareForDebug();
    }

    if (!fComputeFFOnly)
    {
        if (Tag() == ETAG_CAPTION || Tag() == ETAG_TC)
        {
            // Note: The caption.pdl specifies the align as DISPID_A_BLOCKALIGN - which means
            // it gets written into the _blockAlign - but caption has two extra ( vertical )
            // enum values that we need to map onto the equivalent vertical alignment values.
            // The code that handles this maping you can find in ApplyParagraphAlignment() (cpfp.cxx)

            // Map Caption enum to ControlAlign enum
            if (    pCFI->_ppf->_bTableVAlignment == htmlCaptionVAlignTop
                ||  pCFI->_ppf->_bTableVAlignment == htmlCaptionAlignTop)
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._bTableVAlignment = htmlCellVAlignTop;
                DYNCAST(CTableCaption,this)->_uLocation = CTableCaption::CAPTION_TOP;
                pCFI->UnprepareForDebug();
            }
            else if (   pCFI->_ppf->_bTableVAlignment == htmlCaptionVAlignBottom
                    ||  pCFI->_ppf->_bTableVAlignment == htmlCaptionAlignBottom)
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._bTableVAlignment = htmlCellVAlignBottom;
                DYNCAST(CTableCaption,this)->_uLocation = CTableCaption::CAPTION_BOTTOM;
                pCFI->UnprepareForDebug();
            }
        }
    }

Cleanup:
    RRETURN(hr);
}

static HRESULT VerticalAlignFromCellVAlign(CFormatInfo * pCFI)
{
    //
    // Set only block align.
    // 

    HRESULT hr = S_OK;
    htmlControlAlign   ca;  

    switch ((htmlCellVAlign)pCFI->_ppf->_bTableVAlignment)
    {
    case htmlCellVAlignNotSet:
        ca = htmlControlAlignNotSet;
        break;
    case htmlCellVAlignTop:
        ca = htmlControlAlignTop;
        break;
    case htmlCellVAlignMiddle:
        ca = htmlControlAlignMiddle;
        break;
    case htmlCellVAlignBottom:
        ca = htmlControlAlignBottom;
        break;
    case htmlCellVAlignBaseline:
        ca = htmlControlAlignBaseline;
        break;
    default:
        ca = htmlControlAlignNotSet;   // keep compiler happy
        Assert(0);
        hr = E_INVALIDARG;
        break;
    }

    if (pCFI->_pff->_bControlAlign != ca)
    {
        pCFI->PrepareFancyFormat();
        pCFI->_ff()._bControlAlign = ca;
        pCFI->UnprepareForDebug();
    }

    RRETURN(hr);
}

// Look at two different elements and determine if their formats might be different.
static BOOL PotentiallyDifferentFormats (CElement *pElement1, CElement *pElement2)
{
    // If both are missing, then we're the same.
    if (pElement1 != NULL || pElement2 != NULL)
    {
        // Let's compare class and ID.
        if (pElement2 != NULL && pElement1 != NULL)
        {
            LPCTSTR pstr;
            LPCTSTR pstr1;

            // Are there classes at all?
            pstr=pElement2->GetAAclassName();
            pstr1=pElement1->GetAAclassName();
            if (pstr1 != NULL || pstr != NULL)
            {
                if (pstr1 != NULL && pstr != NULL)
                {
                    if (_tcscmp(pstr, pstr1) != 0)
                        goto Cleanup;
                }
                else
                    goto Cleanup;
            }

            // Same thing for the IDs.
            pstr1=pElement2->GetAAid();
            pstr=pElement1->GetAAid();
            if (pstr1 != NULL || pstr != NULL)
            {
                if (pstr1 != NULL && pstr != NULL)
                {
                    if (_tcscmp(pstr, pstr1) != 0)
                        goto Cleanup;
                }
                else
                    goto Cleanup;
            }
        }
        // One element exists the other is NULL.
        else
            goto Cleanup;
    }

    return FALSE;

Cleanup:
    return TRUE;
}

//+------------------------------------------------------------------------
//
//  Member:     CTableCell::CheckSameFormat
//
//  Synopsis:   Check if the other cell in the other row/col has the same
//              format and use it if it is...
//-------------------------------------------------------------------------

BOOL
CTableCell::CheckSameFormat
(
    CTreeNode  * pNodeTarget,
    CTableCell * pCell1,
    CTableRow * pRow,
    CTableRow * pRow1,
    CTableCol * pCol,
    CTableCol * pCol1
)
{
    Assert(this == pNodeTarget->Element());

    // If we are computing formats for pseudo elements, then we cannot steal formats
    // since the formats we will compute will be different than the normal stolen
    // formats because of the first line/letter settings (bug 87707)
    if (GetMarkup()->HasCFState() || !pCell1->_fStealingAllowed)
        return FALSE;

    BOOL fSameRow = pRow == pRow1;
    BOOL fSameCol = pCol == pCol1;
    BOOL fPotentiallyDifferent=FALSE;   // Optimism.
    // Do we have the same class or ID as the column we're comparing?
    if (fSameRow)
    {
        fPotentiallyDifferent = PotentiallyDifferentFormats (pCol, pCol1);
    }
    else if (fSameCol)
    {
        fPotentiallyDifferent = PotentiallyDifferentFormats (pRow, pRow1);
    }

    if (fPotentiallyDifferent)
    {
        return FALSE;
    }

    CTreeNode * pNodeCell1 = pCell1->GetFirstBranch();
    CTreeNode * pNodeRow   = pRow->GetFirstBranch();
    CTreeNode * pNodeRow1  = pRow1->GetFirstBranch();
    CTreeNode * pNodeCol   = pCol? pCol->GetFirstBranch() : NULL;
    CTreeNode * pNodeCol1  = pCol1? pCol1->GetFirstBranch() : NULL;

    if (pNodeCell1->_iFF >= 0)
    {
        const CFancyFormat *pFF = GetFancyFormatEx(pNodeCell1->_iFF);

        if (pFF->_pszFilters || pFF->_fHasExpressions)
            return FALSE;
    }

    if (pNodeRow1->_iFF >= 0)
    {
        const CFancyFormat *pFF = GetFancyFormatEx(pNodeRow1->_iFF);

        // Table rows don't have filters
        if (pFF->_fHasExpressions)
            return FALSE;
    }

    if (HasPeerHolder() && GetPeerHolder()->TestFlagMulti(CPeerHolder::NEEDAPPLYSTYLE))
    {
        return FALSE;
    }

    if (pNodeCell1->_iPF >= 0 &&
        (_pAA == NULL && pCell1->_pAA == NULL ||
         (_pAA != NULL && pCell1->_pAA != NULL && _pAA->Compare(pCell1->_pAA)) ) &&
        ((pNodeRow->_iPF >= 0 && pRow == pRow1) ||
            (pNodeRow1->_iPF >= 0 &&
            pNodeRow->_iPF == pNodeRow1->_iPF &&
            pNodeRow->_iCF == pNodeRow1->_iCF &&
            pNodeRow->_iFF == pNodeRow1->_iFF)) &&
        ((!pCol && !pCol1) ||
            (pCol && pCol1 && ((pNodeCol->_iPF >= 0 && pCol == pCol1) ||
                               (pNodeCol1->_iPF >= 0 &&
                                pNodeCol->_iPF == pNodeCol1->_iPF &&
                                pNodeCol->_iCF == pNodeCol1->_iCF &&
                                pNodeCol->_iFF == pNodeCol1->_iFF)))))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


//+------------------------------------------------------------------------
//
//  Function:   ApplyFormatUptoTable
//
//  Synopsis:   Apply format of all the elements above the passed element (p)
//              upto the table element (not including the table element)
//
//              We need this function because of ETAG_TC elemnts exclude
//              ETAG_TABLE elements when we apply the format to them.
//
//  Arguments:  pCFI - Format Info needed for cascading
//              p - Element to start from
//
//  Note:       This is a recursive function. It can be written in a generic
//              way if anybody would need this function (we could of passed
//              the ETAG_TABLE as a parameter). But since there is no need
//              for it yet (it is remainig as a part of the table code)
//
//-------------------------------------------------------------------------

HRESULT
CTableCell::ApplyFormatUptoTable(CFormatInfo * pCFI)
{
    CTreeNode * pNodeParent = pCFI->_pNodeContext->Parent();
    HRESULT     hr = S_OK;

    if (pNodeParent->Tag() != ETAG_TABLE)
    {
        pCFI->_pNodeContext = pNodeParent;
        hr = ApplyFormatUptoTable(pCFI);
        if (hr)
            goto Cleanup;
        pCFI->_pNodeContext = pNodeParent;
        hr = THR(pNodeParent->Element()->ApplyDefaultFormat(pCFI));
    }

Cleanup:
    RRETURN (hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CTableCell::ComputeFormatsVirtual
//
//  Synopsis:   Compute Char and Para formats induced by this element and
//              every other element above it in the HTML tree.
//
//  Arguments:  pCFI - Format Info needed for cascading
//
//  Returns:    HRESULT
//
//  Note:       We override this here to put our defaults into the format
//              FIRST, and also to cache vertical alignment here in the object
//
//-------------------------------------------------------------------------

HRESULT
CTableCell::ComputeFormatsVirtual(CFormatInfo * pCFI, CTreeNode * pNodeTarget)
{
    SwitchesBegTimer(SWITCHES_TIMER_COMPUTEFORMATS);

    // (KTam) This is bogus, the only reason we ask for layout in this fn
    // is so we can check _fDisplayNoneCell (which ought to be obtained
    // from the cell element).  In the meantime, first layout is OK.
    CTableCellLayout   *pLayout = Layout(GUL_USEFIRSTLAYOUT);
    CTableCol *         pCol = NULL;
    CTableCol *         pColGroup = NULL;
    CTableRow *         pRow = NULL;
    CTableSection *     pSection = NULL;
    ELEMENT_TAG         etag;
    CTable *            pTable;
    CTableLayout *      pTableLayout = NULL;
    const CParaFormat * pPFRow = NULL;
    const CParaFormat * pPFCol = NULL;
    const CParaFormat * pPFColGroup = NULL;
    HRESULT             hr = S_OK;
    CUnitValue          cuvColWidth;
    CUnitValue          cuvZeroPoints;
    CUnitValue          cuvZeroPercent;
    WHEN_DBG( BOOL      fDisableTLCAssert = FALSE; )
    CTreeNode         * pNodeTable;
    CTreeNode         * pNodeRow = NULL;
    CTreeNode         * pNodeCol = NULL;
    CTreeNode         * pNodeColGroup = NULL;
    CTableCell        * pCellNeighbor = NULL;
    CTableCol *         pColNeighbor = NULL;
    CTreeNode         * pNodeInherit;
    THREADSTATE *       pts = GetThreadState();
    LONG                lZeroPoints;
    BOOL                fComputeFFOnly = pNodeTarget->_iCF != -1;
    BOOL                fSetWidthFromCol = FALSE;
    COMPUTEFORMATSTYPE  eExtraValues = pCFI->_eExtraValues;

    if(eExtraValues == ComputeFormatsType_GetInheritedIntoTableValue)
    {
        // It is not violated, we just want to disable the format stealing stuff when
        // the puprose of calling ComputeFormats is to get the inherited value.
        goto TableStructureViolated;
    }


    cuvZeroPercent.SetValue(0, CUnitValue::UNIT_PERCENT);
    cuvZeroPoints.SetPoints(0);
    lZeroPoints = cuvZeroPoints.GetRawValue();

    Assert(pCFI);
    Assert( SameScope( this, pNodeTarget ) );

    etag         = Tag();
    pTable       = Table();

    // If we are not in a table, we are messed up, and we'll just
    // use the CElement::ComputeFormat handling.
    if (!pTable)
        goto TableStructureViolated;

    pNodeTable   = pTable->GetFirstBranch();
    pTableLayout = pTable->TableLayoutCache();

    WHEN_DBG( fDisableTLCAssert = pTableLayout->_fDisableTLCAssert;
              pTableLayout->_fDisableTLCAssert = TRUE; )

    // Note:  We are not doing a pTableLayout->EnsureTableLayoutCache()
    // even though the current version might be dirty (can happen in
    // databinding).  In those cases we WANT to work with the old version
    // in case elements would disappear on us.

    // if there are no attributes to worry about try to use an other cell's format
    if (!IsCaption(etag))
    {
        Assert(!pCol || SameScope(pCol->GetFirstBranch()->Ancestor(ETAG_COLGROUP), pColGroup));

        pSection  = Section();
        pRow      = Row();
        pColGroup = pTableLayout->GetColGroup(ColIndex());
        pCol      = pTableLayout->GetCol(ColIndex());

        if (!pRow || !pSection)
            goto TableStructureViolated;

        // make sure row and col cached it's format...
        pNodeRow = pRow->GetFirstBranch();
        pPFRow = pNodeRow->GetParaFormat();
        if (pColGroup)
        {
            pNodeColGroup = pColGroup->GetFirstBranch();
            if (pNodeColGroup)
                pPFColGroup = pNodeColGroup->GetParaFormat();
        }
        if (pCol)
        {
            pNodeCol = pCol->GetFirstBranch();
            pPFCol = pNodeCol->GetParaFormat();
        }

        if (   (eExtraValues == ComputeFormatsType_Normal) 
            && pTableLayout->IsTableLayoutCacheCurrent() 
            && !pLayout->_fDisplayNoneCell)
        {
            CTableRow *       pRowNeighbor;
            CTableRowLayout * pRowLayout = pRow->RowLayoutCache();
            int               iCol = ColIndex(), iRow;

            iRow = pRow->_iRow;   // faster then  = RowIndex()

            // try to steal format from the cell in the same column from the previous data-bound section
            if (pTableLayout->IsGenerated(iRow) && pSection != pTableLayout->_aryBodys[0])
            {
                // use the template's format
                iRow = iRow - pSection->_iRow; // relative row number
                Assert (iRow < pSection->_cRows);
                if((pTableLayout->_aryBodys[0]->_iRow + iRow) >= 0)
                {
                    pRowNeighbor = pTableLayout->_aryRows[pTableLayout->_aryBodys[0]->_iRow + iRow];
                    if (pRowNeighbor && pRowNeighbor->RowLayoutCache()->GetCells() > iCol)
                    {
                        pCellNeighbor = Cell(pRowNeighbor->RowLayoutCache()->_aryCells[iCol]);
                        if (pCellNeighbor && CheckSameFormat(pNodeTarget, pCellNeighbor, pRow, pRowNeighbor, pCol, pCol))
                        {
                            goto StealFormat;
                        }
                    }
                }
            }

            // try to steal format from the cell in the same row from the previous column 
            if (      iCol > 0 && iCol <= pRowLayout->GetCells()            
                   && (pCellNeighbor = pRowLayout->GetCell(iCol-1)) != this  
                   && pCellNeighbor
                   && pCellNeighbor->Section() == pSection
                   && pTableLayout->GetColGroup(iCol-1) == pColGroup
                   && (pColNeighbor = pTableLayout->GetCol(iCol-1)) == pCol
                   && pCellNeighbor->Tag() == etag)
            {
                if (CheckSameFormat(pNodeTarget, pCellNeighbor, pRow, pRow, pCol, pColNeighbor))
                {
                    goto StealFormat;
                }
            }

            // try to steal format from the cell in the same column from the previous row
            if (iRow > 0 && iRow <= pTableLayout->GetRows())
            {
                pRowNeighbor = pTableLayout->GetRow(iRow-1);
                CTableRowLayout *pRowNeighborLayout = pRowNeighbor->RowLayoutCache();
                if (pRowNeighborLayout->GetCells() > iCol                       &&
                    (pCellNeighbor = pRowNeighborLayout->GetCell(iCol)) != this &&
                    pCellNeighbor                                               &&
                    IsReal(pRowNeighborLayout->_aryCells[iCol])                 &&
                    pCellNeighbor->Section() == pSection                        &&
                    pCellNeighbor->Tag() == etag)
                {
                    Assert(pCellNeighbor->Layout(GUL_USEFIRSTLAYOUT)->ColGroup() == pColGroup);
                    if (CheckSameFormat(pNodeTarget, pCellNeighbor, pRow, pRowNeighbor, pCol, pCol))
                    {
                        goto StealFormat;
                    }
                }
            }
        }
    }

    if (etag == ETAG_TC)
        pNodeInherit = pNodeTable->Parent();
    else if(etag == ETAG_CAPTION)
        pNodeInherit = pNodeTable;
    else if (!pCol || !pColGroup)
        pNodeInherit = pNodeRow;
    else
        pNodeInherit = pNodeTable;

    if (    pNodeInherit->_iCF == -1
        ||  pNodeInherit->_iFF == -1)
    {
        SwitchesEndTimer(SWITCHES_TIMER_COMPUTEFORMATS);

        hr = THR(pNodeInherit->Element()->ComputeFormats(pCFI, pNodeInherit));

        SwitchesBegTimer(SWITCHES_TIMER_COMPUTEFORMATS);

        if (hr)
            goto Cleanup;
    }

    Assert(pNodeInherit->_iCF >= 0);
    Assert(pNodeInherit->_iPF >= 0);
    Assert(pNodeInherit->_iFF >= 0);
    //
    // NOTE: From this point forward any errors must goto Error instead of Cleanup!
    //

    pCFI->Reset();

    //
    // Setup Fancy Format
    //

    if (IsCaption(etag))
    {
        pCFI->_iffSrc = pts->_iffDefault;
        pCFI->_pffSrc = pCFI->_pff = pts->_pffDefault;
        Assert(pCFI->_pffSrc->_pszFilters == NULL);
    }
    else
    {
        pCFI->_iffSrc = pNodeInherit->_iFF;
        pCFI->_pffSrc = pCFI->_pff = &(*pts->_pFancyFormatCache)[pCFI->_iffSrc];
        pCFI->_fHasExpandos = (pCFI->_pff->_iExpandos >= 0);

        if (pCFI->_pff->_pszFilters)
        {
            // note: we are letting the cell inherit zoom and rotation from row, because row can't have a layout
            pCFI->PrepareFancyFormat();
            pCFI->_ff()._pszFilters = NULL;
            pCFI->UnprepareForDebug();
        }
    }

    //
    // Setup Char and Para formats
    //

    pCFI->_icfSrc = pNodeInherit->_iCF;
    pCFI->_pcfSrc = pCFI->_pcf = &(*pts->_pCharFormatCache)[pCFI->_icfSrc];
    pCFI->_ipfSrc = pNodeInherit->_iPF;
    pCFI->_ppfSrc = pCFI->_ppf = &(*pts->_pParaFormatCache)[pCFI->_ipfSrc];

    //
    // Apply formats
    //

    if (etag == ETAG_TC)
    {
        // We treat <TC> (text in between table cells) as if the text is outside the
        // table for Netscape compatibility, so do not apply the table's format.

        pCFI->_pNodeContext = pNodeTarget;
        hr = ApplyFormatUptoTable(pCFI);
        if (hr)
            goto Error;
    }

    if (!fComputeFFOnly)
    {
        // Because we're re-using the pCFI between applies, we need to explictly
        // clear those members that we don't want to "inherit" as we apply.
        // For example, width/height should not be inherited from the table

        if (    pCFI->_ppf->_bBlockAlign != htmlAlignNotSet
            ||  pCFI->_ppf->_cuvRightIndentPoints.GetRawValue() != lZeroPoints
            ||  pCFI->_ppf->_cuvLeftIndentPoints.GetRawValue() != lZeroPoints)
        {
            pCFI->PrepareParaFormat();
            pCFI->_pf()._bBlockAlign = htmlAlignNotSet;
            pCFI->_pf()._cuvRightIndentPoints.SetRawValue(lZeroPoints);
            pCFI->_pf()._cuvLeftIndentPoints.SetRawValue(lZeroPoints);
            pCFI->UnprepareForDebug();
        }
    }

    //
    //  Initialize padding with the CELLPADDING attribute
    //

    if (etag != ETAG_CAPTION)
    {
        CUnitValue uvPadding = pTable->GetAAcellPadding();

        if (uvPadding.IsNull())
        {
            uvPadding.SetValue(1, CUnitValue::UNIT_PIXELS);
        }

        if (uvPadding.GetPixelValue())
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff().SetPadding(SIDE_LEFT, uvPadding);
            pCFI->_ff().SetPadding(SIDE_RIGHT, uvPadding);
            pCFI->_ff().SetPadding(SIDE_TOP, uvPadding);
            pCFI->_ff().SetPadding(SIDE_BOTTOM, uvPadding);
            pCFI->UnprepareForDebug();
        }
    }

    else if (!pTableLayout->_fCollapse)
    {
        // Add caption spacing for Netscape compatibility.
        CUnitValue          uvPadding = pTable->GetAAcellPadding();
        CUnitValue          uvSpacing = pTable->GetAAcellSpacing();
        CUnitValue          uvBorder  = pTable->GetAAborder();
        CUnitValue          uv;
        htmlCaptionVAlign   valign;
        long                cyPaddingBottom;

        if (uvPadding.IsNull())
        {
            uvPadding.SetValue(1, CUnitValue::UNIT_PIXELS);
        }

        if (uvSpacing.IsNull())
        {
            uvSpacing.SetValue(2, CUnitValue::UNIT_PIXELS);
        }

        if (uvBorder.IsNull())
        {
            uvBorder.SetValue(0, CUnitValue::UNIT_PIXELS);
        }

        if (    uvPadding.GetPixelValue()
            ||  uvSpacing.GetPixelValue()
            ||  uvBorder.GetPixelValue())
        {
            pCFI->PrepareFancyFormat();
            pCFI->_ff().SetPadding(SIDE_TOP, uvPadding);

            uv.SetValue(uvPadding.GetPixelValue() + uvSpacing.GetPixelValue() + uvBorder.GetPixelValue(), CUnitValue::UNIT_PIXELS);
            pCFI->_ff().SetPadding(SIDE_LEFT, uv);
            pCFI->_ff().SetPadding(SIDE_RIGHT, uv);

            CAttrArray::FindSimple( *GetAttrArray(), &s_propdescCTableCaptionvAlign.a, (DWORD *)&valign);

            if (valign == htmlCaptionVAlignNotSet)
            {
                CAttrArray::FindSimple( *GetAttrArray(), &s_propdescCTableCaptionalign.a, (DWORD *)&valign);

                valign = (valign == htmlCaptionAlignBottom
                                ? htmlCaptionVAlignBottom
                                : htmlCaptionVAlignTop);
            }

            // Netscape: doesn't adjust TOP for a caption, instead it adjust the bottom of the "TOP" captions
            cyPaddingBottom = uvPadding.GetPixelValue() + (valign == htmlCaptionVAlignBottom
                                                                ? uvSpacing.GetPixelValue()
                                                                : uvBorder.GetPixelValue() + (2 * uvSpacing.GetPixelValue()));

            uv.SetValue(cyPaddingBottom, CUnitValue::UNIT_PIXELS);
            pCFI->_ff().SetPadding(SIDE_BOTTOM, uv);
            pCFI->UnprepareForDebug();
        }
    }

    if (!fComputeFFOnly)
    {
        if (pCFI->_pcf->_fRelative)
        {
            pCFI->PrepareCharFormat();
            pCFI->_cf()._fRelative = FALSE;
            pCFI->UnprepareForDebug();
        }
    }

    if (etag != ETAG_CAPTION && etag != ETAG_TC)
    {
        if (pCol || pColGroup)
        {
            if (pColGroup)
            {
                pCFI->_pNodeContext = pColGroup->GetFirstBranch();
                hr = THR(pColGroup->ApplyDefaultFormat(pCFI));
                if (hr)
                    goto Error;
            }

            if (pCol)
            {
                pCFI->_pNodeContext = pCol->GetFirstBranch();
                hr = THR(pCol->ApplyDefaultFormat(pCFI));
                if (hr)
                    goto Error;
            }

            // Cache column width.
            // Table is always horizontal => width is in physical coordinate system.
            cuvColWidth = pCFI->_pff->GetWidth();
            fSetWidthFromCol = !cuvColWidth.IsNull();

            pCFI->_pNodeContext = pSection->GetFirstBranch();
            hr = THR(pSection->ApplyDefaultFormat(pCFI));
            if (hr)
                goto Error;

            Assert (pNodeRow);
            pCFI->_pNodeContext = pNodeRow;
            hr = THR(pRow->ApplyDefaultFormat(pCFI));
            if (hr)
                goto Error;

        }

        if (!fComputeFFOnly)
        {
            // (alexa) The following is a precedence order for each attribute (HTML3 Table Model Spec),
            // where x > y denotes that x takes precedence over y
            // for ALIGN (_blockAlign), CHAR and CHAROFF
            // cell > column > column groups > row > row groups > default
            // for VALIGN (_bTableVAlignment), LANG, DIR, STYLE
            // cell > row > row groups > column > column groups > table > default

            // 1a. Set default ALIGN property
            if (pCFI->_bBlockAlign == htmlBlockAlignNotSet &&
                etag == ETAG_TH)
            {
                // By default, htmlAlignNotSet is htmlAlignLeft, so do not set it to
                // htmlAlignLeft it will mess up alignment on contained sites which
                // are not aligned left by default (ex. HR).
                pCFI->_bBlockAlign = htmlBlockAlignCenter;

            }

            // 2a. Apply horizontal alignment for table cells in different order
            if (pPFRow->_bBlockAlignInner != htmlBlockAlignNotSet)
            {
                pCFI->_bBlockAlign = pPFRow->_bBlockAlignInner;
            }

            // 3a. then apply alignment from column groups
            if (pPFColGroup && pPFColGroup->_bBlockAlign != htmlBlockAlignNotSet)
            {
                pCFI->_bBlockAlign = pPFColGroup->_bBlockAlign;
            }

            // 3b. then inherit align from columns
            if (pPFCol && pPFCol->_bBlockAlign != htmlBlockAlignNotSet)
            {
                pCFI->_bBlockAlign = pPFCol->_bBlockAlign;
            }

            // 4a. Cell will apply its own ALIGN format if specified when we call ApplyCellFormat()

            // 1b. Set default VALIGN format if it was not set by COLs and Rows already,
            // if it was set, the correct precedence already took place during
            // COL and ROW ApplyFormat() above.
            if (pCFI->_ppf->_bTableVAlignment == htmlCellVAlignNotSet)
            {
                Assert(etag == ETAG_TH || etag == ETAG_TD || etag == ETAG_TC);
                pCFI->PrepareParaFormat();
                pCFI->_pf()._bTableVAlignment = htmlCellVAlignMiddle;
                pCFI->UnprepareForDebug();
            }
        }
    }
    else
    {
        if (!fComputeFFOnly)
        {
            // set the default ALIGN/VALIGN format for CAPTION
            pCFI->_bBlockAlign = (etag == ETAG_CAPTION)? htmlBlockAlignCenter : htmlBlockAlignNotSet;

            if (pCFI->_ppf->_bTableVAlignment != htmlCellVAlignTop)
            {
                pCFI->PrepareParaFormat();
                pCFI->_pf()._bTableVAlignment = htmlCellVAlignTop;
                pCFI->UnprepareForDebug();
            }
        }
    }

    if (    pCFI->_pff->_cuvSpaceBefore.GetRawValue() != lZeroPoints
        ||  pCFI->_pff->_cuvSpaceAfter.GetRawValue() != lZeroPoints
        ||  !pCFI->_pff->GetWidth().IsNull()
        ||  !pCFI->_pff->GetPosition(SIDE_TOP).IsNull()
        ||  !pCFI->_pff->GetPosition(SIDE_LEFT).IsNull()
        ||  !pCFI->_pff->GetMargin(SIDE_TOP).IsNull()
        ||  !pCFI->_pff->GetMargin(SIDE_RIGHT).IsNull()
        ||  !pCFI->_pff->GetMargin(SIDE_BOTTOM).IsNull()
        ||  !pCFI->_pff->GetMargin(SIDE_RIGHT).IsNull()
        ||  pCFI->_pff->_bDisplay != styleDisplayNotSet
        ||  pCFI->_pff->_bPositionType != stylePositionNotSet
        ||  pCFI->_pff->_fPositioned
        ||  pCFI->_pff->_fAutoPositioned
        ||  pCFI->_pff->_fScrollingParent
        ||  pCFI->_pff->_fZParent
        ||  pCFI->_pff->_iExpandos != -1
        ||  pCFI->_pff->_iCustomCursor != -1
        ||  pCFI->_pff->_iPEI != -1
        ||  pCFI->_pff->_fHasExpressions != 0
        ||  pCFI->_pff->_lZIndex != 0
        ||  pCFI->_pff->_pszFilters
        ||  pCFI->_pff->_bPageBreaks != 0
        ||  pCFI->_pff->HasCSSVerticalAlign()
        ||  pCFI->_pff->GetVerticalAlign() != styleVerticalAlignNotSet
        ||  pCFI->_pff->_fLayoutFlowChanged
        ||  fSetWidthFromCol)
    {
        CUnitValue uvNull(0, CUnitValue::UNIT_NULLVALUE);

        pCFI->PrepareFancyFormat();
        pCFI->_ff()._cuvSpaceBefore.SetValue(0, CUnitValue::UNIT_POINT);
        pCFI->_ff()._cuvSpaceAfter.SetValue(0, CUnitValue::UNIT_POINT);
        pCFI->_ff().ClearWidth();
        // set the correct width (column width)
        if (fSetWidthFromCol)
        {
            pCFI->_ff().SetWidth(cuvColWidth);
        }
        pCFI->_ff().SetPosition(SIDE_TOP, uvNull);
        pCFI->_ff().SetPosition(SIDE_LEFT, uvNull);
        pCFI->_ff().SetExplicitMargin(SIDE_TOP, FALSE);
        pCFI->_ff().SetExplicitMargin(SIDE_RIGHT, FALSE);
        pCFI->_ff().SetExplicitMargin(SIDE_BOTTOM, FALSE);
        pCFI->_ff().SetExplicitMargin(SIDE_LEFT, FALSE);
        pCFI->_ff().SetMargin(SIDE_TOP, uvNull);
        pCFI->_ff().SetMargin(SIDE_RIGHT, uvNull);
        pCFI->_ff().SetMargin(SIDE_BOTTOM, uvNull);
        pCFI->_ff().SetMargin(SIDE_LEFT, uvNull);
        pCFI->_ff()._bDisplay = styleDisplayNotSet;
        pCFI->_ff()._bPositionType = stylePositionNotSet;
        pCFI->_ff()._lZIndex = 0;
        pCFI->_ff()._fPositioned = FALSE;
        pCFI->_ff()._fAutoPositioned = FALSE;
        pCFI->_ff()._fScrollingParent = FALSE;
        pCFI->_ff()._fZParent = FALSE;
        pCFI->_ff()._pszFilters = NULL;
        pCFI->_ff()._bPageBreaks = 0;
        pCFI->_ff()._iExpandos = -1;
        pCFI->_ff()._iCustomCursor = -1   ;     
        pCFI->_ff()._iPEI = -1;
        pCFI->_ff()._fHasExpressions = FALSE;
        pCFI->_ff().SetCSSVerticalAlign(FALSE);
        pCFI->_ff().SetVerticalAlign(styleVerticalAlignNotSet);
        pCFI->_ff()._fLayoutFlowChanged = FALSE;
        pCFI->UnprepareForDebug();
    }

    //
    // Due to the complexity of alignment, we must keep these values
    // synchronised.
    //
    pCFI->_bCtrlBlockAlign = pCFI->_bBlockAlign;

    // copy the display & visibility values onto the pCFI, so if
    // visibility/display style change, pcf is correctly updated.
    pCFI->_fDisplayNone      = pCFI->_pcf->_fDisplayNone;
    pCFI->_fVisibilityHidden = pCFI->_pcf->_fVisibilityHidden;

    // Apply the cell itself
    pCFI->_pNodeContext = pNodeTarget;
    hr = THR(ApplyCellFormat(pCFI));
    if (hr)
        goto Error;

    // Transfer the cascading table valign into the vertical align
    hr = VerticalAlignFromCellVAlign(pCFI);
    if (hr)
        goto Error;

    // Vertical alignment for layouts has no meaning (TD has a layout),
    // so it is safe to turn off _fNeedsVerticalAlign flag.
    // We are doing this for perf reasons, when TD has a "vertical-align" property set.
    // In case of vertical text we set _fNeedsVerticalAlign to TRUE in ApplyDefaultFormat, 
    // because of middle vertical alignment of vertical text. So in this case don't 
    // turn off this flag.
    if (   pCFI->_pcf->_fNeedsVerticalAlign
        && !fComputeFFOnly
        && !pCFI->_pcf->HasVerticalLayoutFlow())
    {
        pCFI->PrepareCharFormat();
        pCFI->_cf()._fNeedsVerticalAlign = FALSE;
        pCFI->UnprepareForDebug();
    }

    //
    // NETSCAPE: If the user specified both WIDTH and NOWRAP, ignore NOWRAP if a fixed
    //           WIDTH was supplied (e.g., in pixels, not percent).
    //           PRE tags within the cell should still apply.
    //
    {
        // Since table is always horizontal, we get physical width.
        const CUnitValue & cuvWidth = pCFI->_pff->GetWidth();
        if (    pCFI->_fNoBreak
            &&  !cuvWidth.IsNull()
            &&  !cuvWidth.IsPercent())
        {
            pCFI->_fNoBreak = FALSE;
        }
    }

    hr = ApplyInnerOuterFormats(pCFI);
    if (hr)
        goto Error;

    if (   Tag() == ETAG_CAPTION
        && (pCFI->_pff->_bPositionType != stylePositionNotSet
        ||  pCFI->_pff->_fPositioned))
    {
        // don't support positioning on captions
        pCFI->PrepareFancyFormat();
        pCFI->_ff()._bPositionType = stylePositionNotSet;
        pCFI->_ff()._fPositioned = FALSE;
        pCFI->UnprepareForDebug();
    }

    {
        CMarkup * pMarkup = GetMarkup();
        if ((_fHasFilterSitePtr || pCFI->_fHasFilters) && !pMarkup->IsPrintMedia())
        {
            ComputeFilterFormat(pCFI);
        }
    }

    if(eExtraValues == ComputeFormatsType_Normal)
    {
        hr = THR(pNodeTarget->CacheNewFormats(pCFI));
        pCFI->_cstrFilters.Free();  // Arrggh!!! NOTE (michaelw)  This should really happen 
                                    // somewhere else (when you know where, put it there)
                                    // Fix CElement::ComputeFormats also
        if (hr)
            goto Error;

        // TODO (michaelw) Why do this after caching the new format?
        //                   Why not do it before and not be affected
        //                   by some strange new error return
        //

        // Update expressions in the recalc engine
        //
        // If we had expressions or have expressions then we need to tell the recalc engine
        // 
        if (pCFI->_pff->_fHasExpressions)
        {
            Doc()->AddExpressionTask(this);
            pCFI->NoStealing();
        }
    }

Cleanup:

    // Set the _fBlockNess cache bit on the node to save a little time later.
    // Need to do this here because we don't call super.
    pNodeTarget->_fBlockNess = TRUE;

    WHEN_DBG( pTableLayout->_fDisableTLCAssert = fDisableTLCAssert; )

    SwitchesEndTimer(SWITCHES_TIMER_COMPUTEFORMATS);

    RRETURN(hr);

Error:
    pCFI->Cleanup();
    goto Cleanup;

StealFormat:
    pNodeInherit = pCellNeighbor->GetFirstBranch();
    Assert(   (pNodeTarget->_iPF == -1) 
           || (pNodeTarget->_iCF == -1)
           || (pNodeTarget->_iFF == -1));

    pNodeTarget->_iPF = pNodeInherit->_iPF;
    if (pNodeTarget->_iPF >= 0)
        pts->_pParaFormatCache->AddRefData( pNodeTarget->_iPF );

    pNodeTarget->_iCF = pNodeInherit->_iCF;
    if (pNodeTarget->_iCF >= 0)
        pts->_pCharFormatCache->AddRefData( pNodeTarget->_iCF );

    pNodeTarget->_iFF = pNodeInherit->_iFF;
    if (pNodeTarget->_iFF >= 0)
        pts->_pFancyFormatCache->AddRefData( pNodeTarget->_iFF );

    MtAdd(Mt(CharFormatSteal), 1, 0);
    MtAdd(Mt(ParaFormatSteal), 1, 0);
    MtAdd(Mt(FancyFormatSteal), 1, 0);
    _fInheritedWidth = pCellNeighbor->_fInheritedWidth;

    goto Cleanup;

TableStructureViolated:

    WHEN_DBG( if (pTableLayout) pTableLayout->_fDisableTLCAssert = fDisableTLCAssert; )
    SwitchesEndTimer(SWITCHES_TIMER_COMPUTEFORMATS);
    return super::ComputeFormatsVirtual(pCFI, pNodeTarget);
}

//+---------------------------------------------------------------------------
//
//  Member:     CTableCell::Notify, CSite
//
//  Synopsis:   Handle notification
//
//----------------------------------------------------------------------------

void
CTableCell::Notify(CNotification *pNF)
{
    HRESULT hr = S_OK;

    super::Notify(pNF);

    switch (pNF->Type())
    {
    case NTYPE_ELEMENT_ENTERTREE:
        hr = EnterTree();
        break;
    case NTYPE_ELEMENT_EXITTREE_1:
        if (Tag() == ETAG_TC && !(pNF->DataAsDWORD() & EXITTREE_DESTROY) )
        {
            CTable * pTable = Table();
            CTableLayout * pTableLayout = pTable ? pTable->TableLayoutCache() : NULL;

            if (pTableLayout && pTableLayout->IsRepeating())
            {
                Assert(pTable->IsDatabound());
                int             ic, cC;
                CTableCaption  *pCaption;
                CTableCaption **ppCaption;

                for (cC = pTableLayout->_aryCaptions.Size(), ic = 0, ppCaption = pTableLayout->_aryCaptions;
                     cC > 0;
                     cC--, ppCaption++, ic++)
                {
                    pCaption = *ppCaption;
                    if (pCaption == this)
                    {
                        pTableLayout->DeleteCaption(ic);
                        break;
                    }
                }
            }
        }
        break;
    }

    return;
}




#define _cxx_
#include "caption.hdl"


const CElement::CLASSDESC CTableCaption::s_classdesc =
{
    {
        &CLSID_HTMLTableCaption,        // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_NEVERSCROLL |
        ELEMENTDESC_TEXTSITE    |
        ELEMENTDESC_TABLECELL   |
        ELEMENTDESC_NOBKGRDRECALC,      // _dwFlags
        &IID_IHTMLTableCaption,         // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLTableCaption,  // _pfnTearOff
    &s_AccelsTCellRun                   // _pAccelsRun
};


HRESULT
CTableCaption::CreateElement(CHtmTag *pht,
                  CDoc *pDoc, CElement **ppElement)
{
    Assert(ppElement);

    *ppElement = new CTableCaption(pht->GetTag(), pDoc);
    RRETURN ((*ppElement) ? S_OK : E_OUTOFMEMORY);
}



// copy constructor
CHeightUnitValue::CHeightUnitValue (const CUnitValue &uv)
: CNiceUnitValue(uv)
{
}
// copy constructor
CHeightUnitValue::CHeightUnitValue (const CHeightUnitValue &uv)
: CNiceUnitValue(uv)
{
}

// copy constructor
CWidthUnitValue::CWidthUnitValue (const CUnitValue &uv)
: CNiceUnitValue(uv)
{
}

// copy constructor
CWidthUnitValue::CWidthUnitValue (const CWidthUnitValue &uv)
: CNiceUnitValue(uv)
{
}

// copy constructor
CNiceUnitValue::CNiceUnitValue (const CUnitValue &uv)
: CUnitValue(uv)
{
}

int CTableCell::RowIndex() const
{
    Assert( Tag() != ETAG_CAPTION && Tag() != ETAG_TC );
    CTableRow *pRow = Row();
    return (pRow) ? pRow->_iRow : -1;
}

// Returns true if currect cell is in given range of cells
BOOL
CTableCell::IsInRange(RECT *pRect)
{
    if (IsDisplayNone() || GetFirstBranch()->GetFancyFormat()->_bPositionType == stylePositionabsolute)
        return FALSE;

    int nRow = RowIndex();
    int nCol = ColIndex();

    if(nRow < pRect->top  || nRow > pRect->bottom ||
            nCol < pRect->left || nCol > pRect->right)
        return FALSE;

    return TRUE;
}


BOOL
CTableCell::IsNoPositionedElementsUnder()
{
    CTreeNode *  pNodeSelf = GetFirstBranch();
    CTreePos  *  ptp = pNodeSelf->GetBeginPos();
    for (;;)
    {
        ptp = ptp->NextTreePos();
        Assert (ptp);
        switch( ptp->Type() )
        {
        case CTreePos::NodeEnd:
            if (ptp->Branch() == pNodeSelf && ptp->IsEdgeScope())
                return TRUE;
        case CTreePos::NodeBeg:
            if (ptp->Branch()->GetFancyFormat()->_fPositioned)
                goto Cleanup;
        }
    }
Cleanup:
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\builtin\tdraw.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       tdraw.cxx
//
//  Contents:   CTable and related classes.
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include <formkrnl.hxx>
#endif

#ifndef X_TABLE_HXX_
#define X_TABLE_HXX_
#include "table.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include <download.hxx>
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include <othrguid.h>
#endif

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include <binder.hxx>
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_LTROW_HXX_
#define X_LTROW_HXX_
#include "ltrow.hxx"
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include "ltcell.hxx"
#endif

#ifndef X_DISPDEFS_HXX_
#define X_DISPDEFS_HXX_
#include "dispdefs.hxx"
#endif

MtDefine(CTableDrawSiteList_aryElements_pv, Locals, "CTable::DrawSiteList aryElements::_pv")
MtDefine(CTable_pBorderInfoCellDefault, CTable, "CTable::_pBorderInfoCellDefault")

ExternTag(tagTableRecalc);

extern const WORD s_awEdgesFromTableFrame[];
const WORD s_awEdgesFromTableFrame[htmlFrameborder+1] =
{
    BF_RECT,        // not set case, use all edges
    0,
    BF_TOP,
    BF_BOTTOM,
    BF_TOP | BF_BOTTOM,
    BF_LEFT,
    BF_RIGHT,
    BF_LEFT | BF_RIGHT,
    BF_RECT,
    BF_RECT
};


extern const WORD s_awEdgesFromTableRules[];
const WORD s_awEdgesFromTableRules[htmlRulesall+1] =
{
    BF_RECT,    // not set case, use all edges
    0,
    0,
    BF_TOP | BF_BOTTOM,
    BF_LEFT | BF_RIGHT,
    BF_RECT,
};


//+---------------------------------------------------------------------------
//
//  Member:     CTableCell::GetBorderInfo
//
//  Synopsis:   fill out border information
//
//----------------------------------------------------------------------------

DWORD
CTableCell::GetBorderInfo(CDocInfo * pdci, CBorderInfo *pborderinfo, BOOL fAll, BOOL fAllPhysical FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    // (t-michda) I added four default parameters so a format context could be included.
    return Layout( pdci->GetLayoutContext() )->GetCellBorderInfo(pdci, pborderinfo, fAll, fAllPhysical, 0, NULL, NULL, NULL FCCOMMA FCPARAM);
}


//+---------------------------------------------------------------------------
//
//  Member:     CTable::GetBorderInfo
//
//  Synopsis:   fill out border information
//
//----------------------------------------------------------------------------

DWORD
CTable::GetBorderInfo(CDocInfo * pdci, CBorderInfo *pborderinfo, BOOL fAll, BOOL fAllPhysical FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    return TableLayoutCache()->GetTableBorderInfo(pdci, pborderinfo, fAll, fAllPhysical FCCOMMA FCPARAM);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\builtin\wselect.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//   File:      wselect.h
//
//  Contents:   Unicode support for CSelectElement on win95.
//
//------------------------------------------------------------------------

#ifndef I_WSELECT_H_
#define I_WSELECT_H_
#pragma INCMSG("--- Beg 'wselect.h'")

LRESULT CALLBACK WListboxHookProc(WNDPROC pfnWndProc, HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
LRESULT CALLBACK WComboboxHookProc(WNDPROC pfnWndProc, HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

#pragma INCMSG("--- End 'wselect.h'")
#else
#pragma INCMSG("*** Dup 'wselect.h'")
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\builtin\trowcol.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       table.cxx
//
//  Contents:   CTable and related classes.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_TABLE_HXX_
#define X_TABLE_HXX_
#include "table.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_LTROW_HXX_
#define X_LTROW_HXX_
#include "ltrow.hxx"
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include "ltcell.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_SWITCHES_HXX_
#define X_SWITCHES_HXX_
#include "switches.hxx"
#endif

MtDefine(CTableRow, Elements, "CTableRow")
MtDefine(CTableRow_aryCells_pv, CTableRow, "CTableRow::_aryCells::_pv")
MtDefine(CTableCol, Elements, "CTableCol")
MtDefine(CTableSection, Elements, "CTableSection")
MtDefine(BldRowCellsCol, PerfPigs, "Build CTableRow::CELLS_COLLECTION")
MtDefine(BldSectionRowsCol, PerfPigs, "Build CTableSection::ROWS_COLLECTION")
MtDefine(CharFormatSteal, ComputeFormats, "CharFormat steal from nearby row/col/cell")
MtDefine(ParaFormatSteal, ComputeFormats, "ParaFormat steal from nearby row/col/cell")
MtDefine(FancyFormatSteal, ComputeFormats, "FancyFormat steal from nearby row/col/cell")

const CElement::CLASSDESC CTableRow::s_classdesc =
{
    {
        &CLSID_HTMLTableRow,            // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_NOTIFYENDPARSE |
        0,                              // _dwFlags
        &IID_IHTMLTableRow,             // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLTableRow,      // _pfnTearOff
    NULL                                // _pAccelsRun
};


HRESULT
CTableRow::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(pht->Is(ETAG_TR));
    Assert(ppElement);

    *ppElement = new CTableRow(pDoc);
    RRETURN( (*ppElement) ? S_OK : E_OUTOFMEMORY);
}


//+------------------------------------------------------------------------
//
//  Member:     CTableRow::destructor, CBase
//
//  Note:       The collection cache must be deleted in the destructor, and
//              not in Passivate, because collection objects we've handed out
//              (via get_cells) merely SubAddRef the row.
//-------------------------------------------------------------------------

CTableRow::~CTableRow()
{
    delete _pCollectionCache;
}


//+------------------------------------------------------------------------
//
//  Member:     CTableRow::Passivate, CBase
//
//-------------------------------------------------------------------------

void
CTableRow::Passivate()
{
    super::Passivate();
}

//+----------------------------------------------------------------------------
//
//  Member:     CTableRow::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-----------------------------------------------------------------------------

HRESULT
CTableRow::PrivateQueryInterface ( REFIID iid, void ** ppv )
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_INHERITS2(this, IUnknown, IHTMLTableRow)
        QI_HTML_TEAROFF(this, IHTMLTableRow, NULL)
        QI_HTML_TEAROFF(this, IHTMLTableRow2, NULL)
        QI_HTML_TEAROFF(this, IHTMLTableRow3, NULL)
        QI_TEAROFF(this, IHTMLTableRowMetrics, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     CTableRow::ComputeFormatsVirtual
//
//  Synopsis:   Compute Char and Para formats induced by this element and
//              every other element above it in the HTML tree.
//
//  Arguments:  pCFI - Format Info needed for cascading
//
//  Returns:    HRESULT
//
//  Note:       We override this here to put our defaults into the format
//              FIRST, and also to cache vertical alignment here in the object
//
//-------------------------------------------------------------------------

HRESULT
CTableRow::ComputeFormatsVirtual(CFormatInfo * pCFI, CTreeNode * pNodeTarget )
{
    SwitchesBegTimer(SWITCHES_TIMER_COMPUTEFORMATS);

    HRESULT hr;
    CTableRowLayout *pRowLayout;

    Assert(pNodeTarget && SameScope(this, pNodeTarget));

    pRowLayout = RowLayoutCache();
    Assert(pRowLayout);

    //check row above
    //TODO: (alexa) for data-binding we should take comparable row in a previous GENERATED section instead of a previous row
    if (pRowLayout->RowPosition() > 0)
    {
        CTable    * pTable = Table();

        // If we can't find our table, the table structure is messed up and
        // our compute formats behave like a CElement.
        if (!pTable)
            goto DontStealFormat;

        CTableLayout * pTableLayout = pTable->TableLayoutCache();
        CTableRow * pRow;
        CTreeNode * pNodeRow;

        {
            WHEN_DBG(
                BOOL fDisableTLCAssert = pTableLayout->_fDisableTLCAssert;
                pTableLayout->_fDisableTLCAssert = TRUE; )

            pRow = (pRowLayout->RowPosition()-1 < pTableLayout->GetRows()) 
                        ? pTableLayout->GetRow(pRowLayout->RowPosition()-1) 
                        : NULL;

            WHEN_DBG(
                pTableLayout->_fDisableTLCAssert = fDisableTLCAssert; )
        }

        pNodeRow = pRow ? pRow->GetFirstBranch() : NULL;

        //
        // Proxy Alert!
        //
        // Notice that to do this optimization we are comparing the parent
        // of pElementTarget to that of pRow.  pElementTarget is in the
        // tree (and may be a proxy), while pRow may not be in the tree.
        // But, if the parent of pRow is the parent of pElementTarget, then
        // pRow is in the tree.
        //

        // We do not use this optimization when ComputeFormats is called for getttng a value
        if(pCFI->_eExtraValues != ComputeFormatsType_Normal ||
               !pTableLayout->IsTableLayoutCacheCurrent()   ||
               !pRow                                        ||
               pRow->_fHasPendingRecalcTask)
            goto DontStealFormat;

        if (pNodeRow && pNodeRow->_iPF >= 0 && pNodeRow->_iCF >= 0 && pNodeRow->_iFF >= 0 &&
            SameScope(pNodeTarget->Parent(), pNodeRow->Parent()) && pRow->_fStealingAllowed &&
            (_pAA == NULL && pRow->_pAA == NULL ||
             _pAA != NULL && pRow->_pAA != NULL && _pAA->Compare(pRow->_pAA)) )
        {
            THREADSTATE * pts = GetThreadState();

            // At least one of the caches is dirty.
            Assert(pNodeTarget->_iPF == -1 || pNodeTarget->_iCF == -1 || pNodeTarget->_iFF == -1);

            // The caches that were not dirty, have to match with the corresponding caches of
            // the previous row.
            Assert(pNodeTarget->_iPF == -1 || pNodeTarget->_iPF == pNodeRow->_iPF);
            Assert(pNodeTarget->_iCF == -1 || pNodeTarget->_iCF == pNodeRow->_iCF);
            Assert(pNodeTarget->_iFF == -1 || pNodeTarget->_iFF == pNodeRow->_iFF);

            //
            // Selectively copy down each of the dirty caches.
            //

            if (pNodeTarget->_iPF == -1)
            {
                pNodeTarget->_iPF = pNodeRow->_iPF;
                (pts->_pParaFormatCache)->AddRefData( pNodeRow->_iPF );
                MtAdd(Mt(ParaFormatSteal), 1, 0);
            }

            if (pNodeTarget->_iCF == -1)
            {
                pNodeTarget->_iCF = pNodeRow->_iCF;
                (pts->_pCharFormatCache)->AddRefData( pNodeRow->_iCF );
                MtAdd(Mt(CharFormatSteal), 1, 0);
            }

            if (pNodeTarget->_iFF == -1)
            {
                pNodeTarget->_iFF = pNodeRow->_iFF;
                (pts->_pFancyFormatCache)->AddRefData( pNodeRow->_iFF );
                MtAdd(Mt(FancyFormatSteal), 1, 0);
            }

            // Set the _fBlockNess cache bit on the node to save a little time later.
            // Need to do this here because we don't call super.
            pNodeTarget->_fBlockNess = TRUE;

            hr = S_OK;
            goto Cleanup;
        }
    }

DontStealFormat:

    hr = THR(super::ComputeFormatsVirtual( pCFI, pNodeTarget ));

Cleanup:

    SwitchesEndTimer(SWITCHES_TIMER_COMPUTEFORMATS);

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     ApplyDefaultFormat
//
//  Synopsis:   Applies default formatting properties for that element to
//              the char and para formats passed in
//
//  Arguments:  pCF - charformat to apply default properties on
//              pPF - paraformat to apply default properties on
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CTableRow::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    CColorValue ccvBorderColor;
    CColorValue ccvColor;
    HRESULT     hr;

    hr = super::ApplyDefaultFormat(pCFI);
    if (hr)
        goto Cleanup;

    pCFI->PrepareFancyFormat();

    // Override inherited colors as necessary
    ccvBorderColor = GetAAborderColor();
    if ( ccvBorderColor.IsDefined() )
    {
        long    i;

        for (i = 0; i < SIDE_MAX; i++)
        {
            pCFI->_ff()._bd.SetBorderColor(i, ccvBorderColor);
        }

        pCFI->_ff()._bd._ccvBorderColorLight   =
        pCFI->_ff()._bd._ccvBorderColorHilight =
        pCFI->_ff()._bd._ccvBorderColorDark    =
        pCFI->_ff()._bd._ccvBorderColorShadow  = ccvBorderColor;
        pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
    }

    ccvBorderColor = GetAAborderColorLight();
    if (ccvBorderColor.IsDefined())
    {
        pCFI->_ff()._bd._ccvBorderColorLight   =
        pCFI->_ff()._bd._ccvBorderColorHilight = ccvBorderColor;
        pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
    }

    ccvBorderColor = GetAAborderColorDark();
    if (ccvBorderColor.IsDefined())
    {
        pCFI->_ff()._bd._ccvBorderColorDark    =
        pCFI->_ff()._bd._ccvBorderColorShadow  = ccvBorderColor;
        pCFI->_ff()._bd._fOverrideTablewideBorderDefault = TRUE;
    }

    pCFI->UnprepareForDebug();

Cleanup:

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CTableRow::Save
//
//  Synopsis:   Save the element to the stream
//
//-------------------------------------------------------------------------

HRESULT
CTableRow::Save(CStreamWriteBuff *pStmWrBuff, BOOL fEnd)
{
    HRESULT hr = S_OK;

    hr = super::Save(pStmWrBuff, fEnd);
    if (hr)
        goto Cleanup;

    if (fEnd && pStmWrBuff->TestFlag(WBF_SAVE_PLAINTEXT))
    {
        hr = pStmWrBuff->NewLine();
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CTableRow::OnPropertyChange
//
//  Synopsis:   Process property changes to table row element.
//
//-------------------------------------------------------------------------

HRESULT
CTableRow::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr;
    CTable *pTable = NULL;
    BOOL    fPropagateChange = FALSE;
    BOOL    fSpecialProperty = FALSE;

    hr = THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc));
    if (hr)
        goto Cleanup;

    switch (dispid)
    {
    case DISPID_A_DISPLAY:
    case DISPID_A_POSITION:
        pTable = Table();
        if (pTable)
        {
            CTableLayout *pTableLayout = pTable->TableLayoutCache();
            Assert (pTableLayout);
            if (_fHaveRowSpanCells || _fCrossingRowSpan)
            {
                pTableLayout->MarkTableLayoutCacheDirty();
            }
            pTableLayout->Resize();
        }
        break;

    case DISPID_A_VISIBILITY:
    case DISPID_A_BACKGROUNDIMAGE:
    case DISPID_BACKCOLOR:
        // If the backgroundcolor or image changes, let the affected table
        // cells know, so that they can update their display tree nodes.
        fPropagateChange = TRUE;
        fSpecialProperty = TRUE;
        break;

    default:
        if (dwFlags & (ELEMCHNG_REMEASUREINPARENT | ELEMCHNG_SIZECHANGED |
                       ELEMCHNG_REMEASURECONTENTS | ELEMCHNG_REMEASUREALLCONTENTS))
        {
            fPropagateChange = TRUE;
        }
        break;
    }

    if (fPropagateChange)
    {
        hr = THR(PropagatePropertyChangeToCells(dispid, dwFlags, fSpecialProperty));
        //if (hr)
        //    goto Cleanup;
    }

Cleanup:

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CTableRow::PropagatePropertyChangeToCells
//
//  Synopsis:   Helper function to propagate property changes from
//              table elements to cells.  Called by CTableSection::
//              and CTableRow::OnPropertyChange().
//
//-------------------------------------------------------------------------

HRESULT
CTableRow::PropagatePropertyChangeToCells(DISPID dispid, 
                                          DWORD dwFlags, 
                                          BOOL fSpecialProperty)
{
    CTableRowLayout * pRowLayout = RowLayoutCache();
    CTableCell     ** ppCell;
    CTableCell      * pCell;
    CTableCellLayout * pCellLayout;
    int               cColSpan, cCols, cCells;
    HRESULT           hr = S_OK;
    CTable           *pTable = Table();
    CTableLayout     *pTableLayout = pTable? pTable->TableLayoutCache() : NULL;

    if (!pRowLayout)
        goto Cleanup;
  
    if (!pTableLayout)
        goto Cleanup;

    hr = pTableLayout->EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    for (cCols = pRowLayout->_aryCells.Size(), ppCell = pRowLayout->_aryCells ;  
         cCols > 0; 
         cCols -= cColSpan, ppCell += cColSpan)
    {
        pCell = Cell(*ppCell);
        pCellLayout = pCell ? pCell->Layout() : NULL;

        if (pCell && pCellLayout)
        {
            cColSpan = pCell->ColSpan();
            if (fSpecialProperty)
            {
                hr = THR(pCellLayout->OnPropertyChange(dispid, dwFlags));
                if (hr)
                    goto Cleanup;
            }
            else if (dwFlags & (ELEMCHNG_REMEASUREINPARENT | ELEMCHNG_SIZECHANGED))
            {
                pCellLayout->SetSizeThis( TRUE ); // cell needs to be sized
            }
            else 
            {
                Assert (dwFlags & (ELEMCHNG_REMEASURECONTENTS | ELEMCHNG_REMEASUREALLCONTENTS));
                pCell->RemeasureElement(dwFlags & ELEMCHNG_REMEASUREALLCONTENTS
                                        ? NFLAGS_FORCE
                                        : 0); // make sure we remeasure this cell
                if (pTableLayout->IsFixed())
                {
                    pTableLayout->ResetIncrementalRecalc();  // hack, bug #75881, need to force fixed table to calc.
                    // pRowLayout->SetSizeThis( TRUE );   // the right solution would be to set _fSizeThis
                    // and let CalculateLayout to call CalculateRow for this layout (obvisouly we would need to
                    // enusre LAYOUT_FORCE flag via notification to trigger that logic).
                }
            }
        }
        else
        {
            cColSpan = 1;
        }
    }

    if (pRowLayout->_pDisplayNoneCells)
    {
        for (cCells = pRowLayout->_pDisplayNoneCells->Size(), ppCell = *pRowLayout->_pDisplayNoneCells ;  cCells > 0; cCells--, ppCell++)
        {
            hr = THR((*ppCell)->Layout()->OnPropertyChange(dispid, dwFlags));
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  ROW CELLS collection
//
//-------------------------------------------------------------------------

//-------------------------------------------------------------------------
// Note: the GetNext interface is LITTLE BIT STRANGE (I am being polite to OM team: alexa):
//       it should of being called GetCurrent and Prepare for the Next
//-------------------------------------------------------------------------

CElement *
CTableRowCellsCollectionCacheItem::MoveTo ( long lIndex )
{
    _lCurrentIndex = lIndex;
    return CTableRowCellsCollectionCacheItem::GetAt(lIndex);
}


CElement *
CTableRowCellsCollectionCacheItem::GetNext ( void )
{
    CTableCell *pCell = NULL, *pCellNext;
    int i, cCols;
    
    if (_iCurrentCol < 0)
    {
        return GetAt(_lCurrentIndex++);
    }
    else if (_pRowLayout && _lCurrentIndex < _pRowLayout->_cRealCells)
    {
        // 1. Get Current
        // 2. Prepare for the next
        BOOL    fDisplayNone = _pRowLayout->_pDisplayNoneCells != NULL && _cDisplayNone < _pRowLayout->_pDisplayNoneCells->Size();

        Assert ( _iCurrentCol >= 0 && (_iCol >= 0 || _cDisplayNone >= 0) );
        cCols = _pRowLayout->_aryCells.Size();
        Assert (_iCol < cCols);

        if (_iCol >= 0)
        {
            pCell = _pRowLayout->_aryCells[_iCol];
            Assert (IsReal(pCell));
            // Prepare for the next
            i = _iCol + pCell->ColSpan();
        }
        else
        {
            Assert (_cDisplayNone >= 0);
            pCell = (*_pRowLayout->_pDisplayNoneCells)[_cDisplayNone];
            i =  pCell->ColIndex();
            if (++_cDisplayNone >= _pRowLayout->_pDisplayNoneCells->Size())
            {
                fDisplayNone = FALSE;
            }
        }


        _lCurrentIndex ++;
        _iCol = -1;
        _iCurrentCol = -1;

        while (i < cCols)
        {
            if (fDisplayNone && (*_pRowLayout->_pDisplayNoneCells)[_cDisplayNone]->ColIndex() == i)
            {
                _iCurrentCol = i;
                break;
            }
            pCellNext = _pRowLayout->_aryCells[i];
            if (IsReal(pCellNext))
            {
                _iCol = i;
                _iCurrentCol = i;
                break;
            }
            i++;
        }

    }

    return pCell;
}

CElement *
CTableRowCellsCollectionCacheItem::GetAt ( long lIndex )
{
    int         i;
    CTableCell  *pCell = NULL;
    int         iRealCell = 0;

    _iCol = -1;
    _iCurrentCol = -1;
    _cDisplayNone = -1;

    Assert ( lIndex >= 0);
    Assert (_pRowLayout);
    if (lIndex < _pRowLayout->_cRealCells)
    {

        BOOL            fDisplayNone = _pRowLayout->_pDisplayNoneCells != NULL;
        int             cDisplayNoneCells = 0;
        int             iDisplayNoneCol   = -1;
        CTableCell   **ppDisplayNoneCells = NULL;

        int  cCells = _pRowLayout->_aryCells.Size();
        if (fDisplayNone)
        {
            cDisplayNoneCells = _pRowLayout->_pDisplayNoneCells->Size();
            ppDisplayNoneCells = (*_pRowLayout->_pDisplayNoneCells);
            _cDisplayNone = 0;
            iDisplayNoneCol = (*ppDisplayNoneCells)->ColIndex();
        }
        for (i = 0; i < cCells || fDisplayNone; i++)
        {
            if (fDisplayNone && i == iDisplayNoneCol)
            {
                if (iRealCell == lIndex)
                {
                    pCell = *ppDisplayNoneCells;
                    break;
                }
                else
                {
                    _cDisplayNone++;
                    cDisplayNoneCells--;
                    if (!cDisplayNoneCells)
                    {
                        fDisplayNone = FALSE;
                    }
                    else
                    {
                        ppDisplayNoneCells++;
                        iDisplayNoneCol = (*ppDisplayNoneCells)->ColIndex();
                    }
                    iRealCell++;
                    i--;
                    continue;
                }
            }
            pCell = _pRowLayout->_aryCells[i];
            if ( IsReal(pCell) )
            {
                if (iRealCell == lIndex)
                {
                    _iCol = i;
                    break;
                }
                else
                {
                    iRealCell++;
                    i += pCell->ColSpan() - 1;    // - 1 to account for i++
                }
            }
        }

        _iCurrentCol = i;
        Assert (iRealCell < _pRowLayout->_cRealCells && pCell);
    }
    return pCell;
}

long 
CTableRowCellsCollectionCacheItem::Length ( void )
{
    if (_pRowLayout)
        return _pRowLayout->_cRealCells;
    else
        return NULL;
}


//+------------------------------------------------------------------------
//
//  Member:     EnsureCollectionCache
//
//  Synopsis:   Create the row's collection cache if needed.
//
//-------------------------------------------------------------------------

HRESULT
CTableRow::EnsureCollectionCache(long lIndex)
{
    HRESULT hr = S_OK;

    CTable *pTable = Table();
    if (pTable)
    {
        CTableLayout * pTableLayout = pTable->TableLayoutCache();
        Assert (pTableLayout);
        hr = pTableLayout->EnsureTableLayoutCache();
        if (hr)
            goto Cleanup;
    }
    
    if (!_pCollectionCache)
    {
        _pCollectionCache = new CCollectionCache(
                this,
                GetWindowedMarkupContext(),
                ENSURE_METHOD(CTableRow, EnsureCollections, ensurecollections));
        if (!_pCollectionCache)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(_pCollectionCache->InitReservedCacheItems(1, 1));
        if (hr)
            goto Error;

        CTableRowCellsCollectionCacheItem *pCellsCollection = new CTableRowCellsCollectionCacheItem(this);
        if ( !pCellsCollection )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(_pCollectionCache->InitCacheItem ( CELLS_COLLECTION, pCellsCollection ));
        if (hr)
            goto Cleanup;

        //
        // Collection cache now owns this item & is responsible for freeing it
        //

    }

Cleanup:
    RRETURN(hr);

Error:
    delete _pCollectionCache;
    _pCollectionCache = NULL;
    goto Cleanup;
}


//+------------------------------------------------------------------------
//
//  Member:     EnsureCollections
//
//  Synopsis:   Refresh the cells collection, if needed.
//
//-------------------------------------------------------------------------

HRESULT
CTableRow::EnsureCollections(long lIndex, long * plCollectionVersion)
{
    CTable       *pTable = Table();
    CTableLayout *pTableLayout = pTable? pTable->TableLayoutCache() : NULL;
    HRESULT hr = S_OK;

    Assert (_pCollectionCache);

    CTableRowCellsCollectionCacheItem *pCellsCollection = (CTableRowCellsCollectionCacheItem *) _pCollectionCache->GetCacheItem (lIndex);

    Assert (pCellsCollection);
    pCellsCollection->_iCol = -1;           // Next item must be recomputed
    pCellsCollection->_iCurrentCol = -1;

    if ( pTableLayout)
    {
        hr = pTableLayout->EnsureTableLayoutCache();
        *plCollectionVersion = pTableLayout->_iCollectionVersion;   // to mark it done
    }
    RRETURN(hr);
}

const CTableSection::CLASSDESC CTableSection::s_classdesc =
{
    {
        &CLSID_HTMLTableSection,        // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_NOTIFYENDPARSE |
        ELEMENTDESC_NOLAYOUT,           // _dwFlags
        &IID_IHTMLTableSection,         // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLTableSection   // _pfnTearOff
};


//+------------------------------------------------------------------------
//
//  Member:     CTableSection::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CTableSection::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_TEAROFF(this, IHTMLTableSection2, NULL)
        QI_HTML_TEAROFF(this, IHTMLTableSection3, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

HRESULT
CTableSection::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(pht->Is(ETAG_THEAD) || pht->Is(ETAG_TFOOT) || pht->Is(ETAG_TBODY));
    Assert(ppElement);
    *ppElement = new CTableSection(pht->GetTag(), pDoc);
    return *ppElement ? S_OK : E_OUTOFMEMORY;
}


//+---------------------------------------------------------------------------
//
//  Member:     CTableSection::Notify, CSite
//
//  Synopsis:   Handle notification
//
//----------------------------------------------------------------------------

void
CTableSection::Notify(CNotification *pNF)
{
    DWORD           dw = pNF->DataAsDWORD();

    super::Notify(pNF);
    switch (pNF->Type())
    {
    case NTYPE_ELEMENT_ENTERTREE:
        {
            CTable       *pTable = Table();

            if (pTable)
            {
                CTableLayout *pTableLayout = pTable->TableLayoutCache();
                Assert (pTableLayout);

                if (!(dw & ENTERTREE_PARSE) && !pTableLayout->_fEnsureTBody)
                {
                    pTableLayout->_fDontSaveHistory = TRUE;
                }
                if (dw & ENTERTREE_MOVE)   // if it is a MOVETREE notification
                {
                    // we are moved from another tree
                    if (pTableLayout->_fPastingRows)
                    {
                        Assert (pTable->IsDatabound() && pTableLayout->IsRepeating());
                        pTableLayout->AddSection(this);
                    }
                    else
                    {
                        pTableLayout->MarkTableLayoutCacheDirty();
                    }
                }
                else
                {
                    EnterTree();
                }
            }
        }
        break;
    case NTYPE_ELEMENT_EXITTREE_1:
        if (!(dw & EXITTREE_DESTROY))
        {
            CTable          *pTable = Table();

            if (!pTable)
                break;

           CTableLayout    *pTableLayout = pTable->TableLayoutCache();
           Assert(pTableLayout);

           if (!(dw & EXITTREE_MOVE))      // if it is not a move tree
            {

                // don't update the caches for individual rows in case of :1) shutdown; 2) data-binding removing rows
                if (!(pTableLayout->_fRemovingRows || pTable->_fExittreePending))
                {
                    // Don't hold refs to the tree after our element leaves it
                    pTableLayout->BodyExitTree(this);
                    pTableLayout->MarkTableLayoutCacheDirty();
                }
            }
        }

        break;
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CTableSection::EnterTree, CElement
//
//  Synopsis:   Add section to table.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CTableSection::EnterTree()
{
    HRESULT        hr = S_OK;
    CTable       * pTable = Table();
    CTableLayout * pTableLayout = pTable? pTable->TableLayoutCache() : NULL;

    // Only maintain the table layout cache incrementally until the table
    // has finished parsing.
    if (pTableLayout)
    {
        if (!pTableLayout->IsCompleted() || pTableLayout->_fTableOM)
        {
            hr = pTableLayout->AddSection(this);
        }
        else
        {
            pTableLayout->MarkTableLayoutCacheDirty();
        }
    }

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     ApplyDefaultFormat
//
//  Synopsis:   Applies default formatting properties for that element to
//              the char and para formats passed in
//
//  Arguments:  pCF - charformat to apply default properties on
//              pPF - paraformat to apply default properties on
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CTableSection::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    HRESULT hr;

    // clear back color, width/height, control blockalign coming from the table
    pCFI->_bCtrlBlockAlign = htmlBlockAlignNotSet;

    pCFI->PrepareFancyFormat();

    pCFI->_ff().ClearWidth();
    pCFI->_ff().ClearHeight();
    pCFI->_ff()._bPageBreaks = 0;

    pCFI->UnprepareForDebug();

    hr = super::ApplyDefaultFormat(pCFI);
    if (hr)
        goto Cleanup;

    if ( pCFI->_pff->_bPositionType != stylePositionNotSet )
    {
        pCFI->PrepareFancyFormat();
        pCFI->_ff()._bPositionType = stylePositionNotSet;
        pCFI->UnprepareForDebug();
    }

Cleanup:

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CTableSection::OnPropertyChange
//
//  Synopsis:   Process property changes to table row element.
//
//-------------------------------------------------------------------------

HRESULT
CTableSection::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr;
    CTable       * pTable = NULL;
    CTableLayout * pTableLayout = NULL;
    BOOL           fSpecialProperty = FALSE;
    BOOL           fPropagateChange = FALSE;

    hr = THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc));
    if (hr)
        goto Cleanup;

    pTable = Table();
    pTableLayout = pTable ? pTable->TableLayoutCache() : NULL;

    if (!pTableLayout)
        goto Cleanup;
    
    switch (dispid)
    {
    case DISPID_A_DISPLAY:
    // not supported on section: case DISPID_A_POSITION:
        pTableLayout->Resize();
        break;

    // If the backgroundcolor or image changes, let the affected table
    // cells know, so that they can update their display tree nodes.
    case DISPID_A_VISIBILITY:
    case DISPID_A_BACKGROUNDIMAGE:
    case DISPID_BACKCOLOR:
        fSpecialProperty = TRUE;
        fPropagateChange = TRUE;
        break;

    default:
        fPropagateChange = (dwFlags & (ELEMCHNG_REMEASUREINPARENT | ELEMCHNG_SIZECHANGED |
                                            ELEMCHNG_REMEASURECONTENTS | ELEMCHNG_REMEASUREALLCONTENTS));
        break;
    }

    if (fPropagateChange)
    {
        int            iRow;

        hr = pTableLayout->EnsureTableLayoutCache();
        if (hr)
            goto Cleanup;
        for (iRow = _iRow ; iRow < _iRow + _cRows ; iRow++)
        {
            CTableRow * pRow = pTableLayout->GetRow(iRow);
            Assert(pRow);

            hr = THR(pRow->PropagatePropertyChangeToCells(dispid, dwFlags, fSpecialProperty));
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CTableSection::destructor, CBase
//
//  Note:       The collection cache must be deleted in the destructor, and
//              not in Passivate, because collection objects we've handed out
//              (via get_rows) merely SubAddRef the table.
//-------------------------------------------------------------------------

CTableSection::~CTableSection()
{
    delete _pCollectionCache;
}

class CTableSectionRowsCollectionCacheItem : public CTableCollectionCacheItem
{
protected:
    CTableSection *_pSection;
public:
    DECLARE_MEMCLEAR_NEW_DELETE(Mt(BldSectionRowsCol))
    CTableSectionRowsCollectionCacheItem(CTableSection *pSection) 
    {
        _pSection = pSection; 
        CTable *pTable = pSection->Table();
        if (pTable)
        {
            _pTableLayout = pTable->TableLayoutCache(); 
        }
    }
    CElement *GetAt ( long lIndex );
    long Length ( void );
};


CElement *CTableSectionRowsCollectionCacheItem::GetAt ( long lIndex )
{
    Assert ( lIndex >= 0 );
    return (lIndex < _pSection->_cRows && _pTableLayout)? _pTableLayout->_aryRows[_pSection->_iRow + lIndex] : NULL;
}

long CTableSectionRowsCollectionCacheItem::Length ( void )
{
    return _pSection->_cRows;
}

//+------------------------------------------------------------------------
//
//  Member:     InvalidateCollections
//
//  Synopsis:   Invalidate the collection of the section and all
//              contained rows
//
//-------------------------------------------------------------------------

void CTableSection::InvalidateCollections(CTable *pTable)
{
    Assert(pTable);
    CTableLayout *pTableLayout = pTable->TableLayoutCache();

    if (_pCollectionCache)
        _pCollectionCache->Invalidate();    // this will reset collection version number

    for (int i = _iRow; i < _iRow + _cRows; i++)
    {
        pTableLayout->_aryRows[i]->InvalidateCollections();
    }
    return;
}

//+------------------------------------------------------------------------
//
//  Member:     EnsureCollectionCache
//
//  Synopsis:   Create the table's collection cache if needed.
//
//-------------------------------------------------------------------------

HRESULT
CTableSection::EnsureCollectionCache( long lIndex )
{
    HRESULT hr = S_OK;

    CTable *pTable = Table();
    if (pTable)
    {
        CTableLayout * pTableLayout = pTable->TableLayoutCache();
        Assert (pTableLayout);
        hr = pTableLayout->EnsureTableLayoutCache();
        if (hr)
            goto Cleanup;
    }

    if (!_pCollectionCache)
    {
        _pCollectionCache = new CCollectionCache(
                this,
                GetWindowedMarkupContext(),
                (PFN_CVOID_ENSURE)&CTableSection::EnsureCollections);
        if (!_pCollectionCache)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(_pCollectionCache->InitReservedCacheItems(1, 1));
        if (hr)
            goto Error;

        CTableSectionRowsCollectionCacheItem *pRowsCollection = new CTableSectionRowsCollectionCacheItem(this);
        if ( !pRowsCollection )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(_pCollectionCache->InitCacheItem ( ROWS_COLLECTION, pRowsCollection ));
        if (hr)
            goto Cleanup;

        //
        // Collection cache now owns this item & is responsible for freeing it
        //
   }

Cleanup:
    RRETURN(hr);

Error:
    delete _pCollectionCache;
    _pCollectionCache = NULL;
    goto Cleanup;
}


//+------------------------------------------------------------------------
//
//  Member:     EnsureCollections
//
//  Synopsis:   Refresh the table rows collection, if needed.
//
//-------------------------------------------------------------------------

HRESULT
CTableSection::EnsureCollections(long lIndex, long * plCollectionVersion)
{
    CTable *pTable = Table();
    CTableLayout *pTableLayout = pTable? pTable->TableLayoutCache() : NULL;
    HRESULT hr = S_OK;
    if ( pTableLayout)
    {
        hr = pTableLayout->EnsureTableLayoutCache();
        *plCollectionVersion = pTableLayout->_iCollectionVersion;   // to mark it done
    }
    RRETURN (hr);
}



const CTableCol::CLASSDESC CTableCol::s_classdesc =
{
    {
        &CLSID_HTMLTableCol,            // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_NOLAYOUT,           // _dwFlags
        &IID_IHTMLTableCol,             // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLTableCol       // _pfnTearOff
};


#ifdef NEVER_USED_CODE

//+---------------------------------------------------------------------------
//
//  Member:     CTableSection::GetCellFromRowCol
//
//  Synopsis:   Returns the cell located at table grid position (iRow,iCol)
//
//  Arguments:  iRow [in]         -- visual row index
//              iCol [in]         -- visual col index
//              ppTableCell [out] -- table cell at (iRow,iCol)
//
//  Returns:    Returns S_OK with pointer to table cell.  The pointer will
//              be NULL when the cell at the specified position doesn't exist
//              or is a non-real cell part of another cell's row- or columnspan.
//
//  Note:       The rows and column indices are relative to the section
//              origin (section-top, section-left).
//
//----------------------------------------------------------------------------

HRESULT
CTableSection::GetCellFromRowCol(int iRow, int iCol, CTableCell **ppTableCell)
{
    CTableRow * pTableRow;
    CTableCell *pTableCell;
    HRESULT     hr = S_OK;
    CTableLayout * pTableLayout = Table() ? Table()->TableLayoutCache() : NULL;

    if (!ppTableCell)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppTableCell = NULL;

    if (!pTableLayout)
        goto Cleanup;

    hr = pTableLayout->EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    if (iRow < 0 || iRow >= _cRows || iCol < 0 || iCol >= pTableLayout->GetCols())
        goto Cleanup;

    // Obtain row from iRow.
    iRow = iRow + _iRow;
    Assert(iRow >= 0 && iRow < pTableLayout->GetRows());
    pTableRow = pTableLayout->_aryRows[iRow];
    Assert(pTableRow && !"NULL row in legal range");

    // Obtain col from iCol.
    Assert(pTableRow->RowLayoutCache() && "Row without CTableRowLayout");
    pTableCell = pTableRow->RowLayoutCache()->_aryCells[iCol];

    if (IsReal(pTableCell))
        *ppTableCell = pTableCell;

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CTableSection::GetCellsFromRowColRange
//
//  Synopsis:   Returns an array of the cells located in the inclusive range
//              spanned by (iRowTop,iColLeft)-(iRowBottom,iColRight)
//
//  Arguments:  iRowTop    [in]     -- visual top row index
//              iColLeft   [in]     -- visual left col index
//              iRowBottom [in]     -- visual row index
//              iColRight  [in]     -- visual col index
//              paryCells  [in,out] -- array of table cells in range (allocated
//                                     by caller)
//
//  Returns:    Returns S_OK with array of table cells.
//
//  Note:       The rows and column indices are relative to the section
//              origin (section-top, section-left).
//
//----------------------------------------------------------------------------

HRESULT
CTableSection::GetCellsFromRowColRange(int iRowTop, int iColLeft, int iRowBottom, int iColRight, CPtrAry<CTableCell *> *paryCells)
{
    CTableRow *    pTableRow;
    CTableCell *   pTableCell;
    HRESULT        hr;
    CTableLayout * pTableLayout = Table() ? Table()->TableLayoutCache() : NULL;
    int            cRows, iRow, iCol;

    if (!pTableLayout)
        goto Cleanup;

    hr = pTableLayout->EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    iRowTop = max(0, iRowTop);
    iRowBottom = min(pTableLayout->GetCols()-1, iRowBottom);
    iColLeft = max(0, iColLeft);
    iColRight = min(_cRows-1, iColRight);
    cRows = iRowBottom - iRowTop + 1;

    if (!paryCells || cRows <= 0 || iColLeft > iColRight)
    {
        hr = paryCells ? S_OK : E_POINTER;
        goto Cleanup;
    }

    // Loop from top row to bottom row.
    for (iRow = iRowTop + _iRow ; cRows ; cRows--, iRow++)
    {
        pTableRow = pTableLayout->_aryRows[iRow];
        Assert(pTableRow && !"NULL row in legal range");

        // Loop from left col to right col.
        for (iCol = iColLeft ; iCol <= iColRight ; iCol++)
        {
            Assert(pTableRow->RowLayoutCache() && "Row without CTableRowLayout");
            pTableCell = pTableRow->RowLayoutCache()->_aryCells[iCol];
            if (IsReal(pTableCell))
            {
                // Add cell to array.
                paryCells->Append(pTableCell);
            }
        }
    }

Cleanup:
    RRETURN(hr);
}
#endif



HRESULT
CTableCol::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(pht->Is(ETAG_COLGROUP) || pht->Is(ETAG_COL));
    Assert(ppElement);
    *ppElement = new CTableCol(pht->GetTag(), pDoc);
    return *ppElement ? S_OK : E_OUTOFMEMORY;
}

//+------------------------------------------------------------------------
//
//  Member:     CTableCol::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CTableCol::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_HTML_TEAROFF(this, IHTMLTableCol2, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CTableCol::EnterTree, CElement
//
//  Synopsis:   Add col/colgroup to table.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CTableCol::EnterTree()
{
    CTable       * pTable = Table();
    CTableLayout * pTableLayout = pTable? pTable->TableLayoutCache() : NULL;
    HRESULT hr = S_OK;
    
    if(pTableLayout)
    {
        // Only maintain the table layout cache incrementally until the table
        // has finished parsing.
        if (pTableLayout->IsCompleted())
        {
            pTableLayout->MarkTableLayoutCacheDirty();
        }
        else
        {
            hr = ( Tag() == ETAG_COLGROUP ) ?
                THR(pTableLayout->AddColGroup(this)) :
                THR(pTableLayout->AddCol(this));
        }
    }

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CTableCol::ComputeFormatsVirtual
//
//  Synopsis:   Compute Char and Para formats induced by this element and
//              every other element above it in the HTML tree.
//
//  Arguments:  pCFI - Format Info needed for cascading
//
//  Returns:    HRESULT
//
//  Note:       We override this here to put our defaults into the format
//              FIRST, and also to cache vertical alignment here in the object
//
//-------------------------------------------------------------------------

HRESULT
CTableCol::ComputeFormatsVirtual(CFormatInfo * pCFI, CTreeNode * pNodeTarget)
{
    SwitchesBegTimer(SWITCHES_TIMER_COMPUTEFORMATS);

    HRESULT hr;

    Assert(pNodeTarget && SameScope(this, pNodeTarget));

    //check column left

    // iCol is -1 if col is not in markup, and 0 if it is the first, ...
    if (_iCol >= 0)
    {
        CTable * pTable = Table();

        if (!pTable)
            goto DontStealFormat;

        // Note:  We are not doing a pTableLayout->EnsureTableLayoutCache()
        // even though the current version might be dirty (can happen in
        // databinding).  In those cases we WANT to work with the old version
        // in case elements would disappear on us.

        CTableLayout * pTableLayout = pTable->TableLayoutCache();

        WHEN_DBG( BOOL fDisableTLCAssert = pTableLayout->_fDisableTLCAssert; pTableLayout->_fDisableTLCAssert = TRUE; )
        CTableCol * pCol = pTableLayout->GetCol(_iCol - 1);
        WHEN_DBG( pTableLayout->_fDisableTLCAssert = fDisableTLCAssert; )

        CTreeNode * pNodeCol = pCol ? pCol->GetFirstBranch() : NULL;

        //
        // See comment in CTableRow::ComputeFormats
        //

        if (pCol && pNodeCol && pNodeCol->_iPF >= 0 && pNodeCol->_iCF >= 0 && pNodeCol->_iFF >= 0 &&
            pCol->_fStealingAllowed &&
            SameScope(pNodeTarget->Parent(), pNodeCol->Parent()) &&
            (_pAA == NULL && pCol->_pAA == NULL ||
             _pAA != NULL && pCol->_pAA != NULL && _pAA->Compare(pCol->_pAA)) )
        {
            THREADSTATE * pts = GetThreadState();

            // At least one of the caches is dirty.
            Assert(pNodeTarget->_iPF == -1 || pNodeTarget->_iCF == -1 || pNodeTarget->_iFF == -1);

            // The caches that were not dirty, have to match with the corresponding caches of
            // the previous column.
            Assert(pNodeTarget->_iPF == -1 || pNodeTarget->_iPF == pNodeCol->_iPF);
            Assert(pNodeTarget->_iCF == -1 || pNodeTarget->_iCF == pNodeCol->_iCF);
            Assert(pNodeTarget->_iFF == -1 || pNodeTarget->_iFF == pNodeCol->_iFF);

            //
            // Selectively copy down each of the dirty caches.
            //

            if (pNodeTarget->_iPF == -1)
            {
                pNodeTarget->_iPF = pNodeCol->_iPF;
                (pts->_pParaFormatCache)->AddRefData( pNodeCol->_iPF );
                MtAdd(Mt(ParaFormatSteal), 1, 0);
            }

            if (pNodeTarget->_iCF == -1)
            {
                pNodeTarget->_iCF = pNodeCol->_iCF;
                (pts->_pCharFormatCache)->AddRefData( pNodeCol->_iCF );
                MtAdd(Mt(CharFormatSteal), 1, 0);
            }

            if (pNodeTarget->_iFF == -1)
            {
                pNodeTarget->_iFF = pNodeCol->_iFF;
                (pts->_pFancyFormatCache)->AddRefData( pNodeCol->_iFF );
                MtAdd(Mt(FancyFormatSteal), 1, 0);
            }

            // Set the _fBlockNess cache bit on the node to save a little time later.
            // Need to do this here because we don't call super.
            pNodeTarget->_fBlockNess = TRUE;

            hr = S_OK;
            goto Cleanup;
        }
    }

DontStealFormat:

    hr = THR(super::ComputeFormatsVirtual(pCFI, pNodeTarget));

Cleanup:

    SwitchesEndTimer(SWITCHES_TIMER_COMPUTEFORMATS);

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     ApplyDefaultFormat
//
//  Synopsis:   Applies default formatting properties for that element to
//              the char and para formats passed in
//
//  Arguments:  pCF - charformat to apply default properties on
//              pPF - paraformat to apply default properties on
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CTableCol::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    HRESULT hr;

    // clear back color, width/height and alignment coming from the table

    if (Tag() == ETAG_COLGROUP)
    {
        pCFI->PrepareFancyFormat();
        pCFI->_ff().ClearWidth();
        pCFI->_ff().ClearHeight();
        pCFI->_ff()._bPageBreaks = 0;
        pCFI->UnprepareForDebug();

        pCFI->_bBlockAlign     = htmlBlockAlignNotSet;
        pCFI->_bCtrlBlockAlign = htmlBlockAlignNotSet;
    }

    hr = super::ApplyDefaultFormat(pCFI);
    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     EnsureCols
//
//  Synopsis:   Make sure the table column count includes this column
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CTableCol::EnsureCols()
{
    CTableLayout * pTableLayout = Table() ? Table()->TableLayoutCache() : NULL;
    HRESULT hr = S_OK;
    int c;

    if (pTableLayout)
    {
        hr = pTableLayout->EnsureTableLayoutCache();
        if (hr)
            goto Cleanup;

        c = pTableLayout->GetCols();
        Assert (_iCol + Cols() <= c);
    }

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CTableColCalc::AdjustMaxToUserWidth
//
//  Synopsis:   Adjust max width to user set width when appropriate
//
//-------------------------------------------------------------------------

void
CTableColCalc::AdjustMaxToUserWidth(CCalcInfo * pci, CTableLayout * pTableLayout)
{
    if (IsWidthSpecified() && !IsWidthSpecifiedInPercent())
    {
        _xMax = GetPixelWidth(pci, pTableLayout->ElementOwner(), 2 * pTableLayout->CellPaddingX());
    }
    if (_xMax < _xMin)
    {
        _xMax = _xMin;
    }
}

HRESULT
CTableCol::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT        hr = S_OK;
    CTable       * pTable = Table();
    CTableLayout * pTableLayout = pTable? pTable->TableLayoutCache() : NULL;
    CTableCell   * pCell;
    CTableRow    * pRow;
    int            i, iLast, cR, iRow;
    BOOL           fDirtyCache;

    hr = THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc));
    if(hr || !pTableLayout)
        goto Cleanup;


    hr = pTableLayout->EnsureTableLayoutCache();
    if (hr)
        goto Cleanup;

    iLast = _iCol + _cCols;
    
    fDirtyCache = FALSE;

    // walk all the cells of this column and mark them dirty/clear caches
    for (cR = pTableLayout->GetRows(), iRow = pTableLayout->GetFirstRow();
        cR > 0;
        cR--, iRow = pTableLayout->GetNextRow(iRow))
    {
        pRow = pTableLayout->_aryRows[iRow];
        if ( pRow == NULL )
            continue;
        for (i = _iCol; i < iLast; i++)
        {
            pCell = Cell(pRow->RowLayoutCache()->GetCell(i));
            if ( pCell == NULL )
                continue;

            //TODO: add ppropdesc param to onpropertychange after making sure that dispid is not SPAN (or making adjustments)
            hr = THR( pCell->OnPropertyChange(dispid, dwFlags) );       // NOTE: this can make current layout cache dirty
            if (hr)
                goto Cleanup;
            if (!pTableLayout->IsTableLayoutCacheCurrent())
            {
                fDirtyCache = TRUE;
                pTableLayout->MarkTableLayoutCacheCurrent();
            }
        }
    }

    if (fDirtyCache)
        pTableLayout->MarkTableLayoutCacheDirty();

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CTableCol::Notify, CSite
//
//  Synopsis:   Handle notification
//
//----------------------------------------------------------------------------

void
CTableCol::Notify(CNotification *pNF)
{
    DWORD dw = pNF->DataAsDWORD();

    super::Notify(pNF);
    switch (pNF->Type())
    {
    case NTYPE_ELEMENT_ENTERTREE:
        if (Table())
        {
            EnterTree();
        }
        break;

    case NTYPE_ELEMENT_EXITTREE_1:
        if (!(dw & EXITTREE_DESTROY))
        {
            CTable          *pTable = Table();
            CTableLayout    *pTableLayout = pTable? pTable->TableLayoutCache() : NULL;

            if (!pTableLayout)
                break;

            // if column / colgroup leaves the tree because of other reasons than markup destroying 
            // need to update TableLayoutCache to prevent accessing out-of-date data 
            // (CTableCell::ComputeFormatsVirutal is one such a place)
            pTableLayout->Fixup();
        }
        break;
    }

    return;
}


//+---------------------------------------------------------------------------
//
//  Member:     CTableRow::Notify, CSite
//
//  Synopsis:   Handle notification
//
//----------------------------------------------------------------------------

void
CTableRow::Notify(CNotification *pNF)
{
    DWORD           dw = pNF->DataAsDWORD();

    super::Notify(pNF);
    switch (pNF->Type())
    {
    case NTYPE_ELEMENT_ENTERTREE:
        {
            CTable          *pTable = Table();
            CTableLayout    *pTableLayout = pTable? pTable->TableLayoutCache() : NULL;
            RowLayoutCache();
            _iRow = -1;

            if (!(dw & ENTERTREE_PARSE) && !(dw & ENTERTREE_MOVE))  // if the element cretead NOT via PARSing nor MOVing HTML
            {
                _fCompleted = TRUE; // we are not going to have NTYPE_END_PARSE notification to set the _fCompleted bit
            }
            if (pTableLayout)
            {
                if (!(dw & ENTERTREE_PARSE))
                {
                    pTableLayout->_fDontSaveHistory = TRUE;
                }
                if (dw & ENTERTREE_MOVE)   // if it is a MOVTREE notification
                {
                    // the subtree was moved
                    if (pTableLayout->_fPastingRows)
                    {
                        Assert (pTable->IsDatabound() && pTableLayout->IsRepeating());
                        pTableLayout->AddRow(this, FALSE);
                    }
                    else
                    {
                        pTableLayout->MarkTableLayoutCacheDirty();
                    }
                }
                else
                {
                    EnterTree();
                }
            }
            break;
        }

    case NTYPE_ELEMENT_EXITTREE_1:
        if (!(dw & EXITTREE_DESTROY))
        {
            CTable          *pTable = Table();
            CTableLayout    *pTableLayout = pTable? pTable->TableLayoutCache() : NULL;

            if (!pTableLayout)
                break;

            // don't update the rows caches for individual rows in case of :1) shutdown; 2) data-binding removing rows
            // But, don't hold refs to the tree after our element leaves it
            if (    !pTableLayout->_fRemovingRows 
                &&  !GetMarkup()->_fTemplate 
                &&  (   !pTable->_fExittreePending 
                    //  (bug # 2623) row caches should be updated when leaving windowed markup. 
                    //  In situation when something holds a reference to the row and use the reference 
                    //  after table is destroyed this row may return pointer to "dead" cells thru non-updated 
                    //  caches. 
                    ||  GetMarkup()->IsConnectedToPrimaryMarkup())   )
            {
                ExitTree(pTableLayout);
            }
        }

        break;

    case NTYPE_END_PARSE:
        {
            CTable          *pTable = Table();
            CTableLayout    *pTableLayout = pTable? pTable->TableLayoutCache() : NULL;

            Assert (!_fCompleted && "NTYPE_END_PARSE notification happened more then once");

            _fCompleted = TRUE;     // loading/parsing of the row is complete.

            if (pTableLayout && pTableLayout->_fAllRowsSameShape && pTableLayout->_cCols != pTableLayout->_cTotalColSpan)
            {
                pTableLayout->_fAllRowsSameShape = FALSE;
            }
        }
        break;
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CTableRow::EnterTree, CElement
//
//  Synopsis:   Add row to table.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CTableRow::EnterTree()
{
    HRESULT hr = S_OK;

    CTable       * pTable = Table();
    CTableLayout * pTableLayout = pTable ? pTable->TableLayoutCache() : NULL;

    if (pTableLayout)
    {
        // Only maintain the table layout cache incrementally until the table
        // has finished parsing.
        if (pTableLayout->IsCompleted() && !pTableLayout->_fTableOM)
        {
            pTableLayout->MarkTableLayoutCacheDirty();
        }
        else
        {
            pTableLayout->_cRowsParsed++;
            hr = pTableLayout->AddRow(this);
            if (hr)
                goto Cleanup;
        }
    }
Cleanup:
    RRETURN(hr);
}


void
CTableRow::ExitTree(CTableLayout *pTableLayout)
{
    CTableRowLayout *pRowLayout = RowLayoutCache();
    
    Assert (pRowLayout);

    // 1. clear row layout cache, this also invalidates the collection
    pRowLayout->ClearRowLayoutCache();
    
    // 2. delete from the array of rows and update table caches accordingly
    pTableLayout->RowExitTree(_iRow, Section());

    _iRow = -1;
}


// TableRow needs to expose client* properties, but it doesn't
// inherit from IHTMLControlElement.  Since interfaces are
// immutable, to fix 60731 we add a new interface IHTMLTableRowMetrics
// to expose the client* properties.

//+----------------------------------------------------------
//
//  member  :   get_clientWidth, IHTMLTableRowMetrics
//
//  synopsis    :   returns a long value of the client window
//      width (not counting scrollbar, borders..)
//
//-----------------------------------------------------------

HRESULT
CTableRow::get_clientWidth( long * pl)
{
    HRESULT hr=S_OK;
    RECT    rect;

    if (!pl)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    RowLayoutCache()->GetClientRect(&rect, CLIENTRECT_CONTENT);

    *pl = g_uiDisplay.DocPixelsFromDeviceX(rect.right - rect.left);

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------
//
//  member  :   get_clientHeight, IHTMLTableRowMetrics
//
//  synopsis    :   returns a long value of the client window
//      Height of the body
//
//-----------------------------------------------------------

HRESULT
CTableRow::get_clientHeight( long * pl)
{
    HRESULT hr=S_OK;
    RECT    rect;

    if (!pl)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    RowLayoutCache()->GetClientRect(&rect, CLIENTRECT_CONTENT);

    *pl = g_uiDisplay.DocPixelsFromDeviceY(rect.bottom - rect.top);

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}

//+----------------------------------------------------------
//
//  member  :   get_clientTop, IHTMLTableRowMetrics
//
//  synopsis    :   TableRows can't have borders (in 4.x), so
//      just return 0.  This needs to exist so that scripts
//      can walk up the offsetParent chain from inside tables
//      and sum clientTops + offsetTops.
//
//-----------------------------------------------------------

HRESULT
CTableRow::get_clientTop( long * pl)
{
    HRESULT hr=S_OK;

    if (!pl)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pl = 0;

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+----------------------------------------------------------
//
//  member  :   get_clientLeft, IHTMLTableRowMetrics
//
//  synopsis    :   TableRows can't have borders (in 4.x), so
//      just return 0.  This needs to exist so that scripts
//      can walk up the offsetParent chain from inside tables
//      and sum clientTops + offsetTops.
//
//-----------------------------------------------------------

HRESULT
CTableRow::get_clientLeft( long * pl)
{
    HRESULT hr=S_OK;

    if (!pl)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pl = 0;

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\dbind\binder.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1996-1996
//  All rights Reserved.
//  Information contained herein is Proprietary and Confidential.
//
//  Contents:   Data Source Binder objects
//
//  Classes:    CDataSourceBinder
//
//  History:    10/1/96     (sambent) created

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include <formkrnl.hxx>     // for safetylevel in safety.hxx (via olesite.hxx)
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include <olesite.hxx>
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_SIMPDATA_H_
#define X_SIMPDATA_H_
#include <simpdata.h>
#endif

#ifndef X_MSTDWRAP_H_
#define X_MSTDWRAP_H_
#include "mstdwrap.h"
#endif

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include "binder.hxx"
#endif

#ifndef X_DBTASK_HXX_
#define X_DBTASK_HXX_
#include "dbtask.hxx"
#endif

#ifndef X_ROWBIND_HXX_
#define X_ROWBIND_HXX_
#include "rowbind.hxx"
#endif

#ifndef X_DMEMBMGR_HXX_
#define X_DMEMBMGR_HXX_
#include "dmembmgr.hxx"       // for CDataMemberMgr
#endif

MtDefine(DataBind, Mem, "Data Binding")
MtDefine(CDataSourceBinder, DataBind, "CDataSourceBinder")
MtDefine(CCurrentRecordInstance, DataBind, "CCurrentRecordInstance")
MtDefine(CDataSourceProvider, DataBind, "CDataSourceProvider")
MtDefine(CDataSourceProvider_aryAdvisees_pv, CDataSourceProvider, "CDataSourceProvider::_aryAdvisees::_pv")

/////////////////////////////////////////////////////////////////////////////
/////                    CDataSourceBinder methods                      /////
/////////////////////////////////////////////////////////////////////////////


//+---------------------------------------------------------------------------
//
//  Member:     Passivate
//
//  Synopsis:   revert to pre-init state
//

HRESULT
CDataSourceBinder::Passivate()
{
    HRESULT hr;

    // During binding, we may trigger events that cause the binder to go away.
    // If so, simply set a flag and do the real shutdown later (see TryToBind).
    // An example of this situation (which only Neetu would ever dream of):
    // I'm the first element trying to bind to provider foo, doing so triggers
    // foo.ondatasetcomplete, the handler changes dataFld on my element.
    if (_fBinding)
    {
        _fAbort = TRUE;
        hr = S_OK;
        goto Cleanup;
    }

    if (_fOnTaskList)
    {
        CDataBindTask *pdbt = GetDataBindTask();
        if (pdbt)
        {
            pdbt->RemoveDeferredBinding(this);
        }
    }

    hr = UnBind();

    ClearInterface(&_pConsumer);

    delete this;

Cleanup:
    return hr;
}


#if DBG==1
//+---------------------------------------------------------------------------
//
//  Member:     Destructor
//
//  Synopsis:   go away
//

CDataSourceBinder::~CDataSourceBinder()
{
    Assert("Passivate must be called first" &&
        !_pConsumer && !_pProvider
        );
}
#endif


//+---------------------------------------------------------------------------
//
//  Member:     GetDataBindTask
//
//  Synopsis:   return the task that owns me

CDataBindTask *
CDataSourceBinder::GetDataBindTask()
{
    CMarkup *pMarkup = _pelConsumer->GetMarkup();
    
    return pMarkup ? pMarkup->GetDataBindTask() : NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     SetReady
//
//  Synopsis:   set the "readiness" of the binder.  If it becomes ready, notify
//              the task that it's worth trying to bind.

void
CDataSourceBinder::SetReady(BOOL fReady)
{
    _fNotReady = !fReady;
    if (fReady && _fOnTaskList)
    {
        GetDataBindTask()->SetWaiting();
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     Register
//
//  Synopsis:   register myself with the databinding task
//

HRESULT
CDataSourceBinder::Register(const DBSPEC *pdbs)
{
    Assert("consumer required" && _pelConsumer);
    Assert("consumer already set" && !_pConsumer);
    Assert("provider already set" && !_pProvider && !_cstrProviderName);

    BSTR bstrElement=NULL, bstrDataset=NULL;
    HRESULT hr = S_OK;
    CDataBindTask *pDBTask;

    _pDoc = _pelConsumer->Doc();
    Assert("consumer must belong to a CDoc" && _pDoc);

    // get provider info
    FormsSplitFirstComponent(pdbs->_pStrDataSrc, &bstrElement, &bstrDataset);
    hr = _cstrProviderName.Set(bstrElement);
    if (!hr)
        hr = _cstrDataMember.Set(bstrDataset);
    if (hr)
        goto Cleanup;

    // defer the actual binding
    pDBTask = GetDataBindTask();
    if (!pDBTask)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pDBTask->AddDeferredBinding(this);
    if (hr)
        goto Cleanup;

Cleanup:
    FormsFreeString(bstrElement);
    FormsFreeString(bstrDataset);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     TryToBind (called by CDataBindTask)
//
//  Synopsis:   try to bind to my provider
//

HRESULT
CDataSourceBinder::TryToBind()
{
    HRESULT hr = E_FAIL;
    CDataMemberMgr *pDataMemberManager;
    DBIND_KIND dbk;
    DBSPEC dbs;
    DWORD dwFilter;

    // The element's gotta want to bind.
    dbk = CDBindMethods::DBindKind(_pelConsumer, _idConsumer);
    if (dbk == DBIND_NONE)
        goto Cleanup;       // hr is E_FAIL

    if (S_OK != CDBindMethods::GetDBSpec(_pelConsumer, _idConsumer, &dbs,
                                   DBIND_SETFILTER|DBIND_CURRENTFILTER) )
        goto Cleanup;

    // The element's spec and its inherent binding preference must agree.
    dwFilter = (dbk == DBIND_SINGLEVALUE) ? DBIND_CURRENTFILTER : DBIND_SETFILTER;
    if (!dbs.FFilter(dwFilter, _pelConsumer->Tag()==ETAG_TABLE))
        goto Cleanup;

    // set the re-entrancy flag (see Passivate)
    _fBinding = TRUE;

    // set up consumer
    if (!_pConsumer)
    {
        hr = CConsumer::Create(this, &_pConsumer);
        if (hr)
            goto Cleanup;
    }

    Assert(_pConsumer);
    Assert(!_pProvider);

    // get the HTML element designated as the DataSrc
    if (!_pelProvider)
    {
        hr = THR_NOTRACE(FindProviderByName(&_pelProvider));
        if (hr)
            goto Cleanup;
    }

    // ask it for a CDataSourceProvider
    _pelProvider->EnsureDataMemberManager();
    pDataMemberManager = _pelProvider->GetDataMemberManager();
    if (pDataMemberManager)
    {
        hr = pDataMemberManager->GetDataSourceProvider(_cstrDataMember, &_pProvider);
    }
    else
    {
        hr = E_FAIL;
    }

    // if something went wrong, hook up the null provider
    if (hr)
    {
        hr = CDataSourceProvider::Create(NULL, _pDoc, _cstrDataMember, &_pProvider);  // null provider
        if (hr)
            goto Cleanup;
    }

    // getting the provider may cause me to die (see Passivate).
    // if so, carry out my death now.
    if (_fAbort)
        goto Cleanup;

    // do the actual binding
    Assert(_pProvider);
    _pProvider->AdviseDataProviderEvents(this);
    hr = Bind();

    // if it didn't work, don't hang on to the provider
    if (hr)
    {
        if (_pProvider)
        {
            _pProvider->UnadviseDataProviderEvents(this);
            _pProvider->Release();
            _pProvider = NULL;
        }
        _pelProvider = NULL;
    }

Cleanup:
    _fBinding = FALSE;

    if (_fAbort)
    {
        Passivate();        // calls "delete this", no work after here
        hr = S_OK;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     Bind (public - called SetProvider)
//
//  Synopsis:   hook up the consumer to the provider
//

HRESULT
CDataSourceBinder::Bind()
{
    HRESULT hr;

    Assert(_pConsumer);
    _pelConsumer->AddRef();         // keep consumer alive while binding

    hr = _pConsumer->Bind();
    if (hr == E_NOINTERFACE)        // this means we've bound to the null provider
        hr = S_OK;

    if (!hr && !_fAbort)
    {
        _pConsumer->FireOnDataReady(TRUE);
    }

    Verify(_pelConsumer->Release());

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     DetachBinding (public)
//
//  Synopsis:   detach the binding
//

HRESULT
CDataSourceBinder::DetachBinding()
{
    if (!_pDoc->TestLock(FORMLOCK_UNLOADING))
    {
        _dbop = BINDEROP_UNBIND;
        GetDataBindTask()->AddDeferredBinding(this);
    }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     UnBind (public)
//
//  Synopsis:   unhook the consumer from the provider
//

HRESULT
CDataSourceBinder::UnBind()
{
    HRESULT hr=S_OK;

    if (_pConsumer)
    {
        _pConsumer->FireOnDataReady(FALSE);
        hr = _pConsumer->UnBind();
        if (hr == E_NOINTERFACE)            // bound to null provider
            hr = S_OK;
    }

    if (_pProvider)
    {
        _pProvider->UnadviseDataProviderEvents(this);
        _pProvider->Release();
        _pProvider = NULL;
    }

    _pelProvider = NULL;

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     ReBind (public)
//
//  Synopsis:   rehook the consumer to the (possibly new) provider
//

HRESULT
CDataSourceBinder::ReBind()
{
    HRESULT hr;

    hr = UnBind();
    if (!hr)
    {
        hr = TryToBind();
    }

    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     EnsureDataEvents (public)
//
//  Synopsis:   make sure data events can fire for my "consumer"
//

HRESULT
CDataSourceBinder::EnsureDataEvents()
{
    HRESULT hr;
    CDataMemberMgr *pDataMemberManager;

    _pelConsumer->EnsureDataMemberManager();
    pDataMemberManager = _pelConsumer->GetDataMemberManager();

    if (pDataMemberManager)
    {
        hr = pDataMemberManager->IsReady();
        if (!hr)
        {
            // It's enough to simply ask for the provider and release it.
            // This creates it, and it will live on in the OleSite's cache.
            CDataSourceProvider *pProvider = NULL;
            IGNORE_HR(pDataMemberManager->GetDataSourceProvider(NULL, &pProvider));
            if (pProvider)
            {
                pProvider->Release();
            }
        }
    }
    else
    {
        hr = E_FAIL;
    }
    
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     FindProviderByName (private - called by SetProvider)
//
//  Synopsis:   find an element corresponding to _cstrProviderName
//

HRESULT
CDataSourceBinder::FindProviderByName(CElement **ppelProvider)
{
    HRESULT     hr;

    Assert(GetProviderName() != 0);
    Assert(ppelProvider);
    Assert(_pDoc);

    // DataSrc is supposed to be #<IDRef>
    if (*((LPTSTR)GetProviderName()) != _T('#'))
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    Assert(_pelConsumer->GetMarkup());

    // ask the Consumer for the named element, don't use the '#' in the name match.
    hr = THR_NOTRACE(_pelConsumer->GetMarkup()->GetElementByNameOrID((LPTSTR)GetProviderName() + 1,
                                                ppelProvider));

    // If the lookup failed then stop everything.  It returns S_FALSE if
    // more than one element with that name exists;  we'll use the first one.
    if (FAILED(hr))
    {
        hr = S_FALSE;
        goto Cleanup;
    }
    hr = S_OK;

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     SubstituteProvider (private, called by CConsumer) 
//
//  Synopsis:   substitute the new provider for the current one.  This should
//              only be called in the early stages of binding.  It's used by
//              hierarchically-bound tables, whose dataSrc gives a top-level
//              provider;  the real provider must be computed during binding
//              by examining the repeating context.
//

void
CDataSourceBinder::SubstituteProvider(CDataSourceProvider *pProviderNew)
{
    CDataSourceProvider *pProviderOld = _pProvider;

    _pProvider = pProviderNew;
    
    if (pProviderNew)
    {
        pProviderNew->AddRef();
        pProviderNew->AdviseDataProviderEvents(this);
    }
    
    if (pProviderOld)
    {
        pProviderOld->UnadviseDataProviderEvents(this);
        pProviderOld->Release();
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     ReplaceProvider (public, called by CDataSourceProvider) 
//
//  Synopsis:   cope with provider changing its interfaces
//

HRESULT
CDataSourceBinder::ReplaceProvider(CDataSourceProvider *pdspNewProvider)
{
    HRESULT hr = S_OK;

    if (!_pDoc->TestLock(FORMLOCK_UNLOADING))
    {
        _dbop = BINDEROP_REBIND;
        GetDataBindTask()->AddDeferredBinding(this);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\dbind\adosecur.h ===
#ifndef _ADOSECURITY_H_
#define _ADOSECURITY_H_

interface IADOSecurity: public IUnknown
    {
    public:
		virtual HRESULT STDMETHODCALLTYPE SetURL(BSTR bstrURL) = 0;
		virtual HRESULT STDMETHODCALLTYPE SetSafe(BOOL fSafe) = 0;
    };

// {782D16AE-905F-11d1-AC38-00C04FC29F8F}
DEFINE_GUID(IID_IADOSecurity, 0x782d16ae, 0x905f, 0x11d1, 0xac, 0x38, 0x0, 0xc0, 0x4f, 0xc2, 0x9f, 0x8f);

// {332c4425-26cb-11d0-b483-00c04fd90119}
DEFINE_GUID(IID_IHTMLDocument2, 0x332c4425, 0x26cb, 0x11d0, 0xb4, 0x83, 0x00, 0xc0, 0x4f, 0xd9, 0x01, 0x19);

// {79eac9ee-baf9-11ce-8c82-00aa004ba90b}
DEFINE_GUID(IID_IInternetSecurityManager, 0x79eac9ee, 0xbaf9, 0x11ce, 0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);

// {7b8a2d94-0ac9-11d1-896c-00c04Fb6bfc4}
DEFINE_GUID(CLSID_InternetSecurityManager, 0x7b8a2d94, 0x0ac9, 0x11d1, 0x89, 0x6c, 0x00, 0xc0, 0x4f, 0xb6, 0xbf, 0xc4);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\builtin\textarea.cxx ===
//+---------------------------------------------------------------------
//
//   File:      textarea.cxx
//
//  Contents:   <TEXTAREA> <HTMLAREA>
//
//  Classes:    CTextarea, CRichtext
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SIZE_HXX_
#define X_SIZE_HXX_
#include "size.hxx"
#endif

#ifndef X_RECT_HXX_
#define X_RECT_HXX_
#include "rect.hxx"
#endif

#ifndef X_CGUID_H_
#define X_CGUID_H_
#include <cguid.h>
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_POSTDATA_HXX_
#define X_POSTDATA_HXX_
#include "postdata.hxx"
#endif

#ifndef X_TEXTAREA_HXX_
#define X_TEXTAREA_HXX_
#include "textarea.hxx"
#endif

#ifndef X_TXTSITE_HXX_
#define X_TXTSITE_HXX_
#include "txtsite.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_BTNHLPER_HXX_
#define X_BTNHLPER_HXX_
#include "btnhlper.hxx"
#endif

#ifndef X_TAREALYT_HXX_
#define X_TAREALYT_HXX_
#include "tarealyt.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_EFORM_HXX_
#define X_EFORM_HXX_
#include "eform.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_PERHIST_HXX_
#define X_PERHIST_HXX_
#include "perhist.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X__TEXT_H_
#define X__TEXt_H_
#include "_text.h"
#endif

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include <treepos.hxx>
#endif

#ifndef X_IRANGE_HXX_
#define X_IRANGE_HXX_
#include "irange.hxx"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

EXTERN_C const GUID DIID_HTMLInputTextElementEvents;

#define _cxx_
#include "textarea.hdl"

MtDefine(CRichtext, Elements, "CRichtext")
MtDefine(CTextArea, Elements, "CTextArea")


CElement::ACCELS CRichtext::s_AccelsTextareaRun    = CElement::ACCELS (NULL, IDR_ACCELS_INPUTTXT_RUN);

//+------------------------------------------------------------------------
//
//  Member:     CElement::s_classdesc
//
//  Synopsis:   class descriptor
//
//-------------------------------------------------------------------------


const CElement::CLASSDESC CTextArea::s_classdesc =
{
    {
        &CLSID_HTMLTextAreaElement,     // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_TEXTSITE |
        ELEMENTDESC_DONTINHERITSTYLE |
        ELEMENTDESC_SHOWTWS |
        ELEMENTDESC_CANSCROLL |
        ELEMENTDESC_VPADDING |
        ELEMENTDESC_NOTIFYENDPARSE |
        ELEMENTDESC_NOANCESTORCLICK |
        ELEMENTDESC_HASDEFDESCENT,
        &IID_IHTMLTextAreaElement,      // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLTextAreaElement, // _pfnTearOff
    &s_AccelsTextareaRun                // _pAccelsRun
};

//+------------------------------------------------------------------------
//
//  Member:     CTextArea::CreateElement()
//
//  Synopsis:   called by the parser to create an instance
//
//-------------------------------------------------------------------------

HRESULT
CTextArea::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(ppElement);

    *ppElement = new CTextArea(pht->GetTag(), pDoc);

    RRETURN ( (*ppElement) ? S_OK : E_OUTOFMEMORY);
}

//+------------------------------------------------------------------------
//
//  Member:     CTextArea::Save
//
//  Synopsis:   Save the element to the stream
//
//-------------------------------------------------------------------------
HRESULT
CTextArea::Save(CStreamWriteBuff * pStmWrBuff, BOOL fEnd)
{
    HRESULT hr  = S_OK;

    Assert(!_fInSave);
    _fInSave = TRUE;

    if (!fEnd)
    {
        pStmWrBuff->BeginPre();
    }

    hr = super::Save(pStmWrBuff, fEnd);

    if(hr)
        goto Cleanup;

    if (    fEnd 
        &&  (   !pStmWrBuff->GetElementContext() 
             || GetFirstCp() >= pStmWrBuff->GetElementContext()->GetFirstCp() ) )
    {
        pStmWrBuff->EndPre();
    }

    Assert(_fInSave); // this will catch recursion
    _fInSave = FALSE;

Cleanup:
    RRETURN(hr);
}

DWORD
CTextArea::GetBorderInfo(
    CDocInfo *      pdci,
    CBorderInfo *   pborderinfo,
    BOOL            fAll,
    BOOL            fAllPhysical
    FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    HTHEME hTheme   = GetTheme(THEME_EDIT);

    if (!hTheme)
    {
        return super::GetBorderInfo(pdci, pborderinfo, fAll, fAllPhysical FCCOMMA FCPARAM);
    }
    else
    {
        RECT rcBg;

        THR(GetThemeBackgroundExtent(
                                            hTheme,
                                            NULL,
                                            EP_EDITTEXT,
                                            ETS_NORMAL,
                                            &g_Zero.rc,
                                            &rcBg
                                        ));

        pborderinfo->aiWidths[SIDE_LEFT]   = pdci->DeviceFromDocPixelsX(-rcBg.left);            
        pborderinfo->aiWidths[SIDE_RIGHT]  = pdci->DeviceFromDocPixelsX(rcBg.right);
        pborderinfo->aiWidths[SIDE_TOP]    = pdci->DeviceFromDocPixelsY(-rcBg.top);
        pborderinfo->aiWidths[SIDE_BOTTOM] = pdci->DeviceFromDocPixelsY(rcBg.bottom);

        return DISPNODEBORDER_SIMPLE;
    }

}

void
CTextArea::GetPlainTextWithBreaks(TCHAR * pchBuff)
{
    Assert(pchBuff);
    Assert(Layout()->GetMultiLine());

    Layout()->GetPlainTextWithBreaks( pchBuff );
}

long
CTextArea::GetPlainTextLengthWithBreaks()
{
    Assert(ShouldHaveLayout());
    Assert(Layout()->GetMultiLine());

    return Layout()->GetPlainTextLengthWithBreaks();
}

//+------------------------------------------------------------------------
//
//  Member:     CTextArea::GetSubmitValue()
//
//  Synopsis:   returns the inner HTML
//
//-------------------------------------------------------------------------

HRESULT
CTextArea::GetSubmitValue(CStr *pstr)
{
    HRESULT hr          = S_OK;

    // Make sure the site is not detached. Otherwise, we
    // cannot get to the runs
    if (!IsInMarkup())
        goto Cleanup;

    if (GetAAwrap() == htmlWrapHard)
    {
        long len = GetPlainTextLengthWithBreaks();
        if (len > 1)
        {
            IGNORE_HR(pstr->SetLengthNoAlloc(0));
            hr = THR(pstr->ReAlloc(len));
            if (hr)
                goto Cleanup;
            GetPlainTextWithBreaks(*pstr);
        }
        else
        {
            hr = THR(GetValueHelper(pstr));
        }
    }
    else
    {
        hr = THR(GetValueHelper(pstr));
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CTextArea::ApplyDefaultFormat()
//
//  Synopsis:
//
//-------------------------------------------------------------------------

HRESULT
CTextArea::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    BYTE i;
    CDoc *              pDoc     = Doc();
    CODEPAGESETTINGS *  pCS      = GetMarkup()->GetCodepageSettings();
    HTHEME              hTheme   = GetMarkup()->GetTheme(THEME_EDIT);
    CUnitValue          uv;

    if (!pCS)
        pCS = pDoc->PrimaryMarkup()->GetCodepageSettings();

    COLORREF            crWindow = GetSysColorQuick(COLOR_WINDOW);
    HRESULT             hr       = S_OK;

    pCFI->PrepareFancyFormat();

    if (   !pCFI->_pff->_ccvBackColor.IsDefined()
        ||  pCFI->_pff->_ccvBackColor.GetColorRef() != crWindow)
    {
        pCFI->_ff()._ccvBackColor = crWindow;
    }

    pCFI->PrepareCharFormat();
    pCFI->PrepareParaFormat();

    pCFI->_cf()._ccvTextColor.SetSysColor(COLOR_WINDOWTEXT);

    // our intrinsics shouldn't inherit the cursor property. they have a 'default'
    pCFI->_cf()._bCursorIdx = styleCursorAuto;

    pCFI->_cf()._fBold = FALSE;

    pCFI->_cf()._wWeight = FW_NORMAL; //FW_NORMAL = 400
    pCFI->_cf()._yHeight = 200;       // 10 * 20, 10 points
    
    // Thai does not have a fixed pitch font. Leave it as proportional
    if (GetMarkup()->GetCodePage() != CP_THAI)
    {
        pCFI->_cf()._bPitchAndFamily = FIXED_PITCH;
        pCFI->_cf().SetFaceNameAtom(pCS->latmFixedFontFace);
        if (pCFI->_cf().NeedAtFont())
        {
            ApplyAtFontFace(&pCFI->_cf(), Doc(), GetMarkup());
        }
    }

    pCFI->_cf()._bCharSet = pCS->bCharSet;
    pCFI->_cf()._fNarrow = IsNarrowCharSet(pCFI->_cf()._bCharSet);
    pCFI->_pf()._cuvTextIndent.SetPoints(0);
    pCFI->_fPre = TRUE;

    //
    // Prepare fancy format
    //

    // No vertical spacing between para's
    pCFI->_ff()._cuvSpaceBefore.SetPoints(0);
    pCFI->_ff()._cuvSpaceAfter.SetPoints(0);

    // Border info
    pCFI->_ff()._bd._ccvBorderColorLight.SetSysColor(COLOR_3DLIGHT);
    pCFI->_ff()._bd._ccvBorderColorDark.SetSysColor(COLOR_3DDKSHADOW);
    pCFI->_ff()._bd._ccvBorderColorHilight.SetSysColor(COLOR_BTNHIGHLIGHT);
    pCFI->_ff()._bd._ccvBorderColorShadow.SetSysColor(COLOR_BTNSHADOW);

    uv.SetValue(2, CUnitValue::UNIT_PIXELS);
    for (i = 0; i < SIDE_MAX; i++)
    {
        pCFI->_ff()._bd.SetBorderWidth(i, uv);
        pCFI->_ff()._bd.SetBorderStyle(i, fmBorderStyleSunken);
    }
    // End Border info

    //
    // Add default padding and scrolling
    //
    
    uv.SetValue(TEXT_INSET_DEFAULT_LEFT, CUnitValue::UNIT_PIXELS);

    Assert(TEXT_INSET_DEFAULT_LEFT == TEXT_INSET_DEFAULT_RIGHT);
    Assert(TEXT_INSET_DEFAULT_LEFT == TEXT_INSET_DEFAULT_TOP);
    Assert(TEXT_INSET_DEFAULT_LEFT == TEXT_INSET_DEFAULT_BOTTOM);

    for (i = 0; i < SIDE_MAX; i++)
    {
        pCFI->_ff().SetPadding(i, uv);
    }

    pCFI->UnprepareForDebug();

    hr = THR(super::ApplyDefaultFormat(pCFI));
    if(hr)
        goto Cleanup;

    pCFI->PrepareFancyFormat();
    pCFI->PrepareCharFormat();

    // In the if statement logical/physical does not matter since we check both
    if (hTheme && !pCFI->_ff().IsThemeDisabled()) // the control is themed
    {
        RECT                rcBg;        
        // set theme defaults for properties not already set

        if (!THR(GetThemeBackgroundExtent(hTheme, NULL, EP_EDITTEXT, ETS_NORMAL, &g_Zero.rc, &rcBg)))
        {    
            if (!pCFI->_fPaddingLeftSet)
            {
                uv.SetValue( -rcBg.left + TEXT_INSET_DEFAULT_LEFT, CUnitValue::UNIT_PIXELS);            
                pCFI->_ff().SetPadding(SIDE_LEFT, uv);
            }
            if (!pCFI->_fPaddingRightSet)
            {
                uv.SetValue( rcBg.right + TEXT_INSET_DEFAULT_RIGHT, CUnitValue::UNIT_PIXELS);            
                pCFI->_ff().SetPadding(SIDE_RIGHT, uv);
            }
            if (!pCFI->_fPaddingTopSet)
            {
                uv.SetValue( -rcBg.top + TEXT_INSET_DEFAULT_TOP, CUnitValue::UNIT_PIXELS);            
                pCFI->_ff().SetPadding(SIDE_TOP, uv);
            }
            if (!pCFI->_fPaddingBottomSet)
            {
                uv.SetValue( rcBg.bottom + TEXT_INSET_DEFAULT_BOTTOM, CUnitValue::UNIT_PIXELS);            
                pCFI->_ff().SetPadding(SIDE_BOTTOM, uv);
            }
        }                   

        LOGFONT lf;

        if (!pCFI->_fFontSet && !GetThemeFont(hTheme, NULL, EP_EDITTEXT, ETS_NORMAL, TMT_FONT, &lf))
        {
            long    twips;            
            
            if (!pCFI->_fFontWeightSet)
                pCFI->_cf()._wWeight = lf.lfWeight;

            if (!pCFI->_fFontHeightSet)
            {
                twips = MulDivQuick(lf.lfHeight,TWIPS_PER_INCH,g_sizePixelsPerInch.cy);

                if(twips < 0)
                    twips = - twips;

                pCFI->_cf().SetHeightInTwips( twips );
            }
        }
    }

    if (    pCFI->_pff->GetOverflowX() == (BYTE)styleOverflowNotSet
        ||  pCFI->_pff->GetOverflowY() == (BYTE)styleOverflowNotSet)
    {
        BOOL fVerticalLayoutFlow = pCFI->_pcf->HasVerticalLayoutFlow();
        BOOL fWritingModeUsed = pCFI->_pcf->_fWritingModeUsed;


        if (pCFI->_pff->GetLogicalOverflowX(fVerticalLayoutFlow, fWritingModeUsed) == (BYTE)styleOverflowNotSet)
        {
            styleOverflow overflow = GetAAwrap() != htmlWrapOff
                                    ? styleOverflowHidden
                                    : styleOverflowScroll;
            if (!fVerticalLayoutFlow)
            {
                pCFI->_ff().SetOverflowX(overflow);
            }
            else
            {
                pCFI->_ff().SetOverflowY(overflow);
            }
        }

        if (pCFI->_pff->GetLogicalOverflowY(fVerticalLayoutFlow, fWritingModeUsed) == (BYTE)styleOverflowNotSet)
        {
            if (!fVerticalLayoutFlow)
            {
                pCFI->_ff().SetOverflowY(styleOverflowScroll);
            }
            else
            {
                pCFI->_ff().SetOverflowX(styleOverflowScroll);
            }
        }
    }

    // font height in CharFormat is already nonscaling size in twips
    pCFI->_cf().SetHeightInNonscalingTwips( pCFI->_cf()._yHeight );

    pCFI->UnprepareForDebug();

    FixupEditable(pCFI);

Cleanup:
    RRETURN(hr);
}

// Richtext member functions

const CElement::CLASSDESC CRichtext::s_classdesc =
{
    {
        &CLSID_HTMLRichtextElement,      // _pclsid
        0,                               // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                  // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                          // _pcpi
        ELEMENTDESC_TEXTSITE          |
        ELEMENTDESC_SHOWTWS           |
        ELEMENTDESC_ANCHOROUT         |
        ELEMENTDESC_NOBKGRDRECALC     |
        ELEMENTDESC_CANSCROLL         |
        ELEMENTDESC_HASDEFDESCENT     |
        ELEMENTDESC_NOTIFYENDPARSE,      // _dwFlags
        &IID_IHTMLTextAreaElement,       // _piidDispinterface
        &s_apHdlDescs,                   // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLTextAreaElement, // _pfnTearOff
    &s_AccelsTextareaRun        // _pAccelsRun
};

//+------------------------------------------------------------------------
//
//  Member:     CRichtext::CreateElement()
//
//  Synopsis:   called by the parser to create instance
//
//-------------------------------------------------------------------------

HRESULT
CRichtext::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(ppElement);

    *ppElement = new CRichtext(pht->GetTag(), pDoc);

    RRETURN ( (*ppElement) ? S_OK : E_OUTOFMEMORY);
}



//+------------------------------------------------------------------------
//
//  Member:     CRichtext::Init2()
//
//  Synopsis:   called by the parser to initialize instance
//
//-------------------------------------------------------------------------

HRESULT
CRichtext::Init2(CInit2Context * pContext)
{
    HRESULT hr = S_OK;

    hr = THR(super::Init2(pContext));
    if (!OK(hr))
        goto Cleanup;

#ifdef  NEVER
    if (Tag() == ETAG_HTMLAREA)
    {
        SetAAtype(htmlInputRichtext);
    }
    else
#endif
    {
        Assert(Tag() == ETAG_TEXTAREA);
        SetAAtype(htmlInputTextarea);
    }

    _fReadOnly = !!GetAAreadOnly();

Cleanup:
    RRETURN1(hr, S_INCOMPLETE);
}


//+------------------------------------------------------------------------
//
//  Member:     CRichtext::EnterTree
//
//-------------------------------------------------------------------------

HRESULT
CRichtext::EnterTree()
{
    HRESULT                    hr = S_OK;
    CMarkup *             pMarkup = GetMarkup(); Assert(pMarkup);
    CMarkupTransNavContext * ptnc = pMarkup->EnsureTransNavContext();

    if (!ptnc)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    _iHistoryIndex  = (unsigned short)ptnc->_dwHistoryIndex++;

Cleanup:
    RRETURN(hr);
}

int
CRichtext::GetThemeState()
{
    //
    // TODO: need more states
    //
    if (!IsEnabled())
    {
        return ETS_DISABLED;
    }
    return ETS_NORMAL;
}

//+------------------------------------------------------------------------
//
//  Member:     OnPropertyChange
//
//  Note:       Called after a property has changed to notify derived classes
//              of the change.  All properties (except those managed by the
//              derived class) are consistent before this call.
//
//              Also, fires a property change notification to the site.
//
//-------------------------------------------------------------------------

HRESULT
CRichtext::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr          = S_OK;

    switch (dispid)
    {
    case DISPID_CRichtext_wrap:
        Layout()->SetWrap();
        break;

    case DISPID_CRichtext_readOnly:
        _fReadOnly = !!GetAAreadOnly();
        // update the editability in the edit context
        break;

    case DISPID_CRichtext_value:
        _fTextChanged = TRUE;
        break;
    }

    hr = THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CRichtext::QueryStatus
//
//  Synopsis:   Called to discover if a given command is supported
//              and if it is, what's its state.  (disabled, up or down)
//
//--------------------------------------------------------------------------

HRESULT
CRichtext::QueryStatus(
        GUID * pguidCmdGroup,
        ULONG cCmds,
        MSOCMD rgCmds[],
        MSOCMDTEXT * pcmdtext)
{
    Assert(CBase::IsCmdGroupSupported(pguidCmdGroup));
    Assert(cCmds == 1);

    MSOCMD   * pCmd = & rgCmds[0];
    ULONG      cmdID;

    Assert(!pCmd->cmdf);

    cmdID = CBase::IDMFromCmdID( pguidCmdGroup, pCmd->cmdID );
    switch (cmdID)
    {
    case IDM_INSERTOBJECT:
        // Don't allow objects to be inserted in TEXTAREA
        pCmd->cmdf = MSOCMDSTATE_DISABLED;
        return S_OK;

    default:
        RRETURN_NOTRACE(super::QueryStatus(
            pguidCmdGroup,
            1,
            pCmd,
            pcmdtext));
    }
}


HRESULT
CRichtext::Exec(
        GUID * pguidCmdGroup,
        DWORD nCmdID,
        DWORD nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut)
{
    Assert(CBase::IsCmdGroupSupported(pguidCmdGroup));

    int      idm = CBase::IDMFromCmdID(pguidCmdGroup, nCmdID);
    HRESULT  hr  = MSOCMDERR_E_NOTSUPPORTED;

    switch (idm)
    {
    case IDM_SELECTALL:
        select();
        hr = S_OK;
        break;
    }

    if (hr == MSOCMDERR_E_NOTSUPPORTED)
    {
        hr = super::Exec(
                pguidCmdGroup,
                nCmdID,
                nCmdexecopt,
                pvarargIn,
                pvarargOut);
    }

    RRETURN_NOTRACE(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CRichtext::DelayLoadHistoryValue()
//
//  Synopsis:   DelayedLoadHistory will call this
//
//-------------------------------------------------------------------------

HRESULT
CRichtext::DelayLoadHistoryValue()
{
    HRESULT hr      = S_OK;
    CStr    cstrVal;
    DWORD   dwTemp;
    DWORD   dwScrollPos = 0;
    CMarkup * pMarkup = GetMarkup();
    DWORD   dwHistoryIndex = 0x80000000 | (DWORD)_iHistoryIndex & 0x0FFFF;

    // Load the history stream
    IGNORE_HR(pMarkup->GetLoadHistoryStream(dwHistoryIndex, 
                                HistoryCode(), 
                                &_pStreamHistory));

    if (_pStreamHistory && !pMarkup->_fUserInteracted)
    {
        CDataStream ds(_pStreamHistory);
        DWORD   dwEncoding;

        // Load encoding changing history
        hr = THR(ds.LoadDword(&dwEncoding));
        if (hr)
            goto Cleanup;

        if (!dwEncoding)
        {            
            // load value
            hr = THR(ds.LoadCStr(&cstrVal));
            if (hr)
                goto Cleanup;

            // load _fTextChanged
            hr = THR(ds.LoadDword(&dwTemp));
            if (hr)
                goto Cleanup;

            _fTextChanged = dwTemp ? TRUE : FALSE;

            if (_fTextChanged)
            {
                hr = THR(SetValueHelperInternal(&cstrVal));
                if (hr)
                    goto Cleanup;

                IGNORE_HR(OnPropertyChange(DISPID_A_VALUE, 
                                           0, 
                                           (PROPERTYDESC *)&s_propdescCRichtextvalue));
            }
        }

        // load scroll pos
        hr = THR(ds.LoadDword(&dwScrollPos));
        if (hr)
            goto Cleanup;

        {
            CLayout *pLayout = Layout();
            CDispNode   *pDispNode = pLayout->GetElementDispNode();
            if (pDispNode && pDispNode->IsScroller())
            {
                pLayout->ScrollToY(dwScrollPos);
            }
        }

        //
        // we might insert new elements, we need to ensure the tree cache
        // is up to date
        //
    }
Cleanup:
    ClearInterface(&_pStreamHistory);
    RRETURN(hr);
}

/*
//+------------------------------------------------------------------------
//
//  Member:     CRichtext::LoadHistoryValue()
//
//  Synopsis:   Load history
//
//-------------------------------------------------------------------------

HRESULT
CRichtext::LoadHistoryValue()
{
    HRESULT hr = S_OK;
    CStr    cstrVal;
    DWORD   dwTemp;

    if (_pStreamHistory)
    {
        CDataStream ds(_pStreamHistory);
    }
Cleanup:
    RRETURN(hr);
}

*/

//+------------------------------------------------------------------------
//
//  Member:     CRichtext::SaveHistoryValue()
//
//  Synopsis:   save history:
//                              - value
//                              - _fTextChanged
//                              - scroll position
//
//-------------------------------------------------------------------------

HRESULT
CRichtext::SaveHistoryValue(CHistorySaveCtx *phsc)
{
    CDataStream ds;
    HRESULT     hr      = S_OK;
    IStream *   pStream = NULL;
    CStr        cstrVal;
    DWORD       dwHistoryIndex;

    Assert(phsc);
    if (!phsc)
        goto Cleanup;

    dwHistoryIndex = 0x80000000 | (DWORD)_iHistoryIndex & 0x0FFFF;
    hr = THR(phsc->BeginSaveStream(dwHistoryIndex, HistoryCode(), &pStream));
    if (hr)
        goto Cleanup;

    ds.Init(pStream);

    hr = THR(ds.SaveDword(_fChangingEncoding ? 1 : 0));
    if (hr)
        goto Cleanup;
    if (!_fChangingEncoding)
    {
        // save value
        hr = THR(GetValueHelper(&cstrVal));
        if (hr)
            goto Cleanup;

        hr = THR(ds.SaveCStr(&cstrVal));
        if (hr)
            goto Cleanup;

        // save _fTextChanged
        hr = THR(ds.SaveDword(_fTextChanged ? 1 : 0));
        if (hr)
            goto Cleanup;
    }

    // save scroll pos
    hr = THR(ds.SaveDword(Layout()->GetYScroll()));
    if (hr)
        goto Cleanup;

    hr = THR(phsc->EndSaveStream());
    if (hr)
        goto Cleanup;
Cleanup:
    ReleaseInterface(pStream);
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CRichtext::Notify()
//
//  Synopsis:   handle notifications
//
//-------------------------------------------------------------------------

void
CRichtext::Notify(CNotification *pNF)
{
    IMarkupPointer* pStart = NULL;
    IHTMLElement* pIElement = NULL;
    HRESULT hr = S_OK;
    BOOL fRefTaken = FALSE;
    
    if (pNF->Type() != NTYPE_DELAY_LOAD_HISTORY)
    {
        super::Notify(pNF);
    }
    switch (pNF->Type())
    {

    case NTYPE_ELEMENT_GOTMNEMONIC:
    {
        if (! IsEditable(/*fCheckContainerOnly*/TRUE) && IsEditable(/*fCheckContainerOnly*/FALSE) )
        {
            CDoc* pDoc = Doc();
            fRefTaken = TRUE;
            hr = THR( pDoc->CreateMarkupPointer( & pStart ));
            if ( hr )
                goto Cleanup;
            
            hr = THR( this->QueryInterface( IID_IHTMLElement, (void**) & pIElement ));
            if ( hr )
                goto Cleanup;

            hr = THR( pStart->MoveAdjacentToElement( pIElement, ELEM_ADJ_BeforeEnd ) );
            if ( hr )
                goto Cleanup;

            hr = THR( pDoc->Select( pStart, pStart, SELECTION_TYPE_Caret));                
            if ( hr )
                goto Cleanup;
        }                 
    }            
    break;

    case NTYPE_ELEMENT_LOSTMNEMONIC:
    {
        if (! IsEditable(/*fCheckContainerOnly*/TRUE) && IsEditable(/*fCheckContainerOnly*/FALSE) )
        {
            Doc()->DestroyAllSelection();
        }                 
    }        
    break;

    case NTYPE_SAVE_HISTORY_1:
        pNF->SetSecondChanceRequested();
        break;
 
    case NTYPE_SAVE_HISTORY_2:
        {
            CHistorySaveCtx *   pCtx = NULL;

            pNF->Data((void **)&pCtx);
            IGNORE_HR(SaveHistoryValue(pCtx));
        }
        break;

    case NTYPE_DELAY_LOAD_HISTORY:
        IGNORE_HR(DelayLoadHistoryValue());
        super::Notify(pNF);
        break;

    case NTYPE_END_PARSE:
        GetValueHelper(&_cstrDefaultValue);
        _fLastValueSet = FALSE;
        break;

    case NTYPE_ELEMENT_ENTERTREE:
        EnterTree();
        break;

    case NTYPE_ELEMENT_EXITTREE_1:
        ClearInterface(&_pStreamHistory);
        break;

    case NTYPE_SET_CODEPAGE:
        _fChangingEncoding = TRUE;
        break;
    }

Cleanup:
    if ( fRefTaken )
    {
        ReleaseInterface( pStart );
        ReleaseInterface( pIElement );
    }
    
}


//+------------------------------------------------------------------------
//
//  Member:     CRichtext::GetValueHelper()
//
//  Synopsis:   returns the inner HTML
//
//-------------------------------------------------------------------------

HRESULT
CRichtext::GetValueHelper(CStr *pstr)
{
    HRESULT hr = S_OK;

    if (Tag()==ETAG_TEXTAREA)
    {
        hr = THR(GetPlainTextInScope(pstr));
    }
    else
    {
        BSTR    bStrValue;

#ifdef  NEVER
        Assert(Tag()==ETAG_HTMLAREA);
#endif
        hr = THR(GetText(&bStrValue, WBF_NO_WRAP|WBF_NO_TAG_FOR_CONTEXT));;
        if (hr)
            goto Cleanup;

        Assert(pstr);
        hr = pstr->SetBSTR(bStrValue);
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CRichtext::GetSubmitValue()
//
//  Synopsis:   returns the inner HTML
//
//-------------------------------------------------------------------------

HRESULT
CRichtext::GetSubmitValue(CStr *pstr)
{
    RRETURN(GetValueHelper(pstr));
}

//+------------------------------------------------------------------------
//
//  Member:     CRichtext::GetWordWrap()
//
//  Synopsis:   Callback to tell if the word wrap should be done
//
//-------------------------------------------------------------------------

BOOL
CRichtext::GetWordWrap() const
{
    return  htmlWrapOff == GetAAwrap() ? FALSE : TRUE;
}

HRESULT
CRichtext::SetValueHelperInternal(CStr *pstr, BOOL fOM /* = TRUE */)
{
    HRESULT hr = S_OK;
    int c= pstr->Length();

#ifdef  NEVER
    Assert(Tag()==ETAG_HTMLAREA || Tag()==ETAG_TEXTAREA);
#else
    Assert(Tag()==ETAG_TEXTAREA);
#endif
    Assert(pstr);

#ifdef  NEVER
    hr = THR( Inject( Inside, Tag() == ETAG_HTMLAREA, *pstr, c ) );
#else
    hr = THR( Inject( Inside, FALSE, *pstr, c ) );
#endif

#ifndef NO_DATABINDING
    if (SUCCEEDED(hr))
    {
        hr = SaveDataIfChanged(ID_DBIND_DEFAULT);
        if (SUCCEEDED(hr))
        {
            hr = S_OK;
        }
    }
#endif

    // Set this to prevent OnPropertyChange(_Value_) from firing twice
    // when value is set through OM. This flag is cleared in OnTextChange().
    _fFiredValuePropChange = fOM;

    // TODO, make sure this is covered when turns the HTMLAREA on
    _cstrLastValue.Set(*pstr, c);
    _fLastValueSet = TRUE;
    _fTextChanged = FALSE;

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CRichtext::SetValueHelper()
//
//  Synopsis:   set the inner HTML
//
//-------------------------------------------------------------------------

HRESULT
CRichtext::SetValueHelper(CStr *pstr)
{
    return SetValueHelperInternal(pstr);
}

//+----------------------------------------------------------------------------
//
//  Method:     GetSubmitInfo
//
//  Synopsis:   returns the submit info string if there is a value
//              (name && value pair)
//
//  Returns:    S_OK if successful
//              E_NOTIMPL if not applicable for current element
//
//-----------------------------------------------------------------------------
HRESULT
CRichtext::GetSubmitInfo(CPostData * pSubmitData)
{
    LPCTSTR pstrName = GetAAsubmitname();

    //  no name --> no submit!
    if ( ! pstrName )
        return S_FALSE;

    CStr    cstrValue;
    HRESULT hr = GetSubmitValue(&cstrValue);
    if (hr)
        goto Cleanup;

    hr = THR(pSubmitData->AppendNameValuePair(pstrName, cstrValue, GetMarkup()));

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CRichtext::createTextRange
//
//----------------------------------------------------------------------------
HRESULT
CRichtext::createTextRange( IHTMLTxtRange * * ppDisp )
{
    HRESULT hr = S_OK;

    hr = THR( EnsureInMarkup() );
    
    if (hr)
        goto Cleanup;

    hr = THR( GetMarkup()->createTextRange( ppDisp, this ) );
    
    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( SetErrorInfo( hr ) );
}

HRESULT BUGCALL
CRichtext::select(void)
{
    HRESULT             hr          = S_OK;
    CMarkup *           pMarkup     = GetMarkup();
    CDoc *              pDoc        = Doc();
    CMarkupPointer      ptrStart(pDoc);
    CMarkupPointer      ptrEnd(pDoc); 
    IMarkupPointer *    pIStart; 
    IMarkupPointer *    pIEnd; 

    if (!pMarkup)
        goto Cleanup;

#if 0
    hr = pDoc->SetEditContext(this, TRUE, FALSE);
#else
    hr = BecomeCurrent(0);
#endif
    if (hr)
        goto Cleanup;

    hr = ptrStart.MoveToCp(GetFirstCp(), pMarkup);
    if (hr)
        goto Cleanup;
    hr = ptrEnd.MoveToCp(GetLastCp(), pMarkup);
    if (hr)
        goto Cleanup;
    Verify(S_OK == ptrStart.QueryInterface(IID_IMarkupPointer, (void**)&pIStart));
    Verify(S_OK == ptrEnd.QueryInterface(IID_IMarkupPointer, (void**)&pIEnd));
    hr = pDoc->Select(pIStart, pIEnd, SELECTION_TYPE_Text);
    pIStart->Release();
    pIEnd->Release();
Cleanup:
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CRichtext::RequestYieldCurrency
//
//  Synopsis:   Check if OK to Relinquish currency
//
//  Arguments:  BOOl fForce -- if TRUE, force change and ignore user cancelling the
//                             onChange event
//
//  Returns:    S_OK: ok to yield currency
//
//--------------------------------------------------------------------------

HRESULT
CRichtext::RequestYieldCurrency(BOOL fForce)
{
    CStr    cstr;
    HRESULT hr = S_OK;

    if ((hr = GetValueHelper(&cstr)) == S_OK)
    {
        BOOL fFire =  FormsStringCmpLoc(cstr,
                            _fLastValueSet ?
                                _cstrLastValue : _cstrDefaultValue)
                        != 0;

        if (!fFire)
            goto Cleanup;

        if (!Fire_onchange())   //JS event
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        hr = super::RequestYieldCurrency(fForce);
        if (hr == S_OK)
        {
            _cstrLastValue.Set(cstr);
            _fLastValueSet = TRUE;
        }
    }

Cleanup:
    if (fForce && FAILED(hr))
    {
        hr = S_OK;
    }

    RRETURN1(hr, S_FALSE);
}

//+-------------------------------------------------------------------------
//
//  Method:     CRichText::BecomeUIActive
//
//  Synopsis:   Check imeMode to set state of IME.
//
//  Notes:      This is the method that external objects should call
//              to force sites to become ui active.
//
//--------------------------------------------------------------------------

HRESULT
CRichtext::BecomeUIActive()
{
    HRESULT hr = S_OK;

    hr = THR(super::BecomeUIActive());
    if (hr)
        goto Cleanup;

    hr = THR(SetImeState());
    if (hr)
        goto Cleanup;

Cleanup:    
    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CRichtext::YieldCurrency
//
//  Synopsis:   Relinquish currency
//
//  Arguments:  pSiteNew    New site that wants currency
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------------

HRESULT
CRichtext::YieldCurrency(CElement *pElemNew)
{
    HRESULT hr;

    _fDoReset = FALSE;

    Assert(ShouldHaveLayout());

    hr = THR(super::YieldCurrency(pElemNew));

    RRETURN(hr);
}


HRESULT BUGCALL
CRichtext::HandleMessage(CMessage * pMessage)
{
    HRESULT         hr = S_FALSE;
    CFormElement *  pForm;
    BOOL    fEditable = IsEditable(TRUE);

    if ( !CanHandleMessage() ||
         (!fEditable && !IsEnabled()) )
    {
        goto Cleanup;
    }

    if (!fEditable && _fDoReset)
    {
        if (pMessage->message == WM_KEYDOWN && pMessage->wParam == VK_ESCAPE)
        {
            pForm = GetParentForm();
            if (pForm)
            {
                _fDoReset = FALSE;
                hr = THR(pForm->DoReset(TRUE));
                if (hr != S_FALSE)
                    goto Cleanup;
            }
        }
        else if (pMessage->message >= WM_KEYFIRST &&
                pMessage->message <= WM_KEYLAST &&
                pMessage->wParam != VK_ESCAPE)
        {
            _fDoReset = FALSE;
        }
    }

    switch (pMessage->message)
    {
        case WM_RBUTTONDOWN:
            // Ignore right-click (single click) if the input text box has focus.
            // This prevents the selected contents in an input text control from
            // being loosing selection.

            //
            // marka - we only do this for browse mode. Why ? We want going UI Active
            // to be under mshtmled's rules (ie first click site select, second drills in)
            //
            if ( ! IsEditable(/*fCheckContainerOnly*/TRUE) )
            {
                hr = THR(BecomeCurrent(pMessage->lSubDivision));
            }                
            goto Cleanup;
            
        // We handle all WM_CONTEXTMENUs
        case WM_CONTEXTMENU:
            hr = THR(OnContextMenu(
                    (short) LOWORD(pMessage->lParam),
                    (short) HIWORD(pMessage->lParam),
                    CONTEXT_MENU_CONTROL));
            goto Cleanup;
    }

    if (!fEditable &&
        pMessage->message == WM_KEYDOWN &&
        pMessage->wParam == VK_ESCAPE)
    {
        _fDoReset = TRUE;
        SetValueHelperInternal(_fLastValueSet ? &_cstrLastValue : &_cstrDefaultValue, FALSE);
        hr = S_FALSE;
        goto Cleanup;
    }

    // Let supper take care of event firing
    // Since we let TxtEdit handle messages we do JS events after
    // it comes back
    hr = super::HandleMessage(pMessage);

Cleanup:

    RRETURN1(hr, S_FALSE);
}


HRESULT
CRichtext::put_status(VARIANT status)
{
    switch(status.vt)
    {
    case VT_NULL:
        _vStatus.vt = VT_NULL;
        break;
    case VT_BOOL:
        _vStatus.vt = VT_BOOL;
        V_BOOL(&_vStatus) = V_BOOL(&status);
        break;
    default:
        _vStatus.vt = VT_BOOL;
        V_BOOL(&_vStatus) = VB_TRUE;
    }

    Verify(S_OK==OnPropertyChange(DISPID_CRichtext_status, 
                                  0, 
                                  (PROPERTYDESC *)&s_propdescCRichtextstatus));

    RRETURN(S_OK);
}

HRESULT
CRichtext::get_status(VARIANT * pStatus)
{
    if (_vStatus.vt==VT_NULL)
    {
        pStatus->vt = VT_NULL;
    }
    else
    {
        pStatus->vt = VT_BOOL;
        V_BOOL(pStatus) = V_BOOL(&_vStatus);
    }
    RRETURN(S_OK);
}


HRESULT
CRichtext::DoReset(void)
{
    RRETURN(SetValueHelperInternal(&_cstrDefaultValue));
}

#ifndef NO_DATABINDING
class CDBindMethodsTextarea : public CDBindMethodsText
{
    typedef CDBindMethodsText super;
public:
    CDBindMethodsTextarea() : super(0)   {}
    ~CDBindMethodsTextarea()    {}

    virtual HRESULT BoundValueToElement(CElement *pElem, LONG id,
                                        BOOL fHTML, LPVOID pvData) const;
};

static const CDBindMethodsTextarea DBindMethodsTextarea;

const CDBindMethods *
CRichtext::GetDBindMethods()
{
    return &DBindMethodsTextarea;
}

//+----------------------------------------------------------------------------
//
//  Function: BoundValueToElement, CDBindMethods
//
//  Synopsis: transfer bound data to textarea element.  We need to override
//            the CElement implementation to remember the value being
//            transferred as the "last value".  This keeps the onchange event
//            from firing simply because the value is databound.
//
//  Arguments:
//            [id]      - ID of binding point.
//            [fHTML]   - is HTML-formatted data called for?
//            [pvData]  - pointer to data to transfer, in the expected data
//                        type.  For text-based transfers, must be BSTR.
//
//-----------------------------------------------------------------------------

HRESULT
CDBindMethodsTextarea::BoundValueToElement ( CElement *pElem,
                                                 LONG id,
                                                 BOOL fHTML,
                                                 LPVOID pvData ) const
{
    HRESULT hr = super::BoundValueToElement(pElem, id, fHTML, pvData);    // do the transfer
    if (!hr)
    {
        // NOTE: We were relying on OnTextChange to fire PropertyChange
        // event for value, but this is not reliable if the page is loading
        // and our layout is not listening to notification yet.
        // 

        Assert(pElem->Tag() == ETAG_TEXTAREA);
        CRichtextLayout *pLayout = DYNCAST(CRichtext, pElem)->Layout();

        if (!pLayout || !pLayout->IsListening())
        {
            Verify(!pElem->OnPropertyChange(DISPID_A_VALUE, 0));
        }
        // remember the value
        CRichtext *pElemRT = DYNCAST(CRichtext, pElem);
        pElemRT->_cstrLastValue.Set(*(LPCTSTR*)pvData);
        pElemRT->_fLastValueSet = TRUE;
    }
    return hr;
}
#endif // ndef NO_DATABINDING
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\builtin\wselect.cxx ===
//+---------------------------------------------------------------------
//
//   File:      wselect.cxx
//
//  Contents:   Unicode support for CSelectElement on win95.
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X__FONTLNK_H_
#define X__FONTLNK_H_
#include "_fontlnk.h"
#endif

#ifndef X_ESELECT_HXX_
#define X_ESELECT_HXX_
#include "eselect.hxx"
#endif

#ifndef X_EOPTION_HXX_
#define X_EOPTION_HXX_
#include "eoption.hxx"
#endif

extern class CFontCache & fc();

MtDefine(CSelectElementAddString, CSelectElement, "CSelectElement::_pchItem")

//
// A few wrapper functions that cache system data we use a lot
//

inline
int Margin(void)
{
    static int iMargin = -1;

    return iMargin != -1 ? iMargin : (iMargin = 2*GetSystemMetrics(SM_CXBORDER));
}

#ifdef WIN16
#define _MAKELCID(x,y)  MAKELCID(x)
#else
#define _MAKELCID(x,y)  MAKELCID(x,y)
#endif

//+------------------------------------------------------------------------
//
//  Function:   LcidFromCP, static to this file.
//
//  Synopsis:   Attempts to convert a code page to a correct lcid
//
//  Arguments:  uCodePage -- a win95 code page (e.g. 1252)
//
//  Note:   Returns 0 if either the code page is unrecognized or the code
//          page cannot uniquely be assigned an lcid.  This happens, for
//          instance, with latin 1 (cp 1252), which is used for both
//          english and german locales.
//
//-------------------------------------------------------------------------
LCID LcidFromCP(UINT uCodePage)
{
    switch (uCodePage)
    {
        case 874: // thai
            return _MAKELCID(MAKELANGID(LANG_THAI, SUBLANG_NEUTRAL), SORT_DEFAULT);
        case 932: // japan
            return _MAKELCID(MAKELANGID(LANG_JAPANESE, SUBLANG_NEUTRAL), SORT_DEFAULT);
        case 936: // simpl. chi
            return _MAKELCID(MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED), SORT_DEFAULT);
        case 949: // korean
            return _MAKELCID(MAKELANGID(LANG_KOREAN, SUBLANG_NEUTRAL), SORT_DEFAULT);
        case 950: // trad. chi
            return _MAKELCID(MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL), SORT_DEFAULT);
        case 1250: // 3.1 e. euro
            return 0;
        case 1251: // 3.1 cyrillic
            return _MAKELCID(MAKELANGID(LANG_RUSSIAN, SUBLANG_NEUTRAL), SORT_DEFAULT);
        case 1252: // 3.1 latin 1
            return 0;
        case 1253: // 3.1 greek
            return _MAKELCID(MAKELANGID(LANG_GREEK, SUBLANG_NEUTRAL), SORT_DEFAULT);
        case 1254: // 3.1 turkish
            return _MAKELCID(MAKELANGID(LANG_TURKISH, SUBLANG_NEUTRAL), SORT_DEFAULT);
        case 1255: // hebrew
            return _MAKELCID(MAKELANGID(LANG_HEBREW, SUBLANG_NEUTRAL), SORT_DEFAULT);
        case 1256: // arabic
            return _MAKELCID(MAKELANGID(LANG_ARABIC, SUBLANG_NEUTRAL), SORT_DEFAULT);
        case 1257: // baltic
            return 0;
        default:
            return 0;
    }
}

#ifndef WIN16
//+------------------------------------------------------------------------
//
//  Function:   PrivateToUpper, static to this file.
//
//  Synopsis:   Attempts to convert a WCHAR to uppercase using a locale
//              derived from the supplied cp.
//
//  Arguments:  chSource -- WCHAR to convert
//              BYTE abSource[] -- WCHAR in mbcs form
//                  abSource[1] must be 0 if char is sbc
//                  abSource[0] may be 0 if no mbcs char is available
//              uCodePage -- windows code page of the char (in mbcs)
//
//  Note:   Unfortunately on win95 LCMapStringW is stubbed, so we can't
//          reliably do a pure unicode case insensitive search.  That is, we
//          must use LCMapStringA.
//
//          Worse, at present we don't have an exact lcid for the characters
//          we examine, so we have to check for an exact match between the
//          supplied cp and an lcid.  If we don't find one, we return the
//          original wchar.
//
//          Unicode values between 0x0020 and 0x007f are always converted.
//
//-------------------------------------------------------------------------
WCHAR PrivateToUpper(WCHAR chSource, BYTE abSource[2], UINT uCodePage)
{
    LCID lcid;
    BOOL fUsedDefChar;
    BYTE abDest[2];
    int cbSize;

    // filter out the trivial case
    if ((chSource >= L'a') && (chSource <= L'z'))
        return chSource - L'a' + L'A';

    // filter out other trivial cases
    if ((chSource >= L'A') && (chSource <= L'Z'))
        return chSource;

    lcid = LcidFromCP(uCodePage);

    if (lcid == 0)
    {
        // we don't recognize the code page or it spans more than one LCID
        return chSource;
    }

    if (abSource[0] == 0)
    {
        // need to get an mbcs version of the char -- LCMapStringW stubbed on win95
        cbSize = WideCharToMultiByte(uCodePage, 0, &chSource, 1, (char *)abSource, 2, NULL, &fUsedDefChar);
        if (cbSize < 1 || fUsedDefChar)
            return chSource;
        if (cbSize == 1)
            abSource[1] = 0; // for compare below
    }
    else
    {
        cbSize = abSource[1] == 0 ? 1 : 2;
    }

    cbSize = LCMapStringA(lcid, LCMAP_UPPERCASE, (LPCSTR)abSource, cbSize, (LPSTR)&abDest, 2);

    if (cbSize > 0)
    {
        // got it, convert to unicode if necessary
        if (*((WORD *)abSource) != *((WORD *)abDest))
            MultiByteToWideChar(uCodePage, MB_ERR_INVALID_CHARS, (char *)abDest, cbSize, &chSource, 1);
    }

    return chSource;
}
#endif //!WIN16

//+------------------------------------------------------------------------
//
//  Function:   GenericDrawItem, static to this file.
//
//  Synopsis:   Handle WM_DRAWITEMs for both listboxes and comboboxes.
//
//  Arguments:  uGetItemMessage -- LB_GETITEMDATA or CB_GETITEMDATA
//
//-------------------------------------------------------------------------
void
CSelectElement::GenericDrawItem(LPDRAWITEMSTRUCT pdis, UINT uGetItemMessage)
{
    long idx = -1;
    int itemAction = pdis->itemAction;
    int itemID     = pdis->itemID;
    int itemState  = pdis->itemState;
    COptionElement * pOption = NULL;
    XHDC hDC(pdis->hDC, NULL);
    BOOL fRTL;
    UINT taOld = 0;

    Assert(LB_ERR == CB_ERR); // need a third parameter if this changes!

    if ( itemID >= 0  &&  itemID < _aryOptions.Size() )
    {
        pOption = _aryOptions[itemID]; Assert(pOption);

        if ( pOption->_fIsOptGroup )
        {
            if (!itemID && (itemAction & ODA_FOCUS))
                idx = GetNearestOption(itemID, FALSE);

            if (idx != -1)
            {
                Assert(idx > 0);
                pdis->rcItem.top += (idx*_lFontHeight);
                pdis->rcItem.bottom = pdis->rcItem.top + _lFontHeight;
            }
            else
            {
                itemAction &= ~ODA_FOCUS;
                itemState  &= ~(ODS_SELECTED | ODS_FOCUS);
            }
        }
    }    

    if ( pOption && (itemAction & (ODA_SELECT | ODA_DRAWENTIRE)) )
    {     
        if ( ! pOption->IsInMarkup() )
            return;

        if (itemState & ODS_SELECTED)
        {
            FillRect(hDC, &pdis->rcItem, GetSysColorBrush(COLOR_HIGHLIGHT));
        }
        else
        {
            //  Get the style sheet background color
            CColorValue ccv = pOption->GetFirstBranch()->GetCascadedbackgroundColor();
            HBRUSH hbrush;

            if ( ccv.IsDefined() )
            {
                hbrush = GetCachedBrush(ccv.GetColorRef());
                FillRect(hDC, &pdis->rcItem, hbrush);
                ReleaseCachedBrush(hbrush);
            }
            else
            {
                FillRect(hDC, &pdis->rcItem, (HBRUSH)GetCurrentObject(hDC, OBJ_BRUSH));
            }
        }

        WCHAR * pzItem = pOption->_cstrText;

        if ((pzItem != NULL) && (pzItem != (WCHAR *)LB_ERR))
        {
            int iOldBkMode = SetBkMode(hDC, TRANSPARENT);
            COLORREF crOldColor = 0;
            COLORREF cr;
            CColorValue ccv;
            CStr cstrTransformed;
            CStr * pcstrDisplayText;
            const CCharFormat *pcf;
            const CParaFormat *pPF;
            CCcs  ccs;
            int iRet = -1;
            UINT fuOptions = ETO_CLIPPED;

            if (itemState & ODS_DISABLED)
            {
                cr = GetSysColorQuick(COLOR_GRAYTEXT);
            }
            else if (itemState & ODS_SELECTED)
            {
                cr = GetSysColorQuick(COLOR_HIGHLIGHTTEXT);
            }
            else if ( (ccv = pOption->GetFirstBranch()->GetCascadedcolor()).IsDefined() )
            {
                cr = ccv.GetColorRef();
            }
            else
            {
                cr = GetSysColorQuick(COLOR_WINDOWTEXT);
            }

            crOldColor = SetTextColor(hDC, cr);

            //  Do the textTransform here
            pcstrDisplayText = pOption->GetDisplayText(&cstrTransformed, 
                                                       !!(itemState & ODS_COMBOBOXEDIT) );

            // ComplexText
            pPF = GetFirstBranch()->GetParaFormat();

            fRTL = pPF->HasRTL(TRUE);
            if(fRTL)
            {
                taOld = GetTextAlign(hDC);
                SetTextAlign(hDC, TA_RTLREADING | TA_RIGHT);
                fuOptions |= ETO_RTLREADING;
            }
            
            if (pOption->_fIsOptGroup)
                pcf = pOption->GetFirstBranch()->GetCharFormat();
            else
                pcf = GetFirstBranch()->GetCharFormat();

            if (pcf)
            {
                CDocInfo dci(this);

                if (!fc().GetCcs(&ccs, hDC, &dci, pcf))
                    return;
             
                if (pOption->_fIsOptGroup || pOption->CheckFontLinking(hDC, &ccs))
                {
                    // this option requires font linking
                    iRet = FontLinkTextOut(hDC,
                                           !fRTL ? pdis->rcItem.left + Margin() 
                                                 : pdis->rcItem.right - Margin(),
                                           pdis->rcItem.top,
                                           fuOptions ,
                                           &pdis->rcItem,
                                           *pcstrDisplayText,
                                           pcstrDisplayText->Length(),
                                           &dci,
                                           pcf,
                                           FLTO_TEXTOUTONLY);
                }
            }

            if (iRet < 0)
            {
                // no font linking
                VanillaTextOut(&ccs, hDC,
                               !fRTL ? pdis->rcItem.left + Margin() 
                                     : pdis->rcItem.right - Margin(),
                               pdis->rcItem.top,
                               fuOptions ,
                               &pdis->rcItem,
                               *pcstrDisplayText,
                               pcstrDisplayText->Length(),
                               GetMarkup()->GetCodePage(),
                               NULL);

                if (_hFont && g_dwPlatformID == VER_PLATFORM_WIN32_WINDOWS)
                {
                    // Workaround for win95 gdi ExtTextOutW underline bugs.
                    DrawUnderlineStrikeOut(pdis->rcItem.left+Margin(),
                                           pdis->rcItem.top,
                                           pOption->MeasureLine(NULL),
                                           hDC,
                                           _hFont,
                                           &pdis->rcItem);
                }
            }

            if (itemState & ODS_FOCUS)
            {
                DrawFocusRect(hDC, &pdis->rcItem);
            }

            if (itemState & (ODS_SELECTED | ODS_DISABLED))
            {
                SetTextColor(hDC, crOldColor);
            }

            SetBkMode(hDC, iOldBkMode);

            ccs.Release();

            if(fRTL)
                SetTextAlign(hDC, taOld);
        }
    }

    if (itemAction & ODA_FOCUS)
    {
        DrawFocusRect(hDC, &pdis->rcItem);

        if (idx != -1)
        {
            Assert(idx > 0);
            pdis->rcItem.top -= (idx*_lFontHeight);
            pdis->rcItem.bottom = pdis->rcItem.top + _lFontHeight;
        }
    }
    else
        Assert(idx == -1);
}

#ifndef WIN16
//+------------------------------------------------------------------------
//
//  Function:   GenericCharToItem, static to this file.
//
//  Synopsis:   WM_CHARTOITEM handler for both listboxes and comboboxes.
//              Translates a keypress into the matching list item.
//
//-------------------------------------------------------------------------
LRESULT
CSelectElement::GenericCharToItem (HWND hCtlWnd,
                                   WORD wKey,
                                   WORD wCurrentIndex)
{
    int sCurrentIndex = (unsigned)wCurrentIndex;
    WCHAR chUniKey;
    int iSearch, iCount;
    int cbSize;
    UINT uKbdCodePage, uCtlCodePage;
    CHARSETINFO ci;
    HDC hFontDC;
    UINT uCharSet;
    const WCHAR * pwc;
    char strKey[2];

    iCount = _aryOptions.Size();
    Assert(SendSelectMessage(Select_GetCount, 0, 0) == iCount);

    if ( iCount <= 0)
        return -1;

    // get the current keyboard code page
    // uses TCI_SRCLOCALE (0x1000) flag, documented in gdi.c
    if (TranslateCharsetInfo((DWORD *)GetKeyboardLayout(0), &ci, 0x1000))
        uKbdCodePage = ci.ciACP;
    else
        uKbdCodePage = CP_ACP;

    // check for dbcs
    if ( !IsWindowUnicode( hCtlWnd ) )
    {          
        if (IsDBCSLeadByteEx(uKbdCodePage, HIBYTE(wKey) != 0))
        {
            // lead byte must precede trail byte for MBTWC call below....
            strKey[0] = HIBYTE(wKey);
            strKey[1] = LOBYTE(wKey);
            cbSize = 2;
        }
        else
        {
            strKey[0] = LOBYTE(wKey);
            cbSize = 1;
        }

        // get the unicode char
        if (MultiByteToWideChar(uKbdCodePage, MB_ERR_INVALID_CHARS, strKey, cbSize, &chUniKey, 1) != 1)
            return -1;
    }
    else
    {
        chUniKey = (WCHAR) wKey; 
    }
    
    // and an uppercase version in the case 0x0020 <= chUniKey <= 0x007f
    chUniKey = PrivateToUpper(chUniKey, (BYTE *)&wKey, uKbdCodePage);

    // get the ctl code page from its font
    uCtlCodePage = 0xffff;
    if ((hFontDC = ::GetDC(hCtlWnd)) != NULL)
    {
        uCharSet = GetTextCharsetInfo(hFontDC, NULL, 0);
        ::ReleaseDC(hCtlWnd, hFontDC);
        if (uCharSet != DEFAULT_CHARSET)
        {
            if (TranslateCharsetInfo((DWORD *)(DWORD_PTR)uCharSet, &ci, TCI_SRCCHARSET))
                uCtlCodePage = ci.ciACP;
        }
    }

    //
    // Look for it.  This code assumes the strings are unordered --> we could be
    // n / log n times faster if this ever changes!
    //

    wKey = 0; // use this as a buffer below

    for (iSearch = sCurrentIndex + 1; iSearch < iCount; iSearch++)
    {
        if (_aryOptions[iSearch]->_fIsOptGroup)
            continue;

        //  Guard against empty OPTIONs
        pwc = _aryOptions[iSearch]->_cstrText;
        if ( ! pwc )
        {
            pwc = g_Zero.ach;
        }

        if (PrivateToUpper(*pwc,
                           (BYTE *)&wKey,
                           uCtlCodePage) == chUniKey)
            return iSearch;
    }
    // If no element selected, set sCurrentIndex to the last element index
    if (sCurrentIndex > iCount)
        sCurrentIndex = iCount-1;
    for (iSearch = 0; iSearch <= sCurrentIndex; iSearch++)
    {
        if (_aryOptions[iSearch]->_fIsOptGroup)
            continue;

        //  Guard against empty OPTIONs
        pwc = _aryOptions[iSearch]->_cstrText;
        if ( ! pwc )
        {
            pwc = g_Zero.ach;
        }

        if (PrivateToUpper(*pwc,
                           (BYTE *)&wKey,
                           uCtlCodePage) == chUniKey)
            return iSearch;
    }

    return -1;
}
#endif //!WIN16

//+------------------------------------------------------------------------
//
//  Function:   WListboxHookProc
//
//  Synopsis:   Handles owner-draw ctl messages, also manages string related
//              ctl commands (LB_ADDSTRING, etc.).
//
//  Arguments:  pfnWndProc -- default WNDPROC to pass message to.
//
//  Note:       Called from the subclassed ctl's wndproc, CSelectElement::SelectElementWndProc.
//
//-------------------------------------------------------------------------
LRESULT BUGCALL
CSelectElement::WListboxHookProc(WNDPROC pfnWndProc, HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    WCHAR *pzItemText;
    long lSelectedIndex = -1;

    switch (message)
    {

        //
        // Reflected messages courtesy of CDoc::OnWindowMessage
        //

        case OCM__BASE + WM_DRAWITEM:
            GenericDrawItem((LPDRAWITEMSTRUCT) lParam, LB_GETITEMDATA);
            return TRUE;

        case OCM__BASE + WM_MEASUREITEM:
            //
            //  Laszlog:
            // We get one of these at creation time to determine the field height.
            // Use the font's height.
            //
            {
                LPMEASUREITEMSTRUCT pmi = (LPMEASUREITEMSTRUCT)lParam;

                Assert(pmi);
                Assert(this);

                pmi->itemHeight = _lFontHeight;
            }
            return TRUE;

        case OCM__BASE + WM_COMPAREITEM:
            // Not currently used by CSelectElement.
            // TODO (benwest) support this
            return LB_OKAY;

#ifndef WIN16
        case OCM__BASE + WM_CHARTOITEM:
            //
            // lb sends one of these when a user types a key into the list.
            // Convert the char to unicode and search for a match.
            //
            return GenericCharToItem((HWND)lParam, LOWORD(wParam), HIWORD(wParam));
#endif // ndef WIN16

        case OCM__BASE + WM_GETTEXT:
            //
            // use the selected item to look up the item currently displayed in the static part
            // This is a private message for OLEACC.DLL. They need the string in unicode
            // but the ANSI SendMessage/DefWndProc pair marshals the string and destroys it.
            // It is chooped off after the first 0 byte.
            //
            lSelectedIndex = SendMessageA(hWnd, LB_GETCURSEL, 0, 0);

        case WM_USER + LB_GETTEXT:
            if (-1 == lSelectedIndex)
                lSelectedIndex = wParam;

            if (-1 == lSelectedIndex)
            {
                *(WCHAR *)lParam = 0;
                return LB_OKAY;
            }

            if ((pzItemText = (WCHAR *)SendMessageA(hWnd, LB_GETITEMDATA, lSelectedIndex, 0)) != (WCHAR *)LB_ERR)
            {
                wcscpy((WCHAR *)lParam, pzItemText);
                return wcslen(pzItemText);
            }
            return LB_ERR;

        case LB_GETTEXTLEN:
            // not currently sent by CSelectElement, but it compliments LB_GETTEXT
            if ((pzItemText = (WCHAR *)SendMessageA(hWnd, LB_GETITEMDATA, wParam, 0)) != (WCHAR *)LB_ERR)
                return wcslen(pzItemText);
            return LB_ERR;
    }

    return CallWindowProc(pfnWndProc, hWnd, message, wParam, lParam);
}

//+------------------------------------------------------------------------
//
//  Function:   WComboboxHookProc
//
//  Synopsis:   Handles owner-draw ctl messages, also manages string related
//              ctl commands (CB_ADDSTRING, etc.).
//
//  Arguments:  pfnWndProc -- default WNDPROC to pass message to.
//
//  Note:       Called from the subclassed ctl's wndproc, CSelectElement::SelectElementWndProc.
//
//-------------------------------------------------------------------------
LRESULT BUGCALL
CSelectElement::WComboboxHookProc(WNDPROC pfnWndProc, HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    WCHAR *pzItemText;
    long lSelectedIndex = -1;

    switch (message)
    {

        //
        // Reflected messages courtesy of CDoc::OnWindowMessage
        //

        case OCM__BASE + WM_DRAWITEM:
            GenericDrawItem((LPDRAWITEMSTRUCT) lParam, CB_GETITEMDATA);
            return TRUE;

        case OCM__BASE + WM_MEASUREITEM:
            //
            // We get one of these at creation time to determine the field height.
            //  Laszlog:
            // We get one of these at creation time to determine the field height.
            // Use the font's height.
            //
            {
                LPMEASUREITEMSTRUCT pmi = (LPMEASUREITEMSTRUCT)lParam;

                Assert(pmi);
                Assert(this);

                pmi->itemHeight = _lFontHeight;
            }
            return TRUE;

        case OCM__BASE + WM_COMPAREITEM:
            // Not currently used by CSelectElement.
            // TODO (benwest): support this
            return CB_OKAY;

        //
        // ctl messages we need to augment
        //

        case OCM__BASE + WM_GETTEXTLENGTH:
            // Private message for OLEACC.DLL to get the length of the curently selected string.
            // we need this because the regular WM_GETTEXLENGTH message keeps returning 4 all the time.
            lSelectedIndex = SendMessageA(hWnd, CB_GETCURSEL, 0, 0);

        case CB_GETLBTEXTLEN:
            if (-1 == lSelectedIndex)
                lSelectedIndex = wParam;

            if ((pzItemText = (WCHAR *)SendMessageA(hWnd, CB_GETITEMDATA, lSelectedIndex, 0)) != (WCHAR *)CB_ERR)
                return wcslen(pzItemText);
                
             return CB_ERR;

        case WM_USER + CB_GETLBTEXT:
            lSelectedIndex = wParam;

        case OCM__BASE + WM_GETTEXT:
            //
            // use the selected item to look up the item currently displayed in the static part
            // This is a private message for OLEACC.DLL. They need the string in unicode
            // but the ANSI SendMessage/DefWndProc pair marshals the string and destroys it.
            // It is chooped off after the first 0 byte.
            //
            if (-1 == lSelectedIndex)
                lSelectedIndex = SendMessageA(hWnd, CB_GETCURSEL, 0, 0);

            if (-1 == lSelectedIndex)
            {
                *(WCHAR *)lParam = 0;
                return CB_OKAY;
            }

            if ((pzItemText = (WCHAR *)SendMessageA(hWnd, CB_GETITEMDATA, lSelectedIndex, 0)) != (WCHAR *)CB_ERR)
            {
                wcscpy((WCHAR *)lParam, pzItemText);
                return wcslen(pzItemText);
            }
            return CB_ERR;

#ifndef WIN16
        case WM_CHARTOITEM:
            //
            // cb sends one of these when a user types a key into the list.
            // Convert the char to unicode and search for a match.
            //
            return GenericCharToItem(hWnd/*(HWND)lParam*/, LOWORD(wParam), HIWORD(wParam));
#endif // ndef WIN16

    }

    return CallWindowProc(pfnWndProc, hWnd, message, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\dbind\consumer.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1996-1996
//  All rights Reserved.
//  Information contained herein is Proprietary and Confidential.
//
//  Contents:   Data Consumer objects
//
//  Classes:    CDataSourceBinder::CConsumer (abstract)
//                  CNullConsumer
//                  CTableConsumer
//                  CCurrentRecordConsumer
//                  CRowsetConsumer
//                  CCursorConsumer
//
//  History:    10/1/96     (sambent) created

// The concrete classes derived from CDataSourceBinder::CConsumer are
// declared in this file, which makes them unknown to the rest of the world.
// The function CConsumer::Create acts as a
// factory -- creating the appropriate concrete consumer or provider.
//
// To support a new type of consumer, derive a new class from CConsumer, and
// add code to CConsumer::Create to create an instance.


#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include <formkrnl.hxx>     // for safetylevel in safety.hxx (via olesite.hxx)
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include <olesite.hxx>
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

#ifndef X_DBINDING_HXX_
#define X_DBINDING_HXX_
#include "dbinding.hxx"
#endif

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include "binder.hxx"
#endif

#ifndef X_ROWBIND_HXX_
#define X_ROWBIND_HXX_
#include "rowbind.hxx"
#endif

#ifndef X_DLCURSOR_HXX_
#define X_DLCURSOR_HXX_
#include "dlcursor.hxx"
#endif

#ifndef X_VBCURSOR_OCDB_H_
#define X_VBCURSOR_OCDB_H_
#include <vbcursor/ocdb.h>
#endif

#ifndef X_VBCURSOR_OCDBID_H_
#define X_VBCURSOR_OCDBID_H_
#include <vbcursor/ocdbid.h>
#endif

#ifndef X_VBCURSOR_VBDSC_H_
#define X_VBCURSOR_VBDSC_H_
#include <vbcursor/vbdsc.h>
#endif

#ifndef X_VBCURSOR_OLEBIND_H_
#define X_VBCURSOR_OLEBIND_H_
#include <vbcursor/olebind.h>
#endif

#ifndef X_MSDATSRC_H_
#define X_MSDATSRC_H_
#include <msdatsrc.h>
#endif

EXTERN_C const IID IID_IADORecordset15; // for GetDataMember from Java
EXTERN_C const IID IID_DataSource;      // for QI impl of CDataSourceConsumer


/////////////////////////////////////////////////////////////////////////////
/////                       Consumer Classes                            /////
/////////////////////////////////////////////////////////////////////////////

/////-------------------------------------------------------------------/////
///// null consumer.  Used when binding fails.  Always returns error.   /////
/////-------------------------------------------------------------------/////

MtDefine(CNullConsumer, DataBind, "CNullConsumer")

class CNullConsumer: public CDataSourceBinder::CConsumer
{
    typedef CDataSourceBinder::CConsumer super;
public:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(CNullConsumer))
    CNullConsumer(CDataSourceBinder *pBinder) : super(pBinder) {}
    virtual HRESULT Bind() { return E_FAIL; }
    virtual HRESULT UnBind() { return E_FAIL; }
    virtual void    FireOnDataReady(BOOL fReady) {}
};


/////-------------------------------------------------------------------/////
/////                   Table consumer                                  /////
/////-------------------------------------------------------------------/////

MtDefine(CTableConsumer, DataBind, "CTableConsumer")

class CTableConsumer: public CDataSourceBinder::CConsumer
{
    typedef CDataSourceBinder::CConsumer super;
public:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(CTableConsumer))
    CTableConsumer(CDataSourceBinder *pBinder):
        super(pBinder), _pdlcCursor(NULL), _bstrDataSrc(NULL), _bstrDataFld(NULL) {}
    virtual HRESULT Bind();
    virtual HRESULT UnBind();
    virtual HRESULT GetDLCursor(CDataLayerCursor **pdlc);
    virtual HRESULT GetDataSrcAndFld(BSTR *, BSTR *);
    virtual void    FireOnDataReady(BOOL fReady);
    virtual ~CTableConsumer() {}
private:
    CDataLayerCursor    *_pdlcCursor;   // my DLCursor
    BSTR                _bstrDataSrc;   // my full dataSrc
    BSTR                _bstrDataFld;   // my full dataFld
};


//+-------------------------------------------------------------------------
// Member:              Bind (CTableConsumer, public)
//
// Synopsis:    set up the desired binding

HRESULT
CTableConsumer::Bind()
{
    HRESULT hr = S_OK;
    CDataSourceProvider *pProvider = NULL;
    IRowset *pRowset = NULL;
    CTable *pTable = DYNCAST(CTable, GetElementConsumer());
    Assert(pTable);
    Assert(GetProvider());
    LPCTSTR strDataSrc = pTable->GetAAdataSrc();
    LPCTSTR strDataFld = pTable->GetAAdataFld();
    
    if (strDataFld == NULL)
    {
        // normal table
        pProvider = GetProvider();
        FormsAllocString(strDataSrc, &_bstrDataSrc);
    }
    else
    {
        // hierarchical table
        BSTR bstrColumn=NULL, bstrJunk;
        LPCTSTR strTail;
        CElement *pElemOuter, *pElemRepeat;
        CRecordInstance *pRecInstance = NULL;
        CDataSourceProvider *pProviderParent = NULL;
        
        // look for enclosing repeated table
        hr = pTable->FindDatabindContext(strDataSrc, strDataFld,
                                            &pElemOuter, &pElemRepeat, &strTail);

        // if there is one, use its provider as the source for a subprovider
        if (!hr && pElemOuter)
        {
            CTable *pTableOuter = DYNCAST(CTable, pElemOuter);
            CTableRow *pRow = DYNCAST(CTableRow, pElemRepeat);
            LPCTSTR strDataFldOuter = pTableOuter->GetDataFld();
            UINT cDataFldLength;
            LPTSTR pch;
            
            pProviderParent = pTableOuter->GetProvider();
            hr = pTableOuter->GetInstanceForRow(pRow, &pRecInstance);
            if (hr)
                goto CleanupHierarchy;
            
            FormsAllocString(pTableOuter->GetDataSrc(), &_bstrDataSrc);
            FormsSplitFirstComponent(strTail, &bstrColumn, &bstrJunk);
            FormsFreeString(bstrJunk);
            
            cDataFldLength = (strDataFldOuter ? _tcslen(strDataFldOuter) : 0) +
                              1 +
                              (strTail ? _tcslen(strTail) : 0) +
                              1;
            pch = new TCHAR[cDataFldLength];
            if (pch == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto CleanupHierarchy;
            }
                
            if (strDataFldOuter)
            {
                _tcscpy(pch, strDataFldOuter);
                _tcscat(pch, _T("."));
                _tcscat(pch, bstrColumn);
            }
            else
            {
                _tcscpy(pch, bstrColumn);
            }
            FormsAllocString(pch, &_bstrDataFld);
            
            delete pch;
        }
        
        // if not, perhaps the table is current-record bound to hierarchy
        else if (!hr && strTail)
        {
            CCurrentRecordInstance *pCRI = NULL;
            hr = GetProvider()->QueryDataInterface(IID_ICurrentRecordInstance,
                                        (void**)&pCRI);
            if (!hr)
            {
                FormsAllocString(strDataSrc, &_bstrDataSrc);
                FormsAllocString(strDataFld, &_bstrDataFld);
                FormsSplitFirstComponent(strTail, &bstrColumn, &bstrJunk);
                FormsFreeString(bstrJunk);
                
                pProviderParent = GetProvider();
                hr = pCRI->GetCurrentRecordInstance(&pRecInstance);
            }
            ReleaseInterface(pCRI);
        }

        // if we found a hierarchical context, use the subprovider
        if (!hr && pRecInstance)
        {
            Assert(pProviderParent);
            HROW hrow = pRecInstance->GetHRow();
            CXfer *pXfer;

            // if there's a good HROW, get the provider we'll use to bind
            if (hrow != DB_NULL_HROW)
            {
                hr = pProviderParent->GetSubProvider(&pProvider, bstrColumn, hrow);
                if (!hr)
                    SubstituteProvider(pProvider);
                if (pProvider)
                    pProvider->Release();       // ref now owned by _pProvider
            }

            if (!hr)
            {
                hr = CXfer::CreateBinding(pTable, ID_DBIND_DEFAULT, strTail,
                                        pProviderParent, pRecInstance,
                                        &pXfer, /* fDontTransfer */ TRUE);
            }
        }

CleanupHierarchy:
        FormsFreeString(bstrColumn);
    }

    if (pProvider == NULL)
    {
        hr = E_FAIL;
    }
    if (hr)
        goto Cleanup;
    
    // get the provider's rowset
    hr = pProvider->QueryDataInterface(IID_IRowset, (void**)&pRowset);
    if (hr)
        goto Cleanup;

    // set up my DLCursor to use the rowset
    _pdlcCursor = new CDataLayerCursor(NULL);
    if (!_pdlcCursor)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = _pdlcCursor->Init(pRowset, pProvider->GetChapter(),
                        CDataLayerCursor::DLC_SinkNotifications |
                        CDataLayerCursor::DLC_FilterNotificationsToChapter);
    if (hr == E_NOINTERFACE)
    {
        hr = E_FAIL;        // E_NOINTERFACE from Bind() means "null provider"
    }

Cleanup:
    ReleaseInterface(pRowset);
    pTable->SetReadyStateTable(hr==S_OK ? READYSTATE_LOADING : READYSTATE_COMPLETE);

    return hr;
}

//+-------------------------------------------------------------------------
// Member:              UnBind (CTableConsumer, public)
//
// Synopsis:    tear down existing binding

HRESULT
CTableConsumer::UnBind()
{
    CElement *pelConsumer = GetElementConsumer();
    CDataBindingEvents *pdbe = pelConsumer->GetDBMembers()->GetDataBindingEvents();

    // for hierarchical tables, detach from the RecordInstance
    if (pdbe)
        pdbe->DetachBinding(pelConsumer, ID_DBIND_ALL);

    // all I gotta do is tell my DLCursor to die
    if (_pdlcCursor)
    {
        _pdlcCursor->Release();
        _pdlcCursor = NULL;
    }

    FormsFreeString(_bstrDataSrc);
    FormsFreeString(_bstrDataFld);
    _bstrDataSrc = _bstrDataFld = NULL;
    
    return S_OK;
}


//+-------------------------------------------------------------------------
// Member:              GetDLCursor (CTableConsumer, public)
//
// Synopsis:    return my DLCursor

HRESULT
CTableConsumer::GetDLCursor(CDataLayerCursor **pdlc)
{
    Assert(pdlc);
    *pdlc = _pdlcCursor;
    return _pdlcCursor ? S_OK : E_FAIL;
}


//+-------------------------------------------------------------------------
// Member:              GetDataSrcAndFld (CTableConsumer, public)
//
// Synopsis:    return my full dataSrc and dataFld

HRESULT
CTableConsumer::GetDataSrcAndFld(BSTR *pbstrDataSrc, BSTR *pbstrDataFld)
{
    HRESULT hr;
    BSTR bstrDataSrc, bstrDataFld = NULL;   // this is just to appease the LINT
    
    hr = FormsAllocString(_bstrDataSrc, &bstrDataSrc);
    if (!hr)
    {
        hr = FormsAllocString(_bstrDataFld, &bstrDataFld);
        if (hr)
            FormsFreeString(bstrDataSrc);
    }

    if (!hr)
    {
        *pbstrDataSrc = bstrDataSrc;
        *pbstrDataFld = bstrDataFld;
    }
    else
    {
        *pbstrDataSrc = NULL;
        *pbstrDataFld = NULL;
    }
        
    
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
// Member:              FireOnDataReady (CTableConsumer, public)
//
// Synopsis:    tell my element the data's ready to eat

void
CTableConsumer::FireOnDataReady(BOOL fReady)
{
    CElement *pelConsumer = GetElementConsumer();

    Assert(pelConsumer->GetDBindMethods());
    pelConsumer->GetDBindMethods()->OnDataReady(pelConsumer, fReady);
}


/////-------------------------------------------------------------------/////
/////                   CCurrentRecordConsumer                          /////
/////-------------------------------------------------------------------/////

MtDefine(CCurrentRecordConsumer, DataBind, "CCurrentRecordConsumer")

class CCurrentRecordConsumer: public CDataSourceBinder::CConsumer
{
    typedef CDataSourceBinder::CConsumer super;
public:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(CCurrentRecordConsumer))
    CCurrentRecordConsumer(CDataSourceBinder *pBinder) : super(pBinder) {}
    virtual HRESULT Bind();
    virtual HRESULT UnBind();
    virtual void    FireOnDataReady(BOOL fReady);
    virtual ~CCurrentRecordConsumer() {}
};


//+-------------------------------------------------------------------------
// Member:              Bind (CCurrentRecordConsumer, public)
//
// Synopsis:    set up the desired binding

HRESULT
CCurrentRecordConsumer::Bind()
{
    HRESULT hr;
    CDataSourceProvider *pProvider = GetProvider();
    CElement *pelConsumer = GetElementConsumer();
    CCurrentRecordInstance *pCRI = 0;
    CRecordInstance *priCurrent;

    Assert(pProvider);

    // get the provider's current record instance
    hr = pProvider->QueryDataInterface(IID_ICurrentRecordInstance,
                                        (void**)&pCRI);
    if (hr)
        goto Cleanup;
    hr = pCRI->GetCurrentRecordInstance(&priCurrent);
    if (hr)
        goto Cleanup;

    // attach an Xfer to the instance
    hr = CXfer::CreateBinding(pelConsumer, IdConsumer(), NULL, pProvider, priCurrent);
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pCRI);
    return hr;
}


//+-------------------------------------------------------------------------
// Member:              UnBind (CCurrentRecordConsumer, public)
//
// Synopsis:    tear down existing binding

HRESULT
CCurrentRecordConsumer::UnBind()
{
    CElement *pelConsumer = GetElementConsumer();
    CDataBindingEvents *pdbe = pelConsumer->GetDBMembers()->GetDataBindingEvents();

    if (pdbe)
        pdbe->DetachBinding(pelConsumer, IdConsumer());

    return S_OK;
}


//+-------------------------------------------------------------------------
// Member:              FireOnDataReady (CCurrentRecordConsumer, public)
//
// Synopsis:    tell my element the data's ready to eat

void
CCurrentRecordConsumer::FireOnDataReady(BOOL fReady)
{
    // nothing to do - once we've attached the Xfer to the instance,
    // the Xfer does all the work.  [CurrentRecord consumers use
    // "push model" data binding.]
    // The function does have to be here, so that this is an instantiable
    // class.
}


/////-------------------------------------------------------------------/////
/////                        CCursorConsumer                            /////
/////-------------------------------------------------------------------/////

MtDefine(CCursorConsumer, DataBind, "CCursorConsumer")

class CCursorConsumer: public CDataSourceBinder::CConsumer
{
    typedef CDataSourceBinder::CConsumer super;
public:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(CCursorConsumer))
    CCursorConsumer(CDataSourceBinder *pBinder): super(pBinder), _pCursor(0) {}
    virtual HRESULT Bind();
    virtual HRESULT UnBind();
    virtual void    FireOnDataReady(BOOL fReady);
    virtual HRESULT GetICursor(ICursor **ppCursor);
    virtual ~CCursorConsumer() {}
private:
    ICursor     *_pCursor;      // my ICursor interface (from provider)
};


//+-------------------------------------------------------------------------
// Member:              Bind (CCursorConsumer, public)
//
// Synopsis:    set up the desired binding

HRESULT
CCursorConsumer::Bind()
{
    HRESULT hr;
    CDataSourceProvider *pProvider = GetProvider();

    Assert(pProvider);
    Assert(!_pCursor);

    // get the provider's cursor
    hr = pProvider->QueryDataInterface(IID_ICursor,
                                        (void**)&_pCursor);
    if (hr)
        goto Cleanup;

Cleanup:
    return hr;
}


//+-------------------------------------------------------------------------
// Member:              UnBind (CCursorConsumer, public)
//
// Synopsis:    tear down existing binding

HRESULT
CCursorConsumer::UnBind()
{
    return S_OK;
}


//+-------------------------------------------------------------------------
// Member:              FireOnDataReady (CCursorConsumer, public)
//
// Synopsis:    tell my element the data's ready to eat

void
CCursorConsumer::FireOnDataReady(BOOL fReady)
{
    HRESULT             hr;
    COleSite            *pOleSiteConsumer = DYNCAST(COleSite, GetElementConsumer());
    CLASSINFO           *pci= pOleSiteConsumer->GetClassInfo();
    BOOL                fBound;
    BOOL                bOwnedXfer;
    IBoundObject        *pBO = 0;
    VARIANT             var;

    Assert(pci);
    Assert(pci->dispidCursor != DISPID_UNKNOWN);

    if (!fReady)
        ClearInterface(&_pCursor);

    // See if my control supports IBoundObject
    hr = THR_NOTRACE(pOleSiteConsumer->QueryControlInterface(IID_IBoundObject,
                                                      (void **)&pBO));
    if (!hr)
    {
        // IBoundObject supported: signal the cursor is changing.
        // This will cause my control to call the COleSite::Client's
        // IBoundObjectSite::GetCursor.
        Assert(pBO);
        fBound = (_pCursor != 0);
        hr = THR(pBO->OnSourceChanged(pci->dispidCursor, fBound, &bOwnedXfer));
        if (hr)
            goto Cleanup;
    }
    else
    {
        // IBoundObject not supported: use dispatch to set consumer's Cursor
        VariantInit(&var);
        V_VT(&var) = VT_UNKNOWN;
        V_UNKNOWN(&var) = _pCursor;
        pOleSiteConsumer->CacheDispatch();
        hr = pOleSiteConsumer->SetProperty((UINT)(~0UL),
                            pci->dispidCursor, VT_UNKNOWN, &var);
        if (hr)
            goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pBO);
}


//+-------------------------------------------------------------------------
// Member:              GetICursor (CCursorConsumer, public)
//
// Synopsis:    return my ICursor - called by control's IBoundObjectSite

HRESULT
CCursorConsumer::GetICursor(ICursor **ppCursor)
{
    *ppCursor = _pCursor;
    if (_pCursor)
        _pCursor->AddRef();
    return S_OK;
}



/////-------------------------------------------------------------------/////
/////                        CDataSourceConsumer                        /////
/////-------------------------------------------------------------------/////

MtDefine(CDataSourceConsumer, DataBind, "CDataSourceConsumer")
MtDefine(CDataSourceConsumer_aryListeners_pv, CDataSourceConsumer, "CDataSourceConsumer::_aryListeners::_pv")

class CDataSourceConsumer: public CDataSourceBinder::CConsumer, public DataSource
{
    typedef CDataSourceBinder::CConsumer super;
public:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(CDataSourceConsumer))
    CDataSourceConsumer(CDataSourceBinder *pBinder):
        super(pBinder), _fPropertySet(FALSE), _aryListeners(Mt(CDataSourceConsumer_aryListeners_pv)) {}
    virtual HRESULT Bind();
    virtual HRESULT UnBind();
    virtual void    FireOnDataReady(BOOL fReady);
    virtual void    Passivate();

    // IUnknown members
    ULONG   STDMETHODCALLTYPE AddRef() { return super::AddRef(); }
    ULONG   STDMETHODCALLTYPE Release() { return super::Release(); }
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppv);

    // DataSource members
    HRESULT STDMETHODCALLTYPE getDataMember(DataMember bstrDM, REFIID riid, IUnknown** ppunk);
    HRESULT STDMETHODCALLTYPE getDataMemberName(long lIndex, DataMember* pbstrDM);
    HRESULT STDMETHODCALLTYPE getDataMemberCount(long* plCount);
    HRESULT STDMETHODCALLTYPE addDataSourceListener(DataSourceListener* pDSL);
    HRESULT STDMETHODCALLTYPE removeDataSourceListener(DataSourceListener* pDSL);

private:
    CPtrAry<DataSourceListener *>  _aryListeners;  // DataSource Listeners
    unsigned    _fPropertySet:1;    // true if I've pushed myself into control's property
};


//+-------------------------------------------------------------------------
// Member:              Bind (CDataSourceConsumer, public)
//
// Synopsis:    set up the desired binding

HRESULT
CDataSourceConsumer::Bind()
{
    HRESULT hr = S_OK;

    if (!_fPropertySet)
    {
        // first time - push myself into control's DataSource property
        VARIANT var;
        IUnknown *punkThis = (IUnknown*)(DataSource*)this;

        CElement *pelConsumer = GetElementConsumer();
        LONG id = IdConsumer();
        const CDBindMethods *pdbm = pelConsumer->GetDBindMethods();

        VariantInit(&var);
        V_VT(&var) = VT_UNKNOWN;
        V_UNKNOWN(&var) = punkThis;
        punkThis->AddRef();
        hr = pdbm->BoundValueToElement(pelConsumer, id, /* fHTML */ FALSE,
                                       &var);
        VariantClear(&var);
        if (hr)
            goto Cleanup;
        _fPropertySet = TRUE;

        // Databinding should not save undo information
        pelConsumer->Doc()->FlushUndoData();
    }
    else
    {
        // already connected - notify listeners that data member is changed
        for (int i=_aryListeners.Size()-1; i>=0; --i)
        {
            _aryListeners[i]->dataMemberChanged(NULL);
        }
    }

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
// Member:              UnBind (CDataSourceConsumer, public)
//
// Synopsis:    tear down existing binding

HRESULT
CDataSourceConsumer::UnBind()
{
    // nothing to do.
    // It may seem tempting to notify my listeners that the data member has changed,
    // but we shouldn't do that until Bind() is called.  When the provider is
    // changing, UnBind() is followed by Bind();  the notification should happen
    // during Bind() because most likely the listeners are going to immediately
    // call GetDataMember, and we want to be hooked up to the new provider when
    // that happens.
    //
    // The only other time UnBind() is called is while shutting down the binding
    // completely, in which case there's no point in notifying the listeners.

    return S_OK;
}


//+-------------------------------------------------------------------------
// Member:              FireOnDataReady (CDataSourceConsumer, public)
//
// Synopsis:    tell my element the data's ready to eat

void
CDataSourceConsumer::FireOnDataReady(BOOL fReady)
{
    // nothing to do.  Function exists so class can instantiate.
}


//+-------------------------------------------------------------------------
// Member:              Passivate (CDataSourceConsumer, public)
//
// Synopsis:    release my resources

void
CDataSourceConsumer::Passivate()
{
    // release my listeners.  Array is deleted/freed in destructor.
    for (int i=_aryListeners.Size()-1; i>=0; --i)
    {
        _aryListeners[i]->Release();
    }

    super::Passivate();
}


//+-------------------------------------------------------------------------
// Member:              QueryInterface (CDataSourceConsumer, IUnknown, public)
//
// Synopsis:    return desired interface

HRESULT
CDataSourceConsumer::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr;
    IUnknown *punk = 0;

    if (IsEqualIID(riid, IID_DataSource))
    {
        punk = (DataSource*) this;
    }
    else if (IsEqualIID(riid, IID_IUnknown))
    {
        punk = (IUnknown*)(DataSource*)this;
    }

    if (punk)
    {
        punk->AddRef();
        hr = S_OK;
    } else
        hr = E_NOINTERFACE;

    *ppv = punk;
    return hr;
}


//+-------------------------------------------------------------------------
// Member:              getDataMember (CDataSourceConsumer, DataSource, public)
//
// Synopsis:    return desired data-transfer interface

HRESULT
CDataSourceConsumer::getDataMember(DataMember bstrDM, REFIID riid, IUnknown** ppunk)
{
    HRESULT hr = E_NOINTERFACE;
    IUnknown *punkInterface = 0;
    CDataSourceProvider *pProvider = GetProvider();

    if (IsEqualIID(riid, IID_IUnknown))
    {
        switch (DYNCAST(COleSite, GetElementConsumer())->OlesiteTag())
        {
        case COleSite::OSTAG_ACTIVEX:
            hr = pProvider->QueryDataInterface(IID_IRowPosition, (void**)&punkInterface);
            break;

        case COleSite::OSTAG_APPLET:
            hr = pProvider->QueryDataInterface(IID_IADORecordset15, (void**)&punkInterface);
            break;
        }
    }
    else
    {
        hr = pProvider->QueryDataInterface(riid, (void**)&punkInterface);
    }

    // if the provider returns E_NOINTERFACE, we'll just say we have no data
    if (hr == E_NOINTERFACE)
    {
        hr = S_OK;
        Assert(punkInterface == NULL);
    }
    
    if (!hr && punkInterface)
    {
        *ppunk = punkInterface;
    }

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
// Member:              getDataMemberName (CDataSourceConsumer, DataSource, public)
//
// Synopsis:    return name of given data member

HRESULT
CDataSourceConsumer::getDataMemberName(long lIndex, DataMember* pbstrDM)
{
    return E_NOTIMPL;       // we return Count=0, so this should never get called
}


//+-------------------------------------------------------------------------
// Member:              getDataMemberCount (CDataSourceConsumer, DataSource, public)
//
// Synopsis:    return number of data members

HRESULT
CDataSourceConsumer::getDataMemberCount(long* plCount)
{
    if (plCount)
        *plCount = 0;
    return S_OK;
}


//+-------------------------------------------------------------------------
// Member:              addDataSourceListener (CDataSourceConsumer, DataSource, public)
//
// Synopsis:    add a DataSourceListener to my notification list

HRESULT
CDataSourceConsumer::addDataSourceListener(DataSourceListener* pDSL)
{
    if (pDSL)
    {
        pDSL->AddRef();
        _aryListeners.Append(pDSL);
    }

    return S_OK;
}


//+-------------------------------------------------------------------------
// Member:              removeDataSourceListener (CDataSourceConsumer, DataSource, public)
//
// Synopsis:    remove a DataSourceListener from my notification list

HRESULT
CDataSourceConsumer::removeDataSourceListener(DataSourceListener* pDSL)
{
    int i = _aryListeners.Find(pDSL);
    if (i>=0)
    {
        _aryListeners[i]->Release();
        _aryListeners.Delete(i);
    }

    return S_OK;
}


//+-------------------------------------------------------------------------
// Member:              Release (CConsumer, IUnknown, public)
//
// Synopsis:    decrease refcount, passivate and die if 0

ULONG
CDataSourceBinder::CConsumer::Release()
{
    ULONG ulRefs = --_ulRefs;

    if (_ulRefs == 0)
    {
        _ulRefs = ULREF_IN_DESTRUCTOR;
        Passivate();
        delete this;
    }

    return ulRefs;
}


//+-------------------------------------------------------------------------
// Member:              Create (CConsumer, static public)
//
// Synopsis:    factory method - create a consumer

HRESULT
CDataSourceBinder::CConsumer::Create(CDataSourceBinder *pBinder,
                                     CConsumer **ppConsumer)
{
    CElement *pelConsumer = pBinder->GetElementConsumer();
    LONG id = pBinder->IdConsumer();
    HRESULT hr = S_OK;
    CConsumer *pConsumer = NULL;

    Assert(pelConsumer && ppConsumer);

    switch (CDBindMethods::DBindKind(pelConsumer, id, NULL))
    {
    case DBIND_SINGLEVALUE:
        pConsumer = new CCurrentRecordConsumer(pBinder);
        break;

    case DBIND_IDATASOURCE:
        pConsumer = new CDataSourceConsumer(pBinder);
        break;

    case DBIND_ICURSOR:
        pConsumer = new CCursorConsumer(pBinder);
        break;

    case DBIND_IROWSET:
        pConsumer = new CNullConsumer(pBinder);
        break;

    case DBIND_TABLE:
        pConsumer = new CTableConsumer(pBinder);
        break;

    default:
        pConsumer = new CNullConsumer(pBinder);
        break;
    }

    if (!pConsumer)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

Cleanup:
    *ppConsumer = pConsumer;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\dbind\bmkcoll.cxx ===
#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_BMKCOLL_H_
#define X_BMKCOLL_H_
#include "bmkcoll.hxx"
#endif

#ifndef X_ADO_ADOID_H_
#define X_ADO_ADOID_H_
#include <adoid.h>
#endif

#ifndef X_ADO_ADOINT_H_
#define X_ADO_ADOINT_H_
#include <adoint.h>
#endif

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include "binder.hxx"
#endif

#define _cxx_
#include "bmkcoll.hdl"

EXTERN_C const GUID CLSID_HTMLDocument;
typedef Recordset15 IADORecordset;    // beats me why ADO doesn't use I...
typedef ADORecordsetConstruction IADORecordsetConstruction;

MtDefine(CBookmarkCollection, ObjectModel, "CBookmarkCollection");
MtDefine(CBookmarkCollection_aryBookmarks_pv, CBookmarkCollection, "CBookmarkCollection::_aryBookmarks::_pv");


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//      CBookmarkCollection
//
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+----------------------------------------------------------------
//
//  member : classdesc
//
//+----------------------------------------------------------------

const CBase::CLASSDESC CBookmarkCollection::s_classdesc =
{
    &CLSID_HTMLDocument,            // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLBookmarkCollection,   // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};


//+---------------------------------------------------------------
//
//  Member  : CBookmarkCollection::~CBookmarkCollection (destructor)
//
//  Synopsis : Release all the variants
//
//----------------------------------------------------------------

CBookmarkCollection::~CBookmarkCollection()
{
    VARIANT *pVar;
    int i;

    for (pVar=_aryBookmarks, i=_aryBookmarks.Size();  i>0;  ++pVar, --i)
    {
        VariantClear(pVar);
    }
    _aryBookmarks.DeleteAll();
}


//+---------------------------------------------------------------
//
//  Member  : CBookmarkCollection::Init
//
//  Synopsis : Convert a list of HROWs to ADO bookmarks, and use these
//             to fill the collection.
//
//----------------------------------------------------------------

HRESULT
CBookmarkCollection::Init(const HROW *rghRows, ULONG cRows, IADORecordset *pADO)
{
    HRESULT hr = S_OK;
    _ADORecordset *pADOClone = NULL;
    IADORecordsetConstruction *pADOConstruction = NULL;
    IRowPosition *pRowPos = NULL;
    const HROW *pHRow;
    HCHAPTER hChapter = DB_NULL_HCHAPTER;
    HROW hrow = DB_NULL_HROW;
    DWORD dwFlags;
    VARIANT varBmk;

    // get a copy of the recordset, so as not to disturb currency on the main one
    hr = pADO->_xClone(&pADOClone);

    // get the row position from the clone, and get its chapter
    if (!hr)
        hr = pADOClone->QueryInterface(IID_IADORecordsetConstruction,
                                       (void**)&pADOConstruction);
    if (!hr)
        hr = pADOConstruction->get_RowPosition((IUnknown**)&pRowPos);
    if (!hr)
        hr = pRowPos->GetRowPosition(&hChapter, &hrow, &dwFlags);

    // get room for the variants that hold the bookmarks
    Assert(_aryBookmarks.Size() == 0);
    if (!hr)
        hr = _aryBookmarks.EnsureSize(cRows);
    if (hr)
        goto Cleanup;

    // get an ADO bookmark for each row, and add it to the array
    VariantInit(&varBmk);
    for (pHRow = rghRows; cRows > 0; --cRows, ++pHRow)
    {
        hr = pRowPos->ClearRowPosition();
        if (!hr)
            hr = pRowPos->SetRowPosition(hChapter, *pHRow, DBPOSITION_OK);
        if (!hr)
            hr = pADOClone->get_Bookmark(&varBmk);
        if (!hr && V_VT(&varBmk) != VT_EMPTY)
        {
            VARIANT *pVar = NULL;
            hr = _aryBookmarks.AppendIndirect(NULL, &pVar);
            if (!hr && pVar)
            {
                VariantCopy(pVar, &varBmk);
            }
            VariantClear(&varBmk);
        }
    }

    hr = S_OK;      // clamp any errors found while building the array

Cleanup:
    ReleaseChapterAndRow(hChapter, hrow, pRowPos);
    ReleaseInterface(pRowPos);
    ReleaseInterface(pADOConstruction);
    ReleaseInterface(pADOClone);
    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member  : CBookmarkCollection::PrivateQueryInterface
//
//  Synopsis : Vanilla implementation for this class
//
//----------------------------------------------------------------

HRESULT
CBookmarkCollection::PrivateQueryInterface(REFIID iid, void **ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *)this, IUnknown)
        QI_INHERITS(this, IDispatch)
        QI_TEAROFF(this, IObjectIdentity, NULL)
    default:
        if (iid == IID_IHTMLBookmarkCollection)
        {
           *ppv = (IHTMLBookmarkCollection *) this;
        }
    }

    if (*ppv)
    {
        ((IUnknown*)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//+---------------------------------------------------------------
//
//  Member  : CBookmarkCollection::length
//
//  Sysnopsis : IHTMLBookmarkCollection interface method
//
//----------------------------------------------------------------

HRESULT
CBookmarkCollection::get_length(long * pLength)
{
    HRESULT hr = S_OK;

    if (!pLength)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pLength = _aryBookmarks.Size();

Cleanup:
    RRETURN( SetErrorInfo( hr ));

}


//+---------------------------------------------------------------
//
//  Member  : CBookmarkCollection::item
//
//  Sysnopsis : IHTMLBookmarkCollection interface method
//
//----------------------------------------------------------------

HRESULT
CBookmarkCollection::item(long lIndex, VARIANT *pVarBookmark)
{
    HRESULT hr = S_OK;

    if (!pVarBookmark)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (lIndex < 0 || lIndex >= _aryBookmarks.Size())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = VariantCopy(pVarBookmark, &_aryBookmarks[lIndex]);

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}


//+---------------------------------------------------------------
//
//  Member  : CBookmarkCollection::_newEnum
//
//  Sysnopsis : IHTMLBookmarkCollection interface method
//
//----------------------------------------------------------------

HRESULT
CBookmarkCollection::get__newEnum(IUnknown ** ppEnum)
{
    HRESULT hr = S_OK;

    if (!ppEnum)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppEnum = NULL;

    hr = THR(_aryBookmarks.EnumVARIANT(VT_I4,
                                (IEnumVARIANT**)ppEnum,
                                FALSE,
                                FALSE));

Cleanup:
    RRETURN(SetErrorInfo( hr ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\dbind\currec.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1996-1997
//  All rights Reserved.
//  Information contained herein is Proprietary and Confidential.
//
//  Contents:   Current Record Instance objects
//
//  History:    10/1/96     (sambent) created

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include "binder.hxx"
#endif

#ifndef X_ROWBIND_HXX_
#define X_ROWBIND_HXX_
#include "rowbind.hxx"
#endif

#ifndef X_OLEDBERR_H_
#define X_OLEDBERR_H_
#include <oledberr.h>
#endif

/////////////////////////////////////////////////////////////////////////////
/////                 CCurrentRecordInstance methods                    /////
/////////////////////////////////////////////////////////////////////////////


//+-------------------------------------------------------------------------
// Member:      constructor (public)
//
// Synopsis:    initialize to dormant state

CCurrentRecordInstance::CCurrentRecordInstance():
    _ulRefCount(1), _priCurrent(0), _hrow(0)
{
}


//+-------------------------------------------------------------------------
// Member:      Init (public)
//
// Synopsis:    Associate my record instance with a RowPosition
//
// Arguments:   pRowPos     RowPosition to attach
//
// Returns:     HRESULT

HRESULT
CCurrentRecordInstance::Init(CDataSourceProvider *pProvider, IRowPosition *pRowPos)
{
    Assert("must be passive to attach" && !_priCurrent);
    Assert("need provider" && pProvider);

    HRESULT hr = S_OK;
    IConnectionPointContainer *pCPC = 0;

    // remember my owner
    _pProvider = pProvider;
    
    // hold on to the RowPosition (let go in Detach)
    _pRowPos = pRowPos;

    if (_pRowPos)
    {
        _pRowPos->AddRef();
        
        // sink notifications from the RowPosition
        hr = _pRowPos->QueryInterface(IID_IConnectionPointContainer,
                                               (void **)&pCPC );
        if (hr)
            goto Cleanup;
        hr = pCPC->FindConnectionPoint(IID_IRowPositionChange, &_pCP);
        if (hr)
            goto Cleanup;
        hr = _pCP->Advise(this, &_dwAdviseCookie);
        if (hr)
        {
            ClearInterface(&_pCP);
            goto Cleanup;
        }
    }
        
Cleanup:
    ReleaseInterface(pCPC);
    return hr;
}


//+-------------------------------------------------------------------------
// Member:      InitChapter (public)
//
// Synopsis:    Hook up to a new chapter
//
// Arguments:   hChapter        chapter to attach
//
// Returns:     HRESULT

HRESULT
CCurrentRecordInstance::InitChapter(HCHAPTER hChapter)
{
    IRowset *pRowset = 0;
    HRESULT hr = E_FAIL;

    _hChapter = hChapter;

    Assert(_pProvider);
    hr = _pProvider->QueryDataInterface(IID_IRowset, (void**)&pRowset);
    if (hr)
        goto Cleanup;
    
    // get a DLCursor
    if (_pDLC)
    {
        _pDLC->Release();
    }
    _pDLC = new CDataLayerCursor(this);
    if (!_pDLC)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
    // attach DLCursor to the rowset, don't filter notifications to the chapter
    hr = _pDLC->Init(pRowset, _hChapter, CDataLayerCursor::DLC_SinkNotifications);
    if (hr)
        goto Cleanup;

    // set up the current record instance
    if (_priCurrent)
    {
        _priCurrent->Detach(TRUE);      // clear the elements first
        delete _priCurrent;
    }
    _priCurrent = new CRecordInstance(_pDLC, _hrow);
    if (!_priCurrent)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

Cleanup:
    ReleaseInterface(pRowset);
    return hr;
}


//+-------------------------------------------------------------------------
// Member:      InitPosition (public)
//
// Synopsis:    Initialize the position of my underlying RowPos
//
// Returns:     HRESULT

HRESULT
CCurrentRecordInstance::InitPosition(BOOL fFireRowEnter)
{
    if (!_pRowPos)
        goto Cleanup;

    IGNORE_HR(InitCurrentRow());
    
    // grab the current HROW
    IGNORE_HR(OnRowPositionChange(DBREASON_ROWSET_FETCHPOSITIONCHANGE,
                                  DBEVENTPHASE_SYNCHAFTER,
                                  TRUE));

    if (fFireRowEnter)
    {
        _pProvider->FireDelayedRowEnter();
    }
    
Cleanup:
    return S_OK;
}


//+-------------------------------------------------------------------------
// Member:      Passivate (private, called by Release())
//
// Synopsis:    return to pre-init state
//
// Arguments:   none
//
// Returns:     HRESULT

HRESULT
CCurrentRecordInstance::Passivate()
{
    Assert("call Detach before Passivate" && !_priCurrent);

    if (_pDLC)
    {
        _pDLC->Release();
        _pDLC = NULL;
    }

    return S_OK;
}


//+-------------------------------------------------------------------------
// Member:      Detach (public)
//
// Synopsis:    Disassociate from my RowPosition
//
// Arguments:   none
//
// Returns:     HRESULT

HRESULT
CCurrentRecordInstance::Detach()
{
    HRESULT hr = S_OK;

    // stop listening for events
    if (_pCP)
    {
        IGNORE_HR(_pCP->Unadvise(_dwAdviseCookie));
        ClearInterface(&_pCP);
    }

    // let go of current row
    if (_hrow != DB_NULL_HROW)
    {
        _pDLC->ReleaseRows(1, &_hrow);
        _hrow = DB_NULL_HROW;
    }

    // let go of the RowPosition
    ClearInterface(&_pRowPos);

    // let go of my current record
    if (_priCurrent)
    {
        _priCurrent->Detach();
        delete _priCurrent;
        _priCurrent = 0;
    }

    // release the cursor
    if (_pDLC)
    {
        _pDLC->Release();
        _pDLC = NULL;
    }
    
    return hr;
}


//+-------------------------------------------------------------------------
// Member:      Get Current Record Instance (public)
//
// Synopsis:    return pointer to my record instance
//
// Arguments:   ppRecInstance   where to store the pointer
//
// Returns:     HRESULT

HRESULT
CCurrentRecordInstance::GetCurrentRecordInstance(CRecordInstance **ppRecInstance)
{
    Assert("nowhere to store pointer" && ppRecInstance);
    *ppRecInstance = _priCurrent;
    return S_OK;
}


//+-------------------------------------------------------------------------
// Member:      Release (public, IUnknown)
//
// Synopsis:    decrease refcount, go away when it hits zero
//
// Arguments:   none
//
// Returns:     new refcount

ULONG
CCurrentRecordInstance::Release()
{
    HRESULT hr;
    ULONG ulRefCount = --_ulRefCount;
    if (ulRefCount == 0) {
        hr = Passivate();
        delete this;
    }
    return ulRefCount;
}


//+-------------------------------------------------------------------------
// Member:      Query Interface (public, IUnknown)
//
// Synopsis:    return desired interface pointer
//
// Arguments:   riid        IID of desired interface
//              ppv         where to store the pointer
//
// Returns:     HRESULT

HRESULT
CCurrentRecordInstance::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr;
    IUnknown *punkReturn = 0;

    // check for bad arguments
    if (!ppv)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // look for interfaces I support
    if (    IsEqualIID(riid, IID_IUnknown)
        ||  IsEqualIID(riid, IID_ICurrentRecordInstance)
        ||  IsEqualIID(riid, IID_IRowPositionChange)
        )
    {
        punkReturn = this;          // return addref'd copy
        punkReturn->AddRef();
        *ppv = punkReturn;
        hr = S_OK;
    }
    else
        hr = E_NOINTERFACE;

Cleanup:
    return hr;        
}


//+-------------------------------------------------------------------------
// Member:      On Row Position Change (public, IRowPositionChange)
//
// Synopsis:    sink notification from RowPosition object, adjust
//              my record instance accordingly.
//
// Arguments:   eReason     reason we're being notified
//              ePhase      which notification phase
//              fCantDeny   true if I can't veto the event
//
// Returns:     HRESULT

HRESULT
CCurrentRecordInstance::OnRowPositionChange(DBREASON eReason, DBEVENTPHASE ePhase,
                            BOOL fCantDeny)
{
    HRESULT hr;
    HCHAPTER hchapter;
    DBPOSITIONFLAGS dwPositionFlags;

    hr = _pDLC->CheckCallbackThread();
    if (hr)
        goto Cleanup;
    
    switch (ePhase)
    {
    case DBEVENTPHASE_OKTODO:
        // if we're in act of deleting current record, don't bother
        //  checking if Ok to change HROW.
        if (_dlbDeleted.IsNull())
        {
            hr = _priCurrent->OkToChangeHRow();
        }
        break;
    
    case DBEVENTPHASE_ABOUTTODO:        // position is changing, release HROW
        _pDLC->ReleaseRows(1, &_hrow);
        _hrow = DB_NULL_HROW;
        break;

    case DBEVENTPHASE_FAILEDTODO:
    case DBEVENTPHASE_SYNCHAFTER:       // position changed, get new HROW
        if (_hrow == DB_NULL_HROW)
        {
            _pRowPos->GetRowPosition(&hchapter, &_hrow, &dwPositionFlags);
            
            if (hchapter == _hChapter)
            {
                _priCurrent->SetHRow(_hrow);
            }
            else
            {
                // chapter changes are handled elsewhere.  If the chapter is
                // changing, I'm about to die anyway.
                Assert(eReason == DBREASON_ROWPOSITION_CHAPTERCHANGED);
            }
            
            ReleaseChapterAndRow(hchapter, DB_NULL_HROW, _pRowPos);
        }
        break;
    }

Cleanup:
    return hr;
}


//+-------------------------------------------------------------------------
// Member:      All Changed (public, CDataLayerCursorEvents)
//
// Synopsis:    /*[synopsis]*/
//
// Arguments:   none
//
// Returns:     /*[returns]*/

HRESULT
CCurrentRecordInstance::AllChanged()
{
    return DB_S_UNWANTEDREASON;
}


//+-------------------------------------------------------------------------
// Member:      Rows Changed (public, CDataLayerCursorEvents)
//
// Synopsis:    if my HROW has changed, update my Record Instance
//
// Arguments:   cRows       count of changed rows
//              ahRows      HROW for each changed row
//
// Returns:     S_OK

HRESULT
CCurrentRecordInstance::RowsChanged(DBCOUNTITEM cRows, const HROW *ahRows)
{
    for (ULONG k=0; k<cRows; ++k)
    {
        if (_pDLC->IsSameRow(_hrow, ahRows[k]))
        {
            _priCurrent->SetHRow(ahRows[k]);
        }
    }
    return S_OK;
}


//+-------------------------------------------------------------------------
// Member:      Fields Changed (public, CDataLayerCursorEvents)
//
// Synopsis:    if my HROW is the changed one, notify my Record Instance
//
// Arguments:   hRows       the changed HROW
//              cColumns    count of changed columns
//              aColumns    index of each changed column
//
// Returns:     S_OK

HRESULT
CCurrentRecordInstance::FieldsChanged(HROW hRow, DBORDINAL cColumns, DBORDINAL aColumns[])
{
    HRESULT hr;
    hr = _priCurrent->OnFieldsChanged(hRow, cColumns, aColumns);
    return hr;
}


//+-------------------------------------------------------------------------
// Member:      Rows Inserted (public, CDataLayerCursorEvents)
//
// Synopsis:    /*[synopsis]*/
//
// Arguments:   cRows       count of inserted rows
//              ahRows      HROW of each inserted row
//
// Returns:     /*[returns]*/

HRESULT
CCurrentRecordInstance::RowsInserted(DBCOUNTITEM cRows, const HROW *ahRows)
{
    return DB_S_UNWANTEDREASON;
}


//+-------------------------------------------------------------------------
// Member:      Deleting Rows (public, CDataLayerCursorEvents)
//
// Synopsis:    notification that rows are about to be deleted.  If one of them
//              is my current row, get a bookmark for it.
//
// Arguments:   cRows       count of deleted rows
//              ahRows      HROW of each deleted row
//
// Returns:     S_OK

HRESULT
CCurrentRecordInstance::DeletingRows(DBCOUNTITEM cRows, const HROW *ahRows)
{
    ULONG i;
    
    // if my current record is being deleted, get a bookmark for it
    for (i=0; i<cRows; ++i)
    {
        if (_pDLC->IsSameRow(_hrow, ahRows[i]))
        {
            Assert(_dlbDeleted.IsNull());
            IGNORE_HR(_pDLC->CreateBookmark(ahRows[i], &_dlbDeleted));
            break;
        }
    }
    
    return S_OK;
}


//+-------------------------------------------------------------------------
// Member:      Rows Deleted (CDataLayerCursorEvents, public)
//
// Synopsis:    notification that rows have been deleted.  If we have a
//              bookmark, the current row was deleted.  In this case, move
//              the current row forward (or backward if already at the end).
//
// Arguments:   cRows       count of deleted rows
//              ahRows      HROW of each deleted row
//
// Returns:     S_OK

HRESULT
CCurrentRecordInstance::RowsDeleted(DBCOUNTITEM, const HROW *)
{
    DBCOUNTITEM cRows;
    HROW hrow;
    HRESULT hr;
    DBPOSITIONFLAGS dwPositionFlags = DBPOSITION_OK;
    
    if (!_dlbDeleted.IsNull())
    {
        // try moving forward
        hr = _pDLC->GetRowsAt(_dlbDeleted, 0, 1, &cRows, &hrow);

        // if that doesn't work, try moving backward
        if (FAILED(hr) || cRows==0)
            hr = _pDLC->GetRowsAt(_dlbDeleted, -1, -1, &cRows, &hrow);

        // if we didn't get a good row, use the null row
        if (FAILED(hr) || cRows==0)
        {
            hrow = DB_NULL_HROW;
            dwPositionFlags = DBPOSITION_EOF;
        }

        // set current position to the new row
        if (_pRowPos && S_OK == _pRowPos->ClearRowPosition())
            _pRowPos->SetRowPosition(_hChapter, hrow, dwPositionFlags);
        // clear the bookmark
        _dlbDeleted = CDataLayerBookmark::TheNull;

        // release the row
        _pDLC->ReleaseRows(1, &hrow);
    }

    return S_OK;
}


//+-------------------------------------------------------------------------
// Member:      DeleteCancelled (public, CDataLayerCursorEvents)
//
// Synopsis:    notification that row deletion was cancelled
//
// Arguments:   cRows       count of deleted rows
//              ahRows      HROW of each deleted row
//
// Returns:     S_OK

HRESULT
CCurrentRecordInstance::DeleteCancelled(DBCOUNTITEM cRows, const HROW *ahRows)
{
    // discard the bookmark I may have taken out during pre-notification
    _dlbDeleted = CDataLayerBookmark::TheNull;
    
    return S_OK;
}

//+-------------------------------------------------------------------------
// Member:      Rows Added (public, CDataLayerCursorEvents)
//
// Synopsis:    /*[synopsis]*/
//
// Arguments:
//
// Returns:     /*[returns]*/

HRESULT
CCurrentRecordInstance::RowsAdded()
{
    return InitCurrentRow();
}


//+-------------------------------------------------------------------------
// Member:      Population Complete (public, CDataLayerCursorEvents)
//
// Synopsis:    /*[synopsis]*/
//
// Arguments:
//
// Returns:     /*[returns]*/

HRESULT
CCurrentRecordInstance::PopulationComplete()
{
    return InitCurrentRow();
}


//+-------------------------------------------------------------------------
// Member:      InitCurrentRow (private helper)
//
// Synopsis:    set the current row, if not set already

HRESULT
CCurrentRecordInstance::InitCurrentRow()
{
    HROW hrow = DB_NULL_HROW;
    HCHAPTER hchapter = DB_NULL_HCHAPTER;
    DBPOSITIONFLAGS dwPositionFlags;

    if (!_pRowPos || !_pDLC)
        goto Cleanup;

    // if current HROW is null, move to the first row
    _pRowPos->GetRowPosition(&hchapter, &hrow, &dwPositionFlags);
    if (hrow == DB_NULL_HROW)
    {
        // Get the first row.
        if (S_OK == _pDLC->GetRowAt(CDataLayerBookmark::TheFirst, &hrow))
        {
            dwPositionFlags = DBPOSITION_OK;
        }
        else
        {
            // if there isn't one, try to set the chapter anyway
            hrow = DB_NULL_HROW;
            dwPositionFlags = DBPOSITION_NOROW;
        }
        if (S_OK == _pRowPos->ClearRowPosition())
            _pRowPos->SetRowPosition(_hChapter, hrow, dwPositionFlags);
    }

    ReleaseChapterAndRow(hchapter, hrow, _pRowPos);

Cleanup:
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\dbind\convert.cxx ===
//+---------------------------------------------------------------------------
//
//  Maintained by: Jerry, Terry and Ted
//
//  Microsoft DataDocs
//  Copyright (C) Microsoft Corporation, 1994-1996
//  All rights Reserved.
//  Information contained herein is Proprietary and Confidential.
//
//  File:       site\dbind\convert.cxx
//
//  Contents:   Core conversion code.
//
//  Classes:    CTypeCoerce
//
//  Functions:  None.
//

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DBINDING_HXX_
#define X_DBINDING_HXX_
#include "dbinding.hxx"
#endif

/////////////////////////////////////////////////////////////////////////////
//  Steps to add a new type for conversion:
//
//      1.  Add a new canonical type to CAN_TYPE list.
//
//      2.  Modify CanonicalizeType to canonicalize a new DBTYPE (VARTYPE) to
//          the CAN_TYPE value.  NOTE: Be careful of any overlap between DBTYPE
//          and VARTYPE, currently there are none.
//
//      3.  Update the JumpTable to include the address of routines to do the
//          actual conversion.
//
//      4.  Add CallStr entry for new TYPE_xxxx (convert from type to string)
//          add CallThru entry for new TYPE_xxxx.
//
//      5.  Test it.
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
//  The following the conversion matrix of database types to OLE types and
//  vice versa.
//
//
// FROM                                    TO
// ====                                    ==
//
//         Null  I2    I4    R4    R8    CY    DATE  BSTR  BOOL  VARI 
//         ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
//  Empty  *NuNu XNuI2 XNuI4 XNuR4 XNuR8 XNuCY XNuDT XNuBS XNuBO XNuVA
//  I2     XI2Nu *I2I2 XI2I4 XI2R4 XI2R8  I2CY  I2DT  I2BS  I2BO  I2VA
//  I4     XI4Nu  I4I2 *I4I4  I4R4 XI4R8  I4CY  I4DT  I4BS  I4B0  I4VA
//  R4     XR4Nu  R4I2  R4I4 *R4R4 XR4R8  R4CY  R4DT  R4BS  R4B0  R4VA
//  R8     XR8Nu  R8I2  R8I4  R8R4 *R8R8  R8CY  R8DT  R8BS  R8BO  R8VA
//  CY     XCYNu  CYI2  CYI4  CYR4  CYR8 *CYCY  CYDT  CYBS  CYBO  CYVA
//  DATE   XDTNu  DTI2  DTI4  DTR4  DTR8  DTCY *DTDT  DTBS  DTBO  DTVA
//  BSTR   XBSNu  BSI2  BSI4  BSR4  BSR8  BSCY  BSDT *BSBS  BSBP  BSVA
//  BOOL   XBONu XBOI2 XBOI4 XBOR4 XBOR8  BOCY  BODT  BOBS *BOBO  BOVA
//  VARI   XVANu  VAI2  VAI4  VAR4  VAR8  VACY  VADT  VABS  VABO *VAVA
//
//
//  Key
//  ===
//
//  *     = copy                  Nu    null
//  Xxxxx = upcast                I2    short
//                                I4    long
//                                R4    float
//                                R8    double
//                                CY    currency
//                                DATE  date
//                                BSTR  BSTR
//                                BOOL  boolean
//
// NOTE:
// =====
//
//      The above table is a static array named JumpTable located in the routine
//      ConvertData.
//
////////////////////////////////////////////////////////////////////////////////

// NO_CONVERSION  - Signals that the types are identical.
// PROCESS_UPCAST - Signals that the type can be upcast to the to type w/o worry
//                  of overflow checking.
// PROCESS_NOCALL - Signals processing must be done but the there is no routine
//                  to call.
#define NO_CONVERSION   ((void *)0)
#define PROCESS_UPCAST  ((void *)1)
#define PROCESS_NOCALL  ((void *)~0)



//+---------------------------------------------------------------------------
//
//  Member:     CanonicalizeType (public static member)
//
//  Synopsis:   Canonicalize the DBTYPE and VARTYPES.  Notice that the types
//              match one for one except for types > DBTYPE_STR which are than
//              canonicalized.
//
//              The canonicalizing is based on the values for DBTYPE_xxxx (the
//              VT_xxxx values <= 13 match exactly the DBTYPEs the VTs largest
//              value is 72).  We are interested in I2, I4, R4, R8, CY, DATE,
//              BSTR, BOOL, and VARIANT
//
//                  DBTYPE_EMPTY          0     (Remove Group 1)
//                  DBTYPE_NULL           1     (Group 1)
//                  DBTYPE_I2             2
//                  DBTYPE_I4             3
//                  DBTYPE_R4             4
//                  DBTYPE_R8             5
//                  DBTYPE_CY             6
//                  DBTYPE_DATE           7
//                  DBTYPE_BSTR           8
//                  DBTYPE_DISPATCH       9     (Remove Group 2)
//                  DBTYPE_ERROR         10     (Remove)
//                  DBTYPE_BOOL          11
//                  DBTYPE_VARIANT       12
//                  DBTYPE_UNKNOWN       13     (Remove Group 3)
//                  DBTYPE_ARRAY       8192     (Remove)
//                  DBTYPE_BYREF      16384     (Remove)
//                  DBTYPE_RESERVED   32768     (Remove)
//                  DBTYPE_UI1          128     (Remove)
//                  DBTYPE_I8            20     (Remove)
//                  DBTYPE_GUID          72     (Remove)
//                  DBTYPE_VECTOR      4096     (Remove)
//                  DBTYPE_STR          129     (Remove)
//                  DBTYPE_WSTR         130     (Remove)
//                  DBTYPE_NUMERIC      131     (Remove)
//
//  Arguments:  None
//
//  Returns:    Returns the canonical type (CAN_TYPE)
//

HRESULT
CTypeCoerce::CanonicalizeType (DBTYPE dbType, CAN_TYPE & canType)
{
    static const CAN_TYPE aTypeSimple[] =
    {
        /* DBTYPE_EMPTY     */ TYPE_END,
        /* DBTYPE_NULL      */ TYPE_NULL,
        /* DBTYPE_I2        */ TYPE_I2,
        /* DBTYPE_I4        */ TYPE_I4,
        /* DBTYPE_R4        */ TYPE_R4,
        /* DBTYPE_R8        */ TYPE_R8,
        /* DBTYPE_CY        */ TYPE_CY,
        /* DBTYPE_DATE      */ TYPE_DATE,
        /* DBTYPE_BSTR      */ TYPE_BSTR,
        /* DBTYPE_IDISPATCH */ TYPE_END,
        /* DBTYPE_ERROR     */ TYPE_END,
        /* DBTYPE_BOOL      */ TYPE_BOOL,
        /* DBTYPE_VARIANT   */ TYPE_VARIANT,
    };
    
    Assert(DBTYPE_EMPTY == 0);
    Assert(DBTYPE_NULL == DBTYPE_EMPTY+1);
    Assert(DBTYPE_I2 == DBTYPE_NULL + 1);
    Assert(DBTYPE_I4 == DBTYPE_I2 + 1);
    Assert(DBTYPE_R4 == DBTYPE_I4 + 1);
    Assert(DBTYPE_R8 == DBTYPE_R4 + 1);
    Assert(DBTYPE_CY == DBTYPE_R8 + 1);
    Assert(DBTYPE_DATE == DBTYPE_CY + 1);
    Assert(DBTYPE_BSTR == DBTYPE_DATE + 1);
    Assert(DBTYPE_IDISPATCH == DBTYPE_BSTR + 1);
    Assert(DBTYPE_ERROR == DBTYPE_IDISPATCH + 1);
    Assert(DBTYPE_BOOL == DBTYPE_ERROR + 1);
    Assert(DBTYPE_VARIANT == DBTYPE_BOOL + 1);
    Assert(DBTYPE_IUNKNOWN == DBTYPE_VARIANT + 1);
    Assert(DBTYPE_WSTR >  DBTYPE_IUNKNOWN);
    Assert(DBTYPE_HCHAPTER >  DBTYPE_IUNKNOWN);
    

    HRESULT     hr = S_OK;
    
    canType = TYPE_END;
    
    if (dbType < ARRAY_SIZE(aTypeSimple))
    {
        canType = aTypeSimple[dbType];
    }
    else if (dbType == DBTYPE_HCHAPTER)
    {
        canType = TYPE_CHAPTER;
    }

    if (canType == TYPE_END)
    {
        hr = OLE_E_CANTCONVERT;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     BoolFromStr, private helper (static)
//
//  Synopsis:   used instead of OLE Automation's normal VARIANTBoolFromStr
//              because OLE's conversions aren't compatible enough with
//              Netscape's javascript conversions.
//
//  Arguments:  OLECHAR *       String to convert to BOOL
//
//  Returns:    VARIANT_BOOL    VB_TRUE (0xffff) or VB_FALSE (0x0000)
//                              (be careful, VARIANT_BOOLs are only 16 bits,
//                              normal Win32 Bools are 32 bits!)
//
VARIANT_BOOL
CTypeCoerce::BoolFromStr(OLECHAR *pValueIn)
{
    // The NULL string is FALSE, all other strings are TRUE
    return (pValueIn==NULL || *pValueIn==0) ? VB_FALSE : VB_TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CallStr (private static member)
//
//  Synopsis:   Call low-level OLE conversion VarBstrFromXXXX.
//
//  Arguments:  pCall   - Function to call.
//              inType  - Type of pIn
//              pIn     - Value of data
//              outType - Type of pOut
//              pOut    - Value of data
//
//  Returns:    Returns HRESULT from VarBstrFromXXXX.
//

// The generic function pointer types which CallStr uses.
typedef HRESULT (STDMETHODCALLTYPE *BstrFrmI2)(short, LCID, unsigned long, BSTR FAR*);
typedef HRESULT (STDMETHODCALLTYPE *BstrFrmI4)(long, LCID, unsigned long, BSTR FAR*);
typedef HRESULT (STDMETHODCALLTYPE *BstrFrmR4)(float, LCID, unsigned long, BSTR FAR*);
typedef HRESULT (STDMETHODCALLTYPE *BstrFrmR8)(double, LCID, unsigned long, BSTR FAR*);
typedef HRESULT (STDMETHODCALLTYPE *BstrFrmCy)(CY, LCID, unsigned long, BSTR FAR*);
typedef HRESULT (STDMETHODCALLTYPE *BstrFrmDate)(DATE, LCID, unsigned long, BSTR FAR*);
typedef HRESULT (STDMETHODCALLTYPE *BstrFrmBool)(VARIANT_BOOL, LCID, unsigned long,
                                         BSTR FAR*);

HRESULT
CTypeCoerce::CallStr (void *pCall,
                      CAN_TYPE inType, void * pIn,
                      void * pOut)
{
    HRESULT hr = E_UNEXPECTED;

    BSTR bstr = 0;

    switch (inType)
    {
        case TYPE_I2:
            Assert(pCall != PROCESS_NOCALL);
            hr = (*(BstrFrmI2)pCall) (*(short *)pIn, LOCALE_USER_DEFAULT, 0,
                                      &bstr);
            break;
        case TYPE_I4:
            Assert(pCall != PROCESS_NOCALL);
            hr = (*(BstrFrmI4)pCall) (*(long *)pIn, LOCALE_USER_DEFAULT, 0,
                                      &bstr);
            break;
        case TYPE_R4:
            Assert(pCall != PROCESS_NOCALL);
            hr = (*(BstrFrmR4)pCall) (*(float *)pIn, LOCALE_USER_DEFAULT, 0,
                                      &bstr);
            break;
        case TYPE_R8:
            Assert(pCall != PROCESS_NOCALL);
            hr = (*(BstrFrmR8)pCall) (*(double *)pIn, LOCALE_USER_DEFAULT, 0,
                                      &bstr);
            break;
        case TYPE_CY:
            Assert(pCall != PROCESS_NOCALL);
            hr = (*(BstrFrmCy)pCall) (*(CY *)pIn, LOCALE_NOUSEROVERRIDE, 0,
                                      &bstr);
            break;
        case TYPE_DATE:
            Assert(pCall != PROCESS_NOCALL);
            hr = (*(BstrFrmDate)pCall) (*(DATE *)pIn, LOCALE_USER_DEFAULT, 0,
                                        &bstr);
            break;
        case TYPE_BOOL:
            Assert(pCall != PROCESS_NOCALL);
            // We actually ignore what's in the table and special case this
            // to do sort of Netscape compatible conversions.
#ifdef NEVER            
            // THIS CODE IS IFDEF'D NEVER UNTIL WE'RE SURE PM WON'T CHANGE
            // THEIR MIND AGAIN ABOUT HOW THIS CONVERSION WORKS
            bstr =  SysAllocString(*(VARIANT_BOOL *)pIn ?
                                   _T("true") : NULL);
            // TODO:: Should we consider trying to detect a rather
            // unlikely E_NOMEMORY on allocating "true", here?
            hr = S_OK;
#else
            hr = VarBstrFromBool(*(VARIANT_BOOL *)pIn, LOCALE_USER_DEFAULT, 0, &bstr);
#endif
            break;
        default:
            Assert(!"In type is unknown, or conversion unnecessary!");
    }

    if (!hr)
    {
        *(BSTR *)pOut = bstr;
    }

    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CallThru (private static member)
//
//  Synopsis:   Call low-level OLE conversion VarXXXXFromXXXX where the to type
//              is never Bstr.
//
//  Arguments:  pCall   - Function to call.
//              inType  - Type of pIn
//              pIn     - Value of data
//              pOut    - Value of data
//
//  Returns:    Returns HRESULT from VarXXXXFromXXXX.
//

// The generic function pointer types which CallThru uses.
typedef HRESULT (STDMETHODCALLTYPE *FromI2)(short, void *);
typedef HRESULT (STDMETHODCALLTYPE *FromI4)(long, void *);
typedef HRESULT (STDMETHODCALLTYPE *FromR4)(float, void *);
typedef HRESULT (STDMETHODCALLTYPE *FromR8)(double, void *);
typedef HRESULT (STDMETHODCALLTYPE *FromDate)(DATE, void *);
typedef HRESULT (STDMETHODCALLTYPE *FromCy)(CY, void *);
typedef HRESULT (STDMETHODCALLTYPE *FromBool)(VARIANT_BOOL, void *);
typedef HRESULT (STDMETHODCALLTYPE *FromBStr)(OLECHAR *, LCID, unsigned long, void *);

HRESULT
CTypeCoerce::CallThru (void * pCall, CAN_TYPE inType, void * pIn, void * pOut)
{
    Assert(pCall && pCall != PROCESS_NOCALL);

    HRESULT hr;

    switch (inType)
    {
        case TYPE_I2:
            hr = (*(FromI2)pCall) (*(short *)pIn, pOut);
            break;
        case TYPE_I4:
            hr = (*(FromI4)pCall) (*(int *)pIn, pOut);
            break;
        case TYPE_R4:
            hr = (*(FromR4)pCall) (*(float *)pIn, pOut);
            break;
        case TYPE_R8:
            hr = (*(FromR8)pCall) (*(double *)pIn, pOut);
            break;
        case TYPE_CY:
            hr = (*(FromCy)pCall) (*(CY *)pIn, pOut);
            break;
        case TYPE_DATE:
            hr = (*(FromDate)pCall) (*(DATE *)pIn, pOut);
            break;
        case TYPE_BSTR:
            hr = (*(FromBStr)pCall) (*(BSTR *)pIn, LOCALE_USER_DEFAULT, 0,
                                     pOut);
            break;
        case TYPE_BOOL:
            hr = (*(FromBool)pCall) (*(VARIANT_BOOL *)pIn, pOut);
            break;
        default:
            Assert(!"In type is unknown.");
            hr = OLE_E_CANTCONVERT;
    }

    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     ConvertData (public static member)
//
//  Synopsis:   Given two buffer and type pairs convert the input type to the
//              output type.
//
//  Arguments:  typeIn      - type of data in input buffer
//              pValueIn    - input buffer (data to convert)
//              typeOut     - type of data in output buffer after conversion
//              pValueOut   - output buffer (data to convert to)
//
//  Returns:    S_OK        everything is fine
//              E_xxxx      any VarNNNFromNNN low-level OLE conversion functions
//

HRESULT
CTypeCoerce::ConvertData (CAN_TYPE typeIn, void * pValueIn,
                          CAN_TYPE typeOut, void * pValueOut)
{
    // This array is static and located in this routine so it is only initial-
    // ized once -- the first time this routine is called.
    static void * JumpTable[MAX_CAN_TYPES][MAX_CAN_TYPES] =
    {
        //  *NuNu XNuI2 XNuI4 XNuR4 XNuR8 XNuCY XNuDT XNuBS XNuBO XNuVA
        {   NO_CONVERSION,   PROCESS_UPCAST,  PROCESS_UPCAST,  PROCESS_UPCAST,
            PROCESS_UPCAST,  PROCESS_UPCAST,  PROCESS_UPCAST,  PROCESS_UPCAST,
            PROCESS_UPCAST,  PROCESS_UPCAST      },

        //  XI2Nu  *I2I2 XI2I4 XI2R4 XI2R8  I2CY  I2DT  I2BS  I2BO  I2VA
        {   PROCESS_UPCAST,  NO_CONVERSION,   PROCESS_UPCAST,  PROCESS_UPCAST,
            PROCESS_UPCAST,  &VarCyFromI2,    &VarDateFromI2,  &VarBstrFromI2,
            &VarBoolFromI2,  PROCESS_UPCAST      },

        //  XI4Nu  I4I2 *I4I4  I4R4 XI4R8  I4CY  I4DT  I4BS   I4B0  I4BA
        {   PROCESS_UPCAST,  &VarI2FromI4,    NO_CONVERSION,   &VarR4FromI4,
            PROCESS_UPCAST,  &VarCyFromI4,    &VarDateFromI4,  &VarBstrFromI4,
            &VarBoolFromI4,  PROCESS_UPCAST      },

        //  XR4Nu  R4I2  R4I4 *R4R4 XR4R8  R4CY  R4DT  R4BS  R4B0  R4VA
        {   PROCESS_UPCAST,  &VarI2FromR4,    &VarI4FromR4,    NO_CONVERSION,
            PROCESS_UPCAST,  &VarCyFromR4,    &VarDateFromR4,  &VarBstrFromR4,
            &VarBoolFromR4,  PROCESS_UPCAST      } ,

        //  XR8Nu  R8I2  R8I4  R8R4 *R8R8  R8CY  R8DT  R8BS  R8BO  R8VA
        {   PROCESS_UPCAST,  &VarI2FromR8,    &VarI4FromR8,    &VarR4FromR8,
            NO_CONVERSION,   &VarCyFromR8,    &VarDateFromR8,  &VarBstrFromR8,
            &VarBoolFromR8,  PROCESS_UPCAST      },

        //  XCYNu  CYI2  CYI4  CYR4  CYR8 *CYCY  CYDT  CYBS  CYBO  CYVA
        {   PROCESS_UPCAST,  &VarI2FromCy,    &VarI4FromCy,    &VarR4FromCy,
            &VarR8FromCy,    NO_CONVERSION,   &VarDateFromCy,  &VarBstrFromCy,
            &VarBoolFromCy,  PROCESS_UPCAST      },

        //  XDTNu  DTI2  DTI4  DTR4  DTR8  DTCY *DTDT  DTBS  DTBO  DTVA
        {   PROCESS_UPCAST,  &VarI2FromDate,  &VarI4FromDate,  &VarR4FromDate,
            &VarR8FromDate,  &VarCyFromDate,  NO_CONVERSION,   &VarBstrFromDate,
            &VarBoolFromDate,PROCESS_UPCAST    },

        //  XBSNu  BSI2  BSI4  BSR4  BSR8  BSCY  BSDT *BSBS  BSBP  BSVA
        {   PROCESS_UPCAST,  &VarI2FromStr,   &VarI4FromStr,   &VarR4FromStr,
            &VarR8FromStr,   &VarCyFromStr,   &VarDateFromStr, NO_CONVERSION,
            PROCESS_UPCAST, PROCESS_UPCAST      },

        //  XBONu  XBOI2 XBOI4 XBOR4 XBOR8  BOCY  BODT  BOBS *BOBO  BOVA
        {   PROCESS_UPCAST,  PROCESS_UPCAST, PROCESS_UPCAST,  PROCESS_UPCAST,
            PROCESS_UPCAST,  &VarCyFromBool, &VarDateFromBool,&VarBstrFromBool,
            NO_CONVERSION,   PROCESS_UPCAST     },

        //  XVANu   VAI2  VAI4  VAR4  VAR8  VACY  VADT  VABS  VABO *VAVA
        {   PROCESS_UPCAST,  PROCESS_UPCAST, PROCESS_UPCAST,  PROCESS_UPCAST,
            PROCESS_UPCAST,  PROCESS_UPCAST, PROCESS_UPCAST,  PROCESS_UPCAST,
            PROCESS_UPCAST,  NO_CONVERSION       }
    };

    HRESULT     hr = OLE_E_CANTCONVERT;
    VARIANT     *pVarIn = (VARIANT *)pValueIn;
    VARIANT     *pVarOut = (VARIANT *)pValueOut;

    Assert(typeIn != TYPE_CHAPTER);
    Assert(typeOut != TYPE_CHAPTER);
    Assert(pValueIn && pValueOut);

    void * pFunc = JumpTable[typeIn][typeOut];

    // How do we convert?
    if (pFunc == PROCESS_UPCAST)
    {
        // Upcast.
        switch (typeIn)
        {
        case TYPE_NULL:
            hr = S_OK;

            switch (typeOut)
            {
            case TYPE_I2:
                *(short *)pValueOut = 0;
                break;
            case TYPE_I4:
                *(long *)pValueOut = 0;
                break;
            case TYPE_R4:
                *(float *)pValueOut = 0.0F;
                break;
            case TYPE_R8:
                *(double *)pValueOut = 0;
                break;
            case TYPE_CY:
                ((CY *)pValueOut)->Lo = 0;
                ((CY *)pValueOut)->Hi = 0;
                break;
            case TYPE_DATE:
                *(DATE *)pValueOut = 0;
                break;
            case TYPE_BSTR:
                *(BSTR *)pValueOut = 0;
                break;
            case TYPE_BOOL:
                *(VARIANT_BOOL *)pValueOut = 0;
                break;
            case TYPE_VARIANT:
                pVarOut->vt = VT_EMPTY;
                break;
            default:
                Assert(!"Can't cast this empty");
                break;            
            }
            break;
        
        case TYPE_I2:
            if (typeOut == TYPE_I4)
                *(long *)pValueOut = *(short *)pValueIn;
            else if (typeOut == TYPE_R4)
                *(float *)pValueOut = *(short *)pValueIn;
            else if (typeOut == TYPE_R8)
                *(double *)pValueOut = *(short *)pValueIn;
            else if (typeOut == TYPE_VARIANT)
            {
                pVarOut->vt = VT_I2;
                pVarOut->iVal = *(short *)pValueIn;
            }
            else if (typeOut != TYPE_NULL)
            {
                Assert(!"Can't cast this short");
                break;
            }

            hr = S_OK;
            break;

        case TYPE_I4:
            if (typeOut == TYPE_R8)
                *(double *)pValueOut = *(long *)pValueIn;
            else if (typeOut == TYPE_VARIANT)
            {
                pVarOut->vt = VT_I4;
                pVarOut->lVal = *(long *)pValueIn;
            }
            else if (typeOut != TYPE_NULL)
            {
                Assert(!"Can't cast this long");
                break;
            }

            hr = S_OK;
            break;

        case TYPE_R4:
            if (typeOut == TYPE_R8)
                *(double *)pValueOut = *(float *)pValueIn;
            else if (typeOut == TYPE_VARIANT)
            {
                pVarOut->vt = VT_R4;
                pVarOut->fltVal = *(float *)pValueIn;
            }
            else if (typeOut != TYPE_NULL)
            {
                Assert(!"Can't cast this float");
                break;
            }

            hr = S_OK;
            break;

        case TYPE_R8:
            if (typeOut == TYPE_VARIANT)
            {
                pVarOut->vt = VT_R8;
                pVarOut->dblVal = *(double *)pValueIn;
            }
            else if (typeOut != TYPE_NULL)
            {
                Assert(!"Can't cast this double");
                break;
            }

            hr = S_OK;
            break;

        case TYPE_CY:
            if (typeOut == TYPE_VARIANT)
            {
                pVarOut->vt = VT_CY;
                pVarOut->cyVal = *(CY *)pValueIn;
            }
            else if (typeOut != TYPE_NULL)
            {
                Assert(!"Can't cast this CY");
                break;
            }

            hr = S_OK;
            break;

        case TYPE_DATE:
            if (typeOut == TYPE_VARIANT)
            {
                pVarOut->vt = VT_DATE;
                pVarOut->date = *(DATE *)pValueIn;
            }
            else if (typeOut != TYPE_NULL)
            {
                Assert(!"Can't cast this date");
                break;
            }

            hr = S_OK;
            break;

        case TYPE_BSTR:
            if (typeOut == TYPE_VARIANT)
            {
                pVarOut->vt = VT_BSTR;
                pVarOut->bstrVal = *(BSTR*)pValueIn;
            }
            else if (typeOut == TYPE_BOOL)
            {
                // Special conversion rules for Checkbox-like elements
                // TODO:: 0 is probably not the proper Locale, &
                // NOUSEROVERRIDE is probably wrong.  -cfranks 27 Mar 1997
                TCHAR *pwch = *(TCHAR **)pValueIn;
                TCHAR *pwchEnd = NULL;
                TCHAR chBlank = 0;
                int iLen = FormsStringLen(pwch);

                // strip white space from both ends
                if (iLen > 0  && (IsCharBlank(pwch[0]) || IsCharBlank(pwch[iLen-1])))
                {
                    pwchEnd = pwch + iLen - 1;

                    while (IsCharBlank(*pwch))
                        ++ pwch;

                    while (pwchEnd >= pwch && IsCharBlank(*pwchEnd))
                        -- pwchEnd;

                    if (pwchEnd >= pwch)    // if string isn't all blank...
                    {
                        ++ pwchEnd;     // now points one char past last non-blank
                        chBlank = *pwchEnd;     // save terminating blank
                        *pwchEnd = (TCHAR)0;    // replace it with 0
                    }
                    else
                    {
                        pwchEnd = NULL;
                    }
                }
        
                hr = VarBoolFromStr((OLECHAR *)pwch, LOCALE_USER_DEFAULT, 0,
                               (VARIANT_BOOL *)pValueOut);
                if (hr)
                {
                    *(VARIANT_BOOL *)pValueOut = BoolFromStr((OLECHAR *)pwch);
                    hr = S_OK;
                }

                // restore terminating blank (if we replaced it)
                if (pwchEnd)
                {
                    *pwchEnd = chBlank;
                }
            }
            else if (typeOut != TYPE_NULL)
            {
                Assert(!"Can't cast this BSTR");
                break;
            }

            hr = S_OK;
            break;

        case TYPE_BOOL:
            if (typeOut == TYPE_I2)
                *(short *)pValueOut = *(VARIANT_BOOL *)pValueIn;
            else if (typeOut == TYPE_I4)
                *(long *)pValueOut = *(VARIANT_BOOL *)pValueIn;
            else if (typeOut == TYPE_R4)
                *(float *)pValueOut = *(VARIANT_BOOL *)pValueIn;
            else if (typeOut == TYPE_R8)
                *(double *)pValueOut = *(VARIANT_BOOL *)pValueIn;
            else if (typeOut == TYPE_VARIANT)
            {
                pVarOut->vt = VT_BOOL;
                pVarOut->boolVal = *(VARIANT_BOOL *)pValueIn;
            }
            else if (typeOut != TYPE_NULL)
            {
                Assert(!"Can't cast this boolean");
                break;
            }

            hr = S_OK;
            break;

        case TYPE_VARIANT:
        {
            hr = S_OK;

            if ((typeOut == TYPE_I2) && (pVarIn->vt == VT_I2))
                *(short *)pValueOut = ((VARIANT *)pValueIn)->iVal;
            else if ((typeOut == TYPE_I4) && (pVarIn->vt == VT_I4))
                *(long *)pValueOut = ((VARIANT *)pValueIn)->lVal;
            else if ((typeOut == TYPE_R4) && (pVarIn->vt == VT_R4))
                *(float *)pValueOut = ((VARIANT *)pValueIn)->fltVal;
            else if ((typeOut == TYPE_R8) && (pVarIn->vt == VT_R8))
                *(double *)pValueOut = ((VARIANT *)pValueIn)->dblVal;
            else if ((typeOut == TYPE_CY) && (pVarIn->vt == VT_CY))
                *(CY *)pValueOut = ((VARIANT *)pValueIn)->cyVal;
            else if ((typeOut == TYPE_DATE) && (pVarIn->vt == VT_DATE))
                *(DATE *)pValueOut = ((VARIANT *)pValueIn)->date;
            else if ((typeOut == TYPE_BSTR) && (pVarIn->vt == VT_BSTR))
                *(BSTR *)pValueOut = ((VARIANT *)pValueIn)->bstrVal;
            else if ((typeOut == TYPE_BOOL) && (pVarIn->vt == VT_BOOL))
                *(VARIANT_BOOL *)pValueOut = ((VARIANT *)pValueIn)->boolVal;
            else if (typeOut == TYPE_NULL)
            {
                // Do nothing.
            }
            else
            {
                // Indirect the input to convert the data in the variant to our
                // destination type.
                CAN_TYPE inType;

                hr = CanonicalizeType(pVarIn->vt, inType);
                if (!hr)
                {
                    hr = ConvertData(inType, &pVarIn->iVal, typeOut, pValueOut);
                }
            }
            break;
        }

        default:
            Assert(!"Can't cast up");
            break;
        }
    }
    else if (pFunc != NO_CONVERSION)
    {
        // We got a function adress or PROCESS_NOCALL.
        if (typeOut == TYPE_BSTR)       // BSTR?
        {
            hr = CallStr(pFunc, typeIn, pValueIn, pValueOut);
        }
        else
        {
            hr = CallThru(pFunc, typeIn, pValueIn, pValueOut);
        }
    }
    else
    {
        // pFunc == NO_CONVERSION
        Assert(!"We NEVER want to copy the same exact type \n"
                "GetValue/SetValue should have done it.");
        hr = E_INVALIDARG;
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     FVariantType
//
//  Synopsis:   Returns wehter the given DBTYPE is legal in an automation
//              VARIANT.
//
//  Arguments:  dbType  - the database type
//
//  Returns:    TRUE        OK in variant
//              FALSE       not OK in variant
//

BOOL
CTypeCoerce::FVariantType(DBTYPE dbType)
{
    // Variant.h header file show that all acceptable base types
    //   are < 0x20.
    if (dbType & ~(VT_ARRAY|VT_BYREF|0x1F))
    {
        return FALSE;
    }
    // the bitmask below was built by hand from comments in Variant.h
    //
    return ((1 << (dbType &0x1f)) & 0xcf7fff) != 0;
}


//+--------------------------------------------------------------------------
//
//  Function:   IsNearlyEqual (local helper)
//
//  Synopsis:   Determines whether two floating-point numbers are "equal"
//              within a tolerance allowing for the usual floating-point
//              vagaries (drift, loss of precision, roundoff, etc)

static BOOL
IsNearlyEqual(double d1, double d2)
{
    if (d1 == 0.0)
    {
        return (d1 == d2);
    }
    else
    {
        double dRelError = (d1-d2)/d1;
        if (dRelError < 0)
            dRelError = -dRelError;
        return (dRelError < 1.0e-6);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     IsEqual, static
//
//  Synopsis:   For two values of the same type VariantType, determines 
//              whether or no their values match.  Used by databinding
//              code to compare contents of element with contents of
//              databas, and to decide whether or not to actually save
//              changed data to the data source.
//
//  Arguments:  vt  - data type of values being compared
//              pv1 - pointer to data of first value
//              pv2 - pointer to data of second value
//
//  Returns:    S_OK        The two values match
//              S_FALSE     The values don't match
//              E_*         Something went wrong, assume failure.
//

HRESULT
CTypeCoerce::IsEqual(VARTYPE vt, void *pv1, void *pv2)
{
    HRESULT hr = S_OK;
    
    switch (vt)
    {
    case VT_BSTR:
        if (FormsStringCmp(* (BSTR *) pv1, * (BSTR *) pv2))
        {
            hr = S_FALSE;
        }
        break;
    case VT_VARIANT:
        if (((VARIANT *) pv1)->vt != ((VARIANT *) pv2)->vt)
        {
            hr = S_FALSE;
        }
        else
        {
            hr = IsEqual(((VARIANT *) pv1)->vt,
                         & ((VARIANT *) pv1)->iVal,
                         & ((VARIANT *) pv2)->iVal);
        }
        break;

    case VT_BOOL:
        // In theory, these should be VARIANT_BOOLs with only two possible
        //  values: -1 and 0.  However, to be cautious, we'll consider any
        //  two non-zero values to match.
        // However, I've changed these to VARIANT_BOOL rather than BOOL.
        // Since most of our code only assigns the first 16 bits, we should
        // only look at the first 16 bits.  -cfranks 10 Jan 97
        if (! * (VARIANT_BOOL *) pv1 != ! * (VARIANT_BOOL *) pv2)
        {
            hr = S_FALSE;
        }
        break;
        
    case VT_NULL:
    case VT_EMPTY:
        // we violate conventional database rules, and say that NULL==NULL.
        //  This behavior is required by our clients, which use this routine
        //  to figure out if an element's contents differ from that in the
        //  database.
        break;
        
    case VT_I2:
        if (* (WORD *) pv1 != * (WORD *) pv2)
        {
            hr = S_FALSE;
        }
        break;
        
    case VT_I4:
        if (* (DWORD *) pv1 != * (DWORD *) pv2)
        {
            hr = S_FALSE;
        }
        break;

    case VT_R4:
        if (!IsNearlyEqual(* (float *) pv1, * (float *) pv2))
        {
            hr = S_FALSE;
        }
        break;
        
    case VT_R8:
        if (!IsNearlyEqual(* (double *) pv1, * (double *) pv2))
        {
            hr = S_FALSE;
        }
        break;

    case VT_DATE:
        if (* (double *) pv1 != * (double *) pv2)
        {
            hr = S_FALSE;
        }
        break;

    case VT_CY:
#ifdef UNIX
        if (CY_INT64(pv1) != CY_INT64(pv2))
#else
        if (((CY *) pv1)->int64 != ((CY *) pv2)->int64)
#endif
        {
            hr = S_FALSE;
        }
        break;

    case VT_UNKNOWN:
    case VT_DISPATCH:
        // TODO: should probably call IsSameObject
        if (((VARIANT *) pv1)->punkVal != ((VARIANT *) pv2)->punkVal)
        {
            hr = S_FALSE;
        }
        break;

    default:
        Assert(!"comparing unexpected databinding type.");
        hr = E_FAIL;
        break;
    }
    RRETURN1(hr, S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\dbind\detail.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       detail.cxx
//
//  Contents:   HTML Tables Repeating Extensions
//
//  History:
//
//  Jul-96      AlexA   Creation
//  8/14/96     SamBent Support record generator as a lightweight task
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include <formkrnl.hxx>
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include <tpointer.hxx>
#endif

#ifndef X_CSITE_HXX_
#define X_CSITE_HXX_
#include <csite.hxx>
#endif

#ifndef X__TXTSAVE_H_
#define X__TXTSAVE_H_
#include <_txtsave.h>
#endif

#ifndef X_PRGSNK_H_
#define X_PRGSNK_H_
#include <prgsnk.h>
#endif

#ifndef X_OLEDBERR_H_
#define X_OLEDBERR_H_
#include <oledberr.h>       // for DB_S_UNWANTEDREASON
#endif

#ifndef X_DETAIL_HXX_
#define X_DETAIL_HXX_
#include "detail.hxx"
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_DRECGEN_HXX_
#define X_DRECGEN_HXX_
#include "drecgen.hxx"
#endif

#ifndef X_ROWBIND_HXX_
#define X_ROWBIND_HXX_
#include "rowbind.hxx"
#endif

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include "binder.hxx"
#endif

#if defined(PRODUCT_PROF)
//#  define PROFILE_REPEATED_TABLES
#endif

#ifdef PROFILE_REPEATED_TABLES
#include <icapexp.h>
#endif

DeclareTag(tagDetail,"src\\site\\builtin\\detail.cxx","Detail");
DeclareTag(tagTableProgress, "Databinding", "Trace table progress");
PerfDbgTag(tagTableExpand,  "Databinding", "Trace table expansion");
PerfDbgTag(tagRecRequest,   "Databinding", "Trace record requests");

MtDefine(CDetailGenerator, DataBind, "CDetailGenerator")
MtDefine(CDetailGenerator_aryRecInstance_pv, CDetailGenerator, "CDetailGenerator::_aryRecInstance::_pv");

const LARGE_INTEGER LINULL = {0, 0};    // for IStream->Seek()
const RECORDINDEX  RECORDINDEX_INVALID  = MAXLONG;

// helper function to encapsulate a useful assert
static inline CTableLayout *
TableLayout(CTable *pTable)
{
    Assert(pTable);
    CTableLayout *pLayout = pTable->TableLayoutCache();
    Assert(pLayout);  // Table layout owns the DG, so it must exist
    return pLayout;
}


//+------------------------------------------------------------------------
//
//  class       CDetailGenerator
//
//  Member:     constructor
//
//-------------------------------------------------------------------------

CDetailGenerator::CDetailGenerator() :
      _aryRecInstance(Mt(CDetailGenerator_aryRecInstance_pv))
{
    TraceTag((tagDetail, "CDetailGenerator::constructor() -> %p", this));

    _reqCurrent._riBot = -1;            // prepare for NewRecord on an empty table
}




//+------------------------------------------------------------------------
//
//  class       CDetailGenerator
//
//  Member:     destructor
//
//-------------------------------------------------------------------------

CDetailGenerator::~CDetailGenerator ()
{
    TraceTag((tagDetail, "CDetailGenerator::destructor() -> %p", this));

    Assert (!_pRecordGenerator);
    Assert (!_bstrHtmlText);
}


//+------------------------------------------------------------------------
//
//  Member:     Detach
//
//  Synopsis:   Release all my resources.
//
//-------------------------------------------------------------------------

void
CDetailGenerator::Detach()
{
    TraceTag((tagDetail, "CDetailGenerator::Detach() -> %p", this));
    
    ReleaseGeneratedRows();
    SetReadyState(FALSE);

    // stop my hookup task
    if (_pDGTask)
    {
        _pDGTask->Release();
        _pDGTask = NULL;
    }

    ReleaseProgress();
    
    // Detach from the cursor
    if (_pDLC)
    {
        _pDLC->SetDLCEvents(0);
        _pDLC->Release();
        _pDLC = NULL;
    }

    // Release the template (both text and elements)
    FormsFreeString(_bstrHtmlText);
    _bstrHtmlText = NULL;

    // Release dataSrc and dataFld strings
    FormsFreeString(_bstrDataSrc);
    FormsFreeString(_bstrDataFld);
    _bstrDataSrc = _bstrDataFld = NULL;

    if (_pMarkup)
    {
        _pMarkup->SubRelease();
        _pMarkup = NULL;
    }
}


//+------------------------------------------------------------------------
//
//  Member:     ReleaseGeneratedRows
//
//  Synopsis:   Release resources for generated rows
//
//-------------------------------------------------------------------------

void
CDetailGenerator::ReleaseGeneratedRows()
{
    // don't change readystate here - it could lead to unwanted reentrancy.
    // Instead, callers of this routine should call SetReadyState when the
    // coast is clear. (Bug 83183)
    CancelRequest(FALSE);

    // Release the RecordInstances
    for (int i = _aryRecInstance.Size() - 1; i >= 0; i--)
    {
        _aryRecInstance[i]->Detach();
        delete _aryRecInstance[i];
    }
    _aryRecInstance.DeleteAll();

    // Release the record generator
    if (_pRecordGenerator)
    {
        _pRecordGenerator->Detach();
        delete _pRecordGenerator;
        _pRecordGenerator = NULL;
    }
}


//+------------------------------------------------------------------------
//
//  Member:     ReleaseRecords
//
//  Synopsis:   Release resources for generated rows
//
//-------------------------------------------------------------------------

void
CDetailGenerator::ReleaseRecords(RECORDINDEX riFirst, RECORDINDEX riLast)
{
    if (riFirst <= riLast)
    {
        // release the rows
        if (_pTable->_fEnableDatabinding)
        {
            int             iRowStart = RecordIndex2RowIndex(riFirst);
            int             iRowFinish = RecordIndex2RowIndex(riLast + 1) - 1;
            TableLayout(_pTable)->RemoveRowsAndTheirSections(iRowStart, iRowFinish);
        }
        // release the record instances
        for (int i=riLast; i>=riFirst; --i)
        {
            _aryRecInstance[i]->Detach();
            delete _aryRecInstance[i];
            _aryRecInstance.Delete(i);
        }
    }
}


//+------------------------------------------------------------------------
//
//  Member:     Init
//
//  Synopsis:   Initialization
//
//  Arguments:  [pdlc]       -- pointer to the data layer cursor
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CDetailGenerator::Init (CDataLayerCursor         *pDLC,
                        CTable                   *pTable,
                        unsigned int              cInsertNewRowAt,
                        int                       cPageSize)
{
    TraceTag((tagDetail, "CDetailGenerator::Init() -> %p", this));

    HRESULT hr;

    Assert (pTable);
    _pTable = pTable;
    _pMarkup = _pTable->GetMarkup();
    if (_pMarkup)
        _pMarkup->SubAddRef();
    _iFirstGeneratedRow = cInsertNewRowAt;
    _cPageSize = cPageSize;

    // cache my table's provider
    _pProvider = _pTable->GetProvider();

    // get the full dataSrc and dataFld
    _pTable->GetDBMembers()->GetBinder(ID_DBIND_DEFAULT)->
                GetDataSrcAndFld(&_bstrDataSrc, &_bstrDataFld);
    
    // attach to the cursor
    AssertSz(pDLC, "need a valid cursor");
    _pDLC = pDLC;
    _pDLC->AddRef();
    _pDLC->SetDLCEvents(this);

    // set up my hookup task
    _pDGTask = new CDGTask(this);
    if (!_pDGTask)
        goto MemoryError;

    // Create a record generator for assync CElements population.
    _pRecordGenerator = new CRecordGenerator ();
    if (!_pRecordGenerator)
        goto MemoryError;
    hr = _pRecordGenerator->Init(_pDLC, this);
    if (hr)
        goto Error;

    // this code sets my state so that I can survive
    // a call to nextPage before I even start generating records
    _reqCurrent.Activate(CDataLayerBookmark::TheFirst, 0, 0, 0);
    _reqCurrent.Deactivate();

Cleanup:
    RRETURN (hr);

MemoryError:
    hr = E_OUTOFMEMORY;
Error:
    Detach();
    goto Cleanup;
}


//+------------------------------------------------------------------------
//
//  Member:     IsFieldKnown
//
//  Synopsis:   Determine whether the first component of the given
//              field describes a column in my datasource
//
//  Arguments:  strField    field path (dot-separated components)
//
//  Returns:    TRUE/FALSE
//
//-------------------------------------------------------------------------

BOOL
CDetailGenerator::IsFieldKnown(LPCTSTR strField)
{
    BSTR bstrHead, bstrTail;
    BOOL bResult;
    DBORDINAL ulOrdinal;

    if (!FormsIsEmptyString(strField))
    {
        // try entire field first, in case there's a column named "a.b.c" (IE6 14000)
        bResult = (S_OK == _pDLC->GetColumnNumberFromName(strField, ulOrdinal));

        if (!bResult)
        {
            FormsSplitAtDelimiter(strField, &bstrHead, &bstrTail);
            bResult = (S_OK == _pDLC->GetColumnNumberFromName(bstrHead, ulOrdinal));

            FormsFreeString(bstrHead);
            FormsFreeString(bstrTail);
        }
    }
    else
    {
        bResult = FALSE;
    }

    return bResult;
}


//+---------------------------------------------------------------------------
//
//  Member:     AddDataboundElement
//
//  Synopsis:   An element has entered the tree that wants to bind to the
//              record that generated one of my rows.  Post a request
//              to hook it up to the data.
//
//  Arguments:  pElement        the newly arrived element
//              id              id of binding
//              pRowContaining  the row governing pElement
//              strField        the element's dataFld (or a portion thereof)
//                              describing which column to bind
//
//----------------------------------------------------------------------------

HRESULT
CDetailGenerator::AddDataboundElement(CElement *pElement, LONG id,
                                CTableRow *pRowContaining,
                                LPCTSTR strField)
{
    HRESULT hr = S_OK;

    // if we're restoring the original template, ignore the request
    if (_fRestoringTemplate)
        goto Cleanup;
    
    // if pElement is a table, create a binder and do it the regular way
    if (pElement->Tag() == ETAG_TABLE)
    {
        hr = pElement->CreateDatabindRequest(id);
    }

    // otherwise add it to the DGTask's list - we'll hook it up later
    else
    {
        hr = _pDGTask->AddDataboundElement(pElement, id, pRowContaining, strField);
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     HookUpDataboundElement
//
//  Synopsis:   Hook up an element to the data.
//
//  Arguments:  pElement        the newly arrived element
//              id              id of binding
//              pRowContaining  the row governing pElement
//              strField        the element's dataFld (or a portion thereof)
//                              describing which column to bind
//
//----------------------------------------------------------------------------

HRESULT
CDetailGenerator::HookUpDataboundElement(CElement *pElement, LONG id,
                                CTableRow *pRowContaining,
                                LPCTSTR strField)
{
    HRESULT hr = E_FAIL;
    CRecordInstance *pInstance;

    // check that the element, row, and table still have the right
    // relationship and are still in the tree
    if (pElement->IsInMarkup() && pRowContaining->IsInMarkup())
    {
        CTreeNode *pNodeElt = pElement->GetFirstBranch();
        AssertSz(pNodeElt, "IsInMarkup lied!");
        CTreeNode *pNodeRow = pNodeElt->SearchBranchToRootForScope(pRowContaining);
        
        if (pNodeRow)
        {
            CTreeNode *pNodeTable = pNodeRow->Ancestor(ETAG_TABLE);
            
            if (pNodeTable && pNodeTable->Element() == _pTable)
            {
                if (pNodeTable->Element()->IsConnectedToPrimaryWindow())
                {
                    hr = S_OK;
                }
            }
        }
    }
    if (hr)
        goto Cleanup;

    hr = _pTable->GetInstanceForRow(pRowContaining, &pInstance);
    if (hr)
        goto Cleanup;
    
    hr = CXfer::CreateBinding(pElement, id, strField, _pProvider, pInstance);
    if (SUCCEEDED(hr))
        hr = S_OK;      // S_FALSE just means object/applet wasn't ready yet

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     OnMetaDataAvail
//
//  Synopsis:   Call back from the record generator
//              (the meta data has arived/ Cursor is ready).
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CDetailGenerator::OnMetaDataAvailable()
{
    TraceTag((tagDetail, "CDetailGenerator::OnMetaDataAvail() -> %p", this));

    HRESULT             hr = S_OK;
    RRETURN(hr);
}




//+------------------------------------------------------------------------
//
//  Member:     OnRecordsAvailable
//
//  Synopsis:   Call back from the record generator
//              (new records are available).
//
//  Argumnets:  [pTask]     -- task pointer
//              [cRecords]  -- number of records available
//
//  Returns:    HRESULT (S_FALSE is permited, means that we have read
//              everything that was available);
//
//-------------------------------------------------------------------------

HRESULT
CDetailGenerator::OnRecordsAvailable(ULONG cRecords)
{
    TraceTag((tagDetail, "CDetailGenerator::OnRecordsAvailable() -> %p %ul",
                        this, cRecords));
    PerfDbgLog1(tagRecRequest, this, "got %lu records", cRecords);
    PerfDbgLog1(tagTableExpand, GetHost(), "+OnRecordsAvailable %lu", cRecords);

    HRESULT             hr;
    ULONG               cFetched;
    ULONG               cDetails = 0;
    HROW                ahRows[cBufferCapacity];
    LONG                cNewRows;
    ULONG               cRecordsSupplied = cRecords;
    RECORDINDEX         riFirst;

    Assert(cRecords <= cBufferCapacity);

    // determine how many templates we need to create
    if (_reqCurrent.IsForward())
    {
        riFirst = FirstAvailableIndex();
        cNewRows = riFirst + cRecords - RecordCount();
    }
    else
    {
        riFirst = (GetCurrentIndex()==RECORDINDEX_INVALID) ? -1 : GetCurrentIndex();
        cNewRows = cRecords - (riFirst + 1);
    }

    // ignore records that exceed the page size
    // (this can happen if Inserts occur during the request)
    if (_cPageSize > 0 && RecordCount()+cNewRows > _cPageSize)
    {
        LONG cNewRowsAmended = (RecordCount() < _cPageSize) ? _cPageSize - RecordCount() : 0;
        cRecords -= (cNewRows - cNewRowsAmended);
        cNewRows = cNewRowsAmended;
    }

    // get the records from the generator
    hr = _pRecordGenerator->FetchRecords(cRecords, ahRows, &cFetched);
    Assert(cFetched == cRecords);

    // paste a bunch of rows into the table, and update current position
    if (_reqCurrent.IsForward())
    {
        if (cNewRows > 0)
        {
            hr = Clone(cNewRows);
            if (hr)
                goto Cleanup;
            SetCurrentIndex( riFirst );
        }
    }
    else
    {
        if (cNewRows > 0)
        {
            hr = Clone(cNewRows, 0);
            if (hr)
                goto Cleanup;
            SetCurrentIndex( riFirst + cNewRows );
        }
    }

    // build detail objects from the records
    for (cDetails=0; cDetails<cRecords; ++cDetails)
    {
        RECORDINDEX riCurrent = GetCurrentIndex();

        hr = CreateDetail(ahRows[cDetails], &riCurrent);
        if (hr)
            goto Cleanup;

        SetCurrentIndex(AdvanceRecordIndex(riCurrent));

        _reqCurrent._fGotRecords = TRUE;
    }

Cleanup:
    // advance the progress item
    if (_dwProgressCookie)
    {
        IProgSink *pProgSink = CMarkup::GetProgSinkHelper(_pTable->GetMarkup());

        _reqCurrent._cRecordsRetrieved += cRecordsSupplied;
        pProgSink->SetProgress(_dwProgressCookie, PROGSINK_SET_POS, 0, NULL, 0,
                                      _reqCurrent._cRecordsRetrieved, 0);
    }
    
    // release the records
    _pRecordGenerator->ReleaseRecords(cRecordsSupplied);

    PerfDbgLog1(tagTableExpand, GetHost(), "-OnRecordsAvailable %lu", cRecords);
    RRETURN(hr);
}


HRESULT
CDetailGenerator::OnRequestDone(BOOL fEndOfData)
{
    HRESULT hr = S_OK;

    if (_cPageSize > 0 && fEndOfData)
    {
        // if we paged off the end of the data, delete any extra templates
        if (_reqCurrent.GotRecords())
        {
            RECORDINDEX riCurrent = GetCurrentIndex();

            if (riCurrent != RECORDINDEX_INVALID)
            {
                if (_reqCurrent.IsForward())
                {
                    // we fell of the bottom.  Delete rows at the end
                    ReleaseRecords(riCurrent, RecordCount() - 1);
                }
                else
                {
                    // we fell off the top.  Delete rows at the beginning
                    ReleaseRecords(0, riCurrent);

                    // make sure we're displaying dataPageSize rows
                    if (RecordCount() < _cPageSize)
                    {
                        SetBookmarks();
                        MakeRequest(_reqCurrent._dlbBot, 1,
                                    _cPageSize - RecordCount(), RecordCount());
                        goto Cleanup;
                    }
                }
            }
        }

        // if several next/prev page requests combined to overshoot the end of
        // the data, back up and try again
        else    // !_reqCurrent.GotRecords()
        {
            if (_reqCurrent.IsForward() && _reqCurrent._lOffset > _cPageSize)
            {
                MakeRequest(_reqCurrent._dlbStart,
                            _reqCurrent._lOffset - _cPageSize,
                            _cPageSize, 0);
                goto Cleanup;
            }
            if (!_reqCurrent.IsForward() && _reqCurrent._lOffset < -_cPageSize)
            {
                MakeRequest(_reqCurrent._dlbStart,
                            _reqCurrent._lOffset + _cPageSize,
                            -_cPageSize, RecordCount()-1);
                goto Cleanup;
            }
        }
    }

    // remember bookmarks for top and bottom rows
    EndRequest();
    // WARNING: EndRequest() changes table.readyState, which may call scripts
    // that change the world - e.g. removing table.dataSrc.  So "this" may
    // not even exist after this point.

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     GetHrow
//
//  Synopsis:   return the HROW associated with the given index.
//              return DB_NULL_HROW if index out of bounds

HROW
CDetailGenerator::GetHrow(RECORDINDEX ri)
{
    return (ri<0 || ri>=RecordCount())  ? DB_NULL_HROW
                                        : _aryRecInstance[ri]->GetHRow();
}


//+------------------------------------------------------------------------
//
//  Member:     RecordIndex2RecordNumber
//
//  Synopsis:   Compute the record number (offset from beginning of dataset)
//              for the record with the given index
//
//  Arguments:  ri      index of desired record
//
//  Returns:    index of corresponding record in database
//              -1      if record not found or error

long
CDetailGenerator::RecordIndex2RecordNumber(RECORDINDEX ri)
{
    HRESULT hr = E_FAIL;
    DBCOUNTITEM ulPosition = (DBCOUNTITEM)-1;
    DBCOUNTITEM ulSize;
    HROW hrow;

    // get the corresponding hrow
    hrow = GetHrow(ri);
    if (hrow == DB_NULL_HROW)
        goto Cleanup;

    // find its position in the dataset
    hr = _pDLC->GetPositionAndSize(hrow, &ulPosition, &ulSize);
    if (hr)
        goto Cleanup;

Cleanup:
    return hr ? -1 : (LONG)ulPosition;
}


//+------------------------------------------------------------------------
//
//  Member:     AssignHrowToRecord
//
//  Synopsis:   Send the given HROW to the record at the given index
//
//-------------------------------------------------------------------------

HRESULT
CDetailGenerator::AssignHrowToRecord(HROW hrow, RECORDINDEX ri)
{
    HRESULT hr;
    CRecordInstance *pRecInstance;

    Assert(0<=ri && ri<RecordCount());

    pRecInstance = _aryRecInstance[ri];
    hr = pRecInstance->SetHRow(hrow);

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     NewRecord
//
//  Synopsis:   Called from CTabularDataAgent upon arrival of a new record
//              in the Rowset.  For now, we always assume this new record
//              arrived at the end of the rowset.
//
//  Arguments:  none
//
//  Returns:    S_OK
//
//-------------------------------------------------------------------------
HRESULT
CDetailGenerator::NewRecord()
{
    HRESULT hr = S_OK;

    // If a request is active, it'll pick up the new record in due course.
    if (_reqCurrent.IsActive())
        goto Cleanup;

    // We only care if we're either displaying the whole table, or if the
    // last page we displayed on the table was not complete
    if (_cPageSize==0 || _reqCurrent._riBot+1 < _cPageSize)
    {
        // request more records
        RECORDINDEX riStart = _reqCurrent._riBot + 1;
        CDataLayerBookmark dlbStart = (riStart<=0)? CDataLayerBookmark::TheFirst
                                                    : _reqCurrent._dlbBot;
        LONG lOffset = (riStart<=0)? 0 : 1;
        LONG cRecords = _cPageSize==0 ? MAXLONG : _cPageSize - riStart;

        hr = MakeRequest(dlbStart, lOffset, cRecords, riStart);
    }

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CreateDetail
//
//  Synopsis:   Create an instance of an repeated elements from their templates,
//              1. Clone the template (or reuse the instance)
//              2. RefreshData for the Elements instance
//              3. add the detail (Elements) to the host.
//
//  Arguments:  [hrow]      -- HROW to generate detail for.
//              pRECORDINDEX  -- [in] address of RECORDINDEX to re-use
//                    [out] if not null, pointer to the RECORDINDEX used
//
//  Returns:    S_OK, if the detail was careted
//              S_FALSE if reached end of Element set
//              otherwise returns an error
//
//-------------------------------------------------------------------------

HRESULT
CDetailGenerator::CreateDetail (HROW hrow, RECORDINDEX  *pri)
{
    TraceTag((tagDetail, "CDetailGenerator::CreateDetail() -> %p (%ul)", this, hrow));

    HRESULT             hr;
    RECORDINDEX         ri = RECORDINDEX_INVALID;

    if (pri && *pri!=RECORDINDEX_INVALID)
    {
        ri = *pri;
    }
    else
    {
        // We create the record with HROW 0, then change the HROW afterward.  This
        //  prevents a bug in which we manipulate the element tree while we walk it
        hr = CreateRecordInstance(&ri);

        if (FAILED(hr))
        {
            Assert(ri == RECORDINDEX_INVALID);
            goto Error;
        }

        // we got a new record index
        Assert (ri != RECORDINDEX_INVALID);
        Assert (ri < RecordCount());
    }

    {
        // actually transfer the values.  Turn off table recalc during transfer.
        CElement::CLock Lock(GetHost(), CElement::ELEMENTLOCK_BLOCKCALC);
        PerfDbgLog1(tagTableExpand, GetHost(), "+ChangeHRow %x", hrow);
        hr = AssignHrowToRecord(hrow, ri);
        PerfDbgLog1(tagTableExpand, GetHost(), "-ChangeHRow %x", hrow);
    }
    if (hr)
        goto Error;

Cleanup:
    if (pri)
    {
        *pri = ri;
    }
    RRETURN (hr);

Error:
    DeleteDetail(ri);
    ri = RECORDINDEX_INVALID;
    goto Cleanup;
}


//+------------------------------------------------------------------------
//
//  Member:     CreateRecordInstance
//
//  Synopsis:   Create a record instance and return index where it's stored
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CDetailGenerator::CreateRecordInstance (RECORDINDEX *pri)
{
    HRESULT             hr = S_OK;
    CRecordInstance    *pRecInstance;
    RECORDINDEX         ri = RECORDINDEX_INVALID;

    pRecInstance = new CRecordInstance(_pDLC, DB_NULL_HROW);
    if (!pRecInstance)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // add the new instance to my array, either at the indicated position or
    // at the end
    if (pri && *pri != RECORDINDEX_INVALID)
    {
        ri = *pri;
        hr = _aryRecInstance.Insert(ri, pRecInstance);
    }
    else
    {
        ri = RecordCount();
        hr = _aryRecInstance.Append(pRecInstance);
    }
    if (hr)
        goto Error;

Cleanup:
    if (pri)
        *pri = hr ? RECORDINDEX_INVALID : ri;
    RRETURN(hr);

Error:
    pRecInstance->Detach();
    delete pRecInstance;
    goto Cleanup;
}


//+------------------------------------------------------------------------
//
//  Member:     PrepareForCloning
//
//  Synopsis:   prepare the repeated Elements of the table to Clone.
//              (Save the Element templates into a stream).
//              create a parser
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CDetailGenerator::PrepareForCloning()
{
    TraceTag((tagDetail, "CDetailGenerator::PrepareForCloning() -> %p", this));

    HRESULT hr = S_OK;

#ifndef NO_DATABINDING
    if (!_bstrHtmlText)     // else it is a refresh case
    {
        //
        // Save the table without header and footer to a null-terminated
        // stream.  Save only inside the runs of the <TABLE>.
        //
        hr = TableLayout(_pTable)->GetTemplate(&_bstrHtmlText);
    }
#endif

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     Clone
//
//  Synopsis:   Clone the detail (template)..
//              Generate all the Elements from the template Elements.
//
//  Arguments:  nTemplates      number of templates to clone
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CDetailGenerator::Clone(UINT nTemplates, RECORDINDEX riClone)
{
    TraceTag((tagDetail, "CDetailGenerator::Clone() -> %p", this));

    HRESULT hr;
    UINT i;

    Verify(TableLayout(_pTable)->OpenView());

    // add the new rows
    hr = AddTemplates(nTemplates, riClone);

    // update my array of instances
    for (i=0; i<nTemplates; ++i)
    {
        RECORDINDEX ri = riClone;
        hr = CreateRecordInstance(&ri);
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     AddTemplates
//
//  Synopsis:   add template rows to the table.  Don't do anything more -
//              RestoreTemplate relies on this.
//
//  Arguments:  nTemplates      number of templates to clone
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CDetailGenerator::AddTemplates(UINT nTemplates, RECORDINDEX ri)
{
    HRESULT         hr = S_OK;
    if (_pTable->_fEnableDatabinding)
    {
        BSTR    bstrTemplates = NULL;
        OLECHAR *pStr;
        UINT i;
        int iRow;
        CTableSection *pSectionInsertBefore = NULL;
        CTableLayout * pTableLayout = TableLayout(_pTable);
        static const OLECHAR * oszPreamble = _T("<TABLE>");
        static const OLECHAR * oszPostamble = _T("</TABLE>");
        const UINT cTemplateLength = FormsStringLen(_bstrHtmlText);
        const UINT cLength = wcslen(oszPostamble) +
                            nTemplates * cTemplateLength +
                            wcslen(oszPostamble) + 1;

        // allocate the string and prepare to copy
        hr = FormsAllocStringLen(NULL, cLength, &bstrTemplates);
        if (hr)
            goto Cleanup;
        pStr = bstrTemplates;

        // copy the preamble
        wcscpy(pStr, oszPreamble);
        pStr += wcslen(oszPreamble);

        // copy the template body the requested number of times
        for (i=0; i<nTemplates; ++i)
        {
            if (cTemplateLength > 0)
                wcscpy(pStr, _bstrHtmlText);
            pStr += cTemplateLength;
        }

        // copy the postamble
        wcscpy(pStr, oszPostamble);

        // locate where to paste in the cloned rows

        hr = pTableLayout->EnsureTableLayoutCache();
        if (hr)
            goto Cleanup;

        iRow = ri==RECORDINDEX_INVALID ? -1 : RecordIndex2RowIndex(ri);
        if (0 <= iRow && iRow < pTableLayout->GetRows())
        {
            pSectionInsertBefore = pTableLayout->_aryRows[iRow]->Section();
        }

        // paste the result into the main table
        PerfDbgLog1(tagTableExpand, GetHost(), "+PasteRows %u", nTemplates);
        hr = PasteRows(bstrTemplates, pSectionInsertBefore);
        PerfDbgLog1(tagTableExpand, GetHost(), "-PasteRows %u", nTemplates);
        if (hr)
            goto Cleanup;

    Cleanup:
        // deallocate the string
        FormsFreeString(bstrTemplates);
    }

    RRETURN (hr);
}


//+------------------------------------------------------------------------
//
//  Member:     PasteRows
//
//  Synopsis:   paste generated rows into the tree
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CDetailGenerator::PasteRows(BSTR bstrTemplates, CTableSection *pSectionInsertBefore)
{
    HRESULT             hr;
    BOOL                fSaveDataBindingEnabled;
    CMarkup *           pMarkupOut = NULL;
    CMarkup *           pMarkupTable = _pTable->GetMarkup();
    CDoc *              pDoc = _pTable->Doc();

    Assert(pMarkupTable);
    Assert(pDoc);

    CTableLayout *      pTableLayout = TableLayout(_pTable);
    MARKUP_CONTEXT_TYPE context = CONTEXT_TYPE_None;
    BSTR                bstrTagName = NULL;
    CTreeNode *         pNode;

    CMarkupPointer mpStart(pDoc), mpFinish(pDoc), mpTarget(pDoc);    

    // memo to world:  we're pasting rows, don't interfere
    fSaveDataBindingEnabled = pMarkupTable->SetDataBindingEnabled(FALSE);
    pTableLayout->PastingRows(TRUE, pSectionInsertBefore);
    
    // locate the target
    if (pSectionInsertBefore == NULL)
    {
        hr = mpTarget.MoveAdjacentToElement(_pTable, ELEM_ADJ_BeforeEnd);
    }
    else
    {
        hr = mpTarget.MoveAdjacentToElement(pSectionInsertBefore, ELEM_ADJ_BeforeBegin);
    }
    if (hr)
        goto Cleanup;
    
    // create the source, and narrow the range to include just the new TBODY
    hr = THR(pDoc->ParseString(bstrTemplates, 
                                PARSE_ABSOLUTIFYIE40URLS, 
                                &pMarkupOut, 
                                &mpStart, 
                                &mpFinish, 
                                pMarkupTable));
 
    if (hr)
        goto Cleanup;
        
    Assert(pMarkupOut);

    pMarkupOut->_fTemplate = TRUE;

    while (!hr && !(context==CONTEXT_TYPE_EnterScope && 0==FormsStringCmp(bstrTagName, _T("TABLE"))))
    {
        hr = mpStart.Right(TRUE, &context, &pNode, NULL, NULL, NULL);
        FormsFreeString(bstrTagName);
        bstrTagName = NULL;
        if (!hr)
        {
            Assert(pNode);
            hr = pNode->Element()->get_tagName(&bstrTagName);
        }
    }
    context = CONTEXT_TYPE_None;
    while (!hr && !(context==CONTEXT_TYPE_EnterScope && 0==FormsStringCmp(bstrTagName, _T("TABLE"))))
    {
        hr = mpFinish.Left(TRUE, &context, &pNode, NULL, NULL, NULL);
        FormsFreeString(bstrTagName);
        bstrTagName = NULL;
        if (!hr)
        {
            Assert(pNode);
            hr = pNode->Element()->get_tagName(&bstrTagName);
        }
    }

    // move the new TBODY into the main tree
    if (!hr)
        hr = pDoc->Move(&mpStart, &mpFinish, &mpTarget);

    // memo to world:  we're done now
    pTableLayout->PastingRows(FALSE);
    pMarkupTable->SetDataBindingEnabled(fSaveDataBindingEnabled);

Cleanup:
    // Databinding should not save undo information
    pDoc->FlushUndoData();

    // cleanup
    if (pMarkupOut)
        pMarkupOut->Release();

    FormsFreeString(bstrTagName);

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     Generate
//
//  Synopsis:   populate the host (table/repeater) with the Elements
//              Generate all the Elements from the template Elements.
//              (is called when populating 1st time).
//
//  Returns:    HRESULT, (S_FALSE means the end of Element set was reached).
//
//-------------------------------------------------------------------------

HRESULT
CDetailGenerator::Generate()
{
    TraceTag((tagDetail, "CDetailGenerator::Generate() -> %p", this));

    Assert(_pRecordGenerator);
    Assert(_aryRecInstance.Size() == 0);            // No record instances yet.

    HRESULT hr;

    hr = _pRecordGenerator->RequestMetaData();
    if (hr)
        goto Cleanup;

    if (_cPageSize<0)                   // Clip negatives.
        _cPageSize = 0;

    // Request to generate all the Elements
    hr = MakeRequest(CDataLayerBookmark::TheFirst, 0,
                        _cPageSize ? _cPageSize : MAXLONG, 0);

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     RestoreTemplate
//
//  Synopsis:   Put the template back into the table.  Called when dataSrc
//              changes, and we need to go back to the original state.
//
//-------------------------------------------------------------------------

HRESULT
CDetailGenerator::RestoreTemplate()
{
    HRESULT hr;
    BOOL fRestoringTemplateSave = _fRestoringTemplate;

    // this works because AddTemplates just pastes the template into the
    // table.
    _fRestoringTemplate = TRUE;
    hr = AddTemplates(1);
    _fRestoringTemplate = fRestoringTemplateSave;

    RRETURN(hr);
}


HRESULT
CDetailGenerator::nextPage()
{
    TraceTag((tagDetail, "CDetailGenerator::next() -> %p", this));

    Assert (_pRecordGenerator);

    HRESULT hr = S_OK;

    if (_cPageSize>0)
    {
        CDataLayerBookmark dlb = _reqCurrent._dlbStart;
        LONG lOffset = _reqCurrent._lOffset + _cPageSize;
        LONG cSize = _cPageSize;
        RECORDINDEX riStart = 0;

        if (!_reqCurrent.IsActive())
        {
            dlb = _reqCurrent._dlbBot;
            lOffset = 1;
        }

        else if (_reqCurrent.IsForward())
        {
            // defaults are already correct for extending a forward move
        }

        else
        {
            cSize = -_cPageSize;
            riStart = RecordCount() > 0 ? RecordCount() - 1 : RECORDINDEX_INVALID;

            // ignore, if reversing direction past starting point
            if (lOffset > 0)
                goto Cleanup;
        }

        hr = MakeRequest(dlb, lOffset, cSize, riStart);
    }

Cleanup:
    return hr;
}

HRESULT
CDetailGenerator::previousPage()
{
    TraceTag((tagDetail, "CDetailGenerator::next() -> %p", this));

    Assert (_pRecordGenerator);

    HRESULT hr = S_OK;

    if (_cPageSize>0)
    {
        CDataLayerBookmark dlb = _reqCurrent._dlbStart;
        LONG lOffset = _reqCurrent._lOffset - _cPageSize;
        LONG cSize = -_cPageSize;
        RECORDINDEX riStart = RecordCount() > 0 ? RecordCount() - 1 : RECORDINDEX_INVALID;

        if (!_reqCurrent.IsActive())
        {
            dlb = _reqCurrent._dlbTop;
            lOffset = -1;
        }

        else if (!_reqCurrent.IsForward())
        {
            // defaults are already correct for extending a reverse move
        }

        else
        {
            cSize = _cPageSize;
            riStart = 0;

            // ignore, if reversing direction past starting point
            if (lOffset < 0)
                goto Cleanup;
        }

        hr = MakeRequest(dlb, lOffset, cSize, riStart);
    }

Cleanup:
    return hr;
}


HRESULT
CDetailGenerator::firstPage()
{
    TraceTag((tagDetail, "CDetailGenerator::firstPage() -> %p", this));

    Assert (_pRecordGenerator);

    HRESULT hr = S_OK;

    if (_cPageSize>0)
    {
        hr = MakeRequest(CDataLayerBookmark::TheFirst, 0, _cPageSize, 0);
    }

    return hr;
}


HRESULT
CDetailGenerator::lastPage()
{
    TraceTag((tagDetail, "CDetailGenerator::lastPage() -> %p", this));

    Assert (_pRecordGenerator);

    HRESULT hr = S_OK;

    if (_cPageSize>0)
    {
        hr = MakeRequest(CDataLayerBookmark::TheLast, 0, -_cPageSize,
                RecordCount() - 1);
    }

    return hr;
}


HRESULT
CDetailGenerator::SetPageSize(long cPageSize)
{
    HRESULT hr = S_OK;

    // if the new size is the same as the old, do nothing
    if (cPageSize == _cPageSize)
        goto Cleanup;

    // set the new page size
    _cPageSize = cPageSize;

    // if the new size is 0, regenerate the full table
    if (_cPageSize == 0)
    {
        hr = MakeRequest(CDataLayerBookmark::TheFirst, 0, MAXLONG, 0);
        goto Cleanup;
    }

    // if the table is shrinking, delete rows from the end
    if (_cPageSize < RecordCount())
    {
        ReleaseRecords(_cPageSize, RecordCount() - 1);
        SetBookmarks();
    }

    // if there's an active request, we use the top bookmark so that
    // we'll repopulate the entire table and guarantee that there are no
    // gaps or overlap (as there might be if we used the bottom bookmark)
    if (_reqCurrent.IsActive())
    {
        SetBookmarks();
        hr = MakeRequest(_reqCurrent._dlbTop, 0, _cPageSize, 0);
    }
    
    // if the (inactive) table is growing, add records at the end
    else if (_cPageSize > RecordCount())
    {
        hr = MakeRequest(_reqCurrent._dlbBot, 1,
                        _cPageSize - RecordCount(), RecordCount());
    }
    
Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     DeleteDetail
//
//  Synopsis:   Delete the detail section
//
//  Arguments:  [RECORDINDEX] -- cookie of a new detail
//
//  Note:       the detail might be partialy populated, in this case it is the
//              last one constructed (cloned).
//
//-------------------------------------------------------------------------

void
CDetailGenerator::DeleteDetail (RECORDINDEX  riDelete)
{
    int iRowDelete;

    if (riDelete == RECORDINDEX_INVALID)
        goto Done;

    // detach and delete the record
    _aryRecInstance[riDelete]->Detach();
    delete _aryRecInstance[riDelete];
    _aryRecInstance.Delete(riDelete);

    // delete the corresponding rows from the table
    if (_pTable->_fEnableDatabinding)
    {
        iRowDelete = RecordIndex2RowIndex(riDelete);
        TableLayout(_pTable)->RemoveRowsAndTheirSections(iRowDelete, iRowDelete + GetTemplateSize() - 1);
    }

Done:
    return;
}



//+------------------------------------------------------------------------
//
//  Member:     AdvanceRecordIndex
//
//  Synopsis:   get the next RecordIndex, using the current iteration direction
//
//  Arguments:  [riPrev]         -- previous RecordIndex
//
//-------------------------------------------------------------------------

RECORDINDEX
CDetailGenerator::AdvanceRecordIndex(RECORDINDEX riPrev)
{
    if (riPrev != RECORDINDEX_INVALID)
    {
        if (_reqCurrent.IsForward())
        {
            if (++riPrev >= RecordCount())
                riPrev = RECORDINDEX_INVALID;
        }
        else
        {
            if (--riPrev < 0)
                riPrev = RECORDINDEX_INVALID;
        }
    }
    return riPrev;
}



//+------------------------------------------------------------------------
//
//  Member:     RetreatRecordIndex
//
//  Synopsis:   get the previous RecordIndex, using the current iteration direction
//
//  Arguments:  [riPrev]         -- previous RecordIndex
//
//-------------------------------------------------------------------------

RECORDINDEX
CDetailGenerator::RetreatRecordIndex(RECORDINDEX riPrev)
{
    if (_reqCurrent.IsForward())
        riPrev = ((riPrev == RECORDINDEX_INVALID) ? RecordCount() : riPrev) - 1;
    else
        riPrev = ((riPrev == RECORDINDEX_INVALID) ? -1 : riPrev) + 1;
    return riPrev;
}



//+==========================================================================
//
// Request to record generator
//

//+------------------------------------------------------------------------
//
//  Member:     Activate (CRecRequest)
//
//  Synopsis:   initialize a new request
//

void
CDetailGenerator::CRecRequest::Activate(const CDataLayerBookmark& dlbStart,
                                LONG lOffset, LONG cRecords, RECORDINDEX riStart)
{
    _dlbStart   = dlbStart;
    _lOffset    = lOffset;
    _riCurrent  = riStart;
    _cRecords   = cRecords;
    _fActive    = TRUE;
    _fGotRecords = FALSE;
}


//+------------------------------------------------------------------------
//
//  Member:     MakeRequest
//
//  Synopsis:   make a request to the record generator
//
//  Arguments:  dlbStart        bookmark for starting location
//              lOffset         offset from bookmark to first record desired
//              cRecords        number of records desired (ULMAX = all records)

HRESULT
CDetailGenerator::MakeRequest(const CDataLayerBookmark& dlbStart, LONG lOffset,
                                LONG cRecords, RECORDINDEX riStart)
{
    const ULONG CHUNK_SIZE = 10;
    HRESULT hr;
    RECORDINDEX riRequest = riStart;
    IProgSink *pProgSink = NULL;
    DBCOUNTITEM ulMax = cRecords >= 0 ? cRecords : -cRecords;
    DWORD dwProgressCookieNew;

    // cancel the active request (if any)
    hr = CancelRequest(FALSE);
    if (hr)
        goto Cleanup;

    PerfDbgLog3(tagRecRequest, GetHost(), "+RecReqest off=%ld count=%ld index=%ld",
                lOffset, cRecords, riStart);
#ifdef PROFILE_REPEATED_TABLES
    StartCAP();         // for perf of repeated tables - ends in EndRequest
#endif

    // start the new request
    if (riRequest >= RecordCount())
        riRequest = RECORDINDEX_INVALID;
    _reqCurrent.Activate(dlbStart, lOffset, cRecords, riRequest);

    hr = _pRecordGenerator->RequestRecordsAtBookmark(dlbStart, lOffset, cRecords);
    if (hr)
    {
        CancelRequest();
        goto Cleanup;
    }

    // put the table into "chunk" mode.
    TableLayout(_pTable)->SetDirtyRowThreshold(CHUNK_SIZE);
    _fInteractive = TRUE;

    // if it's an open-ended task, ask the cursor how long
    if (cRecords == MAXLONG)
    {
        Assert(_pDLC);
        IGNORE_HR(_pDLC->GetSize(&ulMax));
    }

    // start up a progress item to track table expansion
    _reqCurrent._cRecordsRetrieved = 0;
    pProgSink = CMarkup::GetProgSinkHelper(_pTable->GetMarkup());

    hr = THR(pProgSink->AddProgress(PROGSINK_CLASS_DATABIND, &dwProgressCookieNew));
    if (hr)
        goto SetReadyState;
    TraceTag((tagTableProgress, "AddProgress %x for table %d (%x)",
                dwProgressCookieNew, _pTable->_nSerialNumber, _pTable));

    ReleaseProgress();
    _dwProgressCookie = dwProgressCookieNew;
    
    hr = THR(pProgSink->SetProgress(_dwProgressCookie,
            PROGSINK_SET_STATE | PROGSINK_SET_IDS | PROGSINK_SET_POS | PROGSINK_SET_MAX,
            PROGSINK_STATE_LOADING, NULL, IDS_LOADINGTABLE, 0, ulMax));
    if (hr)
        goto SetReadyState;

SetReadyState:
    // setting the ready state fires an event and may cause reentrancy
    _pTable->SetReadyStateTable(READYSTATE_INTERACTIVE);
    // (this) is no longer valid!!!

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CancelRequest
//
//  Synopsis:   cancel an active request to the record generator
//

HRESULT
CDetailGenerator::CancelRequest(BOOL fSetReadyState)
{
    HRESULT hr = S_OK;

    if (_reqCurrent.IsActive())
    {
        PerfDbgLog(tagRecRequest, GetHost(), "request cancelled");
        IGNORE_HR(_pRecordGenerator->CancelRequest());
        IGNORE_HR(EndRequest(fSetReadyState));
    }

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     EndRequest
//
//  Synopsis:   post processing, when request terminates
//

HRESULT
CDetailGenerator::EndRequest(BOOL fSetReadyState)
{
    HRESULT hr = S_OK;
    Assert(_reqCurrent.IsActive());

    // if request produced new records, remember bookmarks for top and bottom rows
    if (_reqCurrent.GotRecords())
    {
        SetBookmarks();
    }

    _reqCurrent.Deactivate();

    // change the table's readystate
    if (fSetReadyState && _pDLC->IsComplete())
    {
        SetReadyState();
    }

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     SetBookmarks
//
//  Synopsis:   remember a bookmark for the first and last displayed records.
//              This association is used when moving to the next/previous page
//              of a paged table.

void
CDetailGenerator::SetBookmarks()
{
    CDataLayerBookmark dlb;

    if (RecordCount() > 0)
    {
        if (S_OK == _pDLC->CreateBookmark(GetHrow(0), &dlb))
        {
            _reqCurrent._dlbTop = dlb;
            _reqCurrent._riTop = 0;
        }

        if (S_OK == _pDLC->CreateBookmark(GetHrow(RecordCount()-1), &dlb))
        {
            _reqCurrent._dlbBot = dlb;
            _reqCurrent._riBot = RecordCount() - 1;
        }
    }
}


//+-------------------------------------------------------------------------
// Member:              FindHrow
//
// Synopsis:    Locate the position in the table where the given hrow belongs
//
// Arguments:   hrow        the desired hrow
//              pri         pointer to return value:  index where hrow should be
//                          inserted, or RECORDINDEX_INVALID if hrow doesn't
//                          belong in the active area
//
// Returns:             S_OK        hrow found, *pri set to its index
//              S_FALSE     hrow not found, *pri set to where it belongs
//              E_FAIL      error or hrow out of bounds, *pri set to INVALID

HRESULT
CDetailGenerator::FindHrow(HROW hrow, RECORDINDEX *pri)
{
    CDataLayerBookmark dlbSearch;
    HRESULT hr;

    hr = _pDLC->CreateBookmark(hrow, &dlbSearch);
    if (hr)
        goto Cleanup;

    hr = FindBookmark(dlbSearch, pri);

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+-------------------------------------------------------------------------
// Member:              FindBookmark
//
// Synopsis:    Locate the position in the table where the given bookmark belongs
//
// Arguments:   dlb         the desired hrow
//              pri         pointer to return value:  index where hrow should be
//                          inserted, or RECORDINDEX_INVALID if dlb doesn't
//                          belong in the active area
//
// Returns:             S_OK        dlb found, *pri set to its index
//              S_FALSE     dlb not found, *pri set to where it belongs
//              E_FAIL      error or dlb out of bounds, *pri set to INVALID

HRESULT
CDetailGenerator::FindBookmark(const CDataLayerBookmark& dlbSearch, RECORDINDEX *pri)
{
    RECORDINDEX riFirst = FirstActiveIndex();
    RECORDINDEX riLast = LastActiveIndex();
    RECORDINDEX riLow=riFirst, riHigh=riLast+1, riMid;
    CDataLayerBookmark dlbMid;
    HRESULT hr;

    // binary search
    while (riLow < riHigh)
    {
        riMid = (riLow + riHigh)/2;
        hr = _pDLC->CreateBookmark(GetHrow(riMid), &dlbMid);
        if (hr)
            goto Cleanup;

        if (dlbMid < dlbSearch)
            riLow = riMid + 1;
        else
            riHigh = riMid;
    }

    // now see if the hrow already exists
    if (riLow > riLast)
        hr = S_FALSE;
    else
    {
        hr = _pDLC->CreateBookmark(GetHrow(riLow), &dlbMid);
        if (hr)
            goto Cleanup;
        if (dlbMid != dlbSearch)
            hr = S_FALSE;
    }

Cleanup:
    // return INVALID if any errors occurred, or if the answer is out of range
    // (except in the special case of a nonpaged, fully-expanded table)
    if (FAILED(hr) ||
        (_reqCurrent.IsActive() && riLow > LastActiveIndex()) ||
        (!_reqCurrent.IsActive() && _cPageSize > 0 && riLow >= _cPageSize) )
        riLow = RECORDINDEX_INVALID;
    *pri = riLow;

    RRETURN1(hr, S_FALSE);
}


//+-------------------------------------------------------------------------
// Member:      InsertBeforeCurrentPage (private helper)
//
// Synopsis:    When a new row is inserted before the current page of
//              a paged table, this routine decides whether it should
//              be displayed.  
//
// Arguments:   hrow    - new row.  Caller ensures it belongs before current page
//
// Returns:     index where the new row should be displayed.  Namely:
//                  0                       - it should be displayed
//                  RECORDINDEX_INVALID     - it should not be displayed

RECORDINDEX
CDetailGenerator::InsertBeforeCurrentPage(HROW hrow)
{
    Assert(_cPageSize > 0);
    RECORDINDEX riReturn = RECORDINDEX_INVALID;

    // don't display if we're still populating, or if we're already showing
    // a full page.
    if (_reqCurrent.IsActive() || RecordCount() >= _cPageSize)
        return RECORDINDEX_INVALID;

    // now it makes sense to add a record at the top of an incomplete
    // page.  Next check if the new record is really the last undisplayed
    // record.
    CDataLayerBookmark dlbNew;
    HROW hrowNext = DB_NULL_HROW;
    DBCOUNTITEM cRows;
    HRESULT hr = _pDLC->CreateBookmark(hrow, &dlbNew);
    if (!hr)
    {
        // find the next hrow after the new one
        hr = _pDLC->GetRowsAt(dlbNew, 1, 1, &cRows, &hrowNext);
        if (!hr && cRows == 1)
        {
            // if it's the first displayed row, we can display the new one
            if (RecordCount() > 0 && hrowNext == GetHrow(0))
            {
                riReturn = 0;
            }
        }
        // if it's the last row of all, and we're not displaying anything,
        // we can display the new one
        // COMPAT (sambent)  RDS returns DB_E_BADSTARTPOSITION when we ask for
        // the next row after the last one, instead of DB_S_ENDOFROWSET like
        // the doc says it's supposed to.  We'll treat it the same, but
        // I don't like it.  (see IE5 98023)
        else if (RecordCount() == 0 &&
                    (hr == DB_S_ENDOFROWSET || hr == DB_E_BADSTARTPOSITION))
        {
            riReturn = 0;
        }

        // release the row we obtained
        if (hrowNext != DB_NULL_HROW)
            _pDLC->ReleaseRows(1, &hrowNext);
    }

    return riReturn;
}


//+-------------------------------------------------------------------------
// Member:              AllChanged (public, CDataLayerCursorEvents)
//
// Synopsis:    /*[synopsis]*/
//
// Arguments:   /*[args]*/
//
// Returns:             /*[returns]*/

HRESULT
CDetailGenerator::AllChanged()
{
    CElement * pElement = GetHost();

    // Make sure it's a table site.
    if (pElement->Tag()==ETAG_TABLE)
    {
        DYNCAST(CTable, pElement)->refresh();     // refresh it.
    }

    return S_OK;
}


//+-------------------------------------------------------------------------
// Member:              RowsChanged (public, CDataLayerCursorEvents)
//
// Synopsis:    /*[synopsis]*/
//
// Arguments:   /*[args]*/
//
// Returns:             /*[returns]*/

HRESULT
CDetailGenerator::RowsChanged(DBCOUNTITEM cRows, const HROW *ahRows)
{
    RECORDINDEX ri;

    for (ULONG k=0; k<cRows; ++k)
        if (S_OK == FindHrow(ahRows[k], &ri))
            AssignHrowToRecord(ahRows[k], ri);
    return S_OK;
}


//+-------------------------------------------------------------------------
// Member:              FieldsChanged (public, CDataLayerCursorEvents)
//
// Synopsis:    forward notification to all my instances
//
// Arguments:   /*[args]*/
//
// Returns:             /*[returns]*/

HRESULT
CDetailGenerator::FieldsChanged(HROW hRow, DBORDINAL cColumns, DBORDINAL aColumns[])
{
    RECORDINDEX ri;

    if (S_OK == FindHrow(hRow, &ri))
        IGNORE_HR(_aryRecInstance[ri]->OnFieldsChanged(hRow, cColumns, aColumns));
    return S_OK;
}


//+-------------------------------------------------------------------------
// Member:      RowsInserted (public, CDataLayerCursorEvents)
//
// Synopsis:    add new rows to the table
//
// Arguments:   cRows       number of new rows
//              ahRows      HROWs for the new rows
//
// Returns:     HRESULT

HRESULT
CDetailGenerator::RowsInserted(DBCOUNTITEM cRows, const HROW *ahRows)
{
    HRESULT hr = S_OK;
    DBCOUNTITEM cRowsInserted = 0;

    for (ULONG iRow=0; iRow<cRows; ++iRow)
    {
        // locate the new row in the up-to-date area of the table.
        RECORDINDEX riInsert = RECORDINDEX_INVALID;
        Verify(S_OK != FindHrow(ahRows[iRow], &riInsert));

        // ignore insert if not in bounds.  The new row is either outside
        // the current page of the table, or the active request will find it
        // soon anyway.
        if (riInsert == 0 && _cPageSize > 0)
            riInsert = InsertBeforeCurrentPage(ahRows[iRow]);
        if (riInsert == RECORDINDEX_INVALID)
            continue;

        // insert a new row at the desired place
        hr = Clone(1, riInsert);
        if (hr)
            goto Cleanup;
        hr = CreateDetail(ahRows[iRow], &riInsert);
        if (hr)
            goto Cleanup;

        // if we've exceeded the page size, trim
        if (_cPageSize > 0 && RecordCount() > _cPageSize)
        {
            DeleteDetail(RecordCount() - 1);
        }

        // tell the active request what happened
        if (_reqCurrent.IsActive())
        {
            RECORDINDEX riCurrent = GetCurrentIndex();
            if (riCurrent != RECORDINDEX_INVALID &&
                (_reqCurrent.IsForward() && riCurrent > riInsert))
            {
                SetCurrentIndex(AdvanceRecordIndex(riCurrent));
            }
        }

        ++ cRowsInserted;
    }

Cleanup:
    // if rows arrived, we told the table not to recalc while we pasted stuff in.
    // Tell it to recalc now.
    if (cRowsInserted > 0)
    {
        TableLayout(_pTable)->Resize();

        // adjust bookmarks, if necessary
        SetBookmarks();
    }

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
// Member:              Deleting Rows (public, CDataLayerCursorEvents)
//
// Synopsis:    /*[synopsis]*/
//
// Arguments:   /*[args]*/
//
// Returns:             /*[returns]*/

HRESULT
CDetailGenerator::DeletingRows(DBCOUNTITEM cRows, const HROW *ahRows)
{
    return S_OK;
}



HRESULT
CDetailGenerator::RowsDeleted(DBCOUNTITEM cRows, const HROW *ahRows)
{
    HRESULT hr = S_OK;
    int iRow;
    int cRecordsDeleted = 0;
    RECORDINDEX riDelete = 0;   // force first delete to do a full search

    // delete in reverse order - this is slightly gentler for shifting rows
    for (iRow = cRows-1;  iRow >=0;  --iRow)
    {
        HROW hrowDelete = ahRows[iRow];

        // check for special case:  deleting a bunch of consecutive rows
        if (riDelete > 0 && GetHrow(riDelete-1) == hrowDelete)
        {
            riDelete = riDelete - 1;
        }
        // otherwise do a linear search
        else
        {
            for (riDelete = RecordCount()-1;  riDelete >= 0;  --riDelete)
            {
                if (GetHrow(riDelete) == hrowDelete)
                    break;
            }
        }

        // if we found a record to delete, do so
        if (riDelete >= 0)
        {
            DeleteDetail(riDelete);
            ++ cRecordsDeleted;

            // tell the active request what happened
            if (_reqCurrent.IsActive())
            {
                RECORDINDEX riCurrent = GetCurrentIndex();
                if (riCurrent != RECORDINDEX_INVALID &&
                    (_reqCurrent.IsForward() && riCurrent > riDelete))
                {
                    SetCurrentIndex(RetreatRecordIndex(riCurrent));
                }
            }
        }
    }

    // if we did any work, adjust for it
    if (cRecordsDeleted > 0)
    {
        SetBookmarks();

        // for paged tables, fill in the end from database
        if (_cPageSize > 0)
        {
            MakeRequest(_reqCurrent._dlbBot, +1,
                            _cPageSize - RecordCount(), RecordCount());
        }
    }

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
// Member:              DeleteCancelled (public, CDataLayerCursorEvents)
//
// Synopsis:    notification that a delete-row operation is cancelled.
//
// Arguments:   /*[args]*/
//
// Returns:             /*[returns]*/

HRESULT
CDetailGenerator::DeleteCancelled(DBCOUNTITEM cRows, const HROW *ahRows)
{
    return S_OK;
}


HRESULT
CDetailGenerator::RowsAdded()
{
    NewRecord();
    return S_OK;
}


HRESULT
CDetailGenerator::PopulationComplete()
{
    SetReadyState();

    return S_OK;
}


void
CDetailGenerator::SetReadyState(BOOL fResize /* = TRUE */)
{
    if (!_reqCurrent.IsActive() && _pDGTask->IsIdle())
    {
        // take the table out of "chunk" mode and do a full recalc/redisplay
        CTableLayout *pTableLayout = TableLayout(_pTable);
        pTableLayout->SetDirtyRowThreshold(0);
        if (fResize && _pTable->GetFirstBranch())
        {
            pTableLayout->_fDatabindingRecentlyFinished = TRUE;
            pTableLayout->Resize();
        }

        if (_fInteractive)
        {
#ifdef PROFILE_REPEATED_TABLES
            StopCAP();      // for perf of repeated tables - starts in MakeRequest
#endif
            PerfDbgLog(tagRecRequest, GetHost(), "-RecRequest");
            
            // we can't call ReleaseProgress from here, because of 
            // the possible reentrancy from table.onreadystate change.
            // Instead, imitate it with local variables.
            CMarkup *pMarkup = _pTable->GetMarkup();
            if (pMarkup == NULL)
                pMarkup = _pMarkup;
            IProgSink *pProgSink = CMarkup::GetProgSinkHelper(pMarkup);
            DWORD dwProgCookie = _dwProgressCookie;
            _dwProgressCookie = 0;
            WHEN_DBG( CTable *pTable = _pTable; )   // for TraceTag only!
            WHEN_DBG ( int nSerialNumber = _pTable->_nSerialNumber; )   // TraceTag only
            
            _fInteractive = FALSE;
            _pTable->SetReadyStateTable(READYSTATE_COMPLETE);
            // because table.onreadystatechange may alter the page,
            // assume (this) is no longer valid
            
            // ReleaseProgress();
            if (dwProgCookie && pProgSink)
            {
                TraceTag((tagTableProgress, "DelProgress (ready state) %x for table %d (%x)",
                            dwProgCookie, nSerialNumber, pTable));
                pProgSink->DelProgress(dwProgCookie);
            }
        }
    }
}


void
CDetailGenerator::ReleaseProgress()
{
    // release the progress item that's tracking table expansion
    if (_dwProgressCookie)
    {
        CMarkup *pMarkup = _pTable->GetMarkup();
        if (pMarkup == NULL)
            pMarkup = _pMarkup;
        IProgSink *pProgSink = CMarkup::GetProgSinkHelper(pMarkup);

        if (pProgSink)
        {
            TraceTag((tagTableProgress, "Release Progress %x for table %d (%x)",
                        _dwProgressCookie, _pTable->_nSerialNumber, _pTable));
            pProgSink->DelProgress(_dwProgressCookie);
        }
        _dwProgressCookie = 0;
    }
}

void CDetailGenerator::AccumulateServicedRows()
{
    // notify table that this row was serviced and hooked up (data was transfered)
    TableLayout(_pTable)->AccumulateServicedRows();
}

/////////////////////////////////////////////////////////////////////////////
//
//      CDGTask  -  this task is responsible for hooking up databound
//                  elements that have been added to a repeated table
//

MtDefine(CDGTask, DataBind, "CDGTask");
MtDefine(CDGTask_aryBindRequest_pv, CDGTask, "CDGTask::_aryBindRequest::_pv");

CDGTask::CDGTask(CDetailGenerator *pDG) :
    CTask(TRUE),
    _pDG(pDG),
    _aryBindRequest(Mt(CDGTask_aryBindRequest_pv))
{
}

//+---------------------------------------------------------------------------
//
//  Member:     AddDataboundElement
//
//  Synopsis:   An element has entered the tree that wants to bind to the
//              record that generated one of my rows.  Post a request
//              to hook it up to the data.
//
//  Arguments:  pElement        the newly arrived element
//              id              id of binding
//              pRowContaining  the row governing pElement
//              strField        the element's dataFld (or a portion thereof)
//                              describing which column to bind
//
//----------------------------------------------------------------------------

HRESULT
CDGTask::AddDataboundElement(CElement *pElement, LONG id,
                                CTableRow *pRowContaining,
                                LPCTSTR strField)
{
    HRESULT hr = S_OK;

    CBindRequestRecord *pBindRequest = _aryBindRequest.Append();
    if (pBindRequest)
    {
        UINT cbField;

        pBindRequest->pElement = pElement;
        pBindRequest->id = id;
        pBindRequest->pRowContaining = pRowContaining;
        pRowContaining->DataTransferRequested();
        cbField = lstrlen(strField);
        if (cbField)                    //duplicate strField into our own buffer
        {
            pBindRequest->strField = new TCHAR[cbField+1];
            if (pBindRequest->strField)
                lstrcpy(pBindRequest->strField, strField);
        }
        pElement->AddRef();         // don't let element die
        pRowContaining->AddRef();   // or row, either
        SetBlocked(FALSE);          // get scheduled to run
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     OnRun (CTask)
//
//  Synopsis:   Hook up all the elements currently on my list.
//
//----------------------------------------------------------------------------

void
CDGTask::OnRun(DWORD dwTimeout)
{
    UINT i;
    UINT cSize = _aryBindRequest.Size();
    CTableRow * pRow = NULL;
    
    // hook up the instances to the cloned rows
    for (i = 0;  i < cSize;  ++i)
    {
        // copy the current request.  We can't use a pointer to it, because
        // new requests might arrive and reallocate the array.
        CBindRequestRecord request = _aryBindRequest[i];
        
        IGNORE_HR(_pDG->HookUpDataboundElement(request.pElement,
                                    request.id,
                                    request.pRowContaining,
                                    request.strField));

        if (pRow != request.pRowContaining)
        {
            pRow = request.pRowContaining;
            pRow->DataTransferServiced();
            _pDG->AccumulateServicedRows();
        }
        if (request.strField)
            delete [] request.strField;
        request.pElement->Release();  // addref'd when added to array
        request.pRowContaining->Release();  // addref'd when added to array
    }


    // now delete the requests I've serviced.  More requests may have arrived
    // during the loop above, so be careful.  This is why we cache the array
    // size before looping.
    _aryBindRequest.DeleteMultiple(0, cSize-1);

    // if there are new elements on my list, schedule myself to run again
    SetBlocked( _aryBindRequest.Size() == 0 );

    // set table's readystate
    _pDG->SetReadyState();
}


//+---------------------------------------------------------------------------
//
//  Member:     OnTerminate (CTask)
//
//  Synopsis:   Release elements currently on my list.
//
//----------------------------------------------------------------------------

void
CDGTask::OnTerminate()
{
    UINT i;
    CBindRequestRecord *pBindRequest;
    UINT cSize = _aryBindRequest.Size();
    
    // release any unserviced requests
    for (pBindRequest=_aryBindRequest, i=cSize;
         i > 0;
         ++pBindRequest, --i)
    {
        pBindRequest->pElement->Release();  // addref'd when added to array
        pBindRequest->pRowContaining->Release();  // addref'd when added to array
    }

    // delete all requests.
    _aryBindRequest.DeleteAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\dbind\dbinding.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       dbinding.cxx
//
//  Contents:   HTML Elements Data Binding Extensions
//
//  class CDataBinder  -  knows what we are binding (column/property).
//                        Has a protocol for Setting/Getting data
//                        to/from the HTML elements.
//
//
//-------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include <elemdb.hxx>
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include <mshtmlrc.h>
#endif

#ifndef X_OLEDBERR_H_
#define X_OLEDBERR_H_
#include <oledberr.h>
#endif

#ifndef X_ROWBIND_HXX_
#define X_ROWBIND_HXX_
#include "rowbind.hxx"
#endif

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include "binder.hxx"
#endif

#ifndef X_SIMPDC_H_
#define X_SIMPDC_H_
#include "simpdc.h"
#endif

DeclareTag(tagCRecordInstance, "CRecordInstance", "Row Instance");
DeclareTag(tagDBtransfer, "Databinding", "data transfer values");
PerfDbgTag(tagDataTransfer,   "Databinding", "Data transfer");
MtDefine(CXfer, DataBind, "CXfer")
MtDefine(CXferThunk, DataBind, "CXferThunk")
MtDefine(CHRowAccessor, DataBind, "CHRowAccessor")
MtDefine(CRecordInstance, DataBind, "CRecordInstance")
MtDefine(CRecordInstance_aryPXfer_pv, CRecordInstance, "CRecordInstance::_aryPXfer::_pv")

////////////////////////////////////////////////////////////////////////////////
//
//  CRecordInstance
//
////////////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     constructor
//
//-------------------------------------------------------------------------
CRecordInstance::CRecordInstance(CDataLayerCursor *pDLC, HROW hRow) :
    _pDLC(pDLC),
    _hRow(0),    // so that SetHRow() call won't have suprise side-effect
    _aryPXfer(Mt(CRecordInstance_aryPXfer_pv))
{
    TraceTag((tagCRecordInstance,
              "CRecordInstance::constructor() -> %p", this ));

    _pDLC->AddRef();
    IGNORE_HR(SetHRow(hRow));

    Assert(_aryPXfer.Size() == 0);

    IS_VALID(this);
}


//+------------------------------------------------------------------------
//
//  Member:     destructor
//
//-------------------------------------------------------------------------
CRecordInstance::~CRecordInstance()
{
    TraceTag((tagCRecordInstance,
              "CRecordInstance::constructor() -> %p", this ));

    IS_VALID(this);

    Assert(!_hRow                                &&
           (_aryPXfer.Size() == 0)               && "Detach not called.");

    if (_pDLC)
    {
        _pDLC->Release();
    }
}


//+------------------------------------------------------------------------
//
//  Member:     Detach
//
//  Synopsis:   Detaches RecordInstance and all Xfer's associated w/ this
//              RecordInstance.  Likewise, change all CElements pointed to
//              to no longer point back to the Xfer.
//-------------------------------------------------------------------------
void
CRecordInstance::Detach (BOOL fClear)
{
    TraceTag((tagCRecordInstance, "CRecordInstance::Detach() -> %p", this));

    IS_VALID(this);

    // DeleteXFers before discarding HROW, so that we don't try to stuff
    //  null information into all of the bound elements.
    DeleteXfers(fClear);                        // Remove all XFers.

    IGNORE_HR(SetHRow(0));                      // Release the HROW
}


//+------------------------------------------------------------------------
//
//  Member:     OkToChangeHRow
//
//  Synopsis:   See if it's OK to change my HROW association right now.
//              May validate-and-save the current site on the page.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CRecordInstance::OkToChangeHRow()
{
    TraceTag((tagCRecordInstance, "CRecordInstance::OkToChangeHRow() -> %p ()",
             this ));
             
    HRESULT hr = S_OK;
    const int cXfers = _aryPXfer.Size();
    int i;

    // it's always OK to move off the null HROW
    if (_hRow == DB_NULL_HROW)
        goto Cleanup;

    for (i=0; !hr && i<cXfers; ++i)
    {
        CXfer *pXfer = _aryPXfer[i];
        CElement *pElem;

        if (!pXfer)
            continue;

        if (pXfer->FOneWay())
            continue;
        
        pElem = pXfer->GetDestElement();


        // For Sites, we need to possibly check DISPID_VALID, and we need to
        //  save via a virtual method on the site which takes care of raising
        //  events if the site is current, cancelling posted messages, etc.
        // For elements, we do the save
        //  ourselves, because we've resisted putting a SaveDataIfChanged
        //  method on CElement becuase of VTable bloat.
        // TODO: much of the logic here duplicates that found elsewhere;
        //  this redundancy will lead to maintenance problems.  (JJD)
        //  The DISPID_VALID stuff duplicates RequestYieldCurrency, but
        //  we don't call it ourselves because we support binding to arbitrary
        /// params.
        if (pElem->ShouldHaveLayout())
        {
            LONG idBound = pXfer->IdElem();
            
            if (idBound == 0)   // TODO: what's the right check to decide if
                                //  we need to the the DISPID_VALID check,
                                //  normally done by
                                //  CSite::RequestYieldCurrency()?
            {
                CElement *pElemCurrent = pElem->Doc()->_pElemCurrent;

                if (pElemCurrent->ShouldHaveLayout() &&
                    pElemCurrent->GetElementDataBound() == pElem)
                {
                    if (!pElemCurrent->IsValid())
                    {
                        // TODO   Need to display error message here.
                        //          May not be able to handle synchronous
                        //          display, so consider deferred display.
                        hr = E_FAIL;
                        continue;
                    }
                }
            }

            hr = pElem->SaveDataIfChanged(idBound, /* fLoud */ TRUE);
            if (hr == S_FALSE)
            {
                hr = S_OK;      // if user reverted to database, that's just fine
            }
        }
        else
        {
#if DBG == 1
            DBINFO dbi;

            Verify(DBIND_SINGLEVALUE == CDBindMethods::DBindKind(pElem,
                                                                 pXfer->IdElem(),
                                                                 &dbi));
#endif
        }
    }
    
Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+------------------------------------------------------------------------
//
//  Member:     SetHRow
//
//  Synopsis:   Assign a new HRow to this Instance, releasing the old HROW
//              and addrefing the new HROW..
//
//  Arguments:  [hRow]      new HROW
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CRecordInstance::SetHRow (HROW hRow)
{
    TraceTag((tagCRecordInstance, "CRecordInstance::SetHRow() -> %p (%ul)",
             this, hRow ));

    IS_VALID(this);

    HRESULT             hr = S_OK;

    // Valid RecordInstance data?

    if (_hRow || hRow)
    {
        // AddRef the new hrow we now hold onto.
        if (hRow)
        {
            _pDLC->AddRefRows(1, &hRow);
        }

        // Release the hRow we're holding onto.
        if (_hRow)
        {
            _pDLC->ReleaseRows(1, &_hRow);
        }

        _hRow = hRow;
        IGNORE_HR(TransferToDestination ());
    }
    else
    {
        // Had better be zero already if the cookie is invalid.
        Assert(hRow == 0);
        Assert(_hRow == hRow);
    }

    RRETURN(hr);
}


HRESULT
CRecordInstance::AddBinding(CXfer *pXfer, BOOL fDontTransfer,
                                BOOL fTransferOK)
{
    HRESULT hr;

    pXfer->EnableTransfers(fTransferOK);

    hr = _aryPXfer.Append(pXfer);
    if (hr)
    {
        goto Error;
    }

    if (_hRow && !fDontTransfer)
    {
        IGNORE_HR(pXfer->TransferFromSrc());
    }

Cleanup:
    RRETURN(hr);

Error:
    pXfer->Detach();
    delete pXfer;
    goto Cleanup;
}

//+------------------------------------------------------------------------
//
//  Member:     RemoveBinding
//
//  Synopsis:   Remove one or all Xfers associated with this element.
//
//  Arguments:  [pElement] - element whose binding(s) are being removed
//              [id]       - either individual binding ID being removed,
//                           or else ID_DBIND_ALL, to remove all Xfers
//                           associated with the element
//
//-------------------------------------------------------------------------
void
CRecordInstance::RemoveBinding (CElement *pElement, LONG id)
{
    Assert("valid element required" && pElement);
    TraceTag((tagCRecordInstance,
              "CRecordInstance::DeleteXfers() -> %p", this));

    IS_VALID(this);

    for (int i = _aryPXfer.Size() - 1; i >= 0; i--)
    {
        if (_aryPXfer[i] && pElement==_aryPXfer[i]->GetDestElement())
        {
            if (id == ID_DBIND_ALL || id == _aryPXfer[i]->IdElem())
            {
                // Disconnect CElement from Xfer (destination no longer bound).
                _aryPXfer[i]->Detach();
                delete _aryPXfer[i];
                _aryPXfer.Delete(i);
            }
        }
    }
}

//+------------------------------------------------------------------------
//
//  Member:     DeleteXfers
//
//  Synopsis:   Remove all Xfers associated with this row instance.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
void
CRecordInstance::DeleteXfers (BOOL fClear)
{
    TraceTag((tagCRecordInstance,
              "CRecordInstance::DeleteXfers() -> %p", this));

    IS_VALID(this);

    for (int i = _aryPXfer.Size() - 1; i >= 0; i--)
    {
        if (_aryPXfer[i])
        {
            // clear the element, if requested
            if (fClear)
                _aryPXfer[i]->ClearValue();

            // Disconnect CElement from Xfer (destination no longer bound).
            _aryPXfer[i]->Detach();
            delete _aryPXfer[i];
        }
    }

    // Remove the Xfer slot
    _aryPXfer.DeleteAll();
}


//+------------------------------------------------------------------------
//
//  Member:     TransferToDestination
//
//  Synopsis:   Process each Xfer associated with this RecordInstance
//              transfering data from the source to the destination.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CRecordInstance::TransferToDestination ()
{
    TraceTag((tagCRecordInstance,
              "CRecordInstance::TransferToDestination() -> %p", this));

    IS_VALID(this);

    HRESULT     hr = S_OK;
    HRESULT     hrT;
    int         iMaxIdx;

    iMaxIdx = _aryPXfer.Size() - 1;
    for (int i = 0; i <= iMaxIdx; i++)
    {
        if (!_aryPXfer[i])
            continue;

        hrT = _aryPXfer[i]->TransferFromSrc();

        // don't let one failure abort additional transfers, but
        //  return the first failure.
        if (hrT && !hr)
        {
            hr = hrT;
        }
    }

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
// Member:      On Fields Changed (public)
//
// Synopsis:    notify my Xfer's that columns have changed
//
// Arguments:   cColumns        count of changed columns
//              aColumns        index of each changed column
//
// Returns:     S_OK

HRESULT
CRecordInstance::OnFieldsChanged(HROW hrow, DBORDINAL cColumns, DBORDINAL aColumns[])
{
    if (_pDLC->IsSameRow(hrow, _hRow))
    {
        const int cXfers = _aryPXfer.Size();
        for (int i=0; i<cXfers; ++i)
        {
            if (_aryPXfer[i])
                _aryPXfer[i]->ColumnsChanged(cColumns, aColumns);
        }
    }
    return S_OK;
}


#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Member:     IsValidObject
//
//  Synopsis:   Validation method, called by macro IS_VALID(p)
//
BOOL
CRecordInstance::IsValidObject ()
{
    Assert(this);
    Assert(_pDLC);

    return TRUE;
}


char s_achCRecordInstance[] = "CRecordInstance";

//+---------------------------------------------------------------------------
//
//  Member:     Dump
//
//  Synopsis:   Dump function, called by macro DUMP(p,dc)
//
void
CRecordInstance::Dump (CDumpContext&)
{
    IS_VALID(this);
}


//+---------------------------------------------------------------------------
//
//  Member:     GetClassName
//
//  Synopsis:   GetClassName function. (virtual)
//
char *
CRecordInstance::GetClassName ()
{
    return s_achCRecordInstance;
}
#endif  // DBG == 1



////////////////////////////////////////////////////////////////////////////////
//
//  CXfer
//
////////////////////////////////////////////////////////////////////////////////

DeclareTag(tagCXfer, "CXfer", "CXfer Instance");


//+------------------------------------------------------------------------
//
//  Member:     CreateBinding (static)
//
//-------------------------------------------------------------------------

HRESULT
CXfer::CreateBinding(CElement *pElement,  LONG id, LPCTSTR strDataFld,
                    CDataSourceProvider *pProvider,
                    CRecordInstance *pSrcInstance,
                    CXfer **ppXfer /* = NULL */,
                    BOOL fDontTransfer /* = FALSE */)
{
    HRESULT hr = S_OK;
    DBIND_KIND dbk;
    DBINFO  dbi;
    DBSPEC dbs;
    CXferThunk *pXT = NULL;
    CXfer *pXfer = NULL;

    // Do all checks before memory allocation, for simple error handling.
    dbk = CDBindMethods::DBindKind(pElement, id, &dbi);
    if (dbk != DBIND_SINGLEVALUE && dbk != DBIND_TABLE)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    // we will need to find out if DATAFORMATAS=HTML was specified
    Verify(!CDBindMethods::GetDBSpec(pElement, id, &dbs));

    // if dataformatas=localized-text is set (and is appropriate), mark the target type
    if (dbs.FLocalized() && dbi._vt == VT_BSTR)
    {
        dbi._vt.SetLocalized(TRUE);
    }
    
    // get a thunk from the provider
    if (strDataFld == NULL)
    {
        strDataFld = dbs._pStrDataFld;
    }
    pXT = pProvider->GetXT(strDataFld, dbi._vt);
    if (pXT == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // create a CXfer to govern the binding
    pXfer = new CXfer;
    if (pXfer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // initialize it
    hr = pXfer->Init(pElement, pSrcInstance, pXT, id, dbs.FHTML(), dbi._dwTransfer);

    // add it to the instance's notify list
    if (!hr)
        hr = pSrcInstance->AddBinding(pXfer, fDontTransfer);
    if (hr)
        goto Cleanup;
    
Cleanup:
    if (ppXfer)
        *ppXfer = pXfer;
    
    RRETURN1(hr, S_FALSE);
}


HRESULT
CXfer::ConnectXferToElement()
{
    HRESULT hr  = S_OK;
    DBMEMBERS *pdbm;

    if (!_pDestElem)
        goto Cleanup;

    hr  = _pDestElem->EnsureDBMembers();
    if (hr)
        goto Cleanup;

    pdbm = _pDestElem->GetDBMembers();

    hr = pdbm->GetDataBindingEvents()->AddXfer(this);

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     Init
//
//-------------------------------------------------------------------------

HRESULT
CXfer::Init(CElement *pElem, CInstance *pSrcInstance, CXferThunk *pXT,
                LONG id, BOOL fHTML, DWORD dwTransfer)
{
    HRESULT hr;

    _pDestElem = pElem;
    _pSrcInstance = pSrcInstance;
    _pXT = pXT;
    _idElem = id;
    _fHTMLSpecified = fHTML;
    _dwTransfer = dwTransfer;

    _pXT->AddRef();
    hr = ConnectXferToElement();

    IS_VALID(this);
    return hr;
}


//+------------------------------------------------------------------------
//
//  Member:     destructor
//
//-------------------------------------------------------------------------
CXfer::~CXfer ()
{
    TraceTag((tagCXfer, "CXfer::destructor() -> %p", this));

    IS_VALID(this);

    Assert(!_pDestElem && !_pSrcInstance && !_pXT && "Detach not called.");
}


//+------------------------------------------------------------------------
//
//  Member:     SetDestElement
//
//  Synopsis:   Change the CElement associated with this Xfer.
//
//  Arguments:  [pDestElem]     new CElement associated w/ Xfer.
//
//  Returns:    none
//
//-------------------------------------------------------------------------
HRESULT
CXfer::SetDestElement (CElement *pDestElem)
{
    TraceTag((tagCXfer, "CXfer::SetDestElement() -> %p (%p)", this, pDestElem));

    IS_VALID(this);

    DisonnectXferToElement();

    _pDestElem = pDestElem;

    return ConnectXferToElement();
}


//+------------------------------------------------------------------------
//
//  Member:     Detach
//
//  Synopsis:   Detach the Xfer from the CElement.
//
//  Arguments:  none
//
//  Returns:    none
//
//-------------------------------------------------------------------------
void
CXfer::Detach ()
{
    TraceTag((tagCXfer, "CXfer::Detach() -> %p", this));

    IS_VALID(this);

    DisonnectXferToElement();

    _pSrcInstance = NULL;
    ClearInterface(&_pXT);
}


//+------------------------------------------------------------------------
//
//  Member:     DisonnectXferToElement
//
//  Synopsis:   Disconnect CElement and Xfer connection to each other.
//
//  Arguments:  none
//
//  Returns:    none
//
//-------------------------------------------------------------------------
void
CXfer::DisonnectXferToElement ()
{
    TraceTag((tagCXfer, "CXfer::Detach() -> %p", this));

    IS_VALID(this);

    if (_pDestElem)
    {
        // Sever CElement connection to an XFer.
        _pDestElem->GetDBMembers()->GetDataBindingEvents()->_aryXfer.DeleteByValue(this);

        // Sever Xfer connections to a CElement.
        _pDestElem = NULL;
    }
}


HRESULT
CXfer::TransferToSrc (DWORD *pdwStatus)
{
    HRESULT hr = S_OK;
    VARIANT     var;
    VOID        *pData;
    BOOL fWasTransferring;

    Assert(*pdwStatus == DBSTATUS_S_OK);    // caller must initialize
    VariantInit(&var);
    
    // Note that it is up to callers to avoid calling us when _fTransferringToDest.
    // This division of responsibility is necessary because we sometime decide to
    //  save synchronously, but don't actually do the save asynchronously.
    if (_pDestElem == NULL || _pSrcInstance == NULL || _pXT == NULL
            || _fTransferringToDest)
    {
        Assert(FALSE);
        hr = E_UNEXPECTED;
        goto Done;
    }

    if (_fDontTransfer)
    {
        hr = S_OK;
        goto Done;
    }

    // read-only binding always "succeeds"
    if (_dwTransfer & DBIND_ONEWAY)
        goto Done;

    fWasTransferring = _fTransferringToSrc;
    _fTransferringToSrc = TRUE;

    // prepare the variant which will receive the element's value.
    pData = _pXT->PvInitVar(&var);

    // get the value from the element
    hr = THR(_pDestElem->GetDBindMethods()->BoundValueFromElement(
                _pDestElem,
                IdElem(),
                FHTML(),
                pData ) );

    // set the status to indicate if it's null
    if (pData == &var.bstrVal && V_VT(&var) == VT_BSTR && V_BSTR(&var) == NULL)
    {
        *pdwStatus = DBSTATUS_S_ISNULL;
    }
    
    // transfer the data to the Rowset
    if (!hr)
    {
        hr = THR(_pXT->ValueToSrc(_pSrcInstance, pData, pdwStatus, _pDestElem));
    }
    
    _fTransferringToSrc = fWasTransferring;
    if (hr)
        goto Cleanup;

    // store the database value back into the element (so we get the
    // provider's converions, if any)
    IGNORE_HR(TransferFromSrc());

Cleanup:
    VariantClear(&var);
Done:
    RRETURN(hr);
}
    

HRESULT
CXfer::TransferFromSrc ()
{
    HRESULT         hr = S_OK;
    BOOL            fWasTransferring;
    WHEN_DBG(ULONG ulRefElement;)

    if (_fDontTransfer || _fTransferringToSrc)
    {
        goto Cleanup;
    }

    if (_pDestElem == NULL || _pSrcInstance == NULL || _pXT == NULL)
    {
        Assert(FALSE);
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    _pDestElem->AddRef();           // keep element alive while we change it
    
    fWasTransferring = _fTransferringToDest;
    _fTransferringToDest = TRUE;

    if (_dwTransfer & DBIND_NOTIFYONLY) // element just wants notification, not data
    {
        hr = THR(_pDestElem->GetDBindMethods()->InstanceChanged(_pDestElem, _pSrcInstance));
    }

    else                        // element wants data
    {
        HRESULT hrT;
        VARIANT     var;
        VOID       *pData;

        VariantInit(&var);
        pData = _pXT->PvInitVar(&var);

        PerfDbgLog1(tagDataTransfer, _pDestElem, "+DataTransfer to %ls",
                    _pDestElem->TagName());
        
        hr = THR(_pXT->ValueFromSrc(_pSrcInstance, pData, _pDestElem));

        PerfDbgLog(tagDataTransfer, _pDestElem, "got DB value, sending to element");

#if DBG==1
        if (var.vt == VT_BSTR)
            TraceTag((tagDBtransfer, "%ls %d gets bound value '%.200ls'",
                _pDestElem->TagName(), _pDestElem->_nSerialNumber,
                var.bstrVal));
        else
            TraceTag((tagDBtransfer, "%ls %d gets bound value of type %u value 0x%x",
                _pDestElem->TagName(), _pDestElem->_nSerialNumber,
                var.vt, var.iVal));
#endif

        // even on failure to fetch data from source, we want to put
        //  SOMETHING -- our empty-equivalent data -- into the element
        hrT = THR(_pDestElem->GetDBindMethods()->BoundValueToElement(
                    _pDestElem,
                    IdElem(),
                    FHTML(),
                    pData ) );
        if (!hr)
        {
            hr = hrT;
        }

        PerfDbgLog(tagDataTransfer, _pDestElem, "-DataTransfer");

        VariantClear(&var);

        // Databinding should not save undo information
        _pDestElem->Doc()->FlushUndoData();
    }
    
    // remember whether or not we achieved success
    _fError = (hr != S_OK);

    _fTransferringToDest = fWasTransferring;
    WHEN_DBG(ulRefElement = ) _pDestElem->Release();
    AssertSz(ulRefElement>0, "element unexpectedly destroyed during data transfer");

Cleanup:
    RRETURN(hr);
}


HRESULT
CXfer::ClearValue()
{
    HRESULT hr = S_OK;
    VARIANT var;
    VOID *pNull;
    
    Assert(_pDestElem && _pXT);
    
    if (_dwTransfer & DBIND_NOTIFYONLY) // element just wants notification, not data
        goto Cleanup;
    
    // set up null value
    pNull = _pXT->PvInitVar(&var);
    
    // transfer the null value
    hr = THR( _pDestElem->GetDBindMethods()->BoundValueToElement(
                _pDestElem,
                IdElem(),
                FHTML(),
                pNull ) );

    // Databinding should not save undo information
    _pDestElem->Doc()->FlushUndoData();

Cleanup:
    RRETURN(hr);
}


HRESULT
CXfer::CompareWithSrc ()
{
    HRESULT         hr = S_OK;
    
    VARIANT     var;
    VOID        *pData;
    
    VARIANT     varElem;
    VOID        *pElemData;

    VariantInit(&var);
    VariantInit(&varElem);

    // if we are comparing and we had a previous error, we do nothing and
    //  report a match with S_OK
    if (_fError)
        goto Done;

    // if we are comparing, and we are in the act of transferring back
    //  to the element, then we want to do nothing and return S_OK.
    if (_fTransferringToDest)
        goto Done;
    
    if (_pDestElem == NULL || _pSrcInstance == NULL || _pXT == NULL)
    {
        Assert(FALSE);
        hr = E_UNEXPECTED;
        goto Done;
    }

    Assert(CTypeCoerce::FVariantType(_vtElem.BaseType()));
    
    // compare on a read-only binding always returns true
    if (_dwTransfer & DBIND_ONEWAY)
        goto Done;
   
    pData = _pXT->PvInitVar(&var);    
    pElemData = _pXT->PvInitVar(&varElem);

    // get element's value
    hr = _pDestElem->GetDBindMethods()->BoundValueFromElement(_pDestElem,
                                                           IdElem(),
                                                           FHTML(),
                                                           pElemData);
    if (hr)
    {
        // S_FALSE is an expected return, which means the element is not in
        // a state where it has reasonable data to compare to.  An example
        // of this is a radio button with no buttons pressed, a state that
        // can be achieved if the databinding value matched no buttons.
        // We must suppress the S_FALSE here because our callers become upset
        // on any non-S_OK hr's.
        if (hr==S_FALSE)
        {
            hr = S_OK;
        }
        goto Cleanup;
    }

    // get database value
    hr = _pXT->ValueFromSrc(_pSrcInstance, pData, _pDestElem);
    if (hr)
    {
        if (hr == DB_E_DELETEDROW)
        {
            // moving away from a deleted record - the move-away code wants
            // to compare the current value with the (unavailable) database
            // value.  This condition would never occur if our data sources
            // gave us good deleted-rows notifications, but until ADC does,
            // we have to take some action.  We report that any value
            // matches the contents of a deleted-row, so that we won't
            // trigger save logic.
            hr = S_OK;
        }
        goto Cleanup;
    }

    // compare the values
    hr = CTypeCoerce::IsEqual(VT_VARIANT,
                              &varElem,
                              &var );

    // if we we have a mis-match, and we know that the source is read-only,
    //  let's report E_ACCESSDENIED now.
    if (hr == S_FALSE && !_pXT->IsWritable(_pSrcInstance))
    {
        hr = E_ACCESSDENIED;
        goto Cleanup;
    }

Cleanup:
    VariantClear(&var);
    VariantClear(&varElem);
Done:
    RRETURN1(hr, S_FALSE);
}


//+-------------------------------------------------------------------------
// Member:      Columns Changed (public)
//
// Synopsis:    if my column has changed, get the new data
//
// Arguments:   cColumns    count of changed columns
//              aColumns    index of each changed column
//
// Returns:     S_OK

HRESULT
CXfer::ColumnsChanged(DBORDINAL cColumns, DBORDINAL aColumns[])
{
    HRESULT hr = S_OK;
    HRESULT hrTemp;

    if (_pXT)
    {
        _pDestElem->AddRef();       // keep element alive while we change it
        for (ULONG k=0; k<cColumns; ++k)
        {
            if (_pXT->IdSrc() == aColumns[k])
            {
                hrTemp = TransferFromSrc();
                if (hrTemp)                     // return last error (arbitrarily)
                    hr = hrTemp;
            }
        }
        _pDestElem->Release();
    }
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     ShowDiscardMessage
//
//  Synopsis:   Build and show the right message to prompt the user
//              if she wants changed discarded, and return results.
//
//  Arguments:  hrError  - error code of the failure
//              dwStatus - for DB_E_ERRORSOCCURRED only, status code
//              pnResult - where to put the value return by MessageBox.
//                         It is up to caller to initialize with sensible
//                         value in case error occurs.
//
//  Returns:    HRESULT
//

HRESULT
CXfer::ShowDiscardMessage (HRESULT hrError, DWORD dwStatus, int *pnResult)
{
    TCHAR   achBufError[FORMS_BUFLEN];
    int     errorDescr = 0;
    DBSPEC  dbs = {NULL, NULL, NULL};
    HRESULT hr;

    Verify(!CDBindMethods::GetDBSpec(PElemOwner(), IdElem(), &dbs, DBIND_SINGLEFILTER));
    Assert(dbs._pStrDataFld);

    switch (hrError)
    {
    case OLE_E_CANTCONVERT:
    case DB_E_UNSUPPORTEDCONVERSION:
    case DB_E_CANTCONVERTVALUE:
        errorDescr = IDS_EE_DB_COERCE;
        break;
        
    case DB_E_DELETEDROW:
        errorDescr = IDS_EE_DB_DELROW;
        break;
        
    case E_ACCESSDENIED:
    case DB_E_READONLYACCESSOR:
    case DB_SEC_E_PERMISSIONDENIED:
        errorDescr = IDS_EE_DB_READ;
        break;
        
    case DB_E_INTEGRITYVIOLATION:
    case DB_E_SCHEMAVIOLATION:
        errorDescr = IDS_EE_DB_SCHEMA;
        break;

    case DB_E_CANCELED:
        errorDescr = IDS_EE_DB_CANCELED;
        break;

    case DB_E_ERRORSOCCURRED:
        switch (dwStatus)
        {
        case DBSTATUS_E_CANTCONVERTVALUE:
        case DBSTATUS_E_DATAOVERFLOW:
        case DBSTATUS_E_SIGNMISMATCH:
            errorDescr = IDS_EE_DB_COERCE;
            break;

        case DBSTATUS_E_PERMISSIONDENIED:
            errorDescr = IDS_EE_DB_READ;
            break;

        case DBSTATUS_E_SCHEMAVIOLATION:
        case DBSTATUS_E_INTEGRITYVIOLATION:
            errorDescr = IDS_EE_DB_SCHEMA;
            break;

        default:
            errorDescr = IDS_EE_DB_OTHER_STATUS;
            break;
        }
        break;
        
    }

    if (errorDescr == 0)
    {
        hr = THR(GetErrorText(hrError, achBufError, ARRAY_SIZE(achBufError)));
    }
    else
    {
        hr = THR(Format(0,
                        achBufError,
                        ARRAY_SIZE(achBufError),
                        MAKEINTRESOURCE(errorDescr),
                        hrError,
                        dwStatus));
    }
    if (hr)
        goto Cleanup;

    hr = THR(_pDestElem->ShowMessage(pnResult,
                                MB_YESNO|MB_ICONEXCLAMATION|/*MB_HELP|*/MB_DEFBUTTON1|
                                MB_APPLMODAL,
                                0,             // help context..
                                IDS_MSG_DB_CANTSAVE,
                                dbs._pStrDataFld,
                                achBufError));
Cleanup:
    RRETURN(hr);
}

#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Member:     IsValidObject
//
//  Synopsis:   Validation method, called by macro IS_VALID(p)
//
BOOL
CXfer::IsValidObject ()
{
    Assert(this);

    return TRUE;
}


char s_achCXfer[] = "CXfer";

//+---------------------------------------------------------------------------
//
//  Member:     Dump
//
//  Synopsis:   Dump function, called by macro DUMP(p,dc)
//
void
CXfer::Dump (CDumpContext&)
{
    IS_VALID(this);
}


//+---------------------------------------------------------------------------
//
//  Member:     GetClassName
//
//  Synopsis:   GetClassName function. (virtual)
//
char *
CXfer::GetClassName ()
{
    return s_achCXfer;
}
#endif  // DBG == 1


////////////////////////////////////////////////////////////////////////////////
//
//  CDataBindingEvents
//
//  This now-poorly named class contains all databinding method calls initiated
//  by the bound element.
//
////////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------
//
//  Member:     CDataBindingEvents::SaveIfChanged
//
//  Synopsis:   If appropriate, save value back to data source for
//              either one binding, or all bindings.  Fires any
//              events appropriate.
//              
//
//  Arguments:  [pElement] - Source element
//              [id]       - The ID of the particular binding
//                           within pElement.  ID_DBIND_ALL indicates
//                           all bindings.
//              [fLoud]    - Should a failure bring an alert up
//                           on the user's screen?
//              [fForceIsCurrent]    - Treat pElement as if it were the
//                           current focus element, even if it isn't
//
//  Returns:    S_OK       - Success (or no actual binding)
//              S_FALSE    - user reverted value to database version
//              E_ABORT    - user cancelled update
//              E_*        - failure
//
//
//---------------------------------------------------------------

HRESULT
CDataBindingEvents::SaveIfChanged(CElement * pElement, LONG id, BOOL fLoud,
                                    BOOL fForceIsCurrent)
{
    CXfer     **ppXfer;
    int         i;
    DWORD       dwCookie;
    
    BOOL        fWasInSave = _fInSave;
    
    _fInSave = TRUE;                // recursion detection
    
    CDoc       *pDoc = pElement->Doc();
    BOOL        fCurrent = fForceIsCurrent ||
                            (pElement->ShouldHaveLayout() &&
                            pDoc->_pElemCurrent == pElement);

    BOOL        fBeforeFired = FALSE;
    BOOL        fErrorFired = FALSE;
    BOOL        fAlerted = FALSE;
    BOOL        fRevert = FALSE;    // initialization not really needed
    BOOL        fDoDefault = TRUE;  // initialization not really needed

    // TODO: are Lock and BlockNewUndoUnits really needed on save TO src?
    CDoc::CLock Lock(pDoc, SERVERLOCK_TRANSITION);
    pElement->AddRef();             // stabilize pointer
    HRESULT hr = pDoc->BlockNewUndoUnits(&dwCookie);
    
    if (hr)
        goto Cleanup;

    // set up loop variables to either do one ID, or else all of them
    if (id == ID_DBIND_ALL)
    {
        ppXfer = _aryXfer;
        i = _aryXfer.Size();
    }
    else
    {
        ppXfer = FindPXfer(pElement, id);

        // if this ID isn't bound just report sucess
        if (!ppXfer)
            goto Unblock;

        i = 1;
    }

    for (/* i, ppXfer initialized above */ ;
         i > 0;
         i--, ppXfer++)
    {
        CXfer *pXfer = *ppXfer;
        DWORD dwStatus = DBSTATUS_S_OK;

        Assert(!hr);    // we quit on failure
        
        hr = pXfer->CompareWithSrc();   //  includes IsWritable check
        if (!hr)
            continue;

        // even if we know that update will fail (that is, even if we got
        //  an error code from the comparison), we might still fire
        //  onbeforeupdate.
        
        if (!fBeforeFired && (fCurrent && !fWasInSave))
        {
            // either set fBeforeFired to TRUE, or bail out leaving
            //  it false, which will cause AfterUpdate to not be fired.
            fBeforeFired = pElement->Fire_onbeforeupdate();
            if (!fBeforeFired)
            {
                hr = E_ABORT;
                goto Unblock;
            }

            // don't crash if bindings yanked from underneath us by script
            if (ppXfer < (CXfer **) _aryXfer
                || ppXfer >= &_aryXfer[_aryXfer.Size()]
                || *ppXfer != pXfer)
            {
                goto Unblock;
            }
        }

        // try to write the new value, if it looks like writing is allowed
        if (!FAILED(hr))
        {
            hr = pXfer->TransferToSrc(&dwStatus);
            if (!hr)
                continue;
        }

        // something went wrong.  We'll either fail now, or else
        //  we'll consider what an <OnErrorUpdate and alert> might
        //  indicate.
        if (fLoud || (fCurrent && !fWasInSave))
        {
            if (!fErrorFired)
            {
                // in the unlikely case that we're nested inside another
                //  onerrorUpdate invocation, bail out rather than risk
                //  infinite recursion.
                if (_fInErrorUpdate)
                    goto Unblock;
                    
                _fInErrorUpdate = TRUE;
                fDoDefault = pElement->Fire_onerrorupdate();
                _fInErrorUpdate = FALSE;
                
                fErrorFired = TRUE;
                
                // don't crash if bindings yanked from underneath us by script
                if (ppXfer < (CXfer **) _aryXfer
                    || ppXfer >= &_aryXfer[_aryXfer.Size()]
                    || *ppXfer != pXfer)
                {
                    goto Unblock;
                }

                if (!pXfer->CompareWithSrc())
                {
                    hr = S_OK;
                    continue;
                }
            }

            Assert(hr);     // we're still working with failure
            
            if (fDoDefault && fLoud)
            {
                if (!fAlerted)
                {
                    int nResult = IDYES; // insurance that on failure, we'll revert
                        
                    // revert value if ShowDiscardMessage fails, or if
                    // user picks revert option
                    fRevert =  (pXfer->ShowDiscardMessage (hr, dwStatus, &nResult)
                                || IDYES == nResult );
                    fAlerted = TRUE;
                }


                if (fRevert)
                {
                    hr = S_FALSE;
                    IGNORE_HR(pXfer->TransferFromSrc());
                    continue;
                }
            }
        }

        // nobody fixed our failure
        Assert(hr);
        goto Unblock;
    }

Unblock:
    if (fBeforeFired && !fErrorFired)
    {
        pElement->Fire_onafterupdate();
    }
    pDoc->UnblockNewUndoUnits(dwCookie);

Cleanup:
    _fInSave = fWasInSave;
    pElement->Release();        // remove stabilizing reference
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------
//
//  Member:     CDataBindingEvents::TransferFromSrc
//
//  Synopsis:   Copy the database value back into the element.
//              Used to revert changes the user may have made.
//              
//
//  Arguments:  [pElement] - Destination element
//              [id]       - The ID for the particular binding
//                           destination within pElement.
//
//  Returns:    S_OK       - Success (or no actual binding)
//              E_*        - failure
//
//
//---------------------------------------------------------------

HRESULT
CDataBindingEvents::TransferFromSrc(CElement *pElement, LONG id)
{
    HRESULT     hr = S_OK;
    CXfer       **ppXfer;

    if (id == ID_DBIND_ALL)
    {
        HRESULT hrt;
        int i;
        for (i=0, ppXfer=&_aryXfer[0]; i<_aryXfer.Size(); ++i, ++ppXfer)
        {
            Assert(pElement == (*ppXfer)->GetDestElement());
            hrt = (*ppXfer)->TransferFromSrc();
            if (!hr)
                hr = hrt;       // remember first error
        }
    }
    else
    {
        ppXfer = FindPXfer(pElement, id);
        if (!ppXfer)
            goto Cleanup;

        Assert(pElement == (*ppXfer)->GetDestElement());
        hr = (*ppXfer)->TransferFromSrc();
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CDataBindingEvents::ValueFromSrc
//
//  Synopsis:   Fetch the database value which would be put into the
//              element if a full transfer were accomplished.  Up to
//              caller to initialize receiving memory, and make sure
//              it is of right size to accommodate the element's
//              data type.
//              
//
//  Arguments:  [pElement] - Destination element
//              [id]       - The ID for the particular binding
//                           destination within pElement.
//              [lpv]      - where to put the value
//
//  Returns:    S_OK       - Success (or no actual binding)
//              E_*        - failure
//
//
//---------------------------------------------------------------

HRESULT
CDataBindingEvents::ValueFromSrc(CElement *pElement, LONG id, LPVOID lpv)
{
    HRESULT     hr = S_OK;
    CXfer       **ppXfer;

    ppXfer = FindPXfer(pElement, id);
    if (!ppXfer)
        goto Cleanup;

    Assert(pElement == (*ppXfer)->GetDestElement());

    hr = (*ppXfer)->ValueFromSrc(lpv);

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CDataBindingEvents::CheckSrcWritable
//
//  Synopsis:   Check whether not we could propagate a change from
//              the given ID of the given element to its data source.
//              
//
//  Arguments:  [pElement] - Destination element
//              [id]       - The ID for the particular binding
//                           destination of pElement.
//
//  Returns:    S_OK       - Not bound or OK to write
//              S_FALSE    - Write-to-source is suppressed because we
//                           are in act of propgating value from source
//                           to destination, and don't want to ping-pong
//                           the value between source and destination.
//              E_*        - error
//
//
//---------------------------------------------------------------

HRESULT
CDataBindingEvents::CheckSrcWritable(CElement *pElement, LONG id)
{
    HRESULT     hr = S_OK;
    CXfer       **ppXfer;
    CXfer       *pXfer;
    CXferThunk  *pXT;

    ppXfer = FindPXfer(pElement, id);

    if (!ppXfer)
        goto Cleanup;

    pXfer = *ppXfer;

    Assert(pElement == pXfer->GetDestElement());

    if (pXfer->FTransferringToDest())
    {
        hr = S_FALSE;
        goto Cleanup;
    }

        
    pXT = pXfer->GetXT();

    if (!pXT->IsWritable(pXfer->GetSrcInstance()))
    {
        hr = E_ACCESSDENIED;    // TODO: is this the right code?
        goto Cleanup;
    }
    
Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------
//
//  Member:     CDataBindingEvents::CompareWithSrc
//
//  Synopsis:   Check whether not the data source and element
//              contents hold equal values.
//              
//
//  Arguments:  [pElement] - Destination element tempate
//              [id]       - The ID for the particular binding
//                           destination of pElement.
//
//  Returns:    S_OK       - Values match.
//              S_FALSE    - Non-match.
//              E_*        - error
//
//
//---------------------------------------------------------------

HRESULT
CDataBindingEvents::CompareWithSrc(CElement *pElement, LONG id)
{
    HRESULT     hr = S_OK;
    CXfer       **ppXfer;
    
    ppXfer = FindPXfer(pElement, id);

    if (!ppXfer)
        goto Cleanup;

    Assert(pElement == (*ppXfer)->GetDestElement());

    hr = (*ppXfer)->CompareWithSrc();

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------
//
//  Member:     CDataBindingEvents::Detach
//
//  Synopsis:   Detach the element from the event sink.
//
//  Arguments:  [pElement] - Source element
//              [id]       - The ID for the particular binding
//                           source within pElement.  Or ID_DBIND_ALL
//                           to indicate all bindings
//
//  Returns:    S_OK       - Success (or no actual binding)
//              E_*        - failure
//
//
//---------------------------------------------------------------

void
CDataBindingEvents::DetachBinding(CElement *pElement, LONG id)
{
    int i;
    CXfer **ppXfer;

    // we loop ppXfer backwards to avoid unnecessary memory copying as
    //  we delete from _aryXfer
    if (id == ID_DBIND_ALL)
    {
        i = _aryXfer.Size();
        ppXfer = &_aryXfer[i-1];
    }
    else
    {
        ClearValue(pElement, id);
        ppXfer = FindPXfer(pElement, id);
        i =  ppXfer ? 1 : 0;
    }

    for ( ; i> 0; i--, ppXfer--)
    {
        CRecordInstance *pRecInstance = DYNCAST(CRecordInstance, (*ppXfer)->GetSrcInstance());
        LONG idElem = (*ppXfer)->IdElem();

        Assert(pElement == (*ppXfer)->GetDestElement());
        if (pElement != (*ppXfer)->GetDestElement())
            continue;

        _aryXfer.Delete(ppXfer-(CXfer **)_aryXfer);
        pRecInstance->RemoveBinding(pElement, idElem);  // deletes Xfer
    }
}


//+---------------------------------------------------------------
//
//  Member:     CDataBindingEvents::ClearValue
//
//  Synopsis:   Clear the value in the element to a null-equivalent.
//
//  Arguments:  [pElement] - Source element
//              [id]       - The ID for the particular binding
//                           source within pElement.  ID_DBIND_ALL
//                           is not allowed.
//
//  Returns:    S_OK       - Success (or no actual binding)
//              E_*        - failure
//
//
//---------------------------------------------------------------

HRESULT
CDataBindingEvents::ClearValue(CElement *pElement, LONG id)
{
    Assert(id != ID_DBIND_ALL);

    HRESULT hr = S_OK;
    CXfer **ppXfer = FindPXfer(pElement, id);

    if (pElement->Doc()->TestLock(FORMLOCK_LOADING | FORMLOCK_UNLOADING))
        goto Cleanup;

    if (ppXfer == NULL)
        goto Cleanup;

    Assert(pElement == (*ppXfer)->GetDestElement());
    hr = (*ppXfer)->ClearValue();

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CDataBindingEvents::EnableTransfers
//
//  Synopsis:   Enable data transfer for this binding.  Called when an
//              object becomes ready.
//
//  Arguments:  [pElement] - Source element
//              [id]       - The ID for the particular binding.
//
//  Returns:    S_OK       - Success (or no actual binding)
//              E_*        - failure
//
//
//---------------------------------------------------------------

HRESULT
CDataBindingEvents::EnableTransfers(CElement *pElement, LONG id, BOOL fTransferOK)
{
    HRESULT     hr = S_OK;
    CXfer       **ppXfer;
    int         i;

    // initialize variables for loop below
    if (id == ID_DBIND_ALL)
    {
        i = _aryXfer.Size();
        ppXfer = _aryXfer;
    }
    else
    {
        i = 1;
        ppXfer = FindPXfer(pElement, id);
    }

    if (ppXfer == NULL)
        goto Cleanup;
    
    for (/* i, ppXfer */; i>0; --i, ++ppXfer)
    {
        Assert(pElement == (*ppXfer)->GetDestElement());
        (*ppXfer)->EnableTransfers(fTransferOK);
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------
//
//  Member:     CDataBindingEvents::FindPXfer, private
//
//  Synopsis:   Find the slot in _aryXfer which holds binding to the
//              given ID,if any.
//              
//
//  Arguments:  [pElement] - Source element
//              [id]       - The ID for the particular binding
//                           source within pElement.
//
//  Returns:    ppXfer or NULL
//
//---------------------------------------------------------------
CXfer **
CDataBindingEvents::FindPXfer(CElement *pElement, LONG id)
{
    CXfer **ppXfer;
    int    i;

    Assert(id != ID_DBIND_ALL);
    
    for (i = _aryXfer.Size(), ppXfer = _aryXfer;
         i > 0;
         i--, ppXfer++)
    {
        if ((*ppXfer)->IdElem() == id)
        {
            return ppXfer;
        }
    }

    return NULL;
}

////////////////////////////////////////////////////////////////////////////////
//
//  CXferThunk
//
////////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------
//
//  Member:     CXferThunk::Create, static
//
//  Synopsis:   Create and init CXferThunk with all information necessary
//              for eventual resolution of the source reference, and
//              instantiation of mechanism for accomplishing transfer.
//
//
//  Arguments:  [pDLC]     - Cursor for data source
//              [strField] - Name of column
//              [vtDest]   - Datatype of value desired
//              [pSDC]     - Data conversion object (usually NULL)
//              [ppXT]     - Where to return a pointer to the XferThunk
//
//  Returns:    S_OK       - XferThunk successfully created
//              S_FALSE    - no XferThunk needed for this element
//              E_*        - error
//
//
//---------------------------------------------------------------

HRESULT
CXferThunk::Create(CDataLayerCursor *pDLC, LPCTSTR strField, CVarType vtDest,
                    ISimpleDataConverter *pSDC, CXferThunk **ppXT)
{
    CXferThunk *pXT = NULL;
    CTypeCoerce::CAN_TYPE cantDest;
    HRESULT hr;
    DBORDINAL uColID;

    // initilize in case of failure
    *ppXT = NULL;

    hr = CTypeCoerce::CanonicalizeType(vtDest.BaseType(), cantDest);
    if (hr)
        goto Cleanup;

    // allocate the memory
    pXT = new CXferThunk();
    if (pXT == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // initialize with one reference
    pXT->_ulRefCount = 1;

    hr = THR(pDLC->GetColumnNumberFromName(strField, uColID));
    if (hr)
        goto Cleanup;

    pXT->_idSrc = uColID;

    pXT->_vtDest = vtDest;
    pXT->_cantDest = cantDest;
    Assert(pXT->_fAccessorError == FALSE);
    Assert(!pXT->_pAccessor);
    Assert(pXT->_dbtSrc == VT_EMPTY);
    pXT->_fWriteSrc = TRUE;
    pXT->_pSDC = pSDC;

    hr = pXT->EnsureAccessor(pDLC);

Cleanup:
    if (!hr)
    {
        *ppXT = pXT;
    }
    else
    {
        delete pXT;
    }
    
    RRETURN(hr);
}


HRESULT
CXferThunk::QueryInterface (REFIID riid, LPVOID * ppv)
{
    HRESULT hr;

    Assert(ppv);

    if (riid == IID_IUnknown)
    {
        *ppv = this;
        ((LPUNKNOWN)*ppv)->AddRef();
        hr = S_OK;
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    RRETURN(hr);
}


ULONG
CXferThunk::AddRef (void)
{
    return ++_ulRefCount;
}


ULONG
CXferThunk::Release (void)
{

    if (--_ulRefCount == 0)
    {
        _ulRefCount = ULREF_IN_DESTRUCTOR;
        delete this;
        return 0;
    }

    return _ulRefCount;
}


CXferThunk::~CXferThunk()
{
    if (_pAccessor)
    {
        _pAccessor->Detach();
        _pAccessor = NULL;
    }
}

//+---------------------------------------------------------------
//
//  Member:     CXferThunk::EnsureAccessor, private
//
//  Synopsis:   If we haven't ever tried to get an accessor before, try
//              to get one now.  If it fails for a non-recoverable reason
//              set _fAccessorError flag so we don't keep trying.
//
//  Arguments:  [pDLC]    - DataLayerCursor through which we get the
//                          OLE-DB accessor.
//
//  Returns:    S_OK:       We got an accessor.
//              S_FALSE:    We couldn't get an accessor due to a persistent
//                          error (e.g. the column name referenced in the
//                          DATAFLD doesn't exist).
//              E_*         Error of some sort 
//
//                         * * * * WARNING * * * * 
//  NOTE THAT THIS FUNCTION CAN RETURN S_OK AND YET STILL LEAVE _pAccessor NULL!
//
//---------------------------------------------------------------
HRESULT
CXferThunk::EnsureAccessor(CDataLayerCursor *pDLC)
{
    HRESULT hr = S_OK;

    if (!_pAccessor && !_fAccessorError)
    {
        // TODO: for now, we assume that we will be fetching
        //  from HROWs.  When we add IDispatch-based sources,
        //  we'll need to do better.
        CHRowAccessor *pHRowAccessor = new CHRowAccessor;
        if (!pHRowAccessor)
        {
            hr = E_OUTOFMEMORY;            
            goto Cleanup;
        }

        hr = pHRowAccessor->Init(this, pDLC);
        if (hr)
        {
            delete pHRowAccessor;
            // TODO:: We really should report this error someday, someway,
            // and differentiate from recoverable and non-recoverable errors.
            // For now, we presume all accessor creation failures are non-recov.
            hr = S_OK;                  // look like we succeeded
            _fAccessorError = TRUE;
        }
        else
        {
            _fAccessorError = FALSE;
            _pAccessor = pHRowAccessor;
        }
    }

Cleanup:
    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     CXferThunk::ValueFromSrc, public
//
//  Synopsis:   Fetch a bound value suiable for stuffing into a destination
//              element.  It is up to caller to ensure that receiving
//              memory buffer is suitable for receiving the element's
//              desired type, and to whatever memory initialization is
//              required.
//
//  Arguments:  [pSrc]     - Source instance.  Concrete type must
//                           match that expected my the CXferThunk.
//              [lpv]      - destination memory buffer
//
//  Returns:    S_OK:       All OK.
//              E_*         Error of some sort
//
//---------------------------------------------------------------

HRESULT
CXferThunk::ValueFromSrc (CInstance *pSrc, LPVOID lpv, CElement *pElem)
{
    HRESULT hr;

    hr = _pAccessor ? THR(_pAccessor->ValueFromSrc(this, pSrc, lpv, pElem))
                    : E_FAIL;
    
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CXferThunk::TransferToSrc, public
//
//  Synopsis:   Accomplish a transfer from a destination element
//              back to its source instance.
//
//  Arguments:  [pSrc]     - Source instance.  Concrete type must
//                           match that expected my the CXferThunk.
//              [pCEDest]  - destination element instance
//              [pdwStatus] - used to pass pack status information
//                            from OLE DB
//
//---------------------------------------------------------------

HRESULT
CXferThunk::ValueToSrc(CInstance *pSrc, LPVOID lpv, DWORD *pdwStatus, CElement *pElem)
{
    HRESULT hr;

    hr = _pAccessor ? THR(_pAccessor->ValueToSrc(this, pSrc, lpv, pdwStatus, pElem))
                    : E_FAIL;
    
    RRETURN(hr);
}

BOOL
CXferThunk::IsWritable(CInstance *pSrc)
{
    BOOL fRet = FALSE;

    if (_pAccessor)
    {
        if (!_fWriteSrc)
        {
            goto Cleanup;
        }
        fRet = _pAccessor->IsSrcWritable(pSrc);
    }

Cleanup:
    return fRet;
}

//+---------------------------------------------------------------
//
//  Member:     CXferThunk::PvInitVar, public
//
//  Synopsis:   Initialize variant based on the type desired by an
//              XferThunk's element, and return a pointer either to
//              beginning of the variant or to the data-portion,
//              depending on what the element wants.
//
//  Arguments:  [pvar]     - variant to be initalized
//
//  Returns:    Pointer to beginning or data portion of variant.
//
//  Notes:
//      Arranges that:
//      1) If the variant isn't further manipulated, VariantClear
//         will be harmless.
//      2) If we are doing some cheating where the data fetch is going
//         simulate a variant, or we are otherwise going to rely
//         on VariantClear to release a value, the VT will have been
//         set correctly
//      3) If things go wrong, we'll pass an appropriate empty-equivalent
//         value
//
//---------------------------------------------------------------

VOID *
CXferThunk::PvInitVar(VARIANT *pvar, CVarType vt)
{
    VOID *pv = pvar;
    
#ifdef UNIX
    CY_INT64(&pvar->cyVal) = 0;
#else
    pvar->cyVal.int64 = 0;
#endif
    if (vt.BaseType() == VT_VARIANT)
    {
        pvar->vt = VT_EMPTY;
    }
    else
    {
        pvar->vt = vt.BaseType();
        if (!vt.FInVariant())
        {
            pv = &pvar->iVal;
        }
    }
    return pv;
}

VOID *
CXferThunk::PvInitVar(VARIANT *pvar) const
{
    return PvInitVar(pvar, _vtDest);
}

// DBData type used to fetch and set database data
// we may fetch the data into the beginning of the variant, or
// else directly into the data portion, depending on the datatype
struct DBData {
    DWORD   dwStatus;
    VARIANT var_data;
};

//+---------------------------------------------------------------
//
//  Member:     CHRowAccessor::Init, CAccessor
//
//  Synopsis:   Initialize a helper object for a CXferThunk for
//              accomplishing a transfer from HROW sources.
//
//  Arguments:  [pXT]      - The owning CXferThunk.
//
//---------------------------------------------------------------

HRESULT
CXferThunk::CHRowAccessor::Init(CXferThunk *pXT, CDataLayerCursor *pDLC)
{
    IS_VALID(pXT);

    CVarType  vtDest = pXT->_vtDest;
    DBBINDING binding;
    DBTYPE    dbType;
    HRESULT   hr;
    const CDataLayerCursor::ColumnInfo *pCI;
    size_t    oIn = 0;

    Assert(vtDest != VT_EMPTY);
    Assert(pDLC);

    hr = THR(pDLC->GetPColumnInfo(pXT->IdSrc(), &pCI));
    if (hr)
    {
        goto Cleanup;
    }

    dbType = pCI->dwType;

    // Let's plan our access and conversion strategies.  First, we figure out
    //  how to interact with the database.

    // under certain special circumstances, we don't use the provider's data
    //  type for the Rowset accessor.
    
    Assert(vtDest.BaseType() != DBTYPE_WSTR && vtDest.BaseType() != DBTYPE_STR);
    if (dbType != vtDest.BaseType())        // A type coercion is necessary.
    {
        // see if DSO wants us to use its SimpleDataConverter
        Assert(!pXT->_fUseSDC);
        if (pXT->_pSDC)
        {
            DBTYPE dbTypeTemp;
            
            switch (dbType)
            {
            // map date-like types into DBTYPE_DATE
            case DBTYPE_DATE:
            case DBTYPE_DBDATE:
            case DBTYPE_DBTIME:
            case DBTYPE_DBTIMESTAMP:
                dbTypeTemp = DBTYPE_DATE;
                break;

            // map fixed-point numeric types into DBTYPE_DECIMAL
            case DBTYPE_NUMERIC:
                dbTypeTemp = DBTYPE_DECIMAL;
                break;

            default:
                dbTypeTemp = dbType;
                break;
            }
            
            if (S_OK == pXT->_pSDC->CanConvertData(dbTypeTemp, vtDest.BaseType()))
            {
                pXT->_fUseSDC = TRUE;
                dbType = dbTypeTemp;
            }
        }

        if (!pXT->_fUseSDC)
        {
            // If control wants a string, let's
            //  Assume that provider can deal with WSTRs and BSTRs.

            // Note that all of our conversion code requires BSTRs.
            switch(vtDest.BaseType())
            {
            case DBTYPE_BSTR:
                if(dbType != DBTYPE_R8 && dbType != DBTYPE_R4) dbType = DBTYPE_BSTR;
                break;

            case DBTYPE_VARIANT:
                // if the control wants a variant and the database has a non-variant
                // type, get the provider to convert to BSTR first.
                if (!CTypeCoerce::FVariantType(dbType))
                    dbType = DBTYPE_BSTR;
                break;
                
            default:
                if (dbType == DBTYPE_STR || dbType == DBTYPE_WSTR)
                {
                    dbType = DBTYPE_BSTR;
                }
                break;
            }
        }
    }
    Assert(pXT->_fUseSDC || (dbType != DBTYPE_WSTR && dbType != DBTYPE_STR));
    Assert(!pXT->_fUseSDC || CTypeCoerce::FVariantType(dbType));

    
    Assert(pXT->_dbtSrc == dbType || pXT->_dbtSrc == VT_EMPTY);
    pXT->_dbtSrc = dbType;

    // now figure out how we will convert what we fetch from the database
    //  to what the consumer desires

    // following values 0-filled at "new" time
    Assert(pXT->_cantSrc == CTypeCoerce::TYPE_NULL);  // used as conversion flg

    // when exchanging values with the HROW, should we pass a pointer into the
    //  data portion of a variant, or to the variant as a whole?
    // (Note: VT_DECIMAL overlays the entire variant)
    if (dbType != VT_VARIANT && dbType != VT_DECIMAL)
    {
        oIn = FIELD_OFFSET(VARIANT, iVal);
    }
        
    // If a type coercsion will be required, lay the groundwork
    if (dbType != vtDest.BaseType())
    {
        if (dbType == VT_NULL)
        {
            hr = OLE_E_CANTCONVERT;
        }
        else if (pXT->_fUseSDC)
        {
            hr = S_OK;
            pXT->_cantSrc = dbType;
        }
        else
        {
            hr = CTypeCoerce::CanonicalizeType(dbType, pXT->_cantSrc);

            // we use _cantSrc to indicate whether or not coercion needed
            Assert(hr || pXT->_cantSrc != CTypeCoerce::TYPE_NULL);
        }
        if (hr)
        {
            goto Cleanup;
        }
    }

    binding.iOrdinal = pXT->IdSrc();
    binding.obStatus = FIELD_OFFSET(DBData, dwStatus);
    binding.obValue = FIELD_OFFSET(DBData, var_data) + oIn;
    binding.pBindExt = 0;
    binding.cbMaxLen = 0;
    binding.dwFlags = 0;
    binding.wType = dbType;
    binding.eParamIO = DBPARAMIO_NOTPARAM;
    binding.dwPart = DBPART_STATUS | DBPART_VALUE;
    binding.dwMemOwner = DBMEMOWNER_CLIENTOWNED;
    binding.bPrecision = 0;
    binding.bScale = 0;


    hr = THR_NOTRACE(pDLC->CreateAccessor(_hAccessor,
                        DBACCESSOR_ROWDATA, &binding, 1 ));
    if (hr)
    {
        goto Cleanup;
    }

    // remember whether the column is writeable
    pXT->_fWriteSrc = ((pCI->dwFlags &
                        (DBCOLUMNFLAGS_WRITE | DBCOLUMNFLAGS_WRITEUNKNOWN)) != 0);

    // if we succeeded, keep DLCursor alive during my lifetime
    _pDLC = pDLC;
    _pDLC->AddRef();

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CHRowAccessor::Detach, CAccessor
//
//  Synopsis:   Destroy a CHRowAccessor, releasing any resources it
//              owns, along with its own memory.
//
//---------------------------------------------------------------

void
CXferThunk::CHRowAccessor::Detach()
{
    if (_hAccessor)
    {
        Assert(_pDLC);
        _pDLC->ReleaseAccessor(_hAccessor);
        Assert(_hAccessor == NULL);
    }
    
    if (_pDLC)
        _pDLC->Release();
    
    delete this;
}

//+---------------------------------------------------------------
//
//  Member:     CHRowAccessor::ValueFromSrc, CAccessor
//
//  Synopsis:   Accomplish the actual transfer from the HROW source,
//              to a memory location expecting the bound-element's native
//              data type.
//
//  Arguments:  [pXT]      - The owning CXferThunk.
//              [pSrc]     - source instance
//              [lpvData]  - where to put the data.  It is up to caller
//                           to 0 initialize!
//
//  Returns:    S_OK:       All OK..
//              E_*         Error of some sort
//
//---------------------------------------------------------------

HRESULT
CXferThunk::CHRowAccessor::ValueFromSrc (const CXferThunk *pXT,
                                         CInstance *pSrc,
                                         LPVOID lpvData,
                                         CElement *pElemBound) const
{
    // shouldn't need this const_cast, but the IS_VALID macros
    //  weren't designed to take into account const methods.
    Assert(IS_VALID(const_cast<CXferThunk::CHRowAccessor *>(this)));
    
    HRESULT     hr = S_OK;
    CRecordInstance *pRecInstance;
    HROW        hRow;

    pRecInstance = DYNCAST(CRecordInstance, pSrc);

    hRow = pRecInstance->GetHRow();

    // if we have a NULL hrow, we skip any fetch from the Rowset, and
    //  rely on the fact that we've already initialized pOut in a manner
    //  consisting with pushing empty data into the destination element.
    if (hRow != DB_NULL_HROW)
    {
        DBData      dbValue;
        VOID       *pSrcData;
        
        // prepare the variant which will receive the database value.
        pSrcData = CXferThunk::PvInitVar(&dbValue.var_data, pXT->_dbtSrc);

        hr = THR(_pDLC->GetData(hRow, _hAccessor, (void *) &dbValue));
        Assert(FAILED(hr) || hr == S_OK);

        // VT_DECIMAL overlaps VARIANT completely.  Some providers write
        // into the DECIMAL.wReserved field, wiping out the VARIANT.vt field
        // that we carefully set up in PvInitVar.  Protect against such badness.
        if (pXT->_dbtSrc == VT_DECIMAL)
        {
            dbValue.var_data.vt = VT_DECIMAL;
        }
        
        if (!hr)
        {
            CVarType vtDest = pXT->_vtDest;
            
            if (dbValue.dwStatus == DBSTATUS_S_ISNULL)
            {
                // We got a NULL; rely on pre-clearing of lpvData by caller.
                // However, if destination wants VT_NULL, then he has
                //  pre-initialized vt to VT_EMPTY, and we want VT_NULL.
                if (vtDest.BaseType() == VT_VARIANT)
                {
                    ((VARIANT *) lpvData)->vt = VT_NULL;
                }
            }
            else
            {
                BYTE *pDest = (BYTE *) lpvData;
                CTypeCoerce::CAN_TYPE cantSrc = pXT->_cantSrc;
                CTypeCoerce::CAN_TYPE cantDest = pXT->_cantDest;
                
                if (vtDest.FInVariant())
                {
                    pDest += FIELD_OFFSET(VARIANT, iVal);
                }
                
                if (cantSrc == CTypeCoerce::TYPE_NULL)
                {
                    // no conversion required, just copy the data bits to caller's
                    //  buffer
                    memcpy(pDest, pSrcData, CTypeCoerce::MemSize(cantDest));
                    // owner of lpvData now has reponsibility for freeing
                    //  any BSTR's etc.
                }
                else if (pXT->_fUseSDC)
                {
                    // SimpleDataConverter converts between variants, but
                    // pDest usually doesn't point into a variant.  So we
                    // convert into a temp variant, then copy the value.
                    VARIANT varTemp;
                    IHTMLElement *pHTMLElement = NULL;
                    
                    VariantInit(&varTemp);
                    if (pElemBound)
                    {
                        IGNORE_HR(pElemBound->QueryInterface(IID_IHTMLElement,
                                                        (void**)&pHTMLElement));
                    }

                    hr = pXT->_pSDC->ConvertData(dbValue.var_data,
                                                        vtDest.BaseType(),
                                                        pHTMLElement,
                                                        &varTemp);
                    if (!hr)
                    {
                        memcpy(pDest, &varTemp.iVal, CTypeCoerce::MemSize(cantDest));
                    }
                    else
                    {
                        dbValue.dwStatus = DBSTATUS_E_CANTCONVERTVALUE;
                        hr = DB_E_CANTCONVERTVALUE;
                    }
                    VariantClear(&dbValue.var_data);
                    ReleaseInterface(pHTMLElement);
                }
                else
                {
                    // conversion required, do it
                    hr = THR(CTypeCoerce::ConvertData(cantSrc,
                                                      pSrcData,
                                                      cantDest,
                                                      pDest ) );
                    // caller is not repsonsible for our variant data;
                    //  free it.
                    VariantClear(&dbValue.var_data);
                }
            }
        }
        else
        {
            // if what went wrong was missing data, we treat it like
            // VT_EMPTY success.  We rely on caller pre-initializing
            // his receiving buffer.
            if (hr == DB_E_ERRORSOCCURRED)
            {
                if (dbValue.dwStatus == DBSTATUS_E_UNAVAILABLE)
                {
                    hr= S_OK;
                    // proceed with normal comparison or transfer
                }
            }
        }
    }
    

    RRETURN(hr);
}

//+---------------------------------------------------------------
//
//  Member:     CHRowAccessor::ValueToSrc, CAccessor
//
//  Synopsis:   Accomplish the actual transfer to the HROW source,
//              on behalf of the owning CXferThunk
//
//  Arguments:  [pXT]      - The owning CXferThunk.
//              [pSrc]     - source instance
//              [lpvData]  - pointer to data
//              [pdwStatus] - place for OLE DB status
//
//---------------------------------------------------------------

HRESULT
CXferThunk::CHRowAccessor::ValueToSrc(const CXferThunk *pXT,
                                      CInstance *pSrc,
                                      LPVOID lpvData,
                                      DWORD *pdwStatus,
                                      CElement *pElemBound) const
{
    HRESULT     hr;
    CRecordInstance *pRecInstance;
    HROW        hRow;
    DBData      dbValue;
    VOID       *pSrcData;
    
    CTypeCoerce::CAN_TYPE cantSrc = pXT->_cantSrc;
    DBTYPE      dbtSrc = pXT->_dbtSrc;
    CVarType    vtDest = pXT->_vtDest;
    
    // shouldn't need this const_cast, but the IS_VALID macros
    //  weren't designed to take into account const methods.
    Assert(IS_VALID(const_cast<CXferThunk::CHRowAccessor *>(this)));

    Assert(*pdwStatus == DBSTATUS_S_OK || *pdwStatus == DBSTATUS_S_ISNULL);    // caller-initialized
    dbValue.dwStatus = *pdwStatus;      // initialize for normal transfer

    pRecInstance = DYNCAST(CRecordInstance, pSrc);
    
    hRow = pRecInstance->GetHRow();

    // if NULL HROW, we can't transfer any data to it
    if (hRow == DB_NULL_HROW)
    {
        hr = E_FAIL;
        goto Done;
    }

    // Just because we think the element likes to give us, say
    //  strings in a variant, doesn't mean that it really does!
    if (vtDest.FInVariant() && ((VARIANT *) lpvData)->vt != vtDest.BaseType())
    {
        Assert(!"bound parameter of inconsistent datatype");
        hr = E_FAIL;    // TODO: error code?
        goto Done;
    }
    
    // prepare the structure which we will use to exchange data with
    //  the database.
    pSrcData = CXferThunk::PvInitVar(&dbValue.var_data, dbtSrc);
    
    // Determine if we want NULL-equivalent data in the source column,
    //  or a more "normal" transfer.
    if (vtDest.BaseType() == VT_VARIANT
        && (((VARIANT *) lpvData)->vt == VT_NULL
            || (dbtSrc != VT_VARIANT
                && ((VARIANT *) lpvData)->vt == VT_EMPTY ) ) )
    {
        dbValue.dwStatus = DBSTATUS_S_ISNULL;
        if (dbtSrc == VT_VARIANT)
        {
            dbValue.var_data.vt = VT_NULL;
        }
    }
    else
    {
        // locals are not really named intuitively -- we are transferring
        //  from Dest to Src
        BYTE *pDest = (BYTE *) lpvData;
        CTypeCoerce::CAN_TYPE cantDest = pXT->_cantDest;
        
        if (vtDest.FInVariant())
        {
            pDest += FIELD_OFFSET(VARIANT, iVal);
        }
        
        if (cantSrc == CTypeCoerce::TYPE_NULL)
        {
            // no conversion required, just copy the data bits to caller's
            //  buffer
            memcpy(pSrcData, pDest, CTypeCoerce::MemSize(cantDest));
        }
        else if (pXT->_fUseSDC)
        {
            // SimpleDataConverter uses variants, so copy into a temp
            // variant, then convert.
            VARIANT varTemp;
            IHTMLElement *pHTMLElement = NULL;
            
            V_VT(&varTemp) = vtDest.BaseType();
            memcpy(&varTemp.iVal, pDest, CTypeCoerce::MemSize(cantDest));

            if (pElemBound)
            {
                IGNORE_HR(pElemBound->QueryInterface(IID_IHTMLElement,
                                                (void**)&pHTMLElement));
            }

            hr = pXT->_pSDC->ConvertData(varTemp, dbtSrc,
                                            pHTMLElement, &dbValue.var_data);
            ReleaseInterface(pHTMLElement);
            
            if (hr)
            {
                dbValue.dwStatus = DBSTATUS_E_CANTCONVERTVALUE;
                hr = DB_E_CANTCONVERTVALUE;
                goto Cleanup;
            }
        }
        else
        {
            // conversion required, do it
            hr = THR(CTypeCoerce::ConvertData(cantDest,
                                              pDest,
                                              cantSrc,
                                              pSrcData ) );
            if (hr)
            {
                goto Cleanup;
            }
        }
    }
        
    hr = THR(_pDLC->SetData(hRow, _hAccessor, (void *) &dbValue));
    if (cantSrc != CTypeCoerce::TYPE_NULL)
    {
        VariantClear(&dbValue.var_data);
    }
    
Cleanup:
    *pdwStatus = dbValue.dwStatus;
    
Done:
    RRETURN(hr);
}

BOOL
CXferThunk::CHRowAccessor::IsSrcWritable(CInstance *pSrc) const
{
    return (DYNCAST(CRecordInstance, pSrc)->GetHRow() != NULL);
}


#if DBG==1
char s_achCXferThunk[] = "CXferThunk";

char*
CXferThunk::GetClassName()
{
    return s_achCXferThunk;
}

BOOL
CXferThunk::IsValidObject ()
{
    Assert(this);
    Assert(_vtDest.BaseType() != VT_EMPTY);
    Assert(!_pAccessor || _dbtSrc != VT_EMPTY);
    Assert(!_pAccessor || _pAccessor->IsValidObject ());
    return TRUE;
}

void
CXferThunk::Dump (CDumpContext&)
{
    IS_VALID(this);
}

char s_achCHRowAccessor[] = "CHRowAccessor";

char*
CXferThunk::CHRowAccessor::GetClassName()
{
    return s_achCHRowAccessor;
}

BOOL
CXferThunk::CHRowAccessor::IsValidObject ()
{
    Assert(this);
    return TRUE;
}

void
CXferThunk::CHRowAccessor::Dump (CDumpContext&)
{
    IS_VALID(this);
}
#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\dbind\dbtask.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1996-1997
//  All rights Reserved.
//  Information contained herein is Proprietary and Confidential.
//
//  Contents:   Data Bind Task objects
//
//  Classes:    
//
//  History:    10/1/96     (sambent) created


#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include <formkrnl.hxx>
#endif

#ifndef X_PRGSNK_H_
#define X_PRGSNK_H_
#include <prgsnk.h>
#endif

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include "binder.hxx"
#endif

#ifndef X_DBTASK_HXX_
#define X_DBTASK_HXX_
#include "dbtask.hxx"
#endif

#ifndef X_SIMPDC_HXX_
#define X_SIMPDC_HXX_
#include "simpdc.hxx"
#endif

PerfDbgTag(tagDBTask,"Databinding","Databinding task");
MtDefine(CDataBindTask, DataBind, "CDataBindTask");
MtDefine(CDataBindTask_aryCRI_pv, CDataBindTask, "CDataBindTask::_aryCRI::_pv");


/////////////////////////////////////////////////////////////////////////////
/////                       CDataBindTask methods                       /////
/////////////////////////////////////////////////////////////////////////////

/*  Each CDoc owns a CDataBindTask to manage its databinding chores.
*/


//+-------------------------------------------------------------------------
// Member:      SetEnabled (public)
//
// Synopsis:    change the enabled state of the task
//
// Arguments:   fEnabled    new state
//
// Returns:     old state

BOOL
CDataBindTask::SetEnabled(BOOL fEnabled)
{
    BOOL fOldEnabled = _fEnabled;
    PerfDbgLog1(tagDBTask, this, "fEnabled is now %d", fEnabled);
    _fEnabled = fEnabled;
    DecideToRun();
    return fOldEnabled;
}


//+-------------------------------------------------------------------------
// Member:      Add Deferred Binding (public)
//
// Synopsis:    add a binder to the list of deferred bindings
//
// Arguments:   pdsb        the new binding

HRESULT
CDataBindTask::AddDeferredBinding(CDataSourceBinder *pdsb, BOOL fSetWait)
{
    HRESULT hr = S_OK;
    Assert(pdsb);

    if (pdsb->_fOnTaskList)
    {
        RemoveDeferredBinding(pdsb);
    }
    Assert(!pdsb->_fOnTaskList);

    PerfDbgLog2(tagDBTask, this, "Add binding for %ls %x",
                pdsb->GetElementConsumer()->TagName(), pdsb->GetElementConsumer());
    
    // add new binder to my waiting list
    pdsb->_pdsbNext = _pdsbWaiting;
    _pdsbWaiting = pdsb;
    pdsb->_fOnTaskList = TRUE;

    if (fSetWait)
    {
        SetWaiting();
    }
    
    DecideToRun();
    
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
// Member:      RemoveBindingFromList (private)
//
// Synopsis:    remove a binder from the list of deferred bindings
//
// Arguments:   pdsb                binder to remove
//              ppdsbListHead       pointer to head of list
//              pdwProgCookie       progress cookie for this list

void
CDataBindTask::RemoveBindingFromList(CDataSourceBinder *pdsb,
                                        CDataSourceBinder **ppdsbListHead,
                                        DWORD *pdwProgCookie)
{
    CDataSourceBinder **ppdsbPrev = ppdsbListHead;
    
    // remove binder the list
    while (*ppdsbPrev)
    {
        if (*ppdsbPrev == pdsb)
            *ppdsbPrev = pdsb->_pdsbNext;       // delete binder from list
        else
            ppdsbPrev = &((*ppdsbPrev)->_pdsbNext);
    }

    // if list is now empty, deletes its progress item
    if (*ppdsbListHead == NULL && *pdwProgCookie)
    {
        IProgSink *pProgSink = CMarkup::GetProgSinkHelper(_pMarkup);

        if (pProgSink)
        {        
            pProgSink->DelProgress(*pdwProgCookie);
            *pdwProgCookie = 0;
        }
    }
}


//+-------------------------------------------------------------------------
// Member:      Remove Deferred Binding (public)
//
// Synopsis:    remove a binder from the list of deferred bindings
//
// Arguments:   pdsb        the new binding

HRESULT
CDataBindTask::RemoveDeferredBinding(CDataSourceBinder *pdsb)
{
    HRESULT hr = S_OK;
    Assert(pdsb);

    PerfDbgLog2(tagDBTask, this, "Remove binding for %ls %x",
                pdsb->GetElementConsumer()->TagName(), pdsb->GetElementConsumer());

    // remove binder from my in-process list
    RemoveBindingFromList(pdsb, &_pdsbInProcess, &_dwProgCookieActive);

    // remove binder from my waiting list
    RemoveBindingFromList(pdsb, &_pdsbWaiting, &_dwProgCookieWait);
    
    pdsb->_fOnTaskList = FALSE;

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
// Member:      RemoveDataEventRequestsFor (public)
//
// Synopsis:    remove all ENSURE_DATA_EVENTS requests for the given element
//
// Arguments:   pelProvider     the element whose requests we should remove

HRESULT
CDataBindTask::RemoveDataEventRequestsFor(CElement *pelProvider)
{
    HRESULT hr = S_OK;
    CDataSourceBinder *pdsb, *pdsbNext;

    PerfDbgLog2(tagDBTask, this, "Remove data event requests for %ls %x",
                pelProvider->TagName(), pelProvider);

    // remove requests from my in-process list
    for (pdsb = _pdsbInProcess;  pdsb;  pdsb = pdsbNext)
    {
        pdsbNext = pdsb->_pdsbNext;
        if (pdsb->_dbop == BINDEROP_ENSURE_DATA_EVENTS &&
            pelProvider == pdsb->GetElementConsumer())
        {
            RemoveBindingFromList(pdsb, &_pdsbInProcess, &_dwProgCookieActive);
            delete pdsb;
        }
    }

    // remove requests from my waiting list
    for (pdsb = _pdsbWaiting;  pdsb;  pdsb = pdsbNext)
    {
        pdsbNext = pdsb->_pdsbNext;
        if (pdsb->_dbop == BINDEROP_ENSURE_DATA_EVENTS &&
            pelProvider == pdsb->GetElementConsumer())
        {
            RemoveBindingFromList(pdsb, &_pdsbWaiting, &_dwProgCookieWait);
            delete pdsb;
        }
    }

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
// Member:      InitCurrentRecord (public)
//
// Synopsis:    add to the list of CRI's that need init
//
// Arguments:   pCRI        CRI that needs init

HRESULT
CDataBindTask::InitCurrentRecord(CCurrentRecordInstance *pCRI)
{
    HRESULT hr = _aryCRI.Append(pCRI);
    if (!hr)
    {
        pCRI->AddRef();
        DecideToRun();
    }
    return hr;
}


//+-------------------------------------------------------------------------
// Member:      DecideToRun (public)
//
// Synopsis:    unblock if there's work to do, and permission to do it
//
// Arguments:   none

void
CDataBindTask::DecideToRun()
{
    BOOL fBlocked = !_fEnabled;

    // if there's work waiting, set up a progress sink in the Doc.
    // This delays onload until databinding is done.
    if (_dwProgCookieWait == 0 && _fWorkWaiting && _pdsbWaiting)
    {
        IProgSink *pProgSink = CMarkup::GetProgSinkHelper(_pMarkup);

        if (pProgSink)
            IGNORE_HR(pProgSink->AddProgress(PROGSINK_CLASS_DATABIND, &_dwProgCookieWait));
    }

    if (_fEnabled)
    {
        // transfer waiting tasks to the active list, if it's empty
        if (_fWorkWaiting && !_pdsbInProcess)
        {
            int cBindingsMoved = 0;

            // The binders were added to the front of the waiting list, so
            // they appear in reverse order.  We reverse the list here, so that
            // we process them in the same order they appeared on the page.
            // This is pshychologically more pleasant, and also improves performance
            // (we change the page top-to-bottom, so recalc is faster).
            // This also processes nested tables in the right order (outside-in).
            while (_pdsbWaiting)
            {
                CDataSourceBinder *pdsbTemp = _pdsbWaiting->_pdsbNext;
                _pdsbWaiting->_pdsbNext = _pdsbInProcess;
                _pdsbInProcess = _pdsbWaiting;
                _pdsbWaiting = pdsbTemp;
                ++ cBindingsMoved;
            }

            PerfDbgLog1(tagDBTask, this, "Moving %d bindings to active list", cBindingsMoved);

            // the previous active list may not have shut down its progress sink
            // yet.  If not, do it now.
            if (_dwProgCookieActive)
            {
                IProgSink *pProgSink = CMarkup::GetProgSinkHelper(_pMarkup);
                Assert(pProgSink);

                pProgSink->DelProgress(_dwProgCookieActive);
                _dwProgCookieActive = 0;
            }
            
            _dwProgCookieActive = _dwProgCookieWait;
            _dwProgCookieWait = 0;

            // tell my progress sink to start supplying feedback
            if (_pdsbInProcess && _dwProgCookieActive)
            {
                IProgSink *pProgSink = CMarkup::GetProgSinkHelper(_pdsbInProcess->GetElementConsumer()->GetMarkup());
                Assert(pProgSink);
                
                IGNORE_HR(pProgSink->SetProgress(_dwProgCookieActive,
                    PROGSINK_SET_STATE | PROGSINK_SET_IDS |
                    PROGSINK_SET_POS | PROGSINK_SET_MAX,
                    PROGSINK_STATE_LOADING, NULL, IDS_DATABINDING, 0, cBindingsMoved));
            }
            _cInProcess = 0;        // OnRun will count up again
        }

        // if there's nothing to do, init the CRIs
        if (!_fBinding && _pdsbInProcess == NULL)
        {
            int i;
            CCurrentRecordInstance **ppCRI;
            CPtrAry<CCurrentRecordInstance*> aryCRI(Mt(CDataBindTask_aryCRI_pv));

            // make a local copy of the array, in case there's reentrancy
            for (i=_aryCRI.Size(), ppCRI=_aryCRI; i>0;  --i, ++ppCRI)
            {
                if (S_OK == aryCRI.Append(*ppCRI))
                {
                    (*ppCRI)->AddRef();
                }
            }
            _aryCRI.ReleaseAll();

            // init all the CRI's 
            for (i=aryCRI.Size(), ppCRI=aryCRI; i>0;  --i, ++ppCRI)
            {
                (*ppCRI)->InitPosition(TRUE);
            }
            aryCRI.ReleaseAll();
        }

        // init-ing the CRI's may have caused new bindings to join the list
        fBlocked = (_pdsbInProcess == NULL);
    }

    // if the waiting list is empty, turn off the waiting flag
    if (_pdsbWaiting == NULL)
        _fWorkWaiting = FALSE;

    SetBlocked(fBlocked);
}


//+-------------------------------------------------------------------------
// Member:      On Run (public, CTask)
//
// Synopsis:    process deferred bindings
//
// Arguments:   dwTimeout       time by which I should finish

void
CDataBindTask::OnRun(DWORD dwTimeout)
{
    HRESULT hr=S_OK;

    _fBinding = TRUE;
    
    // process as many bindings as we can do in the allotted time
    while (_pdsbInProcess)
    {
        CDataSourceBinder *pdsbCurrent = _pdsbInProcess;
#if DBG==1 || defined(PERFTAGS)
        int dbop = pdsbCurrent->_dbop;
        CElement *pElemConsumer = pdsbCurrent->GetElementConsumer();
#endif
        
        _pdsbInProcess = _pdsbInProcess->_pdsbNext; // update the list
        pdsbCurrent->_fOnTaskList = FALSE;
        ++ _cInProcess;                             // track progress

        PerfDbgLog3(tagDBTask, this, "+Op %d for %ls %x",
                        dbop, pElemConsumer->TagName(), pElemConsumer);

        // do the operation the current binder wants
        switch (pdsbCurrent->_dbop)
        {
        case BINDEROP_BIND:
            hr = pdsbCurrent->_fNotReady ? S_FALSE : pdsbCurrent->TryToBind();
            break;

        case BINDEROP_UNBIND:
            hr = pdsbCurrent->UnBind();
            break;

        case BINDEROP_REBIND:
            hr = pdsbCurrent->_fNotReady ? S_FALSE : pdsbCurrent->ReBind();
            break;

        case BINDEROP_ENSURE_DATA_EVENTS:
            hr = pdsbCurrent->EnsureDataEvents();
            // once the events are ensured, we don't need the binder
            if (!hr)
            {
                delete pdsbCurrent;
            }
            break;
        }

        PerfDbgLog4(tagDBTask, this, "-Op %d for %ls %x yielded hr %x",
                        dbop, pElemConsumer->TagName(), pElemConsumer,
                        hr);
        
        // If something went wrong, throw the binder back on the waiting list;
        // we'll try again later, perhaps it'll work then.
        if (hr)
        {
            AddDeferredBinding(pdsbCurrent, FALSE);
        }

        if (GetTickCount() >= dwTimeout)            // don't exceed allotted time
            break;
    }

    // report progress
    if (_dwProgCookieActive)
    {
        IProgSink *pProgSink = CMarkup::GetProgSinkHelper(_pMarkup);
        Assert(pProgSink);

        if (_pdsbInProcess)
        {
            pProgSink->SetProgress(_dwProgCookieActive,
                                    PROGSINK_SET_POS, 0, NULL, 0, _cInProcess, 0);
        }
        else
        {
            pProgSink->DelProgress(_dwProgCookieActive);
            _dwProgCookieActive = 0;
        }
    }

    _fBinding = FALSE;
    
    DecideToRun();              // see if there's more work to do
}


//+-------------------------------------------------------------------------
// Member:      On Terminate (public, CTask)
//
// Synopsis:    shut down the task (possibly before all bindings have happened)
//
// Arguments:   none

void
CDataBindTask::OnTerminate()
{
    if (_pDoc == NULL)
        goto Cleanup;

    Stop();

    _pDoc->SubRelease();
    _pDoc = NULL;
    _pMarkup->SubRelease();
    _pMarkup = NULL;

Cleanup:
    return;
}


//+-------------------------------------------------------------------------
// Member:      Stop (public)
//
// Synopsis:    shut down the task (possibly before all bindings have happened)
//
// Arguments:   none

void
CDataBindTask::Stop()
{
    CDataSourceBinder *pdsb, *pdsbNext;
    IProgSink *pProgSink;

    _fWorkWaiting = FALSE;               // don't process the waiting list
    
    // discard waiting list
    for (pdsb=_pdsbWaiting; pdsb; pdsb=pdsbNext)
    {
        pdsbNext = pdsb->_pdsbNext;
        pdsb->_fOnTaskList = FALSE;
        if (pdsb->_dbop == BINDEROP_ENSURE_DATA_EVENTS)
        {
            delete pdsb;
        }
    }
    _pdsbWaiting = 0;
    
    // discard in-process list
    for (pdsb=_pdsbInProcess; pdsb; pdsb=pdsbNext)
    {
        pdsbNext = pdsb->_pdsbNext;
        pdsb->_fOnTaskList = FALSE;
        if (pdsb->_dbop == BINDEROP_ENSURE_DATA_EVENTS)
        {
            delete pdsb;
        }
    }
    _pdsbInProcess = 0;

    // discard CRI list
    _aryCRI.ReleaseAll();

    // turn off progress items
    pProgSink = CMarkup::GetProgSinkHelper(_pMarkup);
    if (pProgSink && _dwProgCookieWait)
    {
        pProgSink->DelProgress(_dwProgCookieWait);
        _dwProgCookieWait = 0;
    }
    if (pProgSink && _dwProgCookieActive)
    {
        pProgSink->DelProgress(_dwProgCookieActive);
        _dwProgCookieActive = 0;
    }

    ClearInterface(&_pSDC);
}


//+-------------------------------------------------------------------------
// Member:      GetSimpleDataConverter (public)
//
// Synopsis:    return the doc-global SimpleDataConverter, creating it
//              if necessary.  This is used for elements bound with
//              dataFormatAs = localized-text.
//
// Arguments:   none

ISimpleDataConverter *
CDataBindTask::GetSimpleDataConverter()
{
    if (!_pSDC)
    {
        _pSDC = new CSimpleDataConverter;
    }
    return _pSDC;       // not refcounted!!
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\dbind\dmembmgr.cxx ===
#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DMEMBMGR_HXX_
#define X_DMEMBMGR_HXX_
#include "dmembmgr.hxx"
#endif

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include <binder.hxx>       // for CDataSourceProvider
#endif

#ifndef X_DBTASK_HXX_
#define X_DBTASK_HXX_
#include "dbtask.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include <formkrnl.hxx>     // for safetylevel in safety.hxx (via olesite.hxx)
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include <olesite.hxx>
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include <evntprm.hxx>      // for eventparam (needed by fire_ondata*)
#endif

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include <elemdb.hxx>       // for DBSPEC
#endif

#ifndef X_ADO_ADOID_H_
#define X_ADO_ADOID_H_
#include <adoid.h>
#endif

#ifndef X_VBCURSOR_VBDSC_H_
#define X_VBCURSOR_VBDSC_H_
#include <vbcursor/vbdsc.h> // for iid_ivbdsc
#endif

#ifndef X_SIMPDATA_H_
#define X_SIMPDATA_H_
#include <simpdata.h>
#endif

#ifndef X_MSDATSRC_H_
#define X_MSDATSRC_H_
#include <msdatsrc.h>
#endif

#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include <tearoff.hxx>
#endif

#ifndef X_GENERIC_HXX_
#define X_GENERIC_HXX_
#include <generic.hxx>
#endif

#ifndef X_SIMPDC_H_
#define X_SIMPDC_H_
#include "simpdc.h"
#endif

DeclareTag(tagDataMemberMgr, "databinding", "DataMemberMgr methods");
DeclareTag(tagUseDebugSDC, "databinding", "implement SDC with VarChangeType");

MtDefine(COSPProxy, DataBind, "COSPProxy");
MtDefine(CDataMemberMgr, DataBind, "CDataMemberMgr");
MtDefine(CDataMemberMgr_aryDataMember_pv, DataBind, "CDataMemberMgr::_aryDataMember::_pv")

const IID IID_ISimpleDataConverter = {0x78667670,0x3C3D,0x11d2,0x91,0xF9,0x00,0x60,0x97,0xC9,0x7F,0x9B};

#if DBG == 1
MtDefine(CDbgSimpleDataConverter, DataBind, "CDbgSimpleDataConverter");

//+---------------------------------------------------------------------------
//
//  Class:      CDbgSimpleDataConverter
//
//  Purpose:    For debugging, we implement ISimpleDataConverter internally
//              by simply calling VariantChangeTypeEx for certain types
//              that we're interested in testing.
//
//----------------------------------------------------------------------------

class CDbgSimpleDataConverter : public ISimpleDataConverter
{
public:
    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CDbgSimpleDataConverter));
    CDbgSimpleDataConverter(): _ulRefs(1) {}
    
    // IUnknown methods
    HRESULT STDMETHODCALLTYPE   QueryInterface(REFIID riid, void **ppv);
    ULONG STDMETHODCALLTYPE     AddRef() { return ++ _ulRefs; }
    ULONG STDMETHODCALLTYPE     Release();

    // ISimpleDataConverter methods
    HRESULT STDMETHODCALLTYPE ConvertData( 
        VARIANT varSrc,
        long vtDest,
        IUnknown __RPC_FAR *pUnknownElement,
        VARIANT __RPC_FAR *pvarDest);
    
    HRESULT STDMETHODCALLTYPE CanConvertData( 
        long vt1,
        long vt2);

private:
    ULONG   _ulRefs;        // refcount
};

HRESULT STDMETHODCALLTYPE
CDbgSimpleDataConverter::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr;
    
    if (ppv == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ISimpleDataConverter))
    {
        *ppv = this;
        AddRef();
        hr = S_OK;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

Cleanup:
    RRETURN(hr);
}


ULONG STDMETHODCALLTYPE
CDbgSimpleDataConverter::Release()
{
    ULONG ulRefs = --_ulRefs;
    if (ulRefs == 0)
    {
        delete this;
    }
    return ulRefs;
}

HRESULT STDMETHODCALLTYPE
CDbgSimpleDataConverter::ConvertData( 
    VARIANT varSrc,
    long vtDest,
    IUnknown *pUnknownElement,
    VARIANT *pvarDest)
{
    HRESULT hr;

    if (!pvarDest)
    {
        hr = S_OK;
    }
    else if (S_OK != CanConvertData(V_VT(&varSrc), vtDest))
    {
        hr = E_FAIL;
    }
    else
    {
        hr = VariantChangeTypeEx(pvarDest, &varSrc, g_lcidUserDefault, 0, vtDest);
    }
    
    RRETURN(hr);
}

HRESULT STDMETHODCALLTYPE
CDbgSimpleDataConverter::CanConvertData( 
    long vt1,
    long vt2)
{
    HRESULT hr = S_FALSE;

    // one of the types must be BSTR
    if (vt1 != VT_BSTR)
    {
        long vtTemp = vt1;
        vt1 = vt2;
        vt2 = vtTemp;
    }

    if (vt1 != VT_BSTR)
        goto Cleanup;

    // the other can be on the list below
    switch (vt2)
    {
    case VT_DATE:
    case VT_CY:
    case VT_I2:
    case VT_I4:
    case VT_R4:
    case VT_R8:
    case VT_DECIMAL:
        hr = S_OK;
        break;

    default:
        break;
    }

Cleanup:
    return hr;
}

#endif DBG == 1


//+---------------------------------------------------------------------------
//
//  Class:      COSPProxy
//
//  Purpose:    This class serves a single purpose.  Namely, to delay
//              the Release() of the java ocx until we've released the
//              OSP object down to zero.
//
//----------------------------------------------------------------------------

class COSPProxy : OLEDBSimpleProvider
{
    int _refs;
    OLEDBSimpleProvider *_pOSPReal;
    IUnknown *_pUnkOther;
    public:
        DECLARE_MEMALLOC_NEW_DELETE(Mt(COSPProxy))
        COSPProxy() : _pOSPReal(NULL), _pUnkOther(NULL), _refs(1) { }

        HRESULT Init(IUnknown *pOSPReal, IUnknown *pUnkOther)
        {
            HRESULT hr = pOSPReal->QueryInterface(IID_OLEDBSimpleProvider, (void**)&_pOSPReal);
            if (hr)
                goto Cleanup;
            _pUnkOther = pUnkOther;
            _pUnkOther->AddRef();
        Cleanup:
            return hr;
        }

        virtual HRESULT STDMETHODCALLTYPE QueryInterface( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
        {
            HRESULT hr = E_NOINTERFACE;
            *ppvObject = NULL;
            if (riid == IID_IUnknown)
                *ppvObject = (void**)this;
            else if (riid == IID_OLEDBSimpleProvider)
                *ppvObject = (void**)this;
            if (*ppvObject)
            {
                hr = S_OK;
                AddRef();
            }
            return hr;
        }
        
        virtual ULONG STDMETHODCALLTYPE AddRef( void)
        {
            return ++_refs;
        }
        
        virtual ULONG STDMETHODCALLTYPE Release( void)
        {
            if (--_refs == 0)
            {
                // this ordering is crucial
                _pOSPReal->Release();
                _pUnkOther->Release();
                delete this;
                return 0;
            }
            return _refs;
        }
        
        virtual HRESULT STDMETHODCALLTYPE getRowCount( 
            /* [retval][out] */ DBROWCOUNT __RPC_FAR *pcRows)
        {
            return _pOSPReal->getRowCount(pcRows);
        }
        
        virtual HRESULT STDMETHODCALLTYPE getColumnCount( 
            /* [retval][out] */ DB_LORDINAL __RPC_FAR *pcColumns)
        {
            return _pOSPReal->getColumnCount(pcColumns);
        }
        
        virtual HRESULT STDMETHODCALLTYPE getRWStatus( 
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DB_LORDINAL iColumn,
            /* [retval][out] */ OSPRW __RPC_FAR *prwStatus)
        {
            return _pOSPReal->getRWStatus(iRow, iColumn, prwStatus);
        }
        
        virtual HRESULT STDMETHODCALLTYPE getVariant( 
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DB_LORDINAL iColumn,
            /* [in] */ OSPFORMAT format,
            /* [retval][out] */ VARIANT __RPC_FAR *pVar)
        {
            return _pOSPReal->getVariant(iRow, iColumn, format, pVar);
        }
        
        virtual HRESULT STDMETHODCALLTYPE setVariant( 
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DB_LORDINAL iColumn,
            /* [in] */ OSPFORMAT format,
            /* [in] */ VARIANT Var)
        {
            return _pOSPReal->setVariant(iRow, iColumn, format, Var);
        }
        
        virtual HRESULT STDMETHODCALLTYPE getLocale( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrLocale)
        {
            return _pOSPReal->getLocale(pbstrLocale);
        }
        
        virtual HRESULT STDMETHODCALLTYPE deleteRows( 
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DBROWCOUNT cRows,
            /* [retval][out] */ DBROWCOUNT __RPC_FAR *pcRowsDeleted)
        {
            return _pOSPReal->deleteRows(iRow, cRows, pcRowsDeleted);
        }
        
        virtual HRESULT STDMETHODCALLTYPE insertRows( 
            /* [in] */ DBROWCOUNT iRow,
            /* [in] */ DBROWCOUNT cRows,
            /* [retval][out] */ DBROWCOUNT __RPC_FAR *pcRowsInserted)
        {
            return _pOSPReal->insertRows(iRow, cRows, pcRowsInserted);
        }
        
        virtual HRESULT STDMETHODCALLTYPE find( 
            /* [in] */ DBROWCOUNT iRowStart,
            /* [in] */ DB_LORDINAL iColumn,
            /* [in] */ VARIANT val,
            /* [in] */ OSPFIND findFlags,
            /* [in] */ OSPCOMP compType,
            /* [retval][out] */ DBROWCOUNT __RPC_FAR *piRowFound)
        {
            return _pOSPReal->find(iRowStart, iColumn, val, findFlags, compType, piRowFound);
        }
        
        virtual HRESULT STDMETHODCALLTYPE addOLEDBSimpleProviderListener( 
            /* [in] */ OLEDBSimpleProviderListener __RPC_FAR *pospIListener)
        {
            return _pOSPReal->addOLEDBSimpleProviderListener(pospIListener);
        }
        
        virtual HRESULT STDMETHODCALLTYPE removeOLEDBSimpleProviderListener( 
            /* [in] */ OLEDBSimpleProviderListener __RPC_FAR *pospIListener)
        {
            return _pOSPReal->removeOLEDBSimpleProviderListener(pospIListener);
        }
        
        virtual HRESULT STDMETHODCALLTYPE isAsync( 
            /* [retval][out] */ BOOL __RPC_FAR *pbAsynch)
        {
            return _pOSPReal->isAsync(pbAsynch);
        }
        
        virtual HRESULT STDMETHODCALLTYPE getEstimatedRows( 
            /* [retval][out] */ DBROWCOUNT __RPC_FAR *piRows)
        {
            return _pOSPReal->getEstimatedRows(piRows);
        }
        
        virtual HRESULT STDMETHODCALLTYPE stopTransfer( void)
        {
            return _pOSPReal->stopTransfer();
        }
};


//+---------------------------------------------------------------------------
//
//  Member:     Create (static, public)
//
//  Synopsis:   Create a CDataMemberMgr for a given element.
//
//----------------------------------------------------------------------------

HRESULT
CDataMemberMgr::Create(CElement *pElement, CDataMemberMgr **ppMgr)
{
    Assert(pElement && ppMgr);
    HRESULT hr = S_OK;
    CDataMemberMgr *pMgr = NULL;

    switch (pElement->Tag())
    {
    case ETAG_OBJECT:
    case ETAG_APPLET:
    case ETAG_EMBED:
        pMgr = new CDataMemberMgr(ET_OLESITE, pElement);
        break;

    case ETAG_GENERIC_LITERAL:
        if (0 == _tcsicmp(pElement->TagName(), _T("XML")))
        {
            pMgr = new CDataMemberMgr(ET_XML, pElement);
        }
        else
            hr = E_INVALIDARG;
        break;
        
    default:
        hr = E_INVALIDARG;
        break;
    }
    
    if (!hr && pMgr == NULL)
        hr = E_OUTOFMEMORY;

    *ppMgr = pMgr;
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     constructor (private)
//
//----------------------------------------------------------------------------

CDataMemberMgr::CDataMemberMgr(ELEMENT_TYPE et, CElement *pElement) :
    _ulRefs(1),
    _et(et),
    _pElementOwner(pElement),
    _aryDataMember(Mt(CDataMemberMgr_aryDataMember_pv)),
    _dispidDataBinding(DISPID_UNKNOWN)
{
    Assert(pElement);
    
    switch (_et)
    {
    case ET_OLESITE:
        _pOleSite = DYNCAST(COleSite, pElement);
        break;

    case ET_XML:
        _pXML = DYNCAST(CGenericElement, pElement);
        break;

    case ET_SCRIPT:
        break;
    }

    _pDoc = _pElementOwner->Doc();
    _pElementOwner->SubAddRef();
}


//+---------------------------------------------------------------------------
//
//  Member:     destructor (private)
//
//----------------------------------------------------------------------------

CDataMemberMgr::~CDataMemberMgr()
{
    _pElementOwner->SubRelease();
}


//+------------------------------------------------------------------------
//
//  Member:     QueryInterface (IUnknown)
//
//  Synopsis:   We support the following interfaces:
//
//                  IUnknown
//                  DataSourceListener
//                  IDATASRCListener
//
//  Arguments:  [iid]
//              [ppv]
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CDataMemberMgr::QueryInterface(REFIID iid, void ** ppv)
{
    if (iid == IID_IUnknown ||
        iid == IID_DataSourceListener)
    {
        *ppv = (DataSourceListener *) this;
    }
    else if (iid == IID_IDATASRCListener)
    {
        *ppv = (IDATASRCListener *) this;
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_NOINTERFACE);
    }

    ((IUnknown *) *ppv)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG)
CDataMemberMgr::AddRef( )
{
    return ++_ulRefs;
}


STDMETHODIMP_(ULONG)
CDataMemberMgr::Release( )
{
    ULONG ulRefs = --_ulRefs;

    if (ulRefs == 0)
    {
        delete this;
    }
    return ulRefs;
}


//+---------------------------------------------------------------------------
//
//  Member:     IllegalCall (private)
//
//  Returns:    TRUE    illegal call (wrong thread, etc)
//              FALSE   legal call
//----------------------------------------------------------------------------

BOOL
CDataMemberMgr::IllegalCall(DWORD dwFlags)
{
    switch (_et)
    {
    case ET_OLESITE:
        Assert(_pOleSite);
        return _pOleSite->IllegalSiteCall(dwFlags);
        break;

    case ET_XML:
    case ET_SCRIPT:
        if (_pDoc->_dwTID != GetCurrentThreadId())
        {
            Assert(0 && "ActiveX control called MSHTML across apartment thread boundary (not an MSHTML bug)");
            return TRUE;
        }
        break;
    }

    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     IsReady (public)
//
//  Returns:    S_OK    ready
//              S_FALSE not ready
//              E_*     some bad kind of error occurred
//----------------------------------------------------------------------------

HRESULT
CDataMemberMgr::IsReady()
{
    HRESULT hr = S_OK;
    LONG lReadyState;
    
    switch (_et)
    {
    case ET_OLESITE:
        hr = _pOleSite->GetReadyState(&lReadyState);
        if (hr==S_OK && lReadyState < READYSTATE_LOADED)
        {
            hr = S_FALSE;
        }
        break;

    case ET_XML:
        break;
    
    case ET_SCRIPT:
        hr = E_NOTIMPL;    // TODO notimpl
        break;
    }

    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     GetDataMemberRecord (protected)
//
//  Synopsis:   looks up bstrName in the associative array, and returns
//              the corresponding data member record.
//
//----------------------------------------------------------------------------

CDataMemberMgr::CDataMemberRecord *
CDataMemberMgr::GetDataMemberRecord(BSTR bstrName)
{
    int i;
    CDataMemberRecord *pdmr;

    for (pdmr=_aryDataMember, i=_aryDataMember.Size(); i > 0; ++pdmr, --i)
    {
        if (FormsStringCmp(bstrName, pdmr->_bstrName) == 0)
        {
            return pdmr;
        }
    }

    return NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     AddDataMemberRecord (protected)
//
//  Synopsis:   adds a new data member record to the associative array,
//              with bstrName as the key.  Returns a pointer to the new record.
//
//----------------------------------------------------------------------------

CDataMemberMgr::CDataMemberRecord *
CDataMemberMgr::AddDataMemberRecord(BSTR bstrName)
{
    HRESULT hr;
    CDataMemberRecord *pdmrResult;

    pdmrResult = _aryDataMember.Append();
    if (pdmrResult)
    {
        hr = FormsAllocString(bstrName, &pdmrResult->_bstrName);
        if (!hr)
        {
            pdmrResult->_pdspProvider = NULL;
            pdmrResult->_punkDataBinding = PUNKDB_UNKNOWN;
        }
        else
        {
            pdmrResult = NULL;
            _aryDataMember.Delete(_aryDataMember.Size()-1);
        }
    }

    return pdmrResult;
}


//+---------------------------------------------------------------------------
//
//  Member:     AccessAllowed (private)
//
//  Synopsis:   determine if cross-domain data access is allowed
//
//----------------------------------------------------------------------------

BOOL
CDataMemberMgr::AccessAllowed()
{
    BOOL fAllowXDomain = FALSE;
    IDispatch *pDisp;

    if (_et == ET_OLESITE)
    {
        switch (_eSecurity)
        {
        case SEC_UNKNOWN:
            Assert(_pOleSite);
            _pOleSite->CacheDispatch();
            pDisp = _pOleSite->_pDisp;
            
            if (pDisp)
            {
                fAllowXDomain = _pOleSite->AccessAllowed(pDisp);

                // if cross-domain access, check the user's policy
                if (!fAllowXDomain)
                {
                    THR(_pOleSite->GetMarkupPtr()->ProcessURLAction(
                        URLACTION_CROSS_DOMAIN_DATA,
                        &fAllowXDomain));
                }
            }

            // remember the answer, so we don't prompt more than once
            _eSecurity = fAllowXDomain ? SEC_SAFE : SEC_UNSAFE;
            break;

        case SEC_SAFE:
            fAllowXDomain = TRUE;
            break;

        case SEC_UNSAFE:
            fAllowXDomain = FALSE;
            break;
        }
            
    }
    else
        fAllowXDomain = TRUE;

    return fAllowXDomain;
}


//+---------------------------------------------------------------------------
//
//  Member:     GetDataSourceProvider (public)
//
//  Synopsis:   return a data-interface provider associated with this <OBJECT>
//              (and its control), creating it if needed.
//
//----------------------------------------------------------------------------

HRESULT
CDataMemberMgr::GetDataSourceProvider(BSTR bstrMember, CDataSourceProvider **ppdsp)
{
    Assert(ppdsp);

    HRESULT hr = S_OK;
    CDataMemberRecord *pdmr;

    *ppdsp = NULL;      // just in case

    // look up the data member
    pdmr = GetDataMemberRecord(bstrMember);

    // if not there, create one
    if (pdmr == NULL)
    {
        pdmr = AddDataMemberRecord(bstrMember);
        if (pdmr == NULL)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }

    // Create the top-level provider, if necessary.
    if (!pdmr->_pdspProvider)
    {
        hr = CDataSourceProvider::Create(this, Doc(), bstrMember, &pdmr->_pdspProvider);
        if (hr)
            goto Cleanup;
    }

    // return the answer
    *ppdsp = pdmr->_pdspProvider;
    if (*ppdsp)
        (*ppdsp)->AddRef();

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     ChangeDataBindingInterface (protected)
//
//  Synopsis:   React to changes in my control's databinding interface,
//              by replacing my provider.
//
//----------------------------------------------------------------------------

HRESULT
CDataMemberMgr::ChangeDataBindingInterface(BSTR bstrMember, BOOL fDataAvail)
{
    HRESULT hr = S_OK;
    CDataMemberRecord *pdmr = GetDataMemberRecord(bstrMember);
    CDataSourceProvider *pdspOldProvider;
    CDataSourceProvider *pdspNewProvider;
    CDoc *pDoc;

    // turn off databinding during this function.  This postpones the onrowenter
    // event on the new provider until after the bound elements have had a chance
    // to re-bind.  (IE5 bug 82058)
    CMarkup *pMarkup = GetOwner()->GetMarkup();
    BOOL fDatabindingEnabled = pMarkup->SetDataBindingEnabled(FALSE);

    // if my control isn't a data provider or we don't care about data member,
    // just ignore
    if (_dpt <= DPT_NOTAPROVIDER || pdmr == NULL)
        goto Cleanup;

    // remember the old provider, discard the old interface
    pdspOldProvider = pdmr->_pdspProvider;
    if (pdmr->_punkDataBinding != PUNKDB_UNKNOWN)
    {
        ClearInterface(&pdmr->_punkDataBinding);
    }
    pdmr->_punkDataBinding = PUNKDB_UNKNOWN;

    // if the notification came from a Trident-as-OSP, the data page may have
    // navigated to a new site, so we should re-evaluate cross-domain
    // security
    if (GetTridentAsOSP(&pDoc) == S_OK)
    {
        _eSecurity = SEC_UNKNOWN;
    }
    
    // get the new interface from the control
    if (fDataAvail)
    {
        IGNORE_HR(EnsureDataBindingInterface(bstrMember));
    }

    // let my provider know what happened
    if (!pdspOldProvider)   // no provider, nothing to do
        goto Cleanup;

    pdmr->_pdspProvider = NULL;                     // unhook the old provider
    hr = GetDataSourceProvider(bstrMember, &pdspNewProvider);   // hook up a new one
    if (hr)
    {
        pdmr->_pdspProvider = pdspOldProvider;      // if error, restore status quo
        goto Cleanup;
    }

    pdspOldProvider->ReplaceProvider(pdspNewProvider);  // notify provider's clients
    pdspOldProvider->Release();                     // let go of old provider
    pdspNewProvider->Release();                     // release local ref to new one

Cleanup:
    // the data member change may let bindings succeed that didn't before,
    // notably bindings to the inner datasets of a hierarchy.  So tell the
    // binding task to try again.
    pMarkup->GetDataBindTask()->SetWaiting();
    pMarkup->SetDataBindingEnabled(fDatabindingEnabled);

    return hr;
}


CDataMemberMgr::DATA_PROVIDER_TYPE
CDataMemberMgr::GetDataProviderType()
{
    // Do we already know what data provider type this site is hosting?
    if (_dpt==DPT_UNKNOWN)
    {
        // No. Try to find one.
        FindDataProviderType();
    }
    return _dpt;
}


//+---------------------------------------------------------------------------
//
//  Member:     EnsureDataBindingInterface (protected)
//
//  Synopsis:   Query the underlying control/applet for an interface
//              its clients can use for databinding
//
//----------------------------------------------------------------------------

HRESULT
CDataMemberMgr::EnsureDataBindingInterface(BSTR bstrMember)
{
    HRESULT hr = S_OK;
    CDataMemberRecord *pdmr;
    IUnknown *punkNew = NULL;

    // look up the data member
    pdmr = GetDataMemberRecord(bstrMember);

    // if not there, create one
    if (pdmr == NULL)
    {
        pdmr = AddDataMemberRecord(bstrMember);
        if (pdmr == NULL)
        {
            hr = E_FAIL;
            goto Cleanup;
        }
    }

    // get the interface, if not there already
    if (pdmr->_punkDataBinding == PUNKDB_UNKNOWN)
    {
        CLASSINFO *pci;
        IServiceProvider *pServiceProvider = NULL;

        // make sure it's still safe to talk to the provider (Windows 549760)
        if (!AccessAllowed())
        {
            pdmr->_punkDataBinding = NULL;
            goto Cleanup;
        }

        switch (GetDataProviderType())
        {
        case DPT_DATASOURCE:
            Assert(_pDataSource);
            hr = _pDataSource->getDataMember(bstrMember, IID_IUnknown, &punkNew);
            break;

        case DPT_COM:
        case DPT_JAVA:
            Assert(_et == ET_OLESITE);
            // the service provider (if needed) is the doc
            Doc()->PrivateQueryInterface(IID_IServiceProvider, (void**)&pServiceProvider);
            hr = CallDispMethod(pServiceProvider,
                                _pOleSite->_pDisp,
                                _dispidDataBinding,
                                g_lcidUserDefault,
                                VT_UNKNOWN,
                                &punkNew,
                                EVENT_PARAM(VTS_BSTR),
                                bstrMember
                                );
            ReleaseInterface(pServiceProvider);
            break;

        case DPT_ICURSOR:
            AssertSz(0, "ChangeDataBindingInterface called on ICursor provider");
            break;
            
        case DPT_PROPERTY:
            Assert(_et == ET_OLESITE);
            pci = _pOleSite->GetClassInfo();
            if (pci->dispidSTD != DISPID_UNKNOWN) // offers OLEDBSimpleProvider
            {
                hr = _pOleSite->GetInterfaceProperty(pci->uGetSTD, pci->dispidSTD,
                                            IID_OLEDBSimpleProvider, &punkNew);
            }
            else if (pci->dispidRowset != DISPID_UNKNOWN)        // offers IRowset
            {
                hr = _pOleSite->GetInterfaceProperty(pci->uGetRowset, pci->dispidRowset,
                                            IID_IRowset, &punkNew);
            }
            break;
        }

        // OSP providers are notoriously guilty of the following sin:  they
        // allow the control to die while references to OSPs are still outstanding.
        // To work around this problem, build a proxy object that artificially
        // increments the refcount of the control throughout the lifetime of the OSP.
        if (!hr && punkNew)
        {
            IUnknown *punkOther = NULL;
            COSPProxy *pProxy = new COSPProxy();

            // get a controlling unknown for the DSO
            switch (_et)
            {
            case ET_OLESITE:
                punkOther = _pOleSite->PunkCtrl();
                punkOther->AddRef();
                break;
            case ET_XML:
                if (S_OK != _pDataSource->QueryInterface(IID_IUnknown, (void**)&punkOther))
                    punkOther = NULL;
                break;
            default:
                break;
            }
            
            // If anything goes wrong (such as if Init() fails because
            // punkNew doesn't implement OLEDBSimpleProvider), then we'll
            // just proceed as normal.
            if (punkOther == NULL || pProxy == NULL || pProxy->Init(punkNew, punkOther))
            {
                delete pProxy;
            }
            else
            {
                punkNew->Release();
                punkNew = (IUnknown*)(void*)pProxy;
            }

            ReleaseInterface(punkOther);
        }

        pdmr->_punkDataBinding = punkNew;
    }

Cleanup:
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     GetDataBindingInterface (public)
//
//  Synopsis:   Query the underlying control/applet for an interface
//              its clients can use for databinding
//
//----------------------------------------------------------------------------

HRESULT
CDataMemberMgr::GetDataBindingInterface(BSTR bstrMember, IUnknown **ppunkDataBinding)
{
    HRESULT hr = S_OK;
    CDataMemberRecord *pdmr;
    IUnknown *punkDataBinding = NULL;

    // look up the data member
    pdmr = GetDataMemberRecord(bstrMember);

    // if this is first request, try to get the dataset
    if (pdmr == NULL || pdmr->_punkDataBinding == PUNKDB_UNKNOWN)
    {
        hr = EnsureDataBindingInterface(bstrMember);
        if (pdmr == NULL)
            pdmr = GetDataMemberRecord(bstrMember);
    }
    
    punkDataBinding = pdmr ? pdmr->_punkDataBinding : NULL;
    if (punkDataBinding == PUNKDB_UNKNOWN)
        punkDataBinding = NULL;

    // return the answer
    Assert(ppunkDataBinding);
    *ppunkDataBinding = punkDataBinding;
    if (punkDataBinding)
        punkDataBinding->AddRef();

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     FindDataProviderType (private helper)
//
//  Synopsis:   determine if the underlying DSO provides data, and if so, how
//
//----------------------------------------------------------------------------

void
CDataMemberMgr::FindDataProviderType()
{
    HRESULT hr = S_OK;
    CLASSINFO *pci;
    IDispatch *pDisp;
    DISPID dispid;
    IUnknown *punkInterface = 0;
    static OLECHAR * oszMsDATASRCObject = _T("msDataSourceObject");
    static OLECHAR * oszAddDataSrcListener = _T("addDataSourceListener");
    DataSource *pDataSource = 0;
    IServiceProvider *pServiceProvider = 0;
    
    Assert(_dpt == DPT_UNKNOWN);    // if we already know, why bother

    _dpt = DPT_NOTAPROVIDER;        // assume the worst

    switch (_et)
    {
    case ET_OLESITE:
        Assert(_pOleSite);
        // must have a valid dispatch for any of our methods
        _pOleSite->CacheDispatch();
        pDisp = _pOleSite->_pDisp;
        if (!pDisp)
            goto Cleanup;

        if (!AccessAllowed())
            goto Cleanup;

        // the service provider (if needed) is the doc
        Doc()->PrivateQueryInterface(IID_IServiceProvider, (void**)&pServiceProvider);

        switch (_pOleSite->OlesiteTag())
        {
        case COleSite::OSTAG_ACTIVEX:
            // method 5:  look for DataSource
            hr = _pOleSite->QueryControlInterface(IID_DataSource, (void**)&pDataSource);
            if (hr == S_OK)
            {
                _dpt = DPT_DATASOURCE;
                IGNORE_HR(pDataSource->addDataSourceListener((DataSourceListener*)this));
                _pDataSource = pDataSource;
                break;
            }

            // method 1:  look for the MsDatasrcInterface method (COM objects)
            hr = CallDispMethod(pServiceProvider,
                                _pOleSite->_pDisp,
                                DISPID_MSDATASRCINTERFACE,
                                g_lcidUserDefault,
                                VT_UNKNOWN,
                                &punkInterface,
                                EVENT_PARAM(VTS_BSTR),
                                (BSTR) 0
                                );
            if (!DISPID_NOT_FOUND(hr))
            {
                _dpt = DPT_COM;
                _dispidDataBinding = DISPID_MSDATASRCINTERFACE;
                
                // listen for DatasrcChanged
                IGNORE_HR(CallDispMethod(pServiceProvider,
                                        _pOleSite->_pDisp,
                                        DISPID_ADVISEDATASRCCHANGEEVENT,
                                        g_lcidUserDefault,
                                        VT_VOID,
                                        NULL,
                                        EVENT_PARAM(VTS_UNKNOWN),
                                        (IUnknown*)(DataSourceListener*) this
                                        ));
                break;
            }

            // method 3:  look for IVBDSC (VB ICursor controls)
            hr = _pOleSite->QueryControlInterface(IID_IVBDSC, (void**)&punkInterface);
            if (hr == S_OK)
            {
                _dpt = DPT_ICURSOR;
                break;
            }

            // method 4:  look for a databinding interface in a property (older controls)
            //      This is last so that we don't look at the typelib until all else fails.
            pci = _pOleSite->GetClassInfo();
            if (pci->dispidSTD != DISPID_UNKNOWN)           // offers ISimpleTabularData
            {
                _dpt = DPT_PROPERTY;
                break;
            }
            if (pci->dispidRowset != DISPID_UNKNOWN)        // offers IRowset
            {
                _dpt = DPT_PROPERTY;
                break;
            }
            
        break;

        case COleSite::OSTAG_APPLET:
            // method 2:  look for the msDATASRCObject method (Java applets)
            hr = _pOleSite->_pDisp->GetIDsOfNames(IID_NULL, &oszMsDATASRCObject, 1,
                                        g_lcidUserDefault, &dispid);
            if (hr == S_OK)
            {
                DataSourceListener *pDSL = 0;
                
                _dpt = DPT_JAVA;
                _dispidDataBinding = dispid;
                
                // listen for DatasrcChanged
                if (S_OK ==_pOleSite->_pDisp->GetIDsOfNames(IID_NULL, &oszAddDataSrcListener, 1,
                                        g_lcidUserDefault, &dispid))
                {
                    IGNORE_HR(CallDispMethod(pServiceProvider,
                                            _pOleSite->_pDisp,
                                            dispid,
                                            g_lcidUserDefault,
                                            VT_VOID,
                                            NULL,
                                            EVENT_PARAM(VTS_UNKNOWN),
                                            (IUnknown*)(DataSourceListener*) this
                                            ));
                    ReleaseInterface(pDSL);
                }
            }
            break;
            
        }
        break;

    case ET_XML:
    {
        HRESULT     hr;
        DataSource *pDataSource = NULL;

        // get DataSource from the data island
        hr = _pElementOwner->QueryInterface(IID_DataSource, (void**)&pDataSource);
        if (hr == S_OK)
        {
            _dpt = DPT_DATASOURCE;
            IGNORE_HR(pDataSource->addDataSourceListener((DataSourceListener*)this));
            _pDataSource = pDataSource;
        }
        break;
    }
    
    default:
        break;
    }


    // if the DSO uses DataSource, it might also use ISimpleDataConverter
    if (_dpt == DPT_DATASOURCE)
    {
        ISimpleDataConverter *pSDC = NULL;

        hr = _pDataSource->QueryInterface(IID_ISimpleDataConverter, (void**)&pSDC);

#if DBG == 1
        // for debugging, use an internal mock-up of ISimpleDataConverter
        if (IsTagEnabled(tagUseDebugSDC))
        {
            ReleaseInterface(pSDC);
            pSDC = new CDbgSimpleDataConverter;
            hr = S_OK;
        }
#endif

        if (!hr && pSDC)
        {
            _pSDC = pSDC;
        }
    }
    
Cleanup:
    ReleaseInterface(punkInterface);
    ReleaseInterface(pServiceProvider);
    
    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDataMemberMgr::DetachDataProviders (public)
//
//  Synopsis:   Release resources associated with data provider objects
//
//----------------------------------------------------------------------------
void
CDataMemberMgr::DetachDataProviders()
{
    int i;
    CDataMemberRecord *pdmr;

    // disconnect providers
    for (i=_aryDataMember.Size(), pdmr=_aryDataMember; i>0; --i, ++pdmr)
    {
        if (pdmr->_pdspProvider)
        {
            pdmr->_pdspProvider->Detach();
            pdmr->_pdspProvider->Release();
            pdmr->_pdspProvider = NULL;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDataMemberMgr::Detach (public)
//
//  Synopsis:   Release resources associated with data source objects
//
//----------------------------------------------------------------------------

void
CDataMemberMgr::Detach()
{
    int i;
    CDataMemberRecord *pdmr;
    
    // disconnect databinding stuff
    for (i=_aryDataMember.Size(), pdmr=_aryDataMember; i>0; --i, ++pdmr)
    {
        FormsFreeString(pdmr->_bstrName);
        
        if (pdmr->_pdspProvider)
        {
            pdmr->_pdspProvider->Detach();
            pdmr->_pdspProvider->Release();
            pdmr->_pdspProvider = NULL;
        }

        if (pdmr->_punkDataBinding != PUNKDB_UNKNOWN)
        {
            ClearInterface(&pdmr->_punkDataBinding);
        }
    }
    _aryDataMember.DeleteAll();

    switch (_dpt)
    {
    case DPT_DATASOURCE:
        IGNORE_HR(_pDataSource->removeDataSourceListener((DataSourceListener*)this));
        ClearInterface(&_pDataSource);
        ClearInterface(&_pSDC);
        break;

    case DPT_COM:
    case DPT_JAVA:
        Assert(_et==ET_OLESITE && _pOleSite);
    // NOTE the spec says we're supposed to call addDataSourceListener(NULL)
    // but TDC, and presumably other controls, barf if we do
#if defined(CONTROLS_KNOW_HOW_TO_HANDLE_AddDataSourceListener_NULL)
        Doc()->PrivateQueryInterface(IID_IServiceProvider, (void**)&pServiceProvider);
        IGNORE_HR(CallDispMethod(pServiceProvider,
                                _pOleSite->_pDisp,
                                DISPID_ADVISEDATASRCCHANGEEVENT,
                                g_lcidUserDefault,
                                VT_VOID,
                                NULL,
                                EVENT_PARAM(VTS_UNKNOWN),
                                NULL
                                ));
        ReleaseInterface(pServiceProvider);
#endif
        break;
        
    default:
        break;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDataMemberMgr::Notify (public)
//
//  Synopsis:   handle notifications set to my element
//
//----------------------------------------------------------------------------

void
CDataMemberMgr::Notify(CNotification * pnf)
{
    CDataMemberRecord * pdmr;
    int                 i;

    switch (pnf->Type())
    {
    case NTYPE_STOP_1:
    case NTYPE_MARKUP_UNLOAD_1:
        if (_aryDataMember.Size())
            pnf->SetSecondChanceRequested();
        break;

    case NTYPE_STOP_2:
    case NTYPE_MARKUP_UNLOAD_2:
        // try to stop any data transfers that may be in progress
        for (i=_aryDataMember.Size(), pdmr=_aryDataMember;
             i > 0;
             --i, ++pdmr)
        {
            if (pdmr->_pdspProvider)
            {
                IGNORE_HR(pdmr->_pdspProvider->Stop());
            }
        }
        break;
        
    case NTYPE_BEFORE_UNLOAD:
        // Databinding spec requires us to fire onrowexit here..
        for (i=_aryDataMember.Size(), pdmr=_aryDataMember; i>0; --i, ++pdmr)
        {
            if (pdmr->_pdspProvider)          // Are we a data provider?
            {
                pdmr->_pdspProvider->FireDataEvent(&s_propdescCElementonrowexit);
            }
        }
        break;

    case NTYPE_ELEMENT_EXITTREE_1:
        DetachDataProviders();
        break;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     GetTridentAsOSP (public)
//
//  Synopsis:   If my element is a Trident-As-OSP, return a pointer to
//              the CDoc.
//
//  Returns:    S_OK        my element is a Trident-As-OSP.  *ppDocOSP set.
//              S_FALSE     my element isn't a Trident-As-OSP.
//
//  Note:       The returned doc is *not* refcounted.
//
//----------------------------------------------------------------------------

HRESULT
CDataMemberMgr::GetTridentAsOSP(CDoc **ppDocOSP)
{
    HRESULT hr = S_FALSE;

    if (_et == ET_OLESITE &&
        S_OK == _pOleSite->QueryControlInterface(CLSID_HTMLDocument,
                                                (void**)ppDocOSP))
    {
        hr = S_OK;
    }

    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     EnsureDataEvents (public)
//
//  Synopsis:   make sure there's a provider to actually fire data events
//              (see IE5 bug 3201).
//
//----------------------------------------------------------------------------

void
CDataMemberMgr::EnsureDataEvents()
{
    CDataMemberRecord *pdmr = GetDataMemberRecord(NULL);
    CDataSourceBinder *pdsb;
    
    // if there's already a provider, no need to create a new one
    if (pdmr==NULL || pdmr->_pdspProvider == NULL)
    {
        // create a provider next time the databinding task list runs
        pdsb = new CDataSourceBinder(_pElementOwner, 0, BINDEROP_ENSURE_DATA_EVENTS);

        if (pdsb)
        {
            HRESULT hr;
            DBSPEC dbs;
            memset(&dbs, 0, sizeof(DBSPEC));

            hr = pdsb->Register(&dbs);
            if (hr)
            {
                pdsb->Passivate();      // will delete the binder
            }
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDataMemberMgr::namedRecordset
//
//  Synopsis:   returns an ADO Recordset for the named data member.  Tunnels
//              into the hierarchy using the path, if given.
//
//  Arguments:  bstrDataMember  name of data member (NULL for default)
//              pvarHierarchy   BSTR path through hierarchy (optional)
//              pRecordSet      where to return the recordset.
//
//  Returns:    S_FALSE         not a provider
//
//----------------------------------------------------------------------------

HRESULT
CDataMemberMgr::namedRecordset(BSTR bstrDatamember,
                               VARIANT *pvarHierarchy,
                               IDispatch **ppRecordSet)
{
    HRESULT hr=S_OK;
    BSTR bstrHierarchy = NULL;

    if (ppRecordSet == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppRecordSet = NULL;                 // Make sure to null on failure.

    if (pvarHierarchy && V_VT(pvarHierarchy) == VT_BSTR)
    {
        bstrHierarchy = V_BSTR(pvarHierarchy);
    }
    
    // normal case, return ADO recordset based on my provider
    if (IsDataProvider())
    {
        CDataSourceProvider *pdsp = NULL;

        // get the top-level provider for the desired data member
        hr = GetDataSourceProvider(bstrDatamember, &pdsp);

        // find the inner level of hierarchy, if desired
        if (!hr && pdsp && !FormsIsEmptyString(bstrHierarchy))
        {
            CDataSourceProvider *pdspTop = pdsp;
            hr = pdspTop->GetSubProvider(&pdsp, bstrHierarchy);
            pdspTop->Release();
        }

        if (pdsp)
        {
            // We then query the CDataSourceProvider to give us back an ADO recordset,
            // if it can.
            hr = pdsp->QueryDataInterface(IID_IADORecordset15, (void **)ppRecordSet);
            pdsp->Release();

            // We clamp the most obvious failure mode here, so script authors can
            // simply test for recordset being NULL, and not get script errors.
            if (E_NOINTERFACE == hr)
            {
                hr = S_OK;
            }
        }
    }

    else
    {
        hr = S_FALSE;
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     dataMemberChanged (DataSourceListener)
//
//  Synopsis:   DataSource notifies that a dataset has changed shape
//
//  Arguments:  bstrDM      name of the changed dataset (NULL means default)
//
//  Returns:    S_OK        success
//----------------------------------------------------------------------------

STDMETHODIMP
CDataMemberMgr::dataMemberChanged(BSTR bstrDM)
{
    TraceTag((tagDataMemberMgr, "CDataMemberMgr::dataMemberChanged SN=%ld", _pElementOwner->SN()));

    if (IllegalCall(COleSite::VALIDATE_LOADED))
        RRETURN(E_UNEXPECTED);

    HRESULT     hr;

    hr = THR(ChangeDataBindingInterface(bstrDM, TRUE));

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     dataMemberAdded (DataSourceListener)
//
//  Synopsis:   DataSource notifies that a new dataset has been born
//
//  Arguments:  bstrDM      name of the new dataset
//
//  Returns:    S_OK        success
//----------------------------------------------------------------------------

STDMETHODIMP
CDataMemberMgr::dataMemberAdded(BSTR bstrDM)
{
    TraceTag((tagDataMemberMgr, "CDataMemberMgr::dataMemberAdded SN=%ld", _pElementOwner->SN()));

    if (IllegalCall(COleSite::VALIDATE_LOADED))
        RRETURN(E_UNEXPECTED);

    RRETURN(S_OK);      // we don't care
}

//+---------------------------------------------------------------------------
//
//  Member:     dataMemberRemoved (DataSourceListener)
//
//  Synopsis:   DataSource notifies that a dataset has died
//
//  Arguments:  bstrDM      name of the dead dataset
//
//  Returns:    S_OK        success
//----------------------------------------------------------------------------

STDMETHODIMP
CDataMemberMgr::dataMemberRemoved(BSTR bstrDM)
{
    TraceTag((tagDataMemberMgr, "CDataMemberMgr::dataMemberRemoved SN=%ld", _pElementOwner->SN()));

    if (IllegalCall(COleSite::VALIDATE_LOADED))
        RRETURN(E_UNEXPECTED);

    CDataMemberRecord *pdmr = GetDataMemberRecord(bstrDM);

    if (pdmr)
    {
        if (pdmr->_pdspProvider)
        {
            pdmr->_pdspProvider->Detach();
            pdmr->_pdspProvider->Release();
            pdmr->_pdspProvider = NULL;
        }

        if (pdmr->_punkDataBinding != PUNKDB_UNKNOWN)
        {
            ClearInterface(&pdmr->_punkDataBinding);
        }
    }
        
    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
//
//  Member:     datasrcChanged (IDATASRCListener)
//
//  Synopsis:   DataSource notifies that a dataset has changed shape
//
//  Arguments:  bstrQualifier   name of the changed dataset (NULL means default)
//              fDataAvail      true if new dataset is available
//
//  Returns:    S_OK        success
//----------------------------------------------------------------------------

STDMETHODIMP
CDataMemberMgr::datasrcChanged(BSTR bstrQualifier, BOOL fDataAvail)
{
    TraceTag((tagDataMemberMgr, "CDataMemberMgr::datasrcChanged SN=%ld", _pElementOwner->SN()));

    if (IllegalCall(COleSite::VALIDATE_LOADED))
        RRETURN(E_UNEXPECTED);

    HRESULT     hr;

    hr = THR(ChangeDataBindingInterface(bstrQualifier, fDataAvail));

    RRETURN(hr);
}


// This method is implemented here (rather than in baseprop.cxx)
// because it uses OleSite methods.  Getting #include <olesite.hxx> to work
// from src\core\cdbase proved to be an insurmountable challenge.

#ifdef USE_STACK_SPEW
#pragma check_stack(off)  
#endif 
STDMETHODIMP CBase::put_DataEvent(VARIANT v)
{
    GET_THUNK_PROPDESC

    return put_DataEventHelper(v, pPropDesc);
}
#ifdef USE_STACK_SPEW
#pragma check_stack(on)  
#endif 

STDMETHODIMP CBase::put_DataEventHelper(VARIANT v, const PROPERTYDESC *pPropDesc, CAttrArray ** ppAttr)
{
    HRESULT     hr;

    hr = put_VariantHelper(v, pPropDesc,  ppAttr);

    if (!hr)
    {
        // if we add a data event to an element, make sure the event can fire
        CDataMemberMgr::EnsureDataEventsFor(this, pPropDesc->GetDispid());
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     EnsureDataEventsFor (static)
//
//  Synopsis:   Make sure that data events can fire for the given element
//
//  Arguments:  pBase       the given element
//              dispid      the dispid of the event being hooked up
//
//  Returns:    nothing
//----------------------------------------------------------------------------

void
CDataMemberMgr::EnsureDataEventsFor(CBase *pBase, DISPID dispid)
{
    CElement *pElement = NULL;
    CDataMemberMgr *pdmm;
    HRESULT hr;

    switch (dispid)
    {
    // this list must agree with the list of events marked "dataevent"
    // in element.pdl
    case DISPID_EVPROP_ONROWEXIT:
    case DISPID_EVPROP_ONROWENTER:
    case DISPID_EVPROP_ONDATASETCHANGED:
    case DISPID_EVPROP_ONDATAAVAILABLE:
    case DISPID_EVPROP_ONDATASETCOMPLETE:
    case DISPID_EVPROP_ONROWSDELETE:
    case DISPID_EVPROP_ONROWSINSERTED:
    case DISPID_EVPROP_ONCELLCHANGE:

        hr = pBase->PrivateQueryInterface(CLSID_CElement, (void**)&pElement);
        if (!hr && pElement && pElement->IsConnectedToPrimaryMarkup())
        {
            pElement->EnsureDataMemberManager();
            pdmm = pElement->GetDataMemberManager();
            if (pdmm)
            {
                pdmm->EnsureDataEvents();
            }
        }
        break;

    default:
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\dbind\ospmrshl.cxx ===
// Copyright (c) 1996-1997  Microsoft Corporation.  All rights reserved.
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#define JAVAVMAPI                   // avoid dll linkage errors

#ifndef X_WINDOWS_H_
#define X_WINDOWS_H_
#include <windows.h>
#endif

#ifndef X_OLEAUTO_H_
#define X_OLEAUTO_H_
#include <oleauto.h>
#endif

#ifndef X_NATIVE_H_
#define X_NATIVE_H_
#include "native.h" // Raw Native Interface declarations.
#endif

#ifndef X_NATIVCOM_H_
#define X_NATIVCOM_H_
#include "nativcom.h"
#endif

// helpers for date conversions
const static double daysBetween1900And1970 = 25567.0;
const static __int64 iSecondsPerDay = 86400;

typedef enum {
    IntegerClass,
    StringClass,
    LongClass,
    FloatClass,
    DoubleClass,
    BooleanClass,
    DateClass
} ClassIDs;

typedef VARIANT *PETYPE, **PPETYPE;

typedef OBJECT* JTYPE;

typedef void (*pf)(JTYPE javaval, PETYPE petype);

typedef struct {
    ClassClass *type;
    pf func;
    char *className;
} TypeFuncPair;

#define EXTERNC extern "C"

static void fInteger(JTYPE javaval, PETYPE petype)
{
    long iTemp = execute_java_dynamic_method(NULL,
                                             javaval,
                                             "intValue",
                                             "()I");
    V_VT(petype) = VT_I4;
    V_I4(petype) = iTemp;
}

static void fLong(JTYPE javaval, PETYPE petype)
{
#if 0
    // do we have a long long type???
    long long iTemp = execute_java_dynamic_method64(NULL,
        javaval,
        "longValue",
        "()J");
    V_VT(petype) = VT_I8;
    V_I4(petype) = iTemp;
#else
    fInteger(javaval, petype);
#endif
}

static void fFloat(JTYPE javaval, PETYPE petype)
{
    long rTemp = execute_java_dynamic_method(NULL,
                                             javaval,
                                             "floatValue",
                                             "()F");
    V_VT(petype) = VT_R4;
    V_I4(petype) = rTemp;
}

static void fDouble(JTYPE javaval, PETYPE petype)
{
    double iTemp = execute_java_dynamic_method64(NULL,
                                                 javaval,
                                                 "doubleValue",
                                                 "()D");
    V_VT(petype) = VT_R8;
    V_R8(petype) = iTemp;
}

static void fBoolean(JTYPE javaval, PETYPE petype)
{
    int iTemp = execute_java_dynamic_method64(NULL,
                                              javaval,
                                              "booleanValue",
                                              "()Z");
    V_VT(petype) = VT_BOOL;
    V_BOOL(petype) = (iTemp ? VARIANT_TRUE : VARIANT_FALSE);
}

static void fDate(JTYPE javaval, PETYPE petype)
{
    // java to variant

    __int64 iDate = execute_java_dynamic_method64(NULL,
                                                  javaval,
                                                  "getTime",
                                                  "()J");

    __int64 iDays = (iDate / 1000) / iSecondsPerDay;
    __int64 iRemainingMS = iDate - (iDays * iSecondsPerDay * 1000);

    double variantDate = daysBetween1900And1970    +
                         (double)iDays             +
                         ((double)iRemainingMS / ((double)iSecondsPerDay * 1000.0));
    
    V_VT(petype) = VT_DATE;
    V_DATE(petype) = variantDate;
}

static void fString(JTYPE javaval, PETYPE petype)
{
    Hjava_lang_String *stringValue = (Hjava_lang_String *) javaval;
    unicode *uc = javaStringStart (stringValue);
    int ucLen = javaStringLength(stringValue);

    V_VT(petype) = VT_BSTR;
    V_BSTR(petype) = SysAllocStringLen(uc, ucLen);
}

static void fStringViaToString(JTYPE javaval, PETYPE petype)
{
    LONG_PTR stringValue = execute_java_dynamic_method64(NULL,  // ExecEnv *ee,
        javaval,                    // HObject *obj,
        "toString",                 // method name
        "()Ljava/lang/String;");    // signature
        fString((JTYPE)stringValue, petype);
}

static void fIUnknown(JTYPE javaval, PETYPE petype)
{
    // TODO what about the iid param
    IUnknown *punk = convert_Java_Object_to_IUnknown(javaval, &IID_IUnknown);
    if (punk != NULL)
    {
        V_VT(petype) = VT_UNKNOWN;
        V_UNKNOWN(petype) = punk;
    }
    else
        fStringViaToString(javaval, petype);
}

static void fVariant(JTYPE javaval, PETYPE petype)
{
    VARIANT *v = (VARIANT*) jcdwGetData(javaval);
    if (v != NULL)
        VariantCopy(petype, v);
}

static TypeFuncPair dispatchTable[] = {
    NULL,       fInteger,           "java/lang/Integer",
    NULL,       fString,            "java/lang/String",
    NULL,       fLong,              "java/lang/Long",
    NULL,       fFloat,             "java/lang/Float",
    NULL,       fDouble,            "java/lang/Double",
    NULL,       fBoolean,           "java/lang/Boolean",
    NULL,       fDate,              "java/util/Date",
    NULL,       fVariant,           "com/ms/com/Variant"
};



static int initialized = 0;

#define EXTERNC     extern "C"

#define JAVAMETHOD(typ, name) \
                              EXTERNC \
                              typ __cdecl com_ms_osp_ospmrshl_##name

DWORD __cdecl RNIGetCompatibleVersion()
{
    return RNIVER;
}

JAVAMETHOD(void, classInit) (OBJECT*x)
{
    int i;
    for (i = 0; i < sizeof(dispatchTable)/sizeof(TypeFuncPair); i++)
    {
        TypeFuncPair *pair = &dispatchTable[i];
        pair->type = FindClass(NULL, pair->className, TRUE);
        if (pair->type == NULL)
        {
            //          char buf[512];
            //          sprintf(buf, "Could not preload %s class!", pair->className);
            //          SignalErrorPrintf("java/lang/ClassNotFoundException", buf);
        }
    }
    initialized = 1;
}

//==========================================================================
// toJava/toJava64
//==========================================================================
#ifdef _WIN64
JAVAMETHOD(JTYPE, toJava64) (OBJECT*x, __int64 ppVariant, int flags)
#else
JAVAMETHOD(JTYPE, toJava) (OBJECT*x, int ppVariant, int flags)
#endif
{
    VARIANT *pVariant = *(PPETYPE)ppVariant;

    VARTYPE type = V_VT(pVariant) & ~VT_BYREF;
    int isByRef = V_ISBYREF(pVariant);

    if ( !initialized )
        com_ms_osp_ospmrshl_classInit(0);

    // question: can we safely ignore the VT_BYREF and assume that
    // the accessor macros will dereference for us?

    if (V_ISARRAY(pVariant) || V_ISVECTOR(pVariant))
        return NULL;

    switch (type)
    {
        case VT_UI1:
        case VT_I1:
        case VT_UI2:
        case VT_I2:
            //      case VT_UI4:
        case VT_I4:
        {
            int intVal = 0;
            switch(V_VT(pVariant))
            {
                case VT_UI1: intVal = (isByRef ? *V_UI1REF(pVariant) : V_UI1(pVariant)); break;
                case VT_I1 : intVal = (isByRef ? *V_I1REF (pVariant) : V_I1 (pVariant)); break;

                case VT_UI2: intVal = (isByRef ? *V_UI2REF(pVariant) : V_UI2(pVariant)); break;
                case VT_I2 : intVal = (isByRef ? *V_I2REF (pVariant) : V_I2 (pVariant)); break;

                             //             case VT_UI4: intVal = (isByRef ? *V_UI4REF(pVariant) : V_UI4(pVariant)); break;
                case VT_I4 : intVal = (isByRef ? *V_I4REF (pVariant) : V_I4 (pVariant)); break;
            }
            return execute_java_constructor(NULL, NULL,
                                            dispatchTable[IntegerClass].type,
                                            "(I)", intVal);
        }

        case VT_UI4:
        {
            __int64 intVal = (isByRef ? *V_UI4REF(pVariant) : V_UI4(pVariant));
            return execute_java_constructor(NULL, NULL,
                                            dispatchTable[LongClass].type,
                                            "(J)", intVal);
        }

        case VT_R4:
            return execute_java_constructor(NULL, NULL,
                                            dispatchTable[FloatClass].type, "(F)",
                                            (isByRef ? *V_R4REF(pVariant) : V_R4(pVariant)));

        case VT_R8:
            return execute_java_constructor(NULL, NULL,
                                            dispatchTable[DoubleClass].type, "(D)",
                                            (isByRef ? *V_R8REF(pVariant) : V_R8(pVariant)));

        case VT_CY:
            return NULL;  // TODO (mwagner) what to do about VT_CY (currency)
            break;

        case VT_BSTR:
        {
            BSTR string = (isByRef ? *V_BSTRREF(pVariant) : V_BSTR(pVariant));
            return (HObject*)makeJavaStringW(string, SysStringLen(string));
        }

        case VT_BOOL:
        {
            BOOL b = !!(isByRef ? *V_BOOLREF(pVariant) : V_BOOL(pVariant));
            return execute_java_constructor(NULL, NULL,
                                            dispatchTable[BooleanClass].type, "(Z)",
                                            b);
        }

        case VT_DATE:
        {
            double variantDate = (isByRef ? *V_DATEREF(pVariant) : V_DATE(pVariant));
            __int64 iDays = (__int64)variantDate;  // truncate, giving integral number of days
            __int64 iMS = (__int64)(variantDate - (double)iDays) * iSecondsPerDay * 1000;
            __int64 iJavaDate = (iDays * 1000) + iMS;  // millisecond units
            
            return execute_java_constructor(NULL, NULL,
                                            dispatchTable[DateClass].type, "(J)",
                                            iJavaDate);       
        }

        case VT_VARIANT:
#ifdef _WIN64
            return com_ms_osp_ospmrshl_toJava64(x, (INT_PTR)&V_VARIANTREF(pVariant), flags);
#else
            return com_ms_osp_ospmrshl_toJava(x, (INT_PTR)&V_VARIANTREF(pVariant), flags);
#endif

        case VT_DISPATCH:
        {
            Hjava_lang_Object *retVal = NULL;
            IDispatch *pdisp = (isByRef ? *V_DISPATCHREF(pVariant) : V_DISPATCH(pVariant));
            IUnknown *punk = NULL;
            if (0 == pdisp->QueryInterface(IID_IUnknown, (void**)&punk))
            {
                retVal = convert_IUnknown_to_Java_Object(punk, NULL, 1);
                punk->Release();
            }
            return retVal;
            break;
        }

        case VT_UNKNOWN:
        {
            IUnknown *punk = (isByRef ? *V_UNKNOWNREF(pVariant) : V_UNKNOWN(pVariant));
            return convert_IUnknown_to_Java_Object(punk, NULL, 1);
        }

        case VT_ARRAY:
        case VT_BYREF:
            
        case VT_ERROR:
        case VT_NULL:
        case VT_EMPTY:

        default:
        {
            return NULL;
        }
    }
}


//==========================================================================
// copyToExternal/copyToExternal64
//==========================================================================

#ifdef _WIN64
JAVAMETHOD(void, copyToExternal64) (OBJECT*x, JTYPE javaval, __int64 ppetype, 
int flags)
#else
JAVAMETHOD(void, copyToExternal) (OBJECT*x, JTYPE javaval, int ppetype, int 
flags)
#endif
{
    PETYPE petype = *(PPETYPE)ppetype;
    int i;
    JTYPE preservedValues[2] = { NULL, (JTYPE)-1 };
    GCFrame frame;
    GCFramePush(&frame, &preservedValues, sizeof(javaval));
    preservedValues[0] = javaval;

    BOOL fDone = FALSE;

    if ( !initialized )
        com_ms_osp_ospmrshl_classInit(0);

    if (preservedValues[0] == NULL)
    {
        V_VT(petype) = VT_NULL;
    }
    else {
        for (i = 0; i < sizeof(dispatchTable)/sizeof(TypeFuncPair); i++)
        {
            const TypeFuncPair *pair = &dispatchTable[i];
            if ( pair->type && is_instance_of(preservedValues[0], pair->type, NULL) )
            {
                (*pair->func)(preservedValues[0], petype);
                fDone = TRUE;
            }
        }
        if (!fDone)
            fIUnknown(preservedValues[0], petype); // could also be fStringViaToString(javaval, petype);
    }
    GCFramePop(&frame);
}

//==========================================================================
// releaseByValExternal/releaseByValExternal64
//==========================================================================
#ifdef _WIN64
JAVAMETHOD(void, releaseByValExternal64) (OBJECT*x, __int64 ppetype, int flags)
#else
JAVAMETHOD(void, releaseByValExternal) (OBJECT*x, int ppetype, int flags)
#endif
{
    PETYPE petype = *(PPETYPE)ppetype;
    VariantClear(petype);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\dbind\simpdc.cxx ===
#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SIMPDC_HXX_
#define X_SIMPDC_HXX_
#include "simpdc.hxx"
#endif


MtDefine(CSimpleDataConverter, DataBind, "CSimpleDataConverter");


HRESULT STDMETHODCALLTYPE
CSimpleDataConverter::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr;
    
    if (ppv == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ISimpleDataConverter))
    {
        *ppv = this;
        AddRef();
        hr = S_OK;
    }
    else
    {
        hr = E_NOINTERFACE;
    }

Cleanup:
    RRETURN(hr);
}


ULONG STDMETHODCALLTYPE
CSimpleDataConverter::Release()
{
    ULONG ulRefs = --_ulRefs;
    if (ulRefs == 0)
    {
        delete this;
    }
    return ulRefs;
}


HRESULT STDMETHODCALLTYPE
CSimpleDataConverter::ConvertData( 
    VARIANT varSrc,
    long vtDest,
    IUnknown *pUnknownElement,
    VARIANT *pvarDest)
{
    HRESULT hr = S_OK;

    if (pvarDest)
    {
        if (vtDest == VT_NULL ||
                (varSrc.vt == VT_BSTR && varSrc.bstrVal == NULL && vtDest != VT_BSTR))
        {
            pvarDest->vt = VT_NULL;
        }
        else if (S_OK == CanConvertData(varSrc.vt, vtDest))
        {
            BOOL fTryVariantChangeType = TRUE;

            // VariantChangeTypeEx converts VT_CY to VT_BSTR by converting to
            // float then to BSTR.  This is bogus - no currency symbol, wrong
            // decimal separator, etc.  So let's trap this and use the
            // special-purpose VarFormatCurrency instead. (The reverse conversion
            // is OK.)
            if (varSrc.vt == VT_CY && vtDest == VT_BSTR)
            {
                BSTR bstrTemp;
                // these magic numbers simply mean to use defaults for number of
                // digits, leading zeros, parens, groups, and allow user to
                // override system locale.
                hr = VarFormatCurrency(&varSrc, -1, -2, -2, -2, 0, &bstrTemp);
                if (!hr)
                {
                    VariantClear(pvarDest);
                    pvarDest->vt = VT_BSTR;
                    pvarDest->bstrVal = bstrTemp;
                    fTryVariantChangeType = FALSE;
                }
            }

            if (fTryVariantChangeType)
            {
                hr = VariantChangeTypeEx(pvarDest, &varSrc, _lcid, 0, vtDest);
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }

    RRETURN(hr);
}


HRESULT STDMETHODCALLTYPE
CSimpleDataConverter::CanConvertData( 
    long vt1,
    long vt2)
{
    HRESULT hr = S_FALSE;

    // one of the types must be BSTR
    if (vt1 != VT_BSTR)
    {
        long vtTemp = vt1;
        vt1 = vt2;
        vt2 = vtTemp;
    }

    if (vt1 != VT_BSTR)
        goto Cleanup;

    // the other can be on the list below
    switch (vt2)
    {
    case VT_I2:
    case VT_I4:
    case VT_R4:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_DECIMAL:
        hr = S_OK;
        break;

    default:
        break;
    }

Cleanup:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\dbind\simpdc.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.03.0110 */
/* at Tue Aug 25 10:20:38 1998
 */
/* Compiler settings for S:\zen\ocp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )


#ifndef I_SIMPDC_H_
#define I_SIMPDC_H_

/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ISimpleDataConverter_FWD_DEFINED__
#define __ISimpleDataConverter_FWD_DEFINED__
typedef interface ISimpleDataConverter ISimpleDataConverter;
#endif 	/* __ISimpleDataConverter_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __ISimpleDataConverter_INTERFACE_DEFINED__
#define __ISimpleDataConverter_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISimpleDataConverter
 * at Tue Aug 25 10:20:38 1998
 * using MIDL 3.03.0110
 ****************************************/
/* [hidden][helpcontext][unique][uuid][object] */ 



DEFINE_GUID(IID_ISimpleDataConverter,0x78667670,0x3C3D,0x11d2,0x91,0xF9,0x00,0x60,0x97,0xC9,0x7F,0x9B);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("78667670-3C3D-11d2-91F9-006097C97F9B")
    ISimpleDataConverter : public IUnknown
    {
    public:
        virtual /* [helpcontext] */ HRESULT STDMETHODCALLTYPE ConvertData( 
            VARIANT varSrc,
            long vtDest,
            IUnknown __RPC_FAR *pUnknownElement,
            VARIANT __RPC_FAR *pvarDest) = 0;
        
        virtual /* [helpcontext] */ HRESULT STDMETHODCALLTYPE CanConvertData( 
            long vt1,
            long vt2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISimpleDataConverterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISimpleDataConverter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISimpleDataConverter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISimpleDataConverter __RPC_FAR * This);
        
        /* [helpcontext] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConvertData )( 
            ISimpleDataConverter __RPC_FAR * This,
            VARIANT varSrc,
            long vtDest,
            IUnknown __RPC_FAR *pUnknownElement,
            VARIANT __RPC_FAR *pvarDest);
        
        /* [helpcontext] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanConvertData )( 
            ISimpleDataConverter __RPC_FAR * This,
            long vt1,
            long vt2);
        
        END_INTERFACE
    } ISimpleDataConverterVtbl;

    interface ISimpleDataConverter
    {
        CONST_VTBL struct ISimpleDataConverterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISimpleDataConverter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISimpleDataConverter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISimpleDataConverter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISimpleDataConverter_ConvertData(This,varSrc,vtDest,pUnknownElement,pvarDest)	\
    (This)->lpVtbl -> ConvertData(This,varSrc,vtDest,pUnknownElement,pvarDest)

#define ISimpleDataConverter_CanConvertData(This,vt1,vt2)	\
    (This)->lpVtbl -> CanConvertData(This,vt1,vt2)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext] */ HRESULT STDMETHODCALLTYPE ISimpleDataConverter_ConvertData_Proxy( 
    ISimpleDataConverter __RPC_FAR * This,
    VARIANT varSrc,
    long vtDest,
    IUnknown __RPC_FAR *pUnknownElement,
    VARIANT __RPC_FAR *pvarDest);


void __RPC_STUB ISimpleDataConverter_ConvertData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext] */ HRESULT STDMETHODCALLTYPE ISimpleDataConverter_CanConvertData_Proxy( 
    ISimpleDataConverter __RPC_FAR * This,
    long vt1,
    long vt2);


void __RPC_STUB ISimpleDataConverter_CanConvertData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISimpleDataConverter_INTERFACE_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif I_SIMPDC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\dbind\drecgen.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       drecgen.cxx
//
//  Contents:   record generator.
//              CRecordGeneratorTask
//              CRecordGenerator
//
//  History:
//
//  Jul-96      AlexA   Creation
//  8/13/96     SamBent Made record generation a LW task, to simulate async
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include <formkrnl.hxx>
#endif

#ifndef X_TABLE_HXX_
#define X_TABLE_HXX_
#include <table.hxx>
#endif

#ifndef X_OLEDBERR_H_
#define X_OLEDBERR_H_
#include <oledberr.h>                   // for db_s_endofrowset
#endif

#ifndef X_DETAIL_HXX_
#define X_DETAIL_HXX_
#include "detail.hxx"
#endif

#ifndef X_DRECGEN_HXX_
#define X_DRECGEN_HXX_
#include "drecgen.hxx"
#endif

#ifndef X_SWITCHES_HXX_
#define X_SWITCHES_HXX_
#include "switches.hxx"
#endif

DeclareTag(tagRecGenTask,"Databinding","CRecordGeneratorTask");
DeclareTag(tagRecGen,"DataBinding","CRecordGenerator");
DeclareTag(tagRecGenBatchSize, "Databinding", "Fetch g_BatchSize records at a time");

PerfDbgTag(tagSyncDatabind,  "Databinding", "Grab all records at once")

MtDefine(CRecordGenerator, DataBind, "CRecordGenerator")
MtDefine(CRecordGeneratorTask, DataBind, "CRecordGeneratorTask")

const int INITIAL_BATCH_SIZE = 3;

#if DBG == 1
static int g_BatchSize = 1;     // When tagRecGenBatchSize is enabled;  change via debugger
#endif


//////////////////////////////////////////////////////////////////////////
//
//  CRecordGeneratorTask implementation
//
//////////////////////////////////////////////////////////////////////////

// The lightweight task that generates records uses a buffer divided into
// four sections, containing respectively
//      o records client has released
//      o records client has fetched (but not released yet)
//      o records task has retrieved from the cursor (but client hasn't fetched)
//      o emply slots
// These areas are defined by data members _iEndReleased, _iEndFetched, and
// _iEndGenerated, which give the index just after the corresponding area:
//
//       --------------------------------------------------------------------
//      |   released    |     fetched     |    generated      |   (empty)    |
//       --------------------------------------------------------------------
//       _iEndReleased---^  _iEndFetched---^  _iEndGenerated---^

// typedef char CompileTimeAssert[cInitialRequestSize<=cBufferCapacity];


CRecordGeneratorTask::CRecordGeneratorTask(CDetailGenerator* pDetailGenerator,
                                           CRecordGenerator* pRecordGenerator,
                                           const CDataLayerBookmark& dlbStart,
                                           LONG lSkipCount,
                                           LONG lRecordsDesired,
                                           int cInitialRequestSize):
    CTask(TRUE),                        // this task should be born blocked
    _pDetailGenerator(pDetailGenerator),
    _pRecordGenerator(pRecordGenerator),
    _dlbLastRetrieved(dlbStart),
    _lSkipCount(lSkipCount),
    _hrTerminated(S_FALSE),         // in case I'm cancelled
    _cInitialRequestSize(cInitialRequestSize)
{
    if (lRecordsDesired > 0)
    {
        _cDirection = 1;
        _cDesired = lRecordsDesired;
    }
    else
    {
        _cDirection = -1;
        _cDesired = -lRecordsDesired;
    }
    Assert(_pDetailGenerator && _pRecordGenerator); 
    Assert(_cDesired > 0);
}

#if DBG==1
//+------------------------------------------------------------------------
//
//  Member:     IsValid
//
//  Synopsis:   Check that buffer representation is valid (used in Asserts)
//
//  Arguments:  none
//
//  Returns:    true        buffer is valid
//              false       buffer isn't valid

BOOL
CRecordGeneratorTask::IsValid() const
{
    return  _iEndReleased <= _iEndFetched &&
            _iEndFetched <= _iEndGenerated &&
            _iEndGenerated <= cBufferCapacity &&
            _cDirection * _cDirection == 1;
}
#endif


//+------------------------------------------------------------------------
//
//  Member:     FetchRecords (called by client)
//
//  Synopsis:   Move records from my buffer to client's buffer
//
//  Arguments:  cRecords            number of records to copy
//              ahRecords           client's array of records
//              pcRecordsFetched    number of records copied
//
//  Returns:    S_OK        it worked

HRESULT
CRecordGeneratorTask::FetchRecords(IN  ULONG  cRecords,
                     OUT RECORD ahRecords[],
                     OUT ULONG* pcRecordsFetched)
{
//    TraceTag((tagRecGenTask,
//                "CRecordGeneratorTask[%p]::FetchRecords(%lu, %p, %p) time %lu",
//                this, cRecords, ahRecords, pcRecordsFetched, GetTickCount()));
    Assert(pcRecordsFetched && "NULL pointer");
    Assert(IsValid());

    // don't fetch more records than we have
    if (cRecords > _iEndGenerated-_iEndFetched)
        cRecords = _iEndGenerated-_iEndFetched;

    // copy records to client's memory
    memmove(ahRecords, &_aRecordBuffer[_iEndFetched], cRecords * sizeof(RECORD));
    _iEndFetched += cRecords;
    
    // tell client how many
    *pcRecordsFetched = cRecords;

    RRETURN(S_OK);
}


//+------------------------------------------------------------------------
//
//  Member:     ReleaseRecords (called by client)
//
//  Synopsis:   Release records
//
//  Arguments:  cRecords            number of records to release
//
//  Returns:    S_OK        it worked

HRESULT
CRecordGeneratorTask::ReleaseRecords(ULONG cRecords)
{
//    TraceTag((tagRecGenTask,
//                "CRecordGeneratorTask[%p]::ReleaseRecords(%lu) time %lu",
//                this, cRecords, GetTickCount()));
    Assert(IsValid());
    HRESULT hr;

    CDataLayerCursor* pCursor;
    
    hr = _pRecordGenerator->GetCursor(&pCursor);
    if (hr)
        goto Cleanup;
    
    // don't release more records than we have
    if (cRecords > _iEndGenerated-_iEndReleased)
        cRecords = _iEndGenerated-_iEndReleased;

    // release the records, and mark them released
    pCursor->ReleaseRows(cRecords, &_aRecordBuffer[_iEndReleased]);
    _iEndReleased += cRecords;
    if (_iEndFetched < _iEndReleased)
        _iEndFetched = _iEndReleased;

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     OnRun (called by task manager)
//
//  Synopsis:   Retrieve more records, and callback to client
//
//  Arguments:  dwTimeout           tick count by which we should finish
//
//  Returns:    nothing

void 
CRecordGeneratorTask::OnRun(DWORD dwTimeout)
{
    TraceTag((tagRecGenTask,
                "CRecordGeneratorTask[%p]::OnRun(%lu) time %lu",
                this, dwTimeout, GetTickCount()));
    Assert(IsValid());

    BOOL    fPerfCtrlSyncDatabind = g_pHtmPerfCtl && (g_pHtmPerfCtl->dwFlags & HTMPF_SYNC_DATABIND)
#ifdef SWITCHES_ENABLED
                                    ||  IsSwitchSyncDatabind()
#endif
#if DBG==1 || defined(PERFTAGS)
                                    ||  IsPerfDbgEnabled(tagSyncDatabind)
#endif
           ;

    do
    {
        HRESULT hr;
        DBCOUNTITEM ulRecordsRetrieved = 0;
        ULONG   cThrottleRecords;         // how many we have time for
        ULONG   cRecords;                 // how many we plan to retrieve
        const   ULONG dwStartTime = GetTickCount();
        CDataLayerCursor* pCursor;

    #if DBG==1
        ULONG cPrevTime = _cPrevTime;
        ULONG cPrevGenerated = _cPrevGenerated;
    #endif
    
        hr = _pRecordGenerator->GetCursor(&pCursor);
        Assert(!hr && "Couldn't get cursor");       // this shouldn't happen

        // discard released records, and shift contents of buffer
        if (_iEndReleased > 0)
        {
            memmove(_aRecordBuffer, &_aRecordBuffer[_iEndReleased],
                    (_iEndGenerated-_iEndReleased) * sizeof(RECORD));
            _iEndGenerated -= _iEndReleased;
            _iEndFetched   -= _iEndReleased;
            _iEndReleased   = 0;
        }
        Assert(IsValid());

        // cThrottleRecords is the "ideal" number of records to fetch
        cThrottleRecords = 
                        // first time - throttle to initial request
            (_cPrevTime == 0) ? _cInitialRequestSize :
                        // otherwise estimate how many we have time for
            (2*_cPrevGenerated*(dwTimeout-dwStartTime) + _cPrevTime) / (2*_cPrevTime);
        if (cThrottleRecords < 1)   // but get at least one
            cThrottleRecords = 1;    
    
        // determine how many records to fetch
        cRecords = _cDesired - _cTotalGenerated;     // try to finish request
        if (cRecords > cThrottleRecords)             // but don't take too long
            cRecords = cThrottleRecords;
        if (cRecords > cBufferCapacity-_iEndGenerated) // and don't overflow buffer
            cRecords = cBufferCapacity - _iEndGenerated;

    #if DBG==1
        if (IsTagEnabled(tagRecGenBatchSize))
            cRecords = g_BatchSize;
    #endif
        AssertSz(cRecords > 0, "Can't make progress fetching 0 records");

        // retrieve the records, mark them generated
        hr = pCursor->GetRowsAt(_dlbLastRetrieved,
                                _lSkipCount,
                                _cDirection * (DBROWCOUNT) cRecords,
                                &ulRecordsRetrieved,
                                &_aRecordBuffer[_iEndGenerated]);
    
        _cTotalGenerated += (ULONG)ulRecordsRetrieved;
        _iEndGenerated += (ULONG)ulRecordsRetrieved;

        // notify client that records are available
        if (_iEndGenerated - _iEndFetched > 0)
        {
            IGNORE_HR(_pDetailGenerator->OnRecordsAvailable(_iEndGenerated - _iEndFetched));
        }

        // prepare for the next batch
        if (ulRecordsRetrieved > 0)
        {
            // remember where we stopped
            IGNORE_HR(pCursor->CreateBookmark(_aRecordBuffer[_iEndGenerated-1],
                                            &_dlbLastRetrieved));
            _lSkipCount = _cDirection;

            // remember how long it took and how many records we got
            _cPrevTime = GetTickCount() - dwStartTime;
            _cPrevGenerated = ulRecordsRetrieved;
        }

        TraceTag((tagRecGenTask,
            "CRecordGeneratorTask[%p]::OnRun (time %lu) retrieved %lu records in %lu ticks \n"
            " desired = %lu, cThrottleRecords = %lu, cRecords = %lu, cPrevTime = %lu, cPrevGenerated = %lu, ticks = %lu",
            this, GetTickCount(), ulRecordsRetrieved, _cPrevTime,
            _cDesired, cThrottleRecords, cRecords,
            cPrevTime, cPrevGenerated , dwTimeout-dwStartTime
            ));

        // if we're done, terminate
        if (_iEndGenerated - _iEndFetched == 0 &&
            (FAILED(hr) || ulRecordsRetrieved<cRecords || _cTotalGenerated>=_cDesired))
        {
            _hrTerminated = hr;
            Terminate();
        }
    }
    while ( fPerfCtrlSyncDatabind && !TestFlag(TASKF_TERMINATED) );

}

//+------------------------------------------------------------------------
//
//  Member:     OnTerminate (called by task manager)
//
//  Synopsis:   notify parent that task is done
//
//  Arguments:  none
//
//  Returns:    nothing

void
CRecordGeneratorTask::OnTerminate()
{
    TraceTag((tagRecGenTask,
                "CRecordGeneratorTask[%p]::OnTerminate() time %lu",
                this, GetTickCount()));
    
    // release records
    IGNORE_HR(ReleaseRecords(_iEndGenerated - _iEndReleased));
    _dlbLastRetrieved = CDataLayerBookmark::TheNull;

    // tell parent I'm done
    if (_hrTerminated != S_FALSE)
        _pRecordGenerator->OnTaskDone();
}
    


//////////////////////////////////////////////////////////////////////////
//
//  CRecordGenerator implementation
//
//////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  class       CRecordGenerator
//
//  Member:     constructor
//
//-------------------------------------------------------------------------
CRecordGenerator::CRecordGenerator ():
    _pDLC(0),
    _pDetailGenerator(0),
    _pTask(0)
{
    TraceTag((tagRecGen, "CRecordGenerator::constructor() -> %p", this));
}




//+------------------------------------------------------------------------
//
//  class       CRecordGenerator
//
//  Member:     destructor
//
//-------------------------------------------------------------------------
CRecordGenerator::~CRecordGenerator()
{
    TraceTag((tagRecGen, "CRecordGenerator::destructor() -> %p", this));

    Assert (!_pDLC);                // Detach should be called first
    Assert (!_pDetailGenerator);
    Assert (!_pTask);
}




//+------------------------------------------------------------------------
//
//  Member:     Detach
//
//  Synopsis:   Detaches the object, removing any internal self-
//              references.
//
//-------------------------------------------------------------------------
void 
CRecordGenerator::Detach()
{
    TraceTag((tagRecGen, "CRecordGenerator::Detach() -> %p", this));

    // if my task is running, shut it off
    if (_pTask)
    {
        _pTask->Release();
        _pTask = 0;
    }

    if (_pDLC)
    {
        _pDLC->Release();
        _pDLC = NULL;
    }
    
    _pDetailGenerator = NULL;
}




//+------------------------------------------------------------------------
//
//  Member:     RequestMetaData
//
//  Synopsis:   Before starting generating rows, we need to get the metadata
//              to establish binding specifications for the bound elements.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT 
CRecordGenerator::RequestMetaData()
{
    TraceTag((tagRecGen, "CRecordGenerator::RequestMetaData() -> %p", this));
    Assert(_pDetailGenerator && "call Init first");
    
    HRESULT hr;
    CDataLayerCursor *pCursor;

    hr = GetCursor(&pCursor);
    if (hr)
        goto Cleanup;

    hr = _pDetailGenerator->OnMetaDataAvailable();

Cleanup:
    RRETURN (hr);
}



//+------------------------------------------------------------------------
//
//  Member:     GetCursor
//
//  Synopsis:   Get Cursor 
//
//  Note:       Could fail during the metadata fetching
//
//  Arguments:  [ppCursor]              -- pointer to an a result (pointer to a Cursor).
//                                          
//  Returns:    HRESULT 
//
//-------------------------------------------------------------------------
HRESULT 
CRecordGenerator::GetCursor(CDataLayerCursor **ppDataLayerCursor)
{
    *ppDataLayerCursor = _pDLC;
    return S_OK;
}



//+------------------------------------------------------------------------
//
//  Member:     CancelRequest
//
//  Synopsis:   Call from the Host to stop previous request to generate rows
//
//  Arguments:  
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT 
CRecordGenerator::CancelRequest ()
{
//    TraceTag((tagRecGen, "CRecordGenerator::CancelRequest() -> %p", this));

    if (_pTask)
    {
        _pTask->Release();      // this calls Terminate
        _pTask = 0;
    }
    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     GetRatio
//
//  Synopsis:   Get the ratio for the record
//
//  Arguments:  record          record to get the ratio for
//              pulNumerator    result
//              pulDenominator  result
//                                          
//-------------------------------------------------------------------------

void 
CRecordGenerator::GetRatio(RECORD record, 
                           DBCOUNTITEM *pulNumerator, 
                           DBCOUNTITEM *pulDenominator)
{
    Assert (pulNumerator);
    Assert (pulDenominator);

    CDataLayerCursor *  pCursor;
    HRESULT             hr;

    hr = GetCursor(&pCursor);
    if (hr)
        goto Cleanup;
    
    hr = pCursor->GetPositionAndSize(record, pulNumerator, pulDenominator);
    Assert (!hr);           // should never fail

Cleanup:
    return;
}




#if DBG==1
static ULONG ulDebugGenerateCount=0;    // set (in debugger) to truncate query
static BOOL fDebugSynchronous=0;        // set to turn off asynchrony
#endif

//+------------------------------------------------------------------------
//
//  Member:     StartTask
//
//  Synopsis:   Start a task to retrive records
//
//  Arguments:  dlbStart        bookmark of starting record
//              lSkipCount      offset from bookmark to starting record
//              ulGenerateCount number of records to generate
//
//  Returns:    HRESULT

HRESULT
CRecordGenerator::StartTask(const CDataLayerBookmark& dlbStart, 
                           LONG lSkipCount,
                           ULONG ulGenerateCount)
{
    TraceTag((tagRecGen, "CRecordGenerator::StartTask[%p](%p, %ld, %lu)",
                            this, &dlbStart, lSkipCount, ulGenerateCount));
    HRESULT hr = S_OK;
    
#if DBG==1
    // debugging - reset desired count
    if (ulDebugGenerateCount>0 && ulDebugGenerateCount<ulGenerateCount)
        ulGenerateCount = ulDebugGenerateCount;
#endif

    Assert(!_pTask);

    // create a task to generate the records (this also schedules the task)
    _pTask = new CRecordGeneratorTask(_pDetailGenerator, this, dlbStart,
                                      lSkipCount, ulGenerateCount, INITIAL_BATCH_SIZE);
    if (_pTask == 0)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    _pTask->SetBlocked(FALSE);          // let task get scheduled now.

#if DBG==1
    // debugging - do task synchronously
    if (fDebugSynchronous)
    {
        while (_pTask)
        {
            _pTask->OnRun(GetTickCount()+100);
        }
    }
#endif

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     OnTaskDone
//
//  Synopsis:   Notification from task that it's done.  Release the task,
//              and notify my client

void
CRecordGenerator::OnTaskDone()
{
    if (_pTask)
    {
        HRESULT hrReasonTerminated = _pTask->ReasonTerminated();
        
        _pTask->Release();
        _pTask = 0;

        Assert(_pDetailGenerator);
        _pDetailGenerator->OnRequestDone( hrReasonTerminated == DB_S_ENDOFROWSET 
                                    || hrReasonTerminated == DB_E_BADSTARTPOSITION );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\dbind\trdntosp.cxx ===
//+------------------------------------------------------------------------
//
//  File:       TRDNTOSP.CXX
//
//  Contents:   Object for HTML based OSP
//
//  Classes:    (part of) CDoc
//
//-------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SIMPDATA_H_
#define X_SIMPDATA_H_
#include "simpdata.h"
#endif

#ifndef X_MSDATSRC_H_
#define X_MSDATSRC_H_
#include "msdatsrc.h"
#endif

#ifndef X_COMMCTRL_H_
#define X_COMMCTRL_H_
#include "commctrl.h"
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

MtDefine(TridentOSP, DataBind, "TridentOSP")
MtDefine(TridentOSP_apaBSTRtagData_pv, TridentOSP, "TridentOSP::_apaBSTRtagData::_pv")
MtDefine(TridentOSPInit_pDataColumn, Locals, "TridentOSP::Init pDataColumn")
MtDefine(TridentOSPInit_pDataColumn_pv, Locals, "TridentOSP::Init pDataColumn::_pv")

BEGIN_TEAROFF_TABLE(CDoc, DataSource)
    TEAROFF_METHOD(CDoc, getDataMember, getdatamember, (DataMember bstrDM, REFIID riid, IUnknown **ppunk))
    TEAROFF_METHOD(CDoc, getDataMemberName, getdatamembername, (long lIndex, DataMember *pbstrDM))
    TEAROFF_METHOD(CDoc, getDataMemberCount, getdatamembercount, (long *plCount))
    TEAROFF_METHOD(CDoc, addDataSourceListener, adddatasourcelistener, (DataSourceListener *pDSL))
    TEAROFF_METHOD(CDoc, removeDataSourceListener, removedatasourcelistener, (DataSourceListener *pDSL))
END_TEAROFF_TABLE()

class TridentOSP:OLEDBSimpleProvider
{ 
public:

    DECLARE_MEMALLOC_NEW_DELETE(Mt(TridentOSP))

// Constructors
    TridentOSP(CDoc *pDoc);

// Destructor
    ~TridentOSP();

// Initializer
    HRESULT Init();
// IOLEDBSimpleProvider
    
    virtual HRESULT STDMETHODCALLTYPE getRowCount(DBROWCOUNT *pcRows);
    virtual HRESULT STDMETHODCALLTYPE getColumnCount(DB_LORDINAL *pcColumns);
    virtual HRESULT STDMETHODCALLTYPE getRWStatus(DBROWCOUNT iRow, DB_LORDINAL iColumn, OSPRW *prwStatus);
    virtual HRESULT STDMETHODCALLTYPE getVariant(DBROWCOUNT iRow, DB_LORDINAL iColumn, OSPFORMAT format, VARIANT *pVar);
    virtual HRESULT STDMETHODCALLTYPE setVariant(DBROWCOUNT iRow, DB_LORDINAL iColumn, OSPFORMAT format, VARIANT Var);
    virtual HRESULT STDMETHODCALLTYPE getLocale(BSTR *pbstrLocale);
    virtual HRESULT STDMETHODCALLTYPE deleteRows(DBROWCOUNT iRow, DBROWCOUNT cRows, DBROWCOUNT *pcRowsDeleted);
    virtual HRESULT STDMETHODCALLTYPE insertRows(DBROWCOUNT iRow, DBROWCOUNT cRows, DBROWCOUNT *pcRowsInserted);
    virtual HRESULT STDMETHODCALLTYPE find(DBROWCOUNT iRowStart, DB_LORDINAL iColumn, VARIANT val, OSPFIND findflags, OSPCOMP compType, DBROWCOUNT *piRowFound);
    virtual HRESULT STDMETHODCALLTYPE addOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pospIListener);
    virtual HRESULT STDMETHODCALLTYPE removeOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pospIListener);
    virtual HRESULT STDMETHODCALLTYPE isAsync(BOOL *pbAsynch);
    virtual HRESULT STDMETHODCALLTYPE getEstimatedRows(DBROWCOUNT *piRows);
    virtual HRESULT STDMETHODCALLTYPE stopTransfer(void);

//  IUnknown Interfaces
    virtual HRESULT __stdcall QueryInterface(const IID& iid, void **ppv);
    virtual ULONG __stdcall AddRef();
    virtual ULONG __stdcall Release();

private:
    long _refCount;
    long _rowCount;
    CDoc *_pDoc;
    OLEDBSimpleProviderListener *_pospMyListener;
    CDataAry< CDataAry<BSTR> *> _apaBSTRtagData;

#ifdef OBJCNTCHK
    DWORD _dwObjCnt;
#endif

};


//+------------------------------------------------------------------------
//
//  Member:     TridentOSP::TridentOSP(CDoc *pDoc)
//
//  Synopsis:   Class constructor which takes a pointer to CDoc, gets the 
//              IHTML Collection and stores the tags with ID's in a dynamically
//              allocated array of type CDataAry. Called upon "new TridentOSP"
//
//  Returns:    no return value
//
//-------------------------------------------------------------------------

TridentOSP::TridentOSP(CDoc *pDoc)
    : _apaBSTRtagData(Mt(TridentOSP_apaBSTRtagData_pv))
{
    _pDoc = pDoc;

// reference counting
    _refCount = 1;
    _rowCount = 0;
    _pDoc->SubAddRef();
    IncrementObjectCount(&_dwObjCnt);

    return;
}

HRESULT
TridentOSP::Init() 
{   
    long i, j, dataLength, dataIndex;
    HRESULT hr;
    VARIANT v, vEmpty;
    IDispatch *pout = NULL;
    IHTMLElement *pout2 = NULL;
    
    CDataAry<BSTR> *pDataColumn, *pDataPtr;
    IHTMLElementCollection *pElementCollection; 
    dataIndex = 0;


//initialization of 2D tag data array

    _pDoc->PrimaryMarkup()->GetCollection(CMarkup::ELEMENT_COLLECTION, &pElementCollection);
    hr = pElementCollection->get_length(&dataLength);
    if(hr)
        return hr;

    V_VT(&vEmpty) = VT_EMPTY;
    V_VT(&v) = VT_I4;

    for (i = 0; i < dataLength; i++) 
    {
        BSTR pstrID = NULL, pstrData = NULL;

        V_I4(&v) = i;
        hr = pElementCollection->item(v, vEmpty, &pout);
        if(hr)
            goto Cleanup;

        pout->QueryInterface(IID_IHTMLElement, (void **)&pout2);
        hr = pout2->get_id(&pstrID);
        if (hr)
            goto Cleanup;

        hr = pout2->get_innerHTML(&pstrData);
        // <HTML> tag gives hr error on get_innerHTML.  Must check ht value and make sure tag is not
        // empty
        if(pstrID && !hr)
        {
            pDataColumn = NULL;
            
            for ( j = 0; j < _apaBSTRtagData.Size(); j++)
            { 
                // Search for a duplicate tag ID in existing structure
                pDataPtr = _apaBSTRtagData.Item(j);

                if (! _tcscmp(pstrID, pDataPtr->Item(0)))       
                    pDataColumn = pDataPtr;
            }

            if (!pDataColumn)
                {       // no match.  Insert new tag id to _apaBSTRtagData
                pDataColumn = new(Mt(TridentOSPInit_pDataColumn)) CDataAry<BSTR>(Mt(TridentOSPInit_pDataColumn_pv));
                if (pDataColumn)
                {
                    _apaBSTRtagData.InsertIndirect(dataIndex, &pDataColumn);
                    pDataColumn->InsertIndirect(0, &pstrID);      
                    dataIndex++; 
                }
            }

            if (pDataColumn)
            {
                pDataColumn->InsertIndirect(pDataColumn->Size(), &pstrData);
                    if (pDataColumn->Size()-1 > _rowCount)
                    _rowCount = pDataColumn->Size()-1;          
            }
        }
        else
        {
           if(pstrData)
               SysFreeString(pstrData);
           if(pstrID)
               SysFreeString(pstrID);
        }

        ClearInterface(&pout);
        ClearInterface(&pout2);
    }


Cleanup:
    ReleaseInterface(pElementCollection);
    ReleaseInterface(pout);
    ReleaseInterface(pout2);

return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     TridentOSP::~TridentOSP()
//
//  Synopsis:   Class deconstructor which releases the CDoc reference and 
//              decrements the object count
//
//  Returns:    no return value
//
//-------------------------------------------------------------------------

TridentOSP::~TridentOSP()
{
    CDataAry<BSTR> **pElem;

    int    i, j;

    for (i = _apaBSTRtagData.Size(), pElem = _apaBSTRtagData;
         i > 0;
         i--, pElem++)
    {
        for (j = (*pElem)->Size()-1;
             j >= 0;
             j--)  
        {
             SysFreeString((*pElem)->Item(j));
        }

        (*pElem)->DeleteAll();
        delete *pElem;        
    }
    _apaBSTRtagData.DeleteAll();

    _pDoc->SubRelease();
    DecrementObjectCount(&_dwObjCnt);
    ReleaseInterface(_pospMyListener);
    return;
}


//+------------------------------------------------------------------------
//
//  Member:     TridentOSP::getRowCount(long *pcRows)
//
//  Synopsis:   Returns the number of rows of data.   For now, the number of 
//              rows is only 2, but future revisions will allow access of 
//              multiple rows for duplicate tag ID's 
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------


HRESULT STDMETHODCALLTYPE
TridentOSP::getRowCount(DBROWCOUNT *pcRows)
{
    *pcRows = _rowCount;
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     TridentOSP::GetColumnCount(long *pcColumns)
//
//  Synopsis:   Returns the number of columns in the _apaBSTRtagData structure
//              which corresponds to the number of non-empty, unique HTML Tag
//              ID's in the data source.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------


HRESULT STDMETHODCALLTYPE
TridentOSP::getColumnCount(DB_LORDINAL *pcColumns)
{
    *pcColumns = _apaBSTRtagData.Size();
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     TridentOSP::getRWStatus(long iRow, long iColumn, OSPRW *prwStatus)
//
//  Synopsis:   Returns the Read/Write Status of the structure.   All elements
//              are read-only
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
TridentOSP::getRWStatus(DBROWCOUNT iRow, DB_LORDINAL iColumn, OSPRW *prwStatus)
{
    *prwStatus = OSPRW_READONLY;
    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     TridentOSP::getVariant(long iRow, long iColumn, OSPFORMAT format, VARIANT *pVar)
//
//  Synopsis:   Gets the desired Variant from the data structure and returns it. 
//              Row 0 is the Tag ID, and any other row is the Inner HTML.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------


HRESULT STDMETHODCALLTYPE
TridentOSP::getVariant(DBROWCOUNT iRow, DB_LORDINAL iColumn, OSPFORMAT format, VARIANT *pVar)
{
    CDataAry<BSTR> *pDataColumn;
    BSTR tempBSTR;

    V_VT(pVar) = VT_BSTR;

    pDataColumn = _apaBSTRtagData.Item(iColumn - 1);

    if (iRow == 0)
    {
       tempBSTR = SysAllocString(pDataColumn->Item(0));
       V_BSTR(pVar) = tempBSTR;
    }

    else
    {   
        if (iRow >= pDataColumn->Size())
            tempBSTR = SysAllocString(_T(""));
        else
            tempBSTR = SysAllocString(pDataColumn->Item(iRow));
        
        V_BSTR(pVar) = tempBSTR;
    }       

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     TridentOSP::setVariant(long iRow, long iColumn, OSPFORMAT format, VARIANT Var)
//
//  Synopsis:   Unimplemented.   setVariant should never be called since all the 
//              elements are READONLY  
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------


HRESULT STDMETHODCALLTYPE
TridentOSP::setVariant(DBROWCOUNT iRow, DB_LORDINAL iColumn, OSPFORMAT format, VARIANT Var)
{
    return E_FAIL;
}



//+------------------------------------------------------------------------
//
//  Member:     TridentOSP::getLocale(BSTR *pbstrLocale)
//
//  Synopsis:   Unimplemented.    
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------


HRESULT STDMETHODCALLTYPE
TridentOSP::getLocale(BSTR *pbstrLocale)
{
// TODO (t-trevs) this should be implemented
    *pbstrLocale = NULL;
    return S_OK;
}



//+------------------------------------------------------------------------
//
//  Member:     TridentOSP::deleteRows(long iRow, long cRows, long *pcRowsDeleted)
//
//  Synopsis:   Unimplemented.  Data structure is read-only.  
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
TridentOSP::deleteRows(DBROWCOUNT iRow, DBROWCOUNT cRows, DBROWCOUNT *pcRowsDeleted)
{
    *pcRowsDeleted = 0;
    return E_FAIL;
}



//+------------------------------------------------------------------------
//
//  Member:     TridentOSP::insertRows(long iRow, long cRows, long *pcRowsInserted)
//
//  Synopsis:   Unimplemented.  Data structure is read-only.  
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
TridentOSP::insertRows(DBROWCOUNT iRow, DBROWCOUNT cRows, DBROWCOUNT *pcRowsInserted)
{
    *pcRowsInserted = 0;
    return E_FAIL;
}


//+------------------------------------------------------------------------
//
//  Member:     TridentOSP::find(long iRowStart, long iColumn, VARIANT val, 
//                               OSPFIND findflags, OSPCOMP compType, long *piRowFound)
//
//  Synopsis:   Unimplemented.   
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
TridentOSP::find(DBROWCOUNT iRowStart, DB_LORDINAL iColumn, VARIANT val, OSPFIND findflags, OSPCOMP compType, DBROWCOUNT *piRowFound)
{
// TODO (t-trevs) we should probably implement TridentOSP::Find()
    return E_FAIL;
}



//+------------------------------------------------------------------------
//
//  Member:    addOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pospIListener)
//
//  Synopsis:   Sets current OLEDBSimpleProviderListener to input pointer.   Sets
//              the member variable.  
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
TridentOSP::addOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pospIListener)
{
    _pospMyListener = pospIListener;
    pospIListener->AddRef();
    return S_OK;
}



//+------------------------------------------------------------------------
//
//  Member:     removeOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pospIListener)
//
//  Synopsis:   removes the current listener and releases the interface.  Clears the 
//              member variable.  
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
TridentOSP::removeOLEDBSimpleProviderListener(OLEDBSimpleProviderListener *pospIListener)
{
    Assert(_pospMyListener == pospIListener);
    _pospMyListener = NULL;
    ReleaseInterface(pospIListener);

    return S_OK;
}


//+------------------------------------------------------------------------
//  Member:     TridentOSP::isAsync(BOOL *pbAsynch)
//
//  Synopsis:   Implementation does not support Asynchronous data transfer 
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------


HRESULT STDMETHODCALLTYPE
TridentOSP::isAsync(BOOL *pbAsynch)
{
    *pbAsynch = 0;
    return S_OK;
}


//+------------------------------------------------------------------------
//  Member:     TridentOSP::getEstimatedRows(long *piRows)
//
//  Synopsis:   Returns unspecified estimation of rows  
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------


HRESULT STDMETHODCALLTYPE
TridentOSP::getEstimatedRows(DBROWCOUNT *piRows)
{
    *piRows = -1;
    return S_OK;
}



//+------------------------------------------------------------------------
//  Member:     TridentOSP::stopTransfer(void)
//
//  Synopsis:   Unimplemented.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
TridentOSP::stopTransfer(void)
{
    return S_OK;
}




//+------------------------------------------------------------------------
//  Member:     TridentOSP::AddRef()
//
//  Synopsis:   Increments the Reference Count
//
//  Returns:    ULONG
//
//-------------------------------------------------------------------------


ULONG __stdcall
TridentOSP::AddRef()
{
    return ++_refCount;
}


//+------------------------------------------------------------------------
//  Member:     TridentOSP::AddRef()
//
//  Synopsis:   Decrements the Reference Count and if reference count becomes
//              0, deletes the instance
//
//  Returns:    ULONG
//
//-------------------------------------------------------------------------

ULONG __stdcall
TridentOSP::Release()
{
    ULONG ulRefs = --_refCount;
    if (ulRefs == 0)
        delete this;

    return ulRefs;
}


//+------------------------------------------------------------------------
//  Member:     TridentOSP::QueryInterface(const IID& iid, void **ppv)
//
//  Synopsis:   QueryInterface implementation for TridentOSP class
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------


HRESULT __stdcall
TridentOSP::QueryInterface(const IID& iid, void **ppv)
{
    if (iid == IID_IUnknown || iid == IID_OLEDBSimpleProvider)
    {
        _refCount++;
        *ppv = this;
        return S_OK;
    }
    
    return E_FAIL;
}


//+------------------------------------------------------------------------
//  Member:     CDoc::getDataMember(DataMember bstrDM,REFIID riid, IUnknown **ppunk)
//
//  Synopsis:   sets ppunk to point to a new TridentOSP class.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------



HRESULT STDMETHODCALLTYPE
CDoc::getDataMember(DataMember bstrDM,REFIID riid, IUnknown **ppunk)
{
    HRESULT hr = S_OK;
    *ppunk = NULL;

    if (PrimaryMarkup()->GetReadyState() == READYSTATE_COMPLETE)
    {
        TridentOSP *pNew = new TridentOSP(this);
        if (pNew)
        {
            hr = pNew->Init();
            if ( !hr )
            {
                *ppunk = (IUnknown *) (void *) pNew;
            }
        }
        else
            hr = E_OUTOFMEMORY;
    }
    return hr;
}


//+------------------------------------------------------------------------
//  Member:     CDoc::getDataMemberName(long lIndex, DataMember *pbstrDM)
//
//  Synopsis:   Unimplemented.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------


HRESULT STDMETHODCALLTYPE 
CDoc::getDataMemberName(long lIndex, DataMember *pbstrDM)
{
    *pbstrDM = NULL;
    return S_OK;
}


//+------------------------------------------------------------------------
//  Member:     CDoc::getDataMemberCount(long *plCount)
//
//  Synopsis:   Unimplemented.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CDoc::getDataMemberCount(long *plCount)
{
    *plCount = NULL;
    return S_OK;
}

//+------------------------------------------------------------------------
//  Member:     CDoc::addDataSourceListener(DataSourceListener *pDSL)
//
//  Synopsis:   Unimplemented.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CDoc::addDataSourceListener(DataSourceListener *pDSL)
{
    _pDSL = pDSL;
    pDSL->AddRef();
    return S_OK;
}


//+------------------------------------------------------------------------
//  Member:     CDoc::removeDataSourceListener(DataSourceListener *pDSL)
//  Synopsis:   Unimplemented.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CDoc::removeDataSourceListener(DataSourceListener *pDSL)
{
    Assert(_pDSL == pDSL);
    _pDSL = NULL;
    ReleaseInterface(pDSL);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\dbind\unixposition.cxx ===
//--------------------------------------------------------------------
// IRowPosition class
// (c) 1995 Microsoft Corporation.  All Rights Reserved.
//
//  File:       position.cxx
//  Author:     Charles Frankston (cfranks)
//
//  Contents:   CRowPosition object implementation
//

#include <dlaypch.hxx>
#pragma hdrstop

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#include <connect.hxx>
#include <coredisp.h>
#include "unixposition.hxx"

#ifdef ROWPOSITION_DELETE
IMPLEMENT_FORMS_SUBOBJECT_IUNKNOWN(CRowPosition::MyRowsetNotify,
                                   CRowPosition, _RowsetNotify);

// Gee, why doesn't the macro above give us one of these??
STDMETHODIMP
CRowPosition::MyRowsetNotify::QueryInterface (REFIID riid, LPVOID *ppv)
{
    Assert(ppv);
    
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IRowsetNotify))
    {
        *ppv = this;
    }
    else
    {
        *ppv = NULL;
    }
    
    //  If we're going to return an interface, AddRef it first
    if (*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

#endif  // ROWPOSITION_DELETE

const CONNECTION_POINT_INFO CRowPosition::s_acpi[] =
{
    CPI_ENTRY(IID_IRowPositionChange, DISPID_A_ROWPOSITIONCHANGESINK)
    CPI_ENTRY_NULL
};

const CRowPosition::CLASSDESC CRowPosition::s_classdesc =
{
        NULL,                           // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        0,                              // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
};

//+---------------------------------------------------------------------------
//  Member:     GetClassDesc (public member)
//
//  Synopsis:   Return the class descriptor, we only use the descriptor to
//              describe the number of connection points our container can
//              handle and the connection points.
//
//  Arguments:  None
//
//  Returns:    CLASSDESC
//

const CBase::CLASSDESC *
CRowPosition::GetClassDesc () const
{
    return &s_classdesc;
}


STDMETHODIMP
CRowPosition::PrivateQueryInterface (REFIID riid, LPVOID * ppv)
{

    Assert(ppv);

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IUnknown *)(IPrivateUnknown *)this;
    }
#define TEST(IFace) else if (IsEqualIID(riid, IID_##IFace)) *ppv = (IFace *)this

    TEST(IRowPosition);

#undef TEST

    else if (IsEqualIID(riid, IID_IConnectionPointContainer))
    {
        *((IConnectionPointContainer **)ppv) =
                                            new CConnectionPointContainer(this, NULL);
        if (!*ppv)
        {
            RRETURN(E_OUTOFMEMORY);
        }
    }
    else
    {
        *ppv = NULL;
    }

    //  If we're going to return an interface, AddRef it first
    if (*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}


//+---------------------------------------------------------------------------
//  Member:     Passivate()
//
//  Synopsis:   Called from our base class's release (CBase::Release).
//              Clean ourselves up in preparation for destruction.
//
//  Arguments:  None
//
//  Returns:    None

void
CRowPosition::Passivate()
{
    ReleaseResources();
    super::Passivate();
}

//+---------------------------------------------------------------------------
//  Member:     ReleaseResources()      (protected helper
//
//  Synopsis:   Release my resources
//
//  Arguments:  None
//
//  Returns:    None

void
CRowPosition::ReleaseResources()
{
    if (_pCP)
    {
        _pCP->Unadvise(_wAdviseCookie);
        ClearInterface(&_pCP);
    }

    if (_pRowset)
    {
#ifdef ROWPOSITION_DELETE
        ReleaseBookmarkAccessor();
        ClearInterface(&_pRowsetLocate);
#endif

        // Special code for our cleanup
        if (_hRow != DB_NULL_HROW)
        {
            _pRowset->ReleaseRows(1, &_hRow, NULL,
                                  NULL, NULL);    
            _hRow = NULL;
        }

        if (_pChapRowset &&_hChapter != DB_NULL_HCHAPTER)
        {
            _pChapRowset->ReleaseChapter(_hChapter, NULL);
        }
        
        ClearInterface(&_pChapRowset);
        ClearInterface(&_pRowset);
    }
}

//+---------------------------------------------------------------------------
//  Member:     Init (public member)
//
//  Synopsis:   Initializes a newly create CRowPosition.
//              We initialize most things here rather than in the constructor
//              so we can do better error checking.
//
//  Arguments:  pRowSet             Pointer to the IRowset we're on top of.
//
//  Returns:    S_OK                if everything is fine,
//

HRESULT
CRowPosition::Initialize(IUnknown *pRowset)
{
    HRESULT hr;
    IConnectionPointContainer *pCPC = NULL;

#ifdef ROWPOSITION_DELETE
    Assert(_pRowsetLocate == NULL && _Bookmark.ptr==NULL && _pAccessor==NULL &&
           _hAccessorBookmark==NULL && "IRowPosition init'd more than once.");
#endif

    Assert(_pRowset==NULL && _pCP==NULL && 
           _hRow==NULL && "IRowPosition init'd more than once.");

    if (!pRowset)
    {
        hr = E_INVALIDARG;
        goto Error;
    }

    hr =  pRowset->QueryInterface(IID_IRowset, (LPVOID *)&_pRowset);
    if (FAILED(hr)) goto Error;

    IGNORE_HR(pRowset->QueryInterface(IID_IChapteredRowset, (LPVOID *)&_pChapRowset));

#ifdef ROWPOSITION_DELETE

    hr = _pRowset->QueryInterface(IID_IRowsetLocate, (void **)&_pRowsetLocate);
    if (FAILED(hr)) goto Error;

    hr = _pRowset->QueryInterface(IID_IConnectionPointContainer, (void **)&pCPC);
    if (pCPC)
    {
        hr = pCPC->FindConnectionPoint(IID_IRowsetNotify, &_pCP);
        if (_pCP)
        {
            hr = _pCP->Advise((IUnknown *)&_RowsetNotify, &_wAdviseCookie);
            if (FAILED(hr))
            {
                ClearInterface(&_pCP);  // make sure we don't DeAdvise
            }
        }
        ClearInterface(&pCPC);
    }

    if (FAILED(hr)) goto Error;

    // Initialize and remember bookmark accessor.
    hr = CreateBookmarkAccessor();
    if (FAILED(hr)) goto Error;

#endif



Cleanup:
    return hr;

Error:
    ReleaseResources();
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//  Member:     GetRowset (public member)
//
//  Synopsis:   returns an interface pointer from the rowset we're on top of.
//              Note this does a QI on that interface, remember to release!
//
//  Arguments:  iid             the IID of the interface we want.
//              *ppIUnknown     pointer to the interface requested
//
//  Returns:    S_OK                if everything is fine,
//
STDMETHODIMP
CRowPosition::GetRowset(REFIID riid, LPUNKNOWN *ppIUnknown)
{
    HRESULT hr;

    if (_pRowset)
    {
        hr = _pRowset->QueryInterface(riid, (void **)ppIUnknown);
    }
    else
    {
        Assert(FALSE && "Rowset disappeared?");
        hr = E_UNEXPECTED;
    }
    return hr;
};

STDMETHODIMP
CRowPosition::ClearRowPosition()
{
    HRESULT hr;
    int iProgress=0;                    // track # of sinks.

    if (!_pRowset || _fCleared)
        return E_UNEXPECTED;

    // First, OKTODO..
    hr = FireRowPositionChange(DBREASON_ROWPOSITION_CLEARED, DBEVENTPHASE_OKTODO, 0, &iProgress);   
    if (CANCELLED(hr))
        goto Cancel;

    // Then ABOUTTODO
    iProgress = 0;
    hr = FireRowPositionChange(DBREASON_ROWPOSITION_CLEARED,  DBEVENTPHASE_ABOUTTODO, 0, &iProgress);
    if (CANCELLED(hr))
        goto Cancel;

    // release our hold on the HROW
    if (_hRow != DB_NULL_HROW)
        _pRowset->ReleaseRows(1, &_hRow, NULL, NULL, NULL);
    
    // set internal state
    _fCleared = TRUE;   
    _hRow = DB_NULL_HROW;
    _dwPositionFlags = DBPOSITION_NOROW;

    return NOERROR;

Cancel: 
    // If Change was cancelled, we fire a FAILEDTODO event.
    FireRowPositionChange(DBREASON_ROWPOSITION_CLEARED, DBEVENTPHASE_FAILEDTODO, 1, &iProgress);
    // UNDONE:  we aren't turning off events yet per connection
    return DB_E_CANCELED;             // User cancelled
};


STDMETHODIMP
CRowPosition::SetRowPosition(HCHAPTER hChapter, HROW hRow, DBPOSITIONFLAGS dwPositionFlags)
{
    HRESULT hr;
    int iProgress=0;                    // track # of sinks.
    int iDummy=0;
    DBREASON eReason = DBREASON_ROWPOSITION_CHANGED;

    if (!_pRowset || !_fCleared)
        return E_UNEXPECTED;

    if( (hRow && dwPositionFlags != DBPOSITION_OK) || 
        (!hRow && dwPositionFlags == DBPOSITION_OK) )
        return E_INVALIDARG;

    // AddRef the new hRow
    // UNDONE:  Is it the client's duty to addref the hRow before
    // returning it back from Move?
    if (hRow!=DB_NULL_HROW) 
    {
        hr = _pRowset->AddRefRows(1, &hRow, NULL, NULL);
        if( FAILED(hr) )
            return DB_E_BADROWHANDLE;
    }

    if (_hChapter != hChapter)
    {
        if (_pChapRowset)
        {
            if (hChapter != DB_NULL_HCHAPTER)
                _pChapRowset->AddRefChapter(hChapter, NULL);
            if (_hChapter != DB_NULL_HCHAPTER)
                _pChapRowset->ReleaseChapter(_hChapter, NULL);
        }
        
        _hChapter = hChapter;   
        eReason = DBREASON_ROWPOSITION_CHAPTERCHANGED;
    }

    _hRow = hRow;               // make the change
    _dwPositionFlags = dwPositionFlags;

    // Do the SYNCHAFTER event.  This cannot be cancelled or fail!
    FireRowPositionChange(eReason, DBEVENTPHASE_SYNCHAFTER, 1, &iDummy);

    iDummy = 0;
    // Do the DIDEVENT.  This cannot be cancelled or fail!
    FireRowPositionChange(eReason, DBEVENTPHASE_DIDEVENT, 1, &iDummy);

    // reset
    _fCleared = FALSE;

    return NOERROR;
}

//+---------------------------------------------------------------------------
//  Member:     GetRowPosition (public member)
//
//  Synopsis:   Gets our current position in the Rowset (as an hRow).
//              AddRefRows the hRow.  CALLER MUST ReleaseRows!!
//
//  Arguments:  hRow            current hRow position
//
//  Returns:    S_OK            if everything is fine,
//
STDMETHODIMP
CRowPosition::GetRowPosition(HCHAPTER *phChapter, HROW *phRow,
                             DBPOSITIONFLAGS *pdwPositionFlags)
{
    if (!_pRowset)
        return E_UNEXPECTED;

    if (phRow)
    {
        if (_hRow != DB_NULL_HROW)
        {
            _pRowset->AddRefRows(1, &_hRow, NULL, NULL);
        }

        *phRow = _hRow;
    }

    if (phChapter)
    {
        if (_hChapter != DB_NULL_HCHAPTER)
        {
            if (_pChapRowset)
            {
                _pChapRowset->AddRefChapter(_hChapter, NULL);
            }
        }

        *phChapter = _hChapter;
    }

    if (pdwPositionFlags)
    {
        *pdwPositionFlags = _dwPositionFlags;
    }

    return S_OK;
};

#ifdef ROWPOSITION_DELETE
//+---------------------------------------------------------------------------
//  Member: CreateBookMarkAccessor (private)
//
//  Synopsis:   Helper function to create the Bookmark Accessor
//  
//  Arguments:  none, uses member variables.
//
//  Returns:    S_OK            if everything is fine,
//
HRESULT
CRowPosition::CreateBookmarkAccessor()
{
    HRESULT       hr=E_FAIL;            // if we can't QI IAccessor!
    DBBINDING     dbind;

    Assert(_hAccessorBookmark==NULL);   // Already init'd??

    hr = _pRowset->QueryInterface(IID_IAccessor,
                                  (void **)&_pAccessor);
    if (_pAccessor)
    {
        dbind.iOrdinal = 0;         // columns 0 must mean Bookmark
        dbind.obValue = 0;          // offset to value
        dbind.obLength = 0;         // ignored, no DBPART_LENGTH
        dbind.obStatus = 0;         // ignored no DBPART_STATUS
        dbind.pTypeInfo = NULL;     // spec sez set to null
        dbind.pObject = NULL;       // ignored unless DBTYPE_IUNKNOWN
        dbind.pBindExt = NULL;      // spec sez set to null
        dbind.dwPart = DBPART_VALUE;
        dbind.dwMemOwner = DBMEMOWNER_CLIENTOWNED;
        dbind.eParamIO = DBPARAMIO_NOTPARAM;
        dbind.cbMaxLen = 0;         // not used for DBTYPE_VECTOR
        dbind.dwFlags = 0;          // spec sez set to 0
        dbind.wType = (DBTYPE_UI1 | DBTYPE_VECTOR);
        hr = _pAccessor->CreateAccessor(DBACCESSOR_ROWDATA,
                                        1, &dbind, 0,
                                        &_hAccessorBookmark,
                                        NULL /*rgStatus*/);
        if (FAILED(hr))
        {
            ClearInterface(&_pAccessor);
        }
    } // _pAccessor

    return hr;
}

//+-----------------------------------------------------------------------
//
//  Member:    ClearBookmark
//
//  Synopsis:  Helper function to de-allocate any bookmarks we might have,
//             because we need this in a few places.
//
//  Arguments: uses member variables.
//

void
CRowPosition::ClearBookmark()
{
    if (_Bookmark.ptr)
    {
        CoTaskMemFree(_Bookmark.ptr);
        _Bookmark.ptr = NULL;
    }
}

//+-----------------------------------------------------------------------
//
//  Member:   ReleaseBookmarkAccessor
//
//  Synopsis:  Helper function to destroy the bookmark accessor.
//
//  Arguments: uses member variables.
//

void
CRowPosition::ReleaseBookmarkAccessor()
{
    ULONG ulDontCare;

    ClearBookmark();
    if (_pAccessor && _hAccessorBookmark)
    {
        _pAccessor->ReleaseAccessor(_hAccessorBookmark, &ulDontCare);
        _hAccessorBookmark = NULL;
    }
    ClearInterface(&_pAccessor);
}
#endif

//+---------------------------------------------------------------------------
//  Member:     CRowPosition::FireRowPositionChange
//
//  Synopsis:   Helper routine to Fire change notices to all of our clients.
//
//  Arguments:  eReason [in]     reason for event
//              ePhase [in]      which notification phase this is
//              fCantDeny [in]   TRUE iff client can cancel this phase
//              piProgress [in]  send this event to the first iProgress sinks
//                        [out]  on output: decremented by the number of sinks,
//                               stop firing when count reaches 0.  We always
//                               fire at least one event however.
//
//  Returns:    S_OK             client accepts change
//              S_FALSE          client wants to cancel change
//              S_UNWANTEDPHASE  client doesn't want any more phase notifications
//                               (caller doesn't have to comply)
//              S_UNWANTEDREASON client doesn't want any more of this reason
//                               (caller doesn't have to comply)
//

HRESULT
CRowPosition::FireRowPositionChange(DBREASON eReason,
                                    DBEVENTPHASE ePhase,
                                    BOOL fCantDeny,
                                    int *piProgress)
{
    AAINDEX         aaidx;
    HRESULT         hr = S_OK;
    NOTIFY_STATE    ns;

    DWORD pdwCookie = 0;                // cookie for GetNextSink
    IRowPositionChange *pRPC=NULL;      // Notification we fire.

    aaidx = AA_IDX_UNKNOWN;

    ns = EnterNotify(eReason, DBEVENTPHASE_DIDEVENT);

    for (;;)
    {
        aaidx = FindNextAAIndex(DISPID_A_ROWPOSITIONCHANGESINK, 
                                CAttrValue::AA_Internal, 
                                aaidx);
        if (aaidx == AA_IDX_UNKNOWN)
            break;

        ClearInterface(&pRPC);
        if (OK(GetUnknownObjectAt(aaidx, (IUnknown **)&pRPC)))
        {
            hr = pRPC->OnRowPositionChange(eReason, ePhase, fCantDeny);

            // Have we fired all we're supposed to yet?
            if (--*piProgress==0) break;

            // Stop upon the first event that fails, or was cancelled.
            // We don't stop on (or propagate upward) DB_S_UNWANTEDPHASE
            // or DB_S_UNWANTED REASON.
            if (FAILED(hr) || (hr==S_FALSE && !fCantDeny))
            {
                // flip piProgress, so if we're called again with the same
                // iProgress, we fire only as many events as we did this time.
                // (Note iProgress actually represents # sinks fired+1).
                *piProgress = -*piProgress;
                goto Cleanup;
            }

        }
    }

    // If we fired events to all sinks without error or cancel.
    *piProgress = 0;

Cleanup:
    LeaveNotify(eReason, DBEVENTPHASE_DIDEVENT, ns);

    ReleaseInterface(pRPC);
    RRETURN(hr);
}

#ifdef ROWPOSITION_DELETE
//+---------------------------------------------------------------------------
//  Member:     MyRowsetNotify::OnChapterChange
//
//  Synopsis:   Implemenation of IRowsetNotify::OnRowChange
//              This doesn't do anything.
//

// We're not interested in OnFieldChange
STDMETHODIMP
CRowPosition::MyRowsetNotify::OnFieldChange (IRowset *pRowset,
                                             HROW hRow,
                                             ULONG cColumns,
                                             ULONG aColumns[],
                                             DBREASON eReason,
                                             DBEVENTPHASE ePhase,
                                             BOOL fCantDeny)
{
    return DB_S_UNWANTEDREASON;
}

//+---------------------------------------------------------------------------
//  Member:     MyRowsetNotify::OnRowChange
//
//  Synopsis:   Implemenation of IRowsetNotify::OnRowChange
//              Looks for ROw_DELETE notifications in case they affect the hRow
//              we're currently on, in which case we pass them along.
//
//  Arguments:  hRow            new hRow position
//
//  Returns:    S_OK                if everything is fine,
//
// We are interested in OnRowChange
STDMETHODIMP
CRowPosition::MyRowsetNotify::OnRowChange (IRowset *pRowset,
                                         ULONG cRows,
                                         const HROW ahRows[],
                                         DBREASON eReason,
                                         DBEVENTPHASE ePhase,
                                         BOOL fCantDeny)
{
    HRESULT thr, hr = S_OK;
    ULONG cRowsObt, i;
    HROW * phRow;
    int iDummy=0;
    // We need a pointer to our containing class..
    CRowPosition *pCRP = CONTAINING_RECORD(this, CRowPosition, _RowsetNotify);
    
    // We only care about the DELETE notification because,
    // only the Delete notification can change the current position.
    if (eReason!=DBREASON_ROW_DELETE)
    {    
        hr = DB_S_UNWANTEDREASON;
        goto Cleanup;
    }

    if (!pCRP->_pRPCSink)               // Do we have any sinks?
    {
        goto Cleanup;                   // No, pointless to continue.
    }

    // For each hRow in the ahRows array,
    for (i=0; i!=cRows; i++)
    {
        // ignore if it doesn't match our current row.
        if (ahRows[i] != pCRP->_hRow)
            continue;
            
        // Our "current row" is the one being deleted.
        // Propogate the notifications to our clients.
        thr = pCRP->FireRowPositionChange(eReason, ePhase, fCantDeny,
                                          &iDummy);

        // Vetos are allowed only when our source says so..
        if (!fCantDeny && thr==S_FALSE )
        {
            hr = S_FALSE; // our client veto'd this change

            // Won't need bookmark anymore (if we had one).
            // (Note if our source is behaving properly, it should send
            // us a FAILEDTODO event, which would also clear the bookmark,
            // but its probably more reliable to not depend on this).
            pCRP->ClearBookmark();
        }
        else
        {
            switch (ePhase)
            {
              case (DBEVENTPHASE_ABOUTTODO):
                // Get a bookmark for the current hRow.
                pCRP->ClearBookmark(); // kill any previous

                // Try to get a bookmark.  If we fail, the
                // DIDEVENT phase is robust, so ignore HR here.
                pCRP->_pRowset->GetData(pCRP->_hRow, pCRP->_hAccessorBookmark,
                                         &pCRP->_Bookmark);
                break;

              case(DBEVENTPHASE_DIDEVENT):
                phRow = &pCRP->_hRow;
                // Make sure to decrement refcount of old _hRow..
                if (*phRow!=NULL)
                {
                    pCRP->_pRowset->ReleaseRows(1, phRow, NULL, NULL, NULL);
                    *phRow = NULL; // Null it out now.
                }

                // Make sure we really have a bookmark.
                if (!pCRP->_Bookmark.ptr) break;

                if (!pCRP->_pRowsetLocate) break;

                thr = pCRP->_pRowsetLocate->GetRowsAt(NULL, NULL,
                                                      pCRP->_Bookmark.size,
                                                      (BYTE *)pCRP->_Bookmark.ptr,
                                                      0, // lRowsOffset 
                                                      1, // cRows [in]
                                                      &cRowsObt, // [out]
                                                      &phRow);

                if (thr==DB_S_ENDOFROWSET) // off the end?
                {
                    // Hmm, try it backwards this time.
                    pCRP->_pRowsetLocate->GetRowsAt(NULL, NULL, 
                                                    pCRP->_Bookmark.size,
                                                    (BYTE *)pCRP->_Bookmark.ptr,
                                                    0, // lRowsOffset 
                                                    -1,  // cRows [in]
                                                    &cRowsObt, //[out]
                                                    &phRow);
                } // DB_S_ENDOFROWSET

                pCRP->ClearBookmark(); // We're done with the bookmark
                break;

              case(DBEVENTPHASE_FAILEDTODO):
                // Something failed, make sure bookmark is cleared.
                  pCRP->ClearBookmark();
                  break;

            } // switch ePhase

        } // else for change veto'd

        break;                      // out of for loop..

    }                                   // for (ULONG i=0; i!=cRows; i++)

Cleanup:
    return hr;
}

//+---------------------------------------------------------------------------
//  Member:     MyRowsetNotify::OnRowsetChange
//
//  Synopsis:   Implementation of IRowsetNotify::OnRowsetChange
//              Currently, the only eReason is ROWSET_RELEASE.  We can never get
//              one of these because if we're still connected, the row position
//              can't go away.
//
//  Arguments:  hRow            new hRow position
//
//  Returns:    S_OK                if everything is fine,
//
STDMETHODIMP
CRowPosition::MyRowsetNotify::OnRowsetChange (IRowset *pRowset,
                                              DBREASON eReason,
                                              DBEVENTPHASE ePhase,
                                              BOOL fCantDeny)
{
    Assert(eReason!=DBREASON_ROWSET_RELEASE && "Impossible event");
    return DB_S_UNWANTEDREASON;

#ifdef never
    CRowPosition *pCRP = CONTAINING_RECORD(this, CRowPosition, _RowsetNotify);

    // The whole rowset is going away.
    // Propagate the notification to our clients.
    IGNORE_HR(pCRP->FireRowPositionChange(eReason, ePhase, fCantDeny));
    
    // Make sure to decrement refcount of our _hRow so rowset cleans up
    // nicely.
    if (pCRP->_hRow!=NULL)
    {
        IGNORE_HR(pCRP->_pRowset->ReleaseRows(1, &pCRP->_hRow,
                                              NULL, NULL, NULL));
        pCRP->_hRow = NULL;
    }
    return S_OK;
#endif    
}

//+------------------------------------------------------------------------
//
//  Member:     CreateRowPosition
//
//  Synopsis:   Creates a new RowPosition instance.
//
//  Arguments:  pUnkOuter   Outer unknown -- must be NULL
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------


#endif

#ifdef UNIX
CBase * STDMETHODCALLTYPE
CreateRowPosition(IUnknown * pUnkOuter)
{
    CBase * pBase;
    Assert(!pUnkOuter);
    pBase = new CRowPosition();
    return(pBase);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\display\advdisp.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:       advdisp.cxx
//
//  Contents:   Advanced display features
//
//  Classes:    CAdvancedDisplay
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ADVDISP_HXX_
#define X_ADVDISP_HXX_
#include "dispnode.hxx"
#endif


MtDefine(CAdvancedDisplay, DisplayTree, "CAdvancedDisplay");
MtDefine(CAryDispClientInfo_pv, DisplayTree, "CAryDispClientInfo_pv");
MtDefine(CAdvancedDisplayIndex_pv, DisplayTree, "CAdvancedDisplayIndex_pv");
MtDefine(CAdvancedDisplayDrawProgram_pv, DisplayTree, "CAdvancedDisplayDrawProgram_pv");


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::CAdvancedDisplay::CAdvancedDisplay
//
//  Synopsis:   Construct an advanced display object owned by the given
//              disp node.  It takes over the pointer to the disp client.
//
//  Arguments:  pDispNode       my owner
//              pDispClient     the disp client
//
//  Notes:
//
//----------------------------------------------------------------------------


CDispNode::CAdvancedDisplay::CAdvancedDisplay(CDispNode *pDispNode, CDispClient *pDispClient)
{
    _pDispNode = pDispNode;
    _pDispClient = pDispClient;
}



//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::CAdvancedDisplay::GetDrawProgram
//
//  Synopsis:   Construct a draw program for the disp node.
//
//  Arguments:  paryProgram     array for program
//              paryCookie      array for cookie arguments in the program
//
//  Notes:
//
//----------------------------------------------------------------------------

#define GrowArray(ary, size)   if (FAILED(ary.Grow(size))) return E_OUTOFMEMORY;

HRESULT
CDispNode::CAdvancedDisplay::GetDrawProgram(CAryDrawProgram *paryProgram,
                                            CAryDrawCookie *paryCookie,
                                            LONG lDrawLayers)
{
    int i;
    CAryDrawProgram& aryProgram = *paryProgram;
    CAryDrawCookie& aryCookie = *paryCookie;
    _aryDispClientInfo.DeleteAll();     // start from scratch
    const LONG lZOrder = _pDispNode->GetPainterInfo(&_aryDispClientInfo);

    if (_pDispNode->NeedAdvanced(&_aryDispClientInfo, lDrawLayers))
    {
        //
        // first sort the info list by the lZOrder field.
        //
        
        // Distribution Counting sort - it's stable (which we need)
        int count[HTMLPAINT_ZORDER_WINDOW_TOP + 1];
        memset(count, 0, sizeof(count));

        // count the occurrences of each zorder
        for (i=_aryDispClientInfo.Size()-1; i>=0; --i)
        {
            Assert(_aryDispClientInfo[i]._sInfo.lZOrder < ARRAY_SIZE(count));
            ++ count[_aryDispClientInfo[i]._sInfo.lZOrder];
        }

        // accumulate the counts in the desired order
        count[HTMLPAINT_ZORDER_REPLACE_ALL]         +=  count[HTMLPAINT_ZORDER_NONE];
        count[HTMLPAINT_ZORDER_REPLACE_BACKGROUND]  +=  count[HTMLPAINT_ZORDER_REPLACE_ALL];
        count[HTMLPAINT_ZORDER_REPLACE_CONTENT]     +=  count[HTMLPAINT_ZORDER_REPLACE_BACKGROUND];
        count[HTMLPAINT_ZORDER_BELOW_CONTENT]       +=  count[HTMLPAINT_ZORDER_REPLACE_CONTENT];
        count[HTMLPAINT_ZORDER_BELOW_FLOW]          +=  count[HTMLPAINT_ZORDER_BELOW_CONTENT];
        count[HTMLPAINT_ZORDER_ABOVE_FLOW]          +=  count[HTMLPAINT_ZORDER_BELOW_FLOW];
        count[HTMLPAINT_ZORDER_ABOVE_CONTENT]       +=  count[HTMLPAINT_ZORDER_ABOVE_FLOW];
        count[HTMLPAINT_ZORDER_WINDOW_TOP]          +=  count[HTMLPAINT_ZORDER_ABOVE_CONTENT];

        // create the mapping into the original array
        CStackDataAry<int, 8> aryIndex(Mt(CAdvancedDisplayIndex_pv));
        GrowArray(aryIndex, _aryDispClientInfo.Size());
        for (i=_aryDispClientInfo.Size()-1; i>=0; --i)
        {
            aryIndex[--count[_aryDispClientInfo[i]._sInfo.lZOrder]] = i;
        }

        //
        // now write the draw program
        //

        BOOL fReplaceAll = FALSE;
        BOOL fReplaceBackground = FALSE;
        BOOL fReplaceContent = FALSE;
        unsigned layerCurrent = DISPNODELAYER_BORDER;
        int iPC = DP_START_INDEX;
        int iCookie = 0;
        GrowArray(aryProgram, iPC);
        GrowArray(aryCookie, iCookie);

        for (i=0; i<=_aryDispClientInfo.Size(); ++i)
        {
            unsigned layerNext = DISPNODELAYER_POSITIVEZ;
            int iOp = DP_WindowTopMulti;
            long lZOrder = i==_aryDispClientInfo.Size() ? HTMLPAINT_ZORDER_WINDOW_TOP
                            : _aryDispClientInfo[aryIndex[i]]._sInfo.lZOrder;
            BOOL fExpand = i==_aryDispClientInfo.Size() ? FALSE :
                            (memcmp(&_aryDispClientInfo[aryIndex[i]]._sInfo.rcExpand,
                                    &g_Zero.rc, sizeof(RECT)));
    
            // the extra iteration with lZOrder==WINDOW_TOP ensures that we
            // draw all the content.  We'll remove the last WINDOW_TOP instruction
            // afterward.

            switch (lZOrder)
            {
            case HTMLPAINT_ZORDER_NONE:
                break;

            case HTMLPAINT_ZORDER_REPLACE_ALL:
                if (!fReplaceAll)
                {
                    fReplaceAll = TRUE;
                    fExpand = TRUE;     // this replaces the borders as well
                    if (lDrawLayers & FILTER_DRAW_CONTENT)
                    {
                        if (fExpand)
                        {
                            GrowArray(aryProgram, iPC+5);
                            aryProgram[iPC++] = DP_Expand;
                            aryProgram[iPC++] = _aryDispClientInfo[aryIndex[i]]._sInfo.rcExpand.top;
                            aryProgram[iPC++] = _aryDispClientInfo[aryIndex[i]]._sInfo.rcExpand.left;
                            aryProgram[iPC++] = _aryDispClientInfo[aryIndex[i]]._sInfo.rcExpand.bottom;
                            aryProgram[iPC++] = _aryDispClientInfo[aryIndex[i]]._sInfo.rcExpand.right;
                        }
                        GrowArray(aryProgram, iPC+1);
                        aryProgram[iPC++] = DP_DrawPainterMulti;
                        GrowArray(aryCookie, iCookie+1);
                        aryCookie[iCookie++] = _aryDispClientInfo[aryIndex[i]]._pvClientData;
                    }
                }
                break;

            case HTMLPAINT_ZORDER_REPLACE_BACKGROUND:
                if (!fReplaceAll && !fReplaceBackground)
                {
                    fReplaceBackground = TRUE;
                    if (lDrawLayers & FILTER_DRAW_BORDER)
                    {
                        GrowArray(aryProgram, iPC+1);
                        aryProgram[iPC++] = DP_DrawBorder;
                    }
                    GrowArray(aryProgram, iPC+1);
                    aryProgram[iPC++] = DP_BoxToContent;
                    if (lDrawLayers & FILTER_DRAW_BACKGROUND)
                    {
                        if (fExpand)
                        {
                            GrowArray(aryProgram, iPC+5);
                            aryProgram[iPC++] = DP_Expand;
                            aryProgram[iPC++] = _aryDispClientInfo[aryIndex[i]]._sInfo.rcExpand.top;
                            aryProgram[iPC++] = _aryDispClientInfo[aryIndex[i]]._sInfo.rcExpand.left;
                            aryProgram[iPC++] = _aryDispClientInfo[aryIndex[i]]._sInfo.rcExpand.bottom;
                            aryProgram[iPC++] = _aryDispClientInfo[aryIndex[i]]._sInfo.rcExpand.right;
                        }
                        GrowArray(aryProgram, iPC+1);
                        aryProgram[iPC++] = DP_DrawPainterMulti;
                        GrowArray(aryCookie, iCookie+1);
                        aryCookie[iCookie++] = _aryDispClientInfo[aryIndex[i]]._pvClientData;
                    }
                    layerCurrent = DISPNODELAYER_NEGATIVEINF;
                }
                break;

            case HTMLPAINT_ZORDER_REPLACE_CONTENT:
                if (!fReplaceAll && !fReplaceContent)
                {
                    fReplaceContent = TRUE;
                    if (!fReplaceBackground)
                    {
                        if (lDrawLayers & FILTER_DRAW_BORDER)
                        {
                            GrowArray(aryProgram, iPC+1);
                            aryProgram[iPC++] = DP_DrawBorder;
                        }
                        GrowArray(aryProgram, iPC+1);
                        aryProgram[iPC++] = (lDrawLayers & FILTER_DRAW_BACKGROUND)
                                        ? DP_DrawBackground : DP_BoxToContent;
                    }
                    if (lDrawLayers & FILTER_DRAW_CONTENT)
                    {
                        if (fExpand)
                        {
                            GrowArray(aryProgram, iPC+5);
                            aryProgram[iPC++] = DP_Expand;
                            aryProgram[iPC++] = _aryDispClientInfo[aryIndex[i]]._sInfo.rcExpand.top;
                            aryProgram[iPC++] = _aryDispClientInfo[aryIndex[i]]._sInfo.rcExpand.left;
                            aryProgram[iPC++] = _aryDispClientInfo[aryIndex[i]]._sInfo.rcExpand.bottom;
                            aryProgram[iPC++] = _aryDispClientInfo[aryIndex[i]]._sInfo.rcExpand.right;
                        }
                        GrowArray(aryProgram, iPC+1);
                        aryProgram[iPC++] = DP_DrawPainterMulti;
                        GrowArray(aryCookie, iCookie+1);
                        aryCookie[iCookie++] = _aryDispClientInfo[aryIndex[i]]._pvClientData;
                    }
                }
                break;

                        // the shifts of layerNext set it to the desired value!
            case HTMLPAINT_ZORDER_BELOW_CONTENT:    layerNext >>= 1;
            case HTMLPAINT_ZORDER_BELOW_FLOW:       layerNext >>= 1;
            case HTMLPAINT_ZORDER_ABOVE_FLOW:       layerNext >>= 1;
            case HTMLPAINT_ZORDER_ABOVE_CONTENT:    iOp = DP_DrawPainterMulti;
            case HTMLPAINT_ZORDER_WINDOW_TOP:
                if (!fReplaceAll && !fReplaceContent)
                {
                    if (layerCurrent == DISPNODELAYER_BORDER)
                    {
                        if (lDrawLayers & FILTER_DRAW_BORDER)
                        {
                            GrowArray(aryProgram, iPC+1);
                            aryProgram[iPC++] = DP_DrawBorder;
                        }
                        layerCurrent = DISPNODELAYER_BACKGROUND;
                    }
                    if (layerCurrent == DISPNODELAYER_BACKGROUND)
                    {
                        if (!fReplaceBackground)
                        {
                            GrowArray(aryProgram, iPC+1);
                            aryProgram[iPC++] = (lDrawLayers & FILTER_DRAW_BACKGROUND)
                                            ? DP_DrawBackground : DP_BoxToContent;
                        }
                        layerCurrent = DISPNODELAYER_NEGATIVEINF;
                    }
                    if (layerCurrent < layerNext)
                    {
                        if (lDrawLayers & FILTER_DRAW_CONTENT)
                        {
                            GrowArray(aryProgram, iPC+2);
                            aryProgram[iPC++] = DP_DrawContent;
                            aryProgram[iPC++] = layerNext;
                        }
                        layerCurrent = layerNext;
                    }
                }
                if (i < _aryDispClientInfo.Size() &&
                    (lDrawLayers & FILTER_DRAW_CONTENT) &&
                    (iOp == DP_WindowTopMulti || (!fReplaceAll && !fReplaceContent)) )
                {
                    if (fExpand)
                    {
                        GrowArray(aryProgram, iPC+5);
                        aryProgram[iPC++] = DP_Expand;
                        aryProgram[iPC++] = _aryDispClientInfo[aryIndex[i]]._sInfo.rcExpand.top;
                        aryProgram[iPC++] = _aryDispClientInfo[aryIndex[i]]._sInfo.rcExpand.left;
                        aryProgram[iPC++] = _aryDispClientInfo[aryIndex[i]]._sInfo.rcExpand.bottom;
                        aryProgram[iPC++] = _aryDispClientInfo[aryIndex[i]]._sInfo.rcExpand.right;
                    }
                    GrowArray(aryProgram, iPC+1);
                    aryProgram[iPC++] = iOp;
                    GrowArray(aryCookie, iCookie+1);
                    aryCookie[iCookie++] = _aryDispClientInfo[aryIndex[i]]._pvClientData;
                }
                break;
            }
        }

        // mark the end of the program
        GrowArray(aryProgram, iPC+1);
        aryProgram[iPC++] = DP_Done;
    }
    else if (_aryDispClientInfo.Size() <= 1)
    {
        Assert(s_rgDrawPrograms[lZOrder][DP_START_INDEX-1] == lZOrder);
        GrowArray(aryProgram, DP_MAX_LENGTH);
        aryProgram.CopyIndirect(DP_MAX_LENGTH, (int *) s_rgDrawPrograms[lZOrder], FALSE);
    }
    else
    {
        return S_FALSE;
    }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::CAdvancedDisplay::MapBounds
//
//  Synopsis:   Apply the mapping specified by the filter behavior (if any)
//
//  Arguments:  prcpBounds      rect to map (in parent coords)
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispNode::CAdvancedDisplay::MapBounds(CRect *prcpBounds) const
{
    Assert(prcpBounds);
    // Assert prcpBounds is in parent coords

    if (!_rcpBoundsMapped.IsEmpty())
    {
        CSize sizeOffset = prcpBounds->TopLeft().AsSize();
        *prcpBounds = _rcpBoundsMapped;
        prcpBounds->OffsetRect(sizeOffset);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::CAdvancedDisplay::MoveOverlays
//
//  Synopsis:   Notify any overlay clients that they have moved
//
//  Arguments:  none
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispNode::CAdvancedDisplay::MoveOverlays()
{
    if (_fHasOverlay)
    {
        // compute the new rect (global coordinates)
        CRect rcgBounds;
        CRect rcpBounds = _pDispNode->GetBounds();

        _pDispNode->GetMappedBounds(&rcpBounds);
        _pDispNode->TransformAndClipRect(rcpBounds, COORDSYS_PARENT, &rcgBounds, COORDSYS_GLOBAL);

        // tell the peers
        _pDispClient->MoveOverlayPeers(_pDispNode, &rcgBounds, &_rcScreen);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\dbind\provider.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1996-1997
//  All rights Reserved.
//  Information contained herein is Proprietary and Confidential.
//
//  Contents:   Data Source Provider objects
//
//  Classes:    CDataSourceProvider (abstract)
//                  CAdaptingProvider
//                      CRowsetProvider
//                      CSTDProvider
//                      CCursorProvider
//                  CNullProvider
//              CDataSetEvents (used by provider classes)
//
//  History:    10/1/96     (sambent) created

// The concrete classes derived from CDataSourceProvider are
// declared in this file, which makes them unknown to the rest of the world.
// The function CDataSourceProvider::Create acts as a
// factory -- creating the appropriate concrete provider.
// 
// To support a new type of provider, derive a new class from CDataSourceProvider,
// and add code to CDataSourceProvider::Create to create an instance.

// The CDataSourceProvider class (and classes derived from it), are
// designed to be owned by a CObjectElement associated with a data-source
// control.  This allows the Trident object model to expose an ADO
// interface on suitable controls -- the OM request for ADO translates into
// a QDI (QueryDataInterface) on the element's provider object.
// A CDataSourceBinder object also holds a reference to a provider, usually (but
// not always) one that it shares with a control site.
// 
// Some words about refcounting.  The provider object owns (and refcounts)
// references into the control.  The owning element also owns references
// into the control, as well as a reference to the provider.  When the
// owning element is through with its control, its Detach method releases
// the provider, which in turn releases its own references to the control.
// Releasing in Detach solves any circular reference problems.
// 
// When a provider is shared by a control site and a binder, it doesn't die
// until both references go away.  This keeps the control alive even after
// its site has died as long as it's still in use for databinding.
// 
// Providers also snap in adapters between a control's native interface and
// the interface desired by a data-bound element (or the object model).  A
// provider remembers adapted interfaces it has handed out, so that it can
// hand out the same interface if asked again.  Thus, several
// ICursor-consuming elements can be bound to single STD control, and the
// provider arranges that they all share the same ICursor it has created by
// interposing the Viaduct II (cursor-to-rowset) and Nile2Std
// (rowset-to-STD) adapters.

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include <formkrnl.hxx>     // for safetylevel in safety.hxx (via olesite.hxx)
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include <olesite.hxx>
#endif

#ifndef X_ROWSET_HXX_
#define X_ROWSET_HXX_
#include <rowset.hxx>
#endif

#ifndef X_FORMSARY_HXX_
#define X_FORMSARY_HXX_
#include <formsary.hxx>
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include <evntprm.hxx>
#endif

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include "binder.hxx"
#endif

#ifndef X_DBTASK_HXX_
#define X_DBTASK_HXX_
#include "dbtask.hxx"
#endif

#ifndef X_DBINDING_HXX_
#define X_DBINDING_HXX_
#include "dbinding.hxx"
#endif

#ifndef X_DMEMBMGR_HXX_
#define X_DMEMBMGR_HXX_
#include "dmembmgr.hxx"       // for CDataMemberMgr
#endif

#ifndef X_SIMPDC_H_
#define X_SIMPDC_H_
#include "simpdc.h"
#endif

#ifndef X_BMKCOLL_HXX_
#define X_BMKCOLL_HXX_
#include "bmkcoll.hxx"
#endif

#ifndef X_ADO_ADOID_H_
#define X_ADO_ADOID_H_
#include <adoid.h>
#endif

#ifndef X_ADO_ADOINT_H_
#define X_ADO_ADOINT_H_
#include <adoint.h>
#endif

#ifndef X_ADO_ADOSECUR_H_
#define X_ADO_ADOSECUR_H_
#include <adosecur.h>
#endif

#define VD_INCLUDE_ROWPOSITION 

#ifndef X_VBCURSOR_OCDB_H_
#define X_VBCURSOR_OCDB_H_
#include <vbcursor/ocdb.h>
#endif

#ifndef X_VBCURSOR_OCDBID_H_
#define X_VBCURSOR_OCDBID_H_
#include <vbcursor/ocdbid.h>
#endif

#ifndef X_VBCURSOR_VBDSC_H_
#define X_VBCURSOR_VBDSC_H_
#include <vbcursor/vbdsc.h>
#endif

#ifndef X_VBCURSOR_OLEBIND_H_
#define X_VBCURSOR_OLEBIND_H_
#include <vbcursor/olebind.h>
#endif

#ifndef X_VBCURSOR_MSC2R_H_
#define X_VBCURSOR_MSC2R_H_
#include <vbcursor/msc2r.h>                      // viaduct-i  ole include
#endif

#ifndef X_VBCURSOR_MSR2C_H_
#define X_VBCURSOR_MSR2C_H_
#include <vbcursor/msr2c.h>                      // viaduct-ii ole include
#endif

#ifndef X_OBJSAFE_H_
#define X_OBJSAFE_H_
#include "objsafe.h"
#endif

typedef Recordset15 IADORecordset;    // beats me why ADO doesn't use I...
typedef ADORecordsetConstruction IADORecordsetConstruction;

#ifdef UNIX
#include "unixposition.hxx"
#else
   EXTERN_C const CLSID CLSID_CRowPosition;
#endif

class CAdaptingProvider;

DeclareTag(tagRowEvents, "RowEvents", "Show row events");
MtDefine(CDataSetEvents, DataBind, "CDataSetEvents")
MtDefine(CADOClientSite, DataBind, "CADOClientSite")
MtDefine(CNullProvider, DataBind, "CNullProvider")
MtDefine(CAdaptingProvider, DataBind, "CAdaptingProvider")
MtDefine(CAdaptingProvider_aryCR_pv, CAdaptingProvider, "CAdaptingProvider::_aryCR::_pv")
MtDefine(CAdaptingProvider_aryPR_pv, CAdaptingProvider, "CAdaptingProvider::_aryPR::_pv")
MtDefine(CAdaptingProvider_aryAR_pv, CAdaptingProvider, "CAdaptingProvider::_aryAR::_pv")
MtDefine(CAdaptingProvider_aryXT_pv, CAdaptingProvider, "CAdaptingProvider::_aryXT::_pv");


/////////////////////////////////////////////////////////////////////////////
/////                       Helper functions                            /////
/////////////////////////////////////////////////////////////////////////////

void
ReleaseChapterAndRow(HCHAPTER hchapter, HROW hrow, IRowPosition *pRowPos)
{
    IRowset *pRowset = NULL;
    IChapteredRowset *pChapRowset = NULL;
    
    if (pRowPos && (hrow != DB_NULL_HROW || hchapter != DB_NULL_HCHAPTER))
    {
        pRowPos->GetRowset(IID_IRowset, (IUnknown **)&pRowset);
        AssertSz(pRowset, "Can't get rowset from rowpos");

        // release the hrow
        if (hrow != DB_NULL_HROW)
        {
            pRowset->ReleaseRows(1, &hrow, NULL, NULL, NULL);
        }

        // release the hchapter
        if (hchapter != DB_NULL_HCHAPTER)
        {
            pRowset->QueryInterface(IID_IChapteredRowset, (void**)&pChapRowset);
            if (pChapRowset)
            {
                pChapRowset->ReleaseChapter(hchapter, NULL);
                ReleaseInterface(pChapRowset);
            }
        }

        ReleaseInterface(pRowset);
    }
}


/////-------------------------------------------------------------------/////
///// CADOClientSite.  Client site given to ADO.  We only implement the /////
///// methods ADO actually uses, and delegate the real work to the Doc. /////
/////-------------------------------------------------------------------/////
class CADOClientSite: public IOleClientSite, public IServiceProvider
{
public:
    // creation/destruction
    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CADOClientSite))
    CADOClientSite(CDoc *pDoc);
    ~CADOClientSite();

    // IOleClientSite methods
    HRESULT STDMETHODCALLTYPE SaveObject();
    HRESULT STDMETHODCALLTYPE GetMoniker(DWORD dwAssign,
            DWORD dwWhichMoniker,
            LPMONIKER FAR* ppmk);
    HRESULT STDMETHODCALLTYPE GetContainer(LPOLECONTAINER FAR* ppContainer);
    HRESULT STDMETHODCALLTYPE ShowObject();
    HRESULT STDMETHODCALLTYPE OnShowWindow(BOOL fShow);
    HRESULT STDMETHODCALLTYPE RequestNewObjectLayout();
    
    //  IServiceProvider methods
    HRESULT STDMETHODCALLTYPE QueryService(REFGUID guidService, REFIID iid, void ** ppv);

    // IUnknown methods
    STDMETHODIMP_(ULONG)    AddRef() { return ++_ulRefs; }
    STDMETHODIMP_(ULONG)    Release();
    STDMETHODIMP            QueryInterface(REFIID riid, void **ppv);

    // public methods

private:
    ULONG               _ulRefs;        // reference count
    CDoc *              _pDoc;          // my Doc

    // private methods
    CDoc *              Doc() { return _pDoc; }
};

//+-------------------------------------------------------------------------
// Member:      constructor (CADOClientSite, public)
//
// Synopsis:    

CADOClientSite::CADOClientSite(CDoc *pDoc) : _ulRefs(1)
{
    Assert(pDoc);

    _pDoc = pDoc;
    if (_pDoc)
        _pDoc->SubAddRef();
}

//+-------------------------------------------------------------------------
// Member:      destructor (CADOClientSite, public)
//
// Synopsis:    

CADOClientSite::~CADOClientSite()
{
    if (_pDoc)
        _pDoc->SubRelease();
}

//+-------------------------------------------------------------------------
// Member:      Release (public, IUnknown)
//
// Synopsis:    decrease refcount, die if 0
//
// Returns:     new refcount

ULONG
CADOClientSite::Release()
{
    ULONG ulRefs = --_ulRefs;
    if (ulRefs == 0)
        delete this;
    return ulRefs;
}


//+-------------------------------------------------------------------------
// Member:      Query Interface (public, IUnknown)
//
// Synopsis:    return desired interface pointer
//
// Arguments:   riid        IID of desired interface
//              ppv         where to store the pointer
//
// Returns:     HRESULT

HRESULT
CADOClientSite::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr;
    IUnknown *punkReturn = 0;

    // check for bad arguments
    if (!ppv)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // look for interfaces I support
    if (IsEqualIID(riid, IID_IUnknown))
    {
        punkReturn = (IOleClientSite *)this;
    }
    else if (IsEqualIID(riid, IID_IOleClientSite))
    {
        punkReturn = (IOleClientSite *)this;
    }
    else if (IsEqualIID(riid, IID_IServiceProvider))
    {
        punkReturn = (IServiceProvider *)this;
    }
    else
    {
        hr = E_NOINTERFACE;
        goto Cleanup;
    }
    punkReturn->AddRef();          // return addref'd copy
    *ppv = punkReturn;
    hr = S_OK;

Cleanup:
    return hr;        
}


/////////////      IOleClientSite methods     ////////////////////////////
// We only need these so we can give ADO a client site (so it can determine
// its security behavior).  But ADO only calls GetContainer, to get to the
// Doc, and QI(ServiceProvider).

STDMETHODIMP
CADOClientSite::SaveObject()
{ return E_NOTIMPL; }

STDMETHODIMP
CADOClientSite::GetMoniker(DWORD dwAssign,
        DWORD dwWhichMoniker,
        LPMONIKER FAR* ppmk)
{ return E_NOTIMPL; }

STDMETHODIMP
CADOClientSite::GetContainer(LPOLECONTAINER FAR* ppContainer)
{
    HRESULT hr;
    hr = Doc() ? THR(Doc()->QueryInterface(IID_IOleContainer, (void **)ppContainer)) : E_FAIL;
    RRETURN(hr);
}

STDMETHODIMP
CADOClientSite::ShowObject()
{ return E_NOTIMPL; }

STDMETHODIMP
CADOClientSite::OnShowWindow(BOOL fShow)
{ return E_NOTIMPL; }

STDMETHODIMP
CADOClientSite::RequestNewObjectLayout()
{ return E_NOTIMPL; }


/////////////      IServiceProvider methods     ////////////////////////////
// We delegate all requests (from ADO) right to the Doc

STDMETHODIMP
CADOClientSite::QueryService(REFGUID guidService, REFIID iid, void ** ppv)
{
    RRETURN(Doc() ? Doc()->QueryService(guidService, iid, ppv) : E_FAIL);
}


/////-------------------------------------------------------------------/////
///// CDataSetEvents.  Listens for rowset notifications on behalf of    /////
///// provider, and fires data events                                   /////
/////-------------------------------------------------------------------/////

class CDataSetEvents: public IRowPositionChange, public IDBAsynchNotify,
                      public IRowsetNotify
{
    friend class CAdaptingProvider;
public:
    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CDataSetEvents))
    // creation/destruction
    CDataSetEvents(): _ulRefs(1) {}
    ~CDataSetEvents();
    HRESULT Init(CDataMemberMgr *pDMembMgr, IRowset *pRowset, IRowPosition *pRowPos,
                    CAdaptingProvider *pProvider);
    HRESULT Detach();

    // watch out for callback on wrong thread
    HRESULT CheckCallbackThread();
    
    // IRowPositionChanged methods
    STDMETHODIMP OnRowPositionChange(DBREASON eReason, DBEVENTPHASE ePhase,
                                BOOL fCantDeny);

    //  IDBAsynchNotify methods
    virtual HRESULT STDMETHODCALLTYPE OnLowResource( 
            /* [in] */ DB_DWRESERVE dwReserved);
        
    virtual HRESULT STDMETHODCALLTYPE OnProgress( 
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ DBASYNCHOP ulOperation,
            /* [in] */ DBCOUNTITEM ulProgress,
            /* [in] */ DBCOUNTITEM ulProgressMax,
            /* [in] */ DBASYNCHPHASE ulStatusCode,
            /* [in] */ LPOLESTR pwszStatusText);
        
    virtual HRESULT STDMETHODCALLTYPE OnStop( 
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ DBASYNCHOP ulOperation,
            /* [in] */ HRESULT hrStatus,
            /* [in] */ LPOLESTR pwszStatusText);

    // IRowsetNotify methods
    virtual HRESULT STDMETHODCALLTYPE OnFieldChange( 
        /* [in] */ IRowset *pRowset,
        /* [in] */ HROW hRow,
        /* [in] */ DBORDINAL cColumns,
        /* [size_is][in] */ DBORDINAL rgColumns[  ],
        /* [in] */ DBREASON eReason,
        /* [in] */ DBEVENTPHASE ePhase,
        /* [in] */ BOOL fCantDeny);
    
    virtual HRESULT STDMETHODCALLTYPE OnRowChange( 
        /* [in] */ IRowset *pRowset,
        /* [in] */ DBCOUNTITEM cRows,
        /* [size_is][in] */ const HROW rghRows[  ],
        /* [in] */ DBREASON eReason,
        /* [in] */ DBEVENTPHASE ePhase,
        /* [in] */ BOOL fCantDeny);
    
    virtual HRESULT STDMETHODCALLTYPE OnRowsetChange( 
        /* [in] */ IRowset *pRowset,
        /* [in] */ DBREASON eReason,
        /* [in] */ DBEVENTPHASE ePhase,
        /* [in] */ BOOL fCantDeny);

    // IUnknown methods
    STDMETHODIMP_(ULONG)    AddRef() { return ++_ulRefs; }
    STDMETHODIMP_(ULONG)    Release();
    STDMETHODIMP            QueryInterface(REFIID riid, void **ppv);

    // accessors
    CDataMemberMgr *  GetDataMemberManager() const { return _pDMembMgr; }
    CElement *      GetOwner() { Assert(_pDMembMgr); return _pDMembMgr->GetOwner(); }
    CDoc *          Doc();
    
private:
    HRESULT Fire_ondatasetcomplete(long lReason);
    ULONG           _ulRefs;            // reference count
    CDataMemberMgr  *_pDMembMgr;        // my data manager.  Fire events on its owner.
    IRowset         *_pRowset;          // the Rowset I'm listening to
    IRowPosition    *_pRowPos;          // the RowPosition I'm listening to
    IConnectionPoint *_pCPRowPos;       // Connection point for listening on RowPos
    IConnectionPoint *_pCPDBAsynch;       // Connection point for listening on Rowset
    IConnectionPoint *_pCPRowset;       // Connection point for listening on Rowset
    DWORD           _dwAdviseCookieRowPos; // saved from Advise, so I can Unadvise
    DWORD           _dwAdviseCookieDBAsynch; // saved from Advise, so I can Unadvise
    DWORD           _dwAdviseCookieRowset; // saved from Advise, so I can Unadvise
    CAdaptingProvider *_pProvider;      // the provider who owns me
    const HROW      *_rghRows;          // HROWs affected by change
    DBCOUNTITEM     _cRows;             // number of HROWs affected by change
    DBORDINAL      *_rgColumns;        // columns affected by change
    DBORDINAL       _cColumns;          // number of columns affected by change
    unsigned        _fCompleteFired:1;  // iff ondatasetcomplete already fired

    void SetEventData(const HROW *rghRows, DBCOUNTITEM cRows,
                      DBORDINAL *rgColumns, DBORDINAL cColumns)
    {
        _rghRows = rghRows;
        _cRows = cRows;
        _rgColumns = rgColumns;
        _cColumns = cColumns;
    }
    void SetEventData(const HROW *rghRows, DBCOUNTITEM cRows)
    {
        _rghRows = rghRows;
        _cRows = cRows;
    }
    void ClearEventData()
    {
        _rghRows = NULL;
        _cRows = 0;
        _rgColumns = NULL;
        _cColumns = 0;
    }
};


/////-------------------------------------------------------------------/////
/////                        Adapting provider                          /////
///// This abstract class is the base class for many of the concrete    /////
///// providers defined below.  It provides common behavior (code       /////
///// sharing), principally the management of interface adapters.       /////
/////-------------------------------------------------------------------/////

class CAdaptingProvider: public CDataSourceProvider
{
    typedef CDataSourceProvider super;
    friend class CDataSetEvents;
public:
    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CAdaptingProvider))
    CAdaptingProvider() :
        _aryCR(Mt(CAdaptingProvider_aryCR_pv)),
        _aryPR(Mt(CAdaptingProvider_aryPR_pv)),
        _aryAR(Mt(CAdaptingProvider_aryAR_pv)),
        _aryXT(Mt(CAdaptingProvider_aryXT_pv))
        {}
    virtual ~CAdaptingProvider() { ReleaseAll(); }
    virtual void    Detach();
    virtual HRESULT QueryDataInterface(REFIID riid, void **ppv);
    virtual HRESULT ReplaceProvider(CDataSourceProvider *pdspNewProvider);
    virtual HRESULT Stop();
    virtual CXferThunk* GetXT(LPCTSTR strColumn, CVarType vtDest);

    // hierarchy
    virtual HRESULT GetSubProvider(CDataSourceProvider **ppdsp,
                        LPCTSTR bstrName, HROW hrow=0);
    virtual HCHAPTER GetChapter() { return _hChapter; }
    BOOL    IsTopLevel() const { return (_pProviderParent == NULL); }
    HRESULT ChangeChapter(HCHAPTER hChapterNew, HROW hRowNew);

    // events
    virtual HRESULT FireDataEvent(const PROPERTYDESC_BASIC *pDesc,
                            BOOL *pfCancelable = NULL,
                            long lReason = 0);
    virtual HRESULT FireDelayedRowEnter();
    virtual HRESULT get_bookmarks(IHTMLBookmarkCollection* *);
    virtual HRESULT get_recordset(IDispatch* *);
    virtual HRESULT get_dataFld(BSTR *);
    
    // helpers for plugging in interface adapters
    HRESULT AdaptRowsetOnRowPosition(IRowset** ppRowset, IRowPosition *pRowPos);
    HRESULT AdaptRowsetOnSTD(IRowset** ppRowset, OLEDBSimpleProvider *pSTD);
    HRESULT AdaptCursorOnRowset(ICursor** ppCursor, IRowset *pRowset);
    HRESULT AdaptCursorOnRowPosition(ICursor** ppCursor, IRowPosition *pRowPos);
    HRESULT AdaptRowPositionOnRowset(IRowPosition** ppRowPos, IRowset *pRowset);
    HRESULT AdaptADOOnRowset(IADORecordset** ppADO, IRowset *pRowset);
    HRESULT AdaptADOOnRowPos(IADORecordset** ppADO, IRowPosition *pRowPos);
    HRESULT AdaptRowsetOnCursor(IRowset** ppRowset, ICursor *pCursor);

    // initialization
    HRESULT Init(CDataMemberMgr *pdmm, HCHAPTER hChapter=DB_NULL_HCHAPTER,
                 CAdaptingProvider *pProviderParent=NULL)
    {
        HRESULT hr;

        _pDoc = pdmm->Doc();
        _pMarkup = pdmm->GetOwner()->GetMarkup();
        _hChapter = hChapter;
        _pProviderParent = pProviderParent;

        // if I'm tied to a chapter, addref it
        if (_hChapter != DB_NULL_HCHAPTER && EnsureRowset())
        {
            IChapteredRowset *pChapRowset = NULL;

            if (S_OK == _pRowset->QueryInterface(IID_IChapteredRowset,
                        reinterpret_cast<void**>(&pChapRowset)))
            {
                IGNORE_HR(pChapRowset->AddRefChapter(_hChapter, NULL));
            }

            ReleaseInterface(pChapRowset);
        }

        // We're about to do things that fire events.  The event handlers
        // might run script that destroys the provider (e.g. ondatasetcomplete
        // handler resets the DSO's URL or query as in bug 57231).  So
        // stabilize to avoid dying during this kind of reentrancy.

        AddRef();
        
        // The order of the next three lines is critical.  We must ensure
        // the CRI before hooking up notifications, because SetRowChangedEventTarget
        // can (and often does) fire ondatasetchanged and ondatasetcomplete.
        // If the handlers for these events touch the rowset and cause
        // IRowsetNotify notificaitons, we need the DLCursor in place, and it's
        // owned by the CRI.  (See bug 59405.)
        //
        // However, we also need to hook up notifications before setting the
        // initial position of the CRI.  This is because setting CRI position
        // causes onrowenter to fire, and it's the CDataSetEvents that does
        // the firing.  (See bug 58708.)
        
        // always hook up CRI, so that we get the "adjust current record after
        // it's deleted" effect, even if there are no current-record-bound elements.
        EnsureCRI();

        // listen for notifications
        hr = SetRowChangedEventTarget(pdmm);

        // set the CRI to its initial position
        if (_pCRI)
            _pMarkup->GetDataBindTask()->InitCurrentRecord(_pCRI);

        Release();
        return hr;
    }

    // create from IRowPosition
    CAdaptingProvider(IRowPosition *pRowPos, HROW hrow): _pRowPos(pRowPos),
        _aryCR(Mt(CAdaptingProvider_aryCR_pv)),
        _aryPR(Mt(CAdaptingProvider_aryPR_pv)),
        _aryAR(Mt(CAdaptingProvider_aryAR_pv)),
        _aryXT(Mt(CAdaptingProvider_aryXT_pv))
    {
        _pRowPos->AddRef();
        _fNeedRowEnter =  (hrow != DB_NULL_HROW);
    }

    // create from IRowset
    CAdaptingProvider(IRowset *pRowset): _pRowset(pRowset),
        _aryCR(Mt(CAdaptingProvider_aryCR_pv)),
        _aryPR(Mt(CAdaptingProvider_aryPR_pv)),
        _aryAR(Mt(CAdaptingProvider_aryAR_pv)),
        _aryXT(Mt(CAdaptingProvider_aryXT_pv))
    {
        _pRowset->AddRef();
    }

    // create from ISimpleTabularData
    CAdaptingProvider(OLEDBSimpleProvider *pSTD): _pSTD(pSTD),
        _aryCR(Mt(CAdaptingProvider_aryCR_pv)),
        _aryPR(Mt(CAdaptingProvider_aryPR_pv)),
        _aryAR(Mt(CAdaptingProvider_aryAR_pv)),
        _aryXT(Mt(CAdaptingProvider_aryXT_pv))
    {
        _pSTD->AddRef();
    }

    // create from IVDBDC (ICursor generator)
    CAdaptingProvider(IVBDSC *pVBDSC) :
        _aryCR(Mt(CAdaptingProvider_aryCR_pv)),
        _aryPR(Mt(CAdaptingProvider_aryPR_pv)),
        _aryAR(Mt(CAdaptingProvider_aryAR_pv)),
        _aryXT(Mt(CAdaptingProvider_aryXT_pv))
    {
        IGNORE_HR(pVBDSC->CreateCursor(&_pCursor));
    }

protected:
    CDataSetEvents      *_pRowEvents; // sink for RowChanged events
    OLEDBSimpleProvider *_pSTD;     // ISTD interface
    IRowset             *_pRowset;  // IRowset interface
    IRowPosition        *_pRowPos;  // IRowPosition interface
    ICursor             *_pCursor;  // ICursor interface
    IADORecordset       *_pADO;     // ADO interface
    CCurrentRecordInstance  *_pCRI; // Current record interface
    CAdaptingProvider   *_pProviderParent;  // my parent provider (hierarchy)
    ISimpleDataConverter *_pSDC;    // DSO's simple data converter (if any)

    struct CXTRecord {          // map <field, type> to <XT>
        BSTR                bstrField;
        CVarType            vtDest;
        CXferThunk *        pXT;
    };

    // support for hierarchical rowsets
    struct CChapterRecord {     // map <hrow, field> to <chapter>
        HROW                hrow;
        BSTR                bstrField;
        HCHAPTER            hChapter;
    };
    
    struct CProviderRecord {    // map <field, chapter> to <provider>
        BSTR                bstrField;
        HCHAPTER            hChapter;
        CDataSourceProvider *pdsp;
    };

    struct CAccessorRecord {    // map <field> to <accessor, rowset>
        BSTR        bstrField;
        HACCESSOR   hAccessor;
        IRowset *   pRowset;
        DBORDINAL   ulOrdinal;  // internal use only
    };

    CDataAry<CXTRecord>         _aryXT;
    CDataAry<CChapterRecord>    _aryCR;
    CDataAry<CProviderRecord>   _aryPR;
    CDataAry<CAccessorRecord>   _aryAR;
    HCHAPTER                    _hChapter;  // restrict to this chapter
    
    unsigned        _fNeedRowEnter:1;   // iff we need to fire onrowenter
    unsigned        _fRowEnterOK:1;     // iff we can fire onrowenter now

    // hierarchy methods
    HRESULT GetChapterFromField(HROW hrow, BSTR bstrField, HCHAPTER *phChapter);
    HRESULT GetProviderFromField(BSTR bstrField, HROW hrow,
                                CDataSourceProvider **ppdsp);
    HRESULT GetAccessorAndRowsetForField(BSTR bstrField,
                                HACCESSOR *phAccessor, IRowset **ppRowset);
    HRESULT GetAccessorForField(BSTR bstrField, HACCESSOR *phAccessor)
            { return GetAccessorAndRowsetForField(bstrField, phAccessor, NULL); }
    HRESULT GetRowsetForField(BSTR bstrField, IRowset **ppRowset)
            { return GetAccessorAndRowsetForField(bstrField, NULL, ppRowset); }
    HRESULT InitializeProviderRecord(CProviderRecord *pPR,
                        HCHAPTER hChapter, BSTR bstrField);
    HRESULT InitializeAccessorRecord(CAccessorRecord *pAR, BSTR bstrField);
    BOOL    EnsureAccessorInAccessorRecord(CAccessorRecord *pAR);
    BOOL    EnsureRowsetInAccessorRecord(CAccessorRecord *pAR);
    static HRESULT CreateSubProvider(CAdaptingProvider *pProviderParent,
                                    IRowset *pChildRowset, IRowPosition *pChildRowPos,
                                    CDataMemberMgr *pdmm,
                                    HCHAPTER hChapter, HROW hrow,
                                    CDataSourceProvider **ppdsp);
    void    RemoveSubProvider(CDataSourceProvider *pdsp);
    HRESULT UpdateProviderRecords(HCHAPTER hChapterOld, CDataSourceProvider *pdspOld,
                                HCHAPTER hChapterNew, CDataSourceProvider *pdspNew);
    
    // helper methods
    HRESULT SetRowChangedEventTarget(CDataMemberMgr *pdmm);
    void    ReleaseAll();
    CDataLayerCursor * GetDLCursor() { return _pCRI ? _pCRI->GetDLCursor() : NULL; }
    BOOL    IsSameRow(HROW hrow1, HROW hrow2)
                { return GetDLCursor()->IsSameRow(hrow1, hrow2); }
private:
    // helper methods to generate adapters, if necessary
    BOOL    EnsureSTD();
    BOOL    EnsureRowset();
    BOOL    EnsureRowsetPosition();
    BOOL    EnsureCursor();
    BOOL    EnsureADO();
    BOOL    EnsureCRI();
};


inline CDoc *
CDataSetEvents::Doc()  { Assert(_pDMembMgr); return _pDMembMgr->Doc(); }

//+-------------------------------------------------------------------------
// Member:      Init (CDataSetEvents, public)
//
// Synopsis:    listen to the given IRowPosition, and remember the OleSite

HRESULT
CDataSetEvents::Init(CDataMemberMgr *pdmm, IRowset *pRowset, IRowPosition *pRowPos,
                    CAdaptingProvider *pProvider)
{
    Assert(pdmm && pProvider);

    HRESULT hr = S_OK, hrFire = S_OK;
    IConnectionPointContainer *pCPC = 0;
    
    _pProvider = pProvider;

    // We can be called with a NULL pRowPos, but not with a NULL pRowset.
    Assert(pRowset);

    // hold on to the RowSet (let go in Detach)
    _pRowset = pRowset;
    _pRowset->AddRef();

    // hold on to the data member manager
    _pDMembMgr = pdmm;
    _pDMembMgr->AddRef();

    // sink notifications from the RowPosition, if we have one
    if (pRowPos)
    {
        // hold on to the RowPosition (let go in Detach)
        _pRowPos = pRowPos;
        _pRowPos->AddRef();

        if (S_OK == _pRowPos->QueryInterface(IID_IConnectionPointContainer,
                                           (void **)&pCPC )
           &&
           S_OK == pCPC->FindConnectionPoint(IID_IRowPositionChange, &_pCPRowPos))
        {
            if (FAILED(_pCPRowPos->Advise((IRowPositionChange *)this, &_dwAdviseCookieRowPos)))
                ClearInterface(&_pCPRowPos);
        }
    }

    ClearInterface(&pCPC);             // re-use connection point container

    // We fire the script event from all the way down here, because
    // if we waited until after we hooked up the Rowset event sink,
    // the Rowset might cause ondataavailable or ondatasetcomplete
    // to be fired before we fired datasetchanged.

    // Fire datasetchanged to tell script code we just got a new
    // dataset.  Note this fires for the initial dataset and for
    // any subsequent datasets.
    if (_pProvider->IsTopLevel())
    {
        hrFire = pProvider->FireDataEvent(&s_propdescCElementondatasetchanged);
    }

    // sink notifications from the Rowset
    if (S_OK == pRowset->QueryInterface(IID_IConnectionPointContainer,
                                        (void **)&pCPC ))
    {
        if (S_OK == pCPC->FindConnectionPoint(IID_IDBAsynchNotify, &_pCPDBAsynch))
        {
            if (FAILED(_pCPDBAsynch->Advise((IDBAsynchNotify *)this, &_dwAdviseCookieDBAsynch)))
            {
                ClearInterface(&_pCPDBAsynch);
            }
        }
        
        if (S_OK == pCPC->FindConnectionPoint(IID_IRowsetNotify, &_pCPRowset))
        {
            if (FAILED(_pCPRowset->Advise((IRowsetNotify *)this, &_dwAdviseCookieRowset)))
            {
                ClearInterface(&_pCPRowset);
            }
        }
    }

    // The Rowset may or may not have fired IDBAsynchNotify::OnStop, during,
    // or since, our Advise call.  If it did, we're done.  If not, then we
    // want to ask the rowset if it was complete, in which case we can fire
    // it for it.
    if (!_fCompleteFired)
    {
        DBASYNCHPHASE ulStatusCode = DBASYNCHPHASE_COMPLETE;
        IDBAsynchStatus *pAsynchStatus;
        DBCOUNTITEM ulProgress, ulProgressMax;

        if (_pRowset &&
            S_OK == _pRowset->QueryInterface(IID_IDBAsynchStatus,
                                             (void **)&pAsynchStatus))
        {
            // Get the Rowset's ulStatusCode
            // (We don't care about ulProgress & ulProgressMax, but I was afraid
            // some OLE-DB providers might crash if we passed in NULL).
            pAsynchStatus->GetStatus(_pProvider->GetChapter(), DBASYNCHOP_OPEN,
                                     &ulProgress, &ulProgressMax,
                                     &ulStatusCode, NULL);

            ClearInterface(&pAsynchStatus);
        }

        if (DBASYNCHPHASE_COMPLETE == ulStatusCode)
        {
            hr = Fire_ondatasetcomplete(0);
        }
    }

    ClearInterface(&pCPC);

    // If we got no other errors, but the Fire OnDataSetChanged event returned
    // an hr, then use that for our hr.  It probably means some script
    // code triggered an ondatasetchanged event in inside the ondatasetchanged
    // handler, and blew the stack.  Checking this hr should stop it.
    if (S_OK == hr)
        hr = hrFire;

    return hr;
}


//+-------------------------------------------------------------------------
// Member:      destructor (CDataSetEvents, public)
//
// Synopsis:    stop listening to my RowPosition, release my OleSite

CDataSetEvents::~CDataSetEvents()
{
    // let go of my data member manager
    if (_pDMembMgr)
    {
        _pDMembMgr->Release();
        _pDMembMgr = NULL;
    }
}


//+-------------------------------------------------------------------------
// Member:      Detach (CDataSetEvents, public)
//
// Synopsis:    stop listening to my RowPosition, release my OleSite

HRESULT
CDataSetEvents::Detach()
{
    HRESULT hr = S_OK;

    // stop listening for events
    if (_pCPRowPos)
    {
        IGNORE_HR(_pCPRowPos->Unadvise(_dwAdviseCookieRowPos));
        ClearInterface(&_pCPRowPos);
    }

    // stop listening for events
    if (_pCPDBAsynch)
    {
        IGNORE_HR(_pCPDBAsynch->Unadvise(_dwAdviseCookieDBAsynch));
        ClearInterface(&_pCPDBAsynch);
    }
    if (_pCPRowset)
    {
        IGNORE_HR(_pCPRowset->Unadvise(_dwAdviseCookieRowset));
        ClearInterface(&_pCPRowset);
    }

    // let go of the Rowset
    ClearInterface(&_pRowset);    
    
    // let go of the RowPosition
    ClearInterface(&_pRowPos);

    // let go of my provider
    if (_pProvider)
    {
        _pProvider = NULL;
    }
    
    return hr;
}



//+-------------------------------------------------------------------------
// Member:      OnRowPositionChange (IRowPositionChange, public)
//
// Synopsis:    translate IRowPosition notifications into
//              onRowExit/Enter events on my OLE site.

HRESULT
CDataSetEvents::OnRowPositionChange(DBREASON eReason, DBEVENTPHASE ePhase,
                                        BOOL fCantDeny)
{
    HCHAPTER hchapter = DB_NULL_HCHAPTER;
    HROW hrow = DB_NULL_HROW;
    DBPOSITIONFLAGS dwPositionFlags;
    HRESULT hr = CheckCallbackThread();
    BOOL fCancelled;

    _pProvider->AddRef();               // stabilize

    if (hr)
        goto Cleanup;

    switch (ePhase)
    {
    case DBEVENTPHASE_ABOUTTODO:        // position is changing, fire onRowExit
        _pRowPos->GetRowPosition(&hchapter, &hrow, &dwPositionFlags);
        if (hrow != DB_NULL_HROW)
        {
            TraceTag((tagRowEvents, "%p -> onRowExit", _pDMembMgr->GetOwner()));
            
            _pProvider->FireDataEvent(&s_propdescCElementonrowexit, &fCancelled);
            if (fCancelled)
            {
                hr = S_FALSE;
            }
        }
        break;
        
    case DBEVENTPHASE_SYNCHAFTER:
        switch (eReason)
        {
        case DBREASON_ROWPOSITION_CHAPTERCHANGED:
            // the provider is effectively a tearoff rowset on a specific
            // chapter, so when the chapter changes we need to replace
            // the provider
            Assert(_pProvider);
            _pRowPos->GetRowPosition(&hchapter, &hrow, &dwPositionFlags);
            IGNORE_HR(_pProvider->ChangeChapter(hchapter, hrow));
            break;

        default:
            break;
        }
        break;
    
    case DBEVENTPHASE_DIDEVENT:         // position changed, fire onRowEnter
        switch (eReason)
        {
        case DBREASON_ROWPOSITION_CHANGED:
            if (_pProvider->_fRowEnterOK)
            {
                TraceTag((tagRowEvents, "%p -> onRowEnter", _pDMembMgr->GetOwner()));
                _pProvider->FireDataEvent(&s_propdescCElementonrowenter);
            }
            else
            {
                _pProvider->_fNeedRowEnter = TRUE;
            }
            break;

        default:
            break;
        }
        break;
    }
    
Cleanup:
    // if we acquired an hrow or hchapter from the row position, release it now
    ReleaseChapterAndRow(hchapter, hrow, _pRowPos);
    
    _pProvider->Release();
    
    RRETURN1(hr, S_FALSE);
}

//  IDBAsynchNotify methods
HRESULT STDMETHODCALLTYPE
CDataSetEvents::OnLowResource( 
            /* [in] */ DB_DWRESERVE dwReserved)
{
    return E_NOTIMPL;
}

HRESULT
CDataSetEvents::Fire_ondatasetcomplete(long lReason)
{
    HRESULT hr = S_OK;
    if (_pProvider && !_fCompleteFired)
    {
        _fCompleteFired = TRUE;

        // only fire for top-level provider
        if (_pProvider->IsTopLevel())
        {
            hr = _pProvider->FireDataEvent(&s_propdescCElementondatasetcomplete,
                                        NULL, lReason);
        }
    }    
    return hr;
}

HRESULT STDMETHODCALLTYPE
CDataSetEvents::OnProgress( 
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ DBASYNCHOP ulOperation,
            /* [in] */ DBCOUNTITEM ulProgress,
            /* [in] */ DBCOUNTITEM ulProgressMax,
            /* [in] */ DBASYNCHPHASE ulStatusCode,
            /* [in] */ LPOLESTR pwszStatusText)
{
    HRESULT hr = CheckCallbackThread();
 
    if (hr)
        goto Cleanup;
        
    if (_pProvider && ulStatusCode==DBASYNCHPHASE_POPULATION && !_fCompleteFired)
    {
        // good place to fire script event
        hr = _pProvider->FireDataEvent(&s_propdescCElementondataavailable);
    }

Cleanup:
    return S_OK;                        // only allowed OLEDB return here
 }

STDMETHODIMP
CDataSetEvents:: OnStop( 
            /* [in] */ HCHAPTER hChapter,
            /* [in] */ ULONG ulOperation,
            /* [in] */ HRESULT hrStatus,
            /* [in] */ LPOLESTR pwszStatusText)
{
    long lReason;
    HRESULT hr = CheckCallbackThread();

    if (hr)
        goto Cleanup;
        

    switch (hrStatus)
    {
        case DB_E_CANCELED:
            lReason = 1;                // Abort
            break;

        case E_FAIL:
            lReason = 2;                // Error
            break;

        case S_OK:
        default:
            lReason = 0;
            break;
    }

    Fire_ondatasetcomplete(lReason);

Cleanup:
    RRETURN(hr);
}


// IRowsetNotify methods

STDMETHODIMP
CDataSetEvents::OnFieldChange( 
        /* [in] */ IRowset *pRowset,
        /* [in] */ HROW hRow,
        /* [in] */ DBORDINAL cColumns,
        /* [size_is][in] */ DBORDINAL rgColumns[  ],
        /* [in] */ DBREASON eReason,
        /* [in] */ DBEVENTPHASE ePhase,
        /* [in] */ BOOL fCantDeny)
{
    HRESULT hr;
    CDataLayerCursor *pDLC;

    switch (eReason)
    {
    case DBREASON_COLUMN_SET:
        switch (ePhase)
        {
        case DBEVENTPHASE_ABOUTTODO:
            // first make sure the row belongs to my chapter
            pDLC = _pProvider->GetDLCursor();
            if (pDLC)
            {
                DBROWCOUNT cRowsGood;
                const HROW *pRowsGood;

                hr = pDLC->FilterRowsToChapter(1, &hRow,
                                                    &cRowsGood, &pRowsGood);
                if (!hr && cRowsGood != 0)
                {
                    Assert(pRowsGood == &hRow); // no allocation for only one row
                    SetEventData(&hRow, 1, rgColumns, cColumns);
                    
                    _pProvider->FireDataEvent(&s_propdescCElementoncellchange);

                    ClearEventData();
                }
             }
            hr = S_OK;
            break;

        default:
            hr = DB_S_UNWANTEDPHASE;
            break;
        }
        break;

    default:
        hr = DB_S_UNWANTEDREASON;
        break;
    }
    
    return hr;
}

    
STDMETHODIMP
CDataSetEvents::OnRowChange( 
        /* [in] */ IRowset *pRowset,
        /* [in] */ DBCOUNTITEM cRows,
        /* [size_is][in] */ const HROW rghRows[  ],
        /* [in] */ DBREASON eReason,
        /* [in] */ DBEVENTPHASE ePhase,
        /* [in] */ BOOL fCantDeny)
{
    HRESULT hr = S_OK;
    DBROWCOUNT cRowsGood;
    const HROW *pRowsGood = rghRows;

    // ignore rows that don't belong to my chapter
    CDataLayerCursor *pDLC = _pProvider->GetDLCursor();
    if (!pDLC)
        goto Cleanup;
    hr = pDLC->FilterRowsToChapter(cRows, rghRows, &cRowsGood, &pRowsGood);
    if (hr || cRowsGood == 0)
        goto Cleanup;

    switch (eReason)
    {
    case DBREASON_ROW_DELETE:
    case DBREASON_ROW_UNDOINSERT:
        switch (ePhase)
        {
        case DBEVENTPHASE_ABOUTTODO:
            SetEventData(pRowsGood, cRowsGood);
            
            _pProvider->FireDataEvent(&s_propdescCElementonrowsdelete);

            ClearEventData();
            hr = S_OK;
            break;
        default:
            hr = DB_S_UNWANTEDPHASE;
            break;
        }
        break;
    
    case DBREASON_ROW_INSERT:
    case DBREASON_ROW_ASYNCHINSERT:
    case DBREASON_ROW_UNDODELETE:
        switch (ePhase)
        {
        case DBEVENTPHASE_DIDEVENT:
            SetEventData(pRowsGood, cRowsGood);
            
            _pProvider->FireDataEvent(&s_propdescCElementonrowsinserted);

            ClearEventData();
            hr = S_OK;
            break;
        default:
            hr = DB_S_UNWANTEDPHASE;
            break;
        }
        break;

    default:
        hr = DB_S_UNWANTEDREASON;
        break;
    }

Cleanup:
    if (pRowsGood != rghRows)
        delete const_cast<HROW *>(pRowsGood);
    
    return hr;
}

    
STDMETHODIMP
CDataSetEvents::OnRowsetChange( 
        /* [in] */ IRowset *pRowset,
        /* [in] */ DBREASON eReason,
        /* [in] */ DBEVENTPHASE ePhase,
        /* [in] */ BOOL fCantDeny)
{
    return DB_S_UNWANTEDREASON;
}


HRESULT
CDataSetEvents::CheckCallbackThread()
{
    HRESULT hr = S_OK;

    if (_pDMembMgr
        && _pDMembMgr->Doc()
        && _pDMembMgr->Doc()->_dwTID != GetCurrentThreadId() )
    {
        Assert(!"OLEDB callback on wrong thread");
        hr = E_UNEXPECTED;
    }

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
// Member:      Release (public, IUnknown)
//
// Synopsis:    decrease refcount, die if 0
//
// Returns:     new refcount

ULONG
CDataSetEvents::Release()
{
    ULONG ulRefs = --_ulRefs;
    if (ulRefs == 0)
        delete this;
    return ulRefs;
}


//+-------------------------------------------------------------------------
// Member:      Query Interface (public, IUnknown)
//
// Synopsis:    return desired interface pointer
//
// Arguments:   riid        IID of desired interface
//              ppv         where to store the pointer
//
// Returns:     HRESULT

HRESULT
CDataSetEvents::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr;
    IUnknown *punkReturn = 0;

    // check for bad arguments
    if (!ppv)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // look for interfaces I support
    if (IsEqualIID(riid, IID_IUnknown))
    {
        // We inherit IUnknown from both IRowPositionChange & IDBAsynchNotify,
        // We can arbitrarily return the IUknown from one of them..
        punkReturn = (IRowPositionChange *)this;
    }
    else if (IsEqualIID(riid, IID_IRowPositionChange))
    {
        punkReturn = (IRowPositionChange *)this;
    }
    else if (IsEqualIID(riid, IID_IRowsetNotify))
    {
        punkReturn = (IRowsetNotify *)this;
    }
    else if (IsEqualIID(riid, IID_IDBAsynchNotify))
    {
        punkReturn = (IDBAsynchNotify *)this;
    }
    else
    {
        hr = E_NOINTERFACE;
        goto Cleanup;
    }
    punkReturn->AddRef();          // return addref'd copy
    *ppv = punkReturn;
    hr = S_OK;

Cleanup:
    return hr;        
}


/////////////////////////////////////////////////////////////////////////////
/////                       Helper functions                            /////
/////////////////////////////////////////////////////////////////////////////

//+-------------------------------------------------------------------------
// Function:    Adapt Rowset On RowPosition (static helper)
//
// Synopsis:    point pRowset at a rowset obtained from the RowPosition object.
//              If pRowset already points at an adapter, don't change it.
//
// Arguments:   ppRowset    [out] where to store adapter
//              pSTD        [in] pointer to ISTD

HRESULT
CAdaptingProvider::AdaptRowsetOnRowPosition(IRowset** ppRowset, IRowPosition *pRowPos)
{
    HRESULT hr = S_OK;
    Assert("RowPos expected" && pRowPos);

    // if adapter already exists, nothing to do
    if (*ppRowset)
        goto Cleanup;

    // get its IRowset interface
    hr = pRowPos->GetRowset(IID_IRowset, (IUnknown**)ppRowset);
    if (hr)
        goto Cleanup;
    Assert(*ppRowset);

Cleanup:
    return hr;
}


//+-------------------------------------------------------------------------
// Function:    Adapt Rowset On STD (static helper)
//
// Synopsis:    point pRowset at an object that adapts IRowset to OLEDBSimpleProvider.
//              If pRowset already points at an adapter, don't change it.
//
// Arguments:   ppRowset    [out] where to store adapter
//              pOSP        [in] pointer to OLEDBSimpleProvider

#if defined(USE_PW_DLL)
HRESULT
CAdaptingProvider::AdaptRowsetOnSTD(IRowset** ppRowset, OLEDBSimpleProvider *pOSP)
{
    HRESULT hr = S_OK;
    IUnknown *pUnkRowset = 0;
    Assert("OSP expected" && pOSP);
    static const CLSID clsidPW = {0xdfc8bdc0, 0xe378, 0x11d0, 0x9b, 0x30, 0x00, 0x80, 0xc7, 0xe9, 0xfe, 0x95};
    static const GUID DBPROPSET_PWROWSET = {0xe6e478db,0xf226,0x11d0,{0x94,0xee,0x0,0xc0,0x4f,0xb6,0x6a,0x50}};
    const DWORD PWPROP_OSPVALUE = 2;
    DBID dbidTable;
    DBPROPSET rgdbpropset[1];
    DBPROP rgprop[1];
    IDBInitialize *pIDBInitialize = NULL;
    IDBCreateSession *pIDBCreateSession = NULL;
    IOpenRowset *pIOpenRowset = NULL;

    // if adapter already exists, nothing to do
    if (*ppRowset)
        goto Cleanup;

    // Instantiate the OSP->Rowset adapter
    hr = CoCreateInstance(clsidPW,
                            NULL,
                            CLSCTX_ALL,
                            IID_IDBInitialize,
                            (void **)&pIDBInitialize);
    if (hr)
        goto Cleanup;

    hr = pIDBInitialize->Initialize();
    if (hr)
        goto Cleanup;

    hr = pIDBInitialize->QueryInterface(IID_IDBCreateSession,
                                        (void **)&pIDBCreateSession);
    if (hr)
        goto Cleanup;

    hr = pIDBCreateSession->CreateSession(NULL, IID_IOpenRowset,
                                            (IUnknown **)&pIOpenRowset);
    if (hr)
        goto Cleanup;

    // Set OSPVALUE property
    rgdbpropset[0].guidPropertySet = DBPROPSET_PWROWSET;
    rgdbpropset[0].cProperties = 1;
    rgdbpropset[0].rgProperties = &rgprop[0];

    rgprop[0].dwPropertyID = PWPROP_OSPVALUE;
    rgprop[0].dwOptions = DBPROPOPTIONS_REQUIRED;
    rgprop[0].dwStatus = DBPROPSTATUS_OK;
    // rgprop[0].colid = DB_NULLID;
    memset(&rgprop[0].colid, 0, sizeof(rgprop[0].colid));
    VariantInit(&(rgprop[0].vValue));
    V_VT(&(rgprop[0].vValue)) = VT_UNKNOWN;
    V_UNKNOWN(&(rgprop[0].vValue)) = (IUnknown *)pOSP;

    dbidTable.eKind = DBKIND_NAME;
    dbidTable.uName.pwszName = NULL;

    hr = pIOpenRowset->OpenRowset(NULL,
                                    &dbidTable,
                                    NULL,
                                    IID_IRowset,
                                    1,
                                    rgdbpropset,
                                    (IUnknown **)ppRowset);
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pIDBInitialize);
    ReleaseInterface(pIDBCreateSession);
    ReleaseInterface(pIOpenRowset);

    return hr;
}
#else // USE_PW_DLL
HRESULT
CAdaptingProvider::AdaptRowsetOnSTD(IRowset** ppRowset, OLEDBSimpleProvider *pOSP)
{
    HRESULT hr = S_OK;
    IUnknown *pUnkRowset = 0;
    Assert("OSP expected" && pOSP);

    // if adapter already exists, nothing to do
    if (*ppRowset)
        goto Cleanup;

    hr = CTopRowset::CreateRowset(pOSP, &pUnkRowset);
    if (hr)
        goto Cleanup;

    // get its IRowset interface
    hr = pUnkRowset->QueryInterface(IID_IRowset, (void**)ppRowset);
    if (hr)
        goto Cleanup;
    Assert(*ppRowset);

Cleanup:
    ReleaseInterface(pUnkRowset);
    return hr;
}
#endif USE_PW_DLL


//+-------------------------------------------------------------------------
// Function:    Adapt Cursor On Rowset (static helper)
//
// Synopsis:    point pCursor at an object that adapts ICursor to IRowset.
//              If pCursor already points at an adapter, don't change it.
//
// Arguments:   ppCursor    [out] where to store adapter
//              pRowset     [in] pointer to IRowset

HRESULT
CAdaptingProvider::AdaptCursorOnRowset(ICursor** ppCursor, IRowset *pRowset)
{
    HRESULT hr = S_OK;
    Assert("rowset expected" && pRowset);
    ICursorFromRowset *pIcfr = 0;

    // if adapter already exists, nothing to do
    if (*ppCursor)
        goto Cleanup;

    // create an adapter
    hr = CoCreateInstance(CLSID_CCursorFromRowset, NULL,
                          CLSCTX_INPROC, IID_ICursorFromRowset,
                          (void **)&pIcfr);
    if (hr) 
        goto Cleanup;
        
    // get its ICursor interface
    hr = THR(pIcfr->GetCursor(pRowset, ppCursor, g_lcidUserDefault));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pIcfr);
    return hr;
}


//+-------------------------------------------------------------------------
// Function:    Adapt Cursor On Row Position (static helper)
//
// Synopsis:    point pCursor at an object that adapts ICursor to IRowset.
//              If pCursor already points at an adapter, don't change it.
//
// Arguments:   ppCursor    [out] where to store adapter
//              pRowset     [in] pointer to IRowset

HRESULT
CAdaptingProvider::AdaptCursorOnRowPosition(ICursor** ppCursor, IRowPosition *pRowPos)
{
    HRESULT hr = S_OK;
#ifdef VD_INCLUDE_ROWPOSITION
    Assert("rowposition expected" && pRowPos);
    ICursorFromRowPosition *pIcfr = 0;

    // if adapter already exists, nothing to do
    if (*ppCursor)
        goto Cleanup;

    // create an adapter
    hr = CoCreateInstance(CLSID_CCursorFromRowset, NULL,
                          CLSCTX_INPROC, IID_ICursorFromRowPosition,
                          (void **)&pIcfr);
    if (hr) 
        goto Cleanup;
        
    // get its ICursor interface
    hr = THR(pIcfr->GetCursor(pRowPos, ppCursor, g_lcidUserDefault));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pIcfr);
#endif // VD_INCLUDE_ROWPOSITION
    return hr;
}


//+-------------------------------------------------------------------------
// Function:    SetADOClientSite (static)
//
// Synopsis:    Tell ADO to use the given client site
//
// Arguments:   pADO            ADO object
//              pClientSite     client site
//
// Returns:     HRESULT

static HRESULT
SetADOClientSite(IADORecordset *pADO, IOleClientSite *pClientSite)
{
    HRESULT hr;
    IObjectWithSite *pObjSite = NULL;

    Assert(pADO);
    hr = pADO->QueryInterface(IID_IObjectWithSite, (void **)&pObjSite);
    if (OK(hr) && pObjSite)
    {
        hr = pObjSite->SetSite(pClientSite);
        ReleaseInterface(pObjSite);
        goto Cleanup;
    }
    hr = S_OK;
    
Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
// Function:    GetADOConstructor (static helper)
//
// Synopsis:    point pADO at an object that adapts IADORecordset to IRowset.
//              point pADOConstructor at its constructor interface
//
// Arguments:   ppADO               [out] where to store adapter
//              ppADOConstructor    [out] where to store constructor

static HRESULT
GetADOConstructor(IADORecordset **ppADO,
                  IADORecordsetConstruction **ppADOConstructor,
                  CDataSourceProvider *pProvider)
{
    HRESULT hr;
    IADOSecurity *pADOSecurity = NULL;
    IADORecordset *pADO = NULL;
    IObjectSafety *pObjSafety = NULL;
    static const IID IID_IADOSecurity = {0x782d16ae, 0x905f, 0x11d1, 0xac, 0x38, 0x0, 0xc0, 0x4f, 0xc2, 0x9f, 0x8f};
    
    // create an adapter
    hr = CoCreateInstance(CLSID_CADORecordset, NULL,
                          CLSCTX_INPROC, IID_IADORecordset15,
                          (void **)&pADO);
    if (hr) 
        goto Cleanup;

    Assert(pProvider);
    if (pProvider == NULL)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // tell it to act safely
    // ADO 2.1 uses ClientSite / ObjectSafety.  Try that first.
    
    // give ADO a client site, so it can post security dialogs
    hr = SetADOClientSite(pADO, (IOleClientSite*) (pProvider->ADOClientSite()));

    // now tell it to act safely
    if (!hr)
        hr = pADO->QueryInterface(IID_IObjectSafety, (void**)&pObjSafety);
    if (!hr && pObjSafety)
    {
        // make it safe to init on IPersistPropertyBag
        IGNORE_HR(pObjSafety->SetInterfaceSafetyOptions(IID_IPersistPropertyBag,
                            INTERFACESAFE_FOR_UNTRUSTED_DATA,
                            INTERFACESAFE_FOR_UNTRUSTED_DATA));

        // make it safe to script on IDispatchEx or IDispatch
        hr = pObjSafety->SetInterfaceSafetyOptions(IID_IDispatchEx,
                            INTERFACESAFE_FOR_UNTRUSTED_CALLER,
                            INTERFACESAFE_FOR_UNTRUSTED_CALLER);
        if (hr)
            hr = pObjSafety->SetInterfaceSafetyOptions(IID_IDispatch,
                            INTERFACESAFE_FOR_UNTRUSTED_CALLER,
                            INTERFACESAFE_FOR_UNTRUSTED_CALLER);

        ReleaseInterface(pObjSafety);

        hr = S_OK;      // we tried our best.  If that failed, just carry on.
    }

    // If that didn't work, maybe it's because ADO 1.5 is installed.
    // So try the old private interface approach.
    if (hr && S_OK == pADO->QueryInterface(IID_IADOSecurity, (void**)&pADOSecurity))
    {
        BSTR bstrURL = NULL;

        hr = pADOSecurity->SetSafe(TRUE);
        
        if (!hr)
            hr = pProvider->Doc()->_pWindowPrimary->Document()->get_URL(&bstrURL);
        if (!hr)
            hr = pADOSecurity->SetURL(bstrURL);

        FormsFreeString(bstrURL);
        ReleaseInterface(pADOSecurity);

        if (hr)
        {
            ReleaseInterface(pADO);
            goto Cleanup;
        }
    }

    *ppADO = pADO;
    
    // get its IADORecordsetConstruction interface
    hr = pADO->QueryInterface(IID_IADORecordsetConstruction,
                                (void **)ppADOConstructor);

Cleanup:
    return hr;
}


//+-------------------------------------------------------------------------
// Function:    Adapt ADO On Rowset (static helper)
//
// Synopsis:    point pADO at an object that adapts IADORecordset to IRowset.
//              If pADO already points at an adapter, don't change it.
//
// Arguments:   ppADO       [out] where to store adapter
//              pRowset     [in] pointer to IRowset

HRESULT
CAdaptingProvider::AdaptADOOnRowset(IADORecordset** ppADO, IRowset *pRowset)
{
    HRESULT hr = S_OK;
    IADORecordset *pADO = 0;
    IADORecordsetConstruction *pAdoConstructor = 0;
    Assert("rowset expected" && pRowset);
    
    // if adapter already exists, nothing to do
    if (*ppADO)
        goto Cleanup;

    // create an adapter
    hr = GetADOConstructor(&pADO, &pAdoConstructor, this);
    if (hr)
        goto Cleanup;

    // return addref'd result to caller
    pADO->AddRef();
    *ppADO = pADO;
        
    // give it the rowset.  This may fire onrowenter, which might ask for
    // event.recordset, so we must set *ppADO first.
    hr = THR(pAdoConstructor->put_Rowset(pRowset));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pADO);
    ReleaseInterface(pAdoConstructor);
    return hr;
}

//+-------------------------------------------------------------------------
// Function:    Adapt ADO On RowPosition (static helper)
//
// Synopsis:    point pADO at an object that adapts IADORecordset to IRowset.
//              If pADO already points at an adapter, don't change it.
//
// Arguments:   ppADO       [out] where to store adapter
//              pRowset     [in] pointer to IRowset

HRESULT
CAdaptingProvider::AdaptADOOnRowPos(IADORecordset** ppADO, IRowPosition *pRowPos)
{
    HRESULT hr = S_OK;
    IADORecordset *pADO = 0;
    IADORecordsetConstruction *pAdoConstructor = 0;
    Assert("rowpos expected" && pRowPos);
    
    // if adapter already exists, nothing to do
    if (*ppADO)
        goto Cleanup;

    // create an adapter
    hr = GetADOConstructor(&pADO, &pAdoConstructor, this);
    if (hr)
        goto Cleanup;

    // return addref'd result to caller
    pADO->AddRef();
    *ppADO = pADO;
        
    // give it the row position.  This may fire onrowenter, which might ask for
    // event.recordset, so we must set *ppADO first.
    hr = THR(pAdoConstructor->put_RowPosition(pRowPos));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pADO);
    ReleaseInterface(pAdoConstructor);
    return hr;
}

EXTERN_C const CLSID CLSID_CRowPosition;

//+-------------------------------------------------------------------------
// Function:    Adapt RowPosition On Rowset (static helper)
//
// Synopsis:    point pRowPos at an object that adapts IRowPosition to IRowset.
//              If pRowPos already points at an adapter, don't change it.
//
// Arguments:   ppRowPos    [out] where to store adapter
//              pRowset     [in] pointer to IRowset

HRESULT
CAdaptingProvider::AdaptRowPositionOnRowset(IRowPosition** ppRowPos, IRowset *pRowset)
{
    IRowPosition *pRowPos = NULL;
    HRESULT hr = S_OK;
    Assert("rowset expected" && pRowset);
    
    // if adapter already exists, nothing to do
    if (*ppRowPos)
        goto Cleanup;

    // create an adapter
    hr = CoCreateInstance(CLSID_CRowPosition, NULL,
                          CLSCTX_INPROC, IID_IRowPosition,
                          (void **)&pRowPos);
    if (hr)
    {
#ifndef UNIX
        // Win32 doesn't have a built-in CRowPosition anymore
        goto Cleanup;
#else
        pRowPos = new CRowPosition();
        if (!pRowPos)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
#endif
    }


    hr = pRowPos->Initialize(pRowset);
    if (hr)
    {
        ReleaseInterface(pRowPos);
        goto Cleanup;
    }
        
Cleanup:
    if (!hr && pRowPos)
        *ppRowPos = pRowPos;
    return hr;
}


//+-------------------------------------------------------------------------
// Function:    Adapt Rowset On Cursor (static helper)
//
// Synopsis:    point pRowset at an object that adapts IRowset to ICursor.
//              If pRowset already points at an adapter, don't change it.
//
// Arguments:   ppRowset    [out] where to store adapter
//              pCursor     [in] pointer to ICursor

HRESULT
CAdaptingProvider::AdaptRowsetOnCursor(IRowset** ppRowset, ICursor *pCursor)
{
    HRESULT hr = S_OK;
//    IRowsetFromCursor *pIrfc = 0;
    Assert("cursor expected" && pCursor);

    // if adapter already exists, nothing to do
    if (*ppRowset)
        goto Cleanup;
    
    // Disable Viaduct Phase I.  The Viaduct-I DLL uses OLE-DB M6.1, but
    // we're at M11.  So it would be a bad idea to hook up to it.
    // (Viaduct is never going to change - so don't ever change this.)
#if !defined(GetRidOfThisWhenViaductConvertsToOleDBM11)
    hr = E_NOTIMPL;
#else // Viaduct-I is enabled

    // create an adapter
    hr = CoCreateInstance(CLSID_CRowsetFromCursor, NULL,
                          CLSCTX_INPROC, IID_IRowsetFromCursor,
                          (void **)&pIrfc);
    if (hr) 
        goto Cleanup;
        
    // get its IRowset interface
    hr = THR(pIrfc->GetRowset(pCursor, ppRowset, g_lcidUserDefault));
#endif // disable Viaduct-I

Cleanup:
//     ReleaseInterface(pIrfc);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////                       Provider Classes                            /////
/////////////////////////////////////////////////////////////////////////////

/////-------------------------------------------------------------------/////
///// null provider.  Used when binding fails.  Always returns error.   /////
/////-------------------------------------------------------------------/////

class CNullProvider: public CDataSourceProvider
{
    typedef CDataSourceProvider super;
public:
    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CNullProvider))
    CNullProvider(CDoc *pDoc): _pADO(0) { _pDoc = pDoc; }
    virtual ~CNullProvider();
    virtual HRESULT QueryDataInterface(REFIID riid, void **ppv);
    virtual HRESULT GetSubProvider(CDataSourceProvider **ppdsp,
                LPCTSTR bstrName, HROW hrow=0) { *ppdsp = this;  AddRef(); return S_OK; }
private:
    IADORecordset *_pADO;
};


//+-------------------------------------------------------------------------
// Member:      Query Data Interface (CNullProvider, public)
//
// Synopsis:    return addref'd interface pointer.  NullProvider supports
//              QDI for ADO, and returns an empty ADO;  this allows scripts
//              to limp along even when there's no real provider.
//              All other requests return E_NOINTERFACE.
//
//              ** The behavior described above also deprives script authors **
//              ** of a reasonable why of telling whether or not they have   **
//              ** a valid recordset, since foo.recordset == null will return**
//              ** false.  I'm going to try deprecating this and see what    **
//              ** happens -- cfranks 2 August 1997                          **
//
// Arguments:   riid        desired interface
//              ppvUnk      where to store interface pointer
//
// Returns:     HRESULT

HRESULT
CNullProvider::QueryDataInterface(REFIID riid, void **ppvUnk)
{
    HRESULT hr = E_NOINTERFACE;     // assume the worst

    if (IsEqualIID(riid, IID_IADORecordset15))
    {
        if (!_pADO)
        {
            IADORecordset *pADO;
            IADORecordsetConstruction *pADOC;

            hr = GetADOConstructor(&pADO, &pADOC, this);
            if (hr)
                goto Cleanup;

            _pADO = pADO;
            ReleaseInterface(pADOC);
        }

        if (_pADO)
        {
            _pADO->AddRef();
            *ppvUnk = _pADO;
            hr = S_OK;
        }
    }
Cleanup:

    return hr;
}


//+-------------------------------------------------------------------------
// Member:      destructor (CNullProvider, public)

CNullProvider::~CNullProvider()
{ 
    if (_pADO)
    {
        SetADOClientSite(_pADO, NULL);
        ReleaseInterface(_pADO);
    }
}


//+-------------------------------------------------------------------------
// Member:      Detach (CDataSourceProvider, public)
//
// Synopsis:    Detach my resources

void
CAdaptingProvider::Detach()
{
    super::Detach();
}


//+-------------------------------------------------------------------------
// Member:      SetRowChangedEventTarget (CAdaptingProvider, protected)
//
// Synopsis:    wire up a listener to my IRowPosition, so I can fire
//              onRowExit/Enter to the given OLE site, and wire up
//              a listener to my IDBAsynchNotify, so we can get transfer
//              notifications.

HRESULT
CAdaptingProvider::SetRowChangedEventTarget(CDataMemberMgr *pdmm)
{
    HRESULT hr = S_OK;
    Assert(pdmm);

    // cache the SimpleDataConverter, if any
    _pSDC = pdmm->GetSDC();
    if (_pSDC)
        _pSDC->AddRef();

    // Try to make sure we have both a row position & a rowset, but ultimately
    // proceed if we have either one.  (Note that Ensuring a RowsetPosition will
    // ensure a Rowset, but not visa versa so the order here is important.)
    if (EnsureRowsetPosition() || EnsureRowset())
    {
        _pRowEvents = new CDataSetEvents;
        if (_pRowEvents)
        {
            hr = _pRowEvents->Init(pdmm, _pRowset, _pRowPos, this);
        }
    }
    return hr;
}

//+-------------------------------------------------------------------------
// Member:      ReleaseAll (CAdaptingProvider, protected)
//
// Synopsis:    release my resources

void
CAdaptingProvider::ReleaseAll()
{
    int i;
    CXTRecord       *pXR;
    CChapterRecord  *pCR;
    CProviderRecord *pPR;
    CAccessorRecord *pAR;
    CDataMemberMgr  *pdmm = NULL;
    
    if (_pRowEvents)
    {
        pdmm = _pRowEvents->GetDataMemberManager();
        if (pdmm)
        {
            pdmm->AddRef();       // keep control alive through shutdown
        }
        _pRowEvents->Detach();
    }
    ClearInterface((IUnknown**)&_pRowEvents);

    // release the XferThunk cache
    for (i=_aryXT.Size(), pXR=_aryXT;  i>0;  --i, ++pXR)
    {
        // release field name
        FormsFreeString(pXR->bstrField);

        // release XT
        if (pXR->pXT)
            pXR->pXT->Release();
    }
    _aryXT.DeleteAll();

    // release current record instance
    if (_pCRI)
        _pCRI->Detach();
    ClearInterface(&_pCRI);

    // release chapter table
    for (i=_aryCR.Size(), pCR=_aryCR;  i>0;  --i, ++pCR)
    {
        // release hrow
        Assert(_pRowset);
        IGNORE_HR(_pRowset->ReleaseRows(1, &pCR->hrow, NULL, NULL, NULL));

        // release field name
        FormsFreeString(pCR->bstrField);
    }
    _aryCR.DeleteAll();
    
    // release provider table
    for (i=_aryPR.Size(), pPR=_aryPR;  i>0;  --i, ++pPR)
    {
        FormsFreeString(pPR->bstrField);
        if (pPR->pdsp)
            pPR->pdsp->Release();
    }
    _aryPR.DeleteAll();

    // release accessor/rowset table
    if (_aryAR.Size() > 0)
    {
        IAccessor *pAccessor = NULL;

        Assert(_pRowset && "hierarchy without a rowset?");
        
        _pRowset->QueryInterface(IID_IAccessor, reinterpret_cast<void**>(&pAccessor));
            
        for (i=_aryAR.Size(), pAR=_aryAR;  i>0;  --i, ++pAR)
        {
            FormsFreeString(pAR->bstrField);
            if (pAccessor && pAR->hAccessor)
                pAccessor->ReleaseAccessor(pAR->hAccessor, NULL);

            ReleaseInterface(pAR->pRowset);
        }
        _aryAR.DeleteAll();

        ReleaseInterface(pAccessor);
    }

    if (_hChapter != DB_NULL_HCHAPTER)
    {
        Assert(_pRowset && "hierarchy without a rowset?");
        IChapteredRowset *pChapRowset = NULL;
        HRESULT hr = _pRowset->QueryInterface(IID_IChapteredRowset,
                        reinterpret_cast<void**>(&pChapRowset));

        if (!hr)
        {
            pChapRowset->ReleaseChapter(_hChapter, NULL);
        }

        _hChapter = DB_NULL_HCHAPTER;
        ReleaseInterface(pChapRowset);
    }

    if (_pADO)
        SetADOClientSite(_pADO, NULL);
    ClearInterface(&_pSDC);
    ClearInterface(&_pCursor);
    ClearInterface(&_pRowset);
    ClearInterface(&_pRowPos);
    ClearInterface(&_pSTD);
    ClearInterface(&_pADO);
    if (pdmm)
        pdmm->Release();
}


//+-------------------------------------------------------------------------
// Member:      Ensure STD (private)
//
// Synopsis:    Try to acquire a valid ISTD interface
//
// Arguments:   none
//
// Returns:     true    _pSTD is valid
//              false   _pSTD is invalid

BOOL
CAdaptingProvider::EnsureSTD()
{
    return !!_pSTD;
}


//+-------------------------------------------------------------------------
// Member:      Ensure Rowset (private)
//
// Synopsis:    Try to acquire a valid IRowset interface
//
// Arguments:   none
//
// Returns:     true    _pRowset is valid
//              false   _pRowset is invalid

BOOL
CAdaptingProvider::EnsureRowset()
{
    if (_pRowPos)
        AdaptRowsetOnRowPosition(&_pRowset, _pRowPos);
    else if (_pSTD)
        AdaptRowsetOnSTD(&_pRowset, _pSTD);
    else if (_pCursor)
        AdaptRowsetOnCursor(&_pRowset, _pCursor);
    return !!_pRowset;
}


//+-------------------------------------------------------------------------
// Member:      Ensure Rowset Position (private)
//
// Synopsis:    Try to acquire a valid IRowPosition interface
//
// Arguments:   none
//
// Returns:     true    _pRowPos is valid
//              false   _pRowPos is invalid

BOOL
CAdaptingProvider::EnsureRowsetPosition()
{
    if (EnsureRowset())
        AdaptRowPositionOnRowset(&_pRowPos, _pRowset);
    return !!_pRowPos;
}


//+-------------------------------------------------------------------------
// Member:      Ensure Cursor (private)
//
// Synopsis:    Try to acquire a valid ICursor interface
//
// Arguments:   none
//
// Returns:     true    _pCursor is valid
//              false   _pCursor is invalid

BOOL
CAdaptingProvider::EnsureCursor()
{
    if (!_pCursor)
    {
#ifdef VD_INCLUDE_ROWPOSITION
        if (EnsureRowsetPosition())
            AdaptCursorOnRowPosition(&_pCursor, _pRowPos);
        else
#endif
        if (EnsureRowset())
            AdaptCursorOnRowset(&_pCursor, _pRowset);
    }
    return !!_pCursor;
}


//+-------------------------------------------------------------------------
// Member:      Ensure ADO (private)
//
// Synopsis:    Try to acquire a valid IADORecordset interface
//
// Arguments:   none
//
// Returns:     true    _pADO is valid
//              false   _pADO is invalid

BOOL
CAdaptingProvider::EnsureADO()
{
    if (_pADO)
        goto Cleanup;
    
    if (EnsureRowsetPosition())
    {
        if (_pCRI)
            _pCRI->InitPosition();      // in case it hasn't been done yet
        AdaptADOOnRowPos(&_pADO, _pRowPos);
    }
    else
    if (EnsureRowset())
        AdaptADOOnRowset(&_pADO, _pRowset);

Cleanup:
    return !!_pADO;
}


//+-------------------------------------------------------------------------
// Member:      Ensure CRI (private)
//
// Synopsis:    Try to acquire a valid ICurrentRecordInstance interface
//
// Arguments:   none
//
// Returns:     true    _pCRI is valid
//              false   _pCRI is invalid

BOOL
CAdaptingProvider::EnsureCRI()
{
    HRESULT hr = S_OK;
    
    if (_pCRI)                      // already exists, nothing to do
        goto Cleanup;

    EnsureRowsetPosition();         // need a valid RowPosition

    // get a CRI object
    _pCRI = new CCurrentRecordInstance;
    if (!_pCRI)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // tell it to track the RowPosition
    hr = _pCRI->Init(this, _pRowPos);
    if (!hr)
        hr = _pCRI->InitChapter(_hChapter);
    if (hr)
    {
        _pCRI->Detach();
        ClearInterface(&_pCRI);
        goto Cleanup;
    }

Cleanup:
    return !!_pCRI;
}


//+-------------------------------------------------------------------------
// Member:      Query Data Interface (CAdaptingProvider, public)
//
// Synopsis:    return addref'd interface pointer
//
// Arguments:   riid        desired interface
//              ppvUnk      where to store interface pointer
//
// Returns:     HRESULT

#define TEST(intf, EnsureFn, _pIntf) \
    if (IsEqualIID(riid, intf))     \
    {                               \
        if (EnsureFn())             \
        {                           \
            _pIntf->AddRef();       \
            *ppvUnk = _pIntf;       \
            hr = S_OK;              \
        }                           \
    }

HRESULT
CAdaptingProvider::QueryDataInterface(REFIID riid, void **ppvUnk)
{
    HRESULT hr = E_NOINTERFACE;     // assume the worst

            TEST(IID_IRowset,               EnsureRowset,           _pRowset)
    else    TEST(IID_ICurrentRecordInstance,EnsureCRI,              _pCRI)
    else    TEST(IID_IADORecordset15,       EnsureADO,              _pADO)
    else    TEST(IID_IRowPosition,          EnsureRowsetPosition,   _pRowPos)
    else    TEST(IID_ICursor,               EnsureCursor,           _pCursor)
    else    TEST(IID_OLEDBSimpleProvider,   EnsureSTD,              _pSTD)

    return hr;
}

#undef TEST


//+-------------------------------------------------------------------------
// Member:      Stop
//
// Synopsis:    Stops any asynchronous download that may be in progress
//
// Arguments:   
//
// Returns:     HRESULT

HRESULT
CAdaptingProvider::Stop()
{
    HRESULT hr=S_OK;
    IDBAsynchStatus * pRowsetAsynch;

    if (_pRowset)
    {
        hr = _pRowset->QueryInterface(IID_IDBAsynchStatus, (void **)&pRowsetAsynch);
        if (SUCCEEDED(hr) && pRowsetAsynch)
        {
            hr = pRowsetAsynch->Abort(NULL, DBASYNCHOP_OPEN);
            pRowsetAsynch->Release();
        }
    }

    return hr;
}

//+-------------------------------------------------------------------------
// Member:      ReplaceProvider (CAdaptingProvider, public)
//
// Synopsis:    tear down current-record bindings before going away
//
// Arguments:   pdspNewProvider        new provider
//
// Returns:     HRESULT


HRESULT
CAdaptingProvider::ReplaceProvider(CDataSourceProvider *pdspNewProvider)
{
    HRESULT hr;
    int i;
    CProviderRecord *pPR;
    
    // notify everyone attached to me that I'm changing
    hr = super::ReplaceProvider(pdspNewProvider);

    // notify all my child providers that their clients should rebind
    for (i=_aryPR.Size(), pPR=_aryPR;  i > 0;  --i, ++pPR)
    {
        if (pPR->pdsp)
        {
            HRESULT hrT;

            hrT = pPR->pdsp->ReplaceProvider(NULL);
            if (!hr)
                hr = hrT;               // report first error
        }
    }
    
    return hr;
}


//+------------------------------------------------------------------------
//
//  Member:     GetXT
//
//  Synopsis:   Return the CXferThunk used to get/set data from the given
//              field using the given type.  Create one, if necessary, and
//              cache it in _aryXT.
//
//  Returns:    XT

CXferThunk *
CAdaptingProvider::GetXT(LPCTSTR strColumn, CVarType vtDest)
{
    CXferThunk *pXT = NULL;
    int i;
    CXTRecord *pXR;

    // look up <field, type> in the table
    for (i=_aryXT.Size(), pXR=_aryXT;  i>0;  --i, ++pXR)
    {
        if (0 == FormsStringCmp(strColumn, pXR->bstrField) &&
            vtDest.IsEqual(pXR->vtDest))
        {
            break;
        }
    }

    // if it's there, just return the XT
    if (i != 0)
    {
        pXT = pXR->pXT;
    }

    // if it's not, create and cache a new XT
    else
    {
        ISimpleDataConverter *pSDC;
        CDataLayerCursor *pDLC = GetDLCursor();

        if (!pDLC)
            goto Cleanup;

        pSDC = vtDest.FLocalized() ? _pMarkup->GetSimpleDataConverter() : _pSDC;

        // create a cache entry
        pXR = _aryXT.Append();
        if (pXR == NULL)
            goto Cleanup;

        // create an XT
        CXferThunk::Create(pDLC, strColumn, vtDest, pSDC, &pXT);

        // fill in the cache entry
        FormsAllocString(strColumn, &pXR->bstrField);
        pXR->vtDest = vtDest;
        pXR->pXT = pXT;
    }

Cleanup:
    return pXT;
}



//+-------------------------------------------------------------------------
// Member:      GetSubProvider (CDataSourceProvider, public)
//
// Synopsis:    return a sub-provider of a hierarchical provider
//
// Arguments:   ppdsp       where to store the answer
//              bstrName    path through hierarchy (e.g. "orders.details")
//              hrow        hrow of interest
//
// Description: This function is called in two circumstances.
//              (1) during nested table expansion, inner tables need a
//              sub-provider corresponding to the HROW of the enclosing table
//              row.  In this case hrow is non-null, and bstrName is a single
//              component denoting the field that holds the chapter handle.
//              (2) script and current-record bound elements need the sub-
//              provider obtained by walking down the tree following the
//              current row position of each provider.  In this case, hrow is
//              null, and bstrName can have many components separated by dots.
//
// Returns:     HRESULT

HRESULT
CAdaptingProvider::GetSubProvider(CDataSourceProvider **ppdsp,
                                    LPCTSTR bstrName, HROW hrow)
{
    HRESULT hr = S_OK;
    BSTR bstrHead = NULL;
    BSTR bstrTail = NULL;
    HCHAPTER hchapter = DB_NULL_HCHAPTER;
    HROW hrowCurr = DB_NULL_HROW;

    // bookkeeping to get started
    Assert(ppdsp);
    *ppdsp = NULL;
    FormsSplitFirstComponent(bstrName, &bstrHead, &bstrTail);

    // if the name is empty, return myself
    if (FormsStringLen(bstrHead) == 0)
    {
        AddRef();
        *ppdsp = this;
    }

    // if an HROW is given, use sub-provider corresponding to chapter (case 1)
    else if (hrow != DB_NULL_HROW)
    {
        hr = GetProviderFromField(bstrHead, hrow, ppdsp);
    }

    // otherwise, follow current position down the tree
    else if (EnsureRowsetPosition())
    {
        DBPOSITIONFLAGS dwFlags;
        CDataSourceProvider *pSubProvider = NULL;

        Assert(_pCRI);
        _pCRI->InitPosition();      // make sure _pRowPos has valid position
        
        // get the current hrow
        hr = _pRowPos->GetRowPosition(&hchapter, &hrowCurr, &dwFlags);
        if (!hr && hrowCurr == DB_NULL_HROW)
            hr = DB_E_BADROWHANDLE;

        // get next level sub-provider
        if (!hr)
            hr = GetProviderFromField(bstrHead, hrowCurr, &pSubProvider);

        // if something failed, return a null provider (so script gets
        // a zombie ADO recordset)
        if (hr)
        {
            *ppdsp = new CNullProvider(Doc());
            hr = (*ppdsp) ? S_OK : E_OUTOFMEMORY;
            goto Cleanup;
        }

        // continue search at next level
        Assert (pSubProvider);

        hr = pSubProvider->GetSubProvider(ppdsp, bstrTail);
        pSubProvider->Release();
    }

    // without a row position object, we're helpless
    else
    {
        hr = E_FAIL;
    }

Cleanup:
    ReleaseChapterAndRow(hchapter, hrowCurr, _pRowPos);
    FormsFreeString(bstrHead);
    FormsFreeString(bstrTail);
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
// Member:      GetChapterFromField (CAdaptingProvider, private)
//
// Synopsis:    find the chapter handle in the given hrow's field.
//
// Flame:       You might think this could be done by doing GetData
//              on the given HROW and field.  But it seems that OLE-DB
//              allows providers to generate chapter handles dynamically,
//              returning a new handle each time you call GetData.  This
//              isn't specifically mentioned in the OLE-DB spce (v2.0), but
//              I called the OLE-DB spec guru (12-May-98) and he attested
//              that this behavior is permitted.
//              Furthermore, at least one provider (the Shape Provider)
//              works this way.  So we have to fetch the handle once and
//              cache it.
//
// Arguments:   hrow        HROW holding desired chapter value
//              bstrField   name of chapter-valued field
//              phChapter   where to return the answer
//
// Returns:     HRESULT


HRESULT
CAdaptingProvider::GetChapterFromField(HROW hrow, BSTR bstrField,
                                        HCHAPTER *phChapter)
{
    HRESULT hr = S_OK;
    int i;
    CChapterRecord *pCR;
    
    // look up <hrow, field> in chapter table
    for (i=_aryCR.Size(), pCR=_aryCR; i>0;  --i, ++pCR)
    {
        if (IsSameRow(pCR->hrow, hrow) &&
            FormsStringCmp(pCR->bstrField, bstrField) == 0)
        {
            break;
        }
    }

    // if it's not there, fetch the handle and cache it in the table
    if (i == 0)
    {
        HACCESSOR hAccessor;
        HCHAPTER hChapter;

        // fetch the chapter handle from the rowset
        hr = GetAccessorForField(bstrField, &hAccessor);
        if (hr)
            goto Cleanup;

        hr = _pRowset->GetData(hrow, hAccessor, &hChapter);
        if (hr)
            goto Cleanup;

        // add an entry to the cache
        pCR = _aryCR.Append();
        if (pCR)
        {
            _pRowset->AddRefRows(1, &hrow, NULL, NULL);
            pCR->hrow = hrow;
            FormsAllocString(bstrField, &pCR->bstrField);
            pCR->hChapter = hChapter;
        }
        else
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    // return the desired chapter handle
    *phChapter = pCR->hChapter;

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
// Member:      GetProviderFromField (CAdaptingProvider, private)
//
// Synopsis:    find the provider associated with the chapter value in the
//              given hrow's field.
//
// Arguments:   bstrField   name of chapter-valued field
//              hrow        HROW holding desired chapter value
//              ppdsp       where to return the answer
//
// Returns:     HRESULT


HRESULT
CAdaptingProvider::GetProviderFromField(BSTR bstrField, HROW hrow,
                                        CDataSourceProvider **ppdsp)
{
    HRESULT hr;
    HCHAPTER hChapter;
    int i;
    CProviderRecord *pPR;

    Assert(_pRowset);
    *ppdsp = NULL;

    hr = GetChapterFromField(hrow, bstrField, &hChapter);
    if (hr)
        goto Cleanup;

    // look up <field, chapter> in my cache
    for (i=_aryPR.Size(), pPR=_aryPR;  i > 0;  --i, ++pPR)
    {
        if (pPR->hChapter == hChapter &&
            FormsStringCmp(pPR->bstrField, bstrField) == 0)
        {
            break;
        }
    }

    // if it wasn't there, create the desired provider and add it to the cache
    if (i == 0)
    {
        pPR = _aryPR.Append();
        if (!pPR)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = InitializeProviderRecord(pPR, hChapter, bstrField);
        if (hr)
            goto Cleanup;
    }

    // return the desired result
    *ppdsp = pPR->pdsp;
    if (*ppdsp)
        (*ppdsp)->AddRef();

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
// Member:      GetAccessorAndRowsetForField (CAdaptingProvider, private)
//
// Synopsis:    find the accessor for the chapter-valued column
//
// Arguments:   bstrField   name of chapter-valued field
//              phAccessor  where to store accessor
//              ppRowset    where to store field's referenced rowset
//
// Returns:     HRESULT


HRESULT
CAdaptingProvider::GetAccessorAndRowsetForField(BSTR bstrField,
                                        HACCESSOR *phAccessor, IRowset **ppRowset)
{
    HRESULT hr = S_OK;
    int i;
    CAccessorRecord *pAR;

    // prepare for failure
    if (phAccessor)
        *phAccessor = NULL;
    if (ppRowset)
        *ppRowset = NULL;

    // look up the field in the cache
    for (i=_aryAR.Size(), pAR=_aryAR;  i>0;  --i, ++pAR)
    {
        if (FormsStringCmp(bstrField, pAR->bstrField) == 0)
            break;
    }

    // if not in the cache, add it
    if (i == 0)
    {
        pAR = _aryAR.Append();
        if (!pAR)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = InitializeAccessorRecord(pAR, bstrField);
        if (hr)
            goto Cleanup;
    }

    // return the desired results
    if (phAccessor)
    {
        if (EnsureAccessorInAccessorRecord(pAR))
        {
            *phAccessor = pAR->hAccessor;
        }
        else
        {
            hr = E_FAIL;
        }
    }
    
    if (ppRowset)
    {
        if (EnsureRowsetInAccessorRecord(pAR))
        {
            *ppRowset = pAR->pRowset;
        }
        else
        {
            hr = E_FAIL;
        }
    }
    
Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
// Member:      InitializeProviderRecord (CAdaptingProvider, private)
//
// Synopsis:    initialize an entry in the _aryPR array that maps
//              <fieldname, chapter> to <provider>.
//
// Arguments:   pPR         pointer to entry that needs initializing
//              hChapter    chapter handle
//              bstrField   name of chapter-valued field
//
// Returns:     HRESULT


HRESULT
CAdaptingProvider::InitializeProviderRecord(CProviderRecord *pPR,
                        HCHAPTER hChapter, BSTR bstrField)
{
    HRESULT hr;
    IRowsetInfo *pRowsetInfo = NULL;
    IRowset *pChildRowset = NULL;

    // fill in entries with null (in case of error)
    FormsAllocString(bstrField, &pPR->bstrField);
    pPR->hChapter = hChapter;
    pPR->pdsp = NULL;

    // get the rowset to which the chapter applies
    hr = GetRowsetForField(bstrField, &pChildRowset);
    if (hr)
        goto Cleanup;

    // create a provider and stick it into the table
    hr = CreateSubProvider(this, pChildRowset, NULL, _pRowEvents->GetDataMemberManager(),
                            hChapter, DB_NULL_HROW, &pPR->pdsp);
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pRowsetInfo);

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
// Member:      InitializeAccessorRecord (CAdaptingProvider, private)
//
// Synopsis:    initialize an entry in the _aryAR array that maps
//              <fieldname> to <accessor, ordinal>.
//
// Arguments:   pAR         pointer to entry that needs initializing
//              bstrField   name of chapter-valued field
//
// Returns:     HRESULT


HRESULT
CAdaptingProvider::InitializeAccessorRecord(CAccessorRecord *pAR, BSTR bstrField)
{
    HRESULT hr;
    IColumnsInfo *pColumnsInfo = NULL;
    DBORDINAL cColumns;
    DBCOLUMNINFO *aColumnInfo = NULL;
    OLECHAR *pStringsBuffer = NULL;
    DBORDINAL i;

    FormsAllocString(bstrField, &pAR->bstrField);
    pAR->hAccessor = 0;
    pAR->pRowset = NULL;
    pAR->ulOrdinal = DB_INVALIDCOLUMN;

    // get the column info
    hr = _pRowset->QueryInterface(IID_IColumnsInfo, reinterpret_cast<void**>(&pColumnsInfo));
    if (hr)
        goto Cleanup;

    hr = pColumnsInfo->GetColumnInfo(&cColumns, &aColumnInfo, &pStringsBuffer);
    if (hr)
        goto Cleanup;

    // look up the desired column, make sure it's chapter-valued
    hr = E_FAIL;        // in case search fails
    for (i=0; i<cColumns; ++i)
    {
        if (FormsStringICmp(bstrField, aColumnInfo[i].pwszName) == 0)
            break;
    }
    if (i == cColumns)
        goto Cleanup;
    if ( !(aColumnInfo[i].dwFlags & DBCOLUMNFLAGS_ISCHAPTER) )
        goto Cleanup;

    pAR->ulOrdinal = i;
    hr = S_OK;

Cleanup:
    CoTaskMemFree(aColumnInfo);
    CoTaskMemFree(pStringsBuffer);
    ReleaseInterface(pColumnsInfo);

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
// Member:      EnsureAccessorInAccessorRecord (CAdaptingProvider, private)
//
// Synopsis:    make sure the accessor field is filled in
//
// Arguments:   pAR         the accessor record of interest
//
// Returns:     TRUE        if accessor field has a valid accessor

BOOL
CAdaptingProvider::EnsureAccessorInAccessorRecord(CAccessorRecord *pAR)
{
    HRESULT hr = S_OK;
    IAccessor *pAccessor = NULL;
    DBBINDING dbBinding;
    DBBINDSTATUS dbBindStatus;

    if (pAR->hAccessor != 0 || pAR->ulOrdinal == DB_INVALIDCOLUMN)
        goto Cleanup;
    
    hr = _pRowset->QueryInterface(IID_IAccessor, reinterpret_cast<void**>(&pAccessor));
    if (hr)
        goto Cleanup;

    dbBinding.iOrdinal = pAR->ulOrdinal;
    dbBinding.obValue = 0;
    dbBinding.dwPart = DBPART_VALUE;
    dbBinding.wType = DBTYPE_HCHAPTER;

    dbBinding.pTypeInfo = 0;
    dbBinding.pBindExt = 0;
    dbBinding.dwMemOwner = DBMEMOWNER_CLIENTOWNED;
    dbBinding.dwFlags = 0;
    
    hr = pAccessor->CreateAccessor(DBACCESSOR_ROWDATA, 1, &dbBinding, 0,
                                    &pAR->hAccessor, &dbBindStatus);
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pAccessor);
    return (pAR->hAccessor != 0);
}


//+-------------------------------------------------------------------------
// Member:      EnsureRowsetInAccessorRecord (CAdaptingProvider, private)
//
// Synopsis:    make sure the rowset field is filled in
//
// Arguments:   pAR         the accessor record of interest
//
// Returns:     TRUE        if rowset field has a valid rowset

BOOL
CAdaptingProvider::EnsureRowsetInAccessorRecord(CAccessorRecord *pAR)
{
    HRESULT hr = S_OK;
    IRowsetInfo *pRowsetInfo = NULL;

    if (pAR->pRowset != NULL || pAR->ulOrdinal == DB_INVALIDCOLUMN)
        goto Cleanup;
    
    hr = _pRowset->QueryInterface(IID_IRowsetInfo, reinterpret_cast<void**>(&pRowsetInfo));
    if (hr)
        goto Cleanup;

    hr = pRowsetInfo->GetReferencedRowset(pAR->ulOrdinal, IID_IRowset,
                                    reinterpret_cast<IUnknown**>(&pAR->pRowset));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pRowsetInfo);
    return (pAR->pRowset != NULL);
}


//+-------------------------------------------------------------------------
// Member:      Create (CAdaptingProvider, static)
//
// Synopsis:    create a sub-provider for a child rowset (for hierarchy)
//
// Arguments:   pChildRowset    child rowset on which to base provider
//              hChapter        chapter to restrict provider
//              ppdsp           where to store the result
//
// Returns:     HRESULT

HRESULT
CAdaptingProvider::CreateSubProvider(CAdaptingProvider *pProviderParent,
                                    IRowset *pChildRowset,
                                    IRowPosition *pChildRowPos,
                                    CDataMemberMgr *pdmm,
                                    HCHAPTER hChapter, HROW hrow,
                                    CDataSourceProvider **ppdsp)
{
    HRESULT hr = S_OK;
    CAdaptingProvider *pProvider;

    if (pChildRowPos)
    {
        pProvider = new CAdaptingProvider(pChildRowPos, hrow);
    }
    else
    {
        Assert(pChildRowset);
        pProvider = new CAdaptingProvider(pChildRowset);
    }
    
    if (pProvider)
    {
        *ppdsp = pProvider;
        pProvider->Init(pdmm, hChapter, pProviderParent);
    }
    else
        hr = E_OUTOFMEMORY;

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
// Member:      RemoveSubProvider (CAdaptingProvider, private)
//
// Synopsis:    remove a sub-provider from my tables
//
// Arguments:   pdsp            sub-provider to remove
//
// Returns:     nothing

void
CAdaptingProvider::RemoveSubProvider(CDataSourceProvider *pdsp)
{
    int i;
    CProviderRecord *pPR;
    Assert(pdsp);

    // look up <field, chapter> in my cache
    for (i=_aryPR.Size()-1, pPR=_aryPR+i;  i >= 0;  --i, --pPR)
    {
        if (pPR->pdsp == pdsp)
        {
            FormsFreeString(pPR->bstrField);
            pPR->pdsp->Release();
            _aryPR.Delete(i);
        }
    }
}


//+-------------------------------------------------------------------------
// Member:      UpdateProviderRecords (CAdaptingProvider, private)
//
// Synopsis:    Replace old <chapter, provider> by new one in my tables
//
// Returns:     HRESULT

HRESULT
CAdaptingProvider::UpdateProviderRecords(HCHAPTER hChapterOld, CDataSourceProvider *pdspOld,
                                HCHAPTER hChapterNew, CDataSourceProvider *pdspNew)
{
    int i, j;
    CProviderRecord *pPR;
    CChapterRecord *pCR;

    // find record for old provider
    for (i=_aryPR.Size()-1, pPR=_aryPR+i;  i >= 0;  --i, --pPR)
    {
        if (pPR->pdsp == pdspOld)
        {
            // it should correspond to the old chapter
            Assert(pPR->hChapter == hChapterOld);

            // replace it with the new chapter and provider
            pPR->hChapter = hChapterNew;
            pdspNew->AddRef();
            pdspOld->Release();
            pPR->pdsp = pdspNew;

            // update the chapter table
            for (j=_aryCR.Size()-1, pCR=_aryCR+j;  j>=0;  --j, --pCR)
            {
                if (pCR->hChapter == hChapterOld &&
                    FormsStringCmp(pPR->bstrField, pCR->bstrField) == 0)
                {
                    IRowset *pChildRowset = NULL;
                    if (S_OK == GetRowsetForField(pPR->bstrField, &pChildRowset)
                        && pChildRowset)
                    {
                        IChapteredRowset *pChapRowset = NULL;

                        if (S_OK == pChildRowset->QueryInterface(IID_IChapteredRowset,
                                                                 (void**)&pChapRowset)
                                && pChapRowset)
                        {
                            IGNORE_HR(pChapRowset->AddRefChapter(hChapterNew, NULL));
                            IGNORE_HR(pChapRowset->ReleaseChapter(pCR->hChapter, NULL));
                        }

                        ReleaseInterface(pChapRowset);
                    }
                    
                    pCR->hChapter = hChapterNew;
                }
            }
        }
    }

    RRETURN(S_OK);
}


//+-------------------------------------------------------------------------
// Member:      ChangeChapter (CAdaptingProvider, private)
//
// Synopsis:    change the chapter I get my data from
//
// Returns:     HRESULT

HRESULT
CAdaptingProvider::ChangeChapter(HCHAPTER hChapterNew, HROW hrowNew)
{
    HRESULT hr = S_OK;
    CDataSourceProvider *pProviderNew = NULL;

    AddRef();               // stabilize during this routine
    
    if (hChapterNew == _hChapter)
        goto Cleanup;
    
    if (_pProviderParent)   // Child provider.
    {
        // create a new provider tied to the new chapter
        hr = CreateSubProvider(_pProviderParent, NULL, _pRowPos,
                                _pRowEvents->GetDataMemberManager(),
                                hChapterNew, hrowNew, &pProviderNew);
        
        // tell my parent to update her records
        if (!hr)
            hr = _pProviderParent->UpdateProviderRecords(_hChapter, this,
                            hChapterNew, pProviderNew);

        // tell my clients to use the new provider
        if (!hr)
            hr = ReplaceProvider(pProviderNew);
    }

    else                    // Top-level provider
    {
        // change my chapter
        IChapteredRowset *pChapRowset = NULL;

        if (S_OK == _pRowset->QueryInterface(IID_IChapteredRowset,
                                             (void**)&pChapRowset)
                     && pChapRowset)
        {
            IGNORE_HR(pChapRowset->AddRefChapter(hChapterNew, NULL));
            IGNORE_HR(pChapRowset->ReleaseChapter(_hChapter, NULL));
            ReleaseInterface(pChapRowset);
        }

        // tell my clients to rebind
        hr = ReplaceProvider(this);
        
        _hChapter = hChapterNew;

        _fNeedRowEnter = (hrowNew != DB_NULL_HROW);
        _fRowEnterOK = FALSE;
        
        IGNORE_HR(_pCRI->InitChapter(_hChapter));
        _pMarkup->GetDataBindTask()->InitCurrentRecord(_pCRI);
    }
    
Cleanup:
    if (pProviderNew)
    {
        pProviderNew->Release();
    }
    Release();      // don't use (this) any more
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  Member:     FireDelayedRowEnter
//
//  Synopsis:   Fire onrowenter now, if there was reason to fire it during
//              startup and we haven't fired it yet.
//
//  Returns:    HRESULT

HRESULT
CAdaptingProvider::FireDelayedRowEnter()
{
    if (_fNeedRowEnter && _pRowEvents)
    {
        TraceTag((tagRowEvents, "%p -> onRowEnter", _pRowEvents->GetOwner()));
        FireDataEvent(&s_propdescCElementonrowenter);
    }
    
    _fNeedRowEnter = FALSE;
    _fRowEnterOK = TRUE;
    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Member:     FireDataEvent
//
//  Synopsis:   Fire one of the events we synthesize on data source objects:
//              datasetchanged, dataavail, datasetcomplete, rowenter, rowexit,
//              rowsinserted, rowsdelete, cellchange
//
//  Returns:    HRESULT

HRESULT
CAdaptingProvider::FireDataEvent(const PROPERTYDESC_BASIC *pDesc,
                                 BOOL *pfCancelled /* NULL */,
                                 long lReason /* 0 */)
{
    HRESULT         hr = S_OK;

    // if there's no _pRowEvents, there's no use trying
    if (_pRowEvents)
    {
        CDataMemberMgr * pdmm = _pRowEvents->GetDataMemberManager();
        CTreeNode *     pNodeContext = pdmm->GetOwner()->GetFirstBranch();
        CDoc *          pDoc = pdmm->Doc();
        CDoc *          pDocOSP = NULL;
        BOOL            fRet = TRUE;
        DISPID          dispidEvent = (DISPID)(pDesc->c);
        DISPID          dispidProp = pDesc->b.dispid;

        // look for Trident-as-OSP, attach param accordingly
        if (S_OK == pdmm->GetTridentAsOSP(&pDocOSP) && pDocOSP)
        {
            pDoc = pDocOSP;
        }
        EVENTPARAM      param(pDoc, pdmm->GetOwner(), NULL, TRUE);
        CDoc::CLock     Lock(pDoc);
    
        // set event parameters
        param.SetNodeAndCalcCoordinates(pNodeContext);
        param.SetType(pDesc->a.pstrName + 2);
        param.SetQualifier(_cstrDataMember);
        param._lReason      = lReason;
        param.pProvider     = this;

        AddRef();       // stabilize during event

        // if we're firing onrowexit, make sure we've enabled firing
        // onrowenter as well
        if (dispidEvent == DISPID_EVMETH_ONROWEXIT && !_fRowEnterOK)
        {
            FireDelayedRowEnter();
        }
        
        // fire the event
        if (pDocOSP)
        {   // Trident-as-OSP (note, pDocOSP is *not* refcounted)
            hr = THR(pDocOSP->FireEvent(pDocOSP,
                            pdmm->GetOwner(),
                            NULL,
                            dispidEvent,
                            dispidProp,
                            NULL,
                            &fRet));
        }
        else
        {   // normal DSO
            hr = pdmm->GetOwner()->FireEvent(
                        pDesc,
                        FALSE,
                        pNodeContext,
                        0);

            fRet = !!hr;
        }

        // see if it was cancelled
        if (pfCancelled)
        {
            *pfCancelled = !fRet;
        }

        Release();
    }
    
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:     get_bookmarks
//
//  Synopsis:   return a collection of ADO bookmarks corresponding to the
//              hrows affected by the current data change event
//
//  Returns:    HRESULT

HRESULT 
CAdaptingProvider::get_bookmarks(IHTMLBookmarkCollection **ppBookmarkCollection)
{
    HRESULT hr;
    CBookmarkCollection *pBmkColl = NULL;

    if (ppBookmarkCollection == NULL)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // create a collection
    pBmkColl = new CBookmarkCollection;
    if (pBmkColl == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    Assert(_pCRI);
    _pCRI->InitPosition();      // make sure _pRowPos has valid position

    // fill it with ADO bookmarks
    hr = pBmkColl->Init(_pRowEvents->_rghRows, _pRowEvents->_cRows, _pADO);
    if (hr)
        goto Cleanup;

    // return the answer
    hr = pBmkColl->QueryInterface(IID_IHTMLBookmarkCollection,
                                  (void**)ppBookmarkCollection);

Cleanup:
    ReleaseInterface(pBmkColl);
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  Member:     get_recordset
//
//  Synopsis:   return the ADO recordset for this provider's dataset
//
//  Returns:    HRESULT

HRESULT 
CAdaptingProvider::get_recordset(IDispatch **ppRecordset)
{
    return QueryDataInterface(IID_IADORecordset15, (void**)ppRecordset);
}


//+----------------------------------------------------------------------------
//
//  Member:     get_dataFld
//
//  Synopsis:   return the name of the data field changed in the current
//              oncellchange event
//
//  Returns:    HRESULT

HRESULT 
CAdaptingProvider::get_dataFld(BSTR *pbstrDataFld)
{
    HRESULT hr;
    
    if (pbstrDataFld)
    {
        if (_pRowEvents->_cColumns > 0)
        {
            LPCTSTR pchDataFld = NULL;
            CDataLayerCursor *pDLC = GetDLCursor();

            hr = pDLC ? pDLC->GetColumnNameFromNumber(_pRowEvents->_rgColumns[0],
                                                        &pchDataFld)
                      : E_FAIL;
            if (!hr)
                hr = FormsAllocString(pchDataFld, pbstrDataFld);
        }
        else
        {
            *pbstrDataFld = NULL;
            hr = S_OK;
        }
    }
    else
        hr = E_POINTER;

    RRETURN(hr);
}


/////-------------------------------------------------------------------/////
/////                   CDataSourceProvider methods                     /////
/////-------------------------------------------------------------------/////

//+-------------------------------------------------------------------------
// Member:      Create (CDataSourceProvider, static, public)
//
// Synopsis:    Factory method - creates an element's interface provider
//
// Arguments:   pelProvider     underlying element
//              ppdsp           where to put pointer to created provider object
//
// Returns:     S_OK            it worked
//              E_OUTOFMEMORY   amnesia

HRESULT
CDataSourceProvider::Create(CDataMemberMgr *pDMembMgr, CDoc *pDoc,
                            BSTR bstrDataMember, CDataSourceProvider **ppdsp)
{
    Assert(ppdsp);
    
    HRESULT hr = S_OK;
    IUnknown *punk = NULL;
    CAdaptingProvider * pAdaptingProvider = NULL;
    OLEDBSimpleProvider *pSTD;
    IRowset *pRowset;
    IVBDSC *pVBDSC;
    IRowPosition *pRowPos = NULL;
    HCHAPTER hChapter = DB_NULL_HCHAPTER;
    HROW hrow = DB_NULL_HROW;

    *ppdsp = NULL;                      // assume failure

    // get the databinding interface
    if (pDMembMgr)
    {
        // Check for NULL punk instead of HRESULT..
        IGNORE_HR(pDMembMgr->GetDataBindingInterface(bstrDataMember, &punk));
    }

    // match it to the ones we know about
    if (punk == NULL)
        *ppdsp = new CNullProvider(pDoc);
    else if (S_OK == punk->QueryInterface(IID_IRowPosition, (void**)&pRowPos) && pRowPos)
    {
        pRowPos->GetRowPosition(&hChapter, &hrow, NULL);
        pAdaptingProvider = new CAdaptingProvider(pRowPos, hrow);
    }
    else if (S_OK == punk->QueryInterface(IID_IRowset, (void**)&pRowset) && pRowset)
    {
        pAdaptingProvider = new CAdaptingProvider(pRowset);
        ReleaseInterface(pRowset);
    }
    else if (S_OK == punk->QueryInterface(IID_OLEDBSimpleProvider, (void**)&pSTD) && pSTD)
    {
        pAdaptingProvider = new CAdaptingProvider(pSTD);
        ReleaseInterface(pSTD);
    }
    else if (S_OK == punk->QueryInterface(IID_IVBDSC, (void**)&pVBDSC) && pVBDSC)
    {
        pAdaptingProvider = new CAdaptingProvider(pVBDSC);
        ReleaseInterface(pVBDSC);
    }
    else
        *ppdsp = new CNullProvider(pDoc);

    // return the answer (this must be done here;  see below)
    if (pAdaptingProvider)
    {
        *ppdsp = pAdaptingProvider;
    }

    // tell the new provider which data member he's attached to
    if (*ppdsp)
    {
        (*ppdsp)->_cstrDataMember.Set(bstrDataMember);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if (pAdaptingProvider)
    {
        // It's very important that *ppdsp be set before we call the Init routine,
        // because the Init may fire script events that could attempt to reference
        // the recordset, which would cause us to arrive here recursively unless
        // our caller's _pdspProvider has already been set.
        hr = pAdaptingProvider->Init(pDMembMgr, hChapter);
    }

    // release the chapter, if we got one
    ReleaseChapterAndRow(hChapter, hrow, pRowPos);
        
    ReleaseInterface(pRowPos);
    ReleaseInterface(punk);
    return hr;
}


//+-------------------------------------------------------------------------
// Member:      destructor (CDataSourceProvider, public)
//
// Synopsis:    release resources

CDataSourceProvider::~CDataSourceProvider()
{
    ClearInterface((IUnknown**)&_pADOClientSite);
}


//+-------------------------------------------------------------------------
// Member:      Release (CDataSourceProvider, public)
//
// Synopsis:    decrement refcount, and if it's 0 delete myself
//
// Returns:     new refcount

ULONG
CDataSourceProvider::Release()
{
    ULONG ulRefCount = --_ulRefCount;
    if (ulRefCount == 0)
        delete this;
    return ulRefCount;        
}


//+-------------------------------------------------------------------------
// Member:      Detach (CDataSourceProvider, public)
//
// Synopsis:    Detach my resources

void
CDataSourceProvider::Detach()
{
    ReplaceProvider(NULL);
    _aryAdvisees.DeleteAll();
}


//+-------------------------------------------------------------------------
// Member:      ADOClientSite (CDataSourceProvider, protected)
//
// Synopsis:    Return my ADO client site, creating it if necessary

CADOClientSite *
CDataSourceProvider::ADOClientSite()
{
    if (!_pADOClientSite)
    {
        _pADOClientSite = new CADOClientSite(Doc());
    }

    return _pADOClientSite;
}


//+-------------------------------------------------------------------------
// Member:      AdviseDataProviderEvents (CDataSourceProvider, public)
//
// Synopsis:    add a new advisee
//
// Returns:     HRESULT

HRESULT
CDataSourceProvider::AdviseDataProviderEvents(CDataSourceBinder *pdsb)
{
    HRESULT hr = S_OK;
    const int iEmpty = _aryAdvisees.Find(NULL);

    if (iEmpty != -1)
    {
        _aryAdvisees[iEmpty] = pdsb;
    }
    else
    {
        hr = THR(_aryAdvisees.Append(pdsb));
        if (hr)
            goto Cleanup;
    }
    
Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
// Member:      UnadviseDataProviderEvents (CDataSourceProvider, public)
//
// Synopsis:    remove an advisee
//
// Returns:     HRESULT

HRESULT
CDataSourceProvider::UnadviseDataProviderEvents(CDataSourceBinder *pdsb)
{
    HRESULT hr = S_OK;
    const int iIndex = _aryAdvisees.Find(pdsb);

    if (iIndex >= 0)
    {
        _aryAdvisees[iIndex] = NULL;
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
// Member:      ReplaceProvider (CDataSourceProvider, public)
//
// Synopsis:    I'm about to be replaced by a new provider.  Inform my advisees.
//
// Returns:     HRESULT

HRESULT
CDataSourceProvider::ReplaceProvider(CDataSourceProvider *pdspNewProvider)
{
    HRESULT hr = S_OK;
    int k;

    for (k=0; k<_aryAdvisees.Size(); ++k)
    {
        if (_aryAdvisees[k])
            _aryAdvisees[k]->ReplaceProvider(pdspNewProvider);
    }

    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  Member:     LoadBoundElementCollection
//
//  Synopsis:   load a collection with the elements bound to my dataset
//
//  Returns:    HRESULT

HRESULT 
CDataSourceProvider::LoadBoundElementCollection(CCollectionCache *pCollectionCache,
                                                long lIndex)
{
    HRESULT hr = S_OK;
    CDataSourceBinder **ppdsb;
    int i;
    
    for (ppdsb=_aryAdvisees, i=_aryAdvisees.Size();  i>0;  ++ppdsb, --i)
    {
        CElement *pBoundElement = (*ppdsb)->GetElementConsumer();
        
        hr = THR(pCollectionCache->SetIntoAry(lIndex, pBoundElement ));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\display\basictreeparentnode.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       basictreeparentnode.cxx
//
//  Contents:   A basic tree node with children.
//
//  Classes:    
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DISPPARENT_HXX_
#define X_DISPPARENT_HXX_
#include "dispparent.hxx"
#endif

#ifndef X_DISPSTRUCTURENODE_HXX_
#define X_DISPSTRUCTURENODE_HXX_
#include "dispstructurenode.hxx"
#endif

//
// tree balancing constants
//

#define DISP_AVERAGE_CHILDREN     50     // ave. # of children in new structure node
#define DISP_MAX_CHILDREN        100     // max. # of children allowed per node
#define DISP_STRUCTURE_DEVIATION   5     // acceptable deviation from average
#define DISP_STRUCTURE_MASK CDispNode::s_layerMask   // flag mask used to identify groups of children
                                                     // that can be turned into structured subtrees

//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::CountChildren
//              
//  Synopsis:   Count all the non-structure children belonging to this node.
//              
//  Arguments:  none
//              
//  Returns:    Count of all the non-structure children.
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

LONG
CDispParentNode::CountChildren() const
{
    long cChildren = 0;
    for (CDispNode* pChild = _pFirstChild; pChild; pChild = pChild->_pNext)
    {
        cChildren += (pChild->IsStructureNode())
            ? pChild->AsParent()->CountChildren()
            : 1;
    }
    
    return cChildren;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::InsertFirstChildNode
//              
//  Synopsis:   Insert the given node as the first child of this node,
//              descending through structure nodes as necessary.
//              
//  Arguments:  pNewChild       node to insert
//              
//  Returns:    TRUE if new node was inserted into a new location in the tree
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CDispParentNode::InsertFirstChildNode(CDispNode* pNewChild)
{
    // no other children
    if (_pFirstChild == NULL)
    {
        return InsertNodeAsOnlyChild(pNewChild);
    }
    
    // no structure nodes
    if (!_pFirstChild->IsStructureNode())
    {
        return _pFirstChild->InsertSiblingNode(pNewChild, before);
    }
    
    // descend into structure nodes
    CDispNode* pFirstChild = GetFirstChildNode();
    
    // pFirstChild can only be NULL if structure nodes only have destroyed
    // children.  This shouldn't happen due to the implementation of Destroy.
    Assert(pFirstChild != NULL);
    return pFirstChild->InsertSiblingNode(pNewChild, before);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::InsertLastChildNode
//              
//  Synopsis:   Insert the given node as the last child of this node,
//              descending through structure nodes as necessary.
//              
//  Arguments:  pNewChild       node to insert
//              
//  Returns:    TRUE if new node was inserted into a new location in the tree
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CDispParentNode::InsertLastChildNode(CDispNode* pNewChild)
{
    // no other children
    if (_pLastChild == NULL)
    {
        return InsertNodeAsOnlyChild(pNewChild);
    }
    
    // no structure nodes
    if (!_pLastChild->IsStructureNode())
    {
        return _pLastChild->InsertSiblingNode(pNewChild, after);
    }
    
    // descend into structure nodes
    CDispNode* pLastChild = GetLastChildNode();
    
    // pLastChild can only be NULL if structure nodes only have destroyed
    // children.  This shouldn't happen due to the implementation of Destroy.
    Assert(pLastChild != NULL);
    return pLastChild->InsertSiblingNode(pNewChild, after);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::InsertNodeAsOnlyChild
//              
//  Synopsis:   Insert a new node as the only child of this node.
//
//  Arguments:  pNew        node to be inserted as sibling of this node
//              
//  Returns:    TRUE if new node was inserted into a new location in the tree
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CDispParentNode::InsertNodeAsOnlyChild(CDispNode* pNew)
{
    Assert(pNew != NULL);
    Assert(_cChildren == 0 ||
           (_pFirstChild == pNew && _pLastChild == pNew));

    // shouldn't be inserting a structure node
    Assert(!pNew->IsStructureNode());
    
    // if new node is already in the tree, don't insert
    if (pNew == this || pNew == _pFirstChild)
        goto NoInsertion;
        
    // extract new sibling from its current location
    if (pNew->_pParent != NULL)
        pNew->ExtractFromTree();

    Assert(pNew->_pParent == NULL);
    Assert(pNew->_pPrevious == NULL);
    Assert(pNew->_pNext == NULL);
    Assert(_cChildren == 0 && 
           _pFirstChild == NULL &&
           _pLastChild == NULL);

    // link new child
    pNew->_pParent = this;
    pNew->_pPrevious = NULL;
    pNew->_pNext = NULL;
    
    // modify parent
    _cChildren++;
    _pFirstChild = _pLastChild = pNew;
    SetChildrenChanged();

    // recalc subtree starting with newly inserted node
    pNew->SetFlags(s_newInsertion | s_recalcSubtree);
    pNew->RequestRecalc();
    
    WHEN_DBG(VerifyTreeCorrectness();)

    pNew->SetInvalid();
    return TRUE;
    
NoInsertion:
    WHEN_DBG(VerifyTreeCorrectness();)
    return FALSE;
}


void
CDispParentNode::CollapseStructureNode()
{
    Assert(IsStructureNode() && _cChildren == 0);
    
    CDispParentNode* pNode = this;
    CDispParentNode* pParent;
    
    while (pNode->IsStructureNode() && pNode->_cChildren == 0)
    {
        pParent = pNode->_pParent;
        Assert(pParent != NULL);
        
        // remove this node from parent's list of children
        pParent->UnlinkChild(pNode);
        pNode->Delete();
        WHEN_DBG(pParent->VerifyChildrenCount();)

        pNode = pParent;
    }

    // this branch will need recalc
    pNode->RequestRecalc();
    pNode->SetChildrenChanged();
}


#if 0
//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::DestroyTreeWithPrejudice
//
//  Synopsis:   Destroy the entire tree in an optimal fashion without executing
//              any destructors.
//
//  Arguments:  none
//
//  Notes:      WARNING!  You must be sure that nothing holds a pointer to
//              any node in the tree before calling this method.
//
//----------------------------------------------------------------------------

void
CDispParentNode::DestroyTreeWithPrejudice()
{
    // traverse entire tree, blowing away everything without running any
    // destructors or calling any virtual methods
    CDispNode* pChild = this;
    CDispParentNode* pParent = NULL;

    while (pChild != NULL)
    {
        // find left-most descendant of this parent node
        while (pChild->IsParentNode())
        {
            pParent = pChild->AsParent();
            pChild = pParent->_pFirstChild;
            if (pChild == NULL)
                break;
            pParent->_pFirstChild = pChild->_pNext;
        }

        // blow away left-most leaf nodes at this level
        while (pChild != NULL && pChild->IsLeafNode())
        {
            CDispNode* pDeadChild = pChild;
            pChild = pChild->_pNext;
            pDeadChild->Delete();
        }

        // descend into tree if we found a parent node
        if (pChild != NULL)
        {
            pParent = pChild->AsParent();
            pParent->_pFirstChild = pChild->_pNext;
        }

        // go up a level in the tree if we ran out of nodes at this level
        else
        {
            Assert(pParent != NULL);
            pChild = pParent->_pParent;
            pParent->_cChildren   = 0;
            pParent->_pFirstChild = 0;
            pParent->_pLastChild  = 0;
            pParent->Delete();
        }
    }
}
#endif


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::UnlinkChildren
//              
//  Synopsis:   Unlink all children belonging to this node, and delete any
//              destroyed children.
//              
//  Arguments:  pFirstChild     first child to unlink
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispParentNode::UnlinkChildren(CDispNode* pFirstChild)
{
    CDispNode* pChild = (pFirstChild) ? pFirstChild : _pFirstChild;
    
    while (pChild != NULL)
    {
        // since we're unlinking this list, we have to remember the next child
        CDispNode* pNext = pChild->_pNext;
        
        // adjust parent's child count
        _cChildren--;
        
        // extract or delete
        if (!pChild->IsStructureNode() && pChild->IsOwned())
        {
            pChild->_pParent = NULL;
            pChild->_pPrevious = pChild->_pNext = NULL;
        }
        else
        {
            pChild->Delete();
        }
        
        pChild = pNext;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::RebalanceParentNode
//              
//  Synopsis:   Rebalance structured subtrees as necessary.
//
//  Note:       After call to this routine all the s_rebalance flags in "structure
//              subtree" are clean. The "structure subtree" means all structure
//              children of this node and of nodes of "structure subtree"
//----------------------------------------------------------------------------

void
CDispParentNode::RebalanceParentNode()
{
    Assert(!IsStructureNode() && ChildrenChanged() && HasChildren());
    
    // rebalance structure nodes
    if (_pFirstChild->IsStructureNode())
    {
        for (CDispNode* pChild = _pFirstChild; pChild; pChild = pChild->_pNext)
        {
            Assert(pChild->IsStructureNode());
            if (pChild->MustRebalance())
                pChild->AsParent()->RebalanceIfNecessary();
        }
        WHEN_DBG(VerifyChildrenCount();)
    }


    // quick check to see if restructuring is needed
    if (_cChildren <= DISP_MAX_CHILDREN)
        return;
    
    //
    // scan the children to see if restructuring is needed.  This has to be done
    // in a separate pass from the actual restructuring, in case we find a mixture of
    // large and small groups of similar children.  In this case, all the groups must
    // be restructured to maintain the invariant that structure nodes are never
    // siblings of non-structure nodes.
    // 

    // Note: the following restructuring can violate invariant mentioned above
    //       if InsertStructureNode will meet memory allocation failure
    //       (mikhaill 10/4/00)
    // TODO: improve it by allocating all structure nodes at once
    
    CDispNode* pStartNode = _pFirstChild;
    int structureFlags = pStartNode->MaskFlags(DISP_STRUCTURE_MASK);
    long cChildren = 1;
    CDispNode* pNode;
    CDispNode* pNext;
    BOOL fNeedRestructure = FALSE;
    
    for (pNode = pStartNode;
         pNode != NULL;
         pNode = pNext)
    {
        pNext = pNode->_pNext;
        
        if (pNext != NULL && pNext->MaskFlags(DISP_STRUCTURE_MASK) == structureFlags)
        {
            cChildren++;
        }
        else
        {
            if (cChildren > DISP_MAX_CHILDREN)
            {
                fNeedRestructure = TRUE;
                break;
            }
            if (pNext != NULL)
            {
                pStartNode = pNext;
                structureFlags = pNext->MaskFlags(DISP_STRUCTURE_MASK);
                cChildren = 1;
            }
        }
    }
    
    //
    // insert structure nodes for groups of children who share the same flag values
    // 

    if (fNeedRestructure)
    {
        pStartNode = _pFirstChild;
        structureFlags = pStartNode->MaskFlags(DISP_STRUCTURE_MASK);
        cChildren = 1;

        for (pNode = pStartNode;
             pNode != NULL;
             pNode = pNext)
        {
            pNext = pNode->_pNext;
            
            if (pNext != NULL && pNext->MaskFlags(DISP_STRUCTURE_MASK) == structureFlags)
            {
                cChildren++;
            }
            else
            {
                InsertStructureNode(pStartNode, pNode, cChildren);
                if (pNext != NULL)
                {
                    pStartNode = pNext;
                    structureFlags = pNext->MaskFlags(DISP_STRUCTURE_MASK);
                    cChildren = 1;
                }
            }
        }
    }
    
    WHEN_DBG(VerifyChildrenCount();)
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::CreateStructureNodes
//              
//  Synopsis:   Create the requested number of structure nodes in the given
//              array.
//              
//  Arguments:  ppNodeArray     array in which the nodes are returned
//              cNodes          how many nodes
//              
//  Returns:    FALSE if creation was unsuccessful in any way.
//              
//  Notes:      If FALSE is returned, all intermediate nodes must be deleted.
//              
//----------------------------------------------------------------------------

BOOL
CDispParentNode::CreateStructureNodes(
        CDispParentNode** ppNodeArray,
        long cNodes)
{
    for (long i = 0; i < cNodes; i++)
    {
        CDispStructureNode* pNewNode = CDispStructureNode::New();
        if (pNewNode != NULL)
        {
            ppNodeArray[i] = pNewNode;
        }
        else
        {
            // delete nodes already allocated and fail
            while (--i >= 0)
                ppNodeArray[i]->Destroy();
            return FALSE;
        }
    }
    
    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::InsertStructureNode
//              
//  Synopsis:   Replace the indicated group of children with a structured
//              subtree.
//              
//  Arguments:  pFirstNode          first child to include in structured subtree
//              pLastNode           last child to include in structured subtree
//              cChildren           amount of children to move under new
//                                  structure node, inluding pFirstNode and pLastNode
//----------------------------------------------------------------------------

void
CDispParentNode::InsertStructureNode(
        CDispNode* pFirstNode,
        CDispNode* pLastNode,
        long cChildren)
{
    CDispParentNode* pStrNode;
    if (!CreateStructureNodes(&pStrNode, 1))
        return;
    
    Assert(pStrNode->IsStructureNode());
    
    // set flags in structure node correctly
    int structureFlags = pFirstNode->MaskFlags(DISP_STRUCTURE_MASK);
    pStrNode->CopyFlags(structureFlags, DISP_STRUCTURE_MASK);

    // replace children with this structure node
    pStrNode->_pParent = this;
    pStrNode->_pPrevious = pFirstNode->_pPrevious;
    pStrNode->_pNext = pLastNode->_pNext;
    if (pFirstNode->_pPrevious != NULL)
    {
        pFirstNode->_pPrevious->_pNext = pStrNode;
        pFirstNode->_pPrevious = NULL;
    }
    else
    {
        _pFirstChild = pStrNode;
    }
    if (pLastNode->_pNext != NULL)
    {
        pLastNode->_pNext->_pPrevious = pStrNode;
        pLastNode->_pNext = NULL;
    }
    else
    {
        _pLastChild = pStrNode;
    }
    
    // structure node adopts the children it replaced
    pStrNode->_cChildren = cChildren;
    pStrNode->_pFirstChild = pFirstNode;
    pStrNode->_pLastChild = pLastNode;
    
    for (CDispNode* pChild = pFirstNode;
         pChild != pLastNode->_pNext;
         pChild = pChild->_pNext)
    {
        pChild->_pParent = pStrNode;
    }

    // parent loses these children but gains 1 structure node
    _cChildren -= cChildren - 1;

    WHEN_DBG(VerifyTreeCorrectness();)
    
    // now rebalance the new structure node
    if (cChildren > DISP_AVERAGE_CHILDREN)
    {
        pStrNode->Rebalance(cChildren);
    }
    else
    {
        pStrNode->CopyFlags(s_recalc, s_recalc);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::InsertNewStructureNode
//              
//  Synopsis:   Insert a new (childless) structure node as a child.
//              
//  Arguments:  pNodePrev           child that becomes predecessor of new node
//              pNodeNext           child that becomes successor of new node
//              structureFlags      value for flag bits
//              structureMask       mask for flag bits
//
//  Returns:    pointer to new structure node
//              
//----------------------------------------------------------------------------

CDispParentNode *
CDispParentNode::InsertNewStructureNode(
        CDispNode* pNodePrev,
        CDispNode* pNodeNext,
        int structureFlags,
        int structureMask)
{
    CDispParentNode* pStrNode;
    if (!CreateStructureNodes(&pStrNode, 1))
        return NULL;
    
    Assert(pStrNode->IsStructureNode());
    Assert(pNodePrev == NULL || (pNodePrev->_pParent == this && pNodePrev->_pNext == pNodeNext));
    Assert(pNodeNext == NULL || (pNodeNext->_pParent == this && pNodeNext->_pPrevious == pNodePrev));
    
    // set flags in structure node correctly
    pStrNode->CopyFlags(structureFlags, structureMask);

    // hook up new node into the tree
    pStrNode->_pParent = this;
    pStrNode->_pPrevious = pNodePrev;
    pStrNode->_pNext = pNodeNext;
    if (pNodePrev)
        pNodePrev->_pNext = pStrNode;
    if (pNodeNext)
        pNodeNext->_pPrevious = pStrNode;

    // set new node's child info
    pStrNode->_cChildren = 0;
    pStrNode->_pFirstChild = NULL;
    pStrNode->_pLastChild = NULL;

    // update this node's child info: one more child, which may be first or last
    _cChildren++;
    if (pNodePrev == NULL)
        _pFirstChild = pStrNode;
    if (pNodeNext == NULL)
        _pLastChild = pStrNode;

    WHEN_DBG(VerifyTreeCorrectness();)

    return pStrNode;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::GetStructureInfo
//              
//  Synopsis:   Prepare for rebalancing and gather relevant balancing data.
//              
//  Arguments:  pfMustRebalance     returns TRUE if balancing is required
//              pcNonStructure      returns count of non structure descendants
//                              
//  Returns:    number of immediate children belonging to this node
//              
//----------------------------------------------------------------------------

long
CDispParentNode::GetStructureInfo(BOOL* pfMustRebalance, long* pcNonStructure)
{
    Assert(IsStructureNode());
    
    Assert(_cChildren > 0);
    long cTotalGrandchildren = 0;
    long cMaxGrandchildren = MINLONG;
    long cMinGrandchildren = MAXLONG;
    
    CDispNode* pChild = _pFirstChild;
    while (pChild != NULL)
    {
        if (pChild->IsStructureNode())
        {
            long cGrandchildren =
                pChild->AsParent()->GetStructureInfo(pfMustRebalance, pcNonStructure);
            
            if (cGrandchildren > cMaxGrandchildren)
                cMaxGrandchildren = cGrandchildren;
            if (cGrandchildren < cMinGrandchildren)
                cMinGrandchildren = cGrandchildren;
            cTotalGrandchildren += cGrandchildren;
        }
        else
        {
            (*pcNonStructure)++;
        }
        pChild = pChild->_pNext;
    }
    
    long cAverageGrandchildren = cTotalGrandchildren / _cChildren;
    
    if (_cChildren > DISP_MAX_CHILDREN ||
        cMaxGrandchildren > cAverageGrandchildren + DISP_STRUCTURE_DEVIATION ||
        cMinGrandchildren < cAverageGrandchildren - DISP_STRUCTURE_DEVIATION)
    {
        *pfMustRebalance = TRUE;
    }
    
    ClearFlag(s_rebalance);
    
    return _cChildren;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::RebalanceIfNecessary
//              
//  Synopsis:   Rebalance the subtree rooted at this structure node if
//              rebalancing is actually needed.
//              
//----------------------------------------------------------------------------

void
CDispParentNode::RebalanceIfNecessary()
{
    Assert(IsStructureNode());
    Assert(MustRebalance());
    
    BOOL fMustRebalance = FALSE;
    long cNonStructure = 0;
    GetStructureInfo(&fMustRebalance, &cNonStructure);
    
    if (fMustRebalance)
        Rebalance(cNonStructure);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::GetNextSiblingNodeOf
//              
//  Synopsis:   Find the right nearest node, descending as necessary
//              through structure nodes.
//
//  Arguments:  pNode: ptr to node which sibling is to be found
//
//  Returns:    ptr to next sibling or NULL
//
//  Note:       this routine is almost the same as CDispNode::GetNextSiblingNode.
//              The only difference is tree ascending is limited with "this" node
//              (while CDispNode::GetNextSiblingNode stops ascending
//              when meet any non-structure node).
//----------------------------------------------------------------------------
__forceinline CDispNode*
CDispParentNode::GetNextSiblingNodeOf(CDispNode* pNode) const
{
    if (pNode->_pNext) return pNode->_pNext;

    // ascending to next level of tree
    for (pNode = pNode->_pParent; ; pNode = pNode->_pParent)
    {
        if (pNode->AsParent() == this) return 0;
        if (pNode->_pNext) break;
    }
    
    pNode = pNode->_pNext;
    Assert(pNode->IsStructureNode());

    // descending into structure nodes
    do
    {
        pNode = pNode->AsParent()->_pFirstChild;
        Assert(pNode);
    }
    while (pNode->IsStructureNode());

    return pNode;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::Rebalance
//              
//  Synopsis:   Rebalance the subtree rooted at this structure node.
//              
//  Arguments:  cChildren           the total number of non-structure
//                                  descendents in this subtree
//                              
//  Notes:      This routine is somewhat tricky.  One of the goals in its
//              design was to avoid excessive memory allocation.
//              
//----------------------------------------------------------------------------

void
CDispParentNode::Rebalance(long cChildren)
{
    Assert(IsStructureNode());

    // how many structure nodes will we need?
    long cNodes = cChildren;
    long cTotalStrNodes = 0;
    do
    {
        // calculate number of structure nodes on the next level of the tree
        cNodes = (cNodes + DISP_AVERAGE_CHILDREN - 1) / DISP_AVERAGE_CHILDREN;
        cTotalStrNodes += cNodes;
    } while (cNodes > DISP_AVERAGE_CHILDREN);
    
    // allocate structure nodes
    CDispParentNode** ppStrNodes = new CDispParentNode* [cTotalStrNodes+1];
    if(!ppStrNodes)
        return;
    if (!CreateStructureNodes(ppStrNodes, cTotalStrNodes))
    {
        delete [] ppStrNodes;
        return;
    }
    
    // we add this structure node to the array of structure nodes, so that its
    // new children will be linked into it as the final step of our rebalancing
    // algorithm
    ppStrNodes[cTotalStrNodes] = this;
    
    // set recalc flag on all structure nodes
    int strFlags = MaskFlags(DISP_STRUCTURE_MASK) | s_recalc;
    int strMask  =           DISP_STRUCTURE_MASK  | s_recalc;
    
    long i = 0;
    CDispNode* pChild = GetFirstChildNode();
    
    // calculate number of structure nodes at the base level
    long cStrNodes = (cChildren + DISP_AVERAGE_CHILDREN - 1) / DISP_AVERAGE_CHILDREN;
    Assert(cStrNodes > 0);
    long cChildrenPerNode = cChildren / cStrNodes;
    Assert(cChildrenPerNode > 0);
    long cExtraChildren = cChildren - cStrNodes * cChildrenPerNode;
    
    for (i = 0; i < cStrNodes; i++)
    {
        // get next structure node and calculate how many children it gets
        CDispParentNode* pStrNode = ppStrNodes[i];
        Assert(pStrNode != NULL && pStrNode->IsStructureNode());
        pStrNode->CopyFlags(strFlags, strMask);
        pStrNode->_cChildren = cChildrenPerNode;
        if (cExtraChildren > 0)
        {
            (pStrNode->_cChildren)++;
            cExtraChildren--;
        }
        
        // adopt first child
        Assert(pChild != NULL);
        pStrNode->_pFirstChild = pChild;
        
        // move children to structure node
        CDispNode* pPrevious = NULL;
        for (long j = 0; j < pStrNode->_cChildren; j++)
        {
            Assert(pChild != NULL);
            CDispNode* pNext = GetNextSiblingNodeOf(pChild);
            pChild->_pParent = pStrNode;
            pChild->_pPrevious = pPrevious;
            pPrevious = pChild;
            pChild = pNext;
            pPrevious->_pNext = pChild;
        }
        
        // adopt last child
        Assert(pPrevious != NULL);
        pStrNode->_pLastChild = pPrevious;
        pPrevious->_pNext = NULL;
    }
    
    // we better have moved all the children
    Assert(pChild == NULL && cExtraChildren == 0);
        
    // delete old structure nodes
    DeleteStructureNodes();
    
    // adopt each new layer of structure nodes
    long cAdoptChild = 0;
    do
    {
        // calculate number of structure nodes on the next level of the tree
        cChildren = cStrNodes;
        cStrNodes = (cChildren + DISP_AVERAGE_CHILDREN - 1) / DISP_AVERAGE_CHILDREN;
        Assert(cStrNodes > 0);
        cChildrenPerNode = cChildren / cStrNodes;
        Assert(cChildrenPerNode > 0);
        cExtraChildren = cChildren - cStrNodes * cChildrenPerNode;
        
        for (long j = 0; j < cStrNodes; j++)
        {
            CDispParentNode* pStrNode = ppStrNodes[i++];
            Assert(pStrNode != NULL && pStrNode->IsStructureNode());
            pStrNode->CopyFlags(strFlags, strMask);
            pStrNode->_cChildren = cChildrenPerNode;
            if (cExtraChildren > 0)
            {
                (pStrNode->_cChildren)++;
                cExtraChildren--;
            }
            
            // adopt first child
            pChild = ppStrNodes[cAdoptChild];
            pStrNode->_pFirstChild = pChild;
            
            // move children to structure node
            CDispNode* pPrevious = NULL;
            for (long k = 0; k < pStrNode->_cChildren; k++)
            {
                CDispParentNode* pNext = ppStrNodes[++cAdoptChild];
                pChild->_pParent = pStrNode;
                pChild->_pPrevious = pPrevious;
                pPrevious = pChild;
                pChild = pNext;
                pPrevious->_pNext = pChild;
            }
            
            // adopt last child
            Assert(pPrevious != NULL);
            pStrNode->_pLastChild = pPrevious;
            pPrevious->_pNext = NULL;
        }
    } while (cAdoptChild < cTotalStrNodes);

    delete [] ppStrNodes;

    WHEN_DBG(VerifyTreeCorrectness();)
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::DeleteStructureNodes
//              
//  Synopsis:   Recursively delete unused structure nodes under this
//              structure node after we've finished rebalancing
//              a structured subtree.
//              
//  Arguments:  none
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispParentNode::DeleteStructureNodes()
{
    Assert(IsStructureNode());
    Assert(_pFirstChild != NULL);

    if (_pFirstChild->IsStructureNode())
    {
        CDispParentNode* pStrNode;
        CDispParentNode* pNext;
        for (pStrNode = _pFirstChild->AsParent();
             pStrNode != NULL;
             pStrNode = pNext)
        {
            Assert(pStrNode->IsStructureNode());
            
            pNext = pStrNode->_pNext->AsParent();
            pStrNode->DeleteStructureNodes();
            
            // ensure that destructor for structure node doesn't try to
            // delete children
            pStrNode->_cChildren   = 0;
            pStrNode->_pFirstChild = 0;
            pStrNode->_pLastChild  = 0;
            pStrNode->Delete();
        }
    }
}


#if DBG==1
//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::VerifyChildrenCount
//              
//  Synopsis:   Verify that this parent node has the correct number of
//              non-destroyed children.
//              
//  Arguments:  none
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispParentNode::VerifyChildrenCount()
{
    long cChildren = 0;
    for (CDispNode* pChild = _pFirstChild;
         pChild != NULL;
         pChild = pChild->_pNext)
    {
        cChildren++;
    }
    
    Assert(cChildren == _cChildren);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\display\dispcontainer.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       dispcontainer.cxx
//
//  Contents:   Basic container node which introduces a new coordinate system
//              and clipping.
//
//  Classes:    CDispContainer
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DISPCONTAINER_HXX_
#define X_DISPCONTAINER_HXX_
#include "dispcontainer.hxx"
#endif

#ifndef X_DISPLEAFNODE_HXX_
#define X_DISPLEAFNODE_HXX_
#include "displeafnode.hxx"
#endif

#ifndef X_DISPROOT_HXX_
#define X_DISPROOT_HXX_
#include "disproot.hxx"
#endif

#ifndef X_DISPCONTAINER_HXX_
#define X_DISPCONTAINER_HXX_
#include "dispcontainer.hxx"
#endif

#ifndef X_DISPINFO_HXX_
#define X_DISPINFO_HXX_
#include "dispinfo.hxx"
#endif

#ifndef X_DISPSURFACE_HXX_
#define X_DISPSURFACE_HXX_
#include "dispsurface.hxx"
#endif

#ifndef X_DISPCLIENT_HXX_
#define X_DISPCLIENT_HXX_
#include "dispclient.hxx"
#endif

#ifndef X_DISPFILTER_HXX_
#define X_DISPFILTER_HXX_
#include "dispfilter.hxx"
#endif

#ifndef _PAINTER_H_
#define _PAINTER_H_
#include "painter.h"
#endif

MtDefine(CDispContainer, DisplayTree, "CDispContainer")


//+---------------------------------------------------------------------------
//
//  Member:     CDispContainer::CDispContainer
//
//  Synopsis:   Construct a container node with equivalent functionality to
//              the CDispLeafNode passed as an argument.
//
//  Arguments:  pLeafNode       the prototype CDispLeafNode
//
//  Notes:
//
//----------------------------------------------------------------------------


CDispContainer::CDispContainer(const CDispLeafNode* pLeafNode)
        : CDispParentNode(pLeafNode->GetDispClient())
{
    // copy size and position
    pLeafNode->GetBounds(&_rcpContainer);

    // copy relevant flags
    CopyFlags(pLeafNode->GetFlags(), s_layerMask |
                                     s_visibleNode |
                                     s_owned | 
                                     s_hasBackground |
                                     s_noScrollBounds |
                                     s_drawnExternally);
    Assert(!IsStructureNode());
    Assert(IsParentNode());

    // Container's effective origin is calculated differently from 
    // leaf node's (in fact, it is always zero). Update origin with 
    // current values to force recalculation
    if (HasContentOrigin())
    {
        SetContentOrigin(GetContentOrigin(), GetContentOffsetRTL());
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispContainer::SetSize
//
//  Synopsis:   Set size of this node.
//
//  Arguments:  sizep               new size in parent coords
//              fInvalidateAll      TRUE to entirely invalidate this node
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispContainer::SetSize(
        const CSize& sizep,
        const CRect *prcpMapped,
        BOOL fInvalidateAll)
{
    if (prcpMapped)
    {
        if (!HasAdvanced())
            SetUpAdvancedDisplay();
        if (HasAdvanced())
            GetAdvanced()->SetMappedBounds(prcpMapped);
    }
    else
    {
        if (HasAdvanced())
            GetAdvanced()->SetNoMappedBounds();
    }

    if (sizep == _rcpContainer.Size())
        return;

    if (!IsInvalid() && IsVisible() && IsInView() && (fInvalidateAll || HasUserTransform()))
    {
       // Invalidate the old rect
        Invalidate();
    }  

    CRect rcpOld(_rcpContainer);
    _rcpContainer.SetSize(sizep);

    // for RTL nodes, keep orinal content right-aligned by adjusting content offset
    if (HasContentOrigin() && GetContentOffsetRTL() >= 0)
    {
        // this recalculates offset from left and invalidates if necessary
        SetContentOrigin(GetContentOrigin(), GetContentOffsetRTL());
    }
    

    // if the inval flag is set, we don't need to invalidate because the
    // current bounds might never have been rendered
    if (!IsInvalid())
    {
        // recalculate in-view flag of all children
        RequestRecalcSubtree();

        if (HasWindowTop())
        {
            InvalidateAtWindowTop();
            SetInvalid();
        }
        else if (IsInView())
        {
            if (fInvalidateAll || HasUserTransform())
            {
                SetInvalid();                           // inval new bounds
            }
            else
            {
                CRect rcbBorderWidths;
                GetBorderWidths(&rcbBorderWidths);
                InvalidateEdges(rcpOld.Size(), sizep, rcbBorderWidths);
            }
        }
        else
        {
            SetInvalid();
        }
    }

    GetDispClient()->OnResize(sizep, this);
    WHEN_DBG(VerifyRecalc());
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispContainer::SetPosition
//
//  Synopsis:   Set the top left position of this container.
//
//  Arguments:  ptpTopLeft      top left coordinate of this container
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispContainer::SetPosition(const CPoint& ptpTopLeft)
{
    if (_rcpContainer.TopLeft() != ptpTopLeft)
    {
        // TODO (donmarsh) - I believe we are recalcing the entire
        // subtree to compute new inview status, but this seems like
        // overkill.  We may be able to improve perf by being a little
        // smarter here.
        InvalidateAndRecalcSubtree();
        
        Assert(MustRecalc());

        _rcpContainer.MoveTo(ptpTopLeft);
        // _rctBounds will be recomputed during recalc
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispContainer::GetClientRect
//
//  Synopsis:   Return rectangles for various interesting parts of a display
//              node.
//
//  Arguments:  prc         rect which is returned
//              type        type of rect wanted
//
//  Notes:      WARNING: the coordinate system of the returned rect depends
//              on the type!
//
//----------------------------------------------------------------------------

void
CDispContainer::GetClientRect(RECT* prc, CLIENTRECT type) const
{
    switch (type)
    {
    case CLIENTRECT_BACKGROUND:
    case CLIENTRECT_CONTENT:
        {
            CRect rcbBorderWidths;
            GetBorderWidths(&rcbBorderWidths);
            
            ((CRect*)prc)->SetRect(
                _rcpContainer.Size()
                - rcbBorderWidths.TopLeft().AsSize()
                - rcbBorderWidths.BottomRight().AsSize());

            // RTL nodes may have non-zero content origin
            if (HasContentOrigin())
            {
                ((CRect*)prc)->OffsetRect(-GetContentOrigin());
            }

            // NOTE: we check emptiness for each individual dimension instead
            // of simply assigning g_Zero.rc, because the layout code uses
            // values from the non-empty dimension in certain circumstances
            if (prc->left >= prc->right)
                prc->left = prc->right = 0;
            if (prc->top >= prc->bottom)
                prc->top = prc->bottom = 0;
        }
        break;
    default:
        *prc = g_Zero.rc;
        break;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispContainer::PreDraw
//
//  Synopsis:   Before drawing starts, PreDraw processes the redraw region,
//              subtracting areas that are blocked by opaque or buffered items.
//              PreDraw is finished when the redraw region becomes empty
//              (i.e., an opaque item completely obscures all content below it)
//
//  Arguments:  pContext    draw context, in COORDSYS_TRANSFORMED
//
//  Returns:    TRUE if first opaque node to draw has been found
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
CDispContainer::PreDraw(CDispDrawContext* pContext)
{
    // Interesting nodes are visible, in-view, opaque
    Assert(IsAllSet(s_preDrawSelector));
    Assert(pContext->IntersectsRedrawRegion(_rctBounds));
    Assert(!IsAnySet(s_flagsNotSetInDraw));

    // We do not delve inside a node whose content is drawn externally.
    // TODO (sambent) Someday, filters may help determine whether PreDraw
    // can safely look at its children and come up with the correct answers.
    if (IsDrawnExternally())
        return FALSE;
    
    // TODO (donmarsh) - subtracting transformed nodes (or their transformed
    // children) from the redraw region is too expensive.  This is overkill, and
    // will degrade the performance of Print Preview, for example.  However, we
    // may be able to do a one-time hack for a transformation at the root of
    // the Display Tree, and thus get back opaque optimizations for the case
    // where the whole view is scaled (but not rotated!)
    if (HasUserTransform())
        return FALSE;
    
    // save current transform
    CDispClipTransform saveTransform(pContext->GetClipTransform());
    if (!TransformedToBoxCoords(&pContext->GetClipTransform(), pContext->GetRedrawRegion()))
    {
        pContext->SetClipTransform(saveTransform);
        return FALSE;
    }
    
    // offset children
    CDispInfo di;
    CalcDispInfo(pContext->GetClipRect(), &di);
    TransformBoxToContent(&pContext->GetClipTransform(), di);
    CDispClipTransform saveContentTransform(pContext->GetClipTransform());

    // continue predraw traversal of children, top layers to bottom
    int lastLayer = s_layerMask;  // greater than any possible value
    for (CDispNode* pChild = _pLastChild; pChild; pChild = pChild->_pPrevious)
    {
        // only children which meet our selection criteria
        if (pChild->IsAllSet(s_preDrawSelector))
        {
            // switch clip rectangles and offsets between different layer types
            int childLayer = pChild->GetLayer();
            if (childLayer != lastLayer)
            {
                Assert(lastLayer > childLayer);

                if (childLayer < s_layerFlow)
                {
                    Assert(childLayer == s_layerNegZ);
                    pContext->SetClipTransform(saveContentTransform);
                }
                else if (childLayer == s_layerFlow)
                {
                    TransformContentToFlow(&pContext->GetClipTransform(), di);
                }
                else
                {
                    Assert(childLayer == s_layerPosZ);
                }

                lastLayer = childLayer;
            }

            // if we found the first child to draw, stop further PreDraw calcs
            if (PreDrawChild(pChild, pContext, saveTransform))
                return TRUE;
        }
    }

    // restore previous transform
    pContext->SetClipTransform(saveTransform);
    
    // if this container is opaque, check to see if it needs to be subtracted
    // from the redraw region
    return
        IsOpaque() &&
        pContext->IntersectsRedrawRegion(_rcpContainer) &&
        CDispNode::PreDraw(pContext);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispContainer::DrawSelf
//
//  Synopsis:   Draw this node's children, plus optional background.
//
//  Arguments:  pContext        draw context, in COORDSYS_BOX
//              pChild          start drawing at this child
//              lDrawLayers     layers to draw (for filters)
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispContainer::DrawSelf(CDispDrawContext* pContext, CDispNode* pChild, long lDrawLayers)
{
    // Interesting nodes are visible, in-view, opaque
    Assert(IsAllSet(pContext->GetDrawSelector()));
    Assert(!IsAnySet(s_flagsNotSetInDraw));
    Assert(!HasUserTransform() || !IsSet(s_savedRedrawRegion));

    // calculate clip and position info
    CDispInfo di;
    CalcDispInfo(pContext->GetClipRect(), &di);

    // prepare to run the draw program
    CRect rccContent(di._sizecBackground);
    CRect rccClip;
    CDispClipTransform transformBox;

    // fSkipToContent flag is to distinguish full draw pass (fSkipToContent == false)
    // from partial one (fSkipToContent == true). Partial pass arrears as a result
    // of PreDraw() optimization.
    BOOL fSkipToContent = (pChild != NULL);

    // draw children, bottom layers to top
    if (pChild == NULL)
        pChild = _pFirstChild;

    // find out which draw program to run
    CAryDrawProgram aryProgram;
    CAryDrawCookie aryCookie;
    if (S_OK != GetDrawProgram(&aryProgram, &aryCookie, lDrawLayers))
    {
        AssertSz(0, "Failed to get draw program");
        return;
    }

    if (HasAdvanced())
    {
        transformBox = pContext->GetClipTransform();
    }

    int iCookie = -1;
    void * cookie = NULL;
    BOOL fExpand = FALSE;
    CRect rcExpand = g_Zero.rc; // keep compiler happy

    // run the program
    for (int iPC = DP_START_INDEX;  aryProgram[iPC] != DP_Done;  ++iPC)
    {
        switch (aryProgram[iPC])
        {
        case DP_DrawBorder:
            // draw optional border
            //Assert(pContext is in box coords);
            DrawBorder(pContext, *di._prcbBorderWidths, GetDispClient());
            break;

        case DP_DrawBackground:
            //Assert(pContext is in box coords);
            if (HasBackground() && !fSkipToContent)
            {
                DrawBackground(pContext, di);
            }
            // fall through to BoxToContent

        case DP_BoxToContent:
            TransformBoxToContent(&pContext->GetClipTransform(), di);
            break;

        case DP_DrawContent:
            {
                DISPNODELAYER layerType = (DISPNODELAYER)aryProgram[++iPC];
                int layerStop = layerType >= DISPNODELAYER_POSITIVEZ ? s_layerPosZ
                              : layerType >= DISPNODELAYER_FLOW      ? s_layerFlow
                              : layerType >= DISPNODELAYER_NEGATIVEZ ? s_layerNegZ
                              : -1;
                while (pChild && pChild->GetLayer() <= layerStop)
                {
                    if (pChild->IsFlowNode())
                    {
                        CDispClipTransform saveTransform = pContext->GetClipTransform();
                        TransformContentToFlow(&pContext->GetClipTransform(), di);
                        DrawChildren(pContext, &pChild);
                        pContext->SetClipTransform(saveTransform);
                    }
                    else
                        DrawChildren(pContext, &pChild);
                    fSkipToContent = false;
                }
            }
            break;

        case DP_Expand:
            fExpand = TRUE;
            rcExpand.top    = aryProgram[++iPC];
            rcExpand.left   = aryProgram[++iPC];
            rcExpand.bottom = aryProgram[++iPC];
            rcExpand.right  = aryProgram[++iPC];
            break;

        case DP_DrawPainterMulti:
            Assert(HasAdvanced());
            cookie = aryCookie[++iCookie];
            // fall through to DP_DrawPainter

        case DP_DrawPainter:
            // Assert(pContext is in content coords);
            if (!fSkipToContent)
            {
                if (!fExpand)
                {
                    rccClip = di._rccBackgroundClip;
                    
                    GetDispClient()->DrawClientLayers(
                        &rccContent,
                        &rccClip,
                        pContext->PrepareDispSurface(),
                        this,
                        cookie,
                        pContext,
                        CLIENTLAYERS_AFTERBACKGROUND);
                }
                else
                {
                    Assert(HasAdvanced());
                    CSaveDispClipTransform transformSaveContent(pContext);
                    CRect rcbBounds = _rcpContainer.Size();
                    GetMappedBounds(&rcbBounds);
                    
                    pContext->SetClipTransform(transformBox);
                    rcbBounds.Expand(rcExpand);
                    CRect rcbClip = rcbBounds;
                    rcbClip.IntersectRect(transformBox.GetClipRect());
                    
                    GetDispClient()->DrawClientLayers(
                        &rcbBounds,
                        &rcbClip,
                        pContext->PrepareDispSurface(),
                        this,
                        cookie,
                        pContext,
                        CLIENTLAYERS_AFTERBACKGROUND);
                }
            }
            cookie = NULL;
            fExpand = FALSE;
            break;

        case DP_WindowTopMulti:     ++iCookie;  // ignore cookie
        case DP_WindowTop:
            if (!HasWindowTop())
            {
                pContext->GetRootNode()->AddWindowTop(this);
            }
            fExpand = FALSE;
            break;

        default:
            AssertSz(0, "Unrecognized draw program opcode");
            break;
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispContainer::DrawChildren
//              
//  Synopsis:   Draw children for a particular layer, starting at the indicated
//              child.
//              
//  Arguments:  pContext    draw context, coordinate system neutral
//              ppChildNode [in] child to start drawing, if it is in the
//                          requested layer
//                          [out] child in next layer (may be NULL)
//              
//  Notes:      
//              
//----------------------------------------------------------------------------
void
CDispContainer::DrawChildren(
        CDispDrawContext* pContext,
        CDispNode** ppChildNode)
{
    CDispNode* pChild = *ppChildNode;
    Assert(pChild);
    if(!pChild || !pContext)
        return;

    int layer = pChild->GetLayer();
    
    do
    {
        // is this child visible and in view?
        if (pChild->IsAllSet(pContext->GetDrawSelector()))
            pChild->Draw(pContext, NULL, FILTER_DRAW_ALLLAYERS);
        
        pChild = pChild->_pNext;
    }
    while (pChild != NULL && pChild->GetLayer() == layer);
    
    // remember new child pointer for subsequent layers
    *ppChildNode = pChild;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispContainer::HitTestPoint
//
//  Synopsis:   Determine whether any of our children, OR THIS CONTAINER,
//              intersects the hit test point.
//
//  Arguments:  pContext        hit context, in COORDSYS_TRANSFORMED
//              fForFilter      TRUE when we're called from a filter
//              fHitContent     TRUE to hit contents of this container,
//                              regardless of this container's bounds
//                              
//  Returns:    TRUE if any child or this container intersects the hit test pt.
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
CDispContainer::HitTestPoint(CDispHitContext* pContext, BOOL fForFilter, BOOL fHitContent)
{
    Assert(IsVisibleBranch());
    
    //
    // FATHIT. Fix for Bug 65015 - enabling "Fat" hit testing on tables.
    // TODO - At some point the edit team may want to provide
    // a better UI-level way of selecting nested "thin" tables
    //
    //
    // TODO - when this is done revert sig. of FuzzyRectIsHit to not take the extra param
    //
    Assert(fHitContent || fForFilter || pContext->FuzzyRectIsHit(_rctBounds, IsFatHitTest()));

    CDispClipTransform transformSaveTransformed(pContext->GetClipTransform());
    TransformedToBoxCoords(&pContext->GetClipTransform());
    CDispClipTransform boxTransform(pContext->GetClipTransform());
    BOOL               fPeerDeclinedHit = FALSE;

    //
    // Save the current coordinate system
    //
    COORDINATE_SYSTEM csSave = pContext->GetHitTestCoordinateSystem();

    // calculate clip and position info
    CDispInfo di;
    CalcDispInfo(pContext->GetClipRect(), &di);

    // open up clipping rect for children if we are hitting contents
    // regardless of this container's bounds
    if (fHitContent)
    {
        di._rccPositionedClip = di._rcfFlowClip = di._rcbContainerClip;
    }
    
    CRect rccContent(di._sizecBackground);

    // transform to content coordinates
    TransformBoxToContent(&pContext->GetClipTransform(), di);
    CDispClipTransform contentTransform(pContext->GetClipTransform());

    // hack for VID's "frozen" attribute
    {
        CPoint ptcHitTest;
        pContext->GetHitTestPoint(&ptcHitTest);
        if (GetDispClient()->HitTestBoxOnly(
                &ptcHitTest,
                this,
                pContext->_pClientData))
        {
            // NOTE: don't bother to restore context transform for speed
            pContext->SetHitTestCoordinateSystem(COORDSYS_CONTENT);                
            return TRUE;
        }
    }

    // get the draw program
    CAryDrawProgram aryProgram;
    CAryDrawCookie aryCookie;
    int iPC;
    int iCookie;
    BOOL fNeedScrollbarTest = IsScroller();
    
    if (S_OK != GetDrawProgram(&aryProgram, &aryCookie, FILTER_DRAW_ALLLAYERS))
    {
        AssertSz(0, "Failed to get draw program");
        return FALSE;
    }

    // we will run the program backwards;  first fix up the arguments
    ReverseDrawProgram(aryProgram, &iPC, &iCookie);

    // search for a hit from foreground layers to background
    int lastLayer = s_layerMask;
    int layerStop;
    void * cookie = NULL;
    COORDINATE_SYSTEM csCurrent = COORDSYS_CONTENT;
    BOOL fExpand = false;
    CRect rcExpand = g_Zero.rc; // keep compiler happy
    
    for (CDispNode* pChild = _pLastChild;  iPC>=DP_START_INDEX;  --iPC)
    {
        switch (aryProgram[iPC])
        {
        case DP_DrawContent:
            // we make an exception to the "hittest is reverse of draw" rule for scrollers.
            // Scrollbars are drawn at the same time as the border (i.e. before content),
            // but we hit test the scrollbars before the content to avoid an expensive
            // descent into the tree just to scroll.
            if (fNeedScrollbarTest)
            {
                pContext->SetClipTransform(boxTransform);
                if (DYNCAST(CDispScroller, this)->HitTestScrollbars(pContext, fHitContent))
                {
                    pContext->SetHitTestCoordinateSystem(COORDSYS_BOX);
                    return TRUE;
                }
                pContext->SetClipTransform(contentTransform);
                fNeedScrollbarTest = FALSE;
            }

            {
                DISPNODELAYER layerType = (DISPNODELAYER)aryProgram[--iPC];
                layerStop = layerType <= DISPNODELAYER_NEGATIVEZ ? s_layerNegZ
                          : layerType <= DISPNODELAYER_FLOW      ? s_layerFlow
                          : layerType <= DISPNODELAYER_POSITIVEZ ? s_layerPosZ
                          :                                        s_layerMask;
            }
            for ( ;
                pChild && pChild->GetLayer() >= layerStop;
                pChild = pChild->_pPrevious)
            {
                // if this branch has no visible children, skip it
                if (!pChild->IsVisibleBranch())
                    continue;
     
                // switch clip rectangles and offsets between different layer types
                int childLayer = pChild->GetLayer();
                if (childLayer != lastLayer)
                {
                    Assert(lastLayer > childLayer);
                    COORDINATE_SYSTEM csDesired = (childLayer == s_layerFlow
                                        ? COORDSYS_FLOWCONTENT : COORDSYS_CONTENT);
                    if (csDesired != csCurrent)
                    {
                        switch (csDesired)
                        {
                        case COORDSYS_CONTENT:
                            pContext->SetClipTransform(contentTransform);
                            break;
                        case COORDSYS_FLOWCONTENT:
                            TransformContentToFlow(&pContext->GetClipTransform(), di);
                            break;
                        default:
                            Assert(FALSE);
                            break;
                        }
                        csCurrent = csDesired;
                    }
                    lastLayer = childLayer;

                    //
                    //
                    // FATHIT. Fix for Bug 65015 - enabling "Fat" hit testing on tables.
                    // TODO - At some point the edit team may want to provide
                    // a better UI-level way of selecting nested "thin" tables
                    //

                    // can any child in this layer contain the hit point?
                    if (!pContext->FuzzyRectIsHit(pContext->GetClipRect(), IsFatHitTest() ))
                    {
                        // skip to previous layer:
                        // find the first child that have layerType == childLayer
                        for (pChild = _pFirstChild; pChild; pChild = pChild->_pNext)
                        {
                            int childLayer2 = pChild->GetLayer();
                            if (childLayer2 == childLayer)
                                break; // found it; result may be a structure node
                            if (childLayer2 > childLayer)
                            {
                                pChild = NULL; // no such layer present
                                break;
                            }
                        }
                        continue;
                    }
                }

                //
                // FATHIT. Fix for Bug 65015 - enabling "Fat" hit testing on tables.
                // TODO - At some point the edit team may want to provide
                // a better UI-level way of selecting nested "thin" tables
                //
                if (pContext->FuzzyRectIsHit(pChild->_rctBounds, pChild->IsFatHitTest() ) &&
                    pChild->HitTestPoint(pContext))
                {
                    // NOTE: don't bother to restore _ptHitTest for speed
                    return TRUE;
                }
            }

            //
            // if the hit test failed from here
            // restore the original cs
            //

            pContext->SetHitTestCoordinateSystem(csSave);

            break;

        case DP_Expand:
            fExpand = TRUE;
            rcExpand.right  = aryProgram[--iPC];
            rcExpand.bottom = aryProgram[--iPC];
            rcExpand.left   = aryProgram[--iPC];
            rcExpand.top    = aryProgram[--iPC];
            break;

        case DP_DrawPainterMulti:
            Assert(HasAdvanced() && iCookie>=1);
            cookie = aryCookie[--iCookie];
            // fall through to DP_DrawPainter

        case DP_DrawPainter:
            if (IsVisible())
            {
                if (!fExpand)
                {
                    pContext->SetClipTransform(contentTransform);
                    if (pContext->RectIsHit(di._rccBackgroundClip))
                    {
                        CPoint ptcHitTest;
                        BOOL   fLocalPeerDeclined = FALSE;  

                        pContext->GetHitTestPoint(&ptcHitTest);
                        pContext->SetClipTransform(transformSaveTransformed);
                        if (GetDispClient()->HitTestPeer(
                                &ptcHitTest,
                                COORDSYS_CONTENT,
                                this,
                                cookie,
                                pContext->_pClientData,
                                fHitContent,
                                pContext,
                                &fLocalPeerDeclined))
                        {
                            // NOTE: don't bother to restore context transform for speed
                            return TRUE;
                        }

                        fPeerDeclinedHit = fLocalPeerDeclined || fPeerDeclinedHit;

                        pContext->SetClipTransform(contentTransform);
                    }
                }
                else
                {
                    pContext->SetClipTransform(boxTransform);
                    CRect rcbBounds = _rcpContainer.Size();
                    if (!fForFilter)
                        GetMappedBounds(&rcbBounds);
                    rcbBounds.Expand(rcExpand);
                    if (pContext->RectIsHit(rcbBounds))
                    {
                        CPoint ptbHitTest;
                        BOOL   fLocalPeerDeclined = FALSE;  

                        pContext->GetHitTestPoint(&ptbHitTest);
                        pContext->SetClipTransform(transformSaveTransformed);
                        if (GetDispClient()->HitTestPeer(
                                &ptbHitTest,
                                COORDSYS_BOX,
                                this,
                                cookie,
                                pContext->_pClientData,
                                fHitContent,
                                pContext,
                                &fLocalPeerDeclined))
                        {
                            // NOTE: don't bother to restore context transform for speed
                            return TRUE;
                        }

                        fPeerDeclinedHit = fLocalPeerDeclined || fPeerDeclinedHit;
                    }
                    pContext->SetClipTransform(contentTransform);
                    csCurrent = COORDSYS_CONTENT;
                }
            }
            cookie = NULL;
            fExpand = FALSE;
            break;

        case DP_DrawBackground:
            if (IsVisible())
            {
                pContext->SetClipTransform(contentTransform);
                if (pContext->RectIsHit(di._rccBackgroundClip))
                {
                    CPoint ptcHitTest;
                    pContext->GetHitTestPoint(&ptcHitTest);
                    if (GetDispClient()->HitTestContent(
                            &ptcHitTest,
                            this,
                            pContext->_pClientData,
                            fPeerDeclinedHit ))
                    {
                        // NOTE: don't bother to restore context transform for speed
                        pContext->SetHitTestCoordinateSystem(COORDSYS_CONTENT);
                        return TRUE;
                    }
                }
            }
            break;

        case DP_WindowTopMulti:     --iCookie;
        case DP_WindowTop:
            fExpand = FALSE;
            break;

        case DP_BoxToContent:
            break;

        case DP_DrawBorder:
            // check for scrollbar hit (if we haven't already done so)
            if (fNeedScrollbarTest)
            {
                pContext->SetClipTransform(boxTransform);
                if (DYNCAST(CDispScroller, this)->HitTestScrollbars(pContext, fHitContent))
                {
                    pContext->SetHitTestCoordinateSystem(COORDSYS_BOX);
                    return TRUE;
                }
                pContext->SetClipTransform(contentTransform);
                fNeedScrollbarTest = FALSE;
            }

            // check for border hit
            if (IsVisible() && HasBorder())
            {
                pContext->SetClipTransform(boxTransform);
                CSize sizepNode = _rcpContainer.Size();
                
                if (pContext->RectIsHit(di._rcbContainerClip) &&
                    (pContext->RectIsHit(CRect(0,0, di._prcbBorderWidths->left, sizepNode.cy)) ||
                     pContext->RectIsHit(CRect(0,0, sizepNode.cx, di._prcbBorderWidths->top)) ||
                     pContext->RectIsHit(CRect(sizepNode.cx - di._prcbBorderWidths->right, 0, sizepNode.cx, sizepNode.cy)) ||
                     pContext->RectIsHit(CRect(0, sizepNode.cy - di._prcbBorderWidths->bottom, sizepNode.cx, sizepNode.cy))))
                {
                    CPoint ptbHitTest;
                    pContext->GetHitTestPoint(&ptbHitTest);
                    
                    if (GetDispClient()->HitTestBorder(
                            &ptbHitTest,
                            (CDispContainer*)this,
                            pContext->_pClientData))
                    {
                        // NOTE: don't bother to restore context transform for speed
                        pContext->SetHitTestCoordinateSystem(COORDSYS_BOX);
                        return TRUE;
                    }
                }
                
                pContext->SetClipTransform(contentTransform);
            }
            break;
        }
        
    }
    
    //
    // FATHIT. Fix for Bug 65015 - enabling "Fat" hit testing on tables.
    // TODO - At some point the edit team may want to provide
    // a better UI-level way of selecting nested "thin" tables
    //
    
    // do fuzzy hit test if requested
    if (pContext->_cFuzzyHitTest)
    {
        pContext->SetClipTransform(boxTransform);
        CRect rcbContainer(_rcpContainer.Size());
        if (!pContext->RectIsHit(rcbContainer) &&
            pContext->FuzzyRectIsHit(rcbContainer, IsFatHitTest()))
        {
            CPoint ptbHitTest;
            pContext->GetHitTestPoint(&ptbHitTest);
            if (GetDispClient()->HitTestFuzzy(
                    &ptbHitTest,
                    (CDispContainer*)this,
                    pContext->_pClientData))
            {
                pContext->SetHitTestCoordinateSystem(COORDSYS_BOX);
                return TRUE;
            }
        }
    }
        
    // restore transform
    pContext->SetClipTransform(transformSaveTransformed);
    
    return FALSE;
}


CDispScroller *
CDispContainer::HitScrollInset(const CPoint& pttHit, DWORD *pdwScrollDir)
{
    CPoint ptcHit;
    TransformPoint(pttHit, COORDSYS_TRANSFORMED, &ptcHit, GetContentCoordinateSystem());
    return super::HitScrollInset(ptcHit, pdwScrollDir);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispContainer::CalcDispInfo
//
//  Synopsis:   Calculate clipping and positioning info for this node.
//
//  Arguments:  rcbClip         clip rect in box coords
//              pdi             display info structure
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispContainer::CalcDispInfo(
        const CRect& rcbClip,
        CDispInfo* pdi) const
{
    CDispInfo& di = *pdi;   // notational convenience

    // no scrolling
    di._sizesScroll = g_Zero.size;
    
    // content size
    _rcpContainer.GetSize(&di._sizesContent);
    
    // offset to box coordinates
    _rcpContainer.GetTopLeft(&(di._sizepBoxToParent.AsPoint()));

    // calc container clip in box coordinates
    di._rcbContainerClip.SetRect(di._sizesContent);
    di._rcbContainerClip.IntersectRect(rcbClip);
    
    // calc positioned clip (in box coordinates, so far)
    di._rccPositionedClip = rcbClip;

    // inset user clip and flow clip by optional border
    GetBorderWidthsAndInset(&di._prcbBorderWidths, &di._sizecInset, &di._rcTemp);
    di._sizebScrollToBox = di._prcbBorderWidths->TopLeft().AsSize();
    di._sizesContent.cx -= di._prcbBorderWidths->left + di._prcbBorderWidths->right;
    di._sizesContent.cy -= di._prcbBorderWidths->top + di._prcbBorderWidths->bottom;
    di._sizecBackground = di._sizesContent;
    di._rccPositionedClip.OffsetRect(-di._sizebScrollToBox);    // to scroll coords
    di._rccBackgroundClip.top = max(0L, di._rccPositionedClip.top);
    di._rccBackgroundClip.bottom = min(di._sizesContent.cy,
                                      di._rccPositionedClip.bottom);
    di._rccBackgroundClip.left = max(0L, di._rccPositionedClip.left);
    di._rccBackgroundClip.right = min(di._sizecBackground.cx,
                                     di._rccPositionedClip.right);
    di._rcfFlowClip.left = max(di._rccBackgroundClip.left, di._sizecInset.cx);
    di._rcfFlowClip.right = di._rccBackgroundClip.right;
    di._rcfFlowClip.top = max(di._rccBackgroundClip.top, di._sizecInset.cy);
    di._rcfFlowClip.bottom = di._rccBackgroundClip.bottom;
    di._rcfFlowClip.OffsetRect(-di._sizecInset);
    
    // optional offset from content origin
    if (HasContentOrigin())
    {
        const CSize& sizecOrigin = GetContentOrigin();
        di._sizesScroll += sizecOrigin;

        // adjust all content rects for content origin
        di._rccPositionedClip.OffsetRect(-sizecOrigin);
        di._rccBackgroundClip.OffsetRect(-sizecOrigin);
        di._rcfFlowClip.OffsetRect(-sizecOrigin);
    }

    if (HasExpandedClipRect())
    {
        const CRect& rcExpandedClip = GetExpandedClipRect();
        di._rccPositionedClip.Expand(rcExpandedClip);
        di._rccBackgroundClip.Expand(rcExpandedClip);
        di._rcfFlowClip.Expand(rcExpandedClip);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispContainer::PushTransform
//
//  Synopsis:   Get transform for the given child node.
//
//  Arguments:  pChild          the child node
//              pTransformStack transform stack to save transform changes in
//              pTransform      display transform
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispContainer::PushTransform(
        const CDispNode* pChild,
        CDispTransformStack* pTransformStack,
        CDispClipTransform* pTransform) const
{
    super::PushTransform(pChild, pTransformStack, pTransform);

    // modify transform for child
    CDispClipTransform childTransform;
    GetNodeClipTransform(
        &childTransform,
        pChild->GetContentCoordinateSystem(),
        COORDSYS_TRANSFORMED);
    
    // child transform first
    childTransform.AddPostTransform(*pTransform);
    *pTransform = childTransform;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispContainer::ComputeVisibleBounds
//
//  Synopsis:   Compute visible bounds for a parent node, marking children
//              that determine the edges of these bounds
//
//  Arguments:  none
//
//  Returns:    TRUE if visible bounds changed.
//
//----------------------------------------------------------------------------

BOOL
CDispContainer::ComputeVisibleBounds()
{
    // visible bounds is always the size of the container, and may be extended
    // by items in Z layers that fall outside these bounds
    CRect rcbBounds(_rcpContainer.Size());
    GetMappedBounds(&rcbBounds);
    CRect rcbBoundsExpanded;
    
    SetPainterState(rcbBounds, &rcbBoundsExpanded);

    // expand bounds to include all positioned children
    CRect rccBounds(CRect::CRECT_EMPTY);
    CRect rcbChildren;

    for (CDispNode* pChild = _pFirstChild; pChild; pChild = pChild->_pNext)
    {
        if ((!pChild->IsFlowNode() || pChild->HasWindowTop())
            &&
            !pChild->_rctBounds.IsEmpty())
        {
            rccBounds.Union(pChild->_rctBounds);
        }
    }
    TransformRect(rccBounds, COORDSYS_CONTENT, &rcbChildren, COORDSYS_BOX);
    rcbBoundsExpanded.Union(rcbChildren);

    // convert to transformed coordinates
    CRect rctBounds;
    TransformRect(rcbBoundsExpanded, COORDSYS_BOX, &rctBounds, COORDSYS_TRANSFORMED);
        
    if (rctBounds != _rctBounds)
    {
        _rctBounds = rctBounds;
        return TRUE;
    }

    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispContainer::CalculateInView
//
//  Synopsis:   Calculate whether this node and its children are in view or not.
//
//  Arguments:  transform           display transform, in COORDSYS_TRANSFORMED
//              fPositionChanged    TRUE if position changed
//              fNoRedraw           TRUE to suppress redraw (after scrolling)
//
//  Returns:    TRUE if this node is in view
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
CDispContainer::CalculateInView(
        const CDispClipTransform& transform,
        BOOL fPositionChanged,
        BOOL fNoRedraw,
        CDispRoot *pDispRoot)
{
    BOOL fInView = _rctBounds.Intersects(transform.GetClipRect());
    BOOL fWasInView = IsInView();
    
    // calculate in view status of children unless this node is not in view
    // and was not in view
    if (fInView || fWasInView)
    {
        // accelerated way to clear in view status of all children, unless
        // some child needs change notification
        if (!fInView && !IsInViewAware())
        {
            ClearSubtreeFlags(s_inView);
            return FALSE;
        }

        CDispClipTransform newTransform(transform);
        TransformedToBoxCoords(&newTransform);
        
        // calculate clip and position info
        CDispInfo di;
        CalcDispInfo(newTransform.GetClipRect(), &di);

        // set up for content
        TransformBoxToContent(&newTransform, di);
        CDispClipTransform contentTransform(newTransform);

        int lastLayer = -1;
        for (CDispNode* pChild = _pFirstChild; pChild; pChild = pChild->_pNext)
        {
            // switch clip rectangles and offsets between different layer types
            int childLayer = pChild->GetLayer();
            if (childLayer != lastLayer)
            {
                Assert(lastLayer < childLayer);
                switch (childLayer)
                {
                case s_layerNegZ:
                    break;
                case s_layerFlow:
                    TransformContentToFlow(&newTransform,di);
                    break;
                default:
                    Assert(childLayer == s_layerPosZ);
                    if (lastLayer == s_layerFlow)
                        newTransform = contentTransform;
                    break;
                }
                lastLayer = childLayer;
            }

            pChild->CalculateInView(newTransform, fPositionChanged, fNoRedraw,
                                    pDispRoot);
        }

        // if an obscuring container comes into view, let the root decide
        // whether the obscuring algorithm needs to be run.
        if (!fWasInView && GetDispClient()->WantsToObscure(this))
        {
            Assert(!pDispRoot->IsInRecalc());
            pDispRoot->ObscureElements(g_Zero.rc, this);
        }
    }

    SetInView(fInView);
    return fInView;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispContainer::RecalcChildren
//
//  Synopsis:   Recalculate children.
//
//  Arguments:  pContext            recalc context, in COORDSYS_TRANSFORMED
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispContainer::RecalcChildren(
        CRecalcContext* pRecalcContext)
{
    Assert(pRecalcContext != NULL);
    
    CDispRecalcContext* pContext = DispContext(pRecalcContext);
    
    // accumulate flag values that are propagated up the tree to the root
    int childrenFlags = 0;

    {
        // save the current transform
        CSaveDispClipTransform saveTransform(pContext);
        TransformedToBoxCoords(&pContext->GetClipTransform());
        
        // calculate clip and position info
        CDispInfo di;
        CalcDispInfo(pContext->GetClipRect(), &di);

        // offset children
        TransformBoxToContent(&pContext->GetClipTransform(), di);
        CDispClipTransform contentTransform(pContext->GetClipTransform());

        // set flag values that are passed down our subtree
        CSwapRecalcState swapRecalcState(pContext, this);

        int lastLayer = -1;
        for (CDispNode* pChild = _pFirstChild; pChild; pChild = pChild->_pNext)
        {
            Assert(pContext->_fRecalcSubtree ||
                pChild->MustRecalc() ||
                !pChild->IsInvalid());

            // recalc children that need it, or all children if we are recalculating
            // the entire subtree
            if (pContext->_fRecalcSubtree || pChild->MustRecalc())
            {
                // switch clip rectangles and offsets between different layer types
                int childLayer = pChild->GetLayer();
                if (childLayer != lastLayer)
                {
                    Assert(lastLayer < childLayer);
                    switch (childLayer)
                    {
                    case s_layerNegZ:
                        break;
                    case s_layerFlow:
                        TransformContentToFlow(&pContext->GetClipTransform(), di);
                        break;
                    default:
                        Assert(childLayer == s_layerPosZ);
                        if (lastLayer == s_layerFlow)
                            pContext->SetClipTransform(contentTransform);
                        break;
                    }
                    lastLayer = childLayer;
                }

                pChild->Recalc(pContext);
            }
        
            Assert(!pChild->IsInvalid());
            Assert(pChild->IsParentNode() || !pChild->PositionChanged());
            Assert(!pChild->MustRecalc());
            Assert(!pChild->MustRecalcSubtree());
            childrenFlags |= pChild->GetFlags();
        }
    }

    // ensure that we don't bother to invalidate anything during bounds calc.
    SetMustRecalc();
    ComputeVisibleBounds();
    
    BOOL fWasInvalid = IsInvalid();

    // propagate flags from children, and clear recalc and inval flags
    CopyFlags(childrenFlags, s_inval | s_propagatedMask | s_recalc | s_recalcSubtree);

    // set in-view status
    SetInView(pContext->IsInView(_rctBounds));

    // add to invalid area if necessary
    if (fWasInvalid && !pContext->_fSuppressInval && IsAllSet(s_inView | s_visibleNode))
    {
        pContext->AddToRedrawRegion(_rctBounds, !HasWindowTop());
    }

    // set visible branch flag, just in case this container has no
    // children from which the visible branch flag is propagated
    if (IsVisible())
    {
        SetVisibleBranch();
    }

    // set opaque branch flag
    if (MaskFlags(s_opaqueBranch | s_opaqueNode) == s_opaqueNode &&
        _rcpContainer.Area() >= MINIMUM_OPAQUE_PIXELS &&
        !HasUserTransform())
    {
        SetOpaqueBranch();
    }

    // if this element should obscure windows lower in the z-order, do so now
    if (IsInView() && IsVisible() && GetDispClient()->WantsToObscure(this))
    {
        CRect rcgClient;
        CRect rcgClip;

        // save old transform, change context to box coordinates
        CSaveDispClipTransform saveTransform(pContext);
        TransformedToBoxCoords(&pContext->GetClipTransform());

        GetGlobalClientAndClipRects(pContext->GetClipTransform(),
                                    &rcgClient,
                                    &rcgClip);

        pContext->_pRootNode->ObscureElements(rcgClip, this);
    }
}


#if DBG==1
//+---------------------------------------------------------------------------
//
//  Member:     CDispContainer::DumpContentInfo
//              
//  Synopsis:   Dump custom information for this node.
//              
//  Arguments:  hFile       file handle to dump to
//              level       tree depth at this node
//              childNumber number of this child in parent list
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispContainer::DumpContentInfo(HANDLE hFile, long level, long childNumber) const
{
#if 0
    IDispClientDebug* pIDebug;
    if (SUCCEEDED(
        GetDispClient()->QueryInterface(IID_IDispClientDebug,(void**)&pIDebug)))
    {
        pIDebug->DumpDebugInfo(hFile, level, childNumber, this, 0);
        pIDebug->Release();
    }
#else
    GetDispClient()->DumpDebugInfo(hFile, level, childNumber, this, 0);
#endif
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispContainer::DumpBounds
//
//  Synopsis:   Dump custom information for this node.
//
//  Arguments:  hFile       file handle to dump to
//              level       tree depth at this node
//              childNumber number of this child in parent list
//
//----------------------------------------------------------------------------

void
CDispContainer::DumpBounds(HANDLE hFile, long level, long childNumber) const
{
    super::DumpBounds(hFile, level, childNumber);

    WriteString(hFile, _T("<rcContainer>"));
    DumpRect(hFile, _rcpContainer);
    WriteString(hFile, _T("</rcContainer>\r\n"));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\display\dispcontext.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       dispcontext.cxx
//
//  Contents:   Context object passed throughout display tree.
//
//  Classes:    CDispContext, CDispDrawContext, CDispHitContext
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DISPCONTEXT_HXX_
#define X_DISPCONTEXT_HXX_
#include "dispcontext.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_DISPSURFACE_HXX_
#define X_DISPSURFACE_HXX_
#include "dispsurface.hxx"
#endif

#ifndef X_DISPROOT_HXX_
#define X_DISPROOT_HXX_
#include "disproot.hxx"
#endif

#ifndef X_DISPPARENT_HXX_
#define X_DISPPARENT_HXX_
#include "dispparent.hxx"
#endif

#ifndef X_DDRAW_H_
#define X_DDRAW_H_
#include "ddraw.h"
#endif

MtDefine(CDispContext, DisplayTree, "CDispContext")
MtDefine(CDispHitContext, DisplayTree, "CDispHitContext")
MtDefine(CDispDrawContext, DisplayTree, "CDispDrawContext")
MtDefine(CDispRecalcContext, DisplayTree, "CDispRecalcContext")
MtDefine(CDispContext_LayoutContextStack_pv, DisplayTree, "Layout context stack")


//
// FATHIT. Fix for Bug 65015 - enabling "Fat" hit testing on tables.
// TODO - At some point the edit team may want to provide
// a better UI-level way of selecting nested "thin" tables
//
const int FAT_HIT_TEST = 4;


//+---------------------------------------------------------------------------
//
//  Member:     CLayoutContextStack::GetLayoutContext()
//              
//  Synopsis:   Returnes the last pushed layout context leaving it on the stack
//  Notes:      In case the stack is empty it returns GUL_USEFIRSTLAYOUT
//              
//----------------------------------------------------------------------------
CLayoutContext *
CLayoutContextStack::GetLayoutContext()
{
    if(_aryContext.Size() > 0)
        return _aryContext.Item(_aryContext.Size() - 1);
    else
        return GUL_USEFIRSTLAYOUT;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLayoutContextStack::PushLayoutContext
//              
//  Synopsis:   Pushed given layout context into the layout context stack
//  Notes:
//              
//----------------------------------------------------------------------------
void
CLayoutContextStack::PushLayoutContext(CLayoutContext *pCnt)
{
    Assert(pCnt != GUL_USEFIRSTLAYOUT);
    Assert(pCnt != 0);
    _aryContext.Append(pCnt);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLayoutContextStack::PushLayoutContext
//              
//  Synopsis:   Pops the last pushed layout context from the layout context stach
//  Notes:      It does not return the Poped context
//              
//----------------------------------------------------------------------------
void
CLayoutContextStack::PopLayoutContext()
{
    Assert(_aryContext.Size() > 0);
    _aryContext.Delete(_aryContext.Size() - 1);
}



//+---------------------------------------------------------------------------
//
//  Member:     CDispRecalcContext::AddToRedrawRegionGlobal
//              
//  Synopsis:   Add the given rect (in global coords) to the current redraw
//              region.
//              
//  Arguments:  rcg     rect to add to redraw region (in global coords)
//              
//  Notes:      Do not make this an in-line method, because dispcontext.hxx
//              cannot be dependent on disproot.hxx (circular dependency).
//              
//----------------------------------------------------------------------------

void
CDispRecalcContext::AddToRedrawRegionGlobal(const CRect& rcg)
{
    Assert(_pRootNode != NULL);
    _pRootNode->InvalidateRoot(rcg, FALSE, FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispDrawContext::PushRedrawRegion
//              
//  Synopsis:   Save the current redraw region, then subtract the given region
//              from the redraw region, and make it the new redraw region.
//              
//  Arguments:  rgng        region to subtract from the current redraw region
//              key         key used to decide when to pop the next region
//              
//  Returns:    TRUE if redraw region was successfully pushed, FALSE if the
//              redraw region became empty after subtraction or the stack is
//              full.
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CDispDrawContext::PushRedrawRegion(const CRegion& rgng, void* key)
{
    Assert(!_pRedrawRegionStack->IsFull());
    
    // save the old redraw region
    CRect rcgBounds;
    CRegion* prgngTemp = new CRegion(*_prgngRedraw);
    if (prgngTemp == NULL)
        return FALSE;
     
    rgng.GetBounds(&rcgBounds);
    _pRedrawRegionStack->PushRegion(_prgngRedraw, key, rcgBounds);

    // New region.
    _prgngRedraw = prgngTemp;

    // subtract given region from current redraw region
    _prgngRedraw->Subtract(rgng);

    // if new redraw region is empty, start drawing
    if (_prgngRedraw->IsEmpty())
        return FALSE;    

    // if the stack became full, we will have to render from the root node
    if (_pRedrawRegionStack->IsFull())
    {
        _pFirstDrawNode = (CDispNode*) _pRootNode;
        return FALSE;
    }

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispDrawContext::PopTransform
//              
//  Synopsis:   Pop transform off the transform stack.
//              
//  Arguments:  pDispNode       current node for which we should be getting
//                              the transform
//              
//  Returns:    TRUE if the proper transform was found
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CDispDrawContext::PopTransform(CDispNode* pDispNode)
{
    Assert(_pTransformStack != NULL);
    return _pTransformStack->PopTransform(&GetClipTransform(), pDispNode);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispDrawContext::FillTransformStack
//              
//  Synopsis:   Fill the transform stack with transforms for display node
//              ancestors.
//              
//  Arguments:  pDispNode       current display node
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispDrawContext::FillTransformStack(CDispNode* pDispNode)
{
    Assert(_pTransformStack != NULL);
    _pTransformStack->Init();
    Assert(pDispNode->HasParent());
    pDispNode->GetRawParentNode()->
        PushTransform(pDispNode, _pTransformStack, &GetClipTransform());
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispDrawContext::SaveTransform
//              
//  Synopsis:   Save the given transform on the transform stack.
//              
//  Arguments:  pDispNode       node the context is associated with
//              transform       transform to save
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispDrawContext::SaveTransform(
        const CDispNode *pDispNode,
        const CDispClipTransform& transform)
{
    // can't inline, because CDispDrawContext doesn't know what a transform
    // stack is (circular dependency)
    _pTransformStack->SaveTransform(transform, pDispNode);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispDrawContext::GetRawDC
//              
//  Synopsis:   Get a raw DC (no adjustments to offset or clipping).
//              
//  Arguments:  none
//              
//  Returns:    DC
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

HDC
CDispDrawContext::GetRawDC()
{
    return _pDispSurface->GetRawDC();
}


void
CDispDrawContext::SetSurfaceRegion()
{
    _pDispSurface->SetClipRgn(_prgngRedraw);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispDrawContext::PrepareDispSurface
//              
//  Synopsis:   Return the display surface, properly prepared for client
//              rendering.
//              
//  Arguments:  none
//              
//  Returns:    pointer to the display surface
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

CDispSurface*
CDispDrawContext::PrepareDispSurface()
{
    _pDispSurface->PrepareClientSurface(&GetClipTransform());
    return _pDispSurface;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispHitContext::RectIsHit
//              
//  Synopsis:   Determine whether the given rect, in local coordinates,
//              intersects the hit point.
//              
//  Arguments:  rc      rect in local coordinates
//              
//  Returns:    TRUE if the rect intersects the hit point
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CDispHitContext::RectIsHit(const CRect& rc) const
{
    // transform the rect into global coordinates and perform the hit test
    CRect rcg;
    GetClipTransform().Transform(rc, &rcg);
    if (!rcg.Contains(_ptgHitTest))
        return FALSE;
    
    // now we know that the hit test succeeded in global coordinates.  However,
    // this is not a sufficient test, because the rectangle is too large in
    // global coordinates if there were any rotations that weren't multiples
    // of 90 degrees.  To catch this case, we transform the global hit point
    // back into local coordinates, and redo the test there.
    // 
    // TODO (donmarsh) -- this is still not sufficient if there are multiple
    // nested non-90 degree rotations that perform clipping.  In that case, we
    // have to use a more complex clipping region to answer the question
    // correctly, but this is a larger task than can be accomplished now.
    CPoint ptHitTest;
    GetHitTestPoint(&ptHitTest);
    return rc.Contains(ptHitTest);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispHitContext::FuzzyRectIsHit
//              
//  Synopsis:   Perform fuzzy hit testing.
//              
//  Arguments:  rc          rect to hit
//              
//  Returns:    TRUE if rect is hit
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL            
CDispHitContext::FuzzyRectIsHit(const CRect& rc, BOOL fFatHitTest )
{
    // simple intersection test first
    CRect rcg;
    GetClipTransform().Transform(rc, &rcg);
    if (rcg.Contains(_ptgHitTest))
    {
        // now we know that the hit test succeeded in global coordinates.  However,
        // this is not a sufficient test, because the rectangle is too large in
        // global coordinates if there were any rotations that weren't multiples
        // of 90 degrees.  To catch this case, we transform the global hit point
        // back into local coordinates, and redo the test there.
        // 
        // TODO (donmarsh) -- this is still not sufficient if there are multiple
        // nested non-90 degree rotations that perform clipping.  In that case, we
        // have to use a more complex clipping region to answer the question
        // correctly, but this is a larger task than can be accomplished now.
        CPoint ptHitTest;
        GetHitTestPoint(&ptHitTest);
        return rc.Contains(ptHitTest);
    }
    
    // no intersection if the simple intersection test failed and we're not
    // doing fuzzy hit test
    if (_cFuzzyHitTest == 0)
    {
        Assert( ! fFatHitTest ); // don't expect to do a fat hit test if not doing a fuzzy.
        return FALSE;
    }
    
    // fail if the transformed rect is empty
    CSize size;
    rcg.GetSize(&size);
    if (size.cx <= 0 || size.cy <= 0)
        return FALSE;
    
    // bump out sides by fuzzy factor if the rect is small in either dimension
    CRect rcgFuzzy(rcg);
    size.cx -= _cFuzzyHitTest;
    size.cy -= _cFuzzyHitTest;
    if (size.cx < 0)
    {
        rcgFuzzy.left += size.cx;
        rcgFuzzy.right -= size.cx; 
    }
    if (size.cy < 0)
    {
        rcgFuzzy.top += size.cy;
        rcgFuzzy.bottom -= size.cy; 
    }

    //
    // FATHIT. Fix for Bug 65015 - enabling "Fat" hit testing on tables.
    // TODO - At some point the edit team may want to provide
    // a better UI-level way of selecting nested "thin" tables
    //

    if (rcgFuzzy.Contains(_ptgHitTest))
        return TRUE;
    else 
        return fFatHitTest && FatRectIsHit( rcg );
}




//+====================================================================================
//
// Method: FatRectIsHit
//
// Synopsis: Check to see if the "fat rect is hit"
//
//------------------------------------------------------------------------------------

//
// FATHIT. Fix for Bug 65015 - enabling "Fat" hit testing on tables.
// TODO - At some point the edit team may want to provide
// a better UI-level way of selecting nested "thin" tables
//

BOOL            
CDispHitContext::FatRectIsHit(const CRect& rcg)
{
    CRect rcgFat(rcg);
    rcgFat.InflateRect(FAT_HIT_TEST, FAT_HIT_TEST);
    return rcgFat.Contains(_ptgHitTest);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\display\basictreenode.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       basictreenode.cxx
//
//  Contents:   
//
//  Classes:    
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_DISPPARENT_HXX_
#define X_DISPPARENT_HXX_
#include "dispparent.hxx"
#endif

DeclareTag(tagRecursiveVerify, "BasicTree: Recursive verify", "Recursively verify basic tree")


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::ExtractOrDestroyNodes
//              
//  Synopsis:   Extract or destroy a range of sibling nodes.  These nodes may
//              be children of different structure nodes.
//              
//  Arguments:  pStartNode      first sibling to extract or destroy
//              pEndNode        last sibling to extract or destroy
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispNode::ExtractOrDestroyNodes(
        CDispNode* pStartNode,
        CDispNode* pEndNode)
{
    Assert(pStartNode != NULL && pEndNode != NULL);
    Assert(pStartNode->_pParent != NULL && pEndNode->_pParent != NULL);
    Assert(!pEndNode->IsStructureNode());
    
#if DBG==1
    CDispNode* pTrueParent = pStartNode->GetParentNode();
    Assert(pTrueParent == pEndNode->GetParentNode());
#endif

    CDispNode* pNode = pStartNode;
    CDispParentNode* pParent = pNode->_pParent;
    
    // tricky case: start node and end node have different parents
    while (pParent != pEndNode->_pParent)
    {
        // unlink all children to the right of (and including) pNode
        CDispNode** ppPrevious = (pNode->_pPrevious)
            ? &(pNode->_pPrevious->_pNext)
            : &(pParent->_pFirstChild);
        *ppPrevious = NULL;
        pParent->_pLastChild = pNode->_pPrevious;
        
        pParent->UnlinkChildren(pNode);
        WHEN_DBG(pParent->VerifyChildrenCount();)
        pParent->SetChildrenChanged();
        pParent->RequestRecalc();
        
        // proceed up the tree, looking for the next child
        CDispNode* pNext = NULL;
        do
        {
            Assert(pParent->IsStructureNode());
            
            long cChildren = pParent->_cChildren;

            pNode = pParent;
            pNext = pNode->_pNext;
            pParent = pNode->_pParent;
            Assert(pParent != NULL);

            if (cChildren == 0)
            {
                // delete empty structure node
                pParent->UnlinkChild(pNode);
                pNode->Delete();
                pParent->SetChildrenChanged();
                pParent->RequestRecalc();
            }
        }
        while (pNext == NULL);
        
        pNode = pNext;
        Assert(pNode->IsStructureNode());
        
        // descend into structure nodes
        do
        {
            pParent = pNode->AsParent();
            pNode = pParent->_pFirstChild;
            Assert(pNode != NULL);
        }
        while (pNode->IsStructureNode());
    }
    
    
    // now the easy case: start node and end node are children of same parent
        
    // unlink start and end nodes, then process all nodes in between
    CDispNode** ppPrevious = (pNode->_pPrevious)
        ? &(pNode->_pPrevious->_pNext)
        : &(pParent->_pFirstChild);
    CDispNode** ppNext = (pEndNode->_pNext)
        ? &(pEndNode->_pNext->_pPrevious)
        : &(pParent->_pLastChild);
    *ppPrevious = pEndNode->_pNext;
    *ppNext = pNode->_pPrevious;
    
    // mark end of nodes to be unlinked
    pEndNode->_pNext = NULL;
    pParent->UnlinkChildren(pNode);
    WHEN_DBG(pParent->VerifyChildrenCount();)
    pParent->SetChildrenChanged();
    pParent->RequestRecalc();

    // collapse empty structure nodes
    if (pParent->IsStructureNode() && pParent->_cChildren == 0)
        pParent->CollapseStructureNode();

#if DBG==1
    WHEN_DBG(pTrueParent->VerifyTreeCorrectness();)
#endif

}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::ReplaceParent
//
//  Synopsis:   Replace this node's parent with this node, and delete the parent
//              node and any of its other children.
//
//  Arguments:  none
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispNode::ReplaceParent()
{
    Assert(_pParent != NULL);
    
    // skip structure nodes between this node and its true parent
    CDispParentNode* pParent = GetParentNode();

    // copy all information needed to insert child in correct spot in tree
    CDispParentNode* pGrandparent = pParent->_pParent;
    CDispNode* pPrevious = pParent->_pPrevious;
    CDispNode* pNext = pParent->_pNext;

    pParent->ExtractFromTree();

    // delete the parent and its unowned children (but make this node owned
    // so it doesn't get deleted)
    BOOL fOwned = IsOwned();
    SetOwned(TRUE);
    pParent->Destroy();
    SetOwned(fOwned);

    // now insert in parent's spot
    if (pPrevious != NULL)
        pPrevious->InsertSiblingNode(this, after);
    else if (pNext != NULL)
        pNext->InsertSiblingNode(this, before);
    else if (pGrandparent != NULL)
        pGrandparent->InsertFirstChildNode(this);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::InsertParent
//
//  Synopsis:   Insert a new parent node above this node.
//
//  Arguments:  pNewParent      new parent node
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispNode::InsertParent(CDispParentNode* pNewParent)
{
    // pNewParent should not be in the tree
    Assert(pNewParent->_pParent == NULL);
    Assert(pNewParent->_pPrevious == NULL);
    Assert(pNewParent->_pNext == NULL);
    
    // pNewParent should have no children
#if DBG==1
    Assert(pNewParent->_cChildren == 0);
    Assert(pNewParent->_pFirstChild == NULL);
    Assert(pNewParent->_pLastChild == NULL);
#endif

    // insert new parent as sibling of this node, then re-parent this node
    // to new parent
    if (_pParent != NULL)
    {
        Verify(InsertSiblingNode(pNewParent, after));
    }
    Verify(pNewParent->InsertNodeAsOnlyChild(this));
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::SetFlagsToRoot
//              
//  Synopsis:   Set flag(s) all the way up this branch of the tree.
//
//  Arguments:  flag        the flag(s) to set
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispNode::SetFlagsToRoot(int flags)
{
    SetFlags(flags);
    
    // set these flags all the way up the branch until we run into the root
    // node or a node that already has these flags set
    for (CDispNode* pNode = _pParent;
        pNode && !pNode->IsAllSet(flags);
        pNode = pNode->_pParent)
    {
        pNode->SetFlags(flags);
    }
    
    WHEN_DBG(VerifyFlagsToRoot(flags));
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::ClearFlagsToRoot
//              
//  Synopsis:   Clear flags all the way to the root, without ORing with flag
//              values contributed by other siblings along the way.
//
//  Arguments:  flags       flags to clear
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispNode::ClearFlagsToRoot(int flags)
{
    ClearFlags(flags);
    
    for (CDispNode* pNode = _pParent;
        pNode != NULL && pNode->IsAnySet(flags);
        pNode = pNode->_pParent)
    {
        pNode->ClearFlags(flags);
    }
}


#if DBG==1
//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::VerifyTreeCorrectness
//              
//  Synopsis:   Verify that the subtree rooted at this node is correct.
//              
//  Arguments:  none
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispNode::VerifyTreeCorrectness()
{
    if (IsParentNode())
    {
        CDispParentNode* p = AsParent();
        
        // verify first/last child node pointers
        AssertSz((p->_pFirstChild && p->_pLastChild) ||
                 (!p->_pFirstChild && !p->_pLastChild),
                "Inconsistent first/last child nodes");
        AssertSz(!p->_pFirstChild || p->_pFirstChild->_pPrevious == NULL,
                 "Invalid first child node");
        AssertSz(!p->_pLastChild || p->_pLastChild->_pNext == NULL,
                 "Invalid last child node");
    
        // verify number of children
        p->VerifyChildrenCount();

        // structure nodes must have non-destroyed children
        AssertSz(!IsStructureNode() || p->_cChildren > 0,
                 "Structure node must have at least one non-destroyed child");
        
        // verify parent-child and sibling relationships
        CDispNode * pLastChild = NULL;
        CDispNode * pChild;
        for (pChild = p->_pFirstChild;
             pChild != NULL;
             pLastChild = pChild, pChild = pChild->_pNext)
        {
            AssertSz(pChild != this, "Invalid parent-child loop");
            AssertSz(pChild->_pParent == this, "Invalid parent-child relationship");
            AssertSz(pChild->_pPrevious == pLastChild, "Invalid previous sibling order");
            AssertSz(pChild->_pNext || pChild == p->_pLastChild, "Invalid last child node");
            AssertSz(!pChild->IsNewInsertion() || IsStructureNode() || ChildrenChanged(), "Inserted child must set ChildrenChanged on parent");
        }
        
        // verify each child
        if (IsTagEnabled(tagRecursiveVerify))
        {
            for (pChild = p->_pFirstChild;
                 pChild != NULL;
                 pChild = pChild->_pNext)
            {
                pChild->VerifyTreeCorrectness();
            }
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::VerifyFlagsToRoot
//              
//  Synopsis:   Verify that the given flags are set on this node and all nodes
//              on this branch from this node to the root.
//              
//  Arguments:  flags       flags to verify
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispNode::VerifyFlagsToRoot(int flags)
{
    for (CDispNode* pNode = this;
         pNode != NULL;
         pNode = pNode->_pParent)
    {
        AssertSz(pNode->IsAllSet(flags), "Flags were not set all the way to the root");
        if (!pNode->IsAllSet(flags))
            break;
    }
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\display\dbgmetaf.cxx ===
// dbgmetaf.cxx
// 
// This file useful for debugging windows metafiles only, so it will be included
// in build only if TRACE_META_RECORDS is defined. 


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
#include "dbgmetaf.hxx"

#if defined (TRACE_META_RECORDS) && (DBG==1)

DeclareTag(tagGbgMetaXform, "DbgMetaXform", "Trace metafile transform");

/////////////////////////////////////////////////////////

struct _DebugMetaFunc__
	{
	char*	m_pczMetaFuncName;
	unsigned short	m_wValue;
	};

extern _DebugMetaFunc__ s_rgAllMeta[];

//////////////////////////////////////////////////////////

void TraceMetaFunc(unsigned short wMetaFunc, int c)
{
	for (_DebugMetaFunc__*pCurrent = s_rgAllMeta; pCurrent->m_wValue; pCurrent++)
		{
		if (pCurrent->m_wValue == wMetaFunc)
			{
			TraceTag((tagGbgMetaXform, "TraceMetaFunc %d: %s\n", c, pCurrent->m_pczMetaFuncName));
			return;
			}
		}
	TraceTag((tagGbgMetaXform, "TraceMetaFunc: Unknown Meta Function %d\n", wMetaFunc));
}
			
/* Metafile Functions */
_DebugMetaFunc__ s_rgAllMeta[] =
	{
		{ "META_SETBKCOLOR",			0x0201 },
		{ "META_SETBKMODE",				0x0102 },  
		{ "META_SETMAPMODE",			0x0103 },
		{ "META_SETROP2",				0x0104 },
		{ "META_SETRELABS",				0x0105 },
		{ "META_SETPOLYFILLMODE",		0x0106 },
		{ "META_SETSTRETCHBLTMODE",		0x0107 },
		{ "META_SETTEXTCHAREXTRA",		0x0108 },
		{ "META_SETTEXTCOLOR",			0x0209 },
		{ "META_SETTEXTJUSTIFICATION",	0x020A },
		{ "META_SETWINDOWORG",			0x020B },
		{ "META_SETWINDOWEXT",			0x020C },
		{ "META_SETVIEWPORTORG",		0x020D },
		{ "META_SETVIEWPORTEXT",		0x020E },
		{ "META_OFFSETWINDOWORG",		0x020F },
		{ "META_SCALEWINDOWEXT",		0x0410 },
		{ "META_OFFSETVIEWPORTORG",		0x0211 },
		{ "META_SCALEVIEWPORTEXT",		0x0412 },
		{ "META_LINETO",				0x0213 },
		{ "META_MOVETO",				0x0214 },
		{ "META_EXCLUDECLIPRECT",		0x0415 },
		{ "META_INTERSECTCLIPRECT",		0x0416 },
		{ "META_ARC",					0x0817 },
		{ "META_ELLIPSE",				0x0418 },
		{ "META_FLOODFILL",				0x0419 },
		{ "META_PIE",					0x081A },
		{ "META_RECTANGLE",				0x041B },
		{ "META_ROUNDRECT",				0x061C },
		{ "META_PATBLT",				0x061D },
		{ "META_SAVEDC",				0x001E },
		{ "META_SETPIXEL",				0x041F },
		{ "META_OFFSETCLIPRGN",			0x0220 },
		{ "META_TEXTOUT",				0x0521 },
		{ "META_BITBLT",				0x0922 },
		{ "META_STRETCHBLT",			0x0B23 },
		{ "META_POLYGON",				0x0324 },
		{ "META_POLYLINE",				0x0325 },
		{ "META_ESCAPE",				0x0626 },
		{ "META_RESTOREDC",				0x0127 },
		{ "META_FILLREGION",			0x0228 },
		{ "META_FRAMEREGION",			0x0429 },
		{ "META_INVERTREGION",			0x012A },
		{ "META_PAINTREGION",			0x012B },
		{ "META_SELECTCLIPREGION",		0x012C },
		{ "META_SELECTOBJECT",			0x012D },
		{ "META_SETTEXTALIGN",			0x012E },
		{ "META_CHORD",					0x0830 },
		{ "META_SETMAPPERFLAGS",		0x0231 },
		{ "META_EXTTEXTOUT",			0x0a32 },
		{ "META_SETDIBTODEV",			0x0d33 },
		{ "META_SELECTPALETTE",			0x0234 },
		{ "META_REALIZEPALETTE",		0x0035 },
		{ "META_ANIMATEPALETTE",		0x0436 },
		{ "META_SETPALENTRIES",			0x0037 },
		{ "META_POLYPOLYGON",			0x0538 },
		{ "META_RESIZEPALETTE",			0x0139 },
		{ "META_DIBBITBLT",				0x0940 },
		{ "META_DIBSTRETCHBLT",			0x0b41 },
		{ "META_DIBCREATEPATTERNBRUSH",	0x0142 },
		{ "META_STRETCHDIB",			0x0f43 },
		{ "META_EXTFLOODFILL",			0x0548 },
		{ "META_DELETEOBJECT",			0x01f0 },
		{ "META_CREATEPALETTE",			0x00f7 },
		{ "META_CREATEPATTERNBRUSH",	0x01F9 },
		{ "META_CREATEPENINDIRECT",		0x02FA },
		{ "META_CREATEFONTINDIRECT",	0x02FB },
		{ "META_CREATEBRUSHINDIRECT",	0x02FC },
		{ "META_CREATEREGION",			0x06FF },
		{ NULL, 0 }  // Terminater
	};

#endif 	// DEBUG && TRACE_META_RECORDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\display\dibrot.cxx ===
/****************************************************************************\
|   File:  DibRot . CXX                                                      |
|                                                                            |
|                                                                            |
|   Rotation of bitmaps                                                      |
|                                                                            |
|    Copyright 1990-1995 Microsoft Corporation.  All rights reserved.        |
|    Microsoft Confidential                                                  |
|                                                                            |
\****************************************************************************/

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifdef NOTYET // FUTURE (alexmog, 6/20/2000): This rotation code is not used in 
              // IE5.5. It will probably never be used. Delete when
              // design for rotation in Blackcomb is settled.
              // The code is ported from Quill.

#ifndef X_MATH_H_
#define X_MATH_H_
#include <math.h>
#endif

#ifndef X_XGDI2_HXX_
#define X_XGDI2_HXX_
#include "xgdi2.hxx"
#endif

#ifndef X_PUBROT_HXX_
#define X_PUBROT_HXX_
#include "pubrot.hxx"
#endif

#ifndef X_PUBPRINT_HXX_
#define X_PUBPRINT_HXX_
#include "pubprint.hxx"
#endif

#ifndef X_DBGMETAF_HXX_
#define X_DBGMETAF_HXX_
#include "grafrot.hxx"
#endif

#ifndef X_DIBROT_HXX_
#define X_DIBROT_HXX_
#include "dibrot.hxx"
#endif

// LIBC FUNCTIONS USED FROM TRAN.LIB: cos sin

#ifndef DEBUG
#define DBGSetupFenceValues(a,b,c,d)
#define  DBGCheckSrcPointer(a)
#define  DBGCheckDstPointer(a)
#endif
// ***************************************************************************
//*********************  NEXT TWO FUNCTIONS ARE DEBUG  ONLY ******************
// ***************************************************************************
#ifdef DEBUG
BYTE  *vpSrcMinDBG, *vpSrcMaxDBG, *vpDstMinDBG, *vpDstMaxDBG;

void DBGSetupFenceValues(BYTE *lpSrc, int cbSrc, BYTE *lpDst, int cbDst)
{
    vpSrcMinDBG = lpSrc;
    vpSrcMaxDBG = lpSrc + cbSrc;
    vpDstMinDBG = lpDst;
    vpDstMaxDBG = lpDst + cbDst;
}

_inline void DBGCheckSrcPointer(BYTE *lpSrc)
{
    AssertEx((lpSrc >= vpSrcMinDBG) && (lpSrc < vpSrcMaxDBG));
}
_inline void DBGCheckDstPointer(BYTE *lpDst)
{
    AssertEx((lpDst >= vpDstMinDBG) && (lpDst < vpDstMaxDBG));
}
#endif // DEBUG

// ***************************************************************************
// %%Function: SkewHorz                 %%Owner: harip    %%Reviewed: 12/15/94
// Description: Skew scan line pointed to by psrc to pdst starting at ipixStart.
//              cbSrc : width of src scanline
//              cbDst : width of dst scan line.
// ***************************************************************************
void SkewHorz(BYTE *psrc, int cbSrc, int cbDst, int ipixStart, BYTE *pdst, int cbPixel, BOOL fFlip)
{
    int i, lim;

    if (ipixStart < 0)
        psrc -= ipixStart;
    i = max(0, ipixStart);
    lim = min(cbSrc + ipixStart, cbDst);

	DBGCheckSrcPointer(psrc);
	DBGCheckDstPointer(pdst + i);
	DBGCheckDstPointer(pdst + lim - 1);

	int cb = (lim - i) / cbPixel; // For 24-bit pixel images, each cb represents 3 bytes.
	pdst += i;
	AssertEx(pdst <= psrc || psrc + i <= pdst);
	AssertEx(cbPixel == 1 || cbPixel == 3);
	int cbIncrSrc, cbIncrDst;
	if (fFlip)
		{
		pdst += ((cb - 1) * cbPixel);
		cbIncrDst = -cbPixel;
		}
	else
		{
		cbIncrDst = cbPixel;
		}
	cbIncrSrc = cbPixel;
		
	while (cb--)
		{
		*pdst = *psrc;
		if (cbPixel > 1)
			{
            *(pdst + 1) = *(psrc + 1);
            *(pdst + 2) = *(psrc + 2);
			}
		pdst += cbIncrDst;
		psrc += cbIncrSrc;
		}

}   /* SkewHorz */

// ***************************************************************************
// %%Function: SkewVert                 %%Owner: harip    %%Reviewed: 12/15/94
// Description:
// Description: Skew vertical line of pixels pointed to by psrc to pdst starting
//              at ipixStart. Distance between pixels is cpixOffset.
//              cpixSrc : height of src scanline
//              cpixDst : height of dst scan line.
//  cbPixel : number of bytes per pixel
// ***************************************************************************
void SkewVert(BYTE *psrc, int cpixSrc, int cpixDst, int ipixStart, int cpixOffset,
                    BYTE *pdst, int cbPixel)
{
    int i, lim;

    if (ipixStart < 0)
        {
        psrc -= (ipixStart * cpixOffset);
        i = 0;
        }
    else
        {
        pdst += (ipixStart * cpixOffset);
        i = ipixStart;
        }
    lim = min(cpixSrc + ipixStart, cpixDst);

    for (; i < lim; i++)
        {
        *pdst = *psrc;

		DBGCheckSrcPointer(psrc);
		DBGCheckDstPointer(pdst);

        if (cbPixel > 1)    // shd most probably unravel into 2 functions. Review.
            {
            //AssertEx(cbPixel == 3);
            *(pdst + 1) = *(psrc + 1);
            *(pdst + 2) = *(psrc + 2);
            }
        psrc += cpixOffset;
        pdst += cpixOffset;
        }
}   /* SkewVert */

// ***************************************************************************
// %%Function: HDIBConvert1To8          %%Owner: harip    %%Reviewed: 12/15/94
//
// Parameters: lpbmi : refers to the src (1 bit) bitmap.
//             pDIBOrig : pointer to original DIB's bits
// Returns:     handle to 8 bit dib
//
// Description: Converts a 1-bit dib to an 8bit dib
//  Aborts! caller (catcher) beware!
// ***************************************************************************
HQ HQDIBConvert1To8(LPBITMAPINFOHEADER lpbmi, BYTE *pDIBOrig)
{
    BYTE *lpPixels;
    BYTE *lpOutPixels;
    BYTE *lpT;
    BYTE *lpOutT;
    WORD cbits;
    int x, y, cbInc, cbIncOut, cpixHeight, cpixWidth;
    HQ hqOutDIB;
    BYTE cMask;
    LPBITMAPINFOHEADER lpbmiOut;
    LPBITMAPINFO lpbi;
    int cbAlloc;

    cbits = lpbmi->biBitCount;

    AssertEx(cbits == 1);
    cpixHeight = lpbmi->biHeight;
    cpixWidth = lpbmi->biWidth;

    cbInc = WIDTHBYTES(cpixWidth); // Scan lines must be word-aligned
    cbIncOut = WIDTHBYTES(cpixWidth << 3);

	cbAlloc = sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD) + ((DWORD) cpixHeight) * cbIncOut;
    hqOutDIB = HqAlloc(cbAlloc);
    if (hqOutDIB == hqNil)
    	goto LErrOOM;
    lpbmiOut = (LPBITMAPINFOHEADER)LpLockHq(hqOutDIB);
    ZeroMemory(lpbmiOut, cbAlloc);
    *lpbmiOut = *lpbmi;
    lpbmiOut->biBitCount  = 8;
    lpbmiOut->biSizeImage = 0;
    lpbmiOut->biClrUsed = lpbmiOut->biClrImportant = 0;

    // now build the palette
    lpbi = (LPBITMAPINFO)(LPBYTE)lpbmiOut;
    // fill in colors 0,1 with colors from 1-bit DIB
    for (x = 0; x < (1 << cbits); x++)
        lpbi->bmiColors[x] = ((LPBITMAPINFO) lpbmi)->bmiColors[x];

    lpPixels = pDIBOrig;
    lpOutPixels = (BYTE *)((LPBYTE)lpbi + CbDibHeader(lpbmiOut));

    // Do actual transfer
    for (y = 0; y < cpixHeight; y++)
        {
        lpT = lpPixels + ((DWORD)cbInc) * y;
        lpOutT = lpOutPixels + ((DWORD)cbIncOut) * y;
        for (x = 0, cMask = (BYTE)128; x < cpixWidth; x++)
            {
            if (*lpT & cMask)   // no need to set to 0 since we do ZEROINIT
                *lpOutT = 1;
            lpOutT++;
            if (!(cMask >>= 1))
                {    // start next byte of 1-bit DIB
                lpT++;
                cMask = (BYTE)128;
                }
            }
        }
    UnlockHq(hqOutDIB);
LErrOOM:
    return hqOutDIB;
}   /* HDIBConvert1To8 */

// ***************************************************************************
// %%Function: HDIBConvert4To8          %%Owner: harip    %%Reviewed: 12/15/94
//
// Parameters: lpbmi : refers to the src (4 bit) bitmap.
//             pDIBOrig : pointer to original DIB's bits
// Returns:     handle to 8 bit dib
//
// Description: Converts a 4-bit dib to an 8bit dib
//  ABorts! caller (catcher) beware!
// ***************************************************************************
HQ HQDIBConvert4To8(LPBITMAPINFOHEADER lpbmi, BYTE *pDIBOrig)
{
    BYTE *lpPixels;
    BYTE *lpOutPixels;
    BYTE *lpT;
    BYTE *lpOutT;
    LPBITMAPINFOHEADER lpbmiOut;
    LPBITMAPINFO   lpbi;
    WORD cbits;
    int x, y, cbInc, cbIncOut, cpixHeight, cpixWidth;
    HQ hqOutDIB;
    int cbAlloc;

    AssertEx(lpbmi->biBitCount == 4);
    cpixHeight = lpbmi->biHeight;
    cpixWidth = lpbmi->biWidth;
    cbits = lpbmi->biBitCount;
    cbInc = WIDTHBYTES(cpixWidth << 2); // Scan lines must be word-aligned
    cbIncOut = WIDTHBYTES(cpixWidth << 3);

	cbAlloc = sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD) + ((DWORD) cpixHeight) * cbIncOut;
    hqOutDIB = HqAlloc(cbAlloc);
    if (hqOutDIB == hqNil)
    	goto LErrOOM;
    lpbmiOut = (LPBITMAPINFOHEADER)LpLockHq(hqOutDIB);
    ZeroMemory(lpbmiOut, cbAlloc);
    *lpbmiOut = *lpbmi;
    lpbmiOut->biBitCount  = 8;
    lpbmiOut->biSizeImage = 0;
    lpbmiOut->biClrUsed = lpbmiOut->biClrImportant = 0;
    // now build the palette
    lpbi = (LPBITMAPINFO)(LPBYTE)lpbmiOut;
    // fill colors 0-15 of the palette with colors of 4-bit DIB
    for (x = 0; x < (1 << cbits); x++)
        lpbi->bmiColors[x] = ((LPBITMAPINFO) lpbmi)->bmiColors[x];

    lpPixels = pDIBOrig;
    lpOutPixels = (BYTE *)((LPBYTE)lpbi + CbDibHeader(lpbmiOut));

    // perform actual transfer
    for (y = 0; y < cpixHeight; y++)
        {
        lpT = lpPixels + ((DWORD)cbInc) * y;
        lpOutT = lpOutPixels + ((DWORD)cbIncOut) * y;
        for (x = 0; x < cpixWidth; x += 2)
            {
            // If cpixWidth is odd, this writes one too many pixels, but since
            // lines are extended to be word aligned, this is OK
            *(lpOutT++) = ((*lpT & 0xf0)>>4);
            *(lpOutT++) = (*(lpT++) & 0x0f);
            }
        }
    UnlockHq(hqOutDIB);
LErrOOM:
    return hqOutDIB;

}   /* HDIBConv4To8 */

// ***************************************************************************
// %%Function: HDIBRot90Incs            %%Owner: harip    %%Reviewed: 12/15/94
//
// Description:  Returns handle to the bits of a dib roated by 90, 180 or 270 degs
// Parameters:  lpbmi : refers to incoming bits (some fields are changed. SEE NOTE)
//              pDIBOrig : points to bits of the incoming DIB.
//              wRot :  1 = 90 degs
//                      2 = 180 degs
//                      3 = 270 degs
//              cbPixel : number of bytes per pixel
// NOTE: alters biWidth & biHeight fields in lpbmi to reflect new dimensions
//       and also sets biSizeImage to 0.
//  Aborts on OOM. caller better catch.
//
// Since this routine is expected to return a handle to the bits of a dib, so
// we don't have the opportunity to optimize the case where the image is rotated
// 180 degrees and flipped both horizontally and vertically resulting in the original
// untransformed image.  That optimization should be made higher up.
// ***************************************************************************
HQ HQDIBRot90Incs(LPBITMAPINFOHEADER lpbmi, BYTE *pDIBOrig, WORD wRot,
                            int cbPixel,    BYTE bFill, int qflip)
{
    int dxNew, dyNew, cbInc, cbIncOut, cbIncLoop, x, y;
    HQ hqDIBOut = hqNil;
    BYTE *lpPixels, *lpOutPixels;

    AssertEx(wRot==1 || wRot==2 || wRot==3);

    if (wRot == 2)  //180
        {
        dyNew = lpbmi->biHeight;
        dxNew = lpbmi->biWidth;
        }
    else        // 90, 270
        {
        dxNew = lpbmi->biHeight;
        dyNew = lpbmi->biWidth;
        }
    cbInc = WIDTHBYTES(lpbmi->biWidth*lpbmi->biBitCount);
    cbIncOut = WIDTHBYTES(dxNew*lpbmi->biBitCount);

    hqDIBOut = HqAlloc(dyNew * cbIncOut); // allocate for new dib bits
    if (hqDIBOut == hqNil)
    	goto LErrOOM;
    lpOutPixels = (BYTE*)LpLockHq(hqDIBOut);
    // setup debug fence values
    DBGSetupFenceValues(pDIBOrig, cbInc * lpbmi->biHeight, lpOutPixels, dyNew * cbIncOut);

    FillLpb(bFill, lpOutPixels, dyNew*cbIncOut); // white out
    lpPixels = pDIBOrig;
    if (wRot==3)        // 270
        {
        lpOutPixels += ((DWORD)cbIncOut) * (dyNew - 1);
        cbIncLoop = -cbIncOut;
        }
    else if (wRot == 2)    // 180
        {
        lpOutPixels += cbPixel * (dxNew - 1);
        cbIncLoop = -cbPixel;
        }
    else                // 90
        cbIncLoop = cbIncOut;
    for (y = 0; y < lpbmi->biHeight; y++)
        {
        BYTE *lpOutT, *lpT;

        if (wRot == 3)        // 270
            lpOutT = lpOutPixels + cbPixel * y;
        else if (wRot == 2)    // 180
            lpOutT = lpOutPixels + ((DWORD)cbIncOut) * (dyNew - y - 1);
        else                 // 90
            lpOutT = lpOutPixels + cbPixel * (dxNew - y - 1);
        lpT = lpPixels + ((DWORD)cbInc) * y;
        for (x = 0; x < lpbmi->biWidth; x++)
            {
            *lpOutT = *lpT;
			DBGCheckSrcPointer(lpT);
			DBGCheckDstPointer(lpOutT);
            if (cbPixel == 3)
                {
                *(lpOutT+1) = *(lpT+1);
                *(lpOutT+2) = *(lpT+2);
                }
            lpT += cbPixel;
            lpOutT += cbIncLoop;
            }
        }
    UnlockHq(hqDIBOut);
    lpbmi->biHeight = dyNew;
    lpbmi->biWidth = dxNew;
    lpbmi->biSizeImage = 0;
LErrOOM:
    return hqDIBOut;
}   /* HDIBRot90Incs */

// ***************************************************************************
// %%Function: HDIBBitsRot              %%Owner: harip    %%Reviewed: 12/15/94
//
// Parameters: lpbmi : refers to the incoming DIB.
//             pDIBOrig : points to bits of the Orig DIB.
//              ang :  angle of rotation
// Returns: Handle to memory containing bits to the rotated dib and changes
//              biHeight and biWidth in lpbmi to be that for the new size.
//              Also sets biSizeImage to 0.
//
// Description : Main dib rotating function.
// ALGORITHM: this implements the Paeth/ Tanaka, et. al,1986, 3 pass shear
//              algorithm. Good desription is there in 'Digital Image Warping'
//                                                  by George Wolberg.
// ***************************************************************************
HQ HQDIBBitsRot(MRS *pmrs, LPBITMAPINFOHEADER lpbmi, BYTE *pDIBOrig, ANG ang)
{
    RAD radCos, radSin, radAng, radTanHalfAng;
    int dyNew, dxNew, dxmax;
    int cbInc, cbIncTemp, cbIncOut;
    int cbitsPix, cbPixel;
    HQ hqOutDIB = hqNil;
    HQ hqTempDIB = hqNil;
    HQ hqDIBT = hqNil;
    HQ hqDIB8 = hqNil;
    BOOL fNotOOM = fTrue;
    BYTE *lpTempPixels, *lpOutPixels, *lpPixels, *psrc, *pdst;
    int x, y;
    // variables for Bresenham's line algorithm
    int dx, dy, incrE, incrNE, d, x0, x1, y0, y1, Offst;
    int dxOrig, dyOrig;
    int i;
    LPBITMAPINFO lpbi;
    LPBITMAPINFOHEADER lpbmiSav = lpbmi;
    COLORREF crBackground; // color to fill in as background
    BYTE bFill;
    BOOL fFlippedBits = (lpbmi->biHeight < 0);
	int qflip = pmrs->qflip;

    if (fFlippedBits)
        lpbmi->biHeight *= -1;
    // if bit depth is less than eight convert to an 8bpp image so that we can rotate.
    if (lpbmi->biBitCount < 8)
        {
        hqDIB8 = (lpbmi->biBitCount == 4) ? HQDIBConvert4To8(lpbmi, pDIBOrig) :
											HQDIBConvert1To8(lpbmi, pDIBOrig);
		if (hqDIB8 == hqNil)
			goto LErrOOM;

        lpbmi = (LPBITMAPINFOHEADER)LpLockHq(hqDIB8);
        pDIBOrig = (LPBYTE)((LPBYTE)lpbmi + CbDibHeader(lpbmi));

#ifdef DEBUG_BITS_ROT
    	StretchDIBits(pmrs->hdcDebug, 0, 0, lpbmi->biWidth, lpbmi->biHeight,
                            0,0, lpbmi->biWidth, lpbmi->biHeight, pDIBOrig,
                            (LPBITMAPINFO)lpbmi, DIB_RGB_COLORS, SRCCOPY);
#endif // DEBUG_BITS_ROT
		}

    cbitsPix = lpbmi->biBitCount; // number of bits per pixel
    AssertEx(cbitsPix == 8 || cbitsPix == 24);
    cbPixel = cbitsPix / 8;         // number of bytes per pixel

    // color to set as background
	crBackground=RGB(255,255,255);

    // find fill value (index into palette) to fill in for background
    lpbi = (LPBITMAPINFO)(LPBYTE)lpbmi;
    if (cbitsPix == 8)
        {
        for (i = 0;  i < 256;  i++)
            {
            if (lpbi->bmiColors[i].rgbRed   == GetRValue(crBackground) &&
                lpbi->bmiColors[i].rgbGreen == GetGValue(crBackground) &&
                lpbi->bmiColors[i].rgbBlue  == GetBValue(crBackground))
                break;
            }
        if (i == 256)   // no black in the colors in the DIB
            bFill = 0;  // so set it deliberately to 0
        else
            bFill = i;
        }
    else
        bFill = 255;

    // make sure degrees within bounds
    ang = AngNormalize(ang);
    if (ang >= ang90)
        {
        hqDIBT = HQDIBRot90Incs(lpbmi, pDIBOrig, (WORD)(ang / ang90), cbPixel, bFill, qflip);
        if (hqDIBT == hqNil)
        	goto LErrOOM;

		if ((qflip & qflipVert || qflip & qflipHorz) &&
			!(qflip & qflipVert && qflip & qflipHorz) &&
			(ang / ang90) % 2)
			{
			qflip = (qflip & qflipVert) ? qflipHorz : qflipVert;
			}

        ang = ang % ang90;
        if (ang == 0 && qflip == 0)
            {
            // got to do this since mem pointed to by lpbmi is going away AND
            // the caller (FStretchMetaFoo()) needs the new values passed back
            *lpbmiSav = *lpbmi;
            lpbmi = lpbmiSav;
            if (hqDIB8)
                {
                UnlockHq(hqDIB8);
                FreeHq(hqDIB8);
                }
            return hqDIBT;
            }

        // lpbmi now contains sizes for new DIB (in hqDIBT )
        pDIBOrig = (BYTE*)LpLockHq(hqDIBT);
        } // ang >= ang90

    // convert ang to radians
    radAng = ang * PI / ang180;

    radCos = cos(radAng);
    radSin = sin(radAng);
    radAng /= 2; // ang/2 for tan

    radTanHalfAng = sin(radAng) / cos(radAng);

    dxOrig = lpbmi->biWidth;
    dyOrig = lpbmi->biHeight;

    // new size of bitmap and intermediate width. the +1's to take care of roundoff
    dyNew = radSin * dxOrig + radCos * dyOrig + 1;
    dxNew = radSin * dyOrig + radCos * dxOrig + 1;
    dxmax = dxOrig + dyOrig * radTanHalfAng + 1;

    cbInc = WIDTHBYTES(dxOrig * cbitsPix);
    cbIncTemp = WIDTHBYTES(dxmax * cbitsPix);
    cbIncOut = WIDTHBYTES(dxNew * cbitsPix);

    hqOutDIB = HqAlloc(dyOrig * cbIncTemp);
    if (hqOutDIB == hqNil)
    	goto LErrOOM;
    lpOutPixels = (BYTE *)LpLockHq(hqOutDIB);
    FillLpb(bFill, lpOutPixels, dyOrig * cbIncTemp); // initialise in background color
    lpPixels = pDIBOrig;
    // setup debug fence values
    DBGSetupFenceValues(pDIBOrig, dyOrig * cbInc, lpOutPixels, dyOrig * cbIncTemp);

    if ((fFlippedBits || qflip & qflipVert) && 
    	!(fFlippedBits && qflip & qflipVert))
        {
        psrc = lpPixels - cbInc; // because we increment right in the beginning
        cbInc = -cbInc;
        }
    else
    	{
        psrc = lpPixels + cbInc * dyOrig; // go to the end, since we will be inverting
        }
        
    pdst = lpOutPixels;
    // **************** skew #1 ************************
    y0 = 0;
    x0 = 0;
    y1 = dyOrig;
    x1 = radTanHalfAng * y1 + 0.5;
    dx = x1 - x0;
    dy = y1 - y0;
    incrE = dx << 1;
    d = incrE - dy;
    incrNE = (dx - dy) << 1;
    x = x0;
    y = y0;
    // All this *3 stuff is there since  SkewHorz() expects cb's and
    // so here we multiply by the number of bytes per pixel.
    if (cbitsPix == 24)
        {
        x = cbPixel * x0;
        dxOrig *=cbPixel;
        dxmax *= cbPixel;
        }
    do
        {
        psrc -= cbInc;
        SkewHorz(psrc, dxOrig, dxmax,  x, pdst, cbPixel, qflip & qflipHorz);

#ifdef DEBUG_BITS_ROT
		BLOCK
			{
		    lpbmi->biWidth = dxmax;
		    lpbmi->biHeight = dyOrig;
    		StretchDIBits(pmrs->hdcDebug, 0, 0, lpbmi->biWidth, lpbmi->biHeight,
				0,0, lpbmi->biWidth, lpbmi->biHeight, lpOutPixels,
				(LPBITMAPINFO)lpbmi, DIB_RGB_COLORS, SRCCOPY);
			}
#endif // DEBUG_BITS_ROT

        pdst += cbIncTemp;
        y++;
        if (d <= 0)
            d += incrE;
        else
            {
            d += incrNE;
            x += cbPixel;
            }
        }
    while (y < y1);

    if (cbitsPix == 24)
        {
        dxOrig /= cbPixel;
        dxmax /= cbPixel;
        }
    if (hqDIBT)
        {
        UnlockHq(hqDIBT);    // possibly assert that ang > 890
        FreeHq(hqDIBT);
        hqDIBT = hqNil;
        }

    hqTempDIB = HqAlloc(dyNew * cbIncTemp);
    if (hqTempDIB == hqNil)
    	goto LErrOOM;
    lpTempPixels = (BYTE*)LpLockHq(hqTempDIB);
    FillLpb(bFill, lpTempPixels, dyNew * cbIncTemp); // initialise in background color
    psrc = lpOutPixels;
    pdst = lpTempPixels;
    // setup debug fence values
    DBGSetupFenceValues(psrc, dyOrig * cbIncTemp, pdst, dyNew * cbIncTemp);
    // **************** skew #2 ************************
    x0 = 0;
    y0 = radSin * (dxOrig - 1) + 0.5;
    x1 = dxmax;
    y1 = radSin * (dxOrig - dxmax - 1) + 0.5;
    dx = x1 - x0;
    dy = y0 - y1;
    incrE = dy << 1;
    d = incrE - dx;
    incrNE = (dy - dx) << 1;
    x = x0;
    y = y0;

    do
        {
        SkewVert(psrc, dyOrig, dyNew,  y, cbIncTemp, pdst, cbPixel);

#ifdef DEBUG_BITS_ROT
		BLOCK
			{
		    lpbmi->biWidth = dxmax;
		    lpbmi->biHeight = dyNew;
    		StretchDIBits(pmrs->hdcDebug, 0, 0, lpbmi->biWidth, lpbmi->biHeight,
				0,0, lpbmi->biWidth, lpbmi->biHeight, lpTempPixels,
				(LPBITMAPINFO)lpbmi, DIB_RGB_COLORS, SRCCOPY);
			}
#endif // DEBUG_BITS_ROT

        psrc += cbPixel;
        pdst += cbPixel;

        x++;
        if (d <= 0)
            d += incrE;
        else
            {
            d += incrNE;
            y--;
            }
        }
    	while (x < dxmax);

    UnlockHq(hqOutDIB);
    FreeHq(hqOutDIB);
    hqOutDIB = hqNil;

    hqOutDIB = HqAlloc(dyNew * cbIncOut);
    if (hqOutDIB == hqNil)
    	goto LErrOOM;
    lpOutPixels = (BYTE *)LpLockHq(hqOutDIB);
    FillLpb(bFill, lpOutPixels, dyNew * cbIncOut); // initialise in background color
    // setup debug fence values
    DBGSetupFenceValues(lpTempPixels, dyNew * cbIncTemp, lpOutPixels , dyNew * cbIncOut);
    psrc = lpTempPixels;
    pdst = lpOutPixels + (cbIncOut * dyNew);
    // **************** skew #3 ************************
    {
    Offst = (dxOrig - 1) * radSin;

    y0 = 0;
    x0 = (y0 - Offst) * radTanHalfAng + 0.5;
    y1 = dyNew;
    x1 = (y1 - Offst) * radTanHalfAng + 0.5;
    dx = x1 - x0;
    dy = y1 - y0;
    incrE = dx << 1;
    d = incrE - dy;
    incrNE = (dx - dy) << 1;
    x = x0;
    y = y0;
    // All this *3 stuff is just so we can reuse the SkewHorz code.

    if (cbitsPix == 24)
        {
        x = cbPixel * x0;
        dxNew *= cbPixel;
        dxmax *= cbPixel;
        }
    do
        {
        pdst -= cbIncOut;
        SkewHorz(psrc, dxmax, dxNew, x, pdst, cbPixel, qflipNil);

#ifdef DEBUG_BITS_ROT
		BLOCK
			{
		    lpbmi->biWidth = dxNew;
		    lpbmi->biHeight = dyNew;
    		StretchDIBits(pmrs->hdcDebug, 0, 0, lpbmi->biWidth, lpbmi->biHeight,
				0,0, lpbmi->biWidth, lpbmi->biHeight, lpOutPixels,
				(LPBITMAPINFO)lpbmi, DIB_RGB_COLORS, SRCCOPY);
			}
#endif // DEBUG_BITS_ROT

        psrc += cbIncTemp;
        y++;
        if (d <= 0)
            d += incrE;
        else
            {
            d += incrNE;
            x += cbPixel;
            }
        }
    while (y < y1);
    if (cbitsPix == 24)
        dxNew /= cbPixel;
    }

LErrOOM:
    // following 2 lines because lpbmi points to hqDIB8 for < 8bpp bmps
    // and that is going to be freed.
    *lpbmiSav = *lpbmi;
    lpbmi = lpbmiSav;
    if (hqDIB8)
        {
        UnlockHq(hqDIB8);
        FreeHq(hqDIB8);
        }
    if (hqDIBT)
        {
        AssertEx(pmrs->ang > ang90);
        UnlockHq(hqDIBT);
        FreeHq(hqDIBT);
        }
    if (hqTempDIB)
        {
        UnlockHq(hqTempDIB);
        FreeHq(hqTempDIB);
        }
    // REVIEW (davidhoe):  If fail to alloc hqTempDIB then the first hqOutDIB
    // will be returned.  Is this desirable?  Could have else case for cleaning
    // up hqTempDIB immediately above that would free hqTempDIB and set it to hqNil.
    if (hqOutDIB)
        UnlockHq(hqOutDIB);
    lpbmi->biWidth = dxNew;
    lpbmi->biHeight = dyNew;
    lpbmi->biSizeImage = 0;
    return hqOutDIB;
}   /* HDIBBitsRot */

// ***************************************************************************
// %%Function: FreeDIBSection           %%Owner: harip    %%Reviewed: 00/00/00
//
// Description: Frees up resources allocated for the DIBSection in pdsi.
//
// ***************************************************************************
void FreeDIBSection(PDSI pdsi)
{
	if (pdsi->hdc)
		{
		HBITMAP hbm = NULL;
		if (pdsi->hbmOld)
			{
			if ((hbm = (HBITMAP)SelectObject(pdsi->hdc, pdsi->hbmOld)) != NULL)
				{
				DeleteObject(hbm);
				}
#ifdef DEBUG
			else
				{
				CommSz(_T("Could not free up created DIBSection"));
				CommCrLf();
				}
#endif
			}
		DeleteDC(pdsi->hdc);
		}
}   /* FreeDIBSection */

// ***************************************************************************
// %%Function: FDIBBitsScaledFromHDIB   %%Owner: harip    %%Reviewed: 00/00/00
//
// Parameters: lpbmih lpBits :info about and the bits to be stretched.
//              dxNew dyNew: new size for the bits.
//
// Returns: fTrue if success else fFalse.
//
// Description: Creates a new DIB of size dxNew, dyNew from lpbmih & lpbi.
//              Uses a DIBSection to do so instead of using a Compat. bmp
//              to stretch the bits to and doing GetDIBits etc that
//              HDIBScaledFromHDib() uses
// ***************************************************************************
BOOL  FDIBBitsScaledFromHDIB(HDC hdc, MRS *pmrs, LPBITMAPINFOHEADER lpbmih,
	BYTE *lpBits, int dxNew, int dyNew, PDSI pdsi)
{
    BOOL fOK = fFalse;
    HBITMAP hbmSec=NULL;
    BITMAPINFOHEADER bmihSav = *lpbmih, bmihNew;

    // sanity checking.
    if (dxNew == 0)
        dxNew = 1;
    if (dyNew == 0)
        dyNew = 1;

#ifdef DEBUG_BITS_ROT
	BLOCK
		{
		StretchDIBits(pmrs->hdcDebug, 0, 0, lpbmih->biWidth, lpbmih->biHeight,
			0,0, lpbmih->biWidth, lpbmih->biHeight, lpBits,
			(LPBITMAPINFO)lpbmih, DIB_RGB_COLORS, SRCCOPY);
		}
#endif // DEBUG_BITS_ROT

    lpbmih->biHeight = Abs(dyNew);
    lpbmih->biWidth = dxNew;
    bmihNew = *lpbmih;
    // clear out *pdsi
    ZeroMemory(pdsi, sizeof(DSI));

    if ((pdsi->hdc = CreateCompatibleDC(hdc)) &&
		(hbmSec = CreateDIBSection(hdc, (LPBITMAPINFO)lpbmih,DIB_RGB_COLORS,
                                    &(pdsi->lpBits), NULL, 0)))
        {
        GdiFlush();
        if (pdsi->hbmOld = (HBITMAP)SelectObject(pdsi->hdc, hbmSec))
            {
            SetStretchBltMode(pdsi->hdc, COLORONCOLOR);
            *lpbmih = bmihSav;  // restore for the stretchDIBits() call
            fOK = (StretchDIBits(pdsi->hdc, 0, 0, dxNew, dyNew,
                          0, 0, lpbmih->biWidth, lpbmih->biHeight,
                          lpBits, (LPBITMAPINFO)lpbmih,
                          DIB_RGB_COLORS, SRCCOPY) != GDI_ERROR);

#ifdef DEBUG_BITS_ROT
			BLOCK
				{
				*lpbmih = bmihNew;  // reflect new size.
				StretchDIBits(pmrs->hdcDebug, 0, 0, lpbmih->biWidth, lpbmih->biHeight,
					0,0, lpbmih->biWidth, lpbmih->biHeight, pdsi->lpBits,
					(LPBITMAPINFO)lpbmih, DIB_RGB_COLORS, SRCCOPY);
				}
#endif // DEBUG_BITS_ROT
            }
        }
    if (!pdsi->hbmOld && hbmSec)
        {
        AssertEx(!fOK);
        DeleteObject(hbmSec);
        }

    *lpbmih = bmihNew;  // reflect new size.

    return fOK;
}   /* FDIBBitsScaledFromHDIB */

// ***************************************************************************
// %%Function: HDIBConvertDIB           %%Owner: harip    %%Reviewed: 12/15/94
//
// Description: returns a handle to dib-bits which contains the same info passed
//              in, except that the type of compression is now dwCompression.
//              lpbmi and lpBits shd point to same block of mem.
//              lpbmi has some of its fields changed.
// ***************************************************************************
HQ HQDIBBitsConvertDIB(HDC hdc, LPBITMAPINFOHEADER lpbmi, BYTE *pDIBBits, DWORD dwCompression)
{
    BITMAPINFOHEADER bmih = *lpbmi;
    HBITMAP hbmT;
    HQ hDIBBitsNew = NULL;
    BYTE *pBitsNew;
    BOOL fOK = fFalse;

    AssertEx(lpbmi->biCompression != dwCompression);
    // convert RLE to RGB bitmap, since rotating rle bits leads to bogosity
    bmih.biCompression = dwCompression;
    hbmT = CreateDIBitmap(hdc, (LPBITMAPINFOHEADER)&bmih, CBM_INIT, pDIBBits,
    					(LPBITMAPINFO)lpbmi, DIB_RGB_COLORS);
    if (!hbmT)
        goto LError;
    *((DWORD *)lpbmi) = sizeof(BITMAPINFOHEADER);
    lpbmi->biCompression = dwCompression;
    // get the size of the image
    if (!GetDIBits(hdc, hbmT, 0, lpbmi->biHeight,(LPVOID)NULL,
				  (LPBITMAPINFO)lpbmi, DIB_RGB_COLORS))
		{
		goto LError;
		}

	hDIBBitsNew = HqAlloc(lpbmi->biSizeImage); // alloc mem for bits
	if (hDIBBitsNew == hqNil)
		goto LError;
	pBitsNew = (BYTE *)LpLockHq(hDIBBitsNew);

    // now get the bits
    fOK = GetDIBits(hdc, hbmT, 0, lpbmi->biHeight, (LPVOID)pBitsNew,
					(LPBITMAPINFO)lpbmi, DIB_RGB_COLORS);
    UnlockHq(hDIBBitsNew);
    if (!fOK)
        goto LError;
    lpbmi->biSizeImage = 0; // just to be safe

    return hDIBBitsNew;
LError:
    if (hDIBBitsNew)
        FreeHq(hDIBBitsNew);
    return NULL;
} /* HQDIBBitsConvertDIB */

#endif // NOTYET
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\display\debugpaint.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       debugpaint.cxx
//
//  Contents:   Utility class to debug painting code.
//
//  Classes:    CDebugPaint
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DEBUGPAINT_HXX_
#define X_DEBUGPAINT_HXX_
#include "debugpaint.hxx"
#endif

#ifndef X_REGION_HXX_
#define X_REGION_HXX_
#include "region.hxx"
#endif

DeclareTag(tagTimePaint,    "DisplayTree", "Time paint");
ExternTag(tagNoOffScr);

//+---------------------------------------------------------------------------
//
//  Member:     CDebugPaint::NoOffScreen
//              
//  Synopsis:   Determine whether rendering should happen offscreen.
//              
//  Arguments:  none
//              
//  Returns:    FALSE if rendering should be offscreen.
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CDebugPaint::NoOffScreen()
{
#if defined(PRODUCT_PROF)    // profile build
    static const int noOffScreen =
        GetPrivateProfileIntA("displaytree", "NoOffScreen", 0, "mshtmdbg.ini");
    return (noOffScreen != 0);
#elif DBG==1                // debug build
    return IsTagEnabled(tagNoOffScr);
#else
    return FALSE;
#endif
}

#if DBG==1
//+---------------------------------------------------------------------------
//
//  Member:     ShowPaint
//
//  Synopsis:   Debugging function to show what's getting
//              painted during each frame.
//
//  Arguments:  prcPaint    rect to paint (if rgnPaint is NULL)
//              rgnPaint    region to paint
//              tagShow     tag which governs whether we show or not
//              tagPause    tag which governs whether we pause briefly or not
//              tagWait     tag which governs whether we wait for shift key
//              fHatch      TRUE if we should use a hatch pattern
//              
//----------------------------------------------------------------------------

void
CDebugPaint::ShowPaint(
        const RECT* prcPaint,
        HRGN rgnPaint,
        HDC hdc,
        TRACETAG tagShow,
        TRACETAG tagPause,
        TRACETAG tagWait,
        BOOL fHatch)
{
    if (IsTagEnabled(tagShow) || IsTagEnabled(tagPause) || IsTagEnabled(tagWait))
    {
        // Flash the background.
        if (hdc == NULL || (prcPaint == NULL && rgnPaint == NULL))
        {
            return;
        }

        HBRUSH hbr;
        static int s_iclr;
        static COLORREF s_aclr[] =
        {
                RGB(  0,   0, 255),
                RGB(  0, 255,   0),
                RGB(  0, 255, 255),
                RGB(255,   0,   0),
                RGB(255,   0, 255),
                RGB(255, 255,   0)
        };

        GetAsyncKeyState(VK_SHIFT);

        do
        {
            if (IsTagEnabled(tagShow))
            {
                // Fill the rect.
                s_iclr = (s_iclr + 1) % ARRAY_SIZE(s_aclr);
                if (fHatch)
                {
                    hbr = CreateHatchBrush(HS_DIAGCROSS, s_aclr[s_iclr]);
                    int bkMode = SetBkMode(hdc, TRANSPARENT);
                    if (rgnPaint != NULL)
                    {
                        FillRgn(hdc, rgnPaint, hbr);
                    }
                    else
                    {
                        FillRect(hdc, prcPaint, hbr);
                    }
                    DeleteObject((HGDIOBJ)hbr);
                    SetBkMode(hdc, bkMode);
                }
                else
                {
                    hbr = GetCachedBrush(s_aclr[s_iclr]);
                    if (rgnPaint != NULL)
                    {
                        FillRgn(hdc, rgnPaint, hbr);
                    }
                    else
                    {
                        FillRect(hdc, prcPaint, hbr);
                    }
                    ReleaseCachedBrush(hbr);
                }
                GdiFlush();
            }
            
            if (IsTagEnabled(tagPause))
            {
                DWORD dwTick = GetTickCount();
                while (GetTickCount() - dwTick < 100) ;
            }
        }
        while (IsTagEnabled(tagWait) &&
               (GetAsyncKeyState(VK_SHIFT) & 0x8000) == 0);
        
        while (IsTagEnabled(tagWait) && 
               (GetAsyncKeyState(VK_SHIFT) & 0x8000) != 0)
        {
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDebugPaint::PausePaint
//              
//  Synopsis:   
//              
//  Arguments:  
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDebugPaint::PausePaint(TRACETAG tagWait)
{
    GdiFlush();
    
    while (IsTagEnabled(tagWait) &&
           (GetAsyncKeyState(VK_SHIFT) & 0x8000) == 0)
        ;
    
    while (IsTagEnabled(tagWait) && 
           (GetAsyncKeyState(VK_SHIFT) & 0x8000) != 0)
        ;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDebugPaint::StartTimer
//              
//  Synopsis:   
//              
//  Arguments:  
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDebugPaint::StartTimer()
{
    QueryPerformanceCounter((LARGE_INTEGER *)&_timeStart);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDebugPaint::StopTimer
//              
//  Synopsis:   
//              
//  Arguments:  
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDebugPaint::StopTimer(TRACETAG tag, char* message, BOOL fMicrosec)
{
    if (IsTagEnabled(tag))
    {
        __int64 timeEnd, timeFreq;
        QueryPerformanceCounter((LARGE_INTEGER *)&timeEnd);
        QueryPerformanceFrequency((LARGE_INTEGER *)&timeFreq);
        if (fMicrosec)
        {
            TraceTag((tag, "%s: %ld usec.", message, 
                ((LONG)(((timeEnd - _timeStart) * 1000000) / timeFreq))));
        }
        else
        {
            TraceTag((tag, "%s: %ld msec.", message, 
                ((LONG)(((timeEnd - _timeStart) * 1000) / timeFreq))));
        }
    }
}

CRegionRects::CRegionRects(const CRegion& rgn)
{
    if (rgn.IsEmpty())
        _count = 0;
    else
    {
        HRGN hRgn = rgn.GetRegionForLook();
        GetRegionData(hRgn, sizeof(_rd), (RGNDATA *)&_rd);
        // TODO 112427 (mikhaill 6/21/00) - this is not quite exact
        // for two reasons: hRgn can be 0 and GetRegionData can
        // return zero as a sign of failure. Cleanup required
        // (unless we'll continue to use this stuff for debugging
        // purposes only)
        _count = _rd.rdh.nCount;
    }
}

#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\display\dispclipnode.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       dispclipnode.cxx
//
//  Contents:   A container node that clips all content (flow and positioned).
//
//  Classes:    CDispClipNode
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DISPCLIPNODE_HXX_
#define X_DISPCLIPNODE_HXX_
#include "dispclipnode.hxx"
#endif

MtDefine(CDispClipNode, DisplayTree, "CDispClipNode")

//+---------------------------------------------------------------------------
//
//  Member:     CDispClipNode::DrawUnbufferedBorder
//              
//  Synopsis:   Draw borders of clipping nodes near the root of the display
//              tree.  This is an important optimization when we're scrolling.
//              We can paint the scrollbar, remove it from the redraw region,
//              and accelerate all remaining intersection tests and painting.
//              
//  Arguments:  pContext        display context
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispClipNode::DrawUnbufferedBorder(CDispDrawContext* pContext)
{
    // TODO (donmarsh) -- this routine doesn't take into account transparent
    // borders yet.  We won't draw the background underneath them correctly.
    
    // go to box coordinates (no need to restore the transform)
    if (!TransformedToBoxCoords(&pContext->GetClipTransform(), pContext->GetRedrawRegion()))
        return;
    
    // draw border for this node
    CDispInfo di;
    CalcDispInfo(pContext->GetClipRect(), &di);
    DrawBorder(pContext, *di._prcbBorderWidths, GetDispClient());
    
    // descend branch if we have exactly one child, and it is a CDispClipNode,
    // and it is in the flow layer, and it isn't offset by an inset or transform
    CDispNode* pChild = NULL;
    if (CountChildren() == 1 && !HasInset() && !HasUserTransform())
    {
        pChild = GetFirstChildNode();
        if (!pChild->IsClipNode())
            pChild = NULL;
    }
    
    if (pChild)
    {
        // go to flow coordinates, which we simplify here because there is
        // no inset or transform
        pContext->AddPreOffset(di._prcbBorderWidths->TopLeft().AsSize());
        AssertCoords(&pContext->GetClipTransform(), COORDSYS_TRANSFORMED, COORDSYS_FLOWCONTENT);
        Assert(pChild->IsClipNode());
        CDispClipNode::Cast(pChild)->DrawUnbufferedBorder(pContext);
    }
    else
    {
        // simplify redraw region, because now we only have to draw stuff inside
        // this border
        CSize size = di._sizebScrollToBox;
        size += di._sizesScroll;
        di._rccBackgroundClip.OffsetRect(size);   // to box coords
        CRect rcgInsideBorder;
        pContext->GetClipTransform().Transform(di._rccBackgroundClip, &rcgInsideBorder);
        pContext->GetRedrawRegion()->Intersect(rcgInsideBorder);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispClipNode::CalcDispInfo
//              
//  Synopsis:   Calculate clipping and positioning info for this node.
//
//  Arguments:  rcbClip         clip rect in box coords
//              pdi             display info structure
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispClipNode::CalcDispInfo( const CRect& rcbClip, CDispInfo* pdi) const
{
    super::CalcDispInfo(rcbClip, pdi);
    
    // positioned content gets clipped like the background
    if (_fClipX)
    {
        pdi->_rccPositionedClip.left = pdi->_rccBackgroundClip.left;
        pdi->_rccPositionedClip.right = pdi->_rccBackgroundClip.right;
    }
    if (_fClipY)
    {
        pdi->_rccPositionedClip.top = pdi->_rccBackgroundClip.top;
        pdi->_rccPositionedClip.bottom = pdi->_rccBackgroundClip.bottom;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispClipNode::GetContentClipInScrollCoords
//              
//  Synopsis:   Return clipping rectange for content.
//              
//  Arguments:  prcsClip    returns content clip rect
//              
//  Returns:    TRUE if this node clips content
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CDispClipNode::GetContentClipInScrollCoords(CRect* prcsClip) const
{
    if (_fClipX && _fClipY)
        return GetFlowClipInScrollCoords(prcsClip);
    
    if ((_fClipX || _fClipY) && GetFlowClipInScrollCoords(prcsClip))
    {
        // NOTE (donmarsh) -- this big constant is the same that we use in
        // CDispClipTransform::SetHugeClip, but it doesn't have to be.  We
        // don't want to use MAXLONG because translation would overflow.
        static const LONG bigVal = 5000000;
        if (!_fClipX)
        {
            prcsClip->left = -bigVal;
            prcsClip->right = bigVal;
        }
        if (!_fClipY)
        {
            prcsClip->top = -bigVal;
            prcsClip->bottom = bigVal;
        }
        return TRUE;
    }

    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispClipNode::ComputeVisibleBounds
//
//  Synopsis:   Compute visible bounds for a parent node, marking children
//              that determine the edges of these bounds
//
//  Arguments:  none
//
//  Returns:    TRUE if visible bounds changed.
//
//----------------------------------------------------------------------------

BOOL
CDispClipNode::ComputeVisibleBounds()
{
    // visible bounds is always the size of the container, and may be extended
    // by items in Z layers that fall outside these bounds
    CRect rcbBounds(_rcpContainer.Size());
    GetMappedBounds(&rcbBounds);
    CRect rcbBoundsExpanded;
    CRect rctBounds(_rctBounds);
    
    SetPainterState(rcbBounds, &rcbBoundsExpanded);

    // convert to transformed coordinates
    TransformRect(rcbBoundsExpanded, COORDSYS_BOX, &_rctBounds, COORDSYS_TRANSFORMED);
        
    // the normal case is to clip in both dimensions.  If so, we're done.  But
    // if either dimension is not clipped, we have to examine the visible bounds
    // of all this node's positioned children to determine this node's visible
    // bounds.
    if (!_fClipX || !_fClipY)
    {
        CRect rctClipped(_rctBounds);
        // calculate visible bounds including all positioned children
        super::ComputeVisibleBounds();
        if (_fClipX)
        {
            _rctBounds.left = rctClipped.left;
            _rctBounds.right = rctClipped.right;
        }
        if (_fClipY)
        {
            _rctBounds.top = rctClipped.top;
            _rctBounds.bottom = rctClipped.bottom;
        }
    }

    return (_rctBounds != rctBounds);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\display\dispscroller.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       dispscroller.cxx
//
//  Contents:   Simple scrolling container.
//
//  Classes:    CDispScroller
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DISPSCROLLER_HXX_
#define X_DISPSCROLLER_HXX_
#include "dispscroller.hxx"
#endif

#ifndef X_DISPROOT_HXX_
#define X_DISPROOT_HXX_
#include "disproot.hxx"
#endif

#ifndef X_DISPCONTEXT_HXX_
#define X_DISPCONTEXT_HXX_
#include "dispcontext.hxx"
#endif

#ifndef X_DISPINFO_HXX_
#define X_DISPINFO_HXX_
#include "dispinfo.hxx"
#endif

#ifndef X_DISPCLIENT_HXX_
#define X_DISPCLIENT_HXX_
#include "dispclient.hxx"
#endif

MtDefine(CDispScroller, DisplayTree, "CDispScroller")

DeclareTag(tagDispScroll, "Scroll", "trace scrolling");

void
CDispScroller::GetVScrollbarRect(
    CRect* prcbVScrollbar,
    const CRect& rcbBorderWidths) const
{
    if (!IsRTLScroller())
    {
        prcbVScrollbar->right =  _rcpContainer.Width() - rcbBorderWidths.right;
        prcbVScrollbar->left =
            max(rcbBorderWidths.left, prcbVScrollbar->right - _sizeScrollbars.cx);
    }
    else
    {
        prcbVScrollbar->left = rcbBorderWidths.left;
        prcbVScrollbar->right =
            min(_rcpContainer.Width() - rcbBorderWidths.right,
                prcbVScrollbar->left + _sizeScrollbars.cx);
    }
    prcbVScrollbar->top = rcbBorderWidths.top;
    prcbVScrollbar->bottom = _rcpContainer.Height() - rcbBorderWidths.bottom;
    if (_fHasHScrollbar)
        prcbVScrollbar->bottom -= _sizeScrollbars.cy;
}

void
CDispScroller::GetHScrollbarRect(
    CRect* prcbHScrollbar,
    const CRect& rcbBorderWidths) const
{
    prcbHScrollbar->bottom = _rcpContainer.Height() - rcbBorderWidths.bottom;
    prcbHScrollbar->top =
        max(rcbBorderWidths.top, prcbHScrollbar->bottom - _sizeScrollbars.cy);
    prcbHScrollbar->left = rcbBorderWidths.left;
    prcbHScrollbar->right = _rcpContainer.Width() - rcbBorderWidths.right;

    if (_fHasVScrollbar)
    {
        if (!IsRTLScroller())
            prcbHScrollbar->right -= _sizeScrollbars.cx;
        else
            prcbHScrollbar->left += _sizeScrollbars.cx;

        // don't do a negative scroll
        if (prcbHScrollbar->right < prcbHScrollbar->left)
            prcbHScrollbar->right = prcbHScrollbar->left;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispScroller::SetVerticalScrollbarWidth
//
//  Synopsis:   Set the width of the vertical scroll bar, and whether it is
//              forced to display.
//
//  Arguments:  width       new width
//              fForce      TRUE to force scroll bar to be displayed
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispScroller::SetVerticalScrollbarWidth(LONG width, BOOL fForce)
{
    Assert(width >= 0);

    if (width != _sizeScrollbars.cx || fForce != !!_fForceVScrollbar)
    {
        _sizeScrollbars.cx = width;
        _fForceVScrollbar = fForce;

        RequestRecalcSubtree();
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispScroller::SetHorizontalScrollbarHeight
//
//  Synopsis:   Set the height of the horizontal scroll bar, and whether it is
//              forced to display.
//
//  Arguments:  height      new height
//              fForce      TRUE to force scroll bar to be displayed
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispScroller::SetHorizontalScrollbarHeight(LONG height, BOOL fForce)
{
    Assert(height >= 0);

    if (height != _sizeScrollbars.cy || fForce != !!_fForceHScrollbar)
    {
        _sizeScrollbars.cy = height;
        _fForceHScrollbar = fForce;

        RequestRecalcSubtree();
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispScroller::VerticalScrollbarIsActive
//
//  Synopsis:   Determine whether the vertical scroll bar is visible and
//              active (can scroll the content).
//
//  Arguments:  none
//
//  Returns:    TRUE if the vertical scroll bar is visible and active
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
CDispScroller::VerticalScrollbarIsActive() const
{
    if (!_fHasVScrollbar)
        return FALSE;

    CRect rcbBorderWidths;
    GetBorderWidths(&rcbBorderWidths);
    
    return
        _rcpContainer.Height()
        - rcbBorderWidths.top - rcbBorderWidths.bottom
        - ((_fHasHScrollbar) ? _sizeScrollbars.cy : 0)
        < _sizesContent.cy;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispScroller::HorizontalScrollbarIsActive
//
//  Synopsis:   Determine whether the horizontal scroll bar is visible and
//              active (can scroll the content).
//
//  Arguments:  none
//
//  Returns:    TRUE if the horizontal scroll bar is visible and active
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
CDispScroller::HorizontalScrollbarIsActive() const
{
    if (!_fHasHScrollbar)
        return FALSE;

    CRect rcbBorderWidths;
    GetBorderWidths(&rcbBorderWidths);
    
    return
        _rcpContainer.Width()
        - rcbBorderWidths.left - rcbBorderWidths.right
        - ((_fHasVScrollbar) ? _sizeScrollbars.cx : 0)
        < _sizesContent.cx;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispScroller::CalcScrollbars
//
//  Synopsis:   Determine scroll bar visibility and adjust scroll offsets.
//
//  Arguments:  none
//
//  Returns:    FALSE if the whole scroller must be invalidated due to
//              scroll offset change.
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
CDispScroller::CalcScrollbars(
        LONG cxsScrollerWidthOld,   // need for RTL scroller
        LONG cxsContentWidthOld)    // need for RTL scroller
{
    // sometimes we're called before SetSize!
    if (_rcpContainer.IsEmpty())
    {
        _fHasVScrollbar = _fHasHScrollbar = FALSE;
        return TRUE;
    }

    BOOL fOldHasVScrollbar = !!_fHasVScrollbar;
    BOOL fOldHasHScrollbar = !!_fHasHScrollbar;
    BOOL fNewHasVScrollbar;

    CRect rcbBorderWidths;
    GetBorderWidths(&rcbBorderWidths);

    // calculate container size inside border
    CSize sizeInsideBorder(
        _rcpContainer.Width()
            - rcbBorderWidths.left - rcbBorderWidths.right,
        _rcpContainer.Height()
            - rcbBorderWidths.top - rcbBorderWidths.bottom);

    // determine whether vertical scroll bar is needed
    fNewHasVScrollbar =
        _sizeScrollbars.cx > 0 &&
        (_fForceVScrollbar || _sizesContent.cy > sizeInsideBorder.cy);

    if (    fNewHasVScrollbar != fOldHasVScrollbar
        &&  GetDispClient()->AllowVScrollbarChange(fNewHasVScrollbar)
       )
    {
        _fHasVScrollbar = fNewHasVScrollbar;
    }

    if (_fHasVScrollbar)
    {
        sizeInsideBorder.cx -= _sizeScrollbars.cx;

        // determine whether horizontal scroll bar is needed
        _fHasHScrollbar =
            _sizeScrollbars.cy > 0 &&
            (_fForceHScrollbar || _sizesContent.cx > sizeInsideBorder.cx);

        if (_fHasHScrollbar)
        {
            sizeInsideBorder.cy -= _sizeScrollbars.cy;
        }
    }

    else
    {
        // determine whether horizontal scroll bar is needed
        _fHasHScrollbar =
            _sizeScrollbars.cy > 0 &&
            (_fForceHScrollbar ||
             _sizesContent.cx > sizeInsideBorder.cx);

        if (_fHasHScrollbar)
        {
            sizeInsideBorder.cy -= _sizeScrollbars.cy;

            // but now vertical scroll bar might be needed
            _fHasVScrollbar =
                _sizeScrollbars.cx > 0 &&
                _sizesContent.cy > sizeInsideBorder.cy;

            if (_fHasVScrollbar)
            {
                sizeInsideBorder.cx -= _sizeScrollbars.cx;
            }
        }
    }

    // Fix scroll offsets: ensure that either all of the content fits, 
    // or all of the scroller is used (as opposed to being scrolled beyond content boundaries).
    BOOL fScrollOffsetChanged = FALSE;
    CSize contentBottomRight = _sizesContent + _sizeScrollOffset;
    
    // RTL scroller preserves offset from right
    if (_fRTLScroller)
    {
        // note that this needs to be done whether we have scrollbars or not (e.g. for overflow:hidden)
        long newOffset = min(0L, _xScrollOffsetRTL + sizeInsideBorder.cx - _sizesContent.cx);
        if (newOffset != _sizeScrollOffset.cx)
        {
            _sizeScrollOffset.cx = newOffset;
            fScrollOffsetChanged = TRUE;
        }
    }
    if (contentBottomRight.cx < sizeInsideBorder.cx)
    {
        long newOffset = min(0L, sizeInsideBorder.cx - _sizesContent.cx);
        if (newOffset != _sizeScrollOffset.cx)
        {
            _sizeScrollOffset.cx = newOffset;
            fScrollOffsetChanged = TRUE;
        }
    }
    if (contentBottomRight.cy < sizeInsideBorder.cy)
    {
        long newOffset = min(0L, sizeInsideBorder.cy - _sizesContent.cy);
        if (newOffset != _sizeScrollOffset.cy)
        {
            _sizeScrollOffset.cy = newOffset;
            fScrollOffsetChanged = TRUE;
        }
    }

    // Update RTL scroll offset from right
    if (_fRTLScroller)
    {
        _xScrollOffsetRTL = max(0L, _sizesContent.cx - sizeInsideBorder.cx + _sizeScrollOffset.cx);
    }

    // Scroll offsets should never be positive
    Assert(_sizeScrollOffset.cx <= 0);
    Assert(_sizeScrollOffset.cy <= 0);

    // TRICKY... invalidate scroll bars if they've come
    // or gone, but their coming and going also invalidates
    // the other scroll bar, because it has to adjust for
    // the presence or absence of the scroll bar filler
    if (!!_fHasVScrollbar != fOldHasVScrollbar)
    {
        _fInvalidVScrollbar = TRUE;
        if (_fHasHScrollbar || fOldHasHScrollbar)
            _fInvalidHScrollbar = TRUE;
    }
    if (!!_fHasHScrollbar != fOldHasHScrollbar)
    {
        _fInvalidHScrollbar = TRUE;
        if (_fHasVScrollbar || fOldHasVScrollbar)
            _fInvalidVScrollbar = TRUE;
    }

    return !fScrollOffsetChanged;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispScroller::InvalidateScrollbars
//
//  Synopsis:   Invalidate the scroll bars according to their invalid flags.
//
//  Arguments:  none
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispScroller::InvalidateScrollbars()
{
    CRect rcbBorderWidths;
    GetBorderWidths(&rcbBorderWidths);
    
    if (_fInvalidVScrollbar)
    {
        _fInvalidVScrollbar = FALSE;
            
        CRect rcbVScrollbar;
        if (_fHasHScrollbar)
        {
            // hack to force invalidation of scrollbar filler
            _fHasHScrollbar = FALSE;
            GetVScrollbarRect(&rcbVScrollbar, rcbBorderWidths);
            _fHasHScrollbar = TRUE;
        }
        else
        {
            GetVScrollbarRect(&rcbVScrollbar, rcbBorderWidths);
        }
        
        Invalidate(rcbVScrollbar, COORDSYS_BOX);
    }
    
    if (_fInvalidHScrollbar)
    {
        _fInvalidHScrollbar = FALSE;
        
        CRect rcbHScrollbar;
        GetHScrollbarRect(&rcbHScrollbar, rcbBorderWidths);
        Invalidate(rcbHScrollbar, COORDSYS_BOX);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispScroller::InvalidateEdges
//
//  Synopsis:   Invalidate edges of a node that is changing size.
//
//  Arguments:  sizebOld        old size
//              sizebNew        new size
//              rcbBorderWidths width of borders
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispScroller::InvalidateEdges(
        const CSize& sizebOld,
        const CSize& sizebNew,
        const CRect& rcbBorderWidths)
{
    CRect rcbBorderWidthsPlusScrollbars(rcbBorderWidths);
    
    if (_fHasVScrollbar)
    {
        if (!_fRTLScroller)
            rcbBorderWidthsPlusScrollbars.right += _sizeScrollbars.cx;
        else
            rcbBorderWidthsPlusScrollbars.left += _sizeScrollbars.cx;
    }
    if (_fHasHScrollbar)
    {
        rcbBorderWidthsPlusScrollbars.bottom += _sizeScrollbars.cy;
    }

    super::InvalidateEdges(sizebOld, sizebNew, rcbBorderWidthsPlusScrollbars);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispScroller::GetSizeInsideBorder
//              
//  Synopsis:   Get the size of the area within the border of this node
//              in content coordinates.
//              
//  Arguments:  psizes          returns size of node inside border
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispScroller::GetSizeInsideBorder(CSize* psizes) const
{
    super::GetSizeInsideBorder(psizes);
    if (_fHasVScrollbar) psizes->cx -= _sizeScrollbars.cx;
    if (_fHasHScrollbar) psizes->cy -= _sizeScrollbars.cy;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispScroller::PrivateScrollRectIntoView
//
//  Synopsis:   Scroll the given rect in the indicated coordinate system into
//              view, with various pinning (alignment) options.
//
//  Arguments:  prc             rect to scroll into view (clipped to content
//                              size on exit)
//              coordSystem     coordinate system for prc
//              spVert          scroll pin request, vertical axis
//              spHorz          scroll pin request, horizontal axis
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispScroller::PrivateScrollRectIntoView(
        CRect* prc,
        COORDINATE_SYSTEM coordSystem,
        SCROLLPIN spVert,
        SCROLLPIN spHorz)
{
    Assert(coordSystem == COORDSYS_CONTENT ||
           coordSystem == COORDSYS_FLOWCONTENT);

    CSize sizeContent(_sizesContent);
    if (coordSystem == COORDSYS_FLOWCONTENT && HasInset())
    {
        sizeContent -= GetInset();
    }
    
    // restrict rect to size of contents
    CRect rccContent(sizeContent);
    if (HasContentOrigin())
    {
        rccContent.OffsetRect(-GetContentOrigin());
    }
    // can't use IntersectRect here - it sets empty result to (0,0,0,0), but
    // we need to preserve the edges even for empty rects.
    if (prc->left < rccContent.left)     prc->left = rccContent.left;
    if (prc->right > rccContent.right)   prc->right = rccContent.right;
    if (prc->top < rccContent.top)       prc->top = rccContent.top;
    if (prc->bottom > rccContent.bottom) prc->bottom = rccContent.bottom;

    CRect rcs;
    TransformRect(*prc, coordSystem, &rcs, COORDSYS_SCROLL);
    
    CSize sizesInsideBorder;
    GetSizeInsideBorder(&sizesInsideBorder);
    CRect rcsView(sizesInsideBorder);
    
    // calculate scroll offset required to bring rcs into view
    CSize scrollDelta;
    CSize sizeDiff;
    if (rcsView.CalcScrollDelta(rcs, &scrollDelta, spVert, spHorz) &&
        !scrollDelta.IsZero() &&
        ComputeScrollOffset(scrollDelta - _sizeScrollOffset,
                            sizesInsideBorder, &sizeDiff))
    {
        CDispRoot *pRoot = GetDispRoot();

        // before scrolling, we may need to invalidate window-top nodes that
        // extend outside my client area
        if (pRoot)
        {
            pRoot->InvalidateWindowTopForScroll(this);
        }
    
        _sizeScrollOffset += sizeDiff;

        TraceTag((tagDispScroll, "scroll into view %x by (%d,%d) to (%d,%d)", this,
                    sizeDiff.cy, sizeDiff.cx,
                    _sizeScrollOffset.cy, _sizeScrollOffset.cx));

        SetInvalidAndRecalcSubtree();
        
        // Update RTL scroll offset from right
        if (_fRTLScroller)
        {
            _xScrollOffsetRTL = _sizesContent.cx - sizesInsideBorder.cx + _sizeScrollOffset.cx;
        }
    
        GetDispClient()->NotifyScrollEvent(NULL, 0);

        // after scrolling, we may need to invalidate window-top nodes that
        // extend outside my client area
        if (pRoot)
        {
            pRoot->InvalidateWindowTopForScroll(this);
        }
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CDispScroller::SetSize
//
//  Synopsis:   Set size of this node.
//
//  Arguments:  sizep               new size in parent coords
//              fInvalidateAll      TRUE to entirely invalidate this node
//
//  Notes:      Adjusts horizontal scroll position for RTL scroller if needed
//
//----------------------------------------------------------------------------

void
CDispScroller::SetSize(
        const CSize& sizep,
        const CRect *prcpMapped,
        BOOL fInvalidateAll)
{
    // FUTURE RTL (donmarsh) -- we can do something more efficient for RTL nodes,
    // but since we're not sure what our final RTL strategy is right now, we
    // simply invalidate the entire bounds of an RTL node in order to make
    // sure the scrollbar is updated correctly
    // TODO RTL 112514: we now know what RTL strategy is, but we don't care enough to make RTL scrolling faster in IE5.5
    super::SetSize(sizep, prcpMapped, fInvalidateAll ||
                   (_fRTLScroller && (_fHasVScrollbar || _fHasHScrollbar)));

    // RTL nodes maintain content origin at constand distance from right edge
    if (_fRTLScroller && HasContentOrigin())
    {
        SetContentOrigin(GetContentOrigin(), GetContentOffsetRTL());
    }
    else
        AssertSz(!_fRTLScroller, "no content origin on RTL scroller?");
        
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispScroller:PreDraw
//
//  Synopsis:   Before drawing starts, PreDraw processes the redraw region,
//              subtracting areas that are blocked by opaque or buffered items.
//              PreDraw is finished when the redraw region becomes empty
//              (i.e., an opaque item completely obscures all content below it)
//
//  Arguments:  pContext    draw context
//
//  Returns:    TRUE if first opaque node to draw has been found
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
CDispScroller::PreDraw(CDispDrawContext* pContext)
{
    // Interesting nodes are visible, in-view, opaque
    Assert(IsAllSet(s_preDrawSelector));
    Assert(pContext->IntersectsRedrawRegion(_rctBounds));
    Assert(!IsAnySet(s_flagsNotSetInDraw));

    // We do not delve inside a node whose content is drawn externally.
    // TODO (sambent) Someday, filters may help determine whether PreDraw
    // can safely look at its children and come up with the correct answers.
    if (IsDrawnExternally())
        return FALSE;
    
    if (HasUserTransform())
        return FALSE;
    
    // check for redraw region intersection with scroll bars
    if ((_fHasVScrollbar || _fHasHScrollbar) && IsVisible())
    {
        CSaveDispClipTransform saveTransform(pContext);
        if (!TransformedToBoxCoords(&pContext->GetClipTransform(), pContext->GetRedrawRegion()))
            return FALSE;
        
        CRect rcbBorderWidths;
        GetBorderWidths(&rcbBorderWidths);

        if (_fHasVScrollbar)
        {
            CRect rcbVScrollbar, rcgVScrollbar;
            GetVScrollbarRect(&rcbVScrollbar, rcbBorderWidths);
            pContext->GetClipTransform().Transform(rcbVScrollbar, &rcgVScrollbar);
            CRect rcBounds;
                pContext->GetRedrawRegion()->GetBounds(&rcBounds);
            if (rcgVScrollbar.Contains(rcBounds))
            {
                // add this node to the redraw region stack
                Verify(!pContext->PushRedrawRegion(rcgVScrollbar,this));
                return TRUE;
            }
        }
        if (_fHasHScrollbar)
        {
            CRect rcbHScrollbar, rcgHScrollbar;
            GetHScrollbarRect(&rcbHScrollbar, rcbBorderWidths);
            pContext->GetClipTransform().Transform(rcbHScrollbar, &rcgHScrollbar);
            CRect rcBounds;
                pContext->GetRedrawRegion()->GetBounds(&rcBounds);
            if (rcgHScrollbar.Contains(rcBounds))
            {
                // add this node to the redraw region stack
                Verify(!pContext->PushRedrawRegion(rcgHScrollbar,this));
                return TRUE;
            }
        }
    }
    
    // process border and children
    return super::PreDraw(pContext);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispScroller::DrawBorder
//              
//  Synopsis:   Draw optional border for this node.
//              
//  Arguments:  pContext        draw context, in COORDSYS_BOX
//              rcbBorderWidths widths of borders
//              pDispClient     client for this node
//              dwFlags         scrollbar hints
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispScroller::DrawBorder(
        CDispDrawContext* pContext,
        const CRect& rcbBorderWidths,
        CDispClient* pDispClient,
        DWORD dwFlags)
{
    Assert(pDispClient == GetDispClient());
    
    if (!IsVisible())
        return;
    
    CRect rcbVScrollbar(CRect::CRECT_EMPTY);
    CRect rcbHScrollbar(CRect::CRECT_EMPTY);
    
    // draw border unless we're simply updating the scrollbars in response
    // to scrolling
    if (dwFlags != DISPSCROLLBARHINT_NOBUTTONDRAW)
    {
        super::DrawBorder(pContext, rcbBorderWidths, pDispClient, dwFlags);
    }
    
    // draw vertical scroll bar
    if (_fHasVScrollbar)
    {
        // calculate intersection with redraw region
        GetVScrollbarRect(&rcbVScrollbar, rcbBorderWidths);
        CRect rcbRedraw(rcbVScrollbar);
        pContext->IntersectRedrawRegion(&rcbRedraw);
        if (!rcbRedraw.IsEmpty())
        {
            pDispClient->DrawClientScrollbar(
                1,
                &rcbVScrollbar,
                &rcbRedraw,
                _sizesContent.cy,        // content size
                rcbVScrollbar.Height(),  // container size
                -_sizeScrollOffset.cy,   // amount scrolled
                pContext->PrepareDispSurface(),
                this,
                pContext->GetClientData(),
                dwFlags);
        }
    }

    // draw horizontal scroll bar
    if (_fHasHScrollbar)
    {
        // calculate intersection with redraw region
        GetHScrollbarRect(&rcbHScrollbar, rcbBorderWidths);
        CRect rcbRedraw(rcbHScrollbar);
        pContext->IntersectRedrawRegion(&rcbRedraw);
        if (!rcbRedraw.IsEmpty())
        {
            long xScroll = -_sizeScrollOffset.cx;
            pDispClient->DrawClientScrollbar(
                0,
                &rcbHScrollbar,
                &rcbRedraw,
                _sizesContent.cx,        // content size
                rcbHScrollbar.Width(),   // container size
                xScroll,                 // amount scrolled
                pContext->PrepareDispSurface(),
                this,
                pContext->GetClientData(),
                dwFlags);
        }

        // draw scroll bar filler if necessary
        if (_fHasVScrollbar)
        {
            // calculate intersection with redraw region
            CRect rcbScrollbarFiller(
                rcbVScrollbar.left,
                rcbHScrollbar.top,
                rcbVScrollbar.right,
                rcbHScrollbar.bottom);
            rcbRedraw = rcbScrollbarFiller;
            pContext->IntersectRedrawRegion(&rcbRedraw);
            if (!rcbRedraw.IsEmpty())
            {
                pDispClient->DrawClientScrollbarFiller(
                    &rcbScrollbarFiller,
                    &rcbRedraw,
                    pContext->PrepareDispSurface(),
                    this,
                    pContext->GetClientData(),
                    dwFlags);
            }
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispScroller::HitTestScrollbars
//
//  Synopsis:   Determine whether any of my scrollbars
//              intersect the hit test point.
//
//  Arguments:  pContext        hit context (box coords)
//              fHitContent     TRUE to hit contents of this container,
//                              regardless of this container's bounds
//
//  Returns:    TRUE if my scrollbars intersect the hit test pt.
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
CDispScroller::HitTestScrollbars(CDispHitContext* pContext, BOOL fHitContent)
{
    Assert(IsVisibleBranch());
    
    if (IsVisible() && (_fHasVScrollbar || _fHasHScrollbar))
    {
        // get border info
        CRect rcbBorderWidths;
        GetBorderWidths(&rcbBorderWidths);

        // translate hit point to local coordinates
        CPoint ptbHitTest;
        pContext->GetHitTestPoint(&ptbHitTest);

        CRect rcbVScrollbar(CRect::CRECT_EMPTY);
        CRect rcbHScrollbar(CRect::CRECT_EMPTY);

        // does point hit vertical scroll bar?
        if (_fHasVScrollbar)
        {
            GetVScrollbarRect(&rcbVScrollbar, rcbBorderWidths);
            if (pContext->RectIsHit(rcbVScrollbar) &&
                GetDispClient()->HitTestScrollbar(
                    1,
                    &ptbHitTest,
                    const_cast<CDispScroller*>(this),
                    pContext->_pClientData))
            {
                // NOTE: don't bother to restore context transform for speed
                return TRUE;
            }
        }

        // does point hit horizontal scroll bar?
        if (_fHasHScrollbar)
        {
            GetHScrollbarRect(&rcbHScrollbar, rcbBorderWidths);
            if (pContext->RectIsHit(rcbHScrollbar) &&
                GetDispClient()->HitTestScrollbar(
                    0,
                    &ptbHitTest,
                    const_cast<CDispScroller*>(this),
                    pContext->_pClientData))
            {
                // NOTE: don't bother to restore context transform for speed
                return TRUE;
            }

            // does point hit scroll bar filler?
            if (_fHasVScrollbar)
            {
                CRect rcbScrollbarFiller(
                    rcbVScrollbar.left,
                    rcbHScrollbar.top,
                    rcbVScrollbar.right,
                    rcbHScrollbar.bottom);
                if (pContext->RectIsHit(rcbScrollbarFiller) &&
                    GetDispClient()->HitTestScrollbarFiller(
                        &ptbHitTest,
                        const_cast<CDispScroller*>(this),
                        pContext->_pClientData))
                {
                    // NOTE: don't bother to restore context transform for speed
                    return TRUE;
                }
            }
        }
    }

    return FALSE;
}


CDispScroller *
CDispScroller::HitScrollInset(const CPoint& pttHit, DWORD *pdwScrollDir)
{
    // translate hit point to local coordinates
    CPoint ptbHit;
    TransformPoint(pttHit, COORDSYS_TRANSFORMED, &ptbHit, COORDSYS_BOX);
    
    *pdwScrollDir = 0;

    CSize sizesInsideBorder;
    GetSizeInsideBorder(&sizesInsideBorder);
    if (sizesInsideBorder.cx > 2 * g_sizeDragScrollInset.cx)
    {
        if (    (ptbHit.x <= g_sizeDragScrollInset.cx)
            &&  (ptbHit.x >= 0)
            &&  (_sizeScrollOffset.cx < 0))
        {
            *pdwScrollDir |= SCROLL_LEFT;
        }
        else if (   (ptbHit.x >= sizesInsideBorder.cx - g_sizeDragScrollInset.cx)
                 && (ptbHit.x <= sizesInsideBorder.cx)
                 && (_sizesContent.cx + _sizeScrollOffset.cx > sizesInsideBorder.cx))
        {
            *pdwScrollDir |= SCROLL_RIGHT;
        }
    }

    if (sizesInsideBorder.cy > 2 * g_sizeDragScrollInset.cy)
    {
        if (    (ptbHit.y <= g_sizeDragScrollInset.cy)
            &&  (ptbHit.y >= 0)
            &&  (_sizeScrollOffset.cy < 0))
        {
            *pdwScrollDir |= SCROLL_UP;
        }
        else if (   (ptbHit.y >= sizesInsideBorder.cy - g_sizeDragScrollInset.cy)
                 && (ptbHit.y <= sizesInsideBorder.cy)
                 && (_sizesContent.cy + _sizeScrollOffset.cy > sizesInsideBorder.cy))
        {
            *pdwScrollDir |= SCROLL_DOWN;
        }
    }

    if (*pdwScrollDir)
        return this;

    return super::HitScrollInset(pttHit, pdwScrollDir);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispScroller::GetClientRect
//
//  Synopsis:   Return rectangles for various interesting parts of a display
//              node.
//
//  Arguments:  prc         rect which is returned
//              type        type of rect wanted
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispScroller::GetClientRect(RECT* prc, CLIENTRECT type) const
{
    CRect rcbBorderWidths;
    GetBorderWidths(&rcbBorderWidths);
    
    switch (type)
    {
    case CLIENTRECT_BACKGROUND:
        {
            CSize sizesInsideBorder;
            GetSizeInsideBorder(&sizesInsideBorder);
            ((CRect*)prc)->SetRect(sizesInsideBorder);

            ((CRect*)prc)->OffsetRect(-_sizeScrollOffset);

            // RTL nodes may have non-zero content origin
            if (HasContentOrigin())
            {
                ((CRect*)prc)->OffsetRect(-GetContentOrigin());
            }
        }
        break;

    case CLIENTRECT_CONTENT:
        {
            CSize sizesInsideBorder;
            GetSizeInsideBorder(&sizesInsideBorder);
            ((CRect*)prc)->SetRect(sizesInsideBorder);

            if (_fForceVScrollbar && !_fHasVScrollbar)
            {
                sizesInsideBorder.cx -= _sizeScrollbars.cx;
            }

            ((CRect*)prc)->SetRect(
                -_sizeScrollOffset.AsPoint(),
                sizesInsideBorder);
                
            // RTL nodes may have non-zero content origin
            if (HasContentOrigin())
            {
                ((CRect*)prc)->OffsetRect(-GetContentOrigin());
            }
        }
        break;

    case CLIENTRECT_VSCROLLBAR:
        if (_fHasVScrollbar)
        {
            GetVScrollbarRect((CRect*)prc, rcbBorderWidths);
        }
        else
            *prc = g_Zero.rc;
        break;

    case CLIENTRECT_HSCROLLBAR:
        if (_fHasHScrollbar)
        {
            GetHScrollbarRect((CRect*)prc, rcbBorderWidths);
        }
        else
            *prc = g_Zero.rc;
        break;

    case CLIENTRECT_SCROLLBARFILLER:
        if (_fHasHScrollbar && _fHasVScrollbar)
        {
            prc->bottom = _rcpContainer.Height() - rcbBorderWidths.bottom;
            prc->top = max(rcbBorderWidths.top, prc->bottom - _sizeScrollbars.cy);
            if (!_fRTLScroller)
            {
                prc->right = _rcpContainer.Width() - rcbBorderWidths.right;
                prc->left = max(rcbBorderWidths.left, prc->right - _sizeScrollbars.cx);
            }
            else
            {
                prc->left = rcbBorderWidths.left;
                prc->right = min(_rcpContainer.Width() - rcbBorderWidths.right, prc->left + _sizeScrollbars.cx);
            }
        }
        else
            *prc = g_Zero.rc;
        break;
    }

    if (prc->left >= prc->right || prc->top >= prc->bottom)
        *prc = g_Zero.rc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispScroller::ComputeScrollOffset
//
//  Synopsis:   Compute a new scroll offset.  This helper routine handles the
//              logic of clamping the scroll offset to be non-positive, and
//              resetting the offset to 0 when the entire content fits on the
//              canvas (in each direction, separately).
//
//  Arguments:  offset              proposed scroll offset
//              sizesInsideBorder   the size of my scrolling canvas (not including scrollbars)
//              psizeDiff           [out] the change in scroll offset
//
//  Returns:    TRUE if the change is non-zero
//
//----------------------------------------------------------------------------

BOOL
CDispScroller::ComputeScrollOffset( const SIZE& offset,
                                    const CSize& sizesInsideBorder,
                                    CSize *psizeDiff)
{
    CSize peggedOffset(offset);

    if (peggedOffset.cx < 0)    // don't scroll into negative coords.
        peggedOffset.cx = 0;

    psizeDiff->cx =
        (sizesInsideBorder.cx >= _sizesContent.cx
            ? 0
            : max(-peggedOffset.cx, sizesInsideBorder.cx - _sizesContent.cx))
        - _sizeScrollOffset.cx;

    if (peggedOffset.cy < 0)
        peggedOffset.cy = 0;

    psizeDiff->cy =
        (sizesInsideBorder.cy >= _sizesContent.cy
            ? 0
            : max(-peggedOffset.cy, sizesInsideBorder.cy - _sizesContent.cy))
        - _sizeScrollOffset.cy;

    return !psizeDiff->IsZero();
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispScroller::SetScrollOffset
//
//  Synopsis:   Set new scroll offset.
//
//  Arguments:  offset          new scroll offset
//              fScrollBits     TRUE if we should try to scroll bits on screen
//
//  Returns:    TRUE if a scroll update occurred
//
//----------------------------------------------------------------------------

BOOL
CDispScroller::SetScrollOffset(
        const SIZE& offset,
        BOOL fScrollBits)
{

    CDispClient* pDispClient = GetDispClient();
    CSize sizesInsideBorder;
    GetSizeInsideBorder(&sizesInsideBorder);

    // calculate new scroll offset
    // scroll only if we need to
    CSize sizeDiff;
    if (!ComputeScrollOffset(offset, sizesInsideBorder, &sizeDiff))
        return FALSE;

    // very little work needed if this node isn't rooted under a CDispRoot node
    // Along the way we need to check for any replaced parents (this is why
    // we don't call GetRootNode).

    BOOL fReplaced = IsDrawnExternally();
    CDispNode* pRootCandidate = this;
    CDispRoot* pRoot = NULL;

    while (pRootCandidate->GetRawParentNode() != NULL)
    {
        pRootCandidate = pRootCandidate->GetRawParentNode();
        fReplaced |= pRootCandidate->IsDrawnExternally();
    }
    if (pRootCandidate->IsDispRoot())
        pRoot = DYNCAST(CDispRoot, pRootCandidate);

    // before scrolling, we may need to invalidate window-top nodes that
    // extend outside my client area
    if (pRoot)
    {
        pRoot->InvalidateWindowTopForScroll(this);
    }

    // update the scroll offset
    _sizeScrollOffset += sizeDiff;

    TraceTag((tagDispScroll, "scroll %x by (%d,%d) to (%d,%d)", this,
                sizeDiff.cy, sizeDiff.cx,
                _sizeScrollOffset.cy, _sizeScrollOffset.cx));

    // Update RTL scroll offset from right
    if (_fRTLScroller)
    {
        _xScrollOffsetRTL = _sizesContent.cx - sizesInsideBorder.cx + _sizeScrollOffset.cx;
    }

    if (!pRoot)
        return FALSE;

    CDispClipTransform transform;

    if (fReplaced)
    {
        GetNodeClipTransform(&transform, COORDSYS_TRANSFORMED, COORDSYS_GLOBAL);
        if (CalculateInView(transform, TRUE, TRUE, pRoot))
        {
            Invalidate();
        }

        goto Cleanup;
    }


    // check to make sure display tree is open
    // NOTE (donmarsh) -- normally we could assert this, but CView::SmoothScroll calls
    // SetScrollOffset multiple times, and the display tree will only be open for the first
    // call.  After we call CDispRoot::ScrollRect below, the tree may not be open anymore.
    //Assert(pRoot->DisplayTreeIsOpen());

    // no more work if this scroller isn't in view and visible
    if (!IsAllSet(s_inView | s_visibleBranch))
        goto Cleanup;

    // if the root is marked for recalc, just recalc this scroller.
    // if we aren't being asked to scroll bits, simply request recalc.
    // if we aren't clipped in both dimensions, request recalc.
    if (!fScrollBits || pRoot->MustRecalc() || !_fClipX || !_fClipY)
    {
        SetInvalid();
        RequestRecalcSubtree();
    }

    else
    {
        GetNodeClipTransform(&transform, COORDSYS_TRANSFORMED, COORDSYS_GLOBAL);

        // get rect area to scroll
        CRect rcsScroll(sizesInsideBorder);
        CRect rctScroll;
        
        CDispNode* pNode;

        // try to scroll bits only if it was requested, and
        // it's being scrolled less than the width of the container,
        // and nothing complicated is happening
        fScrollBits = FALSE;
        if ((abs(sizeDiff.cx) >= sizesInsideBorder.cx) ||   // must be smaller than rect
            (abs(sizeDiff.cy) >= sizesInsideBorder.cy) ||
            !IsOpaque()                                ||   // must be opaque
            HasFixedBackground()                       ||   // no fixed background
            IsDisableScrollBits()                      ||   // scroll bits is enabled
            HasUserTransform()                         ||   // no user transform
            !transform.IsOffsetOnly())                      // no arbitrary transforms
        {
            goto Invalidate;
        }

        TransformRect(rcsScroll, COORDSYS_SCROLL, &rctScroll, COORDSYS_TRANSFORMED);
        
        // Now determine if there are any items layered on top of this
        // scroll container.  We could do partial scroll bits in this
        // scenario, but for now we completely disqualify bit scrolling
        // if there is anything overlapping us.
        if (pRoot && pRoot->DoesWindowTopOverlap(this, rctScroll))
            goto Invalidate;

        pNode = this;
        for (;;)
        {
            for (CDispNode* pSibling = pNode->_pNext; pSibling; pSibling = pSibling->_pNext)
            {
                // does sibling intersect scroll area?
                if (pSibling->IsAllSet(s_inView | s_visibleBranch) &&
                    rctScroll.Intersects(pSibling->_rctBounds))
                {
                    goto Invalidate;
                }
            }

            // no intersections among this node's siblings, now check
            // our parent's siblings
            CDispNode* pParent = pNode->GetRawParentNode();
            if (pParent == NULL)
                break;

            pParent->TransformAndClipRect(
                rctScroll,  // in pNode's transformed coords.
                pNode->GetContentCoordinateSystem(),
                &rctScroll, // to pParent's transformed coords.
                COORDSYS_TRANSFORMED);
            Assert(!rctScroll.IsEmpty());
            pNode = pParent;
        }

        // we made it to the root
        Assert(pNode == pRoot);
        fScrollBits = TRUE;

Invalidate:
        // determine which children are in view, and do change notification
        Verify(CalculateInView(transform, TRUE, TRUE, pRoot));

        CRect rcgScroll;
        TransformAndClipRect(rcsScroll, COORDSYS_SCROLL, &rcgScroll, COORDSYS_GLOBAL);
        
        // do scroll bars need to be redrawn?
        Assert(!_fInvalidVScrollbar && !_fInvalidHScrollbar);
        _fInvalidVScrollbar = _fHasVScrollbar && sizeDiff.cy != 0;
        _fInvalidHScrollbar = _fHasHScrollbar && sizeDiff.cx != 0;
        if (_fInvalidVScrollbar || _fInvalidHScrollbar)
        {
            InvalidateScrollbars();
        }

        // scroll content
        pRoot->ScrollRect(
            rcgScroll,
            sizeDiff,
            this,
            fScrollBits);
        
        // CAUTION:  After we call ScrollRect, this node may have been destroyed!
        // We can no longer refer to any member data or call any methods on
        // this object!
    }

Cleanup:

    // after scrolling, we may need to invalidate window-top nodes that
    // extend outside my client area [caution: (this) should not be dereferenced]
    if (pRoot)
    {
        pRoot->InvalidateWindowTopForScroll(this);
    }

    pDispClient->NotifyScrollEvent(NULL, 0);

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispScroller::RecalcChildren
//
//  Synopsis:   Recalculate children.
//
//  Arguments:  pRecalcContext      recalc context, in COORDSYS_TRANSFORMED
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispScroller::RecalcChildren(
        CRecalcContext* pRecalcContext)
{
    CDispRecalcContext* pContext = DispContext(pRecalcContext);
    
    // recalc children's in view flag with probable scroll bar existence
    if (_fForceVScrollbar)
    {
        _fHasVScrollbar = TRUE;
    }
    if (_fForceHScrollbar)
    {
        _fHasHScrollbar = TRUE;
    }

    BOOL fHadVScrollbar = !!_fHasVScrollbar;
    BOOL fHadHScrollbar = !!_fHasHScrollbar;

    // RecalcChildren may add elements to the root's obscurable list.  Since
    // we may call RecalcChildren several times (if ContentOrigin changes,
    // if ScrollOffset changes), we'll have to "un-add" the new elements 
    // before the second call - otherwise they'll appear to be lower in z-order
    // than all other children of this node.
    int cObscurableBegin = pContext->_pRootNode->GetObscurableCount();

    super::RecalcChildren(pRecalcContext);

    // compute the size of this container's content
    CSize sizeContentOld = _sizesContent;
    CRect rccScrollable;
    GetScrollableBounds(&rccScrollable, COORDSYS_CONTENT);

    // Content origin should be added to scrollable size
    CSize sizeOrigin(0,0);
    if (HasContentOrigin())
    {
        sizeOrigin = GetContentOrigin();
    }

    // top must be always positive (sizeOrigin.cy should be always zero)
    rccScrollable.top = -sizeOrigin.cy;

    // horizontal clipping of scrollable content depends on layout direction
    if (!IsRTLScroller())
    {
        // normal scroller doesn't scroll to negative coordinates
        rccScrollable.left = -sizeOrigin.cx;
    }
    else
    {
        // in RTL, horizontal scrolling is needed if there is something in negative X
        if (rccScrollable.left < 0)
            _fHasHScrollbar = TRUE;

        // need to know exact scroller size to set rccScrollable.right. See below.
    }
    
    // Calculate scrollbar rectangles
    CRect rcbBorderWidths;
    GetBorderWidths(&rcbBorderWidths);
    CRect rcbVSB(g_Zero.rc);
    CRect rcbHSB(g_Zero.rc);

    if (_fHasVScrollbar || _fInvalidVScrollbar)
    {
        GetVScrollbarRect(&rcbVSB, rcbBorderWidths);
    }

    if (_fHasHScrollbar || _fInvalidHScrollbar)
    {
        GetHScrollbarRect(&rcbHSB, rcbBorderWidths);
    }

    // container width adjusted to scrollbars.
    LONG cxsScrollerWidthOld = _fHasHScrollbar ? rcbHSB.Width() : sizeContentOld.cx;

/* (dmitryt) IE6 18787 the "+ _sizeScrollbars.cx" part of it is actually incorrect.
    it was checked in as part of ellipsis work after consultation with AlexMog who
    created this if() at the first place. Grzegorz and I thinked about it and didn't 
    find any reason to have it here. Removal of it fixes some other RTL bugs 
    (30574, 30634, 26261, 24522, 16855)
    
    // now we know the container width - restrict RTL content on the right
    if (IsRTLScroller())
    {
        rccScrollable.right = cxsScrollerWidthOld + _sizeScrollbars.cx;
    }
*/

    // save the content widht
    _sizesContent = rccScrollable.Size();


    // update content origin
    if (HasContentOrigin())
    {
        CSize sizeContentOrigin = GetContentOrigin();
        // update the scroller's content origin
        // note that it is important that we don't inval here - it is
        // not legal to do at the time this method is called
        SetContentOriginNoInval(sizeContentOrigin, GetContentOffsetRTL());

        // if origin has changed, 
        // recalc children again, because clipping rectangle changes 
        // with change of content origin, and visibility of children needs to be updated.
        // Yes, it is kind of inefficient, but the case (RTL with overflow)
        // is not critical enough to refactor RecalcChildren.
        // NOTE: see IE bug 102699 for a test case
        if (GetContentOrigin() != sizeContentOrigin)
        {
            pContext->_pRootNode->SetObscurableCount(cObscurableBegin);
            super::RecalcChildren(pRecalcContext);
        }
    }
    

    //
    // CALCULATE SCROLLBARS
    //
    BOOL fScrollOffsetChanged = !CalcScrollbars(cxsScrollerWidthOld, sizeContentOld.cx);
    
                                                
    if (!pContext->_fSuppressInval && IsVisible())
    {
        if (!fScrollOffsetChanged)
        {
            BOOL fInvalidateVScrollbar = _fInvalidVScrollbar || (_fHasVScrollbar && _sizesContent.cy != sizeContentOld.cy);
            if (fInvalidateVScrollbar)
            {
                Invalidate(rcbVSB, COORDSYS_BOX);           // old box

                GetVScrollbarRect(&rcbVSB, rcbBorderWidths);// new box
                Invalidate(rcbVSB, COORDSYS_BOX);
            }
            if (_fInvalidHScrollbar ||
                (_fHasHScrollbar && _sizesContent.cx != sizeContentOld.cx))
            {

                Invalidate(rcbHSB, COORDSYS_BOX);   //old box
                //(dmitryt) We have to re-take the box of horiz scroller because
                //it might have changed as a result of CalcScrollbars called earlier.
                //(for example, horiz scroller can appear now and thus have non-null size)
                GetHScrollbarRect(&rcbHSB, rcbBorderWidths);
                Invalidate(rcbHSB, COORDSYS_BOX);   //new box
                // invalidate scrollbar filler if we invalidated both
                // scroll bars. We don't need to inval old rect of this small guy.
                if (fInvalidateVScrollbar)
                {
                    CRect rcbFiller(rcbVSB.left, rcbHSB.top, rcbVSB.right, rcbHSB.bottom);
                    Invalidate(rcbFiller, COORDSYS_BOX);
                }
            }
        }
        else
        {
            pContext->AddToRedrawRegion(_rctBounds, !HasWindowTop());
        }
    }
    
    _fInvalidVScrollbar = _fInvalidHScrollbar = FALSE;

    // if the scroll bar status or scrolloffset changed, we need to correct the
    // in-view status of children
    if ((fScrollOffsetChanged ||
         !!_fHasVScrollbar != fHadVScrollbar ||
         !!_fHasHScrollbar != fHadHScrollbar) &&
        (IsInView() || pContext->IsInView(_rctBounds)))
    {
        //CalculateInView(pContext->GetClipTransform(), pContext->_fRecalcSubtree || fScrollOffsetChanged, FALSE);
        // We also need to correct children's bounds.
        // See bug 102979 (mikhaill) -- 02/11/00.
        pContext->_pRootNode->SetObscurableCount(cObscurableBegin);
        SetMustRecalcSubtree();
        super::RecalcChildren(pRecalcContext);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispScroller::CalcDispInfo
//
//  Synopsis:   Calculate clipping and positioning info for this node.
//
//  Arguments:  rcbClip         current clip rect
//              pdi             display info structure
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispScroller::CalcDispInfo(
        const CRect& rcbClip,
        CDispInfo* pdi) const
{
    CDispInfo& di = *pdi;   // notational convenience
    
    // set scrolling offset
    di._sizesScroll = _sizeScrollOffset;

    // content size
    di._sizesContent = _sizesContent;

    // offset to box coordinates
    _rcpContainer.GetTopLeft(&(di._sizepBoxToParent.AsPoint()));

    // calc container clip in box coordinates
    di._rcbContainerClip = rcbClip;

    // calc rect inside border and scroll bars
    GetBorderWidthsAndInset(&di._prcbBorderWidths, &di._sizecInset, &di._rcTemp);
    di._sizebScrollToBox = di._prcbBorderWidths->TopLeft().AsSize();
    di._sizecBackground =
        _rcpContainer.Size()
        - di._prcbBorderWidths->TopLeft().AsSize()
        - di._prcbBorderWidths->BottomRight().AsSize();
    if (_fHasVScrollbar)
    {
        di._sizecBackground.cx -= _sizeScrollbars.cx;

        if (IsRTLScroller())
            di._sizebScrollToBox.cx += _sizeScrollbars.cx;
    }
    if (_fHasHScrollbar)
    {
        di._sizecBackground.cy -= _sizeScrollbars.cy;
    }
    
    // calc background clip (in box coordinates, so far)
    di._rccBackgroundClip.SetRect(
        di._sizebScrollToBox.AsPoint(),
        di._sizecBackground);
    di._rccBackgroundClip.IntersectRect(di._rcbContainerClip);
    di._rccBackgroundClip.OffsetRect(-di._sizebScrollToBox);    // to scroll coords

    // contents scroll
    di._rccBackgroundClip.OffsetRect(-_sizeScrollOffset);
    
    // clip positioned content
    if (_fClipX)
    {
        di._rccPositionedClip.left = di._rccBackgroundClip.left;
        di._rccPositionedClip.right = di._rccBackgroundClip.right;
    }
    else
    {
        di._rccPositionedClip.left = rcbClip.left - di._sizebScrollToBox.cx - _sizeScrollOffset.cx;
        di._rccPositionedClip.right = rcbClip.right - di._sizebScrollToBox.cx - _sizeScrollOffset.cx;
    }
    if (_fClipY)
    {
        di._rccPositionedClip.top = di._rccBackgroundClip.top;
        di._rccPositionedClip.bottom = di._rccBackgroundClip.bottom;
    }
    else
    {
        di._rccPositionedClip.top = rcbClip.top - di._sizebScrollToBox.cy - _sizeScrollOffset.cy;
        di._rccPositionedClip.bottom = rcbClip.bottom - di._sizebScrollToBox.cy - _sizeScrollOffset.cy;
    }

    di._rcfFlowClip.left = max(di._rccBackgroundClip.left, di._sizecInset.cx);
    di._rcfFlowClip.right = di._rccBackgroundClip.right;
    di._rcfFlowClip.top = max(di._rccBackgroundClip.top, di._sizecInset.cy);
    di._rcfFlowClip.bottom = di._rccBackgroundClip.bottom;
    di._rcfFlowClip.OffsetRect(-di._sizecInset);
    
    // size of background is big enough to fill background and content
    di._sizecBackground.Max(di._sizesContent);

    // optional offset from content origin
    if (HasContentOrigin())
    {
        const CSize& sizecOrigin = GetContentOrigin();
        di._sizesScroll += sizecOrigin;

        // adjust all content rects for content origin
        di._rccPositionedClip.OffsetRect(-sizecOrigin);
        di._rccBackgroundClip.OffsetRect(-sizecOrigin);
        di._rcfFlowClip.OffsetRect(-sizecOrigin);
    }
}


#if DBG==1
//+---------------------------------------------------------------------------
//
//  Member:     CDispScroller::DumpBounds
//
//  Synopsis:   Dump custom information for this node.
//
//  Arguments:  hFile       file handle to dump to
//              level       tree depth at this node
//              childNumber number of this child in parent list
//
//----------------------------------------------------------------------------

static void
DumpScrollbarInfo(int i, HANDLE hFile, const CSize& sizeScrollbars, BOOL fHasScrollbar, BOOL fForceScrollbar)
{
    WriteHelp(hFile, _T("<<scrollbar dir='<0s>' width='<1d>'<2s><3s>/>\r\n"),
        i ? _T("V") : _T("H"),
        sizeScrollbars[!i],
        fHasScrollbar ? _T(" visible='1'") : _T(""),
        fForceScrollbar ? _T(" force='1'") : _T(""));
}

void
CDispScroller::DumpBounds(HANDLE hFile, long level, long childNumber) const
{
    super::DumpBounds(hFile, level, childNumber);

    // print scroll offset
    WriteString(hFile, _T("<scroll>"));
    DumpSize(hFile, _sizeScrollOffset);
    WriteString(hFile, _T("</scroll>\r\n"));

    // dump scroll bar info
    DumpScrollbarInfo(1, hFile, _sizeScrollbars, _fHasVScrollbar, _fForceVScrollbar);
    DumpScrollbarInfo(0, hFile, _sizeScrollbars, _fHasHScrollbar, _fForceHScrollbar);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\display\displeafnode.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       displeafnode.cxx
//
//  Contents:   A display item supporting background, border, and
//              user clip.
//
//  Classes:    CDispLeafNode
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DISPLEAFNODE_HXX_
#define X_DISPLEAFNODE_HXX_
#include "displeafnode.hxx"
#endif

#ifndef X_DISPROOT_HXX_
#define X_DISPROOT_HXX_
#include "disproot.hxx"
#endif

#ifndef X_DISPCONTEXT_HXX_
#define X_DISPCONTEXT_HXX_
#include "dispcontext.hxx"
#endif

#ifndef X_DISPINFO_HXX_
#define X_DISPINFO_HXX_
#include "dispinfo.hxx"
#endif

#ifndef X_DISPSURFACE_HXX_
#define X_DISPSURFACE_HXX_
#include "dispsurface.hxx"
#endif

#ifndef X_DEBUGPAINT_HXX_
#define X_DEBUGPAINT_HXX_
#include "debugpaint.hxx"
#endif

#ifndef X_DISPCLIENT_HXX_
#define X_DISPCLIENT_HXX_
#include "dispclient.hxx"
#endif

#ifndef X_DISPFILTER_HXX_
#define X_DISPFILTER_HXX_
#include "dispfilter.hxx"
#endif

MtDefine(CDispLeafNode, DisplayTree, "CDispLeafNode")


//+---------------------------------------------------------------------------
//
//  Member:     CDispLeafNode::Recalc
//              
//  Synopsis:   Recalculate this node's cached state.
//              
//  Arguments:  pRecalcContext      display recalc context
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispLeafNode::Recalc(CRecalcContext* pRecalcContext)
{
    CDispRecalcContext* pContext = DispContext(pRecalcContext);
    
    // shouldn't be here unless this node requested recalc, or we're recalcing
    // the whole subtree
    Assert(MustRecalc() || pContext->_fRecalcSubtree);

    CRect rcpBounds(GetBounds());
    GetMappedBounds(&rcpBounds);
    CRect rcbBounds(rcpBounds.Size());
    CRect rcpBoundsExpanded;

    SetPainterState(rcpBounds, &rcpBoundsExpanded);

    // if we have a transform, recalc the post transformed bounds
    if (HasUserTransform())
    {
        TransformRect(rcpBoundsExpanded, COORDSYS_PARENT, &_rctBounds, COORDSYS_TRANSFORMED);
    }

    // if no transform, but advanced, just use the expanded rect
    else if (HasAdvanced())
    {
        *PBounds() = rcpBounds;
        _rctBounds = rcpBoundsExpanded;
        
        // transformed nodes are not allowed to be opaque because of non-90 degree
        // rotations
        ClearFlag(s_opaqueBranch);
    }

    // if no tranform or advanced, just use the basic rect
    else
    {
        _rctBounds = rcpBounds;
        
        // if no transform or advanced, check for possible opacity optimization
        SetFlag(s_opaqueBranch, IsOpaque() && rcbBounds.Area() >= MINIMUM_OPAQUE_PIXELS);
    }
    
    // is this item in view?
    BOOL fVisible = IsVisible();
    BOOL fWasInView = IsInView();
    BOOL fInView = fVisible && pContext->IsInView(_rctBounds);
    
    // notify client of visibility changes if requested
    if (IsAnySet(s_notifyInViewChange | s_notifyNewInsertion))
    {
        // if our parent moved and forced recalc of its children, the
        // children may have moved
        if (pContext->_fRecalcSubtree)
            SetPositionChanged();

        if (fInView != fWasInView ||
            (fInView && PositionChanged()) ||
            IsAllSet(s_newInsertion | s_notifyNewInsertion))
        {
            // save old transform, change context to box coordinates
            CSaveDispClipTransform saveTransform(pContext);
            TransformedToBoxCoords(&pContext->GetClipTransform());
        
            NotifyInViewChange(
                pContext->GetClipTransform(),
                fInView,
                fWasInView,
                FALSE,
                pContext->_pRootNode);
        }
    }
    
    SetInView(fInView);
    SetVisibleBranch(fVisible);
    
    // add to invalid area
    if (IsAllSet(s_inval | s_inView | s_visibleNode) && !pContext->_fSuppressInval)
    {
        pContext->AddToRedrawRegion(_rctBounds, !HasWindowTop());
    }

    // if this element should obscure windows lower in the z-order, do so now
    if (fInView && fVisible && GetDispClient()->WantsToObscure(this))
    {
        CRect rcgClient;
        CRect rcgClip;

        // save old transform, change context to box coordinates
        CSaveDispClipTransform saveTransform(pContext);
        TransformedToBoxCoords(&pContext->GetClipTransform());

        GetGlobalClientAndClipRects(pContext->GetClipTransform(),
                                    &rcgClient,
                                    &rcgClip);

        pContext->_pRootNode->ObscureElements(rcgClip, this);
    }
    
    // clear display recalc flags
    ClearFlags(s_inval | s_positionChanged);
    
    //BasicRecalc(pContext);
    Assert(pContext != NULL);
    ClearFlags(s_childrenChanged | s_newInsertion | s_recalc | s_recalcSubtree);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispLeafNode::SetSize
//
//  Synopsis:   Set size for this node.
//
//  Arguments:  sizep           new size
//              fInvalidateAll  TRUE to invalidate entire contents of this node
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispLeafNode::SetSize(const CSize& sizep, const CRect *prcpMapped, BOOL fInvalidateAll)
{
    // calculate new bounds
    CRect* prcpBounds = PBounds();

    if (prcpMapped)
    {
        if (!HasAdvanced())
            SetUpAdvancedDisplay();
        if (HasAdvanced())
            GetAdvanced()->SetMappedBounds(prcpMapped);
    }
    else
    {
        if (HasAdvanced())
            GetAdvanced()->SetNoMappedBounds();
    }

    if (sizep == prcpBounds->Size())
        return;

    if (!IsInvalid() && IsVisible() && IsInView() && (fInvalidateAll || HasUserTransform()))
    {
       // Invalidate the old rect
        Invalidate();
    }

    CRect rcpOld(*prcpBounds);
    prcpBounds->SetSize(sizep);
    
    // TODO (donmarsh) - this should really be s_viewHasChanged, when
    // we have such a flag.
    SetPositionChanged();

    // for RTL nodes, keep orinal content right-aligned by adjusting content offset
    if (HasContentOrigin() && GetContentOffsetRTL() >= 0)
    {
        // this recalculates offset from left and invalidates if necessary
        SetContentOrigin(GetContentOrigin(), GetContentOffsetRTL());
    }
    
    // if the inval flag is set, we don't need to invalidate because the
    // current bounds has never been rendered
    if (!IsInvalid())
    {
        RequestRecalc();
        
        if (IsVisible())
        {
            if (HasWindowTop())
            {
                InvalidateAtWindowTop();
                SetInvalid();
            }
            else if (IsInView())
            {
                if (fInvalidateAll || HasUserTransform())
                {
                    // mark invalid, so that new area will be repainted
                    SetInvalid();
                }
                else
                {
                    CRect rcbBorderWidths;
                    GetBorderWidths(&rcbBorderWidths);
                    InvalidateEdges(rcpOld.Size(), sizep, rcbBorderWidths);
                }
            }
            else
            {
                SetInvalid();
            }
        }
    }
    
    GetDispClient()->OnResize(sizep, this);
    Assert(MustRecalc());
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispLeafNode::SetPosition
//              
//  Synopsis:   Set the position of this leaf node.
//              
//  Arguments:  ptpTopLeft      new top left coordinates (in PARENT coordinates)
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispLeafNode::SetPosition(const CPoint& ptpTopLeft)
{
    // calculate new bounds
    CRect* prcpBounds = PBounds();
    if (ptpTopLeft == prcpBounds->TopLeft())
        return;

    if (!IsInvalid())
    {
        if (HasWindowTop())
        {
            InvalidateAtWindowTop();
            SetInvalid();
        }
        else if (IsVisible())
        {
            Invalidate();
            SetInvalid();
        }
    }
    
    prcpBounds->MoveTo(ptpTopLeft);
    
    SetPositionChanged();
    RequestRecalc();
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispLeafNode::GetClientRect
//
//  Synopsis:   Return rectangles for various interesting parts of a display
//              node.
//
//  Arguments:  prc         rect which is returned
//              type        type of rect wanted
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispLeafNode::GetClientRect(RECT* prc, CLIENTRECT type) const
{
    switch (type)
    {
    case CLIENTRECT_BACKGROUND:
    case CLIENTRECT_CONTENT:
        {
            CRect rcbBorderWidths;
            GetBorderWidths(&rcbBorderWidths);
            ((CRect*)prc)->SetRect(
                GetSize()
                - rcbBorderWidths.TopLeft().AsSize()
                - rcbBorderWidths.BottomRight().AsSize());
            if (prc->left >= prc->right || prc->top >= prc->bottom)
                *prc = g_Zero.rc;
        }
        break;
    default:
        *prc = g_Zero.rc;
        break;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispLeafNode::HitTestPoint
//
//  Synopsis:   Determine whether this item intersects the hit test point.
//
//  Arguments:  pContext        hit context, in COORDSYS_TRANSFORMED
//              fForFilter      TRUE when we're called from a filter
//              fHitContent     TRUE to hit contents of this container,
//                              regardless of this container's bounds
//
//  Returns:    TRUE if this item intersects the hit test point.
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
CDispLeafNode::HitTestPoint(CDispHitContext* pContext, BOOL fForFilter, BOOL fHitContent)
{
    Assert(IsVisible());
    //
    // FATHIT. Fix for Bug 65015 - enabling "Fat" hit testing on tables.
    // TODO - At some point the edit team may want to provide
    // a better UI-level way of selecting nested "thin" tables
    //
    //
    // TODO - when this is done revert sig. of FuzzyRectIsHit to not take the extra param
    //   
    Assert(fHitContent || fForFilter || pContext->FuzzyRectIsHit(_rctBounds, IsFatHitTest() ));

    CDispClipTransform transformSaveTransformed(pContext->GetClipTransform());
    TransformedToBoxCoords(&pContext->GetClipTransform());
    CDispClipTransform transformSaveBox(pContext->GetClipTransform());
    BOOL               fPeerDeclinedHit = FALSE;
    
    // calculate clip and position info
    CDispInfo di;
    CalcDispInfo(pContext->GetClipRect(), &di);
    CRect rccContent(di._sizesContent);

    // hack for VID's "frozen" attribute
    {
        TransformBoxToContent(&pContext->GetClipTransform().NoClip(), di);
        CPoint ptcHitTest;
        pContext->GetHitTestPoint(&ptcHitTest);
        if (GetDispClient()->HitTestBoxOnly(
                &ptcHitTest,
                this,
                pContext->_pClientData))
        {
            // NOTE: don't bother to restore context transform for speed
            pContext->SetHitTestCoordinateSystem(COORDSYS_CONTENT);                
            return TRUE;
        }
        pContext->SetClipTransform(transformSaveBox);
    }

    // get the draw program
    CAryDrawProgram aryProgram;
    CAryDrawCookie aryCookie;
    int iPC;
    int iCookie;

    if (S_OK != GetDrawProgram(&aryProgram, &aryCookie, FILTER_DRAW_ALLLAYERS))
    {
        AssertSz(0, "Failed to get draw program");
        return FALSE;
    }

    // we will run the program backwards;  first fix up the arguments
    ReverseDrawProgram(aryProgram, &iPC, &iCookie);

    // search for a hit from foreground layers to background
    DISPNODELAYER layerStop;
    void * cookie = NULL;
    BOOL fContentHasDrawn = FALSE;
    BOOL fExpand = FALSE;
    CRect rcExpand = g_Zero.rc; // keep compiler happy

    TransformBoxToScroll(&pContext->GetClipTransform().NoClip(), di);

    for ( ;  iPC>=DP_START_INDEX;  --iPC)
    {
        switch (aryProgram[iPC])
        {
        case DP_DrawContent:
            layerStop = (DISPNODELAYER) aryProgram[--iPC];

            if (!fContentHasDrawn && DISPNODELAYER_FLOW >= layerStop)
            {
                CDispClipTransform transformSaveScroll(pContext->GetClipTransform());
                TransformScrollToContent(&pContext->GetClipTransform(), di);
                // hit test content
                fContentHasDrawn = TRUE;
                if (pContext->RectIsHit(di._rccBackgroundClip))
                {
                    TransformContentToFlow(&pContext->GetClipTransform(), di);
                    
                    CPoint ptfHitTest;
                    pContext->GetHitTestPoint(&ptfHitTest);

                    if (GetDispClient()->HitTestContent(
                            &ptfHitTest,
                            (CDispNode*)this,
                            pContext->_pClientData,
                            fPeerDeclinedHit ))
                    {
                        // NOTE: don't bother to restore context transform for speed
                        pContext->SetHitTestCoordinateSystem(COORDSYS_FLOWCONTENT);                
                        return TRUE;
                    }
                }
                pContext->SetClipTransform(transformSaveScroll);
            }
            break;

        case DP_Expand:
            fExpand = TRUE;
            rcExpand.right  = aryProgram[--iPC];
            rcExpand.bottom = aryProgram[--iPC];
            rcExpand.left   = aryProgram[--iPC];
            rcExpand.top    = aryProgram[--iPC];
            break;

        case DP_DrawPainterMulti:
            Assert(HasAdvanced() && iCookie>=1);
            cookie = aryCookie[--iCookie];
            // fall through to DP_DrawPainter

        case DP_DrawPainter:
        {
            CDispClipTransform transformSaveScroll(pContext->GetClipTransform());

            if (!fExpand)
            {
                if (pContext->RectIsHit(di._rccBackgroundClip))
                {
                    CPoint ptcHitTest;
                    BOOL   fLocalPeerDeclined = FALSE;
                    pContext->GetHitTestPoint(&ptcHitTest);
                    pContext->SetClipTransform(transformSaveTransformed);
                    if (GetDispClient()->HitTestPeer(
                            &ptcHitTest,
                            COORDSYS_CONTENT,
                            this,
                            cookie,
                            pContext->_pClientData,
                            fHitContent,
                            pContext,
                            &fLocalPeerDeclined ))
                    {
                        // NOTE: don't bother to restore context transform for speed
                        return TRUE;
                    }

                    fPeerDeclinedHit = fLocalPeerDeclined || fPeerDeclinedHit;
                }
            }
            else
            {
                Assert(HasAdvanced());
                CRect rcbBounds = GetBounds().Size();
                if (!fForFilter)
                    GetMappedBounds(&rcbBounds);
                rcbBounds.Expand(rcExpand);
                pContext->SetClipTransform(transformSaveBox);

                if (pContext->RectIsHit(rcbBounds))
                {
                    CPoint ptbHitTest;
                    BOOL   fLocalPeerDeclined = FALSE;

                    pContext->GetHitTestPoint(&ptbHitTest);
                    pContext->SetClipTransform(transformSaveTransformed);
                    if (GetDispClient()->HitTestPeer(
                            &ptbHitTest,
                            COORDSYS_BOX,
                            this,
                            cookie,
                            pContext->_pClientData,
                            fHitContent,
                            pContext,
                            &fLocalPeerDeclined ))
                    {
                        // NOTE: don't bother to restore context transform for speed
                        return TRUE;
                    }

                    fPeerDeclinedHit = fLocalPeerDeclined || fPeerDeclinedHit;
                }
            }
            cookie = NULL;
            fExpand = FALSE;
            pContext->SetClipTransform(transformSaveScroll);
            break;
        }

        case DP_DrawBackground:
            break;

        case DP_WindowTopMulti:     --iCookie;
        case DP_WindowTop:
            fExpand = FALSE;
            break;

        case DP_BoxToContent:
            break;

        case DP_DrawBorder:
            // hit test border
            pContext->SetClipTransform(transformSaveBox);
            if (HasBorder())
            {
                CSize sizepNode = GetSize();
                if (pContext->RectIsHit(di._rcbContainerClip) &&
                    (pContext->RectIsHit(CRect(0,0, di._prcbBorderWidths->left, sizepNode.cy)) ||
                     pContext->RectIsHit(CRect(0,0, sizepNode.cx, di._prcbBorderWidths->top)) ||
                     pContext->RectIsHit(CRect(sizepNode.cx - di._prcbBorderWidths->right, 0, sizepNode.cx, sizepNode.cy)) ||
                     pContext->RectIsHit(CRect(0, sizepNode.cy - di._prcbBorderWidths->bottom, sizepNode.cx, sizepNode.cy))))
                {
                    CPoint ptbHitTest;
                    pContext->GetHitTestPoint(&ptbHitTest);
                    BOOL fHitBorder = GetDispClient()->HitTestBorder(
                                                                        &ptbHitTest,
                                                                        (CDispNode*)this,
                                                                        pContext->_pClientData);                    
                    if (fHitBorder)
                    {
                        // NOTE: don't bother to context transform for speed
                        pContext->SetHitTestCoordinateSystem(COORDSYS_BOX);                
                        return TRUE;
                    }
                }
            }
            break;
        }
        
    }

    pContext->SetClipTransform(transformSaveTransformed);

    //
    // FATHIT. Fix for Bug 65015 - enabling "Fat" hit testing on tables.
    // TODO - At some point the edit team may want to provide
    // a better UI-level way of selecting nested "thin" tables
    //
    //
    // TODO - when this is done revert sig. of FuzzyRectIsHit to not take the extra param
    //
    
    // do fuzzy hit test if requested
    if (pContext->_cFuzzyHitTest &&
        !pContext->RectIsHit(_rctBounds) &&
        pContext->FuzzyRectIsHit(_rctBounds, IsFatHitTest()))
    {
        CPoint ptbHitTest;
        pContext->SetClipTransform(transformSaveBox);
        pContext->GetHitTestPoint(&ptbHitTest);
        if (GetDispClient()->HitTestFuzzy(
                &ptbHitTest,
                (CDispNode*)this,
                pContext->_pClientData))
        {
            pContext->SetHitTestCoordinateSystem(COORDSYS_BOX);
            return TRUE;
        }

        // restore transform
        pContext->SetClipTransform(transformSaveTransformed);
    }
    
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispLeafNode::CalculateInView
//
//  Synopsis:   Determine whether this leaf node is in view, and whether its
//              client must be notified.
//
//  Arguments:  transform           display transform, in COORDSYS_TRANSFORMED
//              fPositionChanged    TRUE if position changed
//              fNoRedraw           TRUE to suppress redraw (after scrolling)
//
//  Returns:    TRUE if this node is in view.
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
CDispLeafNode::CalculateInView(
        const CDispClipTransform& transform,
        BOOL fPositionChanged,
        BOOL fNoRedraw,
        CDispRoot *pDispRoot)
{
    // change to box coordinates
    CDispClipTransform newTransform(transform);
    TransformedToBoxCoords(&newTransform);
    
    CRect rcbBounds = GetExpandedBounds();
    BOOL fInView = rcbBounds.Intersects(newTransform.GetClipRect());
    BOOL fWasInView = IsInView();

    // notify client if client requests it and view status changes
    if (IsAllSet(s_notifyInViewChange | s_visibleBranch) && (fInView || fWasInView))
    {
        if (fPositionChanged)
            SetPositionChanged();
        
        NotifyInViewChange(
            newTransform,
            fInView,
            fWasInView,
            fNoRedraw,
            pDispRoot);
        
        SetPositionChanged(FALSE);
    }

    SetInView(fInView);
    return fInView;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispLeafNode::DrawSelf
//
//  Synopsis:   Draw this item.
//
//  Arguments:  pContext        draw context, in COORDSYS_BOX
//              pChild          start drawing at this child
//              lDrawLayers     layers to draw (for filters)
//
//----------------------------------------------------------------------------

void
CDispLeafNode::DrawSelf(CDispDrawContext* pContext, CDispNode* pChild,
                            LONG lDrawLayers)
{
    // shouldn't be called unless this node was selected to draw
    Assert(IsAllSet(pContext->GetDrawSelector()));
    Assert(IsSet(s_savedRedrawRegion) ||
           pContext->IntersectsRedrawRegion(GetExpandedBounds()) ||
           !pContext->GetClipTransform().IsOffsetOnly());
    Assert(!IsAnySet(s_flagsNotSetInDraw));
    Assert(pChild == NULL);

    // calculate clip and position info
    CDispInfo di;
    CalcDispInfo(pContext->GetClipRect(), &di);
    
    // prepare to run the draw program
    CRect rccContent(di._sizesContent);
    rccContent.OffsetRect(-di._sizesScroll);    // content offset
    
    DISPNODELAYER layerStop;
    CAryDrawProgram aryProgram;
    CAryDrawCookie aryCookie;
    if (S_OK != GetDrawProgram(&aryProgram, &aryCookie, lDrawLayers))
    {
        AssertSz(0, "Failed to get draw program");
        return;
    }
    BOOL fContentHasDrawn = FALSE;
    BOOL fDrawWithinBorders = TRUE;
    int iCookie = -1;
    void * cookie = NULL;
    BOOL fExpand = FALSE;
    CRect rcExpand = g_Zero.rc; // keep compiler happy

    CDispClipTransform transformBox = pContext->GetClipTransform();

    // TODO (sambent) containers draw background in box coordinates,
    // yet leaves draw in content coordinates.  Shouldn't they be the same?

    TransformBoxToContent(&pContext->GetClipTransform().NoClip(), di);
    pContext->SetClipRect(di._rccBackgroundClip);
    CRect rccClip(di._rccBackgroundClip);
    pContext->IntersectRedrawRegion(&rccClip);

    // run the program
    for (int iPC = DP_START_INDEX;  aryProgram[iPC] != DP_Done;  ++iPC)
    {
        switch (aryProgram[iPC])
        {
        case DP_DrawBorder:
            // draw optional border
            if (HasBorder())
            {
                CSaveDispClipTransform transformSaveContent(pContext);
                pContext->SetClipTransform(transformBox);
                //Assert(pContext is in box coords)
                DrawBorder(pContext, *di._prcbBorderWidths, GetDispClient());
            }
            // having drawn the border, we may not need to draw anything else
            fDrawWithinBorders = !rccClip.IsEmpty();
            break;

        case DP_DrawBackground:
            //Assert(pContext is in content coords);
            if (fDrawWithinBorders && HasBackground())
            {
                GetDispClient()->DrawClientBackground(
                        &rccContent,
                        &rccClip,
                        pContext->PrepareDispSurface(),
                        this, 
                        pContext->GetClientData(),
                        0);
            }
            // fall through to BoxToContent

        case DP_BoxToContent:
            // not needed for leaves - we're already in content coords
            break;

        case DP_DrawContent:
            layerStop = (DISPNODELAYER)aryProgram[++iPC];

            if (fDrawWithinBorders && !fContentHasDrawn && DISPNODELAYER_FLOW <= layerStop)
            {
                BOOL fRestoreTransform = (aryProgram[iPC+1] != DP_Done);
                CDispClipTransform transformSave;

                if (fRestoreTransform)
                    transformSave = pContext->GetClipTransform();
                
                TransformContentToFlow(&pContext->GetClipTransform().NoClip(),di);
                CRect rcfClip(rccClip);
                if (!di._sizecInset.IsZero())
                {
                    rcfClip.OffsetRect(-di._sizecInset);
                    rcfClip.IntersectRect(CRect(di._sizecBackground - di._sizecInset));
                }
                if (!rcfClip.IsEmpty())
                {
                    pContext->SetClipRect(rcfClip);
                    CRect rcfContent(di._sizesContent - di._sizecInset);
                    rcfContent.OffsetRect(-di._sizesScroll);    // content offset
                    GetDispClient()->DrawClient(
                        &rcfContent,
                        &rcfClip,
                        pContext->PrepareDispSurface(),
                        this,
                        0,
                        pContext->GetClientData(),
                        0);
                }

                if (fRestoreTransform)
                    pContext->SetClipTransform(transformSave);

                fContentHasDrawn = TRUE;
            }
            break;

        case DP_Expand:
            fExpand = TRUE;
            rcExpand.top    = aryProgram[++iPC];
            rcExpand.left   = aryProgram[++iPC];
            rcExpand.bottom = aryProgram[++iPC];
            rcExpand.right  = aryProgram[++iPC];
            break;

        case DP_DrawPainterMulti:
            Assert(HasAdvanced());
            cookie = aryCookie[++iCookie];
            // fall through to DP_DrawPainter

        case DP_DrawPainter:
            // Assert(pContext is in content coords);
            if (!fExpand)
            {
                if (fDrawWithinBorders)
                {
                    GetDispClient()->DrawClientLayers(
                        &rccContent,
                        &di._rccBackgroundClip,
                        pContext->PrepareDispSurface(),
                        this,
                        cookie,
                        pContext,
                        CLIENTLAYERS_AFTERBACKGROUND);
                }
            }
            else
            {
                Assert(HasAdvanced());
                CSaveDispClipTransform transformSaveContent(pContext);
                CRect rcbBounds = GetBounds().Size();
                GetMappedBounds(&rcbBounds);

                pContext->SetClipTransform(transformBox);
                rcbBounds.Expand(rcExpand);
                CRect rcbClip = rcbBounds;
                rcbClip.IntersectRect(transformBox.GetClipRect());

                GetDispClient()->DrawClientLayers(
                    &rcbBounds,
                    &rcbClip,
                    pContext->PrepareDispSurface(),
                    this,
                    cookie,
                    pContext,
                    CLIENTLAYERS_AFTERBACKGROUND);
            }
            cookie = NULL;
            fExpand = FALSE;
            break;

        case DP_WindowTopMulti:     ++iCookie;  // ignore cookie
        case DP_WindowTop:
            if (!HasWindowTop())
            {
                pContext->GetRootNode()->AddWindowTop(this);
            }
            fExpand = FALSE;
            break;

        default:
            AssertSz(0, "Unrecognized draw program opcode");
            break;
        }
    }

#if DBG==1
    CDebugPaint::PausePaint(tagPaintWait);
#endif
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispLeafNode::CalcDispInfo
//
//  Synopsis:   Calculate clipping and positioning info for this node.
//
//  Arguments:  rcbClip         clip rect in box coordinates
//              pdi             display info structure
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispLeafNode::CalcDispInfo(
        const CRect& rcbClip,
        CDispInfo* pdi) const
{
    CDispInfo& di = *pdi;   // notational convenience

    // no scrolling
    di._sizesScroll = g_Zero.size;

    // get content size and offset to local coordinates
    CRect rcpBounds;
    GetBounds(&rcpBounds);
    rcpBounds.GetSize(&di._sizesContent);
    rcpBounds.GetTopLeft(&di._sizepBoxToParent.AsPoint());
    
    // adjust by optional border
    GetBorderWidthsAndInset(&di._prcbBorderWidths, &di._sizecInset, &di._rcTemp);
    di._sizesContent.cx -= di._prcbBorderWidths->left + di._prcbBorderWidths->right;
    di._sizesContent.cy -= di._prcbBorderWidths->top + di._prcbBorderWidths->bottom;
    di._sizecBackground = di._sizesContent;
    di._sizebScrollToBox = di._prcbBorderWidths->TopLeft().AsSize();

    // calc container clip
    di._rcbContainerClip = rcbClip;
    
    // NOTE: CDispLeafNode doesn't use di._rccPositionedClip, so it is not initialized
    
    // calc background clip
    di._rccBackgroundClip = rcbClip;
    di._rccBackgroundClip.OffsetRect(-di._sizebScrollToBox);
    di._rccBackgroundClip.IntersectRect(CRect(di._sizecBackground));

    // calc flow clip
    di._rcfFlowClip = di._rccBackgroundClip;
    if (!di._sizecInset.IsZero())
    {
        di._rcfFlowClip.OffsetRect(-di._sizecInset);
        di._rcfFlowClip.IntersectRect(CRect(di._sizecBackground - di._sizecInset));
    }

    // optional offset from content origin
    if (HasContentOrigin())
    {
        const CSize& sizecOrigin = GetContentOrigin();
        di._sizesScroll += sizecOrigin;
        
        // adjust for content origin
        di._rccBackgroundClip.OffsetRect(-sizecOrigin);
        di._rcfFlowClip.OffsetRect(-sizecOrigin);
    }

    if (HasExpandedClipRect())
    {
        const CRect& rcExpandedClip = GetExpandedClipRect();
        di._rccBackgroundClip.Expand(rcExpandedClip);
        di._rcfFlowClip.Expand(rcExpandedClip);
    }
    
    // leaf nodes don't have positioned children, but we need this rectangle
    // for the TransformScrollToContent method
    di._rccPositionedClip = di._rccBackgroundClip;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispLeafNode::NotifyInViewChange
//              
//  Synopsis:   Notify client when this item's in-view status or position
//              changes.
//
//  Arguments:  transform           display transform in COORDSYS_BOX
//              fResolvedVisible    TRUE if this item is visible and in view
//              fWasResolvedVisible TRUE if this item was visible and in view
//              fNoRedraw           TRUE to suppress redraw
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispLeafNode::NotifyInViewChange(
        const CDispClipTransform& transform,
        BOOL fResolvedVisible,
        BOOL fWasResolvedVisible,
        BOOL fNoRedraw,
        CDispRoot *pDispRoot)
{
    CRect rcgClient;
    CRect rcgClip;

    GetGlobalClientAndClipRects(transform, &rcgClient, &rcgClip);

    DWORD viewChangedFlags = 0;
    if (fResolvedVisible)
        viewChangedFlags = VCF_INVIEW;
    if (fResolvedVisible != fWasResolvedVisible)
        viewChangedFlags |= VCF_INVIEWCHANGED;
    if (PositionChanged())
        viewChangedFlags |= VCF_POSITIONCHANGED;
    if (fNoRedraw)
        viewChangedFlags |= VCF_NOREDRAW;

    if (fResolvedVisible && GetDispClient()->WantsToBeObscured(this))
    {
        pDispRoot->AddObscureElement(this, rcgClient, rcgClip);
    }
    
    GetDispClient()->HandleViewChange(
        viewChangedFlags,
        &rcgClient,
        &rcgClip,
        this);

    if (HasAdvanced() && GetAdvanced()->HasOverlays())
    {
        GetAdvanced()->MoveOverlays();
    }
}


#if DBG==1
//+---------------------------------------------------------------------------
//
//  Member:     CDispLeafNode::DumpContentInfo
//
//  Synopsis:   Dump custom information for this node.
//
//  Arguments:  hFile       file handle to dump to
//              level       tree depth at this node
//              childNumber number of this child in parent list
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispLeafNode::DumpContentInfo(HANDLE hFile, long level, long childNumber) const
{
#if 0
    IDispClientDebug* pIDebug;
    if (SUCCEEDED(
        GetDispClient()->QueryInterface(IID_IDispClientDebug,(void**)&pIDebug)))
    {
        pIDebug->DumpDebugInfo(hFile, level, childNumber, this, 0);
        pIDebug->Release();
    }
#else
    GetDispClient()->DumpDebugInfo(hFile, level, childNumber, this, 0);
#endif
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\display\dispparent.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       dispparent.cxx
//
//  Contents:   Base class for parent (non-leaf) display nodes.
//
//  Classes:    CDispParentNode
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DISPPARENT_HXX_
#define X_DISPPARENT_HXX_
#include "dispparent.hxx"
#endif

#ifndef X_DISPCONTEXT_HXX_
#define X_DISPCONTEXT_HXX_
#include "dispcontext.hxx"
#endif

#ifndef X_DISPINFO_HXX_
#define X_DISPINFO_HXX_
#include "dispinfo.hxx"
#endif

PerfDbgTag(tagDispPosZ,      "Display", "Trace CDisplay::InsertChildInPosZ")


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::~CDispParentNode
//              
//  Synopsis:   Destruct this node, as well as any children marked for
//              destruction.
//              
//----------------------------------------------------------------------------


CDispParentNode::~CDispParentNode() 
{
    UnlinkChildren();
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::InsertChildInFlow
//              
//  Synopsis:   Insert new child at the end of the flow layer list.
//              
//  Arguments:  pNewChild       node to insert
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CDispParentNode::InsertChildInFlow(CDispNode* pNewChild)
{
    CDispNode *pChildPrev=NULL, *pChildNext=NULL;
    
    // scan backwards through layers
    for (CDispNode* pChild = _pLastChild; pChild; pChild = pChild->_pPrevious)
    {
        int childLayer = pChild->GetLayer();
        
        if (childLayer == s_layerFlow)
        {
            return (pChild->IsStructureNode())
                ? pChild->AsParent()->InsertLastChildNode(pNewChild)
                : pChild->InsertSiblingNode(pNewChild, after);
        }
        
        if (childLayer < s_layerFlow)
        {
            pChildPrev = pChild;
            break;
        }
        else
        {
            pChildNext = pChild;
        }
    }

    if ((pChildPrev && pChildPrev->IsStructureNode()) ||
        (pChildNext && pChildNext->IsStructureNode()))
    {
        // this node is a structure parent, but there are no children at the flow layer (yet)
        CDispParentNode *pParent = InsertNewStructureNode(pChildPrev, pChildNext,
                                                s_layerFlow, s_layerMask);
        return pParent ? pParent->InsertChildInFlow(pNewChild) : FALSE;
    }
    else    // not a structure parent
    {
        if (pChildPrev)
            return pChildPrev->InsertSiblingNode(pNewChild, after);
        else
            return InsertFirstChildNode(pNewChild);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::InsertFirstChildInFlow
//              
//  Synopsis:   Insert new child at the beginning of the flow layer list.
//              
//  Arguments:  pNewChild       node to insert
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CDispParentNode::InsertFirstChildInFlow(CDispNode* pNewChild)
{
    CDispNode *pChildPrev=NULL, *pChildNext=NULL;
    
    // scan forwards through layers
    for (CDispNode* pChild = _pFirstChild; pChild; pChild = pChild->_pNext)
    {
        int childLayer = pChild->GetLayer();
        
        if (childLayer == s_layerFlow)
        {
            return (pChild->IsStructureNode())
                ? pChild->AsParent()->InsertFirstChildNode(pNewChild)
                : pChild->InsertSiblingNode(pNewChild, before);
        }
        
        if (childLayer > s_layerFlow)
        {
            pChildNext = pChild;
            break;
        }
        else
        {
            pChildPrev = pChild;
        }
    }

    if ((pChildPrev && pChildPrev->IsStructureNode()) ||
        (pChildNext && pChildNext->IsStructureNode()))
    {
        // this node is a structure parent, but there are no children at the flow layer (yet)
        CDispParentNode *pParent = InsertNewStructureNode(pChildPrev, pChildNext,
                                                s_layerFlow, s_layerMask);
        return pParent ? pParent->InsertFirstChildInFlow(pNewChild) : FALSE;
    }
    else    // not a structure parent
    {
        if (pChildNext)
            return pChildNext->InsertSiblingNode(pNewChild, before);
        else
            return InsertLastChildNode(pNewChild);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::InsertChildInNegZ
//              
//  Synopsis:   Insert a negative z-ordered child node.
//              
//  Arguments:  pNewChild       child node to insert
//              zOrder          negative z value
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CDispParentNode::InsertChildInNegZ(CDispNode* pNewChild, LONG zOrder)
{
    Assert(zOrder < 0);

    CDispNode* pChild = _pFirstChild;

    BOOL fStructureParent = pChild && pChild->IsStructureNode();

    if (!fStructureParent)
    {
        // scan forwards through layers
        for ( ; pChild; pChild = pChild->_pNext)
        {
            int childLayer = pChild->GetLayer();
            Assert(!pChild->IsStructureNode());

            if (childLayer == s_layerNegZ)
            {
                // if we found a node with greater z order, insert before it
                if (pChild->IsGreaterZOrder(pNewChild, zOrder))
                    return pChild->InsertSiblingNode(pNewChild, before);
            }

            else //if (childLayer > s_layerNegZ)
                return pChild->InsertSiblingNode(pNewChild, before);
        }

        return InsertLastChildNode(pNewChild);
    }
    
    else    // this is a structure parent
    {
        CDispParentNode* pParent = NULL;
        CDispNode* pChildFirst = pChild;

        // scan forwards through layers
        for ( ; pChild; pChild = pChild->_pNext)
        {
            int childLayer = pChild->GetLayer();
            Assert(pChild->IsStructureNode());
            
            if (childLayer == s_layerNegZ)
            {
                pParent = pChild->AsParent();
                CDispNode* pRightChild = pParent->GetLastChildNode();
                if (pRightChild && pRightChild->IsGreaterZOrder(pNewChild, zOrder))
                {
                    break;
                }
            }
            
            else //if (childLayer > s_layerNegZ)
            {
                break;
            }
        }

        // if we didn't find the right parent, there are no (structure) children
        // at the right layer.  So create one.
        if (!pParent)
        {
            pParent = InsertNewStructureNode(NULL, pChildFirst,
                                            s_layerNegZ, s_layerMask);
        }

        // insert new child node in proper order inside this structure node
        return pParent ? pParent->InsertChildInNegZ(pNewChild, zOrder) : FALSE;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::InsertChildInPosZ
//              
//  Synopsis:   Insert a positive z-ordered child node.
//              
//  Arguments:  pNewChild       child node to insert
//              zOrder          positive z value
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CDispParentNode::InsertChildInPosZ(CDispNode* pNewChild, LONG zOrder)
{
    Assert(zOrder >= 0);

    BOOL fRet;

    PerfDbgLog(tagDispPosZ, this, "+CDispParentNode::InsertChildInPosZ");

    CDispNode* pChild = _pLastChild;

    BOOL fStructureParent = pChild && pChild->IsStructureNode();

    if (!fStructureParent)
    {
        // scan backwards through layers
        // NB: binary search here?
        for ( ; pChild; pChild = pChild->_pPrevious)
        {
            int childLayer = pChild->GetLayer();
            Assert(!pChild->IsStructureNode());
            
            if (childLayer == s_layerPosZ)
            {
                // if we found a node with lesser z order, insert after it
                if (!pChild->IsGreaterZOrder(pNewChild, zOrder))
                {
                    fRet = pChild->InsertSiblingNode(pNewChild, after);
                    goto PerfDbgOut;
                }
            }
            
            else //if (childLayer < s_layerPosZ)
            {
                fRet = pChild->InsertSiblingNode(pNewChild, after);
                goto PerfDbgOut;
            }
        }
        
        fRet = InsertFirstChildNode(pNewChild);

PerfDbgOut:
        PerfDbgLog(tagDispPosZ, this, "-CDispParentNode::InsertChildInPosZ (regular)");
    }
    
    else    // this is a structure parent
    {
        CDispParentNode* pParent = NULL;
        CDispNode* pChildLast = pChild;

        // scan backwards through layers
        for ( ; pChild; pChild = pChild->_pPrevious)
        {
            int childLayer = pChild->GetLayer();
            Assert(pChild->IsStructureNode());
            
            if (childLayer == s_layerPosZ)
            {
                pParent = pChild->AsParent();
                CDispNode* pLeftChild = pParent->GetFirstChildNode();
                if (pLeftChild && !pLeftChild->IsGreaterZOrder(pNewChild, zOrder))
                {
                    break;
                }
            }
            
            else //if (childLayer < s_layerPosZ)
            {
                break;
            }
        }

        // if we didn't find the right parent, there are no (structure) children
        // at the right layer.  So create one.
        if (!pParent)
        {
            pParent = InsertNewStructureNode(pChildLast, NULL,
                                            s_layerPosZ, s_layerMask);
        }

        PerfDbgLog(tagDispPosZ, this, "-CDispParentNode::InsertChildInPosZ (recurse)");

        // insert new child node in proper order inside this structure node
        fRet = pParent ? pParent->InsertChildInPosZ(pNewChild, zOrder) : FALSE;
    }

    return fRet;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::Recalc
//              
//  Synopsis:   Recalculate this node's cached state.
//              
//  Arguments:  pRecalcContext      display recalc context
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispParentNode::Recalc(CRecalcContext* pRecalcContext)
{
    // shouldn't be here unless this node requested recalc, or we're recalcing
    // the whole subtree
    Assert(MustRecalc() || pRecalcContext->_fRecalcSubtree);
    
    // rebalance children
    if (ChildrenChanged() && !IsStructureNode() && HasChildren())
        RebalanceParentNode();
    
    // recalculate children
    RecalcChildren(pRecalcContext);

    
    Assert(!IsInvalid());
    Assert(!MustRecalc() && !MustRecalcSubtree());
    
    ClearFlags(s_childrenChanged | s_newInsertion | s_recalc | s_recalcSubtree);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::RecalcChildren
//              
//  Synopsis:   Recalculate children.
//
//  Arguments:  pRecalcContext      recalc context
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispParentNode::RecalcChildren(
        CRecalcContext* pRecalcContext)
{
    Assert(pRecalcContext != NULL);
    
    CDispRecalcContext* pContext = DispContext(pRecalcContext);
    
    // set flag values that are passed down our subtree
    CSwapRecalcState swapRecalcState(pContext, this);

    // accumulate flag values that are propagated up the tree to the root
    int childrenFlags = 0;

    for (CDispNode* pChild = _pFirstChild; pChild; pChild = pChild->_pNext)
    {
        Assert(pContext->_fRecalcSubtree ||
            pChild->MustRecalc() ||
            !pChild->IsInvalid());

        // recalc children that need it, or all children if we are recalculating
        // the entire subtree
        if (pContext->_fRecalcSubtree || pChild->MustRecalc())
        {
            pChild->Recalc(pContext);
        }
        
        Assert(!pChild->IsInvalid());
        Assert(pChild->IsParentNode() || !pChild->PositionChanged());
        Assert(!pChild->MustRecalc());
        Assert(!pChild->MustRecalcSubtree());
        
        childrenFlags |= pChild->GetFlags();
    }

    // ensure that we don't bother to invalidate anything during bounds calc.
    SetMustRecalc();
    ComputeVisibleBounds();

    // set in-view status
    SetInView(pContext->IsInView(_rctBounds));
    
    // propagate flags from children, and clear recalc and inval flags
    CopyFlags(childrenFlags, s_inval | s_propagatedMask | s_recalc | s_recalcSubtree);
    
    Assert(!IsAnySet(s_inval | s_recalc | s_recalcSubtree));
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::PreDraw
//              
//  Synopsis:   Before drawing starts, PreDraw processes the redraw region,
//              subtracting areas that are blocked by opaque or buffered items.
//              PreDraw is finished when the redraw region becomes empty
//              (i.e., an opaque item completely obscures all content below it)
//              
//  Arguments:  pContext    draw context, in COORDSYS_TRANSFORMED
//              
//  Returns:    TRUE if first opaque node to draw has been found
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CDispParentNode::PreDraw(CDispDrawContext* pContext)
{
    // Interesting nodes are visible, in-view, opaque
    Assert(IsAllSet(s_preDrawSelector));
    Assert(pContext->IntersectsRedrawRegion(_rctBounds));
    Assert(!IsAnySet(s_flagsNotSetInDraw));

    // we shouldn't be here if this is an opaque node
    Assert(!IsOpaque());
    
    // the only node type that should be executing here is CDispStructureNode,
    // which can't be filtered or transformed
    Assert(!IsDrawnExternally() && !HasUserTransform());
    
    CDispClipTransform saveTransform(pContext->GetClipTransform());

    // continue predraw traversal of children, top layers to bottom
    for (CDispNode* pChild = _pLastChild; pChild; pChild = pChild->_pPrevious)
    {
        // only children which meet our selection criteria
        if (pChild->IsAllSet(s_preDrawSelector))
        {
            // if we found the first child to draw, stop further PreDraw calcs
            if (PreDrawChild(pChild, pContext, saveTransform))
                return TRUE;
        }
    }
    
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::PreDrawChild
//              
//  Synopsis:   Call the PreDraw method of the given child, and post-process
//              the results.
//              
//  Arguments:  pChild      child node to predraw
//              pContext    display context, in COORDSYS_TRANSFORMED for pChild
//              saveContext context of this parent node which may be saved
//                          on the context stack (and may differ from the
//                          child's context in pContext)
//              
//  Returns:    TRUE if first child to draw was this child or one of the
//              descendants in its branch
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CDispParentNode::PreDrawChild(
    CDispNode* pChild,
    CDispDrawContext* pContext,
    const CDispClipTransform& saveTransform) const
{
    Assert(pChild != NULL);
    Assert(pChild->IsAllSet(s_preDrawSelector));
    // PreDraw should weed out parent nodes with transforms before calling PreDrawChild
    Assert(!HasUserTransform());

    // do the clipped visible bounds of this child intersect the
    // redraw region?
    if (!pContext->IntersectsRedrawRegion(pChild->_rctBounds) ||
        !pChild->PreDraw(pContext))
    {
        // continue predraw pass
        return FALSE;
    }
    
    // if we get here, we found the last opaque node which intersects the
    // redraw region.  No node at any lower layer needs to be drawn.
    // Add context information to stack, which will be used by Draw.
    if (pChild != _pLastChild ||
        pContext->GetFirstDrawNode() == NULL)
    {
        pContext->SaveTransform(this, saveTransform);
        
        // if this child was the first node to be drawn, remember it
        if (pContext->GetFirstDrawNode() == NULL)
            pContext->SetFirstDrawNode(pChild);
    }
    
    // finished with predraw pass
    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::DrawSelf
//              
//  Synopsis:   Draw this node's children, no clip or offset changes.
//              
//  Arguments:  pContext        draw context, in COORDSYS_BOX
//              pChild          start drawing at this child
//              lDrawLayers     layers to draw (for filters)
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispParentNode::DrawSelf(CDispDrawContext* pContext, CDispNode* pChild, LONG lDrawLayers)
{
    // Interesting nodes are visible and in-view
    Assert(!HasUserTransform());  // nodes that can have transform should override DrawSelf
    Assert(IsAllSet(pContext->GetDrawSelector()));
    Assert(!IsAnySet(s_flagsNotSetInDraw));
    Assert(!IsDrawnExternally());
    
    // draw children, bottom layers to top
    if (pChild == NULL) pChild = _pFirstChild;
    for (; pChild; pChild = pChild->_pNext)
    {
        // only children which meet our visibility and inview criteria
        if (pChild->IsAllSet(pContext->GetDrawSelector()))
            pChild->Draw(pContext, NULL, FILTER_DRAW_ALLLAYERS);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::HitTestPoint
//              
//  Synopsis:   Test children for intersection with hit test point.
//              
//  Arguments:  pContext        hit context, in COORDSYS_TRANSFORMED
//              fHitContent     TRUE to hit contents of this container,
//                              regardless of this container's bounds
//              
//  Returns:    TRUE if intersection found
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CDispParentNode::HitTestPoint(CDispHitContext* pContext, BOOL fForFilter, BOOL fHitContent)
{
    Assert(IsVisibleBranch());
    Assert(fHitContent || fForFilter || pContext->FuzzyRectIsHit(_rctBounds, IsFatHitTest() ));

    // NOTE: we don't have to worry about any transforms, offsets, or
    // user clip here, because this code can only be executed by
    // CDispStructureNode, which has none of those.  All other parent
    // nodes derive from CDispContainer, which overrides HitTestPoint.
    
    // search for a hit from foreground layers to background
    for (CDispNode* pChild = _pLastChild; pChild; pChild = pChild->_pPrevious)
    {
        // NOTE: we can't select on s_inView because when sometimes we hit test
        // on content that is not in view.
        if (pChild->IsVisibleBranch())
        {
            //
            // FATHIT. Fix for Bug 65015 - enabling "Fat" hit testing on tables.
            // TODO - At some point the edit team may want to provide
            // a better UI-level way of selecting nested "thin" tables
            //
            //
            // TODO - when this is done revert sig. of FuzzyRectIsHit to not take the extra param
            //
            
            if (fHitContent || pContext->FuzzyRectIsHit(pChild->_rctBounds, IsFatHitTest() ) &&
                pChild->HitTestPoint(pContext))
            {
                return TRUE;
            }
        }
    }
    
    return FALSE;
}


CDispScroller *
CDispParentNode::HitScrollInset(const CPoint& pttHit, DWORD *pdwScrollDir)
{
    CDispScroller * pDispScroller;

    // search for a hit from foreground layers to background
    for (CDispNode* pChild = _pLastChild; pChild; pChild = pChild->_pPrevious)
    {
        if (pChild->IsParentNode() &&
            pChild->IsAllSet(s_inView | s_visibleBranch) &&
            pChild->_rctBounds.Contains(pttHit))
        {
            pDispScroller = pChild->HitScrollInset(pttHit, pdwScrollDir);
            if (pDispScroller)
            {
                return pDispScroller;
            }
        }
    }
    
    return NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::PushTransform
//              
//  Synopsis:   Get transform information for the given child node.
//              
//  Arguments:  pChild          the child node
//              pTransformStack transform stack to save transform changes in
//              pTransform      display transform
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispParentNode::PushTransform(
        const CDispNode* pChild,
        CDispTransformStack* pTransformStack,
        CDispClipTransform* pTransform) const
{
    // transform needs to be saved only if this child is not our last, or this
    // will be the first entry in the transform stack
    if (pChild != _pLastChild || pTransformStack->IsEmpty())
    {
        pTransformStack->ReserveSlot(this);
        if (_pParent != NULL)
            GetRawParentNode()->PushTransform(this, pTransformStack, pTransform);
        pTransformStack->PushTransform(*pTransform, this);
    }
    else if (_pParent != NULL)
    {
        GetRawParentNode()->PushTransform(this, pTransformStack, pTransform);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::ComputeVisibleBounds
//
//  Synopsis:   Compute visible bounds for a parent node, marking children
//              that determine the edges of these bounds
//              
//  Arguments:  none
//              
//  Returns:    TRUE if visible bounds changed.
//
//----------------------------------------------------------------------------

BOOL
CDispParentNode::ComputeVisibleBounds()
{
    // any node that can be filtered should have overridden ComputeVisibleBounds.
    // The only kind of node that doesn't override currently is CDispStructureNode.
    Assert(!IsDrawnExternally());
    
    CRect rctBounds;
    
    if (_pFirstChild == NULL)
    {
        rctBounds.SetRectEmpty();
    }
    
    else
    {
        rctBounds.SetRect(MAXLONG,MAXLONG,MINLONG,MINLONG);
    
        for (CDispNode* pChild = _pFirstChild; pChild; pChild = pChild->_pNext)
        {
            const CRect& rctChild = pChild->_rctBounds;
            if (!rctChild.IsEmpty())
            {
                rctBounds.Union(rctChild);
            }
        }
    }

    if (rctBounds != _rctBounds)
    {
        _rctBounds = rctBounds;
        return TRUE;
    }
    
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::CalculateInView
//
//  Synopsis:   Calculate whether this node and its children are in view or not.
//
//  Arguments:  pTransform          display transform, in COORDSYS_TRANSFORMED
//              fPositionChanged    TRUE if position changed
//              fNoRedraw           TRUE to suppress redraw (after scrolling)
//              
//  Returns:    TRUE if this node is in view
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
CDispParentNode::CalculateInView(CDispRoot *pDispRoot)
{
    CDispClipTransform transform;
    GetNodeClipTransform(&transform, COORDSYS_TRANSFORMED, COORDSYS_GLOBAL);
    return CalculateInView(transform, FALSE, FALSE, pDispRoot);
}


BOOL
CDispParentNode::CalculateInView(
    const CDispClipTransform& transform,
    BOOL fPositionChanged,
    BOOL fNoRedraw,
    CDispRoot *pDispRoot)
{
    // we shouldn't have to worry about user clip here, because all nodes that
    // provide user clip override CalculateInView
    Assert(!HasUserClip());
    
    BOOL fInView = _rctBounds.Intersects(transform.GetClipRect());
    BOOL fWasInView = IsInView();
    
    // calculate in view status of children unless this node is not in view
    // and was not in view
    if (fInView || fWasInView)
    {
        // accelerated way to clear in view status of all children, unless
        // some child needs change notification
        if (!fInView && !IsInViewAware())
        {
            ClearSubtreeFlags(s_inView);
            return FALSE;
        }
        
        for (CDispNode* pChild = _pFirstChild; pChild; pChild = pChild->_pNext)
            pChild->CalculateInView(transform, fPositionChanged, fNoRedraw, pDispRoot);
    }
    
    SetInView(fInView);
    return fInView;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::ClearSubtreeFlags
//
//  Synopsis:   Clear given flags in this subtree.
//
//  Arguments:  flags       flags to clear
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispParentNode::ClearSubtreeFlags(int flags)
{
    // this routine is optimized to deal only with propagated flag values
    Assert((flags & s_propagatedMask) == flags);
    
    ClearFlags(flags);
    
    // process children
    for (CDispNode* pChild = _pFirstChild; pChild; pChild = pChild->_pNext)
    {
        // only need to clear subtrees whose root has these flags set
        if (pChild->IsAnySet(flags))
        {
            if (pChild->IsLeafNode())
            {
                pChild->ClearFlags(flags);
            }
            else
            {
                pChild->AsParent()->ClearSubtreeFlags(flags);
            }
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::SetSubtreeFlags
//
//  Synopsis:   Set given flags in this subtree.
//
//  Arguments:  flags       flags to set
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispParentNode::SetSubtreeFlags(int flags)
{
    // only propagated flag values allowed
    // (to be consistent with ClearSubtreeFlags)
    Assert((flags & s_propagatedMask) == flags);
    
    SetFlags(flags);
    
    // process children
    for (CDispNode* pChild = _pFirstChild; pChild; pChild = pChild->_pNext)
    {
        if (pChild->IsLeafNode())
        {
            pChild->SetFlags(flags);
        }
        else
        {
            pChild->AsParent()->SetSubtreeFlags(flags);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::GetScrollableBounds
//              
//  Synopsis:   Calculate the bounds of scrollable content, excluding child nodes
//              which are marked as not contributing to scroll size calculations.
//              
//  Arguments:  prc         returns bounds of scrollable content
//              cs          coordinate system for returned rect
//              
//----------------------------------------------------------------------------

void
CDispParentNode::GetScrollableBounds(CRect* prc, COORDINATE_SYSTEM cs) const
{
    Assert(prc != NULL);
    
    *prc = g_Zero.rc;
    
    // extend size by size of positioned children which contribute to scrollable
    // content area
    for (CDispNode* pChild = _pFirstChild; pChild; pChild = pChild->_pNext)
    {
        CRect rccChild;
        
        // must recurse for parent nodes in the -Z and +Z layers, because
        // they may contain only relatively-positioned content.  For this
        // reason, it is NOT sufficient to use the child's _rctBounds.
        if (pChild->IsParentNode() &&
            !pChild->IsScroller() &&
            !pChild->IsDrawnExternally() &&
            !pChild->IsFlowNode())
        {
            pChild->AsParent()->GetScrollableBounds(&rccChild, COORDSYS_TRANSFORMED);
            prc->Union(rccChild);
        }
        else if (pChild->AffectsScrollBounds())
        {
            if (pChild->IsStructureNode())
                rccChild = pChild->_rctBounds;
            else
                pChild->GetExpandedBounds(&rccChild, COORDSYS_TRANSFORMED);
            prc->Union(rccChild);
        }
    }
    
    if (prc->IsEmpty())
        return;

    // note: we don't restrict bounds to positive coordinates here - 
    // CDispScroller::RecalcChildren (our only caller) has logic to do that
    // It also handles RTL, which is slightly trickier than just clipping negative
    
    // transform to requested coordinate system
    TransformRect(*prc, COORDSYS_CONTENT, prc, cs);
}


#if DBG==1
//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::VerifyTreeCorrectness
//
//  Synopsis:   Verify the display node integrity
//
//----------------------------------------------------------------------------

void
CDispParentNode::VerifyTreeCorrectness()
{
    // verify the basic node structure
    super::VerifyTreeCorrectness();

    for (CDispNode* pChild = _pFirstChild, *pLastChild = NULL; pChild; pLastChild = pChild, pChild = pChild->_pNext)
    {
        if (pLastChild)
        {
            AssertSz(pChild->GetLayer() >= pLastChild->GetLayer(),
                "Invalid layer ordering");
            if (!pChild->IsFlowNode() && !pLastChild->IsFlowNode())
            {
                CDispNode* pBefore = pLastChild;
                CDispNode* pAfter = pChild;
                if (pBefore->IsStructureNode())
                    pBefore = pBefore->GetLastChildNode();
                if (pAfter->IsStructureNode())
                    pAfter = pAfter->GetFirstChildNode();
                Assert(pBefore != NULL && pAfter != NULL);
                Assert(!pBefore->IsStructureNode() && !pAfter->IsStructureNode());
/* (dmitryt) there are legal situations when this invariant is not true.
   In particular, when massive attribute change is happening (somebody
   changing a lot of 'className' attributes from script is one example)
   we can have a disptree temporarily not reflecting the zindexes of 
   their clients. As calculations progress, order will be restored.
   See IE6 bug 16186 for details and repro.
   
#ifndef ND_ASSERT  // AlexPf: causes problems in Netdocs which sets z-index in .css files
                   // of relative positioned divs which are dynamically inserted. 20 05 1999
                   // Remove this assert when trident bug #79126 is resolved.
                {
                    int bf = 0; bf = bf + pBefore->GetZOrder();
                    int af = 0; af = af + pAfter->GetZOrder();
                AssertSz(!pBefore->IsGreaterZOrder(pAfter, pAfter->GetZOrder()),
                    "Invalid z ordering");
                }
#endif // ND_ASSERT
*/
            }
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::GetMemorySize
//              
//  Synopsis:   Return memory size of the display tree rooted at this node.
//              
//  Arguments:  none
//              
//  Returns:    Memory size of this node and its children.
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

size_t
CDispParentNode::GetMemorySize() const
{
    size_t size = GetMemorySizeOfThis();
    
    for (CDispNode* pChild = _pFirstChild; pChild; pChild = pChild->_pNext)
        size += pChild->GetMemorySize();
    
    return size;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispParentNode::VerifyFlags
//              
//  Synopsis:   Verify that nodes in this subtree have flags set properly.
//              
//  Arguments:  mask        mask to apply to flags
//              value       value to test after mask has been applied
//              fEqual      TRUE if value must be equal, FALSE if not equal
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispParentNode::VerifyFlags(
        int mask,
        int value,
        BOOL fEqual) const
{
    AssertSz((MaskFlags(mask) == value) == fEqual,
             "Display Tree flags are invalid");
    
    for (CDispNode* pChild = _pFirstChild; pChild; pChild = pChild->_pNext)
    {
        if (pChild->IsLeafNode())
        {
            AssertSz((pChild->MaskFlags(mask) == value) == fEqual,
                     "Display Tree flags are invalid");
        }
        else
        {
            pChild->AsParent()->VerifyFlags(mask, value, fEqual);
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\display\dispsizingnode.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       dispsizingnode.cxx
//
//  Contents:   Scroller node which resizes to contain its contents.
//
//  Classes:    CDispSizingNode
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DISPSIZINGNODE_HXX_
#define X_DISPSIZINGNODE_HXX_
#include "dispsizingnode.hxx"
#endif

MtDefine(CDispSizingNode, DisplayTree, "CDispSizingNode")


//+---------------------------------------------------------------------------
//
//  Member:     CDispSizingNode::RecalcChildren
//              
//  Synopsis:   Set the size of this node, if appropriate, after determining
//              the size of its contents.
//              
//  Arguments:  pContext        recalc context, in COORDSYS_TRANSFORMED
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispSizingNode::RecalcChildren(CRecalcContext* pContext)
{
    CRect rcbBorderWidths;
    GetBorderWidths(&rcbBorderWidths);
    CSize sizeBorder =
        rcbBorderWidths.TopLeft().AsSize() + rcbBorderWidths.BottomRight().AsSize();
    
    // add scrollbar widths only if we're being forced to display scrollbars
    if (_fForceVScrollbar)
        sizeBorder.cx += _sizeScrollbars.cx;
    if (_fForceHScrollbar)
        sizeBorder.cy += _sizeScrollbars.cy;
    
    // resize to probable new size (if we're wrong, we must resize after
    // super::RecalcChildren and recompute in view status of this subtree)
    if (_fResizeX)
        _rcpContainer.right = _rcpContainer.left +
        max(_sizeMinimum.cx, _sizesContent.cx + sizeBorder.cx);
    if (_fResizeY)
        _rcpContainer.bottom = _rcpContainer.top +
        max(_sizeMinimum.cy, _sizesContent.cy + sizeBorder.cy);
    
    super::RecalcChildren(pContext);
    
    // now determine whether we need to resize to fit our contents
    BOOL fSizeChanged = FALSE;
    if (_fResizeX)
    {
        long newRight = _rcpContainer.left +
            max(_sizeMinimum.cx, _sizesContent.cx + sizeBorder.cx);
        if (newRight != _rcpContainer.right)
        {
            _rcpContainer.right = newRight;
            fSizeChanged = TRUE;
        }
    }
    if (_fResizeY)
    {
        long newBottom = _rcpContainer.top +
            max(_sizeMinimum.cy, _sizesContent.cy + sizeBorder.cy);
        if (newBottom != _rcpContainer.bottom)
        {
            _rcpContainer.bottom = newBottom;
            fSizeChanged = TRUE;
        }
    }
    
    // recalculate in view status of this subtree if necessary
    if (fSizeChanged)
    {
        CDispRecalcContext *pDispContext = DispContext(pContext);
        ComputeVisibleBounds();
        CalculateInView(pDispContext->GetClipTransform(), TRUE, FALSE,
                                                    pDispContext->_pRootNode);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispSizingNode::SetSize
//              
//  Synopsis:   Set the minimum size of this sizing node.
//              
//  Arguments:  sizep           node size in parent coordinates
//              fInvalidateAll  TRUE to entirely invalidate this node
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispSizingNode::SetSize(const CSize& sizep, const CRect *prcpMapped, BOOL fInvalidateAll)
{
    _sizeMinimum = sizep;
    super::SetSize(_sizeMinimum, prcpMapped, fInvalidateAll);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\display\dispsurface.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       dispsurface.cxx
//
//  Contents:   Drawing surface abstraction used by display tree.
//
//  Classes:    CDispSurface
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DISPSURFACE_HXX_
#define X_DISPSURFACE_HXX_
#include "dispsurface.hxx"
#endif

#ifndef X_REGION_HXX_
#define X_REGION_HXX_
#include "region.hxx"
#endif

#ifndef X_DDRAW_H_
#define X_DDRAW_H_
#include "ddraw.h"
#endif

#ifndef X_DDRAWEX_H_
#define X_DDRAWEX_H_
#include <ddrawex.h>
#endif

#ifndef X_CDUTIL_HXX_
#define X_CDUTIL_HXX_
#include "cdutil.hxx"
#endif

#ifdef _MAC
#ifndef X_MACCONTROLS_HXX_
#define X_MACCONTROLS_HXX_
#include "maccontrols.h"
#endif
#endif

DeclareTag(tagSurfaceDraw, "Display", "trace CDispSurface::Draw");

MtDefine(CDispSurface, DisplayTree, "CDispSurface")

#if !defined (NODD)
extern HRESULT InitSurface();
extern CGlobalCriticalSection    g_csOscCache;
extern IDirectDraw * g_pDirectDraw;
extern DDPIXELFORMAT* PixelFormat(HDC hdc, long cBitsPixel);
#endif

CDispSurface::CDispSurface(HDC hdc)
{
    // there are a lot of checks to prevent this constructor from being called
    // with a NULL hdc.  If this ever happens, we will probably hang in
    // CDispRoot::DrawBands.
    Assert(hdc != NULL);

    SetRawDC(hdc);
}

CDispSurface::CDispSurface(const XHDC& hdc)
{
    // there are a lot of checks to prevent this constructor from being called
    // with a NULL hdc.  If this ever happens, we will probably hang in
    // CDispRoot::DrawBands.
    Assert(!hdc.IsEmpty());
    
    // not expecting to create a surface from an XHDC which is itself a surface
    Assert(hdc.pSurface() == NULL);

    SetRawDC(hdc.hdc());
}


CDispSurface::CDispSurface(IDirectDrawSurface *pDDSurface)
{
    Assert(pDDSurface != NULL);
    
    _pDDSurface = pDDSurface;
    pDDSurface->AddRef();

    pDDSurface->GetDC(&_hdc);
    _dwObjType = 0;

    WHEN_DBG( _hpal = (HPALETTE)::GetCurrentObject(_hdc, OBJ_PAL); )

    WHEN_DBG( InitFromDDSurface(_pDDSurface); )
}


// This is a private function, call it only from a constructor
void
CDispSurface::SetRawDC(HDC hdc)
{
    AssertSz(_pDDSurface == NULL && _hdc == NULL, "CDispSurface is not a reusable class, you need to construct a new one");

    _hdc = hdc;

    if (_hdc == NULL)
    {
#if DBG == 1
        _hpal = NULL;
#endif // DBG == 1
        return;
    }

#if DBG == 1
    _hpal = (HPALETTE)::GetCurrentObject(hdc, OBJ_PAL);

#if !defined(NODD)
    IDirectDrawSurface *pDDSurface = 0;

    HRESULT hr = GetSurfaceFromDC(&pDDSurface);
    if (!hr)
    {
        InitFromDDSurface(pDDSurface);
        ReleaseInterface(pDDSurface);
    }
#endif // !NODD
#endif // DBG == 1
}


#if DBG == 1
void
CDispSurface::InitFromDDSurface(IDirectDrawSurface *pDDSurface)
{
    DDSURFACEDESC desc;
    ZeroMemory(&desc, sizeof(desc));
    desc.dwSize = sizeof(desc);

    Assert(SUCCEEDED((pDDSurface)->GetSurfaceDesc(&desc)) && (desc.dwFlags & DDSD_CAPS));
    Assert((desc.ddsCaps.dwCaps & DDSCAPS_ZBUFFER) == 0);
}
#endif


//+---------------------------------------------------------------------------
//
//  Member:     CDispSurface::CreateBuffer
//              
//  Synopsis:   Create a buffer surface compatible with this (and all the args!)
//              
//  Arguments:  pSurface        surface to clone
//              fTexture        should the dd surface be a texture surface?
//
//  Returns:    A CDispSurface* or NULL
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

CDispSurface *
CDispSurface::CreateBuffer(long width, long height, short bufferDepth, HPALETTE hpal, BOOL fDirectDraw, BOOL fTexture)
{
    CDispSurface *pSurface = new CDispSurface();

    if (!pSurface)
        return 0;

    HRESULT hr;

#if !defined (NODD)
    if (fDirectDraw)
    {
        hr = THR(pSurface->InitDD(_hdc, width, height, bufferDepth, hpal, fTexture));
    }
    else
#endif
    {
        hr = THR(pSurface->InitGDI(_hdc, width, height, bufferDepth, hpal));
    }

    if (hr)
    {
        delete pSurface;
        return 0;
    }

    return pSurface;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDispSurface::IsCompat
//              
//  Synopsis:   Checks if the surface is compatible with the arguments
//              
//  Arguments:  See CreateBuffer
//              
//  Returns:    TRUE if successful
//              
//  Notes:      
//              
//----------------------------------------------------------------------------
BOOL
CDispSurface::IsCompat(long width, long height, short bufferDepth, HPALETTE hpal, BOOL fDirectDraw, BOOL fTexture)
{
    // TODO (michaelw) It really isn't enough to compare bufferDepth because of the strange
    //                   16 bit formats that may be different from one display to the next.
    //                   This could only happen in a multi monitor situation when we move from
    //                   entirely on one monitor to entirely on the other.  In all other cases
    //                   we are (I believe) insulated from this stuff.

    return (_sizeBitmap.cx >= width
    &&          _sizeBitmap.cy >= height
    &&          _bufferDepth == bufferDepth
    &&          (!hpal || _hpal == hpal)
    &&          (_pDDSurface != NULL) == fDirectDraw
    &&          _fTexture == fTexture);
}

#if !defined(NODD)
//+---------------------------------------------------------------------------
//
//  Member:     CDispSurface::InitDD
//              
//  Synopsis:   Create a DD surface.
//              
//  Arguments:  See CreateBuffer
//              
//  Returns:    A regular HRESULT
//              
//  Notes:      
//              
//----------------------------------------------------------------------------
HRESULT
CDispSurface::InitDD(HDC hdc, long width, long height, short bufferDepth, HPALETTE hpal, BOOL fTexture)
{
    // TODO: (mcalkins) Clean up this function a bit for feature fork.

    IDirectDrawPalette* pDDPal = 0;

    Assert(_pDDSurface == 0);
    Assert(_hbm == 0);

    HRESULT hr = THR(InitSurface());
    if (FAILED(hr))
        RRETURN(hr);

    // Figure out the dd pixel format for our buffer depth and dc
    DDPIXELFORMAT* pPF = PixelFormat(hdc, bufferDepth);
    if (!pPF)
        RRETURN(E_FAIL);

    // Setup the surface description
    DDSURFACEDESC	ddsd;

    ZeroMemory(&ddsd, sizeof(ddsd));

    ddsd.dwSize = sizeof(ddsd);
    ddsd.ddpfPixelFormat = *pPF;
    ddsd.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;
    ddsd.ddsCaps.dwCaps = DDSCAPS_DATAEXCHANGE | DDSCAPS_OWNDC;
    if (fTexture)
        ddsd.ddsCaps.dwCaps |= DDSCAPS_3DDEVICE;
    ddsd.dwWidth = width;
    ddsd.dwHeight = height;

    LOCK_SECTION(g_csOscCache);

    // Actually create the surface
    hr = THR(g_pDirectDraw->CreateSurface(&ddsd, &_pDDSurface, NULL));
    if (FAILED(hr))
        goto Cleanup;

    // set color table
    if (bufferDepth <= 8)
    {
        extern const PALETTEENTRY g_pal16[];
        extern const PALETTEENTRY g_pal2[];
        const PALETTEENTRY* pPal;
        PALETTEENTRY        pal256[256];
        long                cEntries;
        DWORD               pcaps;

        if (bufferDepth == 8)
        {
#ifdef NEVER
            int i       = 0;

            ZeroMemory(pal256, sizeof(pal256));

            for ( ; i < 256 ; i++)
            {
                pal256[i].peFlags   = PC_EXPLICIT;
                pal256[i].peRed     = i;
            }

            cEntries    = 256; // GetPaletteEntries(hpal, 0, 256, pal256);
#else  // !NEVER
            cEntries    = GetPaletteEntries(hpal, 0, 256, pal256);
#endif // !NEVER
            pPal        = pal256;
            pcaps       = DDPCAPS_8BIT;
        }
        else if (bufferDepth == 4)
        {
            cEntries    = 16;
            pPal        = g_pal16;
            pcaps       = DDPCAPS_4BIT;
        }
        else if (bufferDepth == 1)
        {
            cEntries    = 2;
            pPal        = g_pal2;
            pcaps       = DDPCAPS_1BIT;
        }
        else
        {
            Assert(0 && "invalid cBitsPerPixel");
            goto Cleanup;
        }
        
        // create and initialize a new DD palette
        hr = THR(g_pDirectDraw->CreatePalette(pcaps | DDPCAPS_INITIALIZE, (LPPALETTEENTRY)pPal, &pDDPal, NULL));
        if (FAILED(hr))
            goto Cleanup;

        // attach the DD palette to the DD surface
        hr = THR(_pDDSurface->SetPalette(pDDPal));
        if (FAILED(hr))
            goto Cleanup;
    }

    hr = THR(_pDDSurface->GetDC(&_hdc));
    _dwObjType = 0;
    if (FAILED(hr))
        goto Cleanup;

    if (hpal)
    {
#if DBG==1
    HPALETTE hPalOld = 
#endif
        SelectPalette(_hdc, hpal, TRUE);
#if DBG==1
        if(!hPalOld)
        {
            CheckSz(FALSE, "SelectPalette call into a DirectDraw DC failed!");
            if (GetObjectType((HGDIOBJ)hpal) != OBJ_PAL)
            {
                AssertSz(FALSE, "Something's wrong with the palette");
            }

            if (GetObjectType((HGDIOBJ)_hdc) != OBJ_MEMDC )
            {
                AssertSz(FALSE, "Something's wrong with the DC");
            }

            hpal = (HPALETTE)::GetCurrentObject(_hdc, OBJ_PAL);
        }
#endif
        ::RealizePalette(_hdc);
        _fDDPaletteSelected = true;
    }


    Assert(VerifyGetSurfaceFromDC());

    _sizeBitmap.cx = width;
    _sizeBitmap.cy = height;
    _fTexture = fTexture;
    _hpal = hpal;
    _bufferDepth = bufferDepth;

Cleanup:
    ReleaseInterface(pDDPal);
    if (hr)
        ClearInterface(&_pDDSurface);

    return hr;
}
#endif //NODD

//+---------------------------------------------------------------------------
//
//  Member:     CDispSurface::InitDD
//              
//  Synopsis:   Create a compatible bitmap surface.
//              
//  Arguments:  See CreateBuffer
//              
//  Returns:    A regular HRESULT
//              
//  Notes:      
//              
//----------------------------------------------------------------------------
HRESULT
CDispSurface::InitGDI(HDC hdc, long width, long height, short bufferDepth, HPALETTE hpal)
{
    // Compatible bitmaps have to be the same bith depth as the display
    Assert(bufferDepth == GetDeviceCaps(hdc, PLANES) * GetDeviceCaps(hdc, BITSPIXEL));

    _hbm = ::CreateCompatibleBitmap(hdc, width, height);
    if (!_hbm)
        RRETURN(GetLastError());

    _hdc = ::CreateCompatibleDC(hdc);
    _dwObjType = 0;
    if (!_hdc)
    {
        ::DeleteObject(_hbm);
        _hbm = NULL;
        RRETURN(GetLastError());
    }

    ::SelectObject(_hdc, _hbm);

    if (!hpal)
    {
        hpal = (HPALETTE) ::GetCurrentObject(hdc, OBJ_PAL);
        if (hpal == NULL)
            hpal = g_hpalHalftone;
    }

    if (hpal)
    {
        Verify(::SelectPalette(_hdc, hpal, TRUE));
        ::RealizePalette(_hdc);
    }

    _sizeBitmap.cx = width;
    _sizeBitmap.cy = height;
    _fTexture = FALSE;
    _hpal = hpal;
    _bufferDepth = bufferDepth;
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispSurface::~CDispSurface
//
//  Synopsis:   destructor
//
//----------------------------------------------------------------------------


CDispSurface::~CDispSurface()
{
    // Prevent Windows from RIPing when we delete our palette later on
    
    if (_fDDPaletteSelected)
    {
        Verify(::SelectPalette(_hdc, (HPALETTE)GetStockObject(DEFAULT_PALETTE), TRUE));
    }
    
    if (_hbm != NULL)
    {
        // clear out old bit map
        ::DeleteDC(_hdc);
        ::DeleteObject(_hbm);
    }

    if (_pDDSurface)
    {
        _pDDSurface->ReleaseDC(_hdc);
        _pDDSurface->Release();
    }

    Assert(_pBaseCcs == NULL);

}


//+---------------------------------------------------------------------------
//
//  Member:     CDispSurface::Draw
//              
//  Synopsis:   Blit the contents of this surface into the destination surface.
//              
//  Arguments:  pDestinationSurface     destination surface
//              rc                      rect to transfer (destination coords.)
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispSurface::Draw(CDispSurface* pDestinationSurface, const CRect& rc)
{
    Assert(pDestinationSurface != NULL);
    
    Assert(_hdc != NULL && (_hbm != NULL || _pDDSurface != NULL) && pDestinationSurface->_hdc != NULL);
    Assert(_sizeBitmap.cx > 0 && _sizeBitmap.cy > 0);

#if DBG == 1
    if (IsTagEnabled(tagSurfaceDraw))
    {
        TraceTag((tagSurfaceDraw,
            "drawing surf %x src %x (%ld,%ld) dst %x (%ld,%ld,%ld,%ld)",
            this, _hdc, _sizeBitmap.cx, _sizeBitmap.cy,
            pDestinationSurface->_hdc, rc.left, rc.top, rc.right, rc.bottom));

        extern void DumpHDC(HDC);
        DumpHDC(_hdc);
        DumpHDC(pDestinationSurface->_hdc);
    }
#endif

    ::BitBlt(
        pDestinationSurface->_hdc,
        rc.left, rc.top,
        min(_sizeBitmap.cx, rc.Width()),
        min(_sizeBitmap.cy, rc.Height()),
        _hdc,
        0, 0,
        SRCCOPY);

#ifdef _MAC
    DrawMacScrollbars();
#endif

}


//+---------------------------------------------------------------------------
//
//  Member:     CDispSurface::SetClip
//
//  Synopsis:   Set the clip region appropriately.
//
//  Arguments:  rcWillDraw      area that will be drawn
//              fGlobalCoords   TRUE if rcWillDraw is in global coordinates
//
//  Returns:    nothing
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispSurface::SetClip(const RECT& rcWillDraw, BOOL fGlobalCoords)
{
    Assert(_pTransform != NULL);

    if (!_fNeverClip)
    {
        CRect rcgClipNew = _pTransform->GetClipRectGlobal();
        BOOL fSetHDCClip = _fClipRgnHasChanged;
        
        // set the clip region if our clipping rect changed in a way that affects
        // the way that rcgWillDraw is clipped
        if (!fSetHDCClip && rcgClipNew != _rcgClip)
        {
            CRect rcgWillDraw;
            if (!fGlobalCoords)
                _pTransform->NoClip().Transform(rcWillDraw, &rcgWillDraw);
            else
                rcgWillDraw = rcWillDraw;
            BOOL fOldClipActive = !_rcgClip.Contains(rcgWillDraw);
            BOOL fNewClipActive = !rcgClipNew.Contains(rcgWillDraw);
            // since the old and new clip rects are different, we have to redo the
            // clip region if either of them would affect rcgWillDraw
            fSetHDCClip = fOldClipActive || fNewClipActive;
        }
        
        // must recalculate the clip region
        if (fSetHDCClip)
        {
            Assert(_prgnClip != NULL);
            
            _rcgClip = rcgClipNew;
            _fClipRgnHasChanged = FALSE;
            
            CRegion rgngClip;
            if (_prgnClip)
                rgngClip = *_prgnClip;
            rgngClip.Intersect(_rcgClip);
            rgngClip.SelectClipRgn(_hdc);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispSurface::GetDC
//
//  Synopsis:   Return an HDC for rendering, clip should be set by SetClip()
//
//  Arguments:  phdc            pointer to returned HDC
//
//  Returns:    S_OK if successful
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT
CDispSurface::GetDC(HDC* phdc)
{
    *phdc = _hdc;

#if DBG == 1
    if ((GetDeviceCaps(_hdc, PLANES) * GetDeviceCaps(_hdc, BITSPIXEL)) == 8)
    {
        Assert(_hpal == (HPALETTE)::GetCurrentObject(_hdc, OBJ_PAL));
    }
#endif

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispSurface::GetDirectDrawSurface
//
//  Synopsis:   Return a DirectDraw surface for rendering.
//
//  Arguments:  ppSurface       pointer to IDirectDrawSurface* for result
//              pOffset         offset from global coordinates
//
//  Returns:    S_OK if successful
//
//  Notes:      If the client didn't specify a desire for a DirectDraw
//              interface when inserted in the tree, he may not get one now.
//
//----------------------------------------------------------------------------

HRESULT
CDispSurface::GetDirectDrawSurface(
        IDirectDrawSurface** ppSurface,
        SIZE* pOffset)
{
    Assert(_pTransform != NULL);
    *ppSurface = _pDDSurface;
    _pTransform->GetOffsetDst((CPoint *)pOffset);

    if (NULL == _pDDSurface)
    {
        return E_FAIL;
    }
    else
    {
        return S_OK;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispSurface::GetSurface
//
//  Synopsis:   Get a surface using a general IID-based interface.
//
//  Arguments:  iid         IID of surface interface to be returned
//              ppv         interface pointer returned
//              pOffset     offset to global coordinates
//
//  Returns:    S_OK if successful, E_NOINTERFACE if we don't have the
//              requested interface, E_FAIL for other problems
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT
CDispSurface::GetSurface(REFIID iid, void** ppv, SIZE* pOffset)
{
    if (iid == IID_IDirectDrawSurface)
    {
        return GetDirectDrawSurface((IDirectDrawSurface**)ppv,pOffset);
    }
    return E_NOINTERFACE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispSurface::GetSurface
//
//  Synopsis:   Return current DC or DirectDraw rendering surface.
//
//  Arguments:  hdc         returns DC
//              ppSurface   returns DirectDraw surface
//
//  Notes:      The owner of the returned HDC remains the CDispSurface.
//              Callers should not cache it.
//
//----------------------------------------------------------------------------

void
CDispSurface::GetSurface(HDC *hdc, IDirectDrawSurface** ppSurface)
{
    if (_pDDSurface)
    {
        *hdc = NULL;
        _pDDSurface->AddRef();
        *ppSurface = _pDDSurface;
    }
    else
    {
        *ppSurface = NULL;
        *hdc = _hdc;
    }
}

HRESULT
CDispSurface::GetSurfaceFromDC(HDC hdc, IDirectDrawSurface **ppDDSurface)
{
#if !defined(NODD)
    IDirectDraw3 *pDD3 = 0;

    HRESULT hr = THR(InitSurface());
    if (FAILED(hr))
        goto Cleanup;

    {
        LOCK_SECTION(g_csOscCache);

        hr = THR(g_pDirectDraw->QueryInterface(IID_IDirectDraw3, (LPVOID *)&pDD3));
        if (FAILED(hr))
            goto Cleanup;
    }

    Assert(pDD3);
    hr = THR_NOTRACE(pDD3->GetSurfaceFromDC(hdc, ppDDSurface));


Cleanup:
    ReleaseInterface(pDD3);

#else
    HRESULT hr = E_FAIL;
#endif
    // This is the code that GetSurfaceFromDC fails to get the Surface
    RRETURN1(hr, DDERR_NOTFOUND  /*0x887600ff */);
}

//+---------------------------------------------------------------------------
//
//  Member:     CDispSurface::VerifyGetSurfaceFromDC
//
//  Synopsis:   Verifies that it is possible to GetSurfaceFromDC
//
//  Arguments:  hdc
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CDispSurface::VerifyGetSurfaceFromDC(HDC hdc)
{
#if !defined(NODD)
    IDirectDrawSurface *pDDSurface;

    HRESULT hr = THR_NOTRACE(GetSurfaceFromDC(hdc, &pDDSurface));

    if (SUCCEEDED(hr))
    {
        pDDSurface->Release();
    }

    return hr == S_OK;
#else
    return FALSE;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\display\dispnode.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       dispnode.cxx
//
//  Contents:   Base class for nodes in the display tree.
//
//  Classes:    CDispNode
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_DISPTRANSFORM_HXX_
#define X_DISPTRANSFORM_HXX_
#include "disptransform.hxx"
#endif

#ifndef X_DISPCONTEXT_HXX_
#define X_DISPCONTEXT_HXX_
#include "dispcontext.hxx"
#endif

#ifndef X_DISPINFO_HXX_
#define X_DISPINFO_HXX_
#include "dispinfo.hxx"
#endif

#ifndef X_DISPCLIENT_HXX_
#define X_DISPCLIENT_HXX_
#include "dispclient.hxx"
#endif

#ifndef X_DISPFILTER_HXX_
#define X_DISPFILTER_HXX_
#include "dispfilter.hxx"
#endif

#ifndef X_DISPROOT_HXX_
#define X_DISPROOT_HXX_
#include "disproot.hxx"
#endif

#ifndef X_DISPCONTAINER_HXX_
#define X_DISPCONTAINER_HXX_
#include "dispcontainer.hxx"
#endif

#ifndef X_DISPSCROLLER_HXX_
#define X_DISPSCROLLER_HXX_
#include "dispscroller.hxx"
#endif

#ifndef X_DISPSURFACE_HXX_
#define X_DISPSURFACE_HXX_
#include "dispsurface.hxx"
#endif

#ifndef X_DDRAW_H_
#define X_DDRAW_H_
#include "ddraw.h"
#endif

MtDefine(CAryDrawProgram, Mem, "CAryDrawProgram");
MtDefine(CAryDrawCookie, Mem, "CAryDrawCookie");
MtDefine(CDispNodeDrawProgram_pv, CAryDrawProgram, "CAryDrawProgram::_pv")
MtDefine(CDispNodeDrawCookie_pv, CAryDrawCookie, "CAryDrawCookie::_pv")
DeclareTag(tagDispNodeVisible, "Display", "disp node visibility");
ExternTag(tagHackGDICoords);


//========================================================================
// extras access

// The following set of macros (OFFSET_*) intended for generating CDispNode::_extraSizeTable.
// CDispNode::_sizeTable[n] should contain the sum of the lenght of all extras which flag values are presented in n.
// This table is somewhat similar to binary code.
// The meaning of binary value <A[n]A[n-1]...A[1]A[0]>, where A[i] = {0|1},
// is defined as sum((2^i) * A[i]);
// The table in question is composed by same manner, but instead of (2^i) the sizeof(extra number 'i') is used.

#define OFFSET_001(x) (x)/sizeof(DWORD_PTR),
#define OFFSET_002(x) OFFSET_001(x) OFFSET_001(x + sizeof(LONG_PTR                )) // simple border
#define OFFSET_004(x) OFFSET_002(x) OFFSET_002(x + sizeof(CRect                   )) // complex border
#define OFFSET_008(x) OFFSET_004(x) OFFSET_004(x + sizeof(CSize                   )) // inset
#define OFFSET_016(x) OFFSET_008(x) OFFSET_008(x + sizeof(CUserClipAndExpandedClip)) // user clip
#define OFFSET_032(x) OFFSET_016(x) OFFSET_016(x + sizeof(void*                   )) // extra cookie
#define OFFSET_064(x) OFFSET_032(x) OFFSET_032(x + sizeof(CExtraTransform         )) // display transform
#define OFFSET_128(x) OFFSET_064(x) OFFSET_064(x + sizeof(CExtraContentOrigin     )) // content origin (used for layout right-alignment in RTL nodes)
#define OFFSET_ALL OFFSET_128(0)

const BYTE CDispNode::_extraSizeTable[DISPEX_ALL+1] = { OFFSET_ALL };


//========================================================================
// new & delete operators; 

#if DBG == 1
void*
CDispNode::operator new(size_t cBytes, PERFMETERTAG mt)
{
    return MemAllocClear(mt, cBytes);
}
#endif

void*
CDispNode::operator new(size_t cBytes, PERFMETERTAG mt, DWORD extras)
{
    // compute size required by optional data
    int extraSize = GetExtraSize(extras);
    
    // allocate enough memory for object + optional data
    void* p = MemAllocClear(mt, cBytes + extraSize);
    if (p)
    {
        p = (char*)p + extraSize;
        ((CDispNode*)p)->_flags = extras;
        
        // Initialize Extras:
        if (extras & DISPEX_CONTENTORIGIN)
            ((CDispNode*)p)->SetContentOriginNoInval(CSize(0,0), -1);
    }
    return p;
}

void*
CDispNode::operator new(size_t cBytes, PERFMETERTAG mt, const CDispNode* pOrigin)
{
    Assert(pOrigin != NULL);
    DWORD extras = pOrigin->_flags & DISPEX_ALL;

    // compute size required by optional data
    int extraSize = GetExtraSize(extras);
    
    // allocate enough memory for object + optional data
    void* p = MemAllocClear(mt, cBytes + extraSize);
    if (p)
    {
        // copy extras
        memcpy(p, (char*)pOrigin - extraSize, extraSize);
    
        p = (char*)p + extraSize;
        ((CDispNode*)p)->_flags = extras;
    }
    return p;
}

#if DBG == 1
void
CDispNode::operator delete(void* pv)
{
    MemFree((char*)pv - GetExtraSize( ((CDispNode*)pv)->_flags & DISPEX_ALL));
}
#endif

//=============================================================================
// tree traversal

//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::GetParentNode
//              
//  Synopsis:   Walk up the current branch, skipping structured nodes, until
//              we find the non-structured node parent.
//              
//  Arguments:  none
//              
//  Returns:    pointer to true parent
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

CDispParentNode*
CDispNode::GetParentNode() const
{
    CDispParentNode* pParent = _pParent;
    while (pParent != NULL)
    {
        if (!pParent->IsStructureNode())
            break;
        pParent = pParent->_pParent;
        AssertSz(pParent != NULL, "No true parent found in GetParentNode()");
    }
    
    return pParent;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::GetRootNode
//              
//  Synopsis:   Return the root of the tree that contains this node, or this
//              node if it has no parent.
//              
//  Arguments:  none
//              
//  Returns:    pointer to root node of tree
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

CDispNode const*
CDispNode::GetRootNode() const
{
    for (CDispNode const* pNode = this; pNode->_pParent; pNode = pNode->_pParent) {}
    
    return pNode;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::IsAncestorOf
//              
//  Synopsis:   Am I an ancestor of the given node?
//              
//  Arguments:  pNode       candidate descendant
//              
//  Returns:    TRUE        if I'm an ancestor
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CDispNode::IsAncestorOf(const CDispNode *pNode) const
{
    for ( ; pNode; pNode = pNode->_pParent)
    {
        if (pNode == this)
            return TRUE;
    }
    
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::GetFirstChildNode
//              
//  Synopsis:   Return this node's first child node, descending into structure nodes.
//              
//  Returns:    pointer to child, may be NULL
//              
//----------------------------------------------------------------------------

CDispNode*
CDispNode::GetFirstChildNode() const
{
    Assert(IsParentNode());

    CDispNode* pNode = AsParent()->_pFirstChild;
    if (pNode)
    {
        while (pNode->IsStructureNode())
        {
            pNode = pNode->AsParent()->_pFirstChild;
            Assert(pNode);
        }
    }
    return pNode;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::GetLastChildNode
//              
//  Synopsis:   Return this node's last child node, descending into structure nodes.
//              
//  Returns:    pointer to child, may be NULL
//              
//----------------------------------------------------------------------------

CDispNode*
CDispNode::GetLastChildNode() const
{
    Assert(IsParentNode());

    CDispNode* pNode = AsParent()->_pLastChild;
    if (pNode)
    {
        while (pNode->IsStructureNode())
        {
            pNode = pNode->AsParent()->_pLastChild;
            Assert(pNode);
        }
    }
    return pNode;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::GetNextSiblingNode
//              
//  Synopsis:   Find the right nearest node, descending as necessary
//              through structure nodes.
//              
//----------------------------------------------------------------------------
CDispNode*
CDispNode::GetNextSiblingNode() const
{
    if (_pNext) return _pNext;

    // ascending to next level of tree
    for (CDispNode* pNode = _pParent; ; pNode = pNode->_pParent)
    {
        if (!pNode->IsStructureNode()) return 0;
        if (pNode->_pNext) break;
    }
    
    pNode = pNode->_pNext;
    Assert(pNode->IsStructureNode());

    // descending into structure nodes
    do
    {
        pNode = pNode->AsParent()->_pFirstChild;
        Assert(pNode);
    }
    while (pNode->IsStructureNode());

    return pNode;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::GetPreviousSiblingNode
//              
//  Synopsis:   Find the left nearest node, descending as necessary
//              through structure nodes.
//              
//----------------------------------------------------------------------------

CDispNode*
CDispNode::GetPreviousSiblingNode() const
{
    if (_pPrevious) return _pPrevious;

    // ascending to next level of tree
    for (CDispNode* pNode = _pParent; ; pNode = pNode->_pParent)
    {
        if (!pNode->IsStructureNode()) return 0;
        if (pNode->_pPrevious) break;
    }
    
    pNode = pNode->_pPrevious;
    Assert(pNode->IsStructureNode());

    // descending into structure nodes
    do
    {
        pNode = pNode->AsParent()->_pLastChild;
        Assert(pNode);
    }
    while (pNode->IsStructureNode());

    return pNode;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::GetFirstFlowChildNode
//              
//  Synopsis:   Get the first child flow node
//              
//  Returns:    ptr to the first child flow node, or NULL if there
//              are no children in flow layer
//              
//----------------------------------------------------------------------------

CDispNode*
CDispNode::GetFirstFlowChildNode() const
{
    Assert(IsParentNode());
    // scan forwards through layers
    for (CDispNode* pChild = AsParent()->_pFirstChild; pChild; pChild = pChild->_pNext)
    {
        int childLayer = pChild->GetLayer();
        if (childLayer == s_layerFlow)
            return (pChild->IsStructureNode())
                ? pChild->GetFirstChildNode()
                : pChild;
        if (childLayer > s_layerFlow)
            return NULL;
    }
    
    return NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::GetLastFlowChildNode
//              
//  Synopsis:   Get the last child flow node
//              
//  Returns:    ptr to the last child flow node, or NULL if there
//              are no children in flow layer
//              
//----------------------------------------------------------------------------

CDispNode*
CDispNode::GetLastFlowChildNode() const
{
    Assert(IsParentNode());
    // scan forwards through layers
    for (CDispNode* pChild = AsParent()->_pLastChild; pChild; pChild = pChild->_pPrevious)
    {
        int childLayer = pChild->GetLayer();
        if (childLayer == s_layerFlow)
            return (pChild->IsStructureNode())
                ? pChild->GetLastChildNode()
                : pChild;
        if (childLayer < s_layerFlow)
            return NULL;
    }
    
    return NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::GetLastInSameLayer
//              
//  Synopsis:   Get the last sibling of same layer type as this node.
//              
//  Returns:    ptr to the last sibling of same layer type as this node. Never NULL.
//              
//----------------------------------------------------------------------------

CDispNode*
CDispNode::GetLastInSameLayer() const
{
    CDispParentNode const* pParent = GetParentNode();
    Assert(pParent);

    int thisLayer = GetLayer();

    // scan backwards through layers
    for (CDispNode* pChild = pParent->_pLastChild; ; pChild = pChild->_pPrevious)
    {
        Assert(pChild);
        int childLayer = pChild->GetLayer();
        if (childLayer == thisLayer)
            break;
        Assert(childLayer > thisLayer);
    }
        
    return (pChild->IsStructureNode())
        ? pChild->GetLastChildNode()
        : pChild;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::TraverseInViewAware
//              
//  Synopsis:   Traverse the display tree from top to bottom, calling the
//              ProcessDisplayTreeTraversal on every in0view aware node
//
//  Arguments:  pClientData     client defined data
//              
//  Returns:    TRUE to continue traversal
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CDispNode::TraverseInViewAware(void* pClientData)
{
    // is this node interesting to us?
    if (!IsInViewAware())
        return TRUE;
    
    if (IsParentNode())
    {
        for (CDispNode* pChild = AsParent()->_pLastChild; pChild; pChild = pChild->_pPrevious)
        {
            if (!pChild->TraverseInViewAware(pClientData))
                return FALSE;
        }
    }

    return
        // TODO (donmarsh) -- this call seems to be about 13% slower
        // after the display tree split when loading select1600.htm.
        // I'm not sure why, but we have work to do here anyway to
        // decrease the frequency with which FixWindowZOrder is invoked.
        IsStructureNode() ||
        GetDispClient()->ProcessDisplayTreeTraversal(pClientData);
}


//=============================================================================


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::GetBounds
//
//  Synopsis:   Get the bounds of this node in the indicated coordinate system.
//
//  Arguments:  prcBounds           returns bounds rect
//              coordinateSystem    which coordinate system
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispNode::GetBounds(
        RECT* prcBounds,
        COORDINATE_SYSTEM coordinateSystem) const
{
    CRect rcpBounds;
    GetBounds(&rcpBounds);
    if (HasAdvanced())
    {
        GetAdvanced()->MapBounds(&rcpBounds);
    }

    TransformRect(rcpBounds, COORDSYS_PARENT, (CRect*) prcBounds, coordinateSystem);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::GetClippedBounds
//
//  Synopsis:   Get the clipped bounds of this node in the requested coordinate
//              system.
//
//  Arguments:  prcBounds           returns bounds rect
//              coordinateSystem    which coordinate system
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispNode::GetClippedBounds(
        CRect* prc,
        COORDINATE_SYSTEM coordinateSystem) const
{
    GetBounds(prc);
    CDispRoot const* pRoot = GetDispRoot();

    // don't clip if we're currently drawing for a filter (bug 104811)
    if (!(pRoot && pRoot->IsDrawingUnfiltered(this)))
    {
        CDispClipTransform transform;
        GetNodeClipTransform(&transform, COORDSYS_PARENT, COORDSYS_GLOBAL);
        
        prc->IntersectRect(transform.GetClipRect());
    }

    if (prc->IsEmpty())
    {
        *prc = g_Zero.rc;
    }
    else if (coordinateSystem != COORDSYS_PARENT)
    {
        TransformRect(*prc, COORDSYS_PARENT, prc, coordinateSystem);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::GetExpandedBounds
//
//  Synopsis:   Get the expanded bounds of this node in the indicated coordinate system.
//
//  Arguments:  prcBounds           returns bounds rect
//              coordinateSystem    which coordinate system
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispNode::GetExpandedBounds(
        CRect* prcBounds,
        COORDINATE_SYSTEM coordinateSystem) const
{
    CRect rcbBounds = GetExpandedBounds();
    TransformRect(rcbBounds, COORDSYS_BOX, prcBounds, coordinateSystem);
}







//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::GetScrollExtnet
//              
//  Synopsis:   Return the Scrolling bounds to outside callers.  This is currently
//              only used to size view Slaves that have no size of their own.
//
//  Notes   :   Use at you own peril.
//
//----------------------------------------------------------------------------

void
CDispNode::GetScrollExtent(CRect * prcsExtent, COORDINATE_SYSTEM coordSys) const
{
    Assert(!IsStructureNode() && " Structure nodes are supposed to be hidden to Layout!" );

    if (IsContainer())
    {
        AsParent()->GetScrollableBounds(prcsExtent, coordSys);
    }
    else 
    {
        GetBounds(prcsExtent, coordSys );
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::GetClipRect
//              
//  Synopsis:   Return the global clip rect in parent coordinates for this node.
//
//  Arguments:  prcpClip    returns clipping rect in parent coordinates
//
//  Returns:    TRUE if prcpClip is not empty
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
CDispNode::GetClipRect(RECT* prcpClip) const
{
    CDispClipTransform transform;
    GetNodeClipTransform(&transform, COORDSYS_PARENT, COORDSYS_GLOBAL);
    *prcpClip = transform.GetClipRect();
    return !transform.GetClipRect().IsEmpty();
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::GetClippedClientRect
//
//  Synopsis:   Get the clipped client rect of this node in the requested coordinate
//              system.
//
//  Arguments:  prc     returns bounds rect
//              type    which client rect
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispNode::GetClippedClientRect(RECT* prc, CLIENTRECT type) const
{
    CDispClipTransform transform;

    GetClientRect(prc, type);
    GetNodeClipTransform(&transform, COORDSYS_FLOWCONTENT, COORDSYS_GLOBAL);
    ((CRect*)prc)->IntersectRect(transform.GetClipRect());

    if (((CRect*)prc)->IsEmpty())
    {
        *prc = g_Zero.rc;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::GetSizeInsideBorder
//              
//  Synopsis:   Get the size of the area within the border of this node
//              in content coordinates.
//              
//  Arguments:  psizes          returns size of node inside border
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispNode::GetSizeInsideBorder(CSize* psizes) const
{
    *psizes = GetSize();
    
    if (HasBorder())
    {
        CRect rcbBorderWidths;
        GetBorderWidths(&rcbBorderWidths);
        *psizes -=
            rcbBorderWidths.TopLeft().AsSize() +
            rcbBorderWidths.BottomRight().AsSize();
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::SetVisible
//              
//  Synopsis:   Set this node's visibility.
//
//  Arguments:  fVisible    TRUE if this node is visible
//              
//----------------------------------------------------------------------------

void
CDispNode::SetVisible(BOOL fVisible)
{
    if (fVisible != IsVisible())
    {
        TraceTag((tagDispNodeVisible, "%x -> %s", this, (fVisible? "visible" : "hidden")));

        //
        // Make sure we send the view change notification for this
        // visibility change.
        //
        
        if (IsLeafNode() && IsInViewAware())
        {
            // must be a leaf node
            SetPositionChanged();
        }

        // if going invisible, invalidate current bounds
        if (!fVisible)
        {
            if (!IsInvalid())
                PrivateInvalidate(_rctBounds, COORDSYS_TRANSFORMED);
            
            ClearFlag(s_visibleNode);
        }
        else
        {
            SetFlags(s_inval | s_visibleNode);
        }

        RequestRecalc();
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::SetOpaque
//              
//  Synopsis:   Set the opacity of this node.  An opaque node must opaquely
//              draw every pixel within its bounds.
//
//  Arguments:  fOpaque         TRUE if this node is opaque
//              fIgnoreFilter   if TRUE, ignore filtering on this node
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispNode::SetOpaque(BOOL fOpaque, BOOL fIgnoreFilter)
{
    if (!IsDrawnExternally() || fIgnoreFilter)
    {
        if (fOpaque != IsOpaque())
        {
            SetFlag(s_opaqueNode, fOpaque);
            // note: s_opaqueBranch will be set appropriately in Recalc
            RequestRecalc();
        }
    }
}




//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::PrivateInvalidate
//              
//  Synopsis:   Invalidate the given rectangle.
//
//  Arguments:  rcInvalid           invalid rect
//              coordinateSystem    which coordinate system the rect is in
//              fSynchronousRedraw  TRUE to force synchronous redraw
//              fIgnoreFilter       TRUE to ignore filtering on this node
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispNode::PrivateInvalidate(
        const CRect& rcInvalid,
        COORDINATE_SYSTEM coordinateSystem,
        BOOL fSynchronousRedraw,
        BOOL fIgnoreFilter)
{
    HRESULT     hr = S_OK;

    if (HasWindowTop())
    {
        PrivateInvalidateAtWindowTop(rcInvalid, coordinateSystem, fSynchronousRedraw);
    }

    // conditions under which no invalidation is necessary:
    // 1. rcInvalid is empty
    // 2. this node is not visible or not in view
    // 3. a parent of this node has set flag to suppress invalidation
    // 4. this node isn't in a tree rooted in a CDispRoot node

    CRect rctInvalid;
    CDispNode* pChild;
    CDispNode* pParent;

    if (rcInvalid.IsEmpty() || !MustInvalidate())
        return;

    // don't clip if we're coming from a parent coordinate system.  This
    // is important to make sure that CDispNode::InvalidateEdges can
    // invalidate areas outside the current display node boundaries when
    // the display node is expanding.
    BOOL fClip = (coordinateSystem >= COORDSYS_BOX);
    
    // clip to userclip
    if (fClip)
    {
        if (HasUserClip())
        {
            CRect rcbInvalid;
            TransformAndClipRect(rcInvalid, coordinateSystem, &rcbInvalid, COORDSYS_BOX);
            rcbInvalid.IntersectRect(GetUserClip());
            TransformAndClipRect(rcbInvalid, COORDSYS_BOX, &rctInvalid, COORDSYS_TRANSFORMED);
            Assert(!HasExpandedClipRect());
        }
        else
        {
            TransformAndClipRect(rcInvalid, coordinateSystem, &rctInvalid, COORDSYS_TRANSFORMED);
        }
    }
    else
    {
        if (HasUserClip())
        {
            CRect rcbInvalid;
            TransformRect(rcInvalid, coordinateSystem, &rcbInvalid, COORDSYS_BOX);
            rcbInvalid.IntersectRect(GetUserClip());
            TransformRect(rcbInvalid, COORDSYS_BOX, &rctInvalid, COORDSYS_TRANSFORMED);
            Assert(!HasExpandedClipRect());
        }
        else
        {
            TransformRect(rcInvalid, coordinateSystem, &rctInvalid, COORDSYS_TRANSFORMED);
        }
    }

    if (HasExpandedClipRect())
    {
        const CRect& rcExpandedClip = GetExpandedClipRect();
        rctInvalid.Expand(rcExpandedClip);
        Assert(!HasUserClip());
    }
    
    if (rctInvalid.IsEmpty())
        return;

    pChild = this;

    // traverse tree to root, clipping rect as necessary
    for (pParent = GetRawParentNode();
         pParent != NULL;
         pChild = pParent, pParent = pParent->GetRawParentNode())
    {
        // hand off to filter
        if (!fIgnoreFilter)
        {
            if (pChild->IsDrawnExternally())
            {
                if (pChild->HasAdvanced())
                {
                    CRect rcbInvalid;
                    pChild->TransformRect(
                        rctInvalid,
                        COORDSYS_TRANSFORMED,
                        &rcbInvalid,
                        COORDSYS_BOX);
                    hr = THR_NOTRACE(pChild->GetDispClient()->InvalidateFilterPeer(&rcbInvalid,
                                                        NULL, fSynchronousRedraw));
                }
                // S_FALSE means the behavior could not be invalidated. This happens, for example when
                //  this is called when detaching the filter behavior for the page transiton. In that
                //  case we just invalidate the dispnode
                if(hr != S_FALSE)
                    return;
            }
        }
        else
        {
            // don't ignore filters of parent nodes further up this branch
            fIgnoreFilter = FALSE;
        }

        // transform to next parent's coordinate system
        pParent->TransformAndClipRect(
            rctInvalid,     // from child's transformed coords
            pChild->GetContentCoordinateSystem(),
            &rctInvalid,    // to parent's transformed coords
            COORDSYS_TRANSFORMED);
        
        // check for clipped rect
        if (rctInvalid.IsEmpty())
            return;
    }

    // we made it to the root with a non-empty rect
    if (pChild->IsDispRoot())
    {
        CDispRoot* pRoot = CDispRoot::Cast(pChild);
        pRoot->InvalidateRoot(rctInvalid, fSynchronousRedraw, FALSE);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::PrivateInvalidate
//              
//  Synopsis:   Invalidate the given region.
//
//  Arguments:  rgnInvalid          invalid region
//              coordinateSystem    which coordinate system the region is in
//              fSynchronousRedraw  TRUE to force synchronous redraw
//              fIgnoreFilter       TRUE to ignore filtering on this node
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispNode::PrivateInvalidate(
        const CRegion& rgnInvalid,
        COORDINATE_SYSTEM coordinateSystem,
        BOOL fSynchronousRedraw,
        BOOL fIgnoreFilter)
{
    CRect rcBounds;
        rgnInvalid.GetBounds(&rcBounds);
    PrivateInvalidate(rcBounds, coordinateSystem, fSynchronousRedraw, fIgnoreFilter);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::PrivateInvalidateAtWindowTop
//              
//  Synopsis:   Invalidate the given rectangle.
//
//  Arguments:  rcInvalid           invalid rect
//              coordinateSystem    which coordinate system the rect is in
//              fSynchronousRedraw  TRUE to force synchronous redraw
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispNode::PrivateInvalidateAtWindowTop(
        const CRect& rcInvalid,
        COORDINATE_SYSTEM coordinateSystem,
        BOOL fSynchronousRedraw)
{
    // conditions under which no invalidation is necessary:
    // 1. rcInvalid is empty
    // 2. this node isn't in a tree rooted in a CDispRoot node

    CRect rcgInvalid;
    CDispRoot* pDispRoot = GetDispRoot();

    if (rcInvalid.IsEmpty() || !pDispRoot)
        return;

    TransformRect(rcInvalid, coordinateSystem, &rcgInvalid, COORDSYS_GLOBAL);

    pDispRoot->InvalidateRoot(rcgInvalid, fSynchronousRedraw, FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::HitTest
//
//  Synopsis:   Determine whether and what the given point intersects.
//
//  Arguments:  pptHit              [in] the point to test
//                                  [out] if something was hit, the point is
//                                  returned in container coordinates for the
//                                  thing that was hit
//              coordinateSystem    [in out] the coordinate system for pptHit
//              pClientData         client data
//              fHitContent         if TRUE, hit test the content regardless
//                                  of whether it is clipped or not. If FALSE,
//                                  take current clipping into account,
//                                  and clip to the bounds of this container.
//              cFuzzyHitTest       Number of pixels to extend hit testing
//                                  rectangles in order to do "fuzzy" hit
//                                  testing
//
//  Returns:    TRUE if the point hit something.
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
CDispNode::HitTest(
        CPoint* pptHit,
        COORDINATE_SYSTEM* pCoordinateSystem,
        void* pClientData,
        BOOL fHitContent,
        long cFuzzyHitTest)
{
    // must be a visible node somewhere
    if (!IsVisibleBranch())
        return FALSE;
    
    // create hit context
    CDispHitContext hitContext;
    hitContext._pClientData = pClientData;
    hitContext._cFuzzyHitTest = cFuzzyHitTest;

    CDispClipTransform transform;
    GetNodeClipTransform(&transform, COORDSYS_TRANSFORMED, COORDSYS_GLOBAL);
    hitContext.SetClipTransform(transform);
        
    // if we're hit-testing content, take away the clipping
    if (fHitContent)
    {
        hitContext.SetHugeClip();
    }
    
#if DBG==1
    hitContext.GetClipTransform().NoClip()._csDebug = COORDSYS_TRANSFORMED;
    hitContext.GetClipTransform().NoClip()._pNode = this;
#endif
    
    // hit point in global coordinates
    CPoint ptgHitTest;
    TransformPoint(
        *pptHit,
        *pCoordinateSystem,
        &ptgHitTest,
        COORDSYS_GLOBAL);
    hitContext.SetHitTestPoint(ptgHitTest);
        
    hitContext.SetHitTestCoordinateSystem(*pCoordinateSystem);
    
    //
    // FATHIT. Fix for Bug 65015 - enabling "Fat" hit testing on tables.
    // TODO - At some point the edit team may want to provide
    // a better UI-level way of selecting nested "thin" tables
    //
    //
    // TODO - when this is done revert sig. of FuzzyRectIsHit to not take the extra param
    //
    if ((fHitContent || hitContext.FuzzyRectIsHit(_rctBounds, IsFatHitTest())) &&
        HitTestPoint(&hitContext, FALSE, fHitContent))
    {
        // if we hit something, the transform should still be in local coordinates
        // of the hit node
        // 
        hitContext.GetHitTestPoint(pptHit);
        *pCoordinateSystem = hitContext.GetHitTestCoordinateSystem();
        return TRUE;
    }
    
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::TransformRect
//
//  Synopsis:   Transform a rect from the source coordinate system to the
//              destination coordinate system.
//
//  Arguments:  rcSource        rect in source coordinates
//              csSource        source coordinate system
//              prcDestination  returns rect in destination coordinates
//              csDestination   destination coordinate system
//
//----------------------------------------------------------------------------

void
CDispNode::TransformRect(const CRect& rcSource,
                         COORDINATE_SYSTEM csSource,
                         CRect* prcDestination,
                         COORDINATE_SYSTEM csDestination) const
{
    CDispTransform transform;
    GetNodeTransform(&transform, csSource, csDestination);
    transform.Transform(rcSource, prcDestination);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::TransformAndClipRect
//
//  Synopsis:   Transform a rect from the source coordinate system to the
//              destination coordinate system with clipping.
//
//  Arguments:  rcSource        rect in source coordinates
//              csSource        source coordinate system
//              prcDestination  returns rect in destination coordinates
//              csDestination   destination coordinate system
//
//----------------------------------------------------------------------------

void
CDispNode::TransformAndClipRect(const CRect& rcSource,
                                COORDINATE_SYSTEM csSource,
                                CRect* prcDestination,
                                COORDINATE_SYSTEM csDestination) const
{
    CDispClipTransform transform;
    GetNodeClipTransform(&transform, csSource, csDestination);
    transform.Transform(rcSource, prcDestination);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::GetBorderWidthsAndInset
//              
//  Synopsis:   Optimized routine to get border widths and inset in one call.
//              
//  Arguments:  pprcbBorderWidths       returns pointer to border widths
//                                      (never NULL)
//              psizebInset             returns inset
//              prcTemp                 temporary rect which must remain in
//                                      scope as long as border information is
//                                      accessed
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispNode::GetBorderWidthsAndInset(
        CRect** pprcbBorderWidths,
        CSize* psizebInset,
        CRect* prcTemp) const
{
    if (HasExtra(DISPEX_SIMPLEBORDER))
    {
        long c = *((long*)
            GetExtra(DISPEX_SIMPLEBORDER));
        prcTemp->SetRect(c);
        *pprcbBorderWidths = prcTemp;
    }
    else if (HasExtra(DISPEX_COMPLEXBORDER))
        *pprcbBorderWidths = (CRect*)
        GetExtra(DISPEX_COMPLEXBORDER);
    else
        *pprcbBorderWidths = &((CRect&)g_Zero.rc);
    
    *psizebInset = HasExtra(DISPEX_INSET)
        ? *((CSize*) GetExtra(DISPEX_INSET))
        : g_Zero.size;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::GetNodeTransform
//
//  Synopsis:   Return a non-clipping transform.
//
//  Arguments:  pTransform      returns transform
//              csSource        source coordinate system
//              csDestination   destination coordinate system
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispNode::GetNodeTransform(
        CDispTransform* pTransform,
        COORDINATE_SYSTEM csSource,
        COORDINATE_SYSTEM csDestination) const
{
    pTransform->SetToIdentity();
    
#if DBG==1
    pTransform->_csDebug = csSource;
    pTransform->_pNode = this;
#endif
    
    if (csDestination == csSource)
        return;
    
    BOOL fReversed = FALSE;
    if (csDestination > csSource)
    {
        COORDINATE_SYSTEM csTemp = csSource;
        csSource = csDestination;
        csDestination = csTemp;
        fReversed = TRUE;
    }
    
    const CDispNode* pNode = this;
    while (pNode != NULL)
    {
        // no coordinate systems inside a structure node
        if (pNode->IsStructureNode())
        {
            if (csDestination != COORDSYS_GLOBAL)
                goto Done;
            csSource = COORDSYS_TRANSFORMED;
        }

        switch (csSource)
        {
        case COORDSYS_FLOWCONTENT:
            // COORDSYS_FLOWCONTENT --> COORDSYS_CONTENT
            if (pNode->HasInset())
                pTransform->AddPostOffset(pNode->GetInset());

            if (csDestination == COORDSYS_CONTENT)
                goto Done;
            
            // fall thru to continue transformation...

        case COORDSYS_CONTENT:
            // COORDSYS_CONTENT --> COORDSYS_SCROLL

            // Add content origin to right-align layouts in RTL nodes
            if (pNode->HasContentOrigin())
                pTransform->AddPostOffset(pNode->GetContentOrigin());

            // add scroll amount
            // TODO (donmarsh) - we may want to make this a flag instead of a
            // virtual call for perf
            if (pNode->IsScroller())
                pTransform->AddPostOffset(CDispScroller::Cast(pNode)->GetScrollOffsetInternal());
            
            if (csDestination == COORDSYS_SCROLL)
                goto Done;
            
            // fall thru to continue transformation...
            
        case COORDSYS_SCROLL:
            // COORDSYS_SCROLL --> COORDSYS_BOX
            
            // add offset for borders
            if (pNode->HasBorder())
            {
                // retrieve border widths
                CRect rcbBorderWidths;
                pNode->GetBorderWidths(&rcbBorderWidths);
                pTransform->AddPostOffset(rcbBorderWidths.TopLeft().AsSize());
            }
            
            // RTL: vertical scrollbar is on the left
            if (pNode->IsScroller() && CDispScroller::Cast(pNode)->IsRTLScroller())
                pTransform->AddPostOffset(
                    CSize(CDispScroller::Cast(pNode)->GetActualVerticalScrollbarWidth(), 0));
            
            if (csDestination == COORDSYS_BOX)
                goto Done;
            
            // fall thru to continue transformation...
            
        case COORDSYS_BOX:
            // COORDSYS_BOX --> COORDSYS_PARENT
            pTransform->AddPostOffset(pNode->GetPosition().AsSize());
            
            if (csDestination == COORDSYS_PARENT)
                goto Done;
            
            // fall thru to continue transformation...
            
        case COORDSYS_PARENT:
            // COORDSYS_PARENT --> COORDSYS_TRANSFORMED
            
            // apply optional user transform
            if (pNode->HasUserTransform())
            {
                CSize sizepToParent(pNode->GetPosition().AsSize());
                pTransform->AddPostOffset(-sizepToParent);
                pTransform->AddPostTransform(pNode->GetUserTransform());
                pTransform->AddPostOffset(sizepToParent);
            }
            
            if (csDestination == COORDSYS_TRANSFORMED)
                goto Done;
            
            // fall thru to continue transformation...
            
        case COORDSYS_TRANSFORMED:
            // COORDSYS_TRANSFORMED --> COORDSYS_GLOBAL
            csSource = pNode->GetContentCoordinateSystem();
            pNode = pNode->GetRawParentNode();
            
            // continue loop until we reach the root
            break;
        }
    }
    
Done:
    if (fReversed)
        pTransform->ReverseTransform();
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::GetNodeClipTransform
//
//  Synopsis:   Return a transform that can be used to transform values from
//              the source coordinate system to the destination coordinate
//              system.
//
//  Arguments:  pTransform      returns transform
//              csSource        source coordinate system
//              csDestination   destination coordinate system
//
//  Notes:      
//
//----------------------------------------------------------------------------

void
CDispNode::GetNodeClipTransform(
        CDispClipTransform* pTransform,
        COORDINATE_SYSTEM csSource,
        COORDINATE_SYSTEM csDestination) const
{
    pTransform->SetToIdentity();

#if DBG==1
    pTransform->NoClip()._csDebug = csSource;
    pTransform->NoClip()._pNode = this;
#endif
    
    if (csDestination == csSource)
        return;
    
    if (csDestination > csSource)
    {
        GetReversedNodeClipTransform(pTransform, csSource, csDestination);
        return;
    }
    
    CRect rcClip;
    CRect rcSourceClip;
    
    const CDispNode* pNode = this;
    while (pNode != NULL)
    {
        // no coordinate systems inside a structure node
        if (pNode->IsStructureNode())
        {
            if (csDestination != COORDSYS_GLOBAL)
                return;
            csSource = COORDSYS_TRANSFORMED;
        }
        
        switch (csSource)
        {
        case COORDSYS_FLOWCONTENT:
            // COORDSYS_FLOWCONTENT --> COORDSYS_CONTENT
            if (pNode->HasInset())
                pTransform->AddPostOffset(pNode->GetInset());
        
            if (csDestination == COORDSYS_CONTENT)
                return;
        
            // fall thru to continue transformation...
            
        case COORDSYS_CONTENT:
            // COORDSYS_CONTENT --> COORDSYS_SCROLL
            
            // Add user content origin to right-align layouts in RTL nodes
            if (pNode->HasContentOrigin())
                pTransform->AddPostOffset(pNode->GetContentOrigin());

            // add scroll amount
            // TODO (donmarsh) - we may want to make this a flag instead of a
            // virtual call for perf
            if (pNode->IsScroller())
                pTransform->AddPostOffset(CDispScroller::Cast(pNode)->GetScrollOffsetInternal());

            // do we need to clip content?
            if ((csSource == COORDSYS_FLOWCONTENT && pNode->GetFlowClipInScrollCoords(&rcClip)) ||
                (csSource == COORDSYS_CONTENT && pNode->IsClipNode()
                                && CDispClipNode::Cast(pNode)->GetContentClipInScrollCoords(&rcClip)))
            {
                pTransform->Untransform(rcClip, &rcSourceClip); // to source coords.
                pTransform->SetClipRect(rcSourceClip);
            }
            
            if (csDestination == COORDSYS_SCROLL)
                return;
            
            // fall thru to continue transformation...
            
        case COORDSYS_SCROLL:
            // COORDSYS_SCROLL --> COORDSYS_BOX

            // add offset for borders
            if (pNode->HasBorder())
            {
                CRect rcbBorderWidths;
                pNode->GetBorderWidths(&rcbBorderWidths);
                pTransform->AddPostOffset(rcbBorderWidths.TopLeft().AsSize());
            }
            
            // RTL: vertical scrollbar is on the left
            if (pNode->IsScroller() && CDispScroller::Cast(pNode)->IsRTLScroller())
                pTransform->AddPostOffset(
                    CSize(CDispScroller::Cast(pNode)->GetActualVerticalScrollbarWidth(), 0));
            
            if (csDestination == COORDSYS_BOX)
                return;
            
            // fall thru to continue transformation...
            
        case COORDSYS_BOX:
            // COORDSYS_BOX --> COORDSYS_PARENT
            if (pNode->HasUserClip())
            {
                pTransform->Untransform(pNode->GetUserClip(), &rcSourceClip); // to source coords.
                pTransform->SetClipRect(rcSourceClip);
            }
            pTransform->AddPostOffset(pNode->GetPosition().AsSize());
            
            if (csDestination == COORDSYS_PARENT)
                return;
            
            // fall thru to continue transformation...
            
        case COORDSYS_PARENT:
            // COORDSYS_PARENT --> COORDSYS_TRANSFORMED
            
            // apply optional user transform
            if (pNode->HasUserTransform())
            {
                CSize sizepToParent(pNode->GetPosition().AsSize());
                pTransform->AddPostOffset(-sizepToParent);
                pTransform->AddPostTransform(pNode->GetUserTransform());
                pTransform->AddPostOffset(sizepToParent);
            }
            
            if (csDestination == COORDSYS_TRANSFORMED)
                return;
            
            // fall thru to continue transformation...
            
        case COORDSYS_TRANSFORMED:
            // COORDSYS_TRANSFORMED --> COORDSYS_GLOBAL
            csSource = pNode->GetContentCoordinateSystem();
            pNode = pNode->GetRawParentNode();
            
            // continue loop until we reach the root
            break;
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::GetReversedNodeClipTransform
//
//  Synopsis:   Return a transform that can be used to transform values from
//              the source coordinate system to the destination coordinate
//              system.
//
//  Arguments:  pTransform      returns transform
//              csSource        source coordinate system
//              csDestination   destination coordinate system
//
//  Notes:      
//
//----------------------------------------------------------------------------

void
CDispNode::GetReversedNodeClipTransform(
        CDispClipTransform* pTransform,
        COORDINATE_SYSTEM csSource,
        COORDINATE_SYSTEM csDestination) const
{
    Assert(csDestination > csSource);
    
    if (csSource == COORDSYS_GLOBAL)
    {
        GetGlobalNodeClipTransform(pTransform, csDestination);
        return;
    }
    
    CRect rcClip;
    CRect rcSourceClip;
    
    // no coordinate systems inside a structure node
    if (IsStructureNode())
        return;
    
    switch (csSource)
    {
    case COORDSYS_TRANSFORMED:
        // COORDSYS_TRANSFORMED --> COORDSYS_PARENT
        
        // apply optional user transform
        if (HasUserTransform())
        {
            CSize sizepToParent(GetPosition().AsSize());
            pTransform->AddPreOffset(-sizepToParent);
            CDispTransform userTransform(GetUserTransform());
            userTransform.ReverseTransform();
            pTransform->AddPreTransform(userTransform);
            pTransform->AddPreOffset(sizepToParent);
        }
        
        if (csDestination == COORDSYS_PARENT)
            break;
        
        // fall thru to continue transformation...
        
    case COORDSYS_PARENT:
        // COORDSYS_PARENT --> COORDSYS_BOX
        pTransform->AddPreOffset(-GetPosition().AsSize());
        if (HasUserClip())
        {
            pTransform->SetClipRect(GetUserClip());
        }
        
        if (csDestination == COORDSYS_BOX)
            break;
        
        // fall thru to continue transformation...
        
    case COORDSYS_BOX:
        // COORDSYS_BOX --> COORDSYS_SCROLL

        // RTL scroller has vertical scrollbar on the left
        if (IsScroller() && CDispScroller::Cast(this)->IsRTLScroller())
            pTransform->AddPreOffset(
                CSize(-CDispScroller::Cast(this)->GetActualVerticalScrollbarWidth(), 0));
        
        // add offset for borders
        if (HasBorder())
        {
            CRect rcbBorderWidths;
            GetBorderWidths(&rcbBorderWidths);
            pTransform->AddPreOffset(-rcbBorderWidths.TopLeft().AsSize());
        }
        
        if (csDestination == COORDSYS_SCROLL)
            break;
        
        // fall thru to continue transformation...
        
    case COORDSYS_SCROLL:
        // COORDSYS_SCROLL --> COORDSYS_CONTENT
        
        // do we need to clip content?
        if ((csSource == COORDSYS_FLOWCONTENT && GetFlowClipInScrollCoords(&rcClip)) ||
            (csSource == COORDSYS_CONTENT && IsClipNode()
                        && CDispClipNode::Cast(this)->GetContentClipInScrollCoords(&rcClip)))
        {
            pTransform->SetClipRect(rcClip);
        }
        
        // add scroll amount
        // TODO (donmarsh) - we may want to make this a flag instead of a
        // virtual call for perf
        if (IsScroller())
            pTransform->AddPreOffset(-CDispScroller::Cast(this)->GetScrollOffsetInternal());

        // Add user content origin to right-align layouts in RTL nodes
        if (HasContentOrigin())
            pTransform->AddPreOffset(-GetContentOrigin());

        if (csDestination == COORDSYS_CONTENT)
            break;
        
        // fall thru to continue transformation...
        
    case COORDSYS_CONTENT:
        // COORDSYS_CONTENT --> COORDSYS_FLOWCONTENT
        if (HasInset())
            pTransform->AddPreOffset(-GetInset());
    
        Assert(csDestination == COORDSYS_FLOWCONTENT);
        
        break;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::GetGlobalNodeClipTransform
//
//  Synopsis:   Return a transform that can be used to transform values from
//              COORDSYS_GLOBAL to the destination coordinate system.
//
//  Arguments:  pTransform      returns transform
//              csDestination   destination coordinate system
//
//  Notes:      
//
//----------------------------------------------------------------------------

void
CDispNode::GetGlobalNodeClipTransform(
        CDispClipTransform* pTransform,
        COORDINATE_SYSTEM csDestination) const
{
    CDispNode* pParent = GetRawParentNode();
    if (pParent != NULL)
    {
        pParent->GetGlobalNodeClipTransform(pTransform, GetContentCoordinateSystem());
    }
    
    GetReversedNodeClipTransform(pTransform, COORDSYS_TRANSFORMED, csDestination);
}

    
//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::GetGlobalClientAndClipRects, helper
//
//  Synopsis:   Compute the client and clip rects (in global coordinates)
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispNode::GetGlobalClientAndClipRects(
        const CDispClipTransform& transform,
        CRect *prcgClient,
        CRect *prcgClip) const
{
    // calculate clip and position info
    CDispInfo di;
    CalcDispInfo(transform.GetClipRect(), &di);

    // calculate client rect in global coordinates
    CRect rcbClient(
        di._sizebScrollToBox.AsPoint(),
        di._sizesContent - di._sizecInset);
    transform.NoClip().Transform(rcbClient, prcgClient);

    // calculate clip rect in global coordinates
    CRect rcbClip(di._rcfFlowClip); // in flow coordinates
    // to box coords
    rcbClip.OffsetRect(di._sizecInset + di._sizesScroll + di._sizebScrollToBox);
    transform.Transform(rcbClip, prcgClip);
    prcgClip->IntersectRect(*prcgClient);
    if (prcgClip->IsEmpty())   // normalize empty rect for ignorant clients
        prcgClip->SetRectEmpty();

    // fixing bug 106399 (mikhaill) - on zooming transform
    // obtained prcgClip can be inexact because of rounding,
    // so we need the following additional intersection
    prcgClip->IntersectRect(transform.GetClipRectGlobal());
}

    
//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::ScrollRectIntoView
//
//  Synopsis:   Scroll the given rect in CONTENT coordinates into
//              view, with various pinning (alignment) options.
//
//  Arguments:  rc              rect to scroll into view
//              coordSystem     coordinate system for rc (COORDSYS_CONTENT
//                              or COORDSYS_FLOWCONTENT only)
//              spVert          scroll pin request, vertical axis
//              spHorz          scroll pin request, horizontal axis
//
//  Returns:    TRUE if any scrolling was necessary.
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispNode::ScrollRectIntoView(
        const CRect& rc,
        COORDINATE_SYSTEM coordSystem,
        SCROLLPIN spVert,
        SCROLLPIN spHorz)
{
    CRect rcScroll(rc);
    CDispNode* pNode = NULL;
    CDispNode* pParent = this; 
    
    // adjust scroll offsets for every node on this branch which is a scroller
    while (pParent != NULL && !rcScroll.IsEmpty())
    {
        Assert(coordSystem == COORDSYS_CONTENT || coordSystem == COORDSYS_FLOWCONTENT);
        pNode = pParent;
        pParent = pNode->GetRawParentNode();
        pNode->PrivateScrollRectIntoView(&rcScroll, coordSystem, spVert, spHorz);
        pNode->TransformAndClipRect(rcScroll, coordSystem, &rcScroll, COORDSYS_TRANSFORMED);
        coordSystem = pNode->GetContentCoordinateSystem();
    }
    
    // TRICKY: if any scroller along the branch needed to change its scroll
    // offset, it would call RequestRecalc, which would set the s_recalc flag
    // on the root.  Therefore, we can look at that flag to see if a synchronous
    // redraw is now necessary.
    
    // do a synchronous update if necessary
    if (!rcScroll.IsEmpty() && pNode->IsDispRoot() && pNode->IsSet(s_recalc))
    {
        CDispRoot::Cast(pNode)->InvalidateRoot(rcScroll, TRUE, TRUE);
    }
}

void
CDispNode::ScrollIntoView(SCROLLPIN spVert, SCROLLPIN spHorz)
{
    CDispParentNode* pParent = GetRawParentNode();
    if (pParent != NULL)
    {
        CRect rctBounds;
        GetBounds(&rctBounds, COORDSYS_TRANSFORMED);
        pParent->ScrollRectIntoView(
            rctBounds, GetContentCoordinateSystem(),
            spVert, spHorz);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::MustInvalidate
//
//  Synopsis:   A parent node may have already invalidated the area within
//              its clipping region, so children may not have to do invalidation
//              calculations.
//
//  Arguments:  none
//
//  Returns:    TRUE if this node must perform invalidation calculations.
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
CDispNode::MustInvalidate() const
{
    for (const CDispNode* pNode = this;
         pNode != NULL;
         pNode = pNode->GetRawParentNode())
    {
        if (pNode->IsInvalid())
            return FALSE;
    }

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::InvalidateEdges
//
//  Synopsis:   Invalidate edges of a node that is changing size.
//
//  Arguments:  sizebOld        old node size
//              sizebNew        new node size
//              rcbBorderWidths width of borders
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispNode::InvalidateEdges(
        const CSize& sizebOld,
        const CSize& sizebNew,
        const CRect& rcbBorderWidths)
{
    // TODO (donmarsh) -- this routine does not currently handle resizing
    // of RTL elements.  It assumes only the right edge needs to be invalidated
    // when horizontal size changes.  Need to revisit when we have our new RTL
    // strategy in place.
    
    Assert(sizebNew != sizebOld);
    
    CRect rcbInval;

    // invalidate right edge and border
    if (sizebOld.cx != sizebNew.cx || rcbBorderWidths.right > 0)
    {
        rcbInval.SetRect(
            min(sizebOld.cx, sizebNew.cx) - rcbBorderWidths.right,
            0,
            max(sizebOld.cx, sizebNew.cx),
            max(sizebOld.cy, sizebNew.cy) - rcbBorderWidths.bottom);
        Invalidate(rcbInval, COORDSYS_BOX);
    }
    
    // invalidate bottom edge and border
    if (sizebOld.cy != sizebNew.cy || rcbBorderWidths.bottom > 0)
    {
        rcbInval.SetRect(
            0,
            min(sizebOld.cy, sizebNew.cy) - rcbBorderWidths.bottom,
            max(sizebOld.cx, sizebNew.cx),
            max(sizebOld.cy, sizebNew.cy));
        Invalidate(rcbInval, COORDSYS_BOX);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::SetUserClip
//
//  Synopsis:   Set user clip rect for this node.
//
//  Arguments:  rcbUserClip      rectangle in box coordinates
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispNode::SetUserClip(const RECT& rcbUserClip)
{
    // if not invalid, and visible branch and visible node
    if (MaskFlags(s_inval | s_visibleBranch | s_visibleNode)
                        == (s_visibleBranch | s_visibleNode))
    {
        // invalidate area that was exposed before (in case it will be clipped
        // now and nodes beneath need to be repainted)
        CRect rcbInvalid;
        TransformRect(_rctBounds, COORDSYS_TRANSFORMED, &rcbInvalid, COORDSYS_BOX);
        rcbInvalid.IntersectRect(GetUserClip());
        Invalidate(rcbInvalid, COORDSYS_BOX);

        // invalidate new clipped area
        SetInvalid();
    }

    RequestRecalcSubtree();

    CRect rcbUC(rcbUserClip);
    rcbUC.RestrictRange();
    Assert(HasExtra(DISPEX_USERCLIP));
    ((CUserClipAndExpandedClip*)GetExtra(DISPEX_USERCLIP))->_fUserClip = TRUE;
    ((CUserClipAndExpandedClip*)GetExtra(DISPEX_USERCLIP))->_fExpandedClip = FALSE;
    ((CUserClipAndExpandedClip*)GetExtra(DISPEX_USERCLIP))->_rcClip = rcbUC;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::RestrictUserClip
//
//  Synopsis:   Restrict user clip rectangle so as no coordinate exceeds +-LONG_MAX/2
//
//----------------------------------------------------------------------------
void CDispNode::RestrictUserClip()
{
    CRect* prcUserClip = (CRect*)GetExtra(DISPEX_USERCLIP);
    prcUserClip->RestrictRange();
}

//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::PreDraw
//
//  Synopsis:   Before drawing starts, PreDraw processes the redraw region,
//              subtracting areas that are blocked by opaque or buffered items.
//              PreDraw is finished when the redraw region becomes empty
//              (i.e., an opaque item completely obscures all content below it)
//
//              NOTE: This method is called by subclasses to handle opaque
//              items and containers.
//
//  Arguments:  pContext    draw context
//
//  Returns:    TRUE if first opaque node to draw has been found
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
CDispNode::PreDraw(CDispDrawContext* pContext)
{
    // Interesting nodes are visible branch, in-view, opaque
    Assert(IsAllSet(s_preDrawSelector));
    Assert(pContext->IntersectsRedrawRegion(_rctBounds));
    Assert(!IsAnySet(s_flagsNotSetInDraw));

    // if this node isn't visible, opacity doesn't matter
    if (!IsVisible())
        return FALSE;

    // don't subtract transformed nodes
    if (HasUserTransform())
        return FALSE;

    // We do not delve inside a node whose content is drawn externally.
    // TODO (sambent) Someday, filters may help determine whether PreDraw
    // can safely look at its children and come up with the correct answers.
    if (IsDrawnExternally())
        return FALSE;

    // determine if enough of this opaque thing is visible to warrant
    // expensive subtraction from the redraw region
    const CRegion* prgngRedraw = pContext->GetRedrawRegion();
    CRect rcpBounds;
    CRect rcgBounds;
    GetBounds(&rcpBounds);
    if (HasUserClip())
    {
        CRect rcpUserClip(GetUserClip());   // in box coordinates
        rcpUserClip.OffsetRect(rcpBounds.TopLeft().AsSize());   // to parent coordinates
        rcpBounds.IntersectRect(rcpUserClip);
    }
    pContext->GetClipTransform().Transform(rcpBounds, &rcgBounds);
    
    // on Win_9x, we can't allow operations on regions that exceed GDI's 16-bit
    // resolution, therefore we don't perform opaque optimizations in these cases
    BOOL fHackForGDI = g_dwPlatformID == VER_PLATFORM_WIN32_WINDOWS;
#if DBG==1
    if (IsTagEnabled(tagHackGDICoords)) fHackForGDI = TRUE;
#endif
    if (fHackForGDI &&
        rcgBounds.Width() > 32767 ||
        rcgBounds.Height() > 32767 ||
        rcgBounds.left < -32768 || rcgBounds.left > 32767 ||
        rcgBounds.top < -32768 || rcgBounds.top > 32767 ||
        rcgBounds.right < -32768 || rcgBounds.right > 32767 ||
        rcgBounds.bottom < -32768 || rcgBounds.bottom > 32767)
        return FALSE;
    
    if (prgngRedraw->BoundsInside(rcgBounds))
    {
        // add this node to the redraw region stack
        Verify(!pContext->PushRedrawRegion(rcgBounds,this));
        return TRUE;
    }

    CRegion rgngGlobal(rcgBounds);
    rgngGlobal.Intersect(*prgngRedraw);
    CRect rcgBounds2;
        rgngGlobal.GetBounds(&rcgBounds2);
    if (rcgBounds2.Area() < MINIMUM_OPAQUE_PIXELS)
    {
        // intersection isn't big enough, simply continue processing
        return FALSE;
    }

    // TODO (donmarsh) - The following code prevents an opaque item from
    // subtracting itself from a rectangular redraw region and producing
    // a non-rectangular result.  Non-rectangular regions are just too
    // slow for Windows to deal with.
    switch (prgngRedraw->ResultOfSubtract(rgngGlobal))
    {
    case CRegion::SUB_EMPTY:
        // this case should have been identified already above
        Assert(FALSE);
        return FALSE;
    case CRegion::SUB_RECTANGLE:
        // subtract this item's region and continue predraw processing
        if (!pContext->PushRedrawRegion(rgngGlobal,this))
            return TRUE;
        break;
    case CRegion::SUB_REGION:
        // don't subtract this item's region to keep redraw region simple
        break;
    case CRegion::SUB_UNKNOWN:
        // see if we can get back to a simple rectangular redraw region
        if (!pContext->PushRedrawRegion(rgngGlobal,this))
        {
            return TRUE;
        }
        prgngRedraw = pContext->GetRedrawRegion();
        if (prgngRedraw->IsComplex())
        {
            pContext->RestorePreviousRedrawRegion();
        }
        break;
    }

    // TODO (donmarsh) - what I would have liked to do instead of the
    // code above.
#ifdef NEVER
    // subtract the item's clipped and offset bounds from the redraw region
    if (!pContext->PushRedrawRegion(rgngGlobal,this))
        return TRUE;
#endif

    return FALSE;
}


// here are the fixed draw programs
const int 
CDispNode::s_rgDrawPrograms[][DP_MAX_LENGTH] =
{
    { DP_PROGRAM(NONE)
        DP_DrawBorder,
        DP_DrawBackground,
        DP_DrawContent, DISPNODELAYER_POSITIVEZ,
        DP_Done,
    },

    { DP_PROGRAM(REPLACE_ALL)
        DP_Expand, 0, 0, 0, 0,
        DP_DrawPainter,
        DP_Done,
    },

    { DP_PROGRAM(REPLACE_CONTENT)
        DP_DrawBorder,
        DP_DrawBackground,
        DP_DrawPainter,
        DP_Done,
    },

    { DP_PROGRAM(REPLACE_BACKGROUND)
        DP_DrawBorder,
        DP_BoxToContent,
        DP_DrawPainter,
        DP_DrawContent, DISPNODELAYER_POSITIVEZ,
        DP_Done,
    },

    { DP_PROGRAM(BELOW_CONTENT)
        DP_DrawBorder,
        DP_DrawBackground,
        DP_DrawPainter,
        DP_DrawContent, DISPNODELAYER_POSITIVEZ,
        DP_Done,
    },

    { DP_PROGRAM(BELOW_FLOW)
        DP_DrawBorder,
        DP_DrawBackground,
        DP_DrawContent, DISPNODELAYER_NEGATIVEZ,
        DP_DrawPainter,
        DP_DrawContent, DISPNODELAYER_POSITIVEZ,
        DP_Done,
    },

    { DP_PROGRAM(ABOVE_FLOW)
        DP_DrawBorder,
        DP_DrawBackground,
        DP_DrawContent, DISPNODELAYER_FLOW,
        DP_DrawPainter,
        DP_DrawContent, DISPNODELAYER_POSITIVEZ,
        DP_Done,
    },

    { DP_PROGRAM(ABOVE_CONTENT)
        DP_DrawBorder,
        DP_DrawBackground,
        DP_DrawContent, DISPNODELAYER_POSITIVEZ,
        DP_DrawPainter,
        DP_Done,
    },

    { DP_PROGRAM(WINDOW_TOP)
        DP_DrawBorder,
        DP_DrawBackground,
        DP_DrawContent, DISPNODELAYER_POSITIVEZ,
        DP_WindowTop,
        DP_Done,
    },
};

// The order in the previous array must match the HTMLPAINT_ZORDER enum.
COMPILE_TIME_ASSERT_1( HTMLPAINT_ZORDER_NONE, 0 );
COMPILE_TIME_ASSERT_1( HTMLPAINT_ZORDER_REPLACE_ALL, 1 );
COMPILE_TIME_ASSERT_1( HTMLPAINT_ZORDER_REPLACE_CONTENT, 2 );
COMPILE_TIME_ASSERT_1( HTMLPAINT_ZORDER_REPLACE_BACKGROUND, 3 );
COMPILE_TIME_ASSERT_1( HTMLPAINT_ZORDER_BELOW_CONTENT, 4 );
COMPILE_TIME_ASSERT_1( HTMLPAINT_ZORDER_BELOW_FLOW, 5 );
COMPILE_TIME_ASSERT_1( HTMLPAINT_ZORDER_ABOVE_FLOW, 6 );
COMPILE_TIME_ASSERT_1( HTMLPAINT_ZORDER_ABOVE_CONTENT, 7 );
COMPILE_TIME_ASSERT_1( HTMLPAINT_ZORDER_WINDOW_TOP, 8);


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::GetDrawProgram
//              
//  Synopsis:   Select a draw program to execute.  If there are multiple
//              painters, we construct the program dynamically.  Otherwise
//              we pick one from the list of predefined programs.
//              
//  Arguments:  paryProgram     array for program
//              paryCookie      array for cookie arguments in the program
//              lDrawLayers     which layers to draw (for filters)
//
//  Returns:    S_OK            normal
//              S_FALSE         use default (hardwired) program
//              E_*             error
//----------------------------------------------------------------------------

HRESULT
CDispNode::GetDrawProgram(CAryDrawProgram *paryProgram,
                          CAryDrawCookie *paryCookie,
                          LONG lDrawLayers)
{
    HRESULT hr = S_FALSE;

    if (!HasAdvanced())
    {
        CAryDispClientInfo aryInfo;
        const LONG lZOrder = GetPainterInfo(&aryInfo);

        if (!NeedAdvanced(&aryInfo, lDrawLayers))
        {
            Assert(0 <= lZOrder && lZOrder < ARRAY_SIZE(s_rgDrawPrograms));
            Assert(s_rgDrawPrograms[lZOrder][DP_START_INDEX-1] == lZOrder);
            if (OK(paryProgram->Grow(DP_MAX_LENGTH)))
            {
                hr = paryProgram->CopyIndirect(DP_MAX_LENGTH, (int *) s_rgDrawPrograms[lZOrder], FALSE);
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else
        {
            // Advanced mode is normally detected in the recalc pass.
            // The one exception is page transitions.  When Apply() is called to
            // take the "before" picture of the old page, the filter behavior
            // will call RenderElement with non-trivial lDrawLayers, and this
            // requires advanced mode.  We can't tell at recalc time, because
            // we don't know whether our client is involved in a page transition.
            AssertSz(GetDispClient()->IsInPageTransitionApply(),
                        "advanced mode should be set during recalc");
            SetUpAdvancedDisplay();
        }
    }

    if (HasAdvanced())
    {
        hr = GetAdvanced()->GetDrawProgram(paryProgram, paryCookie, lDrawLayers);
    }
    
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::GetPainterInfo
//              
//  Synopsis:   Get painter info from the client
//              
//  Arguments:  paryInfo        client info
//              
//----------------------------------------------------------------------------

LONG
CDispNode::GetPainterInfo(CAryDispClientInfo *pAryClientInfo)
{
    LONG lZOrder = GetDispClient()->GetClientPainterInfo(this, pAryClientInfo);

    // intercept any requests to replace the background of the top-level
    // BODY by a transparent painter.  The BODY *must* paint a background of
    // some kind, or else we end up displaying uninitialized garbage from the
    // offscreen buffer

    if (pAryClientInfo->Size() > 0 && RequiresBackground())
    {
        int i;
        for (i=pAryClientInfo->Size()-1; i>=0; --i)
        {
            HTML_PAINTER_INFO *pInfo = &pAryClientInfo->Item(i)._sInfo;

            if (pInfo->lZOrder == HTMLPAINT_ZORDER_REPLACE_BACKGROUND &&
                !(pInfo->lFlags & HTMLPAINTER_OPAQUE))
            {
                // turn this into BELOW_CONTENT instead
                pInfo->lZOrder = HTMLPAINT_ZORDER_BELOW_CONTENT;
                if (i == 0)
                    lZOrder = pInfo->lZOrder;
            }
        }
    }

    return lZOrder;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::RequiresBackground
//              
//  Synopsis:   Determine whether this node absolutely must draw a background
//              
//  Arguments:  none
//              
//----------------------------------------------------------------------------

BOOL
CDispNode::RequiresBackground() const
{
    // the top-level BODY node must paint a background of some kind
    CDispParentNode *pParent = GetParentNode();
    return (pParent && pParent->IsDispRoot());
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::NeedAdvanced
//              
//  Synopsis:   Determine whether this node needs advanced drawing features
//              
//  Arguments:  paryInfo        client info
//              lDrawLayers     which layers need drawing
//              
//----------------------------------------------------------------------------

BOOL
CDispNode::NeedAdvanced(CAryDispClientInfo *paryInfo, LONG lDrawLayers,
                            BOOL *pfIsFiltered)
{
    BOOL fNeedAdvanced = FALSE;
    int i;

    if (pfIsFiltered)
        *pfIsFiltered = FALSE;

    // multiple painters, or non-trivial layer selector, requires advanced
    if (paryInfo->Size() > 1 || lDrawLayers != FILTER_DRAW_ALLLAYERS)
        fNeedAdvanced =  TRUE;

    for (i=paryInfo->Size()-1; i>=0; --i)
    {
        // REPLACE_ALL requires advanced
        // non-zero rcExpand requires advanced
        if (paryInfo->Item(i)._sInfo.lZOrder == HTMLPAINT_ZORDER_REPLACE_ALL ||
            memcmp(&paryInfo->Item(i)._sInfo.rcExpand, &g_Zero.rc, sizeof(RECT)))
        {
            fNeedAdvanced = TRUE;
            break;
        }
    }

    // filters and overlays require advanced
    if (pfIsFiltered || !fNeedAdvanced)
    {
        if (GetDispClient()->HasFilterPeer(this))
        {
            if (pfIsFiltered)
                *pfIsFiltered = TRUE;
            fNeedAdvanced =  TRUE;
        }

        if (GetDispClient()->HasOverlayPeer(this))
        {
            fNeedAdvanced =  TRUE;
        }
    }

    return fNeedAdvanced;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::ReverseDrawProgram
//              
//  Synopsis:   Reverse the draw program (for hit testing)
//              
//  Arguments:  paryProgram     the program
//              piPC            index of end of program (i.e. beginning of reversed program)
//              piCookie        number of cookies
//              
//----------------------------------------------------------------------------

void
CDispNode::ReverseDrawProgram(CAryDrawProgram& aryProgram,
                              int *piPC, int *piCookie)
{
    int iPC, iCookie;
    int layerPrevious = DISPNODELAYER_NEGATIVEINF;

    for (iPC=DP_START_INDEX, iCookie=0;  aryProgram[iPC] != DP_Done;  ++iPC)
    {
        switch (aryProgram[iPC])
        {
            case DP_DrawContent:
                // reverse the instruction and its argument,
                // and change the argument.  We want to stop just above the
                // previous layer, unless the previous layer was NEGATIVEINF
                // when we should include that layer as well.  The left-shift
                // does this perfectly because NEGATIVEINF is 0 (and 0<<1 == 0),
                // while all the other layers we care about (NEGATIVEZ and FLOW)
                // left-shift onto the next higher layer (FLOW and POSITIVEZ).
                aryProgram[iPC] = layerPrevious << 1;
                layerPrevious = aryProgram[++iPC];
                aryProgram[iPC] = DP_DrawContent;
                break;

            case DP_DrawPainterMulti:
            case DP_WindowTopMulti:
                ++iCookie;
                break;

            case DP_Expand:
                Assert(iPC + 5 < aryProgram.Size());
                aryProgram[iPC] = aryProgram[iPC + 5];
                Assert(aryProgram[iPC] == DP_DrawPainterMulti ||
                       aryProgram[iPC] == DP_WindowTopMulti);
                ++iCookie;
                iPC += 5;
                aryProgram[iPC] = DP_Expand;
                break;

            default:
                break;
        }
    }

    *piPC = iPC - 1;
    *piCookie = iCookie;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::Draw
//              
//  Synopsis:   Determine whether this node should be drawn, and what its
//              clipping rect should be.
//              
//  Arguments:  pContext        display context, in COORDSYS_TRANSFORMED
//              pChild          if not NULL, which child to start drawing at
//              
//  Notes:      This method should only be called on nodes that are visible
//              and in-view: IsAllSet(pContext->GetDrawSelector()).
//              
//----------------------------------------------------------------------------

void
CDispNode::Draw(CDispDrawContext* pContext, CDispNode* pChild, long lDrawLayers)
{
    if(!pContext)
        return;
    Assert(IsAllSet(pContext->GetDrawSelector()));
    
    // if this is an opaque node that saved a redraw region during PreDraw,
    // restore that redraw region (with the opaque area now included)
    const CRegion* prgnRedraw;
    if (IsSet(s_savedRedrawRegion))
    {
        pContext->PopRedrawRegionForKey((void*)this);
        prgnRedraw = NULL;  // don't test for redraw region intersection in TransformedToBoxCoords below
    }

    else if (pContext->IntersectsRedrawRegion(_rctBounds))
    {
        prgnRedraw = pContext->GetRedrawRegion();
    }

    // this node's bounds do not intersect the redraw region
    else
    {
        return;
    }
    
    // save old transform, change context to box coordinates
    CSaveDispClipTransform saveTransform(pContext);
    if (TransformedToBoxCoords(&pContext->GetClipTransform(), prgnRedraw))
    {
        // Change drawing resolution on nodes representing DEVICERECTs
        CDispDrawContext drawcontextLocal(s_drawSelector);
        CFormDrawInfo drawinfoLocal;
        
        // Use context with a differen device resolution if it changes here
        if (HasUserTransform() && GetExtraTransform()->_fResolutionChange)
        {
            CExtraTransform *pExtraTransform = GetExtraTransform();
            void *pClientData = pContext->GetClientData();
            CFormDrawInfo *pDI = (CFormDrawInfo *)pClientData;

            // Switch unit info to match the resolution
            drawinfoLocal = *pDI;
            drawinfoLocal.SetUnitInfo(pExtraTransform->_pUnitInfo);
            
            drawcontextLocal = *pContext;
            drawcontextLocal.SetClientData(&drawinfoLocal);
            
            pContext = &drawcontextLocal;
        }

        // redirect for filtering
         pContext->_fBypassFilter = FALSE;
         DrawSelf(pContext, pChild, lDrawLayers);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::DrawBorder
//              
//  Synopsis:   Draw optional border for this node.
//              
//  Arguments:  pContext            draw context, in COORDSYS_BOX
//              rcbBorderWidths     widths of optional border
//              pDispClient         client for this node
//              dwFlags             border flags
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispNode::DrawBorder(
        CDispDrawContext* pContext,
        const CRect& rcbBorderWidths,
        CDispClient* pDispClient,
        DWORD dwFlags)
{
    if(!pContext)
        return;

    if (HasBorder() && IsVisible())
    {
        // does redraw region intersect the border?
        CRect rcbBounds(GetSize());
        CRect rcbInsideBorder(
            rcbBorderWidths.TopLeft(),
            rcbBounds.BottomRight() - rcbBorderWidths.BottomRight().AsSize());
        CRect rcgInsideBorder;
        pContext->GetClipTransform().TransformRoundIn(rcbInsideBorder, &rcgInsideBorder);
        if (!pContext->GetRedrawRegion()->BoundsInside(rcgInsideBorder))
        {
            CRect rcbClip(pContext->GetClipRect());
            rcbClip.IntersectRect(rcbBounds);
            pDispClient->DrawClientBorder(
                &rcbBounds,
                &rcbClip,
                pContext->PrepareDispSurface(),
                this,
                pContext->GetClientData(),
                dwFlags);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::DrawBackground
//              
//  Synopsis:   Draw background (shared for filtered or unfiltered case).
//              
//  Arguments:  pContext    draw context, in COORDSYS_BOX
//              di          clipping and offset information for various layers
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispNode::DrawBackground(CDispDrawContext* pContext, const CDispInfo& di)
{
    Assert(HasBackground());
    
    if (!IsVisible())
        return;
    
    CSaveDispClipTransform saveTransform(pContext);
    TransformBoxToScroll(&pContext->GetClipTransform().NoClip(), di);
    
    // calculate intersection with redraw region
    CRect rccBackground(di._sizecBackground);
    if (HasContentOrigin())
    {
        rccBackground.OffsetRect(-GetContentOrigin());
    }
    CRect rccBackgroundClip(di._rccBackgroundClip);
    TransformScrollToContent(&pContext->GetClipTransform().NoClip(), di);
    
    pContext->SetClipRect(rccBackgroundClip);
    pContext->IntersectRedrawRegion(&rccBackgroundClip);
    if (!rccBackgroundClip.IsEmpty())
    {
        GetDispClient()->DrawClientBackground(
            &rccBackground,
            &rccBackgroundClip,
            pContext->PrepareDispSurface(),
            this,
            pContext->GetClientData(),
            0);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::DrawAtWindowTop
//
//  Synopsis:   Draw this node's window-top layers
//
//  Arguments:  pContext        draw context, in COORDSYS_GLOBAL
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispNode::DrawAtWindowTop(CDispDrawContext* pContext)
{
    CSaveDispClipTransform saveTransform(pContext);
    CDispClipTransform transform;

    // prepare to draw in content coords
    GetNodeTransform(&transform.NoClip(), COORDSYS_CONTENT, COORDSYS_GLOBAL);
    transform.SetHugeClip();
    pContext->GetClipTransform().AddPreTransform(transform);
    
#if DBG==1
    pContext->GetClipTransform().NoClip()._csDebug = COORDSYS_CONTENT;
    pContext->GetClipTransform().NoClip()._pNode = this;
#endif

    // calculate clip and position info
    CDispInfo di;
    CalcDispInfo(pContext->GetClipRect(), &di);
    
    // prepare to run the draw program
    CRect rccContent(di._sizecBackground);
    CRect rccClip(di._rccBackgroundClip);

    // find out which draw program to run
    CAryDrawProgram aryProgram;
    CAryDrawCookie aryCookie;
    if (S_OK != GetDrawProgram(&aryProgram, &aryCookie, FILTER_DRAW_ALLLAYERS))
    {
        AssertSz(0, "Failed to get draw program");
        return;
    }

    int iCookie = -1;
    void * cookie = NULL;
    BOOL fExpand = FALSE;
    CRect rcExpand = g_Zero.rc; // keep compiler happy

    // run the program
    for (int iPC = DP_START_INDEX;  aryProgram[iPC] != DP_Done;  ++iPC)
    {
        switch (aryProgram[iPC])
        {
        case DP_Expand:
            fExpand = TRUE;
            rcExpand.top    = aryProgram[++iPC];
            rcExpand.left   = aryProgram[++iPC];
            rcExpand.bottom = aryProgram[++iPC];
            rcExpand.right  = aryProgram[++iPC];
            break;

        case DP_WindowTopMulti:
            Assert(HasAdvanced());
            cookie = aryCookie[++iCookie];
            // fall through to DP_WindowTop

        case DP_WindowTop:
            if (!fExpand)
            {
                GetDispClient()->DrawClientLayers(
                    &rccContent,
                    &rccClip,
                    pContext->PrepareDispSurface(),
                    this,
                    cookie,
                    pContext,
                    CLIENTLAYERS_AFTERBACKGROUND);
            }
            else
            {
                Assert(HasAdvanced());
                CSaveDispClipTransform transformSaveContent(pContext);
                CRect rcbBounds = GetBounds().Size();

                TransformContentToBox(&pContext->GetClipTransform().NoClip(), di);
                pContext->SetHugeClip();
                rcbBounds.Expand(rcExpand);

                GetDispClient()->DrawClientLayers(
                    &rcbBounds,
                    &rcbBounds,
                    pContext->PrepareDispSurface(),
                    this,
                    cookie,
                    pContext,
                    CLIENTLAYERS_AFTERBACKGROUND);
            }

            cookie = NULL;
            fExpand = FALSE;
            break;

        case DP_DrawContent:
            ++iPC;
            break;

        case DP_DrawPainterMulti:
            ++iCookie;
            fExpand = FALSE;
            break;

        default:
            Assert(aryProgram[iPC] != DP_DrawPainter);
            break;
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::HitTestAtWindowTop
//
//  Synopsis:   Hit-test this node's window-top layers
//
//  Arguments:  pContext        hit context, in COORDSYS_GLOBAL
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
CDispNode::HitTestAtWindowTop(CDispHitContext* pContext, BOOL fHitContent)
{
    CSaveDispClipTransform saveTransform(pContext);
    CDispClipTransform transform;
    BOOL               fDeclinedHit = FALSE;

    // prepare to hit-test in content coords
    GetNodeTransform(&transform.NoClip(), COORDSYS_CONTENT, COORDSYS_GLOBAL);
    transform.SetHugeClip();
    pContext->GetClipTransform().AddPreTransform(transform);
    
#if DBG==1
    pContext->GetClipTransform().NoClip()._csDebug = COORDSYS_CONTENT;
    pContext->GetClipTransform().NoClip()._pNode = this;
#endif

    // calculate clip and position info
    CDispInfo di;
    CalcDispInfo(pContext->GetClipRect(), &di);
    
    // prepare to run the draw program
    CRect rccContent(di._sizecBackground);
    CRect rccClip(di._rccBackgroundClip);

    pContext->SetClipRect(rccClip);

    // find out which draw program to run
    CAryDrawProgram aryProgram;
    CAryDrawCookie aryCookie;
    if (S_OK != GetDrawProgram(&aryProgram, &aryCookie, FILTER_DRAW_ALLLAYERS))
    {
        AssertSz(0, "Failed to get draw program");
        return FALSE;
    }

    int iPC;
    int iCookie;
    void * cookie = NULL;
    BOOL fExpand = FALSE;
    CRect rcExpand = g_Zero.rc; // keep compiler happy

    // we will run the program backwards;  first fix up the arguments
    ReverseDrawProgram(aryProgram, &iPC, &iCookie);

    // run the program
    for ( ;  iPC>=DP_START_INDEX;  --iPC)
    {
        switch (aryProgram[iPC])
        {
        case DP_Expand:
            fExpand = TRUE;
            rcExpand.right  = aryProgram[--iPC];
            rcExpand.bottom = aryProgram[--iPC];
            rcExpand.left   = aryProgram[--iPC];
            rcExpand.top    = aryProgram[--iPC];
            break;

        case DP_WindowTopMulti:
            Assert(HasAdvanced());
            cookie = aryCookie[--iCookie];
            // fall through to DP_WindowTop

        case DP_WindowTop:
            if (!fExpand)
            {
                if (pContext->RectIsHit(di._rccBackgroundClip))
                {
                    CPoint ptcHitTest;
                    pContext->GetHitTestPoint(&ptcHitTest);
                    if (GetDispClient()->HitTestPeer(
                            &ptcHitTest,
                            COORDSYS_CONTENT,
                            (CDispContainer*)this,
                            cookie,
                            pContext->_pClientData,
                            fHitContent,
                            pContext,
                            &fDeclinedHit))
                    {
                        return TRUE;
                    }
                }
            }
            else
            {
                Assert(HasAdvanced());
                CSaveDispClipTransform transformSaveContent(pContext);
                CRect rcbBounds = GetBounds().Size();

                TransformContentToBox(&pContext->GetClipTransform().NoClip(), di);
                pContext->SetHugeClip();
                rcbBounds.Expand(rcExpand);

                if (pContext->RectIsHit(rcbBounds))
                {
                    CPoint ptbHitTest;
                    pContext->GetHitTestPoint(&ptbHitTest);
                    if (GetDispClient()->HitTestPeer(
                            &ptbHitTest,
                            COORDSYS_BOX,
                            (CDispContainer*)this,
                            cookie,
                            pContext->_pClientData,
                            fHitContent,
                            pContext,
                            &fDeclinedHit))
                    {
                        // NOTE: don't bother to restore context transform for speed
                        return TRUE;
                    }
                }
            }
            cookie = NULL;
            fExpand = FALSE;
            break;

        case DP_DrawContent:
            --iPC;
            break;

        case DP_DrawPainterMulti:
            --iCookie;
            fExpand = FALSE;
            break;

        default:
            break;
        }
    }

    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::ComputeExpandedBounds
//              
//  Synopsis:   Return the "expanded" bounds, including expansion requested
//              by external painters.  Used for hit-testing.
//              
//  Arguments:  prcpBounds      returned bounds
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispNode::ComputeExpandedBounds(RECT * prcpBounds)
{
    Assert(HasAdvanced());
    CRect rcbBoundsSelf = GetBounds().Size();
    CRect rcbBounds = rcbBoundsSelf;
    CAryDispClientInfo aryInfo;

    GetDispClient()->GetClientPainterInfo(this, &aryInfo);

    // union in all the expansions desired by external painters
    for (int i=aryInfo.Size()-1; i>=0; --i)
    {
        CRect rcbExpanded = rcbBoundsSelf;
        rcbExpanded.Expand(aryInfo[i]._sInfo.rcExpand);
        rcbBounds.Union(rcbExpanded);
    }

    // union in my "normal" visible bounds
    // TODO (sambent) We should really redo the ComputeVisibleBounds calculation
    // (in parent coords), union, then convert to transformed coords.  This
    // is more accurate when there are non-90-degree rotations involved.
    // For expedience and speed, we do the union in transformed coords instead.

    CRect rctBounds;
    TransformRect(rcbBounds, COORDSYS_BOX, &rctBounds, COORDSYS_TRANSFORMED);
    rctBounds.Union(_rctBounds);

    *prcpBounds = rctBounds;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::SetUpAdvancedDisplay
//              
//  Synopsis:   Create a CAdvancedPainter, to implement advanced features
//              
//  Arguments:  none
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispNode::SetUpAdvancedDisplay()
{
    AssertSz(!HasAdvanced(), "Disp node already in advanced mode");

    if (HasAdvanced())
        return;

    CAdvancedDisplay *pAdvanced = new CAdvancedDisplay(this, _pDispClient);
    if (pAdvanced)
    {
        if (_pDispClient->HasOverlayPeer(this))
        {
            pAdvanced->SetOverlay(TRUE);
            SetPositionAware();
        }
        
        SetFlag(s_advanced);
        _pAdvancedDisplay = pAdvanced;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::TearDownAdvancedDisplay
//              
//  Synopsis:   Remove the CAdvancedDisplay
//              
//  Arguments:  none
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispNode::TearDownAdvancedDisplay()
{
    AssertSz(HasAdvanced(), "Disp node not in advanced mode");

    if (!HasAdvanced())
        return;

    CAdvancedDisplay *pAdvanced = _pAdvancedDisplay;
    _pDispClient = GetDispClient();
    ClearFlag(s_advanced);

    delete pAdvanced;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::SetPainterState
//              
//  Synopsis:   Called during recalc.  Determines how the node needs to
//              interact with external painters (if any).
//              
//  Arguments:  rcpBoundsSelf       bounding rect for this node (parent coords)
//              prcpBoundsExpanded  new bounding rect, taking into account any
//                                  rcExpand from external painters
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispNode::SetPainterState(const CRect& rcpBoundsSelf, CRect *prcpBoundsExpanded)
{
    CDispClient *pDispClient = GetDispClient();

    *prcpBoundsExpanded = rcpBoundsSelf;

    if (pDispClient)
    {
        CAryDispClientInfo aryClientInfo;
        int i;
        BOOL fDrawnExternally = FALSE;
        BOOL fHasWindowTop = FALSE;
        BOOL fHadOverlay = HasOverlay();

        GetPainterInfo(&aryClientInfo);

        for (i=aryClientInfo.Size()-1;  i>=0;  --i)
        {
            CDispClientInfo& info = aryClientInfo[i];

            if (info._sInfo.lZOrder == HTMLPAINT_ZORDER_REPLACE_ALL ||
                info._sInfo.lZOrder == HTMLPAINT_ZORDER_REPLACE_CONTENT)
            {
                fDrawnExternally = TRUE;
            }
            else if (info._sInfo.lZOrder == HTMLPAINT_ZORDER_WINDOW_TOP)
            {
                fHasWindowTop = TRUE;
            }

            CRect rcpExpanded = rcpBoundsSelf;
            rcpExpanded.Expand(info._sInfo.rcExpand);
            prcpBoundsExpanded->Union(rcpExpanded);
        }

        SetFlag(s_drawnExternally, fDrawnExternally);

        if (fHasWindowTop != HasWindowTop())
        {
            CDispRoot *pDispRoot = GetDispRoot();
            if (pDispRoot)
            {
                if (fHasWindowTop)
                {
                    pDispRoot->AddWindowTop(this);
                }
                else
                {
                    pDispRoot->RemoveWindowTop(this);
                }
            }
        }
        Assert(fHasWindowTop == HasWindowTop());

        if (NeedAdvanced(&aryClientInfo, FILTER_DRAW_ALLLAYERS))
        {
            if (!HasAdvanced())
                SetUpAdvancedDisplay();
        }
        else
        {
            if (HasAdvanced())
                TearDownAdvancedDisplay();
        }

        // update overlay info
        if (fHadOverlay != HasOverlay())
        {
            CDispRoot *pDispRoot = GetDispRoot();
            if (pDispRoot)
            {
                if (fHadOverlay)
                {
                    pDispRoot->RemoveOverlay(this);
                }
                else
                {
                    pDispRoot->AddOverlay(this);
                }
            }
        }

        // remember the expanded bounds
        if (HasAdvanced())
        {
            CRect rcbBoundsExpanded = *prcpBoundsExpanded;
            rcbBoundsExpanded.OffsetRect(-rcpBoundsSelf.TopLeft().AsSize());
            GetAdvanced()->SetExpandedBounds(rcbBoundsExpanded);

            if (HasOverlay())
            {
                GetAdvanced()->MoveOverlays();
            }
        }
    }
}

// TODO global variable yuckness.

extern CDispNode * g_pdispnodeElementDrawnToDC;

//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::GetDrawInfo
//              
//  Synopsis:   Return special information that an external painter may
//              want to know during a Draw call.
//
//              If transform information is requested, only transforms that
//              don't represent resolution changes are returned.
//              
//  Arguments:  pContext        draw context, in COORDSYS_CONTENT
//              lFlags          which info the painter wants
//              dwPrivateFlags  Internal flags for filtered elements.
//              pInfo           where to store the info
//              
//----------------------------------------------------------------------------
HRESULT
CDispNode::GetDrawInfo(RENDER_CALLBACK_INFO *   pCallbackInfo,
                       LONG                     lFlags,
                       DWORD                    dwPrivateFlags,
                       HTML_PAINT_DRAW_INFO *   pInfo) const
{
    HRESULT hr = S_OK;
    CDispDrawContext *pContext =  NULL;

    if (pCallbackInfo)
    {
        pContext = (CDispDrawContext*)pCallbackInfo->_pContext;
    }

    if (!pContext)
    {
        hr = E_UNEXPECTED;
        goto done;
    }

    if (!pInfo)
    {
        hr = E_POINTER;
        goto done;
    }
    
    if (lFlags & HTMLPAINT_DRAWINFO_VIEWPORT)
    {
        CRect rccClient;
        CRect rcgViewport;

        GetClientRect(&rccClient, CLIENTRECT_BACKGROUND);
        if (pCallbackInfo->_lFlags & HTMLPAINT_DRAW_USE_XFORM)
        {
            rcgViewport = rccClient;
        }
        else
        {
            pContext->GetClipTransform().NoClip().Transform(rccClient, &rcgViewport);
        }
        pInfo->rcViewport = rcgViewport;
    }

    if (lFlags & HTMLPAINT_DRAWINFO_UPDATEREGION)
    {
        CRegion rgngUpdate = *pContext->GetRedrawRegion();
        rgngUpdate.Intersect(pCallbackInfo->_rcgClip);
        rgngUpdate.Untransform(pContext->GetClipTransform().GetWorldTransform());
        pInfo->hrgnUpdate = rgngUpdate.GetRegionForever();
    }

    if (lFlags & HTMLPAINT_DRAWINFO_XFORM)
    {
        Assert(sizeof(XFORM) == sizeof(pInfo->xform));

        // If we printing or print previewing a filtered element we need to
        // return a transform that doesn't include resolution changes.

        if (   (dwPrivateFlags & HTMLPAINT_DRAWINFO_PRIVATE_PRINTMEDIA)
            && (dwPrivateFlags & HTMLPAINT_DRAWINFO_PRIVATE_FILTER))
        {
            CDispNode const *   pNode       = this;
            CWorldTransform     worldxform;
            CPoint              pt(0, 0);

            while (pNode)
            {
                if (   pNode->HasUserTransform()
                    && !pNode->GetUserTransform().GetWorldTransform()->IsOffsetOnly())
                {
                    CDispTransform  transform   = pNode->GetUserTransform();

                    if (!pNode->GetExtraTransform()->_fResolutionChange)
                    {
                        worldxform.AddPreTransform(transform.GetWorldTransform());
                    }
                }
            
                pNode = pNode->GetParentNode();
            }

            worldxform.GetMatrix().GetXFORM((XFORM&)pInfo->xform);

            // Get translation by transforming a point at {0, 0} with the
            // DispSurface transformation, which holds the element's top/left
            // offset.

            pContext->GetDispSurface()->GetWorldTransform()->Transform(&pt);

            // Because the resolution change transforms we didn't include will
            // not have offsets, we can be certain that the offsets of the 
            // DispSurface transform will be correct.

            pInfo->xform.eDx = pt.x;
            pInfo->xform.eDy = pt.y;
        }
        else
        {
            CWorldTransform     wxform;

            wxform.Init(pContext->GetDispSurface()->GetWorldTransform());

            // If we're a filter rendering to a high resolution device, add a 
            // transform to represent the conversion from 96DPI to the display
            // resolution.
            
            if (   (dwPrivateFlags & HTMLPAINT_DRAWINFO_PRIVATE_FILTER)
                && g_uiDisplay.IsDeviceScaling())
            {
                CWorldTransform wxformHiRes;
                MAT             matrix;

                matrix.eM11 =   (float)g_uiDisplay.GetResolution().cx 
                              / FIXED_PIXELS_PER_INCH;
                matrix.eM12 = 0.0F;
                matrix.eM21 = 0.0F;
                matrix.eM22 =   (float)g_uiDisplay.GetResolution().cy 
                              / FIXED_PIXELS_PER_INCH;
                matrix.eDx  = 0.0F;
                matrix.eDy  = 0.0F;

                wxformHiRes.Init(&matrix);

                wxform.AddPreTransform(&wxformHiRes);
            }

            wxform.GetMatrix().GetXFORM((XFORM&)pInfo->xform);
        }
    }

done:

    RRETURN1(hr, S_FALSE);
}
//  Member:     CDispNode::GetDrawInfo


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::DrawNodeForFilter
//              
//  Synopsis:   This is a special entry point that modifies the context
//              appropriately to draw the contents of a node which will then
//              be filtered.
//              
//  Arguments:  pContext        draw context, in COORDSYS_BOX
//              pFilterSurface  destination surface (NULL means use context)
//              pMatrix         optional matrix to use when drawing to a
//                              surface.
//              lDrawLayers     which layers to actually draw
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispNode::DrawNodeForFilter(
        CDispDrawContext *  pContext,
        CDispSurface *      pFilterSurface,
        MAT *               pMatrix,
        LONG                lDrawLayers)
{
    Assert(pContext != NULL);

    CSaveDispClipTransform saveTransform(pContext);
    CRect rcbBounds(GetSize());

    // if the filter gave us our own HDC, we don't have to do any special
    // clipping

    if (pFilterSurface == NULL)
    {
        // Using a matrix without a CDispSurface isn't supported.

        Assert(NULL == pMatrix);

        // does this disabled filter really intersect the redraw region?
        GetMappedBounds(&rcbBounds);
        pContext->IntersectClipRect(rcbBounds);
        Assert(pContext->IntersectsRedrawRegion(pContext->GetClipRect()));
        
        DrawSelf(pContext, NULL, lDrawLayers);
    
        // NOTE (donmarsh) -- the surface we have here has physical clipping
        // enforced on the DC (see CFilter::DrawFiltered).
        // DrawSelf may modify the surface state to say that no physical clipping
        // is being done, but CFilter::Draw does a RestoreDC that reinstates
        // physical clipping.  Now the clip state in the surface will not match
        // the actual state of the DC, and the next item to draw
        // will assume that no physical clipping has been applied to the DC
        // when it actually has.  The following hack sets surface
        // state so that the next item is forced to reestablish the clip region
        // appropriately.
        pContext->GetDispSurface()->ForceClip();
    }

    else if (!rcbBounds.IsEmpty())
    {
        CDispSurface* pSaveSurface = pContext->GetDispSurface();
        pContext->SetDispSurface(pFilterSurface);

        if (pMatrix)
        {
            pContext->GetClipTransform().GetWorldTransform()->Init(pMatrix);
        }
        else
        {
            pContext->SetToIdentity();
        }

        pContext->ForceClipRect(rcbBounds);

#if DBG==1
        pContext->GetClipTransform().NoClip()._csDebug = COORDSYS_BOX;
        pContext->GetClipTransform().NoClip()._pNode = this;
#endif
        CRegion rgngClip(rcbBounds);

        CRegion* prgngSaveRedraw = pContext->GetRedrawRegion();
        pContext->SetRedrawRegion(&rgngClip);

        // get surface ready for rendering
        pContext->GetDispSurface()->SetClipRgn(&rgngClip);
        CFormDrawInfo *pDI = (CFormDrawInfo*)pContext->GetClientData();
        CSetDrawSurface sds(pDI, &rcbBounds, &rcbBounds, 
                            pContext->GetDispSurface());
        pDI->_hdc = NULL;           // force DI to recompute its hdc
        
        // draw content that might not be in view
        int saveSelector = pContext->GetDrawSelector();
        pContext->SetDrawSelector(s_visibleBranch);

        // register myself with the root
        CDispRoot *pRoot = GetDispRoot();
        CDispNode *pOldDrawingUnfiltered = NULL;
        if (pRoot)
        {
            pOldDrawingUnfiltered = pRoot->SwapDrawingUnfiltered(this);
        }

        // Draw!
        DrawSelf(pContext, NULL, lDrawLayers);

        // restore the world
        if (pRoot)
        {
            WHEN_DBG( pOldDrawingUnfiltered = )
            pRoot->SwapDrawingUnfiltered(pOldDrawingUnfiltered);
            Assert( pOldDrawingUnfiltered == this );
        }
        pContext->SetDrawSelector(saveSelector);
        pContext->SetRedrawRegion(prgngSaveRedraw);
        pContext->SetDispSurface(pSaveSurface);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::HitTestUnfiltered
//              
//  Synopsis:   Hit-test the unfiltered version of a node.
//              
//  Arguments:  pContext        hit context, in COORDSYS_BOX
//              ppt             point to test
//              lDrawLayers     which layers to actually hit-test
//              pbHit           (return) is hit successful
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

HRESULT
CDispNode::HitTestUnfiltered(
                CDispHitContext *pContext,
                BOOL fHitContent,
                POINT *ppt,
                LONG lDrawLayers,
                BOOL *pbHit)
{
    // Do the unfiltered test with a separate context that differs from the
    // original context in two respects:
    //  (1) use the new query point supplied by the filter 
    //  (2) don't clip
    // This allows filters like FlipH to test a point that differs from the
    // original point, and whose pre-image may not even be visible.
    
    CDispHitContext context = *pContext;
    CPoint ptgHitTestFiltered;

    TransformPoint(*ppt, COORDSYS_BOX,
                    &ptgHitTestFiltered, COORDSYS_GLOBAL);

    context.SetHitTestPoint(ptgHitTestFiltered);
    context.SetHugeClip();

    *pbHit = HitTestPoint(&context, TRUE, fHitContent);

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::InsertSiblingNode
//              
//  Synopsis:   Insert a new node into the tree as a sibling of this node.
//
//  Arguments:  pNew        node to be inserted as sibling of this node
//              where       if == before then insert new node before this one;
//                          else insert after.
//              
//  Returns:    TRUE if new node was inserted into a new location in the tree
//              
//----------------------------------------------------------------------------

BOOL
CDispNode::InsertSiblingNode(CDispNode* pNew, BeforeAfterEnum where)
{
    // this node must be in the tree
    Assert(_pParent != NULL);
    Assert(pNew != NULL);

    // we shouldn't be inserting a structure node or next to a structure node
    Assert(!pNew->IsStructureNode() && !IsStructureNode());
    
    // don't execute senseless insertion
    if (pNew == this || _pParent == NULL)
        goto NoInsertion;

    CDispNode *pPrevious, *pNext;
    if (where == before)
    {
        // if new node is already in correct place, don't insert
        if (pNew == _pPrevious)
            goto NoInsertion;

        pPrevious = _pPrevious;
        pNext = this;
    }
    else
    {
        // if new node is already in correct place, don't insert
        if (pNew == _pNext)
            goto NoInsertion;

        pPrevious = this;
        pNext = _pNext;
    }

    // extract new sibling from its current location
    if (pNew->_pParent != NULL)
        pNew->ExtractFromTree();

    Assert(pNew->_pParent == NULL);
    Assert(pNew->_pPrevious == NULL);
    Assert(pNew->_pNext == NULL);

    // link new sibling
    pNew->_pParent = _pParent;
    pNew->_pPrevious = pPrevious;
    pNew->_pNext = pNext;
    
    {   // modify parent
        _pParent->_cChildren++;
        _pParent->SetChildrenChanged();

        // link siblings
        if (pPrevious != NULL)
            pPrevious->_pNext = pNew;
        else
            _pParent->_pFirstChild = pNew;
    
        if (pNext != NULL)
            pNext->_pPrevious = pNew;
        else
            _pParent->_pLastChild = pNew;
    }
        
    // recalc subtree starting with newly inserted node
    pNew->SetFlags(s_newInsertion | s_recalcSubtree);
    pNew->RequestRecalc();
    
    // rebalance grandparent if parent is structure node
    _pParent->RequestRebalance();

    WHEN_DBG(_pParent->VerifyTreeCorrectness();)

    // invalidate this node in its new tree location
    pNew->SetInvalid();

    return TRUE;
    
NoInsertion:
    WHEN_DBG(VerifyTreeCorrectness();)
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::ExtractFromTree
//
//  Synopsis:   Extract this node from the tree.
//
//  Arguments:  none
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispNode::ExtractFromTree()
{
    // invalidate current visible bounds if the bounds aren't already invalid
    // and if there is something visible on this branch
    if (MaskFlags(s_inval | s_visibleBranch) == s_visibleBranch)
        Invalidate();

    // check to see if this node is actually in a tree
    if (_pParent == NULL)
    {
        Assert(_pPrevious == NULL && _pNext == NULL);
        return;
    }

    // flag this branch as needing recalc
    _pParent->RequestRecalc();
    _pParent->SetChildrenChanged();

    // remove this node from parent's list of children
    _pParent->UnlinkChild(this);
    
    // remove all empty structure nodes above this node
    if (_pParent->_cChildren == 0 && _pParent->IsStructureNode())
        _pParent->CollapseStructureNode();

    _pPrevious = _pNext = NULL;
    _pParent = NULL;

    WHEN_DBG(VerifyTreeCorrectness();)
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::RestoreZOrder
//
//  Synopsis:   This node's z-index has changed, possibly violating the
//              invariant that z-index increases within a list of siblings.
//              Restore the invariant by re-inserting this node, if necessary.
//
//  Arguments:  lZOrder of this node: not used for DISPNODELAYER_FLOW layer type.
//
//  Returns:    TRUE    if a change was actually made
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
CDispNode::RestoreZOrder(LONG lZOrder)
{
    Assert(!IsStructureNode());

    // nothing to do if this node in not in tree
    if (_pParent == NULL) return FALSE;

    int layer = GetLayer();

    // layer type should be valid and consistent with lZOrder
    Assert(layer == s_layerNegZ && lZOrder < 0 ||
           layer == s_layerFlow ||
           layer == s_layerPosZ && lZOrder >= 0);


    BOOL fNeedReinsert = FALSE;

    // look to my left.  If the order is wrong, we need to reinsert.
    {
        CDispNode const* pSibling = GetPreviousSiblingNode();
        if (pSibling)
        {
            int siblingLayer = pSibling->GetLayer();
            if (siblingLayer > layer ||
                siblingLayer == layer &&
                layer != s_layerFlow &&
                pSibling->IsGreaterZOrder(this, lZOrder))
                fNeedReinsert = TRUE;
        }
    }

    // now do the same thing to my right
    if (!fNeedReinsert)
    {
        CDispNode const* pSibling = GetNextSiblingNode();
        if (pSibling)
        {
            int siblingLayer = pSibling->GetLayer();
            if (siblingLayer < layer ||
                siblingLayer == layer &&
                layer != s_layerFlow &&
                !pSibling->IsGreaterZOrder(this, lZOrder))
                fNeedReinsert = TRUE;
        }
    }

    if (fNeedReinsert)
    {
        CDispParentNode *pParent = GetParentNode();
        Assert(pParent);

        // remove myself from the tree, and re-insert in the right layer
        ExtractFromTree();

        if (layer < s_layerFlow)
            pParent->InsertChildInNegZ(this, lZOrder);
        else if (layer == s_layerFlow)
            pParent->InsertChildInFlow(this);
        else
            pParent->InsertChildInPosZ(this, lZOrder);
    }

    return fNeedReinsert;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::ReplaceNode
//              
//  Synopsis:   Replace the indicated node with this one.
//
//  Arguments:  pOldNode        node to replace
//
//  Notes:      This node must have no children.  If this node is a leaf node,
//              any unowned children of the replaced node will be deleted.
//              This node must not already be in a tree.
//              
//              All children of pOldNode are adopted to this one.
//              Old node is deleted (even if it was marked as owned).
//
//  CAUTION!  For performance reasons, this method invalidates the new node
//  only if the new and old bounds are different.  If they are equal, the
//  client must invalidate if it's necessary.
//              
//----------------------------------------------------------------------------

void
CDispNode::ReplaceNode(CDispNode* pOldNode)
{
    Assert(pOldNode != NULL && pOldNode != this);
    Assert(_pParent == NULL && _pPrevious == NULL && _pNext == NULL);
    Assert(IsLeafNode() || AsParent()->_cChildren == 0);
    
    const CRect& rcpOld = pOldNode->GetBounds();
    
    BOOL fMustInval =
        pOldNode->IsVisibleBranch() && GetBounds() != rcpOld;

    // invalidate bounds of old node
    if (fMustInval)
    {
        pOldNode->Invalidate();
    }

    CRect rcpMapped;
    CRect *prcpMapped = NULL;
    if (pOldNode->MapsBounds())
    {
        rcpMapped = rcpOld.Size();
        prcpMapped = &rcpMapped;
        pOldNode->GetMappedBounds(prcpMapped);
    }

    SetPosition(rcpOld.TopLeft());
    SetSize(rcpOld.Size(), prcpMapped, FALSE);  // NOTE: don't invalidate here, see SetInvalid below
    SetInView(pOldNode->IsInView());

    // maintain the root's special lists
    CDispRoot *pDispRoot = pOldNode->GetDispRoot();
    if (pDispRoot)
    {
        if (pOldNode->HasWindowTop())
        {
            pDispRoot->RemoveWindowTop(pOldNode);
        }

        if (pOldNode->HasOverlay())
        {
            pDispRoot->RemoveOverlay(pOldNode);
        }
    }

    if (pOldNode->IsParentNode())
    {
        CDispParentNode* pOldNodeAsParent = pOldNode->AsParent();
        
        // transfer children
        if (IsParentNode())
        {
            CDispParentNode* pNewNodeAsParent = AsParent();

            // move children
            pNewNodeAsParent->_cChildren   = pOldNodeAsParent->_cChildren  ;
            pNewNodeAsParent->_pFirstChild = pOldNodeAsParent->_pFirstChild;
            pNewNodeAsParent->_pLastChild  = pOldNodeAsParent->_pLastChild ;
            pOldNodeAsParent->_cChildren   = 0;
            pOldNodeAsParent->_pFirstChild = 0;
            pOldNodeAsParent->_pLastChild  = 0;
            pOldNodeAsParent->SetChildrenChanged();
            SetChildrenChanged();
            
            // set new parent on all children
            for (CDispNode* pChild = pNewNodeAsParent->_pFirstChild;
                 pChild != NULL;
                 pChild = pChild->_pNext)
            {
                pChild->_pParent = pNewNodeAsParent;
            }
        }
    }

    // place in tree
    _pParent = pOldNode->_pParent;
    _pPrevious = pOldNode->_pPrevious;
    _pNext = pOldNode->_pNext;

    if (_pParent)
    {
        if (_pPrevious) _pPrevious->_pNext = this;
        else            _pParent->_pFirstChild = this;
    
        if (_pNext) _pNext->_pPrevious  = this;
        else        _pParent->_pLastChild = this;
    }

    // delete old node
    pOldNode->Delete();
    
    WHEN_DBG(VerifyTreeCorrectness();)

    RequestRecalc();

    // invalidate new bounds
    if (fMustInval)
    {
        SetInvalid();
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::Destroy
//              
//  Synopsis:   Destroy this node. 
//              
//  Arguments:  none
//              
//  Notes:
//      This node is deleted, the "owned" flag is of no matter.
//      
//      If this node is parent node, its children are unlinked recoursively.
//      When the unlinked child is not owned, it is also destroyed; this
//      causes recoursive tree erase.
//
//----------------------------------------------------------------------------

void
CDispNode::Destroy()
{
    if (_pParent != NULL)
    {
        // invalidate current bounds
        if (!IsInvalid())
        {
            Invalidate();
            SetInvalid();   // inhibit invalidation of all children
        }

        CDispRoot* pDispRoot = GetDispRoot();
        if (pDispRoot)
        {
            pDispRoot->ScrubWindowTopList(this);
            pDispRoot->ScrubOverlayList(this);
        }

        _pParent->SetChildrenChanged();
        RequestRecalc();
        _pParent->UnlinkChild(this);

        if (_pParent->IsStructureNode() && _pParent->_cChildren == 0)
            _pParent->CollapseStructureNode();
    
        _pParent = NULL;
        _pNext = NULL;
        _pPrevious = NULL;
    }

    Delete();
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::TransformedToBoxCoords
//              
//  Synopsis:   Switch the given transform from COORDSYS_TRANSFORMED to
//              COORDSYS_BOX, incorporating optional user transform and user
//              clip.
//              
//  Arguments:  pTransform      transform to be modified
//              prgng           if not NULL, the bounds of this node is tested
//                              to make sure it still intersects this region
//                              after user clipping has been incorporated into
//                              the transform
//                              
//  Returns:    TRUE if the bounds of this node still intersects the optional
//              region argument after user clipping has been incorporated into
//              the transform
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CDispNode::TransformedToBoxCoords(
        CDispClipTransform* pTransform,
        const CRegion* prgng) const
{
    if (!IsStructureNode())
    {
        AssertCoords(pTransform, COORDSYS_TRANSFORMED, COORDSYS_BOX);
    
        // add position of this node
        pTransform->AddPreOffset(GetPosition().AsSize());
    
        // add optional user transform
        if (HasUserTransform())
        {
            CDispClipTransform userTransform(GetUserTransform());
            pTransform->AddPreTransform(userTransform);
        }
    
        // incorporate optional user clip rect
        if (HasUserClip())
        {
            pTransform->IntersectClipRect(GetUserClip());
            if (prgng != NULL)
            {
                CRect rcgBounds;
                pTransform->Transform(CRect(_rctBounds.Size()), &rcgBounds);
                return prgng->Intersects(rcgBounds);
            }
        }
    }
    
    return TRUE;
}

void
CDispNode::SetExpandedClipRect(CRect &rc)
{
    Assert(HasExtra(DISPEX_USERCLIP));
    CUserClipAndExpandedClip *pucec = ((CUserClipAndExpandedClip*)GetExtra(DISPEX_USERCLIP));
    if (!pucec->_fUserClip)
    {
        pucec->_fExpandedClip = TRUE;
        pucec->_rcClip = rc;
    }
}

//
// Content origin calculations
//
void                    
CDispNode::SetContentOrigin(const CSize& sizeContentOrigin, 
                            int xOffsetRTL)                         // -1 if unknown or irrelevant
                                                                    // has priority otherwise
{
    CSize sizeContentOriginOld = GetContentOrigin();
    int xOffsetRTLOld = GetContentOffsetRTL();

    SetContentOriginNoInval(sizeContentOrigin, xOffsetRTL);

    if (GetContentOrigin()    != sizeContentOriginOld ||
        GetContentOffsetRTL() != xOffsetRTLOld)
    {
        InvalidateAndRecalcSubtree();
    }
}

void                    
CDispNode::SetContentOriginNoInval(const CSize& sizeContentOrigin,
                                   int xOffsetRTL)                  // -1 if unknown or irrelevant
                                                                    // has priority otherwise
{
    CExtraContentOrigin eco(sizeContentOrigin, xOffsetRTL);

    // If offset from right is non-zero, it takes priority, 
    // and offset from left is calculated from content width
    if (xOffsetRTL != -1)
    {
        // Caclulate size of content rectangle (where content coordinate space is applied)
        int xContentWidth;
        
        if (!IsScroller())
        {
            // CDispLeafNode or CDispContainer: content size equals to size within bounds
            CRect rcContent;
            GetClientRect(&rcContent, CLIENTRECT_CONTENT);
            xContentWidth = rcContent.Width();
        }
        else
        {
            // CDispScroller: 
            // TODO 15036: There is no CLIENTRECT_SCROLLABLECONTENT. consider adding.
            CDispInfo di;
            CalcDispInfo(g_Zero.rc, &di); // clip rect doesn't matter for content size
            xContentWidth = di._sizesContent.cx;
        }

        // content offset has to be positive - if content is wider than the node, 
        // something must be wrong. We can't assert it though, as it temporarily 
        // goes negative when sizes are set in particular order.
        eco._sizeOrigin.cx = max(0L, (long)(xContentWidth - xOffsetRTL));
    }
    
    *(CExtraContentOrigin*)GetExtra(DISPEX_CONTENTORIGIN) = eco;
}


#if DBG==1
//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::AssertCoords
//              
//  Synopsis:   Check correctness of coordinate system.
//              
//  Arguments:  pContext        display context
//              csFrom          current coordinate system
//              csTo            new coordinate system
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispNode::AssertCoords(
        CDispTransform* pTransform,
        COORDINATE_SYSTEM csFrom,
        COORDINATE_SYSTEM csTo) const
{
    Assert(pTransform != NULL);
    CDispNode* pTrueParent = GetParentNode();
    AssertSz(
        pTrueParent == NULL ||
        (pTransform->_csDebug == csFrom && pTransform->_pNode == this) ||
        (csFrom == COORDSYS_TRANSFORMED &&
         pTransform->_pNode == pTrueParent &&
         pTransform->_csDebug == GetContentCoordinateSystem()),
        "Display Tree coordinate system screw up");
    pTransform->_csDebug = csTo;
    pTransform->_pNode = this;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::VerifyRecalc
//              
//  Synopsis:   Verify that the recalc flag is set on this node and all nodes
//              on this branch from this node to the root.
//              
//  Arguments:  none
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispNode::VerifyRecalc()
{
    VerifyFlagsToRoot(s_recalc);
    
    // check tree open state
    CDispRoot* pRoot = GetDispRoot();
    if (pRoot)
    {
        AssertSz(pRoot->_cOpen > 0,
            "Display Tree not properly opened before tree modification");
        AssertSz(!pRoot->_fDrawLock,
            "Display Tree RequestRecalc called during Draw");
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::DumpDisplayTree
//              
//  Synopsis:   Dump entire display tree.
//              
//----------------------------------------------------------------------------

void
CDispNode::DumpDisplayTree() const
{
    DumpTree();
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::DumpTree
//
//  Synopsis:   Dump the tree containing this node.
//
//  Arguments:  none (so it can be easily called from the debugger)
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispNode::DumpTree() const
{
    CDispNode const* pRoot = GetRootNode();
    if (pRoot != NULL)
    {
        pRoot->DumpNode();
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::DumpNode
//
//  Synopsis:   Dump the tree starting at this node.
//
//  Arguments:  none (so it can be easily called from the debugger)
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispNode::DumpNode() const
{
    HANDLE hfile =
        CreateFile(_T("c:\\displaytree.xml"),
            GENERIC_WRITE,
            FILE_SHARE_WRITE | FILE_SHARE_READ,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL,
            NULL);
    
#if 0  // we don't append to the dump file since we started dumping XML
    if (hfile != INVALID_HANDLE_VALUE)
    {
        SetFilePointer( hfile, GetFileSize( hfile, 0 ), 0, 0 );
    }
#endif

    if (hfile == INVALID_HANDLE_VALUE)
    {
        return;
    }

    DumpStart(hfile);
    Dump(hfile, 0, MAXLONG, 0);
    DumpEnd(hfile);

    CloseHandle(hfile);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::DumpStart
//
//  Synopsis:   Start dump of display tree debug information.
//
//  Arguments:  hFile       handle to output file
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispNode::DumpStart(HANDLE hfile) const
{
    WriteString(hfile, _T("<?xml version='1.0' encoding='windows-1252'?>\r\n")
                       _T("<?xml-stylesheet type='text/xsl' href='"));
    WriteString(hfile, _T("http://trident/dev/display/displaytree.xsl"));
    WriteString(hfile, _T("'?>\r\n")
                       _T("\r\n")
                       _T("<treedump>\r\n")
                       _T("\r\n"));
    
    WriteString(hfile, _T("<help>\r\n")
                       _T("The number of children is shown in parentheses after the class name of each node.\r\n")
                       _T("</help>\r\n")
                       _T("\r\n"));
    
    CDispNode const* pRoot = GetRootNode();
    if (pRoot->IsDispRoot())
    {
        CDispRoot const* pDispRoot = CDispRoot::Cast(pRoot);
        if (pDispRoot->_debugUrl)
        {
            WriteHelp(hfile, _T("<<file>\r\n<0s>\r\n<</file>\r\n\r\n"),
                (LPTSTR) *((CStr*)(pDispRoot->_debugUrl)));
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::DumpEnd
//
//  Synopsis:   Finish dumping tree debugging information.
//
//  Arguments:  hFile       handle to output file
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispNode::DumpEnd(HANDLE hFile) const
{
    WriteString(hFile, _T("\r\n")
                       _T("</treedump>\r\n"));
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::Dump
//
//  Synopsis:   Dump debugging information for one node in the tree
//
//  Arguments:  hFile       file handle to dump to
//              level       tree depth at this node
//              maxLevel    max tree depth to dump
//              childNumber number of this child in parent list
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispNode::Dump(HANDLE hFile, long level, long maxLevel, long childNumber) const
{
    WriteString(hFile, _T("<node>\r\n"));
    DumpNodeInfo(hFile, level, childNumber);
    DumpChildren(hFile, level, maxLevel, childNumber);
    WriteString(hFile, _T("</node>\r\n"));
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::DumpChildren
//
//  Synopsis:   Dump this node's children.
//
//  Arguments:  hFile       file handle to dump to
//              level       tree depth at this node
//              maxLevel    max tree depth to dump
//              childNumber number of this child in parent list
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispNode::DumpChildren(HANDLE hFile, long level, long maxLevel, long childNumber) const
{
    // dump children
    if (level < maxLevel && IsParentNode())
    {
        long i = 0;
        for (CDispNode* pChild = AsParent()->_pFirstChild;
             pChild != NULL;
             pChild = pChild->_pNext)
        {
            pChild->Dump(hFile, level+1, maxLevel, i++);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::DumpNodeInfo
//
//  Synopsis:   Dump custom information for this node.
//
//  Arguments:  hFile       file handle to dump to
//              level       tree depth at this node
//              childNumber number of this child in parent list
//
//  Notes:      Nodes with extra information to display override this method.
//
//----------------------------------------------------------------------------

void
CDispNode::DumpNodeInfo(HANDLE hFile, long level, long childNumber) const
{
    WriteHelp(hFile, _T("<<class><0s><</class>\r\n"), ClassName());
    
    DumpContentInfo(hFile, level, childNumber);
    
    DumpFlags(hFile, level, childNumber);
    
    WriteHelp(hFile, _T("<<this><0x><</this>\r\n"), this);
    
    DumpBounds(hFile, level, childNumber);
    
    if (!IsFlowNode() && !IsStructureNode())
    {
        WriteHelp(hFile, _T("<<zindex><0d><</zindex>\r\n"), GetZOrder());
    }
    
    {
        CRect rcbBorderWidths;
        if (HasUserClip())
        {
            WriteString(hFile, _T("<rcUserClip>"));
            DumpRect(hFile, GetUserClip());
            WriteString(hFile, _T("</rcUserClip>\r\n"));
        }
        // WARNING (donmarsh) -- DON'T ADD USER TRANSFORM DATA HERE UNLESS
        // YOU EXTEND displaytree.xsl TO DISPLAY IT USING XML AND XSL.  TALK
        // TO Don Marsh IF YOU NEED ASSISTANCE.
        if (HasUserTransform())
        {
            WriteString(hFile, _T("<i>user transform</i>"));
        }
        if (HasContentOrigin())
        {
            CSize sizeOrigin = GetContentOrigin();
            WriteString(hFile, _T("<contentOrigin>"));
            DumpSize(hFile, sizeOrigin);
            WriteString(hFile, _T("</contentOrigin>\r\n"));
        }
        if (GetBorderType() == DISPNODEBORDER_SIMPLE)
        {
            GetBorderWidths(&rcbBorderWidths);
            WriteHelp(hFile, _T("<<border uniform='1'><0d><</border>\r\n"),
                      rcbBorderWidths.left);
        }
        else if (GetBorderType() == DISPNODEBORDER_COMPLEX)
        {
            GetBorderWidths(&rcbBorderWidths);
            WriteString(hFile, _T("<border>"));
            DumpRect(hFile, rcbBorderWidths);
            WriteString(hFile, _T("</border>\r\n"));
        }
        if (HasInset())
        {
            CSize sizebInset = GetInset();
            WriteString(hFile, _T("<inset>"));
            DumpSize(hFile, sizebInset);
            WriteString(hFile, _T("</inset>\r\n"));
        }
        if (HasExtraCookie())
        {
            WriteHelp(hFile, _T("<<extraCookie><0x><</extraCookie>\r\n"), (LONG)(LONG_PTR)GetExtraCookie());
        }
    }
    
    WriteHelp(hFile, _T("<<size><0d><</size>\r\n"), GetMemorySize());
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::DumpBounds
//
//  Synopsis:   Dump this node's bounding rect.
//
//  Arguments:  hFile       file handle to dump to
//              level       tree depth at this node
//              childNumber number of this child in parent list
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispNode::DumpBounds(HANDLE hFile, long level, long childNumber) const
{
    // print bounds
    WriteString(hFile, _T("<rcVis>"));
    DumpRect(hFile, _rctBounds);
    WriteString(hFile, _T("</rcVis>\r\n"));
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::DumpFlags
//
//  Synopsis:   Dump this node's flags.
//
//  Arguments:  hFile       file handle to dump to
//              level       tree depth at this node
//              childNumber number of this child in parent list
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispNode::DumpFlags(HANDLE hFile, long level, long childNumber) const
{
    WriteString(hFile, _T("<flags>"));
    if (MustRecalc())           WriteString(hFile, _T(" RECALC"));
    if (MustRecalcSubtree())    WriteString(hFile, _T(" RECALCSUBTREE"));
    if (!IsStructureNode() && IsOwned())
                                WriteString(hFile, _T(" OWNED"));
    
    // general flags
    switch (GetLayer())
    {
    case s_layerNegZ:
        WriteString(hFile, _T(" -z"));
        break;
    case s_layerFlow:
        WriteString(hFile, _T(" flow"));
        break;
    case s_layerPosZ:
        WriteString(hFile, _T(" +z"));
        break;
    default:
        WriteHelp(hFile, _T("<<b>ILLEGAL LAYER: <0d><</b>"), GetLayer());
        break;
    }

    if (HasUserTransform())     WriteString(hFile, _T(" userTransform"));
    
    if (!AffectsScrollBounds()) WriteString(hFile, _T(" !affectsScrollBounds"));
    if (!IsVisible())           WriteString(hFile, _T(" invisible"));
    if (HasBackground())        WriteString(hFile, _T(" hasBackground"));
    if (IsSet(s_hasWindowTop))  WriteString(hFile, _T(" hasWindowTop"));
    if (IsSet(s_advanced))      WriteString(hFile, _T(" advanced"));
    if (IsSet(s_savedRedrawRegion))
                                WriteString(hFile, _T(" savedRedrawRegion"));
    if (IsInvalid())            WriteString(hFile, _T(" inval"));
    if (IsOpaque())             WriteString(hFile, _T(" opaque"));
    if (IsDrawnExternally())    WriteString(hFile, _T("<b><i> drawnExternally</i></b>"));

    // leaf flags
    if (IsLeafNode())
    {
        if (PositionChanged())  WriteString(hFile, _T(" positionChanged"));
        if (IsSet(s_notifyNewInsertion))
                                WriteString(hFile, _T(" notifyInsert"));
    }

    // parent flags
    else
    {
        if (HasFixedBackground())
                                WriteString(hFile, _T(" fixedBkgnd"));
    }

    // propagated flags
    if (!IsInView())            WriteString(hFile, _T(" !inView"));
    if (!IsVisibleBranch())     WriteString(hFile, _T(" invisibleBranch"));
    if (IsOpaqueBranch())       WriteString(hFile, _T(" opaqueBranch"));
    if (IsPositionAware())      WriteString(hFile, _T(" positionAware"));
    if (IsInViewAware())        WriteString(hFile, _T(" inViewAware"));
    
    WriteString(hFile, _T("</flags>\r\n"));
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::Info
//              
//  Synopsis:   Dump interesting info to debug output window.
//              
//  Arguments:  
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispNode::Info() const
{
    OutputDebugString(ClassName());
    
    OutputDebugStringA("\n basic flags: ");
    if (IsParentNode())         OutputDebugStringA("PARENT ");
    if (IsStructureNode())      OutputDebugStringA("STRUCTURE ");
    if (!IsStructureNode() && IsOwned())
                                OutputDebugStringA("OWNED ");
    if (IsNewInsertion())       OutputDebugStringA("NEWINSERT ");
    if (IsParentNode() && ChildrenChanged())
                                OutputDebugStringA("CHILDRENCHANGED ");
    if (MustRecalc())           OutputDebugStringA("RECALC ");
    if (MustRecalcSubtree())    OutputDebugStringA("RECALCSUBTREE ");
    if (IsStructureNode() && MustRebalance())
                                OutputDebugStringA("REBALANCE ");
    OutputDebugStringA("\n");
    
    OutputDebugStringA(" display flags: ");
    switch (GetLayer())
    {
    case s_layerNegZ:   OutputDebugStringA("-z ");      break;
    case s_layerFlow:   OutputDebugStringA("flow ");    break;
    case s_layerPosZ:   OutputDebugStringA("+z ");      break;
    default:            OutputDebugStringA("ILLEGAL LAYER "); break;
    }
    
    if (HasUserTransform())         OutputDebugStringA("userTransform ");
    
    if (IsVisible())                OutputDebugStringA("visibleNode ");
    if (HasBackground())            OutputDebugStringA("hasBackground ");
    if (IsSet(s_hasWindowTop))      OutputDebugStringA("hasWindowTop ");
    if (IsSet(s_advanced))          OutputDebugStringA("advanced ");
    if (IsOpaque())                 OutputDebugStringA("opaqueNode ");
    if (!AffectsScrollBounds())     OutputDebugStringA("!noScrollBounds ");
    if (IsDrawnExternally())        OutputDebugStringA("drawnExternally ");
    if (HasUserClip())              OutputDebugStringA("hasUserClip ");
    if (IsSet(s_fatHitTest))        OutputDebugStringA("fatHitTest ");
    if (IsSet(s_savedRedrawRegion)) OutputDebugStringA("savedRedrawRegion ");
    if (IsInView())                 OutputDebugStringA("inView ");
    if (IsVisibleBranch())          OutputDebugStringA("visibleBranch ");
    if (IsOpaqueBranch())           OutputDebugStringA("opaqueBranch ");
    if (IsPositionAware())          OutputDebugStringA("notifyPositionChange ");
    if (IsInViewAware())            OutputDebugStringA("notifyInViewChange ");
    if (IsLeafNode())
    {
        if (PositionChanged())      OutputDebugStringA("positionChanged ");
        if (IsInsertionAware())     OutputDebugStringA("notifyNewInsertion ");
    }
    else
    {
        if (HasFixedBackground())   OutputDebugStringA("fixedBackground ");
    }
    
    if (HasUserTransform())
    {
        _TCHAR buf[1024];
        OutputDebugStringA("\nUser Transform:\n");
        const CDispTransform& transform = GetUserTransform();
        if (transform.IsOffsetOnly())
        {
            const CSize& offset = transform.GetOffsetOnly();
            wsprintf(buf, __T("translate: %d,%d"), offset.cx, offset.cy);
            OutputDebugString(buf); 
        }
        else
        {
            const MAT& m = transform.GetWorldTransform()->GetMatrix();
            wsprintf(buf, __T("mat (*100): %d,%d | %d,%d | %d,%d\n"),
                     (int)(m.eM11*100), (int)(m.eM12*100),
                     (int)(m.eM21*100), (int)(m.eM22*100),
                     (int)(m.eDx*100), (int)(m.eDy*100));
            OutputDebugString(buf); 
            const MAT& r = transform.GetWorldTransform()->GetMatrixInverse();
            wsprintf(buf, __T("inv (*100): %d,%d | %d,%d | %d,%d"),
                     (int)(r.eM11*100), (int)(r.eM12*100),
                     (int)(r.eM21*100), (int)(r.eM22*100),
                     (int)(r.eDx*100), (int)(r.eDy*100));
            OutputDebugString(buf); 
        }
    }
    
    OutputDebugStringA("\n\n");
}


//+---------------------------------------------------------------------------
//
//  Class:      CShowExtras
//              
//  Synopsis:   Visualize extras for debugging purposes.
//              See CDispNode::ShowExtras()
//              
//----------------------------------------------------------------------------

class CShowExtras
{
public:
    LONG*                     _pSimpleBorderWidth;
    CRect*                    _pComplexBorder;
    CSize*                    _pInset;
    CUserClipAndExpandedClip* _pUserClip;
    void**                    _pExtraCookie;
    CExtraTransform*          _pExtraTransform;
    CExtraContentOrigin*      _pExtraContentOrigin;

    // force linker keep dbg methods that are not referenced anywhere else
    CShowExtras(CDispNode* p) {if (p) p->ShowExtras(), p->Info();}
};

CShowExtras g_ShowExtras(0);

//+---------------------------------------------------------------------------
//
//  Member:     CDispNode::ShowExtras
//              
//  Synopsis:   Visualize extras in MSVC debugger.
//              Usage: just drag ShowExtras() into watch window
//              and see pointers to real extras of "this" CDispNode
//              (or zeros if corresponding extras don't present).
//              
//----------------------------------------------------------------------------

CShowExtras const* CDispNode::ShowExtras() const
{
    g_ShowExtras._pSimpleBorderWidth  = HasExtra(DISPEX_SIMPLEBORDER ) ? (LONG*                    )GetExtra(DISPEX_SIMPLEBORDER ) : 0;
    g_ShowExtras._pComplexBorder      = HasExtra(DISPEX_COMPLEXBORDER) ? (CRect*                   )GetExtra(DISPEX_COMPLEXBORDER) : 0;
    g_ShowExtras._pInset              = HasExtra(DISPEX_INSET        ) ? (CSize*                   )GetExtra(DISPEX_INSET        ) : 0;
    g_ShowExtras._pUserClip           = HasExtra(DISPEX_USERCLIP     ) ? (CUserClipAndExpandedClip*)GetExtra(DISPEX_USERCLIP     ) : 0;
    g_ShowExtras._pExtraCookie        = HasExtra(DISPEX_EXTRACOOKIE  ) ? (void**                   )GetExtra(DISPEX_EXTRACOOKIE  ) : 0;
    g_ShowExtras._pExtraTransform     = HasExtra(DISPEX_USERTRANSFORM) ? (CExtraTransform*         )GetExtra(DISPEX_USERTRANSFORM) : 0;
    g_ShowExtras._pExtraContentOrigin = HasExtra(DISPEX_CONTENTORIGIN) ? (CExtraContentOrigin*     )GetExtra(DISPEX_CONTENTORIGIN) : 0;
    return &g_ShowExtras;
}

#endif

void CDispNode::SetUserTransform(const CDispTransform *pUserTransform)
{
    GetExtraTransform()->_transform = *pUserTransform;
    InvalidateAndRecalcSubtree();
}

void CDispNode::SetInset(const SIZE& sizebInset)
{
    *(CSize*)GetExtra(DISPEX_INSET) = sizebInset;
    InvalidateAndRecalcSubtree();
}

DISPNODEBORDER CDispNode::GetBorderType() const
{
    return HasExtra(DISPEX_SIMPLEBORDER ) ? DISPNODEBORDER_SIMPLE
         : HasExtra(DISPEX_COMPLEXBORDER) ? DISPNODEBORDER_COMPLEX
         :                                  DISPNODEBORDER_NONE;
}
    
void CDispNode::GetBorderWidths(CRect* prcbBorderWidths) const
{
    if (HasExtra(DISPEX_SIMPLEBORDER))
    {
        long c = *((long*)GetExtra(DISPEX_SIMPLEBORDER));
        prcbBorderWidths->SetRect(c);
    }
    else if (HasExtra(DISPEX_COMPLEXBORDER))
        *prcbBorderWidths = *((CRect*)GetExtra(DISPEX_COMPLEXBORDER));
    else
        *prcbBorderWidths = g_Zero.rc;
}

void CDispNode::SetBorderWidths(LONG borderWidth)
{
    *(LONG*)GetExtra(DISPEX_SIMPLEBORDER) = borderWidth;
    InvalidateAndRecalcSubtree();
}

void CDispNode::SetBorderWidths(const CRect& rcbBorderWidths)
{
    *(CRect*)GetExtra(DISPEX_COMPLEXBORDER) =  rcbBorderWidths;
    InvalidateAndRecalcSubtree();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\display\dispstructurenode.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       dispstructurenode.cxx
//
//  Contents:   Structure node for display tree.
//
//  Classes:    CDispStructureNode
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DISPSTRUCTURENODE_HXX_
#define X_DISPSTRUCTURENODE_HXX_
#include "dispstructurenode.hxx"
#endif

MtDefine(CDispStructureNode, DisplayTree, "CDispStructureNode")

// ======== CDispStructureNode basics =============
// (this comment should go to proper place)
//
// Structure node never exposed to display tree users.
// Structure node is never owned (i.e. SetOwned/IsOwned never applied to it)
// Structure node is never empty, it contains at least one child (that can be also structure)
// Structure node siblings are always structure node.
// Structure node subtree however can have "different depth". I.e. structure node cousins
//   not necessary is structure node.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\display\disproot.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       disproot.cxx
//
//  Contents:   Parent node at the root of a display tree.
//
//  Classes:    CDispRoot
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DISPROOT_HXX_
#define X_DISPROOT_HXX_
#include "disproot.hxx"
#endif

#ifndef X_DEBUGPAINT_HXX_
#define X_DEBUGPAINT_HXX_
#include "debugpaint.hxx"
#endif

#ifndef X_DISPCLIENT_HXX_
#define X_DISPCLIENT_HXX_
#include "dispclient.hxx"
#endif

#ifndef X_DISPINFO_HXX_
#define X_DISPINFO_HXX_
#include "dispinfo.hxx"
#endif

MtDefine(DisplayTree, Mem, "DisplayTree")
MtDefine(CDispRoot, DisplayTree, "CDispRoot")
MtDefine(CDispRoot_aryDispNode_pv, DisplayTree, "CDispRoot_aryDispNode")
MtDefine(CDispRoot_aryWTopScroller_pv, DisplayTree, "CDispRoot_aryWTopScroller")
MtDefine(CDispRoot_aryObscure_pv, DisplayTree, "CDispRoot_aryObscure")

DeclareTag(tagDisplayTreeOpen, "Display", "trace Open/Close");
DeclareTag(tagDisplayTreeOpenStack,   "Display: TreeOpen stack",   "Stack trace for each OpenDisplayTree")
DeclareTag(tagObscure,   "Display",   "trace obscured list")

#if DBG==1
void
CDispRoot::OpenDisplayTree()
{
#ifndef VSTUDIO7
    CheckReenter();
#endif //VSTUDIO7
    _cOpen++;

    TraceTag((tagDisplayTreeOpen, "TID:%x %x root +%d", GetCurrentThreadId(), this, _cOpen));
    TraceTag((tagDisplayTreeOpenStack, "\n***** OpenDisplayTree call stack:"));
    TraceCallers(tagDisplayTreeOpenStack, 0, 10);

    if (_cOpen == 1)
    {
        // on first open, none of these flags should be set
        VerifyFlags(s_flagsNotSetInDraw, 0, TRUE);
    }
}

void
CDispRoot::CloseDisplayTree(CDispRecalcContext* pContext)
{
#ifndef VSTUDIO7
    CheckReenter();
#endif //VSTUDIO7
    Assert(_cOpen > 0 && !IsInRecalc());
    TraceTag((tagDisplayTreeOpen, "TID:%x %x root -%d", GetCurrentThreadId(), this, _cOpen));
    if (_cOpen == 1)
    {
        RecalcRoot(pContext);
        
        // after recalc, no recalc flags should be set
        VerifyFlags(s_flagsNotSetInDraw, 0, TRUE);
    }
    _cOpen--;
}
#endif

//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::CDispRoot
//
//  Synopsis:   Constructor.
//
//  Arguments:  pObserver       display tree observer
//              pDispClient     display client
//
//  Notes:
//
//----------------------------------------------------------------------------

CDispRoot::CDispRoot(
        CDispObserver* pObserver,
        CDispClient* pDispClient)
    : CDispScroller(pDispClient)
{
    SetFlags(s_visibleBranch | s_visibleNode | s_opaqueBranch | s_opaqueNode | s_inView);
    _pDispObserver = pObserver;
    _pOverlaySink = NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::~CDispRoot
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------


CDispRoot::~CDispRoot()
{
    AssertSz(!_fDrawLock, "Illegal call to CDispRoot inside Draw()");
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::Unload
//
//  Synopsis:   Unload the tree (called by CView::Unload)
//
//----------------------------------------------------------------------------

void
CDispRoot::Unload()
{
    CDispNode * pDispNode;

    ClearWindowTopList();
    ClearOverlayList();
    
    Assert(CountChildren() <= 1);

    pDispNode = GetFirstChildNode();

    if (pDispNode)
    {
        pDispNode->ExtractFromTree();
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::ExtractNode
//
//  Synopsis:   Remove the given node from the tree
//
//----------------------------------------------------------------------------

void
CDispRoot::ExtractNode(CDispNode *pDispNode)
{
    // if the node is in the tree, remove its descendants from the special lists
    if (pDispNode->_pParent)
    {
        if (_aryDispNodeWindowTop.Size() > 0)
        {
            ScrubWindowTopList(pDispNode);
        }

        if (_aryDispNodeOverlay.Size() > 0)
        {
            ScrubOverlayList(pDispNode);
        }
    }

    pDispNode->ExtractFromTree();
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::ExtractNodes
//
//  Synopsis:   Removes several nodes from the tree
//
//----------------------------------------------------------------------------

void
CDispRoot::ExtractNodes(CDispNode *pDispNodeStart, CDispNode *pDispNodeStop)
{
    // all tree extractions must clean up the special lists
    if (pDispNodeStart->GetParentNode() &&
        (_aryDispNodeWindowTop.Size() > 0 ||
         _aryDispNodeOverlay.Size() > 0))
    {
        // for each node between the start and stop
        for (   CDispNode* pNode = pDispNodeStart;
                (_aryDispNodeWindowTop.Size() > 0 ||
                 _aryDispNodeOverlay.Size() > 0)
                 && pNode != 0;
                pNode = pNode->GetNextSiblingNode()
            )
        {
            // clean up current node (and its descendants)
            ScrubWindowTopList(pNode);
            ScrubOverlayList(pNode);

            // if we're reached the stop node, we're done
            if (pNode == pDispNodeStop)
            {
                break;
            }
        }
    }

    // now do the real extraction
    ExtractOrDestroyNodes(pDispNodeStart, pDispNodeStop);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::DrawRoot
//
//  Synopsis:   Draw this display tree.
//
//  Arguments:  pContext        draw context
//              pClientData     client data used by clients in DrawClient
//              hrgngDraw       region to draw in destination coordinates
//              prcgDraw        rect to draw in destination coordinates
//
//  Notes:      if hrgngDraw and prcgDraw are both NULL, the bounding rect of
//              this root node is used
//
//----------------------------------------------------------------------------

void
CDispRoot::DrawRoot(
        CDispSurface* pRenderSurface,
        CDispSurface* pOffscreenBuffer,
        CDispDrawContext* pContext,
        void* pClientData,
        HRGN hrgngDraw,
        const RECT* prcgDraw)
{
    AssertSz(!_fDrawLock, "Illegal call to DrawRoot inside Draw()");
    AssertSz(_cOpen == 0, "DrawRoot called while Display Tree is open");
    Assert(pRenderSurface != NULL);
    Assert(!IsAnySet(s_flagsNotSetInDraw));

    pContext->SetRootNode(this);
    pContext->SetDispSurface(pRenderSurface);

    // set redraw region (will become a rect if possible)
    CRegion rgngRedraw;
    CRect rcContainerTransformed;
    pContext->GetClipTransform()
             .NoClip()
             .GetWorldTransform()
            ->GetBoundingRectAfterTransform(&_rcpContainer,
                                            &rcContainerTransformed,
                                            TRUE);
    if (hrgngDraw != NULL)
    {
        rgngRedraw = hrgngDraw;
        rgngRedraw.Intersect(rcContainerTransformed);
    }
    else if (prcgDraw != NULL)
    {
        rgngRedraw = *prcgDraw;
        rgngRedraw.Intersect(rcContainerTransformed);
    }
    else
    {
        rgngRedraw = rcContainerTransformed;
    }
    
#if DBG==1
    CRegionRects debugHrgn(hrgngDraw);
    CRegionRects debugRedraw(rgngRedraw);

    // show invalid area for debugging

        CDebugPaint::ShowPaint(
            NULL, rgngRedraw.GetRegionForLook(), pRenderSurface->GetRawDC(),
            tagPaintShow, tagPaintPause, tagPaintWait, TRUE);
#endif

    // check for early exit conditions
    if (!rgngRedraw.Intersects(_rcpContainer))
        return;
    
    // set initial context values
    pContext->SetClientData(pClientData);
    pContext->SetFirstDrawNode(NULL);
    pContext->SetRedrawRegion(&rgngRedraw);

    // NOTE (donmarsh) -- this is a little ugly, but _rctBounds
    // for CDispRoot must be zero-based, because it is transformed by the
    // offset in CDispNode::Draw, and if _rctBounds == _rcpContainer like
    // one would expect, _rctBounds gets transformed twice.
    _rctBounds.MoveToOrigin();

    // DrawRoot does not allow recursion
    _fDrawLock = TRUE;

    // don't worry about return value of TransformedToBoxCoords, because we
    // don't expect the root to have user clip specified
    Assert(!HasUserClip());
    TransformedToBoxCoords(&pContext->GetClipTransform());
    
    // calculate rect inside border and scrollbars
    CSize sizeInsideBorder;
    GetSizeInsideBorder(&sizeInsideBorder);
    CRect rcgInsideBorder(_rcpContainer.TopLeft(), sizeInsideBorder);
    
    // speed optimization: draw border and scroll bars
    // without buffering or banding, then subtract them from the redraw
    // region.
    if (IsVisible())
    {
        CRect rcgClip;
        rgngRedraw.GetBounds(&rcgClip);
        
        CRegion rgngClip(rcgClip);
        pRenderSurface->SetClipRgn(&rgngClip);
        
        // draw borders for clipping nodes near the top of the tree, and remove
        // the border areas from the redraw region
        {
            CSaveDispClipTransform saveTransform(pContext);
            Assert(IsClipNode());
            CDispClipNode::Cast(this)->DrawUnbufferedBorder(pContext);
        }
        
        pRenderSurface->SetClipRgn(NULL);

        // restore clipping on destination surface to redraw region
        // (this is important when we're using filters and we have a
        // direct draw surface)
        rgngRedraw.SelectClipRgn(pRenderSurface->GetRawDC());
        
        // early exit if all we needed to draw was the border and scroll bars
        if (rgngRedraw.IsEmpty())
            goto Cleanup;
    }

    // early exit if all we needed to draw was the border and scroll bars
    if (!rcgInsideBorder.IsEmpty())
    {
        // save the initial state, to be used in the window-top pass
        CDispClipTransform transformInitial = pContext->GetClipTransform();

        // allocate stacks for redraw regions and transforms
        CRegionStack redrawRegionStack;
        pContext->SetRedrawRegionStack(&redrawRegionStack);
        CDispTransformStack transformStack;
        pContext->SetTransformStack(&transformStack);

        // PreDraw pass processes the tree from highest layer to lowest,
        // culling layers beneath opaque layers, and identifying the lowest
        // opaque layer which needs to be rendered during the Draw pass
        PreDraw(pContext);
        pContext->SetClipTransform(transformInitial);
        
        // the redraw region will always be empty, because we should subtract
        // the root from it if nothing else
        Assert(pContext->GetRedrawRegion()->IsEmpty());
        delete pContext->GetRedrawRegion();
        // we shouldn't reference this redraw region again
        WHEN_DBG(pContext->SetRedrawRegion(NULL);)

        if (pContext->GetFirstDrawNode() == NULL)
        {
            pContext->SetFirstDrawNode(this);
        }
        else
        {
            AssertSz(redrawRegionStack.MoreToPop(), "Mysterious redraw region stack bug!");
            transformStack.Restore();
        }


        if (pOffscreenBuffer == NULL)
        {
            DrawEntire(pContext);
        }
        else if (pOffscreenBuffer->Height() >= rcgInsideBorder.Height())
        {
#if DBG == 1
            {
                HDC hdc = pOffscreenBuffer->GetRawDC();
                HBRUSH hbr = CreateSolidBrush(RGB(0, 255, 0));
                CRect rc(-10000, -10000, 20000, 20000);
                FillRect(hdc, &rc, hbr);
                DeleteObject(hbr);
            }
#endif

            pContext->SetDispSurface(pOffscreenBuffer);
            DrawEntire(pContext);
            pOffscreenBuffer->Draw(pRenderSurface, rcgInsideBorder);
        }
        else
        {
            pContext->SetDispSurface(pOffscreenBuffer);
            DrawBands(
                pRenderSurface,
                pOffscreenBuffer,
                pContext,
                &rgngRedraw,
                redrawRegionStack,
                rcgInsideBorder);
        }

        // delete all regions except the first
        redrawRegionStack.DeleteStack(&rgngRedraw);
    
#if DBG==1
        // make sure we didn't lose any nodes that were marked with
        // savedRedrawRegion
        VerifyFlags(s_savedRedrawRegion, 0, TRUE);
#endif

        pContext->SetClientData(NULL);
    }

Cleanup:
    // NOTE (donmarsh) -- restore _rctBounds to coincide with _rcpContainer
    _rctBounds = _rcpContainer;

    _fDrawLock = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::DrawWindowTopNodes
//
//  Synopsis:   Draw the nodes on the window-top list
//
//  Arguments:  pContext        draw context
//
//  Notes:      
//
//----------------------------------------------------------------------------

void
CDispRoot::DrawWindowTopNodes(CDispDrawContext* pContext)
{
    if (_aryDispNodeWindowTop.Size() > 0)
    {
        int i = _aryDispNodeWindowTop.Size();
        CDispNode **ppDispNode = &_aryDispNodeWindowTop[0];

        for ( ; i > 0; --i, ++ppDispNode)
        {
            Assert((*ppDispNode)->GetDispRoot() == this);
            (*ppDispNode)->DrawAtWindowTop(pContext);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::DrawEntire
//
//  Synopsis:   Draw the display tree in one pass, starting at the top node
//              in the saved redraw region array.
//
//  Arguments:  pContext        draw context
//
//  Notes:      
//
//----------------------------------------------------------------------------

void
CDispRoot::DrawEntire(CDispDrawContext* pContext)
{
    CDispClipTransform transformSave;

    // if there are window-top nodes, we'll need the original context later
    if (_aryDispNodeWindowTop.Size() > 0)
    {
        transformSave = pContext->GetClipTransform();
    }

    // pop first node and redraw region
    CDispNode* pDrawNode = (CDispNode*) pContext->PopFirstRedrawRegion();
    
    Assert(pDrawNode == pContext->GetFirstDrawNode());

    // we better have the correct context ready for the parent node
    Assert(pDrawNode != NULL &&
           (pDrawNode->GetRawParentNode() == NULL ||
            pContext->GetTransformStack()->GetTopNode() == pDrawNode->GetRawParentNode()));
    
    MarkSavedRedrawBranches(*pContext->GetRedrawRegionStack(), TRUE);
    
    while (pDrawNode != NULL)
    {
        // get context (clip rect and offset) for parent node
        CDispNode* pParent = pDrawNode->GetRawParentNode();
        
        if (pParent == NULL)
        {
            pParent = this;
            pDrawNode = NULL;
        }
        else if (!pContext->PopTransform(pParent))
        {
            pContext->FillTransformStack(pDrawNode);
            Verify(pContext->PopTransform(pParent));
        }

        // draw children of this parent node, starting with this child
        pParent->Draw(pContext, pDrawNode, FILTER_DRAW_ALLLAYERS);

        // find next node to the right of the parent node
        for (;;)
        {
            pDrawNode = pParent->_pNext;
            if (pDrawNode != NULL)
                break;
            pParent = pParent->GetRawParentNode();
            if (pParent == NULL)
                break;
            
            // this parent node should not have saved context information
            Assert(pContext->GetTransformStack()->GetTopNode() != pParent);
        }
    }

    MarkSavedRedrawBranches(*pContext->GetRedrawRegionStack(), FALSE);

    // stacks should now be empty
    Assert(!pContext->GetTransformStack()->MoreToPop());
    Assert(!pContext->GetRedrawRegionStack()->MoreToPop());

    // draw the window-top nodes
    if (_aryDispNodeWindowTop.Size() > 0)
    {
        pContext->SetClipTransform(transformSave);
        DrawWindowTopNodes(pContext);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::DrawBand
//
//  Synopsis:   Draw one band using the display tree, starting at the top node
//              in the saved redraw region array.
//
//  Arguments:  pContext        draw context
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispRoot::DrawBands(
        CDispSurface* pRenderSurface,
        CDispSurface* pOffscreenBuffer,
        CDispDrawContext* pContext,
        CRegion* prgngRedraw,
        const CRegionStack& redrawRegionStack,
        const CRect& rcgInsideBorder)
{
    Assert(pOffscreenBuffer);

    if(!pContext)
        return;

    long height = min(rcgInsideBorder.Height(), pOffscreenBuffer->Height());
    while (!prgngRedraw->IsEmpty())
    {
        // compute next banding rectangle
        CRect rcgBand;
        prgngRedraw->GetBounds(&rcgBand);
        rcgBand.left = rcgInsideBorder.left;
        rcgBand.right = rcgInsideBorder.right;
        rcgBand.bottom = rcgBand.top + height;
        if (rcgBand.bottom > rcgInsideBorder.bottom)
        {
            rcgBand.bottom = rcgInsideBorder.bottom;
        }
        
        // NOTE (donmarsh) -- for some reason, we're getting here occasionally
        // with an empty rcBand.  At one time, this could be caused by
        // pOffscreenBuffer->Height() returning zero.  I don't believe that
        // is possible any more.  However, something is happening, and we have
        // to check for it, or we will go into an infinite loop.
        Assert(height > 0 && pOffscreenBuffer->Height() > 0);
        Assert(!rcgBand.IsEmpty());
        Assert(prgngRedraw->Intersects(rcgBand));
        if (rcgBand.bottom <= rcgBand.top || !prgngRedraw->Intersects(rcgBand))
            break;
        
        // clip regions in redraw region stack to this band
        CRegionStack clippedRedrawRegionStack(redrawRegionStack, rcgBand);
        
        if (clippedRedrawRegionStack.MoreToPop())
        {
            pContext->SetRedrawRegionStack(&clippedRedrawRegionStack);
    
#if DBG==1
            // show invalid area for debugging
            CRect rcDebug(0,0,_rcpContainer.Width(), height);
            CDebugPaint::ShowPaint(
                &rcDebug, NULL,
                pContext->GetRawDC(),
                tagPaintShow, tagPaintPause, tagPaintWait, TRUE);

            {
                HDC hdc = pOffscreenBuffer->GetRawDC();
                HBRUSH hbr = CreateSolidBrush(RGB(0, 255, 0));
                CRect rc(-10000, -10000, 20000, 20000);
                FillRect(hdc, &rc, hbr);
                DeleteObject(hbr);
            }
#endif
            
            // draw contents of this band
            MarkSavedRedrawBranches(clippedRedrawRegionStack, TRUE);
            DrawBand(pContext, rcgBand);
            MarkSavedRedrawBranches(clippedRedrawRegionStack, FALSE);

            // draw offscreen buffer to destination
            pOffscreenBuffer->Draw(pRenderSurface, rcgBand);
            
            // discard clipped regions
            clippedRedrawRegionStack.DeleteStack();
        }
        
        // remove band from redraw region
        prgngRedraw->Subtract(rcgBand);
    }
}

void
CDispRoot::DrawBand(CDispDrawContext* pContext, const CRect& rcgBand)
{
    if(!pContext)
        return;

    CSaveDispClipTransform transformSave(pContext);
    CDispClipTransform transformSaveForWindowTop;

    // add band offset to transform
    pContext->AddPostOffset(-rcgBand.TopLeft().AsSize());

    // if there are window-top nodes, we'll need the original context later
    if (_aryDispNodeWindowTop.Size() > 0)
    {
        transformSaveForWindowTop = pContext->GetClipTransform();
    }
    
    // pop first node and redraw region
    CDispNode* pDrawNode = (CDispNode*) pContext->PopFirstRedrawRegion();

    // create a new transform stack that will incorporate the new band offset
    CDispTransformStack transformStack;
    pContext->SetTransformStack(&transformStack);

    while (pDrawNode != NULL)
    {
        // get context (clip rect and offset) for parent node
        CDispNode* pParent = pDrawNode->GetRawParentNode();
        if (pParent == NULL)
        {
            pParent = this;
            pDrawNode = NULL;
        }
        else if (!pContext->PopTransform(pParent))
        {
            pContext->FillTransformStack(pDrawNode);
            Verify(pContext->PopTransform(pParent));
        }

        // draw children of this parent node, starting with this child
        pParent->Draw(pContext, pDrawNode, FILTER_DRAW_ALLLAYERS);

        // find next node to the right of the parent node
        for (;;)
        {
            pDrawNode = pParent->_pNext;
            if (pDrawNode != NULL)
                break;
            pParent = pParent->GetRawParentNode();
            if (pParent == NULL)
                break;

            // this parent node should not have saved transform information
            Assert(pContext->GetTransformStack()->GetTopNode() != pParent);
        }
    }

    // stacks should now be empty
    Assert(!pContext->GetTransformStack()->MoreToPop());
    Assert(!pContext->GetRedrawRegionStack()->MoreToPop());

    // draw the window-top nodes
    if (_aryDispNodeWindowTop.Size() > 0)
    {
        pContext->SetClipTransform(transformSaveForWindowTop);
        DrawWindowTopNodes(pContext);
    }
}


void
CDispRoot::MarkSavedRedrawBranches(const CRegionStack& regionStack, BOOL fSet)
{
    for (int i = 0; i < regionStack.Size(); i++)
    {
        CDispNode* pNode = (CDispNode*) regionStack.GetKey(i);
        if (fSet)
            pNode->SetFlagsToRoot(s_savedRedrawRegion);
        else
            pNode->ClearFlagsToRoot(s_savedRedrawRegion);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::DrawNode
//
//  Synopsis:   Draw the display tree rooted at the given display node on
//              an HDC supplied by external entity.
//              Used for trans. filters and external printing
//              Called by CView::RenderElement
//
//  Arguments:  
//              pNode           node to draw
//              pSurface        drawinf surface
//              pContext        drawing context
//
//  Notes:      
//
//----------------------------------------------------------------------------

void
CDispRoot::DrawNode(
        CDispNode* pNode,
        CDispSurface *pSurface,
        CDispDrawContext *pContext,
        long lDrawLayers)
{
    // DrawRoot does not allow recursion
    AssertSz(!_fDrawLock, "Illegal call to DrawNodeLayer inside Draw()");
    AssertSz(_cOpen == 0, "DrawNodeLayer called while Display Tree is open");
    Assert(pNode && pSurface && pContext);

    if(!pNode || !pContext)
        return;


#if DBG==1
    // shouldn't be here with a tree needing recalc
    VerifyFlags(s_flagsNotSetInDraw, 0, TRUE);
#endif

    _fDrawLock = TRUE;

    // TODO (donmarsh) -- for ultimate performance, we should set things up
    // like DrawRoot in order to do a PreDraw pass on the children belonging to
    // the indicated layer.  However, this is complicated by the fact that we
    // may begin drawing at an arbitrary node deep in the tree below this node,
    // and we have to be sure not to draw any nodes above this node.
    // DrawEntire, which we would like to
    // use to accomplish this, does not stop drawing until it has drawn all
    // layers in all nodes all the way to the root.  For now, we do the simple
    // thing, and just draw all of our children,
    // ignoring the opaque optimizations of PreDraw.

    // allocate stacks for redraw regions and transforms
    CRegionStack redrawRegionStack;
    pContext->SetRedrawRegionStack(&redrawRegionStack);
    CDispTransformStack transformStack;
    pContext->SetTransformStack(&transformStack);

    pContext->SetDispSurface(pSurface);

#if DBG==1
    pContext->GetClipTransform().NoClip()._csDebug = COORDSYS_TRANSFORMED;
    pContext->GetClipTransform().NoClip()._pNode = pNode;
#endif

    pNode->Draw(pContext, NULL, lDrawLayers);

    _fDrawLock = FALSE;

}


//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::SetSize
//
//  Synopsis:   Set the size of the root container.
//
//  Arguments:  sizep               new size
//              fInvalidateAll      TRUE if entire area should be invalidated
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispRoot::SetSize(const CSize& sizep, const CRect *prcpMapped, BOOL fInvalidateAll)
{
    AssertSz(!_fDrawLock, "Illegal call to CDispRoot::SetSize inside Draw()");
    super::SetSize(sizep, prcpMapped, fInvalidateAll);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::SetContentOffset
//              
//  Synopsis:   Set an offset that shifts displayed content (used by printing
//              to effectively scroll content between pages).
//              
//  Arguments:  sizesOffset     offset amount, where positive values display
//                              content farther to the right and bottom
//                              
//  Returns:    TRUE if the content offset amount was successfully set.
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CDispRoot::SetContentOffset(const SIZE& sizesOffset)
{
    AssertSz(_cOpen == 1, "Display Tree: Unexpected call to SetContentOffset");
    
    _sizeScrollOffset = -(CSize&)sizesOffset;
    CDispParentNode::CalculateInView(this);
    
    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::RecalcRoot
//              
//  Synopsis:   Recalculate this tree's cached state.
//              
//  Arguments:  pContext    recalc context
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispRoot::RecalcRoot(CDispRecalcContext* pContext)
{
    AssertSz(_cOpen == 1, "Display Tree: Unexpected call to RecalcRoot");
#ifndef VSTUDIO7
    AssertSz(!_fDrawLock, "Illegal call to RecalcRoot inside Draw()");
#endif //VSTUDIO7

    if (MustRecalc())
    {
        ULONG cObscuringElements  = _cObscuringElements;
        ULONG cObscurableElements = _cObscurableElements;
        BOOL fWasObscuringPossible = IsObscuringPossible();

        pContext->SetRootNode(this);
        
        // recalc everything if root size changed, or obscuring might occur
        pContext->_fSuppressInval = IsInvalid();
        pContext->_fRecalcSubtree = pContext->_fSuppressInval || fWasObscuringPossible;

RestartRecalc:
        // initialize obscure list
        _cObscuringElements = 0;
        Assert(_aryObscure.Size() == 0);

        // recalc
        _fRecalcLock = TRUE;
        Recalc(pContext);
        _fRecalcLock = FALSE;


        // after a full recalc, simply update the counts of obscurable
        // elements (obscuring elements get counted in Recalc)
        if (pContext->_fRecalcSubtree)
        {
            _cObscurableElements = _aryObscure.Size();
        }

        // after a partial recalc, update the counts of
        // elements participating in obscuring.  (We don't need an exact count,
        // only the zero/nonzero status matters.)
        else
        {
            _cObscuringElements = max(_cObscuringElements, cObscuringElements);
            _cObscurableElements = max((ULONG)_aryObscure.Size(), cObscurableElements);

            // if new obscuring and/or obscurable elements were discovered during
            // recalc, we have to run the full obscuring algorithm.  This requires
            // a full recalc.
            if (IsObscuringPossible())
            {
                _cObscuringElements = 0;    // supress real work in ProcessObscureList
                ProcessObscureList();       // but clear the list anyway

                pContext->_fRecalcSubtree = TRUE;
                goto RestartRecalc;
            }
        }


        // process the obscure list
        ProcessObscureList();

        // the root is always a visible, opaque, in-view branch
        SetFlags(s_preDrawSelector);

        Assert(_aryObscure.Size() == 0);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::HitTest
//              
//  Synopsis:   Perform hit testing starting at the root of the display tree.
//              
//  Arguments:  pptHit              [in] the point to test
//                                  [out] if something was hit, the point is
//                                  returned in container coordinates for the
//                                  thing that was hit
//              pCoordinateSystem   the coordinate system for pptHit
//              pClientData         client data
//              fHitContent         if TRUE, hit test the content regardless
//                                  of whether it is clipped or not. If FALSE,
//                                  take current clipping into account,
//                                  and clip to the bounds of this container.
//              cFuzzyHitTest       Number of pixels to extend hit testing
//                                  rectangles in order to do "fuzzy" hit
//                                  testing
//
//  Returns:    TRUE if the point hit something.
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CDispRoot::HitTest(
        CPoint* pptHit,
        COORDINATE_SYSTEM *pCoordinateSystem,
        void* pClientData,
        BOOL fHitContent,
        long cFuzzyHitTest)
{
    // test the window-top nodes first (top to bottom)
    if (_aryDispNodeWindowTop.Size() > 0)
    {
        // create hit context
        CDispHitContext hitContext;
        hitContext._pClientData = pClientData;
        hitContext._cFuzzyHitTest = cFuzzyHitTest;
        hitContext.GetClipTransform().SetToIdentity();
    
#if DBG==1
        hitContext.GetClipTransform().NoClip()._csDebug = COORDSYS_GLOBAL;
        hitContext.GetClipTransform().NoClip()._pNode = this;
#endif
        
        // hit point in global coordinates
        CPoint ptgHitTest;
        TransformPoint(
            *pptHit,
            *pCoordinateSystem,
            &ptgHitTest,
            COORDSYS_GLOBAL);
        hitContext.SetHitTestPoint(ptgHitTest);

        int i = _aryDispNodeWindowTop.Size();
        CDispNode **ppDispNode = &_aryDispNodeWindowTop[i-1];

        for ( ; i > 0; --i, --ppDispNode)
        {
            Assert((*ppDispNode)->GetDispRoot() == this);
            if ((*ppDispNode)->HitTestAtWindowTop(&hitContext, fHitContent))
            {
                hitContext.GetHitTestPoint(pptHit);
                return TRUE;
            }
        }
    }
    
    // if we are doing a virtual hit test on the root, we actually must do
    // the test on its first child, because virtualness applies only to the
    // immediate children of the node that is tested.  If we test the root,
    // it will report no hit outside its bounds, because the body's display node
    // is the same size as the root.
    if (fHitContent)
    {
        CDispNode* pChild = GetFirstChildNode();
        if (pChild != NULL)
        {
            *pptHit -= _rcpContainer.TopLeft().AsSize();
            return pChild->HitTest(
                pptHit, pCoordinateSystem, pClientData, fHitContent, cFuzzyHitTest);
        }
    }
    
    return super::HitTest(
        pptHit, pCoordinateSystem, pClientData, fHitContent, cFuzzyHitTest);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::ScrollRect
//
//  Synopsis:   Smoothly scroll the content in the given rect by the indicated
//              delta, and draw the newly-exposed content.
//
//  Arguments:  rcgScroll               rect to scroll
//              sizegScrollDelta        direction to scroll
//              pScroller               the scroller node that
//                                      is requesting the scroll
//              fMayScrollDC            TRUE if it would be okay to use ScrollDC
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CDispRoot::ScrollRect(
        const CRect& rcgScroll,
        const CSize& sizegScrollDelta,
        CDispScroller* pScroller,
        BOOL fMayScrollDC)
{
    // shouldn't be here with recalc flags set
    WHEN_DBG(VerifyFlags( s_flagsNotSetInDraw, 0, TRUE));
    
    Assert(!sizegScrollDelta.IsZero());
    AssertSz(!_fDrawLock, "CDispRoot::ScrollRect called inside Draw.");
    if (_fDrawLock || _pDispObserver == NULL)
        return;

    // can we use ScrollDC to simply scroll the bits?
    if (fMayScrollDC)
    {
        _pDispObserver->ScrollRect(
            rcgScroll,
            sizegScrollDelta,
            pScroller);
    }
    else
    {
        InvalidateRoot(rcgScroll, TRUE, TRUE);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::PreDraw
//
//  Synopsis:   Before drawing starts, PreDraw processes the redraw region,
//              subtracting areas that are blocked by opaque or buffered items.
//              PreDraw is finished when the redraw region becomes empty
//              (i.e., an opaque item completely obscures all content below it)
//
//  Arguments:  pContext    draw context
//
//  Returns:    TRUE if first opaque node to draw has been found
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
CDispRoot::PreDraw(CDispDrawContext* pContext)
{
    // Interesting nodes are visible, in-view, opaque
    Assert(IsAllSet(s_preDrawSelector));
    Assert(!IsAnySet(s_flagsNotSetInDraw));

    // we don't expect filter or transform on the root node
    Assert(!IsDrawnExternally() && !HasUserTransform());
    
    if (!super::PreDraw(pContext))
    {
        // root is always opaque
        pContext->SetFirstDrawNode(this);
        Verify(!pContext->PushRedrawRegion(*(pContext->GetRedrawRegion()),this));
    }
    
    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::EraseBackground
//              
//  Synopsis:   Quickly draw border and background.
//              
//  Arguments:  pContext        draw context
//              pClientData     client data used by clients in DrawClient
//              hrgngDraw       region to draw in destination coordinates
//              prcgDraw        rect to draw in destination coordinates
//              fEraseChildWindow   if TRUE, we are erasing the background of
//                                  a child window (the IE Label control)
//
//  Notes:      if hrgngDraw and prcgDraw are both NULL, the bounding rect of
//              this root node is used
//              
//----------------------------------------------------------------------------

void
CDispRoot::EraseBackground(
        CDispSurface* pRenderSurface,
        CDispDrawContext* pContext,
        void* pClientData,
        HRGN hrgngDraw,
        const RECT* prcgDraw,
        BOOL fEraseChildWindow)
{
    // NOTE (donmarsh) - EraseBackground can be called while we are recalcing
    // the display tree!  For example, CSelectLayout::HandleViewChange changes
    // the clip region of child windows, which causes an immediate
    // call to EraseBackground.  This is messy, because we could stomp on
    // values in pContext that are in use by the recalc code.  Therefore, we
    // ignore these calls.  If the following Assert fires, you should look
    // at the stack and protect the operation that called it with
    // CServer::CLock lock(Doc(), SERVERLOCK_IGNOREERASEBKGND);
    CheckSz(!_fDrawLock, "EraseBackground called during drawing");
    CheckSz(!_fRecalcLock, "EraseBackground called during recalc");
    if (_fDrawLock || _fRecalcLock)
        return;
    
    Assert(pRenderSurface != NULL);

    CSaveDispClipTransform saveTransform(pContext);
    pContext->SetRootNode(this);
    pContext->SetDispSurface(pRenderSurface);

    // set redraw region (will become a rect if possible)
    CRegion rgngRedraw;
    // TODO (donmarsh) -- this isn't exactly what we want with transforms
    // enabled, but it will work for now, because there is never a transform
    // on the root node.
    if (hrgngDraw != NULL)
    {
        rgngRedraw = hrgngDraw;
    }
    else if (prcgDraw != NULL)
    {
        rgngRedraw = *prcgDraw;
    }
    else
    {
        rgngRedraw = _rcpContainer;
    }
    
    // check for early exit conditions
    if (!rgngRedraw.Intersects(_rcpContainer))
        return;
    
    // set initial context values
    pContext->SetClientData(pClientData);
    pContext->SetFirstDrawNode(NULL);
    pContext->SetRedrawRegion(&rgngRedraw);
    pContext->SetDispSurface(pRenderSurface);

    // NOTE (donmarsh) - To address bug 62008 (erase background for HTML Help
    // control), we need to disable clipping in CDispSurface::GetDC.  Ideally,
    // CDispSurface should allow us to have a NULL _prgngClip, but that is
    // currently not the case.
    CRegion rgngClip(-15000,-15000,15000,15000);
    pRenderSurface->SetClipRgn(&rgngClip);
    
    // draw border and scrollbars
    Assert(!HasUserClip());
    TransformedToBoxCoords(&pContext->GetClipTransform());
    CRect rcbContainer(_rcpContainer.Size());
    CDispInfo di;
    CalcDispInfo(rcbContainer, &di);
    DrawBorder(pContext, *di._prcbBorderWidths, GetDispClient());
    
    // determine area that the root's children opaquely.  We do this in order
    // to avoid drawing the root background if it is completely covered by its
    // opaque children, thus reducing flash.
    // NOTE: Ideally, we should examine all children of the root node.  However,
    // Trident currently creates at most one opaque child, and it is always
    // the first child.  To simplify the code and accelerate performance, we
    // take advantage of this special case.
    BOOL fHasOpaqueChild = FALSE;
    CDispNode* pFirstChild = GetFirstChildNode();
    if (pFirstChild != NULL &&
        pFirstChild->IsOpaque() &&
        pFirstChild->IsVisible() &&
        pFirstChild->HasBackground() &&
        pFirstChild->IsContainer() &&
        !pFirstChild->HasUserTransform())
    {
        CSize sizecInsideBorder;
        GetSizeInsideBorder(&sizecInsideBorder);
        fHasOpaqueChild = pFirstChild->_rctBounds.Contains(CRect(sizecInsideBorder));
    }
    
    TransformBoxToContent(&pContext->GetClipTransform(), di);
    
    // draw background of first child
    if (fHasOpaqueChild)
    {
        if (pFirstChild->IsFlowNode())
            TransformContentToFlow(&pContext->GetClipTransform(), di);
        
        if (pFirstChild->TransformedToBoxCoords(
                &pContext->GetClipTransform(), pContext->GetRedrawRegion()))
        {
            // we checked that pFirstChild is a container above
            Assert(pFirstChild->IsContainer());
            CDispContainer::Cast(pFirstChild)->CalcDispInfo(pContext->GetClipRect(), &di);
            
            // this is evil: the nasty IE Label control passes us its DC for
            // us to draw our background into.  This was a hack to try
            // to simulate transparency, but it doesn't even work very well.
            // In this case, we have to avoid setting any clip region on this
            // foreign DC.
            if (fEraseChildWindow)
                pContext->GetDispSurface()->SetNeverClip(TRUE);

            pFirstChild->DrawBorder(pContext, *di._prcbBorderWidths, pFirstChild->GetDispClient());
            if (pFirstChild->HasBackground())
                pFirstChild->DrawBackground(pContext, di);

            pContext->GetDispSurface()->SetNeverClip(FALSE);
        }
    }
    
    // draw background for root
    else
    {
        CRect rccBackground(di._sizecBackground);
        GetDispClient()->DrawClientBackground(
            &rccBackground,
            &di._rccBackgroundClip,
            pContext->PrepareDispSurface(),
            this,
            pContext->GetClientData(),
            0);
    }
    
    pRenderSurface->SetClipRgn(NULL);
    ::SelectClipRgn(pRenderSurface->GetRawDC(), NULL);
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::InvalidateRoot
//              
//  Synopsis:   Add the given rect to the accumulated invalid area.
//              
//  Arguments:  rcgInval    invalid rect
//              
//  Notes:      Slot 0 in the invalid rect array is special.  It is used to
//              hold the new invalid rect while figuring out which rects to
//              merge.
//              
//----------------------------------------------------------------------------

void
CDispRoot::InvalidateRoot(const CRect& rcgInval, BOOL fSynchronousRedraw, BOOL fInvalChildWindows)
{
    // Unfortunately, we can't assert this, because certain OLE controls
    // invalidate when they are asked to draw.  This isn't really harmful,
    // just not optimal.
    //AssertSz(!_fDrawLock, "Illegal call to CDispRoot inside Draw()");

    if (_pDispObserver != NULL)
    {
        _pDispObserver->Invalidate(&rcgInval, NULL, fSynchronousRedraw, fInvalChildWindows);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::InvalidateRoot
//              
//  Synopsis:   Add the given invalid region to the accumulated invalid area.
//              
//  Arguments:  rgng        region to invalidate
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispRoot::InvalidateRoot(const CRegion& rgng, BOOL fSynchronousRedraw, BOOL fInvalChildWindows)
{
    // Unfortunately, we can't assert this, because certain OLE controls
    // invalidate when they are asked to draw.  This isn't really harmful,
    // just not optimal.
    //AssertSz(!_fDrawLock, "Illegal call to CDispRoot inside Draw()");
    
    if (rgng.IsComplex())
    {
        if (_pDispObserver != NULL)
            _pDispObserver->Invalidate(NULL, rgng.GetRegionForLook(), fSynchronousRedraw, fInvalChildWindows);
    }
    else
    {
        CRect rc;
        rgng.GetBounds(&rc);
        InvalidateRoot(rc, fSynchronousRedraw, fInvalChildWindows);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::SwapDrawingUnfiltered
//              
//  Synopsis:   When a node is doing DrawNodeForFilter, it records itself
//              at the root, so that GetClippedBounds can do the right
//              thing.
//              
//  Arguments:  pDispNode   node to add
//
//  Returns:    node that was previously drawing unfiltered
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

CDispNode *
CDispRoot::SwapDrawingUnfiltered(CDispNode *pDispNode)
{
    CDispNode *pdn = _pDispNodeDrawingUnfiltered;
    _pDispNodeDrawingUnfiltered = pDispNode;
    return pdn;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::AddWindowTop
//              
//  Synopsis:   Add the given node to the window-top list
//              
//  Arguments:  pDispNode   node to add
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispRoot::AddWindowTop(CDispNode *pDispNode)
{
    if (_aryDispNodeWindowTop.Find(pDispNode) == -1)
    {
        _aryDispNodeWindowTop.Append(pDispNode);
        pDispNode->SetWindowTop();

        // remember the node's ancestors that are scrollers
        CDispNode *pdnAncestor;
        for (pdnAncestor = pDispNode->GetRawParentNode();
             pdnAncestor;
             pdnAncestor = pdnAncestor->GetRawParentNode())
        {
            // the top-level (BODY) scroller doesn't count
            if (pdnAncestor->IsScroller() && pdnAncestor->GetRawParentNode() != this)
            {
                WTopScrollerEntry *pEntry;
                if (S_OK == _aryWTopScroller.AppendIndirect(NULL, &pEntry))
                {
                    pEntry->pdnWindowTop = pDispNode;
                    pEntry->pdnScroller = CDispScroller::Cast(pdnAncestor);
                }
            }
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::RemoveWindowTop
//              
//  Synopsis:   Remove the given node from the window-top list
//              
//  Arguments:  pDispNode   node to remove
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispRoot::RemoveWindowTop(CDispNode *pDispNode)
{
    _aryDispNodeWindowTop.DeleteByValue(pDispNode);
    pDispNode->ClearWindowTop();

    // remove the node from the scroller associative array
    for (int i=_aryWTopScroller.Size()-1;  i>=0;  --i)
    {
        if (_aryWTopScroller[i].pdnWindowTop == pDispNode)
        {
            _aryWTopScroller.Delete(i);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::IsOnWindowTopList
//              
//  Synopsis:   Return TRUE if the given node is on the window-top list
//              
//  Arguments:  pDispNode   node to query
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CDispRoot::IsOnWindowTopList(CDispNode *pDispNode)
{
    return (-1 != _aryDispNodeWindowTop.Find(pDispNode));
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::ScrubWindowTopList
//              
//  Synopsis:   Remove all entries that are descendants of the given node
//              
//  Arguments:  pDispNode   node to query
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispRoot::ScrubWindowTopList(CDispNode *pDispNode)
{
    // if the node isn't in my tree, there's nothing to do
    if (_aryDispNodeWindowTop.Size() == 0 || pDispNode->GetDispRoot() != this)
        return;

    int i = _aryDispNodeWindowTop.Size() - 1;
    CDispNode **ppDispNode = &_aryDispNodeWindowTop[i];

    // loop backwards, so that deletions don't affect the loop's future
    for ( ; i>=0; --i, --ppDispNode)
    {
        CDispNode *pdn;
        for (pdn = *ppDispNode; pdn; pdn = pdn->GetRawParentNode())
        {
            if (pdn == pDispNode)
            {
                RemoveWindowTop(*ppDispNode);
                break;
            }
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::ClearWindowTopList
//              
//  Synopsis:   Remove all entries
//              
//  Arguments:  none
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispRoot::ClearWindowTopList()
{
    int i = _aryDispNodeWindowTop.Size() - 1;
    CDispNode **ppDispNode = &_aryDispNodeWindowTop[i];

    for ( ; i>=0; --i, --ppDispNode)
    {
        (*ppDispNode)->ClearWindowTop();
    }

    _aryDispNodeWindowTop.DeleteAll();
    _aryWTopScroller.DeleteAll();
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::InvalidateWindowTopForScroll
//              
//  Synopsis:   Whenever a CDispScroller scrolls, any window-top nodes
//              that it governs will move.  If these nodes stick out
//              beyond the scroller's client area, we need to invalidate
//              them (since the parts that stick out don't get moved by
//              the normal scrolling process).
//              
//  Arguments:  pDispScroller   - the scroller that's scrolling
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispRoot::InvalidateWindowTopForScroll(CDispScroller *pDispScroller)
{
    // TODO (sambent) we should really check only for window-top nodes that
    // extrude from the client area.  But for now, let's invalidate all
    // window-top nodes governed by the scroller.  Overkill, but much simpler.

    // Note: the top-level (BODY) scroller doesn't participate in this
    // little dance (see AddWindowTop), because nothing sticks out from it.

    for (int i=_aryWTopScroller.Size()-1;  i>=0;  --i)
    {
        if (_aryWTopScroller[i].pdnScroller == pDispScroller)
        {
            _aryWTopScroller[i].pdnWindowTop->InvalidateAtWindowTop();
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::DoesWindowTopOverlap
//              
//  Synopsis:   A scroller wants to scroll by BLTing bits.  This won't work
//              if there's a window-top node that draws on top of the
//              scrolling area - the BLT will incorrectly move bits painted
//              by the window-top node.  This function determines whether
//              this situation exists.
//              
//  Arguments:  pDispScroller   - the scroller that's scrolling
//              rctScroll       - the area it wants to scroll (transformed coords)
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CDispRoot::DoesWindowTopOverlap(CDispScroller *pDispScroller, const CRect& rctScroll)
{
    int i, j;
    CRect rcgScroll;

    pDispScroller->TransformRect(rctScroll, COORDSYS_TRANSFORMED,
                                &rcgScroll, COORDSYS_GLOBAL);

    // look for a window-top node that (a) isn't a descendant of the scroller, 
    // and (b) intersects the scrolling area
    for (i=0; i<_aryDispNodeWindowTop.Size(); ++i)
    {
        CDispNode *pdnWT = _aryDispNodeWindowTop[i];
        BOOL fIsScrolling = FALSE;

        for (j=0; j<_aryWTopScroller.Size(); ++j)
        {
            if (_aryWTopScroller[j].pdnScroller == pDispScroller &&
                _aryWTopScroller[j].pdnWindowTop == pdnWT)
            {
                fIsScrolling = TRUE;
                break;
            }
        }

        if (!fIsScrolling)
        {
            CRect rcgBounds;

            pdnWT->TransformRect(pdnWT->_rctBounds, COORDSYS_TRANSFORMED,
                                        &rcgBounds, COORDSYS_GLOBAL);
            if (rcgScroll.Intersects(rcgBounds))
                return TRUE;
        }
    }

    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::AddObscureElement
//              
//  Synopsis:   Add a new entry to the obscure list.  During Recalc, this list
//              holds information about each element that should be obscured
//              by content higher in the z-order.  At the end of recalc, we
//              use the accumulated information to set the visible region of
//              the obscured elements.
//              
//  Arguments:  pDispNode       the disp node of the obscured element
//              rcgClient       the element's client rect (global coords)
//              rcgClip         the element's initial clip rect (global coords)
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispRoot::AddObscureElement(CDispNode *pDispNode,
                                const CRect& rcgClient,
                                const CRect& rcgClip)
{
    if (IsInRecalc())
    {
        // during recalc, add an entry to the list
        ObscureEntry *pEntry;

        if (_aryObscure.AppendIndirect(NULL, &pEntry) == S_OK)
        {
            pEntry->pDispNode = pDispNode;
            pEntry->rcgClient = rcgClient;
            pEntry->rcgClip = rcgClip;
            pEntry->rgngVisible = rcgClip;

            TraceTag((tagObscure, 
                    "add obscured node %x  clnt: (%ld,%ld,%ld,%ld)  clip: (%ld,%ld,%ld,%ld)",
                    pDispNode,
                    rcgClient.left, rcgClient.top, rcgClient.right, rcgClient.bottom,
                    rcgClip.left,   rcgClip.top,   rcgClip.right,   rcgClip.bottom));
        }
    }
    else
    {
        // outside of recalc (i.e. while scrolling), just mark the root as
        // having an obscurable element.  See ScrollRect for the rest of the story.
        ++ _cObscurableElements;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::ObscureElements
//              
//  Synopsis:   Subtract the given rect from the visible region of each
//              entry on the obscure list.  Don't change descendants of
//              the given disp node - clipping against ancestors is handled
//              the normal way.
//              
//  Arguments:  rcgOpaque       rect to subtract (global coordinates)
//              pDispNode       dispnode doing the clipping
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispRoot::ObscureElements(const CRect& rcgOpaque, const CDispNode *pDispNode)
{
    if (IsInRecalc())
    {
        // during recalc, clip the elements on the list by the rect
        CRegion2 rgngOpaque = rcgOpaque;
        int i;

        for (i=_aryObscure.Size()-1;  i>=0;  --i)
        {
            if (!pDispNode->IsAncestorOf(_aryObscure[i].pDispNode))
            {
                _aryObscure[i].rgngVisible.Subtract(rgngOpaque);
            }
        }

        ++ _cObscuringElements;

        TraceTag((tagObscure, "%ld obscure by (%ld,%ld,%ld,%ld)",
                    _cObscuringElements,
                    rcgOpaque.left, rcgOpaque.top, rcgOpaque.right, rcgOpaque.bottom));
    }
    else
    {
        // outside of recalc (i.e. while scrolling), just mark the root as
        // having an obscuring element.  See ScrollRect for the rest of the story.
        ++ _cObscuringElements;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::ProcessObscureList
//              
//  Synopsis:   At the end of Recalc, tell each obscured element what
//              visible region remains after all the obscuring.
//              
//  Arguments:  none
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispRoot::ProcessObscureList()
{
    int i;
    ObscureEntry *pEntry;

    if (_fDisableObscureProcessing)
       _cObscuringElements = 0;

    for (   i = _aryObscure.Size()-1,  pEntry = &_aryObscure[0];
            i >= 0;
            --i,  ++pEntry)
    {
        // if obscuring didn't change anything, no need to work
        if (_cObscuringElements > 0 && pEntry->rgngVisible != pEntry->rcgClip)
        {
            // tell the obscured element what's still visible
            pEntry->pDispNode->GetDispClient()->Obscure(
                                                    &pEntry->rcgClient,
                                                    &pEntry->rcgClip,
                                                    &pEntry->rgngVisible);

            TraceTag((tagObscure, "obscuring %x  clnt:(%ld,%ld,%ld,%ld)",
                        pEntry->pDispNode,
                        pEntry->rcgClient.left, pEntry->rcgClient.top, pEntry->rcgClient.right, pEntry->rcgClient.bottom));
        }

        // CDataAry doesn't call destructors, so explicitly tell region to
        // release its memory
        pEntry->rgngVisible.SetEmpty();
    }

    TraceTag((tagObscure, "obscuring done - %d entries",
                _aryObscure.Size()));

    _aryObscure.SetSize(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\display\grafrot.cxx ===
/****************************************************************************\
|   File:  GrafRot . CXX                                                     |
|                                                                            |
|                                                                            |
|   Handle drawing of rotated metafiles                                      |
|                                                                            |
|    Copyright 1990-1995 Microsoft Corporation.  All rights reserved.        |
|    Microsoft Confidential                                                  |
|                                                                            |
\****************************************************************************/

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifdef NOTYET // FUTURE (alexmog 6/20/2000): Unused Quill rotation code.
              // remove if a different solution is used for metafile rotation

#ifndef X_XGDI2_HXX_
#define X_XGDI2_HXX_
#include "xgdi2.hxx"
#endif

#ifndef X_PUBROT_HXX_
#define X_PUBROT_HXX_
#include "pubrot.hxx"
#endif

#ifndef X_PUBPRINT_HXX_
#define X_PUBPRINT_HXX_
#include "pubprint.hxx"
#endif

#ifndef X_DBGMETAF_HXX_
#define X_DBGMETAF_HXX_
#include "grafrot.hxx"
#endif

#ifndef X_DIBROT_HXX_
#define X_DIBROT_HXX_
#include "dibrot.hxx"
#endif

BOOL FMetaExtTextOutFlip(MRS *pmrs, WORD * pParam, DWORD cwParam);

// shoud we scale the X coords in the metafile. scale Y if fFalse
// should most probably replace with WMultDiv(pmrs->mde.drcWin.dy,pmrs->mde.drcView.dx, pmrs->mde.drcView.dy) < pmrs->mde.drcWin.dx
// to handle a very wide mf played into a tall frame or vice-versa.
#define FScaleX(pmrs) (pmrs->mde.drcView.dy > pmrs->mde.drcView.dx)

// macro to scale down all coords to avoid overflow.
#define ZScaled(pmrs, z) ((z) >> pmrs->wScale)

/****************************************************************************
* %%Function: RotRotatePt        %%Owner:harip           Reviewed:00/00/00
* Rotates the pt lppt. using matCurrent returns result in same
*****************************************************************************/
void RotRotatePt(MRS *pmrs, CPoint *ppt)
{
    if (pmrs->ang)
        ApplyMatToPt(&pmrs->mat, ppt);
} /* RotRotatePt */

// ***************************************************************************
// %%Function: ScaleDownRc              %%Owner: harip    %%Reviewed: 12/15/94
// Description: scales down the rc
//
// ***************************************************************************
void ScaleDownRc(MRS *prms, RECT *prc)
{
    prc->left = ZScaled(prms, prc->left);
    prc->top  = ZScaled(prms, prc->top);
    prc->right = ZScaled(prms, prc->right);
    prc->bottom = ZScaled(prms, prc->bottom);
}   /* ScaleDownRc */

/* %%Function:LGetHypWW %%Owner:kennyy %%Reviewed:0/0/00 */
/* Gets the hypotenuse of a triangle where the legs are integers. */
long LGetHypWW(int dx, int dy)
{
    long lhypSq = (long)dx * dx + (long)dy * dy;
    long lhypGuess;

    if (lhypSq == 0L)
        return 0;
    lhypGuess = max(abs(dx), abs(dy));
    lhypGuess = (lhypGuess + lhypSq / lhypGuess) >> 1;
    lhypGuess = (lhypGuess + lhypSq / lhypGuess) >> 1;
    lhypGuess = (lhypGuess + lhypSq / lhypGuess) >> 1;

    return lhypGuess;
} /* LGetHypWW */

// ***************************************************************************
// %%Function: FRcSafeForRotation       %%Owner: harip    %%Reviewed: 12/15/94
// Description: returns fTrue if the rc given (generally the  window ext rc of
//              a metafile) will not overflow gdi on rotation.
//  dzDiagHalf is half the diagonal of the rc.
//  The test is that the encircling circle should be inside GDI coords.
// ***************************************************************************
BOOL FRcSafeForRotation(RECT *prc)
{
    int dzDiagHalf; // half the diagonal of the rc
    int dxRc = prc->right - prc->left,
        dyRc = prc->bottom - prc->top;
    int xCenter = prc->left + dxRc / 2;  // center of the rc
    int yCenter = prc->top + dyRc / 2;

    dzDiagHalf =  LGetHypWW(dxRc, dyRc) / 2 + 1;
    if (((xCenter - dzDiagHalf) >= zGDIMin + 1) &&
        ((xCenter + dzDiagHalf) <= zGDIMost - 1) &&
        ((yCenter + dzDiagHalf) <= zGDIMost - 1) &&
        ((yCenter - dzDiagHalf) >= zGDIMin - 1))
        return fTrue;

    return fFalse;

}   /* FRcSafeForRotation */

/****************************************************************************\
|   %%Function:RcToDrc      %%Owner:AdamE       %%Reviewed:05/17/91          |
|                                                                            |
|   Convert an Rc to a Drc                                                   |
|                                                                            |
|   Returns: a Drc in *pdrc.                                                 |
|                                                                            |
\****************************************************************************/
void RcToDrc(RECT rc, DRC *pdrc)
{
    pdrc->x  = rc.left;
    pdrc->dx = rc.right - rc.left;
    pdrc->y  = rc.top;
    pdrc->dy = rc.bottom - rc.top;
}  /* RcToDrc */

/****************************************************************************\
|   %%Function:DrcToRc      %%Owner:AdamE       %%Reviewed:05/17/91          |
|                                                                            |
|   Convert a Drc to an Rc                                                   |
|                                                                            |
|   Returns: an Rc in *prc.                                                  |
|                                                                            |
\****************************************************************************/
void DrcToRc(DRC drc, RECT *prc)
{
    prc->left  = drc.x;
    prc->right = drc.x + drc.dx;
    prc->top   = drc.y;
    prc->bottom = drc.y + drc.dy;
}  /* DrcToRc */

// Make sure that RCs have a width and a height
void ValidateRcForRotate(RECT *prc)
{
	if (prc->right - prc->left == 0)
		prc->right = prc->left + 1;
	if (prc->bottom - prc->top == 0)
		prc->bottom = prc->top + 1;
}

// Make sure that DRCs have a width and a height
void ValidateDrcForRotate(DRC *pdrc)
{
	if (pdrc->dx == 0)
		pdrc->dx = 1;
	if (pdrc->dy == 0)
		pdrc->dy = 1;
}

// ***************************************************************************
// %%Function: InitMFRotationInfo       %%Owner: harip    %%Reviewed: 12/15/94
// Description: initializes fields in pmrs after calling this the client
//          wanting to draw the rotated mf can call their own enumertion fn with
//          the call to FPlayRotatedMFR() before the switch stmt.
// ***************************************************************************
BOOL FInitMFRotationInfo(MRS *pmrs, int ang, BOOL fCropped,
	RECT *prcWin, RECT *prcView, RECT *prcMFViewport, long qflip, BOOL fInverted, BOOL fPrint)
{
    RECT rcSav;
    DRC drcView; // Local copy to modify

    if (ang == 0)
        return fFalse;

	AssertEx(pmrs);
	AssertEx(prcWin);
    AssertEx(prcView);
    AssertEx(prcMFViewport);

	ZeroMemory(pmrs, cbMRS);

	pmrs->ang = ang;
	pmrs->qflip = qflip;
	pmrs->fPrint = fPrint;
	pmrs->fInverted = fInverted;

	MatFromRcAng(&pmrs->mat, prcView, ang);

	RcToDrc(*prcMFViewport, &drcView);

	// Extents cannot equal zero.
	ValidateDrcForRotate(&drcView);
	BltLpb(&drcView, &pmrs->mde.drcView, cbDRC);

    if ((pmrs->hplMDE = HplNew(cbMDE, 4)) == hplNil)
		return fFalse;

    // croppage??
    // this is because rotation is wrt the current frame (cropped or otherwise)
    // pmrs->wScale is used to scale down (amt of right shift) all metafile coord
    // values to prevent integer overflow if the rcmfViewport is too big.
    pmrs->fCropped = fCropped;
    if (pmrs->fCropped)
        {
        AssertEx(prcMFViewport);
        rcSav = *prcMFViewport;

        while(!FRcSafeForRotation(prcMFViewport))
            {
            *prcMFViewport = rcSav;
            pmrs->wScale++;
            ScaleDownRc(pmrs, prcMFViewport);
            }
        // restore, since we may scale down again after next block
        *prcMFViewport = rcSav;
        }
    BLOCK // values for this will be set again in FPlayRotatedMFR()
        {
        // now see if lprcWin itself might overflow with current pmrs->wScale
        RECT rcWin = *prcWin;

        ScaleDownRc(pmrs, &rcWin);    // scale it down by existing scaling factor
        rcSav = rcWin;
        while(!FRcSafeForRotation(&rcWin))
            {
            rcWin = rcSav;
            pmrs->wScale++;
            ScaleDownRc(pmrs, &rcWin);
            }
        RcToDrc(rcWin, &pmrs->mde.drcWin);
        ValidateDrcForRotate(&pmrs->mde.drcWin);
        }
    if (pmrs->fCropped)
        {
        // When cropped the rcmfViewport is the visible part
        // of the image which is drawn into rcmfPreferred.
		pmrs->rcmfViewport = *prcView;
		// The window is scaled from the preferred to the
		// viewport.
        pmrs->rcmfPreferred = *prcMFViewport;
        ValidateRcForRotate(&pmrs->rcmfPreferred);
        }
    // init scaling values
    pmrs->mde.xScaleNum     = 1;
    pmrs->mde.xScaleDen     = 1;
    pmrs->mde.yScaleNum     = 1;
    pmrs->mde.yScaleDen     = 1;
    pmrs->mde.xWinScaleNum  = 1;
    pmrs->mde.xWinScaleDen  = 1;
    pmrs->mde.yWinScaleNum  = 1;
    pmrs->mde.yWinScaleDen  = 1;
    pmrs->mde.xVPScaleNum   = 1;
    pmrs->mde.xVPScaleDen   = 1;
    pmrs->mde.yVPScaleNum   = 1;
    pmrs->mde.yVPScaleDen   = 1;
    return fTrue;
}   /* FInitMFRotationInfo */

// ***************************************************************************
// %%Function: FEndRotation              %%Owner: harip    %%Reviewed: 12/15/94
// Description: Resets pmrs and frees up memory allocated during rotation
//              returns fFalse is there was an error during display.
//              Shows error msg if fReportError
// ***************************************************************************
BOOL FEndRotation(MRS *pmrs)
{
    BOOL fReturn = fTrue;

	FreeHpl(pmrs->hplMDE);

	ZeroMemory(pmrs, cbMRS);

    return fReturn;
}   /* FEndRotation */

// ***************************************************************************
// %%Function: ZScaleZ                  %%Owner: harip    %%Reviewed: 12/15/94
// Description: scales the x or y coordinate depending on the FScaleX(). this is
//              so that we do not always scale blindly, but  we always scale DOWN
//              and hence avoid overflow problems.
// ***************************************************************************
int ZScaleZ(MRS *pmrs, int z)
{
    int zT;
    if (FScaleX(pmrs))
        {
        zT = MulDivR(z, pmrs->mde.drcWin.dy, pmrs->mde.drcWin.dx);
        return MulDivR(zT, pmrs->mde.drcView.dx, pmrs->mde.drcView.dy);
        }
    else
        {
        zT = MulDivR(z, pmrs->mde.drcWin.dx, pmrs->mde.drcWin.dy);
        return MulDivR(zT, pmrs->mde.drcView.dy, pmrs->mde.drcView.dx);
        }
}   /* ZScaleZ */

// ***************************************************************************
// %%Function: ScaleXAndY               %%Owner: harip    %%Reviewed: 12/15/94
// Description: takes  original x and y mf coords and scales the appropriate
//              one so that they can be passed to a Rot<foo> function.
//              the initial pmrs->dzWinOff subtraction is for OffsetWindowOrg.
// ***************************************************************************
void ScaleXAndY(MRS *pmrs, int *px, int *py)
{
    int dzT;
    int sign;

    *px = MulDivR(*px - pmrs->mde.dxWinOff, pmrs->mde.xScaleNum, pmrs->mde.xScaleDen);
    *py = MulDivR(*py - pmrs->mde.dyWinOff, pmrs->mde.yScaleNum, pmrs->mde.yScaleDen);
    
    if (pmrs->qflip & qflipHorz)
    	*px = 2 * XpCenterFromMrs(pmrs) - *px;
    if (pmrs->qflip & qflipVert)
    	*py = 2 * YpCenterFromMrs(pmrs) - *py;

    dzT = FScaleX(pmrs) ? (*px - pmrs->mde.drcWin.x) : (*py - pmrs->mde.drcWin.y);
    sign = Sgn(dzT);
    dzT = ZScaleZ(pmrs, dzT);
    if (FScaleX(pmrs))
        *px = pmrs->mde.drcWin.x + Abs(dzT)*sign;
    else
        *py = pmrs->mde.drcWin.y + Abs(dzT)*sign;
}   /* ScaleXAndY */

/****************************************************************************\
 * %%Macro: WNonZero                %%Owner: EdR       %%Reviewed: 12/21/93 *
 *                                                                          *
 * Description:                                                             *
 *    If w is nonzero, return w. Otherwise, return the smallest non-zero    *
 *    int of the same sign as wReference.                                   *
 *    If w == 0 and wReference == 0, returns (positive) 1.                  *
 *                                                                          *
\****************************************************************************/
#define WNonZero(w, wReference)                         \
            (AssertZero((w) == (w)),                       \
            AssertZero((wReference) == (wReference)),      \
            (w) == 0 ? ((wReference) < 0 ? (-1) : 1) : (w))

// ***************************************************************************
// %%Function: ZScaledNZ                %%Owner: harip    %%Reviewed: 12/15/94
// Description:
//
// ***************************************************************************
int ZScaledNZ(MRS *pmrs, int dxOrig)
{
    int     dx;

    dx = ZScaled(pmrs, dxOrig);
    if (dxOrig != 0)
        dx = WNonZero(dx, dxOrig);
    return dx;
} /* ZScaledNZ */

// ***************************************************************************
// %%Function: CalcScaleValues          %%Owner: harip    %%Reviewed: 12/15/94
// Description:  calculates the numerator and denominator for scaling the x or
//              y coordinated of a metafile. used in meta_poly... routines so
//              ZScaleZ() is not called for each point.
// ***************************************************************************
void CalcScaleValues(MRS *pmrs, long * plScaleNum, long * plScaleDen)
{
    // set up scale values
    if (FScaleX(pmrs))
        {
        *plScaleNum = (long)pmrs->mde.drcWin.dy * (long)pmrs->mde.drcView.dx;
        *plScaleDen = (long)pmrs->mde.drcWin.dx * (long)pmrs->mde.drcView.dy;
        }
    else
        {
        *plScaleNum = (long)pmrs->mde.drcWin.dx * (long)pmrs->mde.drcView.dy;
        *plScaleDen = (long)pmrs->mde.drcWin.dy * (long)pmrs->mde.drcView.dx;
        }

	AssertEx(*plScaleNum);
	AssertEx(*plScaleDen);
}   /* CalcScaleValues */

// ***************************************************************************
// %%Function: RgptScaleRgpt16            %%Owner: harip    %%Reviewed: 12/15/94
// Description: Scales pts in lpptSrc and returns in lpptDest.
//
// ***************************************************************************
void RgptScaleRgpt16(MRS *pmrs, POINT *lpptDest, PT16 * lpptSrc, int cpt)
{
    int  i;
    long lScaleNum, lScaleDen;
    X    xpCenter;
    Y    ypCenter;
    
    // calc scale values
    CalcScaleValues(pmrs, &lScaleNum, &lScaleDen);

    // calc and save centers for flipped orientation
    if (pmrs->qflip & qflipHorz)
	    xpCenter = XpCenterFromMrs(pmrs);
    if (pmrs->qflip & qflipVert)
	    ypCenter = YpCenterFromMrs(pmrs);
    
    for (i = cpt; i-- > 0; )
        {
        int x = lpptSrc->x;
        int y = lpptSrc->y;

        x = MulDivR(ZScaled(pmrs, x) - pmrs->mde.dxWinOff, pmrs->mde.xScaleNum, pmrs->mde.xScaleDen);
        y = MulDivR(ZScaled(pmrs, y) - pmrs->mde.dyWinOff, pmrs->mde.yScaleNum, pmrs->mde.yScaleDen);
                    
		if (pmrs->qflip & qflipHorz)
			x = 2 * xpCenter - x;
		if (pmrs->qflip & qflipVert)
			y = 2 * ypCenter - y;

        int dzT = FScaleX(pmrs) ? (x - pmrs->mde.drcWin.x) : (y - pmrs->mde.drcWin.y);
        int sign = Sgn(dzT);
        dzT = MulDivR(dzT, lScaleNum, lScaleDen);
        lpptDest->x = FScaleX(pmrs) ? (pmrs->mde.drcWin.x + sign * Abs(dzT)) : x;
        lpptDest->y = FScaleX(pmrs) ?  y : (pmrs->mde.drcWin.y + sign * Abs(dzT));
        lpptDest++; lpptSrc++;
        }
}   /* RgptScaleRgpt16 */

/****************************************************************************\
|   %%Macro:FValidGdiCoord        %%Owner:edr         %%Reviewed: 0/00/00
|   Determines if a value is within the range of GDI logical coordinates.
|   Assumes that x and y coords have same limits; thus, use this macro for
|   both x and y.
\****************************************************************************/
#define FValidGDICoord(z) \
                (AssertZero((z) == (z)), (z) >= zGDIMin && (z) <= zGDIMost)

// ***************************************************************************
// %%Function: SetMFRotationContext    %%Owner: harip    %%Reviewed: 12/15/94
// Description: Sets the rotation context for a metafile with the window
//            origin and extents that we have got at the moment for a NON_CROPPED
//             pif. For Cropped pifs we want the center of rotation to be the
//              center of dppif->rcmfViewport
// ***************************************************************************
void SetMFRotationContext(MRS *pmrs)
{
    RECT rcT;

    if (pmrs->fCropped)
        {// need to scale the crop rc in the mf
        int sign;
        rcT.left = pmrs->mde.drcWin.x + 
                      MulDivR(pmrs->rcmfViewport.left - pmrs->rcmfPreferred.left,
                                    pmrs->mde.drcWin.dx,
                                    DxOfRc(&pmrs->rcmfPreferred));
        rcT.top = pmrs->mde.drcWin.y +
                         MulDivR(pmrs->rcmfViewport.top - pmrs->rcmfPreferred.top,
                                    pmrs->mde.drcWin.dy,
                                    DyOfRc(&pmrs->rcmfPreferred));
        rcT.right = rcT.left +
                           MulDivR(DxOfRc(&pmrs->rcmfViewport), pmrs->mde.drcWin.dx,
                                        DxOfRc(&pmrs->rcmfPreferred));
        rcT.bottom = rcT.top +
                            MulDivR(DyOfRc(&pmrs->rcmfViewport), pmrs->mde.drcWin.dy,
                                        DyOfRc(&pmrs->rcmfPreferred));
        if (FScaleX(pmrs))
            {
            sign = Sgn(rcT.left - pmrs->mde.drcWin.x);
            rcT.left = sign*Abs(ZScaleZ(pmrs, rcT.left - pmrs->mde.drcWin.x)) + pmrs->mde.drcWin.x;
            sign = Sgn(rcT.right - pmrs->mde.drcWin.x);
            rcT.right = sign*Abs(ZScaleZ(pmrs, rcT.right - pmrs->mde.drcWin.x)) + pmrs->mde.drcWin.x;
            }
        else
            {
            sign = Sgn(rcT.top - pmrs->mde.drcWin.y);
            rcT.top = sign*Abs(ZScaleZ(pmrs, rcT.top - pmrs->mde.drcWin.y)) + pmrs->mde.drcWin.y;
            sign = Sgn(rcT.bottom - pmrs->mde.drcWin.y);
            rcT.bottom = sign*Abs(ZScaleZ(pmrs, rcT.bottom - pmrs->mde.drcWin.y)) + pmrs->mde.drcWin.y;
            }
        }
    else
        {
        DrcToRc(pmrs->mde.drcWin, &rcT);
        // values better be in gdi coord space
        AssertEx(FValidGDICoord(rcT.left) && FValidGDICoord(rcT.top) &&
                FValidGDICoord(rcT.right) && FValidGDICoord(rcT.bottom) &&
                FValidGDICoord(rcT.right-rcT.left) &&
                FValidGDICoord(rcT.bottom - rcT.top));
        if (FScaleX(pmrs))
            rcT.right = rcT.left + Sgn(pmrs->mde.drcWin.dx) *
                            Abs(MulDivR(pmrs->mde.drcWin.dy,pmrs->mde.drcView.dx, pmrs->mde.drcView.dy));
        else
            rcT.bottom = rcT.top + Sgn(pmrs->mde.drcWin.dy) *
                            Abs(MulDivR(pmrs->mde.drcWin.dx,pmrs->mde.drcView.dy, pmrs->mde.drcView.dx));
        }

	POINT ptCenterHacked;
	ptCenterHacked.x = ((long)rcT.left + (long)rcT.right) / 2;
	ptCenterHacked.y = ((long)rcT.top + (long)rcT.bottom) / 2;

	MatFromPtAng(&pmrs->mat, ptCenterHacked,
				((pmrs->mde.drcWin.dy < 0 && pmrs->mde.drcWin.dx > 0) ?
				(3600 - pmrs->ang) : pmrs->ang));

	pmrs->fRotContextSet = fTrue;
} /* SetMFRotationContext */

// ***************************************************************************
// %%Function: PushMDE                  %%Owner: harip    %%Reviewed: 12/15/94
// ***************************************************************************
BOOL PushMDE(MRS *pmrs)
{
    if (!pmrs->hplMDE)
        return fFalse;

	return FInsertInPl(pmrs->hplMDE, 0, &pmrs->mde);
} /* PushMDE */

// ***************************************************************************
// %%Function: PopMDE                   %%Owner: harip    %%Reviewed: 12/15/94
// Description:  pops the stored rotation extents (on restoredc)
// ***************************************************************************
void PopMDE(MRS *pmrs)
{
    if (!pmrs->hplMDE)
        return;

    // could happen if one of the PushMDE's fails, and we keep Popping away.
    if (IMacPl(pmrs->hplMDE) == 0)
        return;
        
    BltLpb(LqInPl(pmrs->hplMDE, 0), &pmrs->mde, cbMDE);

    DeleteFromPl(pmrs->hplMDE, 0);
} /* PopMDE */

// ***************************************************************************
// %%Function: MultiplyRatios           %%Owner: edr      %%Reviewed: 01/16/96
//
//  Multiply two pairs of ratios of the form Num/Den, resulting in a product
//  ratio.
//  Make sure that the resulting num and denom terms are all < 32K (so GDI can
//  use them).
//  The output parameters can point to either of the sets of inputs.
// ***************************************************************************
void MultiplyRatios(int xNum1, int xDen1, int yNum1, int yDen1,
                int xNum2, int xDen2, int yNum2, int yDen2,
                int *pxNumOut, int *pxDenOut, int *pyNumOut, int *pyDenOut)
{
    long    rgzScale[4];
    int     zScaleMost;
    int     i;

    AssertEx(pxNumOut != NULL && pxDenOut != NULL &&
            pyNumOut != NULL && pyDenOut != NULL);

    rgzScale[0] = xNum1 * xNum2;
    rgzScale[1] = xDen1 * xDen2;
    rgzScale[2] = yNum1 * yNum2;
    rgzScale[3] = yDen1 * yDen2;

    zScaleMost = 0;
    for (i = 0; i < 4; i++)
        if (Abs(rgzScale[i]) > zScaleMost)
            zScaleMost = Abs(rgzScale[i]);
    AssertEx(zScaleMost > 0);
    if (zScaleMost > SHRT_MAX)
        {
        int     wdiv;

        wdiv = (zScaleMost/(SHRT_MAX+1)) + 1;
        for (i = 0; i < 4; i++)
            {
            if (rgzScale[i] != 0)
                {
                int     w;

                w = rgzScale[i] / wdiv;
                if (w == 0)
                    w = (rgzScale[i] < 0) ? -1 : 1;
                rgzScale[i] = w;
                }
            }
        }

    *pxNumOut = rgzScale[0];
    *pxDenOut = rgzScale[1];
    *pyNumOut = rgzScale[2];
    *pyDenOut = rgzScale[3];

    AssertEx(*pxDenOut != 0);
    AssertEx(*pyDenOut != 0);

} // MultiplyRatios

// ***************************************************************************
// %%Function: FMeta_IntersectClipRect   %%Owner: harip    %%Reviewed: 12/15/94
//
// Description:Rotates a Meta_intersectCLipRect call. uses clip path.
// ***************************************************************************
BOOL FMeta_IntersectClipRect(HDC hdc, MRS *pmrs, LPMETARECORD lpMFR)
{
    HRGN  hrgn=NULL;
    RECT rcT;
    RRC rrcT;
    BOOL    fSuccess;
    int xL = ZScaled(pmrs, (short)Param(3)),   // left
        yT = ZScaled(pmrs, (short)Param(2)),   // top
        xR = ZScaled(pmrs, (short)Param(1)),   // right
        yB = ZScaled(pmrs, (short)Param(0));   // bottom

    AssertEx(lpMFR->rdFunction == META_INTERSECTCLIPRECT);

    // since nt has problems with the selectclippath() during metafile playback
    // when printing to PS, we are just going to ignore this record.
    if (!FWindows95() && FPrintingToPostscript(hdc))
        return fTrue;
    ScaleXAndY(pmrs, &xL, &yT);
    ScaleXAndY(pmrs, &xR, &yB);
    SetRc(&rcT, xL, yT, xR, yB);
	RrcFromMatRc(&rrcT, &pmrs->mat, &rcT);
    BeginPath(hdc);
    Polygon(hdc, (POINT *)&rrcT, 4);
    EndPath(hdc);
    fSuccess = SelectClipPath(hdc, RGN_AND);
    return fSuccess;
}   /* FMeta_IntersectClipRect */

// ***************************************************************************
// %%Function: FMeta_CreateFontInd  %%Owner: harip    %%Reviewed: 12/15/94
// Description: creates roated font for text in a mf (which is rotated)
// ***************************************************************************
BOOL FMeta_CreateFontInd(HDC hdc, MRS *pmrs, LPHANDLETABLE lpHTable, LPMETARECORD lpMFR, int nObj)
{
    LOGFONT16 *lplf,            // ptr to logfont data
              lfSav;            // saved original data
    BOOL      fStrokeFont;      // was font stroke font?
    BOOL      fSuccess;         // result of playing metafile record
    int       nHeight;          // new scaled height of font
    ANG       angT;             // ang of font

    AssertEx(lpMFR->rdFunction == META_CREATEFONTINDIRECT);

    lplf = (LOGFONT16 *)&(Param(0));
    lfSav=*lplf;

    // raid 3.7522 - warrenb - calculate new font height
    nHeight = MulDivR(lplf->lfHeight, pmrs->mde.xScaleNum, pmrs->mde.xScaleDen);
    lplf->lfHeight = Abs(ZScaleZ(pmrs, nHeight));

    // is it a stroke font??
    fStrokeFont = (lplf->lfCharSet == OEM_CHARSET);
    // force windows to give a  TT fnt so that it will rotate
    lplf->lfOutPrecision = fStrokeFont ? OUT_STROKE_PRECIS : OUT_TT_ONLY_PRECIS;
    // clipping
    lplf->lfClipPrecision = CLIP_LH_ANGLES | CLIP_TT_ALWAYS | CLIP_STROKE_PRECIS;

    // take into account if window is flipped.
    if ((pmrs->mde.drcWin.dy < 0) && (pmrs->mde.drcWin.dx > 0))
        angT = -pmrs->ang;
    else
        angT = pmrs->ang;

    lplf->lfEscapement = AngNormalize(lplf->lfEscapement + angT);
    lplf->lfOrientation = AngNormalize(lplf->lfOrientation + angT);

    fSuccess = PlayMetaFileRecord(hdc, lpHTable, lpMFR, nObj);

    // restore values which were changed
    *lplf=lfSav;

    return fSuccess;
} /* FMeta_CreateFontInd */

// ***************************************************************************
// %%Function: FMeta_ExtTextOut          %%Owner: harip    %%Reviewed: 12/15/94
// Description: rotated exttextout call. takes care of setting new position.
//              NOTE: no clipping is done.
// ***************************************************************************
BOOL FMeta_ExtTextOut(HDC hdc, MRS *pmrs, LPHANDLETABLE lpHTable, LPMETARECORD lpMFR, int nObj)
{
    POINT  ptT;
    short x,y;
    BOOL fSuccess;

    AssertEx(lpMFR->rdFunction == META_EXTTEXTOUT);

    ptT.y = ZScaled(pmrs, y = SParam(0));
    ptT.x = ZScaled(pmrs, x = SParam(1));
    ScaleXAndY(pmrs, (int*)&(ptT.x), (int*)&(ptT.y));
    Param(0) = (short)ptT.y;
    Param(1) = (short)ptT.x;
    fSuccess = FMetaExtTextOutFlip(hdc, pmrs, (WORD *)&Param(0),
                            lpMFR->rdSize - (sizeof(DWORD)+sizeof(WORD))/sizeof(WORD));

    Param(0) = y;
    Param(1) = x;
    return fSuccess;
} /* FMeta_ExtTextOut */

// ***************************************************************************
// %%Function: FMeta_TextOut             %%Owner: harip    %%Reviewed: 12/15/94
// Description: Rotated TextOut handler.
// ***************************************************************************
BOOL FMeta_TextOut(XHDC xhdc, MRS *pmrs, LPHANDLETABLE lpHTable, LPMETARECORD lpMFR, int nObj)
{
    POINT  ptT;
    short x,y, bT;
    BOOL fSuccess;

    AssertEx(lpMFR->rdFunction == META_TEXTOUT);

    bT = (Param(0) + sizeof(WORD)-1)/sizeof(WORD);  // offset to y coord
    ptT.y = ZScaled(pmrs, y = SParam(1 + bT));
    ptT.x = ZScaled(pmrs, x = SParam(2 + bT));
    ScaleXAndY(pmrs, (int*)&(ptT.x), (int*)&(ptT.y));
    xhdc.TransformPt(&ptT);
    Param(1 + bT) = (short)ptT.y;
    Param(2 + bT) = (short)ptT.x;
    fSuccess = PlayMetaFileRecord(xhdc.Hdc(), lpHTable, lpMFR, nObj);
    Param(1 + bT) = y;
    Param(2 + bT) = x;
    return fSuccess;
} /* FMeta_TextOut */

// ***************************************************************************
// %%Function: FMeta_MoveTo              %%Owner: harip    %%Reviewed: 12/15/94
//
// Description: MoveTo handling under rotation
// ***************************************************************************
BOOL FMeta_MoveTo(HDC hdc, MRS *pmrs, LPMETARECORD lpMFR)
{
    int x = ZScaled(pmrs, SParam(1));
    int y = ZScaled(pmrs, SParam(0));

    AssertEx(lpMFR->rdFunction == META_MOVETO);

    ScaleXAndY(pmrs, &x, &y);
    return RotMoveTo(hdc, pmrs, x, y);
}   /* FMeta_MoveTo */

// ***************************************************************************
// %%Function: FMeta_LineTo              %%Owner: harip    %%Reviewed: 12/15/94
//
// Description: LineTo handling under rotation
// ***************************************************************************
BOOL FMeta_LineTo(HDC hdc, MRS *pmrs, LPMETARECORD lpMFR)
{
    int x = ZScaled(pmrs, SParam(1));
    int y = ZScaled(pmrs, SParam(0));

    AssertEx(lpMFR->rdFunction == META_LINETO);

    ScaleXAndY(pmrs, &x, &y);
    return RotLineTo(hdc, pmrs, x, y);
}   /* FMeta_LineTo */

// ***************************************************************************
// %%Function: FMeta_SetPixel              %%Owner: harip    %%Reviewed: 12/15/94
// ***************************************************************************
BOOL FMeta_SetPixel(HDC hdc, MRS *pmrs, LPMETARECORD lpMFR)
{
    POINT  ptT;

    AssertEx(lpMFR->rdFunction == META_SETPIXEL);

    ptT.x = ZScaled(pmrs, SParam(3));
    ptT.y = ZScaled(pmrs, SParam(2));
    ScaleXAndY(pmrs, (int*)&(ptT.x), (int*)&(ptT.y));
    RotRotatePt(pmrs, &ptT);
    // using SetPixelV() since it is faster because it doesn't return a COLORREF
    SetPixelV(hdc,   ptT.x, ptT.y, MAKELONG(Param(0), Param(1)));
    // RAID 3413 : SetPixel() requires that the pt be inside the clipping
    // region and some pixels seem to fall outside and thus stop the mf
    // enumeration. So we always return fTrue in this case.
    return fTrue;
}   /* FMeta_SetPixel */

// ***************************************************************************
// %%Function: FMeta_Rectangle           %%Owner: harip    %%Reviewed: 12/15/94
// ***************************************************************************
BOOL FMeta_Rectangle(HDC hdc, MRS *pmrs, LPMETARECORD lpMFR)
{
    int xL = ZScaled(pmrs, SParam(3)),  // left
        yT = ZScaled(pmrs, SParam(2)),  // top
        xR = ZScaled(pmrs, SParam(1)),  // right
        yB = ZScaled(pmrs, SParam(0));  // bottom

    AssertEx(lpMFR->rdFunction == META_RECTANGLE);

    ScaleXAndY(pmrs, &xL, &yT);
    ScaleXAndY(pmrs, &xR, &yB);
    return RotRectangle(hdc, pmrs, xL, yT, xR, yB);
}   /* FMeta_Rectangle */

// ***************************************************************************
// %%Function: FMeta_RoundRect           %%Owner: harip    %%Reviewed: 12/15/94
// Description:
//
// ***************************************************************************
BOOL FMeta_RoundRect(HDC hdc, MRS *pmrs, LPMETARECORD lpMFR)
{
    int xL = ZScaled(pmrs, SParam(5)),
        yT = ZScaled(pmrs, SParam(4)),
        xR = ZScaled(pmrs, SParam(3)),
        yB = ZScaled(pmrs, SParam(2)),
        dxEllipse = ZScaledNZ(pmrs, SParam(1)),
        dyEllipse = ZScaledNZ(pmrs, SParam(0));

    AssertEx(lpMFR->rdFunction == META_ROUNDRECT);

    ScaleXAndY(pmrs, &xL, &yT);
    ScaleXAndY(pmrs, &xR, &yB);
    // size of the ellipse is just that, and and so we'll treat it as an offset and scale
    // not calling just ScaleXAndY() since  these 2 are not related to the origin etc.
    // and we dont want to take offsets from pmrs->mde.drcWin.x etc.
    AssertEx(dxEllipse > 0 && dyEllipse > 0);  // else need to multiply Abs() scaled value by sign below
    dxEllipse = MulDivR(dxEllipse, pmrs->mde.xScaleNum, pmrs->mde.xScaleDen);
    dyEllipse = MulDivR(dyEllipse, pmrs->mde.xScaleNum, pmrs->mde.xScaleDen);
    if (FScaleX(pmrs))
        dxEllipse = Abs(ZScaleZ(pmrs, dxEllipse));    // should be > 0
    else
        dyEllipse = Abs(ZScaleZ(pmrs, dyEllipse));

    return RotRoundRect(hdc, pmrs, xL, yT, xR, yB, dxEllipse, dyEllipse);
}   /* FMeta_RoundRect */

// ***************************************************************************
// %%Function: FMeta_PolyFoo             %%Owner: harip    %%Reviewed: 12/15/94
// Description:Plays rotated versions of the META_POLYGON & META_POLYLINE
// ***************************************************************************
BOOL FMeta_PolyFoo(HDC hdc, MRS *pmrs, LPMETARECORD lpMFR)
{
    int cpt;
    POINT *lppt;
    POINT *lpptDest;
    PT16 *lpptSrc;
    BOOL fSuccess;

    AssertEx(lpMFR->rdFunction == META_POLYGON ||
            lpMFR->rdFunction == META_POLYLINE);

    cpt = SParam(0);
    if (cpt < 2)
        return fTrue;  // something screwy around here. see bug 7271 for the fTrue (and 8227)

    lppt = lpptDest = (POINT *) new POINT[cpt];
	if (!lpptDest)
		return fFalse;

    lpptSrc = (PT16 *)&Param(1);
    // scale the pts
	RgptScaleRgpt16(pmrs, lpptDest, lpptSrc, cpt);

	if (lpMFR->rdFunction == META_POLYGON)
		fSuccess = RotPolygon(hdc, pmrs, lppt, cpt);
	else
		fSuccess = RotPolyline(hdc, pmrs, lppt, cpt);

	delete [] lpptDest;

    return fSuccess;
} /* FMeta_PolyFoo */

// ***************************************************************************
// %%Function: FMeta_PolyPolygon         %%Owner: harip    %%Reviewed: 12/15/94
// Description: rotates META_polypolygon record.
//
// ***************************************************************************
BOOL FMeta_PolyPolygon(HDC hdc, MRS *pmrs, LPMETARECORD lpMFR)
{
    short cply;       /* number of polygons */
    short cptTotal;   /* number of points in all polygons */
    int *lpcpt;
    short *pcptT;
    POINT *lpptSav;
    POINT *lpptDest;
    PT16 *lpptSrc;
    int iply;
    BOOL fReturn;

    AssertEx(lpMFR->rdFunction == META_POLYPOLYGON);

    cply = SParam(0);
    if (cply <= 0)
        return fTrue; // see bug 7271 for the fTrue

    for (iply = cply, cptTotal = 0, pcptT = (short*)(&Param(1)); iply-- > 0;)
        cptTotal += *pcptT++;
    if (cptTotal <= 0)
        return fTrue;   // see bug 7271 for the fTrue

    lpptSav = lpptDest = (POINT *)new POINT[cptTotal];
	if (!lpptSav)
		return fFalse;

    // now convert pcpt (array of short ints) to an array of ints
	lpcpt = (int *)new int[cply];
	if (!lpcpt)
		{
    	delete [] lpptDest;
    	return fFalse;
    	}

    for (iply = 0, pcptT = (short*)&Param(1); iply < cply; iply++)
        {
        *lpcpt = *pcptT;
        lpcpt++; pcptT++;
        }
    // reset lpt to point to beginning of block
    lpcpt -= cply;
    lpptSrc = (PT16 *)&Param(1 + cply);
    // scale all the pts
    RgptScaleRgpt16(pmrs, lpptDest, lpptSrc, cptTotal);

    fReturn = RotPolyPolygon(hdc, pmrs, lpptSav, lpcpt, cply);

    delete [] lpptDest;
    delete [] lpcpt;

    return fReturn;
}   /* FMeta_PolyPolygon */

// ***************************************************************************
// %%Function: FMeta_Ellipse             %%Owner: harip    %%Reviewed: 12/15/94
// Description:
//
// ***************************************************************************
BOOL FMeta_Ellipse(HDC hdc, MRS *pmrs, LPMETARECORD lpMFR)
{
    int xL = ZScaled(pmrs, SParam(3)),
        yT = ZScaled(pmrs, SParam(2)),
        xR = ZScaled(pmrs, SParam(1)),
        yB = ZScaled(pmrs, SParam(0));

    AssertEx(lpMFR->rdFunction == META_ELLIPSE);

    ScaleXAndY(pmrs, &xL, &yT);
    ScaleXAndY(pmrs, &xR, &yB);
    return RotEllipse(hdc, pmrs, xL, yT, xR, yB);
}   /* FMeta_Ellipse */

// ***************************************************************************
// %%Function: FMeta_ArcChordPie         %%Owner: harip    %%Reviewed: 12/15/94
// Description: Three in one! Calls appropriate Rot-foo function
//
// ***************************************************************************
BOOL FMeta_ArcChordPie(HDC hdc, MRS *pmrs, LPMETARECORD lpMFR)
{
    int xL = ZScaled(pmrs, SParam(7)),
        yT = ZScaled(pmrs, SParam(6)),
        xR = ZScaled(pmrs, SParam(5)),
        yB = ZScaled(pmrs, SParam(4)),
        xS = ZScaled(pmrs, SParam(3)),   // xStartArc
        yS = ZScaled(pmrs, SParam(2)),   // yStartArc
        xE = ZScaled(pmrs, SParam(1)),   // xEndArc
        yE = ZScaled(pmrs, SParam(0));   // yEndArc

    AssertEx(lpMFR->rdFunction == META_ARC || lpMFR->rdFunction == META_CHORD ||
            lpMFR->rdFunction == META_PIE);

    ScaleXAndY(pmrs, &xL, &yT);
    ScaleXAndY(pmrs, &xR, &yB);
    ScaleXAndY(pmrs, &xS, &yS);
    ScaleXAndY(pmrs, &xE, &yE);

	if (lpMFR->rdFunction == META_ARC)
		return RotArc(hdc, pmrs, xL, yT, xR, yB, xS, yS, xE, yE);
	else if (lpMFR->rdFunction == META_CHORD)
		return RotChord(hdc, pmrs, xL, yT, xR, yB, xS, yS, xE, yE);
	else
		return RotPie(hdc, pmrs, xL, yT, xR, yB, xS, yS, xE, yE);
}   /* FMeta_Arc */

// ***************************************************************************
// %%Function: FMeta_FooFloodFill        %%Owner: harip    %%Reviewed: 12/15/94
// Description: handles FloodFill and ExtFloodFill
//
// ***************************************************************************
BOOL FMeta_FooFloodFill(HDC hdc, MRS *pmrs, LPHANDLETABLE lpHTable, LPMETARECORD lpMFR, int nObj)
{
    POINT  ptT;
    short x,y;
    int bCoord; // offsett to be added depending on the record
    BOOL fSuccess;

    AssertEx(lpMFR->rdFunction == META_FLOODFILL ||
            lpMFR->rdFunction == META_EXTFLOODFILL);

    bCoord = (lpMFR->rdFunction == META_FLOODFILL) ? 0 : 1;
    ptT.y = ZScaled(pmrs, y = SParam(2+bCoord));    // clrref takes 2 ints
    ptT.x = ZScaled(pmrs, x = SParam(3+bCoord));
    ScaleXAndY(pmrs, (int*)&(ptT.x), (int*)&(ptT.y));
    RotRotatePt(pmrs, &ptT);
    Param(2+bCoord) = (short)ptT.y;
    Param(3+bCoord) = (short)ptT.x;
    fSuccess = PlayMetaFileRecord(hdc, lpHTable, lpMFR, nObj);
    Param(2+bCoord) = y;
    Param(3+bCoord) = x;
    return fSuccess;
} /* FMeta_FloodFill */

// ***************************************************************************
// %%Function: FMeta_PatBlt             %%Owner: harip    %%Reviewed: 12/15/94
// Description:
//
// ***************************************************************************
BOOL FMeta_PatBlt(HDC hdc, MRS *pmrs, LPMETARECORD lpMFR)
{
    int xL = ZScaled(pmrs, SParam(5)),
        yT = ZScaled(pmrs, SParam(4)),
        dx = ZScaledNZ(pmrs, SParam(3)),
        dy = ZScaledNZ(pmrs, SParam(2));
    int sign;

    AssertEx(lpMFR->rdFunction == META_PATBLT);

    ScaleXAndY(pmrs, &xL, &yT);
    dx = MulDivR(dx, pmrs->mde.xScaleNum, pmrs->mde.xScaleDen);
    dy = MulDivR(dy, pmrs->mde.xScaleNum, pmrs->mde.xScaleDen);
    if (FScaleX(pmrs))
        {
        sign = Sgn(dx);
        dx = sign * Abs(ZScaleZ(pmrs, dx));
        }
    else
        {
        sign = Sgn(dy);
        dy = sign * Abs(ZScaleZ(pmrs, dy ));
        }
    return RotPatBlt(hdc, pmrs, xL, yT, dx, dy, MAKELONG(Param(0), Param(1)));
}   /* FMeta_Ellipse */

// ***************************************************************************
// %%Function: CopySdibToDibext         %%Owner: harip    %%Reviewed: 00/00/00
//  
// Description:
//  
// ***************************************************************************
void CopySdibToDibext(LPSDIB psdib, PDIBEXT pdibext)
{
    pdibext->dySrc = psdib->dySrc;
    pdibext->dxSrc = psdib->dxSrc;
    pdibext->ySrc =  psdib->ySrc;
    pdibext->xSrc =  psdib->xSrc;
    pdibext->dyDst = psdib->dyDst;
    pdibext->dxDst = psdib->dxDst;
    pdibext->yDst =  psdib->yDst;
    pdibext->xDst =  psdib->xDst;
}	// CopySdibToDibext

// ***************************************************************************
// %%Function: FNeedToScaleDIB          %%Owner: harip    %%Reviewed: 12/15/94
//
// Parameters:
//          ohgxf : oh of frame containing the dib (can be ohNil)
// Description:
//          return fTrue if we need to scale the dib pointed to by lpbmih so
//          that scaling in x and y is the same.
// ***************************************************************************
BOOL FNeedToScaleDIB(MRS *pmrs, LPBITMAPINFOHEADER lpbmih,
                                                    int *pdxNew, int *pdyNew)
{
    BOOL    fNeedToScale=fFalse;

    // if we need to scale we scale down one side of the dib depending on which
    // coordinate we are scaling during this rotation (from FScaleX()).
    *pdyNew = lpbmih->biHeight;
    *pdxNew = lpbmih->biWidth;

    int dzT;
    long    lScaleNum, lScaleDen;

    // calc scale values
    CalcScaleValues(pmrs, &lScaleNum, &lScaleDen);
    // we only want to do the scaling and dont want to worry about the sign.
    lScaleNum = Abs(lScaleNum);
    lScaleDen = Abs(lScaleDen);
    // this handles dibs in metafiles.
    if (FScaleX(pmrs))
        {
        dzT = MulDivR(lpbmih->biWidth, pmrs->mde.xScaleNum,pmrs->mde.xScaleDen);
        dzT = MulDivR(dzT, pmrs->mde.yScaleDen, pmrs->mde.yScaleNum);
        *pdxNew = Abs(MulDivR(dzT, lScaleNum, lScaleDen));
        }
    else
        {
        dzT = MulDivR(lpbmih->biHeight, pmrs->mde.yScaleNum,pmrs->mde.yScaleDen);
        dzT = MulDivR(dzT, pmrs->mde.xScaleDen, pmrs->mde.xScaleNum);
        *pdyNew = Abs(MulDivR(dzT, lScaleNum, lScaleDen));
		}

	if (FScaleX(pmrs))
		fNeedToScale = (lpbmih->biWidth != *pdxNew);
	else
		fNeedToScale = (lpbmih->biHeight != *pdyNew);
	return fNeedToScale;
}   /* FNeedToScaleDIB */

// ***************************************************************************
// %%Function: FLotsOfMemReqd           %%Owner: harip    %%Reviewed: 01/16/96
//
// Parameters:  *pdxReqd, *pdyReqd: (IN/OUT)size of bits which would be rotated. Need not
//                              be the original size (unequally scaled pifs).
//              *pndivisor: number to divide by to scale down.
// Description: Returns fTrue if the intermediate dib bits would require a
//          lot of memory. So we want to warn the user about this and
//          scale down the sides and rotate that. In this case *pndivisor
//          will contain the amount to divide the sides by.
//          ELSE returns fFalse.
// ***************************************************************************
BOOL FLotsOfMemReqd(MRS *pmrs, LPBITMAPINFOHEADER lpbmih, int *pdxNew, int *pdyNew, int *pndivisor)
{
    MEMORYSTATUS ms;
    int cbPixel;    // number of bytes per pixel
    int dxT = *pdxNew,
        dyT = *pdyNew;
    BOOL fReturn = fFalse;
    RECT rcRot, rcNew;
    DRC drcRot;
    int ndivisor;

    ndivisor = 1;  // init to 1 ==> no scaling.
    if (lpbmih->biBitCount <= 8)
        cbPixel = 2;    // the values are 1 and 3 mult by 2 since we want
    else                // twice the size in the product below. This is so that
        cbPixel = 6;    // we take the intermediate also into account.

    ms.dwLength = sizeof(MEMORYSTATUS); // got to do this
    GlobalMemoryStatus(&ms);            // get total avail mem info.
    // get bounding rc's since that is the size of final DIB bits
    SetRc(&rcRot, 0, 0,dxT, dyT);
	BoundingRcFromRcAng(&rcNew, &rcRot, pmrs->ang);
    RcToDrc(rcNew, &drcRot);
    // we keep scaling down while the mem reqd is > half the total RAM.
    while ((cbPixel * drcRot.dx * drcRot.dy) > MulDivR(ms.dwTotalPhys, 1L, 2L))
        {
        ndivisor++;
        dxT = MulDivR(*pdxNew, 1L, ndivisor);
        dyT = MulDivR(*pdyNew, 1L, ndivisor);
        SetRc(&rcRot, 0, 0,dxT, dyT);
		BoundingRcFromRcAng(&rcNew, &rcRot, pmrs->ang);
        RcToDrc(rcNew, &drcRot);
        }   //while
#ifdef DEBUG
    if (ndivisor > 1)
        {
        CommSzNum(_T("Size of bounding bits (in bytes): "), *pdxNew-0);
        CommSzNum(_T(" x "), *pdyNew - 0);
        CommSzNum(_T(" x "), cbPixel / 2);
        CommCrLf();
        if (ndivisor > 1)
            {
            CommSzNum(_T("Dividing factor = "), ndivisor - 0);
            }
        else
            {
            CommSz(_T("**** Did not scale down. *****"));
            }
        CommCrLf();
        }
#endif
    if ((*pndivisor = ndivisor) > 1)
        {
        *pdxNew = dxT;
        *pdyNew = dyT;
        fReturn = fTrue;
        }
    return fReturn;
}   // FLotsOfMemReqd

// ***************************************************************************
// %%Function: FRotateDIBits            %%Owner: harip    %%Reviewed: 01/16/96
//  
// Description: Rotates the dib bits and returns fTrue on success.
//  
// ***************************************************************************
BOOL FRotateDIBits(HDC hdc, MRS *pmrs, LPBITMAPINFOHEADER lpbmih, DIBEXT *pdibext, 
                        BYTE *pDIBBitsOrig, UINT iUsage, DWORD dwRopOrig)
{
    BYTE       *pDIBBitsRot=NULL;
    BOOL	fSuccess =         fFalse,
            fDIBScaled =     fFalse,
            fBitBlt = fFalse;

    BITMAPINFOHEADER *lpbmihScaled, bmihSav;
    HPALETTE    hpalSav=NULL;
    HQ hqDIBBitsRot = NULL;
	HQ hqDIBBitsOrig = NULL;
            
    RECT  rcRot, rcNew;
    DRC drcRot, drcRotDst;
    DSI dsiScaled, dsiScaledRot;  // dibsection info for the scaled dib bits
	int cPSClip;
	MGE mge;

    bmihSav = *lpbmih;  //save away dib info so that we can restore later
    
    // check that bits are not encoded and if they are, convert to BI_RGB
    if (lpbmih->biCompression != BI_RGB)
        {
        // convert RLE to RGB bitmap, since rotating rle bits leads to bogosity
        if (hqDIBBitsOrig = HQDIBBitsConvertDIB(hdc, lpbmih, pDIBBitsOrig, BI_RGB))
            pDIBBitsOrig = (BYTE*)LpLockHq(hqDIBBitsOrig);
        else
            goto LExit;
        }
    // check if we need to get the bits in the same proportion as viewport.
    {
    int dxNew, dyNew;   // size for new dib returned by FNeedToScaleDIB()
    int ndivisor;

    fDIBScaled = FNeedToScaleDIB(pmrs, lpbmih, &dxNew, &dyNew);
    if (!fDIBScaled)
        {
        dxNew = lpbmih->biWidth;
        dyNew = Abs(lpbmih->biHeight);
        }
    // now check if the image is so big that trying to rotate it will send
    // us into disk rotating confusion.
     if (FLotsOfMemReqd(pmrs, lpbmih, &dxNew, &dyNew, &ndivisor))
        {
        AssertEx(ndivisor > 1);
        pdibext->dxSrc = MulDivR(pdibext->dxSrc, 1, ndivisor);
        pdibext->dySrc = MulDivR(pdibext->dySrc, 1, ndivisor);
        fDIBScaled = fTrue; // so that we go through normal scaling code
        }

    if (fDIBScaled)
        {
        // clear out the dsi's
        // NOTE: FUTURE: using i variable for the dsi will simplify cleanup code and would
        //              not require this setting to 0 stuff here.
        ClearStruct(dsiScaled);
        ClearStruct(dsiScaledRot);

        if (!FDIBBitsScaledFromHDIB(hdc, pmrs, lpbmih, pDIBBitsOrig, dxNew, dyNew, &dsiScaled))
            {
            FreeDIBSection(&dsiScaled);
            goto LCleanup;
            }
        pDIBBitsOrig = (BYTE*)dsiScaled.lpBits;
        lpbmihScaled = NULL;
        if (hqDIBBitsOrig)
            {
            UnlockHq(hqDIBBitsOrig);
            FreeHq(hqDIBBitsOrig);
            hqDIBBitsOrig = hqNil;
            }
        }
    }
    // get bounding rc's for the source and destination rc's of the BLT record.
    SetRc(&rcRot, pdibext->xSrc, pdibext->xSrc,
                    pdibext->xSrc + pdibext->dxSrc, pdibext->ySrc + pdibext->dySrc);
    // get size of rotated bitmap
    BoundingRcFromRcAng(&rcNew, &rcRot, pmrs->ang);
    RcToDrc(rcNew, &drcRot);
    // now the dest
    SetRc(&rcRot, pdibext->xDst, pdibext->yDst,
                    pdibext->xDst + pdibext->dxDst, pdibext->yDst + pdibext->dyDst);

    ScaleXAndY(pmrs, (int*)&rcRot.left, (int*)&rcRot.top);
    ScaleXAndY(pmrs, (int*)&rcRot.right, (int*)&rcRot.bottom);
	RRC rrcT;
	RrcFromMatRc(&rrcT, &pmrs->mat, &rcRot);
	BoundingRcFromRrc(&rcNew, &rrcT);
    RcToDrc(rcNew, &drcRotDst);

    // need to do this stuff below because -ve dz's are used to flip the bits
    // from src to dst and going from rc to drc screws with the origin ot the drc.
    if ((pdibext->dxDst < 0) && (Sgn(pmrs->mde.drcWin.dx) != Sgn(pmrs->mde.drcView.dx)))
        {
        drcRotDst.x += drcRotDst.dx;
        drcRotDst.dx = -drcRotDst.dx;
        }
    if ((pdibext->dyDst < 0) && (Sgn(pmrs->mde.drcWin.dy) != Sgn(pmrs->mde.drcView.dy)))
        {
        drcRotDst.y += drcRotDst.dy;
        drcRotDst.dy = -drcRotDst.dy;
        }
    // if the dib is being inverted as part of the blt we'll pretend that the bits are
    // inverted when rotating them. biHeight is made +ve again in HDIBBitsRot().
    if ((pdibext->dyDst < 0) && (pmrs->mde.drcWin.dy > 0))
        lpbmih->biHeight *= -1;
    // lets rotate
    if ((hqDIBBitsRot = HQDIBBitsRot(pmrs, lpbmih, pDIBBitsOrig, pmrs->ang)) == NULL)
        goto LCleanup;
    AssertEx(Sgn(lpbmih->biHeight) == Sgn(bmihSav.biHeight));

    pDIBBitsRot = (BYTE*)LpLockHq(hqDIBBitsRot);    // get pointer to the bits

#ifdef DEBUG_BITS_ROT
	BLOCK
		{
		StretchDIBits(pmrs->hdcDebug, 0, 0, lpbmih->biWidth, lpbmih->biHeight,
			0,0, lpbmih->biWidth, lpbmih->biHeight, pDIBBitsRot,
			(LPBITMAPINFO)lpbmih, DIB_RGB_COLORS, SRCCOPY);
		}
#endif // DEBUG_BITS_ROT

    if (fDIBScaled) // scale it back to size we would have got
        {
        FreeDIBSection(&dsiScaled);
        if (!FDIBBitsScaledFromHDIB(hdc, pmrs, lpbmih, pDIBBitsRot, drcRot.dx, drcRot.dy, &dsiScaledRot))
            goto LCleanup;
        pDIBBitsRot = (BYTE*)dsiScaledRot.lpBits;
        }   // if (fDIBScaled)

	SDE sde = SdeFromHwndHdc(NULL, hdc);
	InitMge(pNil, 0, &mge, &sde, qinitsdePaint);
	// We have no CQuillView to use to call SetMgeDisplay
	// so set the needed fields by hand.
	mge.rcVisi = rcNew; // rcNew is the bounding rect of the rotated image
	mge.ang = pmrs->ang;
	mge.mat = pmrs->mat;
	mge.fPrint = pmrs->fPrint;

 	cPSClip = SavePSClipRgn(&mge);
	ClipRcPS(&mge, &rcRot, grfcrcNormal);

    // finally, we display it
    fSuccess = (StretchDIBits(hdc, drcRotDst.x, drcRotDst.y, drcRotDst.dx, drcRotDst.dy,
                            0,0, lpbmih->biWidth, lpbmih->biHeight, pDIBBitsRot,
                            (LPBITMAPINFO)lpbmih, iUsage, dwRopOrig) !=
                            GDI_ERROR);

	RestorePSClipRgn(&mge, cPSClip);
	FreeMge(&mge);

LCleanup:
    // cleanup if necessary
    if (hqDIBBitsOrig)
        {
        UnlockHq(hqDIBBitsOrig);
        FreeHq(hqDIBBitsOrig);
        }

    *lpbmih = bmihSav;   //restore
    if (hqDIBBitsRot)
        {
        UnlockHq(hqDIBBitsRot);
        FreeHq(hqDIBBitsRot);
        }
    if (fDIBScaled)
        FreeDIBSection(&dsiScaledRot);
LExit:
    return fSuccess;

}    //     FRotateDIBits

BOOL NormalizeDCCoords(HDC hdc, DCInfo *pDCInfo)
{
	AssertEx(pDCInfo);

    GetViewportOrgEx(hdc, (LPPOINT)&pDCInfo->ptdVPSav);
    GetViewportExtEx(hdc, (LPSIZE)&pDCInfo->dptdVPSav);
    GetWindowOrgEx(hdc, (LPPOINT)&pDCInfo->ptdWinSav);    
    GetWindowExtEx(hdc, (LPSIZE)&pDCInfo->dptdWinSav);    

	BOOL fFlipHorz = pDCInfo->dptdVPSav.x < 0;
	BOOL fFlipVert = pDCInfo->dptdVPSav.y < 0;

	if (!fFlipHorz && !fFlipVert)
		return fFalse; // No flipping was undone

    SetViewportExtEx(hdc, fFlipHorz ? -pDCInfo->dptdVPSav.x : pDCInfo->dptdVPSav.x,
    					  fFlipVert ? -pDCInfo->dptdVPSav.y : pDCInfo->dptdVPSav.y, (LPSIZE)NULL); 
    SetViewportOrgEx(hdc, pDCInfo->ptdVPSav.x + (fFlipHorz ? pDCInfo->dptdVPSav.x : 0),
    					  pDCInfo->ptdVPSav.y + (fFlipVert ? pDCInfo->dptdVPSav.y : 0), (LPPOINT)NULL);

	return fTrue; // Flipping was undone
}

void RestoreDCCoords(HDC hdc, DCInfo *pDCInfo)
{
	AssertEx(pDCInfo);
	
	SetViewportOrgEx(hdc, pDCInfo->ptdVPSav.x, pDCInfo->ptdVPSav.y, (LPPOINT)NULL);  //Restore VPort Orig
	SetViewportExtEx(hdc, pDCInfo->dptdVPSav.x, pDCInfo->dptdVPSav.y, (LPSIZE)NULL);  //Restore VPort Ext
}

// ***************************************************************************
// %%Function: FMeta_StretchFoo         %%Owner: harip    %%Reviewed: 12/15/94
//
// Description: Handles all the bitmap blt calls (META_STRETCHDIB etc.)
// ***************************************************************************
BOOL FMeta_StretchFoo(HDC hdc, MRS *pmrs, LPMETARECORD lpMFR, EMFP FAR *lpemfp)
{
    SDIB *psdib, sdibT;
    int iwDySrc;
    LPBITMAPINFOHEADER lpbmih;
    BOOL  fSuccess = fFalse;
    DWORD dwRopOrig;
    BYTE   *pDIBBitsOrig = NULL;
    WORD    wUsage;
    UINT    iUsage=DIB_RGB_COLORS;
    BOOL    fBitBlt = fFalse;
    SDBBLT  *psdblt;
    DIBEXT dibext;

    // get position of src/dest rc's in the metafile record
    if( lpMFR->rdFunction == META_STRETCHDIB )
        iwDySrc = 3;
    else if( lpMFR->rdFunction == META_STRETCHBLT ||
             lpMFR->rdFunction == META_DIBSTRETCHBLT )
        iwDySrc = 2;
    else if( lpMFR->rdFunction == META_SETDIBTODEV )
        iwDySrc = 0;
    else if( lpMFR->rdFunction == META_DIBBITBLT)
        {
        iwDySrc = 2;
        fBitBlt = fTrue;
        }
    else
        {
        AssertEx(fFalse);
        goto LExit; // what strange beast do we have here?
        }

    // since there is no iUsage for stretchblt()
    if (iwDySrc == 3)
        {
        wUsage = lpMFR->rdParm[2];
        iUsage = wUsage;
        }
    // this stuff below because for BITBLT dxSrc and dxDst is not present so
    // we have to translate to a sdib struct.
    if (fBitBlt)
        {
        psdblt = (SDBBLT *)&Param(iwDySrc);
        sdibT.dySrc = sdibT.dyDst = psdblt->dyDst;
        sdibT.dxSrc = sdibT.dxDst = psdblt->dxDst;
        sdibT.ySrc = psdblt->ySrc;
        sdibT.xSrc = psdblt->xSrc;
        sdibT.yDst = psdblt->yDst;
        sdibT.xDst = psdblt->xDst;
        psdib = &sdibT;
        lpbmih = (LPBITMAPINFOHEADER)((LPBYTE)psdblt + cbSDBBLT);
        }
    else
        {
        psdib = (SDIB *)&Param(iwDySrc);
        lpbmih = (LPBITMAPINFOHEADER)((LPBYTE)psdib + cbSDIB);
        }

    dwRopOrig = *((DWORD FAR *)&lpMFR->rdParm[0]);      //Store Original Rop
    // Get ptr to the bits of the Src DIB
    pDIBBitsOrig = (BYTE *)((BYTE *)lpbmih + CbDibHeader(lpbmih));
	CopySdibToDibext(psdib, &dibext);

	DCInfo dcinfo;
	long qflipSav;
	if (pmrs->fInverted)
		{
		qflipSav = pmrs->qflip;
		pmrs->qflip ^= (qflipHorz | qflipVert);
		NormalizeDCCoords(hdc, &dcinfo);
		}

	fSuccess = FRotateDIBits(hdc, pmrs, lpbmih, &dibext, pDIBBitsOrig, 
						    				iUsage, dwRopOrig);

	if (pmrs->fInverted)
		{
		pmrs->qflip = qflipSav;
		RestoreDCCoords(hdc, &dcinfo);
		}

LExit:
    return fSuccess;
} /* FMeta_StretchFoo */

void ScaleWindowExtentParmsForRotation(MRS *pmrs, short *px, short *py)
{
	*px = (short)(ZScaledNZ(pmrs, (short)*px));
	*py = (short)(ZScaledNZ(pmrs, (short)*py));
	pmrs->mde.drcWin.dx  =  (short)*px;
	pmrs->mde.drcWin.dy  =  (short)*py;
	ValidateDrcForRotate(&pmrs->mde.drcWin);
	if (FScaleX(pmrs))
		*px = (short) (Sgn(pmrs->mde.drcWin.dx) *
			Abs(MulDivR((short)*py,pmrs->mde.drcView.dx, pmrs->mde.drcView.dy)));
	else
		*py = (short)(Sgn(pmrs->mde.drcWin.dy) *
			Abs(MulDivR((short)*px,pmrs->mde.drcView.dy, pmrs->mde.drcView.dx)));
	// Zero extents don't make sense and cause PlayMetaFileRecord to fail.
	if (*py == 0)
		*py = 1;
	if (*px == 0)
		*px = 1;
}

// ***************************************************************************
// %%Function: FPlayRotatedMFR          %%Owner: harip    %%Reviewed: 12/15/94
//
// Description: this function handles the records for which we may need to do
//      something special or get information, in the case of rotation.
// Returns: fTrue if it handled the record (called PlayMetafileRecord) or else
//          fFalse (which means the calling function should handle the playing
//          of that record.
// ***************************************************************************
BOOL FPlayRotatedMFR(HDC hdc, LPHANDLETABLE lpHTable, LPMETARECORD lpMFR,
					int nObj, EMFP *lpemfp)
{
	MRS *pmrs = lpemfp->pmrs;

    AssertEx(pmrs->ang);

    switch(lpMFR->rdFunction)
        {
        case META_DIBSTRETCHBLT:
        case META_STRETCHBLT:       /* Stretches a DDB */
        case META_STRETCHDIB:       /* StretchDIBits */
        case META_DIBBITBLT:
            {
            if (!FRotContextSet(pmrs))
                SetMFRotationContext(pmrs);
            lpemfp->fMFRSucceeded = FMeta_StretchFoo(hdc, pmrs, lpMFR, lpemfp);
            return fTrue;
            }

#ifdef METAFILE_SQUAREEDGES
        case META_CREATEPENINDIRECT:
            {
            // We create the Pen ourself to use the extendid pen fetures (square edges)
            DWORD Style = ((LOGPEN16*)lpMFR->rdParm)->lopnStyle;
			DWORD Width = ((LOGPEN16*)lpMFR->rdParm)->lopnWidth.x;
			COLORREF crColor = ((LOGPEN16*)lpMFR->rdParm)->lopnColor;

            if (!FRotContextSet(pmrs))
                SetMFRotationContext(pmrs);

            if (!pmrs->fPrint)
                crColor = crColor & 0x00FFFFFF;

            if (Width > 0)
                Width = (short)MulDivR(ZScaled(pmrs, (short)Width), pmrs->mde.xScaleNum, pmrs->mde.xScaleDen);
			else
				Width = 1;

			LOGBRUSH logBrush;

			logBrush.lbStyle = BS_SOLID;
			logBrush.lbColor = crColor;
			logBrush.lbHatch = 0;

			if ( (Width > 1) && (Style == PS_SOLID || Style == PS_INSIDEFRAME) )
				Style = Style | PS_GEOMETRIC|PS_ENDCAP_FLAT|PS_JOIN_MITER;

			HPEN hPen = ExtCreatePen(Style, Width, &logBrush, 0, NULL);

			lpemfp->fMFRSucceeded = FALSE;
			if (hPen)
				{
				int i;
				for (i=0; i<nObj; i++)
					{
					if(lpHTable->objectHandle[i] == NULL)
						{
						lpHTable->objectHandle[i] = hPen;
						lpemfp->fMFRSucceeded = TRUE;
						break;
						}
					}
				}

            return fTrue;
            break;
            }
#else
        case META_CREATEPENINDIRECT:
            {
            // raid 1588 : need to scale down pen sizes by the amount we scale down the
            //             all other coordinates.
            PT16   pt;
            PT16 * lppt;
            COLORREF crSaved;

            if (!pmrs->fPrint)
                {
                crSaved = ((LOGPEN16 *)lpMFR->rdParm)->lopnColor;
				// Bug 4733 (Q98): unless we put the paletteRgb bit on, light rotated colors
				// may be displayed wrong on a 256 color display.
                ((LOGPEN16 *)lpMFR->rdParm)->lopnColor = (crSaved & 0x00FFFFFF) | qcrPaletteRgb;
                }

            if (!FRotContextSet(pmrs))
                SetMFRotationContext(pmrs);

            lppt = (PT16 FAR *)&Param(1);
            pt = *lppt;
            if (lppt->x > 0)
                lppt->x = (short)MulDivR(ZScaled(pmrs, lppt->x), pmrs->mde.xScaleNum, pmrs->mde.xScaleDen);
            lpemfp->fMFRSucceeded =
                        PlayMetaFileRecord(hdc, lpHTable, lpMFR, nObj);
            *lppt = pt;
            if (!pmrs->fPrint)
                ((LOGPEN16 *)lpMFR->rdParm)->lopnColor = crSaved;
            return fTrue;
            break;
            }
#endif

        case META_SAVEDC:
        	// Publisher sets the rotation context here for some reason.  I discussed
        	// this with HariP and he agreed that it seemed unnecessary.  The original
        	// rotation code check-in contained the context push (set) so it is unlikely
        	// that it served as a bug fix.  -davidhoe
            PushMDE(pmrs);
            goto LDefault;
        case META_RESTOREDC:
            PopMDE(pmrs);
            goto LDefault;

        case META_EXCLUDECLIPRECT :
        // returning fTrue because there is nothing we can do about this and we
        // certainly dont want the original record played.
            return fTrue;
        case META_OFFSETCLIPRGN:   // dont want to do much about this either.
            return fTrue;

        case META_INTERSECTCLIPRECT:
            if (!FRotContextSet(pmrs))
                SetMFRotationContext(pmrs);
            lpemfp->fMFRSucceeded = FMeta_IntersectClipRect(hdc, pmrs, lpMFR);
            return fTrue;
            break;

        case META_SETTEXTCHAREXTRA:
			NewCode("Attach metafile to bug and report any problems.");
            SetTextCharacterExtra(hdc, ZScaled(pmrs, SParam(0)));
            return fTrue;
            break;

        case META_CREATEFONTINDIRECT:
            lpemfp->fMFRSucceeded =
                            FMeta_CreateFontInd(hdc, pmrs, lpHTable, lpMFR, nObj);  // calls PlayMetaFileRecord
            return fTrue;
            break;
        case META_EXTTEXTOUT :
            if (!FRotContextSet(pmrs))
                SetMFRotationContext(pmrs);
            lpemfp->fMFRSucceeded =
                            FMeta_ExtTextOut(hdc, pmrs, lpHTable, lpMFR, nObj);
            return fTrue;
            break;
        case META_TEXTOUT :
            if (!FRotContextSet(pmrs))
                SetMFRotationContext(pmrs);
            lpemfp->fMFRSucceeded =
                            FMeta_TextOut(hdc, pmrs, lpHTable, lpMFR, nObj);
            return fTrue;
            break;
        case META_MOVETO:
            if (!FRotContextSet(pmrs))
                SetMFRotationContext(pmrs);
            lpemfp->fMFRSucceeded = FMeta_MoveTo(hdc, pmrs, lpMFR);
            return fTrue;
            break;
        case META_LINETO:
            if (!FRotContextSet(pmrs))
                SetMFRotationContext(pmrs);
            lpemfp->fMFRSucceeded = FMeta_LineTo(hdc, pmrs, lpMFR);
            return fTrue;
            break;
        case META_SETPIXEL:
            if (!FRotContextSet(pmrs))
                SetMFRotationContext(pmrs);
            lpemfp->fMFRSucceeded = FMeta_SetPixel(hdc, pmrs, lpMFR);
            return fTrue;
            break;

        case META_RECTANGLE:
            if (!FRotContextSet(pmrs))
                SetMFRotationContext(pmrs);
            lpemfp->fMFRSucceeded = FMeta_Rectangle(hdc, pmrs, lpMFR);
            return fTrue;
            break;
        case META_ROUNDRECT:
            if (!FRotContextSet(pmrs))
                SetMFRotationContext(pmrs);
            lpemfp->fMFRSucceeded = FMeta_RoundRect(hdc, pmrs, lpMFR);
            return fTrue;
            break;
        case META_POLYPOLYGON:
            if (!FRotContextSet(pmrs))
                SetMFRotationContext(pmrs);
            lpemfp->fMFRSucceeded = FMeta_PolyPolygon(hdc, pmrs, lpMFR);
            return fTrue;
            break;
        case META_POLYGON:
        case META_POLYLINE:
            if (!FRotContextSet(pmrs))
                SetMFRotationContext(pmrs);
            lpemfp->fMFRSucceeded = FMeta_PolyFoo(hdc, pmrs, lpMFR);
            return fTrue;
            break;
        case META_ELLIPSE:
            if (!FRotContextSet(pmrs))
                SetMFRotationContext(pmrs);
            lpemfp->fMFRSucceeded = FMeta_Ellipse(hdc, pmrs, lpMFR);
            return fTrue;
            break;
        case META_ARC:
        case META_CHORD:
        case META_PIE:
            if (!FRotContextSet(pmrs))
                SetMFRotationContext(pmrs);
            lpemfp->fMFRSucceeded = FMeta_ArcChordPie(hdc, pmrs, lpMFR);
            return fTrue;
            break;

        case META_FLOODFILL :
        case META_EXTFLOODFILL :
            if (!FRotContextSet(pmrs))
                SetMFRotationContext(pmrs);
            lpemfp->fMFRSucceeded =
                            FMeta_FooFloodFill(hdc, pmrs, lpHTable, lpMFR, nObj);
            return fTrue;
            break;

        case META_PATBLT:
            if (!FRotContextSet(pmrs))
                SetMFRotationContext(pmrs);
            lpemfp->fMFRSucceeded = FMeta_PatBlt(hdc, pmrs, lpMFR);
            return fTrue;
            break;


        case META_OFFSETWINDOWORG:
                // we dont play this record, but just remember the offset values.
                pmrs->mde.dxWinOff += ZScaled(pmrs, SParam(1));
                pmrs->mde.dyWinOff += ZScaled(pmrs, SParam(0));

                return fTrue;
                break;

        case META_SCALEWINDOWEXT:
                pmrs->mde.xWinScaleNum = pmrs->mde.drcWin.dx;
                pmrs->mde.xWinScaleDen = MulDivR(pmrs->mde.drcWin.dx, SParam(3), SParam(2));
                pmrs->mde.yWinScaleNum = pmrs->mde.drcWin.dy;
                pmrs->mde.yWinScaleDen = MulDivR(pmrs->mde.drcWin.dy, SParam(1), SParam(0));
                MultiplyRatios(pmrs->mde.xVPScaleNum,    pmrs->mde.xVPScaleDen,
                                pmrs->mde.yVPScaleNum,   pmrs->mde.yVPScaleDen,
                                pmrs->mde.xWinScaleNum,  pmrs->mde.xWinScaleDen,
                                pmrs->mde.yWinScaleNum,  pmrs->mde.yWinScaleDen,
                                &pmrs->mde.xScaleNum,    &pmrs->mde.xScaleDen,
                                &pmrs->mde.yScaleNum,    &pmrs->mde.yScaleDen);
                return fTrue;   // not playing this

        case META_SETWINDOWEXT:
            {
            if (FRotContextSet(pmrs))
                {
                pmrs->mde.xWinScaleNum = pmrs->mde.drcWin.dx;
                pmrs->mde.xWinScaleDen = ZScaledNZ(pmrs, SParam(1));
                pmrs->mde.yWinScaleNum = pmrs->mde.drcWin.dy;
                pmrs->mde.yWinScaleDen = ZScaledNZ(pmrs, SParam(0));
                MultiplyRatios(pmrs->mde.xVPScaleNum,    pmrs->mde.xVPScaleDen,
                                pmrs->mde.yVPScaleNum,   pmrs->mde.yVPScaleDen,
                                pmrs->mde.xWinScaleNum,  pmrs->mde.xWinScaleDen,
                                pmrs->mde.yWinScaleNum,  pmrs->mde.yWinScaleDen,
                                &pmrs->mde.xScaleNum,    &pmrs->mde.xScaleDen,
                                &pmrs->mde.yScaleNum,    &pmrs->mde.yScaleDen);
                return fTrue;   // not playing this
                }
            else
                {
                short dxSav = SParam(1);    // save values
                short dySav = SParam(0);
                short dx = dxSav;
                short dy = dySav;

				ScaleWindowExtentParmsForRotation(pmrs, &dx, &dy);

                Param(1) = dx;
                Param(0) = dy;

                lpemfp->fMFRSucceeded =
                                PlayMetaFileRecord(hdc, lpHTable, lpMFR, nObj);
                Param(1) = dxSav;
                Param(0) = dySav;
                return fTrue;
                }
             goto LDefault;
             break;
             }
        case META_SETWINDOWORG:
            {
            if (FRotContextSet(pmrs))
                {
                pmrs->mde.dxWinOff = ZScaled(pmrs, SParam(1)) - pmrs->mde.drcWin.x;
                pmrs->mde.dyWinOff = ZScaled(pmrs, SParam(0)) - pmrs->mde.drcWin.y;
                return fTrue;   // not playing this
                }
            else
                {
                short xT = SParam(1);
                short yT = SParam(0);
                Param(1) = (short)(pmrs->mde.drcWin.x  = ZScaled(pmrs, xT));
                Param(0) = (short)(pmrs->mde.drcWin.y  = ZScaled(pmrs, yT));
                ValidateDrcForRotate(&pmrs->mde.drcWin);
                lpemfp->fMFRSucceeded =
                            PlayMetaFileRecord(hdc, lpHTable, lpMFR, nObj);
                Param(1) = xT;
                Param(0) = yT;
                return fTrue;
                }
            goto LDefault;
            break;
            }
        case META_SCALEVIEWPORTEXT:
            MultiplyRatios(pmrs->mde.xVPScaleNum,    pmrs->mde.xVPScaleDen,
                            pmrs->mde.yVPScaleNum,   pmrs->mde.yVPScaleDen,
                            SParam(3),        SParam(2),
                            SParam(1),        SParam(0),
                            &pmrs->mde.xVPScaleNum,  &pmrs->mde.xVPScaleDen,
                            &pmrs->mde.yVPScaleNum,  &pmrs->mde.yVPScaleDen);
            MultiplyRatios(pmrs->mde.xVPScaleNum,    pmrs->mde.xVPScaleDen,
                            pmrs->mde.yVPScaleNum,   pmrs->mde.yVPScaleDen,
                            pmrs->mde.xWinScaleNum,  pmrs->mde.xWinScaleDen,
                            pmrs->mde.yWinScaleNum,  pmrs->mde.yWinScaleDen,
                            &pmrs->mde.xScaleNum,    &pmrs->mde.xScaleDen,
                            &pmrs->mde.yScaleNum,    &pmrs->mde.yScaleDen);
            return fTrue;
            break;
LDefault:
        default:
            return fFalse;
            break;

        } /* switch */
    AssertEx(fFalse); // something slipped through
	return fFalse;
}   /* FPlayRotatedMFR */

///////////////////////////
//
// more text out
//

//
// ExtTextOutFlip
//
BOOL ExtTextOutFlip(
    HDC     hdc,
    MRS		*pmrs,
    int     xp,
    int     yp,
    UINT    eto,
    RECT *lprcp,
    char *lpch,
    UINT    cch,
    int FAR *lpdxp)
{
    return RotExtTextOut(hdc, pmrs, xp, yp, eto, lprcp, lpch, cch, lpdxp);
} /* ExtTextOutFlip */

#define SwapValNonDebug(val1,val2)      ((val1)^=(val2), (val2)^=(val1), (val1)^=(val2))
#define  SwapVal(val1,val2)   (Assert0(sizeof(val1) == sizeof(val2), "SwapVal problem", 0, 0), \
							   SwapValNonDebug((val1),(val2)))

BOOL FMetaTextOutFlip2(HDC hdc, MRS *pmrs, int xp, int yp, UINT cch, char *pch,
	UINT eto, RC16 *prcp16, WORD *pdxp16);



// ---------------------------------------------------------------------------
// %%Function: FMetaTextOutFlip         %%Owner: davidve  %%Reviewed: 00/00/00
//
// Parameters:
//  hdc     -
//  pParam  -   Parameter list from METARECORD struct
//  cwParam -   Size in words of param list
//
// Returns:
//  fTrue is successful
//  fFalse otherwise
//
// Description:
//  Translate a metafile ExtTextOut record to a call to our upside-down
//  text printing routine.
//
//  You'll grow to love this code.
//
// ---------------------------------------------------------------------------
BOOL FMetaTextOutFlip(HDC hdc, MRS *pmrs, WORD * pParam, DWORD cwParam)
{
    /*
    Here is the format of the parameter list:
    Index   Content
        0   cch
        1   string
        1 + ((cch + 1)>>1)  yp
        2 + ((cch + 1)>>1)  xp
    */

    int     xp;
    int     yp;
    UINT    cch;

    cch = (UINT)(WORD)pParam[0];
    yp = (int)(short)pParam[1 + ((cch + 1) >> 1)];
    xp = (int)(short)pParam[2 + ((cch + 1) >> 1)];

    return FMetaTextOutFlip2(hdc, pmrs, xp, yp, cch, (char *)&pParam[1], 0, NULL, NULL);
} /* FMetaTextOutFlip */



// REVIEW (davidhoe):  Consider the possibility of trying to combine some of the
// TextOutFlip functions.  There are enough differences to require significant care.
// Note that Publisher, the source of these functions, has these functions separate
// just as we currently have.
BOOL FMetaExtTextOutFlip(HDC hdc, MRS *pmrs, WORD * pParam, DWORD cwParam)
{
    /*
    Here is the format of the parameter list:
    Index   Content
        0   yp
        1   xp
        2   cch
        3   options: eto flags
        4   if options != 0, contains a RECT, otherwise, nonexistent
    4 or 8  String
    4 or 8 + ((cch + 1)>>1)     rgdxp (optional)
    */

    int     xp;
    int     yp;
    UINT    cch;
    UINT    eto;
    RC16    *prcp16;
    WORD    *pdxp16;
    DWORD   cw;

    yp = (int)(short)pParam[0];
    xp = (int)(short)pParam[1];
    cch = (UINT)(WORD)pParam[2];
    eto = (UINT)((WORD)pParam[3] & ETO_CLIPPED) | ((WORD)pParam[3] & ETO_OPAQUE);
    cw = 4;
    if (!pParam[3])
        prcp16 = NULL;
    else
        {
        prcp16 = (RC16 FAR *)&pParam[4];
        cw += sizeof(RC16) / sizeof(WORD);
        }

    /* At this point, cw is the index to the string */
    char *pszT = (char *)&pParam[cw];

    cw += (cch + 1) >> 1;
    /* At this point, cw is the index to the array of character widths */
    /* Assert that there are either 0 or cch character widths */
    AssertEx(cw == cwParam || cw + cch == cwParam);
    if (cw >= cwParam)
        pdxp16 = NULL;
    else
        pdxp16 = &pParam[cw];

    return FMetaTextOutFlip2(hdc, pmrs, xp, yp, cch, pszT, eto, prcp16, pdxp16);
} /* FMetaExtTextOutFlip */



BOOL FMetaTextOutFlip2(HDC hdc, MRS *pmrs, int xp, int yp, UINT cch, char *pch, UINT eto, 
                       RC16 *prcp16, WORD *pdxp16)
{
    RECT      rcp;
    int     rgdxp[256];
    int     *pdxp = NULL;
    
    if (pdxp16 != NULL)
        {
        UINT idxp;
        /* we have to make a copy of the array of character widths
           padded to 32 bit */
        AssertEx(cch <= 256);
        cch = min((UINT)256, cch);
        pdxp = rgdxp;
        for(idxp = 0; idxp < cch; idxp++)
            pdxp[idxp] = (int)(short)pdxp16[idxp];
        }

    if (prcp16)
        {
        rcp.left   = (int)prcp16->xLeft;
        rcp.top    = (int)prcp16->yTop;
        rcp.right  = (int)prcp16->xRight;
        rcp.bottom = (int)prcp16->yBottom;
        }
    else
        {
        /* The metafile record didn't contain a bounding rect, so fake
            one */
        SIZE    sizeWExt;
        SIZE    sizeTExt;
        UINT    ta;
        TEXTMETRIC  tm;

        GetTextExtentPointA(hdc, pch, cch, &sizeTExt);
        GetWindowExtEx(hdc, &sizeWExt);
        ta = GetTextAlign(hdc);
        if ((ta & (TA_BASELINE | TA_BOTTOM | TA_TOP)) == TA_BASELINE)
            {
            GetTextMetrics(hdc, &tm);
            }
        if (sizeWExt.cy < 0)
            {
            sizeTExt.cy = -sizeTExt.cy;
            tm.tmAscent = -tm.tmAscent;
            tm.tmDescent = -tm.tmDescent;
            }
        switch (ta & (TA_BASELINE | TA_BOTTOM | TA_TOP))
            {
        case TA_TOP:
            rcp.top = yp;
            rcp.bottom = yp + sizeTExt.cy;
            break;
        case TA_BOTTOM:
            rcp.bottom = yp;
            rcp.top = yp - sizeTExt.cy;
            break;
        case TA_BASELINE:
            rcp.top = yp - tm.tmAscent;
            rcp.bottom = yp + tm.tmDescent;
            break;
            } /* switch vertical alignment */
        if (pdxp != NULL)
            {
            UINT    idxp;

            for (sizeTExt.cx = 0, idxp = 0; idxp < cch; idxp++)
                sizeTExt.cx += pdxp[idxp];
            }
        if (sizeWExt.cx < 0)
            {
            sizeTExt.cx = -sizeTExt.cy;
            }
        switch (ta & (TA_LEFT | TA_CENTER | TA_RIGHT))
            {
        case TA_LEFT:
            rcp.left = xp;
            rcp.right = xp + sizeTExt.cx;
            break;
        case TA_RIGHT:
            rcp.right = xp;
            rcp.left = xp - sizeTExt.cx;
            break;
        case TA_CENTER:
            rcp.left = xp - sizeTExt.cx / 2;
            rcp.right = rcp.left + sizeTExt.cx;
            break;
            } /* switch horizontal alignment */
        }

    return ExtTextOutFlip(hdc, pmrs, xp, yp, eto, &rcp, pch, cch, pdxp);

} /* FMetaTextOutFlip2 */

#endif // NOTYET
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\display\pubprint.cxx ===
/**************************************************************************
*
*                           PUBPRINT.CXX
*
*  PUBLISHER CODE TO HANDLE PRINTING TO AN INVERTED DC PORTED TO QUILL
*      
*  This is necessary because of the following reasons...
*
*      *  some metafiles are naughty and cannot be rendered to
*         an upside down DC because they use non rotated clip
*         rects (actually a windows bug) and clip themselves
*         out of existance. They are handled by patching up the
*         parameters of the INTERSECTCLIPRECT GDI call.
*
*      *  DJ5xxx and BJxxx series printer drivers GPF when stretchblt'ing
*         with inverted extents. They are handled by inverting scanline
*         by scanline into a DIB.
*
*      *  ExtTextOut calls to rotated DC's do not work correctly. They
*         are handled by setting the font's escapement to 180deg           
*
*  This code modified from Publishers GRAFDRAW.C to work in Quill code
*  base by warrenb (09/09/1994)
*
*  Changes from Publisher code base
*       Always called in rotated case so tests for rotation removed
*       Some CommPrintf's removed (no quill equiv.)
*       Raster font capability removed.
*       Special cased Monochrome capability removed (FColorStretchDibHack)
*         handles Monochrome perfectly well. (removed ~400 lines)
*
*  Notes:
*       This code *may* be completely replaced in Win32 by just doing a 
*       PlayMetafileRecord in the main enumeration routine. Investigate.
*       We do not handle the following records correctly...
*       META_BITBLT, META_SETDIBTODEV, META_STRETCHBLT, META_DIBBITBLT
*       META_TEXTOUT but good metafiles don't usually use these.           
*
*       Copyright (C)1994 Microsoft Corporation. All rights reserved.
*
***************************************************************************/

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_XGDI2_HXX_
#define X_XGDI2_HXX_
#include "xgdi2.hxx"
#endif

#ifndef X_PUBROT_HXX_
#define X_PUBROT_HXX_
#include "pubrot.hxx"
#endif

#ifndef X_PUBPRINT_HXX_
#define X_PUBPRINT_HXX_
#include "pubprint.hxx"
#endif

#ifndef X_DBGMETAF_HXX_
#define X_DBGMETAF_HXX_
#include "dbgmetaf.hxx"
#endif

BOOL fBruteFlipping = fTrue;

extern BOOL FPlayRotatedMFR(HDC hdc, LPHANDLETABLE lpHTable, LPMETARECORD lpMFR, int nObj, EMFP *lpemfp);

/****************************************************************************\
 *                                                                          *
 * %%Function: FStepMetaPrint       %%Owner: EdR       %%Reviewed: 12/21/93 *
 *                                                                          *
 * Parameters:                                                              *
 *    hdc           - hdc to play record on                                 *
 *    lpHTable      - Handle table                                          *
 *    lpMFR         - metafile record                                       *
 *    nObj          - Number of active objects                              *
 *    lpemfp        - long ptr to enum meta file params                     *
 *                                                                          *
 * Description:                                                             *
 *    Graphic enumeration routine.                                          *
 *    Can display executing metafile commands through debug menu.           *
 *    For use only when printing.                                           *
 *                                                                          *
 *    Modified for Quill - warrenb:                                         *
 *      . bad records now will cause harmless  assert.                      *
 *      . does not use Monochrome routines, lets color routines handle it   *
 *                                                                          *
 * Port to quill:                                                           *
 *    Owner: warrenb                Reviewed: 00/00/00                      *
\****************************************************************************/

int CALLBACK FStepMetaPrint(HDC hdc, 
							LPHANDLETABLE lpHTable, 
							LPMETARECORD lpMFR, 
							int nObj,
							LPARAM lparam)
{
	EMFP	*pemfp = (EMFP *) lparam;
    BOOL    fReturn = fTrue;

    pemfp->lcNumRecords++;

	TraceMetaFunc(lpMFR->rdFunction, pemfp->lcNumRecords); // Trace it in DEBUG if TRACE_META_RECORDS is defined.

	// Setup handling and filtering of metarecords
	switch (lpMFR->rdFunction)
		{

		{ // BUG 4423
		// Not all devices support the PatBlt function. Moreover, many printers handle it
		// in different way. Using this simple code (for UNROTATED case) improves print output
		// for some printer drivers for Win 95 and (always?) does not makes difference for
		// NT or for display. So we do best we can for this record.
		// NOTE 1: The way we (and Publisher) handle META_PATBLT for rotated images will give
		// incorrect result when ROP parameter is PATINVERT or DSTINVERT. I don't think that
		// there is any workaround.
		// NOTE 2: I didn't find any metafiles with META_PATBLT in real world. Only metafiles
		// created specialy for testing  ( see \\alchemy\gold\graphics\wmf\Test Suite\WMFCreatNT3.51(OR Win95))
		// have that record. If that record is not easy to play, it could be not easy to create
		// using todays software.. 
		// SashaT
		case META_PATBLT:
			if (!pemfp->pmrs->ang)
				{
				unsigned int iValueThisDC = GetDeviceCaps(hdc,  RASTERCAPS);
				AssertSz(iValueThisDC & RC_BITBLT, "Device does not support PatBlt");
				if (!(iValueThisDC & RC_BITBLT))
					{
					AssertSz(FALSE, "Device does not support PatBlt");
					break; // Will fail in PlayMetaRecord
					}

				DWORD dwRop = MAKELONG(lpMFR->rdParm[0], lpMFR->rdParm[1]);

				short nLeft = lpMFR->rdParm[5];
				short nTop = lpMFR->rdParm[4];
				short nWidth = lpMFR->rdParm[3];
				short nHeight = lpMFR->rdParm[2];

				return PatBlt(hdc, nLeft, nTop, nWidth, nHeight, dwRop);
				}
		break;
		} // END of BUG 4423

	case META_SETSTRETCHBLTMODE:
		// Do not let metafiles do this GDI call because it can override Quill's
		// SetStretchBltMode(COLORONCOLOR); which ensures smooth drawing of bitmaps
		// resized smaller than their orginal.
        goto LMFRHandled;
		break;

	case META_SETVIEWPORTORG:
	case META_SETVIEWPORTEXT:
		// Don't let the metafile reposition itself.
        goto LMFRHandled;
		break;

	case META_SELECTPALETTE:
	case META_REALIZEPALETTE:
	case META_ANIMATEPALETTE:
	case META_SETPALENTRIES:
	case META_RESIZEPALETTE:
		// We are disabling any metafile record which attempts a palette change.
        goto LMFRHandled;
		break;

	case META_ESCAPE:
		// The META_ESCAPE function returns false if it isn't supported, but
		// we don't care.  We also don't need to try to rotate it.
		PlayMetaFileRecord(hdc, lpHTable, lpMFR, nObj);
		goto LMFRHandled; // We _WILL_ return true!

    case META_ARC:
    case META_CHORD:
    case META_PIE:
		if (!(pemfp->qflip & qflipHorz) != !(pemfp->qflip & qflipVert))
			{
			SwapValNonDebug(Param(0), Param(2));
			SwapValNonDebug(Param(1), Param(3));
			}
		break;
		}

    // Metarecord rotation
#ifdef NOTYET // FUTURE alexmog (6/9/99) to be enabled if grafrot.cxx is used
    if (pemfp->pmrs->ang && FPlayRotatedMFR(hdc, lpHTable, lpMFR, nObj, pemfp))
        {
        fReturn = pemfp->fMFRSucceeded;
        goto LMFRHandled;
        }
#else
	Assert(FALSE);
#endif

	// Nonrotated metarecord handling (generally flipped/inverted cases)
    switch(lpMFR->rdFunction)
        {
        case META_STRETCHDIB:
        case META_STRETCHBLT:
        case META_DIBSTRETCHBLT:
        case META_SETDIBTODEV:
        case META_DIBBITBLT:
        case META_BITBLT:
	        if (pemfp->fPrint)	// NOTE: in Publisher, it is called always
	            {
	            SDIB FAR * lpsdib = NULL;
	            int iwDySrc;

	            if( lpMFR->rdFunction == META_STRETCHDIB )
	                iwDySrc = 3;
	            else if( lpMFR->rdFunction == META_STRETCHBLT ||
	                     lpMFR->rdFunction == META_DIBSTRETCHBLT )
	                iwDySrc = 2;
	            else if( lpMFR->rdFunction == META_SETDIBTODEV )
	                iwDySrc = 0;
	            else
	                break;

	            lpsdib = (SDIB FAR *)&Param(iwDySrc);
	            if ( (lpMFR->rdFunction == META_STRETCHDIB || 
	                  lpMFR->rdFunction == META_DIBSTRETCHBLT) &&
	                (FColorStretchDibHack(hdc, lpHTable, lpMFR, nObj, lpsdib))  )
	                {
	                fReturn = fTrue;
	                break;
	                }
	            }
            goto LDefault;

        case META_INTERSECTCLIPRECT:
            /* When printing on upside down pages of a greeting or tent
                card, the viewport extents will be negative.
                IntersectClipRect records will have to have their
                coordinates reversed (top <-> bottom, left <-> right)
                to be compatible with the current clip rgn. */
            if (pemfp->fFlipped && GetMapMode(hdc) == MM_ANISOTROPIC)
                {
                CPoint     dptVExt;

				AssertSz(pemfp->fPrint, "Currently this is only done while printing.");

                GetViewportExtEx(hdc, (SIZE *) &dptVExt);

                if (dptVExt.x < 0 || dptVExt.y < 0)
                    {
                    int     xdvLeft;
                    int     xdvRight;
                    int     ydvTop;
                    int     ydvBottom;

                    xdvLeft = Param(3);
                    ydvTop = Param(2);
                    xdvRight = Param(1);
                    ydvBottom = Param(0);

                    if (dptVExt.x < 0)
                        SwapValNonDebug(xdvLeft, xdvRight);
                    if (dptVExt.y < 0)
                        SwapValNonDebug(ydvTop, ydvBottom);

                    fReturn = (IntersectClipRect(hdc, xdvLeft, ydvTop, xdvRight, ydvBottom) != ERROR);
					AssertSz(fReturn, "Failed to intersect clip region");
                    break;
                    } /* Negative viewport extents */
                } /* Flipped printing and Anisotropic */
			else
				{
				if (FWindows9x() && pemfp->qflip)
					{
					// We'll handle META_INTERSECTCLIPRECT on Windows 95 for flipped images without passing it to the
					// PlayMetaFile, because on Windows 95 PlayMetaFile for META_INTERSECTCLIPRECT makes current clipping
					// rectangle empty for flipped images. Looks like Win 95 cannot intersect rectangles if one of rectangles
					// has left greater than right.
					// META_INTERSECTCLIPRECT widely used in Adobe Ilustrator. Many other windows metafiles (source unknown)
					// don't have META_INTERSECTCLIPRECT. SashaT
						
#ifdef DEBUG
					BLOCK
						{
						CPoint dptVExt;
						GetViewportExtEx(hdc, (SIZE *) &dptVExt);

						AssertSz(dptVExt.x < 0 || dptVExt.y < 0, "Implemented for flipped images only");

						RECT rcClip;
						int iRes = GetClipBox(hdc, &rcClip.rect);

						int iDummy;
						switch (iRes)
							{
							case ERROR:
								WarningSz(fFalse, "GetClipBox returned ERROR");
								break;
							case NULLREGION:
								iDummy = iRes;
								break;
							case SIMPLEREGION:
								iDummy = iRes;
								break;
							case COMPLEXREGION:
								iDummy = iRes;
								break;
							}
						}
#endif // DEBUG
					POINT rgpt[4];
					rgpt[0].x = Param(3);
					rgpt[0].y = Param(2);

					rgpt[1].x = Param(1);
					rgpt[1].y = Param(2);
					
					rgpt[2].x = Param(1);
					rgpt[2].y = Param(0);

					rgpt[3].x = Param(3);
					rgpt[3].y = Param(0);

					BeginPath(hdc);
					Polygon(hdc, rgpt, 4);  // Don't use Rectangle() because it will make empty clipping region.
					EndPath(hdc);
					return SelectClipPath(hdc, RGN_AND);
					}
				}

            /* Normal case, pass the clip record to PlayMetaFile */
            goto LDefault;

        case META_EXTTEXTOUT:
        	if (pemfp->fFlipped)
				{
				AssertSz(pemfp->fPrint, "Currently this is only done while printing.");
                fReturn = FMetaTextOutFlip(hdc, (WORD *)&Param(0),
                   lpMFR->rdSize - (sizeof(DWORD)+sizeof(WORD))/sizeof(WORD));
				AssertSz(fReturn, "FMetaTextOutFlip failed");
				}
            else
            	goto LDefault;
            break;  

#ifdef METAFILE_SQUAREEDGES
#include "grafrot.hxx"
        case META_CREATEPENINDIRECT:
            {
            // We create the Pen ourself to use the extendid pen fetures (square edges)
            DWORD Style = ((LOGPEN16*)lpMFR->rdParm)->lopnStyle;
			DWORD Width = ((LOGPEN16*)lpMFR->rdParm)->lopnWidth.x;
			COLORREF crColor = ((LOGPEN16*)lpMFR->rdParm)->lopnColor;

            if (Width == 0)
				Width = 1;	// Width must be at least one

			LOGBRUSH logBrush;
			logBrush.lbStyle = BS_SOLID;
			logBrush.lbColor = crColor;
			logBrush.lbHatch = 0;

			if ( (Width > 1) && (Style == PS_SOLID || Style == PS_INSIDEFRAME) )
				Style = Style | PS_GEOMETRIC|PS_ENDCAP_FLAT|PS_JOIN_MITER;

			HPEN hPen = ExtCreatePen(Style, Width, &logBrush, 0, NULL);

			fReturn = FALSE;
			if (hPen)
				{
				int i;
				for (i=0; i<nObj; i++)
					{
					if(lpHTable->objectHandle[i] == NULL)
						{
						lpHTable->objectHandle[i] = hPen;
						fReturn = TRUE;
						break;
						}
					}
				}
            break;
            }
#endif

LDefault:
        default:
			{
#ifdef DEBUG
			BOOL fResult = PlayMetaFileRecord(hdc, lpHTable, lpMFR, nObj);
			if (!fResult)
				{
				// One of the reasons it may fail: "Your file waiting to be printed was deleted" bug 3895
				// Sure, we don't have to assert on this.
				DWORD dErr = GetLastError();
				if (dErr) 
				    {
				    AssertSz(FALSE, "PlayMetaFileRecord() failed");
					// DPF("PlayMetaFileRecord() failed, Last Error == 0x%x\n", dErr);
			        }
				fReturn = fFalse;
				goto LMFRHandled;
				}
#else
			if (!PlayMetaFileRecord(hdc, lpHTable, lpMFR, nObj))
				{
				fReturn = fFalse;
				goto LMFRHandled;
				}
#endif
			}
            break;

        } /* switch */
        
LMFRHandled:

	// Metarecord cleanup handling
	switch (lpMFR->rdFunction)
		{
    case META_ARC:
    case META_CHORD:
    case META_PIE:
		if (!(pemfp->qflip & qflipHorz) != !(pemfp->qflip & qflipVert))
			{
			SwapValNonDebug(Param(0), Param(2));
			SwapValNonDebug(Param(1), Param(3));
			}
		break;
		}

	AssertSz(fReturn, "FStepMetaPrint failed");
    return fReturn;
} /* FStepMetaPrint */

/****************************************************************************\
 *                                                                          *
 * %%Function: CbDibHeader          %%Owner: DavidVe   %%Reviewed: 00/00/00 *
 *                                                                          *
 * Parameters:                                                              *
 *    lpbi - long pointer to a BITMAPINFOHEADER                             *
 *                                                                          *
 * Description: Determine the size of the DIB header + RGB data             *
 *              (the offset to the bitmap bits array)                       *
 *                                                                          *
 * Port to quill:                                                           *
 *    Owner: warrenb                Reviewed: 00/00/00                      *
\****************************************************************************/
int CbDibHeader(LPBITMAPINFOHEADER lpbi)
{
    return CbDibColorTable(lpbi) + sizeof(BITMAPINFOHEADER);    
}    /* CbDibHeader */

/****************************************************************************\
 *                                                                          *
 * %%Function: CbDibColorTable      %%Owner: DavidVe   %%Reviewed: 00/00/00 *
 *                                                                          *
 * Parameters:                                                              *
 *    lpbi - long pointer to a BITMAPINFOHEADER                             *
 *                                                                          *
 * Description: Determine the size of the DIB colortable                    *
 *              Does not work for OS/2 Dibs, i.e. BITMAPCOREHEADER          *
 *              The number of bitmap planes must be 1.                      *
 *              The number of Bits/Pixel must be 1, 4, 8 or 24              *
 *                                                                          *
 * Port to quill:                                                           *
 *    Owner: warrenb                Reviewed: 00/00/00                      *
\****************************************************************************/
int CbDibColorTable(LPBITMAPINFOHEADER lpbi)
{
    WORD cClr = 0;

    PubAssert(lpbi->biSize == sizeof(BITMAPINFOHEADER));
    if (lpbi->biPlanes != 1)
        {
        PubAssert(fFalse);
        return 0;
        }
        
    if (lpbi->biClrUsed == 0)
        {
        if (  lpbi->biBitCount == 1 || lpbi->biBitCount == 4 || lpbi->biBitCount == 8)
           cClr = (WORD) (1 << lpbi->biBitCount);
        else
           PubAssert(lpbi->biBitCount == 24);
        }
    else
        {
        PubAssert(lpbi->biClrUsed < (long)UINT_MAX);
        cClr = (WORD)lpbi->biClrUsed;
        }        
    return (cClr * cbRGBQUAD);
}    /* CbDibColorTable */

/****************************************************************************\
 *                                                                          *
 * %%Function: FPlayDibFlipped       %%Owner: DavidVe  %%Reviewed: 00/00/00 *
 *                                                                          *
 * Parameters:  HDC         hdc to hack StretchDib call to (printer DC)     *
 *              lpMFR       long pointer to metafile record                 *
 *                                                                          *
 * Description:                                                             *
 *       Function which takes a hdc and a lpMFR containing a METASTRETCHDIB *
 *       record and StretchDibBlts the DIB upside down by creating a copy   *
 *       of the DIB mirrored along both axes.                               *
 *                                                                          *
 *       Only works with 16 and 256 color dibs.  Monochrom dibs are         *
 *       supported by FMonoStretchDibHack.  24-bit dibs are not supported.  *
 *                                                                          *
 * Return:                                                                  *
 *      fTrue if Successful, fFalse otherwise                               *
 *                                                                          *
 * Port to quill:                                                           *
 *    Owner: warrenb                Reviewed: 00/00/00                      *
 *   . dependancy on large static bit-flipping lookup table removed         *
\****************************************************************************/
BOOL FPlayDibFlipped(HDC hdc, LPMETARECORD lpMFR, BOOL fFlipHorz, BOOL fFlipVert)
{
    LPBITMAPINFOHEADER lpbmi;
    BITMAPINFOHEADER   bmiSav;
    LPSDIB             lpsdib;
    HANDLE  volatile ghdibDst = NULL;
    HPSTR   hpBufSrc = NULL;
    HPSTR   hpBufDst = NULL;
    PubDebug(HPSTR   hpBufSrcBtm = NULL;)
    HPSTR   hpBufDstBtm = NULL;
    DWORD   cbSclnSrc, cbPixelSclnSrc, cbPaddingDst;
    DWORD   cbSclnDst, cbPixelSclnDst, cbPaddingSrc;
    DWORD   cbDibSrc, cbDibDst;
    int     dxmAdjust0;
    int     dxmAdjust1;
    int     dxmAdjust2;
    int     nScanLines;
    BOOL    f1Bit;     
    BOOL    f4Bit;
    BOOL    f8Bit;
    BOOL    f24Bit;
    BOOL    fSuccess = fFalse;
    unsigned int fuColorUse;    

	AssertEx(fFlipHorz || fFlipVert);

    PubAssert(hdc   != NULL);
    PubAssert(lpMFR != NULL);
    PubAssert(lpMFR->rdFunction == META_STRETCHDIB || lpMFR->rdFunction == META_DIBSTRETCHBLT);

    //Get pointer to BITMAPINFOHEADER, and sav a copy
    bmiSav = *(lpbmi = (LPBITMAPINFOHEADER)&(lpMFR->rdParm[10 + (lpMFR->rdFunction==META_STRETCHDIB)]));

    // Bail if compressed
    if(bmiSav.biCompression != BI_RGB)
        return fSuccess;

    // SDIB, beautiful SDIB
    lpsdib = (LPSDIB)&(lpMFR->rdParm[2 + (lpMFR->rdFunction==META_STRETCHDIB)]);
    PubAssert(lpsdib->xSrc>=0 && lpsdib->ySrc>=0 && lpsdib->dxSrc>=0 && lpsdib->dySrc>=0 &&
              lpsdib->xDst>=0 && lpsdib->yDst>=0);
    PubAssert(((LONG)(lpsdib->xSrc + lpsdib->dxSrc)) <= (LONG)lpbmi->biWidth);
    PubAssert(((LONG)(lpsdib->ySrc + lpsdib->dySrc)) <= (LONG)lpbmi->biHeight);

    // These value cached for optimization
    PubAssert(lpbmi->biPlanes == 1);
    f1Bit = f4Bit = f8Bit = f24Bit = dxmAdjust0 = dxmAdjust1 = dxmAdjust2 = fFalse;
    switch (bmiSav.biBitCount)
        {
        default:
            PubAssert(fFalse);
        case 8:
            f8Bit = fTrue;
            break;
        case 1:
            f1Bit = fTrue;
            dxmAdjust0 = lpsdib->xSrc % 8;
            dxmAdjust1 = (lpsdib->xSrc + lpsdib->dxSrc) % 8;
            dxmAdjust2 = (8 - dxmAdjust1) % 8;              
            break;
        case 4:
            f4Bit = fTrue;
            dxmAdjust0 = lpsdib->dxSrc % 2;                // start on odd nibble?
            dxmAdjust1 = (lpsdib->xSrc + lpsdib->dxSrc) % 2; // end on odd nibble?
            dxmAdjust2 = dxmAdjust1;
            break;
        case 24:
            f24Bit = fTrue;
            break;
        } // switch
        
    // Get ptr to the bits of the Src DIB 
    hpBufSrc = (HPSTR)LpAddLpCb((LPSTR)lpbmi, (DWORD)CbDibHeader(lpbmi));

    cbSclnSrc      = (((bmiSav.biWidth * bmiSav.biBitCount) + 31) >> 5) << 2;
    cbPixelSclnSrc = ( (bmiSav.biWidth * bmiSav.biBitCount) + 7) >> 3;
    cbPaddingSrc   = cbSclnSrc - cbPixelSclnSrc;
    cbDibSrc       = cbSclnSrc * bmiSav.biHeight;
    //Assert(cbDibSrc == bmiSav.biSizeImage); /* Bogus Assert, bmiSav.biSizeImage can be 0 */
    
    cbSclnDst      = ((((lpsdib->dxSrc + dxmAdjust0 + dxmAdjust2) * bmiSav.biBitCount) + 31) >> 5) << 2;
    cbPixelSclnDst = ( ((lpsdib->dxSrc + dxmAdjust0 + dxmAdjust2) * bmiSav.biBitCount) + 7) >> 3;
    cbPaddingDst   = cbSclnDst - cbPixelSclnDst;
    cbDibDst       = cbSclnDst * lpsdib->dySrc;
    //Assert(cbDibDst <= bmiSav.biSizeImage); /* Bogus Assert, bmiSav.biSizeImage can be 0 */
    
    lpbmi->biWidth  = lpsdib->dxSrc + dxmAdjust0;
    lpbmi->biHeight = lpsdib->dySrc;
    lpbmi->biSizeImage = 0; /* Valid for a non-compressed bmp */
    
    /* Make sure DIB is not compressed and allocate a global block to
    ** place the flipped DIB. (Clear room for optimization here)  Also, 
    ** we can allocate the block as moveable since it wont persist past
    ** this function (i.e. no chance for it to move)
    */
    ghdibDst = GhAllocLcbGrf(cbDibDst, GHND);
    if (!ghdibDst) 
        goto LCleanUp;
        
    if ((hpBufDst = (HPSTR) LpLockGh(ghdibDst)) == NULL)
        goto LCleanUp;
        
    PubDebug(hpBufSrcBtm = hpBufSrc + cbDibSrc - 1);
    hpBufDstBtm = hpBufDst + cbDibDst - 1;
    PubAssert( (DWORD)(hpBufDstBtm - hpBufDst + 1) <= LcbSizeGh(ghdibDst));

    {
    SCLN sclnMin = 0;
    SCLN sclnMac = lpsdib->dySrc;
    SCLN sclnCur = 0;
    HPSTR hpbSrc  = NULL;
    HPSTR hpbDst  = NULL;
    DWORD  cbPixelsCopied;
    int    cbRPixel = (f24Bit) ? 3 : 1;

    for (sclnCur = sclnMin ; sclnCur < sclnMac ; sclnCur++)
        {
        if (fFlipHorz)
        	{
	        for (hpbSrc = hpBufSrc + ( ((fFlipVert ? sclnCur : (sclnMac - 1 - sclnCur)) + (DWORD)lpsdib->ySrc) * (DWORD)cbSclnSrc)
	                                  + (((DWORD)lpsdib->xSrc * lpbmi->biBitCount) >> 3)
	            ,hpbDst = hpBufDstBtm - ((DWORD)sclnCur * cbSclnDst) - cbPaddingDst - cbRPixel + 1
	            ,cbPixelsCopied = 0L
	            ;cbPixelsCopied < cbPixelSclnDst 
	            ;hpbSrc += cbRPixel
	            ,hpbDst -= cbRPixel
	            ,cbPixelsCopied += cbRPixel
	            )
	            {
	            PubAssert(hpbSrc >= hpBufSrc);
	            PubAssert(hpbSrc <= hpBufSrcBtm);
	            PubAssert(hpbDst >= hpBufDst);
	            PubAssert(hpbDst <= hpBufDstBtm);
	            if (f1Bit)
	            {
	                BYTE bSrc;
	                bSrc=(BYTE) *hpbSrc;
	                *hpbDst = ((bSrc&0x01)<<7) | ((bSrc&0x02)<<5) | ((bSrc&0x04)<<3) | ((bSrc&0x08)<<1) |
	                          ((bSrc&0x10)>>1) | ((bSrc&0x20)>>3) | ((bSrc&0x40)>>5) | ((bSrc&0x80)>>7);
	            }
	            else if (f4Bit)
	            {
	                BYTE bSrc;
	                bSrc=(BYTE) *hpbSrc;
	                *hpbDst = ((bSrc&0x0F)<<4) | ((bSrc&0xF0)>>4);
	            }
	            else if (f8Bit)
	                *hpbDst = *hpbSrc;
	            else
	                {
	                PubAssert(f24Bit);
	                *((HPPIX24)hpbDst) = *((HPPIX24)hpbSrc);
	                }
            	} //for
	        PubAssert(cbPixelsCopied == cbPixelSclnDst);
			}
		else
			{
			CopyLpb(hpBufSrc + (fFlipVert ? (sclnMac - 1 - sclnCur) : sclnCur) * (DWORD)cbSclnSrc,
					hpBufDst + sclnCur * (DWORD)cbSclnDst, cbSclnSrc);
			}
		} //for
	}

    fuColorUse=lpMFR->rdParm[2];
    if (fuColorUse!=DIB_PAL_COLORS && fuColorUse!=DIB_RGB_COLORS) 
        fuColorUse=DIB_RGB_COLORS;

#ifdef DEBUG
	BLOCK
		{
		CPoint dptdVPSav;
    	GetViewportExtEx(hdc, (LPSIZE)&dptdVPSav);
		AssertSz(dptdVPSav.x > 0, "BLTing to negative extents");
		AssertSz(dptdVPSav.y > 0, "BLTing to negative extents");
		}
#endif // DEBUG

    nScanLines=StretchDIBits(hdc,
                             lpsdib->xDst , lpsdib->yDst ,
                             lpsdib->dxDst, lpsdib->dyDst,
                             0 + dxmAdjust2, 0,
                             lpsdib->dxSrc, lpsdib->dySrc,
                             (LPBYTE)hpBufDst,
                             (LPBITMAPINFO)lpbmi,   
                             fuColorUse, 
                             *((DWORD FAR *)&lpMFR->rdParm[0])); 
                             
    fSuccess= (nScanLines == lpsdib->dySrc);

LCleanUp:
    if (hpBufDst != NULL)
        UnlockGh(ghdibDst);
    if (ghdibDst != NULL)
        {
        PubAssert(!FLockedGh(ghdibDst));
        FreeGh(ghdibDst);
        ghdibDst = NULL;
        }
    *lpbmi = bmiSav;        
    return fSuccess;
} /* FPlayDibFlipped */

/****************************************************************************\
 *                                                                          *
 * %%Function: FColorStretchDibHack  %%Owner: DavidVe  %%Reviewed: 00/00/00 *
 *                                                                          *
 * Parameters:  HDC         hdc to hack StretchDib call to (printer DC)     *
 *              lpHTable    Handle table                                    *
 *              lpMFR       long pointer to metafile record                 *
 *              nObj        Number of active objects                        *
 *              lpsdib      long pointer to struct ( in MFR!!) containing   *
 *                          parameters to StretchDIb (except for RasterOp)  *
 *                          in reverse order                                *
 *                                                                          *
 * Description:                                                             *
 *      Function to work around some driver bugs that occurs                * 
 *      when StretchBlting a DIB to a DC which has had its                  *
 *      ViewPort flipped upside down (i.e. the ViewPort                     *
 *      Extents are negative).                                              *
 *                                                                          *
 *      If the dib is color and is going onto an upside down                *
 *      page we first set the VP RSU and try to flip the                    *
 *      DIB directly.                                                       *
 *                                                                          *
 *      If we fail to flip it directly we create a                          *
 *      compatible Mem DC. We then play the metafile record                 *   
 *      into this compatible DC (right side up) optimizing                  *
 *      in such a way such that only the portion of the DIB                 *
 *      falling in the clipping rect of the printer DC is                   *
 *      actually played into the Mem DC.  This allows the                   *
 *      Mem DC to be as small as possible.                                  *
 *                                                                          *
 *      We then StretchBlt the DDB in the Mem DC (it's a                    *
 *      DDB since we used the Mem DC is compatible with the                 *
 *      DC we ultimately want to go to) into the printer                    *
 *      DC, flipping it in the process such that it is                      *
 *      upside-down on the printer DC.                                      *
 *                                                                          *
 * Return:                                                                  *
 *      fTrue if Successful, fFalse otherwise                               *
 *                                                                          *
 * Port to quill:                                                           *
 *    Owner: warrenb                Reviewed: 00/00/00                      *
\****************************************************************************/
BOOL FColorStretchDibHack(HDC               hdc,
                          LPHANDLETABLE     lpHTable,
                          LPMETARECORD      lpMFR,
                          int               nObj, 
                          LPSDIB            lpsdib)
{
    BOOL  fSuccess = fFalse;
    DWORD dwRopOrig;
    SDIB  sdibOrig; 
    CPoint    ptdWinSav, ptdVPSav;
    CPoint    dptdWinSav, dptdVPSav;

    // Sav Away Some Original Info    
    dwRopOrig = *((DWORD FAR *)&lpMFR->rdParm[0]);   //Store Original Rop
    sdibOrig  = *lpsdib;                             //Store Original SDIB
    GetViewportOrgEx(hdc, (LPPOINT)&ptdVPSav);
    GetViewportExtEx(hdc, (LPSIZE)&dptdVPSav);
    GetWindowOrgEx(hdc, (LPPOINT)&ptdWinSav);    
    GetWindowExtEx(hdc, (LPSIZE)&dptdWinSav);    

	// Due to HP print driver bugs, we should never BLT when the extents
	// are negative.  Rather than BLT to negative extents, flip the image
	// manually and draw it into positive extents.
	//
	// DrawPicInRc didn't know that the metafile would contain a dib, so it
	// has already set the extents.  One or both of the horizontal and vertical
	// extents may be negative.
	//
	// Keep track of which extents are negative and then accomplish the
	// effect by manually flipping the bits of the dib.
	BOOL fFlipHorz = dptdVPSav.x < 0;
	BOOL fFlipVert = dptdVPSav.y < 0;

	if (!fFlipHorz && !fFlipVert)	// No flipping required, don't waste time looping...
		return fFalse;

    // Set VPort RSU
    SetViewportExtEx(hdc, fFlipHorz ? -dptdVPSav.x : dptdVPSav.x,
    					  fFlipVert ? -dptdVPSav.y : dptdVPSav.y, (LPSIZE)NULL); 
    SetViewportOrgEx(hdc, ptdVPSav.x + (fFlipHorz ? dptdVPSav.x : 0),
    					  ptdVPSav.y + (fFlipVert ? dptdVPSav.y : 0), (LPPOINT)NULL);

    // Try flipping the DIB directly
    lpsdib->xDst  = (int)(2 * ptdWinSav.x + dptdWinSav.x - lpsdib->xDst - lpsdib->dxDst);
    lpsdib->yDst  = (int)(2 * ptdWinSav.y + dptdWinSav.y - lpsdib->yDst - lpsdib->dyDst);

    fSuccess = FPlayDibFlipped(hdc, lpMFR, fFlipHorz, fFlipVert);

    SetViewportOrgEx(hdc,ptdVPSav.x, ptdVPSav.y, (LPPOINT)NULL);  //Restore VPort Orig
    SetViewportExtEx(hdc,dptdVPSav.x,dptdVPSav.y, (LPSIZE)NULL);  //Restore VPort Ext
    *((SDIB FAR *)lpsdib) = sdibOrig;                               // Restore Info, this really isn't necessary, but what the hey
    *((DWORD FAR *)&lpMFR->rdParm[0]) = dwRopOrig;                  // Restore Rop
    return fSuccess;
} /* FColorStretchDibHack */

/****************************************************************************
    %%Function:ExtTextOutFlip2        %%Owner:edr     %%Reviewed:00/00/00

    Special-purpose ExtTextOut for drawing fonts onto compatible DC (for
    upside-down pages.)  We have to do it this way because many printer
    drivers won't allow raster fonts to be drawn on compatible DCs.
    This does work for screen-compatible DC's, so we draw the text in a
    screen-compatible DC monochrome, then BLT the bitmap to the
    printer-compatible DC.

    This allows users to get Bitstream fonts to come out upside down.

    Note: vppjp->dptpFlipFont contains the size of the compatible bitmap.
                                                                           
    Port to quill:                                                         
     Owner: warrenb                Reviewed: 00/00/00                       

    CAUTION: this function is not Unicode
    
****************************************************************************/
BOOL ExtTextOutFlip2(   HDC hdc, 
                        int x, 
                        int y, 
                        UINT eto, 
                        const RECT FAR *lprcp, 
                        LPCSTR lpch, 
                        UINT cch, 
                        int FAR *lpdxp, 
                        BOOL fSelectFont)  
{
    TEXTMETRIC  tm;
    LOGFONT     lf;
    HFONT       hfont = NULL;
    HFONT       hfontPrinter;
    BOOL        fDCSaved;

    PubAssert(lprcp != NULL);
    GetTextMetrics(hdc, &tm);

    // wlb... code for rasterised printer fonts removed...
    
    fDCSaved = SaveDC(hdc);
      
    if (tm.tmPitchAndFamily & TMPF_VECTOR)
        {
        hfontPrinter = (HFONT)SelectObject(hdc, GetStockObject(DEVICE_DEFAULT_FONT));
            
        if (hfontPrinter != NULL)
            {
            GetObject(hfontPrinter, sizeof(LOGFONT),(LPSTR)(LOGFONT FAR *)&lf);

            lf.lfOrientation = lf.lfEscapement = 1800;

            if ((hfont = CreateFontIndirect((LOGFONT FAR *)&lf)) != NULL)
                SelectObject(hdc, hfont);
            else 
                SelectObject(hdc, hfontPrinter);
            }

        /* On some printer drivers, the opaque box is not
            rotated with the text.  If we ever print using
            ETO_OPAQUE we will have to work around that. */
        /* removed the assert for print pass, we should investigate
           whether rotating a ET_OPAQUE extetextout call has any
           adverse side-affect on any printers - davidve - 4/6/93 
        Assert(!(eto & ETO_OPAQUE));
        */
        ::ExtTextOutA(hdc, x, y, eto, (RECT FAR *) lprcp, lpch, cch, lpdxp);

        if (hfontPrinter != NULL && hfont != NULL)
            {
            SelectObject(hdc, hfontPrinter);
            if (hfont != NULL)
                DeleteObject(hfont);
            }
        }
    /* Else: use FlipFont code -- currently the memory DC isn't
        set up to do this. */

    if (fDCSaved)
        PubDoAssert(RestoreDC(hdc, -1));

    return fTrue;
} /* ExtTextOutFlip2 */
           
// ---------------------------------------------------------------------------
// %%Function: FMetaTextOutFlip         %%Owner: davidve  %%Reviewed: 00/00/00
// 
// Parameters:
//  hdc     -   
//  pParam  -   Parameter list from METARECORD struct
//  cwParam -   Size in words of param list
//  
// Returns:
//  fTrue is successful
//  fFalse otherwise
//  
// Description:
//  Translate a metafile ExtTextOut record to a call to our upside-down
//  text printing routine.
//
//  You'll grow to love this code.
//
//                                                                          
// Port to quill:                                                           
//    Owner: warrenb                Reviewed: 00/00/00                      
// ---------------------------------------------------------------------------
BOOL FMetaTextOutFlip(  HDC hdc, 
                        WORD * pParam, 
                        DWORD cwParam)
{
    // CAUTION alexmog (6/3/99): this function is not Unicode.
    //                          If we end up using it, we'll probably need a unicode
    //                          version as well.
    
    /*
    Here is the format of the parameter list:
    Index   Content
        0   y
        1   x
        2   cch
        3   options: eto flags
        4   if options != 0, contains a RECT, otherwise, nonexistent
    4 or 8  String
    4 or 8 + ((cch + 1)>>1)     rgdxp (optional)
    */

    int     x;
    int     y;
    int     cch;
    UINT    eto;
    RC16   *prcp16=NULL;
    RECT    rcp;
    LPCSTR  pch;
    int     rgdxp[256];
    int    *pdxp;
    DWORD   cw;

    y = (int)(short)pParam[0];
    x = (int)(short)pParam[1];
    cch = (int)(WORD)pParam[2];
    eto = (int)((WORD)pParam[3] & ETO_CLIPPED) | ((WORD)pParam[3] & ETO_OPAQUE);
    cw = 4;
    if (pParam[3])
        {
        prcp16 = (RC16 FAR *)&pParam[4];
        cw += sizeof(RC16) / sizeof(WORD);
        }

    /* At this point, cw is the index to the string */
    pch = (LPCSTR)&pParam[cw];

    cw += (cch + 1)>>1;
    /* At this point, cw is the index to the array of character widths */
    /* Assert that there are either 0 or cch character widths */
    PubAssert(cw == cwParam || cw + cch == cwParam);
    if (cw >= cwParam)
        pdxp = NULL;
    else
        {
        int idxp;
        /* we have to make a copy of the array of character widths
           padded to 32 bit */
        PubAssert(cch <= 256);
        cch = min(256, cch);
        pdxp = rgdxp;        
        for(idxp = 0; idxp < cch; idxp++)
            pdxp[idxp] = (int)(short)pParam[cw + idxp];
        }

    if (prcp16)
        {
        rcp.left   = (int)prcp16->xLeft;
        rcp.top    = (int)prcp16->yTop;
        rcp.right  = (int)prcp16->xRight;
        rcp.bottom = (int)prcp16->yBottom;
        }
    else
        {
        /* The metafile record didn't contain a bounding rect, so fake
            one */
        SIZE    sizeWExt;
        SIZE    sizeTExt;
        UINT    ta;
        TEXTMETRIC  tm = {0};

        GetTextExtentPointA(hdc, pch, cch, &sizeTExt);
        GetWindowExtEx(hdc, &sizeWExt);
        ta = GetTextAlign(hdc);
        if ((ta & (TA_BASELINE | TA_BOTTOM | TA_TOP)) == TA_BASELINE)
            {
            GetTextMetrics(hdc, &tm);
            }
        if (sizeWExt.cy < 0)
            {
            sizeTExt.cy = -sizeTExt.cy;
            tm.tmAscent = -tm.tmAscent;
            tm.tmDescent = -tm.tmDescent;
            }
        switch (ta & (TA_BASELINE | TA_BOTTOM | TA_TOP))
            {
        case TA_TOP:
            rcp.top = y;
            rcp.bottom = y + sizeTExt.cy;
            break;
        case TA_BOTTOM:
            rcp.bottom = y;
            rcp.top = y - sizeTExt.cy;
            break;
        case TA_BASELINE:
            rcp.top = y - tm.tmAscent;
            rcp.bottom = y + tm.tmDescent;
            break;
            } /* switch vertical alignment */
        if (pdxp != NULL)
            {
            int    idxp;

            for (sizeTExt.cx = 0, idxp = 0; idxp < cch; idxp++)
                sizeTExt.cx += pdxp[idxp];
            }
        if (sizeWExt.cx < 0)
            {
            sizeTExt.cx = -sizeTExt.cy;
            AssertSz(0, "Negative X Window Extent. This is wierd, but not fatal.");
            }
        switch (ta & (TA_LEFT | TA_CENTER | TA_RIGHT))
            {
        case TA_LEFT:
            rcp.left = x;
            rcp.right = x + sizeTExt.cx;
            break;
        case TA_RIGHT:
            rcp.right = x;
            rcp.left = x - sizeTExt.cx;
            break;
        case TA_CENTER:
            rcp.left = x - sizeTExt.cx/2;
            rcp.right = rcp.left + sizeTExt.cx;
            break;
            } /* switch horizontal alignment */
        }

    return ExtTextOutFlip2(hdc, x, y, eto, &rcp, pch, cch, pdxp, fTrue);

} /* FMetaTextOutFlip */

//
// Init EMFP structure
//
void InitEmfp(EMFP *pemfp, BOOL fFlipped, MRS *pmrs, BOOL fPrint, long qflip)
{
	pemfp->lcNumRecords = 0;
	pemfp->fFlipped = fFlipped;
	pemfp->fMFRSucceeded = fTrue;
	pemfp->pmrs = pmrs;
	pemfp->fPrint = fPrint;
	pemfp->qflip = qflip;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\display\region.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1997-2000
//
//  File:       region.cxx
//
//  Contents:   Container class to operate regions in both Windows and local
//              representation.
//
//  Classes:    CRegion
//
//  Notes:      The purpose of this class is to avoid, whenever possible,
//              the expensive HRGN conversions from/to CRegion2.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DISPTRANSFORM_HXX_
#define X_DISPTRANSFORM_HXX_
#include "disptransform.hxx"
#endif

MtDefine(CRegion, DisplayTree, "CRegion");


//+---------------------------------------------------------------------------
//
//  Member:     CRegion::Intersect
//              
//  Synopsis:   Intersect this region with the given HRGN.
//              
//  Arguments:  hrgn        HRGN to intersect
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CRegion::Intersect(HRGN hrgn)
{
    Assert(hrgn != NULL);

    if (_rgn2.IsEmpty())
        return;
    
    RidHRGN();
    
    CRegion2 tmp;
    tmp.ConvertFromWindows(hrgn);
    _rgn2.Intersect(tmp);
}


//+---------------------------------------------------------------------------
//
//  Member:     CRegion::Union
//              
//  Synopsis:   Union this region with the given rect.
//              
//  Arguments:  rc      rect to union
//              
//  Notes:      
//              
//----------------------------------------------------------------------------
void
CRegion::Union(const RECT& rc)
{
    RidHRGN();
    CRegion2 tmpRgn(rc);
    _rgn2.Union(tmpRgn);
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegion::Union
//              
//  Synopsis:   Union this region with the given HRGN.
//              
//  Arguments:  hrgn        HRGN to union
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CRegion::Union(HRGN hrgn)
{
    RidHRGN();
    CRegion2 tmp;
    tmp.ConvertFromWindows(hrgn);
    _rgn2.Union(tmp);
}


//+---------------------------------------------------------------------------
//
//  Member:     CRegion::Subtract
//              
//  Synopsis:   Subtract the given rect from this region.
//              
//  Arguments:  rc      rect to subtract
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CRegion::Subtract(const RECT& rc)
{
    RidHRGN();
    CRegion2 tmp(rc);
    _rgn2.Subtract(tmp);
}


//+---------------------------------------------------------------------------
//
//  Member:     CRegion::Subtract
//              
//  Synopsis:   Subtract the given HRGN from this region.
//              
//  Arguments:  hrgn        HRGN to subtract
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CRegion::Subtract(HRGN hrgn)
{
    RidHRGN();
    CRegion2 tmp;
    tmp.ConvertFromWindows(hrgn);
    _rgn2.Subtract(tmp);
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegion::BoundsInside
//              
//  Synopsis:   Determine whether this region is totally contained in given rectangle
//              
//  Arguments:  rc      given rectangle
//              
//  Returns:    TRUE if this region is totally contained in given rectangle
//              
//----------------------------------------------------------------------------
BOOL
CRegion::BoundsInside(const RECT& rc) const
{
    CRect rcBounds;
    _rgn2.GetBoundingRect(rcBounds);
    return ((CRect&)rc).Contains(rcBounds);
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegion::BoundsIntersects
//              
//  Synopsis:   Determine whether this region contains points in given rectangle
//              
//  Arguments:  rc      given rectangle
//              
//  Returns:    TRUE if this region's bounding rectangle contains one or more points of given rectangle
//              
//----------------------------------------------------------------------------
BOOL
CRegion::BoundsIntersects(const RECT& rc) const
{
    CRect rcBounds;
    _rgn2.GetBoundingRect(rcBounds);
    return rcBounds.Intersects(rc);
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegion::ResultOfSubtract
//              
//  Synopsis:   This method returns a quick estimate of the type of region that
//              will be returned if the given region is subtracted from this
//              one.
//              
//  Arguments:  rgnSubtract     region to be subtracted
//              
//  Returns:    SR_RECTANGLE    if the result would be a rectangle
//              SR_REGION       if the result would be a complex region
//              SR_UNKNOWN      if the result cannot be determined without
//                              invoking the more expensive Subtract method
//                              
//  Notes:      
//              
//----------------------------------------------------------------------------

CRegion::SUBTRACTRESULT
CRegion::ResultOfSubtract(const CRegion& rgnSubtract) const
{
    CRect rcThis, rcThat;
                _rgn2.GetBoundingRect(rcThis);
    rgnSubtract._rgn2.GetBoundingRect(rcThat);

    if (IsComplex())
    {
        if (rgnSubtract.IsComplex())
            return SUB_UNKNOWN;
        return (rcThat.Contains(rcThis))
            ? SUB_EMPTY
            : SUB_UNKNOWN;
    }
    
    if (rgnSubtract.IsComplex())
    {
        return (rcThis.Intersects(rcThat))
            ? SUB_UNKNOWN
            : SUB_RECTANGLE;
    }

    // subtracted rectangle must contain at least two corners of this
    // rectangle to yield a rectangular result.  If it contains 4, the
    // result will be empty.
    int cContainedCorners =
        rcThat.CountContainedCorners(rcThis);
    switch (cContainedCorners)
    {
    case -1:
        return SUB_RECTANGLE;   // rectangles do not intersect
    case 0:
        return SUB_REGION;      // produces rectangle with a hole in it
    case 1:
        return SUB_REGION;      // produces a rectangle with notch out of a corner
    case 2:
        return SUB_RECTANGLE;   // produces a smaller rectangle
    case 4:
        return SUB_EMPTY;       // rectangles completely overlap
    default:
        Assert(FALSE);          // 3 is an impossible result
    }
    return SUB_REGION;
}


//+---------------------------------------------------------------------------
//
//  Member:     CRegion::Transform
//
//  Synopsis:   Transform region
//
//----------------------------------------------------------------------------

void 
CRegion::Transform(const CWorldTransform *pTransform, BOOL fRoundOut)
{
    // NOTE:  In some (rare) scenarios, rotating a region must
    //        produce a polygon. In most cases, we'll want to 
    //        get a bounding rectangle instead (for performance reasons,
    //        or just to make our life easier).
    //        If these two different behaviors are actually 
    //        desired, we need to use different transformation methods,
    //        or maybe a flag.
    

    // speed optimization for offset-only matrix
    if (pTransform->IsOffsetOnly())
    {
        Offset(pTransform->GetOffsetOnly());
        return;
    }

    if (pTransform->FTransforms())
    {

        // Apply transform to the region
        // Note: We can only transform complex rectangle regions only
        // Once the region is transformed it will be of a polygon type
        // and can not be transformed again.

        RidHRGN();
        _rgn2.Transform(pTransform, fRoundOut);
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CRegion::Untransform
//
//  Synopsis:   Untransform region
//
//----------------------------------------------------------------------------
void 
CRegion::Untransform(const CWorldTransform *pTransform)
{
    // apply the reverse transformation
    //REVIEW dmitryt: we do have a reverse matrix in CWorldTransform,
    //                I guess we could optimize things here not calculating a new one..
    //          To Do: use cached reverse matrix from CWorldTransform.
    
    Assert(pTransform);
    
    // speed optimization in case we only have an offset
    if (pTransform->IsOffsetOnly())
    {
        Offset(-pTransform->GetOffsetOnly());
        return;
    }
   
    CWorldTransform transformReverse(pTransform);
    transformReverse.Reverse();
    Transform(&transformReverse, TRUE);
}


#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Member:     DumpRegion
//
//  Synopsis:   debugging
//
//----------------------------------------------------------------------------

void 
DumpRegion(const CRegion& rgn)
{
    rgn.Dump();
}

void
CRegion::Dump() const
{
    DumpRegion(_rgn2);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\display\disptransform.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       disptransform.cxx
//
//  Contents:   
//
//  Classes:    
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DISPTRANSFORM_HXX_
#define X_DISPTRANSFORM_HXX_
#include "disptransform.hxx"
#endif


MtDefine(CDispTransform, DisplayTree, "CDispTransform")
MtDefine(CDispClipTransform, DisplayTree, "CDispClipTransform")

void
CDispClipTransform::TransformRoundIn(const CRect& rcSource, CRect* prcDest) const
{
    if (_transform.IsOffsetOnly())
    {
        *prcDest = rcSource;
        prcDest->OffsetRect(_transform.GetOffsetOnly());
    }
    else
    {
        // note: FALSE for fRoundOut doesn't really mean "round in". 
        //       It means "round to closest integer", which is the default behavior.
        _transform.GetBoundingRectAfterTransform(&rcSource, prcDest, FALSE);
    }
}

void
CDispClipTransform::UntransformRoundOut(const CRect& rcSource, CRect* prcDest) const
{
    if (_transform.IsOffsetOnly())
    {
        *prcDest = rcSource;
        prcDest->OffsetRect(-_transform.GetOffsetOnly());
    }
    else
    {
        // Note: it is important to round clip rectangle out. With zoom > 100%
        //       clip rectangle is represented in fractional pixels in content coordinates.
        //       Normal rounding doesn't do the right thing in this case: if clip rectangle
        //       includes 1/3 of a pixel at 600% zoom, we still need to render the pixel.
        //       If normal rounding is applied, the 1/3 is truncated, the pixel is not rendered,
        //       and there is a 2-pixel gap in the image.
        _transform.GetBoundingRectAfterInverseTransform(&rcSource, prcDest, TRUE);        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\display\float2int.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       float2int.cxx
//
//  Contents:   routines to accelerate float/double -> int conversion
//
//
// The float- (or double-) -to-int conversion does not look like a big
// problem. However it hides some underwater rocks that required following
// introduction.

// The standard C++ double-to-int conversion is often unacceptable
// because of two reasons:
//
// - it works slow (much slower than floating point addition and multiplication);
// - it makes so-called "chopping" conversion, that is irregular.

// The (int)x or int(x), where x is floating-point expression, is transformed
// by MS C++ compilers to the call to service routine
//      int _ftol(double)
// that provides "nearest-to-zero" rounding conversion:
//      int(2.999) == 2;     int(-2.999) == -2;
//      int(3.000) == 3;     int(-3.000) == -3;
//      int(3.001) == 3;     int(-3.001) == -3;
// and so on.
// This irregularity, being used for graphics, eventually distorts images.
// The rounding-to-near can be obtained as
//      int Round1(double d) { return d < 0 ? int(d-.5) : int(d+.5); }
// or 
//      int Round2(double d) { return int(floor(d+.5)); }
//
// Note: Round1() also is "a little" irregular: the positive and negative
// half-integers are rounded in oppose directions (out-of-zero).
//      Round1(-1.501) == -2;
//      Rounf1(-1.500) == -2; <-------- rounded down
//      Rounf1(-1.499) == -1;
//      ..........
//      Round1( 1.499) ==  1;
//      Rounf1( 1.500) ==  2; <-------- rounded up
//      Rounf1( 1.500) ==  2;
// The attempts to invent regular Round1-like expression, say
//      int Round3(double d) { return d < 0 ? -int(.5-d) : int(d+.5); }
// give nothing - one can ensure in it by careful thinking. So Round2() routine
// is preferrable, in spite of it is approxinately thrice slower than int(),
// which, in turn, is 20 times slower than processor actually can do it.
//
// The typical floating point processor (486, Pentiums and others) have four
// rounding modes:
//
// near: round to the nearest integer
// down: round to nearest integer less or equal than origin
// up:   round to nearest integer greater or equal than origin
// chop: round to nearest integer toward zero
//
// Rounding takes effect each time when data are moved from fp register to
// memory - not only when converting to integer, but also when storing double
// or float value (internal 80-bit representation is rounded to 64-bit double
// or 32-bit float value).
// In Windows (likely in every OS) the default processor state is rounding-near
// mode. What actually int() do is:
// - change processor state to chop mode for a moment,
// - convert-to-int-and-store value to memory, and then
// - restore processor mode.
// The mode switch operation brakes Pentium conveyers and therefore
// is slow, and that is the reason why int() works slow.
//
// "down" mode works like floor(), "up" - like ceil().
// WARNING: the "near" mode looks good - but it is irregular!
// The matter is it rounds half-integers to nearest even number:
//  proc_near(1.499) == 1
//  proc_near(1.500) == 2   <------ rounded up
//  proc_near(1.501) == 2
//  .........
//  proc_near(2.499) == 2
//  proc_near(2.500) == 2   <------ rounded down
//  proc_near(2.501) == 3
//  .........
//  proc_near(3.499) == 3
//  proc_near(3.500) == 4   <------ rounded up
//  proc_near(3.501) == 4

// Such manner is targeted to average error balancing, but in graphics
// it can cause images wriggling.


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FLOAT2INT_HXX_
#define X_FLOAT2INT_HXX_
#include "float2int.hxx"
#endif

#ifdef _M_IX86

                                        // corresponding values in _control87
//Rounding
#define F2I_ROUNDING_NEAR        0x000  //_RC_NEAR 0x00000000
#define F2I_ROUNDING_DOWN        0x400  //_RC_DOWN 0x00000100
#define F2I_ROUNDING_UP          0x800  //_RC_UP   0x00000200
#define F2I_ROUNDING_CHOP        0xC00  //_RC_CHOP 0x00000300
#define F2I_ROUNDING_MASK        0xC00  //_MCW_RC  0x00000300

// the following definitions reserved for future needs
//Precision control
#define F2I_PRECISION_24         0x000  //_PC_24  0x00020000
#define F2I_PRECISION_53         0x200  //_PC_53  0x00010000
#define F2I_PRECISION_64         0x300  //_PC_64  0x00000000
#define F2I_PRECISION_MASK       0x300  //_MCW_PC 0x00030000 

//Interrupt exception
#define F2I_EXCEPTION_INVALID    0x001  //_EM_INVALID    0x00000010
#define F2I_EXCEPTION_DENORMAL   0x002  //_EM_DENORMAL   0x00080000
#define F2I_EXCEPTION_ZERODIVIDE 0x004  //_EM_ZERODIVIDE 0x00000008
#define F2I_EXCEPTION_OVERFLOW   0x008  //_EM_OVERFLOW   0x00000004
#define F2I_EXCEPTION_UNDERFLOW  0x010  //_EM_UNDERFLOW  0x00000002
#define F2I_EXCEPTION_INEXACT    0x020  //_EM_INEXACT    0x00000001
#define F2I_EXCEPTION_MASK       0x03F  //_MCW_EM        0x0008001F


/* reserved universal version
CRoundingMode::CRoundingMode(int mode)
{
    unsigned cw;
    _asm fstcw cw;
    _cw_saved = cw & F2I_ROUNDING_MASK;
    cw = cw & ~F2I_ROUNDING_MASK | mode & F2I_ROUNDING_MASK;
    _asm fldcw cw;
}

CRoundingMode::~CRoundingMode()
{
    unsigned cw;
    _asm fstcw cw;
    cw = cw & ~F2I_ROUNDING_MASK | _cw_saved;
    _asm fldcw cw;
}*/

CF2I_Flow::CF2I_Flow()
{
    unsigned cw;
    _asm fstcw cw;
    _cw_saved = cw & F2I_WORK_MASK;
    cw = cw & ~F2I_WORK_MASK | F2I_WORK_DOWN;
    _asm fldcw cw;
}

CF2I_Flow::~CF2I_Flow()
{
    unsigned cw;
    _asm fstcw cw;
    cw = cw & ~F2I_WORK_MASK | _cw_saved;
#if WINDOWS_MISSING_CW_DEFENCE == 1
    _asm fclex;
#endif //WINDOWS_MISSING_CW_DEFENCE
    _asm fldcw cw;
}

#if F2I_USE_INLINE_ASSEMBLER == 0 || DBG == 1
_declspec(naked) int _stdcall CF2I_Quick::_IntFloor(double d)
{
    _asm
    {
        sub esp, 8              // make room in stack
        fstcw [esp+4]           // store processor control word
        fld qword ptr [esp+12]  // get d
        mov eax, [esp+4]        // pcw to eax
        and eax,~F2I_WORK_MASK  // ax &= ~F2I_WORK_MASK
        or eax,F2I_WORK_DOWN    // ax |= F2I_WORK_DOWN
        mov [esp], eax          // put new pcw to memory
        fldcw [esp]             // and load it into pcw (this switches processor to proper rounding mode)
        fistp dword ptr [esp]   // convert d to integer and store in memory
#if WINDOWS_MISSING_CW_DEFENCE == 1
        fclex                   // clear exception flags
#endif //WINDOWS_MISSING_CW_DEFENCE
        fldcw [esp+4]           // wait for result and restore processor mode
        mov eax,[esp]           // result to eax
        add esp,8               // clear stack
        ret 8                   // return to caller using _stdcall convention
    }
} 

_declspec(naked) int _stdcall CF2I_Quick::_IntCeil(double d)
{
    _asm
    {
        sub esp, 8              // make room in stack
        fstcw [esp+4]           // store processor control word
        fld qword ptr [esp+12]  // get d
        mov eax, [esp+4]        // pcw to eax
        and eax,~F2I_WORK_MASK  // ax &= ~F2I_WORK_MASK
        or eax,F2I_WORK_UP      // ax |= F2I_WORK_UP
        mov [esp], eax          // put new pcw to memory
        fldcw [esp]             // and load it into pcw (this switches processor to proper rounding mode)
        fistp dword ptr [esp]   // convert d to integer and store in memory
#if WINDOWS_MISSING_CW_DEFENCE == 1
        fclex                   // clear exception flags
#endif //WINDOWS_MISSING_CW_DEFENCE
        fldcw [esp+4]           // wait for result and restore processor mode
        mov eax,[esp]           // result to eax
        add esp,8               // clear stack
        ret 8                   // return to caller using _stdcall convention
    }
} 

#if DBG == 0
_declspec(naked) int _stdcall CF2I_Flow::_IntOf(double d)
{
    _asm
    {
        fld qword ptr [esp+4]   // get d
        fistp dword ptr [esp+4] // convert d to integer and store in memory
        wait                    // wait for result
        mov eax, [esp+4]        // result to eax
        ret 8                   // return to caller using _stdcall convention
    }
}

#else //DBG == 1

int _stdcall CF2I_Flow::_IntOf(double d)
{
    unsigned cw;
    _asm fstcw cw;
    AssertSz((cw & F2I_WORK_MASK) == F2I_WORK_DOWN, "Wrong processor state");
    // This assertion can appear if F2I_FLOW was not properly declared
    
    _asm fld d      // get d
    int r;
    _asm fistp r    // convert d to integer and store in memory
    _asm wait       // wait for r
    return r;
} 
#endif //DBG
#endif //F2I_NO_INLINE_ASSEMBLER

#endif //_M_IX86
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\display\overlay.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       overlay.cxx
//
//  Contents:   Overlay processing for disp root.
//
//  Classes:    CDispRoot (overlay methods), COverlaySink
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DISPROOT_HXX_
#define X_DISPROOT_HXX_
#include "disproot.hxx"
#endif

#ifndef X_DEBUGPAINT_HXX_
#define X_DEBUGPAINT_HXX_
#include "debugpaint.hxx"
#endif

#ifndef X_DISPCLIENT_HXX_
#define X_DISPCLIENT_HXX_
#include "dispclient.hxx"
#endif

#ifndef X_DISPINFO_HXX_
#define X_DISPINFO_HXX_
#include "dispinfo.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

MtDefine(COverlaySink, DisplayTree, "COverlaySink")

// how frequently to sample window position (in samples per second)
#define OVERLAY_POLLING_RATE    (30)

//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::AddOverlay
//              
//  Synopsis:   Add the given node to the overlay list
//              
//  Arguments:  pDispNode   node to add
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispRoot::AddOverlay(CDispNode *pDispNode)
{
    if (_aryDispNodeOverlay.Find(pDispNode) == -1)
    {
        BOOL fStartService = (_aryDispNodeOverlay.Size() == 0);
        
        _aryDispNodeOverlay.Append(pDispNode);

        if (fStartService)
        {
            StartOverlayService();
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::RemoveOverlay
//              
//  Synopsis:   Remove the given node from the overlay list
//              
//  Arguments:  pDispNode   node to remove
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispRoot::RemoveOverlay(CDispNode *pDispNode)
{
    _aryDispNodeOverlay.DeleteByValue(pDispNode);

    if (_aryDispNodeOverlay.Size() == 0)
    {
        StopOverlayService();
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::ScrubOverlayList
//              
//  Synopsis:   Remove all entries that are descendants of the given node
//              
//  Arguments:  pDispNode   node to query
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispRoot::ScrubOverlayList(CDispNode *pDispNode)
{
    // if the node isn't in my tree, there's nothing to do
    if (_aryDispNodeOverlay.Size() == 0 || pDispNode->GetDispRoot() != this)
        return;

    int i = _aryDispNodeOverlay.Size() - 1;
    CDispNode **ppDispNode = &_aryDispNodeOverlay[i];

    // loop backwards, so that deletions don't affect the loop's future
    for ( ; i>=0; --i, --ppDispNode)
    {
        CDispNode *pdn;
        for (pdn = *ppDispNode; pdn; pdn = pdn->GetRawParentNode())
        {
            if (pdn == pDispNode)
            {
                RemoveOverlay(*ppDispNode);
                break;
            }
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::ClearOverlayList
//              
//  Synopsis:   Remove all entries
//              
//  Arguments:  none
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispRoot::ClearOverlayList()
{
    _aryDispNodeOverlay.DeleteAll();

    StopOverlayService();
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::StartOverlayService
//              
//  Synopsis:   Start the overlay service
//              
//  Arguments:  none
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispRoot::StartOverlayService()
{
    if (_pOverlaySink || _aryDispNodeOverlay.Size() == 0)
        return;

    _pOverlaySink = new COverlaySink(this);

    if (_pOverlaySink)
    {
        IServiceProvider *pSP = GetDispClient()->GetServiceProvider();
        
        _pOverlaySink->StartService(pSP);

        ReleaseInterface(pSP);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::StopOverlayService
//              
//  Synopsis:   Stop the overlay service
//              
//  Arguments:  none
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CDispRoot::StopOverlayService()
{
    Assert(_aryDispNodeOverlay.Size() == 0);

    if (_pOverlaySink)
    {
        _pOverlaySink->StopService();

        ClearInterface(&_pOverlaySink);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CDispRoot::NotifyOverlays
//              
//  Synopsis:   Callback from overlay timer.  Notify overlay nodes if they've
//              moved.
//              
//  Arguments:  none
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

HRESULT
CDispRoot::NotifyOverlays()
{
    HRESULT hr = S_OK;
    int i;

    for (i=_aryDispNodeOverlay.Size()-1; i>=0; --i)
    {
        _aryDispNodeOverlay[i]->GetAdvanced()->MoveOverlays();
    }

    RRETURN(hr);
}


/******************************************************************************
                COverlaySink
******************************************************************************/

COverlaySink::COverlaySink( CDispRoot *pDispRoot )
{
    _pDispRoot = pDispRoot;
    _ulRefs = 1;
}


COverlaySink::~COverlaySink()
{
}


ULONG
COverlaySink::AddRef()
{
    return ++_ulRefs;
}


ULONG
COverlaySink::Release()
{
    if ( 0 == --_ulRefs )
    {
        delete this;
        return 0;
    }
    return _ulRefs;
}


//+-------------------------------------------------------------------------
//
//  Member:     QueryInterface
//
//  Synopsis:   IUnknown implementation.
//
//  Arguments:  the usual
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------------
HRESULT
COverlaySink::QueryInterface(REFIID iid, void **ppv)
{
    if ( !ppv )
        RRETURN(E_POINTER);

    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((ITimerSink *)this, IUnknown)
        QI_INHERITS(this, ITimerSink)
        default:
            break;
    }

    if (*ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    RRETURN(E_NOINTERFACE);
}


//+----------------------------------------------------------------------------
//
//  Method:     OnTimer             [ITimerSink]
//
//  Synopsis:   Notify all overlay painters that have moved since the last time.
//
//  Arguments:  timeAdvise - the time that the advise was set.
//
//  Returns:    S_OK
//
//-----------------------------------------------------------------------------
HRESULT
COverlaySink::OnTimer( VARIANT vtimeAdvise )
{
    HRESULT hr = _pDispRoot->NotifyOverlays();

    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Member:     StartService
//
//  Synopsis:   Start the timer.
//
//  Arguments:  pSP     - service provider to ask for timer service
//
//--------------------------------------------------------------------------

void
COverlaySink::StartService(IServiceProvider *pSP)
{
    HRESULT hr;
    ITimerService *pTS = NULL;

    if (_pTimer)
        return;

    hr = pSP->QueryService( SID_STimerService, IID_ITimerService, (void **)&pTS );
    
    if (!hr && pTS)
        hr = pTS->CreateTimer( NULL, &_pTimer );

    if (!hr && _pTimer)
    {
        VARIANT varTimeStart, varTimeStop, varInterval;

        _pTimer->Freeze(TRUE);

        _pTimer->GetTime(&varTimeStart);        // start now

        V_VT(&varTimeStop) = VT_UI4;            // stop never
        V_UI4(&varTimeStop) = 0;

        V_VT(&varInterval) = VT_UI4;            // fire at polling rate
        V_UI4(&varInterval) = (ULONG) (1000L / OVERLAY_POLLING_RATE);

        _dwCookie = 0;                          // in case Advise fails

        hr = _pTimer->Advise(varTimeStart, varTimeStop, varInterval,
                                0, (ITimerSink*)this, &_dwCookie);

        _pTimer->Freeze(FALSE);
    }

    ReleaseInterface(pTS);
}


//+-------------------------------------------------------------------------
//
//  Member:     StopService
//
//  Synopsis:   Stop the timer.
//
//  Arguments:  none
//
//--------------------------------------------------------------------------

void
COverlaySink::StopService()
{
    if (_pTimer && _dwCookie)
    {
        _pTimer->Unadvise(_dwCookie);
    }

    _dwCookie = 0;
    ClearInterface(&_pTimer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\display\matrix.cxx ===
//+---------------------------------------------------------------------------
//  
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1995.
//  
//  File:       matrix.cxx
//  
//  Contents:   rotation matrix implementation
//  
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#include <math.h>

#ifndef X_FLOAT2INT_HXX_
#define X_FLOAT2INT_HXX_
#include "float2int.hxx"
#endif

#undef F2I_MODE
#define F2I_MODE Flow

//+---------------------------------------------------------------------------
//
//  The functions in this file deals with the transformation matrix.
//  A transformation matrix is a special 3x3 matrix that can store rotation,
//  scaling and offset information. It looks like this
//
//      M11    M21    eDx
//      M12    M22    eDy
//       0      0      1
//
//----------------------------------------------------------------------------


//+---------------------------------------------------------------------------
//
//  Synopsis:   Return the sine snd cosine of an angle
//              
//  Notes:      LIBC FUNCTIONS USED FROM TRAN.LIB: atan2 cos sin
//              
//----------------------------------------------------------------------------
void CosSinFromAng(ANG ang, float *pangCos, float *pangSin)
{
    // Ensure angle is normalized
    Assert(ang < ang360 && ang >= 0);

    //Note: Sine sign is reversed, since the window coordinate system is reversed in Y
    switch (ang)
    {
    // special-cases for speed and to avoid noise in math library.
    case 0:
        *pangCos = 1.0f;
        *pangSin = 0.0f;
        break;

    case ang90:
        *pangCos = 0.0f;
        *pangSin = -1.0f;
        break;
        
    case ang180:
        *pangCos = -1.0f;
        *pangSin = 0.0f;
        break;

    case ang270:
        *pangCos = 0.0f;
        *pangSin = 1.0f;
        break;

    default:
        {
        float angRadians = RadFromAng(ang);
        *pangCos = cos(angRadians);
        *pangSin = -sin(angRadians);
        break;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     MAT::MultiplyForward
//              
//  Synopsis:   Multiply this matrix (multiplier) by pmat (multiplicand)
//              The result is stored in this matrix
//              
//  Arguments:  pmat         the multiplicand matrix
//              
//  Notes: This is a customized matrix multiplication for the transforms.
//         Order of transforms: 'pmat' transform applies first, 'this' second
//              
//----------------------------------------------------------------------------
void MAT::MultiplyForward(MAT const *pmat)
{
    float fTmp1, fTmp2;

    fTmp1 = eM11 * pmat->eM11 + eM21 * pmat->eM12;
    fTmp2 = eM11 * pmat->eM21 + eM21 * pmat->eM22;
    eDx = eM11 * pmat->eDx + eM21 * pmat->eDy + eDx;
    eM11 = fTmp1;
    eM21 = fTmp2;

    fTmp1 = eM12 * pmat->eM11 + eM22 * pmat->eM12;
    fTmp2 = eM12 * pmat->eM21 + eM22 * pmat->eM22;
    eDy  = eM12 * pmat->eDx + eM22 * pmat->eDy + eDy;
    eM12 = fTmp1;
    eM22 = fTmp2;
}

//+---------------------------------------------------------------------------
//
//  Member:     MAT::MultiplyBackward
//              
//  Synopsis:   Multiply pmat (multiplier) by this matrix (multiplicand),
//              The result is stored in this matrix
//              
//  Arguments:  pmat         the multiplier matrix
//              
//  Notes: This is a customized matrix multiplication for the transforms
//         Order of transforms: 'this' transform applies first, 'pmat' second
//              
//----------------------------------------------------------------------------
void MAT::MultiplyBackward(MAT const*pmat)
{
    float fTmp1;

    fTmp1 = pmat->eM11 * eM11 + pmat->eM21 * eM12;
    eM12 = pmat->eM12 * eM11 + pmat->eM22 * eM12;    
    eM11 = fTmp1;
    fTmp1 = pmat->eM11 * eM21 + pmat->eM21 * eM22;
    eM22 = pmat->eM12 * eM21 + pmat->eM22 * eM22;
    eM21 = fTmp1;

    double fTmp2 = pmat->eM11 * eDx + pmat->eM21 * eDy + pmat->eDx;
    eDy = pmat->eM12 * eDx + pmat->eM22 * eDy + pmat->eDy;
    eDx = fTmp2;
}

//+---------------------------------------------------------------------------
//
//  Member:     MAT::Inverse
//              
//  Synopsis:   Inverse the current matrix
//              
//  Notes: Inverse is defined as (MAT * Inverse MAT = Unity Matrix)
//              
//----------------------------------------------------------------------------
void MAT::Inverse(void)
{
    double det = eM11 * eM22 - eM21 * eM12;

    if (det == 0)
    {
        AssertSz(FALSE, "Matrix cannot be inversed");
        return;
    }

    double det_rc = 1/det;
    //NOTE (mikhaill) -- previous version used 6 divisions by det; I've replaced
    //                   it to single division and 6 multiplications by det_rc.
    //                   This is much faster - because compiler never treats this
    //                   repeating divisions as repeating expressions and can't make
    //                   optimization. Note that, in general, a/b != a*(1/b), although
    //                   the difference can be just in least significant bits of 80-bit
    //                   internal fpp representation.

    double t = eDx;
    eDx = (eDy * eM21 - eDx * eM22) * det_rc;
    eDy = (  t * eM12 - eDy * eM11) * det_rc;
    
    t = eM11;
    eM11 = eM22 * det_rc;
    eM22 =    t * det_rc;

    eM21 = - eM21 * det_rc;
    eM12 = - eM12 * det_rc;
}

//+---------------------------------------------------------------------------
//
//  Member:     MAT::InitTranslation
//              
//  Synopsis:   Constructs a matrix from the passed translation.
//              
//  Arguments:  x, y  offset
//              
//----------------------------------------------------------------------------
void MAT::InitTranslation(const int x, const int y)
{
    eM11 = eM22 = 1;
    eM12 = eM21 = 0;
    eDx = x; eDy = y;
}

//+---------------------------------------------------------------------------
//
//  Member:     MAT::InitFromXYAng
//              
//  Synopsis:   Constructs a matrix from the passed floating point point and angle.
//              
//  Arguments:  xl, yl  center of rotation
//              ang     angle of rotation
//              
//  Notes: the result matrix does contain coordinate rounding
//              
//----------------------------------------------------------------------------
void MAT::InitFromXYAng(double xl, double yl, ANG ang)
{
    float angCos;    // not really angles, but oh well
    float angSin;

    AssertSz(ang, "Rotation angle = 0, avoid using this function for performance");

    // force to be in bounds
    ang = AngNormalize(ang);

    CosSinFromAng(ang, &angCos, &angSin);
    
    eM11 = angCos;
    eM12 = angSin;
    eM21 = -angSin;
    eM22 = angCos;
    eDx = (1 - angCos) * xl + yl * angSin;
    eDy = (1 - angCos) * yl - xl * angSin;
}

//+---------------------------------------------------------------------------
//
//  Member:     MAT::InitFromPtAng
//              
//  Synopsis:   Constructs a matrix from the passed point and angle
//              
//  Arguments:  ptCenter    center of rotation
//              ang         angle of rotation
//              
//  Notes: the result matrix does contain coordinate rounding
//              
//----------------------------------------------------------------------------
void MAT::InitFromPtAng(const CPoint ptCenter, ANG ang)
{
    InitFromXYAng(ptCenter.x, ptCenter.y, ang);
}

//+---------------------------------------------------------------------------
//
//  Member:     MAT::InitFromRcAng
//              
//  Synopsis:   Constructs a matrix from the passed rectangle and angle
//              
//  Arguments:  prc    rectangle, its center is the center of rotation
//              ang    angle of rotation
//              
//  Notes: the result matrix does contain coordinate rounding
//              
//----------------------------------------------------------------------------
void MAT::InitFromRcAng(const CRect *prc, ANG ang)
{
    InitFromXYAng((prc->left + prc->right)*.5, (prc->top + prc->bottom)*.5, ang);
}

//+---------------------------------------------------------------------------
//
//  Member:     MAT::TransformRgpt
//              
//  Synopsis:   The core transformation function,
//              Transforms an array of points using the current matrix
//              
//  Arguments:  ppt    pointer to the array of points.
//              cpt    number of points in the array
//              
//----------------------------------------------------------------------------
void MAT::TransformRgpt(CPoint *ppt, int cpt) const
{
    Assert(ppt);

    F2I_FLOW;

    for (; cpt > 0; ppt++, cpt--)
    {
        int x = ppt->x;
        int y = ppt->y;

        // For each point: multiply the 2x2 vector by the 1x2 point vector,
        // then add the translation offset

        ppt->x = IntNear(eM11 * x + eM21 * y + eDx);
        ppt->y = IntNear(eM12 * x + eM22 * y + eDy);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     MAT::GetBoundingRect
//              
//  Synopsis:   Computes the bounding CRect from a given RRC
//              
//  Arguments:  prrc    the rotated rectangle
//              
//  Notes: the result matrix does contain coordinate rounding
//              
//----------------------------------------------------------------------------
CRect MAT::GetBoundingRect(const RRC * const prrc) const
{
    CRect rcBound;
    int xp1, xp2;
    int yp1, yp2;
    // compute left edge: min of four points
    xp1 = min(prrc->ptTopLeft.x,    prrc->ptTopRight.x);
    xp2 = min(prrc->ptBottomLeft.x, prrc->ptBottomRight.x);
    rcBound.left = min(xp1, xp2);
    // compute right edge: max of four points
    xp1 = max(prrc->ptTopLeft.x,    prrc->ptTopRight.x);
    xp2 = max(prrc->ptBottomLeft.x, prrc->ptBottomRight.x);
    rcBound.right = max(xp1, xp2);
    // compute top edge: min of four points
    yp1 = min(prrc->ptTopLeft.y,    prrc->ptTopRight.y);
    yp2 = min(prrc->ptBottomLeft.y, prrc->ptBottomRight.y);
    rcBound.top = min(yp1, yp2);
    // compute bottom edge: max of four points
    yp1 = max(prrc->ptTopLeft.y,    prrc->ptTopRight.y);
    yp2 = max(prrc->ptBottomLeft.y, prrc->ptBottomRight.y);
    rcBound.bottom = max(yp1, yp2);

    return rcBound;
}

//+---------------------------------------------------------------------------
//
//  Member:     MAT::GetBoundingRectAfterTransform
//              
//  Synopsis:   Computes the bounding rect of prc after applying the transform
//              
//  Arguments:  prc         the rectangle to be rotated
//              fRoundOut   TRUE if floating-point coords should be rounded outwards
//              
//----------------------------------------------------------------------------

void MAT::GetBoundingRectAfterTransform(CRect *prc, BOOL fRoundOut) const
{
    // Transform each point of the
    // rect individually in floating-point coordinates,
    // detect mins and maxs of x and y of transformed points,
    // and compose bounding rectangle.

    double x = eM11 * prc->left + eM21 * prc->top + eDx;
    double y = eM12 * prc->left + eM22 * prc->top + eDy;

    double minx = x, maxx = x,
           miny = y, maxy = y;

    x = eM11 * prc->right + eM21 * prc->top + eDx;
    y = eM12 * prc->right + eM22 * prc->top + eDy;

    if (minx > x) minx = x; else if (maxx < x) maxx = x;
    if (miny > y) miny = y; else if (maxy < y) maxy = y;

    x = eM11 * prc->right + eM21 * prc->bottom + eDx;
    y = eM12 * prc->right + eM22 * prc->bottom + eDy;

    if (minx > x) minx = x; else if (maxx < x) maxx = x;
    if (miny > y) miny = y; else if (maxy < y) maxy = y;

    x = eM11 * prc->left + eM21 * prc->bottom + eDx;
    y = eM12 * prc->left + eM22 * prc->bottom + eDy;

    if (minx > x) minx = x; else if (maxx < x) maxx = x;
    if (miny > y) miny = y; else if (maxy < y) maxy = y;

    F2I_FLOW;
    if (fRoundOut)
        prc->SetRect(IntFloor(minx), IntFloor(miny),
                     IntCeil(maxx),  IntCeil(maxy));
    else
        prc->SetRect(IntNear(minx),  IntNear(miny),
                     IntNear(maxx),  IntNear(maxy));
}

//+---------------------------------------------------------------------------
//
//  Member:     MAT::GetXFORM
//              
//  Synopsis:   Convert martix into Windows atdard form
//              
//  Arguments:  x       reference to Windows matrix
//              
//----------------------------------------------------------------------------
void MAT::GetXFORM(XFORM& x) const
{
    x.eM11 = eM11;
    x.eM12 = eM12;
    x.eM21 = eM21;
    x.eM22 = eM22;
    x.eDx  = float(eDx);
    x.eDy  = float(eDy);
}

//+---------------------------------------------------------------------------
//
//  Member:     MAT::CombinePostTranslation
//              
//  Synopsis:   Adds a post transform offset to the current matrix
//              
//  Arguments:  xOffset, yOffset
//              
//  Notes: This is a short cut instead of combining the two transforms
//              
//----------------------------------------------------------------------------
void MAT::CombinePostTranslation(int xOffset, int yOffset)
{
    eDx += xOffset;
    eDy += yOffset;
}

//+---------------------------------------------------------------------------
//
//  Member:     MAT::CombinePreTranslation
//              
//  Synopsis:   Adds a pre transform offset to the current matrix
//              
//  Arguments:  xOffset, yOffset
//              
//  Notes: This is a short cut instead of combining the two transforms
//              
//----------------------------------------------------------------------------
void MAT::CombinePreTranslation(int xOffset, int yOffset)
{
    eDx += eM11 * xOffset + eM21 * yOffset;
    eDy += eM12 * xOffset + eM22 * yOffset;
}

//+---------------------------------------------------------------------------
//
//  Member:     MAT::CombinePostScaling
//              
//  Synopsis:   Adds a post transform scaling to the current matrix
//              
//  Arguments:  xScale, yScale
//              
//  Notes: This is a short cut instead of combining the two transforms
//              
//----------------------------------------------------------------------------
void MAT::CombinePostScaling(double scaleX, double scaleY)
{
    eM11 *= scaleX;
    eM21 *= scaleX;
    eDx  *= scaleX;
    eM12 *= scaleY; 
    eM22 *= scaleY; 
    eDy  *= scaleY;
}

//+---------------------------------------------------------------------------
//
//  Member:     MAT::CombinePostTransform
//              
//  Synopsis:   Combines the current transform with the pmat transform
//              
//  Arguments:  pmat    Transform to be added After the current one
//              
//  Notes: The order of applying transforms is important,
//         the result is current transform followed by the one form pmat     
//----------------------------------------------------------------------------
// (mikhaill) - inlined
//void MAT::CombinePostTransform(MAT const *pmat)
//{
//    MultiplyBackward(pmat);
//}

//+---------------------------------------------------------------------------
//
//  Member:     MAT::CombinePreTransform
//              
//  Synopsis:   Combines the pmat transform with the current transform
//              
//  Arguments:  pmat    Transform to be added prior to the current one
//              
//  Notes: The order of applying transforms is important,
//         the result is the pmat transform followed by the current transform
//----------------------------------------------------------------------------
// (mikhaill) - inlined
//void MAT::CombinePreTransform(MAT const *pmat)
//{
//    MultiplyForward(pmat);
//}

//+---------------------------------------------------------------------------
//
//  Member:     MAT::CombinePreScaling
//              
//  Synopsis:   Adds a pre transform scaling to the current matrix
//              
//  Arguments:  xScale, yScale
//              
//  Notes: This is a short cut instead of combining the two transforms
//              
//----------------------------------------------------------------------------
void MAT::CombinePreScaling(double scaleX, double scaleY)
{
    eM11 = eM11 * scaleX;
    eM21 = eM21 * scaleY;
    eM12 = eM12 * scaleX; 
    eM22 = eM22 * scaleY; 
}

//+---------------------------------------------------------------------------
//
//  Synopsis: returns whether two floats are within 1% of each other.
//              
//----------------------------------------------------------------------------
#define floatCloseRange  0.01
#define floatSmallEnough 0.0001
static bool AreClose(double f1, double f2)
{
    if (fabs(f1) < floatSmallEnough && fabs(f2) < floatSmallEnough)
        return TRUE;
    else
        return (fabs(f1 - f2) < fabs(floatCloseRange * f1));
}


//+---------------------------------------------------------------------------
//
//  Member:     MAT::GetAngleScaleTilt
//              
//  Synopsis: Deconstruct the matrix
//              
//----------------------------------------------------------------------------
void MAT::GetAngleScaleTilt(float *pdegAngle, float *pflScaleX, float *pflScaleY, float *pdegTilt) const
{
    // note: we need angle for all parameters except scaleX, so don't bother to check if they are
    //       are actually intereated in the angle
    //
    // angle is reversed because Y points down
    float degAngle = - DegFromRad(atan2(eM12, eM11));

    if (pdegAngle)
        *pdegAngle = degAngle;

    if (pdegTilt)
    {
        // where a vertical line moves when rotated. remember, Y axis is reversed
        float degAngleV = - DegFromRad(atan2(-eM22, -eM21));

        *pdegTilt = 90.0 + degAngle - degAngleV;
        if (*pdegTilt > 180)
            *pdegTilt -= 360;
        else
        if (*pdegTilt < -180)
            *pdegTilt += 360;
        
        // Tilt is supposed to be zero, because there is no way to set it now
        AssertSz(AreClose(*pdegTilt, 0), "Tilt is not zero");
    }

    if (pflScaleX)
    {
        *pflScaleX = sqrt(eM11 * eM11 + eM12 * eM12);
    }

    if (pflScaleY)
    {
        // FUTURE (alexmog, 6/7/99): this formula must take tilt into account. Change when it matters.
        AssertSz(AreClose(GetRealTilt(), 0), "ScaleY calculation does not support tilt");
        *pflScaleY = sqrt(eM21 * eM21 + eM22 * eM22);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     MAT::FTransforms
//              
//  Synopsis:   Test whether matrix provide any transform
//
//  Returns:    TRUE if indeed transforms
//              
//----------------------------------------------------------------------------
BOOL MAT::FTransforms() const
{
    return eM11 != 1 || eM22 != eM11 ||
           eM12 != 0 || eM21 != eM12 ||
           eDx  != 0 || eDy  != eDx;
}



#ifdef DBG
//+---------------------------------------------------------------------------
//
// ---------------------- SMOKE TEST -----------------------------------------
//
//----------------------------------------------------------------------------

static int IntPart(double d) { return (int) d; }
static int FracPart(double d) { return (int)(10000*(d - IntPart(d))); } // in 10000th's

//+---------------------------------------------------------------------------
//
//  Member:     MAT::Dump
//              
//  Synopsis: Dumps a matrix to the debug output. Since this will call wsprintf,
//        we can't use floating point conversion specifiers. !#^@%$&*
//              
//----------------------------------------------------------------------------
void MAT::Dump() const
{
/*
    wsprintf("|%d.%05d\t%d.%05d\t(%d.%05d)|\r\n",
        IntPart(eM11),
        FracPart(eM11),
        IntPart(eM21),
        FracPart(eM21),
        IntPart(eDx),
        FracPart(eDx));
    wsprintf("|%d.%05d\t%d.%05d\t(%d.%05d)|\r\n",
        IntPart(eM12),
        FracPart(eM12),
        IntPart(eM22),
        FracPart(eM22),
        IntPart(eDy),
        FracPart(eDy));
    wsprintf("angle %d\r\n",
        (int)(DegFromRad(GetAngFromMat())));
*/
}

//+---------------------------------------------------------------------------
//
//  Synopsis: Finds if the two matrices are close.

//  Note:     Because we are comparing floats, we test if they are close enough
//              
//----------------------------------------------------------------------------
static bool AreClose(MAT const& mat1, MAT const& mat2)
{
    return (AreClose(mat1.eM11, mat2.eM11) &&
            AreClose(mat1.eM21, mat2.eM21) &&
            AreClose(mat1.eM12, mat2.eM12) &&
            AreClose(mat1.eM22, mat2.eM22) &&
            AreClose(mat1.eDx,  mat2.eDx)  &&
            AreClose(mat1.eDy,  mat2.eDy) );
}

//+---------------------------------------------------------------------------
//
//  Member:     MAT::AssertValid
//              
//  Synopsis: Asserts a passed matrix is in fact a rotation matrix.
//            Plan: Get the angle from the matrix, then assert that the values in
//            the matrix correspond to the correct sin/cos values.
//              
//----------------------------------------------------------------------------
void MAT::AssertValid() const
{
    double rad = RadFromDeg(GetRealAngle());
   //Note: Sine sign is reversed, since the window coordinate system is reversed in Y
    float radCos = cos(rad), radSin = -sin(rad);

    double scale = GetRealScaleX();
    AssertSz(AreClose(scale, GetRealScaleY()), "Anisotropic matrix");

    AssertSz(AreClose(eM11,  radCos * scale), "Bogus matrix 1");
    AssertSz(AreClose(eM21, -radSin * scale), "Bogus matrix 2");
    AssertSz(AreClose(eM12,  radSin * scale), "Bogus matrix 3");
    AssertSz(AreClose(eM22,  radCos * scale), "Bogus matrix 4");
}

//+---------------------------------------------------------------------------
//
//  Member:     MAT::IsMatrixEqualTo
//              
//  Synopsis:   Test two matrices equality
//
//  Returns:    TRUE if this matrix is equal to given one
//              
//----------------------------------------------------------------------------
BOOL MAT::IsMatrixEqualTo(const MAT &m) const
{
    return eM11 == m.eM11 &&
           eM12 == m.eM12 &&
           eM21 == m.eM21 &&
           eM22 == m.eM22 &&
           eDx  == m.eDx  &&
           eDy  == m.eDy;
}

//+---------------------------------------------------------------------------
//
//  Member:     MAT::TestMatrix
//              
//  Synopsis: Test matrix operations work as expected
//              
//----------------------------------------------------------------------------
BOOL MAT::TestMatrix()
{
    BOOL    fRet = TRUE;    // return code
    CRect   rcDisp;         // dummy display rectangle
    ANG     ang1, ang2;     // dummy angle of rotation
    MAT     mat1, mat2, mat3;
    CRect   rcTestBefore, rcTestAfter, rcTestFinal;
    CRect   rcBounds1, rcBounds2;
    CPoint  ptCenter(-5,10);

    rcDisp.left = 366;
    rcDisp.top = -165;
    rcDisp.right = 486;
    rcDisp.bottom = 63;

    ang1 = AngFromDeg(180);

    // Test matrix initialization
    mat1.InitFromRcAng(&rcDisp, ang1);
    mat1.AssertValid();

    mat2.InitFromRcAng(&rcDisp, ang360 - ang1);
    mat2.AssertValid();
    AssertSz(mat1.IsMatrixEqualTo(mat2), "180 degree rotation matrices differ.");

    // Test bounding rectangles
    RRC rrc1(&rcDisp);
    rcBounds1 = GetBoundingRect(&rrc1);
    if (rcDisp != rcBounds1)
    {
        AssertSz(FALSE, "Bounding rectangle differs from rectangle.");
        fRet = FALSE;
    }

    mat1.TransformRRc(&rrc1);   // rotate 180 deg
    rcBounds2 = GetBoundingRect(&rrc1);
    if (rcBounds1 != rcBounds2)
    {
        AssertSz(FALSE, "180 degree rotated bounding rectangles differ.");
        fRet = FALSE;
    }

    // test matrix operations
    
    // Test inverse
    mat1.InitFromPtAng(ptCenter, ang1);
    mat1.Inverse();
    mat2.InitFromPtAng(ptCenter, -ang1);
    if (!AreClose(mat1, mat2))
    {
        AssertSz(FALSE, "Matrix inverse is not correct.");
        fRet = FALSE;
    }

    // Test multiplication
    ang1 = AngFromDeg(90);
    ang2 = AngFromDeg(180);    
    mat1.InitFromPtAng(ptCenter, ang1);
    mat2.InitFromPtAng(ptCenter, ang2);
    mat3.InitFromPtAng(ptCenter, ang1 + ang2);

    mat1.MultiplyForward(&mat2);
    if (!AreClose(mat1, mat3))
    {
        AssertSz(FALSE, "Matrix Forward multiplication is not correct.");
        fRet = FALSE;
    }

    mat1.InitFromPtAng(ptCenter, ang1);    
    mat1.MultiplyBackward(&mat2);
    if (!AreClose(mat1, mat3))
    {
        AssertSz(FALSE, "Matrix Backward multiplication is not correct.");
        fRet = FALSE;
    }

    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     DoMatrixSmokeTest
//              
//  Synopsis: Performs the matrix smoke test
//              
//----------------------------------------------------------------------------
BOOL DoMatrixSmokeTest()
{
    MAT mat;
    return (mat.TestMatrix());
}
#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\display\rect.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       rect.cxx
//
//  Contents:   Class to make rectangles easier to deal with.
//
//  Classes:    CRect
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_RECT_HXX_
#define X_RECT_HXX_
#include "rect.hxx"
#endif


//+---------------------------------------------------------------------------
//
//  Member:     CRect::Union
//              
//  Synopsis:   Extend rect to contain the given point.  If the rect is
//              initially empty, it will contain only the point afterwards.
//              
//  Arguments:  p       point to extend to
//              
//----------------------------------------------------------------------------

void
CRect::Union(const POINT& p)
{
    if (IsRectEmpty())
        SetRect(p.x,p.y,p.x+1,p.y+1);
    else
    {
        if (p.x < left) left = p.x;
        if (p.y < top) top = p.y;
        if (p.x >= right) right = p.x+1;
        if (p.y >= bottom) bottom = p.y+1;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CRect::Intersects
//              
//  Synopsis:   Determine whether the given rect intersects this rect without
//              taking the time to compute the intersection.
//              
//  Arguments:  rc      other rect
//              
//  Returns:    TRUE if the rects are not empty and overlap    
//              
//----------------------------------------------------------------------------

BOOL
CRect::Intersects(const RECT& rc) const
{
    return
        left < rc.right &&
        top < rc.bottom &&
        right > rc.left &&
        bottom > rc.top &&
        !IsRectEmpty() &&
        !((CRect&)rc).IsRectEmpty();
}


//+---------------------------------------------------------------------------
//
//  Function:   CalcScrollDelta
//
//  Synopsis:   Calculates the distance needed to scroll to make a given rect
//              visible inside this rect.
//
//  Arguments:  rc          Rectangle which needs to be visible inside this rect
//              psizeScroll Amount to scroll
//              vp, hp      Where to "pin" given RECT inside this RECT
//
//  Returns:    TRUE if scrolling required.
//
//----------------------------------------------------------------------------

BOOL
CRect::CalcScrollDelta(
        const CRect& rc,
        CSize* psizeScroll,
        SCROLLPIN spVert,
        SCROLLPIN spHorz) const
{
    int         i;
    long        cxLeft;
    long        cxRight;
    SCROLLPIN   sp;

    Assert(psizeScroll);

    if ((spVert == SP_MINIMAL || spVert == SP_TYPINGSCROLL)
          && (spHorz == SP_MINIMAL || spHorz == SP_TYPINGSCROLL)
          && Contains(rc))
    {
        *psizeScroll = g_Zero.size;
        return FALSE;
    }

    sp = spHorz;
    for (i = 0; i < 2; i++)
    {
        // Calculate amount necessary to "pin" the left edge
        cxLeft = rc[i] - (*this)[i];

        // Examine right edge only if not "pin"ing to the left
        if (sp != SP_TOPLEFT)
        {
            Assert(sp == SP_BOTTOMRIGHT || sp == SP_MINIMAL || sp == SP_TYPINGSCROLL);

            cxRight = (*this)[i+2] - rc[i+2];

            // "Pin" the inner RECT to the right side of the outer RECT
            if (sp == SP_BOTTOMRIGHT)
            {
                cxLeft = -cxRight;
            }

            // Otherwise, move the minimal amount necessary to make the
            // inner RECT visible within the outer RECT
            // (This code will try to make the entire inner RECT visible
            //  and gives preference to the left edge)
            else if (cxLeft > 0)
            {
                if (cxRight >= 0)
                {
                    cxLeft = 0;
                }
                else if (-cxRight < cxLeft)
                {
                    cxLeft = -cxRight;
                }
            }
        }
        if(sp == SP_TYPINGSCROLL)
        {
            if(cxLeft > 0)
                cxLeft = max(cxLeft, ((*this)[i+2] - (*this)[i]) / 3);
            else if (cxLeft < 0)
                cxLeft = min(cxLeft, -((*this)[i+2] - (*this)[i]) / 3);                    
        }

        (*psizeScroll)[i] = cxLeft;
        sp = spVert;
    }

    return !psizeScroll->IsZero();
}


//+---------------------------------------------------------------------------
//
//  Member:     CRect::CountContainedCorners
//              
//  Synopsis:   Count how many corners of the given rect are contained by
//              this rect.  This is tricky, because a rect doesn't technically
//              contain any of its corners except the top left.  This method
//              returns a count of 4 for rc.CountContainedCorners(rc).
//              
//  Arguments:  rc      rect to count contained corners for
//              
//  Returns:    -1 if rectangles do not intersect, or 0-4 if they do.  Zero
//              if rc completely contains this rect.
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

int
CRect::CountContainedCorners(const RECT& rc) const
{
    if (!Intersects(rc))
        return -1;
    
    int c = 0;
    if (rc.left >= left) {
        if (rc.top >= top) c++;
        if (rc.bottom <= bottom) c++;
    }
    if (rc.right <= right) {
        if (rc.top >= top) c++;
        if (rc.bottom <= bottom) c++;
    }
    return c;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\download\bitsctx.cxx ===
#error "@@@ This file is nuked"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\display\xtextout.cxx ===
/*----------------------------------------------------------------------------
    File: xtextout.cxx

    Transformation wrappers for ExtTextOut*
----------------------------------------------------------------------------*/

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\display\transform.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       transform.cxx
//
//  Contents:   Transformation classes.
//
//  Classes:    CWorldTransform, CDocScaleInfo
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_TRANSFORM_HXX_
#define X_TRANSFORM_HXX_
#include "transform.hxx"
#endif



//++--------------------------------------------------------------------------
///  Member:     CWorldTransform::Init
//++---------------------------------------------------------------------------
void 
CWorldTransform::Init(const CWorldTransform * pTransform)
{
    _fUseMatrix = pTransform->_fUseMatrix;
    if (_fUseMatrix)
    {
        _ang     = pTransform->_ang;
#if DBG==1
        _ptSrcRot= pTransform->_ptSrcRot;
#endif //DBG
        _mat     = pTransform->_mat;
        _matInverse = pTransform->_matInverse;
    }
    else
    {
        _offset = pTransform->_offset;
    }

    IF_DBG(ValidateTransform());
}

//++--------------------------------------------------------------------------
///  Member:     CWorldTransform::Init
//++---------------------------------------------------------------------------
void 
CWorldTransform::Init(const MAT * pMatrix)
{
    SetToIdentity();
    
    _mat = *pMatrix;
    _matInverse = _mat;
    _matInverse.Inverse();
    _fUseMatrix = TRUE;
    
    IF_DBG(ValidateTransform());
}

//++--------------------------------------------------------------------------
///  Member:     CWorldTransform::GetOffsetDst
//++--------------------------------------------------------------------------
void 
CWorldTransform::GetOffsetDst(CPoint *ppt) const
{
    IF_DBG(ValidateTransform());
    
    if (_fUseMatrix)
    {
        //dmitryt: Can't return this. It's mixed into matrix. Fix the code using it later
        //$REVIEW (azmyh): This gets the overall translation effect of the transformation, 
        // not the translation component, translation effect due to rotation should be accounted for.
        CPoint p(0,0);
        Transform(&p);
        *ppt = p;
    }
    else
    {
        *ppt = _offset.AsPoint();
    }
}

//++--------------------------------------------------------------------------
///  Member:     CWorldTransform::Reverse
///  Synopsis:   Convert transformation to the opposite of itself
//++--------------------------------------------------------------------------
void
CWorldTransform::Reverse()
{
    if (_fUseMatrix)
    {
        // reverse rotation
        _ang = -_ang;
        MAT matT = _mat;
        _mat = _matInverse;
        _matInverse = matT;
    }
    else
    {
        _offset = -_offset;
    }

    IF_DBG(ValidateTransform());
};

//++--------------------------------------------------------------------------
/// Member:     CWorldTransform::AddPostTransform
/// Synopsis:   Combine two transformations. 
///             Offsets add, angles add, scaling and rotation multiply.
/// Note:       Order of transforms: 'this' first, 'ptransform' second.
//++--------------------------------------------------------------------------
void CWorldTransform::AddPostTransform(const CWorldTransform *ptransform)
{
    if (ptransform->_fUseMatrix)    
    {
        if (!_fUseMatrix)
        {
            // Current matrix is unused, just use the other matrix
            _ang     = 0;
#if DBG==1
            _ptSrcRot= g_Zero.pt;
#endif //DBG
            _mat.InitTranslation(_offset.cx,_offset.cy);
            _matInverse.InitTranslation(-_offset.cx,-_offset.cy);
            _fUseMatrix = TRUE;
        }

        // REVIEW azmyh: if the rotation center of both transforms are not the same
        // then the angle and center of the resultant transform are undefined
        _ang += ptransform->_ang;
#if DBG==1
        _ptSrcRot = ptransform->_ptSrcRot;
#endif //DBG
        _mat.CombinePostTransform(&ptransform->_mat);
        _matInverse.CombinePreTransform(&ptransform->_matInverse);
    }
    else // ptransform is just an offset
    {
        if(!_fUseMatrix)
        {
            _offset += ptransform->_offset;
        }
        else
        {
            _mat.CombinePostTranslation(ptransform->_offset.cx,ptransform->_offset.cy);
            _matInverse.CombinePreTranslation(-ptransform->_offset.cx,-ptransform->_offset.cy);
        }
    }

    IF_DBG(ValidateTransform());
}

//++--------------------------------------------------------------------------
/// Member:     CWorldTransform::AddPreTransform
/// Synopsis:   Combine two transformations. 
///             Offsets add, angles add, scaling and rotation multiply.
/// Note:       Order of transforms: 'ptransform' first, 'this' second.
//++--------------------------------------------------------------------------
void CWorldTransform::AddPreTransform(const CWorldTransform *ptransform)
{
    if (ptransform->_fUseMatrix)    
    {
        if (!_fUseMatrix)
        {
            // Current matrix is unused, just use the other matrix
            _ang     = 0;
#if DBG==1
            _ptSrcRot= g_Zero.pt;
#endif //DBG            
            _mat.InitTranslation(_offset.cx,_offset.cy);
            _matInverse.InitTranslation(-_offset.cx,-_offset.cy);
            _fUseMatrix = TRUE;
        }

        // REVIEW azmyh: if the rotation center of both transforms are not the same
        // then the angle and center of the resultant transform are undefined
        _ang += ptransform->_ang;

        _mat.CombinePreTransform(&ptransform->_mat);
        _matInverse.CombinePostTransform(&ptransform->_matInverse);
    }
    else // ptransform is just an offset
    {
        if(!_fUseMatrix)
        {
            _offset += ptransform->_offset;
        }
        else
        {
            _mat.CombinePreTranslation(ptransform->_offset.cx,ptransform->_offset.cy);
            _matInverse.CombinePostTranslation(-ptransform->_offset.cx,-ptransform->_offset.cy);
        }
    }

    IF_DBG(ValidateTransform());
}

//++--------------------------------------------------------------------------
/// Member:     CWorldTransform::GetBoundingRectAfterTransform
/// Synopsis:   Calculates the bounding Rect of prcSrc after transformation
//++--------------------------------------------------------------------------
void
CWorldTransform::GetBoundingRectAfterTransform(const CRect *prcSrc, CRect *prcBound, BOOL fRoundOut) const
{
    *prcBound = *prcSrc;
    if (_fUseMatrix)
        _mat.GetBoundingRectAfterTransform(prcBound, fRoundOut);
    else
        prcBound->OffsetRect(_offset);
}

//++--------------------------------------------------------------------------
/// Member:     CWorldTransform::GetBoundingRectAfterInverseTransform
/// Synopsis:   Calculates the bounding Rect of prcSrc after inverse transformation
//++--------------------------------------------------------------------------
void
CWorldTransform::GetBoundingRectAfterInverseTransform(const CRect *prcSrc, CRect *prcBound, BOOL fRoundOut) const
{
    *prcBound = *prcSrc;
    if (_fUseMatrix)
        _matInverse.GetBoundingRectAfterTransform(prcBound, fRoundOut);
    else
        prcBound->OffsetRect(-_offset);
}

//++--------------------------------------------------------------------------
/// Member:     CWorldTransform::GetBoundingSizeAfterTransform
/// Synopsis:   Calculates the bounding Rect of prcSrc after transformation
//++--------------------------------------------------------------------------
void
CWorldTransform::GetBoundingSizeAfterTransform(const CRect *prcSrc, CSize *pSize) const
{
    if (_fUseMatrix)
    {
        CRect rcBound(*prcSrc);
        _mat.GetBoundingRectAfterTransform(&rcBound, FALSE /*changed from TRUE for bug 93619*/);
        pSize->cx = rcBound.Width();
        pSize->cy = rcBound.Height();
    }
    else
    {
        pSize->cx = prcSrc->Width();
        pSize->cy = prcSrc->Height();
    }
}

//++--------------------------------------------------------------------------
/// Member:     CWorldTransform::GetBoundingSizeAfterInverseTransform
/// Synopsis:   Calculates the bounding Rect of prcSrc after inverse transformation
//++--------------------------------------------------------------------------
void
CWorldTransform::GetBoundingSizeAfterInverseTransform(const CRect *prcSrc, CSize *pSize) const
{
    if (_fUseMatrix)
    {
        CRect rcBound(*prcSrc);
        _matInverse.GetBoundingRectAfterTransform(&rcBound, FALSE /*changed from TRUE for bug 93619*/);
        pSize->cx = rcBound.Width();
        pSize->cy = rcBound.Height();
    }
    else
    {
        pSize->cx = prcSrc->Width();
        pSize->cy = prcSrc->Height();
    }
}

//++--------------------------------------------------------------------------
/// Member:     CWorldTransform::AddScaling
/// Synopsis:   Add a post scaling fraction to the current transform
//++--------------------------------------------------------------------------
void
CWorldTransform::AddScaling(FLOAT scaleX, FLOAT scaleY)
{
    AssertSz(scaleX == scaleY, "Anisotrpic scaling is not supported");

    // Multiply scales
    if (scaleX != 1.0 /* || scaleY != 1.0 */)    
    {
        if (!_fUseMatrix)
        {
            _ang = 0; // angle was unused while _fUseMatrix was false
            _mat.InitTranslation(_offset.cx,_offset.cy);
            _matInverse.InitTranslation(-_offset.cx,-_offset.cy);
            _fUseMatrix = TRUE;
        }

        _mat.CombinePostScaling(scaleX, scaleY);
        _matInverse.CombinePreScaling(1./scaleX, 1./scaleY);
    }

    IF_DBG(ValidateTransform());
}


//++--------------------------------------------------------------------------
/// Member:     CWorldTransform::AddRotation
/// Synopsis:   Add a post rotation to the current transform
//++--------------------------------------------------------------------------
void
CWorldTransform::AddRotation(ANG ang)
{
    if (ang)
    {
        if(!_fUseMatrix)
        {
            _mat.InitTranslation(_offset.cx,_offset.cy);
            _matInverse.InitTranslation(-_offset.cx,-_offset.cy);
            _ang = 0;
            _fUseMatrix = TRUE;
        }

        CPoint ptSrcRot(0, 0);
#if DBG==1
        _ptSrcRot = ptSrcRot;  //undefined if we have an offset between rotations,
                               //use the center of the last rotation for debugging puposes.
#endif //DBG
        _ang += ang;

        MAT m;
        m.InitFromPtAng(ptSrcRot, ang);
        _mat.CombinePostTransform(&m);

        //dmitryt: we are guaranteed the existence of reverse matrix
        //         here because rotation matrix always has det = 1 (cos^2 + sin^2)
        //m.Inverse();    
        m.InitFromPtAng(ptSrcRot, -ang);
        _matInverse.CombinePreTransform(&m);
    }

    IF_DBG(ValidateTransform());
}


//++--------------------------------------------------------------------------
/// Member:     CWorldTransform::AddRotation
/// Synopsis:   Add a post rotation to the current transform
//++--------------------------------------------------------------------------
void
CWorldTransform::AddRotation(const CRect *prcSrc, ANG ang)
{
    if (ang)
    {
        if(!_fUseMatrix)
        {
            _mat.InitTranslation(_offset.cx,_offset.cy);
            _matInverse.InitTranslation(-_offset.cx,-_offset.cy);
            _ang = 0;
            _fUseMatrix = TRUE;
        }

        CPoint ptSrcRot((prcSrc->left + prcSrc->right) / 2, (prcSrc->top + prcSrc->bottom) / 2);
#if DBG==1
        _ptSrcRot = ptSrcRot;  //undefined if we have an offset between rotations,
                               //use the center of the last rotation for debugging puposes.
#endif //DBG
        _ang += ang;

        MAT m;
        m.InitFromPtAng(ptSrcRot, ang);
        _mat.CombinePostTransform(&m);

        //dmitryt: we are guaranteed the existence of reverse matrix
        //         here because rotation matrix always has det = 1 (cos^2 + sin^2)
        //m.Inverse();    
        m.InitFromPtAng(ptSrcRot, -ang);
        _matInverse.CombinePreTransform(&m);
    }

    IF_DBG(ValidateTransform());
}

//++--------------------------------------------------------------------------
/// Member:     CWorldTransform::ShiftMatrixOrigin
/// Synopsis:   Shifts the origin of the current transformation matrix
//++--------------------------------------------------------------------------
void
CWorldTransform::ShiftMatrixOrigin(const CSize& offset)
{
    if (_fUseMatrix)
    {
        _mat.CombinePreTranslation(offset.cx, offset.cy);
        _mat.CombinePostTranslation(-offset.cx, -offset.cy);

        _matInverse.CombinePostTranslation(-offset.cx, -offset.cy);
        _matInverse.CombinePreTranslation(offset.cx, offset.cy);
    }

    IF_DBG(ValidateTransform());
}

const MAT& CWorldTransform::GetMatrix() const
{ 
    if(!_fUseMatrix)
        const_cast<MAT &>(_mat).InitTranslation(_offset.cx,_offset.cy);
    return _mat; 
}


const MAT& CWorldTransform::GetMatrixInverse() const
{ 
    if(!_fUseMatrix)
        const_cast<MAT &>(_matInverse).InitTranslation(-_offset.cx,-_offset.cy);
    return _matInverse; 
}

#if DBG==1
bool AreAnglesEqual(ANG a1, ANG a2)
{
    return (a1-a2)%3600 == 0;
}

void CWorldTransform::ValidateTransform() const
{
    if (_fUseMatrix)
    {
#ifdef OPTIMIZE_MATRIX // we can optimize transform to remove matrix when it is not needed
        AssertSz(_mat.eM11 != 1.0
              || _mat.eM12 != 0.0
              || _mat.eM21 != 0.0
              || _mat.eM22 != 1.0, "_fUseMatrix set for offset-only matrix");
#endif
              
        AssertSz(!_fUseMatrix || AreAnglesEqual(_ang, _mat.GetAng()), "_ang not is sync with _mat");
        _mat.AssertValid();
    }
    else
    {
        Assert(_ang == 0);  // Angle should not be unititialized when matrix is not used.
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\display\region2.cxx ===
//+-----------------------------------------------------------------------
//
//  Microsoft MSHTM
//  Copyright (C) Microsoft Corporation, 1999
//
//  File:      src\site\display\region2.cpp
//
//  Contents:  CRegion2 implementation
//
//  Classes:   CRegion2
//             CRgnData (local)
//             CStripe  (local)
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_REGION2_HXX_
#define X_REGION2_HXX_
#include "region2.hxx"
#endif


#ifndef X_FLOAT2INT_HXX_
#define X_FLOAT2INT_HXX_
#include "float2int.hxx"
#endif

#undef F2I_MODE
#define F2I_MODE Flow

#ifndef X_DISPTRANSFORM_HXX_
#define X_DISPTRANSFORM_HXX_
#include "disptransform.hxx"
#endif

MtDefine(CRegion2, DisplayTree, "CRegion2");

#if DBG == 1
#  define RGN_INLINE
#else
#  define RGN_INLINE inline
#endif


// CRegion2 data are contained in variable-length structure CRgnData,
// that occupies single contiguous memory block.
// Empty regions have no data, and _pData == 0.
//
// class CRgnData
// {
//     int _count;          // number of horizontal stripes
//     int _left, _right;   // bounding rectangle edges: left <= x < right
//     class CStripe
//     {
//          int _nTop;  // top y of a stripe
//          int* _px;   // points into xHeap
//     } stripe[count];
//     possible unused gap 1;
//     int xHeap[xHeapSize];
//     possible unused gap 2;
// }
//
//    For each point belonging to the stripe[i]
//        stripe[i].top <= point.y < stripe[i+1].top.
//
//    The last stripe, stripe[count-1], is dummy.
//    It actually does not describe region's stripe, but holds
//    region's bottom y-coordinate (as stripe[count-1].top),
//    and also points to end of xHeap.
//
//    For each stripe[i], 0<=i<count-1, stripe[i]._px points to
//    an array of 2*k integer x-coordinates, where k >= 0 is the number of segments.
//
//    The length of x-coordinate array can be obtained as
//        stripe[i+1]._px - stripe[i]._px
//
//    Numbers in x-coordinate array goes in increasing order.
//    Segment j of stripe i contains points (x,y) where
//        stripe[i].top <= y < stripe[i+1].top
//        stripe[i]._px[2*j] <= x < stripe[i]._px[2*j+1]
//
//    There are no unused gaps in xHeap.
//    The length of xHeap = stripe[count-1]._px - stripe[0]._px.

#if DBG==1
DeclareTag(tagRgnDataValid, "Regions", "Trace CRgnData validity");
#define ASSERT_RGN_VALID\
    if (IsTagEnabled(tagRgnDataValid))\
        if (!IsEmpty())\
            Assert(Data()->IsDataValid(UsingOwnMemory() != FALSE));
#else
#define ASSERT_RGN_VALID
#endif

static const int SizeOfSimpleStripe = 2 * sizeof(int);

class CStripe
{
    friend class CRgnData;
    friend class CRegion2;

    int  _nTop; // least y of a stripe
    int  _ox;   // offset in bytes from (this) to stripe's x-coordinates array

    int* px() const { return (int*)((char*)(this) + _ox); }
    void setp(const int* px) { _ox = ((char*)px - (char*)this); }

    int GetSize() const
    {
        return (char*)(this+1)->px() - (char*)px();
    }

    bool IsSimple() const { return GetSize() == SizeOfSimpleStripe; }

    void Copy(const CStripe *s)
    {
        _nTop = s->_nTop;
        int *q = s->px();
        int n = (s+1)->px() - q;
        int *p = px();
        for (int i = 0; i < n; i++) p[i] = q[i];
        (this+1)->setp(p+n);
    }

    void Copy(const CStripe *s, const CStripe *t)
    {
        _nTop = t->_nTop;
        int *q = s->px();
        int n = (s+1)->px() - q;
        int *p = px();
        for (int i = 0; i < n; i++) p[i] = q[i];
        (this+1)->setp(p+n);
    }

    bool IsEqualToPrevious() const
    {
        int *p = px();
        int *q = (this-1)->px();
        int n = p - q;
        if (n != (this+1)->px() - p)
            return false;   // lengths differ
        for (int i = 0; i < n; i++)
            if (p[i] != q[i]) return false;
        return true;
    }

    bool IsEqualTo(const CStripe &s) const
    {
        if (_nTop != s._nTop)
            return false;
        int *p = px();
        int *q = s.px();
        int n = (this+1)->px() - p;
        int m = (&s+1)->px() - q;
        if (m != n) return false;

        for (int i = 0; i < n; i++)
            if (p[i] != q[i]) return false;
        return true;
    }

    void Offset(int dx)
    {
        int *p = px(), *q = (this+1)->px();
        while (p != q) *p++ += dx;
    }

    void Scale(double coef)
    {
        _nTop = IntNear(coef*_nTop);
        int *p = px(), *q = (this+1)->px();
        for (int i = q-p; --i>=0;)
            p[i] = IntNear(coef*p[i]);
    }

    void SetTop(const CStripe *s)
    {
        _nTop = s->_nTop;
    }

    void Zero(const CStripe *s)
    {
        _nTop = s->_nTop;
        (this+1)->setp(px());
    }

    bool Contains(int x) const;

    void Union(const CStripe *sa, const CStripe *sb);

    void Intersect(const CStripe *sa, const CStripe *sb);

    static bool Intersects(const CStripe *sa, const CStripe *sb);

    void Subtract(const CStripe *sa, const CStripe *sb, const CStripe *sc);
};

RGN_INLINE
bool CStripe::Contains(int x) const
{
    int *p = px(),
        *q = (this+1)->px();
    if (p == q) return false;   // empty stripe

    if (x < *p || x >= q[-1]) return false;
    for (int i = 0, j = (q-p)>>1; j-i != 1;)
    {
        int k = (i+j)>>1;
        if (x < p[2*k]) j = k;
        else            i = k;
    }
    return x < p[i+j];
}

RGN_INLINE
void CStripe::Union(const CStripe *sa, const CStripe *sb)
{
    _nTop = sa->_nTop;

    int *qa = sa->px(), *qafin = (sa+1)->px();
    int *qb = sb->px(), *qbfin = (sb+1)->px();
    int *p = px();

    if (qa != qafin && qb != qbfin)
    for (;;)
    {
a0b0:
        if (*qa < *qb) { *p++ = *qa++;                               goto a1b0; }
        if (*qb < *qa) { *p++ =       *qb++;                         goto a0b1; }
        /* *qa==*qb */ { *p++ = *qa++; qb++;                         goto a1b1; }
a1b1:
        if (*qa < *qb) {         qa++;       if (qa == qafin) break; goto a0b1; }
        if (*qb < *qa) {               qb++; if (qb == qbfin) break; goto a1b0; }
        /* *qa==*qb */ { *p++ = *qa++; qb++; if (qa == qafin) break;
                                             if (qb == qbfin) break; goto a0b0; }
a1b0:
        if (*qa < *qb) { *p++ = *qa++;       if (qa == qafin) break; goto a0b0; }
        if (*qb < *qa) {               qb++;                         goto a1b1; }
        /* *qa==*qb */ {         qa++; qb++; if (qa == qafin) break; goto a0b1; }
a0b1:
        if (*qa < *qb) {         qa++;                               goto a1b1; }
        if (*qb < *qa) { *p++ =       *qb++; if (qb == qbfin) break; goto a0b0; }
        /* *qa==*qb */ {         qa++; qb++; if (qb == qbfin) break; goto a1b0; }
    }

    while (qa != qafin) *p++ = *qa++;
    while (qb != qbfin) *p++ = *qb++;
    (this+1)->setp(p);
}

RGN_INLINE
void CStripe::Intersect(const CStripe *sa, const CStripe *sb)
{
    _nTop = sa->_nTop;

    int *qa = sa->px(), *qafin = (sa+1)->px();
    int *qb = sb->px(), *qbfin = (sb+1)->px();
    int *p = px();

    if (qa != qafin && qb != qbfin)
    for (;;)
    {
a0b0:
        if (*qa < *qb) {         qa++;                               goto a1b0; }
        if (*qb < *qa) {               qb++;                         goto a0b1; }
        /* *qa==*qb */ { *p++ = *qa++; qb++;                         goto a1b1; }
a1b1:
        if (*qa < *qb) { *p++ = *qa++;       if (qa == qafin) break; goto a0b1; }
        if (*qb < *qa) { *p++ =       *qb++; if (qb == qbfin) break; goto a1b0; }
        /* *qa==*qb */ { *p++ = *qa++; qb++; if (qa == qafin) break;
                                             if (qb == qbfin) break; goto a0b0; }
a1b0:
        if (*qa < *qb) {         qa++;       if (qa == qafin) break; goto a0b0; }
        if (*qb < *qa) { *p++ =       *qb++;                         goto a1b1; }
        /* *qa==*qb */ {         qa++; qb++; if (qa == qafin) break; goto a0b1; }
a0b1:
        if (*qa < *qb) { *p++ = *qa++;                               goto a1b1; }
        if (*qb < *qa) {               qb++; if (qb == qbfin) break; goto a0b0; }
        /* *qa==*qb */ {         qa++; qb++; if (qb == qbfin) break; goto a1b0; }
    }

    (this+1)->setp(p);
}

RGN_INLINE
bool CStripe::Intersects(const CStripe *sa, const CStripe *sb)
{
    int *qa = sa->px(), *qafin = (sa+1)->px();
    int *qb = sb->px(), *qbfin = (sb+1)->px();

    if (qa == qafin || qb == qbfin) return false;

    for (;;)
    {
a0b0:
        if (*qa < *qb) {qa++;                               goto a1b0; }
        if (*qb < *qa) {      qb++;                         goto a0b1; }
        /* *qa==*qb */ {                                  return true; }
a1b0:
        if (*qa < *qb) {qa++;       if (qa == qafin) break; goto a0b0; }
        if (*qb < *qa) {                                  return true; }
        /* *qa==*qb */ {qa++; qb++; if (qa == qafin) break; goto a0b1; }
a0b1:
        if (*qa < *qb) {                                  return true; }
        if (*qb < *qa) {      qb++; if (qb == qbfin) break; goto a0b0; }
        /* *qa==*qb */ {qa++; qb++; if (qb == qbfin) break; goto a1b0; }
    }

    return false;
}

RGN_INLINE
void CStripe::Subtract(const CStripe *sa, const CStripe *sb, const CStripe *sc)
{
    _nTop = sc->_nTop;

    int *qa = sa->px(), *qafin = (sa+1)->px();
    int *qb = sb->px(), *qbfin = (sb+1)->px();
    int *p = px();

    if (qa != qafin && qb != qbfin)
    for (;;)
    {
a0b0:
        if (*qa < *qb) { *p++ = *qa++;                               goto a1b0; }
        if (*qb < *qa) {               qb++;                         goto a0b1; }
        /* *qa==*qb */ {         qa++; qb++;                         goto a1b1; }
a1b1:
        if (*qa < *qb) {         qa++;       if (qa == qafin) break; goto a0b1; }
        if (*qb < *qa) { *p++ =       *qb++; if (qb == qbfin) break; goto a1b0; }
        /* *qa==*qb */ {         qa++; qb++; if (qa == qafin) break;
                                             if (qb == qbfin) break; goto a0b0; }
a1b0:
        if (*qa < *qb) { *p++ = *qa++;       if (qa == qafin) break; goto a0b0; }
        if (*qb < *qa) { *p++ =       *qb++;                         goto a1b1; }
        /* *qa==*qb */ { *p++ = *qa++; qb++; if (qa == qafin) break; goto a0b1; }
a0b1:
        if (*qa < *qb) {         qa++;                               goto a1b1; }
        if (*qb < *qa) {               qb++; if (qb == qbfin) break; goto a0b0; }
        /* *qa==*qb */ { *p++ = *qa++; qb++; if (qb == qbfin) break; goto a1b0; }
    }

    while (qa != qafin) *p++ = *qa++;
    (this+1)->setp(p);
}

class CRgnData
{
    friend CRegion2;

    int _nCount;            // (count-1) == number of horizontal stripes
    int _nLeft, _nRight;    // bounding rectangle edges: _nLeft <= x < _nRight
    CStripe _aStripe[2];     // actually _aStripe[_nCount]

    int GetHdrSize() const  // in char
    {
        return sizeof(CRgnData) + (_nCount-2)*sizeof(CStripe);
    }

    int GetArySize() const  // in char
    {
        return (char*)_aStripe[_nCount-1].px() - (char*)_aStripe[0].px();
    }

    int CountRectangles() const
    {
        return (_aStripe[_nCount-1].px() - _aStripe[0].px()) >> 1;
    }

    int GetMinSize() const  // in char
    {
        return GetHdrSize() + GetArySize();
    }

    void SetRectangle(int left, int top, int right, int bottom)
    {
        int *p = (int*)(this + 1);

        _nCount = 2;
        _nLeft  = left;
        _nRight = right;

        _aStripe[0]._nTop = top;
        _aStripe[0].setp(p);

        p[0] = left;
        p[1] = right;
        _aStripe[1]._nTop = bottom;
        _aStripe[1].setp(p+2);
    }

    void GetBoundingRect(RECT &rc) const
    {
        rc.left  = _nLeft;
        rc.right = _nRight;
        rc.top = _aStripe[0]._nTop;
        rc.bottom = _aStripe[_nCount-1]._nTop;
    }

    bool IsEqualTo(const CRect &rc) const
    {
        if (_nCount != 2 || !_aStripe[0].IsSimple()) return false;
        return rc.left  == _nLeft &&
               rc.right == _nRight &&
               rc.top == _aStripe[0]._nTop &&
               rc.bottom == _aStripe[1]._nTop;
    }

    bool IsRectangle(int left, int top, int right, int bottom) const
    {
        if (_nCount != 2|| !_aStripe[0].IsSimple()) return false;
        return left  == _nLeft &&
               right == _nRight &&
               top == _aStripe[0]._nTop &&
               bottom == _aStripe[1]._nTop;
    }

    RECT* GetAllRectangles(RECT *pr)
    {
        for (int i = 0, n = _nCount-1; i < n; i++)
        {
            CStripe &s = _aStripe[i];
            int *p = s.px();
            int m = ((&s+1)->px() - p) >> 1;

            int top = s._nTop;
            int bottom = (&s+1)->_nTop;

            for (int j = 0; j < m; j++, pr++)
            {
                pr->top    = top;
                pr->bottom = bottom;
                pr->left   = p[2*j];
                pr->right  = p[2*j+1];
            }
        }
        return pr;
    }

    bool Offset(int dx, int dy)
    {
        int countm1 = _nCount-1;
        int new_left  = _nLeft + dx,
            new_right = _nRight + dx,
            top = _aStripe[0]._nTop,
            new_top = top + dy,
            bottom = _aStripe[countm1]._nTop,
            new_bottom = bottom + dy;
        // check oveflows
        if (dx > 0)
        {
            if (new_right < _nRight)
                return false;
        }
        else
        {
            if (new_left > _nLeft)
                return false;
        }

        if (dy > 0)
        {
            if (new_bottom < bottom)
                return false;
        }
        else
        {
            if (new_top > top)
                return false;
        }

        // do shift
        _nLeft = new_left;
        _nRight = new_right;
        for (int i = 0; i < countm1; i++)
        {
            CStripe &s = _aStripe[i];
            s._nTop += dy;
            s.Offset(dx);
        }

        _aStripe[countm1]._nTop += dy;

        return true;
    }

    bool Scale(double coef)
    {
        if (coef <= 0) return false;

        double dbl_left   = _nLeft,
               dbl_right  = _nRight,
               dbl_top    = _aStripe[0]._nTop,
               dbl_bottom = _aStripe[_nCount-1]._nTop,

               new_left   = coef*dbl_left,
               new_right  = coef*dbl_right,
               new_top    = coef*dbl_top,
               new_bottom = coef*dbl_bottom,

               limit = double(int(0x80000000));

        if (new_left   < limit ||
            new_right  < limit ||
            new_top    < limit ||
            new_bottom < limit)
            return false;

               limit = double(int(0x7FFFFFFF));

        if (new_left   > limit ||
            new_right  > limit ||
            new_top    > limit ||
            new_bottom > limit)
            return false;

        _nLeft  = IntNear(new_left);
        _nRight = IntNear(new_right);

        // do scale
        for (int i = 0; i < _nCount-1; i++)
            _aStripe[i].Scale(coef);

            _aStripe[i]._nTop = IntNear(new_bottom);

        return true;
    }

    bool Squeeze(const CRgnData& d);

    void Copy(const CRgnData& d)
    {
        _nCount = d._nCount;
        _nLeft = d._nLeft;
        _nRight = d._nRight;

        int *p = (int*)((char*)this + GetHdrSize());
        const int *q = d._aStripe[0].px();
        int off = p-q;
        for (int i = 0; i < _nCount; i++)
        {
            _aStripe[i]._nTop = d._aStripe[i]._nTop;
            _aStripe[i].setp(d._aStripe[i].px() + off);
        }
        int n = d.GetArySize()/sizeof(int);
        for (i = 0; i < n; i++) p[i] = q[i];
    }


    bool IsEqualTo(const CRgnData& d) const
    {
        if (_nCount != d._nCount) return false;
        for (int i = 0; i < _nCount-1; i++)
        {
            if (!_aStripe[i].IsEqualTo(d._aStripe[i]))
                return false;
        }
        return _aStripe[i]._nTop == d._aStripe[i]._nTop;
    }

    bool Contains(const CPoint& pt) const
    {
        if (pt.x < _nLeft ||
            pt.x >= _nRight ||
            pt.y < _aStripe[0]._nTop ||
            pt.y >= _aStripe[_nCount-1]._nTop)
            return false;
        int i = 0, j = _nCount-1;
        while (j-i > 1)
        {
            int k = (i+j)>>1;
            if (pt.y < _aStripe[k]._nTop) j = k;
            else                        i = k;
        }
        return _aStripe[i].Contains(pt.x);
    }

    bool Contains(const CRect& rc) const;

    static int EstimateSizeUnion(const CRgnData& da, const CRgnData& db);

    void Union(const CRgnData& da, const CRgnData& db);

    static int EstimateSizeIntersect(const CRgnData& da, const CRgnData& db);

    void Intersect(const CRgnData& da, const CRgnData& db);

    static bool Intersects(const CRgnData& da, const CRgnData& db);

    void Intersect(const CRgnData& da, const CRect& r);

    static int EstimateSizeSubtract(const CRgnData& da, const CRgnData& db);

    void Subtract(const CRgnData& da, const CRgnData& db);

#if DBG == 1
    void Dump(const CRegion2* prgn) const;

    #define INVALID return falseBreak()

    static bool falseBreak()
    {
#ifdef _M_IX86
        _asm int 3;
#endif //_M_IX86
        return false;
    }

    bool IsDataValid(bool own) const
    {
        if (_nCount < 2) INVALID;

        int* xHeapMin = (int*)((char*)this + GetHdrSize());
        int* xHeapMax = (int*)((char*)this + (own ? RGN_OWN_MEM_SIZ : MemGetSize((void*)this)));

        if (_aStripe[        0].px() < xHeapMin) INVALID; // header overlaps xHeap
        if (_aStripe[_nCount-1].px() > xHeapMax) INVALID; // xHeap overlaps allocated space

        int xmin = 0x7FFFFFFF,
            xmax = 0x80000000;
        for (int i = 0; i < _nCount-1; i++)
        {
            if (_aStripe[i]._nTop >= _aStripe[i+1]._nTop) INVALID;  // stripes do not go in increasing order by y
            if (_aStripe[i].px()   >  _aStripe[i+1].px()  ) INVALID;  // x arrays mixed
            if (INT_PTR(_aStripe[i].px()) & 3) INVALID;            // odd address
            int l = (char*)_aStripe[i+1].px() - (char*)_aStripe[i].px();
            if (l & 7) INVALID; // stripe size should be even, but does not

            if (l == 0) continue;
            l >>= 2; // measure ints now

            const int *p = _aStripe[i].px();
            if (xmin > *p) xmin = *p;
            for (int j = 0; j < l-1; j++, p++)
                if (p[0] >= p[1]) INVALID;    // x increasing order violation
            if (xmax < *p) xmax = *p;
        }
        if (_nLeft  != xmin) INVALID;
        if (_nRight != xmax) INVALID;
        return true;
    }
#endif
};


// the following routine copies data from given CRgnData
// with removing repeated coordinates
// (possibly appeared after calling Scale(coef < 1).
// Can work in-place (i.e. &d can be == this)
RGN_INLINE
bool CRgnData::Squeeze(const CRgnData& d)
{
    _nLeft  = 0x7FFFFFFF; // will be
    _nRight = 0x80000000; //         recalculated
    int *p = (int*)((char*)this + d.GetHdrSize());
    int ilimit = d._nCount-1;
    _nCount = 0;
    for (int i = 0; i < ilimit; i++)
    {
        const CStripe &src = d._aStripe[i];
        if (src._nTop == (&src+1)->_nTop) continue; // zero-height(width?) stripe

        CStripe &dst = _aStripe[_nCount];
        dst._nTop = src._nTop;
        int *srcBeg = src.px(),
            *srcEnd = (&src+1)->px(),
            srcLen = srcEnd - srcBeg;
        dst.setp(p);
        if (srcLen)
        {
            if (_nLeft  > srcBeg[ 0]) _nLeft  = srcBeg[ 0];
            if (_nRight < srcEnd[-1]) _nRight = srcEnd[-1];

            for (int j = 0; j < srcLen-1;)
            {
                if (srcBeg[j] == srcBeg[j+1])
                {
                    j += 2; // skip this pair
                    continue;
                }
                *p++ = srcBeg[j++];
            }
            if (j < srcLen)
                *p++ = srcBeg[j];
        }

        if (_nCount++)
        {   // check if this newly created stripe is x-equal to previous
            int *pthis = dst.px();
            int *pprev = (&dst-1)->px();
            int nprev = pthis - pprev;
            int nthis = p - pthis;
            if (nprev == nthis)
            {
                for (int k = 0; k < nthis; k++)
                {
                    if (pthis[k] != pprev[k])
                        break;
                }
                if (k == nthis)
                {   // indeed equal; roll back to ignore this stripe
                    p = dst.px();
                    _nCount--;
                }

            }
        }
    }

    if (_nCount == 0) return false;   // totally empty

    // finalize: fill last stripe
    {
        const CStripe &src = d._aStripe[i];
        CStripe &dst = _aStripe[_nCount++];
        dst._nTop = src._nTop;
        dst.setp(p);
    }

    return true;
}


RGN_INLINE
bool CRgnData::Contains(const CRect& rc) const
{
    // if the rect sticks out of my bounding box, return false
    if (rc.left < _nLeft ||
        rc.right > _nRight ||
        rc.top < _aStripe[0]._nTop ||
        rc.bottom > _aStripe[_nCount-1]._nTop)
        return false;

    // check that each stripe that y-touches the rect also x-covers the rect
    int i;
    for (i=0; ; ++i)
    {
        if (rc.bottom <= _aStripe[i]._nTop)
            break;                      // stripe is below the rect - done
        Assert(i < _nCount - 1);        // rect doesn't stick out the bottom
        if (rc.top >= _aStripe[i+1]._nTop)
            continue;                   // stripe is above the rect
        int x = rc.left;                // this stripe x-covers up to x
        const int *px = _aStripe[i].px();
        const int * const pEnd = _aStripe[i+1].px();
        for (;  px < pEnd;  px += 2)
        {
            if (*px > x)
                break;                  // stripe has a gap at x - done
            else if (*(px+1) > x)       // else advance the frontier
                x = *(px+1);
        }
        if (x < rc.right)
            return false;               // gap is within rect
    }
    return true;
}


// label agreement:
// x0 - no stripes of region x passed (x == a or b)
// x1 - some (not all) stripes of region x passed
// x2 - all stripes of region x passed

#define ANEXT qa->_nTop < qb->_nTop
#define BNEXT qa->_nTop > qb->_nTop
#define ALAST qa == paLast
#define BLAST qb == pbLast


RGN_INLINE
int CRgnData::EstimateSizeUnion(const CRgnData& da, const CRgnData& db)
{
    const CStripe *qa = da._aStripe, *paLast = qa + da._nCount;
    const CStripe *qb = db._aStripe, *pbLast = qb + db._nCount;

    int estCount = da._nCount + db._nCount;
    int siz = sizeof(CRgnData) + (estCount-2)*sizeof(CStripe);

#define PLUS_A   siz += (qa-1)->GetSize()
#define PLUS_B   siz += (qb-1)->GetSize()
#define PLUS_AB PLUS_A; PLUS_B
//a0b0:
    if (ANEXT) { qa++;                                {   PLUS_A; goto a1b0; }
    }

    if (BNEXT) {       qb++;                          {   PLUS_B; goto a0b1; }
    }

    {            qa++, qb++;                          {  PLUS_AB; goto a1b1; }
    }

a0b1:
    if (ANEXT) { qa++;                                {  PLUS_AB; goto a1b1; }
    }

    if (BNEXT) {       qb++;               if (BLAST) {           goto a0b2; }
                                                      {   PLUS_B; goto a0b1; }
    }

    {            qa++, qb++;               if (BLAST) {   PLUS_A; goto a1b2; }
                                                      {  PLUS_AB; goto a1b1; }
    }

a1b0:
    if (ANEXT) { qa++;       if (ALAST)               {           goto a2b0; }
                                                      {   PLUS_A; goto a1b0; }
    }

    if (BNEXT) {       qb++;                          {  PLUS_AB; goto a1b1; }
    }

    {            qa++, qb++; if (ALAST)               {   PLUS_B; goto a2b1; }
                                                      {  PLUS_AB; goto a1b1; }
    }

a1b1:
    if (ANEXT) { qa++;       if (ALAST)               {   PLUS_B; goto a2b1; }
                                                      {  PLUS_AB; goto a1b1; }
    }

    if (BNEXT) {       qb++;               if (BLAST) {   PLUS_A; goto a1b2; }
                                                      {  PLUS_AB; goto a1b1; }
    }

    {            qa++, qb++; if (ALAST)  { if (BLAST) {           goto a2b2; }
                                                      {   PLUS_B; goto a2b1; }
                                         }
                                         { if (BLAST) {   PLUS_A; goto a1b2; }
                                                      {  PLUS_AB; goto a1b1; }
                                         }
    }

a0b2:
    {            qa++;                                {   PLUS_A; goto a1b2; }
    }

a1b2:
    {            qa++;       if (ALAST)               {           goto a2b2; }
                                                      {   PLUS_A; goto a1b2; }
    }

a2b0:
    {                  qb++;                          {   PLUS_B; goto a2b1; }
    }

a2b1:
    {                  qb++;               if (BLAST) {           goto a2b2; }
                                                      {   PLUS_B; goto a2b1; }
    }

a2b2:   return siz;
}


RGN_INLINE
void CRgnData::Union(const CRgnData& da, const CRgnData& db)
{
    const CStripe *qa = da._aStripe, *paLast = qa + da._nCount;
    const CStripe *qb = db._aStripe, *pbLast = qb + db._nCount;
          CStripe *p  =    _aStripe;

    int estCount = da._nCount + db._nCount;
    int estHdrSize = sizeof(CRgnData) + (estCount-2)*sizeof(CStripe);

    _aStripe[0].setp((int*)((char*)this + estHdrSize));

#define YSTEP if (p == _aStripe) { if (p->GetSize() != 0) p++; }\
          else               { if (!p->IsEqualToPrevious()) p++; }
#define YSTEPFIN if (p != _aStripe) { if (p->px() != (p-1)->px()) p++; }

#define COPY_A   p->Copy(qa-1);            YSTEP
#define COPY_B   p->Copy(qb-1);            YSTEP

#define COPY_AB  p->Copy(qa-1, qb-1);      YSTEP
#define COPY_BA  p->Copy(qb-1, qa-1);      YSTEP

#define OR_AB    p->Union(qa-1, qb-1);     YSTEP
#define OR_BA    p->Union(qb-1, qa-1);     YSTEP

#define AND_AB   p->Intersect(qa-1, qb-1); YSTEP
#define AND_BA   p->Intersect(qb-1, qa-1); YSTEP

#define ZERO_A   p->Zero(qa-1);            YSTEP
#define ZERO_B   p->Zero(qb-1);            YSTEP

#define SETTOP_A p->SetTop(qa-1);          YSTEPFIN
#define SETTOP_B p->SetTop(qb-1);          YSTEPFIN
//a0b0:
    if (ANEXT) { qa++;                                {   COPY_A; goto a1b0; }
    }

    if (BNEXT) {       qb++;                          {   COPY_B; goto a0b1; }
    }

    {            qa++, qb++;                          {    OR_AB; goto a1b1;}
    }

a0b1:
    if (ANEXT) { qa++;                                {    OR_AB; goto a1b1; }
    }

    if (BNEXT) {       qb++;               if (BLAST) {   ZERO_B; goto a0b2; }
                                                      {   COPY_B; goto a0b1; }
    }

    {            qa++, qb++;               if (BLAST) {   COPY_A; goto a1b2; }
                                                      {    OR_AB; goto a1b1; }
    }

a1b0:
    if (ANEXT) { qa++;       if (ALAST)               {   ZERO_A; goto a2b0; }
                                                      {   COPY_A; goto a1b0; }
    }

    if (BNEXT) {       qb++;                          {    OR_BA; goto a1b1; }
    }

    {            qa++, qb++; if (ALAST)               {   COPY_B; goto a2b1; }
                                                      {    OR_BA; goto a1b1; }
    }


a1b1:
    if (ANEXT) { qa++;       if (ALAST)               {  COPY_BA; goto a2b1; }
                                                      {    OR_AB; goto a1b1; }
    }

    if (BNEXT) {       qb++;               if (BLAST) {  COPY_AB; goto a1b2; }
                                                      {    OR_BA; goto a1b1; }
    }

    {            qa++, qb++; if (ALAST)  { if (BLAST) { SETTOP_A; goto a2b2; }
                                                      {  COPY_BA; goto a2b1; }
                                         }
                                         { if (BLAST) {  COPY_AB; goto a1b2; }
                                                      {    OR_AB; goto a1b1; }
                                         }
    }

a0b2:
    {            qa++;                                {   COPY_A; goto a1b2; }
    }

a1b2:
    {            qa++;       if (ALAST)               { SETTOP_A; goto a2b2; }
                                                      {   COPY_A; goto a1b2; }
    }

a2b0:
    {                  qb++;                          {   COPY_B; goto a2b1; }
    }

a2b1:
    {                  qb++;               if (BLAST) { SETTOP_B; goto a2b2; }
                                                      {   COPY_B; goto a2b1; }
    }

a2b2:
    _nCount = p - _aStripe;
    _nLeft  = da._nLeft  < db._nLeft  ? da._nLeft  : db._nLeft;
    _nRight = da._nRight > db._nRight ? da._nRight : db._nRight;
}


RGN_INLINE
int CRgnData::EstimateSizeIntersect(const CRgnData& da, const CRgnData& db)
{
    const CStripe *qa = da._aStripe, *paLast = qa + da._nCount;
    const CStripe *qb = db._aStripe, *pbLast = qb + db._nCount;

    int estCount = da._nCount + db._nCount;
    int siz = sizeof(CRgnData) + (estCount-2)*sizeof(CStripe);

#define PLUS_A   siz += (qa-1)->GetSize()
#define PLUS_B   siz += (qb-1)->GetSize()
#define PLUS_AB PLUS_A; PLUS_B
//a0b0:
    if (ANEXT) { qa++;                                {           goto a1b0; }
    }

    if (BNEXT) {       qb++;                          {           goto a0b1; }
    }

    {            qa++, qb++;                          {  PLUS_AB; goto a1b1; }
    }

a0b1:
    if (ANEXT) { qa++;                                {  PLUS_AB; goto a1b1; }
    }

    if (BNEXT) {       qb++;               if (BLAST) {           goto a0b2; }
                                                      {           goto a0b1; }
    }

    {            qa++, qb++;               if (BLAST) {           goto a1b2; }
                                                      {  PLUS_AB; goto a1b1; }
    }

a1b0:
    if (ANEXT) { qa++;       if (ALAST)               {           goto a2b0; }
                                                      {           goto a1b0; }
    }

    if (BNEXT) {       qb++;                          {  PLUS_AB; goto a1b1; }
    }

    {            qa++, qb++; if (ALAST)               {           goto a2b1; }
                                                      {  PLUS_AB; goto a1b1; }
    }

a1b1:
    if (ANEXT) { qa++;       if (ALAST)               {           goto a2b1; }
                                                      {  PLUS_AB; goto a1b1; }
    }

    if (BNEXT) {       qb++;               if (BLAST) {           goto a1b2; }
                                                      {  PLUS_AB; goto a1b1; }
    }

    {            qa++, qb++; if ((ALAST) || (BLAST))  {           goto a2b2; }
                                                      {  PLUS_AB; goto a1b1; }
    }

a0b2:
a1b2:
a2b0:
a2b1:
a2b2:   return siz;
}


RGN_INLINE
void CRgnData::Intersect(const CRgnData& da, const CRgnData& db)
{
    const CStripe *qa = da._aStripe, *paLast = qa + da._nCount;
    const CStripe *qb = db._aStripe, *pbLast = qb + db._nCount;
          CStripe *p  =    _aStripe;

    int estCount = da._nCount + db._nCount;
    int estHdrSize = sizeof(CRgnData) + (estCount-2)*sizeof(CStripe);

    _aStripe[0].setp((int*)((char*)this + estHdrSize));

//a0b0:
    if (ANEXT) { qa++;                                {           goto a1b0; }
    }

    if (BNEXT) {       qb++;                          {           goto a0b1; }
    }

    {            qa++, qb++;                          {   AND_AB; goto a1b1;}
    }

a0b1:
    if (ANEXT) { qa++;                                {   AND_AB; goto a1b1; }
    }

    if (BNEXT) {       qb++;               if (BLAST) {           goto a0b2; }
                                                      {           goto a0b1; }
    }

    {            qa++, qb++;               if (BLAST) {           goto a1b2; }
                                                      {   AND_AB; goto a1b1; }
    }

a1b0:
    if (ANEXT) { qa++;       if (ALAST)               {           goto a2b0; }
                                                      {           goto a1b0; }
    }

    if (BNEXT) {       qb++;                          {   AND_BA; goto a1b1; }
    }

    {            qa++, qb++; if (ALAST)               {           goto a2b1; }
                                                      {   AND_BA; goto a1b1; }
    }


a1b1:
    if (ANEXT) { qa++;       if (ALAST)               { SETTOP_A; goto a2b1; }
                                                      {   AND_AB; goto a1b1; }
    }

    if (BNEXT) {       qb++;               if (BLAST) { SETTOP_B; goto a1b2; }
                                                      {   AND_BA; goto a1b1; }
    }

    {            qa++, qb++; if ((ALAST) || (BLAST))  { SETTOP_A; goto a2b2; }
                                                      {   AND_AB; goto a1b1; }
    }

a0b2:
a1b2:
a2b0:
a2b1:
a2b2:
    _nCount = p - _aStripe;
    if (_nCount)
    {   // calculate hor bounds
        _nLeft = 0x7FFFFFFF, _nRight = 0x80000000;
        p--;
        int *pLeft = p->px();
        while (--p >= _aStripe)
        {
            int *pLeftPrev = pLeft;
            pLeft = p->px();
            if (pLeft == pLeftPrev) continue;
            int t = *pLeft; if (_nLeft > t) _nLeft = t;
            t = pLeftPrev[-1]; if (_nRight < t) _nRight = t;
        }
    }
}


// "Incomplete intersecting":
// Just to understand that there exist at least one point
// belonging to both given regions
RGN_INLINE
bool CRgnData::Intersects(const CRgnData& da, const CRgnData& db)
{
    const CStripe *qa = da._aStripe, *paLast = qa + da._nCount;
    const CStripe *qb = db._aStripe, *pbLast = qb + db._nCount;

#define AND_CHECK if (CStripe::Intersects(qa-1, qb-1)) return true
//a0b0:
    if (ANEXT) { qa++;                                {            goto a1b0; }
    }

    if (BNEXT) {       qb++;                          {            goto a0b1; }
    }

    {            qa++, qb++;                          { AND_CHECK; goto a1b1;}
    }

a0b1:
    if (ANEXT) { qa++;                                { AND_CHECK; goto a1b1; }
    }

    if (BNEXT) {       qb++;               if (BLAST) {            goto a0b2; }
                                                      {            goto a0b1; }
    }

    {            qa++, qb++;               if (BLAST) {            goto a1b2; }
                                                      { AND_CHECK; goto a1b1; }
    }

a1b0:
    if (ANEXT) { qa++;       if (ALAST)               {            goto a2b0; }
                                                      {            goto a1b0; }
    }

    if (BNEXT) {       qb++;                          { AND_CHECK; goto a1b1; }
    }

    {            qa++, qb++; if (ALAST)               {            goto a2b1; }
                                                      { AND_CHECK; goto a1b1; }
    }


a1b1:
    if (ANEXT) { qa++;       if (ALAST)               {            goto a2b1; }
                                                      { AND_CHECK; goto a1b1; }
    }

    if (BNEXT) {       qb++;               if (BLAST) {            goto a1b2; }
                                                      { AND_CHECK; goto a1b1; }
    }

    {            qa++, qb++; if ((ALAST) || (BLAST))  {            goto a2b2; }
                                                      { AND_CHECK; goto a1b1; }
    }

a0b2:
a1b2:
a2b0:
a2b1:
a2b2:
    return false;
}


RGN_INLINE
int CRgnData::EstimateSizeSubtract(const CRgnData& da, const CRgnData& db)
{
    const CStripe *qa = da._aStripe, *paLast = qa + da._nCount;
    const CStripe *qb = db._aStripe, *pbLast = qb + db._nCount;

    int estCount = da._nCount + db._nCount;
    int siz = sizeof(CRgnData) + (estCount-2)*sizeof(CStripe);

#define PLUS_A   siz += (qa-1)->GetSize()
#define PLUS_B   siz += (qb-1)->GetSize()
#define PLUS_AB PLUS_A; PLUS_B
//a0b0:
    if (ANEXT) { qa++;                                {   PLUS_A; goto a1b0; }
    }

    if (BNEXT) {       qb++;                          {           goto a0b1; }
    }

    {            qa++, qb++;                          {  PLUS_AB; goto a1b1; }
    }

a0b1:
    if (ANEXT) { qa++;                                {  PLUS_AB; goto a1b1; }
    }

    if (BNEXT) {       qb++;               if (BLAST) {           goto a0b2; }
                                                      {           goto a0b1; }
    }

    {            qa++, qb++;               if (BLAST) {   PLUS_A; goto a1b2; }
                                                      {  PLUS_AB; goto a1b1; }
    }

a1b0:
    if (ANEXT) { qa++;       if (ALAST)               {           goto a2b0; }
                                                      {   PLUS_A; goto a1b0; }
    }

    if (BNEXT) {       qb++;                          {  PLUS_AB; goto a1b1; }
    }

    {            qa++, qb++; if (ALAST)               {           goto a2b1; }
                                                      {  PLUS_AB; goto a1b1; }
    }

a1b1:
    if (ANEXT) { qa++;       if (ALAST)               {           goto a2b1; }
                                                      {  PLUS_AB; goto a1b1; }
    }

    if (BNEXT) {       qb++;               if (BLAST) {   PLUS_A; goto a1b2; }
                                                      {  PLUS_AB; goto a1b1; }
    }

    {            qa++, qb++; if (ALAST)  { if (BLAST) {           goto a2b2; }
                                                      {           goto a2b1; }
                                         }
                                         { if (BLAST) {   PLUS_A; goto a1b2; }
                                                      {  PLUS_AB; goto a1b1; }
                                         }
    }

a0b2:
    {            qa++;                                {   PLUS_A; goto a1b2; }
    }

a1b2:
    {            qa++;       if (ALAST)               {           goto a2b2; }
                                                      {   PLUS_A; goto a1b2; }
    }

a2b0:
a2b1:
a2b2:   return siz;
}


#define SUB_AB    p->Subtract(qa-1, qb-1, qa-1);   YSTEP
#define SUB_BA    p->Subtract(qa-1, qb-1, qb-1);   YSTEP
RGN_INLINE
void CRgnData::Subtract(const CRgnData& da, const CRgnData& db)
{
    const CStripe *qa = da._aStripe, *paLast = qa + da._nCount;
    const CStripe *qb = db._aStripe, *pbLast = qb + db._nCount;
          CStripe *p  =    _aStripe;

    int estCount = da._nCount + db._nCount;
    int estHdrSize = sizeof(CRgnData) + (estCount-2)*sizeof(CStripe);

    _aStripe[0].setp((int*)((char*)this + estHdrSize));

//a0b0:
    if (ANEXT) { qa++;                                {   COPY_A; goto a1b0; }
    }

    if (BNEXT) {       qb++;                          {           goto a0b1; }
    }

    {            qa++, qb++;                          {   SUB_AB; goto a1b1;}
    }

a0b1:
    if (ANEXT) { qa++;                                {   SUB_AB; goto a1b1; }
    }

    if (BNEXT) {       qb++;               if (BLAST) {           goto a0b2; }
                                                      {           goto a0b1; }
    }

    {            qa++, qb++;               if (BLAST) {   COPY_A; goto a1b2; }
                                                      {   SUB_AB; goto a1b1; }
    }

a1b0:
    if (ANEXT) { qa++;       if (ALAST)               { SETTOP_A; goto a2b0; }
                                                      {   COPY_A; goto a1b0; }
    }

    if (BNEXT) {       qb++;                          {   SUB_BA; goto a1b1; }
    }

    {            qa++, qb++; if (ALAST)               { SETTOP_A; goto a2b1; }
                                                      {   SUB_BA; goto a1b1; }
    }


a1b1:
    if (ANEXT) { qa++;       if (ALAST)               { SETTOP_A; goto a2b1; }
                                                      {   SUB_AB; goto a1b1; }
    }

    if (BNEXT) {       qb++;               if (BLAST) {  COPY_AB; goto a1b2; }
                                                      {   SUB_BA; goto a1b1; }
    }

    {            qa++, qb++; if (ALAST)  {            { SETTOP_A; goto a2b2; }
                                         }
                                         { if (BLAST) {  COPY_AB; goto a1b2; }
                                                      {   SUB_AB; goto a1b1; }
                                         }
    }

a0b2:
    {            qa++;                                {   COPY_A; goto a1b2; }
    }

a1b2:
    {            qa++;       if (ALAST)               { SETTOP_A; goto a2b2; }
                                                      {   COPY_A; goto a1b2; }
    }

a2b0:
a2b1:
a2b2:
    _nCount = p - _aStripe;
    if (_nCount)
    {   // calculate hor bounds
        _nLeft = 0x7FFFFFFF, _nRight = 0x80000000;
        p--;
        int *pLeft = p->px();
        while (--p >= _aStripe)
        {
            int *pLeftPrev = pLeft;
            pLeft = p->px();
            if (pLeft == pLeftPrev) continue;
            int t = *pLeft; if (_nLeft > t) _nLeft = t;
            t = pLeftPrev[-1]; if (_nRight < t) _nRight = t;
        }
    }
}


//+===========================================================================
//
//                          CRegion2
//
//============================================================================

#define TMP_MEM_SIZ 200


//+---------------------------------------------------------------------------
//
//  Member:     CRegion2::~CRegion2
//
//----------------------------------------------------------------------------
CRegion2::~CRegion2()
{
    FreeMemory();
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegion2::SetEmpty
//
//  Synopsis:   Remove all the points from region
//
//----------------------------------------------------------------------------
CRegion2&
CRegion2::SetEmpty()
{
    FreeMemory();
    _pData = 0;
    return *this;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegion2::Swap
//
//  Synopsis:   Exchange content of this and given region
//
//  Arguments:  r       ref to given region
//
//----------------------------------------------------------------------------
void
CRegion2::Swap(CRegion2& r)
{
    if (UsingOwnMemory())
    {
        CRgnData *pData = Data();
        Assert(pData->GetMinSize() <= RGN_OWN_MEM_SIZ);
        if (r.UsingOwnMemory())
        {
            CRgnData *prData = r.Data();
            Assert(prData->GetMinSize() <= RGN_OWN_MEM_SIZ);

            char tmpMem[RGN_OWN_MEM_SIZ];
            CRgnData *p = (CRgnData*)tmpMem;
                      p->Copy(*prData);
                               prData->Copy(*pData);
                                             pData->Copy(*p);
        }
        else
        {
            _pData = r._pData;
            r.UseOwnMemory();
            r.Data()->Copy(*pData);
        }
    }
    else if (r.UsingOwnMemory())
    {
        CRgnData *prData = r.Data();
        Assert(prData->GetMinSize() <= RGN_OWN_MEM_SIZ);
        r._pData = _pData;
        UseOwnMemory();
        Data()->Copy(*prData);
    }
    else
    {
        CRgnData* t = _pData;
                      _pData = r._pData;
                               r._pData = t;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegion2::SetRectangle
//
//  Synopsis:   Create rectangular region, containing points (x,y),
//              r.left <= x < r.right
//              r.top  <= y < r.bottom
//
//  Arguments:  r       ref to given rectangle
//
//----------------------------------------------------------------------------

CRegion2&
CRegion2::SetRectangle(const CRect& r)
{
    FreeMemory();

    if (r.IsEmpty())
        _pData = 0;
    else
    {
        Assert(RGN_OWN_MEM_SIZ >= (sizeof(CRgnData) + 2*sizeof(int)));
        UseOwnMemory();
        Data()->SetRectangle(r.left, r.top, r.right, r.bottom);
    }
    return *this;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegion2::SetRectangle
//
//  Synopsis:   Create rectangular region, containing points (x,y),
//              left <= x < right
//              top  <= y < bottom
//
//  Arguments:  left        |
//              top         |   rectangle
//              right       |   limits
//              bottom      |
//
//----------------------------------------------------------------------------
CRegion2&
CRegion2::SetRectangle(int left, int top, int right, int bottom)
{
    FreeMemory();

    if (left >= right || top >= bottom)
        _pData = 0;
    else
    {
        Assert(RGN_OWN_MEM_SIZ >= (sizeof(CRgnData) + 2*sizeof(int)));
        UseOwnMemory();
        Data()->SetRectangle(left, top, right, bottom);
    }
    return *this;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegion2::IsRectangular
//
//  Synopsis:   check whether region has rectangular shape
//
//  Arguments:  no
//
//  Returns:    TRUE if region has rectangular shape
//
//  Note:       Empty region returns FALSE
//
//----------------------------------------------------------------------------
BOOL
CRegion2::IsRectangular() const
{
    CRgnData *pData = Data();
    if (pData == 0) return FALSE;
    if (pData->_nCount != 2) return FALSE;
    if (pData->_aStripe[1].px() - pData->_aStripe[0].px() != 2) return FALSE;
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegion2::IsRectangle
//
//  Synopsis:   check whether region has rectangular shape of given size
//
//  Arguments:  left        |
//              top         |   rectangle
//              right       |   limits
//              bottom      |
//
//  Returns:    TRUE if would be equal to region made
//                   by SetRectanle(left, top, right, bottom)
//
//----------------------------------------------------------------------------
BOOL
CRegion2::IsRectangle(int left, int top, int right, int bottom) const
{
    return IsEmpty() ? FALSE : Data()->IsRectangle(left, top, right, bottom);
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegion2::GetBoundingRect
//
//  Synopsis:   get minimal rectangle including all region points
//
//  Arguments:  rc      reference to rectangle to fill
//
//  Returns:    FALSE if region is empty
//
//----------------------------------------------------------------------------
BOOL
CRegion2::GetBoundingRect(CRect &rc) const
{
    if (IsEmpty()) return FALSE;
    Data()->GetBoundingRect(rc);
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegion2::Union
//
//  Synopsis:   Calculate the union of two regions:
//              Resulting region contains points
//              presenting at least in one of this and given regions
//
//  Arguments:  r      reference to second region
//
//----------------------------------------------------------------------------
void
CRegion2::Union(const CRegion2& r)
{
    if (r.IsEmpty()) return;
    if (IsEmpty()) { Copy(r); return; }

    CRgnData *pData  = Data();
    CRgnData *prData = r.Data();

    int es = CRgnData::EstimateSizeUnion(*pData, *prData);
    char tmpMem[TMP_MEM_SIZ];
    CRgnData *result = es <= TMP_MEM_SIZ
                     ? (CRgnData*)tmpMem
                     : (CRgnData*)new char[es];
    if (result == NULL)
        return;
    result->Union(*pData, *prData);

    FreeMemory();

    int rs = result->GetMinSize();
    if (rs <= RGN_OWN_MEM_SIZ)
    {
        UseOwnMemory();
        Data()->Copy(*result);
        if (result != (CRgnData*)tmpMem)
            delete[] (char*)result;
    }
    else if (result == (CRgnData*)tmpMem)
    {
        CRgnData *pData = (CRgnData*)new char[rs];
        if (pData == NULL)
            return;
        _pData = pData;
        _pData->Copy(*result);
    }
    else
        _pData = result;

    ASSERT_RGN_VALID
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegion2::Intersect
//
//  Synopsis:   Calculate the intersection of two regions:
//              Resulting region contains points
//              presenting at least in both this and given regions
//
//  Arguments:  r      reference to second region
//
//----------------------------------------------------------------------------
void
CRegion2::Intersect(const CRegion2& r)
{
    if (r.IsEmpty()) { SetEmpty(); return; }

    if (IsEmpty()) return;

    CRgnData *pData  = Data();
    CRgnData *prData = r.Data();

    int es = CRgnData::EstimateSizeIntersect(*pData, *prData);
    char tmpMem[TMP_MEM_SIZ];
    CRgnData *result = es <= TMP_MEM_SIZ
                     ? (CRgnData*)tmpMem
                     : (CRgnData*)new char[es];
    if (result == NULL)
        return;
    result->Intersect(*pData, *prData);

    FreeMemory();

    if (result->_nCount == 0)
    {
        if (result != (CRgnData*)tmpMem)
            delete[] (char*)result;
        _pData = 0;
        return;
    }

    int rs = result->GetMinSize();
    if (rs <= RGN_OWN_MEM_SIZ)
    {
        UseOwnMemory();
        Data()->Copy(*result);
        if (result != (CRgnData*)tmpMem)
            delete[] (char*)result;
    }
    else if (result == (CRgnData*)tmpMem)
    {
        CRgnData *pData = (CRgnData*)new char[rs];
        if (pData == NULL)
            return;
        _pData = pData;
        _pData->Copy(*result);
    }
    else
        _pData = result;

    ASSERT_RGN_VALID
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegion2::Intersects
//
//  Synopsis:   Incomplete intersecting:
//              Just to understand that there exist at least one point
//              belonging to both given regions
//
//  Arguments:  r      reference to second region
//
//  Returns:    TRUE if regions have nonempty intersection
//
//----------------------------------------------------------------------------
BOOL
CRegion2::Intersects(const CRegion2& r) const
{
    if (r.IsEmpty()) return FALSE;
    if (  IsEmpty()) return FALSE;


    return CRgnData::Intersects(*Data(), *r.Data());
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegion2::Subtract
//
//  Synopsis:   Calculate the "difference" of two regions:
//              Resulting region contains points
//              that present in this region but not in given region
//
//  Arguments:  r      reference to second region
//
//----------------------------------------------------------------------------
void
CRegion2::Subtract(const CRegion2& r)
{
    if (r.IsEmpty()) return;

    if (IsEmpty()) return;

    CRgnData *pData  = Data();
    CRgnData *prData = r.Data();

    int es = CRgnData::EstimateSizeSubtract(*pData, *prData);
    char tmpMem[TMP_MEM_SIZ];
    CRgnData *result = es <= TMP_MEM_SIZ
                     ? (CRgnData*)tmpMem
                     : (CRgnData*)new char[es];
    if (result == NULL)
        return;
    result->Subtract(*pData, *prData);

    FreeMemory();

    if (result->_nCount == 0)
    {
        if (result != (CRgnData*)tmpMem)
            delete[] (char*)result;
        _pData = 0;
        return;
    }

    int rs = result->GetMinSize();
    if (rs <= RGN_OWN_MEM_SIZ)
    {
        UseOwnMemory();
        Data()->Copy(*result);
        if (result != (CRgnData*)tmpMem)
            delete[] (char*)result;
    }
    else if (result == (CRgnData*)tmpMem)
    {
        CRgnData *pData = (CRgnData*)new char[rs];
        if (pData == NULL)
            return;
        _pData = pData;
        _pData->Copy(*result);
    }
    else
        _pData = result;


    ASSERT_RGN_VALID
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegion2::operator==
//
//  Synopsis:   Compare two regions
//
//  Arguments:  r      reference to second region
//
//  Returns:    TRUE if this region is equal to given
//
//  Note: two regions, A and B, are considered to be equal if
//        each point contained in A is contained in B, and
//        each point contained in B is contained in A.
//
//----------------------------------------------------------------------------
BOOL
CRegion2::operator==(const CRegion2& r) const
{
    if (IsEmpty()) return r.IsEmpty();
    if (r.IsEmpty()) return FALSE;
    return Data()->IsEqualTo(*r.Data());
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegion2::operator!=
//
//  Synopsis:   Compare two regions
//
//  Arguments:  r      reference to second region
//
//  Returns:    TRUE if this region is not equal to given
//
//----------------------------------------------------------------------------
BOOL
CRegion2::operator!=(const CRegion2& r) const
{
    if (IsEmpty()) return !r.IsEmpty();
    if (r.IsEmpty()) return TRUE;
    return !Data()->IsEqualTo(*r.Data());
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegion2::operator==
//
//  Synopsis:   Compare this region and rectangle
//
//  Arguments:  r      reference to rectangle
//
//  Returns:    TRUE if this region is equal to given rect.
//              Equivalent of operator==(CRegion2(r))
//
//----------------------------------------------------------------------------
BOOL
CRegion2::operator==(const CRect& r) const
{
    return IsEmpty() ? r.IsRectEmpty() : Data()->IsEqualTo(r);
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegion2::operator!=
//
//  Synopsis:   Compare this region and rectangle
//
//  Arguments:  r      reference to rectangle
//
//  Returns:    TRUE if this region is not equal to given rect.
//
//----------------------------------------------------------------------------
BOOL
CRegion2::operator!=(const CRect& r) const
{
    return IsEmpty() ? !r.IsRectEmpty() : !Data()->IsEqualTo(r);
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegion2::Contains
//
//  Synopsis:   Check whether given point is contained in this region
//
//  Arguments:  pt      reference to point
//
//  Returns:    TRUE if this region contains given point
//
//----------------------------------------------------------------------------
BOOL
CRegion2::Contains(const CPoint& pt) const
{
    if (IsEmpty())
        return FALSE;

    return Data()->Contains(pt);
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegion2::Contains
//
//  Synopsis:   Check whether given rect is contained in this region
//
//  Arguments:  rc      reference to rect
//
//  Returns:    TRUE if this region contains given rect
//
//----------------------------------------------------------------------------
BOOL
CRegion2::Contains(const CRect& rc) const
{
    if (IsEmpty())
        return FALSE;

    return Data()->Contains(rc);
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegion2::CRegion2
//
//  Synopsis:   Construct region of rectangle
//
//  Arguments:  r      reference to rectangle
//
//----------------------------------------------------------------------------
CRegion2::CRegion2(const CRect& r)
{
    if (r.IsEmpty())
        _pData = 0;
    else
    {
        Assert(RGN_OWN_MEM_SIZ >= (sizeof(CRgnData) + 2*sizeof(int)));
        UseOwnMemory();
        Data()->SetRectangle(r.left, r.top, r.right, r.bottom);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegion2::CRegion2
//
//  Synopsis:   Construct rectangular region
//
//  Arguments:  left        |
//              top         |   rectangle
//              right       |   limits
//              bottom      |
//
//----------------------------------------------------------------------------
CRegion2::CRegion2(int left, int top, int right, int bottom)
{
    if (left >= right || top >= bottom)
        _pData = 0;
    else
    {
        Assert(RGN_OWN_MEM_SIZ >= (sizeof(CRgnData) + 2*sizeof(int)));
        UseOwnMemory();
        Data()->SetRectangle(left, top, right, bottom);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CRegion2::CRegion2
//
//  Synopsis:   Construct region as a copy of given one
//
//  Arguments:  r       reference to given region
//
//----------------------------------------------------------------------------
CRegion2::CRegion2(const CRegion2& r)
{
    if (r.IsEmpty())
        _pData = 0;
    else
    {
        int rs = r.Data()->GetMinSize();
        if (rs <= RGN_OWN_MEM_SIZ)
        {
            UseOwnMemory();
        }
        else
        {
            _pData = (CRgnData*)new char[rs];
            if (_pData == NULL)
                return;
        }
        Data()->Copy(*r.Data());
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegion2::Copy
//
//  Synopsis:   Copy of given region to this one
//
//  Arguments:  r       reference to given region
//
//  Note: if given region contains unused gaps in data,
//        they will be renmoved while copying
//
//----------------------------------------------------------------------------
void
CRegion2::Copy(const CRegion2& r)
{
    FreeMemory();
    if (r.IsEmpty())
        _pData = 0;
    else
    {
        int rs = r.Data()->GetMinSize();
        if (rs <= RGN_OWN_MEM_SIZ)
        {
            UseOwnMemory();
        }
        else
        {
            _pData = (CRgnData*)new char[rs];
            if (_pData == NULL)
                return;
        }
        Data()->Copy(*r.Data());
    }
}


//----------------------- windows operations -------------------------------------//


//+---------------------------------------------------------------------------
//
//  Member:     static CRegion2::MakeRgnOfRectAry
//
//  Synopsis:   Compose region of given array of rectangles.
//
//  Arguments:  pRect       pointer to aray of rectangles
//              nRect       amount of rectangles in array
//
//  Returns:    New region
//
//  Note:   nRect should not be zero
//
//----------------------------------------------------------------------------
CRegion2*
CRegion2::MakeRgnOfRectAry(CRect *pRect, int nRect)
{
    if (nRect  == 1)
        return new CRegion2(*pRect);

    int nHalf = nRect >> 1;
    CRegion2 *a = MakeRgnOfRectAry(pRect, nHalf),
             *b = MakeRgnOfRectAry(pRect+nHalf, nRect-nHalf);
    if(a && b)
    {
        a->Union(*b);
    }
    else
    {
        delete a;
        a = NULL;
    }
    delete b;
    return a;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegion2::ConvertFromWindows
//
//  Synopsis:   Compose region identical to given Window's region
//
//  Arguments:  hRgn        handle to Windows region
//
//  Returns:    FALSE if any error returned by call to Windows
//
//----------------------------------------------------------------------------
BOOL
CRegion2::ConvertFromWindows(HRGN hRgn)
// returns false on error returned by Windows
{
    DWORD dwCount = GetRegionData(hRgn, 0, 0);
    BOOL ok = FALSE;

    if (dwCount == 0)
        return FALSE;

    LPRGNDATA lpRgnData = (LPRGNDATA)new char[dwCount];
    if (lpRgnData)
    {
        DWORD dwCountReturned = GetRegionData(hRgn, dwCount, lpRgnData);

        ok = dwCountReturned == dwCount;
        if (ok)
            ok = lpRgnData->rdh.iType == RDH_RECTANGLES;
        if (ok)
        {
            CRect *pRectAry = (CRect*)((char*)lpRgnData + lpRgnData->rdh.dwSize);
            int nRectAry = lpRgnData->rdh.nCount;
            if (nRectAry == 0) SetEmpty();
            else
            {
                CRegion2 *r = MakeRgnOfRectAry(pRectAry, lpRgnData->rdh.nCount);
                if (r)
                {
                    Swap(*r);
                    delete r;
                }
            }
        }

        delete[] (char*)lpRgnData;
    }
    return ok;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegion2::ConvertToWindows
//
//  Synopsis:   Compose Windows region identical to this
//
//  Arguments:  no
//
//  Returns:    handle to new Windows region
//
//----------------------------------------------------------------------------

#if DBG == 1
// Win9x 16-bit overflow defence helper
static void Win9xOverflowDefence(RECT *prc, int n)
{
    static const int min = -0x3FFF, max = 0x3FFF;

    for (int i = 0; i < n; i++, prc++)
    {
        RECT *p = prc+i;
        if (p->left < min || p->top < min || p->right > max || p->bottom > max)
        {
            AssertSz(FALSE, "Rectangle too big for ExtCreateRegion in Win9x");
            break; // single assertion is quite enough
        }
    }

    // correct remaining RECTs without assertion
    for (; i < n; i++, prc++)
    {
        RECT *p = prc+i;
        if (p->left   < min) p->left   = min;
        if (p->top    < min) p->top    = min;
        if (p->right  > max) p->right  = max;
        if (p->bottom > max) p->bottom = max;
    }
}
#endif

HRGN
CRegion2::ConvertToWindows() const
{
    if (IsEmpty())
        return ::CreateRectRgn(0,0,0,0);

    CRgnData *pData = Data();

    int n = pData->CountRectangles();

    DWORD dwRgnDataSize = sizeof(RGNDATAHEADER) + n*sizeof(RECT);
    LPRGNDATA lpRgnData = (LPRGNDATA)new char[dwRgnDataSize];
    if (lpRgnData == NULL)
        return NULL;

    lpRgnData->rdh.dwSize = sizeof(RGNDATAHEADER);
    lpRgnData->rdh.iType = RDH_RECTANGLES;
    lpRgnData->rdh.nCount = n;
    lpRgnData->rdh.nRgnSize = 0;
    pData->GetBoundingRect(lpRgnData->rdh.rcBound);
    pData->GetAllRectangles((RECT*)(lpRgnData->Buffer));

    //IF_DBG(Win9xOverflowDefence((RECT*)(lpRgnData->Buffer), n));

    HRGN hRgn = ::ExtCreateRegion(0, dwRgnDataSize, lpRgnData);
    delete[] (char*)lpRgnData;
    return hRgn;
}

//----------------------------- transformations --------------------------------//

//+---------------------------------------------------------------------------
//
//  Member:     CRegion2::Offset
//
//  Synopsis:   Shift all the points in region by given 2d vector
//
//  Arguments:  s       reference to CSize containing shift vector
//
//  Returns:    FALSE if given vector is too big and
//              conversion can't be provided because of int32 overflow
//
//----------------------------------------------------------------------------
BOOL
CRegion2::Offset(const CSize& s)
{
    if (IsEmpty()) return TRUE;
    BOOL ok = Data()->Offset(s.cx, s.cy);
    ASSERT_RGN_VALID
    return ok;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegion2::Scale
//
//  Synopsis:   Stretch given region from (0,0) center
//
//  Arguments:  coef        stretch coefficient
//
//  Returns:    FALSE if given coef is zero, negative or big so much that
//              conversion can't be provided because of int32 overflow
//
//  Note:   Scaling with coef < 1 can brake the region shape:
//          slightly different coordinates can became equal, and some
//          areas can merge. To keep region data in legal state, the
//          special Squeeze routine is executed. This routine removes
//          merged edges and decrease region data size.
//
//----------------------------------------------------------------------------
BOOL
CRegion2::Scale(double coef)
{
    if (coef <= 0) return FALSE;
    if (IsEmpty()) return TRUE;

    CRgnData *pData = Data();

    F2I_FLOW;

    if (!pData->Scale(coef)) return FALSE;
    if (coef < 1)
    {
        if (!pData->Squeeze(*pData))
        {
            FreeMemory();
            _pData = 0;
        }
        else if (!UsingOwnMemory() && pData->GetMinSize() <= RGN_OWN_MEM_SIZ)
        {
            UseOwnMemory();
            Data()->Copy(*pData);
            delete[] (char*)pData;
        }
    }

    ASSERT_RGN_VALID
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegion2::Transform
//
//  Synopsis:   Transform region
//
//  Note: Made of CRegion::Transform by donmarsh without deep thoughts
//
//----------------------------------------------------------------------------

void
CRegion2::Transform(const CWorldTransform *pTransform, BOOL fRoundOut)
{
    // NOTE:  In some (rare) scenarios, rotating a region must
    //        produce a polygon. In most cases, we'll want to
    //        get a bounding rectangle instead (for performance reasons,
    //        or just to make our life easier).
    //        If these two different behaviors are actually
    //        desired, we need to use different transformation methods,
    //        or maybe a flag.


    if (IsEmpty())
        return;

    CRgnData *pData = Data();

    //
    // apply transformations
    //

    // speed optimization for offset-only matrix
    if (pTransform->IsOffsetOnly())
    {
        Offset(pTransform->GetOffsetOnly());
        return;
    }

    if (pTransform->FTransforms())
    {
        int n = pData->CountRectangles();
        CRect* pRect = new CRect[n];
        if (pRect)
        {
            pData->GetAllRectangles(pRect);

            for (int i = 0; i < n; i++)
            {
                CRect srcRect = pRect[i];
                pTransform->GetBoundingRectAfterTransform(&srcRect, &pRect[i], fRoundOut);
            }

            CRegion2* r = MakeRgnOfRectAry(pRect, n);
            delete[] pRect;
            if (r)
            {
                Swap(*r);
                delete r;
            }
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegion2::Untransform
//
//  Synopsis:   Untransform region
//
//  Note: Made of CRegion::Untransform by donmarsh without deep thoughts
//
//----------------------------------------------------------------------------
void
CRegion2::Untransform(const CWorldTransform *pTransform)
{
    // apply the reverse transformation
    //REVIEW dmitryt: we do have a reverse matrix in CWorldTransform,
    //                I guess we could optimize things here not calculating a new one..
    //          To Do: use cached reverse matrix from CWorldTransform.

    Assert(pTransform);

    // speed optimization in case we only have an offset
    if (pTransform->IsOffsetOnly())
    {
        Offset(-pTransform->GetOffsetOnly());
        return;
    }

    CWorldTransform transformReverse(pTransform);
    transformReverse.Reverse();
    Transform(&transformReverse, TRUE);
}


#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Member:     DumpRegion, Dump
//
//  Synopsis:   debugging
//
//----------------------------------------------------------------------------
void
DumpRegion(const CRegion2& rgn)
{
    rgn.Dump();
}

void
CRegion2::Dump() const
{
    Data()->Dump(this);
}

void
CRgnData::Dump(const CRegion2* prgn) const
{
    TraceTagEx((0, TAG_NONAME, "CRegion2 %x  bounds (%d,%d,%d,%d)", prgn,
                _nLeft, _aStripe[0]._nTop, _nRight, _aStripe[_nCount-1]._nTop));

    for (int i = 0, n = _nCount-1; i < n; i++)
    {
        const CStripe &s = _aStripe[i];
        int *p = s.px();
        int m = ((&s+1)->px() - p) >> 1;

        int top = s._nTop;
        int bottom = (&s+1)->_nTop;

        for (int j = 0; j < m; j++)
        {
            TraceTagEx((0, TAG_NONAME, "    Slice %d rect %d (%d,%d,%d,%d)",
                        i, j, p[2*j], top, p[2*j+1], bottom));
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\display\regionstack.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       regionstack.cxx
//
//  Contents:   Store regions associated with particular display nodes.
//
//  Classes:    CRegionStack
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_REGIONSTACK_HXX_
#define X_REGIONSTACK_HXX_
#include "regionstack.hxx"
#endif


//+---------------------------------------------------------------------------
//
//  Member:     CRegionStack::CRegionStack
//              
//  Synopsis:   Constructor that creates a new region stack clipped to the
//              given band rectangle.
//              
//  Arguments:  rgnStack        region stack to copy
//              rcgBand          band rectangle to clip regions
//              
//  Notes:      
//              
//----------------------------------------------------------------------------


CRegionStack::CRegionStack(const CRegionStack& rgnStack, const CRect& rcgBand)
{
    _stackIndex = 0;
    
    // copy regions that intersect the band
    for (int i = 0; i < rgnStack._stackMax; i++)
    {
        // unless the bounds of an opaque item intersects this band, we're not
        // interested
        if (rcgBand.Intersects(rgnStack._stack[i]._rcgBounds))
        {
            CRegion* prgng = new CRegion(*rgnStack._stack[i]._prgng);

            if (prgng == NULL)
                break;

            prgng->Intersect(rcgBand);
            
            // believe it or not, both the opaque item's bounds AND the new
            // redraw region have to intersect this band in order for us
            // to put this entry in the stack
            if (prgng->IsEmpty())
            {
                delete prgng;
            }
            else
            {
                prgng->Offset(-rcgBand.TopLeft().AsSize());
                stackElement* p = &_stack[_stackIndex++];
                p->_prgng = prgng;
                p->_key = rgnStack._stack[i]._key;
            }
        }
    }
    
    _stackMax = _stackIndex;
}


#if DBG==1
//+---------------------------------------------------------------------------
//
//  Member:     CRegionStack::~CRegionStack
//              
//  Synopsis:   destructor
//              
//----------------------------------------------------------------------------


CRegionStack::~CRegionStack()
{
    Assert(_stackMax == 0);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\download\bits.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       bits.cxx
//
//  Contents:   CBitsCtx
//              CBitsInfo
//              CBitsLoad
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_BITS_HXX_
#define X_BITS_HXX_
#include "bits.hxx"
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_FATSTG_HXX_
#define X_FATSTG_HXX_
#include "fatstg.hxx"
#endif

#ifndef X_PRGSNK_H_
#define X_PRGSNK_H_
#include <prgsnk.h>
#endif

// Debugging ------------------------------------------------------------------

PerfDbgTag(tagBitsBuffer, "Dwn", "! Force CBitsCtx to buffer data")
PerfDbgTag(tagBitsInfo,   "Dwn", "Trace CBitsInfo")
PerfDbgTag(tagBitsLoad,   "Dwn", "Trace CBitsLoad")
MtDefine(CBitsCtx, Dwn, "CBitsCtx")
MtDefine(CBitsInfo, Dwn, "CBitsInfo")
MtDefine(CBitsInfoGetFile, Dwn, "CBitsInfo::GetFile")
MtDefine(CBitsLoad, Dwn, "CBitsLoad")

// CBitsCtx -------------------------------------------------------------------

void
CBitsCtx::SelectChanges(ULONG ulChgOn, ULONG ulChgOff, BOOL fSignal)
{
    WORD wNewChg = 0;

    EnterCriticalSection();

    _wChgReq &= (WORD)~ulChgOff;

    if (    fSignal
        &&  !(_wChgReq & DWNCHG_COMPLETE)
        &&  (ulChgOn & DWNCHG_COMPLETE)
        &&  GetDwnInfo()->TstFlags(DWNLOAD_COMPLETE))
    {
        wNewChg = DWNCHG_COMPLETE;
    }

    _wChgReq |= (WORD)ulChgOn;
    
    if (wNewChg)
    {
        super::Signal(wNewChg);
    }

    LeaveCriticalSection();
}

HRESULT
CBitsCtx::GetStream(IStream ** ppStream)
{
    return(((CBitsInfo *)GetDwnInfo())->GetStream(ppStream));
}

// CBitsInfo ------------------------------------------------------------------

HRESULT
CBitsInfo::Init(DWNLOADINFO * pdli)
{
    _dwClass = pdli->dwProgClass ? pdli->dwProgClass : PROGSINK_CLASS_MULTIMEDIA;
    
    RRETURN(THR(super::Init(pdli)));
}

CBitsInfo::~CBitsInfo()
{
    PerfDbgLog(tagBitsInfo, this, "+CBitsInfo::~CBitsInfo");

    if (_hLock)
    {
        InternetUnlockRequestFile(_hLock);
    }

    if (_pDwnStm)
        _pDwnStm->Release();

    if (_fIsTemp && _cstrFile)
    {
        DeleteFile(_cstrFile);
    }

    PerfDbgLog(tagBitsInfo, this, "-CBitsInfo::~CBitsInfo");
}

HRESULT
CBitsInfo::GetFile(LPTSTR * ppch)
{
    RRETURN(_cstrFile ? MemAllocString(Mt(CBitsInfoGetFile), _cstrFile, ppch) : E_FAIL);
}

HRESULT
CBitsInfo::NewDwnCtx(CDwnCtx ** ppDwnCtx)
{
    *ppDwnCtx = new CBitsCtx;
    RRETURN(*ppDwnCtx ? S_OK : E_OUTOFMEMORY);
}

HRESULT
CBitsInfo::NewDwnLoad(CDwnLoad ** ppDwnLoad)
{
    *ppDwnLoad = new CBitsLoad;
    RRETURN(*ppDwnLoad ? S_OK : E_OUTOFMEMORY);
}

HRESULT
CBitsInfo::OnLoadFile(LPCTSTR pszFile, HANDLE * phLock, BOOL fIsTemp)
{
    PerfDbgLog2(tagBitsInfo, this, "+CBitsInfo::OnLoadFile (psz=%ls,hLock=%lX)", pszFile, phLock ? *phLock : NULL);

    HRESULT hr = THR(_cstrFile.Set(pszFile));

    if (hr == S_OK)
    {
        if (phLock)
        {
            _hLock = *phLock;
            *phLock = NULL;
        }

        _fIsTemp = fIsTemp;
    }

    PerfDbgLog1(tagBitsInfo, this, "-CBitsInfo::OnLoadFile (hr=%lX)", hr);
    RRETURN(hr);
}

void
CBitsInfo::OnLoadDwnStm(CDwnStm * pDwnStm)
{
    Assert(_pDwnStm == NULL);
    _pDwnStm = pDwnStm;
    _pDwnStm->AddRef();
}

void
CBitsInfo::OnLoadDone(HRESULT hrErr)
{
    PerfDbgLog1(tagBitsInfo, this, "+CBitsInfo::OnLoadDone (hrErr=%lX)", hrErr);

    Assert(EnteredCriticalSection());

    UpdFlags(DWNLOAD_MASK, !hrErr ? DWNLOAD_COMPLETE : DWNLOAD_ERROR);
    Signal(DWNCHG_COMPLETE);

    PerfDbgLog(tagBitsInfo, this, "-CBitsInfo::OnLoadDone");
}

BOOL
CBitsInfo::AttachEarly(UINT dt, DWORD dwRefresh, DWORD dwFlags, DWORD dwBindf)
{
    // In order to attach to an existing CBitsInfo, the following must match:
    //      _cstrUrl            (Already checked by caller)
    //      _dwRefresh
    //      DWNF_DOWNLOADONLY
    //      BINDF_OFFLINEOPERATION
    
    return( GetRefresh() == dwRefresh
        &&  GetFlags(DWNF_DOWNLOADONLY) == (dwFlags & DWNF_DOWNLOADONLY)
        &&  _dt == dt
        &&  (GetBindf() & BINDF_OFFLINEOPERATION) == (dwBindf & BINDF_OFFLINEOPERATION));
}

HRESULT
CBitsInfo::GetStream(IStream ** ppStream)
{
    PerfDbgLog(tagBitsInfo, this, "+CBitsInfo::GetStream");

    HRESULT hr;

    if (_cstrFile)
    {
        hr = THR(CreateStreamOnFile(_cstrFile,
                    STGM_READ | STGM_SHARE_DENY_NONE,
                    ppStream));
        if (hr)
            goto Cleanup;
    }
    else if (_pDwnStm)
    {
        hr = THR(CreateStreamOnDwnStm(_pDwnStm, ppStream));
        if (hr)
            goto Cleanup;
    }
    else
    {
        hr = E_FAIL;
        *ppStream = NULL;
    }

Cleanup:
    PerfDbgLog1(tagBitsInfo, this, "-CBitsInfo::GetStream (hr=%lX)", hr);
    RRETURN(hr);
}

// CBitsLoad ---------------------------------------------------------------

CBitsLoad::~CBitsLoad()
{
    if (_pDwnStm)
        _pDwnStm->Release();

    ReleaseInterface(_pStmFile);
}

HRESULT
CBitsLoad::Init(DWNLOADINFO * pdli, CDwnInfo * pDwnInfo)
{
    PerfDbgLog(tagBitsLoad, this, "+CBitsLoad::Init");

    HRESULT hr;

    hr = THR(super::Init(pdli, pDwnInfo, 
        IDS_BINDSTATUS_DOWNLOADINGDATA_BITS,
        DWNF_GETFILELOCK|DWNF_NOAUTOBUFFER|DWNF_GETSTATUSCODE|DWNF_GETMODTIME));

    PerfDbgLog1(tagBitsLoad, this, "-CBitsLoad::Init (hr=%lX)", hr);
    RRETURN(hr);
}

HRESULT
CBitsLoad::OnBindHeaders()
{
    PerfDbgLog(tagBitsLoad, this, "+CBitsLoad::OnBindHeaders");

    LPCTSTR     pch;
    HANDLE      hLock = NULL;
    HRESULT     hr = S_OK;
    DWORD       dwStatusCode = _pDwnBindData->GetStatusCode();
    BOOL        fPretransform;

    #if DBG==1 || defined(PERFTAGS)
    if (IsPerfDbgEnabled(tagBitsBuffer))
        goto Cleanup;
    #endif

    if ((dwStatusCode >= 400) && (dwStatusCode < 600))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    GetBitsInfo()->SetLastMod( _pDwnBindData->GetLastMod() );
    OnHeaders(S_OK);

    pch = _pDwnBindData->GetFileLock(&hLock, &fPretransform);
    
    if (fPretransform)
    {
        // we don't want to hold onto this file, we always want the bits
        if (hLock)
        {
            InternetUnlockRequestFile(hLock);
            hLock = NULL;
        }
        pch = NULL;
    }
    
    if (pch)
    {
        hr = THR(GetBitsInfo()->OnLoadFile(pch, &hLock, FALSE));
        if (hr)
            goto Cleanup;

        _fGotFile = TRUE;

        if (    _pDwnBindData->GetScheme() == URL_SCHEME_FILE
            ||  _pDwnBindData->IsFullyAvail())
        {
            CDwnDoc * pDwnDoc = _pDwnBindData->GetDwnDoc();

            if (pDwnDoc)
            {
                DWNPROG DwnProg;
                _pDwnBindData->GetProgress(&DwnProg);
                pDwnDoc->AddBytesRead(DwnProg.dwMax);
            }

            _pDwnBindData->Disconnect();
            OnDone(S_OK);

            hr = S_FALSE;
        }
    }

Cleanup:
    if (hLock)
        InternetUnlockRequestFile(hLock);
    PerfDbgLog1(tagBitsLoad, this, "-CBitsLoad::OnBindHeaders (hr=%lX)", hr);
    RRETURN1(hr, S_FALSE);
}

HRESULT
CBitsLoad::OnBindData()
{
    PerfDbgLog(tagBitsLoad, this, "+CBitsLoad::OnBindData");

    BYTE    ab[1024];
    ULONG   cb;
    HRESULT hr;

    if (!_fGotData)
    {
        _fGotData = TRUE;

        if (!_fGotFile)
        {
            if (GetBitsInfo()->_dt == DWNCTX_FILE)
            {
                if (_pDwnBindData->GetScheme() == URL_SCHEME_HTTPS)
                {
                    // No can do for secure connections.  The user has told
                    // us to not write secure data to disk (because otherwise
                    // we would have gotten a cache file name already).

                    hr = E_FAIL;
                    goto Cleanup;
                }

                // Create a temporary file for storing the data.

                TCHAR achFileName[MAX_PATH];
                TCHAR achPathName[MAX_PATH];
                DWORD dwRet;

                dwRet = GetTempPath(ARRAY_SIZE(achPathName), achPathName);
                if (!(dwRet && dwRet < ARRAY_SIZE(achPathName)))
                {
                    hr = E_FAIL;
                    goto Cleanup;
                }

                if (!GetTempFileName(achPathName, _T("dat"), 0, achFileName))
                {
                    hr = E_FAIL;
                    goto Cleanup;
                }

                hr = THR(CreateStreamOnFile(achFileName,
                         STGM_READWRITE | STGM_SHARE_DENY_WRITE | STGM_CREATE,
                         &_pStmFile));
                if (hr)
                    goto Cleanup;

                hr = THR(GetBitsInfo()->OnLoadFile(achFileName, NULL, TRUE));
                if (hr)
                    goto Cleanup;
            }
            else
            {
                // We only need to provide access to the data, not a file,
                // so just buffer the data as it comes in.

                _pDwnStm = new CDwnStm;

                if (_pDwnStm == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

                _pDwnStm->SetSeekable();

                GetBitsInfo()->OnLoadDwnStm(_pDwnStm);
            }
        }
    }

    if (_pDwnStm)
    {
        void *  pv;
        ULONG   cbW, cbR;

        for (;;)
        {
            hr = THR(_pDwnStm->WriteBeg(&pv, &cbW));
            if (hr)
                goto Cleanup;

            Assert(cbW > 0);

            hr = THR(_pDwnBindData->Read(pv, cbW, &cbR));
            if (hr)
                break;

            Assert(cbR <= cbW);

            _pDwnStm->WriteEnd(cbR);

            if (cbR == 0)
                break;
        }
    }
    else
    {
        for (;;)
        {
            hr = THR(_pDwnBindData->Read(ab, sizeof(ab), &cb));

            if (hr || !cb)
                break;

            if (_pStmFile)
            {
                hr = THR(_pStmFile->Write(ab, cb, NULL));
                if (hr)
                    goto Cleanup;
            }
        }
    }

Cleanup:
    PerfDbgLog1(tagBitsLoad, this, "-CBitsLoad::OnBindData (hr=%lX)", hr);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\display\xgdi.cxx ===
/*****************************************************************************
*
*   xgdi.cxx
*
*   This file contains the implementation of the transforming GDI fns.
*
*   Ported from Quill on 5/20/99 - alexmog
*
*   Created: 12/29/93 - warrenb
*
*   Copyright 1990-1995 Microsoft Corporation.  All rights reserved.
*   Microsoft confidential.
*
*****************************************************************************/

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MATH_H_
#define X_MATH_H_
#include <math.h>
#endif

#ifndef X_XGDI2_HXX_
#define X_XGDI2_HXX_
#include "xgdi2.hxx"
#endif

#ifndef X_DISPGDI16BIT_HXX_
#define X_DISPGDI16BIT_HXX_
#include "dispgdi16bit.hxx"
#endif

#ifndef X_DISPSURFACE_HXX_
#define X_DISPSURFACE_HXX_
#include "dispsurface.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_DDRAW_H_
#define X_DDRAW_H_
#include "ddraw.h"
#endif

#ifndef X_DDRAWEX_H_
#define X_DDRAWEX_H_
#include <ddrawex.h>
#endif

extern const ZERO_STRUCTS     g_Zero;
extern IDirectDraw *    g_pDirectDraw;

MtDefine(XHDC, DisplayTree, "XHDC");
MtDefine(XHDC_LocalBitmaps, XHDC, "XHDC local bitmaps");
MtDefine(CTransformWidthsArray, DisplayTree, "width space allocated for transformations");
MtExtern(Mem);

DeclareTag(tagXFormFont, "Font", "XFormFont trace");

class CNewWidths : public CStackDataAry<INT, 100>
{
public:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(Mem))
    DECLARE_MEMMETER_NEW;
    CNewWidths() : CStackDataAry<INT,100>(Mt(CTransformWidthsArray)){}
    INT *GetWidths(INT *lpdxdOriginal) { return lpdxdOriginal ? &Item(0) : NULL; }
    void TransformWidthsArray(INT *lpdxd, UINT cch, double scf);
};

class CNewOffsets : public CStackDataAry<GOFFSET, 50>
{
public:
    DECLARE_MEMALLOC_NEW_DELETE(Mt(Mem))
    DECLARE_MEMMETER_NEW;
    CNewOffsets() : CStackDataAry<GOFFSET,50>(Mt(CTransformWidthsArray)){}
    GOFFSET *GetOffsets(GOFFSET *pO) { return pO ? &Item(0) : NULL; }
    void TransformOffsetsArray(GOFFSET *pOffset, UINT cch, double sx, double sy);
};

static void RotateBitmap(const BITMAP& bmSrc, BITMAP& bmDst, int rotation);

ExternTag(tagFilterPaintScreen);

#ifdef USEADVANCEDMODE
DeclareTag(tagEmulateTransform, "Display:EmulateTransform", "Emulate Transformations on WinNT");

inline BOOL EmulateTransform()
{
    return g_dwPlatformID != VER_PLATFORM_WIN32_NT
        WHEN_DBG(|| IsTagEnabled(tagEmulateTransform)) ;
}

class CAdvancedDC
{
public:
    CAdvancedDC(const XHDC* pxhdc)
    {
        _pSurface = pxhdc->pSurface();
        if (_pSurface)
        {
            const CWorldTransform* pTransform = _pSurface->GetWorldTransform();
            Assert(pTransform);
            _hdc = _pSurface->GetRawDC();
            Assert(_hdc);
            // set advanced mode the first time we encounter an advanced transform,
            // and never go back!
            ::SetGraphicsMode(_hdc, GM_ADVANCED);
            ::GetWorldTransform(_hdc, &_xf);
            Assert(_xf.eM11==1.0f && _xf.eM12==0.0f &&
                   _xf.eM21==0.0f && _xf.eM22==1.0f &&
                   _xf.eDx ==0.0f && _xf.eDy ==0.0f);
            ::SetWorldTransform(_hdc, pTransform->GetXform());
        }
        else
        {
            _hdc = pxhdc->hdc();
        }
    }
    
    ~CAdvancedDC()
    {
        if (_pSurface)
            ::SetWorldTransform(_hdc, &_xf);
    }
    
    operator HDC()
    {
        return _hdc;
    }
    
private:
    const CDispSurface* _pSurface;
    HDC     _hdc;
    XFORM   _xf;
};
#endif


class CXFormFont
{
public:
#if DBG==1
    CXFormFont(const XHDC* pxhdc, BOOL fStockFont = FALSE);
#else
    CXFormFont(const XHDC* pxhdc);
#endif
    ~CXFormFont();

private:
    HFONT _hFontOld;
    HFONT _hFontNew;
    const XHDC *_pxhdc;
};

inline static void Translate(const SIZE* psizeOffset, int* px, int* py)
{
    *px += psizeOffset->cx;
    *py += psizeOffset->cy;
    CDispGdi16Bit::Assert16Bit(*px, *py);
}

inline static void Translate(const SIZE* psizeOffset, int* px1, int* py1, int* px2, int* py2)
{
    Translate(psizeOffset, px1, py1);
    Translate(psizeOffset, px2, py2);
}

inline static void Translate(const SIZE* psizeOffset, LONG* px, LONG* py)
{
    *px += psizeOffset->cx;
    *py += psizeOffset->cy;
    CDispGdi16Bit::Assert16Bit(*px, *py);
}

inline static void Translate(const SIZE* psizeOffset, LONG* px1, LONG* py1, LONG* px2, LONG* py2)
{
    Translate(psizeOffset, px1, py1);
    Translate(psizeOffset, px2, py2);
}

inline static void Translate(const SIZE* psizeOffset, POINT* ppt)
{
    ppt->x += psizeOffset->cx;
    ppt->y += psizeOffset->cy;
    CDispGdi16Bit::Assert16Bit(*ppt);
}

inline static void Translate(const SIZE* psizeOffset, RECT* prc)
{
    Translate(psizeOffset, &prc->left, &prc->top);
    Translate(psizeOffset, &prc->right, &prc->bottom);
}

static void Translate(const SIZE* psizeOffset, POINT* ppt, int cpt)
{
    for (; cpt > 0; ppt++, cpt--)
    {
        Translate(psizeOffset, ppt);
    }
}

// GDI MoveTo and LineTo fill in the pixel below and to the right of the
// given point.  If we've done a rotation, we actually want to fill in
// a different pixel.  For example, after rotation by 270 degrees we want
// to fill in the pixel below and to the *left* of the point.  This function
// makes the necessary adjustment.

void
XHDC::TransformPtWithCorrection(POINT *ppt) const
{
    ANG ang = AngNormalize(transform().GetAngle()) + (ang90 / 2);

    TransformPt(ppt);

    // rotations of 180 or 270 degrees require adjusting x by -1.  We'll
    // extend that to rotations between 135 and 315 degrees, for generality.
    if (ang180 <= ang && ang < ang360)
        ppt->x -= 1;

    // We need to adjust y for 90 and 180 degrees.  Extend to angles between
    // 45 and 225.  The boundaries are at 45-degree marks to move any possible
    // discontinuities away from the common cases of 90-degree rotations.
    // And we add 45 degrees first so we can use the handy ang* constants.
    if (ang90 <= ang && ang < ang270)
        ppt->y -= 1;
}


BOOL
XHDC::TransformRect(CRect *prc) const
{
    if (!prc->IsEmpty())
    {
        RRC rrc;
        RrcFromMatRc(&rrc, &mat(), prc);
        rrc.GetBounds(prc);
        return rrc.IsAxisAlignedRect();
    }
    else
    {
        return TRUE;
    }
}


/****************************************************************************
*
*  %%Function: GetObjectType
*
* This function returns the GDI object type of the DC.  Because ::GetObjectType
*   is slow and throws exceptions on W9x, we compute the type once (the first
*   time we need it), and cache the result.
*
****************************************************************************/
DWORD
XHDC::GetObjectType() const
{
    if (_dwObjType == 0)
    {
#ifdef COMPILER_UNDERSTANDS_MUTABLE
        // TODO (sambent) _dwObjType is marked mutable, but VC still
        // won't let me change it from a const method.  The doc (for VC 5.0)
        // says this is supposed to work, goldarn it.
        _dwObjType = ::GetObjectType(hdc());    // _dwObjType is mutable
#else
        // here's the standard workaround.  It's a hack...
        XHDC *pThis = const_cast<XHDC*>(this);
        pThis->_dwObjType = ::GetObjectType(hdc());
#endif
    }

    return _dwObjType;
}


/****************************************************************************
*
*  %%Function: CptGetArcPoints
*
*  %%Owner:    t-erick
*
*  %%Reviewed: 00/00/00
*
* This function fills a buffer with the points that describe a single arc.
*  If the arc data passed in describes a straight segment, only one point
*  is placed in the buffer, that point being the same as the first point
*  in the arc data buffer.
*
****************************************************************************/
#define cptMaxInc       5
#define cptPolyMax      160
#define cptOpenPolyMax  (cptPolyMax+1)
#define cptClipPolyMax  (2 * cptOpenPolyMax)
#define iptPyMax        cptPolyMax
#define radTwoPI        (2 * PI)

int CptGetArcPoints(CPoint *pptBuf, CPoint *pptArcData, int cptMax, int dzlThreshold, BOOL fForRotGdi)
{
    struct tagArcData
    {
        CPoint ptStart;
        CPoint ptCenter;
        int dxlRad;
        int dylRad;
        CPoint ptEnd;
    } ArcData;
    
    float radStartAngle;
    float radEndAngle;
    float radTotAngle;
    float radDegInc = 0, radCurrDeg;
    float radCosDegInc;
    int  ipt;                // Index into buffer for polygon points
    long lxTemp, lyTemp;
    int  dxlRadAbs;
    int  dylRadAbs;
    long dzlRadLargest;

    // Assert that the start & end points are valid

    Assert( cptMax && cptMax < iptPyMax );

    if (!fForRotGdi)
        // Always copy segment starting point directly
        pptBuf[0] = pptArcData[0];
    else
        cptMax--; // because we'll compute last point too

    // Copy arc data into local buffer so we can change it at will

    BltLpb(pptArcData, &ArcData, sizeof(ArcData));

    // Since we have an arc, get more detailed info

    dxlRadAbs = abs(ArcData.dxlRad);
    dylRadAbs = abs(ArcData.dylRad);
    dzlRadLargest = max(dxlRadAbs, dylRadAbs);

    // Translate start & end points of ellipse to be centered at the origin

    ArcData.ptStart.x -= ArcData.ptCenter.x;
    ArcData.ptStart.y -= ArcData.ptCenter.y;
    ArcData.ptEnd.x   -= ArcData.ptCenter.x;
    ArcData.ptEnd.y   -= ArcData.ptCenter.y;

    // Scale radii so that points lie on a circle

    if( dylRadAbs > dxlRadAbs && ArcData.dxlRad != 0 )
        {
        ArcData.ptStart.x = MulDivR( dylRadAbs, ArcData.ptStart.x, dxlRadAbs );
        ArcData.ptEnd.x   = MulDivR( dylRadAbs, ArcData.ptEnd.x,   dxlRadAbs );
        }
    else if( dxlRadAbs > dylRadAbs && ArcData.dylRad != 0 )
        {
        ArcData.ptStart.y = MulDivR( dxlRadAbs, ArcData.ptStart.y, dylRadAbs );
        ArcData.ptEnd.y   = MulDivR( dxlRadAbs, ArcData.ptEnd.y,   dylRadAbs );
        }

    // Calculate total degree sweep for arc

    radStartAngle = atan2((float)ArcData.ptStart.y, (float)ArcData.ptStart.x);
    radEndAngle = atan2((float)ArcData.ptEnd.y, (float)ArcData.ptEnd.x);

    // Normalize angles

    if (ArcData.dxlRad > 0)
        radStartAngle += radTwoPI;
    else
        radStartAngle -= radTwoPI;

    radTotAngle = radEndAngle;
    radTotAngle -= radStartAngle;

    while (radTotAngle > radTwoPI)
        radTotAngle -= radTwoPI;
    while (radTotAngle < -radTwoPI)
        radTotAngle += radTwoPI;

    Assert(radTotAngle >= -radTwoPI && radTotAngle <= radTwoPI);

    // Calculate degree increment according to resolution of output device

    if (dzlRadLargest != 0)
        {
        // Keep adjusting the max. point count until the error in the
        // arc is greater than one device unit

        do  {
            cptMax -= cptMaxInc;

            radDegInc = radTotAngle;
            radDegInc /= cptMax;

            if (radDegInc < 0)
            	radDegInc = -radDegInc;
            radDegInc /= 2;
            radCosDegInc = cos(radDegInc);

            } while ((dzlRadLargest * (1 - radCosDegInc)) < dzlThreshold &&
                     cptMax > cptMaxInc);

        // We went one step too far, so get a more accurate point count

        cptMax += cptMaxInc;

        // Calculate final degree increment

        radDegInc = radTotAngle;
        radDegInc /= cptMax;

        } /* if there is a radius we need to calculate a valid increment */

    if (fForRotGdi)
        cptMax++; // radDegInc based on 1 less so endpoint will be output

    // Calculate actual points

    for (ipt = (fForRotGdi ? 0 : 1) ; ipt < cptMax; ipt++)
        {
        radCurrDeg = radDegInc;
        radCurrDeg *= ipt;
        radCurrDeg += radStartAngle;

        while (radCurrDeg >= radTwoPI)
            radCurrDeg -= radTwoPI;
        while (radCurrDeg < 0)
            radCurrDeg += radTwoPI;

        // Calculate ellipse X at current degree

        lxTemp = dxlRadAbs * cos(radCurrDeg);

        // Calculate ellipse Y at current degree

        lyTemp = dylRadAbs * sin(radCurrDeg);

        // transform point back to original ellipse center

        lxTemp += ArcData.ptCenter.x;
        lyTemp += ArcData.ptCenter.y;

        // Store point

        pptBuf[ipt].x = lxTemp;
        pptBuf[ipt].y = lyTemp;

        } /* for looping through arc sweep, calculating points */

#undef cptMaxInc

    Assert(ipt <= cptMax);
    return ipt;

} /* CptGetArcPoints */


/****************************************************************************
*
*                         BEZIER/POLYGON HELPER FUNCTIONS
*
* Module internal fn prototypes for Bezier/Polygon helper functions
*****************************************************************************/

// max. 5 levels of recursion / segment (32 points)
#define MAX_BEZIER_RECURSE  (5)

typedef struct
    {
    CPoint pt1;
    CPoint pt2;
    CPoint pt3;
    int iLevel;
    } GPT;

/****************************************************************************
* %%Function: CptBezierLine   %%Owner:kennyy   Reviewed:0/0/0
*
* Generates a Bezier segment within the specified tolerance and stack limit,
* returning the number of points generated. Returns 0 if it can't fit the line
* into the buffer with these parameters.
*****************************************************************************/
int CptBezierLine(CPoint *rgptvControl, CPoint *rgptv, int cptMax, long dzlThreshold, int log2Cpt)
{
    CPoint ptvStart = rgptvControl[0];
    GPT gptvCur;
    GPT rggptvStack[6];
    int iStackDepth = 0;
    BOOL fSplit = fFalse;
    int cpt = 0;

    Assert(log2Cpt < 6);

    BltLpb(&rgptvControl[1], &gptvCur, sizeof(GPT));
    gptvCur.iLevel = 0;

    Assert(1 << log2Cpt <= cptMax);

    while (cpt < cptMax)
        {
        if (gptvCur.iLevel < log2Cpt)
            {
            GPT gptvL;
            CPoint ptvH;

            gptvL.pt1.x = (ptvStart.x + gptvCur.pt1.x) >> 1;
            gptvL.pt1.y = (ptvStart.y + gptvCur.pt1.y) >> 1;
            ptvH.x = (gptvCur.pt1.x + gptvCur.pt2.x) >> 1;
            ptvH.y = (gptvCur.pt1.y + gptvCur.pt2.y) >> 1;
            gptvL.pt2.x = (gptvL.pt1.x + ptvH.x) >> 1;
            gptvL.pt2.y = (gptvL.pt1.y + ptvH.y) >> 1;
            gptvCur.pt2.x = (gptvCur.pt2.x + gptvCur.pt3.x) >> 1;
            gptvCur.pt2.y = (gptvCur.pt2.y + gptvCur.pt3.y) >> 1;
            gptvCur.pt1.x = (ptvH.x + gptvCur.pt2.x) >> 1;
            gptvCur.pt1.y = (ptvH.y + gptvCur.pt2.y) >> 1;
            gptvL.pt3.x = (gptvL.pt2.x + gptvCur.pt1.x) >> 1;
            gptvL.pt3.y = (gptvL.pt2.y + gptvCur.pt1.y) >> 1;

            if ((labs(gptvL.pt3.x - ((gptvCur.pt3.x + ptvStart.x) >> 1))+
                 labs(gptvL.pt3.y - ((gptvCur.pt3.y + ptvStart.y) >> 1)) >= dzlThreshold)
                 || !fSplit)
                {
                gptvL.iLevel = ++gptvCur.iLevel;
                rggptvStack[iStackDepth++] = gptvCur;
                gptvCur = gptvL;
                fSplit = fTrue;
                continue;
                }
            }
        rgptv[cpt++] = gptvCur.pt3;
        if (iStackDepth == 0)
            return cpt;
        ptvStart = gptvCur.pt3;
        gptvCur = rggptvStack[--iStackDepth];
        }
        
    return 0;
}


/****************************************************************************
*
*                         BEZIER/POLYGON HELPER FUNCTIONS
*
* The following are functions which make the generation of arbitrary bezier
* polygons easier.
*****************************************************************************/


/****************************************************************************
* %%Function:AddBezierPts       %%Owner:warrenb             Reviewed:03/01/94
*
* Adds up to 2^cPts to the Polygon Array passed in rgpt. The points specified
* by the bezier end & control points passed. starting at ipt the value of ipt
* is updated to reflect the current index.
*****************************************************************************/
void AddBezierPts(CPoint rgpt[], int *pipt,
                  const CPoint& ptEnd1, const CPoint& ptEnd2,
                  const CPoint& ptCtrl1, const CPoint& ptCtrl2, int cPtsLog2)
{
    CPoint rgptControl[4];
    int cpt;
    int ipt;

    // don't allow more than 32pts per bezier seg
    Assert(cPtsLog2<6);

    rgptControl[0] = ptEnd1;
    rgptControl[1] = ptCtrl1;
    rgptControl[2] = ptCtrl2;
    rgptControl[3] = ptEnd2;

    // get better precision: mult by 256
    for (ipt = 0; ipt < 4; ipt++)
        {
        Assert(labs(rgptControl[ipt].x <= 0x007FFFFF));
        Assert(labs(rgptControl[ipt].y <= 0x007FFFFF));
        rgptControl[ipt].x <<= 8;
        rgptControl[ipt].y <<= 8;
        }

    // Generate to 1 pixel tolerance
    cpt = CptBezierLine(rgptControl, &(rgpt[*pipt]), 1 << cPtsLog2, 256, cPtsLog2);
    Assert(cpt != 0);

    // Scale back
    for (ipt = 0; ipt < cpt; ipt++)
        {
        rgpt[*pipt + ipt].x >>= 8;
        rgpt[*pipt + ipt].y >>= 8;
        }

    *pipt += cpt;
} // AddBezierPts

/****************************************************************************
* %%Function:FillPolygonRoundRect  %%Owner:warrenb         Reviewed:03/01/94
*
* Creates the points for the round rect passed in the passed polygon array.
* Called by RotRoundedRect & CreateRoundRectRgn. returns # pts used
*****************************************************************************/
#define iptEnd1   0
#define iptEnd2   1
#define iptCtl1   2
#define iptCtl2   3

int XHDC::FillPolygonRoundRect(CPoint  *rgptPolygon,
                               int ptdvLeft, int ptdvTop,
                               int ptdvRight, int ptdvBottom,
                               int nWidthEllipse, int nHeightEllipse) const
{
    CRect  rc;
    int nWidthCtrl;
    int nHeightCtrl;
    CPoint  rgptBez[4];
    int iptPolygon;

    if (ptdvTop > ptdvBottom)
        SwapVal(ptdvTop, ptdvBottom);
    if (ptdvLeft > ptdvRight)
        SwapVal(ptdvLeft, ptdvRight);

    nWidthEllipse  = min(ptdvRight - ptdvLeft, nWidthEllipse );
    nHeightEllipse = min(ptdvBottom - ptdvTop, nHeightEllipse );

    nWidthCtrl = (nWidthEllipse << 3) / 29;
    nHeightCtrl = (nHeightEllipse << 3) / 29;

    // half the height&width ellipses
    nWidthEllipse >>= 1;
    nHeightEllipse >>= 1;

    SetRc(&rc, ptdvLeft, ptdvTop, ptdvRight, ptdvBottom);

    iptPolygon = 0;

    // top left corner
    SetPt(&rgptBez[iptEnd1], rc.left, rc.top+nHeightEllipse);
    SetPt(&rgptBez[iptEnd2], rc.left + nWidthEllipse, rc.top);
    SetPt(&rgptBez[iptCtl1], rgptBez[iptEnd1].x, rgptBez[iptEnd1].y - nHeightCtrl);
    SetPt(&rgptBez[iptCtl2], rgptBez[iptEnd2].x - nWidthCtrl, rgptBez[iptEnd2].y);
    TransformRgpt(rgptBez, 4);
    rgptPolygon[iptPolygon++] = rgptBez[iptEnd1];
    AddBezierPts(&(rgptPolygon[0]), &iptPolygon,
                 rgptBez[iptEnd1], rgptBez[iptEnd2],
                 rgptBez[iptCtl1], rgptBez[iptCtl2], MAX_BEZIER_RECURSE);

    // top right corner
    SetPt(&rgptBez[iptEnd1], rc.right, rc.top + nHeightEllipse);
    SetPt(&rgptBez[iptEnd2], rc.right - nWidthEllipse, rc.top);
    SetPt(&rgptBez[iptCtl1], rgptBez[iptEnd1].x, rgptBez[iptEnd1].y - nHeightCtrl);
    SetPt(&rgptBez[iptCtl2], rgptBez[iptEnd2].x + nWidthCtrl, rgptBez[iptEnd2].y);
    TransformRgpt(rgptBez, 4);
    rgptPolygon[iptPolygon++] = rgptBez[iptEnd2];
    AddBezierPts(&(rgptPolygon[0]), &iptPolygon,
                 rgptBez[iptEnd2], rgptBez[iptEnd1],
                 rgptBez[iptCtl2], rgptBez[iptCtl1], MAX_BEZIER_RECURSE);

    // bottom right corner
    SetPt(&rgptBez[iptEnd1], rc.right, rc.bottom - nHeightEllipse);
    SetPt(&rgptBez[iptEnd2], rc.right - nWidthEllipse, rc.bottom);
    SetPt(&rgptBez[iptCtl1], rgptBez[iptEnd1].x, rgptBez[iptEnd1].y + nHeightCtrl);
    SetPt(&rgptBez[iptCtl2], rgptBez[iptEnd2].x + nWidthCtrl, rgptBez[iptEnd2].y);
    TransformRgpt(rgptBez, 4);
    rgptPolygon[iptPolygon++] = rgptBez[iptEnd1];
    AddBezierPts(&(rgptPolygon[0]), &iptPolygon,
                 rgptBez[iptEnd1], rgptBez[iptEnd2],
                 rgptBez[iptCtl1], rgptBez[iptCtl2], MAX_BEZIER_RECURSE);

    // bottom left corner
    SetPt(&rgptBez[iptEnd1], rc.left, rc.bottom - nHeightEllipse);
    SetPt(&rgptBez[iptEnd2], rc.left + nWidthEllipse, rc.bottom);
    SetPt(&rgptBez[iptCtl1], rgptBez[iptEnd1].x, rgptBez[iptEnd1].y + nHeightCtrl);
    SetPt(&rgptBez[iptCtl2], rgptBez[iptEnd2].x - nWidthCtrl, rgptBez[iptEnd2].y);
    TransformRgpt(rgptBez, 4);
    rgptPolygon[iptPolygon++] = rgptBez[iptEnd2];
    AddBezierPts(&(rgptPolygon[0]), &iptPolygon,
                 rgptBez[iptEnd2], rgptBez[iptEnd1],
                 rgptBez[iptCtl2], rgptBez[iptCtl1], MAX_BEZIER_RECURSE);

    return iptPolygon;
} // FillPolygonRoundRect

/****************************************************************************
* %%Function:FillPolygonEllipse  %%Owner:warrenb         Reviewed:03/01/94
*
* Creates the points for the else passed in the passed polygon array. Called
* by RotEllipse & CreateEllipticRgn. returns the number of points used
*****************************************************************************/
int XHDC::FillPolygonEllipse(CPoint  *rgptPolygon,
                             int xdvLeft, int ydvTop,
                             int xdvRight, int ydvBottom) const
{
    Assert(!IsOffsetOnly());

    CRect      rc;
    CPoint      rgptBez[4];
    int     iptPolygon;
    int     xMid, yMid, xCtrl, yCtrl;
    long    xWidth, yHeight;

    SetRc(&rc, xdvLeft, ydvTop, xdvRight, ydvBottom);

    // midpoints of rect
    xMid = (xdvLeft + xdvRight) >> 1;
    yMid = (ydvTop + ydvBottom) >> 1;

    // dimensions of rect
    xWidth = (long)(xdvRight - xdvLeft);
    yHeight = (long)(ydvBottom - ydvTop);

    // length of control points
    xCtrl = (int)((xWidth << 3L) / 29L);
    yCtrl = (int)((yHeight << 3L) / 29L);

    iptPolygon = 0;

    // 1st Quadrant
    SetPt(&rgptBez[iptEnd1], rc.left,		yMid);
    SetPt(&rgptBez[iptEnd2], xMid,			rc.top);
    SetPt(&rgptBez[iptCtl1], rc.left,		yMid - yCtrl);
    SetPt(&rgptBez[iptCtl2], xMid - xCtrl,	rc.top);
    TransformRgpt(rgptBez, 4);
    rgptPolygon[iptPolygon++] = rgptBez[0];
    AddBezierPts(&(rgptPolygon[0]), &iptPolygon,
                 rgptBez[iptEnd1], rgptBez[iptEnd2],
                 rgptBez[iptCtl1], rgptBez[iptCtl2], MAX_BEZIER_RECURSE);

    // 2nd Quadrant
    SetPt(&rgptBez[iptEnd1], rc.right,	yMid);
    SetPt(&rgptBez[iptEnd2], xMid,			rc.top);
    SetPt(&rgptBez[iptCtl1], rc.right,	yMid - yCtrl);
    SetPt(&rgptBez[iptCtl2], xMid + xCtrl,	rc.top);
    TransformRgpt(rgptBez, 4);
    AddBezierPts(&(rgptPolygon[0]), &iptPolygon,
                 rgptBez[iptEnd2], rgptBez[iptEnd1],
                 rgptBez[iptCtl2], rgptBez[iptCtl1], MAX_BEZIER_RECURSE);

    // 3rd Quadrant
    SetPt(&rgptBez[iptEnd1], rc.right,	yMid);
    SetPt(&rgptBez[iptEnd2], xMid,			rc.bottom);
    SetPt(&rgptBez[iptCtl2], xMid+xCtrl,	rc.bottom);
    SetPt(&rgptBez[iptCtl1], rc.right,	yMid + yCtrl);
    TransformRgpt(rgptBez, 4);
    AddBezierPts(&(rgptPolygon[0]), &iptPolygon,
                 rgptBez[iptEnd1], rgptBez[iptEnd2],
                 rgptBez[iptCtl1], rgptBez[iptCtl2], MAX_BEZIER_RECURSE);

    // Final Quadrant
    SetPt(&rgptBez[iptEnd1], rc.left,		yMid);
    SetPt(&rgptBez[iptEnd2], xMid,			rc.bottom);
    SetPt(&rgptBez[iptCtl2], xMid - xCtrl,	rc.bottom);
    SetPt(&rgptBez[iptCtl1], rc.left,		yMid + yCtrl);
    TransformRgpt(rgptBez, 4);
    AddBezierPts(&(rgptPolygon[0]), &iptPolygon,
                 rgptBez[iptEnd2], rgptBez[iptEnd1],
                 rgptBez[iptCtl2], rgptBez[iptCtl1], MAX_BEZIER_RECURSE);

    return iptPolygon - 1;
} // FillPolygonEllipse

/****************************************************************************
* %%Function:FillPolygonArc  %%Owner:warrenb         Reviewed:00/00/00
*
* Creates the points for the arc passed in the passed polygon array. Called
* by RotArc, RotPie & RotChord. returns the number of points used
*****************************************************************************/
int XHDC::FillPolygonArc(CPoint  *rgptPolygon,
                         int xdvLeft, int ydvTop,
                         int xdvRight, int ydvBottom,
                         int xdvArcStart, int ydvArcStart,
                         int xdvArcEnd, int ydvArcEnd) const
{
    Assert(!IsOffsetOnly());
    
    int ipt;
    int cpt;
    CPoint  ptBuf[4];

    ptBuf[0].x = xdvArcStart;
    ptBuf[0].y = ydvArcStart;
    ptBuf[1].x = (xdvLeft + xdvRight) / 2;
    ptBuf[1].y = (ydvTop + ydvBottom) / 2;
    ptBuf[2].x = Abs(xdvRight - xdvLeft) / 2;
    ptBuf[2].y = Abs(ydvBottom - ydvTop) / 2;
    ptBuf[3].x = xdvArcEnd;
    ptBuf[3].y = ydvArcEnd;

    // threshold is 1/2 of scaleup value
    cpt = CptGetArcPoints(rgptPolygon, ptBuf, 127, 1, fTrue);

    // Scale down
    for (ipt = 0; ipt < cpt; ipt++)
        {
        rgptPolygon[ipt].x;
        rgptPolygon[ipt].y;
        }

    TransformRgpt(rgptPolygon, cpt);

    return cpt;
} // FillPolygonArc

//
// Fill Polygon helper
//
inline BOOL FillPolygonHelper(HDC hdc, CPoint *rgpt, int cpt, HBRUSH hbr)
{
    BOOL fReturn;
    HBRUSH hbrOld = (HBRUSH)SelectObject(hdc, hbr);
    HPEN hpnOld = (HPEN)SelectObject(hdc, GetStockObject(NULL_PEN));
    fReturn = Polygon(hdc, rgpt, cpt);
    if (hpnOld != NULL)
        SelectObject(hdc, hpnOld);
    if (hbrOld != NULL)
        SelectObject(hdc, hbrOld);
    return fReturn;
}

/****************************************************************************
* %%Function: RotRoundRect        %%Owner:warrenb           Reviewed:03/01/94
*
* The rotated version of RoundRect. creates a rounded rectangle at the passed
* points influenced by the current rotation context with passed Corner
* Elliptical radii
*****************************************************************************/
BOOL XHDC::RoundRect(int xdvLeft, int ydvTop,
                     int xdvRight, int ydvBottom,
                     int nWidthEllipse, int nHeightEllipse) const
{
    Assert(hdc());

    const SIZE* psizeOffset = GetOffsetOnly();
    if (psizeOffset)
    {
        Translate(psizeOffset, &xdvLeft, &ydvTop, &xdvRight, &ydvBottom);
        return ::RoundRect(hdc(), xdvLeft, ydvTop, xdvRight, ydvBottom, nWidthEllipse, nHeightEllipse);
    }

#ifdef USEADVANCEDMODE
    if (!EmulateTransform())
    {
        CAdvancedDC adc(this);
        return ::RoundRect(adc, xdvLeft, ydvTop, xdvRight, ydvBottom, nWidthEllipse, nHeightEllipse);
    }
#endif

    CPoint rgptPolygon[133];
    int cpt = FillPolygonRoundRect(&rgptPolygon[0], xdvLeft, ydvTop,
                                   xdvRight - 1, ydvBottom - 1,
                                   nWidthEllipse, nHeightEllipse);
    
    CDispGdi16Bit::Assert16Bit((POINT *)rgptPolygon, cpt);
    return ::Polygon(hdc(), (POINT *)rgptPolygon, cpt);
} // RotRoundRect

/****************************************************************************
* %%Function: RotMoveTo        %%Owner:warrenb           Reviewed:03/01/94
*
* The rotated version of MoveTo. A normal MoveTo influenced by the current
* rotation context. The pragma's are bizarre. Even though the MoveTo is
* declared to take ints I cannot type them to work. cf. the LineTo's below!
*****************************************************************************/
BOOL XHDC::MoveToEx(int x, int y, POINT* ppt) const
{
    Assert(hdc());
    Assert(ppt == NULL);    // we don't return this yet

    const SIZE* psizeOffset = GetOffsetOnly();
    if (psizeOffset)
    {
        Translate(psizeOffset, &x, &y);
        return ::MoveToEx(hdc(), x, y, NULL);
    }
    
#ifdef USEADVANCEDMODE
    if (!EmulateTransform())
    {
        CAdvancedDC adc(this);
        return ::MoveToEx(adc, x, y, NULL);
    }
#endif
    
    CPoint pt(x,y);
    TransformPtWithCorrection(&pt);
    return ::MoveToEx(hdc(), pt.x, pt.y, NULL);
} // RotMoveTo

/****************************************************************************
* %%Function: RotLineTo        %%Owner:warrenb           Reviewed:03/01/94
*
* The rotated version of LineTo. A normal LineTo influenced by the current
* rotation context
*****************************************************************************/
BOOL XHDC::LineTo(int x, int y) const
{
    Assert(hdc());

    const SIZE* psizeOffset = GetOffsetOnly();
    if (psizeOffset)
    {
        Translate(psizeOffset, &x, &y);
        return ::LineTo(hdc(), x, y);
    }

#ifdef USEADVANCEDMODE
    if (!EmulateTransform())
    {
        CAdvancedDC adc(this);
        return ::LineTo(adc, x, y);
    }
#endif
    
    CPoint pt(x,y);
    TransformPtWithCorrection(&pt);
    return ::LineTo(hdc(), pt.x, pt.y);
} // RotLineTo

/****************************************************************************
* %%Function: RotPolyline       %%Owner:warrenb           Reviewed:03/01/94
*
* The rotated version of Polyline. A normal Polyline influenced by the current
* rotation context
*
* This function is preceded by another version that takes a MGE.  Since
* a MGE isn't available to the caller and creating a MGE would more than
* double the size of the function I have opted to leave this as-is. -davidhoe
* 
* WLB note: currently destroys points in polyline...
*****************************************************************************/
BOOL XHDC::Polyline(POINT * ppt, int cpts) const
{
    Assert(hdc() && ppt && cpts >= 0);

    const SIZE* psizeOffset = GetOffsetOnly();
    if (psizeOffset)
    {
        Translate(psizeOffset, ppt, cpts);
        return ::Polyline(hdc(), ppt, cpts);
    }
    
#ifdef USEADVANCEDMODE
    if (!EmulateTransform())
    {
        CAdvancedDC adc(this);
        return ::Polyline(adc, ppt, cpts);
    }
#endif
    
    TransformRgpt(ppt, cpts);
    return ::Polyline(hdc(), (POINT *)ppt, cpts);
} // RotPolyline

/****************************************************************************
* %%Function: RotPolygon       %%Owner:warrenb           Reviewed:03/01/94
*
* The rotated version of Polygon. A normal Polygon influenced by the current
* rotation context
*
* WLB note: currently destroys points in polygon...
*****************************************************************************/
BOOL XHDC::Polygon(POINT * ppt, int cpt) const
{
    Assert(hdc());
    Assert(ppt && cpt >= 0);

    const SIZE* psizeOffset = GetOffsetOnly();
    if (psizeOffset)
    {
        Translate(psizeOffset, ppt, cpt);
        return ::Polygon(hdc(), ppt, cpt);
    }
    
#ifdef USEADVANCEDMODE
    if (!EmulateTransform())
    {
        CAdvancedDC adc(this);
        return ::Polygon(adc, ppt, cpt);
    }
#endif
    
    TransformRgpt(ppt, cpt);
    return ::Polygon(hdc(), ppt, cpt);
} // RotPolygon

/****************************************************************************
* %%Function: RotPolyPolygon     %%Owner:warrenb           Reviewed:03/01/94
*
* The rotated version of PolyPolygon. A normal PolyPolygon influenced by the
* current rotation context
*
* WLB note: currently destroys points in polygon...
*****************************************************************************/
BOOL XHDC::PolyPolygon(POINT * ppt, LPINT lpnPolyCounts, int cpoly) const
{
    Assert(hdc());
    Assert(ppt && lpnPolyCounts && cpoly >= 0);

    int ipoly;
    int npt = 0;

    for (ipoly = 0; ipoly < cpoly; ++ipoly)
        npt += lpnPolyCounts[ipoly];

    const SIZE* psizeOffset = GetOffsetOnly();
    if (psizeOffset)
    {
        Translate(psizeOffset, ppt, npt);
        return ::PolyPolygon(hdc(), (POINT *)ppt, lpnPolyCounts, cpoly);
    }
    
#ifdef USEADVANCEDMODE
    if (!EmulateTransform())
    {
        CAdvancedDC adc(this);
        return ::PolyPolygon(adc, (POINT *)ppt, lpnPolyCounts, cpoly);
    }
#endif
    
    TransformRgpt(ppt, npt);
    return ::PolyPolygon(hdc(), (POINT *)ppt, lpnPolyCounts, cpoly);
} // RotPolyPolygon

/****************************************************************************
* %%Function: RotEllipse %%Owner:warrenb     Reviewed:03/01/94
*
*****************************************************************************/
BOOL XHDC::Ellipse(int xdvLeft, int ydvTop, int xdvRight, int ydvBottom) const
{
    Assert(hdc());

    const SIZE* psizeOffset = GetOffsetOnly();
    if (psizeOffset)
    {
        Translate(psizeOffset, &xdvLeft, &ydvTop, &xdvRight, &ydvBottom);
        return ::Ellipse(hdc(), xdvLeft, ydvTop, xdvRight, ydvBottom);
    }
    
#ifdef USEADVANCEDMODE
    if (!EmulateTransform())
    {
        CAdvancedDC adc(this);
        return ::Ellipse(adc, xdvLeft, ydvTop, xdvRight, ydvBottom);
    }
#endif
    
    CPoint rgptPolygon[133];
    CPoint *pptPolygon = &rgptPolygon[0];
    int cpt;

    cpt = FillPolygonEllipse(pptPolygon, xdvLeft, ydvTop,
                             xdvRight - 1, ydvBottom - 1);

    CDispGdi16Bit::Assert16Bit(pptPolygon, cpt);
    return ::Polygon(hdc(), pptPolygon, cpt);
} // RotEllipse

/****************************************************************************
* %%Function: RotArc            %%Owner:warrenb             Reviewed:00/00/00
*
* The rotated version of Arc.
*****************************************************************************/
BOOL XHDC::Arc(int xdvLeft, int ydvTop, int xdvRight, int ydvBottom,
               int xdvArcStart, int ydvArcStart,
               int xdvArcEnd, int ydvArcEnd) const
{
    Assert(hdc());

    const SIZE* psizeOffset = GetOffsetOnly();
    if (psizeOffset)
    {
        Translate(psizeOffset, &xdvLeft, &ydvTop, &xdvRight, &ydvBottom);
        Translate(psizeOffset, &xdvArcStart, &ydvArcStart, &xdvArcEnd, &ydvArcEnd);
        return ::Arc(hdc(), xdvLeft, ydvTop, xdvRight, ydvBottom, xdvArcStart, ydvArcStart, xdvArcEnd, ydvArcEnd);
    }

#ifdef USEADVANCEDMODE
    if (!EmulateTransform())
    {
        CAdvancedDC adc(this);
        return ::Arc(adc, xdvLeft, ydvTop, xdvRight, ydvBottom, xdvArcStart, ydvArcStart, xdvArcEnd, ydvArcEnd);
    }
#endif
    
    CPoint  rgptPolygon[128];
    int cpt;

    cpt = FillPolygonArc(&rgptPolygon[0], xdvLeft, ydvTop, xdvRight, ydvBottom,
                         xdvArcStart, ydvArcStart, xdvArcEnd, ydvArcEnd);
    CDispGdi16Bit::Assert16Bit(xdvLeft, ydvTop, xdvRight, ydvBottom);
    CDispGdi16Bit::Assert16Bit(xdvArcStart, ydvArcStart, xdvArcEnd, ydvArcEnd);
    return ::Polyline(hdc(), (POINT *)rgptPolygon, cpt);
} // RotArc

/****************************************************************************
* %%Function: RotChord          %%Owner:warrenb             Reviewed:00/00/00
*
* The rotated version of Chord
*****************************************************************************/
BOOL XHDC::Chord(int xdvLeft, int ydvTop, int xdvRight, int ydvBottom,
                    int xdvArcStart, int ydvArcStart,
                    int xdvArcEnd, int ydvArcEnd) const
{
    Assert(hdc());

    const SIZE* psizeOffset = GetOffsetOnly();
    if (psizeOffset)
    {
        Translate(psizeOffset, &xdvLeft, &ydvTop, &xdvRight, &ydvBottom);
        Translate(psizeOffset, &xdvArcStart, &ydvArcStart, &xdvArcEnd, &ydvArcEnd);
        return ::Chord(hdc(), xdvLeft, ydvTop, xdvRight, ydvBottom, xdvArcStart, ydvArcStart, xdvArcEnd, ydvArcEnd);
    }

#ifdef USEADVANCEDMODE
    if (!EmulateTransform())
    {
        CAdvancedDC adc(this);
        return ::Chord(adc, xdvLeft, ydvTop, xdvRight, ydvBottom, xdvArcStart, ydvArcStart, xdvArcEnd, ydvArcEnd);
    }
#endif
    
    CPoint  rgptPolygon[129];
    int cpt;

    cpt = FillPolygonArc(&rgptPolygon[0], xdvLeft, ydvTop, xdvRight, ydvBottom,
                         xdvArcStart, ydvArcStart, xdvArcEnd, ydvArcEnd);
    rgptPolygon[cpt++] = rgptPolygon[0];
    
    CDispGdi16Bit::Assert16Bit(rgptPolygon, cpt);
    return ::Polygon(hdc(), rgptPolygon, cpt);
} // RotChord

/****************************************************************************
* %%Function: RotPie         %%Owner:warrenb             Reviewed:03/01/94
*
* The rotated version of Pie
*****************************************************************************/
BOOL XHDC::Pie(int xdvLeft, int ydvTop, int xdvRight, int ydvBottom,
               int xdvArcStart, int ydvArcStart,
               int xdvArcEnd, int ydvArcEnd) const
{
    Assert(hdc());

    const SIZE* psizeOffset = GetOffsetOnly();
    if (psizeOffset)
    {
        Translate(psizeOffset, &xdvLeft, &ydvTop, &xdvRight, &ydvBottom);
        Translate(psizeOffset, &xdvArcStart, &ydvArcStart, &xdvArcEnd, &ydvArcEnd);
        return ::Pie(hdc(), xdvLeft, ydvTop, xdvRight, ydvBottom, xdvArcStart, ydvArcStart, xdvArcEnd, ydvArcEnd);
    }

#ifdef USEADVANCEDMODE
    if (!EmulateTransform())
    {
        CAdvancedDC adc(this);
        return ::Pie(adc, xdvLeft, ydvTop, xdvRight, ydvBottom, xdvArcStart, ydvArcStart, xdvArcEnd, ydvArcEnd);
    }
#endif
    
    CPoint  rgptPolygon[130];
    int cpt;

    cpt = FillPolygonArc(&rgptPolygon[0], xdvLeft, ydvTop, xdvRight, ydvBottom,
                         xdvArcStart, ydvArcStart, xdvArcEnd, ydvArcEnd);
    rgptPolygon[cpt].x = (xdvLeft + xdvRight) >> 1;
    rgptPolygon[cpt].y = (ydvTop + ydvBottom) >> 1;
    TransformPt(&rgptPolygon[cpt]);
    cpt++;
    rgptPolygon[cpt++] = rgptPolygon[0];
    
    CDispGdi16Bit::Assert16Bit(rgptPolygon, cpt);
    return ::Polygon(hdc(), rgptPolygon, cpt);
} // RotPie


// Nameless ROP: destnew = destold & src. From Petzold on PatBlt
#define ROPAND 0x00A000C9L
// Nameless ROP: destnew = destold | src. From Petzold on PatBlt
#define ROPOR  0x00FA0089L

/* %%Function:RotPatBlt %%Owner:mattrh %%Reviewed:0/0/00 */
//  The rotated version of PatBlt.
// We do some mapping here to try to boil things down to a RotRectangle.  We
// can map the ROP to something with which we can call SetROP2; we do so,
// call RotRectangle, and are peachy.
BOOL XHDC::PatBlt(int xdsLeft, int ydsTop, int dxd, int dyd, DWORD rop) const
{
    Assert(hdc());

    const SIZE* psizeOffset = GetOffsetOnly();
    if (psizeOffset)
    {
        Translate(psizeOffset, &xdsLeft, &ydsTop);
        return ::PatBlt(hdc(), xdsLeft, ydsTop, dxd, dyd, rop);
    }
    
    // *** NOTE *** 
    // WinNT PatBlt ignores the matrix, so we do emulation on both WinNT and Win9x
        
    // brushes we may use
    enum { ibrNone, ibrBlack, ibrWhite };

    // Here's the mapping array. We put the ROPs we're most likely to use
    // often near the top. There are 16 possible ROP2s; PatBlt can only
    // use the equivalent ROPs. Many of them don't have names; the names
    // quoted here are from Petzold's chapter on PatBlt.
    // Comments marked with *** are nameless ROPs for which we have already
    // defined names (usually in disp.h). Also note these are dword values;
    // they all fit into three bytes so I saved some notation space here.
    // Because some ROPs you can pass to PatBlt make it ignore the brush
    // selected into the DC (WHITENESS is an example), we store a reference
    // to a brush on vdraw in the table; then we can look up the brush
    // and select it if needed.
    static struct
        {
        DWORD dwROP;
        DWORD dwROP2;
        int iBrush;
        }
    kmpRopRop2 [] =
    //    ROP,       ROP2
        {
        { PATCOPY,   R2_COPYPEN,    ibrNone },		// P
        { BLACKNESS, R2_BLACK,      ibrBlack },	    // 0
        { WHITENESS, R2_WHITE,      ibrWhite },	    // 1
        { DSTINVERT, R2_NOT,        ibrNone },		// ~D
        { PATINVERT, R2_XORPEN,     ibrNone },		// P ^ D
        { ROPAND,    R2_MASKPEN,    ibrNone },		// P & D ***
        { ROPOR,     R2_MERGEPEN,   ibrNone },		// P | D ***
        { 0x0A0329,  R2_MASKNOTPEN, ibrNone },		// ~P & D
        { 0x500325,  R2_MASKPENNOT, ibrNone },		// P & ~D
        { 0xAF0229,  R2_MERGENOTPEN,ibrNone },	    // ~P | D
        { 0xF50225,  R2_MERGEPENNOT,ibrNone },	    // P | ~D
        { 0xAA0029,  R2_NOP,        ibrNone },		// D
        { 0x0F0001,  R2_NOTCOPYPEN, ibrNone },		// ~P
        { 0x5F00E9,  R2_NOTMASKPEN, ibrNone },		// ~(P & D)
        { 0x0500A9,  R2_NOTMERGEPEN,ibrNone },	    // ~(P | D)
        { 0xA50065,  R2_NOTXORPEN,  ibrNone },		// ~(P ^ D)
        { PATPAINT,  R2_COPYPEN,    ibrNone },
        };


    Assert(sizeof(kmpRopRop2) / (3 * sizeof(DWORD)) == 17);
    // NOTE: We reset values in the DC if drawing to a non MF dc.
    int irop;
    int bkMode;
    DWORD ropOld = 0;
    HPEN hpnOld;
    HBRUSH hbrPrev = NULL;
    BOOL fSuccess;

    hpnOld = (HPEN)SelectObject(hdc(), GetStockObject(NULL_PEN));
    for (irop = 0; irop < 17; irop++)
        {
        if (kmpRopRop2[irop].dwROP == rop)
            {
            ropOld = kmpRopRop2[irop].dwROP2;
            break;
            }
        }
    if (!ropOld)
        {
        Assert(irop == 17);
        AssertSz(FALSE, "RotPatBlt called with bogus rop"/* 0x%08X\r\n", rop*/);
        fSuccess = fFalse;
        goto LRPBErr;
        }

    ropOld = SetROP2(hdc(), ropOld);
    bkMode = SetBkMode(hdc(), OPAQUE);
    switch (kmpRopRop2[irop].iBrush)
        {
    case ibrWhite:
        hbrPrev = (HBRUSH)SelectObject(hdc(), GetStockObject(WHITE_BRUSH));
        break;
    case ibrBlack:
        hbrPrev = (HBRUSH)SelectObject(hdc(), GetStockObject(BLACK_BRUSH));
        break;
        }

    // NOTE (donmarsh) -- this is a weird hack, but since we are reusing the
    // XHDC::Rectangle method here, we need to adjust the bottom,right coords
    // of the rectangle. I'm actually not sure why this is necessary, but it
    // seems to work.
    dxd++;
    dyd++;
    
    fSuccess = Rectangle(xdsLeft, ydsTop,
                         xdsLeft + dxd, ydsTop + dyd);

    if (bkMode)
        SetBkMode(hdc(), bkMode);
    if (ropOld)
        SetROP2(hdc(), ropOld);
    if (hbrPrev)
        SelectObject(hdc(), hbrPrev);

LRPBErr:
    if (hpnOld != NULL)
        SelectObject(hdc(), hpnOld);
        
    return fSuccess;
} /* RotPatBlt */


/****************************************************************************\
|   %%Function:PatBltRc        %%Owner:AdamE       %%Reviewed:               |
|                                                                            |
|   Pat Blt our CRect type.                                                     |
|                                                                            |
\****************************************************************************/

void XHDC::PatBltRc(const CRect *prcds, DWORD rop) const
{
    Assert(!IsOffsetOnly());
    Assert((prcds) == (prcds));

    if (!prcds->IsEmpty())
    {
        PatBlt((prcds)->left, (prcds)->top,
               (prcds)->right - (prcds)->left,
               (prcds)->bottom - (prcds)->top, (rop)); 
    }
}

#ifdef NEEDED
/* %%Function:RotExtTextOut %%Owner:gems %%Reviewed:0/0/00 */
/* Rotated version of ExtTextOut.  The caller is responsible for selecting
   a font with the correct escapement into the hdc */
// REVIEW (davidhoe):  This looks remarkably like parts of RotExtTextOutA, although
// it takes a hdc rather than a MGE.  This function is so small that it may
// not be worth the complication of building a MGE just to call the other.
// The main thing that concerns me is: Is this function sufficient?

// NOTE (alexmog, 6/3/99): This function is not Unicode. The only caller is ExtTextOutFlip (unused so far)

BOOL XHDC::RotExtTextOut(int xds, int yds, UINT eto, CRect *lprect, char *rgch, UINT cch, int *lpdxd) const
{
    Assert(!IsOffsetOnly());
    
    CPoint ptdv;
    int xdv, ydv;

    eto = (eto & ~ETO_CLIPPED);
    if (eto & ETO_OPAQUE)
        {
        PatBltRc(lprect, PATCOPY);
        eto = (eto & ~ETO_OPAQUE);
        }
    Assert(eto == 0);

    ptdv.x = xds;
    ptdv.y = yds;
    TransformPt(&ptdv);
    xdv = ptdv.x;
    ydv = ptdv.y;
    ::ExtTextOutA(hdc(), xdv, ydv, eto, NULL, rgch, cch, lpdxd);

    return fTrue;
} /* RotExtTextOut */
#endif

/* %%Function:FEscSupported %%Owner:kennyy %%Reviewed:0/0/00 */
/* Returns whether or not the escape is supported on the given hdc.
 * Handles aborts gracefully.
 */
BOOL XHDC::FEscSupported(int nEscape) const
{
    Assert(!IsOffsetOnly());
    return (ExtEscape(hdc(),QUERYESCSUPPORT,sizeof(int),(LPSTR)&nEscape,0, NULL) > 0);
} /* FEscSupported */

// ---------------------------------------------------------------------------
// %%Function: FPrintingToPostscript    %%Owner: davidve  %%Reviewed: 00/00/00
//
// Parameters:
//
// Returns:
//
// Description:
//
// ---------------------------------------------------------------------------

BOOL XHDC::FPrintingToPostscript() const
{
    Assert(!IsOffsetOnly());
    return (FEscSupported(POSTSCRIPT_PASSTHROUGH));
} // FPrintingToPostscript

/* Maximum size of the X-clipped pipeline */
#define iptPipeMax 3

/* %%Function:ClipPoly %%Owner:kennyy %%Reviewed:6/11/92 */
/* This function is an ugly one, but it's necessary. It's a more generalized
 * (read slower) version of ClipLnpd that uses only integer math (no quads).
 * We clip a polygon to an arbitrary rectangle, returning the polygon
 * representing the intersection.
 *
 * The algorithm, by the way, is a version of the Sutherland-Hodgman
 * algorithm, which has been optimized to take half as long as the general
 * algorithm. The more general algorithm performs four clipping passes,
 * one for each edge of the clipping rectangle; I do two clipping passes
 * only, one for the horizontal boundaries and one for the vertical.
 *
 * I clip the polygon against the X boundaries first; the X-clipped
 * polygon is stored in a "pipeline" where the Y-clipping routine picks it
 * up.
 *
 * Historical note: The TF for the class in which I learned the general
 * Sutherland-Hodgman algorithm was Nat Brown. Go figure!
 */

void ClipPoly(CRect *prc, int cpt, CPoint *ppt, int *pcptClip, CPoint *pptClip)
{
    int iptX;                   /* X-clipping index */
    CPoint ptPrevX;             /* Previous X point */
    CPoint ptCurX;              /* Current X point */
    int wPtPrevLocX;            /* The previous X point's location in the range -1, 0, or 1 */
    int wPtCurLocX;             /* The current X point's location in the range? */
    CPoint  rgptPipe[iptPipeMax];/* The X-clipped pipeline */
    int iptPipeMac = 0;         /* # of points in the pipe */
    BOOL fPipeBegun = fFalse;   /* Have we begun to use the pipeline? */
    CPoint ptPipelineFirst(0,0);/* First point in pipeline */
    int iptY;                   /* Y-clipping index */
    CPoint ptPrevY(0,0);        /* Previous Y point */
    CPoint ptCurY;              /* Current Y point */
    int wPtPrevLocY = 0;        /* The previous Y point's location in the range -1, 0, or 1 */
    int wPtCurLocY;             /* The current Y point's location in the range? */
    int iptClipMac = 0;         /* # of points in the clipped polygon */

    Assert(cpt >= 3);

    /* X clipping routine. Clipped points are placed in the pipeline. */

    /* The point behind the first one is the last one. Set up the
     * previous-point information.
     */

    ptPrevX = ppt[cpt - 1];
    wPtPrevLocX = (ptPrevX.x < prc->left) ? -1: ((ptPrevX.x > prc->right) ? 1 : 0);

    for (iptX = 0; iptX < cpt; iptX++)
        {
        /* Set up the current-point information */

        ptCurX = ppt[iptX];
        wPtCurLocX = (ptCurX.x < prc->left) ? -1: ((ptCurX.x > prc->right) ? 1 : 0);

        /* If we crossed a boundary, output the point(s) at which we cross */

        if (wPtPrevLocX != wPtCurLocX)
            {
            if (wPtPrevLocX != 0)
                {
                /* Add intersection point to the pipe */

                rgptPipe[iptPipeMac].x = (wPtPrevLocX < 0) ? prc->left : prc->right;
                rgptPipe[iptPipeMac].y = ptPrevX.y +
                                    (int)(((long)rgptPipe[iptPipeMac].x - ptPrevX.x) *
                                    (ptCurX.y - ptPrevX.y) / (ptCurX.x - ptPrevX.x));
                iptPipeMac++;
                Assert(iptPipeMac <= iptPipeMax);
                } /* if */
            if (wPtCurLocX != 0)
                {
                /* Add intersection point to the pipe */

                rgptPipe[iptPipeMac].x = (wPtCurLocX < 0) ? prc->left : prc->right;
                rgptPipe[iptPipeMac].y = ptPrevX.y +
                                    (int)(((long)rgptPipe[iptPipeMac].x - ptPrevX.x) *
                                    (ptCurX.y - ptPrevX.y) / (ptCurX.x - ptPrevX.x));
                iptPipeMac++;
                Assert(iptPipeMac <= iptPipeMax);
                } /* if */
            } /* if */

        /* If this point is in the valid range, add it to the pipe as well. */

        if (wPtCurLocX == 0)
            {
            rgptPipe[iptPipeMac++] = ptCurX;
            Assert(iptPipeMac <= iptPipeMax);
            }

        /* Cur -> Prev so we can move on to the next point */

        ptPrevX = ptCurX;
        wPtPrevLocX = wPtCurLocX;

        if (iptPipeMac <= 1)
            continue;

        /* Y clipping routine. X-clipped points are taken from the pipeline and
         * placed in the output buffer in XY-clipped form. The code here is essentially
         * the same as the X-clipping, so I won't elaborate...
         */

        if (!fPipeBegun)
            {
            fPipeBegun = fTrue;
            ptPipelineFirst = ptPrevY = rgptPipe[0];
            wPtPrevLocY = (ptPrevY.y < prc->top) ? -1: ((ptPrevY.y > prc->bottom) ? 1 : 0);
            }

        /* Skip the first point in the pipeline, since it's the prev point */

LFlushPipe:
        for (iptY = 1; iptY < iptPipeMac; iptY++)
            {
            ptCurY = rgptPipe[iptY];
            wPtCurLocY = (ptCurY.y < prc->top) ? -1:((ptCurY.y > prc->bottom) ? 1 : 0);

            if (wPtPrevLocY != wPtCurLocY)
                {
                if (wPtPrevLocY != 0)
                    {
                    pptClip[iptClipMac].y = (wPtPrevLocY < 0) ? prc->top : prc->bottom;
                    pptClip[iptClipMac].x = ptPrevY.x +
                                        (int)(((long)pptClip[iptClipMac].y-ptPrevY.y) *
                                        (ptCurY.x - ptPrevY.x) / (ptCurY.y - ptPrevY.y));
                    iptClipMac++;
                    // Assert(iptClipMac <= cptClipPolyMax);
                    } /* if */
                if (wPtCurLocY != 0)
                    {
                    pptClip[iptClipMac].y = (wPtCurLocY < 0) ? prc->top : prc->bottom;
                    pptClip[iptClipMac].x = ptPrevY.x +
                                        (int)(((long)pptClip[iptClipMac].y - ptPrevY.y) *
                                        (ptCurY.x - ptPrevY.x) / (ptCurY.y - ptPrevY.y));
                    iptClipMac++;
                    // Assert(iptClipMac <= cptClipPolyMax);
                    } /* if */
                } /* if */

            if (wPtCurLocY == 0)
                {
                pptClip[iptClipMac++] = ptCurY;
                // Assert(iptClipMac <= cptClipPolyMax);
                }

            rgptPipe[0] = ptPrevY = ptCurY;
            wPtPrevLocY = wPtCurLocY;
            } /* for Y */
        iptPipeMac = 1;
        } /* for X */

    if (fPipeBegun)
        {
        Assert(iptPipeMac == 1);
        rgptPipe[iptPipeMac++] = ptPipelineFirst;
        fPipeBegun = fFalse;       /* to avoid endless loop */
        goto LFlushPipe;
        }

    *pcptClip = iptClipMac;
} /* ClipPoly */

/****************************************************************************\
 * %%Function: MakeNormalRect       %%Owner: Warrenb   %%Reviewed: 00/00/00 *
 *                                                                          *
 * Description: makes the passed rectangle normal ie. bottomleft>topright   *
\****************************************************************************/
void MakeNormalRc(CRect *prc)
{
    if (prc->left > prc->right)
        SwapVal(prc->left, prc->right);
    if (prc->top > prc->bottom)
        SwapVal(prc->top, prc->bottom);
} // MakeNormalRect

/*----------------------------------------------------------------------------
@func void | RestrictPolygonToRectangleInterior | Rotation support code.
@contact sidda

@comm   The Windows API Rectangle() excludes the right and bottom edges.
        The Windows API Polygon() does not (for the same set of points).

        This routine ensures the image painted by Polygon() does not exceed
        the bounds of that which would be painted by Rectangle().
----------------------------------------------------------------------------*/
void RestrictPolygonToRectangleInterior(
    CPoint *rgpt,
    int cpt,
    CRect *prc)
{
    int    i = 0;
    CPoint    *ppt = rgpt;

    for (; i < cpt; i++, ppt++)
        {
        // restrict to left, top edges
        if (ppt->x < prc->left)
            ppt->x = prc->left;

        if (ppt->y < prc->top)
            ppt->y = prc->top;

        // restrict to lie inside right, bottom edges
        if (ppt->x >= prc->right)
            ppt->x = prc->right - 1;

        if (ppt->y >= prc->bottom)
            ppt->y = prc->bottom - 1;
        }
}

/*----------------------------------------------------------------------------
@func BOOL | RotRectangle | Rotation GDI wrapper
@contact mattrh

@comm The rotated version of Rectangle, creates a rectangle at the passed points
influenced by the passed MGE's rotation information.

pub3 RAID 1072: Rectangle Border Width varies as position and angle changes
*   WLB > The rectangle now calculate a thickness vector and makes sure that
*   WLB > the largest of dx,dy of the vectors is at least 1 pixel.
If this becomes a problem we can port similar code from Publisher codebase.

----------------------------------------------------------------------------*/
BOOL XHDC::Rectangle(int xpwLeft, int ypwTop, int xpwRight, int ypwBottom,
                     RECT *prcBounds) // @parm Upright bounding rectangle. We should not draw
                                       // in the right and bottom edges of this rectangle. Pass
                     const             // NULL if you don't care that we do.
{
    Assert(hdc());

    const SIZE* psizeOffset = GetOffsetOnly();
    if (psizeOffset)
    {
        Translate(psizeOffset, &xpwLeft, &ypwTop, &xpwRight, &ypwBottom);
        return ::Rectangle(hdc(), xpwLeft, ypwTop, xpwRight, ypwBottom);
    }

#ifdef USEADVANCEDMODE
    if (!EmulateTransform())
    {
        CAdvancedDC adc(this);
        return ::Rectangle(adc, xpwLeft, ypwTop, xpwRight, ypwBottom);
    }
#endif
    
    CPoint rgptPoly[4];

    RRC rrcpw;
    CRect rcpwr;

    SetRc(&rcpwr, xpwLeft, ypwTop, xpwRight-1, ypwBottom-1);
    RrcFromMatRc(&rrcpw, &mat(), &rcpwr);
    rgptPoly[0] = rrcpw.ptTopLeft;
    rgptPoly[1] = rrcpw.ptTopRight;
    rgptPoly[2] = rrcpw.ptBottomRight;
    rgptPoly[3] = rrcpw.ptBottomLeft;

    if (prcBounds != NULL)
        RestrictPolygonToRectangleInterior(rgptPoly, 4, (CRect*) prcBounds);

    CDispGdi16Bit::Assert16Bit((LPPOINT) &rgptPoly, 4);
    return ::Polygon(hdc(), (LPPOINT) &rgptPoly, 4);
}

/*----------------------------------------------------------------------------
@func BOOL | RotFillRect | Rotation GDI wrapper
@contact mattrh

@comm The rotated version of FillRect.

----------------------------------------------------------------------------*/
BOOL XHDC::FillRect(const RECT *prc, HBRUSH hbr) const
{
    Assert(hdc());

    CRect rcpwr = *prc;
    
    const SIZE* psizeOffset = GetOffsetOnly();
    if (psizeOffset)
    {
        Translate(psizeOffset, &rcpwr);
        return ::FillRect(hdc(), &rcpwr, hbr);
    }

#ifdef USEADVANCEDMODE
    if (!EmulateTransform())
    {
        CAdvancedDC adc(this);
        return ::FillRect(adc, &rcpwr, hbr);
    }
#endif
    
    RRC rrcpw;
    CPoint rgptPoly[4];
    BOOL fReRotate = fFalse;

    RrcFromMatRc(&rrcpw, &mat(), (CRect*)prc);

    // if either height or width of rotated rectangle
    // is sub pixel then add 1 to initial rectangle
    // and recalculate
    if (rrcpw.ptTopLeft == rrcpw.ptBottomLeft)
        {
        fReRotate = fTrue;
        rcpwr.bottom += 1;
        }
    if (rrcpw.ptTopLeft == rrcpw.ptTopRight)
        {
        fReRotate = fTrue;
        rcpwr.right += 1;
        }

    // if we had to adjust existing unrotated rectangle
    // then re-rotate.
    if (fReRotate)
        RrcFromMatRc(&rrcpw, &mat(), &rcpwr);

    // make polygon from rotated points
    SetPt(&(rgptPoly[0]), rrcpw.ptTopLeft.x, rrcpw.ptTopLeft.y);
    SetPt(&(rgptPoly[1]), rrcpw.ptTopRight.x, rrcpw.ptTopRight.y);
    SetPt(&(rgptPoly[2]), rrcpw.ptBottomRight.x, rrcpw.ptBottomRight.y);
    SetPt(&(rgptPoly[3]), rrcpw.ptBottomLeft.x, rrcpw.ptBottomLeft.y);

    CDispGdi16Bit::Assert16Bit(rgptPoly[0]);
    CDispGdi16Bit::Assert16Bit(rgptPoly[1]);
    CDispGdi16Bit::Assert16Bit(rgptPoly[2]);
    CDispGdi16Bit::Assert16Bit(rgptPoly[3]);
    
    return FillPolygonHelper(hdc(), rgptPoly, 4, hbr);
}


BOOL XHDC::FrameRect(const RECT *prc, HBRUSH hbr) const
{
    Assert(hdc());

    CRect rc = *prc;
    const SIZE* psizeOffset = GetOffsetOnly();
    if (psizeOffset)
    {
        Translate(psizeOffset, &rc);
        return ::FrameRect(hdc(), &rc, hbr);
    }
    
#ifdef USEADVANCEDMODE
    // NOTE: FrameRect doesn't appear to work in Advanced Mode in NT!
#endif
    
    if (!TransformRect(&rc))
    {
        AssertSz(FALSE, "FrameRect doesn't work with non-axis-aligned transformations yet");
        return FALSE;
    }
    
    return ::FrameRect(hdc(), &rc, hbr);
}


BOOL XHDC::DrawEdge(const RECT* prc, UINT edge, UINT grfFlags) const
{
    Assert(hdc());

    CRect rc = *prc;
    const SIZE* psizeOffset = GetOffsetOnly();
    if (psizeOffset)
    {
        Translate(psizeOffset, &rc);
        return ::DrawEdge(hdc(), &rc, edge, grfFlags);
    }
    
#ifdef USEADVANCEDMODE
    // NOTE: DrawEdge doesn't appear to work in Advanced Mode in NT!
#endif
    
    if (!TransformRect(&rc))
    {
        AssertSz(FALSE, "DrawEdge doesn't work with non-axis-aligned transformations yet");
        return FALSE;
    }
    
    return ::DrawEdge(hdc(), &rc, edge, grfFlags);
}


int XHDC::SelectClipRgn(HRGN hrgn) const
{
    Assert(hdc());
    
    if (hrgn == NULL)
        return ::SelectClipRgn(hdc(), NULL);

    // easy if transform is just a translation
    const SIZE* psizeOffset = GetOffsetOnly();
    if (psizeOffset)
    {
        HRGN hrgnShifted = ::CreateRectRgn(0,0,0,0);
        if (hrgnShifted == NULL)
            return RGN_ERROR;

        int r = ::CombineRgn(hrgnShifted, hrgn, NULL, RGN_COPY);
        if (r == ERROR)
            return RGN_ERROR;

        r = ::OffsetRgn(hrgnShifted, psizeOffset->cx, psizeOffset->cy);
        if (r == ERROR)
            return RGN_ERROR;

        r = ::SelectClipRgn(hdc(), hrgnShifted);
        ::DeleteObject(hrgnShifted);
        return r;
    }
    
#ifdef USEADVANCEDMODE
    // NOTE (donmarsh) -- because we aren't using advanced mode
    // to render transformed images, we can't use advanced mode to
    // handle clip regions: they don't mix and match.
    if (!EmulateTransform())
    {
        CAdvancedDC adc(this);
        return ::SelectClipRgn(adc, hrgn);
    }
#endif
    
    // transform region.  Note that this works correctly only once if we have
    // a rotation that isn't a multiple of 90 degrees.
    CRegion rgnTransformed(hrgn);
    rgnTransformed.Transform(&transform());
    return rgnTransformed.SelectClipRgn(hdc());
}


int XHDC::ExtSelectClipRgn(HRGN hrgn, int fnMode) const
{
    Assert(hdc());
    
    if (hrgn == NULL)
    {
        return ::ExtSelectClipRgn(hdc(), NULL, fnMode);
    }

    // easy if transform is just a translation
    const SIZE* psizeOffset = GetOffsetOnly();
    if (psizeOffset)
    {
        HRGN hrgnShifted = ::CreateRectRgn(0,0,0,0);
        if (hrgnShifted == NULL)
            return RGN_ERROR;

        int r = ::CombineRgn(hrgnShifted, hrgn, NULL, RGN_COPY);
        if (r == ERROR)
            return RGN_ERROR;

        r = ::OffsetRgn(hrgnShifted, psizeOffset->cx, psizeOffset->cy);
        if (r == ERROR)
            return RGN_ERROR;

        r = ::ExtSelectClipRgn(hdc(), hrgnShifted, fnMode);
        ::DeleteObject(hrgnShifted);
        return r;
    }
    
#ifdef USEADVANCEDMODE
    // NOTE (donmarsh) -- because we aren't using advanced mode
    // to render transformed images, we can't use advanced mode to
    // handle clip regions: they don't mix and match.
    if (!EmulateTransform())
    {
        CAdvancedDC adc(this);
        return ::ExtSelectClipRgn(adc, hrgn, fnMode);
    }
#endif
    
    // transform region.  Note that this works correctly only once if we have
    // a rotation that isn't a multiple of 90 degrees.
    CRegion rgnTransformed(hrgn);
    rgnTransformed.Transform(&transform());
    return rgnTransformed.ExtSelectClipRgn(hdc(), fnMode);
}


int XHDC::GetClipRgn(HRGN hrgn) const
{
    Assert(hdc());
    Assert(hrgn);

    // easy if transform is just a translation
    int result;
    const SIZE* psizeOffset = GetOffsetOnly();
    if (psizeOffset)
    {
        result = ::GetClipRgn(hdc(), hrgn);
        if (result == 1)
            ::OffsetRgn(hrgn, -psizeOffset->cx, -psizeOffset->cy);
        return result;
    }
    
#ifdef USEADVANCEDMODE
    // NOTE (donmarsh) -- because we aren't using advanced mode
    // to render transformed images, we can't use advanced mode to
    // handle clip regions: they don't mix and match.
    if (!EmulateTransform())
    {
        CAdvancedDC adc(this);
        return ::GetClipRgn(adc, hrgn);
    }
#endif
    
    result = ::GetClipRgn(hdc(), hrgn);
    if (result != 1)
        return result;
    
    // untransform region
    CRegion rgnTransformed(hrgn);
    rgnTransformed.Untransform(&transform());
    return rgnTransformed.CopyTo(hrgn) != RGN_ERROR
        ? 1
        : -1;  // NOTE (donmarsh) -- GetLastError won't work after this!
}

BOOL XHDC::GetCurrentPositionEx(POINT* ppt) const
{
    if (!::GetCurrentPositionEx(hdc(), ppt))
        return FALSE;
    
    const SIZE* pOffset = GetOffsetOnly();
    if (pOffset)
    {
        ppt->x -= pOffset->cx;
        ppt->y -= pOffset->cy;
    }
    else
    {
        transform().Untransform((CPoint*)ppt);
    }
    
    return TRUE;
}

BOOL XHDC::BitBlt(
        int nXDest,
        int nYDest,
        int nWidth,
        int nHeight,
        const XHDC& hdcSrc,
        int nXSrc,
        int nYSrc,
        DWORD dwRop) const
{
    const SIZE* psizeOffsetDest = GetOffsetOnly();
    const SIZE* psizeOffsetSrc = hdcSrc.GetOffsetOnly();
    if (psizeOffsetDest && psizeOffsetSrc)
    {
        Translate(psizeOffsetDest, &nXDest, &nYDest);
        Translate(psizeOffsetSrc, &nXSrc, &nYSrc);
        return ::BitBlt(hdc(), nXDest, nYDest, nWidth, nHeight, hdcSrc.hdc(), nXSrc, nYSrc, dwRop);
    }
    
#ifdef USEADVANCEDMODE
    if (!EmulateTransform())
    {
        CAdvancedDC adcDest(this);
        CAdvancedDC adcSrc(&hdcSrc);
        return ::BitBlt(adcDest, nXDest, nYDest, nWidth, nHeight, adcSrc, nXSrc, nYSrc, dwRop);
    }
#endif
    
    return StretchBlt(nXDest, nYDest, nWidth, nHeight, hdcSrc, nXSrc, nYSrc, nWidth, nHeight, dwRop);
}

BOOL XHDC::MaskBlt(
        int nXDest, 
        int nYDest, 
        int nWidth, 
        int nHeight, 
        const XHDC& hdcSrc, 
        int nXSrc, 
        int nYSrc, 
        HBITMAP hbmMask, 
        int xMask, 
        int yMask, 
        DWORD dwRop) const
{
    // NOTE: this should only be called on WinNT
    Assert(g_dwPlatformID == VER_PLATFORM_WIN32_NT);
    
    const SIZE* psizeOffsetDest = GetOffsetOnly();
    const SIZE* psizeOffsetSrc = hdcSrc.GetOffsetOnly();
    if (psizeOffsetDest && psizeOffsetSrc)
    {
        Translate(psizeOffsetDest, &nXDest, &nYDest);
        Translate(psizeOffsetSrc, &nXSrc, &nYSrc);
        return ::MaskBlt(hdc(), nXDest, nYDest, nWidth, nHeight, hdcSrc.hdc(), nXSrc, nYSrc, hbmMask, xMask, yMask, dwRop);
    }
    
#ifdef USEADVANCEDMODE
    if (!EmulateTransform())
    {
        CAdvancedDC adcDest(this);
        CAdvancedDC adcSrc(&hdcSrc);
        return ::MaskBlt(adcDest, nXDest, nYDest, nWidth, nHeight, adcSrc, nXSrc, nYSrc, hbmMask, xMask, yMask, dwRop);
    }
#endif
    
    AssertSz(FALSE, "MaskBlt called with complex transform");
    return FALSE;
}


// Transformation doesn't include any scale
BOOL XHDC::HasNoScale() const
{
    if (_fSurface == NULL)
        return TRUE;

    const MAT& xf = mat();

    if (xf.eM12 == 0 && xf.eM21 == 0)
    {
        if ((xf.eM11 == 1.0 || xf.eM11 == -1.0) && (xf.eM22 == 1.0 || xf.eM22 == -1.0))
        {
            // no scale, may be flipped
            return TRUE;
        }
    }
    else if (xf.eM11 == 0 && xf.eM22 == 0)
    {
        if ((xf.eM12 == 1.0 || xf.eM12 == -1.0) && (xf.eM21 == 1.0 || xf.eM21 == -1.0))
        {
            // no scale, may have a combination of 90-degree rotation and flips
            return TRUE;
        }
    }

    float flScaleX, flScaleY;
    xf.GetAngleScaleTilt(NULL, &flScaleX, &flScaleY, NULL);
    return flScaleX == 1.0 && flScaleY == 1.0;
}

int XHDC::GetTrivialRotationAngle() const
{
    Assert(HasTransform() && HasTrivialRotation());
    
    const MAT& xf = mat();

    if (xf.eM12 == 0 && xf.eM21 == 0)
    {
        // check for 0 or 180 degree rotation
        if (xf.eM11 > 0 && xf.eM22 > 0)
            return 0;
        else if (xf.eM11 < 0 && xf.eM22 < 0)
            return 180;
    }
    else if (xf.eM11 == 0 && xf.eM22 == 0)
    {
        // check for 90 or 270 degree rotation
        if (xf.eM12 < 0 && xf.eM21 > 0)
            return 90;
        else if (xf.eM12 > 0 && xf.eM21 < 0)
            return 270;
    }
    
    AssertSz(FALSE, "Unexpected non-axis-aligned rotation");
    return 0;
}


WHEN_DBG(static HDC hdcDebug;)


//+-----------------------------------------------------------------------------
//
//  Member: XHDC::StretchBlt
//
//------------------------------------------------------------------------------
BOOL 
XHDC::StretchBlt(
        int             nXOriginDest,
        int             nYOriginDest,
        int             nWidthDest,
        int             nHeightDest,
        const XHDC &    hdcSrc, 
        int             nXOriginSrc,
        int             nYOriginSrc,
        int             nWidthSrc,
        int             nHeightSrc,
        DWORD           dwRop) const
{
    HRESULT         hr              = S_OK;
    HDC             hdcSrc1         = hdcSrc.hdc();
    const SIZE *    psizeOffsetDest = GetOffsetOnly();
    const SIZE *    psizeOffsetSrc  = hdcSrc.GetOffsetOnly();
    HBITMAP         hSrcBitmap2     = NULL;
    HBITMAP         hDstBitmap      = NULL;
    HBITMAP         hbmOld          = NULL;
    HDC             hdcSrc2         = NULL;
    int             iResult         = GDI_ERROR;
    bool            fDstAlloc       = false;
    BITMAP          bmpSrc;
    BITMAP          bmpDst;
    IDirectDraw3 *  pDD3            = NULL;
    IDirectDrawSurface *    
                    pDDSurface      = NULL;
    
    ZeroMemory(&bmpSrc, sizeof(bmpSrc));
    ZeroMemory(&bmpDst, sizeof(bmpDst));

    if (psizeOffsetDest && psizeOffsetSrc)
    {
        Translate(psizeOffsetDest, &nXOriginDest, &nYOriginDest);
        Translate(psizeOffsetSrc, &nXOriginSrc, &nYOriginSrc);

        return ::StretchBlt(hdc(), nXOriginDest, nYOriginDest, nWidthDest, nHeightDest,
                            hdcSrc1, nXOriginSrc, nYOriginSrc, nWidthSrc, nHeightSrc, dwRop);
    }
    
#ifdef USEADVANCEDMODE
    // NOTE: WinNT advanced mode messes up clipping, 1-bit mask rotation, and
    // it seems to be slow!  Just use emulation instead.
#endif    
    
    // only deal with complex transformation for destination
    Assert(psizeOffsetSrc);

    if (psizeOffsetSrc)
    {
        Translate(psizeOffsetSrc, &nXOriginSrc, &nYOriginSrc);
    }
    
    // compute transformed rectangle
    CRect rc(nXOriginDest, nYOriginDest, 
             nXOriginDest + nWidthDest, nYOriginDest + nHeightDest);

    if (!TransformRect(&rc))
    {
        AssertSz(FALSE, "StretchBlt doesn't work with non-axis-aligned transformations yet");
        return FALSE;
    }

    // compute rotation amount
    int nRotationAngle = GetTrivialRotationAngle();
    
    // important optimization for no rotation
    if (nRotationAngle == 0)
    {
        return ::StretchBlt(hdc(), rc.left, rc.top, rc.Width(), rc.Height(),
                            hdcSrc1, nXOriginSrc, nYOriginSrc, nWidthSrc, nHeightSrc, dwRop);
    }

    // At the point we know we need to do a rotation.  To do this we'll create 
    // two bitmaps:
    //
    // hSrcBitmap2: This is a copy of the input area to be stretch blitted.
    // hDstBitmap:  This is a bitmap to hold the post-rotated image.
    //
    // And one new HDC:
    //
    // hdcSrc2:     This DC will first have hSrcBitmap2 selected into it so that
    //              the pixel information needed can be copied to hSrcBitmap2.
    //              Then it will have hDstBitmap selected into it so that the
    //              post-rotated image can be stretch blitted to "this" XHDC.

    // Create hSrcBitmap2 (source for rotation)

    hSrcBitmap2 = ::CreateCompatibleBitmap(hdcSrc1, nWidthSrc, nHeightSrc);

    // Create hDstBitmap (destination for rotation)

    if (nRotationAngle == 180)
    {
        hDstBitmap = ::CreateCompatibleBitmap(hdcSrc1, nWidthSrc, nHeightSrc);
    }
    else
    {
        hDstBitmap = ::CreateCompatibleBitmap(hdcSrc1, nHeightSrc, nWidthSrc);
    }
    
    // Create hdcSrc2 which will host the bitmaps.

    hdcSrc2 = ::CreateCompatibleDC(hdcSrc1);
    
    // If everything was created properly...

    if (   (hSrcBitmap2 != NULL)
        && (hDstBitmap  != NULL)
        && (hdcSrc2     != NULL))
    {
        // Save old bitmap.

        hbmOld = (HBITMAP)::SelectObject(hdcSrc2, hSrcBitmap2);

        // Copy source pixels.

        ::BitBlt(hdcSrc2, 0, 0, nWidthSrc, nHeightSrc,
                 hdcSrc1, nXOriginSrc, nYOriginSrc, SRCCOPY);
    
        // rotate pixels
        ::SelectObject(hdcSrc2, hDstBitmap);

        WHEN_DBG(hdcDebug = hdcSrc2;)

        // Get the actual bitmap bits.

        ::GetObject(hSrcBitmap2, sizeof(BITMAP), &bmpSrc);
        ::GetObject(hDstBitmap, sizeof(BITMAP), &bmpDst);

        // With a usual trident HDC, apparently GetObject will fill in the 
        // bmBits member of the structure.  But with HDCs created from 
        // DirectDraw surfaces it won't, so we'll do it manually below.

        if (NULL == bmpSrc.bmBits)
        {
            DDSURFACEDESC   ddsd;

            // 2000/10/02 (mcalkins) I'm only going to handle the 32-bit case as
            // this issue of bmBits being NULL only first showed up during my 
            // work to get filtered elements to print and I know that the source
            // will always be a DirectDraw surface with 32 bits per pixel and 
            // I'm under time pressure.

            Assert(32 == bmpSrc.bmBitsPixel);

            if (bmpSrc.bmBitsPixel != 32)
            {
                hr = E_FAIL;

                goto done;
            }

            // Initialize the surface description.

            ZeroMemory(&ddsd, sizeof(ddsd));

            ddsd.dwSize = sizeof(ddsd);

            // IDirectDraw3 needed to get surface.

            hr = g_pDirectDraw->QueryInterface(IID_IDirectDraw3, 
                                               (void **)&pDD3);

            if (hr)
            {
                goto done;
            }

            hr = pDD3->GetSurfaceFromDC(hdcSrc1, &pDDSurface);

            if (hr)
            {
                goto done;
            }

            // Locking the surface gets us a direct pointer to its bits.

            hr = pDDSurface->Lock(NULL, &ddsd, DDLOCK_SURFACEMEMORYPTR | DDLOCK_NOSYSLOCK, NULL);

            if (hr)
            {
                goto done;
            }

            // This is the pointer to the bits.

            bmpSrc.bmBits = ddsd.lpSurface;
        }

        if (NULL == bmpDst.bmBits)
        {
            Assert(32 == bmpDst.bmBitsPixel);

            if (bmpDst.bmBitsPixel != 32)
            {
                hr = E_FAIL;

                goto done;
            }

            bmpDst.bmBits = new BYTE[bmpDst.bmWidth * bmpDst.bmHeight * 4];

            if (NULL == bmpDst.bmBits)
            {
                hr = E_OUTOFMEMORY;

                goto done;
            }

            fDstAlloc = true;
        }

        RotateBitmap(bmpSrc, bmpDst, nRotationAngle);

        // If we used a DirectDraw surface for input, we need to unlock it now.

        if (pDDSurface)
        {
            hr = pDDSurface->Unlock(NULL);

            if (hr)
            {
                goto done;
            }
        }

        // We've rotated the bitmap, but if we had to allocate the destination
        // bitmap memory ourselves, the bits won't be associated with the 
        // GDI bitmap.  A call to SetDIBits will fix that.

        if (fDstAlloc)
        {
            BITMAPINFO  bmi;

            ZeroMemory(&bmi, sizeof(bmi));

            bmi.bmiHeader.biSize        = sizeof(bmi.bmiHeader);
            bmi.bmiHeader.biWidth       = bmpDst.bmWidth;
            bmi.bmiHeader.biHeight      = bmpDst.bmHeight;
            bmi.bmiHeader.biPlanes      = bmpDst.bmPlanes;
            bmi.bmiHeader.biBitCount    = bmpDst.bmBitsPixel;
            bmi.bmiHeader.biCompression = BI_RGB;

            iResult = ::SetDIBits(hdcSrc2, hDstBitmap, 
                                  0,                // Start row 
                                  bmpDst.bmHeight,  // Row count
                                  bmpDst.bmBits, &bmi, DIB_RGB_COLORS);

            if (0 == iResult)
            {
                hr = E_FAIL;

                goto done;
            }
        }

        // Now blit from hdcSrc2 (attached to the post-rotated bitmap) to the
        // final destination.

        iResult = ::StretchBlt(hdc(), 
                               rc.left, rc.top, rc.Width(), rc.Height(),
                               hdcSrc2, 
                               0, 0, bmpDst.bmWidth, bmpDst.bmHeight, 
                               dwRop);

        if (GDI_ERROR == iResult)
        {
            hr = E_FAIL;

            goto done;
        }
    }

done:

    ReleaseInterface(pDDSurface);
    ReleaseInterface(pDD3);

    if (fDstAlloc)
    {
        delete [] bmpDst.bmBits;
    }
    
    // Restore previous bitmap into hdcSrc2.

    if (hbmOld)
    {
        ::SelectObject(hdcSrc2, hbmOld);
    }

    if (hSrcBitmap2)
    {
        ::DeleteObject(hSrcBitmap2);
    }

    if (hDstBitmap)
    {
        ::DeleteObject(hDstBitmap);
    }

    if (hdcSrc2)
    {
        ::DeleteDC(hdcSrc2);
    }
    
    // TODO (donmarsh) -- this should actually return the number of scanlines copied

    if (hr)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}
//  Member: XHDC::StretchBlt


int GetScanlineSizeInBytes(int nPixels, int nBitsPerPixel)
{
    return (nPixels * nBitsPerPixel + 31) / 32 * 4;
}

BOOL XHDC::StretchDIBits(
        int nXDest,
        int nYDest,
        int nDestWidth,
        int nDestHeight, 
        int nXSrc,
        int nYSrc,
        int nSrcWidth,
        int nSrcHeight,
        const void *lpBits,
        const BITMAPINFO *lpBitsInfo,
        UINT iUsage,
        DWORD dwRop) const
{
    const SIZE* psizeOffset = GetOffsetOnly();
    if (psizeOffset)
    {
        Translate(psizeOffset, &nXDest, &nYDest);
        return ::StretchDIBits(hdc(), nXDest, nYDest, nDestWidth, nDestHeight,
                               nXSrc, nYSrc, nSrcWidth, nSrcHeight, lpBits, lpBitsInfo, iUsage, dwRop);
    }
    
#ifdef USEADVANCEDMODE
    // NOTE: WinNT advanced mode is messed up for StretchBlt, so we don't use
    // it.  For consistency, we don't use advanced mode here either.  Given
    // the buggy implementation for StretchBlt, it seems safer not to trust
    // NT in this area.
#endif    
    
    // compute transformed rectangle
    CRect rc(nXDest, nYDest, nXDest+nDestWidth, nYDest+nDestHeight);

    if (!TransformRect(&rc))
    {
        AssertSz(FALSE, "StretchDIBits doesn't work with non-axis-aligned transformations yet");
        return FALSE;
    }

    // compute rotation amount
    int nRotationAngle = GetTrivialRotationAngle();

    // important special case for no rotation
    if (nRotationAngle == 0)
    {
        return ::StretchDIBits( hdc(), rc.left, rc.top, rc.Width(), rc.Height(),
                                nXSrc, nYSrc, nSrcWidth, nSrcHeight,
                                lpBits, lpBitsInfo, iUsage, dwRop);
    }

    // populate src bitmap structure
    BITMAP bmpSrc;
    bmpSrc.bmType = 0;
    bmpSrc.bmWidth = lpBitsInfo->bmiHeader.biWidth;
    bmpSrc.bmHeight = lpBitsInfo->bmiHeader.biHeight;
    bmpSrc.bmBitsPixel = lpBitsInfo->bmiHeader.biBitCount;
    bmpSrc.bmWidthBytes = GetScanlineSizeInBytes(bmpSrc.bmWidth, bmpSrc.bmBitsPixel);
    bmpSrc.bmPlanes = 1;
    bmpSrc.bmBits = const_cast<void*>(lpBits);
    
    // copy the src bitmapinfo header and palette data
    long lInfoSize = sizeof(BITMAPINFO) + (lpBitsInfo->bmiHeader.biClrUsed-1) * sizeof(RGBQUAD);
    BITMAPINFO* pbmiDest = (BITMAPINFO*) MemAlloc(Mt(XHDC_LocalBitmaps), lInfoSize);
    if (!pbmiDest)
        return FALSE; //GDI_ERROR;
    memcpy(pbmiDest, lpBitsInfo, lInfoSize);
    
    // set the size of the destination bitmap
    if (90 == nRotationAngle || 270 == nRotationAngle)
    {
        int tmp = pbmiDest->bmiHeader.biWidth;
        pbmiDest->bmiHeader.biWidth = pbmiDest->bmiHeader.biHeight;
        pbmiDest->bmiHeader.biHeight = tmp;
    }

    // populate the destination bitmap structure
    BITMAP bmpDst;
    bmpDst.bmType = 0;
    bmpDst.bmWidth = pbmiDest->bmiHeader.biWidth;
    bmpDst.bmHeight = pbmiDest->bmiHeader.biHeight;
    bmpDst.bmBitsPixel = bmpSrc.bmBitsPixel;
    bmpDst.bmWidthBytes = GetScanlineSizeInBytes(bmpDst.bmWidth, bmpDst.bmBitsPixel);
    bmpDst.bmPlanes = 1;
    bmpDst.bmBits = MemAlloc(Mt(XHDC_LocalBitmaps), bmpDst.bmHeight * GetScanlineSizeInBytes(bmpDst.bmWidth, bmpDst.bmBitsPixel));

    if (NULL == bmpDst.bmBits)
    {
        MemFree(pbmiDest);
        return FALSE;
    }

#if DBG==1
    __int64 t1, t2, tfrq;
    QueryPerformanceFrequency((LARGE_INTEGER *)&tfrq);

    QueryPerformanceCounter((LARGE_INTEGER *)&t1);
#endif

    RotateBitmap(bmpSrc, bmpDst, nRotationAngle);

#if DBG==1
    QueryPerformanceCounter((LARGE_INTEGER *)&t2);
    TraceTag((tagError, "RotateBitmap took us %ld", ((LONG)(((t2 - t1) * 1000000) / tfrq))));
#endif

    int result = ::StretchDIBits( hdc(), rc.left, rc.top, rc.Width(), rc.Height(),

                                  //-------------------------------------------------------------------------
                                  //
                                  // TODO: These 4 are suspect. We need to understand what they need to be
                                  //
                                  0, 0, pbmiDest->bmiHeader.biWidth, pbmiDest->bmiHeader.biHeight,
                                  //
                                  //-------------------------------------------------------------------------
                                  
                                  bmpDst.bmBits, pbmiDest, iUsage, dwRop);

    MemFree(bmpDst.bmBits);
    MemFree(pbmiDest);
    
    // TODO (donmarsh) -- this should actually return the number of scanlines copied
    return result != GDI_ERROR;
}

void RotateBitmap(const BITMAP& bmSrc, BITMAP& bmDst, int rotation)
{
    // This code should actually never be called in Trident v3, because there are
    // no situations in which images should be rotated.
    // NOTE: This code is executed for glyphs
    // AssertSz(FALSE, "Harmless assert: we do not expect to rotate images in MSHTML v3");
    
    // this routine handles rotations of only 90, 180, or 270 degrees
    Assert(
        ((rotation == 90 || rotation == 270) && 
         bmSrc.bmWidth == bmDst.bmHeight && bmSrc.bmHeight == bmDst.bmWidth) ||
        (rotation == 180 &&
         bmSrc.bmWidth == bmDst.bmWidth && bmSrc.bmHeight == bmDst.bmHeight));
    
    Assert(bmSrc.bmBitsPixel == bmDst.bmBitsPixel);
    
    int     srcWidthBytes   = GetScanlineSizeInBytes(bmSrc.bmWidth, 
                                                     bmSrc.bmBitsPixel);
    int     dstWidthBytes   = GetScanlineSizeInBytes(bmDst.bmWidth, 
                                                     bmDst.bmBitsPixel);

    //
    // 8,16,24, or 32 bits per pixel
    // 
    if (bmSrc.bmBitsPixel > 4)
    {
        BYTE* pSrcPixel = (BYTE*) bmSrc.bmBits;
        BYTE* pDstPixel = (BYTE*) bmDst.bmBits;
        int bytesPerPixel = bmSrc.bmBitsPixel/8;
        int srcSkip = srcWidthBytes - bmSrc.bmWidth * bytesPerPixel;
        int dstSkip = dstWidthBytes - bmDst.bmWidth * bytesPerPixel;
        int dstPixelInc;
        int dstRowInc;
        
        switch (rotation)
        {
        case 90:
            pDstPixel += -bytesPerPixel + dstWidthBytes - dstSkip;
            dstPixelInc = -bytesPerPixel + dstWidthBytes;
            dstRowInc = -bytesPerPixel - dstWidthBytes * bmDst.bmHeight;
            break;
        case 180:
            pDstPixel += -bytesPerPixel + dstWidthBytes * bmDst.bmHeight - dstSkip;
            dstPixelInc = -2*bytesPerPixel;
            dstRowInc = -dstSkip;
            break;
        default:
            pDstPixel += dstWidthBytes * (bmDst.bmHeight-1);
            dstPixelInc = -bytesPerPixel - dstWidthBytes;
            dstRowInc = bytesPerPixel + dstWidthBytes * bmDst.bmHeight;
            break;
        }
        
        for (int y = 0; y < bmSrc.bmHeight; y++)
        {
            for (int x = 0; x < bmSrc.bmWidth; x++)
            {
                // copy one pixel
                switch (bytesPerPixel)
                {
                case 4:  *pDstPixel++ = *pSrcPixel++;
                case 3:  *pDstPixel++ = *pSrcPixel++;
                case 2:  *pDstPixel++ = *pSrcPixel++;
                default: *pDstPixel++ = *pSrcPixel++;
                }
                
                // jump to next destination pixel
                pDstPixel += dstPixelInc;
            }
            
            // jump to next source and destination row
            pSrcPixel += srcSkip;
            pDstPixel += dstRowInc;
        }
        
        return;
    }
    

    //
    // 1 or 4 bits per pixel
    // 
    int pixelsPerByte = 8 / bmSrc.bmBitsPixel;
    BYTE leftMask = bmSrc.bmBitsPixel == 1 ? 0x80 : 0xF0;
    
    for (int y = 0; y < bmSrc.bmHeight; y++)
    {
        BYTE* pSrcPixel = ((BYTE*) bmSrc.bmBits) + y * srcWidthBytes;
        int y1 = bmSrc.bmHeight-1 - y;
        
        switch (rotation)
        {
        case 90:
            {
                BYTE* pDstPixel = ((BYTE*) bmDst.bmBits) + y1 / pixelsPerByte;
                int srcShift = 0;
                int dstShift = (y1 % pixelsPerByte) * bmSrc.bmBitsPixel;
                BYTE dstMask = ~(leftMask >> dstShift);
                for (int x = 0; x < bmSrc.bmWidth; x++)
                {
                    int shift = dstShift - srcShift;
                    BYTE pixel = *pSrcPixel & (leftMask >> srcShift);
                    *pDstPixel &= dstMask;
                    if (shift < 0)
                        *pDstPixel |= pixel << -shift;
                    else
                        *pDstPixel |= pixel >> shift;
                    
                    srcShift = (srcShift + bmSrc.bmBitsPixel) & 0x07;
                    if (srcShift == 0)
                        pSrcPixel++;
                    
                    pDstPixel += dstWidthBytes;
                }
            }
            break;
        
        case 180:
            {
                BYTE* pDstPixel = ((BYTE*) bmDst.bmBits) + y1 * dstWidthBytes + bmDst.bmWidth / pixelsPerByte;
                int srcShift = 0;
                int dstShift = (bmDst.bmWidth % pixelsPerByte) * bmSrc.bmBitsPixel;
                for (int x = 0; x < bmSrc.bmWidth; x++)
                {
                    int shift = dstShift - srcShift;
                    BYTE pixel = *pSrcPixel & (leftMask >> srcShift);
                    *pDstPixel &= ~(leftMask >> dstShift);
                    if (shift < 0)
                        *pDstPixel |= pixel << -shift;
                    else
                        *pDstPixel |= pixel >> shift;
                    
                    srcShift = (srcShift + bmSrc.bmBitsPixel) & 0x07;
                    if (srcShift == 0)
                        pSrcPixel++;
                    
                    if (dstShift == 0)
                        pDstPixel--;
                    dstShift = (dstShift - bmSrc.bmBitsPixel) & 0x07;
                }
            }
            break;
        
        default:
            {
                BYTE* pDstPixel = ((BYTE*) bmDst.bmBits) + (bmDst.bmHeight-1) * dstWidthBytes + y / pixelsPerByte;
                int srcShift = 0;
                int dstShift = (y % pixelsPerByte) * bmSrc.bmBitsPixel;
                BYTE dstMask = ~(leftMask >> dstShift);
                for (int x = 0; x < bmSrc.bmWidth; x++)
                {
                    int shift = dstShift - srcShift;
                    BYTE pixel = *pSrcPixel & (leftMask >> srcShift);
                    *pDstPixel &= dstMask;
                    if (shift < 0)
                        *pDstPixel |= pixel << -shift;
                    else
                        *pDstPixel |= pixel >> shift;
                    
                    srcShift = (srcShift + bmSrc.bmBitsPixel) & 0x07;
                    if (srcShift == 0)
                        pSrcPixel++;
                    
                    pDstPixel -= dstWidthBytes;
                }
            }
            break;
        }

#if DBG == 1
        if (IsTagEnabled(tagFilterPaintScreen))
        {
            HDC hdcScreen = CreateDC(_T("DISPLAY"), NULL, NULL, NULL);
            if (hdcScreen)
            {
                ::BitBlt(hdcScreen, 0, 0, bmDst.bmWidth, bmDst.bmHeight, hdcDebug, 0, 0, BLACKNESS);
                ::BitBlt(hdcScreen, 0, 0, bmDst.bmWidth, bmDst.bmHeight, hdcDebug, 0, 0, SRCCOPY);  
                ::DeleteDC(hdcScreen);
            }
        }
#endif
    }
}


BOOL XHDC::DrawFocusRect(const RECT* prc) const
{
    CRect rc(*prc);
    const SIZE* psizeOffset = GetOffsetOnly();
    if (psizeOffset)
    {
        Translate(psizeOffset, &rc);
        return ::DrawFocusRect(hdc(), &rc);
    }
    
#ifdef USEADVANCEDMODE
    if (!EmulateTransform())
    {
        CAdvancedDC adc(this);
        return ::DrawFocusRect(adc, prc);
    }
#endif
    
    // compute transformed rectangle
    if (!TransformRect(&rc))
    {
        AssertSz(FALSE, "DrawFocusRect doesn't work with non-axis-aligned transformations yet");
        return FALSE;
    }
        
    return ::DrawFocusRect(hdc(), &rc);
}

BOOL XHDC::DrawFrameControl(LPRECT prc, UINT uType, UINT uState) const
{
    CRect rc(*prc);
    const SIZE* psizeOffset = GetOffsetOnly();
    if (psizeOffset)
    {
        Translate(psizeOffset, &rc);
        return ::DrawFrameControl(hdc(), &rc, uType, uState);
    }
    
#ifdef USEADVANCEDMODE
    // NOTE: we don't use Advanced Mode on WinNT to render frame controls,
    // because it does not properly handle the direction of the light source.
    // In other words, when we rotate a checkbox by 90 degrees, it should
    // look no different than the unrotated case, but WinNT actually rotates
    // the shading!
#endif
    
    if (!TransformRect(&rc))
    {
        AssertSz(FALSE, "DrawFrameControl doesn't work with non-axis-aligned transformations yet");
        return FALSE;
    }
    
    return ::DrawFrameControl(hdc(), &rc, uType, uState);
}

int XHDC::ExcludeClipRect(int left, int top, int right, int bottom) const
{
    const SIZE* psizeOffset = GetOffsetOnly();
    if (psizeOffset)
    {
        Translate(psizeOffset, &left, &top, &right, &bottom);
        return ::ExcludeClipRect(hdc(), left, top, right, bottom);
    }
    
#ifdef USEADVANCEDMODE
    if (!EmulateTransform())
    {
        CAdvancedDC adc(this);
        return ::ExcludeClipRect(adc, left, top, right, bottom);
    }
#endif
        
    // compute transformed rectangle
    CRect rc(left, top, right, bottom);
    if (!TransformRect(&rc))
    {
        AssertSz(FALSE, "ExcludeClipRect doesn't work with non-axis-aligned transformations yet");
        return FALSE;
    }
    
    return ::ExcludeClipRect(hdc(), rc.left, rc.top, rc.right, rc.bottom);
}

int XHDC::GetClipBox(LPRECT prc) const
{
    int result;
    const SIZE* psizeOffset = GetOffsetOnly();
    if (psizeOffset)
    {
        result = ::GetClipBox(hdc(), prc);
        ((CRect*)prc)->OffsetRect(-psizeOffset->cx, -psizeOffset->cy);
        return result;
    }
    
#ifdef USEADVANCEDMODE
    if (!EmulateTransform())
    {
        CAdvancedDC adc(this);
        return ::GetClipBox(hdc(), prc);
    }
#endif

    result = ::GetClipBox(hdc(), prc);
    if (result == NULLREGION || result == RGN_ERROR)
        return result;
    
    // untransform rc
    transform().Untransform((CRect*) prc);
    return result;    
}

int XHDC::IntersectClipRect(int left, int top, int right, int bottom) const
{
    const SIZE* psizeOffset = GetOffsetOnly();
    if (psizeOffset)
    {
        Translate(psizeOffset, &left, &top, &right, &bottom);
        return ::IntersectClipRect(hdc(), left, top, right, bottom);
    }
    
#ifdef USEADVANCEDMODE
    if (!EmulateTransform())
    {
        CAdvancedDC adc(this);
        return ::IntersectClipRect(adc, left, top, right, bottom);
    }
#endif
        
    // compute transformed rectangle
    CRect rc(left, top, right, bottom);
    if (!TransformRect(&rc))
    {
        AssertSz(FALSE, "IntersectClipRect doesn't work with non-axis-aligned transformations yet");
        return FALSE;
    }
    
    return ::IntersectClipRect(hdc(), rc.left, rc.top, rc.right, rc.bottom);
}

BOOL XHDC::SetBrushOrgEx(int nXOrg, int nYOrg, LPPOINT ppt) const
{
    const SIZE* psizeOffset = GetOffsetOnly();
    if (psizeOffset)
    {
        Translate(psizeOffset, &nXOrg, &nYOrg);
        BOOL result = ::SetBrushOrgEx(hdc(), nXOrg, nYOrg, ppt);
        if (ppt)
        {
            ppt->x -= psizeOffset->cx;
            ppt->y -= psizeOffset->cy;
        }
        return result;
    }
    
#ifdef USEADVANCEDMODE
    if (!EmulateTransform())
    {
        CAdvancedDC adc(this);
        return ::SetBrushOrgEx(adc, nXOrg, nYOrg, ppt);
    }
#endif
        
    // TODO (donmarsh) -- not sure what to do here.  Since we aren't actually
    // transforming the brush, transforming the brush origin might be futile.
    return ::SetBrushOrgEx(hdc(), nXOrg, nYOrg, ppt);
}

#ifdef NOTYET
//
//  Metafile enumeration callback
//
int CALLBACK XhdcEnhMetaFunc(
                              HDC hDC,                    // handle to device context
                              HANDLETABLE *lpHTable,      // pointer to metafile handle table
                              ENHMETARECORD const *lpEMFR,// pointer to metafile record
                              int nObj,                   // count of objects
                              LPARAM lpData               // pointer to optional data
                            )
{
    ENHMETARECORD *pemfrCopy = NULL;

    switch (lpEMFR->iType)
    {
    case EMR_BITBLT:
    case EMR_MASKBLT:
    case EMR_STRETCHBLT:
        {
            EMRBITBLT *pemrbitblt = (EMRBITBLT *) lpEMFR;
            
            if (!IsRectlEmpty(&pemrbitblt->rclBounds))
            {
                // copy the record and redirect record pointer
                pemfrCopy = (ENHMETARECORD *) MemAlloc(Mt(XHDC), lpEMFR->nSize);
                if (pemfrCopy)
                {
                    memcpy(pemfrCopy, lpEMFR, lpEMFR->nSize);
                    lpEMFR = pemfrCopy;
                    pemrbitblt = (EMRBITBLT *) lpEMFR;

                    // Convert rectangles
                    ...
                    // Draw transformed image
                    ...

                    goto Cleanup;
                }
            }
            
        }
        break;

    case EMR_TEXT:
        {
            // transform font sizes and/or replace screen fonts with TT fonts.
            ...
        }
        break;

    default:
        // no change
        break;
    }

    // Default processing
    {
        BOOL fResult = ::PlayEnhMetaFileRecord(hDC, lpHTable, lpEMFR, nObj);
    }

Cleanup:
    if (pemfrCopy)
        MemFree(pemfrCopy);

    // continue enumeration regardless of individual record failures
    return 1;   
}
#endif

//
// PlayEnhMetaFile
//
BOOL XHDC::PlayEnhMetaFile(HENHMETAFILE hemf, const RECT *prc) const
{
    // FUTURE (alexmog): for now, we merely transform the rectangle, 
    // and rely on Windows to scale metafile appropriately.
    // That works fine at 100% zoom in print preview, and when printing 
    // (as long as physical size of rectangle matches size of metafile bounds).
    // At other zoom levels, metafiles scale reasonably, but font sizes are not 
    // scaled, resulting in weird rendering of text. 
    // And of course, we can't make Win9x apply rotation.
    //
    // To transform properly, we need to enumerate metafile, and transform all points
    // in all records, plus scale fonts. PUBPRINT.CXX contains code that does exactly
    // that - it needs to be updated, reviewed, and put to work.

    // Transform the rectangle
    CRect rc(*prc);
    if (HasTransform())
        transform().Transform(&rc);

    return ::PlayEnhMetaFile(hdc(), hemf, &rc);

#ifdef NOTYET
    // Enumerate the metafile and transform record by record
    return ::EnumEnhMetaFile(hdc(), 
                             hemf,
                             &XhdcEnhMetaFunc,
                             (LPVOID) this,
                             prc);  // note: original rect. may need to pass both.
#endif
}


//
// PlayEnhMetaFileRecord
//
BOOL XHDC::PlayEnhMetaFileRecord(LPHANDLETABLE pHandleTable, const ENHMETARECORD *pemr, UINT nHandles) const
{
    AssertSz(0, "PlayEnhMetaFileRecord: not yet implemented");
    return FALSE;
}

/*----------------------------------------------------------------------------
@func BOOL | RotExtTextOutA | Rotation GDI wrapper
@contact mattrh

@comm    The rotated version of ExtTextOutA.
        ETO_OPAQUE and ETO_CLIPPED are unsupported.
        You must select a font with the appropriate escapement.
        Unlike RotExtTextOutW, this does not handle the visi characters.  All visi drawing must be done in RotExtTextOutW.

----------------------------------------------------------------------------*/
BOOL XHDC::ExtTextOutA(int xds, int yds, UINT eto,
    const RECT *lprect, LPCSTR rgch, UINT cch, const int FAR *lpdxd) const
{
    Assert(hdc());
    RECT rectT;
    LPRECT prectT = NULL;
    if (lprect)
    {
        rectT = *lprect;
        prectT = &rectT;
    }
    
    const SIZE* psizeOffset = GetOffsetOnly();
    if (psizeOffset)
    {
        Translate(psizeOffset, &xds, &yds);
        if (prectT)
        {
            Translate(psizeOffset, prectT);
        }
        return ::ExtTextOutA(hdc(), xds, yds, eto, prectT, rgch, cch, lpdxd);
    }
    
#ifdef USEADVANCEDMODE
    if (!EmulateTransform())
    {
        CAdvancedDC adc(this);
        return ::ExtTextOutA(adc, xds, yds, eto, prectT, rgch, cch, lpdxd);
    }
#endif
        
    CXFormFont xf(this);
    
    CPoint ptpw(xds, yds);
    CNewWidths nw;
    
    TransformPt(&ptpw);
    nw.TransformWidthsArray((INT*)lpdxd, cch, transform().GetRealScaleX());
    if (prectT && !TransformRect((CRect*) prectT))
    {
        AssertSz(FALSE, "ExtTextOutA called with clipping rect and complex transform");
        prectT = NULL;
    }
    return ::ExtTextOutA(hdc(), ptpw.x, ptpw.y, eto, prectT, rgch, cch, nw.GetWidths((INT*)lpdxd));
}


/*----------------------------------------------------------------------------
@func BOOL | RotExtTextOutW | Rotation GDI wrapper
@contact mattrh

@comm    The rotated version of ExtTextOutW.
        ETO_OPAQUE and ETO_CLIPPED are unsupported.
        You must select a font with the appropriate escapement.

----------------------------------------------------------------------------*/
BOOL XHDC::ExtTextOutW(int xds, int yds, UINT eto,
    const RECT *lprect, LPCWSTR rgch, UINT cch, const int *lpdxd/*, const LHT* plht*/, int kTFlow) const
{
    Assert(hdc());
    
    RECT rectT;
    LPRECT prectT = NULL;
    if (lprect)
    {
        rectT = *lprect;
        prectT = &rectT;
    }
    
    const SIZE* psizeOffset = GetOffsetOnly();
    if (psizeOffset)
    {
        Translate(psizeOffset, &xds, &yds);
        if (prectT)
        {
            Translate(psizeOffset, prectT);
        }
        return ::ExtTextOutW(hdc(), xds, yds, eto, prectT, rgch, cch, lpdxd);
    }
    
#ifdef USEADVANCEDMODE
    if (!EmulateTransform())
    {
        CAdvancedDC adc(this);
        return ::ExtTextOutW(adc, xds, yds, eto, prectT, rgch, cch, lpdxd);
    }
#endif
        
    CPoint ptpw(xds, yds);
    CXFormFont xf(this);
    CNewWidths nw;
    TransformPt(&ptpw);
    nw.TransformWidthsArray((INT*)lpdxd, cch, transform().GetRealScaleX());
    if (prectT && !TransformRect((CRect*) prectT))
    {
        AssertSz(FALSE, "ExtTextOutW called with clipping rect and complex transform");
        prectT = NULL;
    }
    
    return ::ExtTextOutW(hdc(), ptpw.x, ptpw.y, eto, prectT, rgch, cch, nw.GetWidths((INT*)lpdxd));
}

BOOL XHDC::TextOutW(int xds, int yds, LPCWSTR rgch, UINT cch) const
{
    return ExtTextOutW(xds, yds, NULL, NULL, rgch, cch, NULL);
}


HRESULT XHDC::ScriptStringAnalyse(
        const void *pString, 
        int cString, 
        int cGlyphs, 
        int iCharset, 
        DWORD dwFlags,
        int iReqWidth,
        SCRIPT_CONTROL *psControl,
        SCRIPT_STATE *psState,
        const int *piDx,
        SCRIPT_TABDEF *pTabdef,
        const BYTE *pbInClass,
        SCRIPT_STRING_ANALYSIS *pssa
        ) const
{
    Assert(hdc());

    const SIZE* psizeOffset = GetOffsetOnly();
    if (psizeOffset)
    {
        return ::ScriptStringAnalyse(hdc(), pString, cString, cGlyphs, iCharset, dwFlags, iReqWidth, psControl, psState, piDx, pTabdef, pbInClass, pssa);
    }
 
    // this case is called only for rendering image alt text, and therefore
    // should never be rotated
    // Actually, selects also use this codepath in printing.
    Assert(GetTrivialRotationAngle() == 0);
        

    CXFormFont xf(this);
    int iXWidth = (iReqWidth * transform().GetRealScaleX());
    
    return ::ScriptStringAnalyse(hdc(), pString, cString, cGlyphs, iCharset, dwFlags, iXWidth, psControl, psState, piDx, pTabdef, pbInClass, pssa);
}

HRESULT XHDC::ScriptStringOut(
        SCRIPT_STRING_ANALYSIS ssa,
        int iX,
        int iY,
        UINT uOptions,
        const RECT* prc,
        int iMinSel,
        int iMaxSel,
        BOOL fDisabled) const
{
    Assert(hdc());
    
    RECT rectT;
    LPRECT prectT = NULL;
    if (prc)
    {
        rectT = *prc;
        prectT = &rectT;
    }
    
    const SIZE* psizeOffset = GetOffsetOnly();
    if (psizeOffset)
    {
        Translate(psizeOffset, &iX, &iY);
        if (prectT)
        {
            Translate(psizeOffset, prectT);
        }
        return ::ScriptStringOut(ssa, iX, iY, uOptions, prectT, iMinSel, iMaxSel, fDisabled);
    }
    
#ifdef USEADVANCEDMODE
    if (!EmulateTransform())
    {
        CAdvancedDC adc(this);
        return ::ScriptStringOut(ssa, iX, iY, uOptions, prectT, iMinSel, iMaxSel, fDisabled);
    }
#endif
        
    // this case is called only for rendering image alt text, and therefore
    // should never be rotated
    // Actually, selects also use this codepath in printing.
    Assert(GetTrivialRotationAngle() == 0);
    
    CXFormFont xf(this);
    CPoint pt(iX,iY);
    TransformPt(&pt);
    if (prectT)
    {
        Verify(TransformRect((CRect*) prectT));
    }
    
    return ::ScriptStringOut(ssa, pt.x, pt.y, uOptions, prectT, iMinSel, iMaxSel, fDisabled);
}

BOOL XHDC::ScriptTextOut(
                         SCRIPT_CACHE *psc,          // cache handle
                         int x,                      // x,y position for first glyph
                         int y,                      // 
                         UINT fuOptions,             // ExtTextOut options
                         const RECT *lprc,            // optional clipping/opaquing rectangle
                         const SCRIPT_ANALYSIS *psa, // result of ScriptItemize
                         const WCHAR *pwcInChars,    // required only for metafile DCs
                         int cChars,                 // required only for metafile DCs
                         const WORD *pwGlyphs,       // glyph buffer from prior ScriptShape call
                         int cGlyphs,                // number of glyphs
                         const int *piAdvance,       // advance widths from ScriptPlace
                         const int *piJustify,       // justified advance widths (optional)
                         const GOFFSET *pGoffset     // x,y offset for combining glyph
                     ) const
{
    Assert(hdc());
    
    RECT rectT;
    LPRECT prectT = NULL;
    if (lprc)
    {
        rectT = *lprc;
        prectT = &rectT;
    }
    
    const SIZE* psizeOffset = GetOffsetOnly();
    if (psizeOffset)
    {
        Translate(psizeOffset, &x, &y);
        if (prectT)
        {
            Translate(psizeOffset, prectT);
        }
        return ::ScriptTextOut(hdc(), psc, x, y, fuOptions, prectT, psa, pwcInChars, cChars, pwGlyphs, cGlyphs, 
                             piAdvance, piJustify, pGoffset);    
    }
    
#ifdef USEADVANCEDMODE
    if (!EmulateTransform())
    {
        CAdvancedDC adc(this);
        return ::ScriptTextOut(adc, psc, x, y, fuOptions, lprc, psa, pwcInChars, cChars, pwGlyphs, cGlyphs, 
                             piAdvance, piJustify, pGoffset);    
    }
#endif
        
    SCRIPT_CACHE scTemp = NULL;
    BOOL         fReturn;
    CPoint pt(x, y);
    CXFormFont xf(this);
    CNewWidths nw1;
    CNewWidths nw2;
    CNewOffsets no;
    TransformPt(&pt);
    nw1.TransformWidthsArray((INT*)piAdvance, cGlyphs, transform().GetRealScaleX());
    nw2.TransformWidthsArray((INT*)piJustify, cGlyphs, transform().GetRealScaleX());
    no.TransformOffsetsArray((GOFFSET*)pGoffset, cGlyphs, transform().GetRealScaleX(), transform().GetRealScaleY());
    if (prectT && !TransformRect((CRect*) prectT))
    {
        AssertSz(FALSE, "ScriptTextOut called with clipping rect and complex transform");
        prectT = NULL;
    }
        
    // TODO Bug #2831 in IE6 database
    // The SCRIPT_CACHE parameter contains font information cached by Uniscribe to avoid doing GDI work.
    // If we use the passed in script cache, Uniscribe will use the measuring font metrics, causing several issues.
    // So, we force Uniscribe to use this font info on the hdc by passing in a null SCRIPT_CACHE.
    // What we really need here is a lightweight rendering font cache to avoid recreation of fonts in CXFormFont and
    // to allow us to use SCRIPT_CACHE variables for contiguous glyph runs in the same font.

    fReturn = ::ScriptTextOut(hdc(), &scTemp, pt.x, pt.y, fuOptions, prectT, psa, pwcInChars, cChars, pwGlyphs, cGlyphs, 
                     nw1.GetWidths((INT*)piAdvance), nw2.GetWidths((INT*)piJustify), no.GetOffsets((GOFFSET*)pGoffset));    

    if (scTemp)
        ::ScriptFreeCache(&scTemp);

    return fReturn;
}

BOOL XHDC::DrawTextW(
                     LPCTSTR lpString, // pointer to string to draw
                     int nCount,       // string length, in characters
                     LPRECT lpRect,    // pointer to struct with formatting dimensions
                     UINT uFormat      // text-drawing flags
                     ) const
{
    Assert(hdc());
    BOOL fCalcRectOnly = !!(uFormat & DT_CALCRECT);
    BOOL fRetVal;
    
    CRect rc(*lpRect);
    const SIZE* psizeOffset = GetOffsetOnly();
    if (psizeOffset)
    {
        if(!fCalcRectOnly)
        {
            Translate(psizeOffset, &rc);
            return ::DrawTextW(hdc(), lpString, nCount, &rc, uFormat);   
        }
        else
        {
            fRetVal = ::DrawTextW(hdc(), lpString, nCount, lpRect, uFormat);
            // Returning the value, do an UnTranslate
            OffsetRect(lpRect, -psizeOffset->cx, -psizeOffset->cy);
            return fRetVal;
        }
    }
    
#ifdef USEADVANCEDMODE
    if (!EmulateTransform())
    {
        CAdvancedDC adc(this);
        return ::DrawTextW(adc, lpString, nCount, lpRect, uFormat);   
    }
#endif
        
    if (!TransformRect(&rc))
    {
        AssertSz(FALSE, "DrawTextW doesn't work with non-axis-aligned transformations yet");
        return FALSE;
    }
    
    if (!fCalcRectOnly)
    {
#if DBG==1
        CXFormFont xf(this, TRUE);
#else
        CXFormFont xf(this);
#endif
        return ::DrawTextW(hdc(), lpString, nCount, &rc, uFormat);
    }
    else
    {
#if DBG==1
        CXFormFont xf(this, TRUE);
#else
        CXFormFont xf(this);
#endif
        fRetVal = ::DrawTextW(hdc(), lpString, nCount, lpRect, uFormat);
        transform().Untransform((CRect *)lpRect);

        return fRetVal;
    }
}

BOOL XHDC::DrawTextA(
                     LPCSTR lpString,  // pointer to string to draw
                     int nCount,       // string length, in characters
                     LPRECT lpRect,    // pointer to struct with formatting dimensions
                     UINT uFormat      // text-drawing flags
                     ) const
{
    Assert(hdc());
    BOOL fCalcRectOnly = !!(uFormat & DT_CALCRECT);
    BOOL fRetVal;
    
    CRect rc(*lpRect);
    const SIZE* psizeOffset = GetOffsetOnly();
    if (psizeOffset)
    {
        if(!fCalcRectOnly)
        {
            Translate(psizeOffset, &rc);
            return ::DrawTextA(hdc(), lpString, nCount, &rc, uFormat);
        }
        else
        {
            fRetVal = ::DrawTextA(hdc(), lpString, nCount, lpRect, uFormat);
            // Returning the value, do an UnTranslate
            OffsetRect(lpRect, -psizeOffset->cx, -psizeOffset->cy);
            return fRetVal;
        }
    }
    
#ifdef USEADVANCEDMODE
    if (!EmulateTransform())
    {
        CAdvancedDC adc(this);
        return ::DrawTextA(adc, lpString, nCount, lpRect, uFormat);   
    }
#endif
        
    if (!TransformRect(&rc))
    {
        AssertSz(FALSE, "DrawTextA doesn't work with non-axis-aligned transformations yet");
        return FALSE;
    }

    if(!fCalcRectOnly)
    {
#if DBG==1
        CXFormFont xf(this, TRUE);
#else
        CXFormFont xf(this);
#endif
        return ::DrawTextA(hdc(), lpString, nCount, &rc, uFormat);
    }
    else
    {
#if DBG==1
        CXFormFont xf(this, TRUE);
#else
        CXFormFont xf(this);
#endif
        fRetVal = ::DrawTextA(hdc(), lpString, nCount, lpRect, uFormat);
        transform().Untransform((CRect *)lpRect);

        return fRetVal;
    }
}

BOOL XHDC::DrawThemeBackground(
                    HANDLE  hTheme,
                    int     iPartId,
                    int     iStateId,
                    const   RECT *pRect,
                    const   RECT *pClipRect)
{
    Assert(hdc());

    CRect rc(*pRect);
    const SIZE* psizeOffset = GetOffsetOnly();
    if (psizeOffset)
    {
        Translate(psizeOffset, &rc);
        return SUCCEEDED(::DrawThemeBackground(hTheme, hdc(), iPartId, iStateId, &rc, pClipRect));
    }

    // This code works fine for everything but check boxes and radio buttons, which fail to
    // print (though they preview fine).  Current guess: This is a themeing API issue.
    // A bug is being opened to track this issue separately (but can't really b.  (greglett)
    if (!TransformRect(&rc))
    {
        AssertSz(FALSE, "DrawThemeBackground doesn't work with non-axis-aligned transformations yet");
        return FALSE;
    }
    
    return (SUCCEEDED(::DrawThemeBackground(hTheme, hdc(), iPartId, iStateId, &rc, pClipRect)));
}

const CBaseCcs* XHDC::GetBaseCcsPtr() const
{ 
    return (_fSurface && _pSurface ? _pSurface->_pBaseCcs : NULL ); 
}

void XHDC::SetBaseCcsPtr(CBaseCcs *pCcs)
{ 
    if(_fSurface && _pSurface)
    {
        CBaseCcs *pOldCcs = _pSurface->_pBaseCcs;

        _pSurface->_pBaseCcs = pCcs; 
        if(pCcs) pCcs->AddRef();

        if(pOldCcs) pOldCcs->Release();
    }
}



#ifndef X_XTEXTOUT_HXX_
#define X_XTEXTOUT_HXX_
#include "xtextout.hxx"
#endif

#ifndef X_LSTFLOW_H_
#define X_LSTFLOW_H_
#include "lstflow.h"
#endif

// including this here isn't ideal, but we need CStrIn...
#ifndef X_UNICWRAP_HXX_
#define X_UNICWRAP_HXX_
#include "unicwrap.hxx"
#endif

#if DBG==1
CXFormFont::CXFormFont(const XHDC* pxhdc, BOOL fStockFont)
#else
CXFormFont::CXFormFont(const XHDC* pxhdc)
#endif
{
    HFONT hFontOld = NULL;
    HFONT hFontNew = NULL;
    
    if (pxhdc->HasComplexTransform())
    {
        LOGFONT lf;
                
        hFontOld = (HFONT)::GetCurrentObject(*pxhdc, OBJ_FONT);
        if (   hFontOld
            && GetObject(hFontOld, sizeof(lf), &lf)
           )
        {
            TraceTagEx((tagXFormFont, TAG_NONAME,
                        "XFormFont: (Old) F:%ls, H:=%d, E:%d, CS:%d, OP:%d",
                        lf.lfFaceName, lf.lfHeight, lf.lfEscapement, lf.lfCharSet, lf.lfOutPrecision));           

#if DBG==1
            if (!fStockFont)
            {
                // These asserts firing may cause incorrect display, especially on localized systems.
                AssertSz(pxhdc->GetBaseCcsPtr(), "XFormFont instantiated with no font pushed!");
            }
#endif
            lf.lfEscapement = lf.lfOrientation = pxhdc->transform().GetAngle();
            lf.lfOutPrecision = OUT_TT_ONLY_PRECIS;
            lf.lfWidth = (lf.lfWidth * pxhdc->transform().GetRealScaleX());
            lf.lfHeight = (lf.lfHeight * pxhdc->transform().GetRealScaleY());

            const CBaseCcs *pBaseCcs = pxhdc->GetBaseCcsPtr();

            
            if (pBaseCcs && pBaseCcs->_fScalingRequired)
            {
                lf.lfWidth *= pBaseCcs->_flScaleFactor;
                lf.lfHeight *= pBaseCcs->_flScaleFactor;
            }
            
            //  Force us to render using the measuring font face.
            //  This becomes an issue because the font mapper may choose different font at a different resolution.
            if (pBaseCcs)
            {
                AssertSz((pxhdc->GetBaseCcsPtr()->_fTTFont), "Non true-type font pushed when rendering with complex XForm!");
                _tcsncpy(lf.lfFaceName, fc().GetFaceNameFromAtom(pBaseCcs->_latmRealFaceName), LF_FACESIZE);
            }

            hFontNew = CreateFontIndirect(&lf);
            
            if (hFontNew)
            {
                Verify(hFontOld == SelectFontEx(*pxhdc, hFontNew));

#if DBG==1
                if ( IsTagEnabled(tagXFormFont) )
                {
                    TCHAR       szNewFaceName[LF_FACESIZE];
                    TEXTMETRIC  tm;

                    if (!::GetTextMetrics(*pxhdc, &tm))
                    {    
                        AssertSz(FALSE, "(DEBUG Trace Code) GetTextMetrics failed for XFormFont!");
                    }
                    else
                    {
                        AssertSz(!!(TMPF_TRUETYPE & tm.tmPitchAndFamily), "Non TrueType Font selected for XFont!");
                        GetTextFace(*pxhdc, LF_FACESIZE, szNewFaceName);

                        TraceTagEx((tagXFormFont, TAG_NONAME,
                                    "XFormFont: (Requested) F:%ls, H:=%d, E:%d, CS:%d, OP:%d",
                                    lf.lfFaceName, lf.lfHeight, lf.lfEscapement, lf.lfCharSet, lf.lfOutPrecision));

                        TraceTagEx((tagXFormFont, TAG_NONAME,
                                    "XFormFont: (New) F:%ls, H:=%d, CS:%d, TT:%d",
                                    szNewFaceName, tm.tmHeight, tm.tmCharSet, !!(TMPF_TRUETYPE & tm.tmPitchAndFamily)));
                    }
                    
                }
#endif
            }
        }
    }
    if (hFontOld && hFontNew)
    {
        _hFontOld = hFontOld;
        _hFontNew = hFontNew;
        _pxhdc = pxhdc;
    }
    else
    {
        _hFontOld = _hFontNew = NULL;
        _pxhdc = NULL;
    }
}

CXFormFont::~CXFormFont()
{
    if (_hFontOld)
    {
        Assert(_pxhdc);
        Assert(_hFontNew);
        SelectFontEx(*_pxhdc, _hFontOld);
        DeleteFontEx(_hFontNew);
    }
#if DBG==1
    else
    {
        Assert(!_pxhdc);
        Assert(!_hFontNew);
    }
#endif
}   

void
CNewWidths::TransformWidthsArray(INT *lpdxd, UINT cch, double scf)
{
    if (lpdxd)
    {
        if (S_OK == EnsureSize(cch))
        {
            INT *pWidths = lpdxd;
            INT *pWidthsNew = &Item(0);
            INT sxut = 0;           // sigmaX - untransformed
            double sxt;             // sigmaX - transformed
            INT sxtPrev = 0;        // sigmaX till prev char - transformed

            for (UINT i = 0; i < cch; i++, pWidths++, pWidthsNew++)
            {
                sxut += *pWidths;
                sxt = sxut * scf;
                *pWidthsNew = sxt - sxtPrev;
                sxtPrev += *pWidthsNew;
            }
        }
    }
}

void
CNewOffsets::TransformOffsetsArray(GOFFSET *pOffset, UINT cch, double sx, double sy)
{
    if (pOffset)
    {
        if (S_OK == EnsureSize(cch))
        {
            INT sxut = 0;           // sigmaX - untransformed
            INT syut = 0;           // sigmaX - untransformed
            double sxt;             // sigmaX - transformed
            double syt;             // sigmaX - transformed
            INT sxtPrev = 0;        // sigmaX till prev char - transformed
            INT sytPrev = 0;        // sigmaX till prev char - transformed
            GOFFSET *pOffsetNew = &Item(0);

            for (UINT i = 0; i < cch; i++, pOffset++, pOffsetNew++)
            {
                sxut += pOffset->du;
                sxt = sxut * sx;
                pOffsetNew->du = sxt - sxtPrev;
                sxtPrev += pOffsetNew->du;

                syut += pOffset->dv;
                syt = syut * sy;
                pOffsetNew->dv = syt - sytPrev;
                sytPrev += pOffsetNew->dv;
            }
        }
    }
}

#if USE_UNICODE_WRAPPERS==1
int DrawTextInCodePage(UINT uCP, XHDC xhdc, LPCWSTR lpString, int nCount, LPRECT lpRect, UINT uFormat)
{
    if (g_fUnicodePlatform)
        return xhdc.DrawTextW((LPWSTR)lpString, nCount, lpRect, uFormat);
    else
    {
        CStrIn str(uCP,lpString,nCount);
        return xhdc.DrawTextA(str, str.strlen(), lpRect, uFormat);
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\download\css.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 2000 - 2001.
//
//  File:       Css.cxx
//
//  Contents:   CCssCtx
//              CCssInfo
//              CCssLoad
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CSS_HXX_
#define X_CSS_HXX_
#include "css.hxx"
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"
#endif

#ifndef X_MSHTMLRC_H_
#define X_MSHTMLRC_H_
#include "mshtmlrc.h"
#endif

#ifndef X_FATSTG_HXX_
#define X_FATSTG_HXX_
#include "fatstg.hxx"
#endif

#ifndef X_PRGSNK_H_
#define X_PRGSNK_H_
#include <prgsnk.h>
#endif

// Debugging ------------------------------------------------------------------
PerfDbgTag(tagCssCtx,    "Dwn",  "Trace CCssCtx")
PerfDbgTag(tagCssInfo,   "Dwn", "Trace CCssInfo")
PerfDbgTag(tagCssLoad,   "Dwn", "Trace CCssLoad")
MtDefine(CCssCtx, Dwn, "CCssCtx")
MtDefine(CCssInfo, Dwn, "CCssInfo")
MtDefine(CCssLoad, Dwn, "CCssLoad")

// CCssCtx -------------------------------------------------------------------
DWORD
CCssCtx::GetState()
{
    PerfDbgLog(tagCssCtx, this, "+CCssCtx::GetState ");

    DWORD dwState;

    EnterCriticalSection();

    dwState = _wChg;

    if (_pDwnInfo)
    {
        dwState |= _pDwnInfo->GetFlags(DWNF_STATE|DWNLOAD_HEADERS);
    }

    LeaveCriticalSection();

    PerfDbgLog1(tagCssCtx, this, "-CCssCtx::GetState (dwState=%08lX)", dwState);
    return(dwState);
}


DWORD    
CCssCtx::GetRefresh()
{
    return _pDwnInfo->GetRefresh();
}

DWORD    
CCssCtx::GetBindf()
{
    return _pDwnInfo->GetBindf();
}


void
CCssCtx::SelectChanges(ULONG ulChgOn, ULONG ulChgOff, BOOL fSignal)
{

    WORD wNewChg = 0;
    
    EnterCriticalSection();

    _wChgReq &= (WORD)~ulChgOff;

    if (    fSignal
        &&  !(_wChgReq & DWNCHG_HEADERS)
        &&  (ulChgOn & DWNCHG_HEADERS)
        &&  GetDwnInfo()->TstFlags(DWNLOAD_HEADERS))
    {
        wNewChg |= DWNCHG_HEADERS;
    }

    if (    fSignal
        &&  !(_wChgReq & DWNCHG_COMPLETE)
        &&  (ulChgOn & DWNCHG_COMPLETE)
        &&  GetDwnInfo()->TstFlags(DWNLOAD_COMPLETE))
    {
        wNewChg |= DWNCHG_COMPLETE;
    }

    _wChgReq |= (WORD)ulChgOn;
    
    if (wNewChg)
    {
        Signal(wNewChg);
    }

    LeaveCriticalSection();
}



// CCssInfo ------------------------------------------------------------------
HRESULT
CCssInfo::NewDwnCtx(CDwnCtx ** ppDwnCtx)
{
    *ppDwnCtx = new CCssCtx;
    RRETURN(*ppDwnCtx ? S_OK : E_OUTOFMEMORY);
}

HRESULT
CCssInfo::NewDwnLoad(CDwnLoad ** ppDwnLoad)
{
    *ppDwnLoad = new CCssLoad;
    RRETURN(*ppDwnLoad ? S_OK : E_OUTOFMEMORY);
}


void
CCssInfo::OnLoadDone(HRESULT hrErr)
{
    PerfDbgLog1(tagCssInfo, this, "+CCssInfo::OnLoadDone (hrErr=%lX)", hrErr);

    Assert(EnteredCriticalSection());

    UpdFlags(DWNLOAD_MASK|DWNLOAD_HEADERS, !hrErr ? DWNLOAD_COMPLETE : DWNLOAD_ERROR);
    Signal(DWNCHG_COMPLETE);

    PerfDbgLog(tagCssInfo, this, "-CCssInfo::OnLoadDone");
}


void  
CCssInfo::OnLoadHeaders(HRESULT hrErr)
{
    PerfDbgLog1(tagCssInfo, this, "+CCssInfo::OnHeadersDone (hrErr=%lX)", hrErr);

    Assert(!EnteredCriticalSection());

    EnterCriticalSection();

    UpdFlags(DWNLOAD_MASK|DWNLOAD_HEADERS, !hrErr ? DWNLOAD_HEADERS : DWNLOAD_ERROR);
    Signal(DWNCHG_HEADERS);
    
    LeaveCriticalSection();

    PerfDbgLog(tagCssInfo, this, "-CCssInfo::OnHeadersDone");
}



// CCssLoad ---------------------------------------------------------------
HRESULT 
CCssLoad::OnHeaders(HRESULT hrErr)
{
    GetCssInfo()->OnLoadHeaders(hrErr);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\download\bodyctx.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       bodyctx.cxx
//
//  Contents:   CHtmTextParseCtx manipulates spaces and nbsps, and adds
//              special characters underneath certain elements in the BODY
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X_ROOTCTX_HXX_
#define X_ROOTCTX_HXX_
#include "rootctx.hxx"
#endif

#ifndef X_HTM_HXX_
#define X_HTM_HXX_
#include "htm.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_FILLCODE_HXX_
#define X_FILLCODE_HXX_
#include "fillcode.hxx"
#endif

DeclareTag(tagNoWchNoScope, "TextNoScope", "Don't use WCH_NOSCOPE for noscope elements");

MtDefine(CHtmTextParseCtx, CHtmParseCtx, "CHtmTextParseCtx");
MtDefine(CHtmBodyParseCtx, CHtmParseCtx, "CHtmTextParseCtx");
MtDefine(CHtmPreParseCtx,  CHtmParseCtx, "CHtmCrlfParseCtx")
MtDefine(CHtmHeadParseCtx, Dwn,          "CHtmHeadParseCtx")

ULONG
FillCodeFromEtag(ELEMENT_TAG etag)
{
    switch (etag)
    {
    case ETAG_ADDRESS:
    case ETAG_BLOCKQUOTE:
    case ETAG_BODY:
    case ETAG_CAPTION:
    case ETAG_CENTER:
    case ETAG_COLGROUP:
    case ETAG_DD:
    case ETAG_DIR:
    case ETAG_DL:
    case ETAG_DT:
    case ETAG_FORM:
    case ETAG_H1:
    case ETAG_H2:
    case ETAG_H3:
    case ETAG_H4:
    case ETAG_H5:
    case ETAG_H6:
    case ETAG_LEGEND:
    case ETAG_LI:
    case ETAG_MENU:
    case ETAG_OL:
    case ETAG_P:
    case ETAG_TABLE:
    case ETAG_TBODY:
    case ETAG_TC:
    case ETAG_TD:
    case ETAG_TFOOT:
    case ETAG_TH:
    case ETAG_THEAD:
    case ETAG_TR:
    case ETAG_UL:
    case ETAG_DIV:
#ifdef  NEVER
    case ETAG_HTMLAREA:
#endif
    case ETAG_BR:
        
        // Left of  begin: allow space
        // Right of begin: eat space
        // Left of  end:   allow space
        // Right of end:   eat space
        return LB(FILL_PUT) | RB(FILL_EAT) | LE(FILL_PUT) | RE(FILL_EAT);

    case ETAG_FIELDSET:
        // Left of  begin: allow space
        // Right of begin: eat space
        // Left of  end:   allow space
        // Right of end:   allow space
        return LB(FILL_PUT) | RB(FILL_EAT) | LE(FILL_PUT) | RE(FILL_PUT);
    case ETAG_LISTING:
    case ETAG_PLAINTEXT:
    case ETAG_PRE:
    case ETAG_XMP:
    
        // Left of  begin: allow space
        // Right of begin: allow space
        // Left of  end:   allow space
        // Right of end:   eat space
        return LB(FILL_PUT) | RB(FILL_PUT) | LE(FILL_PUT) | RE(FILL_EAT);
    
    case ETAG_OPTION:
    
        // Left of  begin: allow space
        // Right of begin: eat space
        // Left of  end:   eat space
        // Right of end:   allow space
        return LB(FILL_PUT) | RB(FILL_EAT) | LE(FILL_EAT) | RE(FILL_PUT);

    case ETAG_IMG:
    case ETAG_INPUT:
    case ETAG_SELECT:
    case ETAG_TEXTAREA:
    case ETAG_APPLET:
    case ETAG_EMBED:
    
        // Left of  begin: allow space
        // Right of begin: allow space
        // Left of  end:   allow space
        // Right of end:   allow space
        return LB(FILL_PUT) | RB(FILL_PUT) | LE(FILL_PUT) | RE(FILL_PUT);

    case ETAG_OBJECT:
    
        // Note that OBJECT tags in IE4 ate spaces around themselves(IE5 21266)
        
        // Left of  begin: eat space
        // Right of begin: eat space
        // Left of  end:   eat space
        // Right of end:   eat space
        return LB(FILL_EAT) | RB(FILL_EAT) | LE(FILL_EAT) | RE(FILL_EAT);
    
    case ETAG_MARQUEE:
    
        // MARQUEE tags in IE4 ate spaces after themselves
        
        // Left of  begin: eat space
        // Right of begin: eat space
        // Left of  end:   eat space
        // Right of end:   eat space
        return LB(FILL_PUT) | RB(FILL_EAT) | LE(FILL_EAT) | RE(FILL_EAT);
        
    case ETAG_BUTTON:
    
        // BUTTON tags in IE4 ate spaces before themselves (IE5 24846)
        
        // Left of  begin: eat space
        // Right of begin: eat space
        // Left of  end:   eat space
        // Right of end:   eat space
        return LB(FILL_EAT) | RB(FILL_EAT) | LE(FILL_EAT) | RE(FILL_PUT);
    case ETAG_SCRIPT:
        // Transfer space through a script as if it weren't there
        return LB(FILL_NUL) | RB(FILL_NUL) | LE(FILL_NUL) | RE(FILL_NUL);

    default:
        // Left of  begin: allow space
        // Right of begin: don't care
        // Left of  end:   allow space
        // Right of end:   don't care
        return LB(FILL_PUT) | RB(FILL_NUL) | LE(FILL_PUT) | RE(FILL_NUL);
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   RemoveOneNbspFromEtag
//
//  Synopsis:   Returns TRUE for etags for which a single nbsp will be
//              removed in edit mode.
//
//-----------------------------------------------------------------------------
static BOOL
ShouldEatNbsp(ELEMENT_TAG etag)
{
    switch (etag)
    {
    case ETAG_ADDRESS:
    case ETAG_BLOCKQUOTE:
    case ETAG_BODY:
    case ETAG_CAPTION:
    case ETAG_CENTER:
    case ETAG_DD:
    case ETAG_DIR:
    case ETAG_DL:
    case ETAG_DT:
    case ETAG_FIELDSET:
    case ETAG_FORM:
    case ETAG_H1:
    case ETAG_H2:
    case ETAG_H3:
    case ETAG_H4:
    case ETAG_H5:
    case ETAG_H6:
    case ETAG_LEGEND:
    case ETAG_LI:
    case ETAG_LISTING:
    case ETAG_MENU:
    case ETAG_OL:
    case ETAG_P:
    case ETAG_PLAINTEXT:
    case ETAG_PRE:
    case ETAG_UL:
    case ETAG_XMP:
    case ETAG_DIV:
#ifdef  NEVER
    case ETAG_HTMLAREA:
#endif
    return TRUE;
    }
    return FALSE;
}


//+----------------------------------------------------------------------------
//
//  Function:   DoesNotDisturbNbspEating
//
//  Synopsis:   These ETAGs can be mixed in with a potential nbsp to be
//              removed and turned into a break on empty.
//
//-----------------------------------------------------------------------------
static BOOL
DoesNotDisturbNbspEating(ELEMENT_TAG etag)
{
    switch (etag)
    {
    // (JHarding): List of tags here that do not disturb nbsp eating
    // came from JohnThim 8/10/99
    case ETAG_CITE:
    case ETAG_FONT:
    case ETAG_S:
    case ETAG_STRONG:
    case ETAG_U:
    case ETAG_B:
    case ETAG_CODE:
    case ETAG_I:
    case ETAG_SAMP:
    case ETAG_SUB:
    case ETAG_BIG:
    case ETAG_DFN:
    case ETAG_KBD:
    case ETAG_SMALL:
    case ETAG_SUP:
    case ETAG_EM:
    case ETAG_Q:
    case ETAG_STRIKE:
    case ETAG_TT:
    case ETAG_COMMENT:
    case ETAG_SCRIPT:
    case ETAG_NOSCRIPT:
    case ETAG_A:
    case ETAG_SPAN:
    case ETAG_UNKNOWN:
    case ETAG_NOFRAMES:
    // Add the rest here
        return TRUE;
    }
    return FALSE;
}



//+----------------------------------------------------------------------------
//
//  CHtmTextParseCtx
//
//  Synopsis:   This class
//              1. Depends on its base class to collapse crlfs and spaces
//              2. Depends on the Root parse context to actually insert
//                 text and nodes into the tree
//              3. Applies rules to figure out when to remove &nbsps in edit mode
//
//-----------------------------------------------------------------------------

class CHtmTextParseCtx : public CHtmSpaceParseCtx
{
public:

    typedef CHtmSpaceParseCtx super;

    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CHtmTextParseCtx))

    CHtmTextParseCtx(CHtmParseCtx *phpxParent, CElement *pel, CHtmParse *pHtmParse);
    
    virtual ~CHtmTextParseCtx ();
    
    virtual HRESULT BeginElement(CTreeNode **ppNodeNew, CElement *pel, CTreeNode *pNodeCur, BOOL fEmpty);
    virtual HRESULT EndElement(CTreeNode **ppNodeNew, CTreeNode *pNodeCur, CTreeNode *pNodeEnd);
    virtual HRESULT AddWord(CTreeNode *pNode, TCHAR *pch, ULONG cch, BOOL fAscii);
    virtual HRESULT AddSpace(CTreeNode *pNode);
    virtual HRESULT AddCollapsedWhitespace(CTreeNode *pNode, TCHAR *pch, ULONG cch);
    virtual HRESULT Init();
    virtual HRESULT Finish();
    virtual HRESULT InsertLPointer ( CTreePos * * pptp, CTreeNode * pNodeCur );
    virtual HRESULT InsertRPointer ( CTreePos * * pptp, CTreeNode * pNodeCur );


    HRESULT FlushNbsp(CTreeNode * pNodeCur);
    void AbsorbNbsp();
    void BeginNbspEater(CTreeNode *pNode);
    void SetNbspPos(CTreePos *ptp);
    HRESULT AddOneNbsp(CTreeNode *pNode);
    BOOL MatchNbspNode(CTreeNode *pNode);

protected:

    CTreeNode    *_pNodeNbsp;       // for setting _fBreakOnEmpty
    CTreePos     *_ptpAfterNbsp;    // for adding &nbsp text
    BOOL          _fHaveNbsp;
    CHtmParseCtx *_phpxRoot;
    BOOL          _fNbspMode;
    ELEMENT_TAG   _etagContainer;   // Top container, whether BODY or TD etc
    CHtmParse    *_pHtmParse;       // HtmParse for commit-ing
};

//+----------------------------------------------------------------------------
//
//  Function:   CreateHtmTextParseContext
//
//  Synopsis:   Factory
//
//-----------------------------------------------------------------------------

HRESULT
CreateHtmTextParseCtx(CHtmParseCtx **pphpx, CElement *pel, CHtmParseCtx *phpxParent, CHtmParse *pHtmParse)
{
    CHtmParseCtx *phpx;

    phpx = new CHtmTextParseCtx(phpxParent, pel, pHtmParse);
    
    if (!phpx)
        return E_OUTOFMEMORY;

    *pphpx = phpx;

    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Function:   CHtmTextParseContext::CHtmTextParseContext
//
//  Synopsis:   Constructor, destructor
//
//-----------------------------------------------------------------------------

const ELEMENT_TAG
s_atagTextReject[] =
{
    ETAG_HEAD,
    ETAG_HTML,
    ETAG_FRAMESET,
    ETAG_FRAME,
    ETAG_OPTGROUP,
    ETAG_OPTION,
    ETAG_PARAM,
    ETAG_UNKNOWN,
    ETAG_NULL
};

const ELEMENT_TAG
s_atagTextDrop[] =
{
    ETAG_HEAD,
    ETAG_HTML,
    ETAG_NULL
};

const ELEMENT_TAG
s_atagTextIgnoreEnd[] =
{
    ETAG_HEAD,
    ETAG_HTML,
    ETAG_BODY,
    ETAG_BASE,
    ETAG_LI,
    ETAG_DD,
    ETAG_DT,
    ETAG_NULL
};

const ELEMENT_TAG
s_atagPasteIgnoreEnd[] =
{
    ETAG_HEAD,
    ETAG_HTML,
    ETAG_BODY,
    ETAG_BASE,
    ETAG_NULL
};

CHtmTextParseCtx::CHtmTextParseCtx(CHtmParseCtx *phpxParent, CElement *pel, CHtmParse *pHtmParse)
    : CHtmSpaceParseCtx(phpxParent)
{
    CMarkup *pMarkup = pel->GetMarkup();

    _phpxRoot = GetHpxRoot();
    
    // When parsing for paste, don't ignore end-tags for LI's, DD's, DT's.
    if (pMarkup->_fMarkupServicesParsing)
        _atagIgnoreEnd = s_atagPasteIgnoreEnd;
    else
        _atagIgnoreEnd = s_atagTextIgnoreEnd;
    
    _atagReject    = s_atagTextReject;
    _atagTag       = s_atagTextDrop;

    // TODO (MohanB) Shouldn't check pel->IsEditable() instead?
    _fNbspMode = (pMarkup && pMarkup->IsEditable());
    _pHtmParse = pHtmParse;
    
    _etagContainer = pel->Tag();
}

//+----------------------------------------------------------------------------
//
//  Function:   CHtmTextParseCtx::AddWord, CHtmTextParseCtx::AddSpace
//
//  Synopsis:   Text handling for CHtmTextParseCtx
//
//              In addition to using the base class to collapse multiple
//              spaces down to one, this class also removes single
//              &nbsp characters from within paragraphs and other designated
//              elements, and from before BRs.
//
//-----------------------------------------------------------------------------

HRESULT
CHtmTextParseCtx::AddWord(CTreeNode *pNode, TCHAR *pch, ULONG cch, BOOL fAscii)
{
    HRESULT hr;
    
    // 1. Deal with single nbsp

    if (_fNbspMode)
    {
        if (cch == 1 && *pch == WCH_NBSP)
        {
            hr = THR(AddOneNbsp(pNode));
            goto Cleanup; // skip the rest
        }
        else
        {
            hr = THR(FlushNbsp(pNode));
            if (hr)
                goto Cleanup;
        }
    }

    // 2. Go ahead and add text
    
    hr = THR(_phpxRoot->AddText(pNode, pch, cch, fAscii));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Function:   CHtmTextParseCtx::AddCollapsedWhitespace
//
//  Synopsis:   Collapsed whitespace handling for CHtmTextParseCtx
//
//-----------------------------------------------------------------------------

HRESULT
CHtmTextParseCtx::AddCollapsedWhitespace(CTreeNode *pNode, TCHAR *pch, ULONG cch)
{
    HRESULT hr;
    
    // Delegate to root context
    
    hr = THR(_phpxRoot->AddCollapsedWhitespace(pNode, pch, cch));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

            
HRESULT
CHtmTextParseCtx::AddSpace(CTreeNode *pNode)
{
    HRESULT hr;
    TCHAR ch = _T(' ');
    
    if (_fNbspMode)
    {
        hr = THR(FlushNbsp(pNode));
        if (hr)
            goto Cleanup;
    }
    
    hr = THR(_phpxRoot->AddText(pNode, &ch, 1, TRUE));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Methods:    CHtmTextParseCtx::BeginElement
//              CHtmTextParseCtx::EndElement
//
//  Synopsis:   Tag handling for CHtmTextParseCtx
//
//              In addition to driving space collapsing logic for
//              CHtmSpaceParseCtx, this code also
//
//              1. drives the nbsp eater to absorb lone nbsps in certain
//                 situations (while setting _fBreakOnEmpty)
//
//              2. places embedding characters underneath certain elements
//
//-----------------------------------------------------------------------------

HRESULT
CHtmTextParseCtx::BeginElement(CTreeNode **ppNodeNew, CElement *pel, CTreeNode *pNodeCur, BOOL fEmpty)
{
    HRESULT hr;
    ULONG fillcode;
    ELEMENT_TAG etag;

    etag = pel->Tag();

    // 1. Flush any nbsp that we might have been saving

    if (_fNbspMode)
    {
        if (etag == ETAG_BR)
        {
            AbsorbNbsp();
        }
        else if (!DoesNotDisturbNbspEating(etag))
        {
            hr = THR(FlushNbsp(pNodeCur));
            if (hr)
                goto Cleanup;
        }
    }
    
    // 2. Deal with space collapsing before begin tag
    
    fillcode = FillCodeFromEtag(etag);
    hr = THR(LFill(FILL_LB(fillcode)));
    if (hr)
        goto Cleanup;
   
    // 3. Put element into tree

    hr = THR(super::BeginElement(ppNodeNew, pel, pNodeCur, fEmpty));
    if (hr)
        goto Cleanup;

    // 4. Deal with space collapsing after begin tag

    RFill(FILL_RB(fillcode), fEmpty ? pNodeCur : *ppNodeNew);

    // 5. If element is of a current class, try to eat the next nbsp

    if( _fNbspMode )
    {
        // If we're eating an nbsp but haven't seen a begin/end yet, 
        if( _fHaveNbsp && !_ptpAfterNbsp )
        {
            SetNbspPos( (*ppNodeNew)->GetBeginPos() );
        }
        else if ( ShouldEatNbsp(etag) )
        {
            // Otherwise if we need to eat an nbsp, let's do that
            BeginNbspEater(*ppNodeNew);
        }
    }
 
Cleanup:
    RRETURN(hr);
}

HRESULT
CHtmTextParseCtx::EndElement(CTreeNode **ppNodeNew, CTreeNode *pNodeCur, CTreeNode *pNodeEnd)
{
    ULONG fillcode;
    HRESULT hr;

    // 1. Flush or absorb any nbsp that we might have been saving
    
    if (_fNbspMode)
    {
        if (MatchNbspNode(pNodeEnd))
        {
            AbsorbNbsp();
        }
        else if (!DoesNotDisturbNbspEating(pNodeEnd->Tag()))
        {
            hr = THR(FlushNbsp(pNodeCur));
            if (hr)
                goto Cleanup;
        }
    }

    // 2. Deal with whitespace to the left
    
    fillcode = FillCodeFromEtag(pNodeEnd->Tag());
    hr = THR(LFill(FILL_LE(fillcode)));
    if (hr)
        goto Cleanup;

    // 3. End element in tree

    hr = THR(super::EndElement(ppNodeNew, pNodeCur, pNodeEnd));
    if (hr)
        goto Cleanup;

    // 4. Deal with whitespace to the right
    
    hr = THR(RFill(FILL_RE(fillcode), *ppNodeNew));
    if (hr)
        goto Cleanup;

    if( _fNbspMode && _fHaveNbsp && !_ptpAfterNbsp )
    {
        SetNbspPos( pNodeEnd->GetEndPos() );
    }
        
Cleanup:
    RRETURN(hr);
}

HRESULT
CHtmTextParseCtx::InsertLPointer(CTreePos **pptp, CTreeNode *pNodeCur)
{
    HRESULT hr;
    
    // 1. Space eaten to the left of the beginning of a paste dealie
    
    hr = THR(LFill(FILL_EAT));
    if (hr)
        goto Cleanup;
   
    // 2. Insert LPointer

    hr = THR(super::InsertLPointer(pptp, pNodeCur));
    if (hr)
        goto Cleanup;

    // 3. Space is forced to the right of the beginning of a paste dealie

    RFill(FILL_PUT, pNodeCur);

Cleanup:
    RRETURN(hr);
}

HRESULT
CHtmTextParseCtx::InsertRPointer(CTreePos **pptp, CTreeNode *pNodeCur)
{
    HRESULT hr;
    
    // 1. Space is forced to the left of the end of a paste dealie
    
    hr = THR(LFill(FILL_PUT));
    if (hr)
        goto Cleanup;
   
    // 2. Insert RPointer

    hr = THR(super::InsertRPointer(pptp, pNodeCur));
    if (hr)
        goto Cleanup;

    // 3. Space is eaten to the right of the end pf a paste dealie

    RFill(FILL_EAT, pNodeCur);

Cleanup:
    RRETURN(hr);
}


HRESULT
CHtmTextParseCtx::Init()
{
    HRESULT hr = S_OK;
    ULONG fillcode;
    
    fillcode = FillCodeFromEtag(_etagContainer);
    hr = THR(RFill(FILL_RB(fillcode), NULL));
    if (hr)
        goto Cleanup;
    
Cleanup:
    RRETURN(hr);
}

HRESULT
CHtmTextParseCtx::Finish()
{
    HRESULT hr = S_OK;
    ULONG fillcode;
    
    fillcode = FillCodeFromEtag(_etagContainer);
    hr = THR(LFill(FILL_LE(fillcode)));
    if (hr)
        goto Cleanup;
    
Cleanup:
    RRETURN(hr);
}

CHtmTextParseCtx::~CHtmTextParseCtx()
{
#ifdef NOPARSEADDREF
    CTreeNode::ReleasePtr(_pNodeNbsp);
    CTreeNode::ReleasePtr(_ptpAfterNbsp);
#endif
}

//+----------------------------------------------------------------------------
//
//  Methods:    CHtmTextParseCtx::FlushNbsp
//              CHtmTextParseCtx::AbsorbNbsp
//              CHtmTextParseCtx::BeginNbspEater
//              CHtmTextParseCtx::AddOneNbsp
//              CHtmTextParseCtx::MatchNbspNode
//
//  Synopsis:   Basic Nbsp handling primitives for CHtmTextParseCtx 
//
//-----------------------------------------------------------------------------

// Flushes nbsp state and add stored nbsp if we had one
HRESULT
CHtmTextParseCtx::FlushNbsp(CTreeNode * pNodeCur)
{
    HRESULT hr = S_OK;
    
    if (_fHaveNbsp)
    {
        TCHAR ch = WCH_NBSP;
        Assert(_pNodeNbsp);

        if( !_ptpAfterNbsp )
        {
            // If we haven't put any nodes in after the nbsp, we can just insert
            hr = THR(_phpxRoot->AddText(pNodeCur, &ch, 1, FALSE));
            if (hr)
                goto Cleanup;
        }
        else
        {
            // Otherwise, we have to commit the parser, go back and insert the text, and then
            // spin the parser back up
            hr = THR( _pHtmParse->Commit() );
            if( hr )
                goto Cleanup;

            // We may have created an inclusion when we ended the node, 
            // so walk back to the appropriate spot
            if( _ptpAfterNbsp->IsEndNode() )
            {
                CTreePos * ptpPrev = _ptpAfterNbsp->PreviousTreePos();
                while( ptpPrev->IsNode() && !ptpPrev->IsEdgeScope() )
                {
                    Assert( ptpPrev->IsEndNode() );
                    _ptpAfterNbsp = ptpPrev;
                    ptpPrev = ptpPrev->PreviousTreePos();
                }
            }
            // CONSIDER (JHarding): May want to do this manually since we know we're inserting between 2 node pos's
            hr = THR( _ptpAfterNbsp->Branch()->GetMarkup()->InsertTextInternal( _ptpAfterNbsp, &ch, 1, 0 ) );
            if( hr )
                goto Cleanup;

            hr = THR( _pHtmParse->Prepare() );
            if( hr )
                goto Cleanup;
        }
    }

#ifdef NOPARSEADDREF
    CTreeNode::ClearPtr(&_pNodeNbsp);
    CTreeNode::ClearPtr(&_ptpAfterNbsp);
#else
    _pNodeNbsp = NULL;
    _ptpAfterNbsp = NULL;
#endif
    _fHaveNbsp = FALSE;

Cleanup:
    RRETURN(hr);
}

// Absorbs the nbsp if we have one
void
CHtmTextParseCtx::AbsorbNbsp()
{
    if (_fHaveNbsp)
    {
        Assert(_pNodeNbsp);
        
        _pNodeNbsp->Element()->_fBreakOnEmpty = TRUE;
    }
       
#ifdef NOPARSEADDREF
    CTreeNode::ClearPtr(&_pNodeNbsp);
    CTreeNode::ClearPtr(&_ptpAfterNbsp);
#else
    _pNodeNbsp = NULL;
    _ptpAfterNbsp = NULL;
#endif
    _fHaveNbsp = FALSE;
}

// Starts up our nbsp-storing state for a new nbsp-eater
void
CHtmTextParseCtx::BeginNbspEater(CTreeNode *pNode)
{
#ifdef NOPARSEADDREF
    CTreeNode::ReplacePtr(&_pNodeNbsp, pNode);
#else
    _pNodeNbsp = pNode;
#endif
    _ptpAfterNbsp = NULL;
    _fHaveNbsp = FALSE;
}


// Sets the variables that track where to put the nbsp
#if !DBG==1
inline
#endif // !DBG
void
CHtmTextParseCtx::SetNbspPos( CTreePos * ptp )
{
    Assert( ptp->IsEdgeScope() );

    _ptpAfterNbsp = ptp;
}

// Adds an nbsp - if we had one, we flush and insert this, otherwise
// we save it for later
HRESULT
CHtmTextParseCtx::AddOneNbsp(CTreeNode *pNode)
{
    HRESULT hr = S_OK;
    static TCHAR ch = WCH_NBSP;
    
    if (_fHaveNbsp)
    {
        hr = THR(FlushNbsp(pNode));
        if (hr)
            goto Cleanup;
    }

    if (_pNodeNbsp)
    {
        _fHaveNbsp = TRUE;
    }
    else
    {
        hr = THR(_phpxRoot->AddText(pNode, &ch, 1, FALSE));
        if (hr)
            goto Cleanup;
    }
    
Cleanup:
    RRETURN(hr);
}

// Is this node the one we were saving an nbsp for?
inline BOOL
CHtmTextParseCtx::MatchNbspNode(CTreeNode *pNode)
{
    return SameScope( pNode, _pNodeNbsp );
}


//+------------------------------------------------------------------------
//
//  CHtmHeadParseCtx
//
//  The top-level context for the HEAD element
//
//-------------------------------------------------------------------------

class CHtmHeadParseCtx : public CHtmTextParseCtx
{
public:
    typedef CHtmTextParseCtx super;

    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CHtmHeadParseCtx));
    
    CHtmHeadParseCtx(CHtmParseCtx *phpxParent, CElement *pelTop, CHtmParse * pHtmParse);
    ~CHtmHeadParseCtx();
    
    CHtmParseCtx *GetHpxEmbed();
    
    virtual BOOL QueryTextlike(CMarkup * pMarkup, ELEMENT_TAG etag, CHtmTag *pht);
    virtual HRESULT AddText(CTreeNode *pNode, TCHAR *pch, ULONG cch, BOOL fAscii);
    virtual HRESULT BeginElement(CTreeNode **ppNodeNew, CElement *pel, CTreeNode *pNodeCur, BOOL fEmpty);
    virtual HRESULT EndElement(CTreeNode **ppNodeNew, CTreeNode *pNodeCur, CTreeNode *pNodeEnd);

    CHeadElement *  _pHeadElement;
    long            _cAccumulate;
};

//+------------------------------------------------------------------------
//
//  Function:   CreateHtmHeadParseCtx
//
//  Synopsis:   Factory
//
//-------------------------------------------------------------------------

HRESULT
CreateHtmHeadParseCtx(CHtmParseCtx **pphpx, CElement *pel, CHtmParseCtx *phpxParent, CHtmParse *pHtmParse)
{
    CHtmParseCtx *phpx;

    phpx = new CHtmHeadParseCtx(phpxParent, pel, pHtmParse);
    if (!phpx)
        return E_OUTOFMEMORY;

    *pphpx = phpx;
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Constant:   s_atagHeadAccept
//
//  Synopsis:   The set of tags not treated as unknowns within a head ctx.
//              Note that CHtmPost ensures that the majority of tags are
//              not even fed to the HEAD ctx.
//
//-------------------------------------------------------------------------

//ELEMENT_TAG s_atagHeadAccept[] = {ETAG_TITLE, ETAG_SCRIPT, ETAG_STYLE, ETAG_META,
//                                  ETAG_LINK, ETAG_NEXTID, ETAG_BASE_EMPTY, ETAG_BGSOUND, ETAG_OBJECT,
//                                  ETAG_NOSCRIPT, ETAG_NOEMBED, ETAG_NOFRAMES, ETAG_COMMENT, ETAG_NULL};

const ELEMENT_TAG s_atagHeadReject[] = {ETAG_NULL};
const ELEMENT_TAG s_atagHeadIgnoreEnd[] = {ETAG_HTML, ETAG_HEAD, ETAG_BODY, ETAG_NULL};


//+------------------------------------------------------------------------
//
//  Member:     CHtmHeadParseCtx::ctor
//
//  Synopsis:   first-phase construction
//
//-------------------------------------------------------------------------
CHtmHeadParseCtx::CHtmHeadParseCtx(CHtmParseCtx *phpxParent, CElement *pelTop, CHtmParse * pHtmParse)
    : CHtmTextParseCtx(phpxParent, pelTop, pHtmParse)
{
    Assert(pelTop->Tag() == ETAG_HEAD);

    _atagReject    = s_atagHeadReject;
    _atagIgnoreEnd = s_atagHeadIgnoreEnd;
    _pHeadElement  = DYNCAST(CHeadElement, pelTop);
    _pHeadElement->AddRef();
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmHeadParseCtx::ctor
//
//  Synopsis:   first-phase construction
//
//-------------------------------------------------------------------------
CHtmHeadParseCtx::~CHtmHeadParseCtx()
{
    CElement::ReleasePtr(_pHeadElement);
}

//+------------------------------------------------------------------------
//
//  Member:     CHtmHeadParseCtx::GetHpxEmbed
//
//  Synopsis:   HEAD is an embedding context
//
//-------------------------------------------------------------------------
CHtmParseCtx *
CHtmHeadParseCtx::GetHpxEmbed()
{
    return this;
}

//+------------------------------------------------------------------------
//
//  Method:     CHtmHeadParseCtx::QueryTextlike
//
//  Synopsis:   Computes if a tag should be treated as textlike in
//              the HEAD - mostly, compatibility concerns
//
//-------------------------------------------------------------------------
BOOL
CHtmHeadParseCtx::QueryTextlike(CMarkup * pMarkup, ELEMENT_TAG etag, CHtmTag *pht)
{
    Assert(!pht || pht->Is(etag));
    
    // For IE 3 compatibility:
    // an OBJECT in the HEAD is not textlike if the HEAD was explicit and /HEAD hasn't been seen yet
    if (etag == ETAG_OBJECT && !_pHeadElement->_fSynthesized && !_pHeadElement->_fExplicitEndTag)
        return FALSE;

    return _phpxParent->QueryTextlike(pMarkup, etag, pht);
}


//+----------------------------------------------------------------------------
//
//  Methods:    CHtmHeadParseCtx::BeginElement
//              CHtmHeadParseCtx::EndElement
//              CHtmHeadParseCtx::AddText
//
//  Synopsis:   Accumulate text or not based on generic elements
//
//-----------------------------------------------------------------------------

HRESULT
CHtmHeadParseCtx::BeginElement(CTreeNode **ppNodeNew, CElement *pel, CTreeNode *pNodeCur, BOOL fEmpty)
{
    if (pel->TagType() == ETAG_GENERIC)
    {
        _cAccumulate++;
    }

    if (!_cAccumulate)
    {
        RRETURN(CHtmParseCtx::BeginElement(ppNodeNew, pel, pNodeCur, fEmpty));
    }
    
    RRETURN(super::BeginElement(ppNodeNew, pel, pNodeCur, fEmpty));
}


HRESULT
CHtmHeadParseCtx::EndElement(CTreeNode **ppNodeNew, CTreeNode *pNodeCur, CTreeNode *pNodeEnd)
{
    if (pNodeEnd->TagType() == ETAG_GENERIC)
    {
        _cAccumulate--;
    }
        
    RRETURN(super::EndElement(ppNodeNew, pNodeCur, pNodeEnd));
}

HRESULT 
CHtmHeadParseCtx::AddText(CTreeNode *pNode, TCHAR *pch, ULONG cch, BOOL fAscii) 
{ 
    if (!_cAccumulate)
    {
        Assert(IsAllSpaces(pch, cch)); 
        return S_OK; 
    }

    RRETURN(super::AddText(pNode, pch, cch, fAscii));
}



//+------------------------------------------------------------------------
//
//  Function:   TagPreservationType
//
//  Synopsis:   Describes how white space is handled in this tag
//
//-------------------------------------------------------------------------

WSPT
TagPreservationType ( ELEMENT_TAG etag )
{
    switch ( etag )
    {
    case ETAG_PRE :
    case ETAG_PLAINTEXT :
    case ETAG_LISTING :
    case ETAG_XMP :
    case ETAG_TEXTAREA:
    case ETAG_INPUT:
        return WSPT_PRESERVE;

    case ETAG_TD :
    case ETAG_TH :
    case ETAG_TC :
    case ETAG_CAPTION :
    case ETAG_BODY :
    case ETAG_ROOT :
    case ETAG_BUTTON :
#ifdef  NEVER
    case ETAG_HTMLAREA :
#endif
        return WSPT_COLLAPSE;

    default:
        return WSPT_NEITHER;
    }
}

//+----------------------------------------------------------------------------
//
//  CHtmBodyParseCtx
//
//  Synopsis:   This class extends CHtmTextParseCtx so that it knows
//              when to insert an automatic character under an element
//
//-----------------------------------------------------------------------------

class CHtmBodyParseCtx : public CHtmTextParseCtx
{
public:

    typedef CHtmTextParseCtx super;

    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CHtmBodyParseCtx))

    CHtmBodyParseCtx(CHtmParseCtx *phpxParent, CElement *pel, CHtmParse * pHtmParse) : CHtmTextParseCtx(phpxParent, pel, pHtmParse) { };
    
    virtual BOOL QueryTextlike(CMarkup * pMarkup, ELEMENT_TAG etag, CHtmTag *pht);
    
    CHtmParseCtx *GetHpxEmbed();
    
private:

    CHtmParseCtx *_phpxParent;
};

//+----------------------------------------------------------------------------
//
//  Function:   CreateHtmBodyParseContext
//
//  Synopsis:   Factory
//
//-----------------------------------------------------------------------------

HRESULT
CreateHtmBodyParseCtx(CHtmParseCtx **pphpx, CElement *pel, CHtmParseCtx *phpxParent, CHtmParse *pHtmParse)
{
    CHtmParseCtx *phpx;

    phpx = new CHtmBodyParseCtx(phpxParent, pel, pHtmParse);
    
    if (!phpx)
        return E_OUTOFMEMORY;

    *pphpx = phpx;

    return S_OK;
}


CHtmParseCtx *
CHtmBodyParseCtx::GetHpxEmbed()
{
    return this;
}


//+----------------------------------------------------------------------------
//
//  Function:   QueryTextlike
//
//  Synopsis:   Determines if TEXTLIKE_QUERY tags are textlike in the body
//              or not
//
//-----------------------------------------------------------------------------
BOOL
CHtmBodyParseCtx::QueryTextlike(CMarkup * pMarkup, ELEMENT_TAG etag, CHtmTag *pht)
{
    switch(etag)
    {
        case ETAG_INPUT:
        case ETAG_OBJECT:
        case ETAG_APPLET:
        case ETAG_A:
        case ETAG_DIV:
        case ETAG_SPAN:
        
            // Inside the body, INPUTs, OBJECTs, APPLETs, and As are always textlike

            return TRUE;

        default:

            // Everything else marked textlike_query is not.

            return FALSE;
    }
}
            

#if 0
//+----------------------------------------------------------------------------
//
//  Function:   InPre
//
//  Synopsis:   This computes the pre status of a branch after an element goes
//              out of scope.  The branch before the element goes out of scope
//              is passed in, as well as the element going out of scope.
//
//-----------------------------------------------------------------------------

CTreeNode *
InPre(CTreeNode * pNodeCur, CTreeNode * pNodeEnd)
{
    CTreeNode *pNode;

    for ( pNode = pNodeCur ; pNode ; pNode = pNode->Parent() )
    {
        if (!pNodeEnd || DifferentScope( pNode, pNodeEnd ))
        {
            switch ( TagPreservationType( pNode->Tag()) )
            {
            case WSPT_PRESERVE : return pNode;
            case WSPT_COLLAPSE : return NULL;
            case WSPT_NEITHER  : break;
            default            : Assert( 0 );
            }
        }
    }

    return NULL;
}
#endif

//+----------------------------------------------------------------------------
//
//  Class:      CHtmPreParseCtx
//
//  Synopsis:   For preformatted areas of text in which we should not
//              collapse any spaces, like in <PRE>s
//
//-----------------------------------------------------------------------------
class CHtmPreParseCtx : public CHtmCrlfParseCtx
{
    typedef CHtmCrlfParseCtx super;

public:

    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CHtmPreParseCtx))

    CHtmPreParseCtx(CHtmParseCtx *phpxParent);
            
    virtual HRESULT BeginElement(CTreeNode **ppNodeNew, CElement *pel, CTreeNode *pNodeCur, BOOL fEmpty);
    virtual HRESULT EndElement(CTreeNode **ppNodeNew, CTreeNode *pNodeCur, CTreeNode *pNodeEnd);
    virtual HRESULT AddNonspaces(CTreeNode *pNode, TCHAR *pch, ULONG cch, BOOL fAscii);
    virtual HRESULT AddSpaces(CTreeNode *pNode, TCHAR *pch, ULONG cch);

    inline void FlushLine(CTreeNode *pNodeCur);

private:
    BOOL _fInside;
    CHtmParseCtx *_phpxRoot;
};

HRESULT
CreateHtmPreParseCtx(CHtmParseCtx **pphpx, CElement *pel, CHtmParseCtx *phpxParent, CHtmParse *pHtmParse)
{
    CHtmParseCtx *phpx;

    phpx = new CHtmPreParseCtx(phpxParent);
    
    if (!phpx)
        return E_OUTOFMEMORY;

    Assert(pel->GetFirstBranch());
    pel->GetFirstBranch()->SetPre(TRUE);

    *pphpx = phpx;

    return S_OK;
}

CHtmPreParseCtx::CHtmPreParseCtx(CHtmParseCtx *phpxParent) : CHtmCrlfParseCtx(phpxParent)
{
    _atagReject    = s_atagTextReject;
    _atagIgnoreEnd = s_atagTextIgnoreEnd;
    
    _phpxRoot = GetHpxRoot();
}


//+----------------------------------------------------------------------------
//
//  Method:     CHtmPreParseCtx::FlushLine
//
//  Synopsis:   Used to a line if we've been saving one (disabled for
//              infoseek.htm robovision compat - it's not correct to
//              drop the last \r in a PRE.)
//
//              Now, simply notes that we're past the first \r in a pre.
//              (The first \r still needs to be dropped.)
//
//-----------------------------------------------------------------------------
void
CHtmPreParseCtx::FlushLine(CTreeNode *pNodeCur)
{
    _fInside = TRUE;
}

//+----------------------------------------------------------------------------
//
//  Methods:    CHtmPreParseCtx::EmptyElement
//              CHtmPreParseCtx::BeginElement
//              CHtmPreParseCtx::EndElement
//              CHtmPreParseCtx::AddNonspaces
//
//  Synopsis:   Flush a saved line before any element boundary or text
//
//-----------------------------------------------------------------------------
HRESULT
CHtmPreParseCtx::BeginElement(CTreeNode **ppNodeNew, CElement *pel, CTreeNode *pNodeCur, BOOL fEmpty)
{
    FlushLine(pNodeCur);

    pNodeCur->SetPre(TRUE);
        
    RRETURN(super::BeginElement(ppNodeNew, pel, pNodeCur, fEmpty));
}

HRESULT
CHtmPreParseCtx::EndElement(CTreeNode **ppNodeNew, CTreeNode *pNodeCur, CTreeNode *pNodeEnd)
{
    FlushLine(pNodeCur);
        
    RRETURN(super::EndElement(ppNodeNew, pNodeCur, pNodeEnd));
}

HRESULT
CHtmPreParseCtx::AddNonspaces(CTreeNode *pNode, TCHAR *pch, ULONG cch, BOOL fAscii)
{
    FlushLine(pNode);
        
    RRETURN(_phpxRoot->AddText(pNode, pch, cch, fAscii));
}

//+----------------------------------------------------------------------------
//
//  Method:     CHtmPreParseCtx::AddSpaces
//
//  Synopsis:   Drop first character in the pre if it is a \r
//
//-----------------------------------------------------------------------------

HRESULT
CHtmPreParseCtx::AddSpaces(CTreeNode *pNode, TCHAR *pch, ULONG cch)
{
    HRESULT hr = S_OK;

    Assert(cch > 0);
    
    // Eat first carriage return in pre if any

    if (!_fInside && *pch == _T('\r'))
    {
        pch++;
        cch--;
    }

    FlushLine(pNode);

    // Send the rest of the text into the tree

    if (cch)
    {
        hr = THR(_phpxRoot->AddText(pNode, pch, cch, TRUE));
        if (hr)
            goto Cleanup;
    }
    
Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\download\dither.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DITHERS_H_
#define X_DITHERS_H_
#include "dithers.h"
#endif

#ifndef X_OCMM_H_
#define X_OCMM_H_
#include "ocmm.h"
#endif

#ifndef X_SHLOBJ_H_
#define X_SHLOBJ_H_
#include "shlobj.h"
#endif

#ifndef X_SHLOBJP_H_
#define X_SHLOBJP_H_
#include "shlobjp.h"
#endif

#ifndef X_SHLGUID_H_
#define X_SHLGUID_H_
#include "shlguid.h"
#endif

#ifndef WIN16
#ifndef X_SHLGUIDP_H_
#define X_SHLGUIDP_H_
#include "shlguidp.h"
#endif
#endif

#if DBG==1
#define INLINE
#else
#define INLINE __inline
#endif

MtExtern(Dwn)
MtDefine(ImgDithBufs, Dwn, "AllocDitherBuffers")
MtDefine(CIntDitherer, Dwn, "CIntDitherer")

//-----------------------------------------------------------------------------
// helpers
//-----------------------------------------------------------------------------

const BYTE g_abClamp[] = {
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,
32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,
64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,
96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,
128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,
160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,
192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,
224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
};

INLINE UINT Clamp8(int z)
{
#if DBG==1
    UINT t = (z & 0xff00) ? (0xff & ~(z >> 16)) : z;

    if (t != g_abClamp[z + 256])
        DebugBreak();
#endif

    return g_abClamp[z + 256];
}

INLINE WORD rgb555(BYTE r, BYTE g, BYTE b)
{
    return( WORD( ((((WORD)(r) << 5) | (WORD)(g)) << 5) | (WORD)(b) ) );
}

INLINE WORD rgb565(BYTE r, BYTE g, BYTE b)
{
//    return( WORD( ((((WORD)(r) << 5) | (WORD)(g)) << 6) | (WORD)(b) ) );
//    return( WORD( ((((WORD)(r) << 6) | (WORD)((g << 1) | !!(g > 16))) << 5) | (WORD)(b) ) );
    return((WORD)(((((((WORD)(r) << 5) | (WORD)(g)) << 1) | (WORD)((g) > 16)) << 5) | (WORD)(b)));
}

//-----------------------------------------------------------------------------
// Halftoning stuff
//-----------------------------------------------------------------------------
//
// This table is used to halftone from 8 to 5 bpp.  Typically, 16 bit
// halftoning code will map an 8 bit value to a 5 bit value, map it back to
// 8 bits, compute some error, and use a halftone table to adjust the 5 bit
// value for the error.  This array is a concatenation of 8 different 8-to-5
// tables that include the error factoring in their mapping.  It is used with
// the halftoning table below, which gives indices to each of the mapping
// tables within the array.   Given the correct table pointer for a pixel,
// callers can perform a single lookup per color component in this table to get
// a halftoned 5 bit component.
//
#pragma data_seg(".text", "CODE")
const BYTE aHT16Data[] =
{
      0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,
      1,  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,  2,
      3,  3,  3,  3,  3,  3,  3,  3,  4,  4,  4,  4,  4,  4,  4,  4,
      5,  5,  5,  5,  5,  5,  5,  5,  6,  6,  6,  6,  6,  6,  6,  6,
      7,  7,  7,  7,  7,  7,  7,  7,  8,  8,  8,  8,  8,  8,  8,  8,
      9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10,
     11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12,
     13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14,
     15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
     17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18,
     19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20,
     21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22,
     23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24,
     25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26,
     27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28,
     29, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 31,
      0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,
      1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,  2,  3,
      3,  3,  3,  3,  3,  3,  3,  4,  4,  4,  4,  4,  4,  4,  4,  5,
      5,  5,  5,  5,  5,  5,  5,  6,  6,  6,  6,  6,  6,  6,  6,  7,
      7,  7,  7,  7,  7,  7,  7,  8,  8,  8,  8,  8,  8,  8,  8,  9,
      9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10, 11,
     11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 13,
     13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 15,
     15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 17,
     17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19,
     19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 21,
     21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 23,
     23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 25,
     25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 27,
     27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 29,
     29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 31,
     31, 31, 31, 31, 31, 31
};
const UINT aHT16Heads[4][4] =
{
    262, 256, 261,   0,
    258, 260, 257, 259,
    261,   0, 262, 256,
    257, 259, 258, 260,
};
#pragma data_seg()

INLINE UINT *
Get555HalftoneRow(UINT y)
{
    return (UINT*) (aHT16Heads[y % 4]);
}

INLINE BYTE *
Get555HalftoneTable(UINT *row, UINT x)
{
    return (BYTE*) (aHT16Data + row[x % 4]);
}

//-----------------------------------------------------------------------------
// Rounding stuff
//-----------------------------------------------------------------------------
//
// round an 8bit value to a 5bit value with good distribution
//
#pragma data_seg(".text", "CODE")
const BYTE aRound8to5[] = {
      0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,
      2,  2,  2,  2,  2,  3,  3,  3,  3,  3,  3,  3,  3,  4,  4,  4,
      4,  4,  4,  4,  4,  4,  5,  5,  5,  5,  5,  5,  5,  5,  6,  6,
      6,  6,  6,  6,  6,  6,  7,  7,  7,  7,  7,  7,  7,  7,  8,  8,
      8,  8,  8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9,  9, 10,
     10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 12,
     12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13,
     14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15,
     16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19,
     19, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21,
     21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23,
     23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25,
     25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27,
     27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29,
     29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31,
};
#pragma data_seg()

#pragma data_seg(".text", "CODE")
const BYTE aRound8to6[] =
{
  0,  0,  0,  0,  0,  1,  1,  1,  1,  2,  2,  2,  2,  3,  3,  3,
  3,  4,  4,  4,  4,  5,  5,  5,  5,  6,  6,  6,  6,  7,  7,  7,
  7,  8,  8,  8,  8,  9,  9,  9,  9, 10, 10, 10, 10, 11, 11, 11,
 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15,
 15, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19,
 19, 20, 20, 20, 20, 21, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23,
 23, 23, 24, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 26, 27, 27,
 27, 27, 28, 28, 28, 28, 29, 29, 29, 29, 30, 30, 30, 30, 31, 31,
 31, 31, 32, 32, 32, 32, 33, 33, 33, 33, 34, 34, 34, 34, 35, 35,
 35, 35, 36, 36, 36, 36, 37, 37, 37, 37, 38, 38, 38, 38, 39, 39,
 39, 39, 40, 40, 40, 40, 41, 41, 41, 41, 42, 42, 42, 42, 42, 43,
 43, 43, 43, 44, 44, 44, 44, 45, 45, 45, 45, 46, 46, 46, 46, 47,
 47, 47, 47, 48, 48, 48, 48, 49, 49, 49, 49, 50, 50, 50, 50, 51,
 51, 51, 51, 52, 52, 52, 52, 53, 53, 53, 53, 54, 54, 54, 54, 55,
 55, 55, 55, 56, 56, 56, 56, 57, 57, 57, 57, 58, 58, 58, 58, 59,
 59, 59, 59, 60, 60, 60, 60, 61, 61, 61, 61, 62, 62, 62, 62, 63,
};
#pragma data_seg()

//
// complement of table above
//
#pragma data_seg(".text", "CODE")
const BYTE aRound5to8[] = {
      0,  8, 16, 25, 33, 41, 49, 58, 66, 74, 82, 90, 99,107,115,123,
    132,140,148,156,165,173,181,189,197,206,214,222,230,239,247,255,
};
#pragma data_seg()

///////////////////////////////////////////////////////////////////////////////
//
// Dithering stuff.
//
// This code implements error-diffusion to an arbitrary set of colors,
// optionally with transparency.  Since the output colors can be arbitrary,
// the color picker for the dither is a 32k inverse-mapping table.  24bpp
// values are whacked down to 16bpp (555) and used as indices into the table.
// To compensate for posterization effects when converting 24bpp to 16bpp, an
// ordered dither (16bpp halftone) is used to generate the 555 color.
//
///////////////////////////////////////////////////////////////////////////////

INLINE void SwapError(ERRBUF **a, ERRBUF **b)
{
    ERRBUF *te;

    te = *a;
    *a = *b;
    *b = te;
}

INLINE void ZeroError(ERRBUF *err, size_t pels)
{
    ZeroMemory(err - 1, ErrbufBytes(pels));
}

#if 0
// UNUSED DITHERING CODE
//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*

INLINE void ConvertScan8to8( BYTE* pbDest, const BYTE* pbSrc, 
   const RGBQUAD* prgbColors, const BYTE* pbMap, UINT x, UINT xl, UINT y )
{
   UINT* pRow = Get555HalftoneRow( y );
   BYTE* pbTable;
   BYTE r;
   BYTE g;
   BYTE b;

   for (; x < xl; pbSrc += 3, x++ )
   {
      r = prgbColors[*pbSrc].rgbRed;
      g = prgbColors[*pbSrc].rgbGreen;
      b = prgbColors[*pbSrc].rgbBlue;

      pbTable = Get555HalftoneTable( pRow, x );
      *pbDest = pbMap[rgb555( pbTable[r], pbTable[g], pbTable[b] )];
   }
}

void Convert8to8( BYTE* pbDest, const BYTE* pbSrc, int nDestPitch, 
   int nSrcPitch, const RGBQUAD* prgbColors, const BYTE* pbMap, UINT x, 
   UINT nWidth, UINT y, int nHeight )
{
   int dy;
   UINT x2;

   x2 = x+nWidth;

   if( nHeight < 0 )
   {
      dy = -1;
      nHeight *= -1;
   }
   else
   {
      dy = 1;
   }

   while( nHeight )
   {
      ConvertScan8to8( pbDest, pbSrc, prgbColors, pbMap, x, x2, y );

      pbSrc += nSrcPitch;
      pbDest += nDestPitch;

      y += dy;
      nHeight--;
   }
}

INLINE void ConvertScanGray8to8( BYTE* pbDest, const BYTE* pbSrc,
   const BYTE* pbMap, UINT x, UINT xl, UINT y )
{
   UINT* pRow = Get555HalftoneRow( y );
   BYTE* pbTable;
   BYTE g;

   for (; x < xl; pbSrc++, x++ )
   {
      g = *pbSrc;

      pbTable = Get555HalftoneTable( pRow, x );
      *pbDest++ = pbMap[rgb555( pbTable[g], pbTable[g], pbTable[g] )];
   }
}

void ConvertGray8to8( BYTE* pbDest, const BYTE* pbSrc, int nDestPitch, 
   int nSrcPitch, const BYTE* pbMap, UINT x, UINT nWidth, UINT y, int nHeight )
{
   int dy;
   UINT x2;

   x2 = x+nWidth;

   if( nHeight < 0 )
   {
      dy = -1;
      nHeight *= -1;
   }
   else
   {
      dy = 1;
   }

   while( nHeight )
   {
      ConvertScanGray8to8( pbDest, pbSrc, pbMap, x, x2, y );

      pbSrc += nSrcPitch;
      pbDest += nDestPitch;

      y += dy;
      nHeight--;
   }
}

///////////////////////////////////////////////////////////////////////////////
//
// Dith8to16()                                            8bpp to 16bpp dither.
//
// Computes the 24bpp source color by combining the source pixel's color table
// entry with accumulated error for the pixel.  Halftones this 24bpp value to a
// 16bpp 555 color.  Remaps this color to 24bpp to compute and accumulates
// error for neighboring pixels.
//
///////////////////////////////////////////////////////////////////////////////

INLINE void DithScan8to16(WORD *dst, const BYTE *src, const RGBQUAD *colors,
    ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT xl, UINT y)
{
    UINT *row = Get555HalftoneRow(y);

    for (; x < xl; src++, x++)
    {
        register const RGBQUAD *pChosen;
        register WORD wColor;
        register BYTE *tbl;
        register int r;
        register int g;
        register int b;

        pChosen = colors + *src;
        r = Clamp8((int)pChosen->rgbRed   + cur_err->r / 16);
        g = Clamp8((int)pChosen->rgbGreen + cur_err->g / 16);
        b = Clamp8((int)pChosen->rgbBlue  + cur_err->b / 16);
        cur_err++;

        tbl = Get555HalftoneTable(row, x);
        wColor = (*dst++ = rgb555(tbl[r], tbl[g], tbl[b]));

        b -= (int)aRound5to8[wColor & 0x1f];
        (nxt_err+1)->b += b * 1;
        (nxt_err-1)->b += b * 3;
        (nxt_err  )->b += b * 5;
        (cur_err  )->b += b * 7;

        g -= (int)aRound5to8[(wColor >> 5) & 0x1f];
        (nxt_err+1)->g += g * 1;
        (nxt_err-1)->g += g * 3;
        (nxt_err  )->g += g * 5;
        (cur_err  )->g += g * 7;

        r -= (int)aRound5to8[(wColor >> 10) & 0x1f];
        (nxt_err+1)->r += r * 1;
        (nxt_err-1)->r += r * 3;
        (nxt_err  )->r += r * 5;
        (cur_err  )->r += r * 7;

        nxt_err++;
    }
}

void Dith8to16(WORD *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, const RGBQUAD *colors, ERRBUF *cur_err, ERRBUF *nxt_err,
    UINT x, UINT cx, UINT y, int cy)
{
    int dy;

    cx += x;

    if (cy < 0)
    {
        dy = -1;
        cy *= -1;
    }
    else
        dy = 1;

    if (y & 1)
        SwapError(&cur_err, &nxt_err);

    while (cy)
    {
        DithScan8to16(dst, src, colors, cur_err, nxt_err, x, cx, y);

        ZeroError(cur_err, cx);
        SwapError(&cur_err, &nxt_err);

        *(BYTE **)&src += src_next_scan;
        *(BYTE **)&dst += dst_next_scan;
        y += dy;
        cy--;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// Dith8to16t()                         8bpp to 16bpp dither with transparency.
//
// If the source pixel is the given source transparency color, this routine
// picks the destination transparency color for output and zero error is
// accumulated to the pixel's neighbors.
// Otherwise, this routine functions identically to Dith8to16.
//
///////////////////////////////////////////////////////////////////////////////

INLINE void DithScan8to16t(WORD *dst, const BYTE *src, const RGBQUAD *colors,
    ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT xl, UINT y,
    WORD wColorTxpOUT, BYTE indexTxpIN)
{
    UINT *row = Get555HalftoneRow(y);

    for (; x < xl; src ++, x++)
    {
        register const RGBQUAD *pChosen;
        register WORD wColor;
        register BYTE *tbl;
        register BYTE index;
        register int r;
        register int g;
        register int b;

        index = *src;
        if (index == indexTxpIN)
        {
            *dst++ = wColorTxpOUT;
            cur_err++;
            nxt_err++;
            continue;
        }

        pChosen = colors + index;
        r = Clamp8((int)pChosen->rgbRed   + cur_err->r / 16);
        g = Clamp8((int)pChosen->rgbGreen + cur_err->g / 16);
        b = Clamp8((int)pChosen->rgbBlue  + cur_err->b / 16);
        cur_err++;

        tbl = Get555HalftoneTable(row, x);
        wColor = (*dst++ = rgb555(tbl[r], tbl[g], tbl[b]));

        b -= (int)aRound5to8[wColor & 0x1f];
        (nxt_err+1)->b += b * 1;
        (nxt_err-1)->b += b * 3;
        (nxt_err  )->b += b * 5;
        (cur_err  )->b += b * 7;

        g -= (int)aRound5to8[(wColor >> 5) & 0x1f];
        (nxt_err+1)->g += g * 1;
        (nxt_err-1)->g += g * 3;
        (nxt_err  )->g += g * 5;
        (cur_err  )->g += g * 7;

        r -= (int)aRound5to8[(wColor >> 10) & 0x1f];
        (nxt_err+1)->r += r * 1;
        (nxt_err-1)->r += r * 3;
        (nxt_err  )->r += r * 5;
        (cur_err  )->r += r * 7;

        nxt_err++;
    }
}

void Dith8to16t(WORD *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, const RGBQUAD *colors, ERRBUF *cur_err, ERRBUF *nxt_err,
    UINT x, UINT cx, UINT y, int cy, WORD wColorTxpOUT, BYTE indexTxpIN)
{
    int dy;

    cx += x;

    if (cy < 0)
    {
        dy = -1;
        cy *= -1;
    }
    else
        dy = 1;

    if (y & 1)
        SwapError(&cur_err, &nxt_err);

    while (cy)
    {
        DithScan8to16t(dst, src, colors, cur_err, nxt_err, x, cx, y,
            wColorTxpOUT, indexTxpIN);

        ZeroError(cur_err, cx);
        SwapError(&cur_err, &nxt_err);

        *(BYTE **)&src += src_next_scan;
        *(BYTE **)&dst += dst_next_scan;
        y += dy;
        cy--;
    }
}

INLINE void ConvertScan24to8( BYTE* pbDest, const BYTE* pbSrc, 
   const BYTE* pbMap, UINT x, UINT xl, UINT y )
{
   UINT* pRow;
   BYTE* pbTable;
   BYTE r;
   BYTE g;
   BYTE b;

   pRow = Get555HalftoneRow( y );

   for (; x < xl; pbSrc += 3, x++ )
   {
      r = pbSrc[2];
      g = pbSrc[1];
      b = pbSrc[0];

      pbTable = Get555HalftoneTable( pRow, x );
      *pbDest = pbMap[rgb555( pbTable[r], pbTable[g], pbTable[b] )];
   }
}

void Convert24to8( BYTE* pbDest, const BYTE* pbSrc, int nDestPitch, 
   int nSrcPitch, const BYTE* pbMap, UINT x, UINT nWidth, UINT y, int nHeight )
{
   int dy;
   UINT x2;

   x2 = x+nWidth;

   if( nHeight < 0 )
   {
      dy = -1;
      nHeight *= -1;
   }
   else
   {
      dy = 1;
   }

   while( nHeight )
   {
      ConvertScan24to8( pbDest, pbSrc, pbMap, x, x2, y );

      pbSrc += nSrcPitch;
      pbDest += nDestPitch;

      y += dy;
      nHeight--;
   }
}

///////////////////////////////////////////////////////////////////////////////
//
// Dith24to16()                                          24bpp to 16bpp dither.
//
// Computes the 24bpp source color by combining the source pixel's color with
// accumulated error for the pixel.  Halftones this 24bpp value to a 16bpp 555
// color.  Remaps this color to 24bpp to compute and accumulates error for
// neighboring pixels.
//
///////////////////////////////////////////////////////////////////////////////

INLINE void DithScan24to16(WORD *dst, const BYTE *src, ERRBUF *cur_err,
    ERRBUF *nxt_err, UINT x, UINT xl, UINT y)
{
    UINT *row = Get555HalftoneRow(y);

    for (; x < xl; src += 3, x++)
    {
        register WORD wColor;
        register BYTE *tbl;
        register int r;
        register int g;
        register int b;

        r = Clamp8((int)src[2] + cur_err->r / 16);
        g = Clamp8((int)src[1] + cur_err->g / 16);
        b = Clamp8((int)src[0] + cur_err->b / 16);
        cur_err++;

        tbl = Get555HalftoneTable(row, x);
        wColor = (*dst++ = rgb555(tbl[r], tbl[g], tbl[b]));

        b -= (int)aRound5to8[wColor & 0x1f];
        (nxt_err+1)->b += b * 1;
        (nxt_err-1)->b += b * 3;
        (nxt_err  )->b += b * 5;
        (cur_err  )->b += b * 7;

        g -= (int)aRound5to8[(wColor >> 5) & 0x1f];
        (nxt_err+1)->g += g * 1;
        (nxt_err-1)->g += g * 3;
        (nxt_err  )->g += g * 5;
        (cur_err  )->g += g * 7;

        r -= (int)aRound5to8[(wColor >> 10) & 0x1f];
        (nxt_err+1)->r += r * 1;
        (nxt_err-1)->r += r * 3;
        (nxt_err  )->r += r * 5;
        (cur_err  )->r += r * 7;

        nxt_err++;
    }
}

void Dith24to16(WORD *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT cx,
    UINT y, int cy)
{
    int dy;

    cx += x;

    if (cy < 0)
    {
        dy = -1;
        cy *= -1;
    }
    else
        dy = 1;

    if (y & 1)
        SwapError(&cur_err, &nxt_err);

    while (cy)
    {
        DithScan24to16(dst, src, cur_err, nxt_err, x, cx, y);

        ZeroError(cur_err, cx);
        SwapError(&cur_err, &nxt_err);

        *(BYTE **)&src += src_next_scan;
        *(BYTE **)&dst += dst_next_scan;
        y += dy;
        cy--;
    }
}

// END OF UNUSED DITHERING CODE
//-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
#endif

///////////////////////////////////////////////////////////////////////////////
//
// Dith24rto15()                                         24bpp to 15bpp dither.
//
// Computes the 24bpp source color by combining the source pixel's color with
// accumulated error for the pixel.  THE SOURCE COMPONENT ORDER IS OPPOSITE A DIB:
// RED, GREEN, BLUE.  Halftones this 24bpp value to a 16bpp 555 color.  Remaps this 
// color to 24bpp to compute and accumulates error for neighboring pixels.
//
///////////////////////////////////////////////////////////////////////////////

INLINE void DithScan24rto15(WORD *dst, const BYTE *src, ERRBUF *cur_err,
    ERRBUF *nxt_err, UINT x, UINT xl, UINT y)
{
    UINT *row = Get555HalftoneRow(y);

    for (; x < xl; src += 3, x++)
    {
        register WORD wColor;
        register BYTE *tbl;
        register int r;
        register int g;
        register int b;

        r = Clamp8((int)src[0] + cur_err->r / 16);
        g = Clamp8((int)src[1] + cur_err->g / 16);
        b = Clamp8((int)src[2] + cur_err->b / 16);
        cur_err++;

        tbl = Get555HalftoneTable(row, x);
        wColor = (*dst++ = rgb555(tbl[r], tbl[g], tbl[b]));

        b -= (int)aRound5to8[wColor & 0x1f];
        (nxt_err+1)->b += b * 1;
        (nxt_err-1)->b += b * 3;
        (nxt_err  )->b += b * 5;
        (cur_err  )->b += b * 7;

        g -= (int)aRound5to8[(wColor >> 5) & 0x1f];
        (nxt_err+1)->g += g * 1;
        (nxt_err-1)->g += g * 3;
        (nxt_err  )->g += g * 5;
        (cur_err  )->g += g * 7;

        r -= (int)aRound5to8[(wColor >> 10) & 0x1f];
        (nxt_err+1)->r += r * 1;
        (nxt_err-1)->r += r * 3;
        (nxt_err  )->r += r * 5;
        (cur_err  )->r += r * 7;

        nxt_err++;
    }
}

void Dith24rto15(WORD *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT cx,
    UINT y, int cy)
{
    int dy;

    cx += x;

    if (cy < 0)
    {
        dy = -1;
        cy *= -1;
    }
    else
        dy = 1;

    if (y & 1)
        SwapError(&cur_err, &nxt_err);

    while (cy)
    {
        DithScan24rto15(dst, src, cur_err, nxt_err, x, cx, y);

        ZeroError(cur_err, cx);
        SwapError(&cur_err, &nxt_err);

        *(BYTE **)&src += src_next_scan;
        *(BYTE **)&dst += dst_next_scan;
        y += dy;
        cy--;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// Dith24rto16()                                         24bpp to 16bpp dither.
//
// Computes the 24bpp source color by combining the source pixel's color with
// accumulated error for the pixel.  THE SOURCE COMPONENT ORDER IS OPPOSITE A DIB:
// RED, GREEN, BLUE.  Halftones this 24bpp value to a 16bpp 565 color.  Remaps this 
// color to 24bpp to compute and accumulates error for neighboring pixels.
//
///////////////////////////////////////////////////////////////////////////////

INLINE void DithScan24rto16(WORD *dst, const BYTE *src, ERRBUF *cur_err,
    ERRBUF *nxt_err, UINT x, UINT xl, UINT y)
{
    UINT *row = Get555HalftoneRow(y);

    for (; x < xl; src += 3, x++)
    {
        register WORD wColor;
        register BYTE *tbl;
        register int r;
        register int g;
        register int b;

        r = Clamp8((int)src[0] + cur_err->r / 16);
        g = Clamp8((int)src[1] + cur_err->g / 16);
        b = Clamp8((int)src[2] + cur_err->b / 16);
        cur_err++;

        tbl = Get555HalftoneTable(row, x);
        wColor = (*dst++ = rgb565(tbl[r], tbl[g], tbl[b]));

        b -= (int)aRound5to8[wColor & 0x1f];
        (nxt_err+1)->b += b * 1;
        (nxt_err-1)->b += b * 3;
        (nxt_err  )->b += b * 5;
        (cur_err  )->b += b * 7;

        g -= (int)aRound5to8[(wColor >> 6) & 0x1f];
        (nxt_err+1)->g += g * 1;
        (nxt_err-1)->g += g * 3;
        (nxt_err  )->g += g * 5;
        (cur_err  )->g += g * 7;

        r -= (int)aRound5to8[(wColor >> 11) & 0x1f];
        (nxt_err+1)->r += r * 1;
        (nxt_err-1)->r += r * 3;
        (nxt_err  )->r += r * 5;
        (cur_err  )->r += r * 7;

        nxt_err++;
    }
}

void Dith24rto16(WORD *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT cx,
    UINT y, int cy)
{
    int dy;

    cx += x;

    if (cy < 0)
    {
        dy = -1;
        cy *= -1;
    }
    else
        dy = 1;

    if (y & 1)
        SwapError(&cur_err, &nxt_err);

    while (cy)
    {
        DithScan24rto16(dst, src, cur_err, nxt_err, x, cx, y);

        ZeroError(cur_err, cx);
        SwapError(&cur_err, &nxt_err);

        *(BYTE **)&src += src_next_scan;
        *(BYTE **)&dst += dst_next_scan;
        y += dy;
        cy--;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// Convert24rto16()                                         24bpp to 16bpp translation.
//
// Converts 24bpp source color to 16bpp (565) format by mapping each component
// to the closest value in 565 space.  THE SOURCE COMPONENT ORDER IS OPPOSITE A DIB:
// RED, GREEN, BLUE. 
//
///////////////////////////////////////////////////////////////////////////////

void Convert24rto16(WORD *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, UINT x, UINT cx, UINT y, int cy)
{
    int dy;

    cx += x;

    if (cy < 0)
    {
        dy = -1;
        cy *= -1;
    }
    else
        dy = 1;

    while (cy)
    {
        WORD *pdst;
        const BYTE *psrc;
        UINT xt;

        pdst = dst;
        psrc = src;
        for (xt = x; xt < cx; psrc += 3, xt++)
        {
            *pdst++ = (WORD)((((WORD)aRound8to5[psrc[0]] << 6) | (WORD)aRound8to6[psrc[1]]) << 5) | (WORD)aRound8to5[psrc[2]];
        }
        
        *(BYTE **)&src += src_next_scan;
        *(BYTE **)&dst += dst_next_scan;
        y += dy;
        cy--;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// Convert24rto15()                                         24bpp to 15bpp translation.
//
// Converts 24bpp source color to 15bpp (555) format by mapping each component
// to the closest value in 555 space.  THE SOURCE COMPONENT ORDER IS OPPOSITE A DIB:
// RED, GREEN, BLUE. 
//
///////////////////////////////////////////////////////////////////////////////

void Convert24rto15(WORD *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, UINT x, UINT cx, UINT y, int cy)
{
    int dy;

    cx += x;

    if (cy < 0)
    {
        dy = -1;
        cy *= -1;
    }
    else
        dy = 1;

    while (cy)
    {
        WORD *pdst;
        const BYTE *psrc;
        UINT xt;

        pdst = dst;
        psrc = src;
        for (xt = x; xt < cx; psrc += 3, xt++)
        {
#ifdef _MAC
            WORD    wVal;
            
            wVal = (WORD)((((WORD)aRound8to5[psrc[0]] << 5) | (WORD)aRound8to5[psrc[1]]) << 5) | (WORD)aRound8to5[psrc[2]];
            *pdst++ = (wVal << 8) | (wVal >> 8);
#else
            *pdst++ = (WORD)((((WORD)aRound8to5[psrc[0]] << 5) | (WORD)aRound8to5[psrc[1]]) << 5) | (WORD)aRound8to5[psrc[2]];
#endif
        }
        
        *(BYTE **)&src += src_next_scan;
        *(BYTE **)&dst += dst_next_scan;
        y += dy;
        cy--;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// Dith24to8()                                            24bpp to 8bpp dither.
//
// Computes the 24bpp source color by combining the source pixel's color with
// accumulated error for the pixel.  Halftones this 24bpp value to a 16bpp 555
// color.  Uses the 16bpp color as a lookup into an inverse mapping table to
// pick the output color for the pixel.  Uses the destination color table entry
// to compute and accumulates error for neighboring pixels.
//
///////////////////////////////////////////////////////////////////////////////

INLINE void DithScan24to8(BYTE *dst, const BYTE *src, const RGBQUAD *colors,
    const BYTE *map, ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT xl, UINT y)
{
    UINT *row = Get555HalftoneRow(y);

    for (; x < xl; src += 3, x++)
    {
        register const RGBQUAD *pChosen;
        register BYTE *tbl;
        register int r;
        register int g;
        register int b;

        r = Clamp8((int)src[2] + cur_err->r / 16);
        g = Clamp8((int)src[1] + cur_err->g / 16);
        b = Clamp8((int)src[0] + cur_err->b / 16);
        cur_err++;

        tbl = Get555HalftoneTable(row, x);
        pChosen = colors + (*dst++ = map[rgb555(tbl[r], tbl[g], tbl[b])]);

        r -= (int)pChosen->rgbRed;
        (nxt_err+1)->r += r * 1;
        (nxt_err-1)->r += r * 3;
        (nxt_err  )->r += r * 5;
        (cur_err  )->r += r * 7;

        g -= (int)pChosen->rgbGreen;
        (nxt_err+1)->g += g * 1;
        (nxt_err-1)->g += g * 3;
        (nxt_err  )->g += g * 5;
        (cur_err  )->g += g * 7;

        b -= (int)pChosen->rgbBlue;
        (nxt_err+1)->b += b * 1;
        (nxt_err-1)->b += b * 3;
        (nxt_err  )->b += b * 5;
        (cur_err  )->b += b * 7;

        nxt_err++;
    }
}

void Dith24to8(BYTE *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, const RGBQUAD *colors, const BYTE *map, ERRBUF *cur_err,
    ERRBUF *nxt_err, UINT x, UINT cx, UINT y, int cy)
{
    int dy;

    cx += x;

    if (cy < 0)
    {
        dy = -1;
        cy *= -1;
    }
    else
        dy = 1;

    if (y & 1)
        SwapError(&cur_err, &nxt_err);

    while (cy)
    {
        DithScan24to8(dst, src, colors, map, cur_err, nxt_err, x, cx, y);

        ZeroError(cur_err, cx);
        SwapError(&cur_err, &nxt_err);

        *(BYTE **)&src += src_next_scan;
        *(BYTE **)&dst += dst_next_scan;
        y += dy;
        cy--;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// Dith24rto8()                                            24bpp to 8bpp dither.
//
// Computes the 24bpp source color by combining the source pixel's color with
// accumulated error for the pixel.  Halftones this 24bpp value to a 16bpp 555
// color.  Uses the 16bpp color as a lookup into an inverse mapping table to
// pick the output color for the pixel.  Uses the destination color table entry
// to compute and accumulates error for neighboring pixels.
//
///////////////////////////////////////////////////////////////////////////////

INLINE void DithScan24rto8(BYTE *dst, const BYTE *src, const RGBQUAD *colors,
    const BYTE *map, ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT xl, UINT y)
{
    UINT *row = Get555HalftoneRow(y);

    for (; x < xl; src += 3, x++)
    {
        register const RGBQUAD *pChosen;
        register BYTE *tbl;
        register int r;
        register int g;
        register int b;

        r = Clamp8((int)src[0] + cur_err->r / 16);
        g = Clamp8((int)src[1] + cur_err->g / 16);
        b = Clamp8((int)src[2] + cur_err->b / 16);

        cur_err++;

        tbl = Get555HalftoneTable(row, x);
        pChosen = colors + (*dst++ = map[rgb555(tbl[r], tbl[g], tbl[b])]);

        r -= (int)pChosen->rgbRed;
        (nxt_err+1)->r += r * 1;
        (nxt_err-1)->r += r * 3;
        (nxt_err  )->r += r * 5;
        (cur_err  )->r += r * 7;

        g -= (int)pChosen->rgbGreen;
        (nxt_err+1)->g += g * 1;
        (nxt_err-1)->g += g * 3;
        (nxt_err  )->g += g * 5;
        (cur_err  )->g += g * 7;

        b -= (int)pChosen->rgbBlue;
        (nxt_err+1)->b += b * 1;
        (nxt_err-1)->b += b * 3;
        (nxt_err  )->b += b * 5;
        (cur_err  )->b += b * 7;

        nxt_err++;
    }
}

void Dith24rto8(BYTE *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, const RGBQUAD *colors, const BYTE *map, ERRBUF *cur_err,
    ERRBUF *nxt_err, UINT x, UINT cx, UINT y, int cy)
{
    int dy;

    cx += x;

    if (cy < 0)
    {
        dy = -1;
        cy *= -1;
    }
    else
        dy = 1;

    if (y & 1)
        SwapError(&cur_err, &nxt_err);

    while (cy)
    {
        DithScan24rto8(dst, src, colors, map, cur_err, nxt_err, x, cx, y);

        ZeroError(cur_err, cx);
        SwapError(&cur_err, &nxt_err);

        *(BYTE **)&src += src_next_scan;
        *(BYTE **)&dst += dst_next_scan;
        y += dy;
        cy--;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// Dith15to8()                                            16bpp to 8bpp dither.
//
// Uses the 16bpp color as a lookup into an inverse mapping table to
// pick the output color for the pixel.  Uses the destination color table entry
// to compute and accumulates error for neighboring pixels.
//
///////////////////////////////////////////////////////////////////////////////

INLINE void DithScan15to8(BYTE *dst, const WORD *src, const RGBQUAD *colors,
    const BYTE *map, ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT xl, UINT y)
{
    UINT *row = Get555HalftoneRow(y);

    for (; x < xl; ++src, x++)
    {
        register const RGBQUAD *pChosen;
        register BYTE *tbl;
        register int r;
        register int g;
        register int b;

        r = Clamp8((int)aRound5to8[(*src >> 10) & 0x1F] + cur_err->r / 16);
        g = Clamp8((int)aRound5to8[(*src >> 5) & 0x1F] + cur_err->g / 16);
        b = Clamp8((int)aRound5to8[*src & 0x1F] + cur_err->b / 16);
        cur_err++;

        tbl = Get555HalftoneTable(row, x);
        pChosen = colors + (*dst++ = map[rgb555(tbl[r], tbl[g], tbl[b])]);

        r -= (int)pChosen->rgbRed;
        (nxt_err+1)->r += r * 1;
        (nxt_err-1)->r += r * 3;
        (nxt_err  )->r += r * 5;
        (cur_err  )->r += r * 7;

        g -= (int)pChosen->rgbGreen;
        (nxt_err+1)->g += g * 1;
        (nxt_err-1)->g += g * 3;
        (nxt_err  )->g += g * 5;
        (cur_err  )->g += g * 7;

        b -= (int)pChosen->rgbBlue;
        (nxt_err+1)->b += b * 1;
        (nxt_err-1)->b += b * 3;
        (nxt_err  )->b += b * 5;
        (cur_err  )->b += b * 7;

        nxt_err++;
    }
}

void Dith15to8(BYTE *dst, const WORD *src, int dst_next_scan,
    int src_next_scan, const RGBQUAD *colors, const BYTE *map, ERRBUF *cur_err,
    ERRBUF *nxt_err, UINT x, UINT cx, UINT y, int cy)
{
    int dy;

    cx += x;

    if (cy < 0)
    {
        dy = -1;
        cy *= -1;
    }
    else
        dy = 1;

    if (y & 1)
        SwapError(&cur_err, &nxt_err);

    while (cy)
    {
        DithScan15to8(dst, src, colors, map, cur_err, nxt_err, x, cx, y);

        ZeroError(cur_err, cx);
        SwapError(&cur_err, &nxt_err);

        *(BYTE **)&src += src_next_scan;
        *(BYTE **)&dst += dst_next_scan;
        y += dy;
        cy--;
    }
}


///////////////////////////////////////////////////////////////////////////////
//
// Dith16to8()                                            16bpp to 8bpp dither.
//
// Uses the 16bpp color as a lookup into an inverse mapping table to
// pick the output color for the pixel.  Uses the destination color table entry
// to compute and accumulates error for neighboring pixels.
//
///////////////////////////////////////////////////////////////////////////////

INLINE void DithScan16to8(BYTE *dst, const WORD *src, const RGBQUAD *colors,
    const BYTE *map, ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT xl, UINT y)
{
    UINT *row = Get555HalftoneRow(y);

    for (; x < xl; ++src, x++)
    {
        register const RGBQUAD *pChosen;
        register BYTE *tbl;
        register int r;
        register int g;
        register int b;

        r = Clamp8((int)aRound5to8[(*src >> 11) & 0x1F] + cur_err->r / 16);
        g = Clamp8((int)aRound5to8[(*src >> 6) & 0x1F] + cur_err->g / 16);
        b = Clamp8((int)aRound5to8[*src & 0x1F] + cur_err->b / 16);
        cur_err++;

        tbl = Get555HalftoneTable(row, x);
        pChosen = colors + (*dst++ = map[rgb555(tbl[r], tbl[g], tbl[b])]);

        r -= (int)pChosen->rgbRed;
        (nxt_err+1)->r += r * 1;
        (nxt_err-1)->r += r * 3;
        (nxt_err  )->r += r * 5;
        (cur_err  )->r += r * 7;

        g -= (int)pChosen->rgbGreen;
        (nxt_err+1)->g += g * 1;
        (nxt_err-1)->g += g * 3;
        (nxt_err  )->g += g * 5;
        (cur_err  )->g += g * 7;

        b -= (int)pChosen->rgbBlue;
        (nxt_err+1)->b += b * 1;
        (nxt_err-1)->b += b * 3;
        (nxt_err  )->b += b * 5;
        (cur_err  )->b += b * 7;

        nxt_err++;
    }
}

void Dith16to8(BYTE *dst, const WORD *src, int dst_next_scan,
    int src_next_scan, const RGBQUAD *colors, const BYTE *map, ERRBUF *cur_err,
    ERRBUF *nxt_err, UINT x, UINT cx, UINT y, int cy)
{
    int dy;

    cx += x;

    if (cy < 0)
    {
        dy = -1;
        cy *= -1;
    }
    else
        dy = 1;

    if (y & 1)
        SwapError(&cur_err, &nxt_err);

    while (cy)
    {
        DithScan16to8(dst, src, colors, map, cur_err, nxt_err, x, cx, y);

        ZeroError(cur_err, cx);
        SwapError(&cur_err, &nxt_err);

        *(BYTE **)&src += src_next_scan;
        *(BYTE **)&dst += dst_next_scan;
        y += dy;
        cy--;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// Dith8to8()                                              8bpp to 8bpp dither.
//
// Computes the 24bpp source color by combining the source pixel's color table
// entry with accumulated error for the pixel.  Halftones this 24bpp value to a
// 16bpp 555 color.  Uses the 16bpp color as a lookup into an inverse mapping
// table to pick the output color for the pixel.  Uses the destination color
// table entry to compute and accumulates error for neighboring pixels.
//
///////////////////////////////////////////////////////////////////////////////

INLINE void DithScan8to8(BYTE *dst, const BYTE *src, const RGBQUAD *colorsIN,
    const RGBQUAD *colorsOUT, const BYTE *map, ERRBUF *cur_err,
    ERRBUF *nxt_err, UINT x, UINT xl, UINT y)
{
    UINT *row = Get555HalftoneRow(y);

    for (; x < xl; src++, x++)
    {
        register const RGBQUAD *pChosen;
        register BYTE *tbl;
        register int r;
        register int g;
        register int b;

        pChosen = colorsIN + *src;

        r = Clamp8((int)pChosen->rgbRed   + (cur_err->r >> 4));
        g = Clamp8((int)pChosen->rgbGreen + (cur_err->g >> 4));
        b = Clamp8((int)pChosen->rgbBlue  + (cur_err->b >> 4));
        cur_err++;

        tbl = Get555HalftoneTable(row, x);
        pChosen = colorsOUT + (*dst++ = map[rgb555(tbl[r], tbl[g], tbl[b])]);

        r -= (int)pChosen->rgbRed;
        (nxt_err+1)->r += r * 1;
        (nxt_err-1)->r += r * 3;
        (nxt_err  )->r += r * 5;
        (cur_err  )->r += r * 7;

        g -= (int)pChosen->rgbGreen;
        (nxt_err+1)->g += g * 1;
        (nxt_err-1)->g += g * 3;
        (nxt_err  )->g += g * 5;
        (cur_err  )->g += g * 7;

        b -= (int)pChosen->rgbBlue;
        (nxt_err+1)->b += b * 1;
        (nxt_err-1)->b += b * 3;
        (nxt_err  )->b += b * 5;
        (cur_err  )->b += b * 7;

        nxt_err++;
    }
}

void Dith8to8(BYTE *dst, const BYTE *src, int dst_next_scan, int src_next_scan,
    const RGBQUAD *colorsIN, const RGBQUAD *colorsOUT, const BYTE *map,
    ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT cx, UINT y, int cy)
{
    int dy;

    cx += x;

    if (cy < 0)
    {
        dy = -1;
        cy *= -1;
    }
    else
        dy = 1;

    if (y & 1)
        SwapError(&cur_err, &nxt_err);

    while (cy)
    {
        DithScan8to8(dst, src, colorsIN, colorsOUT, map, cur_err, nxt_err,
            x, cx, y);

        ZeroError(cur_err, cx);
        SwapError(&cur_err, &nxt_err);

        *(BYTE **)&src += src_next_scan;
        *(BYTE **)&dst += dst_next_scan;
        y += dy;
        cy--;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// Dith8to8t()                           8bpp to 8bpp dither with transparency.
//
// If the source pixel is the given source transparency color, this routine
// picks the destination transparency color for output and zero error is
// accumulated to the pixel's neighbors.
// Otherwise, this routine functions identically to Dith8to8.
//
///////////////////////////////////////////////////////////////////////////////

INLINE void DithScan8to8t(BYTE *dst, const BYTE *src,
    const RGBQUAD *colorsIN, const RGBQUAD *colorsOUT, const BYTE *map,
    ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT xl, UINT y,
    BYTE indexTxpOUT, BYTE indexTxpIN)
{
    UINT *row = Get555HalftoneRow(y);

    for (; x < xl; src++, x++)
    {
        register const RGBQUAD *pChosen;
        register BYTE *tbl;
        register BYTE index;
        register int r;
        register int g;
        register int b;

        index = *src;
        if (index == indexTxpIN)
        {
            *dst++ = indexTxpOUT;
            cur_err++;
            nxt_err++;
            continue;
        }

        pChosen = colorsIN + index;
        r = Clamp8((int)pChosen->rgbRed   + (cur_err->r >> 4));
        g = Clamp8((int)pChosen->rgbGreen + (cur_err->g >> 4));
        b = Clamp8((int)pChosen->rgbBlue  + (cur_err->b >> 4));
        cur_err++;

        tbl = Get555HalftoneTable(row, x);
        pChosen = colorsOUT + (*dst++ = map[rgb555(tbl[r], tbl[g], tbl[b])]);

        r -= (int)pChosen->rgbRed;
        (nxt_err+1)->r += r * 1;
        (nxt_err-1)->r += r * 3;
        (nxt_err  )->r += r * 5;
        (cur_err  )->r += r * 7;

        g -= (int)pChosen->rgbGreen;
        (nxt_err+1)->g += g * 1;
        (nxt_err-1)->g += g * 3;
        (nxt_err  )->g += g * 5;
        (cur_err  )->g += g * 7;

        b -= (int)pChosen->rgbBlue;
        (nxt_err+1)->b += b * 1;
        (nxt_err-1)->b += b * 3;
        (nxt_err  )->b += b * 5;
        (cur_err  )->b += b * 7;

        nxt_err++;
    }
}

void Dith8to8t(BYTE *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, const RGBQUAD *colorsIN, const RGBQUAD *colorsOUT,
    const BYTE *map, ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT cx, UINT y,
    int cy, BYTE indexTxpOUT, BYTE indexTxpIN)
{
    int dy;

    cx += x;

    if (cy < 0)
    {
        dy = -1;
        cy *= -1;
    }
    else
        dy = 1;

    if (y & 1)
        SwapError(&cur_err, &nxt_err);

    while (cy)
    {
        DithScan8to8t(dst, src, colorsIN, colorsOUT, map, cur_err, nxt_err,
            x, cx, y, indexTxpOUT, indexTxpIN);

        ZeroError(cur_err, cx);
        SwapError(&cur_err, &nxt_err);

        *(BYTE **)&src += src_next_scan;
        *(BYTE **)&dst += dst_next_scan;
        y += dy;
        cy--;
    }
}

INLINE void DithScanGray8to8( BYTE* pbDest, const BYTE* pbSrc,
   const RGBQUAD* prgbColors, const BYTE* pbMap, ERRBUF* pCurrentError,
   ERRBUF* pNextError, UINT x, UINT xl, UINT y )
{
   BYTE bSrc;
   BYTE bDest;
    UINT* pRow = Get555HalftoneRow( y );

    for(; x < xl; pbSrc++, x++ )
    {
        const RGBQUAD* prgbChosen;
        BYTE* pbTable;
        int r;
        int g;
        int b;

        bSrc = *pbSrc;
        r = Clamp8( (int)bSrc + pCurrentError->r/16 );
        g= Clamp8( (int)bSrc + pCurrentError->g/16 );
        b = Clamp8( (int)bSrc + pCurrentError->b/16 );
        pCurrentError++;

        pbTable = Get555HalftoneTable( pRow, x );
        bDest = pbMap[rgb555( pbTable[r], pbTable[g], pbTable[b] )];
         prgbChosen = prgbColors+bDest;
         *pbDest = bDest;
         pbDest++;

        r -= (int)prgbChosen->rgbRed;
        (pNextError+1)->r += r * 1;
        (pNextError-1)->r += r * 3;
        (pNextError)->r += r * 5;
        (pCurrentError)->r += r * 7;

        g -= (int)prgbChosen->rgbGreen;
        (pNextError+1)->g += g * 1;
        (pNextError-1)->g += g * 3;
        (pNextError)->g += g * 5;
        (pCurrentError)->g += g * 7;

        b -= (int)prgbChosen->rgbBlue;
        (pNextError+1)->b += b * 1;
        (pNextError-1)->b += b * 3;
        (pNextError)->b += b * 5;
        (pCurrentError)->b += b * 7;

        pNextError++;
    }
}

void DithGray8to8( BYTE* pbDest, const BYTE* pbSrc, int nDestPitch, 
   int nSrcPitch, const RGBQUAD* prgbColors, const BYTE* pbMap, 
   ERRBUF* pCurrentError, ERRBUF* pNextError, UINT x, UINT cx, UINT y, int cy )
{
    int dy;

    cx += x;

    if (cy < 0)
    {
        dy = -1;
        cy *= -1;
    }
    else
    {
        dy = 1;
    }

    if (y & 1)
    {
        SwapError( &pCurrentError, &pNextError );
    }
    while (cy)
    {
        DithScanGray8to8( pbDest, pbSrc, prgbColors, pbMap, pCurrentError, 
           pNextError, x, cx, y );

        ZeroError( pCurrentError, cx );
        SwapError( &pCurrentError, &pNextError );

        *(BYTE **)&pbSrc += nSrcPitch;
        *(BYTE **)&pbDest += nDestPitch;
        y += dy;
        cy--;
    }
}

INLINE void DithScanGray8to16( WORD* dst, const BYTE* src,
   ERRBUF* cur_err, ERRBUF* nxt_err, UINT x, UINT xl, UINT y )
{
    UINT *row = Get555HalftoneRow(y);

    for (; x < xl; ++src, x++)
    {
        register WORD wColor;
        register BYTE *tbl;
        register int r;
        register int g;
        register int b;
        int bSrc;

        bSrc = (int)*src;
        r = Clamp8(bSrc + cur_err->r / 16);
        g = Clamp8(bSrc + cur_err->g / 16);
        b = Clamp8(bSrc + cur_err->b / 16);
        cur_err++;

        tbl = Get555HalftoneTable(row, x);
        wColor = (*dst++ = rgb565(tbl[r], tbl[g], tbl[b]));

        b -= (int)aRound5to8[wColor & 0x1f];
        (nxt_err+1)->b += b * 1;
        (nxt_err-1)->b += b * 3;
        (nxt_err  )->b += b * 5;
        (cur_err  )->b += b * 7;

        g -= (int)aRound5to8[(wColor >> 6) & 0x1f];
        (nxt_err+1)->g += g * 1;
        (nxt_err-1)->g += g * 3;
        (nxt_err  )->g += g * 5;
        (cur_err  )->g += g * 7;

        r -= (int)aRound5to8[(wColor >> 11) & 0x1f];
        (nxt_err+1)->r += r * 1;
        (nxt_err-1)->r += r * 3;
        (nxt_err  )->r += r * 5;
        (cur_err  )->r += r * 7;

        nxt_err++;
    }
}

void DithGray8to16( WORD* pbDest, const BYTE* pbSrc, int nDestPitch, 
   int nSrcPitch, ERRBUF* pCurrentError, ERRBUF* pNextError, UINT x, 
   UINT cx, UINT y, int cy )
{
    int dy;

    cx += x;

    if (cy < 0)
    {
        dy = -1;
        cy *= -1;
    }
    else
    {
        dy = 1;
    }

    if (y & 1)
    {
        SwapError( &pCurrentError, &pNextError );
    }
    while (cy)
    {
        DithScanGray8to16( pbDest, pbSrc, pCurrentError, pNextError, x, cx, y );

        ZeroError( pCurrentError, cx );
        SwapError( &pCurrentError, &pNextError );

        *(BYTE **)&pbSrc += nSrcPitch;
        *(BYTE **)&pbDest += nDestPitch;
        y += dy;
        cy--;
    }
}

INLINE void DithScanGray8to15( WORD* dst, const BYTE* src,
   ERRBUF* cur_err, ERRBUF* nxt_err, UINT x, UINT xl, UINT y )
{
    UINT *row = Get555HalftoneRow(y);

    for (; x < xl; ++src, x++)
    {
        register WORD wColor;
        register BYTE *tbl;
        register int r;
        register int g;
        register int b;
        int bSrc;

        bSrc = (int)*src;
        r = Clamp8(bSrc + cur_err->r / 16);
        g = Clamp8(bSrc + cur_err->g / 16);
        b = Clamp8(bSrc + cur_err->b / 16);
        cur_err++;

        tbl = Get555HalftoneTable(row, x);
        wColor = (*dst++ = rgb555(tbl[r], tbl[g], tbl[b]));

        b -= (int)aRound5to8[wColor & 0x1f];
        (nxt_err+1)->b += b * 1;
        (nxt_err-1)->b += b * 3;
        (nxt_err  )->b += b * 5;
        (cur_err  )->b += b * 7;

        g -= (int)aRound5to8[(wColor >> 5) & 0x1f];
        (nxt_err+1)->g += g * 1;
        (nxt_err-1)->g += g * 3;
        (nxt_err  )->g += g * 5;
        (cur_err  )->g += g * 7;

        r -= (int)aRound5to8[(wColor >> 10) & 0x1f];
        (nxt_err+1)->r += r * 1;
        (nxt_err-1)->r += r * 3;
        (nxt_err  )->r += r * 5;
        (cur_err  )->r += r * 7;

        nxt_err++;
    }
}

void DithGray8to15( WORD* pbDest, const BYTE* pbSrc, int nDestPitch, 
   int nSrcPitch, ERRBUF* pCurrentError, ERRBUF* pNextError, UINT x, 
   UINT cx, UINT y, int cy )
{
    int dy;

    cx += x;

    if (cy < 0)
    {
        dy = -1;
        cy *= -1;
    }
    else
    {
        dy = 1;
    }

    if (y & 1)
    {
        SwapError( &pCurrentError, &pNextError );
    }
    while (cy)
    {
        DithScanGray8to15( pbDest, pbSrc, pCurrentError, pNextError, x, cx, y );

        ZeroError( pCurrentError, cx );
        SwapError( &pCurrentError, &pNextError );

        *(BYTE **)&pbSrc += nSrcPitch;
        *(BYTE **)&pbDest += nDestPitch;
        y += dy;
        cy--;
    }
}

#ifdef UNIX
INLINE void DithScanGray8to1( BYTE* pbDest, const BYTE* pbSrc,
   ERRBUF* pCurrentError, ERRBUF* pNextError, UINT x, UINT xl, UINT y )
{
    BYTE bSrc;
    BYTE bDest;
    register BYTE byOut = 0;

    for(; x < xl; pbSrc++, x++ )
    {
        int r;
        int g;
        int b;
        int v;

        bSrc = *pbSrc;
        r = Clamp8( (int)bSrc + pCurrentError->r/16 );
        g = Clamp8( (int)bSrc + pCurrentError->g/16 );
        b = Clamp8( (int)bSrc + pCurrentError->b/16 );
        v = (r * 30 + g * 59 + b * 11) / 100;
        v = (v > 127) ? 255 : 0;
        pCurrentError++;

        byOut = (byOut << 1) | (v & 1);
        if ((x & 7) == 7)
        {
            *pbDest++ = byOut;
            byOut = 0;
        }
        
        r -= v;
        (pNextError+1)->r += r;
        (pNextError-1)->r += r * 3;
        (pNextError)->r += r * 5;
        (pCurrentError)->r += r * 7;

        g -= v;
        (pNextError+1)->g += g;
        (pNextError-1)->g += g * 3;
        (pNextError)->g += g * 5;
        (pCurrentError)->g += g * 7;

        b -= v;
        (pNextError+1)->b += b;
        (pNextError-1)->b += b * 3;
        (pNextError)->b += b * 5;
        (pCurrentError)->b += b * 7;

        pNextError++;
    }

    if (x & 7)
    {
        *pbDest++ = byOut << (8 - (x & 7));
    }
    
}

void DithGray8to1( BYTE* pbDest, const BYTE* pbSrc, int nDestPitch, 
   int nSrcPitch, ERRBUF* pCurrentError, ERRBUF* pNextError, 
   UINT x, UINT cx, UINT y, int cy )
{
    int dy;

    cx += x;

    if (cy < 0)
    {
        dy = -1;
        cy *= -1;
    }
    else
    {
        dy = 1;
    }

    if (y & 1)
    {
        SwapError( &pCurrentError, &pNextError );
    }
    while (cy)
    {
        DithScanGray8to1( pbDest, pbSrc, pCurrentError, pNextError, x, cx, y );

        ZeroError( pCurrentError, cx );
        SwapError( &pCurrentError, &pNextError );

        *(BYTE **)&pbSrc += nSrcPitch;
        *(BYTE **)&pbDest += nDestPitch;
        y += dy;
        cy--;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// Dith24rto1()                                            24bpp to 1bpp dither.
//
// Computes the 24bpp source color by combining the source pixel's color with
// accumulated error for the pixel.  Halftones this 24bpp value to a monochrome
// color.  Uses threshold of 128 to determine the output color for the pixel.  
// Uses the destination color to compute and accumulates error for neighboring 
// pixels.
//
///////////////////////////////////////////////////////////////////////////////

INLINE void DithScan24rto1(BYTE *dst, const BYTE *src, ERRBUF *cur_err, ERRBUF *nxt_err, UINT x, UINT xl, UINT y)
{
    register BYTE byOut = 0;

    for (; x < xl; src += 3, x++)
    {
        register int r;
        register int g;
        register int b;
        register int v;

        r = Clamp8((int)src[0] + cur_err->r / 16);
        g = Clamp8((int)src[1] + cur_err->g / 16);
        b = Clamp8((int)src[2] + cur_err->b / 16);
        v = (r * 30 + g * 59 + b * 11) / 100;
        v = (v > 127) ? 255 : 0;
        cur_err++;

        byOut = (byOut << 1) | (v & 1);
        if ((x & 7) == 7)
        {
            *dst++ = byOut;
            byOut = 0;
        }

        r -= v;
        (nxt_err+1)->r += r;
        (nxt_err-1)->r += r * 3;
        (nxt_err  )->r += r * 5;
        (cur_err  )->r += r * 7;

        g -= v;
        (nxt_err+1)->g += g;
        (nxt_err-1)->g += g * 3;
        (nxt_err  )->g += g * 5;
        (cur_err  )->g += g * 7;

        b -= v;
        (nxt_err+1)->b += b;
        (nxt_err-1)->b += b * 3;
        (nxt_err  )->b += b * 5;
        (cur_err  )->b += b * 7;

        nxt_err++;
    }

    if (x & 7)
    {
        *dst++ = byOut << (8 - (x & 7));
    }
}

void Dith24rto1(BYTE *dst, const BYTE *src, int dst_next_scan,
    int src_next_scan, ERRBUF *cur_err, ERRBUF *nxt_err, 
    UINT x, UINT cx, UINT y, int cy)
{
    int dy;

    cx += x;

    if (cy < 0)
    {
        dy = -1;
        cy *= -1;
    }
    else
        dy = 1;

    if (y & 1)
        SwapError(&cur_err, &nxt_err);

    while (cy)
    {
        DithScan24rto1(dst, src, cur_err, nxt_err, x, cx, y);

        ZeroError(cur_err, cx);
        SwapError(&cur_err, &nxt_err);

        *(BYTE **)&src += src_next_scan;
        *(BYTE **)&dst += dst_next_scan;
        y += dy;
        cy--;
    }
}
#endif

#ifndef WIN16

class CIntDitherer : public IIntDitherer
{
public:

    DECLARE_MEMALLOC_NEW_DELETE(Mt(CIntDitherer))

    CIntDitherer();
    
    // IUnknown members

    STDMETHOD(QueryInterface)(REFIID, void **);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

    // IIntDitherer members
    
    STDMETHOD(DitherTo8bpp)( BYTE * pDestBits, LONG nDestPitch, 
                    BYTE * pSrcBits, LONG nSrcPitch, REFGUID bfidSrc, 
                    RGBQUAD * prgbDestColors, RGBQUAD * prgbSrcColors,
                    BYTE * pbDestInvMap,
                    LONG x, LONG y, LONG cx, LONG cy,
                    LONG lDestTrans, LONG lSrcTrans);

public:
    ULONG   m_cRef;
};

CIntDitherer::CIntDitherer()
{
    m_cRef = 1;
}

STDMETHODIMP
CIntDitherer::QueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IIntDitherer || riid == IID_IUnknown)
    {
        *ppv = (IUnknown *)this;
        ((LPUNKNOWN)*ppv)->AddRef();
        return(S_OK);
    }
    else
    {
        *ppv = NULL;
        return(E_NOINTERFACE);
    }
}

STDMETHODIMP_(ULONG)
CIntDitherer::AddRef()
{
    return(++m_cRef);
}

STDMETHODIMP_(ULONG)
CIntDitherer::Release()
{
    --m_cRef;
    if (m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

HRESULT CIntDitherer::DitherTo8bpp(  BYTE * pDestBits, LONG nDestPitch, 
                    BYTE * pSrcBits, LONG nSrcPitch, REFGUID bfidSrc, 
                    RGBQUAD * prgbDestColors, RGBQUAD * prgbSrcColors,
                    BYTE * pbDestInvMap,
                    LONG x, LONG y, LONG cx, LONG cy,
                    LONG lDestTrans, LONG lSrcTrans)
{
    return DitherTo8(pDestBits, nDestPitch, pSrcBits, nSrcPitch, bfidSrc, 
                    prgbDestColors, prgbSrcColors, pbDestInvMap,
                    x, y, cx, cy, lDestTrans, lSrcTrans);
}
#endif // ndef WIN16

HRESULT DitherTo8(  BYTE * pDestBits, LONG nDestPitch, 
                    BYTE * pSrcBits, LONG nSrcPitch, REFGUID bfidSrc, 
                    RGBQUAD * prgbDestColors, RGBQUAD * prgbSrcColors,
                    BYTE * pbDestInvMap,
                    LONG x, LONG y, LONG cx, LONG cy,
                    LONG lDestTrans, LONG lSrcTrans)
{
    ERRBUF* m_pErrBuf1;
    ERRBUF* m_pErrBuf2;

    HRESULT hr;

    hr = AllocDitherBuffers(cx, &m_pErrBuf1, &m_pErrBuf2);
    if (FAILED(hr))
        return hr;
        
    if (bfidSrc == BFID_RGB_24)
    {
        Dith24to8( pDestBits, pSrcBits, nDestPitch, nSrcPitch, 
            prgbDestColors, pbDestInvMap, 
            m_pErrBuf1, m_pErrBuf2, x, cx, y, cy );
    }
    else if (bfidSrc == BFID_RGB_555)
    {
        Dith15to8( pDestBits, (WORD *)pSrcBits, nDestPitch, nSrcPitch,
            prgbDestColors, pbDestInvMap,
            m_pErrBuf1, m_pErrBuf2, x, cx, y, cy );
    }
    else if (bfidSrc == BFID_RGB_565)
    {
        Dith16to8( pDestBits, (WORD *)pSrcBits, nDestPitch, nSrcPitch,
            prgbDestColors, pbDestInvMap,
            m_pErrBuf1, m_pErrBuf2, x, cx, y, cy );
    }
    else if (bfidSrc == BFID_RGB_8)
    {
        if (lDestTrans == -1 || lSrcTrans == -1)
        {
            Dith8to8( pDestBits, pSrcBits, nDestPitch, nSrcPitch,
                prgbSrcColors, prgbDestColors, pbDestInvMap, 
                m_pErrBuf1, m_pErrBuf2, x, cx, y, cy );
        }
        else
        {
            Dith8to8t( pDestBits, pSrcBits, nDestPitch, nSrcPitch,
                prgbSrcColors, prgbDestColors, pbDestInvMap, 
                m_pErrBuf1, m_pErrBuf2, x, cx, y, cy, (BYTE)lDestTrans, (BYTE)lSrcTrans );
        }
    }
    else
    {
        hr = E_FAIL;
    }

    FreeDitherBuffers(m_pErrBuf1, m_pErrBuf2);
    
    return hr;
}

HRESULT AllocDitherBuffers(LONG cx, ERRBUF **ppBuf1, ERRBUF **ppBuf2)
{
    ERRBUF *pBuf;

    *ppBuf1 = *ppBuf2 = NULL;
    
    pBuf = (ERRBUF *)MemAllocClear(Mt(ImgDithBufs), (cx+2)*2*sizeof(ERRBUF));
    if (pBuf == NULL)
        return E_OUTOFMEMORY;

    *ppBuf1 = &pBuf[1];
    *ppBuf2 = &pBuf[cx+3];

    return S_OK;       
}

void FreeDitherBuffers(ERRBUF *pBuf1, ERRBUF *pBuf2)
{
    MemFree(&pBuf1[-1]);
}

HRESULT
CreateIIntDitherer(IUnknown * pUnkOuter, IUnknown **ppUnk)
{
    if (pUnkOuter != NULL)
    {
        *ppUnk = NULL;
        return(CLASS_E_NOAGGREGATION);
    }

    CIntDitherer * pDitherer = new CIntDitherer;

    *ppUnk = pDitherer;

    RRETURN(pDitherer ? S_OK : E_OUTOFMEMORY);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\download\dwnbind.cxx ===
//+ ---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       dwnbind.cxx
//
//  Contents:   CDwnPost, CDwnBind
//
// ----------------------------------------------------------------------------

#include "headers.hxx"

// This list needs to continue to be updated and we should try to keep parity with Office and shdocvw

const LPCTSTR c_arszUnsafeExts[]  =
{
    TEXT(".exe"), TEXT(".com"), TEXT(".bat"), TEXT(".lnk"), TEXT(".url"),
    TEXT(".cmd"), TEXT(".inf"), TEXT(".reg"), TEXT(".isp"), TEXT(".bas"), TEXT(".pcd"),
    TEXT(".mst"), TEXT(".pif"), TEXT(".scr"), TEXT(".hlp"), TEXT(".chm"), TEXT(".hta"), TEXT(".asp"), 
    TEXT(".js"),  TEXT(".jse"), TEXT(".vbs"), TEXT(".vbe"), TEXT(".ws"),  TEXT(".wsh"), TEXT(".msi"),
    TEXT(".ade"), TEXT(".adp"), TEXT(".crt"), TEXT(".ins"), TEXT(".mdb"),
    TEXT(".mde"), TEXT(".msc"), TEXT(".msp"), TEXT(".sct"), TEXT(".shb"),
    TEXT(".vb"),  TEXT(".wsc"), TEXT(".wsf"), TEXT(".cpl"), TEXT(".shs"),
    TEXT(".vsd"), TEXT(".vst"), TEXT(".vss"), TEXT(".vsw"), TEXT(".its"), TEXT(".tmp"),
    TEXT(".mdw"), TEXT(".mdt"), TEXT(".ops"), TEXT("")
};

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DWN_HXX_
#define X_DWN_HXX_
#include "dwn.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"
#endif

#ifndef X_INETREG_H_
#define X_INETREF_H_
#include <inetreg.h>
#endif

#ifndef X_WINNETWK_H_
#define X_WINNETWK_H_
#include <winnetwk.h>
#endif

#ifndef X_URLCOMP_HXX_
#define X_URLCOMP_HXX_
#include <urlcomp.hxx>
#endif

extern class CResProtocolCF g_cfResProtocol;
extern class CAboutProtocolCF g_cfAboutProtocol;
extern class CViewSourceProtocolCF g_cfViewSourceProtocol;

void IndicateWinsockActivity();
DWORD _GetErrorThreshold(DWORD dwError);
BOOL IsErrorHandled( DWORD dwError );
BOOL IsSpecialUrl(LPCTSTR pchUrl);   // TRUE for javascript, vbscript, about protocols

// Debugging ------------------------------------------------------------------

PerfDbgTag(tagDwnBindInfo,      "Dwn", "Trace CDwnBindInfo")
PerfDbgTag(tagDwnBindData,      "Dwn", "Trace CDwnBindData")
PerfDbgTag(tagDwnBindDataIO,    "Dwn", "Trace CDwnBindData Peek/Read")
PerfDbgTag(tagDwnBindSlow,      "Dwn", "! Don't use InternetSession")
PerfDbgTag(tagNoWriteCache,     "Dwn", "! Force BINDF_NOWRITECACHE")
PerfDbgTag(tagNoReadCache,      "Dwn", "! Force BINDF_GETNEWESTVERSION")
PerfDbgTag(tagPushData,         "Dwn", "! Force PUSHDATA");
DeclareTag(tagDwnBindTrace,     "Dwn", "Trace CDwnBindInfo refs (next instance)")
DeclareTag(tagDwnBindTraceAll,  "Dwn", "Trace CDwnBindInfo refs (all instances)")
DeclareTag(tagDwnBindBinds,     "Dwn", "Trace all calls to CDwnBindData::Bind")
DeclareTag(tagDwnBindPrivacy,   "Dwn", "Trace all privacy notifications and list additions")
MtDefine(CDwnBindInfo, Dwn, "CDwnBindInfo")
MtDefine(CDwnBindData, Dwn, "CDwnBindData")
MtDefine(CDwnBindData_pbPeek, CDwnBindData, "CDwnBindData::_pbPeek")
MtDefine(CDwnBindData_pbRawEcho, Dwn, "CDwnBindData::_pbRawEcho")
MtDefine(CDwnBindData_pSecConInfo, Dwn, "CDwnBindData::_pSecConInfo")
MtDefine(CDwnBindData_pchP3PHeader, Dwn, "CDwnBindData::_pchP3PHeader")

PerfDbgExtern(tagPerfWatch)
extern BOOL IsGlobalOffline();
extern BOOL g_fInIexplorer;
extern BOOL g_fDisableUnTrustedProtocol;


// Globals --------------------------------------------------------------------

CDwnBindInfo *      g_pDwnBindTrace = NULL;

#if DBG==1 || defined(PERFTAGS)
static char * const g_rgpchBindStatus[] = { "",
    "FINDINGRESOURCE","CONNECTING","REDIRECTING","BEGINDOWNLOADDATA",
    "DOWNLOADINGDATA","ENDDOWNLOADDATA","BEGINDOWNLOADCOMPONENTS",
    "INSTALLINGCOMPONENTS","ENDDOWNLOADCOMPONENTS","USINGCACHEDCOPY",
    "SENDINGREQUEST","CLASSIDAVAILABLE","MIMETYPEAVAILABLE",
    "CACHEFILENAMEAVAILABLE","BEGINSYNCOPERATION","ENDSYNCOPERATION",
    "BEGINUPLOADDATA","UPLOADINGDATA","ENDUPLOADDATA","PROTOCOLCLASSID",
    "ENCODING","VERIFIEDMIMETYPEAVAILABLE","CLASSINSTALLLOCATION",
    "DECODING","LOADINGMIMEHANDLER","CONTENTDISPOSITIONATTACH",
    "FILTERREPORTMIMETYPE","CLSIDCANINSTANTIATE","IUNKNOWNAVAILABLE",
    "DIRECTBIND","RAWMIMETYPE","PROXYDETECTING","ACCEPTRANGES",
    "COOKIE_SENT","COOKIE_RECEIVED","COOKIE_SUPPRESSED", 
    "COOKIE_STATE_UNKNOWN","COOKIE_STATE_ACCEPT","COOKIE_STATE_REJECT",
    "COOKIE_STATE_PROMPT","COOKIE_STATE_LEASH", "COOKIE_STATE_DOWNGRADE", 
    "POLICY_HREF", "P3P_HEADER", "SESSION_COOKIE_RECEIVED", 
    "PERSISTENT_COOKIE_RECEIVED", "SESSION_COOKIES_ALLOWED", "COMPACT_POLICY_RECEIVED",
    "?","?", "?","?","?","?", "?"
};
#endif

// Data for custom marshaling security
// We don't have to init this flag to FALSE because it is global data
// and global data is always init to null
BOOL                    CDwnBindInfo::_fSecretInit;
BYTE                    CDwnBindInfo::_SecretBlock[16];
CGlobalCriticalSection  CDwnBindInfo::_csSecretInit;


// Definitions ----------------------------------------------------------------

#define Align64(n)              (((n) + 63) & ~63)

#define ERRORPAGE_DNS               1
#define ERRORPAGE_SYNTAX            2
#define ERRORPAGE_NAVCANCEL         3
#define ERRORPAGE_OFFCANCEL         4
#define ERRORPAGE_CHANNELNOTINCACHE 5

BOOL IsDangerousChmMime(LPCTSTR pszURL)
{
    BOOL   fIsChime = FALSE;
    BOOL   fIsSafe  = TRUE;
    TCHAR* pch;

    if ((pszURL == NULL) || ((*pszURL) == NULL))
    {
        return FALSE;
    }

    //
    // Is this a chm file
    //

    pch = _tcschr(pszURL, _T('.'));

    while ((pch != NULL) && (!fIsChime))
    {
        if (_tcsncicmp,(pch,_TEXT(".chm"),4))
        {
            fIsChime = TRUE;
        }

        //
        // Even if we found the .chm we want to look
        // at the embedded extension.
        //
        pch++;
        pch = _tcschr(pch, _T('.'));
    }

    if (!fIsChime)
    {
        return FALSE;
    }

    while ((pch != NULL) && fIsSafe)
    {
        int i = 0;

        while (fIsSafe && (_tcslen(c_arszUnsafeExts[i])!= 0))
        {
            if (_tcsncicmp(pch,c_arszUnsafeExts[i],_tcslen(c_arszUnsafeExts[i])) == 0)
            {
                fIsSafe = FALSE;
            }

            i++;
        }

        pch++;
        pch = _tcschr(pch, _T('.'));
    }

    return !fIsSafe; 
}

BOOL IsDangerousProtoclAndChmMime(LPCTSTR pszURL)
{
    BOOL fDangerousProtocol = TRUE;
    BOOL fDangerousChm      = TRUE;

    UINT uProt = GetUrlScheme(pszURL);
    HRESULT hrParseUrl  = E_FAIL;
    LPTSTR  pTempBuffer = NULL;
    DWORD   nUrlLen = 0;
    
    pTempBuffer = new TCHAR [INTERNET_MAX_URL_LENGTH + 1];

    //
    //  Target specific dangerous protocols for now
    //

    if (URL_SCHEME_MK          == uProt || 
        URL_SCHEME_MSHELP      == uProt)             
    {
        fDangerousProtocol = TRUE;
    }
    else
    {  
        hrParseUrl = CoInternetParseUrl(pszURL,
                                        PARSE_SCHEMA,
                                        0,
                                        pTempBuffer,
                                        INTERNET_MAX_URL_LENGTH + 1,
                                        &nUrlLen,
                                        0);

        if (SUCCEEDED(hrParseUrl))
        {
            fDangerousProtocol = (_tcsicmp(pTempBuffer,_T("ms-its")) == 0)        ||
                                 (_tcsicmp(pTempBuffer,_T("ms-itss")) == 0)       ||
                                 (_tcsicmp(pTempBuffer,_T("its")) == 0)           ||
                                 (_tcsicmp(pTempBuffer,_T("mk:@msitstore")) == 0); 
        }
        else
        {
            fDangerousProtocol = FALSE;
        }
    }

    if (fDangerousProtocol)
    {
        fDangerousChm = IsDangerousChmMime(pszURL);
    }
    else
    {
        fDangerousChm = FALSE;
    }

    if (pTempBuffer)
    {
        delete[] pTempBuffer;
    }

    return fDangerousChm;
}

//
// NB - the table of errors that are handled is in shdocvw
// this needs to be kept in sync
//

// Utilities ------------------------------------------------------------------

BOOL GetFileLastModTime(TCHAR * pchFile, FILETIME * pftLastMod)
{
    WIN32_FIND_DATA fd;
    HANDLE hFF = FindFirstFile(pchFile, &fd);

    if (hFF != INVALID_HANDLE_VALUE)
    {
        *pftLastMod = fd.ftLastWriteTime;
        FindClose(hFF);
        return(TRUE);
    }

    return(FALSE);
}

BOOL GetUrlLastModTime(TCHAR * pchUrl, UINT uScheme, DWORD dwBindf, FILETIME * pftLastMod)
{
    BOOL    fRet = FALSE;
    HRESULT hr;

    Assert(uScheme == GetUrlScheme(pchUrl));

    if (uScheme == URL_SCHEME_FILE)
    {
        TCHAR achPath[MAX_PATH];
        DWORD cchPath;

        hr = THR(CoInternetParseUrl(pchUrl, PARSE_PATH_FROM_URL, 0,
                    achPath, ARRAY_SIZE(achPath), &cchPath, 0));

        if (hr == S_OK)
        {
            fRet = GetFileLastModTime(achPath, pftLastMod);
        }
    }
    else if (uScheme == URL_SCHEME_HTTP || uScheme == URL_SCHEME_HTTPS)
    {
        fRet = !IsUrlCacheEntryExpired(pchUrl, dwBindf & BINDF_FWD_BACK, pftLastMod)
               && pftLastMod->dwLowDateTime
               && pftLastMod->dwHighDateTime;
    }

    return(fRet);
}

// CDwnBindInfo ---------------------------------------------------------------

CDwnBindInfo::CDwnBindInfo()
{
    PerfDbgLog(tagDwnBindInfo, this, "CDwnBindInfo::CDwnBindInfo");

    #if DBG==1
    if (    (g_pDwnBindTrace == NULL && IsTagEnabled(tagDwnBindTrace))
        ||  IsTagEnabled(tagDwnBindTraceAll))
    {
        g_pDwnBindTrace = this;
        TraceTag((0, "DwnBindInfo [%lX] Construct %d", this, GetRefs()));
        TraceCallers(0, 1, 12);
    }
    #endif
}

CDwnBindInfo::~CDwnBindInfo()
{
    PerfDbgLog(tagDwnBindInfo, this, "+CDwnBindInfo::~CDwnBindInfo");

    #if DBG==1
    if (g_pDwnBindTrace == this || IsTagEnabled(tagDwnBindTraceAll))
    {
        g_pDwnBindTrace = NULL;
        TraceTag((0, "DwnBindInfo [%lX] Destruct", this));
        TraceCallers(0, 1, 12);
    }
    #endif

    if (_pDwnDoc)
        _pDwnDoc->Release();

    ReleaseInterface((IUnknown *)_pDwnPost);

    PerfDbgLog(tagDwnBindInfo, this, "-CDwnBindInfo::~CDwnBindInfo");
}

// CDwnBindInfo (IUnknown) --------------------------------------------------------

STDMETHODIMP
CDwnBindInfo::QueryInterface(REFIID iid, void **ppv)
{
    PerfDbgLog(tagDwnBindInfo, this, "CDwnBindInfo::QueryInterface");
    Assert(CheckThread());

    if (iid == IID_IUnknown || iid == IID_IBindStatusCallback)
        *ppv = (IBindStatusCallback *)this;
    else if (iid == IID_IServiceProvider)
        *ppv = (IServiceProvider *)this;
    else if (iid == IID_IHttpNegotiate)
        *ppv = (IHttpNegotiate *)this;
    else if (iid == IID_IHttpNegotiate2)
        *ppv = (IHttpNegotiate2 *)this;
    else if (iid == IID_IMarshal)
        *ppv = (IMarshal *)this;
    else if (iid == IID_IInternetBindInfo)
        *ppv = (IInternetBindInfo *)this;
    else if (iid == IID_IDwnBindInfo)
    {
        *ppv = this;
        AddRef();
        return(S_OK);
    }
    else
    {
        *ppv = NULL;
        return(E_NOINTERFACE);
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG)
CDwnBindInfo::AddRef()
{
    ULONG ulRefs = super::AddRef();

    #if DBG==1
    if (this == g_pDwnBindTrace || IsTagEnabled(tagDwnBindTraceAll))
    {
        TraceTag((0, "[%lX] DwnBindInfo %lX AR  %ld",
            GetCurrentThreadId(), this, ulRefs));
        TraceCallers(0, 1, 12);
    }
    #endif

    PerfDbgLog1(tagDwnBindInfo, this, "CDwnBindInfo::AddRef (cRefs=%ld)",
        ulRefs);

    return(ulRefs);
}

STDMETHODIMP_(ULONG)
CDwnBindInfo::Release()
{
    PerfDbgLog(tagDwnBindInfo, this, "+CDwnBindInfo::Release");

    ULONG ulRefs = super::Release();

    #if DBG==1
    if (this == g_pDwnBindTrace || IsTagEnabled(tagDwnBindTraceAll))
    {
        TraceTag((0, "[%lX] DwnBindInfo %lX Rel %ld",
            GetCurrentThreadId(), this, ulRefs));
        TraceCallers(0, 1, 12);
    }
    #endif

    PerfDbgLog1(tagDwnBindInfo, this, "-CDwnBindInfo::Release (cRefs=%ld)",
        ulRefs);

    return(ulRefs);
}

void
CDwnBindInfo::SetDwnDoc(CDwnDoc * pDwnDoc)
{
    if (_pDwnDoc)
        _pDwnDoc->Release();

    _pDwnDoc = pDwnDoc;

    if (_pDwnDoc)
        _pDwnDoc->AddRef();
}

void
CDwnBindInfo::SetDwnPost(CDwnPost * pDwnPost)
{
    if (_pDwnPost)
        _pDwnPost->Release();

    _pDwnPost = pDwnPost;

    if (_pDwnPost)
        _pDwnPost->AddRef();
}

UINT
CDwnBindInfo::GetScheme()
{
    return(URL_SCHEME_UNKNOWN);
}

// CDwnBindInfo (IBindStatusCallback) -----------------------------------------

STDMETHODIMP
CDwnBindInfo::OnStartBinding(DWORD grfBSCOption, IBinding *pbinding)
{
    PerfDbgLog(tagDwnBindInfo, this, "CDwnBindInfo::OnStartBinding");
    Assert(CheckThread());
    return(S_OK);
}

STDMETHODIMP
CDwnBindInfo::GetPriority(LONG *pnPriority)
{
    PerfDbgLog(tagDwnBindInfo, this, "CDwnBindInfo::GetPriority");
    Assert(CheckThread());
    *pnPriority = NORMAL_PRIORITY_CLASS;
    return(S_OK);
}

STDMETHODIMP
CDwnBindInfo::OnLowResource(DWORD dwReserved)
{
    PerfDbgLog(tagDwnBindInfo, this, "CDwnBindInfo::OnLowResource");
    Assert(CheckThread());
    return(S_OK);
}

STDMETHODIMP
CDwnBindInfo::OnProgress(ULONG ulPos, ULONG ulMax, ULONG ulCode,
    LPCWSTR pszText)
{
    PerfDbgLog(tagDwnBindInfo, this, "CDwnBindInfo::OnProgress");
    Assert(CheckThread());
  
    if (pszText && (ulCode == BINDSTATUS_MIMETYPEAVAILABLE || ulCode == BINDSTATUS_RAWMIMETYPE))
    {
        _cstrContentType.Set(pszText);
    }

    if (pszText && (ulCode == BINDSTATUS_CACHEFILENAMEAVAILABLE))
    {
        _cstrCacheFilename.Set(pszText);
    }

    return(S_OK);
}

STDMETHODIMP
CDwnBindInfo::OnStopBinding(HRESULT hrReason, LPCWSTR szReason)
{
    PerfDbgLog(tagDwnBindInfo, this, "CDwnBindInfo::OnStopBinding");
    Assert(CheckThread());
    return(S_OK);
}

STDMETHODIMP
CDwnBindInfo::GetBindInfo(DWORD * pdwBindf, BINDINFO * pbindinfo)
{
    PerfDbgLog(tagDwnBindInfo, this, "+CDwnBindInfo::GetBindInfo");
    Assert(CheckThread());

    HRESULT hr;

    if (pbindinfo->cbSize != sizeof(BINDINFO))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    memset(pbindinfo, 0, sizeof(BINDINFO));

    pbindinfo->cbSize = sizeof(BINDINFO);

    *pdwBindf = BINDF_ASYNCHRONOUS|BINDF_ASYNCSTORAGE|BINDF_PULLDATA;

    if (_pDwnDoc)
    {
        if (_fIsDocBind)
        {
            *pdwBindf |= _pDwnDoc->GetDocBindf();
            pbindinfo->dwCodePage = _pDwnDoc->GetURLCodePage();
        }
        else
        {
            *pdwBindf |= _pDwnDoc->GetBindf();
            pbindinfo->dwCodePage = _pDwnDoc->GetDocCodePage();
        }

        if (_pDwnDoc->GetLoadf() & DLCTL_URL_ENCODING_DISABLE_UTF8)
            pbindinfo->dwOptions = BINDINFO_OPTIONS_DISABLE_UTF8;
        else if (_pDwnDoc->GetLoadf() & DLCTL_URL_ENCODING_ENABLE_UTF8)
            pbindinfo->dwOptions = BINDINFO_OPTIONS_ENABLE_UTF8;
        else 
            pbindinfo->dwOptions = BINDINFO_OPTIONS_USE_IE_ENCODING;
    }

#ifdef WINCE	// WINCEREVIEW - temp until we have caching support
	*pdwBindf |= BINDF_GETNEWESTVERSION | BINDF_NOWRITECACHE;
#endif // WINCE

    #if DBG==1 || defined(PERFTAGS)
    if (IsPerfDbgEnabled(tagNoWriteCache))
        *pdwBindf |= BINDF_NOWRITECACHE;
    if (IsPerfDbgEnabled(tagNoReadCache))
        *pdwBindf |= BINDF_GETNEWESTVERSION;
    if (IsPerfDbgEnabled(tagPushData))
        *pdwBindf &= ~BINDF_PULLDATA;
    #endif

    if (_pDwnPost)
    {
        hr = THR(_pDwnPost->GetBindInfo(pbindinfo));
        if (hr)
            goto Cleanup;

        // If local cache is not demanded,
        // Then require POSTs to go all the way to the originating server
        if (!(*pdwBindf & BINDF_OFFLINEOPERATION))
        {
            *pdwBindf |= BINDF_GETNEWESTVERSION | BINDF_PRAGMA_NO_CACHE;
            *pdwBindf &= ~BINDF_RESYNCHRONIZE;
        }

        pbindinfo->dwBindVerb = BINDVERB_POST;
    }
    else
    {
        // If a GET method for a form, always hit the server
        if (!(*pdwBindf & BINDF_OFFLINEOPERATION) && (*pdwBindf & BINDF_FORMS_SUBMIT))
        {
            *pdwBindf &= ~(BINDF_GETNEWESTVERSION | BINDF_PRAGMA_NO_CACHE);
            *pdwBindf |= BINDF_RESYNCHRONIZE;
        }
        pbindinfo->dwBindVerb = BINDVERB_GET;
    }


    if (_fIsOfflineBind)
    {
        *pdwBindf &= ~(BINDF_GETNEWESTVERSION | BINDF_PRAGMA_NO_CACHE | BINDF_RESYNCHRONIZE);
        // NB (JHarding): What we really want to say here is
        // "I know you've downloaded this before, and I want the same bits, no
        //  matter what the server may have said about caches or expiration"
        // But URLMON can't do that right now.
        // *pdwBindf |= BINDF_OFFLINEOPERATION;
    }

    // If us-ascii (20127) encoding is used and it's not available on the system,
    // MLang uses 1252 during conversion to Unicode. But it cannot convert
    // from Unicode to 20127. So callers of GetBindInfo may fail to do conversion.
    // In this case pretend using 1252.
    if (   pbindinfo->dwCodePage == CP_20127
        && !IsValidCodePage(CP_20127)
       )
    {
        pbindinfo->dwCodePage = CP_1252;
    }

    hr = S_OK;

Cleanup:
    PerfDbgLog1(tagDwnBindInfo, this, "-CDwnBindInfo::GetBindInfo (hr=%lX)", hr);
    RRETURN(hr);
}

STDMETHODIMP
CDwnBindInfo::OnDataAvailable(DWORD grfBSCF, DWORD dwSize,
    FORMATETC * pformatetc, STGMEDIUM * pstgmed)
{
    PerfDbgLog(tagDwnBindInfo, this, "CDwnBindInfo::OnDataAvailable");
    Assert(CheckThread());
    return(S_OK);
}

STDMETHODIMP
CDwnBindInfo::OnObjectAvailable(REFIID riid, IUnknown *punk)
{
    PerfDbgLog(tagDwnBindInfo, this, "CDwnBindInfo::OnObjectAvailable");
    Assert(CheckThread());
    return(S_OK);
}

// CDwnBindInfo (IInternetBindInfo) -------------------------------------------

STDMETHODIMP
CDwnBindInfo::GetBindString(ULONG ulStringType, LPOLESTR * ppwzStr,
    ULONG cEl, ULONG * pcElFetched)
{
    PerfDbgLog1(tagDwnBindData, this, "+CDwnBindData::GetBindString %s",
        ulStringType == BINDSTRING_URL              ? "URL" :
        ulStringType == BINDSTRING_HEADERS          ? "HEADERS" :
        ulStringType == BINDSTRING_ACCEPT_MIMES     ? "ACCEPT_MIMES" :
        ulStringType == BINDSTRING_EXTRA_URL        ? "EXTRA_URL" :
        ulStringType == BINDSTRING_LANGUAGE         ? "LANGUAGE" :
        ulStringType == BINDSTRING_USERNAME         ? "USERNAME" :
        ulStringType == BINDSTRING_PASSWORD         ? "PASSWORD" :
        ulStringType == BINDSTRING_UA_PIXELS        ? "UA_PIXELS" :
        ulStringType == BINDSTRING_UA_COLOR         ? "UA_COLOR" :
        ulStringType == BINDSTRING_OS               ? "OS" :
        ulStringType == BINDSTRING_ACCEPT_ENCODINGS ? "ACCEPT_ENCODINGS" :
        ulStringType == BINDSTRING_POST_DATA_MIME   ? "POST_DATA_MIME" :
        "???");

    HRESULT hr = S_OK;

    *pcElFetched = 0;

    switch (ulStringType)
    {
        case BINDSTRING_URL:
            {
                if (cEl >= 1)
                {
                    LPOLESTR pwzURL = NULL;
                    pwzURL = (LPOLESTR)CoTaskMemAlloc( (_cstrUrl.Length()+1) *  sizeof(TCHAR));

                    if (!pwzURL)
                    {
                        hr = E_OUTOFMEMORY;
                        goto Cleanup;
                    }

                    memcpy(pwzURL, _cstrUrl, (_cstrUrl.Length() + 1) * sizeof(TCHAR));
                    *ppwzStr = pwzURL;
                    *pcElFetched = 1;
                }
            }
            break;
        case BINDSTRING_ACCEPT_MIMES:
            {
                if (cEl >= 1)
                {
                    ppwzStr[0] = (LPOLESTR)CoTaskMemAlloc(4 * sizeof(TCHAR));

                    if (ppwzStr[0] == 0)
                    {
                        hr = E_OUTOFMEMORY; 
                        goto Cleanup;
                    }

                    memcpy(ppwzStr[0], _T("*/*"), 4 * sizeof(TCHAR));
                    *pcElFetched = 1;
                }
            }
            break;

        case BINDSTRING_POST_COOKIE:
            {
                if (cEl >= 1 && _pDwnPost)
                {
                    hr = THR(_pDwnPost->GetHashString(&(ppwzStr[0])));

                    *pcElFetched = hr ? 0 : 1;
                }
            }
            break;

        case BINDSTRING_POST_DATA_MIME:
            {
                if (cEl >= 1 && _pDwnPost)
                {
                    LPCTSTR pcszEncoding = _pDwnPost->GetEncodingString();
                    
                    if (pcszEncoding)
                    {
                        DWORD   dwSize = sizeof(TCHAR) + 
                                    _tcslen(pcszEncoding) * sizeof(TCHAR);

                        ppwzStr[0] = (LPOLESTR)CoTaskMemAlloc(dwSize);
                        if (ppwzStr[0])
                        {
                            memcpy(ppwzStr[0], pcszEncoding, dwSize);
                            *pcElFetched = 1;
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }
                    else
                    {   // we don't know, use the default instead
                        hr = INET_E_USE_DEFAULT_SETTING;
                    }
                }

            }
            break;
    }

Cleanup:
    PerfDbgLog1(tagDwnBindData, this, "-CDwnBindData::GetBindString (hr=%lX)", hr);
    RRETURN(hr);
}

// CDwnBindInfo (IServiceProvider) --------------------------------------------

STDMETHODIMP
CDwnBindInfo::QueryService(REFGUID rguidService, REFIID riid, void ** ppvObj)
{
    PerfDbgLog(tagDwnBindInfo, this, "+CDwnBindInfo::QueryService");
    Assert(CheckThread());

    HRESULT hr;

    if (   rguidService == IID_IHttpNegotiate
        || rguidService == IID_IHttpNegotiate2)
    {
        hr = QueryInterface(riid, ppvObj);
    }
    else if (rguidService == IID_IInternetBindInfo)
    {
        hr = QueryInterface(riid, ppvObj);
    }
    else if (_pDwnDoc)
    {
        hr = _pDwnDoc->QueryService(IsBindOnApt(), rguidService, riid, ppvObj);
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }

    PerfDbgLog1(tagDwnBindInfo, this, "-CDwnBindInfo::QueryService (hr=%lX)", hr);
    RRETURN(hr);
}

// CDwnBindInfo (IHttpNegotiate) ----------------------------------------------

STDMETHODIMP
CDwnBindInfo::BeginningTransaction(LPCWSTR pszUrl, LPCWSTR pszHeaders,
    DWORD dwReserved, LPWSTR * ppszHeaders)
{
    PerfDbgLog1(tagDwnBindInfo, this, "+CDwnBindInfo::BeginningTransaction "
        "\"%ls\"", pszUrl ? pszUrl : g_Zero.ach);
    Assert(CheckThread());

    LPCTSTR     apch[16];
    UINT        acch[16];
    LPCTSTR *   ppch = apch;
    UINT *      pcch = acch;
    HRESULT     hr   = S_OK;

    _cstrUrl.Set(pszUrl);

    // If we have been told the exact http headers to use, use them now
    
    if (_fIsDocBind && _pDwnDoc && _pDwnDoc->GetRequestHeaders())
    {
        TCHAR *     pch;
        UINT        cch = _pDwnDoc->GetRequestHeadersLength();
        
        pch = (TCHAR *)CoTaskMemAlloc(cch * sizeof(TCHAR));

        if (pch == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        // note: we don't need to convert an extra zero terminator, so cch-1
        
        AnsiToWideTrivial((char *)_pDwnDoc->GetRequestHeaders(), pch, cch - 1);

        *ppszHeaders = pch;

        goto Cleanup;
    }
    
    // Otherwise, assemble the http headers
    
    *ppszHeaders = NULL;

    if (_pDwnDoc)
    {
        LPCTSTR pch;

        pch = _fIsDocBind ? _pDwnDoc->GetDocReferer() :
                _pDwnDoc->GetSubReferer();

        if (pch)
        {
            UINT uSchemeSrc;
            UINT uSchemeDst;

            if (_fIsDocBind)
                uSchemeSrc = _pDwnDoc->GetDocRefererScheme();
            else
                uSchemeSrc = _pDwnDoc->GetSubRefererScheme();

            uSchemeDst = GetScheme();

            if (uSchemeDst == URL_SCHEME_UNKNOWN && pszUrl)
                uSchemeDst = GetUrlScheme(pszUrl);

            // Only send the referer through the same protocol with the exception
            // of https protocol receiving the http referer information.
            if (uSchemeSrc == uSchemeDst || 
                (uSchemeDst == URL_SCHEME_HTTPS && uSchemeSrc == URL_SCHEME_HTTP))
            {
                UINT    cch = _tcslen(pch);
                UINT    ich = 0;

                *ppch++ = _T("Referer: ");
                *pcch++ = 9;
                *ppch++ = pch;

                for (; ich < cch; ++ich, ++pch)
                {
                    if (*pch == ':')
                    {
                        // Skip past all slashes to find the beginning of the host

                        for (++ich, ++pch; ich < cch; ++ich, ++pch)
                        {
                            if (*pch != '/')
                                break;
                        }
                        break;
                    }
                }

                *pcch++ = ich;

                if (ich < cch)
                {
                    for (; ich < cch; ++ich, ++pch)
                    {
                        if (*pch == '@')
                        {
                            *ppch++ = pch + 1;
                            *pcch++ = cch - ich - 1;
                            goto zapped;
                        }
                        else if (*pch == '/')
                            break;
                    }

                    // No username or password, so just change the last
                    // fragment to include the entire string.

                    pcch[-1] = cch;
                }
                
            zapped:

                *ppch++ = _T("\r\n");
                *pcch++ = 2;
            }
        }

        pch = _pDwnDoc->GetAcceptLanguage();

        if (pch)
        {
            *ppch++ = _T("Accept-Language: ");
            *pcch++ = 17;
            *ppch++ = pch;
            *pcch++ = _tcslen(pch);
            *ppch++ = _T("\r\n");
            *pcch++ = 2;
        }

        pch = _pDwnDoc->GetExtraHeaders();
        if (pch)
        {
            *ppch++ = pch;
            *pcch++ = _tcslen(pch);
            *ppch++ = _T("\r\n");
            *pcch++ = 2;
        }

        pch = _pDwnDoc->GetUserAgent();

        if (pch)
        {
            *ppch++ = _T("User-Agent: ");
            *pcch++ = 12;
            *ppch++ = pch;
            *pcch++ = _tcslen(pch);
            *ppch++ = _T("\r\n");
            *pcch++ = 2;
        }
    }

    if (_pDwnPost)
    {
        LPCTSTR pchEncoding = _pDwnPost->GetEncodingString();

        if (pchEncoding)
        {
            *ppch++ = _T("Content-Type: ");
            *pcch++ = 14;
            *ppch++ = pchEncoding;
            *pcch++ = _tcslen(pchEncoding);
            *ppch++ = _T("\r\n");
            *pcch++ = 2;
        }
        // KB: If we can't determine the Content-Type, we should not submit
        // anything thereby allowing the server to sniff the incoming data
        // and make its own determination.
    }

    if (ppch > apch)
    {
        LPCTSTR *   ppchEnd = ppch;
        TCHAR *     pch;
        UINT        cch = 0;

        for (; ppch > apch; --ppch)
            cch += *--pcch;

        pch = (TCHAR *)CoTaskMemAlloc((cch + 1) * sizeof(TCHAR));

        if (pch == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        *ppszHeaders = pch;

        for (; ppch < ppchEnd; pch += *pcch++, ppch++)
        {
            memcpy(pch, *ppch, *pcch * sizeof(TCHAR));
        }

        *pch = 0;

        Assert((UINT)(pch - *ppszHeaders) == cch);
    }

Cleanup:
    PerfDbgLog1(tagDwnBindInfo, this, "-CDwnBindInfo::BeginningTransaction (hr=%lX)", hr);
    RRETURN(hr);
}

STDMETHODIMP
CDwnBindInfo::OnResponse(DWORD dwResponseCode, LPCWSTR szResponseHeaders,
    LPCWSTR szRequestHeaders, LPWSTR * ppszAdditionalRequestHeaders)
{
    PerfDbgLog(tagDwnBindInfo, this, "+CDwnBindInfo::OnResponse");
    Assert(CheckThread());
    PerfDbgLog(tagDwnBindInfo, this, "-CDwnBindInfo::OnResponse (hr=0)");
    return(S_OK);
}

// CDwnBindInfo (IHttpNegotiate2) ----------------------------------------------

STDMETHODIMP
CDwnBindInfo::GetRootSecurityId( BYTE       * pbSecurityId, 
                                 DWORD      * pcbSecurityId, 
                                 DWORD_PTR    dwReserved)
{
    HRESULT hr = E_FAIL;

    PerfDbgLog(tagDwnBindInfo, this, "+CDwnBindInfo::GetRootSecurityId");
    Assert(CheckThread());

    if (_pDwnDoc && !_fIsRootMarkup)
    {
        hr = _pDwnDoc->GetSecurityID(pbSecurityId, pcbSecurityId);
    }

    PerfDbgLog1(tagDwnBindInfo, this, "-CDwnBindInfo::GetRootSecurityId (hr=%lX)", hr);
    RRETURN(hr);
}


// CDwnBindInfo (IMarshal) --------------------------------------------------------

// SECURITY NOTE: (jbeda 2/28/2002)
// Any data coming into an unmarshal call should be considered completely 
// untrusted.  This means that all buffers should be validated.  
//
// In the case when we are doing a free threaded marshal type trick we have
// to take extra precautions.  Specifically if we are just pushing pointers
// around in memory because we know that we are in proc we want to pass a secret
// key along with those pointers.  The code for doing this is very similar to
// the code implemented in the FTM itself.  Refer to this source file:
//  nt\com\ole32\com\dcomrem\ipmrshl.cxx 

STDMETHODIMP
CDwnBindInfo::GetUnmarshalClass(REFIID riid, void *pvInterface,
    DWORD dwDestContext, void * pvDestContext, DWORD mshlflags, CLSID * pclsid)
{
    PerfDbgLog(tagDwnBindInfo, this, "CDwnBindInfo::GetUnmarshalClass");
    HRESULT hr;

    hr = ValidateMarshalParams(riid, pvInterface, dwDestContext,
            pvDestContext, mshlflags);

    if (hr == S_OK)
    {
        *pclsid = CLSID_CDwnBindInfo;
    }

    RRETURN(hr);
}

STDMETHODIMP
CDwnBindInfo::GetMarshalSizeMax(REFIID riid, void * pvInterface,
    DWORD dwDestContext, void *pvDestContext, DWORD mshlflags, DWORD * pdwSize)
{
    PerfDbgLog(tagDwnBindInfo, this, "CDwnBindInfo::GetMarshalSizeMax");
    HRESULT hr;

    hr = ValidateMarshalParams(riid, pvInterface, dwDestContext,
            pvDestContext, mshlflags);

    if (hr == S_OK)
    {
        *pdwSize = sizeof(BYTE) +                       // fByRef
            ((dwDestContext == MSHCTX_INPROC) ?
                sizeof(CDwnBindInfo *)                  // _pDwnBindInfo
                + sizeof(_SecretBlock)                  // secret block 
                :                
                CDwnDoc::GetSaveSize(_pDwnDoc)          // _pDwnDoc
                + CDwnPost::GetSaveSize(_pDwnPost));    // _pDwnPost
    }
    else
    {
        *pdwSize = 0;
    }

    RRETURN(hr);
}

STDMETHODIMP
CDwnBindInfo::MarshalInterface(IStream * pstm, REFIID riid,
    void *pvInterface, DWORD dwDestContext,
    void *pvDestContext, DWORD mshlflags)
{
    PerfDbgLog(tagDwnBindInfo, this, "CDwnBindInfo::MarshalInterface");
    BYTE fByRef = (dwDestContext == MSHCTX_INPROC);
    HRESULT hr;

    hr = ValidateMarshalParams(riid, pvInterface, dwDestContext,
            pvDestContext, mshlflags);

    if (hr == S_OK)
        hr = pstm->Write(&fByRef, sizeof(BYTE), NULL);
    if (hr == S_OK)
    {
        if (fByRef)
        {
            CDwnBindInfo * pDwnBindInfo = this;

            // Write the secret to the stream
            hr = EnsureSecret();
            if (SUCCEEDED(hr))
            {
                hr = pstm->Write(_SecretBlock, sizeof(_SecretBlock), NULL);
                if (hr == S_OK)
                {
                    hr = pstm->Write(&pDwnBindInfo, sizeof(CDwnBindInfo *), NULL);
                    if (hr == S_OK)
                        pDwnBindInfo->AddRef();
                }
            }
        }
        else
        {
            hr = CDwnDoc::Save(_pDwnDoc, pstm);
            if (hr == S_OK)
                hr = CDwnPost::Save(_pDwnPost, pstm);
         }
    }

    RRETURN(hr);
}

STDMETHODIMP
CDwnBindInfo::UnmarshalInterface(IStream * pstm, REFIID riid, void ** ppvObj)
{
    PerfDbgLog(tagDwnBindInfo, this, "CDwnBindInfo::UnmarshalInterface");
    BYTE fByRef = FALSE;
    HRESULT hr;

    *ppvObj = NULL;

    hr = CanMarshalIID(riid) ? S_OK : E_NOINTERFACE;
    if (hr == S_OK)
        hr = pstm->Read(&fByRef, sizeof(BYTE), NULL);
    if (hr == S_OK)
    {
        CDwnBindInfo * pDwnBindInfo = NULL;

        if (fByRef)
        {
            BYTE  secret[sizeof(_SecretBlock)];

            // Our secret should have been initialized by now
            if (!_fSecretInit)
                hr = E_UNEXPECTED;

            if (SUCCEEDED(hr))
            {
                  ULONG cbSize = 0;

                  hr = pstm->Read(secret, sizeof(secret), &cbSize);
                  if (SUCCEEDED(hr))
                  {
                      if (   cbSize != sizeof(secret) 
                          || memcmp(secret, _SecretBlock, sizeof(secret)) != 0)
                      {
                          hr = E_UNEXPECTED;
                      }
                  }
                  
            }

            if (SUCCEEDED(hr))
            {
                hr = pstm->Read(&pDwnBindInfo, sizeof(CDwnBindInfo *), NULL);
            }
        }
        else
        {
            hr = CDwnDoc::Load(pstm, &_pDwnDoc);
            if (hr == S_OK)
                hr = CDwnPost::Load(pstm, &_pDwnPost);

            pDwnBindInfo = this;
            pDwnBindInfo->AddRef();
        }

        if (hr == S_OK)
        {
            hr = pDwnBindInfo->QueryInterface(riid, ppvObj);
            pDwnBindInfo->Release();
        }
    }

    RRETURN(hr);
}

STDMETHODIMP
CDwnBindInfo::ReleaseMarshalData(IStream * pstm)
{
    PerfDbgLog(tagDwnBindInfo, this, "CDwnBindInfo::ReleaseMarshalData");
    return(S_OK);
}

STDMETHODIMP
CDwnBindInfo::DisconnectObject(DWORD dwReserved)
{
    PerfDbgLog(tagDwnBindInfo, this, "CDwnBindInfo::DisconnectObject");
    return(S_OK);
}

BOOL
CDwnBindInfo::CanMarshalIID(REFIID riid)
{
    return(riid == IID_IUnknown
        || riid == IID_IBindStatusCallback
        || riid == IID_IServiceProvider
        || riid == IID_IHttpNegotiate
        || riid == IID_IHttpNegotiate2);
}

HRESULT
CDwnBindInfo::ValidateMarshalParams(REFIID riid, void *pvInterface,
    DWORD dwDestContext, void *pvDestContext, DWORD mshlflags)
{
    HRESULT hr = S_OK;
 
    if (!CanMarshalIID(riid))
        hr = E_NOINTERFACE;
    else if (   (   dwDestContext != MSHCTX_INPROC
                &&  dwDestContext != MSHCTX_LOCAL
                &&  dwDestContext != MSHCTX_NOSHAREDMEM)
            || (    mshlflags != MSHLFLAGS_NORMAL
                &&  mshlflags != MSHLFLAGS_TABLESTRONG))
        hr = E_INVALIDARG;
    else
        hr = S_OK;

    RRETURN(hr);
}

HRESULT 
CDwnBindInfo::EnsureSecret()
{
    HRESULT hr = S_OK;

    if (!_fSecretInit)
    {
        LOCK_SECTION(_csSecretInit);
        
        if (!_fSecretInit)
        {
            // The easy way to get mostly random bits
            // (Random for all but 3 bytes)
            hr = CoCreateGuid((GUID *)_SecretBlock);
            if (SUCCEEDED(hr))
            {
                _fSecretInit = TRUE;        
            }
        }
    }

    return hr;
}

// CDwnBindInfo (Internal) ----------------------------------------------------

HRESULT
CreateDwnBindInfo(IUnknown *pUnkOuter, IUnknown **ppUnk)
{
    PerfDbgLog(tagDwnBindInfo, NULL, "CreateDwnBindInfo");

    *ppUnk = NULL;

    if (pUnkOuter != NULL)
        RRETURN(CLASS_E_NOAGGREGATION);

    CDwnBindInfo * pDwnBindInfo = new CDwnBindInfo;

    if (pDwnBindInfo == NULL)
        RRETURN(E_OUTOFMEMORY);

    *ppUnk = (IBindStatusCallback *)pDwnBindInfo;
    
    return(S_OK);
}

// CDwnBindData (IUnknown) ----------------------------------------------------

STDMETHODIMP
CDwnBindData::QueryInterface(REFIID iid, void **ppv)
{
    PerfDbgLog(tagDwnBindInfo, this, "CDwnBindData::QueryInterface");
    Assert(CheckThread());

    *ppv = NULL;

    if (iid == IID_IInternetBindInfo)
        *ppv = (IInternetBindInfo *)this;
    else if (iid == IID_IInternetProtocolSink)
        *ppv = (IInternetProtocolSink *)this;
    else
        return(super::QueryInterface(iid, ppv));

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG)
CDwnBindData::AddRef()
{
    return(super::AddRef());
}

STDMETHODIMP_(ULONG)
CDwnBindData::Release()
{
    return(super::Release());
}

// CDwnBindData (Internal) ----------------------------------------------------

CDwnBindData::~CDwnBindData()
{
    PerfDbgLog(tagDwnBindData, this, "+CDwnBindData::~CDwnBindData");

    Assert(!_fBindOnApt || _u.pts == NULL);

    if (_pDwnStm)
        _pDwnStm->Release();

    MemFree(_pbPeek);

    if (!_fBindOnApt && _o.pInetProt)
    {
        _o.pInetProt->Release();
    }

    if (_hLock)
    {
        InternetUnlockRequestFile(_hLock);
    }

    delete [] _pchP3PHeader;

    PerfDbgLog(tagDwnBindData, this, "-CDwnBindData::~CDwnBindData");
}

void
CDwnBindData::Passivate()
{

    MemFree( _pSecConInfo );
    _pSecConInfo = NULL;

    if (!_fBindTerm)
    {
        Terminate(E_ABORT);
    }

    super::Passivate();
}

void
CDwnBindData::Terminate(HRESULT hrErr)
{
    if (_fBindTerm)
        return;

    PerfDbgLog1(tagDwnBindData, this, "+CDwnBindData::Terminate (hrErr=%lX)", hrErr);

    BOOL fTerminate = FALSE;

    g_csDwnBindTerm.Enter();

    if (_fBindTerm)
        goto Cleanup;

    if (_hrErr == S_OK)
    {
        _hrErr = hrErr;
    }

    if (_fBindOnApt)
    {
        if (    !_u.pstm
            &&  !_u.punkForRel
            &&  !_u.pbc
            &&  !_u.pbinding
            &&  !_u.pts)
            goto Cleanup;

        if (_u.dwTid != GetCurrentThreadId())
        {
            if (!_u.pts || _u.fTermPosted)
                goto Cleanup;

            // We're not on the apartment thread, so we can't access
            // the objects we're binding right now.  Post a callback
            // on the apartment thread.

            PerfDbgLog(tagDwnBindData, this, "+CDwnBindData::Terminate "
                "GWPostMethodCall");

            // SubAddRef and set flags before posting the message to avoid race
            SubAddRef();
            _u.fTermPosted = TRUE;
            _u.fTermReceived = FALSE;

            HRESULT hr = GWPostMethodCallEx(_u.pts, this,
                ONCALL_METHOD(CDwnBindData, TerminateOnApt, terminateonapt), 0, FALSE, "CDwnBindData::TerminateOnApt");

            PerfDbgLog1(tagDwnBindData, this, "-CDwnBindData::Terminate "
                "GWPostMethodCall (hr=%lX)", hr);

            if (hr)
            {
            	_u.fTermReceived = TRUE;
                SubRelease();
            }

            goto Cleanup;
        }
    }

    fTerminate = TRUE;

Cleanup:
    g_csDwnBindTerm.Leave();

    if (fTerminate)
    {
        TerminateBind();
    }

    PerfDbgLog(tagDwnBindData, this, "-CDwnBindData::Terminate");
}

void BUGCALL
CDwnBindData::TerminateOnApt(DWORD_PTR dwContext)
{
    PerfDbgLog(tagDwnBindData, this, "+CDwnBindData::TerminateOnApt");

    Assert(!_u.fTermReceived);

    _u.fTermReceived = TRUE;
    TerminateBind();
    SubRelease();

    PerfDbgLog(tagDwnBindData, this, "-CDwnBindData::TerminateOnApt");
}

void
CDwnBindData::TerminateBind()
{
    PerfDbgLog(tagDwnBindData, this, "+CDwnBindData::TerminateBind");
    Assert(CheckThread());

    SubAddRef();

    g_csDwnBindTerm.Enter();

    if (_pDwnStm && !_pDwnStm->IsEofWritten())
        _pDwnStm->WriteEof(_hrErr);

    SetEof();

    if (_fBindOnApt)
    {
        IUnknown * punkRel1 = _u.pstm;
        IUnknown * punkRel2 = _u.punkForRel;
        IBindCtx * pbc      = NULL;
        IBinding * pbinding = NULL;
        BOOL       fDoAbort = FALSE;
        BOOL       fRelTls  = FALSE;

        _u.pstm             = NULL;
        _u.punkForRel       = NULL;

        if (_u.pts && _u.fTermPosted && !_u.fTermReceived)
        {
            // We've posted a method call to TerminateOnApt which hasn't been received
            // yet.  This happens if Terminate gets called on the apartment thread
            // before messages are pumped.  To keep reference counts happy, we need
            // to simulate the receipt of the method call here by first killing any
            // posted method call and then undoing the SubAddRef.

            GWKillMethodCallEx(_u.pts, this,
                  ONCALL_METHOD(CDwnBindData, TerminateOnApt, terminateonapt), 0);
                  
            // note: no danger of post/kill/set-flag race because
            // we're protected by g_csDwnBindTerm
            
            _u.fTermReceived = TRUE;
            SubRelease();
        }

        if (_fBindDone)
        {
            pbc         = _u.pbc;
            _u.pbc      = NULL;
            pbinding    = _u.pbinding;
            _u.pbinding = NULL;
            fRelTls     = !!_u.pts;
            _u.pts      = NULL;
            _fBindTerm  = TRUE;
        }
        else if (!_fBindAbort && _u.pbinding)
        {
            pbinding    = _u.pbinding;
            fDoAbort    = TRUE;
            _fBindAbort = TRUE;
        }

        g_csDwnBindTerm.Leave();

        ReleaseInterface(punkRel1);
        ReleaseInterface(punkRel2);

        if (fDoAbort)
        {
            PerfDbgLog(tagDwnBindData, this, "CDwnBindData::TerminateBind (Aborting IBinding)");
            pbinding->Abort();
        }
        else
        {
            PerfDbgLog(tagDwnBindData, this, "CDwnBindData::TerminateBind (Release IBinding)");
            ReleaseInterface(pbinding);
        }

        if (pbc)
        {
            PerfDbgLog(tagDwnBindData, this, "CDwnBindData::TerminateBind (Release IBindCtx)");
            IGNORE_HR(RevokeBindStatusCallback(pbc, this));
            ReleaseInterface(pbc);
        }

        if (fRelTls)
        {
            PerfDbgLog(tagDwnBindData, this, "CDwnBindData::TerminateBind (ReleaseThreadState)");
            ReleaseThreadState(&_u.dwObjCnt);
        }
    }
    else if (_o.pInetProt)
    {
        BOOL fDoTerm    = _fBindDone && !_fBindTerm;
        BOOL fDoAbort   = !_fBindDone && !_fBindAbort;

        if (_fBindDone)
            _fBindTerm = TRUE;
        else
            _fBindAbort = TRUE;

        g_csDwnBindTerm.Leave();

        if (fDoAbort)
        {
            PerfDbgLog(tagDwnBindData, this, "CDwnBindData::TerminateBind (Abort IInternetProtocol)");
            _o.pInetProt->Abort(E_ABORT, 0);
        }
        else if (fDoTerm)
        {
            PerfDbgLog(tagDwnBindData, this, "CDwnBindData::TerminateBind (Terminate IInternetProtocol)");
            _o.pInetProt->Terminate(0);
        }
    }
    else
    {
        _fBindTerm = TRUE;
        g_csDwnBindTerm.Leave();
    }

    SubRelease();

    PerfDbgLog(tagDwnBindData, this, "-CDwnBindData::TerminateBind");
}

void
CDwnBindData::AddToPrivacyList()
{
    if (_pDwnDoc)
    {
        g_csDwnDoc.Enter();

        CDoc *pDoc = _pDwnDoc->GetCDoc();
        if (pDoc && !pDoc->IsShut())
        {
            _dwPrivacyFlags |= (_fIsRootMarkup ? PRIVACY_URLISTOPLEVEL : 0);
            _dwPrivacyFlags |= (_pDwnPost ? PRIVACY_URLHASPOSTDATA : 0);
            THR(pDoc->AddToPrivacyList(_achUrl, _achPolicyRef, _dwPrivacyFlags, _fStartedInPending));
            TraceTag((tagDwnBindPrivacy, "Added to Privacy List - url %ls, policyRef %ls, privacyFlags %x", _achUrl, _achPolicyRef, _dwPrivacyFlags));
        }
        else
            TraceTag((tagDwnBindPrivacy, "Failed to add to Privacy List - could not get CDoc"));

        g_csDwnDoc.Leave();
    }
    else
        TraceTag((tagDwnBindPrivacy, "Failed to add to Privacy List - could not get CDwnDoc"));
}

HRESULT
CDwnBindData::SetBindOnApt()
{
    HRESULT hr;

    if (!(_dwFlags & DWNF_NOAUTOBUFFER))
    {
        _pDwnStm = new CDwnStm;

        if (_pDwnStm == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    hr = THR(AddRefThreadState(&_u.dwObjCnt));
    if (hr)
        goto Cleanup;

    _u.pts      = GetThreadState();
    _u.dwTid    = GetCurrentThreadId();
    _fBindDone  = TRUE;
    _fBindOnApt = TRUE;

Cleanup:
    RRETURN(hr);
}

#if DBG==1
BOOL
CDwnBindData::CheckThread()
{
    return(!_fBindOnApt || _u.dwTid == GetCurrentThreadId());
}
#endif

void
CDwnBindData::OnDwnDocCallback(void * pvArg)
{
    PerfDbgLog(tagDwnBindData, this, "+CDwnBindData::OnDwnDocCallback");

    Assert(!_fBindOnApt);

    if (_o.pInetProt)
    {
        HRESULT hr = THR(_o.pInetProt->Continue((PROTOCOLDATA *)pvArg));

        if (hr)
        {
            SignalDone(hr);
        }
    }

    PerfDbgLog(tagDwnBindData, this, "-CDwnBindData::OnDwnDocCallback");
}

void
CDwnBindData::SetEof()
{
    PerfDbgLog(tagDwnBindDataIO, this, "+CDwnBindData::SetEof");

    g_csDwnBindPend.Enter();

    _fPending = FALSE;
    _fEof = TRUE;

    g_csDwnBindPend.Leave();

    PerfDbgLog(tagDwnBindDataIO, this, "-CDwnBindData::SetEof");
}

void
CDwnBindData::SetPending(BOOL fPending)
{
    PerfDbgLog1(tagDwnBindDataIO, this, "+CDwnBindData::SetPending %s",
        fPending ? "TRUE" : "FALSE");

    g_csDwnBindPend.Enter();

    if (!_fEof)
    {
        _fPending = fPending;
    }

    g_csDwnBindPend.Leave();

    PerfDbgLog(tagDwnBindDataIO, this, "-CDwnBindData::SetPending");
}

// CDwnBindData (Binding) -----------------------------------------------------

void
CDwnBindData::Bind(DWNLOADINFO * pdli, DWORD dwFlagsExtra)
{
    PerfDbgLog(tagPerfWatch, this, "+CDwnBindData::Bind");
    PerfDbgLog(tagDwnBindData, this, "+CDwnBindData::Bind");
     LPTSTR      pchAlloc = NULL;
    IMoniker *  pmkAlloc = NULL;
    IBindCtx *  pbcAlloc = NULL;
    IStream *   pstm     = NULL;
    CDwnDoc *   pDwnDoc  = pdli->pDwnDoc;
    IBindHost * pbh      = pDwnDoc ? pDwnDoc->GetBindHost() : NULL;
    CMarkup *   pMarkup  = pDwnDoc ? pDwnDoc->GetMarkup() : _pDwnDoc->GetMarkup();
    LPCTSTR     pchUrl;
    IMoniker *  pmk;
    IBindCtx *  pbc;
    IWrappedProtocol * pWP = NULL;
    HRESULT     hr;

    TraceTag((tagDwnBindBinds, "CDwnBindData::Bind url=%S", pdli->pchUrl ? pdli->pchUrl : _T("UNKNOWN")));
    
    _dwFlags = dwFlagsExtra;

    if (pDwnDoc)
    {
        _dwFlags |= pDwnDoc->GetDownf();
    }

    if (_dwFlags & DWNF_ISDOCBIND)
    {
        SetIsDocBind();
    }

    if (_dwFlags & DWNF_ISROOTMARKUP)
    {
        SetIsRootMarkup();
    }

    // Doing it here rather than in the constructor since we memset the class on creating
    // and adding a constructor means re-initializing 
    ResetPrivacyInfo();

    // Case 1: Binding to an user-supplied IStream

    if (pdli->pstm)
    {
        Assert(!pdli->fForceInet);

        _dwSecFlags = (!pdli->fUnsecureSource && IsUrlSecure(pdli->pchUrl)) ? SECURITY_FLAG_SECURE : 0;

        hr = THR(SetBindOnApt());
        if (hr)
            goto Cleanup;

        ReplaceInterface(&_u.pstm, pdli->pstm);
        SignalData();
        
        // Retain the url so we can send url info in the cookie privacy notifications
        _tcscpy(_achUrl, pdli->pchUrl);
        
        goto Cleanup;
    }

    // Case 2: Not binding to a moniker or URL.  This is a manual binding
    // where data will be provided externally and shunted to the consumer.
    // Actual configuration of buffering will occur outside this function.
        
    if (pdli->fClientData || (!pdli->pmk && !pdli->pchUrl))
    {
        _dwSecFlags = (!pdli->fUnsecureSource && IsUrlSecure(pdli->pchUrl)) ? SECURITY_FLAG_SECURE : 0;
        hr = S_OK;
        goto Cleanup;
    }

    // Case 3: Binding asynchronously with IInternetSession

    pchUrl = pdli->pchUrl;

    if (!pchUrl && IsAsyncMoniker(pdli->pmk) == S_OK)
    {
        hr = THR(pdli->pmk->GetDisplayName(NULL, NULL, &pchAlloc));
        if (hr)
            goto Cleanup;

        pchUrl = pchAlloc;
    }

    // Retain the url so we can send url info in the cookie privacy notifications
    _tcscpy(_achUrl, pchUrl);

    // Since INTERNET_OPTION_SECURITY_FLAGS doesn't work for non-wininet URLs
    _uScheme = pchUrl ? GetUrlScheme(pchUrl) : URL_SCHEME_UNKNOWN;

    // Check _uScheme first before calling IsUrlSecure to avoid second (slow) GetUrlScheme call
    _dwSecFlags = (_uScheme != URL_SCHEME_HTTP &&
                   _uScheme != URL_SCHEME_FILE &&
                   !pdli->fUnsecureSource &&
                   IsUrlSecure(pchUrl)) ? SECURITY_FLAG_SECURE : 0;
    
    if (    _uScheme == URL_SCHEME_FILE
        &&  (_dwFlags & (DWNF_GETFILELOCK|DWNF_GETMODTIME)))
    {
        TCHAR achPath[MAX_PATH];
        DWORD cchPath;

        hr = THR(CoInternetParseUrl(pchUrl, PARSE_PATH_FROM_URL, 0,
                    achPath, ARRAY_SIZE(achPath), &cchPath, 0));
        if (hr)
            goto Cleanup;

        hr = THR(_cstrFile.Set(achPath));
        if (hr)
            goto Cleanup;

        if (_cstrFile && (_dwFlags & DWNF_GETMODTIME))
        {
            GetFileLastModTime(_cstrFile, &_ftLastMod);
        }
    }

#ifndef _MAC // Temporarily disable this code so we can get images to load until IInternetSession is fully implemented
    if (    pchUrl
        &&  pdli->pInetSess
        &&  !pbh
        &&  !pdli->pbc
        &&  (   _uScheme == URL_SCHEME_FILE
            ||  _uScheme == URL_SCHEME_HTTP
            ||  _uScheme == URL_SCHEME_HTTPS)
        #if DBG==1 || defined(PERFTAGS)
        &&  !IsPerfDbgEnabled(tagDwnBindSlow)
        #endif
        )
    {
        hr = THR(pdli->pInetSess->CreateBinding(NULL, pchUrl, NULL,
                    NULL, &_o.pInetProt, 0));
        if (hr)
            goto Cleanup;

        //
        // If this QI succeeds, then it means that we've gotten an URLMON wrapper object on
        // an APP instead of the system protocol.  This changes things in 2 ways:
        // 1) If this is a speculative download from the tokenizer (fForceInet == TRUE ), 
        //      we should just bail.  Ideally, we should have an out-of-band stream between 
        //      the tokenzier and postparser that could kick off speculative downloads on 
        //      the UI thread, but that's a bit of work.
        // 2) If this is a normal download, we should re-create the binding, passing in
        //      OIBDG_APARTMENTTHREADED, so that we only get called back on the UI thread.
        //
        if( SUCCEEDED( _o.pInetProt->QueryInterface( IID_IWrappedProtocol, (void **)&pWP ) ) )
        {
#if DBG == 1
            // Right now this method is just there for future compat.  If this assert fires,
            // we should understand what the new code means before changing this.
            LONG lCode;
            pWP->GetWrapperCode( &lCode, NULL );
            Assert( lCode == 0 );
#endif
            pWP->Release();
            ClearInterface( &_o.pInetProt );

            if( pdli->fForceInet )
            {
                // Case 1 - abort speculative download
                hr = E_FAIL;
                goto Cleanup;
            }
            else
            {
                // Case 2 - restart apartment threaded
                hr = THR(pdli->pInetSess->CreateBinding(NULL, pchUrl, NULL,
                            NULL, &_o.pInetProt, PI_APARTMENTTHREADED));
                if( hr )
                    goto Cleanup;
            }
        }
        
        if (!_fIsDocBind)
        {
            IOInetPriority * pOInetPrio = NULL;

            _o.pInetProt->QueryInterface(IID_IInternetPriority, (void **)&pOInetPrio);

            if (pOInetPrio)
            {
                IGNORE_HR(pOInetPrio->SetPriority(THREAD_PRIORITY_BELOW_NORMAL));
                pOInetPrio->Release();
            }
        }

        hr = THR(_o.pInetProt->Start(pchUrl, this, this,
                    PI_MIMEVERIFICATION, 0));

        // That's it.  We're off ...

        goto Cleanup;
    }

    if (pdli->fForceInet)
    {
        hr = E_FAIL;
        goto Cleanup;
    }
#endif // _MAC

    // Case 4: Binding through URL moniker on apartment thread

    pmk = pdli->pmk;

    if (pmk == NULL)
    {
        hr = THR(CreateURLMoniker(NULL, pchUrl, &pmkAlloc));
        if (hr)
            goto Cleanup;
    
        pmk = pmkAlloc;
    }

    hr = THR(SetBindOnApt());
    if (hr)
        goto Cleanup;

    pbc = pdli->pbc;

    if (pbc == NULL)
    {
        hr = THR(CreateBindCtx(0, &pbcAlloc));
        if (hr)
            goto Cleanup;

        pbc = pbcAlloc;
    }

    // Register the "Accept: " headers
    if (_fIsDocBind && pMarkup && pMarkup->Doc()->_pShellBrowser)
        RegisterDefaultAcceptHeaders(pbc, pMarkup->Doc()->_pShellBrowser);

    ReplaceInterface(&_u.pbc, pbc);

    if ((dwFlagsExtra & DWNF_IMGLOAD) && 
        ((_uScheme == URL_SCHEME_JAVASCRIPT) || (_uScheme == URL_SCHEME_VBSCRIPT) || 
         (_uScheme == URL_SCHEME_ABOUT) || !pchUrl || !*pchUrl))
    {
        Assert(pMarkup);
        CStr cstrCreatorUrl;

        hr = THR(cstrCreatorUrl.Set(CMarkup::GetUrl(pMarkup)));
        if (hr)
            goto Cleanup;

#if DBG==1
        // We should not find a bind context param in this case.
        // We will assert but won't touch whatever was inside the bctxparam 
        hr = GetBindContextParam(pbc, &cstrCreatorUrl);

        Assert(hr != S_OK);
#endif

        hr = THR(AddBindContextParam(pbc, &cstrCreatorUrl));
        if (hr)
            goto Cleanup;
    }

    if (pbh)
    {
        hr = THR(pbh->MonikerBindToStorage(pmk, pbc, this,
                IID_IStream, (void **)&pstm));
        if (FAILED(hr))
            goto Cleanup;
    }
    else
    {
        hr = THR(RegisterBindStatusCallback(pbc, this, 0, 0));
        if (FAILED(hr))
            goto Cleanup;

        // If aggregated, save the pUnkOuter in the bind context
        if (_pDwnDoc->GetCDoc() && _pDwnDoc->GetCDoc()->IsAggregated())
        {
            // we're being aggregated
            // don't need to add ref, should be done by routine
            hr = pbc->RegisterObjectParam(L"AGG", _pDwnDoc->GetCDoc()->PunkOuter());
            if (FAILED(hr))
                goto Cleanup;
        }

        hr = THR(pmk->BindToStorage(pbc, NULL, IID_IStream, (void **)&pstm));
        if (FAILED(hr))
        {
            IGNORE_HR(RevokeBindStatusCallback(pbc, this));
            goto Cleanup;
        }
        else if (S_ASYNCHRONOUS == hr && _fBindMayBeIntercepted)
        {
            // 
            // This bind was intercepted by a pluggable protocol (ex: getright)
            // We stop the navigation by signalling data not available.
            //
            TraceTag((tagError, "Bind was Intercepted by pluggable protocol"));
            SignalDone(INET_E_DATA_NOT_AVAILABLE);
        }
    }

    if (pstm)
    {
        ReplaceInterface(&_u.pstm, pstm);
        SignalData();
    }

    hr = S_OK;

Cleanup:

    // If failed to start binding, signal done
    if (hr)
    {
        SignalDone(hr);
    }
    
    ReleaseInterface(pbcAlloc);
    ReleaseInterface(pmkAlloc);
    ReleaseInterface(pstm);
    CoTaskMemFree(pchAlloc);

    PerfDbgLog1(tagDwnBindData, this, "-CDwnBindData::Bind (returning void, hr=%lX)", hr);
    PerfDbgLog(tagPerfWatch, this, "-CDwnBindData::Bind");
}

// CDwnBindData (Reading) ---------------------------------------------------------

HRESULT
CDwnBindData::Peek(void * pv, ULONG cb, ULONG * pcb, BOOL fReadForMimeChk)
{
    PerfDbgLog1(tagDwnBindData, this, "+CDwnBindData::Peek (req %ld)", cb);

    ULONG   cbRead;
    ULONG   cbPeek = _pbPeek ? *(ULONG *)_pbPeek : 0;
    HRESULT hr = S_OK;

    *pcb = 0;

    if (cb > cbPeek)
    {
        if (Align64(cb) > Align64(cbPeek))
        {
            hr = THR(MemRealloc(Mt(CDwnBindData_pbPeek),
                        (void **)&_pbPeek, sizeof(ULONG) + Align64(cb)));
            if (hr)
                goto Cleanup;
        }

        cbRead = 0;

        hr = THR(ReadFromData(_pbPeek + sizeof(ULONG) + cbPeek,
                    cb - cbPeek, &cbRead, fReadForMimeChk));
        if (hr)
            goto Cleanup;

        cbPeek += cbRead;
        *(ULONG *)_pbPeek = cbPeek;

        if (cbPeek == 0)
        {
            // We don't want the state where _pbPeek exists but has no peek
            // data.  The IsEof and IsPending functions assume this won't
            // happen.

            MemFree(_pbPeek);
            _pbPeek = NULL;
        }

    }

    if (cb > cbPeek)
        cb = cbPeek;

    if (cb > 0)
        memcpy(pv, _pbPeek + sizeof(ULONG), cb);

    *pcb = cb;

Cleanup:
    PerfDbgLog3(tagDwnBindData, this, "-CDwnBindData::Peek (%ld bytes) %c%c",
        *pcb, IsPending() ? 'P' : ' ', IsEof() ? 'E' : ' ');
    RRETURN(hr);
}

HRESULT
CDwnBindData::Read(void * pv, ULONG cb, ULONG * pcb)
{
    PerfDbgLog1(tagDwnBindDataIO, this, "+CDwnBindData::Read (req %ld)", cb);

    ULONG   cbRead  = 0;
    ULONG   cbPeek  = _pbPeek ? *(ULONG *)_pbPeek : 0;
    HRESULT hr      = S_OK;

    if (cbPeek)
    {
        cbRead = (cb > cbPeek) ? cbPeek : cb;

        memcpy(pv, _pbPeek + sizeof(ULONG), cbRead);

        if (cbRead == cbPeek)
        {
            MemFree(_pbPeek);
            _pbPeek = NULL;
        }
        else
        {
            memmove(_pbPeek + sizeof(ULONG), _pbPeek + sizeof(ULONG) + cbRead, 
                cbPeek - cbRead);
            *(ULONG *)_pbPeek -= cbRead;
        }

        cb -= cbRead;
        pv = (BYTE *)pv + cbRead;
    }

    *pcb = cbRead;

    if (cb)
    {
        hr = THR(ReadFromData(pv, cb, pcb));

        if (hr)
            *pcb  = cbRead;
        else
            *pcb += cbRead;
    }

    if (_pDwnDoc)
        _pDwnDoc->AddBytesRead(*pcb);

    PerfDbgLog3(tagDwnBindDataIO, this, "-CDwnBindData::Read (got %ld) %c%c",
        *pcb, IsPending() ? 'P' : ' ', IsEof() ? 'E' : ' ');

    RRETURN(hr);
}
    
HRESULT
CDwnBindData::ReadFromData(void * pv, ULONG cb, ULONG * pcb, BOOL fReadForMimeChk)
{
    PerfDbgLog1(tagDwnBindDataIO, this, "+CDwnBindData::ReadFromData (cb=%ld)", cb);

    BOOL fBindDone = _fBindDone;
    HRESULT hr;

    if (_pDwnStm)
    {
        if (!fReadForMimeChk)
        {
            hr = THR(_pDwnStm->Read(pv, cb, pcb));            
        }
        else
        {
            hr = THR(_pDwnStm->ReadForMimeChk(pv, cb, pcb));
        }
    }
    else
        hr = THR(ReadFromBind(pv, cb, pcb));

    if (hr || (fBindDone && IsEof()))
    {
        SignalDone(hr);
    }

    PerfDbgLog2(tagDwnBindDataIO, this,
        "-CDwnBindData::ReadFromData (*pcb=%ld,hr=%lX)", *pcb, hr);

    RRETURN(hr);
}

HRESULT
CDwnBindData::ReadFromBind(void * pv, ULONG cb, ULONG * pcb)
{
    PerfDbgLog1(tagDwnBindDataIO, this, "+CDwnBindData::ReadFromBind (cb=%ld)", cb);
    Assert(CheckThread());

    HRESULT hr;

    #if DBG==1 || defined(PERFTAGS)
    BOOL fBindDone = _fBindDone;
    #endif

    *pcb = 0;

    if (_fEof)
        hr = S_FALSE;
    else if (!_fBindOnApt)
    {
        if (_o.pInetProt)
        {
            SetPending(TRUE);

            hr = _o.pInetProt->Read(pv, cb, pcb);

            PerfDbgLog2(tagDwnBindDataIO, this,
                "CDwnBindData::ReadFromBind InetProt::Read (*pcb=%ld,hr=%lX)",
                *pcb, hr);
        }
        else
            hr = S_FALSE;
    }
    else if (_u.pstm)
    {
        SetPending(TRUE);

        hr = _u.pstm->Read(pv, cb, pcb);

        PerfDbgLog2(tagDwnBindDataIO, this,
            "CDwnBindData::ReadFromBind IStream::Read (*pcb=%ld,hr=%lX)",
            *pcb, hr);
    }
    else
        hr = S_FALSE;

    AssertSz(hr != E_PENDING || !fBindDone, 
        "URLMON reports data pending after binding done!");

    if (!hr && cb && *pcb == 0)
    {
        PerfDbgLog(tagDwnBindData, this,
            "CDwnBindData::ReadFromBind (!hr && !*pcb) == Implied Eof!");
        hr = S_FALSE;
    }
 
    if (hr == E_PENDING)
    {
        hr = S_OK;
    }
    else if (hr == S_FALSE)
    {
        SetEof();

        if (_fBindOnApt)
        {
            ClearInterface(&_u.pstm);
        }

        hr = S_OK;
    }
    else if (hr == S_OK)
    {
        SetPending(FALSE);
    }

    #if DBG==1 || defined(PERFTAGS)
    _cbBind += *pcb;
    #endif

    PerfDbgLog6(tagDwnBindDataIO, this,
        "-CDwnBindData::ReadFromBind (*pcb=%ld,cbBind=%ld,hr=%lX) %c%c%c",
        *pcb, _cbBind, hr, _fPending ? 'P' : ' ', _fEof ? 'E' : ' ',
        fBindDone ? 'D' : ' ');

    RRETURN(hr);
}

void
CDwnBindData::BufferData()
{
    PerfDbgLog(tagPerfWatch, this, "+CDwnBindData::BufferData");

    if (_pDwnStm)
    {
        void *  pv;
        ULONG   cbW, cbR;
        HRESULT hr = S_OK;

        for (;;)
        {
            hr = THR(_pDwnStm->WriteBeg(&pv, &cbW));
            if (hr)
                break;

            Assert(cbW > 0);

            hr = THR(ReadFromBind(pv, cbW, &cbR));
            if (hr)
                break;

            Assert(cbR <= cbW);

            _pDwnStm->WriteEnd(cbR);

            if (cbR == 0)
                break;
        }

        if (hr || _fEof)
        {
            _pDwnStm->WriteEof(hr);
        }

        if (hr)
        {
            SignalDone(hr);
        }
    }

    PerfDbgLog(tagPerfWatch, this, "-CDwnBindData::BufferData");
}

BOOL
CDwnBindData::IsPending()
{
    return(!_pbPeek && (_pDwnStm ? _pDwnStm->IsPending() : _fPending));
}

BOOL
CDwnBindData::IsEof()
{
    return(!_pbPeek && (_pDwnStm ? _pDwnStm->IsEof() : _fEof));
}

// CDwnBindData (Callback) ----------------------------------------------------

void
CDwnBindData::SetCallback(CDwnLoad * pDwnLoad)
{
    PerfDbgLog(tagDwnBindData, this, "+CDwnBindData::SetCallback");

    g_csDwnBindSig.Enter();

    _wSig     = _wSigAll;
    _pDwnLoad = pDwnLoad;
    _pDwnLoad->SubAddRef();

    g_csDwnBindSig.Leave();

    if (_wSig)
    {
        Signal(0);
    }

    if (_fHandleFailedNavigationOnAttatch)
    {
        HandleFailedNavigation(_hrReasonForFailedNavigation);
    }

    PerfDbgLog(tagDwnBindData, this, "-CDwnBindData::SetCallback");
}

void
CDwnBindData::Disconnect()
{
    PerfDbgLog(tagDwnBindData, this, "+CDwnBindData::Disconnect");

    g_csDwnBindSig.Enter();

    CDwnLoad * pDwnLoad = _pDwnLoad;

    _pDwnLoad = NULL;
    _wSig     = 0;

    g_csDwnBindSig.Leave();

    if (pDwnLoad)
        pDwnLoad->SubRelease();

    PerfDbgLog(tagDwnBindData, this, "-CDwnBindData::Disconnect");
}

void
CDwnBindData::Signal(WORD wSig)
{
    PerfDbgLog1(tagDwnBindData, this, "+CDwnBindData::Signal (wSig=%04lX)", wSig);

    SubAddRef();

    for (;;)
    {
        CDwnLoad *  pDwnLoad = NULL;
        WORD        wSigCur  = 0;

        g_csDwnBindSig.Enter();

        // DBF_DONE is sent exactly once, even though it may be signalled
        // more than once.  If we are trying to signal it and have already
        // done so, turn off the flag.

        wSig &= ~(_wSigAll & DBF_DONE);

        // Remember all flags signalled since we started in case we disconnect
        // and reconnect to a new client.  That way we can replay all the
        // missed flags.

        _wSigAll |= wSig;

        if (_pDwnLoad)
        {
            // Someone is listening, so lets figure out what to tell the
            // callback.  Notice that if _dwSigTid is not zero, then a
            // different thread is currently in a callback.  In that case,
            // we just let it do the callback again when it returns.

            _wSig |= wSig;

            if (_wSig && !_dwSigTid)
            {
                wSigCur   = _wSig;
                _wSig     = 0;
                _dwSigTid = GetCurrentThreadId();
                pDwnLoad  = _pDwnLoad;
                pDwnLoad->SubAddRef();
            }
        }

        g_csDwnBindSig.Leave();

        if (!pDwnLoad)
            break;

        // NB: (jbeda, jharding) If this is not _fBindOnApt, then
        // we want to delay BufferData as long as possible -- so
        // we do it only right before we signal.  We can't do this
        // when _fBindOnApt because that might cause us to do the
        // BufferData on the wrong thread.
        if (!_fBindOnApt && _pDwnStm && (wSigCur & DBF_DATA))
        {
            BufferData();
        }

        pDwnLoad->OnBindCallback(wSigCur);
        pDwnLoad->SubRelease();

        _dwSigTid = 0;
        wSig      = 0;
    }

    SubRelease();

    PerfDbgLog(tagDwnBindData, this, "-CDwnBindData::Signal");
}

void
CDwnBindData::SignalRedirect(LPCTSTR pszText, IUnknown *punkBinding)
{
    PerfDbgLog1(tagDwnBindData, this, "+CDwnBindData::SignalRedirect %ls", pszText);

    IWinInetHttpInfo * pwhi = NULL;
    char  achA[16];
    TCHAR achW[16];
    ULONG cch = ARRAY_SIZE(achA);
    HRESULT hr;

    //$ Need protection here.  Redirection can happen more than once.
    //$ This means that GetRedirect() returns a potentially dangerous
    //$ string.

    // Discover the last HTTP request method

    _cstrMethod.Free();
    hr = THR(punkBinding->QueryInterface(IID_IWinInetHttpInfo, (void **)&pwhi));
    if (!hr && pwhi)
    {
        hr = THR(pwhi->QueryInfo(HTTP_QUERY_REQUEST_METHOD, &achA, &cch, NULL, 0));
        if (!hr && cch)
        {
            AnsiToWideTrivial(achA, achW, cch);
            hr = THR(_cstrMethod.Set(achW));
            if (hr)
                goto Cleanup;

            if (_tcsequal(_T("POST"), _cstrMethod))
            {
                // HACK HACK HACK !!
                // Double check the status code to see if this is a real POST
                // there is a HttpQueryInfo() bug which will send verb=POST
                // on a POST->GET Redirect
                //

                DWORD dwStatusCode = 0;
                ULONG cch = sizeof(dwStatusCode);

                hr = THR(pwhi->QueryInfo(HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
                                         &dwStatusCode, &cch, NULL, 0));
                if (!hr && cch && dwStatusCode != HTTP_STATUS_REDIRECT_KEEP_VERB)
                {
                    hr = THR(_cstrMethod.Set(_T("GET")));
                    if (hr)
                        goto Cleanup;
                }
            }
        }
    }

    // In case the new URL isn't covered by wininet: clear security flags
    
    _dwSecFlags = IsUrlSecure(pszText) ? SECURITY_FLAG_SECURE : 0;
    
    // Set the redirect url
    
    hr = THR(_cstrRedirect.Set(pszText));

    // Redirection means that our POST request, if any, may have become a GET
    
    if (!_cstrMethod || !_tcsequal(_T("POST"), _cstrMethod))
        SetDwnPost(NULL);

Cleanup:

    ReleaseInterface(pwhi);
    
    if (hr)
        SignalDone(hr);
    else
    {
        Signal(DBF_REDIRECT);

        AddToPrivacyList();
        ResetPrivacyInfo();
        // If this was a top level navigation then this redirection should be considered
        // a non-user initiated navigation, so we need to add the dummy marker record here
        if (_fIsRootMarkup)
            AddToPrivacyList();
        
        // Store the redirect url 
        Assert(pszText);
        _tcscpy(_achUrl, pszText);
    }

    PerfDbgLog(tagDwnBindData, this, "-CDwnBindData::SignalRedirect");
}

void
CDwnBindData::SignalProgress(DWORD dwPos, DWORD dwMax, DWORD dwStatus)
{
    PerfDbgLog(tagDwnBindData, this, "+CDwnBindData::SignalProgress");

    _DwnProg.dwMax    = dwMax;
    _DwnProg.dwPos    = dwPos;
    _DwnProg.dwStatus = dwStatus;

    Signal(DBF_PROGRESS);

    PerfDbgLog(tagDwnBindData, this, "-CDwnBindData::SignalProgress");
}

void
CDwnBindData::SignalFile(LPCTSTR pszText)
{
    if (    pszText
        &&  *pszText
        &&  (_dwFlags & DWNF_GETFILELOCK)
        &&  (   _uScheme == URL_SCHEME_HTTP
             || _uScheme == URL_SCHEME_HTTPS
             || _uScheme == URL_SCHEME_FTP
             || _uScheme == URL_SCHEME_GOPHER
             || ( _pDwnDoc && _pDwnDoc->GetTrustAPPCache()) ))
    {
        HRESULT hr = THR(_cstrFile.Set(pszText));

        if (hr)
        {
            SignalDone(hr);
        }
    }
}

void
CDwnBindData::SignalHeaders(IUnknown * punkBinding)
{
    PerfDbgLog(tagDwnBindData, this, "+CDwnBindData::SignalHeaders");

    IWinInetHttpInfo * pwhi = NULL;
    IWinInetInfo *pwi = NULL;
    BOOL fSignal = FALSE;
    ULONG cch;
    HRESULT hr = S_OK;

    punkBinding->QueryInterface(IID_IWinInetHttpInfo, (void **)&pwhi);

    if (pwhi)
    {
        CHAR    achA[256];
        TCHAR   achW[256];
 
        if (_dwFlags & DWNF_GETCONTENTTYPE)
        {
            cch = sizeof(achA);

            hr = THR(pwhi->QueryInfo(HTTP_QUERY_CONTENT_TYPE, achA, &cch, NULL, 0));

            if (hr == S_OK && cch > 0)
            {
                AnsiToWideTrivial(achA, achW, cch);

                hr = THR(_cstrContentType.Set(achW));
                if (hr)
                    goto Cleanup;

                fSignal = TRUE;
            }

            hr = S_OK;
        }

        if (_dwFlags & DWNF_GETREFRESH)
        {
            cch = sizeof(achA);

            hr = THR(pwhi->QueryInfo(HTTP_QUERY_REFRESH, achA, &cch, NULL, 0));

            if (hr == S_OK && cch > 0)
            {
                AnsiToWideTrivial(achA, achW, cch);

                hr = THR(_cstrRefresh.Set(achW));
                if (hr)
                    goto Cleanup;

                fSignal = TRUE;
            }

            hr = S_OK;
        }

        if (_dwFlags & DWNF_GETMODTIME)
        {
            SYSTEMTIME st;
            cch = sizeof(SYSTEMTIME);

            hr = THR(pwhi->QueryInfo(HTTP_QUERY_LAST_MODIFIED|HTTP_QUERY_FLAG_SYSTEMTIME,
                        &st, &cch, NULL, 0));

            if (hr == S_OK && cch == sizeof(SYSTEMTIME))
            {
                if (SystemTimeToFileTime(&st, &_ftLastMod))
                {
                    fSignal = TRUE;
                }
            }

            hr = S_OK;
        }

        if (_dwFlags & DWNF_GETPICS)
        {
            ExternTag(tagPics);

            cch = sizeof(achA);
            StrCpyA(achA, "PICS-Label");
            hr = THR(pwhi->QueryInfo(HTTP_QUERY_CUSTOM, achA, &cch, NULL, 0));
            if (hr == S_OK && cch > 0)
            {
                AnsiToWideTrivial(achA, achW, cch);

                hr = THR(_cstrPics.Set(achW));
                if (hr)
                    goto Cleanup;

                fSignal = TRUE;

                TraceTag((tagPics, "PICS-Label: %S", achW));
            }
        }
        
        Assert(!(_dwFlags & DWNF_HANDLEECHO) || (_dwFlags & DWNF_GETSTATUSCODE));

        if (_dwFlags & DWNF_GETSTATUSCODE)
        {
            cch = sizeof(_dwStatusCode);

            hr = THR(pwhi->QueryInfo(HTTP_QUERY_STATUS_CODE|HTTP_QUERY_FLAG_NUMBER,
                        &_dwStatusCode, &cch, NULL, 0));

            if (!hr && (_dwFlags & DWNF_HANDLEECHO) && _dwStatusCode == HTTP_STATUS_RETRY_WITH)
            {
                ULONG cb = 0;

                hr = THR(pwhi->QueryInfo(HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_ECHO_HEADERS_CRLF, NULL, &cb, NULL, 0));
                if ((hr && hr != S_FALSE) || !cb)
                    goto NoHeaders;

                Assert(!_pbRawEcho);
                MemFree(_pbRawEcho);
                
                _pbRawEcho = (BYTE *)MemAlloc(Mt(CDwnBindData_pbRawEcho), cb);
                if (!_pbRawEcho)
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }

                _cbRawEcho = cb;

                hr = THR(pwhi->QueryInfo(HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_ECHO_HEADERS_CRLF, _pbRawEcho, &cb, NULL, 0));
                Assert(!hr && cb+1 == _cbRawEcho);
                
            NoHeaders:
                ;
            }

            fSignal = TRUE;
            hr = S_OK;
        }
    }
    
    if (!pwhi)
    {
        punkBinding->QueryInterface(IID_IWinInetInfo, (void **)&pwi);
    }
    else
    {
        pwi = pwhi;
        pwhi = NULL;
    }

    if (_dwFlags & DWNF_GETFLAGS)
    {
        if (pwi)
        {
            DWORD dwFlags;
            cch = sizeof(DWORD);

            hr = THR_NOTRACE(pwi->QueryOption(INTERNET_OPTION_REQUEST_FLAGS, &dwFlags, &cch));
            if (hr == S_OK && cch == sizeof(DWORD))
            {
                _dwReqFlags = dwFlags;
            }

            // NOTE: wininet does not remember security for cached files,
            // if it's from the cache, don't ask wininet; just use security-based-on-url.

            cch = sizeof(DWORD);

            hr = THR_NOTRACE(pwi->QueryOption(INTERNET_OPTION_SECURITY_FLAGS, &dwFlags, &cch));
            if (hr == S_OK && cch == sizeof(DWORD))
            {
                if ((dwFlags & SECURITY_FLAG_SECURE) || !(_dwReqFlags & INTERNET_REQFLAG_FROM_CACHE))
                    _dwSecFlags = dwFlags;
            }
        }
        
        fSignal = TRUE; // always pick up security flags

        hr = S_OK;
    }

    if ((_dwFlags & DWNF_GETSECCONINFO) && pwi)
    {
        ULONG cb = sizeof(INTERNET_SECURITY_CONNECTION_INFO);
        INTERNET_SECURITY_CONNECTION_INFO isci;
        
        Assert(!_pSecConInfo);
        MemFree(_pSecConInfo);

        isci.dwSize = cb;
        
        hr = THR_NOTRACE(pwi->QueryOption(INTERNET_OPTION_SECURITY_CONNECTION_INFO, &isci, &cb));
        if (!hr && cb == sizeof(INTERNET_SECURITY_CONNECTION_INFO))
        {
            _pSecConInfo = (INTERNET_SECURITY_CONNECTION_INFO *)MemAlloc(Mt(CDwnBindData_pSecConInfo), cb);
            if (!_pSecConInfo)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            memcpy(_pSecConInfo, &isci, cb);
        }

        hr = S_OK;
    }


    if (_cstrFile)
    {
        fSignal = TRUE;

        if (pwi && _uScheme != URL_SCHEME_FILE)
        {
            cch = sizeof(HANDLE);
            IGNORE_HR(pwi->QueryOption(WININETINFO_OPTION_LOCK_HANDLE, &_hLock, &cch));
        }
    }

Cleanup:

    if (pwhi)
        pwhi->Release();

    if (pwi)
        pwi->Release();

    if (hr)
        SignalDone(hr);
    else if (fSignal)
        Signal(DBF_HEADERS);

    PerfDbgLog2(tagDwnBindData, this, "-CDwnBindData::SignalHeaders ReqFlags:%lx SecFlags:%lx", _dwReqFlags, _dwSecFlags);
}

void
CDwnBindData::SignalData()
{
    PerfDbgLog(tagDwnBindData, this, "+CDwnBindData::SignalData");

    // NB: (jbeda, jharding) If we are _fBindOnApt, we need to buffer 
    // data here to make sure that we do it on the correct thread.  We 
    // can't do it late because in Signal because it might be picked up 
    // and done on the wrong thread
    if (_fBindOnApt && _pDwnStm)
    {
        BufferData();
    }

    Signal(DBF_DATA);

    PerfDbgLog(tagDwnBindData, this, "-CDwnBindData::SignalData");
}

void
CDwnBindData::SignalDone(HRESULT hrErr)
{
    PerfDbgLog1(tagDwnBindData, this, "+CDwnBindData::SignalDone (hrErr=%lX)", hrErr);

    Terminate(hrErr);

    Signal(DBF_DONE);

    PerfDbgLog(tagDwnBindData, this, "-CDwnBindData::SignalDone");
}

// CDwnBindData (Misc) --------------------------------------------------------

LPCTSTR
CDwnBindData::GetFileLock(HANDLE * phLock, BOOL *pfPretransform)
{
    // Don't grab the file if there is a MIME filter or we have a transformed HTML file
    // because we don't want to look at the file directly.
    BOOL fTransform = FALSE;
    CDwnDoc *pDwnDoc;
    if ((pDwnDoc = GetDwnDoc()) != NULL)
        fTransform = pDwnDoc->GetDwnTransform();
    *pfPretransform = _fMimeFilter || fTransform;
    if (_cstrFile)  // note that the file will always be returned
    {
        *phLock = _hLock;
        _hLock = NULL;

        return(_cstrFile);
    }

    *phLock = NULL;
    return(NULL);
}

void
CDwnBindData::GiveRawEcho(BYTE **ppb, ULONG *pcb)
{
    Assert(!*ppb);
    
    *ppb = _pbRawEcho;
    *pcb = _cbRawEcho;
    _pbRawEcho = NULL;
    _cbRawEcho = 0;
}

void
CDwnBindData::GiveSecConInfo(INTERNET_SECURITY_CONNECTION_INFO **ppsci)
{
    Assert(!*ppsci);
    
    *ppsci = _pSecConInfo;
    _pSecConInfo = NULL;
}

// CDwnBindData (IBindStatusCallback) -----------------------------------------

STDMETHODIMP
CDwnBindData::OnStartBinding(DWORD grfBSCOption, IBinding *pbinding)
{
    PerfDbgLog(tagPerfWatch, this, "+CDwnBindData::OnStartBinding");
    PerfDbgLog(tagDwnBindData, this, "+CDwnBindData::OnStartBinding");

    Assert(_fBindOnApt && CheckThread());

    _fBindDone = FALSE;

    ReplaceInterface(&_u.pbinding, pbinding);

    if (!_fIsDocBind)
    {
        IGNORE_HR(pbinding->SetPriority(THREAD_PRIORITY_BELOW_NORMAL));
    }

    PerfDbgLog(tagDwnBindData, this, "-CDwnBindData::OnStartBinding");
    PerfDbgLog(tagPerfWatch, this, "-CDwnBindData::OnProgress");

    return(S_OK);
}

void
CDwnBindData::SignalCache(IBindCtx * pbc, ULONG ulPos, ULONG ulMax, ULONG ulCode, LPCWSTR pszText)
{
    IUnknown *      pUnk = NULL;
    CDwnBindInfo *  pDwnBindInfo      = NULL;

    if (pbc)
    {
        pbc->GetObjectParam(SZ_DWNBINDINFO_OBJECTPARAM, &pUnk);

        if (pUnk)
        {
            pUnk->QueryInterface(IID_IDwnBindInfo, (void **)&pDwnBindInfo);

            if (pDwnBindInfo)
            {
                IGNORE_HR(pDwnBindInfo->OnProgress(ulPos, ulMax,  ulCode,  pszText));
            }
        }
        ReleaseInterface(pUnk);
        ReleaseInterface((IBindStatusCallback *)pDwnBindInfo);
    }
}

STDMETHODIMP
CDwnBindData::OnProgress(ULONG ulPos, ULONG ulMax, ULONG ulCode, LPCWSTR pszText)
{
    PerfDbgLog(tagPerfWatch, this, "+CDwnBindData::OnProgress");
    PerfDbgLog4(tagDwnBindData, this, "+CDwnBindData::OnProgress %ld %ld %s \"%ls\"",
        ulPos, ulMax, g_rgpchBindStatus[ulCode], pszText ? pszText : g_Zero.ach);

    BindingNotIntercepted();

    //
    // marka - tickle dialmon periodically - 
    // like shdocvw's CDocObjectHost::CDOHBindStatusCallback::OnProgress
    //
    IndicateWinsockActivity();
    
    Assert(_fBindOnApt && CheckThread());

    CDoc * pDoc = _pDwnDoc ? _pDwnDoc->GetCDoc() : NULL;

    switch (ulCode)
    {
        case BINDSTATUS_SENDINGREQUEST:
            if (   _pDwnDoc
                && _pDwnDoc->GetMarkup()
                && !_pDwnDoc->GetMarkup()->_fLoadingHistory
                && _pDwnDoc->GetCDoc()
                && _pDwnDoc->GetCDoc()->_pClientSite)
            {
                IUnknown_Exec(_pDwnDoc->GetCDoc()->_pClientSite,
                              &CGID_DocHostCmdPriv,
                              DOCHOST_SENDINGREQUEST,
                              0, NULL, NULL);
            }

            break;

        case BINDSTATUS_COOKIE_SENT:            
            if(pszText && *pszText && pDoc)
            {
                TraceTag((tagDwnBindPrivacy, "CDwnBindData::ReportProgress - Received BINDSTATUS_COOKIE_SENT for url %ls", pszText));            
                THR(pDoc->AddToPrivacyList(pszText, NULL, COOKIEACTION_READ)); 
            }
            else
            {
                TraceTag((tagDwnBindPrivacy, "CDwnBindData::ReportProgress - Received BINDSTATUS_COOKIE_SENT for url %ls", _achUrl));            
                _dwPrivacyFlags |= COOKIEACTION_READ;
            }
            break;

        case BINDSTATUS_COOKIE_SUPPRESSED:            
            if(pszText && *pszText && pDoc)
            {
                TraceTag((tagDwnBindPrivacy, "CDwnBindData::ReportProgress - Received BINDSTATUS_COOKIE_SUPPRESSED for url %ls", pszText));
                THR(pDoc->AddToPrivacyList(pszText, NULL, COOKIEACTION_SUPPRESS)); 
            }
            else
            {
                TraceTag((tagDwnBindPrivacy, "CDwnBindData::ReportProgress - Received BINDSTATUS_COOKIE_SUPPRESSED for url %ls", _achUrl));
                _dwPrivacyFlags |= COOKIEACTION_SUPPRESS;
            }
            break;

        case BINDSTATUS_COOKIE_STATE_UNKNOWN:
            TraceTag((tagDwnBindPrivacy, "Trident should never BINDSTATUS_COOKIE_STATE_UNKNOWN from Wininet/Urlmon for url %ls", _achUrl));
            break;
        case BINDSTATUS_COOKIE_STATE_ACCEPT:            
            if(pszText && *pszText && pDoc)
            {
                TraceTag((tagDwnBindPrivacy, "CDwnBindData::OnProgress - Received BINDSTATUS_COOKIE_STATE_ACCEPT for url %ls", pszText));
                THR(pDoc->AddToPrivacyList(pszText, NULL, COOKIEACTION_ACCEPT)); 
            }
            else
            {
                TraceTag((tagDwnBindPrivacy, "CDwnBindData::OnProgress - Received BINDSTATUS_COOKIE_STATE_ACCEPT for url %ls", _achUrl));
                _dwPrivacyFlags |= COOKIEACTION_ACCEPT;
            }
            break;
        case BINDSTATUS_COOKIE_STATE_REJECT:            
            if(pszText && *pszText && pDoc)
            {
                TraceTag((tagDwnBindPrivacy, "CDwnBindData::OnProgress - Received BINDSTATUS_COOKIE_STATE_REJECT for url %ls", pszText));
                THR(pDoc->AddToPrivacyList(pszText, NULL, COOKIEACTION_REJECT)); 
            }
            else
            {
                TraceTag((tagDwnBindPrivacy, "CDwnBindData::OnProgress - Received BINDSTATUS_COOKIE_STATE_REJECT for url %ls", _achUrl));
                _dwPrivacyFlags |= COOKIEACTION_REJECT;
            }
            break;
        case BINDSTATUS_COOKIE_STATE_LEASH:            
            if(pszText && *pszText && pDoc)
            {
                TraceTag((tagDwnBindPrivacy, "CDwnBindData::OnProgress - Received BINDSTATUS_COOKIE_STATE_LEASH for url %ls", pszText));
                THR(pDoc->AddToPrivacyList(pszText, NULL, COOKIEACTION_LEASH)); 
            }
            else
            {
                TraceTag((tagDwnBindPrivacy, "CDwnBindData::OnProgress - Received BINDSTATUS_COOKIE_STATE_LEASH for url %ls", _achUrl));
                _dwPrivacyFlags |= COOKIEACTION_LEASH;
            }
            break;
        case BINDSTATUS_COOKIE_STATE_DOWNGRADE:            
            if(pszText && *pszText && pDoc)
            {
                TraceTag((tagDwnBindPrivacy, "CDwnBindData::OnProgress - Received BINDSTATUS_COOKIE_STATE_DOWNGRADE for url %ls", pszText));
                THR(pDoc->AddToPrivacyList(pszText, NULL, COOKIEACTION_DOWNGRADE)); 
            }
            else
            {
                TraceTag((tagDwnBindPrivacy, "CDwnBindData::OnProgress - Received BINDSTATUS_COOKIE_STATE_DOWNGRADE for url %ls", _achUrl));
                _dwPrivacyFlags |= COOKIEACTION_DOWNGRADE;
            }
            break;
            
        case BINDSTATUS_COMPACT_POLICY_RECEIVED:
            _dwPrivacyFlags |= PRIVACY_URLHASCOMPACTPOLICY;
            break;            
        
        case BINDSTATUS_POLICY_HREF:
            TraceTag((tagDwnBindPrivacy, "CDwnBindData::OnProgress - Received BINDSTATUS_POLICY_HREF for url %ls", _achUrl));
            Assert(pszText && *pszText);
            _tcscpy(_achPolicyRef, pszText);
            _dwPrivacyFlags |= PRIVACY_URLHASPOLICYREFHEADER;
            break;

        case BINDSTATUS_P3P_HEADER:
            TraceTag((tagDwnBindPrivacy, "CDwnBindData::OnProgress - Received BINDSTATUS_P3P_HEADER for url %ls", _achUrl));
            Assert(pszText && *pszText);
            {
                // We are getting two notifications from urlmon, once that is fixed, need to uncomment this assert
                //Assert(!_pchP3PHeader);
                delete [] _pchP3PHeader;

                unsigned len = _tcslen(pszText);
                _pchP3PHeader = new(Mt(CDwnBindData_pchP3PHeader)) TCHAR[len + 1];
                if (_pchP3PHeader)
                {
                    _tcscpy(_pchP3PHeader, pszText);
                    _pchP3PHeader[len] = _T('\0');
                }
                _dwPrivacyFlags |= PRIVACY_URLHASP3PHEADER;
            }
            break;

        case BINDSTATUS_REDIRECTING:
            SignalRedirect(pszText, _u.pbinding);
            break;

        case BINDSTATUS_CACHEFILENAMEAVAILABLE:
            SignalFile(pszText);
            SignalCache(_u.pbc, ulPos, ulMax,  ulCode,  pszText);
            break;

        case BINDSTATUS_RAWMIMETYPE:
            _pRawMimeInfo = GetMimeInfoFromMimeType(pszText);
            _fReceivedMimeNotification = TRUE;
            SignalCache(_u.pbc, ulPos, ulMax,  ulCode,  pszText);
            break;

        case BINDSTATUS_MIMETYPEAVAILABLE:
            SignalCache(_u.pbc, ulPos, ulMax,  ulCode,  pszText);
            _pmi = GetMimeInfoFromMimeType(pszText);
            _fReceivedMimeNotification = TRUE;
            if (StrCmpIC(pszText,_T("text/xml")) == 0)
                _pDwnDoc->SetDocIsXML(TRUE);
            if (!_pmi)
            {
                // This stores the media mime-type as a string on the bind ctx.
                // This is a hook for the IE Media Bar, so that when navigation
                // is delegated to shdocvw, the media bar can catch media urls.
                // This approach is needed because (as per VenkatK) the mime-type 
                // cannot be curently obtained from the bind ctx after delegating 
                // to shdocvw.
                SetMediaMimeOnBindCtx(pszText, _u.pbc);
            }
            break;

        case BINDSTATUS_LOADINGMIMEHANDLER:
            _fMimeFilter = TRUE;
            break;

        case BINDSTATUS_FINDINGRESOURCE:
            if (   _pDwnDoc
                && _pDwnDoc->GetMarkup()
                && !_pDwnDoc->GetMarkup()->_fLoadingHistory
                && _pDwnDoc->GetCDoc()
                && _pDwnDoc->GetCDoc()->_pClientSite)
            {
                IUnknown_Exec(_pDwnDoc->GetCDoc()->_pClientSite,
                              &CGID_DocHostCmdPriv,
                              DOCHOST_FINDINGRESOURCE,
                              0, NULL, NULL);
            }

            // Intentional fall-through.

        case BINDSTATUS_CONNECTING:
        case BINDSTATUS_BEGINDOWNLOADDATA:
        case BINDSTATUS_DOWNLOADINGDATA:
        case BINDSTATUS_ENDDOWNLOADDATA:
            SignalProgress(ulPos, ulMax, ulCode);

            if (_pDwnDoc && _pDwnDoc->GetCDoc())
            {
                CMarkup        * pMarkup        = _pDwnDoc->GetMarkup();
                COmWindowProxy * pWindowPending = pMarkup  ? pMarkup->GetWindowPending() : NULL;

                if (    pWindowPending 
                    &&  pWindowPending->Window()->_pMarkup
                    && !pWindowPending->Window()->IsPrimaryWindow())
                {
                    // NB (scotrobe): ulProgress depends on the value of ulCode.
                    //
                    ULONG ulProgress = ulCode >= BINDSTATUS_BEGINDOWNLOADDATA ? (ulCode-1) : ulCode;

                    _pDwnDoc->GetCDoc()->_webOCEvents.FrameProgressChange(pWindowPending,
                                                                          ulProgress,
                                                                          BINDSTATUS_ENDDOWNLOADDATA - 1);
                }
            }

            break;

        case BINDSTATUS_CONTENTDISPOSITIONATTACH:
            _fDelegateDownload = TRUE;
            break;
    }

    // NB: Shdocvw would handle http errors (404) on the OnStopBinding of its BindToObject bind.
    // However, we are always doing BindToStorage so OnStopBinding has different meaning.  Instead,
    // we handle http errors when BEGINDOWNLOADDATA is sent -- this is an equivalent time 
    // for BindToStorage.  We also want to make sure that we don't switch before we can process
    // this data -- don't worry -- it shouldn't be a problem.  Why would we switch before we have
    // *any* data?
    if (ulCode == BINDSTATUS_BEGINDOWNLOADDATA)
    {
        HandleFailedNavigation(S_OK);
    }
  
    PerfDbgLog(tagDwnBindData, this, "-CDwnBindData::OnProgress");
    PerfDbgLog(tagPerfWatch, this, "-CDwnBindData::OnProgress");
    return(S_OK);
}

//
//  Only available in the DDK so defined here 
//
#define E_INVALID_SYNTAX  0x800401E4

STDMETHODIMP
CDwnBindData::OnStopBinding(HRESULT hrReason, LPCWSTR szReason)
{
    PerfDbgLog(tagPerfWatch, this, "+CDwnBindData::OnStopBinding");
    PerfDbgLog2(tagDwnBindData, this, "+CDwnBindData::OnStopBinding %lX \"%ls\"",
        hrReason, szReason ? szReason : g_Zero.ach);
    Assert(_fBindOnApt && CheckThread());

    LPWSTR pchError = NULL;

    SubAddRef();

    _fBindDone = TRUE;

    //
    // We will always be notified of mime-type before OnStopBinding
    // if there is a mime-type to be had. The reason we would not get
    // a mime-type is because the bind failed too quickly. I believe that 
    // the only way the bind would fail that quickly is because of a syntax
    // error in the URL; however I am not going to rely on that belief.
    // I will use CoInternetParseUrl to check syntax of the URL.
    // 
    // CoInternetParseUrl will verify the syntax against the protocol.
    // It is more expensive than Parse URL; however using.
    //
    // OnStopBinding is where Trident does all its error handling.
    // This is a problem, because if we do have syntactically bad Url
    // then it will show up in SignalDone and not here. So what we are going
    // to do, change the reason from okay to invalid syntax for this 
    // one error case.
    //
    // The reason we do this is because if we keep delegating to Shdocvw
    // Urls with invalid syntax instead using HandleFailedNavigation, 
    // it will eventually blow up Shdocvw.
    // 

    //
    // This breaks application compatibility, so let us make sure we are
    // hosted in the browser and the we don't have any reported mime-type
    // GetMimeInfo filters out certain mime-types.
    //

    if (g_fInIexplorer && (_fReceivedMimeNotification != TRUE) && !SHRegGetBoolUSValue(TEXT("SOFTWARE\\Microsoft\\Internet Explorer\\Main"), TEXT("Enable Browser Extensions"), FALSE, TRUE))
    {
        if ((GetMimeInfo() == NULL) && SUCCEEDED(hrReason))
        {
            HRESULT  hrParseUrl  = E_FAIL;
            LPTSTR   pTempBuffer = NULL;
            DWORD    nUrlLen;

            pTempBuffer = new TCHAR [INTERNET_MAX_URL_LENGTH + 1];

            if (pTempBuffer)
            {
                // CoInternetParseUrl does not give us a detailed 
                // analysis of its failures. So we going to check 
                // the protocol and the domain because they or so
                // important. We are going to check the mime-type.
                // It was the lack of a mime-type that caused 
                // us to have a problem with Windows Bugs://493765

                hrParseUrl = CoInternetParseUrl(_achUrl,
                                                PARSE_SCHEMA,
                                                0,
                                                pTempBuffer,
                                                INTERNET_MAX_URL_LENGTH + 1,
                                                &nUrlLen,
                                                0);

                if (SUCCEEDED(hrParseUrl))
                {
                    hrParseUrl = CoInternetParseUrl(_achUrl,
                                                    PARSE_DOMAIN,
                                                    0,
                                                    pTempBuffer,
                                                    INTERNET_MAX_URL_LENGTH + 1,
                                                    &nUrlLen,
                                                    0);
                }

                if (SUCCEEDED(hrParseUrl))
                {
                    hrParseUrl = CoInternetParseUrl(_achUrl,
                                                    PARSE_MIME,
                                                    0,
                                                    pTempBuffer,
                                                    INTERNET_MAX_URL_LENGTH + 1,
                                                    &nUrlLen,
                                                    0);
                }

                //
                // Just to be ultra safe, let's check that we aren't failing 
                // these checks because we are dealing with a local file.
                //

                if (SUCCEEDED(hrParseUrl))
                {
                    hrParseUrl = CoInternetParseUrl(_achUrl,
                                                    PARSE_PATH_FROM_URL,
                                                    0,
                                                    pTempBuffer,
                                                    INTERNET_MAX_URL_LENGTH + 1,
                                                    &nUrlLen,
                                                    0);
                }

                if (FAILED(hrParseUrl))
                {
                    hrReason = E_INVALID_SYNTAX;
                }
            }

            delete[] pTempBuffer;
        }
    }

    if (SUCCEEDED(hrReason) &&
        g_fDisableUnTrustedProtocol &&
        _pDwnDoc->HasCallerUrl() &&
        IsDangerousProtoclAndChmMime(_achUrl))
    {
        DWORD dwZoneIDCaller  = URLZONE_UNTRUSTED;

        //
        // Get the security manager.
        //
        //
        // I don't trust _pDwnDoc calls on _pDoc
        // They cause leaks and threading issues.
        //

        HRESULT hrSec = E_FAIL;

        IInternetSecurityManager* pISM = NULL; 

        hrSec = THR(CoInternetCreateSecurityManager(NULL, &pISM, 0));

        if (SUCCEEDED(hrSec))
        {
            hrSec = pISM->MapUrlToZone(_pDwnDoc->GetCallerUrl(),&dwZoneIDCaller,0);

            if (FAILED(hrSec) ||
                ((dwZoneIDCaller != URLZONE_LOCAL_MACHINE) &&
                 (dwZoneIDCaller != URLZONE_TRUSTED)))
            {
                hrReason = E_ACCESSDENIED;        
            }

            ClearInterface(&pISM);
        }
    }

    //
    // Handle a bad error -- friendly error page
    // is handled with BINDSTATUS_BEGINDOWNLOADDATA
    //
    if (hrReason && hrReason != E_ABORT && hrReason != INET_E_TERMINATED_BIND)
    {
        HandleFailedNavigation(hrReason);
    }

    if (hrReason || _fBindAbort)
    {
        CLSID clsid;
        HRESULT hrUrlmon = S_OK;

        if (_u.pbinding && GetErrorStatusCode() == HTTP_STATUS_NO_CONTENT)
        {
            HandleFailedNavigation(S_OK);
            SignalDone(INET_E_DATA_NOT_AVAILABLE);
        }
        else
        {        
            if (_u.pbinding)
                IGNORE_HR(_u.pbinding->GetBindResult(&clsid, (DWORD *)&hrUrlmon, &pchError, NULL));

            // NB: URLMON returns a native Win32 error.
            if (SUCCEEDED(hrUrlmon))
                hrUrlmon = HRESULT_FROM_WIN32(hrUrlmon);

            if (!SUCCEEDED(hrUrlmon))
            {
                SignalDone(hrUrlmon);
            }
            else
            {
                SignalDone(hrReason);
            }

            if ( hrReason == INET_E_DOWNLOAD_FAILURE && IsGlobalOffline() )
            {
                _hrErr =  hrReason ; // store the original error result.
            }            
        }
    }
    else if (!_fBindNotIntercepted)
    {
        //
        // OnStopBinding has been called before OnProgress or OnDataAvaiable
        // the bind may have been intercepted - we can tell when we return from BindToStorage
        //
        _fBindMayBeIntercepted = TRUE;

        //
        // Special case for navigation javascript: navigation within security=restricted 
        // OnStopBind gets called, after the bind is done, 
        // but OnProgress, OnDataAvailable don't get called
        //
        // TODO: urlmon should tell us in a better way that this wasn't allowed due to security
        // 
        CMarkup* pMarkup = _pDwnDoc->GetMarkup();
        CWindow* pWindow = pMarkup ? pMarkup->GetWindowedMarkupContext()->GetWindowPending()->Window() : NULL ;

        if ( pWindow &&
             pWindow->_fRestricted)
        {                    
            SignalDone(INET_E_DATA_NOT_AVAILABLE);
        }
    }
    else
    {
        SetPending(FALSE);
        SignalData();
    }

    SubRelease();
    CoTaskMemFree(pchError);

    PerfDbgLog(tagDwnBindData, this, "-CDwnBindData::OnStopBinding");
    PerfDbgLog(tagPerfWatch, this, "-CDwnBindData::OnStopBinding");
    return(S_OK);
}

//+---------------------------------------------------------------
//
//  Member   : CDwnBindData::VerifyResource
//
//  Synopsis : This method checks if an url points to an UNC
//             and if so, ensures that it's alive so we can 
//             go to shdocvw.
//----------------------------------------------------------------

HRESULT
CDwnBindData::VerifyResource()
{
    HRESULT hr = INET_E_RESOURCE_NOT_FOUND;
    TCHAR szPath[MAX_PATH];
    DWORD dwLen = ARRAY_SIZE(szPath);

    if (SUCCEEDED(PathCreateFromUrl(CMarkup::GetUrl(_pDwnDoc->GetMarkup()), szPath, &dwLen, 0))
        && PathIsUNC(szPath))
    {
        DWORD dwRes;
        HANDLE hEnum;
        PTSTR psz = szPath + 2;
        while (*psz && *psz!=TEXT('\\'))
            psz++;

        if (!*psz || !*(psz+1))
        {
#ifdef UNICODE
            if (g_dwPlatformID==VER_PLATFORM_WIN32_NT)
            {
#endif
                NETRESOURCE nr = {RESOURCE_GLOBALNET,RESOURCETYPE_ANY,
                        RESOURCEDISPLAYTYPE_GENERIC, RESOURCEUSAGE_CONTAINER,
                        NULL, szPath, NULL, NULL};

                dwRes = WNetOpenEnum(RESOURCE_GLOBALNET, RESOURCETYPE_ANY,
                        RESOURCEUSAGE_ALL, &nr, &hEnum);
#ifdef UNICODE
            }
            else
            {
                CHAR szPathA[MAX_PATH];
                SHUnicodeToAnsi(szPath, szPathA, ARRAY_SIZE(szPath));

                {
                    NETRESOURCEA nr = {RESOURCE_GLOBALNET,RESOURCETYPE_ANY,
                            RESOURCEDISPLAYTYPE_GENERIC, RESOURCEUSAGE_CONTAINER,
                            NULL, szPathA, NULL, NULL};

                    dwRes = WNetOpenEnumA(RESOURCE_GLOBALNET, RESOURCETYPE_ANY,
                            RESOURCEUSAGE_ALL, &nr, &hEnum);
                }
            }
#endif
            if (WN_SUCCESS==dwRes)
            {
                WNetCloseEnum(hEnum);
                hr = INET_E_REDIRECT_TO_DIR;
            }
        }
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member : DontAddToMRU
//
//  Synopsis : parallel to the docHost function of the same name.
//
//----------------------------------------------------------------------------

void 
CDwnBindData::DontAddToMRU()
{
    IDockingWindow    * pdw  = NULL;
    IOleCommandTarget * poct = NULL;
    IServiceProvider  * psp  = NULL;

    if (   _pDwnDoc->GetCDoc()->_pShellBrowser 
        && SUCCEEDED(_pDwnDoc->GetCDoc()->_pShellBrowser->QueryInterface(IID_IServiceProvider, 
                                                                       (LPVOID*)&psp)))
    {
        if (   psp
            && SUCCEEDED(psp->QueryService(SID_SExplorerToolbar, 
                                           IID_IDockingWindow, 
                                           (LPVOID*)&pdw)))
        {
            if (SUCCEEDED(pdw->QueryInterface(IID_IOleCommandTarget, (LPVOID*)&poct)))
            {
                // Get the URL we were navigating to
                CVariant cvarURL;

                cvarURL.vt      = VT_BSTR;
                V_BSTR(&cvarURL) = SysAllocString (CMarkup::GetUrl(_pDwnDoc->GetMarkup()));

                poct->Exec(&CGID_Explorer, SBCMDID_ERRORPAGE, 0, &cvarURL, NULL);
            }
        }
    }

    ReleaseInterface(poct);
    ReleaseInterface(pdw);
    ReleaseInterface(psp);
}

//+---------------------------------------------------------------
//
//  Member   : CDwnBindData::HandleFailedNavigation
//
//  Synopsis : This method alerts the client site of a download
//             error. If the given error code is 0, the HTTP
//             status code will be retrieved and sent to the
//             client site instead.
// 
//  Input    : hrReason - the binding error or HTTP status code.
//
//  Note     : This method builds a SafeArray that is sent
//             to the client site. Here is the format of the
//             SafeArray. (See CMarkup::DoAutoSearch.)
//
//             pos  data                            type
//             ---  -----------------------------   ----------
//             0    error code                      VT_I4
//             1    pending URL                     VT_BSTR
//             2    IBinding interface              VT_UNKNOWN
//             3    current window's IHTMLWindow2   VT_UNKNOWN
//             4    flag - do autosearch or show
//                  friendly error page             VT_BOOL
//
//----------------------------------------------------------------

void
CDwnBindData::HandleFailedNavigation(HRESULT hrReason)
{
    COmWindowProxy * pWindowPending = NULL;

    if (!_pDwnDoc || !_pDwnDoc->GetCDoc())
    {
        goto Cleanup;
    }

    //
    // Send SBCMDID_CANCELNAVIGATION ( to show offline cancel dialog if necessary ).
    //
    if ((hrReason == INET_E_DOWNLOAD_FAILURE) && IsGlobalOffline())
    {
        IGNORE_HR(CTExec(_pDwnDoc->GetCDoc()->_pClientSite,  &CGID_Explorer,
                     SBCMDID_CANCELNAVIGATION, 0, NULL, NULL ));
    } 

    if (!_pDwnDoc->GetMarkup())
        goto Cleanup;

    if (   _fBindAbort
        || !_fIsDocBind
        || !_pDwnLoad
        || !_pDwnDoc->GetCDoc()->_pClientSite
        || (   hrReason == E_ABORT
            && IsSpecialUrl(CMarkup::GetUrl(_pDwnDoc->GetMarkup()))))
    {
        if (hrReason==INET_E_RESOURCE_NOT_FOUND)
        {
            hrReason = VerifyResource();
        }

        // if we ever get attatched to an element, call this function again!
        if (   hrReason
            && hrReason != INET_E_REDIRECT_TO_DIR
            && hrReason != HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY))
        {
            _hrReasonForFailedNavigation      = hrReason;
            _fHandleFailedNavigationOnAttatch = TRUE;
        }

        goto Cleanup;
    }
   
    // If the binding didn't fail, find out if there
    // was a WinInet error (e.g., 404 - file not found).
    //
    if (!hrReason)
    {
        hrReason = GetErrorStatusCode();

        if (!hrReason || hrReason == HTTP_STATUS_NO_CONTENT)
        {
            goto Cleanup;
        }
    }

    if (IsErrorHandled(hrReason))
    {
        _pDwnDoc->GetMarkup()->NoteErrorWebPage();
        if (_DwnProg.dwPos > _GetErrorThreshold(hrReason))
        {
            // Mimic shdocvw behavior. We only navigate to the error page - if we get 
            // below a certain threshold. Beyond the threshhold - we display the data
            // that we received.
            // 
            // (carled) this also include NOT adding this url to the MRU
            //
            DontAddToMRU();

            _pDwnDoc->GetMarkup()->_fServerErrorPage = TRUE;

            _pDwnDoc->GetCDoc()->_webOCEvents.NavigateError(_pDwnDoc->GetMarkup(), hrReason);

            hrReason = S_OK;
            goto Cleanup;
        }
    }

    pWindowPending = _pDwnDoc->GetMarkup()->GetWindowPending();

    if (!pWindowPending)
        goto Cleanup;
    
    Assert(pWindowPending->_pWindow);

    _pDwnDoc->GetMarkup()->DoAutoSearch(hrReason, pWindowPending->_pWindow, _u.pbinding);
    
Cleanup:
    if (   _pDwnDoc 
        && _pDwnDoc->GetCDoc()
        && _pDwnDoc->GetMarkup()
        && !_pDwnDoc->GetCDoc()->_fStartup
        && (!hrReason || (E_ABORT == hrReason)))
    {
        _pDwnDoc->GetMarkup()->ResetSearchInfo();
    }
}

//
// When an http error occurs the server generally returns a page.  The
// threshold value this function returns is used to determine if the
// server page is displayed (if the size of the returned page is greater than
// the threshold) or if an internal error page is shown (if the returned page
// is smaller than the threshold).
//

DWORD _GetErrorThreshold(DWORD dwError)
{
    DWORD dwRet;

    TCHAR szValue[11]; // Should be large enough to hold max dword 4294967295
    DWORD cbValue = sizeof(szValue)/sizeof(szValue[0]) ;
    DWORD cbdwRet = sizeof(dwRet);
    DWORD dwType  = REG_DWORD;

    wnsprintf(szValue, cbValue, TEXT("%d"), dwError);

    if (ERROR_SUCCESS != SHRegGetUSValue(REGSTR_PATH_THRESHOLDS, szValue,
                                         &dwType, (LPVOID)&dwRet, &cbdwRet,
                                         FALSE, NULL, 0))
    {
        dwRet = 512; // hard coded default size if all else fails.
    }

    return dwRet;
}

//
// NB - the table of errors that are handled is in shdocvw
// this needs to be kept in sync
//

BOOL
IsErrorHandled(DWORD dwError)
{
    switch(dwError)
    {
        case 404:
        case 400:
        case 403:
        case 405:
        case 406:
        case 408:
        case 409:
        case 410:
        case 500:
        case 501:
        case 505:
        case ERRORPAGE_DNS:
        case ERRORPAGE_SYNTAX:
        case ERRORPAGE_NAVCANCEL:
        case ERRORPAGE_OFFCANCEL:
        case ERRORPAGE_CHANNELNOTINCACHE:
            return TRUE;

        default: 
            return FALSE;
    }
}    
//+---------------------------------------------------------------
//
//  Member:     CDwnBindData::GetStatusCode
//
//  Synopsis:   Retrieves the HTTP status code from WinInet.
//
//----------------------------------------------------------------

DWORD
CDwnBindData::GetErrorStatusCode() const
{
    HRESULT  hr;
    DWORD    dwStatusCode = 0L;
    ULONG    cch = sizeof(DWORD);
    IWinInetHttpInfo * pWinInetHttpInfo = NULL;

    hr = _u.pbinding->QueryInterface(IID_IWinInetHttpInfo,
                                     (void**)&pWinInetHttpInfo);
    if (hr)
        goto Cleanup;

    IGNORE_HR(pWinInetHttpInfo->QueryInfo(HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
                                          &dwStatusCode, &cch, NULL, 0));
    if (!dwStatusCode)
    {
        goto Cleanup;
    }

    if (HTTP_STATUS_NO_CONTENT == dwStatusCode)
        goto Cleanup;

    if (  dwStatusCode < HTTP_STATUS_BAD_REQUEST )
        dwStatusCode = 0L;

    if ( dwStatusCode > HTTP_STATUS_LAST)
        dwStatusCode = 0L;
    
Cleanup:
    ReleaseInterface(pWinInetHttpInfo);

    return dwStatusCode;
}
    
BOOL
UrlIsFtpDirectory(const TCHAR * pchUrl)
{
    if (UrlIs(pchUrl, URLIS_DIRECTORY))
        return TRUE;

    // (#109598) Check if there is a file extension. If none found, treat as a directory. Sure, this
    // is a hack, but it emulates the behavior in FtpItemID_CreateFake() in shell\ext\ftp\ftppidl.cpp

    CStr    cstrPath;
    TCHAR * pchLastItem;

    if (S_OK != GetUrlComponentHelper(pchUrl, &cstrPath, ICU_DECODE | URL_ESCAPE_SPACES_ONLY | URL_BROWSER_MODE, URLCOMP_PATHNAME))
        return FALSE;

    pchLastItem = StrRChr(cstrPath, NULL, _T('/'));
    if (!pchLastItem)
    {
        pchLastItem = cstrPath;
    }
    else
    {
        pchLastItem++;
        if (!*pchLastItem)
            return TRUE;
    }

    // Get the traling part of the path in the Url.
    return !*PathFindExtension(pchLastItem);
}

// *** IE Media Bar Hook *** 
// This stores the media mime-type as a string on the bind ctx.
// This is a hook for the IE Media Bar, so that when navigation
// is delegated to shdocvw, the media bar can catch media urls.
// This approach is needed because (as per VenkatK) the mime-type 
// cannot be curently obtained from the bind ctx after delegating 
// to shdocvw.
void 
CDwnBindData::SetMediaMimeOnBindCtx(LPCWSTR pstrMimeType, IBindCtx * pbc)
{
    // do it only for audio or video
    if (    pbc
        &&  pstrMimeType
        &&  (   !StrCmpNIW(pstrMimeType, _T("audio"), 5)
             || !StrCmpNIW(pstrMimeType, _T("video"), 5)))
    {
        CStr cstrMime;
        
        HRESULT hr = cstrMime.Set(pstrMimeType);
        if (FAILED(hr))
            goto done;
        
        hr = AddBindContextParam(pbc, &cstrMime, NULL, _T("MediaBarMime"));
        if (FAILED(hr))
            goto done;
    }

done:
    return;
}



STDMETHODIMP
CDwnBindData::OnDataAvailable(DWORD grfBSCF, DWORD dwSize,
    FORMATETC * pformatetc, STGMEDIUM * pstgmed)
{    

    PerfDbgLog(tagPerfWatch, this, "+CDwnBindData::OnDataAvailable");
    PerfDbgLog5(tagDwnBindData, this, "+CDwnBindData::OnDataAvailable %c%c%c%c %ld",
        (grfBSCF & BSCF_FIRSTDATANOTIFICATION) ? 'F' : ' ',
        (grfBSCF & BSCF_INTERMEDIATEDATANOTIFICATION) ? 'I' : ' ',
        (grfBSCF & BSCF_LASTDATANOTIFICATION) ? 'L' : ' ',
        (grfBSCF & BSCF_DATAFULLYAVAILABLE) ? 'A' : ' ',
        dwSize);

    CMarkup * pMarkup = _pDwnDoc? _pDwnDoc->GetMarkup(): NULL;

    Assert(_fBindOnApt && CheckThread());
    
    BindingNotIntercepted();

    HRESULT hr = S_OK;
    
    if (pstgmed->tymed == TYMED_ISTREAM)
    {
        ReplaceInterface(&_u.pstm, pstgmed->pstm);
        ReplaceInterface(&_u.punkForRel, pstgmed->pUnkForRelease);
    }

    if (grfBSCF & (BSCF_DATAFULLYAVAILABLE|BSCF_LASTDATANOTIFICATION))
    {
        _fFullyAvail = TRUE;

        // Clients assume that they can find out how many bytes are fully
        // available in the callback to SignalHeaders.  Fill it in here if
        // we haven't already.

        if (_DwnProg.dwMax == 0)
            _DwnProg.dwMax = dwSize;
    }

    if (!_fSigHeaders)
    {
        _fSigHeaders = TRUE;
        SignalHeaders(_u.pbinding);
    }

    if (!_fSigMime)
    {
        _fSigMime = TRUE;

        if (_pmi == NULL)
            _pmi = GetMimeInfoFromClipFormat(pformatetc->cfFormat);

        BOOL fIsActiveDesktopComponent = FALSE;
        if (pMarkup && pMarkup->IsActiveDesktopComponent())
        {
            fIsActiveDesktopComponent = TRUE;
        }

        // Don't delegate if this is the primary markup and we have no tob web OC to delegate to.
        BOOL fPrimaryMarkupAndNoWebOC = pMarkup?( pMarkup->HasPrimaryWindow() && !_pDwnDoc->GetCDoc()->_pTopWebOC ):TRUE;

        // TODO: (jbeda) All of this stuff should be on the other side of the signal -- that is what
        // it is there for!
        if ( _fIsDocBind && !_fBindAbort && !fPrimaryMarkupAndNoWebOC &&    
             (    _pmi == NULL
               || !StrCmpIC(_pmi->pch, CFSTR_MIME_AVI)
               || !StrCmpIC(_pmi->pch, CFSTR_MIME_X_MSVIDEO)
               || !StrCmpIC(_pmi->pch, CFSTR_MIME_MPEG)
               || !StrCmpIC(_pmi->pch, CFSTR_MIME_QUICKTIME)
               || (!StrCmpIC(_pmi->pch, CFSTR_MIME_HTA) && 
                        !(_pDwnDoc->GetCDoc()->_dwCompat & URLCOMPAT_ALLOWBIND))
               || (! IsHtcDownload()  &&
                    _pmi == g_pmiTextComponent  ) )  // cancel for non HTC-download ( ie. click on hyperlink to HTC)
                
                   
               || (_uScheme == URL_SCHEME_FTP && 
                   _pDwnDoc && 
                   _pDwnDoc->GetDocReferer()  &&

                   //
                   // cancel if we're going to show a directory
                   //
                   UrlIsFtpDirectory(CMarkup::GetUrl(pMarkup)))
               || fIsActiveDesktopComponent
               || _fDelegateDownload )
        {
            if (_pmi != NULL || (pMarkup && !pMarkup->_fPrecreated))
            {
                hr = INET_E_TERMINATED_BIND;

                // This stores the media mime-type as a string on the bind ctx.
                // This is a hook for the IE Media Bar, so that when navigation
                // is delegated to shdocvw, the media bar can catch media urls.
                // This approach is needed because (as per VenkatK) the mime-type 
                // cannot be curently obtained from the bind ctx after delegating 
                // to shdocvw.
                if (_pmi)
                {
                    SetMediaMimeOnBindCtx(_pmi->pch, _u.pbc);
                }

                // Set the bind ctx on the pending window so that we
                // can send it to shdocvw when delegating the navigation.
                //
                if (pMarkup && pMarkup->HasWindowPending())
                {
                    pMarkup->GetWindowPending()->Window()->SetBindCtx(_u.pbc);
                }

                if (pMarkup)
                {
                    pMarkup->_fIsActiveDesktopComponent = fIsActiveDesktopComponent;
                }

                goto Cleanup;
            }
        }

        Signal(DBF_MIME);
    }

    SetPending(FALSE);
    SignalData();

Cleanup:
    PerfDbgLog(tagDwnBindData, this, "-CDwnBindData::OnDataAvailable");
    PerfDbgLog(tagPerfWatch, this, "-CDwnBindData::OnDataAvailable");
    RRETURN(hr);
}

// CDwnBindData (IHttpNegotiate) ----------------------------------------------

STDMETHODIMP
CDwnBindData::OnResponse(DWORD dwResponseCode, LPCWSTR szResponseHeaders,
    LPCWSTR szRequestHeaders, LPWSTR * ppszAdditionalRequestHeaders)
{
    PerfDbgLog(tagDwnBindData, this, "+CDwnBindData::OnResponse");
    Assert(CheckThread());

    PerfDbgLog(tagDwnBindData, this, "-CDwnBindData::OnResponse (hr=0)");
    return(S_OK);
}

// CDwnBindData (IInternetBindInfo) -------------------------------------------

STDMETHODIMP
CDwnBindData::GetBindInfo(DWORD * pdwBindf, BINDINFO * pbindinfo)
{
    PerfDbgLog(tagDwnBindData, this, "+CDwnBindData::GetBindInfo");
    Assert(CheckThread());

    HRESULT hr;

    hr = THR(super::GetBindInfo(pdwBindf, pbindinfo));

    if (hr == S_OK)
    {
        if (!_fBindOnApt)
            *pdwBindf |= BINDF_DIRECT_READ;

        if (_dwFlags & DWNF_ENFORCERESTRICTED)
            *pdwBindf |= BINDF_ENFORCERESTRICTED;

        if (_dwFlags & DWNF_IGNORESECURITY)
            *pdwBindf |= BINDF_IGNORESECURITYPROBLEM;
    }

    PerfDbgLog1(tagDwnBindData, this, "-CDwnBindData::GetBindInfo (hr=%lX)", hr);
    RRETURN(hr);
}

// CDwnBindData (IInternetProtocolSink) ---------------------------------------

STDMETHODIMP
CDwnBindData::Switch(PROTOCOLDATA * ppd)
{
    PerfDbgLog(tagDwnBindData, this, "+CDwnBindData::Switch");

    HRESULT hr;

    if (!_pDwnDoc || _pDwnDoc->IsDocThread())
    {
        hr = THR(_o.pInetProt->Continue(ppd));
    }
    else
    {
        hr = THR(_pDwnDoc->AddDocThreadCallback(this, ppd));
    }

    PerfDbgLog1(tagDwnBindData, this, "-CDwnBindData::Switch (hr=%lX)", hr);
    RRETURN(hr);
}

STDMETHODIMP
CDwnBindData::ReportProgress(ULONG ulCode, LPCWSTR pszText)
{
    PerfDbgLog2(tagDwnBindData, this, "+CDwnBindData::ReportProgress %s \"%ls\"",
        g_rgpchBindStatus[ulCode], pszText ? pszText : g_Zero.ach);

    SubAddRef();

    CDoc * pDoc = _pDwnDoc ? _pDwnDoc->GetCDoc() : NULL;

    switch (ulCode)
    {        
        case BINDSTATUS_COOKIE_SENT:            
            if(pszText && *pszText && pDoc)
            {
                TraceTag((tagDwnBindPrivacy, "CDwnBindData::ReportProgress - Received BINDSTATUS_COOKIE_SENT for url %ls", pszText));
                THR(pDoc->AddToPrivacyList(pszText, NULL, COOKIEACTION_READ)); 
            }
            else
            {
                TraceTag((tagDwnBindPrivacy, "CDwnBindData::ReportProgress - Received BINDSTATUS_COOKIE_SENT for url %ls", _achUrl));
                _dwPrivacyFlags |= COOKIEACTION_READ;
            }
            break;

        case BINDSTATUS_COOKIE_SUPPRESSED:            
            if(pszText && *pszText && pDoc)
            {
                TraceTag((tagDwnBindPrivacy, "CDwnBindData::ReportProgress - Received BINDSTATUS_COOKIE_SUPPRESSED for url %ls", pszText));
                THR(pDoc->AddToPrivacyList(pszText, NULL, COOKIEACTION_SUPPRESS)); 
            }
            else
            {
                TraceTag((tagDwnBindPrivacy, "CDwnBindData::ReportProgress - Received BINDSTATUS_COOKIE_SUPPRESSED for url %ls", _achUrl));
                _dwPrivacyFlags |= COOKIEACTION_SUPPRESS;
            }
            break;

        case BINDSTATUS_COOKIE_STATE_UNKNOWN:
            TraceTag((tagDwnBindPrivacy, "Trident should never BINDSTATUS_COOKIE_STATE_UNKNOWN from Wininet/Urlmon for url %ls", _achUrl));
            break;
        case BINDSTATUS_COOKIE_STATE_ACCEPT:            
            if(pszText && *pszText && pDoc)
            {
                TraceTag((tagDwnBindPrivacy, "CDwnBindData::ReportProgress - Received BINDSTATUS_COOKIE_STATE_ACCEPT for url %ls", pszText));
                THR(pDoc->AddToPrivacyList(pszText, NULL, COOKIEACTION_ACCEPT)); 
            }
            else
            {
                TraceTag((tagDwnBindPrivacy, "CDwnBindData::ReportProgress - Received BINDSTATUS_COOKIE_STATE_ACCEPT for url %ls", _achUrl));
                _dwPrivacyFlags |= COOKIEACTION_ACCEPT;
            }
            break;
        case BINDSTATUS_COOKIE_STATE_REJECT:            
            if(pszText && *pszText && pDoc)
            {
                TraceTag((tagDwnBindPrivacy, "CDwnBindData::ReportProgress - Received BINDSTATUS_COOKIE_STATE_REJECT for url %ls", pszText));
                THR(pDoc->AddToPrivacyList(pszText, NULL, COOKIEACTION_REJECT)); 
            }
            else
            {
                TraceTag((tagDwnBindPrivacy, "CDwnBindData::ReportProgress - Received BINDSTATUS_COOKIE_STATE_REJECT for url %ls", _achUrl));
                _dwPrivacyFlags |= COOKIEACTION_REJECT;
            }
            break;
        case BINDSTATUS_COOKIE_STATE_LEASH:            
            if(pszText && *pszText && pDoc)
            {
                TraceTag((tagDwnBindPrivacy, "CDwnBindData::OnProgress - Received BINDSTATUS_COOKIE_STATE_LEASH for url %ls", pszText));
                THR(pDoc->AddToPrivacyList(pszText, NULL, COOKIEACTION_LEASH)); 
            }
            else
            {
                TraceTag((tagDwnBindPrivacy, "CDwnBindData::OnProgress - Received BINDSTATUS_COOKIE_STATE_LEASH for url %ls", _achUrl));
                _dwPrivacyFlags |= COOKIEACTION_LEASH;
            }
            break;
        case BINDSTATUS_COOKIE_STATE_DOWNGRADE:            
            if(pszText && *pszText && pDoc)
            {
                TraceTag((tagDwnBindPrivacy, "CDwnBindData::OnProgress - Received BINDSTATUS_COOKIE_STATE_DOWNGRADE for url %ls", pszText));
                THR(pDoc->AddToPrivacyList(pszText, NULL, COOKIEACTION_DOWNGRADE)); 
            }
            else
            {
                TraceTag((tagDwnBindPrivacy, "CDwnBindData::OnProgress - Received BINDSTATUS_COOKIE_STATE_DOWNGRADE for url %ls", _achUrl));
                _dwPrivacyFlags |= COOKIEACTION_DOWNGRADE;
            }
            break;
            
        case BINDSTATUS_COMPACT_POLICY_RECEIVED:
            _dwPrivacyFlags |= PRIVACY_URLHASCOMPACTPOLICY;
            break;
        
        case BINDSTATUS_POLICY_HREF:
            TraceTag((tagDwnBindPrivacy, "CDwnBindData::ReportProgress - Received BINDSTATUS_POLICY_HREF for url %ls", _achUrl));
            Assert(pszText && *pszText);
            _tcscpy(_achPolicyRef, pszText);
            _dwPrivacyFlags |= PRIVACY_URLHASPOLICYREFHEADER;
            break;
        case BINDSTATUS_P3P_HEADER:
            TraceTag((tagDwnBindPrivacy, "CDwnBindData::ReportProgress - Received BINDSTATUS_P3P_HEADER for url %ls", _achUrl));
            Assert(pszText && *pszText);
            {
                // We are getting two notifications from urlmon, once that is fixed, need to uncomment this assert
                //Assert(!_pchP3PHeader);
                delete [] _pchP3PHeader;

                unsigned len = _tcslen(pszText);
                _pchP3PHeader = new(Mt(CDwnBindData_pchP3PHeader)) TCHAR[len + 1];
                if (_pchP3PHeader)
                {
                    _tcscpy(_pchP3PHeader, pszText);
                    _pchP3PHeader[len] = _T('\0');
                }
                _dwPrivacyFlags |= PRIVACY_URLHASP3PHEADER;
            }
            break;

        case BINDSTATUS_REDIRECTING:
            SignalRedirect(pszText, _o.pInetProt);
            break;

        case BINDSTATUS_CACHEFILENAMEAVAILABLE:
            SignalFile(pszText);
            break;

        case BINDSTATUS_RAWMIMETYPE:
            _pRawMimeInfo = GetMimeInfoFromMimeType(pszText);
            _fReceivedMimeNotification = TRUE;
            break;

        case BINDSTATUS_MIMETYPEAVAILABLE:
            _pmi = GetMimeInfoFromMimeType(pszText);
            _fReceivedMimeNotification = TRUE;
            if (StrCmpIC(pszText,_T("text/xml")) == 0)
                _pDwnDoc->SetDocIsXML(TRUE);
            break;

        case BINDSTATUS_LOADINGMIMEHANDLER:
            _fMimeFilter = TRUE;
            break;

        case BINDSTATUS_FINDINGRESOURCE:
        case BINDSTATUS_CONNECTING:
            SignalProgress(0, 0, ulCode);
            break;
    }

    SubRelease();
   
    PerfDbgLog(tagDwnBindData, this, "-CDwnBindData::ReportProgress (hr=0)");
    return(S_OK);
}

STDMETHODIMP
CDwnBindData::ReportData(DWORD grfBSCF, ULONG ulPos, ULONG ulMax)
{
    PerfDbgLog6(tagDwnBindData, this, "+CDwnBindData::ReportData %c%c%c%c ulPos=%ld ulMax=%ld", 
        (grfBSCF & BSCF_FIRSTDATANOTIFICATION) ? 'F' : ' ',
        (grfBSCF & BSCF_INTERMEDIATEDATANOTIFICATION) ? 'I' : ' ',
        (grfBSCF & BSCF_LASTDATANOTIFICATION) ? 'L' : ' ',
        (grfBSCF & BSCF_DATAFULLYAVAILABLE) ? 'A' : ' ',
        ulPos, ulMax);

    SubAddRef();

    if (grfBSCF & (BSCF_DATAFULLYAVAILABLE|BSCF_LASTDATANOTIFICATION))
    {
        _fFullyAvail = TRUE;

        // Clients assume that they can find out how many bytes are fully
        // available in the callback to SignalHeaders.  Fill it in here if
        // we haven't already.

        if (_DwnProg.dwMax == 0)
            _DwnProg.dwMax = ulMax;
    }

    if (!_fSigHeaders)
    {
        _fSigHeaders = TRUE;
        SignalHeaders(_o.pInetProt);
    }

    if (!_fSigData)
    {
        _fSigData = TRUE;

        Assert(_pDwnStm == NULL);

        // If the data is coming from the network, then read it immediately
        // into a buffers in order to release the socket connection as soon
        // as possible.

        if (    !_fFullyAvail
            &&  (_uScheme == URL_SCHEME_HTTP || _uScheme == URL_SCHEME_HTTPS)
            &&  !(_dwFlags & (DWNF_DOWNLOADONLY|DWNF_NOAUTOBUFFER)))
        {
            // No problem if this fails.  We just end up not buffering.

            _pDwnStm = new CDwnStm;
        }
    }

    if (!_fSigMime)
    {
        _fSigMime = TRUE;
        Signal(DBF_MIME);
    }

    SignalProgress(ulPos, ulMax, BINDSTATUS_DOWNLOADINGDATA);

    SetPending(FALSE);
    SignalData();

    SubRelease();

    PerfDbgLog(tagDwnBindData, this, "-CDwnBindData::ReportData (hr=0)");
    return(S_OK);
}

STDMETHODIMP
CDwnBindData::ReportResult(HRESULT hrResult, DWORD dwError, LPCWSTR szResult)
{
    PerfDbgLog3(tagDwnBindData, this, "+CDwnBindData::ReportResult (hrErr=%lX,"
        "dwErr=%ld,szRes=%ls)", hrResult, dwError,
        szResult ? szResult : g_Zero.ach);

    SubAddRef();

    _fBindDone = TRUE;

    if (hrResult || _fBindAbort)
    {
        // Mimics urlmon's GetBindResult
        if (dwError)
            hrResult = HRESULT_FROM_WIN32(dwError);

        SignalDone(hrResult);
    }
    else
    {
        SetPending(FALSE);
        SignalData();
    }

    SubRelease();

    PerfDbgLog(tagDwnBindData, this, "-CDwnBindData::ReportResult (hr=0)");
    return(S_OK);
}

// Public Functions -----------------------------------------------------------

HRESULT
NewDwnBindData(DWNLOADINFO * pdli, CDwnBindData ** ppDwnBindData,
    DWORD dwFlagsExtra)
{
    HRESULT hr = S_OK;

    if (pdli->pDwnBindData)
    {
        *ppDwnBindData = pdli->pDwnBindData;
        pdli->pDwnBindData->SetDwnDoc(pdli->pDwnDoc);
        pdli->pDwnBindData->SetStartedInPending(pdli->fPendingRoot);
        pdli->pDwnBindData->AddRef();
        return(S_OK);
    }

    PerfDbgLog(tagDwnBindData, NULL, "+NewDwnBindData");

    CDwnBindData * pDwnBindData = new CDwnBindData;

    if (pDwnBindData == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pDwnBindData->SetDwnDoc(pdli->pDwnDoc);
    pDwnBindData->SetDwnPost(pdli->pDwnPost);
    pDwnBindData->SetHtcDownload( ( dwFlagsExtra & DWNF_HTCDOWNLOAD ) != 0 );
    pDwnBindData->SetStartedInPending(pdli->fPendingRoot);
    
    if (pdli->fOffline)
        pDwnBindData->SetIsOfflineBind();

    pDwnBindData->Bind(pdli, dwFlagsExtra);

    *ppDwnBindData = pDwnBindData;
    pDwnBindData = NULL;

Cleanup:
    if (pDwnBindData)
        pDwnBindData->Release();
    PerfDbgLog1(tagDwnBindData, NULL, "-NewDwnBindData (hr=%lX)", hr);
    RRETURN(hr);
}

// TlsGetInternetSession ------------------------------------------------------

IInternetSession *
TlsGetInternetSession()
{
    IInternetSession * pInetSess = TLS(pInetSess);

    if (pInetSess == NULL)
    {
        IGNORE_HR(CoInternetGetSession(0, &pInetSess, 0));
        TLS(pInetSess) = pInetSess;

        if (pInetSess)
        {
            pInetSess->RegisterNameSpace((IClassFactory *) &g_cfResProtocol, CLSID_ResProtocol, _T("res"), 0, NULL, 0);
            pInetSess->RegisterNameSpace((IClassFactory *) &g_cfAboutProtocol, CLSID_AboutProtocol, _T("about"), 0, NULL, 0);
            pInetSess->RegisterNameSpace((IClassFactory *) &g_cfViewSourceProtocol, CLSID_ViewSourceProtocol, _T("view-source"), 0, NULL, 0);
        }
    }

    return(pInetSess);
}


//-------------------------------------------------------------
//
// marka - some vintage code from shdocvw
// to tickle dialmon periodically
//
//-------------------------------------------------------------

#define AUTODIAL_MONITOR_CLASS_NAME     TEXT("MS_AutodialMonitor")
#define WEBCHECK_MONITOR_CLASS_NAME     TEXT("MS_WebcheckMonitor")
#define WM_DIALMON_FIRST        WM_USER+100

// message sent to dial monitor app window indicating that there has been
// winsock activity and dial monitor should reset its idle timer
#define WM_WINSOCK_ACTIVITY             WM_DIALMON_FIRST + 0


static const TCHAR szAutodialMonitorClass[] = AUTODIAL_MONITOR_CLASS_NAME;
static const TCHAR szWebcheckMonitorClass[] = WEBCHECK_MONITOR_CLASS_NAME;

#define MIN_ACTIVITY_MSG_INTERVAL       15000

VOID IndicateWinsockActivity(VOID)
{
    // if there is an autodisconnect monitor, send it an activity message
    // so that we don't get disconnected during long downloads.  For perf's sake,
    // don't send a message any more often than once every MIN_ACTIVITY_MSG_INTERVAL
    // milliseconds (15 seconds).  Use GetTickCount to determine interval;
    // GetTickCount is very cheap.
    DWORD dwTickCount = GetTickCount();
    // Sharing this among multiple threads is OK
    static DWORD dwLastActivityMsgTickCount = 0;
    DWORD dwElapsed = dwTickCount - dwLastActivityMsgTickCount;

    // have we sent an activity message recently?
    if (dwElapsed > MIN_ACTIVITY_MSG_INTERVAL) 
    {
        HWND hwndMonitorApp = FindWindow(szAutodialMonitorClass,NULL);
        if (hwndMonitorApp) 
        {
            PostMessage(hwndMonitorApp,WM_WINSOCK_ACTIVITY,0,0);
        }
        hwndMonitorApp = FindWindow(szWebcheckMonitorClass,NULL);
        if (hwndMonitorApp) 
        {
            PostMessage(hwndMonitorApp,WM_WINSOCK_ACTIVITY,0,0);
        }

        // record the tick count of the last time we sent an
        // activity message
        dwLastActivityMsgTickCount = dwTickCount;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\download\dwntask.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       dwntask.cxx
//
//  Contents:   CDwnTask
//				CDwnTaskExec
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DWN_HXX_
#define X_DWN_HXX_
#include "dwn.hxx"
#endif

#ifndef X_SWITCHES_HXX_
#define X_SWITCHES_HXX_
#include "switches.hxx"
#endif

// Debugging ------------------------------------------------------------------

PerfDbgTag(tagDwnTask,            "Dwn", "Trace CDwnTask")
PerfDbgTag(tagDwnTaskExec,        "Dwn", "Trace CDwnTaskExec")
PerfDbgTag(tagDwnTaskExecVerbose, "Dwn", "Trace CDwnTaskExec (Verbose)")
PerfDbgTag(tagDwnTaskExec10Sec,   "Dwn", "! Timeout download threads in 10 sec")

MtDefine(CDwnTaskExec, Dwn, "CDwnTaskExec")

// Globals --------------------------------------------------------------------

CDwnTaskExec *   g_pDwnTaskExec = NULL;

// CDwnTask -------------------------------------------------------------------

void
CDwnTask::Passivate()
{
    PerfDbgLog(tagDwnTask, this, "+CDwnTask::Passivate");

    Terminate();
    super::Passivate();

    PerfDbgLog(tagDwnTask, this, "-CDwnTask::Passivate");
}

// CDwnTaskExec ---------------------------------------------------------------

CDwnTaskExec::CDwnTaskExec(CRITICAL_SECTION * pcs)
    : super(pcs)
{
    // This object will be destroyed on DllProcessDetach, so its existence
    // should not prevent the DLL from being unloaded.  This next call
    // undoes what CBaseFT::CBaseFT did.

    DecrementSecondaryObjectCount(10);
}

CDwnTaskExec::~CDwnTaskExec()
{
    // This next call temporarily puts back a secondary reference that
    // CBaseFT::~CBaseFT will decrement.

    IncrementSecondaryObjectCount(10);
}

void
CDwnTaskExec::AddTask(CDwnTask * pDwnTask)
{
    PerfDbgLog1(tagDwnTaskExec, this, "+CDwnTaskExec::AddTask %lX", pDwnTask);

    BOOL fSignal = FALSE;

    EnterCriticalSection();

    #if DBG==1
    Invariant();
    #endif

    Assert(!pDwnTask->_fEnqueued);
    Assert(!pDwnTask->_pDwnTaskExec);

    pDwnTask->_pDwnTaskExec = this;
    pDwnTask->_pDwnTaskNext = NULL;
    pDwnTask->_pDwnTaskPrev = _pDwnTaskTail;
    pDwnTask->_fEnqueued    = TRUE;
    pDwnTask->SubAddRef();

    if (_pDwnTaskTail)
        _pDwnTaskTail = _pDwnTaskTail->_pDwnTaskNext = pDwnTask;
    else
        _pDwnTaskHead = _pDwnTaskTail = pDwnTask;

    if (pDwnTask->_fActive)
    {
        fSignal = (_cDwnTaskActive == 0);
        _cDwnTaskActive += 1;
    }

    _cDwnTask += 1;

    #if DBG==1
    Invariant();
    #endif

    LeaveCriticalSection();

    if (fSignal)
    {
        Verify(SetEvent(_hevWait));
    }

    PerfDbgLog(tagDwnTaskExec, this, "+CDwnTaskExec::AddTask");
}

void
CDwnTaskExec::SetTask(CDwnTask * pDwnTask, BOOL fActive)
{
    PerfDbgLog2(tagDwnTaskExec, this, "+CDwnTaskExec::SetTask %lX %s", pDwnTask, fActive ? "Active" : "Blocked");

    BOOL fSignal = FALSE;

    EnterCriticalSection();

    #if DBG==1
    Invariant();
    #endif

    if (pDwnTask->_fEnqueued)
    {
        if (pDwnTask == _pDwnTaskRun)
        {
            // Making a running task active always wins ... the task will
            // run from the top at least one more time.

            if (_ta != TA_DELETE)
            {
                if (fActive)
                    _ta = TA_ACTIVATE;
                else if (_ta != TA_ACTIVATE)
                    _ta = TA_BLOCK;
            }
        }
        else if (!!fActive != !!pDwnTask->_fActive)
        {
            pDwnTask->_fActive = fActive;

            if (fActive)
            {
                fSignal = (_cDwnTaskActive == 0);
                _cDwnTaskActive += 1;
            }
            else
            {
                _cDwnTaskActive -= 1;
            }
        }
    }

    #if DBG==1
    Invariant();
    #endif

    LeaveCriticalSection();

    if (fSignal && GetThreadId() != GetCurrentThreadId())
    {
        Verify(SetEvent(_hevWait));
    }

    PerfDbgLog(tagDwnTaskExec, this, "-CDwnTaskExec::SetTask");
}

void
CDwnTaskExec::DelTask(CDwnTask * pDwnTask)
{
    PerfDbgLog1(tagDwnTaskExec, this, "+CDwnTaskExec::DelTask %lX", pDwnTask);

    BOOL fRelease = FALSE;

    EnterCriticalSection();

    #if DBG==1
    Invariant();
    #endif

    if (pDwnTask->_fEnqueued)
    {
        if (pDwnTask == _pDwnTaskRun)
        {
            _ta = TA_DELETE;
        }
        else
        {
            if (pDwnTask->_pDwnTaskPrev)
                pDwnTask->_pDwnTaskPrev->_pDwnTaskNext = pDwnTask->_pDwnTaskNext;
            else
                _pDwnTaskHead = pDwnTask->_pDwnTaskNext;

            if (pDwnTask->_pDwnTaskNext)
                pDwnTask->_pDwnTaskNext->_pDwnTaskPrev = pDwnTask->_pDwnTaskPrev;
            else
                _pDwnTaskTail = pDwnTask->_pDwnTaskPrev;

            if (pDwnTask->_fActive)
            {
                _cDwnTaskActive -= 1;
            }

            _cDwnTask -= 1;

            if (_pDwnTaskCur == pDwnTask)
                _pDwnTaskCur = pDwnTask->_pDwnTaskNext;

            pDwnTask->_fEnqueued = FALSE;
            fRelease = TRUE;
        }
    }

    #if DBG==1
    Invariant();
    #endif

    LeaveCriticalSection();

    if (fRelease)
        pDwnTask->SubRelease();

    PerfDbgLog(tagDwnTaskExec, this, "-CDwnTaskExec::DelTask");
}

BOOL
CDwnTaskExec::IsTaskTimeout()
{
    return(_fShutdown || (GetTickCount() - _dwTickRun > _dwTickSlice));
}

HRESULT
CDwnTaskExec::Launch()
{
    PerfDbgLog(tagDwnTaskExec, this, "+CDwnTaskExec::Launch");

    HRESULT hr;

    _hevWait = CreateEventA(NULL, FALSE, FALSE, NULL);

    if (_hevWait == NULL)
    {
        hr = 