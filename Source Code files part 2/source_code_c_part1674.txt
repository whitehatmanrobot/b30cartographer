
#define OutputDebugStringA(pszMsg)  (MyDebugPrint(DEBUG_PREFIX, "%hs", pszMsg))
#define OutputDebugStringW(pszMsg)  (MyDebugPrint(DEBUG_PREFIX, "%ls", pszMsg))

#if !defined(_M_ALPHA) && !defined(_M_IA64)
    #define InterlockedIncrement        DrvInterlockedIncrement
    #define InterlockedDecrement        DrvInterlockedDecrement
#endif


#define SetLastError                NOP_FUNCTION
#define GetLastError                NOP_FUNCTION



////////////////////////////////////////////////////////
//      Kernel Mode Functions
////////////////////////////////////////////////////////

//
// Implement inline functions to replace user mode 
// functions that don't have kernel mode equivalents.
//


inline int __cdecl _purecall (void)
{
#ifdef DEBUG
    EngDebugBreak();
#endif

    return E_FAIL;
}


inline LONG DrvInterlockedIncrement(PLONG pRef)
{
    ENTER_CRITICAL_SECTION();

        ++(*pRef);

    LEAVE_CRITICAL_SECTION();


    return (*pRef);
}


inline LONG DrvInterlockedDecrement(PLONG pRef)
{
    ENTER_CRITICAL_SECTION();

        --(*pRef);

    LEAVE_CRITICAL_SECTION();


    return (*pRef);
}


inline void* __cdecl operator new(size_t nSize)
{
    // return pointer to allocated memory
    return  EngAllocMem(0, nSize, DRV_MEM_POOL_TAG);
}


inline void __cdecl operator delete(void *pMem)
{
    if(pMem)
        EngFreeMem(pMem);
}


inline VOID MyDebugPrint(PCHAR pszPrefix, PCHAR pszFormat, ...)
{
    va_list VAList;

    va_start(VAList, pszFormat);
    EngDebugPrint(DEBUG_PREFIX, pszFormat, VAList);
    va_end(VAList);

    return;
}



#endif // USERMODE_DRIVER


#endif // _KMODE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemps\precomp.h ===
//    
//
//  PURPOSE:	Header files that should be in the precompiled header.

//
//  PLATFORMS:
//    Windows NT
//
//
#ifndef _PRECOMP_H
#define _PRECOMP_H


// Necessary for compiling under VC.
#if(!defined(WINVER) || (WINVER < 0x0500))
	#undef WINVER
	#define WINVER          0x0500
#endif
#if(!defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500))
	#undef _WIN32_WINNT
	#define _WIN32_WINNT    0x0500
#endif

// Polymorphic types for Win32/Win64
// These don't exist for NT4.
#ifdef WINNT_40
    #define ULONG_PTR   ULONG
#endif


// Required header files that shouldn't change often.

#include <STDDEF.H>
#include <STDLIB.H>
#ifdef OEMCOM
  #include <OBJBASE.H>
#endif
#include <STDARG.H>
#include <STDIO.H>
#include <WINDEF.H>
#include <WINERROR.H>
#include <WINBASE.H>
#include <WINGDI.H>
extern "C" 
{
    #include <WINDDI.H>
}
#include <TCHAR.H>
#include <EXCPT.H>
#include <ASSERT.H>
#include <PRINTOEM.H>


#define COUNTOF(p)  (sizeof(p)/sizeof(*(p)))


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemps\enable.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Enable.cpp
//    
//
//  PURPOSE:  Enable routines for User Mode COM Customization DLL.
//
//
//	Functions:
//
//		
//
//
//  PLATFORMS:	Windows NT
//
//

#include "precomp.h"
#include "debug.h"
#include "oemps.h"



////////////////////////////////////////////////////////
//      Internal Constants
////////////////////////////////////////////////////////

///////////////////////////////////////////////////////
// Warning: the following array order must match the 
//          order in enum ENUMHOOKS.
///////////////////////////////////////////////////////
static const DRVFN OEMHookFuncs[] =
{
    { INDEX_DrvRealizeBrush,                (PFN) OEMRealizeBrush               },
    { INDEX_DrvCopyBits,                    (PFN) OEMCopyBits                   },
    { INDEX_DrvBitBlt,                      (PFN) OEMBitBlt                     },
    { INDEX_DrvStretchBlt,                  (PFN) OEMStretchBlt                 },
    { INDEX_DrvTextOut,                     (PFN) OEMTextOut                    },
    { INDEX_DrvStrokePath,                  (PFN) OEMStrokePath                 },
    { INDEX_DrvFillPath,                    (PFN) OEMFillPath                   },
    { INDEX_DrvStrokeAndFillPath,           (PFN) OEMStrokeAndFillPath          },
    { INDEX_DrvStartPage,                   (PFN) OEMStartPage                  },
    { INDEX_DrvSendPage,                    (PFN) OEMSendPage                   },
    { INDEX_DrvEscape,                      (PFN) OEMEscape                     },
    { INDEX_DrvStartDoc,                    (PFN) OEMStartDoc                   },
    { INDEX_DrvEndDoc,                      (PFN) OEMEndDoc                     },
    { INDEX_DrvQueryFont,                   (PFN) OEMQueryFont                  },
    { INDEX_DrvQueryFontTree,               (PFN) OEMQueryFontTree              },
    { INDEX_DrvQueryFontData,               (PFN) OEMQueryFontData              },
    { INDEX_DrvQueryAdvanceWidths,          (PFN) OEMQueryAdvanceWidths         },
    { INDEX_DrvFontManagement,              (PFN) OEMFontManagement             },
    { INDEX_DrvGetGlyphMode,                (PFN) OEMGetGlyphMode               },
#ifndef WINNT_40
    { INDEX_DrvStretchBltROP,               (PFN) OEMStretchBltROP              },
    { INDEX_DrvPlgBlt,                      (PFN) OEMPlgBlt                     },
    { INDEX_DrvTransparentBlt,              (PFN) OEMTransparentBlt             },
    { INDEX_DrvAlphaBlend,                  (PFN) OEMAlphaBlend                 },
    { INDEX_DrvGradientFill,                (PFN) OEMGradientFill               },
    { INDEX_DrvIcmCreateColorTransform,     (PFN) OEMIcmCreateColorTransform    },
    { INDEX_DrvIcmDeleteColorTransform,     (PFN) OEMIcmDeleteColorTransform    },
    { INDEX_DrvQueryDeviceSupport,          (PFN) OEMQueryDeviceSupport         },
#endif
};







PDEVOEM APIENTRY OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded        // Unidrv's hook table
    )
{
    POEMPDEV    poempdev;
    INT         i, j;
    DWORD       dwDDIIndex;
    PDRVFN      pdrvfn;

    VERBOSE(DLLTEXT("OEMEnablePDEV() entry.\r\n"));

    //
    // Allocate the OEMDev
    //
    poempdev = new OEMPDEV;
    if (NULL == poempdev)
    {
        return NULL;
    }

    //
    // Fill in OEMDEV as you need
    //

    //
    // Fill in OEMDEV
    //

    for (i = 0; i < MAX_DDI_HOOKS; i++)
    {
        //
        // search through Unidrv's hooks and locate the function ptr
        //
        dwDDIIndex = OEMHookFuncs[i].iFunc;
        for (j = pded->c, pdrvfn = pded->pdrvfn; j > 0; j--, pdrvfn++)
        {
            if (dwDDIIndex == pdrvfn->iFunc)
            {
                poempdev->pfnPS[i] = pdrvfn->pfn;
                break;
            }
        }
        if (j == 0)
        {
            //
            // didn't find the Unidrv hook. Should happen only with DrvRealizeBrush
            //
            poempdev->pfnPS[i] = NULL;
        }

    }

    return (POEMPDEV) poempdev;
}


VOID APIENTRY OEMDisablePDEV(
    PDEVOBJ pdevobj
    )
{
    VERBOSE(DLLTEXT("OEMDisablePDEV() entry.\r\n"));


    //
    // Free memory for OEMPDEV and any memory block that hangs off OEMPDEV.
    //
    assert(NULL != pdevobj->pdevOEM);
    delete pdevobj->pdevOEM;
}


BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew
    )
{
    VERBOSE(DLLTEXT("OEMResetPDEV() entry.\r\n"));


    //
    // If you want to carry over anything from old pdev to new pdev, do it here.
    //

    return TRUE;
}


VOID APIENTRY OEMDisableDriver()
{
    VERBOSE(DLLTEXT("OEMDisableDriver() entry.\r\n"));
}


BOOL APIENTRY OEMEnableDriver(DWORD dwOEMintfVersion, DWORD dwSize, PDRVENABLEDATA pded)
{
    VERBOSE(DLLTEXT("OEMEnableDriver() entry.\r\n"));

    // List DDI functions that are hooked.
    pded->iDriverVersion =  PRINTER_OEMINTF_VERSION;
    pded->c = sizeof(OEMHookFuncs) / sizeof(DRVFN);
    pded->pdrvfn = (DRVFN *) OEMHookFuncs;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemui\devmode.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Devmode.h
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for devmode functions.
//
//  PLATFORMS:
//
//    Windows NT
//
//
#ifndef _DEVMODE_H
#define _DEVMODE_H


////////////////////////////////////////////////////////
//      OEM Devmode Defines
////////////////////////////////////////////////////////




////////////////////////////////////////////////////////
//      OEM Devmode Type Definitions
////////////////////////////////////////////////////////

typedef struct tagOEMDEV
{
    OEM_DMEXTRAHEADER   dmOEMExtra;
    BOOL                dwDriverData;

} OEMDEV, *POEMDEV;

typedef const OEMDEV *PCOEMDEV;



/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

HRESULT hrOEMDevMode(DWORD dwMode, POEMDMPARAM pOemDMParam);
BOOL ConvertOEMDevmode(PCOEMDEV pOEMDevIn, POEMDEV pOEMDevOut);
BOOL MakeOEMDevmodeValid(POEMDEV pOEMDevmode);
void Dump(PCOEMDEV pOEMDevIn);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemui\dllentry.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	dllentry.cpp
//    
//
//  PURPOSE:  Source module for DLL entry function(s).
//
//
//	Functions:
//
//		DllMain
//
//
//  PLATFORMS:	Windows NT
//
//

#include "precomp.h"
#include "oemui.h"
#include "debug.h"



// Need to export these functions as c declarations.
extern "C" {


///////////////////////////////////////////////////////////
//
// DLL entry point
//
BOOL WINAPI DllMain(HINSTANCE hInst, WORD wReason, LPVOID lpReserved)
{
	switch(wReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(DLLTEXT("Process attach.\r\n"));
            ghInstance = hInst;
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(DLLTEXT("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(DLLTEXT("Process detach.\r\n"));
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(DLLTEXT("Thread detach.\r\n"));
			break;
	}

	return TRUE;
}


}  // extern "C" closing bracket
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemui\globals.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Globals.cpp
//    
//
//  PURPOSE:  File that contains all the globals.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows NT
//
//
#define _GLOBALS_H

#include "precomp.h"
#include "oemui.h"



///////////////////////////////////////
//          Globals
///////////////////////////////////////

// Module's Instance handle from DLLEntry of process.
HINSTANCE   ghInstance = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemui\globals.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Globals.h
//    
//
//  PURPOSE:   Lists of globals declared in Globals.cpp.
//
//
//  PLATFORMS:
//
//    Windows NT
//
//
#ifndef _GLOBALS_H
#define _GLOBALS_H


///////////////////////////////////////
//          Globals
///////////////////////////////////////

// Module's Instance handle from DLLEntry of process.
extern HINSTANCE   ghInstance;




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemps\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by OEMPS.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemui\oem.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997, 1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debug.cpp.
//
//  PLATFORMS:
//    Windows NT
//
//
#ifndef _OEM_H
#define _OEM_H



////////////////////////////////////////////////////////
//      OEM Defines
////////////////////////////////////////////////////////

#define OEM_SIGNATURE   'MSFT'
#define OEM_VERSION     0x00000001L



////////////////////////////////////////////////////////
//      OEM Type Definitions
////////////////////////////////////////////////////////



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemps\oemps.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997, 1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	OEMPS.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debug.cpp.
//
//  PLATFORMS:
//    Windows NT
//
//
#ifndef _OEMPS_H
#define _OEMPS_H

#include "OEM.H"
#include "DEVMODE.H"


////////////////////////////////////////////////////////
//      OEM Defines
////////////////////////////////////////////////////////

#define DLLTEXT(s)      __TEXT("OEMPS:  ") __TEXT(s)
#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)


///////////////////////////////////////////////////////
// Warning: the following enum order must match the 
//          order in OEMHookFuncs[].
///////////////////////////////////////////////////////
typedef enum tag_Hooks {
    UD_DrvRealizeBrush,
    UD_DrvCopyBits,
    UD_DrvBitBlt,
    UD_DrvStretchBlt,
    UD_DrvTextOut,
    UD_DrvStrokePath,
    UD_DrvFillPath,
    UD_DrvStrokeAndFillPath,
    UD_DrvStartPage,
    UD_DrvSendPage,
    UD_DrvEscape,
    UD_DrvStartDoc,
    UD_DrvEndDoc,
    UD_DrvQueryFont,
    UD_DrvQueryFontTree,
    UD_DrvQueryFontData,
    UD_DrvQueryAdvanceWidths,
    UD_DrvFontManagement,
    UD_DrvGetGlyphMode,
    UD_DrvStretchBltROP,
    UD_DrvPlgBlt,
    UD_DrvTransparentBlt,
    UD_DrvAlphaBlend,
    UD_DrvGradientFill,
    UD_DrvIcmCreateColorTransform,
    UD_DrvIcmDeleteColorTransform,
    UD_DrvQueryDeviceSupport,

    MAX_DDI_HOOKS,

} ENUMHOOKS;


typedef struct _OEMPDEV {
    //
    // define whatever needed, such as working buffers, tracking information,
    // etc.
    //
    // This test DLL hooks out every drawing DDI. So it needs to remember
    // PS's hook function pointer so it call back.
    //
    PFN     pfnPS[MAX_DDI_HOOKS];

    //
    // define whatever needed, such as working buffers, tracking information,
    // etc.
    //
    DWORD     dwReserved[1];

} OEMPDEV, *POEMPDEV;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemui\devmode.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Devmode.cpp
//    
//
//  PURPOSE:  Implementation of Devmode functions shared with OEM UI and OEM rendering modules.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows NT
//
//

#include "precomp.h"
#include "oemui.h"
#include "debug.h"
#include "devmode.h"



HRESULT hrOEMDevMode(DWORD dwMode, POEMDMPARAM pOemDMParam)
{
    POEMDEV pOEMDevIn;
    POEMDEV pOEMDevOut;


    // Verify parameters.
    if( (NULL == pOemDMParam)
        ||
        ( (OEMDM_SIZE != dwMode)
          &&
          (OEMDM_DEFAULT != dwMode)
          &&
          (OEMDM_CONVERT != dwMode)
          &&
          (OEMDM_MERGE != dwMode)
        )
      )
    {
        ERR(ERRORTEXT("DevMode() ERROR_INVALID_PARAMETER.\r\n"));
        VERBOSE(DLLTEXT("\tdwMode = %d, pOemDMParam = %#lx.\r\n"), dwMode, pOemDMParam);

        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    // Cast generic (i.e. PVOID) to OEM private devomode pointer type.
    pOEMDevIn = (POEMDEV) pOemDMParam->pOEMDMIn;
    pOEMDevOut = (POEMDEV) pOemDMParam->pOEMDMOut;

    switch(dwMode)
    {
        case OEMDM_SIZE:
            pOemDMParam->cbBufSize = sizeof(OEMDEV);
            break;

        case OEMDM_DEFAULT:
            pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
            pOEMDevOut->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
            pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
            pOEMDevOut->dwDriverData            = 0;
            VERBOSE(DLLTEXT("pOEMDevOut after setting default values:\r\n"));
            Dump(pOEMDevOut);
            break;

        case OEMDM_CONVERT:
            ConvertOEMDevmode(pOEMDevIn, pOEMDevOut);
            break;

        case OEMDM_MERGE:
            ConvertOEMDevmode(pOEMDevIn, pOEMDevOut);
            MakeOEMDevmodeValid(pOEMDevOut);
            break;
    }
    Dump(pOemDMParam);

    return S_OK;
}


BOOL ConvertOEMDevmode(PCOEMDEV pOEMDevIn, POEMDEV pOEMDevOut)
{
    if( (NULL == pOEMDevIn)
        ||
        (NULL == pOEMDevOut)
      )
    {
        ERR(ERRORTEXT("ConvertOEMDevmode() invalid parameters.\r\n"));
        return FALSE;
    }

    // Check OEM Signature, if it doesn't match ours,
    // then just assume DMIn is bad and use defaults.
    if(pOEMDevIn->dmOEMExtra.dwSignature == pOEMDevOut->dmOEMExtra.dwSignature)
    {
        VERBOSE(DLLTEXT("Converting private OEM Devmode.\r\n"));
        VERBOSE(DLLTEXT("pOEMDevIn:\r\n"));
        Dump(pOEMDevIn);

        // Set the devmode defaults so that anything the isn't copied over will
        // be set to the default value.
        pOEMDevOut->dwDriverData = 0;

        // Copy the old structure in to the new using which ever size is the smaller.
        // Devmode maybe from newer Devmode (not likely since there is only one), or
        // Devmode maybe a newer Devmode, in which case it maybe larger,
        // but the first part of the structure should be the same.

        // DESIGN ASSUMPTION: the private DEVMODE structure only gets added to;
        // the fields that are in the DEVMODE never change only new fields get added to the end.

        memcpy(pOEMDevOut, pOEMDevIn, __min(pOEMDevOut->dmOEMExtra.dwSize, pOEMDevIn->dmOEMExtra.dwSize));

        // Re-fill in the size and version fields to indicated 
        // that the DEVMODE is the current private DEVMODE version.
        pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
        pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
    }
    else
    {
        WARNING(DLLTEXT("Unknown DEVMODE signature, pOEMDMIn ignored.\r\n"));

        // Don't know what the input DEVMODE is, so just use defaults.
        pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
        pOEMDevOut->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
        pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
        pOEMDevOut->dwDriverData            = 0;
    }

    return TRUE;
}


BOOL MakeOEMDevmodeValid(POEMDEV pOEMDevmode)
{
    if(NULL == pOEMDevmode)
    {
        return FALSE;
    }

    // ASSUMPTION: pOEMDevmode is large enough to contain OEMDEV structure.

    // Make sure that dmOEMExtra indicates the current OEMDEV structure.
    pOEMDevmode->dmOEMExtra.dwSize       = sizeof(OEMDEV);
    pOEMDevmode->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
    pOEMDevmode->dmOEMExtra.dwVersion    = OEM_VERSION;

    // Set driver data, if not valid.
    if(pOEMDevmode->dwDriverData > 100)
    {
        pOEMDevmode->dwDriverData = 0;
    }

    return TRUE;
}


void Dump(PCOEMDEV pOEMDevmode)
{
    if( (NULL != pOEMDevmode)
        &&
        (pOEMDevmode->dmOEMExtra.dwSize >= sizeof(OEMDEV))
        &&
        (OEM_SIGNATURE == pOEMDevmode->dmOEMExtra.dwSignature)
      )
    {
        VERBOSE(__TEXT("\tdmOEMExtra.dwSize      = %d\r\n"), pOEMDevmode->dmOEMExtra.dwSize);
        VERBOSE(__TEXT("\tdmOEMExtra.dwSignature = %#x\r\n"), pOEMDevmode->dmOEMExtra.dwSignature);
        VERBOSE(__TEXT("\tdmOEMExtra.dwVersion   = %#x\r\n"), pOEMDevmode->dmOEMExtra.dwVersion);
        VERBOSE(__TEXT("\tdwDriverData           = %#x\r\n"), pOEMDevmode->dwDriverData);
    }
    else
    {
        ERR(ERRORTEXT("Dump(POEMDEV) unknown private OEM DEVMODE.\r\n"));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemps\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.inc

    Abstract:

        This file specifies the target component being built and the list of
        sources files needed to build that component.  Also specifies optional
        compiler switches and libraries that are unique for the component being
        built.

!ENDIF

DLLBASE=0x70000000

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj


# To build version with debug output, add -DDEBUG to C_DEFINES line below
!if defined(WINNT_40)       # NT4 kernel-mode driver
C_DEFINES=$(C_DEFINES) -DKERNEL_MODE -D_UNICODE -DUNICODE -DWINNT_40 -DOEMCOM
!else                       # NT5 Drivers
C_DEFINES=$(C_DEFINES) -DKERNEL_MODE -D_UNICODE -DUNICODE -DOEMCOM
!endif



TARGETLIBS=  $(SDK_LIB_PATH)\uuid.lib


INCLUDES=..;$(SDK_INC_PATH)\MFC42

SOURCES= ..\dllentry.cpp    \
         ..\intrface.cpp    \
         ..\command.cpp     \
         ..\ddihook.cpp     \
         ..\debug.cpp       \
         ..\devmode.cpp     \
         ..\enable.cpp      \
         ..\oemps.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemuni\debug.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.cpp
//    
//
//  PURPOSE:  Debug functions.
//
//
//	Functions:
//
//
//
//  PLATFORMS:	Windows NT, Windows 2000
//
//

#include "precomp.h"
#include "oem.h"
#include "debug.h"
#include "kmode.h"



////////////////////////////////////////////////////////
//      INTERNAL DEFINES
////////////////////////////////////////////////////////

#define DEBUG_BUFFER_SIZE       1024
#define PATH_SEPARATOR          '\\'



// Determine what level of debugging messages to eject. 
#ifdef VERBOSE_MSG
    #define DEBUG_LEVEL     DBG_VERBOSE
#elif TERSE_MSG
    #define DEBUG_LEVEL     DBG_TERSE
#elif WARNING_MSG
    #define DEBUG_LEVEL     DBG_WARNING
#elif ERROR_MSG
    #define DEBUG_LEVEL     DBG_ERROR
#elif RIP_MSG
    #define DEBUG_LEVEL     DBG_RIP
#elif NO_DBG_MSG
    #define DEBUG_LEVEL     DBG_NONE
#else
    #define DEBUG_LEVEL     DBG_WARNING
#endif



////////////////////////////////////////////////////////
//      EXTERNAL GLOBALS
////////////////////////////////////////////////////////

INT giDebugLevel = DEBUG_LEVEL;




////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist);
static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist);




//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist)
{
    DWORD   dwSize = DEBUG_BUFFER_SIZE;
    LPSTR   lpszMsgBuf = NULL;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    do
    {
        // Allocate memory for message buffer.
        if(NULL != lpszMsgBuf)
        {
            delete[] lpszMsgBuf;
            dwSize *= 2;
        }
        lpszMsgBuf = new CHAR[dwSize + 1];
        if(NULL == lpszMsgBuf)
            return FALSE;

    // Pass the variable parameters to wvsprintf to be formated.
    } while (_vsnprintf(lpszMsgBuf, dwSize, lpszMessage, arglist) < 0);

    // Dump string to Debug output.
    OutputDebugStringA(lpszMsgBuf);

    // Cleanup.
    delete[] lpszMsgBuf;

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist)
{
    LPWSTR     lpszMsgBuf;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    // Allocate memory for message buffer.
    lpszMsgBuf = new WCHAR[dwSize + 1];    
    if(NULL == lpszMsgBuf)
        return FALSE;

    // Pass the variable parameters to wvsprintf to be formated.
    vswprintf(lpszMsgBuf, lpszMessage, arglist);

    // Dump string to debug output.
    OutputDebugStringW(lpszMsgBuf);

    // Clean up.
    delete[] lpszMsgBuf;

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV for processing.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCWSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV to be processed.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(MAX_PATH, lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}

void Dump(PPUBLISHERINFO pPublisherInfo)
{
    VERBOSE(__TEXT("pPublisherInfo:\r\n"));
    VERBOSE(__TEXT("\tdwMode           =   %#x\r\n"), pPublisherInfo->dwMode);
    VERBOSE(__TEXT("\twMinoutlinePPEM  =   %d\r\n"), pPublisherInfo->wMinoutlinePPEM);
    VERBOSE(__TEXT("\twMaxbitmapPPEM   =   %d\r\n"), pPublisherInfo->wMaxbitmapPPEM);
}

void Dump(POEMDMPARAM pOemDMParam)
{
    VERBOSE(__TEXT("pOemDMParam:\r\n"));
    VERBOSE(__TEXT("\tcbSize = %d\r\n"), pOemDMParam->cbSize);
    VERBOSE(__TEXT("\tpdriverobj = %#x\r\n"), pOemDMParam->pdriverobj);
    VERBOSE(__TEXT("\thPrinter = %#x\r\n"), pOemDMParam->hPrinter);
    VERBOSE(__TEXT("\thModule = %#x\r\n"), pOemDMParam->hModule);
    VERBOSE(__TEXT("\tpPublicDMIn = %#x\r\n"), pOemDMParam->pPublicDMIn);
    VERBOSE(__TEXT("\tpPublicDMOut = %#x\r\n"), pOemDMParam->pPublicDMOut);
    VERBOSE(__TEXT("\tpOEMDMIn = %#x\r\n"), pOemDMParam->pOEMDMIn);
    VERBOSE(__TEXT("\tpOEMDMOut = %#x\r\n"), pOemDMParam->pOEMDMOut);
    VERBOSE(__TEXT("\tcbBufSize = %d\r\n"), pOemDMParam->cbBufSize);
}



PCSTR
StripDirPrefixA(
    IN PCSTR    pstrFilename
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    PCSTR   pstr;

    if (pstr = strrchr(pstrFilename, PATH_SEPARATOR))
        return pstr + 1;

    return pstrFilename;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemuni\debug.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debugging functions.
//
//  PLATFORMS:
//
//    Windows NT, Windows 2000
//
//
#ifndef _DEBUG_H
#define _DEBUG_H

#include "kmode.h"


// VC and Build use different debug defines.
// The following makes it so either will
// cause the inclusion of debugging code.
#if !defined(_DEBUG) && defined(DBG)
    #define _DEBUG      DBG
#elif defined(_DEBUG) && !defined(DBG)
    #define DBG         _DEBUG
#endif



/////////////////////////////////////////////////////////
//		Macros
/////////////////////////////////////////////////////////

//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// giDebugLevel
//  Global variable which set the current debug level to control
//  the amount of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ERR(msg)
//  Similiar to WARNING macro above - displays a message
//  if the current debug level is <= DBG_ERROR.
//
// ASSERT(cond)
//  Verify a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//  These macros require extra parantheses for the msg argument
//  example, ASSERTMSG(x > 0, ("x is less than 0\n"));
//           WARNING(("App passed NULL pointer, ignoring...\n"));
//

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_ERROR   4
#define DBG_RIP     5
#define DBG_NONE    6

#if DBG

    #define DebugMsg    DebugMessage

    //
    // Strip the directory prefix from a filename (ANSI version)
    //

    PCSTR
    StripDirPrefixA(
        IN PCSTR    pstrFilename
        );

    extern INT giDebugLevel;


    #define DBGMSG(level, prefix, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg("%s %s (%d): ", prefix, StripDirPrefixA(__FILE__), __LINE__); \
                    DebugMsg(msg); \
                } \
            }

    #define DBGPRINT(level, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg(msg); \
                } \
            }

    #define VERBOSE         if(giDebugLevel <= DBG_VERBOSE) DebugMsg
    #define TERSE           if(giDebugLevel <= DBG_TERSE) DebugMsg
    #define WARNING         if(giDebugLevel <= DBG_WARNING) DebugMsg
    #define ERR             if(giDebugLevel <= DBG_ERROR) DebugMsg

    #define ASSERT(cond) { \
                if (! (cond)) { \
                    RIP(("\n")); \
                } \
            }

    #define ASSERTMSG(cond, msg) { \
                if (! (cond)) { \
                    RIP(msg); \
                } \
            }

    #define RIP(msg) { \
                DBGMSG(DBG_RIP, "RIP", msg); \
                DebugBreak(); \
            }


#else // !DBG

    #define DebugMsg    NOP_FUNCTION

    #define VERBOSE     NOP_FUNCTION
    #define TERSE       NOP_FUNCTION
    #define WARNING     NOP_FUNCTION
    #define ERR         NOP_FUNCTION

    #define ASSERT(cond)

    #define ASSERTMSG(cond, msg)
    #define RIP(msg)
    #define DBGMSG(level, prefix, msg)
    #define DBGPRINT(level, msg)

#endif




/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR, ...);
BOOL DebugMessage(LPCWSTR, ...);
void Dump(PPUBLISHERINFO pPublisherInfo);
void Dump(POEMDMPARAM pOemDMParam);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemui\precomp.h ===
//    
//
//  PURPOSE:	Header files that should be in the precompiled header.

//
//  PLATFORMS:
//    Windows NT
//
//
#ifndef _PRECOMP_H
#define _PRECOMP_H


// Necessary for compiling under VC.
#if(!defined(WINVER) || (WINVER < 0x0500))
	#undef WINVER
	#define WINVER          0x0500
#endif
#if(!defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500))
	#undef _WIN32_WINNT
	#define _WIN32_WINNT    0x0500
#endif

// Polymorphic types for Win32/Win64
// These don't exist for NT4.
#ifdef WINNT_40
    #define ULONG_PTR   ULONG
    #define LONG_PTR    LONG
#endif


// Required header files that shouldn't change often.


#include <STDDEF.H>
#include <STDLIB.H>
#include <OBJBASE.H>
#include <STDARG.H>
#include <STDIO.H>
#include <WINDEF.H>
#include <WINERROR.H>
#include <WINBASE.H>
#include <WINGDI.H>
#include <WINDDI.H>
#include <WINSPOOL.H>
#include <TCHAR.H>
#include <EXCPT.H>
#include <ASSERT.H>
#include <PRSHT.H>
#include "COMPSTUI.H"
#include <WINDDIUI.H>
#include <PRINTOEM.H>

// Define from ntdef.h in Win2K SDK.
// NT 4 may not have this defined
// in the public headers.
#ifndef NOP_FUNCTION
  #if (_MSC_VER >= 1210)
    #define NOP_FUNCTION __noop
  #else
    #define NOP_FUNCTION (void)0
  #endif
#endif


#define COUNTOF(p)  (sizeof(p)/sizeof(*(p)))


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemui\oemui.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    OEMUI.cpp
//    
//
//  PURPOSE:  Main file for OEM UI test module.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 95, Windows NT
//
//

#include "precomp.h"
#include "resource.h"
#include "debug.h"
#include "oemui.h"



////////////////////////////////////////////////////////
//      INTERNAL MACROS and DEFINES
////////////////////////////////////////////////////////

typedef struct _tagCBUserData 
{
    HANDLE          hComPropSheet;
    HANDLE          hPropPage;
    POEMUIPSPARAM   pOEMUIParam;
    PFNCOMPROPSHEET pfnComPropSheet;

} CBUSERDATA, *PCBUSERDATA;



////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static HRESULT hrDocumentPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam);
static HRESULT hrPrinterPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam);
LONG APIENTRY OEMPrinterUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam);
LONG APIENTRY OEMDocUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam);
LONG APIENTRY OEMDocUICallBack(PCPSUICBPARAM pCallbackParam);
BOOL APIENTRY DevicePropPageProc(HWND hDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);
static POPTITEM CreateOptItems(HANDLE hHeap, DWORD dwOptItems);
static void InitOptItems(POPTITEM pOptItems, DWORD dwOptItems);
static POPTTYPE CreateOptType(HANDLE hHeap, WORD wOptParams);
static PTSTR GetStringResource(HANDLE hHeap, HANDLE hModule, UINT uResource);



////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems to display OEM device or document property UI.
//
HRESULT hrOEMPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
    HRESULT hResult = S_OK;


    VERBOSE(DLLTEXT("hrOEMPropertyPage(%d) entry.\r\n"), dwMode);

    // Validate parameters.
    if( (OEMCUIP_DOCPROP != dwMode)
        &&
        (OEMCUIP_PRNPROP != dwMode)        
      )
    {
        ERR(ERRORTEXT("hrOEMPropertyPage() ERROR_INVALID_PARAMETER.\r\n"));
        VERBOSE(DLLTEXT("\tdwMode = %d, pOEMUIParam = %#lx.\r\n"), dwMode, pOEMUIParam);

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    switch(dwMode)
    {
        case OEMCUIP_DOCPROP:
            hResult = hrDocumentPropertyPage(dwMode, pOEMUIParam);
            break;

        case OEMCUIP_PRNPROP:
            hResult = hrPrinterPropertyPage(dwMode, pOEMUIParam);
            break;

        default:
            // Should never reach this!
            ERR(ERRORTEXT("hrOEMPropertyPage() Invalid dwMode, %d"), dwMode);
            SetLastError(ERROR_INVALID_PARAMETER);
            hResult = E_FAIL;
            break;
    }

    return hResult;
}

////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems to display OEM document property UI.
//
static HRESULT hrDocumentPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
    if(NULL == pOEMUIParam->pOEMOptItems)
    {
        // Fill in the number of OptItems to create for OEM document property UI.
        pOEMUIParam->cOEMOptItems = 1;

        VERBOSE(DLLTEXT("hrDocumentPropertyPage() requesting %d number of items.\r\n"), pOEMUIParam->cOEMOptItems);
    }
    else
    {
        POEMDEV pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;


        VERBOSE(DLLTEXT("hrDocumentPropertyPage() fill out %d items.\r\n"), pOEMUIParam->cOEMOptItems);

        // Init UI Callback reference.
        pOEMUIParam->OEMCUIPCallback = OEMDocUICallBack;

        // Init OEMOptItmes.
        InitOptItems(pOEMUIParam->pOEMOptItems, pOEMUIParam->cOEMOptItems);

        // Fill out tree view items.

        // New section.
        pOEMUIParam->pOEMOptItems[0].Level = 1;
        pOEMUIParam->pOEMOptItems[0].Flags = OPTIF_COLLAPSE;
        pOEMUIParam->pOEMOptItems[0].pName = GetStringResource(pOEMUIParam->hOEMHeap, pOEMUIParam->hModule, IDS_SECTION);
        pOEMUIParam->pOEMOptItems[0].Sel = pOEMDev->dwDriverData;

        pOEMUIParam->pOEMOptItems[0].pOptType = CreateOptType(pOEMUIParam->hOEMHeap, 2);

        pOEMUIParam->pOEMOptItems[0].pOptType->Type = TVOT_UDARROW;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].IconID = 0;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].lParam = 100;
    }

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems to display OEM printer property UI.
//
static HRESULT hrPrinterPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
    if(NULL == pOEMUIParam->pOEMOptItems)
    {
        // Fill in the number of OptItems to create for OEM printer property UI.
        pOEMUIParam->cOEMOptItems = 1;

        VERBOSE(DLLTEXT("hrPrinterPropertyPage() requesting %d number of items.\r\n"), pOEMUIParam->cOEMOptItems);
    }
    else
    {
        DWORD   dwError;
        DWORD   dwDeviceValue;
        DWORD   dwType;
        DWORD   dwNeeded;


        VERBOSE(DLLTEXT("hrPrinterPropertyPage() fill out %d items.\r\n"), pOEMUIParam->cOEMOptItems);

        // Get device settings value from printer.
        dwError = GetPrinterData(pOEMUIParam->hPrinter, OEMUI_VALUE, &dwType, (PBYTE) &dwDeviceValue,
                                   sizeof(dwDeviceValue), &dwNeeded);
        if( (ERROR_SUCCESS != dwError)
            ||
            (dwDeviceValue > 100)
          )
        {
            // Failed to get the device value or value is invalid, just use the default.
            dwDeviceValue = 0;
        }

        // Init UI Callback reference.
        pOEMUIParam->OEMCUIPCallback = OEMPrinterUICallBack;

        // Init OEMOptItmes.
        InitOptItems(pOEMUIParam->pOEMOptItems, pOEMUIParam->cOEMOptItems);

        // Fill out tree view items.

        // New section.
        pOEMUIParam->pOEMOptItems[0].Level = 1;
        pOEMUIParam->pOEMOptItems[0].Flags = OPTIF_COLLAPSE;
        pOEMUIParam->pOEMOptItems[0].pName = GetStringResource(pOEMUIParam->hOEMHeap, pOEMUIParam->hModule, IDS_SECTION);
        pOEMUIParam->pOEMOptItems[0].Sel = dwDeviceValue;

        pOEMUIParam->pOEMOptItems[0].pOptType = CreateOptType(pOEMUIParam->hOEMHeap, 2);

        pOEMUIParam->pOEMOptItems[0].pOptType->Type = TVOT_UDARROW;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].IconID = 0;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].lParam = 100;
    }

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//
// Adds property page to Document property sheet.
//
HRESULT hrOEMDocumentPropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam, 
                                    IPrintOemDriverUI*  pOEMHelp)
{
    LONG_PTR    lResult;


    VERBOSE(DLLTEXT("OEMDocumentPropertySheets() entry.\r\n"));

    // Validate parameters.
    if( (NULL == pPSUIInfo)
        ||
        (PROPSHEETUI_INFO_VERSION != pPSUIInfo->Version)
      )
    {
        ERR(ERRORTEXT("OEMDocumentPropertySheets() ERROR_INVALID_PARAMETER.\r\n"));

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return  E_FAIL;
    }

    // Do action.
    switch(pPSUIInfo->Reason)
    {
        case PROPSHEETUI_REASON_INIT:
            {
                DWORD           dwSheets = 0;
                PCBUSERDATA     pUserData;
                POEMUIPSPARAM   pOEMUIParam = (POEMUIPSPARAM) pPSUIInfo->lParamInit;
                HANDLE          hHeap = pOEMUIParam->hOEMHeap;
                POEMDEV         pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;
                COMPROPSHEETUI  Sheet;


                // Init property page.
                memset(&Sheet, 0, sizeof(COMPROPSHEETUI));
                Sheet.cbSize = sizeof(COMPROPSHEETUI);
                Sheet.Flags = CPSUIF_UPDATE_PERMISSION;
                Sheet.hInstCaller = ghInstance;
                Sheet.pCallerName = GetStringResource(hHeap, ghInstance, IDS_NAME);
                Sheet.pHelpFile = NULL;
                Sheet.pfnCallBack = OEMDocUICallBack;
                Sheet.pDlgPage = CPSUI_PDLGPAGE_TREEVIEWONLY;
                Sheet.cOptItem = 1;
                Sheet.IconID = IDI_CPSUI_PRINTER;
                Sheet.pOptItemName = GetStringResource(hHeap, ghInstance, IDS_SECTION);
                Sheet.CallerVersion = 0x100;
                Sheet.OptItemVersion = 0x100;

                // Init user data.
                pUserData = (PCBUSERDATA) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(CBUSERDATA));
                pUserData->hComPropSheet = pPSUIInfo->hComPropSheet;
                pUserData->pfnComPropSheet = pPSUIInfo->pfnComPropSheet;
                pUserData->pOEMUIParam = pOEMUIParam;
                Sheet.UserData = (ULONG_PTR) pUserData;

                // Create OptItems for page.
                Sheet.pOptItem = CreateOptItems(hHeap, Sheet.cOptItem);

                // Initialize OptItems
                Sheet.pOptItem[0].Level = 1;
                Sheet.pOptItem[0].Flags = OPTIF_COLLAPSE;
                Sheet.pOptItem[0].pName = GetStringResource(hHeap, ghInstance, IDS_SECTION);
                Sheet.pOptItem[0].Sel = pOEMDev->dwDriverData;

                Sheet.pOptItem[0].pOptType = CreateOptType(hHeap, 2);

                Sheet.pOptItem[0].pOptType->Type = TVOT_UDARROW;
                Sheet.pOptItem[0].pOptType->pOptParam[1].IconID = 0;
                Sheet.pOptItem[0].pOptType->pOptParam[1].lParam = 100;


                // Add property sheets.
                lResult = pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet, CPSFUNC_ADD_PCOMPROPSHEETUI, 
                                                     (LPARAM)&Sheet, (LPARAM)&dwSheets);
            }
            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:
            {
                PPROPSHEETUI_INFO_HEADER    pHeader = (PPROPSHEETUI_INFO_HEADER) lParam;

                pHeader->pTitle = (LPTSTR)PROP_TITLE;
                lResult = TRUE;
            }
            break;

        case PROPSHEETUI_REASON_GET_ICON:
            // No icon
            lResult = 0;
            break;

        case PROPSHEETUI_REASON_SET_RESULT:
            {
                PSETRESULT_INFO pInfo = (PSETRESULT_INFO) lParam;

                lResult = pInfo->Result;
            }
            break;

        case PROPSHEETUI_REASON_DESTROY:
            lResult = TRUE;
            break;
    }

    pPSUIInfo->Result = lResult;
    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//
// Adds property page to printer property sheet.
//
HRESULT hrOEMDevicePropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam)
{
    LONG_PTR    lResult;


    VERBOSE(DLLTEXT("hrOEMDevicePropertySheets(%#x, %#x) entry\r\n"), pPSUIInfo, lParam);

    // Validate parameters.
    if( (NULL == pPSUIInfo)
        ||
        (PROPSHEETUI_INFO_VERSION != pPSUIInfo->Version)
      )
    {
        ERR(ERRORTEXT("hrOEMDevicePropertySheets() ERROR_INVALID_PARAMETER.\r\n"));

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    Dump(pPSUIInfo);

    // Do action.
    switch(pPSUIInfo->Reason)
    {
        case PROPSHEETUI_REASON_INIT:
            {
                PROPSHEETPAGE   Page;

                // Init property page.
                memset(&Page, 0, sizeof(PROPSHEETPAGE));
                Page.dwSize = sizeof(PROPSHEETPAGE);
                Page.dwFlags = PSP_DEFAULT;
                Page.hInstance = ghInstance;
                Page.pszTemplate = MAKEINTRESOURCE(IDD_DEVICE_PROPPAGE);
                Page.pfnDlgProc = (DLGPROC) DevicePropPageProc;

                // Add property sheets.
                lResult = pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet, CPSFUNC_ADD_PROPSHEETPAGE, (LPARAM)&Page, 0);

                VERBOSE(DLLTEXT("hrOEMDevicePropertySheets() pfnComPropSheet returned %d.\r\n"), lResult);
            }
            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:
            {
                PPROPSHEETUI_INFO_HEADER    pHeader = (PPROPSHEETUI_INFO_HEADER) lParam;

                pHeader->pTitle = (LPTSTR)PROP_TITLE;
                lResult = TRUE;
            }
            break;

        case PROPSHEETUI_REASON_GET_ICON:
            // No icon
            lResult = 0;
            break;

        case PROPSHEETUI_REASON_SET_RESULT:
            {
                PSETRESULT_INFO pInfo = (PSETRESULT_INFO) lParam;

                lResult = pInfo->Result;
            }
            break;

        case PROPSHEETUI_REASON_DESTROY:
            lResult = TRUE;
            break;
    }

    pPSUIInfo->Result = lResult;
    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//
// OptItems call back for OEM printer property UI.
//
LONG APIENTRY OEMPrinterUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam)
{
    LONG    lReturn = CPSUICB_ACTION_NONE;
    POEMDEV pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;


    VERBOSE(DLLTEXT("OEMPrinterUICallBack() entry, Reason is %d.\r\n"), pCallbackParam->Reason);

    switch(pCallbackParam->Reason)
    {
        case CPSUICB_REASON_APPLYNOW:
            {
                DWORD   dwDriverValue = pOEMUIParam->pOEMOptItems[0].Sel;

                // Store OptItems state in printer data.
                SetPrinterData(pOEMUIParam->hPrinter, OEMUI_VALUE, REG_DWORD, (PBYTE) &dwDriverValue, sizeof(DWORD));
            }
            break;

        default:
            break;
    }

    return lReturn;
}


////////////////////////////////////////////////////////////////////////////////
//
// Call back for OEM device property UI.
//
BOOL APIENTRY DevicePropPageProc(HWND hDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uiMsg)
    {
        case WM_COMMAND:
            switch(HIWORD(wParam))
            {
                case BN_CLICKED:
                    switch(LOWORD(wParam))
                    {
                        case IDC_CALIBRATE:
                            // Just display a message that the printer is calibrated,
                            // since we don't acutally calibrate anything.
                            {
                                TCHAR   szName[MAX_PATH];
                                TCHAR   szCalibrated[MAX_PATH];


                                LoadString(ghInstance, IDS_NAME, szName, sizeof(szName));
                                LoadString(ghInstance, IDS_CALIBRATED, szCalibrated, sizeof(szCalibrated));
                                MessageBox(hDlg, szCalibrated, szName, MB_OK);
                            }
                            break;
                    }
                    break;

                default:
                    return FALSE;
            }
            return TRUE;

        case WM_NOTIFY:
            {
                switch (((LPNMHDR)lParam)->code)  // type of notification message
                {
                    case PSN_SETACTIVE:
                        break;
    
                    case PSN_KILLACTIVE:
                        break;

                    case PSN_APPLY:
                        break;

                    case PSN_RESET:
                        break;
                }
            }
            break;
    }

    return FALSE;
} 


////////////////////////////////////////////////////////////////////////////////
//
// OptItems call back for OEM document property UI.
//
LONG APIENTRY OEMDocUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam)
{
    LONG    lReturn = CPSUICB_ACTION_NONE;
    POEMDEV pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;


    VERBOSE(DLLTEXT("OEMDocUICallBack() entry, Reason is %d.\r\n"), pCallbackParam->Reason);

    switch(pCallbackParam->Reason)
    {
        case CPSUICB_REASON_APPLYNOW:
            // Store OptItems state in DEVMODE.
            pOEMDev->dwDriverData = pOEMUIParam->pOEMOptItems[0].Sel;
            break;

        case CPSUICB_REASON_KILLACTIVE:
            pOEMDev->dwDriverData = pOEMUIParam->pOEMOptItems[0].Sel;
            break;

        case CPSUICB_REASON_SETACTIVE:
            pOEMUIParam->pOEMOptItems[0].Sel = pOEMDev->dwDriverData;
            pOEMUIParam->pOEMOptItems[0].Flags |= OPTIF_CHANGED;
            lReturn = CPSUICB_ACTION_OPTIF_CHANGED;
            break;

        default:
            break;
    }

    return lReturn;
}


LONG APIENTRY OEMDocUICallBack(PCPSUICBPARAM pCallbackParam)
{
    LONG            lReturn = CPSUICB_ACTION_NONE;
    PCBUSERDATA     pUserData = (PCBUSERDATA) pCallbackParam->UserData;
    POEMDEV         pOEMDev = (POEMDEV) pUserData->pOEMUIParam->pOEMDM;


    VERBOSE(DLLTEXT("OEMDocUICallBack() entry, Reason is %d.\r\n"), pCallbackParam->Reason);

    switch(pCallbackParam->Reason)
    {
        case CPSUICB_REASON_APPLYNOW:
            pOEMDev->dwDriverData = pCallbackParam->pOptItem[0].Sel;
            pUserData->pfnComPropSheet(pUserData->hComPropSheet, CPSFUNC_SET_RESULT,
            	                       (LPARAM)pUserData->hPropPage,
               	                       (LPARAM)CPSUI_OK);
            break;

        case CPSUICB_REASON_KILLACTIVE:
            pOEMDev->dwDriverData = pCallbackParam->pOptItem[0].Sel;
            break;

        case CPSUICB_REASON_SETACTIVE:
            pCallbackParam->pOptItem[0].Sel = pOEMDev->dwDriverData;
            pCallbackParam->pOptItem[0].Flags |= OPTIF_CHANGED;
            lReturn = CPSUICB_ACTION_OPTIF_CHANGED;
            break;

        default:
            break;
    }

    return lReturn;
}


////////////////////////////////////////////////////////////////////////////////
//
// Creates and Initializes OptItems.
//
static POPTITEM CreateOptItems(HANDLE hHeap, DWORD dwOptItems)
{
    POPTITEM    pOptItems = NULL;


    // Allocate memory for OptItems;
    pOptItems = (POPTITEM) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(OPTITEM) * dwOptItems);
    if(NULL != pOptItems)
    {
        InitOptItems(pOptItems, dwOptItems);
    }
    else
    {
        ERR(ERRORTEXT("CreateOptItems() failed to allocate memory for OPTITEMs!\r\n"));
    }

    return pOptItems;
}


////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems.
//
static void InitOptItems(POPTITEM pOptItems, DWORD dwOptItems)
{
    VERBOSE(DLLTEXT("InitOptItems() entry.\r\n"));

    // Zero out memory.
    memset(pOptItems, 0, sizeof(OPTITEM) * dwOptItems);

    // Set each OptItem's size, and Public DM ID.
    for(DWORD dwCount = 0; dwCount < dwOptItems; dwCount++)
    {
        pOptItems[dwCount].cbSize = sizeof(OPTITEM);
        pOptItems[dwCount].DMPubID = DMPUB_NONE;
    }
}


////////////////////////////////////////////////////////////////////////////////
//
// Allocates and initializes OptType for OptItem.
//
static POPTTYPE CreateOptType(HANDLE hHeap, WORD wOptParams)
{
    POPTTYPE    pOptType = NULL;


    VERBOSE(DLLTEXT("CreateOptType() entry.\r\n"));

    // Allocate memory from the heap for the OPTTYPE; the driver will take care of clean up.
    pOptType = (POPTTYPE) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(OPTTYPE));
    if(NULL != pOptType)
    {
        // Initialize OPTTYPE.
        pOptType->cbSize = sizeof(OPTTYPE);
        pOptType->Count = wOptParams;

        // Allocate memory from the heap for the OPTPARAMs for the OPTTYPE.
        pOptType->pOptParam = (POPTPARAM) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, wOptParams * sizeof(OPTPARAM));
        if(NULL != pOptType->pOptParam)
        {
            // Initialize the OPTPARAMs.
            for(WORD wCount = 0; wCount < wOptParams; wCount++)
            {
                pOptType->pOptParam[wCount].cbSize = sizeof(OPTPARAM);
            }
        }
        else
        {
            ERR(ERRORTEXT("CreateOptType() failed to allocated memory for OPTPARAMs!\r\n"));

            // Free allocated memory and return NULL.
            HeapFree(hHeap, 0, pOptType);
            pOptType = NULL;
        }
    }
    else
    {
        ERR(ERRORTEXT("CreateOptType() failed to allocated memory for OPTTYPE!\r\n"));
    }

    return pOptType;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  Retrieves pointer to a String resource.
//
static PTSTR GetStringResource(HANDLE hHeap, HANDLE hModule, UINT uResource)
{
    int     nResult;
    DWORD   dwSize = MAX_PATH;
    PTSTR   pszString = NULL;


    VERBOSE(DLLTEXT("GetStringResource(%#x, %#x, %d) entered.\r\n"), hHeap, hModule, uResource);

    // Allocate buffer for string resource from heap; let the driver clean it up.
    pszString = (PTSTR) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwSize * sizeof(TCHAR));
    if(NULL != pszString)
    {
        // Load string resource; resize after loading so as not to waste memory.
        nResult = LoadString((HMODULE)hModule, uResource, pszString, dwSize);
        if(nResult > 0)
        {
            PTSTR   pszTemp;


            VERBOSE(DLLTEXT("LoadString() returned %d!\r\n"), nResult);
            VERBOSE(DLLTEXT("String load was \"%s\".\r\n"), pszString);

            pszTemp = (PTSTR) HeapReAlloc(hHeap, HEAP_ZERO_MEMORY, pszString, (nResult + 1) * sizeof(TCHAR));
            if(NULL != pszTemp)
            {
                pszString = pszTemp;
            }
            else
            {
                ERR(ERRORTEXT("GetStringResource() HeapReAlloc() of string retrieved failed! (Last Error was %d)\r\n"), GetLastError());
            }
        }
        else
        {
            ERR(ERRORTEXT("LoadString() returned %d! (Last Error was %d)\r\n"), nResult, GetLastError());
            ERR(ERRORTEXT("GetStringResource() failed to load string resource %d!\r\n"), uResource);

            pszString = NULL;
        }
    }
    else
    {
        ERR(ERRORTEXT("GetStringResource() failed to allocate string buffer!\r\n"));
    }

    return pszString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemui\oemui.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	OEMUI.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for OEMUI Test Module.
//
//  PLATFORMS:
//    Windows 95, Windows NT
//
//
#ifndef _OEMUI_H
#define _OEMUI_H

#include <PRCOMOEM.H>

#include "OEM.H"
#include "DEVMODE.H"
#include "globals.h"


////////////////////////////////////////////////////////
//      OEM UI Defines
////////////////////////////////////////////////////////


// OEM Signature and version.
#define PROP_TITLE      L"OEM UI Page"
#define DLLTEXT(s)      __TEXT("UI:  ") __TEXT(s)

// OEM UI Misc defines.
#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)


// Printer registry keys where OEM data is stored.
#define OEMUI_VALUE             TEXT("OEMUI_VALUE")
#define OEMUI_DEVICE_VALUE      TEXT("OEMUI_DEVICE_VALUE")



////////////////////////////////////////////////////////
//      Prototypes
////////////////////////////////////////////////////////

HRESULT hrOEMPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam);
HRESULT hrOEMDocumentPropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam, IPrintOemDriverUI*  pOEMHelp);
HRESULT hrOEMDevicePropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by OEMUI.rc
//
#define IDS_SECTION                     1
#define IDS_CALIBRATED                  2
#define IDS_NAME                        3
#define IDD_DEVICE_PROPPAGE             106
#define IDD_DOC_PROPPAGE                107
#define IDC_CALIBRATE                   1001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemui\intrface.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2001  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Intrface.cpp
//    
//
//  PURPOSE:  Implementation of interface for PScript4, PScript5, Unidrv4, 
//            Unidrv5 UI plug-ins.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows NT 4, Windows 2000, Windows XP
//
//


#include "precomp.h"
#include <INITGUID.H>
#include <PRCOMOEM.H>

#include "oemui.h"
#include "debug.h"
#include "intrface.h"



////////////////////////////////////////////////////////
//      Internal Globals
////////////////////////////////////////////////////////

static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks



////////////////////////////////////////////////////////////////////////////////
//
// IOemUI body
//
IOemUI::~IOemUI()
{
    // Make sure that helper interface is released.
    if(NULL != m_pOEMHelp)
    {
        m_pOEMHelp->Release();
        m_pOEMHelp = NULL;
    }

    // If this instance of the object is being deleted, then the reference 
    // count should be zero.
    assert(0 == m_cRef);
}

HRESULT __stdcall IOemUI::QueryInterface(const IID& iid, void** ppv)
{    
    VERBOSE(DLLTEXT("IOemUI:QueryInterface entry.\r\n\r\n")); 
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        VERBOSE(DLLTEXT("IOemUI:Return pointer to IUnknown.\r\n\r\n")); 
    }
    else if (iid == IID_IPrintOemUI)
    {
        *ppv = static_cast<IPrintOemUI*>(this) ;
        VERBOSE(DLLTEXT("IOemUI:Return pointer to IPrintOemUI.\r\n")); 
    }
    else
    {
#if DBG
        TCHAR szOutput[80] = {0};
        StringFromGUID2(iid, szOutput, COUNTOF(szOutput)); // can not fail!
        WARNING(DLLTEXT("IOemUI::QueryInterface %s not supported.\r\n"), szOutput); 
#endif

        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemUI::AddRef()
{
    VERBOSE(DLLTEXT("IOemUI:AddRef entry.\r\n")); 
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemUI::Release() 
{
    VERBOSE(DLLTEXT("IOemUI:Release entry.\r\n")); 
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

HRESULT __stdcall IOemUI::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE(DLLTEXT("IOemUI:PublishDriverInterface entry.\r\n")); 

    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (m_pOEMHelp == NULL)
    {
        HRESULT hResult;


        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUI, (void** ) &(m_pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            m_pOEMHelp = NULL;

            return E_FAIL;
        }
    }

    return S_OK;
}

HRESULT __stdcall IOemUI::GetInfo(
    DWORD  dwMode,
    PVOID  pBuffer,
    DWORD  cbSize,
    PDWORD pcbNeeded)
{
    VERBOSE(DLLTEXT("IOemUI::GetInfo(%d) entry.\r\r\n"), dwMode);

    // Validate parameters.
    if( (NULL == pcbNeeded)
        ||
        ( (OEMGI_GETSIGNATURE != dwMode)
          &&
          (OEMGI_GETVERSION != dwMode)
          &&
          (OEMGI_GETPUBLISHERINFO != dwMode)
        )
      )
    {
        WARNING(DLLTEXT("IOemUI::GetInfo() exit pcbNeeded is NULL! ERROR_INVALID_PARAMETER\r\r\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    // Set expected buffer size and number of bytes written.
    *pcbNeeded = sizeof(DWORD);

    // Check buffer size is sufficient.
    if((cbSize < *pcbNeeded) || (NULL == pBuffer))
    {
        WARNING(DLLTEXT("IOemUI::GetInfo() exit insufficient buffer!\r\r\n"));
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return E_FAIL;
    }

    switch(dwMode)
    {
        // OEM DLL Signature
        case OEMGI_GETSIGNATURE:
            *(PDWORD)pBuffer = OEM_SIGNATURE;
            break;

        // OEM DLL version
        case OEMGI_GETVERSION:
            *(PDWORD)pBuffer = OEM_VERSION;
            break;

        // dwMode not supported.
        default:
            // Set written bytes to zero since nothing was written.
            WARNING(DLLTEXT("IOemUI::GetInfo() exit mode not supported.\r\r\n"));
            *pcbNeeded = 0;
            SetLastError(ERROR_NOT_SUPPORTED);
            return E_FAIL;
    }

    VERBOSE(DLLTEXT("IOemUI::GetInfo() exit S_OK, (*pBuffer is %#x).\r\r\n"), *(PDWORD)pBuffer);
    return S_OK;
}

HRESULT __stdcall IOemUI::DevMode(
    DWORD  dwMode,
    POEMDMPARAM pOemDMParam)
{   
    VERBOSE(DLLTEXT("IOemUI:DevMode(%d, %#x) entry.\r\n"), dwMode, pOemDMParam); 

    return hrOEMDevMode(dwMode, pOemDMParam);
}

HRESULT __stdcall IOemUI::CommonUIProp(
    DWORD  dwMode,
    POEMCUIPPARAM   pOemCUIPParam)
{
    VERBOSE(DLLTEXT("IOemUI:CommonUIProp entry.\r\n")); 

    return hrOEMPropertyPage(dwMode, pOemCUIPParam);
}


HRESULT __stdcall IOemUI::DocumentPropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam)
{
    VERBOSE(DLLTEXT("IOemUI:DocumentPropertySheets entry.\r\n")); 

    return hrOEMDocumentPropertySheets(pPSUIInfo, lParam, m_pOEMHelp);
}

HRESULT __stdcall IOemUI::DevicePropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam)
{
    VERBOSE(DLLTEXT("IOemUI:DevicePropertySheets entry.\r\n")); 

    return hrOEMDevicePropertySheets(pPSUIInfo, lParam);
}

HRESULT __stdcall IOemUI::DeviceCapabilities(
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult)
{
    VERBOSE(DLLTEXT("IOemUI:DeviceCapabilities entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUI::DevQueryPrintEx(
    POEMUIOBJ               poemuiobj,
    PDEVQUERYPRINT_INFO     pDQPInfo,
    PDEVMODE                pPublicDM,
    PVOID                   pOEMDM)
{
    VERBOSE(DLLTEXT("IOemUI:DevQueryPrintEx entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUI::UpgradePrinter(
    DWORD   dwLevel,
    PBYTE   pDriverUpgradeInfo)
{
    VERBOSE(DLLTEXT("IOemUI:UpgradePrinter entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUI::PrinterEvent(
    PWSTR   pPrinterName,
    INT     iDriverEvent,
    DWORD   dwFlags,
    LPARAM  lParam)
{
    VERBOSE(DLLTEXT("IOemUI:PrinterEvent entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUI::DriverEvent(
    DWORD   dwDriverEvent,
    DWORD   dwLevel,
    LPBYTE  pDriverInfo,
    LPARAM  lParam)
{
    VERBOSE(DLLTEXT("IOemUI:DriverEvent entry.\r\n"));

    return E_NOTIMPL;
};


#define PROFILE_NAME    L"OEMPROFILE.icm\0"

HRESULT __stdcall IOemUI::QueryColorProfile(
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulQueryMode,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData)
{
    HRESULT Result = E_FAIL;


    VERBOSE(DLLTEXT("IOemUI:QueryColorProfile entry.\r\n"));


    if(QCP_DEVICEPROFILE == ulQueryMode)
    {
        if(NULL == pvProfileData)
        {
            *pcbProfileData = sizeof(PROFILE_NAME);
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }
        else
        {
            if(*pcbProfileData < sizeof(PROFILE_NAME))
            {
                *pcbProfileData = sizeof(PROFILE_NAME);
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
            }
            else
            {
                lstrcpynW((LPWSTR)pvProfileData, PROFILE_NAME, *pcbProfileData);
                *pcbProfileData = sizeof(PROFILE_NAME);
                *pflProfileData = QCP_PROFILEDISK;

                Result = S_OK;
            }
        }
    }

    return Result;
};

HRESULT __stdcall IOemUI::FontInstallerDlgProc(
        HWND    hWnd,
        UINT    usMsg,
        WPARAM  wParam,
        LPARAM  lParam) 
{
    VERBOSE(DLLTEXT("IOemUI:FontInstallerDlgProc entry.\r\n"));

    return E_NOTIMPL;
};

HRESULT __stdcall IOemUI::UpdateExternalFonts(
        HANDLE  hPrinter,
        HANDLE  hHeap,
        PWSTR   pwstrCartridges)
{
    VERBOSE(DLLTEXT("IOemUI:UpdateExternalFonts entry.\r\n"));

    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// oem class factory
//
class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this) ;
    }
    else
    {
#if DBG && defined(USERMODE_DRIVER)
        TCHAR szOutput[80] = {0};
        StringFromGUID2(iid, szOutput, COUNTOF(szOutput)); // can not fail!
        WARNING(DLLTEXT("IOemCF::QueryInterface %s not supported.\r\n"), szOutput); 
#endif

        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCF::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    //DbgPrint(DLLTEXT("Class factory:\t\tCreate component.")) ;

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IOemUI* pOemCB = new IOemUI ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }
    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv) ;

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release() ;
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks) ;
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks) ;
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Exported functions
//


// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    VERBOSE(DLLTEXT("DllGetClassObject:Create class factory.\r\n"));

    // Can we create this component?
    if (clsid != CLSID_OEMUI)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv) ;
    pFontCF->Release() ;

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemuni\ddihook.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	 DDIHook.cpp
//    
//
//  PURPOSE:  DDI Hook routines for User Mode COM Customization DLL.
//
//
//	Functions:
//
//		
//
//
//  PLATFORMS:	Windows NT
//
//

#include "precomp.h"
#include "debug.h"
#include "oemuni.h"




//
// OEMBitBlt
//

BOOL APIENTRY
OEMBitBlt(
    SURFOBJ        *psoTrg,
    SURFOBJ        *psoSrc,
    SURFOBJ        *psoMask,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclTrg,
    POINTL         *pptlSrc,
    POINTL         *pptlMask,
    BRUSHOBJ       *pbo,
    POINTL         *pptlBrush,
    ROP4            rop4
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMBitBlt() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoTrg->dhpdev;

    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvBitBlt)(poempdev->pfnUnidrv[UD_DrvBitBlt])) (
           psoTrg,
           psoSrc,
           psoMask,
           pco,
           pxlo,
           prclTrg,
           pptlSrc,
           pptlMask,
           pbo,
           pptlBrush,
           rop4));

}

//
// OEMStretchBlt
//

BOOL APIENTRY
OEMStretchBlt(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMStretchBlt() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDest->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;


    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvStretchBlt)(poempdev->pfnUnidrv[UD_DrvStretchBlt])) (
            psoDest,
            psoSrc,
            psoMask,
            pco,
            pxlo,
            pca,
            pptlHTOrg,
            prclDest,
            prclSrc,
            pptlMask,
            iMode));

}

//
// OEMCopyBits
//

BOOL APIENTRY
OEMCopyBits(
    SURFOBJ        *psoDest,
    SURFOBJ        *psoSrc,
    CLIPOBJ        *pco,
    XLATEOBJ       *pxlo,
    RECTL          *prclDest,
    POINTL         *pptlSrc
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMCopyBits() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDest->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvCopyBits)(poempdev->pfnUnidrv[UD_DrvCopyBits])) (
            psoDest,
            psoSrc,
            pco,
            pxlo,
            prclDest,
            pptlSrc));

}

//
// OEMTextOut
//

BOOL APIENTRY
OEMTextOut(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMTextOut() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvTextOut)(poempdev->pfnUnidrv[UD_DrvTextOut])) (
            pso,
            pstro,
            pfo,
            pco,
            prclExtra,
            prclOpaque,
            pboFore,
            pboOpaque,
            pptlOrg,
            mix));

}

//
// OEMStrokePath
//

BOOL APIENTRY
OEMStrokePath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    LINEATTRS  *plineattrs,
    MIX         mix
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMStokePath() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvStrokePath)(poempdev->pfnUnidrv[UD_DrvStrokePath])) (
            pso,
            ppo,
            pco,
            pxo,
            pbo,
            pptlBrushOrg,
            plineattrs,
            mix));

}

//
// OEMFillPath
//

BOOL APIENTRY
OEMFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    POINTL     *pptlBrushOrg,
    MIX         mix,
    FLONG       flOptions
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMFillPath() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvFillPath)(poempdev->pfnUnidrv[UD_DrvFillPath])) (
            pso,
            ppo,
            pco,
            pbo,
            pptlBrushOrg,
            mix,
            flOptions));

}

//
// OEMStrokeAndFillPath
//

BOOL APIENTRY
OEMStrokeAndFillPath(
    SURFOBJ    *pso,
    PATHOBJ    *ppo,
    CLIPOBJ    *pco,
    XFORMOBJ   *pxo,
    BRUSHOBJ   *pboStroke,
    LINEATTRS  *plineattrs,
    BRUSHOBJ   *pboFill,
    POINTL     *pptlBrushOrg,
    MIX         mixFill,
    FLONG       flOptions
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMStrokeAndFillPath() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvStrokeAndFillPath)(poempdev->pfnUnidrv[UD_DrvStrokeAndFillPath])) (
            pso,
            ppo,
            pco,
            pxo,
            pboStroke,
            plineattrs,
            pboFill,
            pptlBrushOrg,
            mixFill,
            flOptions));

}

//
// OEMRealizeBrush
//

BOOL APIENTRY
OEMRealizeBrush(
    BRUSHOBJ   *pbo,
    SURFOBJ    *psoTarget,
    SURFOBJ    *psoPattern,
    SURFOBJ    *psoMask,
    XLATEOBJ   *pxlo,
    ULONG       iHatch
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMRealizeBrush() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoTarget->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // the OEM DLL should NOT hook out this function unless it wants to draw
    // graphics directly to the device surface. In that case, it calls
    // EngRealizeBrush which causes GDI to call DrvRealizeBrush.
    // Note that it cannot call back into Unidrv since Unidrv doesn't hook it.
    //

    //
    // In this test DLL, the drawing hooks does not call EngRealizeBrush. So this
    // this function will never be called. Do nothing.
    //

    return TRUE;
}

//
// OEMStartPage
//

BOOL APIENTRY
OEMStartPage(
    SURFOBJ    *pso
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMStartPage() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvStartPage)(poempdev->pfnUnidrv[UD_DrvStartPage]))(pso));

}

#define OEM_TESTSTRING  "The DDICMDCB DLL adds this line of text."

//
// OEMSendPage
//

BOOL APIENTRY
OEMSendPage(
    SURFOBJ    *pso
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMSendPage() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // print a line of text, just for testing
    //
    if (pso->iType == STYPE_BITMAP)
    {
        pdevobj->pDrvProcs->DrvXMoveTo(pdevobj, 0, 0);
        pdevobj->pDrvProcs->DrvYMoveTo(pdevobj, 0, 0);
        pdevobj->pDrvProcs->DrvWriteSpoolBuf(pdevobj, OEM_TESTSTRING,
                                             sizeof(OEM_TESTSTRING));
    }

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvSendPage)(poempdev->pfnUnidrv[UD_DrvSendPage]))(pso));

}

//
// OEMEscape
//

ULONG APIENTRY
OEMEscape(
    SURFOBJ    *pso,
    ULONG       iEsc,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMEscape() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvEscape)(poempdev->pfnUnidrv[UD_DrvEscape])) (
            pso,
            iEsc,
            cjIn,
            pvIn,
            cjOut,
            pvOut));

}

//
// OEMStartDoc
//

BOOL APIENTRY
OEMStartDoc(
    SURFOBJ    *pso,
    PWSTR       pwszDocName,
    DWORD       dwJobId
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMStartDoc() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvStartDoc)(poempdev->pfnUnidrv[UD_DrvStartDoc])) (
            pso,
            pwszDocName,
            dwJobId));

}

//
// OEMEndDoc
//

BOOL APIENTRY
OEMEndDoc(
    SURFOBJ    *pso,
    FLONG       fl
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMEndDoc() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvEndDoc)(poempdev->pfnUnidrv[UD_DrvEndDoc])) (
            pso,
            fl));

}

////////
// NOTE:
// OEM DLL needs to hook out the following six font related DDI calls only
// if it enumerates additional fonts beyond what's in the GPD file.
// And if it does, it needs to take care of its own fonts for all font DDI
// calls and DrvTextOut call.
///////

//
// OEMQueryFont
//

PIFIMETRICS APIENTRY
OEMQueryFont(
    DHPDEV      dhpdev,
    ULONG_PTR   iFile,
    ULONG       iFace,
    ULONG_PTR  *pid
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMQueryFont() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvQueryFont)(poempdev->pfnUnidrv[UD_DrvQueryFont])) (
            dhpdev,
            iFile,
            iFace,
            pid));

}

//
// OEMQueryFontTree
//

PVOID APIENTRY
OEMQueryFontTree(
    DHPDEV      dhpdev,
    ULONG_PTR   iFile,
    ULONG       iFace,
    ULONG       iMode,
    ULONG_PTR  *pid
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMQueryFontTree() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvQueryFontTree)(poempdev->pfnUnidrv[UD_DrvQueryFontTree])) (
            dhpdev,
            iFile,
            iFace,
            iMode,
            pid));

}

//
// OEMQueryFontData
//

LONG APIENTRY
OEMQueryFontData(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH      hg,
    GLYPHDATA  *pgd,
    PVOID       pv,
    ULONG       cjSize
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMQueryFontData() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv if this is not the font that OEM enumerated.
    //

    return (((PFN_DrvQueryFontData)(poempdev->pfnUnidrv[UD_DrvQueryFontData])) (
            dhpdev,
            pfo,
            iMode,
            hg,
            pgd,
            pv,
            cjSize));

}

//
// OEMQueryAdvanceWidths
//

BOOL APIENTRY
OEMQueryAdvanceWidths(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo,
    ULONG       iMode,
    HGLYPH     *phg,
    PVOID       pvWidths,
    ULONG       cGlyphs
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMQueryAdvanceWidths() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv if this is not the font that OEM enumerated.
    //

    return (((PFN_DrvQueryAdvanceWidths)
             (poempdev->pfnUnidrv[UD_DrvQueryAdvanceWidths])) (
                   dhpdev,
                   pfo,
                   iMode,
                   phg,
                   pvWidths,
                   cGlyphs));

}

//
// OEMFontManagement
//

ULONG APIENTRY
OEMFontManagement(
    SURFOBJ    *pso,
    FONTOBJ    *pfo,
    ULONG       iMode,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMFontManagement() entry.\r\n"));

    //
    // Note that Unidrv will not call OEM DLL for iMode==QUERYESCSUPPORT.
    // So pso is not NULL for sure.
    //
    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv if this is not the font that OEM enumerated.
    //

    return (((PFN_DrvFontManagement)(poempdev->pfnUnidrv[UD_DrvFontManagement])) (
            pso,
            pfo,
            iMode,
            cjIn,
            pvIn,
            cjOut,
            pvOut));

}

//
// OEMGetGlyphMode
//

ULONG APIENTRY
OEMGetGlyphMode(
    DHPDEV      dhpdev,
    FONTOBJ    *pfo
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMGetGlyphMode() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv if this is not the font that OEM enumerated.
    //

    return (((PFN_DrvGetGlyphMode)(poempdev->pfnUnidrv[UD_DrvGetGlyphMode])) (
            dhpdev,
            pfo));

}

BOOL APIENTRY
OEMNextBand(
    SURFOBJ *pso,
    POINTL *pptl
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMNextBand() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvNextBand)(poempdev->pfnUnidrv[UD_DrvNextBand])) (
            pso,
            pptl));

}

BOOL APIENTRY
OEMStartBanding(
    SURFOBJ *pso,
    POINTL *pptl
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMStartBanding() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvStartBanding)(poempdev->pfnUnidrv[UD_DrvStartBanding])) (
            pso,
            pptl));


}

ULONG APIENTRY
OEMDitherColor(
    DHPDEV  dhpdev,
    ULONG   iMode,
    ULONG   rgbColor,
    ULONG  *pulDither
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMDitherColor() entry.\r\n"));

    pdevobj = (PDEVOBJ)dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvDitherColor)(poempdev->pfnUnidrv[UD_DrvDitherColor])) (
            dhpdev,
            iMode,
            rgbColor,
            pulDither));

}

BOOL APIENTRY
OEMPaint(
    SURFOBJ         *pso,
    CLIPOBJ         *pco,
    BRUSHOBJ        *pbo,
    POINTL          *pptlBrushOrg,
    MIX             mix
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMPaint() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvPaint)(poempdev->pfnUnidrv[UD_DrvPaint])) (
            pso,
            pco,
            pbo,
            pptlBrushOrg,
            mix));

}

BOOL APIENTRY
OEMLineTo(
    SURFOBJ    *pso,
    CLIPOBJ    *pco,
    BRUSHOBJ   *pbo,
    LONG        x1,
    LONG        y1,
    LONG        x2,
    LONG        y2,
    RECTL      *prclBounds,
    MIX         mix
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMLineTo() entry.\r\n"));

    pdevobj = (PDEVOBJ)pso->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvLineTo)(poempdev->pfnUnidrv[UD_DrvLineTo])) (
            pso,
            pco,
            pbo,
            x1,
            y1,
            x2,
            y2,
            prclBounds,
            mix));

}





#ifndef WINNT_40

//
// OEMStretchBltROP
//

BOOL APIENTRY
OEMStretchBltROP(
    SURFOBJ         *psoDest,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlHTOrg,
    RECTL           *prclDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG            iMode,
    BRUSHOBJ        *pbo,
    ROP4             rop4
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMStretchBltROP() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDest->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvStretchBltROP)(poempdev->pfnUnidrv[UD_DrvStretchBltROP])) (
            psoDest,
            psoSrc,
            psoMask,
            pco,
            pxlo,
            pca,
            pptlHTOrg,
            prclDest,
            prclSrc,
            pptlMask,
            iMode,
            pbo,
            rop4
            ));


}

//
// OEMPlgBlt
//

BOOL APIENTRY
OEMPlgBlt(
    SURFOBJ         *psoDst,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMask,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    POINTFIX        *pptfixDest,
    RECTL           *prclSrc,
    POINTL          *pptlMask,
    ULONG           iMode
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMPlgBlt() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDst->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvPlgBlt)(poempdev->pfnUnidrv[UD_DrvPlgBlt])) (
            psoDst,
            psoSrc,
            psoMask,
            pco,
            pxlo,
            pca,
            pptlBrushOrg,
            pptfixDest,
            prclSrc,
            pptlMask,
            iMode));

}

//
// OEMAlphaBlend
//

BOOL APIENTRY
OEMAlphaBlend(
    SURFOBJ    *psoDest,
    SURFOBJ    *psoSrc,
    CLIPOBJ    *pco,
    XLATEOBJ   *pxlo,
    RECTL      *prclDest,
    RECTL      *prclSrc,
    BLENDOBJ   *pBlendObj
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMAlphaBlend() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDest->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvAlphaBlend)(poempdev->pfnUnidrv[UD_DrvAlphaBlend])) (
            psoDest,
            psoSrc,
            pco,
            pxlo,
            prclDest,
            prclSrc,
            pBlendObj
            ));

}

//
// OEMGradientFill
//

BOOL APIENTRY
OEMGradientFill(
        SURFOBJ    *psoDest,
        CLIPOBJ    *pco,
        XLATEOBJ   *pxlo,
        TRIVERTEX  *pVertex,
        ULONG       nVertex,
        PVOID       pMesh,
        ULONG       nMesh,
        RECTL      *prclExtents,
        POINTL     *pptlDitherOrg,
        ULONG       ulMode
    )
{
    PDEVOBJ pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMGradientFill() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDest->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvGradientFill)(poempdev->pfnUnidrv[UD_DrvGradientFill])) (
            psoDest,
            pco,
            pxlo,
            pVertex,
            nVertex,
            pMesh,
            nMesh,
            prclExtents,
            pptlDitherOrg,
            ulMode
            ));

}

BOOL APIENTRY
OEMTransparentBlt(
        SURFOBJ    *psoDst,
        SURFOBJ    *psoSrc,
        CLIPOBJ    *pco,
        XLATEOBJ   *pxlo,
        RECTL      *prclDst,
        RECTL      *prclSrc,
        ULONG      iTransColor,
        ULONG      ulReserved
    )
{
    PDEVOBJ     pdevobj;
    POEMPDEV    poempdev;

    VERBOSE(DLLTEXT("OEMTransparentBlt() entry.\r\n"));

    pdevobj = (PDEVOBJ)psoDst->dhpdev;
    poempdev = (POEMPDEV)pdevobj->pdevOEM;

    //
    // turn around to call Unidrv
    //

    return (((PFN_DrvTransparentBlt)(poempdev->pfnUnidrv[UD_DrvTransparentBlt])) (
            psoDst,
            psoSrc,
            pco,
            pxlo,
            prclDst,
            prclSrc,
            iTransColor,
            ulReserved
            ));

}




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemuni\devmode.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Devmode.h
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for devmode functions.
//
//  PLATFORMS:
//
//    Windows NT
//
//
#ifndef _DEVMODE_H
#define _DEVMODE_H


////////////////////////////////////////////////////////
//      OEM Devmode Defines
////////////////////////////////////////////////////////




////////////////////////////////////////////////////////
//      OEM Devmode Type Definitions
////////////////////////////////////////////////////////

typedef struct tagOEMDEV
{
    OEM_DMEXTRAHEADER   dmOEMExtra;
    BOOL                dwDriverData;

} OEMDEV, *POEMDEV;

typedef const OEMDEV *PCOEMDEV;



/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

HRESULT hrOEMDevMode(DWORD dwMode, POEMDMPARAM pOemDMParam);
BOOL ConvertOEMDevmode(PCOEMDEV pOEMDevIn, POEMDEV pOEMDevOut);
BOOL MakeOEMDevmodeValid(POEMDEV pOEMDevmode);
void Dump(PCOEMDEV pOEMDevIn);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemui\intrface.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2001  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Intrface.cpp
//    
//
//  PURPOSE:  Header of interface for PScript4, PScript5, Unidrv4, 
//            Unidrv5 UI plug-ins.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows NT 4, Windows 2000, Windows XP
//
//


////////////////////////////////////////////////////////////////////////////////
//
// IOemUI
//
class IOemUI: public IPrintOemUI
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD  dwMode, PVOID  pBuffer, DWORD  cbSize,
                           PDWORD pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_  DWORD  dwMode, POEMDMPARAM pOemDMParam) ;

    //
    // OEMCommonUIProp
    //

    STDMETHOD(CommonUIProp) (THIS_  
            DWORD  dwMode, 
            POEMCUIPPARAM   pOemCUIPParam
            );

    //
    // OEMDocumentPropertySheets
    //

    STDMETHOD(DocumentPropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            );

    //
    // OEMDevicePropertySheets
    //

    STDMETHOD(DevicePropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            );


    //
    // OEMDevQueryPrintEx
    //

    STDMETHOD(DevQueryPrintEx) (THIS_
            POEMUIOBJ               poemuiobj,
            PDEVQUERYPRINT_INFO     pDQPInfo,
            PDEVMODE                pPublicDM,
            PVOID                   pOEMDM
            );

    //
    // OEMDeviceCapabilities
    //

    STDMETHOD(DeviceCapabilities) (THIS_
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult
            );

    //
    // OEMUpgradePrinter
    //

    STDMETHOD(UpgradePrinter) (THIS_
            DWORD   dwLevel,
            PBYTE   pDriverUpgradeInfo
            );

    //
    // OEMPrinterEvent
    //

    STDMETHOD(PrinterEvent) (THIS_
            PWSTR   pPrinterName,
            INT     iDriverEvent,
            DWORD   dwFlags,
            LPARAM  lParam
            );

    //
    // OEMDriverEvent
    //

    STDMETHOD(DriverEvent)(THIS_
            DWORD   dwDriverEvent,
            DWORD   dwLevel,
            LPBYTE  pDriverInfo,
            LPARAM  lParam
            );
 
    //
    // OEMQueryColorProfile
    //

    STDMETHOD( QueryColorProfile) (THIS_
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulReserved,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData);

    //
    // OEMFontInstallerDlgProc
    //

    STDMETHOD(FontInstallerDlgProc) (THIS_ 
            HWND    hWnd,
            UINT    usMsg,
            WPARAM  wParam,
            LPARAM  lParam
            );
    //
    // UpdateExternalFonts
    //

    STDMETHOD(UpdateExternalFonts) (THIS_
            HANDLE  hPrinter,
            HANDLE  hHeap,
            PWSTR   pwstrCartridges
            );


    IOemUI() { m_cRef = 1; m_pOEMHelp = NULL; };
    ~IOemUI();

protected:
    LONG                m_cRef;
    IPrintOemDriverUI*  m_pOEMHelp;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemuni\kmode.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:       KMode.h
//
//
//  PURPOSE:    Definitions and routines for compiling kernel mode instead of user mode.
//
//  PLATFORMS:
//    Windows NT
//
//

#ifndef _KMODE_H
#define _KMODE_H


// Define from ntdef.h in Win2K SDK.
// NT 4 may not have this defined
// in the public headers.
#ifndef NOP_FUNCTION
  #if (_MSC_VER >= 1210)
    #define NOP_FUNCTION __noop
  #else
    #define NOP_FUNCTION (void)0
  #endif
#endif



#ifdef USERMODE_DRIVER

//
// User mode difinitions to get rid of defines for kernel mode.
//

// Don't need critical section in user mode.

#define DECLARE_CRITICAL_SECTION    ;
#define INIT_CRITICAL_SECTION()     NOP_FUNCTION
#define DELETE_CRITICAL_SECTION()   NOP_FUNCTION
#define IS_VALID_CRITICAL_SECTION() (TRUE)


#else // !USERMODE_DRIVER


////////////////////////////////////////////////////////
//      Kernel Mode Defines
////////////////////////////////////////////////////////

extern HSEMAPHORE ghOEMSemaphore;

#define DECLARE_CRITICAL_SECTION    HSEMAPHORE ghOEMSemaphore = NULL;
#define INIT_CRITICAL_SECTION()     ghOEMSemaphore = EngCreateSemaphore()
#define ENTER_CRITICAL_SECTION()    EngAcquireSemaphore(ghOEMSemaphore)
#define LEAVE_CRITICAL_SECTION()    EngReleaseSemaphore(ghOEMSemaphore)
#define DELETE_CRITICAL_SECTION()   EngDeleteSemaphore(ghOEMSemaphore)
#define IS_VALID_CRITICAL_SECTION() (NULL != ghOEMSemaphore)
#define DebugBreak                  EngDebugBreak

// Pool tag marker for memory marking memory allocations.
#define DRV_MEM_POOL_TAG    'meoD'

// Debug prefix that is outputted in the debug messages.
#define DEBUG_PREFIX        "OEMDLL: "


// Remap user mode functions that don't have kernel mode
// equivalents to functions that we implement ourselves.

#define OutputDebugStringA(pszMsg)  (MyDebugPrint(DEBUG_PREFIX, "%hs", pszMsg))
#define OutputDebugStringW(pszMsg)  (MyDebugPrint(DEBUG_PREFIX, "%ls", pszMsg))

#if !defined(_M_ALPHA) && !defined(_M_IA64)
    #define InterlockedIncrement        DrvInterlockedIncrement
    #define InterlockedDecrement        DrvInterlockedDecrement
#endif


#define SetLastError                NOP_FUNCTION
#define GetLastError                NOP_FUNCTION



////////////////////////////////////////////////////////
//      Kernel Mode Functions
////////////////////////////////////////////////////////

//
// Implement inline functions to replace user mode 
// functions that don't have kernel mode equivalents.
//


inline int __cdecl _purecall (void)
{
#ifdef DEBUG
    EngDebugBreak();
#endif

    return E_FAIL;
}


inline LONG DrvInterlockedIncrement(PLONG pRef)
{
    ENTER_CRITICAL_SECTION();

        ++(*pRef);

    LEAVE_CRITICAL_SECTION();


    return (*pRef);
}


inline LONG DrvInterlockedDecrement(PLONG pRef)
{
    ENTER_CRITICAL_SECTION();

        --(*pRef);

    LEAVE_CRITICAL_SECTION();


    return (*pRef);
}


inline void* __cdecl operator new(size_t nSize)
{
    // return pointer to allocated memory
    return  EngAllocMem(0, nSize, DRV_MEM_POOL_TAG);
}


inline void __cdecl operator delete(void *pMem)
{
    if(pMem)
        EngFreeMem(pMem);
}


inline VOID MyDebugPrint(PCHAR pszPrefix, PCHAR pszFormat, ...)
{
    va_list VAList;

    va_start(VAList, pszFormat);
    EngDebugPrint(DEBUG_PREFIX, pszFormat, VAList);
    va_end(VAList);

    return;
}



#endif // USERMODE_DRIVER


#endif // _KMODE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemuni\oem.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997, 1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debug.cpp.
//
//  PLATFORMS:
//    Windows NT
//
//
#ifndef _OEM_H
#define _OEM_H



////////////////////////////////////////////////////////
//      OEM Defines
////////////////////////////////////////////////////////

#define OEM_SIGNATURE   'MSFT'
#define OEM_VERSION     0x00000001L



////////////////////////////////////////////////////////
//      OEM Type Definitions
////////////////////////////////////////////////////////



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemuni\devmode.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Devmode.cpp
//    
//
//  PURPOSE:  Implementation of Devmode functions shared with OEM UI and OEM rendering modules.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows NT
//
//

#include "precomp.h"
#include "oemuni.h"
#include "debug.h"
#include "devmode.h"
#include "kmode.h"



HRESULT hrOEMDevMode(DWORD dwMode, POEMDMPARAM pOemDMParam)
{
    POEMDEV pOEMDevIn;
    POEMDEV pOEMDevOut;


    // Verify parameters.
    if( (NULL == pOemDMParam)
        ||
        ( (OEMDM_SIZE != dwMode)
          &&
          (OEMDM_DEFAULT != dwMode)
          &&
          (OEMDM_CONVERT != dwMode)
          &&
          (OEMDM_MERGE != dwMode)
        )
      )
    {
        VERBOSE(ERRORTEXT("DevMode() ERROR_INVALID_PARAMETER.\r\n"));
        VERBOSE(DLLTEXT("\tdwMode = %d, pOemDMParam = %#lx.\r\n"), dwMode, pOemDMParam);

        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    // Cast generic (i.e. PVOID) to OEM private devomode pointer type.
    pOEMDevIn = (POEMDEV) pOemDMParam->pOEMDMIn;
    pOEMDevOut = (POEMDEV) pOemDMParam->pOEMDMOut;

    switch(dwMode)
    {
        case OEMDM_SIZE:
            pOemDMParam->cbBufSize = sizeof(OEMDEV);
            break;

        case OEMDM_DEFAULT:
            pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
            pOEMDevOut->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
            pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
            pOEMDevOut->dwDriverData            = 0;
            VERBOSE(DLLTEXT("pOEMDevOut after setting default values:\r\n"));
            Dump(pOEMDevOut);
            break;

        case OEMDM_CONVERT:
            ConvertOEMDevmode(pOEMDevIn, pOEMDevOut);
            break;

        case OEMDM_MERGE:
            ConvertOEMDevmode(pOEMDevIn, pOEMDevOut);
            MakeOEMDevmodeValid(pOEMDevOut);
            break;
    }
    Dump(pOemDMParam);

    return S_OK;
}


BOOL ConvertOEMDevmode(PCOEMDEV pOEMDevIn, POEMDEV pOEMDevOut)
{
    if( (NULL == pOEMDevIn)
        ||
        (NULL == pOEMDevOut)
      )
    {
        VERBOSE(ERRORTEXT("ConvertOEMDevmode() invalid parameters.\r\n"));
        return FALSE;
    }

    // Check OEM Signature, if it doesn't match ours,
    // then just assume DMIn is bad and use defaults.
    if(pOEMDevIn->dmOEMExtra.dwSignature == pOEMDevOut->dmOEMExtra.dwSignature)
    {
        VERBOSE(DLLTEXT("Converting private OEM Devmode.\r\n"));
        VERBOSE(DLLTEXT("pOEMDevIn:\r\n"));
        Dump(pOEMDevIn);

        // Set the devmode defaults so that anything the isn't copied over will
        // be set to the default value.
        pOEMDevOut->dwDriverData = 0;

        // Copy the old structure in to the new using which ever size is the smaller.
        // Devmode maybe from newer Devmode (not likely since there is only one), or
        // Devmode maybe a newer Devmode, in which case it maybe larger,
        // but the first part of the structure should be the same.

        // DESIGN ASSUMPTION: the private DEVMODE structure only gets added to;
        // the fields that are in the DEVMODE never change only new fields get added to the end.

        memcpy(pOEMDevOut, pOEMDevIn, __min(pOEMDevOut->dmOEMExtra.dwSize, pOEMDevIn->dmOEMExtra.dwSize));

        // Re-fill in the size and version fields to indicated 
        // that the DEVMODE is the current private DEVMODE version.
        pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
        pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
    }
    else
    {
        VERBOSE(DLLTEXT("Unknown DEVMODE signature, pOEMDMIn ignored.\r\n"));

        // Don't know what the input DEVMODE is, so just use defaults.
        pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
        pOEMDevOut->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
        pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
        pOEMDevOut->dwDriverData            = 0;
    }

    return TRUE;
}


BOOL MakeOEMDevmodeValid(POEMDEV pOEMDevmode)
{
    if(NULL == pOEMDevmode)
    {
        return FALSE;
    }

    // ASSUMPTION: pOEMDevmode is large enough to contain OEMDEV structure.

    // Make sure that dmOEMExtra indicates the current OEMDEV structure.
    pOEMDevmode->dmOEMExtra.dwSize       = sizeof(OEMDEV);
    pOEMDevmode->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
    pOEMDevmode->dmOEMExtra.dwVersion    = OEM_VERSION;

    // Set driver data.
    pOEMDevmode->dwDriverData = 0;

    return TRUE;
}


void Dump(PCOEMDEV pOEMDevmode)
{
    if( (NULL != pOEMDevmode)
        &&
        (pOEMDevmode->dmOEMExtra.dwSize >= sizeof(OEMDEV))
        &&
        (OEM_SIGNATURE == pOEMDevmode->dmOEMExtra.dwSignature)
      )
    {
        VERBOSE(__TEXT("\tdmOEMExtra.dwSize      = %d\r\n"), pOEMDevmode->dmOEMExtra.dwSize);
        VERBOSE(__TEXT("\tdmOEMExtra.dwSignature = %#x\r\n"), pOEMDevmode->dmOEMExtra.dwSignature);
        VERBOSE(__TEXT("\tdmOEMExtra.dwVersion   = %#x\r\n"), pOEMDevmode->dmOEMExtra.dwVersion);
        VERBOSE(__TEXT("\tdwDriverData           = %#x\r\n"), pOEMDevmode->dwDriverData);
    }
    else
    {
        VERBOSE(ERRORTEXT("Dump(POEMDEV) unknown private OEM DEVMODE.\r\n"));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemuni\dllentry.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	dllentry.cpp
//    
//
//  PURPOSE:  Source module for DLL entry function(s).
//
//
//	Functions:
//
//		DllMain
//
//
//  PLATFORMS:	Windows NT
//
//

#include "precomp.h"
#include "oemuni.h"
#include "debug.h"
#include "kmode.h"


// Used in kernel mode implementation to declare a critical section.
// Need to similate InterlockedIncrement and InterlockedDecrement
// by using a semaphore, since these functions don't
// exist in kernel mode.
DECLARE_CRITICAL_SECTION;



// Need to export these functions as c declarations.
extern "C" {


///////////////////////////////////////////////////////////
//
// DLL entry point
//

// DllMain isn't called/used for kernel mode version.
BOOL WINAPI DllMain(HINSTANCE hInst, WORD wReason, LPVOID lpReserved)
{
	switch(wReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(DLLTEXT("Process attach.\r\n"));
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(DLLTEXT("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(DLLTEXT("Process detach.\r\n"));
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(DLLTEXT("Thread detach.\r\n"));
			break;
	}

	return TRUE;
}


// DllInitialize isn't called/used for user mode version.
BOOL WINAPI DllInitialize(ULONG ulReason)
{
    BOOL    bRet = TRUE;

	switch(ulReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(DLLTEXT("Process attach.\r\n"));

            // In kernel mode version, initializes semaphore.
            INIT_CRITICAL_SECTION();
            bRet = IS_VALID_CRITICAL_SECTION();
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(DLLTEXT("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(DLLTEXT("Process detach.\r\n"));

            // In kernel mode version, deletes semaphore.
            DELETE_CRITICAL_SECTION();
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(DLLTEXT("Thread detach.\r\n"));
			break;
	}

	return bRet;
}



}  // extern "C" closing bracket
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemuni\precomp.h ===
//    
//
//  PURPOSE:	Header files that should be in the precompiled header.

//
//  PLATFORMS:
//    Windows NT
//
//
#ifndef _PRECOMP_H
#define _PRECOMP_H


// Necessary for compiling under VC.
#if(!defined(WINVER) || (WINVER < 0x0500))
	#undef WINVER
	#define WINVER          0x0500
#endif
#if(!defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500))
	#undef _WIN32_WINNT
	#define _WIN32_WINNT    0x0500
#endif

// Polymorphic types for Win32/Win64
// These don't exist for NT4.
#ifdef WINNT_40
    #define ULONG_PTR   ULONG
#endif


// Required header files that shouldn't change often.


#include <STDDEF.H>
#include <STDLIB.H>
#include <OBJBASE.H>
#include <STDARG.H>
#include <STDIO.H>
#include <WINDEF.H>
#include <WINERROR.H>
#include <WINBASE.H>
#include <WINGDI.H>
extern "C" 
{
    #include <WINDDI.H>
}
#include <TCHAR.H>
#include <EXCPT.H>
#include <ASSERT.H>
#include <PRINTOEM.H>


#define COUNTOF(p)  (sizeof(p)/sizeof(*(p)))


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemuni\intrface.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Intrface.H
//    
//
//  PURPOSE:	Define COM interface for User Mode Printer Customization DLL.
//
//  PLATFORMS:
//
//    Windows NT
//
//
#ifndef _INTERFACE_H
#define _INTERFACE_H




////////////////////////////////////////////////////////////////////////////////
//
//  IOemUni
//
//  Interface for Unidrv OEM sample rendering module
//
class IOemUni : public IPrintOemUni
{
public:
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

   //
   // Method for getting the implemented methods.
   // Returns S_OK if the given method is implemneted.
   // Returns S_FALSE if the given method is notimplemneted.
   //

   STDMETHOD(GetImplementedMethod)(THIS_ PSTR pMethodName);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);

    //
    // OEMDriverDMS - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(DriverDMS)(THIS_ PVOID   pDevObj,
                               PVOID   pBuffer,
                               DWORD   cbSize,
                               PDWORD  pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // OEMCommandCallback - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(CommandCallback)(THIS_ PDEVOBJ     pdevobj,
                                     DWORD       dwCallbackID,
                                     DWORD       dwCount,
                                     PDWORD      pdwParams,
                                     OUT INT     *piResult);

    //
    // OEMImageProcessing - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(ImageProcessing)(THIS_ PDEVOBJ             pdevobj,
                                     PBYTE               pSrcBitmap,
                                     PBITMAPINFOHEADER   pBitmapInfoHeader,
                                     PBYTE               pColorTable,
                                     DWORD               dwCallbackID,
                                     PIPPARAMS           pIPParams,
                                     OUT PBYTE           *ppbResult);

    //
    // OEMFilterGraphics - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen);
    //
    // OEMCompression - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult);

    //
    // OEMHalftone - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize);

    //
    // OEMMemoryUsage - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage);

    //
    // OEMTTYGetInfo - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded);

    //
    // OEMDownloadFontheader - UNIDRV only
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMDownloadCharGlyph - UNIDRV only
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult);

    //
    // OEMTTDownloadMethod - UNIDRV only
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMOutputCharStr - UNIDRV only
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph);

    //
    // OEMSendFontCmd - UNIDRV only
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv);

    //
    // OEMTextOutAsBitmap - UNIDRV only
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix);

    
    IOemUni() { m_cRef = 1; m_pOEMHelp = NULL; };
    ~IOemUni();

protected:
    LONG                m_cRef;
    IPrintOemDriverUni* m_pOEMHelp;
};





#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemuni\enable.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Enable.cpp
//    
//
//  PURPOSE:  Enable routines for User Mode COM Customization DLL.
//
//
//	Functions:
//
//		
//
//
//  PLATFORMS:	Windows NT
//
//

#include "precomp.h"
#include "debug.h"
#include "oemuni.h"



////////////////////////////////////////////////////////
//      Internal Constants
////////////////////////////////////////////////////////

///////////////////////////////////////////////////////
// Warning: the following array order must match the 
//          order in enum ENUMHOOKS.
///////////////////////////////////////////////////////
static const DRVFN OEMHookFuncs[] =
{
    { INDEX_DrvRealizeBrush,        (PFN) OEMRealizeBrush        },
    { INDEX_DrvDitherColor,         (PFN) OEMDitherColor         },
    { INDEX_DrvCopyBits,            (PFN) OEMCopyBits            },
    { INDEX_DrvBitBlt,              (PFN) OEMBitBlt              },
    { INDEX_DrvStretchBlt,          (PFN) OEMStretchBlt          },
    { INDEX_DrvTextOut,             (PFN) OEMTextOut             },
    { INDEX_DrvStrokePath,          (PFN) OEMStrokePath          },
    { INDEX_DrvFillPath,            (PFN) OEMFillPath            },
    { INDEX_DrvStrokeAndFillPath,   (PFN) OEMStrokeAndFillPath   },
    { INDEX_DrvPaint,               (PFN) OEMPaint               },
    { INDEX_DrvLineTo,              (PFN) OEMLineTo              },
    { INDEX_DrvStartPage,           (PFN) OEMStartPage           },
    { INDEX_DrvSendPage,            (PFN) OEMSendPage            },
    { INDEX_DrvEscape,              (PFN) OEMEscape              },
    { INDEX_DrvStartDoc,            (PFN) OEMStartDoc            },
    { INDEX_DrvEndDoc,              (PFN) OEMEndDoc              },
    { INDEX_DrvNextBand,            (PFN) OEMNextBand            },
    { INDEX_DrvStartBanding,        (PFN) OEMStartBanding        },
    { INDEX_DrvQueryFont,           (PFN) OEMQueryFont           },
    { INDEX_DrvQueryFontTree,       (PFN) OEMQueryFontTree       },
    { INDEX_DrvQueryFontData,       (PFN) OEMQueryFontData       },
    { INDEX_DrvQueryAdvanceWidths,  (PFN) OEMQueryAdvanceWidths  },
    { INDEX_DrvFontManagement,      (PFN) OEMFontManagement      },
    { INDEX_DrvGetGlyphMode,        (PFN) OEMGetGlyphMode        },
#ifndef WINNT_40
    { INDEX_DrvStretchBltROP,       (PFN) OEMStretchBltROP       },
    { INDEX_DrvPlgBlt,              (PFN) OEMPlgBlt              },
    { INDEX_DrvTransparentBlt,      (PFN) OEMTransparentBlt      },
    { INDEX_DrvAlphaBlend,          (PFN) OEMAlphaBlend          },
    { INDEX_DrvGradientFill,        (PFN) OEMGradientFill        },
#endif
};







PDEVOEM APIENTRY OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded        // Unidrv's hook table
    )
{
    POEMPDEV    poempdev;
    INT         i, j;
    DWORD       dwDDIIndex;
    PDRVFN      pdrvfn;

    VERBOSE(DLLTEXT("OEMEnablePDEV() entry.\r\n"));

    //
    // Allocate the OEMDev
    //
    poempdev = new OEMPDEV;
    if (NULL == poempdev)
    {
        return NULL;
    }

    //
    // Fill in OEMDEV as you need
    //

    //
    // Fill in OEMDEV
    //

    for (i = 0; i < MAX_DDI_HOOKS; i++)
    {
        //
        // search through Unidrv's hooks and locate the function ptr
        //
        dwDDIIndex = OEMHookFuncs[i].iFunc;
        for (j = pded->c, pdrvfn = pded->pdrvfn; j > 0; j--, pdrvfn++)
        {
            if (dwDDIIndex == pdrvfn->iFunc)
            {
                poempdev->pfnUnidrv[i] = pdrvfn->pfn;
                break;
            }
        }
        if (j == 0)
        {
            //
            // didn't find the Unidrv hook. Should happen only with DrvRealizeBrush
            //
            poempdev->pfnUnidrv[i] = NULL;
        }

    }

    return (POEMPDEV) poempdev;
}


VOID APIENTRY OEMDisablePDEV(
    PDEVOBJ pdevobj
    )
{
    VERBOSE(DLLTEXT("OEMDisablePDEV() entry.\r\n"));


    //
    // Free memory for OEMPDEV and any memory block that hangs off OEMPDEV.
    //
    assert(NULL != pdevobj->pdevOEM);
    delete pdevobj->pdevOEM;
}


BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew
    )
{
    VERBOSE(DLLTEXT("OEMResetPDEV() entry.\r\n"));


    //
    // If you want to carry over anything from old pdev to new pdev, do it here.
    //

    return TRUE;
}


VOID APIENTRY OEMDisableDriver()
{
    VERBOSE(DLLTEXT("OEMDisableDriver() entry.\r\n"));
}


BOOL APIENTRY OEMEnableDriver(DWORD dwOEMintfVersion, DWORD dwSize, PDRVENABLEDATA pded)
{
    VERBOSE(DLLTEXT("OEMEnableDriver() entry.\r\n"));

    // List DDI functions that are hooked.
    pded->iDriverVersion =  PRINTER_OEMINTF_VERSION;
    pded->c = sizeof(OEMHookFuncs) / sizeof(DRVFN);
    pded->pdrvfn = (DRVFN *) OEMHookFuncs;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemuni\oemuni.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997, 1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	OEMUNI.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debug.cpp.
//
//  PLATFORMS:
//    Windows NT
//
//
#ifndef _OEMUNI_H
#define _OEMUNI_H

#include "OEM.H"
#include "DEVMODE.H"


////////////////////////////////////////////////////////
//      OEM Defines
////////////////////////////////////////////////////////

#define DLLTEXT(s)      __TEXT("OEMUNI:  ") __TEXT(s)
#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)


///////////////////////////////////////////////////////
// Warning: the following enum order must match the 
//          order in OEMHookFuncs[].
///////////////////////////////////////////////////////
typedef enum tag_Hooks {
    UD_DrvRealizeBrush,
    UD_DrvDitherColor,
    UD_DrvCopyBits,
    UD_DrvBitBlt,
    UD_DrvStretchBlt,
    UD_DrvTextOut,
    UD_DrvStrokePath,
    UD_DrvFillPath,
    UD_DrvStrokeAndFillPath,
    UD_DrvPaint,
    UD_DrvLineTo,
    UD_DrvStartPage,
    UD_DrvSendPage,
    UD_DrvEscape,
    UD_DrvStartDoc,
    UD_DrvEndDoc,
    UD_DrvNextBand,
    UD_DrvStartBanding,
    UD_DrvQueryFont,
    UD_DrvQueryFontTree,
    UD_DrvQueryFontData,
    UD_DrvQueryAdvanceWidths,
    UD_DrvFontManagement,
    UD_DrvGetGlyphMode,
    UD_DrvStretchBltROP,
    UD_DrvPlgBlt,
    UD_DrvTransparentBlt,
    UD_DrvAlphaBlend,
    UD_DrvGradientFill,

    MAX_DDI_HOOKS,

} ENUMHOOKS;


typedef struct _OEMPDEV {
    //
    // define whatever needed, such as working buffers, tracking information,
    // etc.
    //
    // This test DLL hooks out every drawing DDI. So it needs to remember
    // Unidrv's hook function pointer so it call back.
    //
    PFN     pfnUnidrv[MAX_DDI_HOOKS];

    //
    // define whatever needed, such as working buffers, tracking information,
    // etc.
    //
    DWORD     dwReserved[1];

} OEMPDEV, *POEMPDEV;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemuni\intrface.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Intrface.cpp
//    
//
//  PURPOSE:  Interface for User Mode COM Customization DLL.
//
//
//	Functions:
//
//		
//
//
//  PLATFORMS:	Windows NT
//
//

#include "precomp.h"
#include <INITGUID.H>
#include <PRCOMOEM.H>

#include "oemuni.h"
#include "debug.h"
#include "intrface.h"
#include "name.h"
#include "kmode.h"



////////////////////////////////////////////////////////
//      Internal Globals
////////////////////////////////////////////////////////

static long g_cComponents = 0;     // Count of active components
static long g_cServerLocks = 0;    // Count of locks






////////////////////////////////////////////////////////////////////////////////
//
// IOemUni body
//
IOemUni::~IOemUni()
{
    // Make sure that helper interface is released.
    if(NULL != m_pOEMHelp)
    {
        m_pOEMHelp->Release();
        m_pOEMHelp = NULL;
    }

    // If this instance of the object is being deleted, then the reference 
    // count should be zero.
    assert(0 == m_cRef);
}


HRESULT __stdcall IOemUni::QueryInterface(const IID& iid, void** ppv)
{    
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        VERBOSE(DLLTEXT("IOemUni::QueryInterface IUnknown.\r\n")); 
    }
    else if (iid == IID_IPrintOemUni)
    {
        *ppv = static_cast<IPrintOemUni*>(this);
        VERBOSE(DLLTEXT("IOemUni::QueryInterface IPrintOemUni.\r\n")); 
    }
    else
    {
        *ppv = NULL;
#if DBG && defined(USERMODE_DRIVER)
        TCHAR szOutput[80] = {0};
        StringFromGUID2(iid, szOutput, COUNTOF(szOutput)); // can not fail!
        WARNING(DLLTEXT("IOemUni::QueryInterface %s not supported.\r\n"), szOutput); 
#endif
        return E_NOINTERFACE;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

ULONG __stdcall IOemUni::AddRef()
{
    VERBOSE(DLLTEXT("IOemUni::AddRef() entry.\r\n"));
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemUni::Release() 
{
    VERBOSE(DLLTEXT("IOemUni::Release() entry.\r\n"));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}


HRESULT __stdcall IOemUni::GetInfo (
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE(DLLTEXT("IOemUni::GetInfo(%d) entry.\r\n"), dwMode);

    // Validate parameters.
    if( (NULL == pcbNeeded)
        ||
        ( (OEMGI_GETSIGNATURE != dwMode)
          &&
          (OEMGI_GETVERSION != dwMode)
          &&
          (OEMGI_GETPUBLISHERINFO != dwMode)
        )
      )
    {
        WARNING(DLLTEXT("IOemUni::GetInfo() exit pcbNeeded is NULL! ERROR_INVALID_PARAMETER.\r\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    // Set expected buffer size.
    if(OEMGI_GETPUBLISHERINFO != dwMode)
    {
        *pcbNeeded = sizeof(DWORD);
    }
    else
    {
        *pcbNeeded = sizeof(PUBLISHERINFO);
        return E_FAIL;
    }

    // Check buffer size is sufficient.
    if((cbSize < *pcbNeeded) || (NULL == pBuffer))
    {
        VERBOSE(DLLTEXT("IOemUni::GetInfo() exit insufficient buffer!\r\n"));
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return E_FAIL;
    }

    switch(dwMode)
    {
        // OEM DLL Signature
        case OEMGI_GETSIGNATURE:
            *(PDWORD)pBuffer = OEM_SIGNATURE;
            break;

        // OEM DLL version
        case OEMGI_GETVERSION:
            *(PDWORD)pBuffer = OEM_VERSION;
            break;

        case OEMGI_GETPUBLISHERINFO:
            Dump((PPUBLISHERINFO)pBuffer);
            // Fall through to default case.

        // dwMode not supported.
        default:
            // Set written bytes to zero since nothing was written.
            WARNING(DLLTEXT("IOemUni::GetInfo() exit mode not supported.\r\n"));
            *pcbNeeded = 0;
            SetLastError(ERROR_NOT_SUPPORTED);
            return E_FAIL;
    }

    VERBOSE(DLLTEXT("IOemUni::GetInfo() exit S_OK, (*pBuffer is %#x).\r\n"), *(PDWORD)pBuffer);

    return S_OK;
}

HRESULT __stdcall IOemUni::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE(DLLTEXT("IOemUni::PublishDriverInterface() entry.\r\n"));

    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->m_pOEMHelp == NULL)
    {
        HRESULT hResult;


        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** ) &(this->m_pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->m_pOEMHelp = NULL;

            return E_FAIL;
        }
    }

    return S_OK;
}


HRESULT __stdcall IOemUni::EnableDriver(
    DWORD          dwDriverVersion,
    DWORD          cbSize,
    PDRVENABLEDATA pded)
{
    VERBOSE(DLLTEXT("IOemUni::EnableDriver() entry.\r\n"));

    OEMEnableDriver(dwDriverVersion, cbSize, pded);

    // Even if nothing is done, need to return S_OK so 
    // that DisableDriver() will be called, which releases
    // the reference to the Printer Driver's interface.
    return S_OK;
}

HRESULT __stdcall IOemUni::DisableDriver(VOID)
{
    VERBOSE(DLLTEXT("IOemUni::DisaleDriver() entry.\r\n"));

    OEMDisableDriver();

    // Release reference to Printer Driver's interface.
    if (this->m_pOEMHelp)
    {
        this->m_pOEMHelp->Release();
        this->m_pOEMHelp = NULL;
    }

    return S_OK;
}

HRESULT __stdcall IOemUni::DisablePDEV(
    PDEVOBJ         pdevobj)
{
    VERBOSE(DLLTEXT("IOemUni::DisablePDEV() entry.\r\n"));

    OEMDisablePDEV(pdevobj);

    return S_OK;
};

HRESULT __stdcall IOemUni::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
{
    VERBOSE(DLLTEXT("IOemUni::EnablePDEV() entry.\r\n"));

    *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns,  phsurfPatterns,
                             cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);

    return (NULL != *pDevOem ? S_OK : E_FAIL);
}


HRESULT __stdcall IOemUni::ResetPDEV(
    PDEVOBJ         pdevobjOld,
    PDEVOBJ        pdevobjNew)
{
    BOOL    bResult;


    VERBOSE(DLLTEXT("IOemUni::ResetPDEV() entry.\r\n"));


    bResult = OEMResetPDEV(pdevobjOld, pdevobjNew);

    return (bResult ? S_OK : E_FAIL);
}


HRESULT __stdcall IOemUni::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam)
{   
    VERBOSE(DLLTEXT("IOemUni:DevMode(%d, %#x) entry.\n"), dwMode, pOemDMParam); 
    return hrOEMDevMode(dwMode, pOemDMParam);
}

HRESULT __stdcall IOemUni::GetImplementedMethod(PSTR pMethodName)
{
    HRESULT Result = S_FALSE;


    VERBOSE(DLLTEXT("IOemUni::GetImplementedMethod() entry.\r\n"));
    VERBOSE(DLLTEXT("        Function:%hs:"),pMethodName);

    switch (*pMethodName)
    {
        case 'C':
            if (!strcmp(NAME_CommandCallback, pMethodName))
            {
                Result = S_OK;
            }
            else if (!strcmp(NAME_Compression, pMethodName))
            {
                Result = S_OK;
            }
            break;

        case 'D':
            if (!strcmp(NAME_DisableDriver, pMethodName))
            {
                Result = S_OK;
            }
            else if (!strcmp(NAME_DisablePDEV, pMethodName))
            {
                Result = S_OK;
            }
            else if (!strcmp(NAME_DriverDMS, pMethodName))
            {
                Result = S_OK;
            }
            else if (!strcmp(NAME_DevMode, pMethodName))
            {
                Result = S_OK;
            }
            else if (!strcmp(NAME_DownloadFontHeader, pMethodName))
            {
                Result = S_OK;
            }
            else if (!strcmp(NAME_DownloadCharGlyph, pMethodName))
            {
                Result = S_OK;
            }
            break;

        case 'E':
            if (!strcmp(NAME_EnableDriver, pMethodName))
            {
                Result = S_OK;
            }
            else if (!strcmp(NAME_EnablePDEV, pMethodName))
            {
                Result = S_OK;
            }
            break;

        case 'F':
            if (!strcmp(NAME_FilterGraphics, pMethodName))
            {
                Result = S_OK;
            }
            break;

        case 'G':
            if (!strcmp(NAME_GetInfo, pMethodName))
            {
                Result = S_OK;
            }
            break;

        case 'H':
            if (!strcmp(NAME_HalftonePattern, pMethodName))
            {
                Result = S_OK;
            }
            break;

        case 'I':
            if (!strcmp(NAME_ImageProcessing, pMethodName))
            {
                Result = S_OK;
            }
            break;

        case 'M':
            if (!strcmp(NAME_MemoryUsage, pMethodName))
            {
                Result = S_OK;
            }
            break;

        case 'O':
            if (!strcmp(NAME_OutputCharStr, pMethodName))
            {
                Result = S_OK;
            }
            break;

        case 'R':
            if (!strcmp(NAME_ResetPDEV, pMethodName))
            {
                Result = S_OK;
            }
            break;

        case 'S':
            if (!strcmp(NAME_SendFontCmd, pMethodName))
            {
                Result = S_OK;
            }
            break;

        case 'T':
            if (!strcmp(NAME_TextOutAsBitmap, pMethodName))
            {
                Result = S_OK;
            }
            else if (!strcmp(NAME_TTDownloadMethod, pMethodName))
            {
                Result = S_OK;
            }
            else if (!strcmp(NAME_TTYGetInfo, pMethodName))
            {
                Result = S_OK;
            }
            break;
    }

    VERBOSE( Result == S_OK ? TEXT("Supported\r\n") : TEXT("NOT supported\r\n"));

    return Result;
}

HRESULT __stdcall IOemUni::CommandCallback(
    PDEVOBJ     pdevobj,
    DWORD       dwCallbackID,
    DWORD       dwCount,
    PDWORD      pdwParams,
    OUT INT     *piResult)
{
    VERBOSE(DLLTEXT("IOemUni::CommandCallback() entry.\r\n"));
    VERBOSE(DLLTEXT("        dwCallbackID = %d\r\n"), dwCallbackID);
    VERBOSE(DLLTEXT("        dwCount      = %d\r\n"), dwCount);

    *piResult = 0;

    return S_OK;
}

HRESULT __stdcall IOemUni::ImageProcessing(
    PDEVOBJ             pdevobj,  
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
{
    VERBOSE(DLLTEXT("IOemUni::ImageProcessing() entry.\r\n"));

    return S_OK;
}

HRESULT __stdcall IOemUni::FilterGraphics(
    PDEVOBJ     pdevobj,
    PBYTE       pBuf,
    DWORD       dwLen)
{
    DWORD dwResult;
    VERBOSE(DLLTEXT("IOemUni::FilterGraphis() entry.\r\n"));
    m_pOEMHelp->DrvWriteSpoolBuf(pdevobj, pBuf, dwLen, &dwResult);
    
    if (dwResult == dwLen)
        return S_OK;
    else
        return S_FALSE;
}

HRESULT __stdcall IOemUni::Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
{
    VERBOSE(DLLTEXT("IOemUni::Compression() entry.\r\n"));
    return E_NOTIMPL;
}


HRESULT __stdcall IOemUni::HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
{
    VERBOSE(DLLTEXT("IOemUni::HalftonePattern() entry.\r\n"));
    return E_NOTIMPL;
}

HRESULT __stdcall IOemUni::MemoryUsage(
    PDEVOBJ         pdevobj,   
    POEMMEMORYUSAGE pMemoryUsage)
{
    VERBOSE(DLLTEXT("IOemUni::MemoryUsage() entry.\r\n"));
    return E_NOTIMPL;
}

HRESULT __stdcall IOemUni::DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE(DLLTEXT("IOemUni::DownloadFontHeader() entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUni::DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult) 
{
    VERBOSE(DLLTEXT("IOemUni::DownloadCharGlyph() entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUni::TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE(DLLTEXT("IOemUni::TTDownloadMethod() entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUni::OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph) 
{
    VERBOSE(DLLTEXT("IOemUni::OutputCharStr() entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUni::SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv) 
{
    VERBOSE(DLLTEXT("IOemUni::SendFontCmd() entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUni::DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE(DLLTEXT("IOemUni::DriverDMS() entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUni::TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *NAME_o,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
{
    VERBOSE(DLLTEXT("IOemUni::TextOutAsBitmap() entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUni::TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded)
{
    VERBOSE(DLLTEXT("IOemUni::TTYGetInfo() entry.\r\n"));

    return E_NOTIMPL;
}


////////////////////////////////////////////////////////////////////////////////
//
// oem class factory
//
class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);
   
    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{    
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this); 
    }
    else
    {
        *ppv = NULL;
#if DBG && defined(USERMODE_DRIVER)
        TCHAR szOutput[80] = {0};
        StringFromGUID2(iid, szOutput, COUNTOF(szOutput)); // can not fail!
        WARNING(DLLTEXT("IOemCF::QueryInterface %s not supported.\r\n"), szOutput); 
#endif
        return E_NOINTERFACE;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCF::Release() 
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv) 
{
    //VERBOSE(DLLTEXT("Class factory:\t\tCreate component."));

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION;
    }

    // Create component.
    IOemUni* pOemCP = new IOemUni;
    if (pOemCP == NULL)
    {
        return E_OUTOFMEMORY;
    }

    // Get the requested interface.
    HRESULT hr = pOemCP->QueryInterface(iid, ppv);

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCP->Release();
    return hr;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock) 
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks); 
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks);
    }
    return S_OK;
}


//
// Registration functions
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    VERBOSE(DLLTEXT("DllCanUnloadNow entered.\r\n"));

    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    VERBOSE(DLLTEXT("DllGetClassObject:\tCreate class factory.\r\n"));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemuni\name.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Name.H
//    
//
//  PURPOSE:	Define string literals for interface funcion names.
//
//  PLATFORMS:
//
//    Windows NT
//
//
#ifndef _NAME_H
#define _NAME_H


/////////////////////////////////////////////////////////
//		String Leterals
/////////////////////////////////////////////////////////

CONST CHAR NAME_CommandCallback[]           = "CommandCallback";
CONST CHAR NAME_Compression[]               = "Compression";
CONST CHAR NAME_DevMode[]                   = "DevMode";
CONST CHAR NAME_DisableDriver[]             = "DiableDriver";
CONST CHAR NAME_DisablePDEV[]               = "DisablePDEV";
CONST CHAR NAME_DownloadCharGlyph[]         = "DownloadCharGlyph";
CONST CHAR NAME_DownloadFontHeader[]        = "DownloadFontHeader";
CONST CHAR NAME_DriverDMS[]                 = "DriverDMS";
CONST CHAR NAME_EnableDriver[]              = "EnableDriver";
CONST CHAR NAME_EnablePDEV[]                = "EnablePDEV";
CONST CHAR NAME_FilterGraphics[]            = "FilterGraphics";
CONST CHAR NAME_GetImplementedMethod[]      = "GetImplementedMethod";
CONST CHAR NAME_GetInfo[]                   = "GetInfo";
CONST CHAR NAME_HalftonePattern[]           = "HalftonePattern";
CONST CHAR NAME_ImageProcessing[]           = "ImageProcessing";
CONST CHAR NAME_MemoryUsage[]               = "MemoryUsage";
CONST CHAR NAME_OutputCharStr[]             = "OutputCharStr";
CONST CHAR NAME_PublishDriverInterface[]    = "PublishDriverInterface";
CONST CHAR NAME_SendFontCmd[]               = "SendFontCmd";
CONST CHAR NAME_ResetPDEV[]                 = "ResetPDEV";
CONST CHAR NAME_TextOutAsBitmap[]           = "TextOutAsBitmap";
CONST CHAR NAME_TTDownloadMethod[]          = "TTDownloadMethod";
CONST CHAR NAME_TTYGetInfo[]                = "TTYGetInfo";





#endif

/* 

CommandCallback
Compression
DevMode
DisableDriver
DisablePDEV
DownloadCharGlyph
DownloadFontHeader
DriverDMS
EnableDriver
EnablePDEV
FilterGraphics
GetImplementedMethod
GetInfo
HalftonePattern
ImageProcessing
MemoryUsage
OutputCharStr
PublishDriverInterface
QueryInterface
ResetPDEV
SendFontCmd
TextOutAsBitmap
TTDownloadMethod
TTYGetInfo

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemuni\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by OEMUNI.rc
//


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\devmode.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2001  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Devmode.cpp
//    
//
//  PURPOSE:  Implementation of Devmode functions shared with OEM UI and OEM rendering modules.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP
//
//

#include "precomp.h"
#include "oemui.h"
#include "debug.h"
#include "devmode.h"



HRESULT hrOEMDevMode(DWORD dwMode, POEMDMPARAM pOemDMParam)
{
    POEMDEV pOEMDevIn;
    POEMDEV pOEMDevOut;


    // Verify parameters.
    if( (NULL == pOemDMParam)
        ||
        ( (OEMDM_SIZE != dwMode)
          &&
          (OEMDM_DEFAULT != dwMode)
          &&
          (OEMDM_CONVERT != dwMode)
          &&
          (OEMDM_MERGE != dwMode)
        )
      )
    {
        ERR(ERRORTEXT("DevMode() ERROR_INVALID_PARAMETER.\r\n"));
        VERBOSE(DLLTEXT("\tdwMode = %d, pOemDMParam = %#lx.\r\n"), dwMode, pOemDMParam);

        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    // Cast generic (i.e. PVOID) to OEM private devomode pointer type.
    pOEMDevIn = (POEMDEV) pOemDMParam->pOEMDMIn;
    pOEMDevOut = (POEMDEV) pOemDMParam->pOEMDMOut;

    switch(dwMode)
    {
        case OEMDM_SIZE:
            pOemDMParam->cbBufSize = sizeof(OEMDEV);
            break;

        case OEMDM_DEFAULT:
            pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
            pOEMDevOut->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
            pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
            pOEMDevOut->dwDriverData            = 0;
            VERBOSE(DLLTEXT("pOEMDevOut after setting default values:\r\n"));
            Dump(pOEMDevOut);
            break;

        case OEMDM_CONVERT:
            ConvertOEMDevmode(pOEMDevIn, pOEMDevOut, pOemDMParam->cbBufSize);
            break;

        case OEMDM_MERGE:
            ConvertOEMDevmode(pOEMDevIn, pOEMDevOut, pOemDMParam->cbBufSize);
            MakeOEMDevmodeValid(pOEMDevOut);
            break;
    }
    Dump(pOemDMParam);

    return S_OK;
}


BOOL ConvertOEMDevmode(PCOEMDEV pOEMDevIn, POEMDEV pOEMDevOut, DWORD dwSize)
{
    if( (NULL == pOEMDevIn)
        ||
        (NULL == pOEMDevOut)
        ||
        (dwSize < sizeof(OEMDEV))
      )
    {
        ERR(ERRORTEXT("ConvertOEMDevmode() invalid parameters.\r\n"));
        return FALSE;
    }

    // Check OEM Signature, if it doesn't match ours,
    // then just assume DMIn is bad and use defaults.
    if(pOEMDevIn->dmOEMExtra.dwSignature == pOEMDevOut->dmOEMExtra.dwSignature)
    {
        VERBOSE(DLLTEXT("Converting private OEM Devmode.\r\n"));
        VERBOSE(DLLTEXT("pOEMDevIn:\r\n"));
        Dump(pOEMDevIn);

        // Set the devmode defaults so that anything the isn't copied over will
        // be set to the default value.
        pOEMDevOut->dwDriverData = 0;

        // Copy the old structure in to the new using which ever size is the smaller.
        // Devmode maybe from newer Devmode (not likely since there is only one), or
        // Devmode maybe a newer Devmode, in which case it maybe larger,
        // but the first part of the structure should be the same.

        // DESIGN ASSUMPTION: the private DEVMODE structure only gets added to;
        // the fields that are in the DEVMODE never change only new fields get added to the end.

        memcpy(pOEMDevOut, pOEMDevIn, __min(dwSize, __min(pOEMDevOut->dmOEMExtra.dwSize, pOEMDevIn->dmOEMExtra.dwSize)));

        // Re-fill in the size and version fields to indicated 
        // that the DEVMODE is the current private DEVMODE version.
        pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
        pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
    }
    else
    {
        WARNING(DLLTEXT("Unknown DEVMODE signature, pOEMDMIn ignored.\r\n"));

        // Don't know what the input DEVMODE is, so just use defaults.
        pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
        pOEMDevOut->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
        pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
        pOEMDevOut->dwDriverData            = 0;
    }

    return TRUE;
}


BOOL MakeOEMDevmodeValid(POEMDEV pOEMDevmode)
{
    if(NULL == pOEMDevmode)
    {
        return FALSE;
    }

    // ASSUMPTION: pOEMDevmode is large enough to contain OEMDEV structure.

    // Make sure that dmOEMExtra indicates the current OEMDEV structure.
    pOEMDevmode->dmOEMExtra.dwSize       = sizeof(OEMDEV);
    pOEMDevmode->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
    pOEMDevmode->dmOEMExtra.dwVersion    = OEM_VERSION;

    // Set driver data, if not valid.
    if(pOEMDevmode->dwDriverData > 100)
    {
        pOEMDevmode->dwDriverData = 0;
    }

    return TRUE;
}


void Dump(PCOEMDEV pOEMDevmode)
{
    if( (NULL != pOEMDevmode)
        &&
        (pOEMDevmode->dmOEMExtra.dwSize >= sizeof(OEMDEV))
        &&
        (OEM_SIGNATURE == pOEMDevmode->dmOEMExtra.dwSignature)
      )
    {
        VERBOSE(TEXT("\tdmOEMExtra.dwSize      = %d\r\n"), pOEMDevmode->dmOEMExtra.dwSize);
        VERBOSE(TEXT("\tdmOEMExtra.dwSignature = %#x\r\n"), pOEMDevmode->dmOEMExtra.dwSignature);
        VERBOSE(TEXT("\tdmOEMExtra.dwVersion   = %#x\r\n"), pOEMDevmode->dmOEMExtra.dwVersion);
        VERBOSE(TEXT("\tdwDriverData           = %#x\r\n"), pOEMDevmode->dwDriverData);
    }
    else
    {
        ERR(ERRORTEXT("Dump(POEMDEV) unknown private OEM DEVMODE.\r\n"));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\debug.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 2001  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debugging functions.
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP
//
//
#ifndef _DEBUG_H
#define _DEBUG_H


// VC and Build use different debug defines.
// The following makes it so either will
// cause the inclusion of debugging code.
#if !defined(_DEBUG) && defined(DBG)
    #define _DEBUG      DBG
#elif defined(_DEBUG) && !defined(DBG)
    #define DBG         _DEBUG
#endif



/////////////////////////////////////////////////////////
//		Macros
/////////////////////////////////////////////////////////

//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// giDebugLevel
//  Global variable which set the current debug level to control
//  the amount of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ERR(msg)
//  Similiar to WARNING macro above - displays a message
//  if the current debug level is <= DBG_ERROR.
//
// ASSERT(cond)
//  Verify a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//  These macros require extra parantheses for the msg argument
//  example, ASSERTMSG(x > 0, ("x is less than 0\n"));
//           WARNING(("App passed NULL pointer, ignoring...\n"));
//

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_ERROR   4
#define DBG_RIP     5
#define DBG_NONE    6

#if DBG

    #define DebugMsg    DebugMessage

    //
    // Strip the directory prefix from a filename (ANSI version)
    //

    PCSTR
    StripDirPrefixA(
        IN PCSTR    pstrFilename
        );

    extern INT giDebugLevel;


    #define DBGMSG(level, prefix, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg("%s %s (%d): ", prefix, StripDirPrefixA(__FILE__), __LINE__); \
                    DebugMsg(msg); \
                } \
            }

    #define DBGPRINT(level, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg(msg); \
                } \
            }

    #define VERBOSE         if(giDebugLevel <= DBG_VERBOSE) DebugMsg
    #define TERSE           if(giDebugLevel <= DBG_TERSE) DebugMsg
    #define WARNING         if(giDebugLevel <= DBG_WARNING) DebugMsg
    #define ERR             if(giDebugLevel <= DBG_ERROR) DebugMsg

    #define ASSERT(cond) { \
                if (! (cond)) { \
                    RIP(("\n")); \
                } \
            }

    #define ASSERTMSG(cond, msg) { \
                if (! (cond)) { \
                    RIP(msg); \
                } \
            }

    #define RIP(msg) { \
                DBGMSG(DBG_RIP, "RIP", msg); \
                DebugBreak(); \
            }


#else // !DBG

    #define DebugMsg    NOP_FUNCTION

    #define VERBOSE     NOP_FUNCTION
    #define TERSE       NOP_FUNCTION
    #define WARNING     NOP_FUNCTION
    #define ERR         NOP_FUNCTION

    #define ASSERT(cond)

    #define ASSERTMSG(cond, msg)
    #define RIP(msg)
    #define DBGMSG(level, prefix, msg)
    #define DBGPRINT(level, msg)

#endif




/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR, ...);
BOOL DebugMessage(LPCWSTR, ...);
void Dump(PPUBLISHERINFO pPublisherInfo);
void Dump(POEMDMPARAM pOemDMParam);
void Dump(PPROPSHEETUI_INFO pPSUIInfo);
void Dump(POPTITEM pOptItem);
void Dump(POPTTYPE pOptType);
void Dump(POPTPARAM pOptParam, WORD wCount);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\devmode.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2001  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Devmode.h
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for devmode functions.
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP
//
//
#ifndef _DEVMODE_H
#define _DEVMODE_H

#include "precomp.h"


////////////////////////////////////////////////////////
//      OEM Devmode Defines
////////////////////////////////////////////////////////




////////////////////////////////////////////////////////
//      OEM Devmode Type Definitions
////////////////////////////////////////////////////////

typedef struct tagOEMDEV
{
    OEM_DMEXTRAHEADER   dmOEMExtra;
    BOOL                dwDriverData;

} OEMDEV, *POEMDEV;

typedef const OEMDEV *PCOEMDEV;



/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

HRESULT hrOEMDevMode(DWORD dwMode, POEMDMPARAM pOemDMParam);
BOOL ConvertOEMDevmode(PCOEMDEV pOEMDevIn, POEMDEV pOEMDevOut, DWORD dwSize);
BOOL MakeOEMDevmodeValid(POEMDEV pOEMDevmode);
void Dump(PCOEMDEV pOEMDevIn);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\oemuni\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

    Abstract:

        This file specifies the target component being built and the list of
        sources files needed to build that component.  Also specifies optional
        compiler switches and libraries that are unique for the component being
        built.

!ENDIF

DLLBASE=0x70000000

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj


# To build version with debug output, add -D_DEBUG to C_DEFINES line below
!if defined(WINNT_40)       # NT4 kernel-mode driver
C_DEFINES=$(C_DEFINES) -DKERNEL_MODE -D_UNICODE -DUNICODE -DWINNT_40 -DOEMCOM
!else                       # NT5 Drivers
C_DEFINES=$(C_DEFINES) -DKERNEL_MODE -D_UNICODE -DUNICODE -DOEMCOM
!endif


TARGETLIBS=  $(SDK_LIB_PATH)\uuid.lib


INCLUDES=..;$(SDK_INC_PATH)\MFC42

SOURCES= ..\dllentry.cpp    \
         ..\intrface.cpp    \
         ..\ddihook.cpp     \
         ..\debug.cpp       \
         ..\devmode.cpp     \
         ..\enable.cpp      \
         ..\oemuni.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\debug.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 2001  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.cpp
//    
//
//  PURPOSE:  Debug functions.
//
//
//	Functions:
//
//
//
//  PLATFORMS:	Windows 2000, Windows XP
//
//

#include "precomp.h"
#include "oem.h"
#include "debug.h"



////////////////////////////////////////////////////////
//      INTERNAL DEFINES
////////////////////////////////////////////////////////

#define DEBUG_BUFFER_SIZE       1024
#define PATH_SEPARATOR          '\\'



// Determine what level of debugging messages to eject. 
#ifdef VERBOSE_MSG
    #define DEBUG_LEVEL     DBG_VERBOSE
#elif TERSE_MSG
    #define DEBUG_LEVEL     DBG_TERSE
#elif WARNING_MSG
    #define DEBUG_LEVEL     DBG_WARNING
#elif ERROR_MSG
    #define DEBUG_LEVEL     DBG_ERROR
#elif RIP_MSG
    #define DEBUG_LEVEL     DBG_RIP
#elif NO_DBG_MSG
    #define DEBUG_LEVEL     DBG_NONE
#else
    #define DEBUG_LEVEL     DBG_WARNING
#endif



////////////////////////////////////////////////////////
//      EXTERNAL GLOBALS
////////////////////////////////////////////////////////

INT giDebugLevel = DEBUG_LEVEL;




////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist);
static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist);




//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist)
{
    DWORD   dwSize = DEBUG_BUFFER_SIZE;
    LPSTR   lpszMsgBuf = NULL;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    do
    {
        // Allocate memory for message buffer.
        if(NULL != lpszMsgBuf)
        {
            delete[] lpszMsgBuf;
            dwSize *= 2;
        }
        lpszMsgBuf = new CHAR[dwSize + 1];
        if(NULL == lpszMsgBuf)
            return FALSE;

    // Pass the variable parameters to wvsprintf to be formated.
    } while (_vsnprintf(lpszMsgBuf, dwSize, lpszMessage, arglist) < 0);

    // Dump string to Debug output.
    OutputDebugStringA(lpszMsgBuf);

    // Cleanup.
    delete[] lpszMsgBuf;

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist)
{
    LPWSTR     lpszMsgBuf;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    // Allocate memory for message buffer.
    lpszMsgBuf = new WCHAR[dwSize + 1];    
    if(NULL == lpszMsgBuf)
        return FALSE;

    // Pass the variable parameters to wvsprintf to be formated.
    vswprintf(lpszMsgBuf, lpszMessage, arglist);

    // Dump string to debug output.
    OutputDebugStringW(lpszMsgBuf);

    // Clean up.
    delete[] lpszMsgBuf;

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV for processing.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCWSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV to be processed.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(MAX_PATH, lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}

void Dump(PPUBLISHERINFO pPublisherInfo)
{
    VERBOSE(TEXT("pPublisherInfo:\r\n"));
    if(NULL == pPublisherInfo)
    {
        VERBOSE(TEXT("\tpPublisherInfo is NULL!\r\n"));
        return;
    }
    VERBOSE(TEXT("\tdwMode           =   %#x\r\n"), pPublisherInfo->dwMode);
    VERBOSE(TEXT("\twMinoutlinePPEM  =   %d\r\n"), pPublisherInfo->wMinoutlinePPEM);
    VERBOSE(TEXT("\twMaxbitmapPPEM   =   %d\r\n"), pPublisherInfo->wMaxbitmapPPEM);
}

void Dump(POEMDMPARAM pOemDMParam)
{
    VERBOSE(TEXT("pOemDMParam:\r\n"));
    if(NULL == pOemDMParam)
    {
        VERBOSE(TEXT("\tpOemDMParam is NULL!\r\n"));
        return;
    }
    VERBOSE(TEXT("\tcbSize = %d\r\n"), pOemDMParam->cbSize);
    VERBOSE(TEXT("\tpdriverobj = %#x\r\n"), pOemDMParam->pdriverobj);
    VERBOSE(TEXT("\thPrinter = %#x\r\n"), pOemDMParam->hPrinter);
    VERBOSE(TEXT("\thModule = %#x\r\n"), pOemDMParam->hModule);
    VERBOSE(TEXT("\tpPublicDMIn = %#x\r\n"), pOemDMParam->pPublicDMIn);
    VERBOSE(TEXT("\tpPublicDMOut = %#x\r\n"), pOemDMParam->pPublicDMOut);
    VERBOSE(TEXT("\tpOEMDMIn = %#x\r\n"), pOemDMParam->pOEMDMIn);
    VERBOSE(TEXT("\tpOEMDMOut = %#x\r\n"), pOemDMParam->pOEMDMOut);
    VERBOSE(TEXT("\tcbBufSize = %d\r\n"), pOemDMParam->cbBufSize);
}

void Dump(PPROPSHEETUI_INFO pPSUIInfo)
{
    VERBOSE(TEXT("pPSUIInfo:\r\n"));
    if(NULL == pPSUIInfo)
    {
        VERBOSE(TEXT("\tpPSUIInfo is NULL!\r\n"));
        return;
    }
    VERBOSE(TEXT("\tcbSize          = %d\r\n"), pPSUIInfo->cbSize);
    VERBOSE(TEXT("\tVersion         = %#x\r\n"), pPSUIInfo->Version);
    VERBOSE(TEXT("\tFlags           = %#x\r\n"), pPSUIInfo->Flags);
    VERBOSE(TEXT("\tReason          = %d\r\n"), pPSUIInfo->Reason);
    VERBOSE(TEXT("\thComPropSheet   = %#x\r\n"), pPSUIInfo->hComPropSheet);
    VERBOSE(TEXT("\tpfnComPropSheet = %#x\r\n"), pPSUIInfo->pfnComPropSheet);
    VERBOSE(TEXT("\tlParamInit      = %#x\r\n"), pPSUIInfo->lParamInit);
    VERBOSE(TEXT("\tUserData        = %#x\r\n"), pPSUIInfo->UserData);
    VERBOSE(TEXT("\tResult          = %#x\r\n"), pPSUIInfo->Result);
}

void Dump(POPTITEM pOptItem)
{
    VERBOSE(TEXT("pOptItem:\r\n"));
    if(NULL == pOptItem)
    {
        VERBOSE(TEXT("\tpOptItem is NULL!\r\n"));
        return;
    }
    VERBOSE(TEXT("\tcbSize          = %d\r\n"),     pOptItem->cbSize);
    VERBOSE(TEXT("\tLevel           = %d\r\n"),     pOptItem->Level);
    VERBOSE(TEXT("\tDlgPageIdx      = %d\r\n"),     pOptItem->DlgPageIdx);
    VERBOSE(TEXT("\tFlags           = 0x%x\r\n"),   pOptItem->Flags);
    VERBOSE(TEXT("\tUserData        = 0x%p\r\n"),   pOptItem->UserData);
    VERBOSE(TEXT("\tpName           = %s\r\n"),     pOptItem->pName ? pOptItem->pName : TEXT("<NULL>"));
    VERBOSE(TEXT("\tpSel            = 0x%p\r\n"),   pOptItem->pSel);
    VERBOSE(TEXT("\tpExtChkBox      = 0x%p\r\n"),   pOptItem->pExtChkBox);
    VERBOSE(TEXT("\tpExtChkBox      = 0x%p\r\n"),   pOptItem->pExtChkBox);
    VERBOSE(TEXT("\tHelpIndex       = 0x%x\r\n"),   pOptItem->HelpIndex);
    VERBOSE(TEXT("\tDMPubID         = 0x%x\r\n"),   pOptItem->DMPubID);
    VERBOSE(TEXT("\tUserItemID      = 0x%x\r\n"),   pOptItem->UserItemID);
    VERBOSE(TEXT("\twReserved       = 0x%x\r\n"),   pOptItem->wReserved);
    VERBOSE(TEXT("\tpOIExt          = 0x%p\r\n"),   pOptItem->pOIExt);

    Dump(pOptItem->pOptType);
}

void Dump(POPTTYPE pOptType)
{
    VERBOSE(TEXT("\tpOptType:\r\n"));
    if(NULL == pOptType)
    {
        VERBOSE(TEXT("\t\tpOptType is NULL!\r\n"));
        return;
    }
    VERBOSE(TEXT("\t\tcbSize    = %d\r\n"),     pOptType->cbSize);
    VERBOSE(TEXT("\t\tType      = 0x%x\r\n"),   pOptType->Type);
    VERBOSE(TEXT("\t\tFlags     = 0x%x\r\n"),   pOptType->Flags);
    VERBOSE(TEXT("\t\tCount     = %d\r\n"),     pOptType->Count);
    VERBOSE(TEXT("\t\tCount     = 0x%x\r\n"),   pOptType->BegCtrlID);
    VERBOSE(TEXT("\t\tStyle     = 0x%x\r\n"),   pOptType->Style);

    Dump(pOptType->pOptParam, pOptType->Count);
}

void Dump(POPTPARAM pOptParam, WORD wCount)
{
    if(NULL == pOptParam)
    {
        VERBOSE(TEXT("\t\tpOptParam is NULL!\r\n"));
        return;
    }

    for(WORD wIndex = 0; wIndex < wCount; ++wIndex)
    {
        VERBOSE(TEXT("\t\tpOptParam[wIndex]:\r\n"));
        VERBOSE(TEXT("\t\t\tcbSize    = %d\r\n"),     pOptParam[wIndex].cbSize);
        VERBOSE(TEXT("\t\t\tFlags     = 0x%x\r\n"),   pOptParam[wIndex].Flags);
        VERBOSE(TEXT("\t\t\tStyle     = 0x%x\r\n"),   pOptParam[wIndex].Style);
        VERBOSE(TEXT("\t\t\tpData     = 0x%p\r\n"),   pOptParam[wIndex].pData);
        VERBOSE(TEXT("\t\t\tIconID    = 0x%p\r\n"),   pOptParam[wIndex].IconID);
        VERBOSE(TEXT("\t\t\tlParam    = 0x%p\r\n"),   pOptParam[wIndex].lParam);
    }
}


PCSTR
StripDirPrefixA(
    IN PCSTR    pstrFilename
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    PCSTR   pstr;

    if (pstr = strrchr(pstrFilename, PATH_SEPARATOR))
        return pstr + 1;

    return pstrFilename;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\dllentry.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2001  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	dllentry.cpp
//    
//
//  PURPOSE:  Source module for DLL entry function(s).
//
//
//	Functions:
//
//		DllMain
//
//
//  PLATFORMS:	Windows 2000, Windows XP
//
//

#include "precomp.h"
#include "oemui.h"
#include "debug.h"



// Need to export these functions as c declarations.
extern "C" {


///////////////////////////////////////////////////////////
//
// DLL entry point
//
BOOL WINAPI DllMain(HINSTANCE hInst, WORD wReason, LPVOID lpReserved)
{
	switch(wReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(DLLTEXT("Process attach.\r\n"));
            ghInstance = hInst;
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(DLLTEXT("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(DLLTEXT("Process detach.\r\n"));
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(DLLTEXT("Thread detach.\r\n"));
			break;
	}

	return TRUE;
}


}  // extern "C" closing bracket
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\features.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  2001  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Features.h
//    
//
//  PURPOSE:	Defines wrapper class for WinXP PS Features and Options.
//
//
//  PLATFORMS:    Windows XP
//
//
#ifndef _FEATURES_H
#define _FEATURES_H

#include "precomp.h"
#include "helper.h"


////////////////////////////////////////////////////////
//      Defines and Macros
////////////////////////////////////////////////////////



////////////////////////////////////////////////////////
//      Type Definitions
////////////////////////////////////////////////////////

// Struct used to map keyword to information
// such as display name and stickiness.
typedef struct _tagKeywordMap
{
    PCSTR   pszKeyword;
    PCWSTR  pwszModule;
    UINT    uDisplayNameID;
    DWORD   dwMode;
    DWORD   dwFlags;

} KEYWORDMAP, *PKEYWORDMAP;


// Struct container for info about
// feature that is in conflict.
typedef struct  _tagConflict
{
    PCSTR   pszFeatureKeyword;
    PCWSTR  pszFeature;
    PSTR    pszOptionKeyword;
    PWSTR   pszOption;
    PSTR    pmszReasons;
    DWORD   dwReasonsSize;

} CONFLICT, *PCONFLICT;



////////////////////////////////////////////////////////
//      Class Definitions
////////////////////////////////////////////////////////

// Class wrapper and container for Core Driver Feature Options.
class COptions
{
    private:

        // Option Infomation
        class OPTION_INFO
        {
            public:
                PKEYWORDMAP pMapping;
                PWSTR       pszDisplayName;

            public:
                OPTION_INFO()
                {
                    pMapping        = NULL;
                    pszDisplayName  = NULL;
                }

                virtual ~OPTION_INFO(){}
        };
        typedef class OPTION_INFO   *POPTION_INFO;

        // Data Members
        WORD            m_wOptions;     // Count of the number of options contained for an instance of the class.
        BYTE            m_cType;        // CPSUI Option Type (i.e. what to set pOptItem->pOptType->Type to).
        PSTR            m_pmszRaw;      // The RAW multi NULL terminated string buffer used for IPrintCoreUI2::EnumOptions().
        PCSTR           m_pszFeature;   // Pointer to the feature for which the enumerate options belong.
        PCSTR          *m_ppszOptions;  // String list pointer that points to begining of each of the strings in multi-SZ pointed to by m_pmszRaw.
        POINT           m_ptRange;      // Option range for features, such as %JobTimeout, that have a range of possible vaules not a small selection list.
        DWORD           m_dwSize;       // Size of m_pmszRaw buffer.
        PWSTR           m_pszUnits;     // String that contains the unit specifier for options, such as %JobTimeout, which need Units (i.e. seconds).
        HANDLE          m_hHeap;        // Heap to do allocations from.
        POPTION_INFO    m_pInfo;        // Array of Info about each option for a feature.

        union {                         // Current selected option for a feature.
            LONG    m_Sel;              // This is what pOptItem->m_pSel or pOptItem->m_Sel
            LPTSTR  m_pSel;             // will be set to.
        };

    public:
        COptions();
        virtual ~COptions();

        // Populate Options list for specified keyword.
        HRESULT COptions::Acquire(HANDLE hHeap, CUIHelper &Helper, POEMUIOBJ poemuiobj, 
                                  PCSTR pszFeature);

        // Returns number of feature options contained in class instance.
        inline WORD GetCount() const {return m_wOptions;}

        // Returns selection.
        inline LPTSTR GetSelection() const {return m_pSel;}

        // Return nth options keyword.
        PCSTR GetKeyword(WORD wIndex) const;

        // Return nth option Display Name.
        PCWSTR GetName(WORD wIndex) const;

        // Find option with matching keyword string.
        WORD FindOption(PCSTR pszOption, WORD wDefault) const;

        // Initializes options portion of OPTITEM.
        HRESULT InitOptItem(HANDLE hHeap, POPTITEM pOptItem);

        // Refresh option selection.
        HRESULT RefreshSelection(CUIHelper &Helper, POEMUIOBJ poemuiobj);

    private:
        void Init();
        void Clear();
        void FreeOptionInfo();
        HRESULT GetOptionsForSpecialFeatures(CUIHelper &Helper, POEMUIOBJ poemuiobj);
        HRESULT GetOptionsForOutputPSLevel(CUIHelper &Helper, POEMUIOBJ poemuiobj);
        HRESULT GetOptionSelectionString(CUIHelper &Helper, POEMUIOBJ poemuiobj, PSTR *ppszSel);
        HRESULT GetOptionSelectionLong(CUIHelper &Helper, POEMUIOBJ poemuiobj);
        HRESULT GetOptionSelectionShort(CUIHelper &Helper, POEMUIOBJ poemuiobj);
        HRESULT GetOptionSelectionIndex(CUIHelper &Helper, POEMUIOBJ poemuiobj);
};


// Class wrapper and container for Cor Driver Features.
class CFeatures
{
    private:

        // Feature Infomation
        class FEATURE_INFO
        {
            public:
                PKEYWORDMAP pMapping;
                PWSTR       pszDisplayName;
                COptions    Options;
                DWORD       dwMode;

            public:
                FEATURE_INFO()
                {
                    pMapping        = NULL;
                    pszDisplayName  = NULL;
                    dwMode          = 0;
                }

                virtual ~FEATURE_INFO() {}
        };
        typedef class FEATURE_INFO  *PFEATURE_INFO;

        WORD            m_wFeatures;        // Count of the number of features.
        WORD            m_wDocFeatures;     // Count of the number of Document sticky features.
        WORD            m_wPrintFeatures;   // Count of the number of Printer sticky features.
        PSTR            m_pmszRaw;          // Buffer for multi-SZ for call to IPrintCoreUI2::EnumFeatures.
        PCSTR          *m_ppszKeywords;     // String list that points to each of the strings in m_pmszRaw.
        DWORD           m_dwSize;           // Size of m_pmszRaw.
        HANDLE          m_hHeap;            // Heap to do allocations from.           
        PFEATURE_INFO   m_pInfo;            // Array of feature information about each of the enumerate features.

    public:
        CFeatures();
        virtual ~CFeatures();

        // Populates the Feature list
        HRESULT Acquire(HANDLE hHeap, CUIHelper &Helper, POEMUIOBJ poemuiobj);

        // Returns number of features contained in class instance.
        WORD GetCount(DWORD dwMode = 0) const;

        // Returns feature keyword.
        PCSTR GetKeyword(WORD wIndex, DWORD dwMode = 0) const;

        // Return feature Display Name.
        PCWSTR GetName(WORD wIndex, DWORD dwMode = 0) const;

        // Returns pointer to option class for nth feature.
        COptions* GetOptions(WORD wIndex, DWORD dwMode = 0) const;

        // Initializes OPTITEM for the feature.
        HRESULT InitOptItem(HANDLE hHeap, POPTITEM pOptItem, WORD wIndex, DWORD dwMode);

    private:
        void Init();
        void Clear();
        void FreeFeatureInfo();
        WORD GetModelessIndex(WORD wIndex, DWORD dwMode) const;
};



////////////////////////////////////////////////////////
//      Prototypes
////////////////////////////////////////////////////////

HRESULT DetermineFeatureDisplayName(HANDLE hHeap, CUIHelper &Helper, POEMUIOBJ poemuiobj, 
                                    PCSTR pszKeyword, const PKEYWORDMAP pMapping, 
                                    PWSTR *ppszDisplayName);
HRESULT DetermineOptionDisplayName(HANDLE hHeap, CUIHelper &Helper, POEMUIOBJ poemuiobj, 
                                   PCSTR pszFeature, PCSTR pszOption, 
                                   const PKEYWORDMAP pMapping, PWSTR *ppszDisplayName);
HRESULT DetermineStickiness(CUIHelper &Helper, POEMUIOBJ poemuiobj, PCSTR pszKeyword,
                            const PKEYWORDMAP pMapping,PDWORD pdwMode);

PKEYWORDMAP FindKeywordMapping(PKEYWORDMAP pKeywordMap, WORD wMapSize, PCSTR pszKeyword);
HRESULT GetDisplayNameFromMapping(HANDLE hHeap, PKEYWORDMAP pMapping, PWSTR *ppszDisplayName);

BOOL IsFeatureOptitem(POPTITEM pOptItem);
HRESULT SaveFeatureOptItems(HANDLE hHeap, CUIHelper *pHelper, POEMUIOBJ poemuiobj, 
                            HWND hWnd, POPTITEM pOptItem, WORD wItems);
HRESULT GetWhyConstrained(HANDLE hHeap, CUIHelper *pHelper, POEMUIOBJ poemuiobj,
                          PCSTR pszFeature, PCSTR pszOption, PSTR *ppmszReason,
                          PDWORD pdwSize);
HRESULT GetChangedFeatureOptions(HANDLE hHeap, POPTITEM pOptItem, WORD wItems, 
                                 PSTR *ppmszPairs, PWORD pdwPairs, PDWORD pdwSize);
PSTR GetOptionKeywordFromOptItem(HANDLE hHeap, POPTITEM pOptItem);
PWSTR GetOptionDisplayNameFromOptItem(HANDLE hHeap, POPTITEM pOptItem);
HRESULT RefreshOptItemSelection(CUIHelper *pHelper, POEMUIOBJ poemuiobj, POPTITEM pOptItems, 
                                WORD wItems);
HRESULT GetFirstConflictingFeature(HANDLE hHeap, CUIHelper *pHelper, POEMUIOBJ poemuiobj, 
                                   POPTITEM pOptItem, WORD wItems, PCONFLICT pConflict);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\features.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  2001  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Features.cpp
//    
//
//  PURPOSE:  Implementation wrapper class for WinXP PS Driver Features and Options.
//
//
//
//  PLATFORMS:    Windows XP
//
//

#include "precomp.h"
#include "debug.h"
#include "oemui.h"
#include "stringutils.h"
#include "features.h"
#include "resource.h"



////////////////////////////////////////////////////////
//      Internal Defines and Macros
////////////////////////////////////////////////////////

#define INITIAL_ENUM_FEATURES_SIZE          1024
#define INITIAL_ENUM_OPTIONS_SIZE           64
#define INITIAL_FEATURE_DISPLAY_NAME_SIZE   64
#define INITIAL_OPTION_DISPLAY_NAME_SIZE    32
#define INITIAL_GET_OPTION_SIZE             64
#define INITIAL_GET_REASON_SIZE             1024

#define DRIVER_FEATURE_PREFIX               '%'
#define IS_DRIVER_FEATURE(f)                (DRIVER_FEATURE_PREFIX == (f)[0])

// Flags that the uDisplayNameID should be returned as 
// MAKEINTRESOURCE() instead of loading the string resource.
#define RETURN_INT_RESOURCE     1

// Macros to test for conditions of KEYWORDMAP entry.
#define IS_MAPPING_INT_RESOURCE(p)  ((p)->dwFlags & RETURN_INT_RESOURCE)

// TAG the identifies feature OPTITEM data stuct.
#define FEATURE_OPTITEM_TAG     'FETR'


////////////////////////////////////////////////////////
//      Type Definitions
////////////////////////////////////////////////////////

// Struct used to identify OPTITEM as 
// feature OPTITEM and to map back from
// an OPTITEM to the feature.
typedef struct _tagFeatureOptitemData
{
    DWORD       dwSize;
    DWORD       dwTag;
    PCSTR       pszFeatureKeyword;
    COptions    *pOptions;

} FEATUREOPTITEMDATA, *PFEATUREOPTITEMDATA;



////////////////////////////////////////////////////////
//      Internal Constants
////////////////////////////////////////////////////////

static KEYWORDMAP gkmFeatureMap[] =
{
    "%AddEuro",                 NULL,                   IDS_ADD_EURO,           OEMCUIP_PRNPROP,    0,
    "%CtrlDAfter",              NULL,                   IDS_CTRLD_AFTER,        OEMCUIP_PRNPROP,    0,
    "%CtrlDBefore",             NULL,                   IDS_CTRLD_BEFORE,       OEMCUIP_PRNPROP,    0,
    //"%CustomPageSize",          NULL,                   IDS_PSCRIPT_CUSTOMSIZE, OEMCUIP_DOCPROP,    0,
    "%GraphicsTrueGray",        NULL,                   IDS_TRUE_GRAY_GRAPH,    OEMCUIP_PRNPROP,    0,
    "%JobTimeout",              NULL,                   IDS_JOBTIMEOUT,         OEMCUIP_PRNPROP,    0,
    "%MaxFontSizeAsBitmap",     NULL,                   IDS_PSMAXBITMAP,        OEMCUIP_PRNPROP,    0,
    "%MetafileSpooling",        NULL,                   IDS_METAFILE_SPOOLING,  OEMCUIP_DOCPROP,    0,
    "%MinFontSizeAsOutline",    NULL,                   IDS_PSMINOUTLINE,       OEMCUIP_PRNPROP,    0,
    "%Mirroring",               NULL,                   IDS_MIRROR,             OEMCUIP_DOCPROP,    0,
    "%Negative",                NULL,                   IDS_NEGATIVE_PRINT,     OEMCUIP_DOCPROP,    0,
    "%Orientation",             TEXT("COMPSTUI.DLL"),   IDS_CPSUI_ORIENTATION,  OEMCUIP_DOCPROP,    RETURN_INT_RESOURCE,
    "%OutputFormat",            NULL,                   IDS_PSOUTPUT_OPTION,    OEMCUIP_DOCPROP,    0,
    "%OutputProtocol",          NULL,                   IDS_PSPROTOCOL,         OEMCUIP_PRNPROP,    0,
    "%OutputPSLevel",           NULL,                   IDS_PSLEVEL,            OEMCUIP_DOCPROP,    0,
    "%PageOrder",               TEXT("COMPSTUI.DLL"),   IDS_CPSUI_PAGEORDER,    OEMCUIP_DOCPROP,    RETURN_INT_RESOURCE,
    "%PagePerSheet",            TEXT("COMPSTUI.DLL"),   IDS_CPSUI_NUP,          OEMCUIP_DOCPROP,    RETURN_INT_RESOURCE,
    "%PSErrorHandler",          NULL,                   IDS_PSERROR_HANDLER,    OEMCUIP_DOCPROP,    0,
    "%PSMemory",                NULL,                   IDS_POSTSCRIPT_VM,      OEMCUIP_PRNPROP,    0,
    "%TextTrueGray",            NULL,                   IDS_TRUE_GRAY_TEXT,     OEMCUIP_PRNPROP,    0,
    "%TTDownloadFormat",        NULL,                   IDS_PSTT_DLFORMAT,      OEMCUIP_DOCPROP,    0,
    "%WaitTimeout",             NULL,                   IDS_WAITTIMEOUT,        OEMCUIP_PRNPROP,    0,
};
static const NUM_FEATURE_MAP    = (sizeof(gkmFeatureMap)/sizeof(gkmFeatureMap[0]));


static KEYWORDMAP gkmOptionMap[] =
{
    "True",             TEXT("COMPSTUI.DLL"),       IDS_CPSUI_TRUE,             0,  RETURN_INT_RESOURCE,
    "False",            TEXT("COMPSTUI.DLL"),       IDS_CPSUI_FALSE,            0,  RETURN_INT_RESOURCE,
    "Portrait",         TEXT("COMPSTUI.DLL"),       IDS_CPSUI_PORTRAIT,         0,  RETURN_INT_RESOURCE,
    "Landscape",        TEXT("COMPSTUI.DLL"),       IDS_CPSUI_LANDSCAPE,        0,  RETURN_INT_RESOURCE,
    "RotatedLandscape", TEXT("COMPSTUI.DLL"),       IDS_CPSUI_ROT_LAND,         0,  RETURN_INT_RESOURCE,
    "Speed",            NULL,                       IDS_PSOPT_SPEED,            0,  RETURN_INT_RESOURCE,
    "Portability",      NULL,                       IDS_PSOPT_PORTABILITY,      0,  0,
    "EPS",              NULL,                       IDS_PSOPT_EPS,              0,  0,
    "Archive",          NULL,                       IDS_PSOPT_ARCHIVE,          0,  0,
    "ASCII",            NULL,                       IDS_PSPROTOCOL_ASCII,       0,  0,
    "BCP",              NULL,                       IDS_PSPROTOCOL_BCP,         0,  0,
    "TBCP",             NULL,                       IDS_PSPROTOCOL_TBCP,        0,  0,
    "Binary",           NULL,                       IDS_PSPROTOCOL_BINARY,      0,  0,
    "FrontToBack",      TEXT("COMPSTUI.DLL"),       IDS_CPSUI_FRONTTOBACK,      0,  RETURN_INT_RESOURCE,
    "BackToFront",      TEXT("COMPSTUI.DLL"),       IDS_CPSUI_BACKTOFRONT,      0,  RETURN_INT_RESOURCE,
    "1",                TEXT("COMPSTUI.DLL"),       IDS_CPSUI_NUP_NORMAL,       0,  RETURN_INT_RESOURCE,
    "2",                TEXT("COMPSTUI.DLL"),       IDS_CPSUI_NUP_TWOUP,        0,  RETURN_INT_RESOURCE,
    "4",                TEXT("COMPSTUI.DLL"),       IDS_CPSUI_NUP_FOURUP,       0,  RETURN_INT_RESOURCE,
    "6",                TEXT("COMPSTUI.DLL"),       IDS_CPSUI_NUP_SIXUP,        0,  RETURN_INT_RESOURCE,
    "9",                TEXT("COMPSTUI.DLL"),       IDS_CPSUI_NUP_NINEUP,       0,  RETURN_INT_RESOURCE,
    "16",               TEXT("COMPSTUI.DLL"),       IDS_CPSUI_NUP_SIXTEENUP,    0,  RETURN_INT_RESOURCE,
    "Booklet",          TEXT("COMPSTUI.DLL"),       IDS_CPSUI_BOOKLET,          0,  RETURN_INT_RESOURCE,
    "Automatic",        NULL,                       IDS_TTDL_DEFAULT,           0,  0,
    "Outline",          NULL,                       IDS_TTDL_TYPE1,             0,  0,
    "Bitmap",           NULL,                       IDS_TTDL_TYPE3,             0,  0,
    "NativeTrueType",   NULL,                       IDS_TTDL_TYPE42,            0,  0,
};
static const NUM_OPTION_MAP     = (sizeof(gkmOptionMap)/sizeof(gkmOptionMap[0]));




////////////////////////////////////////////
//
//  COptions Methods
//

//
//  Private Methods
// 

// Initializes class data members.
void COptions::Init()
{
    m_wOptions      = 0;
    m_cType         = TVOT_COMBOBOX;
    m_pmszRaw       = NULL;
    m_pszFeature    = NULL;
    m_ppszOptions   = NULL;
    m_ptRange.x     = 0;
    m_ptRange.y     = 0;
    m_dwSize        = 0;
    m_pszUnits      = NULL;
    m_hHeap         = NULL;
    m_pInfo         = NULL;
}

void COptions::Clear()
{
    // Free memory associated with data members.
    if(NULL != m_pmszRaw)       HeapFree(m_hHeap, 0, m_pmszRaw);
    if(NULL != m_ppszOptions)   HeapFree(m_hHeap, 0, m_ppszOptions);
    if( (NULL != m_pszUnits) && !IS_INTRESOURCE(m_pszUnits))    HeapFree(m_hHeap, 0, m_pszUnits);

    // Free option info.
    FreeOptionInfo();

    // Initialize data members.
    Init();
}

// Frees memory associated with Option Info array.
void COptions::FreeOptionInfo()
{
    // Validate parameters.
    if( (NULL == m_hHeap)
        ||
        (NULL == m_pInfo)
      )
    {
        return;
    }

    // Free strings in the array.
    for(WORD wIndex = 0; wIndex < m_wOptions; ++wIndex)
    {
        PWSTR   pszDisplay = m_pInfo[wIndex].pszDisplayName;

        if( (NULL != pszDisplay) 
            && 
            !(IS_INTRESOURCE(pszDisplay))
          ) 
        {
            HeapFree(m_hHeap, 0, pszDisplay);
        }
    }

    // Free the array.
    HeapFree(m_hHeap, 0, m_pInfo);
    m_pInfo = NULL;
}

// Will do init for features that need special handling.
HRESULT COptions::GetOptionsForSpecialFeatures(CUIHelper &Helper, POEMUIOBJ poemuiobj)
{
    HRESULT hrResult    = E_NOTIMPL;


    // See if this is a special feature.
    // If it is, then call the special option init for the
    // feature.
    if(!lstrcmpA(m_pszFeature, "%CustomPageSize"))
    {
        // There is no option init for CustomPageSize.
        // The item itself must be handled specially.
        hrResult = S_OK;
    }
    else if( !lstrcmpA(m_pszFeature, "%JobTimeout")
             ||
             !lstrcmpA(m_pszFeature, "%WaitTimeout")
           )
    {
        // JobTimeout and WaitTimeout feature options are string representations 
        // of an integer that represents number of seconds in the range 0 through 
        // 2,147,483,647 (i.e. LONG_MAX).  However, COMPSTUI limits us to
        // WORD size, which has range of 0 to 32,767 (i.e. SHRT_MAX).
        m_cType     = TVOT_UDARROW;
        m_ptRange.x = 0;
        m_ptRange.y = SHRT_MAX;
        hrResult    = GetOptionSelectionShort(Helper, poemuiobj);
        if(!SUCCEEDED(hrResult))
        {
            ERR(ERRORTEXT("COptions::GetOptionsForSpecialFeatures() failed to get current selection for feature %hs. (hrResult = 0x%x)\r\n"), 
                m_pszFeature,
                hrResult);

            goto Exit;
        }
    }
    else if( !lstrcmpA(m_pszFeature, "%MaxFontSizeAsBitmap")
             ||
             !lstrcmpA(m_pszFeature, "%MinFontSizeAsOutline")
           )
    {
        // MaxFontSizeAsBitmap, and MinFontSizeAsOutline feature options 
        // are string representations of an integer that represents number 
        // of pixels in the range 0 through 32,767 (i.e. SHRT_MAX).
        m_cType     = TVOT_UDARROW;
        m_ptRange.x = 0;
        m_ptRange.y = SHRT_MAX;
        hrResult    = GetOptionSelectionShort(Helper, poemuiobj);
        if(!SUCCEEDED(hrResult))
        {
            ERR(ERRORTEXT("COptions::GetOptionsForSpecialFeatures() failed to get current selection for feature %hs. (hrResult = 0x%x)\r\n"), 
                m_pszFeature,
                hrResult);

            goto Exit;
        }
    }
    else if( !lstrcmpA(m_pszFeature, "%PSMemory") )
    {
        DWORD   dwType;
        DWORD   dwLevel;
        DWORD   dwNeeded;


        // PSMemory option is string representation of an integer
        // that represents number of seconds in the range 0
        // through 32,767 (i.e. SHRT_MAX).
        // However, the minimum is 172 KB for Level 1 and 249 KB for level 2
        m_cType     = TVOT_UDARROW;
        m_ptRange.y = SHRT_MAX;
        hrResult    = GetOptionSelectionShort(Helper, poemuiobj);
        if(!SUCCEEDED(hrResult))
        {
            ERR(ERRORTEXT("COptions::GetOptionsForSpecialFeatures() failed to get current selection for feature %hs. (hrResult = 0x%x)\r\n"), 
                m_pszFeature,
                hrResult);

            goto Exit;
        }

        // Get the global attribute for max language level.
        hrResult = Helper.GetGlobalAttribute(poemuiobj, 
                                             0, 
                                             "LanguageLevel", 
                                             &dwType, 
                                             (PBYTE) &dwLevel, 
                                             sizeof(dwLevel), 
                                             &dwNeeded);
        if(!SUCCEEDED(hrResult))
        {
            ERR(ERRORTEXT("COptions::GetOptionsForSpecialFeatures() failed to get global attribute \"LanguageLevel\". (hrResult = 0x%x)\r\n"), 
                hrResult);

            goto Exit;
        }

        // Set minimum range based on PS Max Language level.
        switch(dwLevel)
        {
            case 1:
                m_ptRange.x     = 172;
                break;

            default:
            case 2:
            case 3:
                m_ptRange.x     = 249;
                break;
        }

        // Get Units string.
        //GetStringResource(m_pszUnits
    }
    else if(!lstrcmpA(m_pszFeature, "%OutputPSLevel"))
    {
        hrResult = GetOptionsForOutputPSLevel(Helper, poemuiobj);
        if(!SUCCEEDED(hrResult))
        {
            ERR(ERRORTEXT("COptions::GetOptionsForSpecialFeatures() failed to get current selection for feature %hs. (hrResult = 0x%x)\r\n"), 
                m_pszFeature,
                hrResult);

            goto Exit;
        }
    }


Exit:

    return hrResult;
}

// Do init for PS Level options.
HRESULT COptions::GetOptionsForOutputPSLevel(CUIHelper &Helper, POEMUIOBJ poemuiobj)
{
    WORD    wCount      = 0;
    DWORD   dwLevel     = 0;
    DWORD   dwType      = -1;
    DWORD   dwNeeded    = 0;
    HRESULT hrResult    = E_NOTIMPL;


    // PS Level is integers from 1 to "LanguageLevel"
    // global atribute.
    m_cType = TVOT_COMBOBOX;

    // Get the global attribute for max language level.
    hrResult = Helper.GetGlobalAttribute(poemuiobj, 
                                         0, 
                                         "LanguageLevel", 
                                         &dwType, 
                                         (PBYTE) &dwLevel, 
                                         sizeof(dwLevel), 
                                         &dwNeeded);
    if(!SUCCEEDED(hrResult))
    {
        ERR(ERRORTEXT("COptions::GetOptionsForOutputPSLevel() failed to get global attribute \"LanguageLevel\". (hrResult = 0x%x)\r\n"), 
            hrResult);

        goto Exit;
    }

    //
    // Create Options for PS Level
    //
    
    // Set the number of options to the PS Level supported.
    m_wOptions = (WORD) dwLevel;

    // Allocate keyword list.
    // Allocate memory for pointer to keyword and the keyword itself, so that
    // the memory for the keyword strings will get de-allocated with the keyword list
    // on object destruction, just like regular features for which EnumOptions works.
    // User the size of a pointer (4 bytes on x86, and 8 on IA64) so that
    // it begining of the keyword strings will be DWORD or QUADWORD aligned
    // for x86 and IA64 respectively.  Keyword strings aren't required to
    // be DWORD or QUADWORD aligned, but it is more optimal.  Also, this gives
    // some additional space for the case of %OutputPSLevel keywords, which are
    // in the range of 1 through the max PostScript level supported, and only
    // require 2 CHARs (1 for the digit and one for the NULL terminator).
    m_ppszOptions = (PCSTR *) HeapAlloc(m_hHeap, HEAP_ZERO_MEMORY, m_wOptions * ( sizeof(PSTR) + sizeof(PCSTR *) ) );
    if(NULL == m_ppszOptions)
    {
        ERR(ERRORTEXT("COptions::GetOptionsForOutputPSLevel() failed to allocate option keyword array for PS Level.\r\n"));

        hrResult = E_OUTOFMEMORY;
        goto Exit;
    }


    // Allocate option info array.
    m_pInfo = (POPTION_INFO) HeapAlloc(m_hHeap, HEAP_ZERO_MEMORY, m_wOptions * sizeof(OPTION_INFO));
    if(NULL == m_pInfo)
    {
        ERR(ERRORTEXT("COptions::GetOptionsForOutputPSLevel() failed to allocate info array for PS Level.\r\n"));

        hrResult = E_OUTOFMEMORY;
        goto Exit;
    }

    // Init the option info.
    for(wCount = 0; wCount < m_wOptions; ++wCount)
    {
        // Init keyword.
        // The memory for both the keyword list and the keyword strings was allocated above.
        m_ppszOptions[wCount] = (PSTR)(m_ppszOptions + m_wOptions) + (sizeof(PSTR) * wCount);
        _snprintf(const_cast<PSTR>(m_ppszOptions[wCount]), sizeof(PSTR), "%d", wCount + 1);

        // Init option display name.
        m_pInfo[wCount].pszDisplayName = (PWSTR) HeapAlloc(m_hHeap, HEAP_ZERO_MEMORY, 2 * sizeof(WCHAR));
        if(NULL == m_pInfo[wCount].pszDisplayName)
        {
            ERR(ERRORTEXT("COptions::GetOptionsForOutputPSLevel() failed to allocate display string for Level %d.\r\n"), 
                          wCount);

            hrResult = E_OUTOFMEMORY;
            goto Exit;
        }
    
        // Init option display name.
        _snwprintf(m_pInfo[wCount].pszDisplayName, 2, TEXT("%d"), wCount + 1);
    }

    //
    // Get Current Selection
    //

    hrResult = GetOptionSelectionIndex(Helper, poemuiobj);


Exit:

    // Don't need to clean up memory allocation on error, since
    // all memory allocated are assigned to data members, which
    // will be cleaned up in the object destructor.

    return hrResult;
}

HRESULT COptions::GetOptionSelectionString(CUIHelper &Helper, POEMUIOBJ poemuiobj, PSTR *ppszSel)
{
    PSTR    pmszFeature     = NULL;
    PSTR    pmszBuf         = NULL;
    WORD    wCount          = 0;
    PCSTR  *ppszList        = NULL;
    DWORD   dwFeatureSize   = 0;
    DWORD   dwNeeded        = 0;
    DWORD   dwSize          = INITIAL_GET_OPTION_SIZE;
    HRESULT hrResult        = S_OK;


    //
    // Make single feature multi-sz.
    //

    // Allocate singe feature multi-sz buffer.
    dwFeatureSize = lstrlenA(m_pszFeature) + 2;
    pmszFeature = (PSTR) HeapAlloc(m_hHeap, HEAP_ZERO_MEMORY, dwFeatureSize);
    if(NULL == pmszFeature)
    {
        ERR(ERRORTEXT("COptions::GetOptionSelectionString() failed to allocate buffer for single feature multi-sz for feature %hs.\r\n"),
                      m_pszFeature);

        hrResult = E_OUTOFMEMORY;
        goto Exit;
    }

    // Just need to do a regular string copy, since the buffer is already zero filled.
    strcpy(pmszFeature, m_pszFeature);

    // Allocated initial buffer of reasonible size.
    pmszBuf = (PSTR) HeapAlloc(m_hHeap, HEAP_ZERO_MEMORY, dwSize);
    if(NULL == pmszBuf)
    {
        ERR(ERRORTEXT("COptions::GetOptionSelectionString() failed to allocate buffer to get current setting for feature %hs.\r\n"),
                      m_pszFeature);

        hrResult = E_OUTOFMEMORY;
        goto Exit;
    }

    // Get current option selection.
    hrResult = Helper.GetOptions(poemuiobj, 
                                 0, 
                                 pmszFeature, 
                                 dwFeatureSize,
                                 pmszBuf,
                                 dwSize,
                                 &dwNeeded);
    if( (E_OUTOFMEMORY == hrResult) && (dwSize < dwNeeded) )
    {
        PSTR    pTemp   = NULL;


        // INVARIANT:  initial buffer not large enough.

        // Re-alloc buffer and try again.
        pTemp = (PSTR) HeapReAlloc(m_hHeap, HEAP_ZERO_MEMORY, pmszBuf, dwNeeded);
        if(NULL == pTemp)
        {
            ERR(ERRORTEXT("COptions::GetOptionSelectionString() failed to re-allocate buffer to get current setting for feature %hs.\r\n"),
                          m_pszFeature);

            hrResult = E_OUTOFMEMORY;
            goto Exit;
        }
        pmszBuf = pTemp;

        
        // Try to get current option selection again.
        hrResult = Helper.GetOptions(poemuiobj, 
                                     0, 
                                     pmszFeature, 
                                     dwFeatureSize,
                                     pmszBuf,
                                     dwNeeded,
                                     &dwNeeded);
    }

    if(!SUCCEEDED(hrResult))
    {
        ERR(ERRORTEXT("COptions::GetOptionSelectionString() failed to get current setting for feature %hs. (hrResult = 0x%x)\r\n"), 
            m_pszFeature,
            hrResult);

        goto Exit;
    }

    // NOTE: The return string from GetOptions() may return
    //       contain no strings and not return a HRESULT error
    //       when the feature isn't supported in the current document or 
    //       printer sticky mode.
    if('\0' == pmszBuf[0])
    {
        // Feature not supported for this sticky mode.
        goto Exit;
    }

    // Parse the results buffer to see what the current setting is.
    hrResult = MakeStrPtrList(m_hHeap, pmszBuf, &ppszList, &wCount);
    if(!SUCCEEDED(hrResult))
    {
        ERR(ERRORTEXT("COptions::GetOptionSelectionString() failed to make string list for GetOptions() return for feature %hs. (hrResult = 0x%x)\r\n"), 
            m_pszFeature,
            hrResult);

        goto Exit;
    }

    // Check that we got 2 strings back.
    if(2 != wCount)
    {
        WARNING(DLLTEXT("COptions::GetOptionSelectionString() the GetOption() return string list for \r\n\tfeature %hs is not of size 2.\r\n\tNumber of string is %d\r\n"),
                        m_pszFeature,
                        wCount);

        // Bail if we don't have at least 2 strings.
        if(2 > wCount)
        {
            goto Exit;
        }
    }

    // Return copy of just the GetOption() result.
    *ppszSel = MakeStringCopy(m_hHeap, ppszList[1]);
    if(NULL == *ppszSel)
    {
        ERR(ERRORTEXT("COptions::GetOptionSelectionString() failed to duplicate string GetOptions() return for feature %hs. (hrResult = 0x%x)\r\n"), 
            m_pszFeature,
            hrResult);

        hrResult = E_OUTOFMEMORY;
        goto Exit;
    }


Exit:

    // Free local buffers.
    if(NULL != pmszFeature) HeapFree(m_hHeap, 0, pmszFeature);
    if(NULL != pmszBuf)     HeapFree(m_hHeap, 0, pmszBuf);
    if(NULL != ppszList)    HeapFree(m_hHeap, 0, ppszList);

    return hrResult;
}

// Gets current Options selection for LONG value.
HRESULT COptions::GetOptionSelectionLong(CUIHelper &Helper, POEMUIOBJ poemuiobj)
{
    PSTR    pszSel      = NULL;
    HRESULT hrResult    = S_OK;


    // Get option selection string.
    hrResult = GetOptionSelectionString(Helper, poemuiobj, &pszSel);
    if(!SUCCEEDED(hrResult))
    {
        ERR(ERRORTEXT("COptions::GetOptionSelectionLong() failed to get string for GetOptions() return for feature %hs. (hrResult = 0x%x)\r\n"), 
            m_pszFeature,
            hrResult);

        goto Exit;
    }

    // Convert string option to LONG and uses that as the selection.
    if(NULL != pszSel) m_Sel = atol(pszSel);


Exit:

    // Free local buffers.
    if(NULL != pszSel)  HeapFree(m_hHeap, 0, pszSel);

    return hrResult;
}

// Gets current Options selection for SHORT value.
HRESULT COptions::GetOptionSelectionShort(CUIHelper &Helper, POEMUIOBJ poemuiobj)
{
    PSTR    pszSel      = NULL;
    HRESULT hrResult    = S_OK;


    // Get option selection string.
    hrResult = GetOptionSelectionString(Helper, poemuiobj, &pszSel);
    if(!SUCCEEDED(hrResult))
    {
        ERR(ERRORTEXT("COptions::GetOptionSelectionLong() failed to get string for GetOptions() return for feature %hs. (hrResult = 0x%x)\r\n"), 
            m_pszFeature,
            hrResult);

        goto Exit;
    }

    // Convert string option to LONG and uses that as the selection.
    if(NULL != pszSel) m_Sel = atoi(pszSel) & 0x00ffff;


Exit:

    // Free local buffers.
    if(NULL != pszSel)  HeapFree(m_hHeap, 0, pszSel);

    return hrResult;
}

// Gets current option selection for feature.
HRESULT COptions::GetOptionSelectionIndex(CUIHelper &Helper, POEMUIOBJ poemuiobj)
{
    PSTR    pszSel      = NULL;
    HRESULT hrResult    = S_OK;


    // Get option selection string.
    hrResult = GetOptionSelectionString(Helper, poemuiobj, &pszSel);
    if(!SUCCEEDED(hrResult))
    {
        ERR(ERRORTEXT("COptions::GetOptionSelectionIndex() failed to get string for GetOptions() return for feature %hs. (hrResult = 0x%x)\r\n"), 
            m_pszFeature,
            hrResult);

        goto Exit;
    }

    // Find the matching option for the string returned from GetOption.
    m_Sel = FindOption(pszSel, m_wOptions - 1);


Exit:

    // Free local buffers.
    if(NULL != pszSel)  HeapFree(m_hHeap, 0, pszSel);

    return hrResult;
}
 


//
//  Public Methods
// 

// Default constructor
COptions::COptions()
{
    Init();
}

// Destructor
COptions::~COptions()
{
    Clear();
}

// Get the option list for a feature
HRESULT COptions::Acquire(HANDLE hHeap,            
                          CUIHelper &Helper, 
                          POEMUIOBJ poemuiobj,
                          PCSTR pszFeature)
{
    DWORD   dwNeeded    = 0;
    HRESULT hrResult    = S_OK;


    VERBOSE(DLLTEXT("COptions::Acquire(0x%p, Helper, 0x%p, %hs) entered.\r\n"),
            hHeap,
            poemuiobj,
            pszFeature ? pszFeature : "NULL");

    // Don't retreive the Options again if we already got them.
    if( (0 < m_wOptions) 
        && 
        (NULL != m_pszFeature) 
        && 
        !lstrcmpA(m_pszFeature, pszFeature)
      )
    {
        VERBOSE(DLLTEXT("COptions::Acquire() already have options for feature %hs.\r\n"), m_pszFeature);
        VERBOSE(DLLTEXT("COptions::Acquire() returning with HRESULT of S_OK\r\n"));

        return S_OK;
    }

    // Save the heap handle for use later, such as freeing memory at destruction.
    m_hHeap = hHeap;

    // Store Keyword string.
    m_pszFeature = pszFeature;


    //
    // Enumerate Options.
    //


    // Some features require special handling for initializing their options.
    // EnumOpionts isn't implemented for these features.
    // Return of E_NOTIMPL indicates it isn't the feature doesn't
    // need special handling.
    hrResult = GetOptionsForSpecialFeatures(Helper, poemuiobj);
    if( SUCCEEDED(hrResult) 
        || 
        (!SUCCEEDED(hrResult) && (E_NOTIMPL != hrResult) )
      )
    {
        // We either dealt with the special feature or incounter an error
        // trying to deal with the special feature.

        goto Exit;
    }

    // To try to cut down on having to call EnumOptions more than once, 
    // pre-allocate a buffer of reasonable size.
    m_dwSize = INITIAL_ENUM_OPTIONS_SIZE;
    m_pmszRaw = (PSTR) HeapAlloc(m_hHeap, HEAP_ZERO_MEMORY, m_dwSize);
    if(NULL == m_pmszRaw)
    {
        ERR(ERRORTEXT("COptions::Acquire() alloc for options for feature %hs failed.\r\n"), m_pszFeature);

        hrResult = E_OUTOFMEMORY;
        goto Exit;
    }


    // Try to get options list with initial buffer.
    hrResult = Helper.EnumOptions(poemuiobj, 0, m_pszFeature, m_pmszRaw, m_dwSize, &dwNeeded);
    if( (E_OUTOFMEMORY == hrResult) && (m_dwSize < dwNeeded))
    {
        PSTR    pTemp;


        // INVARIANT:  options list multi-sz wasn't large enough.

        // Re-allocate the buffer and try again.
        pTemp = (PSTR) HeapReAlloc(m_hHeap, HEAP_ZERO_MEMORY, m_pmszRaw, dwNeeded);
        if(NULL == pTemp)
        {
            ERR(ERRORTEXT("COptions::Acquire() re-alloc for options list for feature %hs failed.\r\n"), m_pszFeature); 

            hrResult = E_OUTOFMEMORY;
            goto Exit;
        }
        m_pmszRaw = pTemp;
        m_dwSize = dwNeeded;

        // Try again to get the options list.
        hrResult = Helper.EnumOptions(poemuiobj, 0, m_pszFeature, m_pmszRaw, m_dwSize, &dwNeeded);
        if(!SUCCEEDED(hrResult))
        {
            ERR(ERRORTEXT("COptions::Acquire() failed to EnumOptions() for feature %hs after re-allocating buffer.\r\n"), m_pszFeature); 

            goto Exit;
        }
    }

    // Make sure we got the option list.
    // Can't do anything more with out it.
    if(!SUCCEEDED(hrResult))
    {
        if(E_NOTIMPL != hrResult) ERR(ERRORTEXT("COptions::Acquire() failed to enumerate options for feature %hs. (hrResult = 0x%x)\r\n"), m_pszFeature, hrResult); 

        goto Exit;
    }

    // INVARIANT:  successfully got option keyword list.

    // Create array of string pointers to the Option names
    // in the multi-sz we got from EnumOptions().
    hrResult = MakeStrPtrList(m_hHeap, m_pmszRaw, &m_ppszOptions, &m_wOptions);
    if(!SUCCEEDED(hrResult))
    {
        ERR(ERRORTEXT("COptions::Acquire() failed to create pointer list to options. (hrResult = 0x%x)\r\n"), hrResult); 

        goto Exit;
    }

    //
    //  Build Option Information
    //

    // Allocate array to hold feature info
    m_pInfo = (POPTION_INFO) HeapAlloc(m_hHeap, HEAP_ZERO_MEMORY, m_wOptions * sizeof(OPTION_INFO));
    if(NULL == m_pInfo)
    {
        ERR(ERRORTEXT("COptions::Acquire() failed to alloc feature info array.\r\n")); 

        hrResult = E_OUTOFMEMORY;
        goto Exit;
    }

    // For each option, build or get useful information, such as display name.
    for(WORD wIndex = 0; wIndex < m_wOptions; ++wIndex)
    {
        POPTION_INFO    pCurrent    = m_pInfo + wIndex;


        // Get or build a keyword mapping entry
        // that maps from keyword to usefully where to get info, such as 
        // display name, icon, option type, for keywords that may not be
        // able to get info for from Helper.
        pCurrent->pMapping = FindKeywordMapping(gkmOptionMap, NUM_OPTION_MAP, m_ppszOptions[wIndex]);

        // Get display names for each of the Options.
        // The function implements a heuristic for detemining the display name,
        // since can't get the display name from the UI Helper for all Options.
        hrResult = DetermineOptionDisplayName(m_hHeap, 
                                              Helper, 
                                              poemuiobj, 
                                              m_pszFeature,
                                              m_ppszOptions[wIndex],
                                              pCurrent->pMapping,
                                              &pCurrent->pszDisplayName);
        if(!SUCCEEDED(hrResult))
        {
            ERR(ERRORTEXT("COptions::Acquire() failed to get display name for %hs of feature %hs. (hrResult = 0x%x)\r\n"), 
                          m_ppszOptions[wIndex], 
                          m_pszFeature,
                          hrResult); 

            goto Exit;
        }
    }

    //
    // Get current option selection.
    //

    hrResult = GetOptionSelectionIndex(Helper, poemuiobj);


Exit:

    // Clean up if weren't successful.
    if(!SUCCEEDED(hrResult))
    {
        Clear();
    }

    VERBOSE(DLLTEXT("COptions::Acquire() returning with HRESULT of 0x%x\r\n"), hrResult);

    return hrResult;
}

// Return nth options keyword.
PCSTR COptions::GetKeyword(WORD wIndex) const
{
    // Validate parameters.
    if( (wIndex >= m_wOptions)
        ||
        (NULL == m_ppszOptions)
      )
    {
        return NULL;
    }

    return m_ppszOptions[wIndex];
}

// Return nth options display name.
PCWSTR COptions::GetName(WORD wIndex) const
{
    // Validate parameters.
    if( (wIndex >= m_wOptions)
        ||
        (NULL == m_pInfo)
      )
    {
        ERR(ERRORTEXT("COptions::GetName() invalid parameters.\r\n"));

        return NULL;
    }

    if(NULL == m_pInfo[wIndex].pszDisplayName) ERR(ERRORTEXT("COptions::GetName() returning NULL option display name.\r\n"));

    return m_pInfo[wIndex].pszDisplayName;
}

// Find option with matching keyword string.
WORD COptions::FindOption(PCSTR pszOption, WORD wDefault) const
{
    BOOL    bFound  = FALSE;
    WORD    wMatch  = wDefault;


    // Validate parameters.
    if( (NULL == pszOption)
        ||
        (NULL == m_ppszOptions)
      )
    {
        return wDefault;
    }

    // Walk the option keyword looking for a match.
    for(WORD wIndex = 0; !bFound && (wIndex < m_wOptions); ++wIndex)
    {
        bFound = !lstrcmpA(pszOption, m_ppszOptions[wIndex]);
        if(bFound)
        {
            wMatch = wIndex;
        }
    }

    return wMatch;
}

// Initializes OptItem with options for a feature.
HRESULT COptions::InitOptItem(HANDLE hHeap, POPTITEM pOptItem)
{
    WORD    wParams     = 0;
    WORD    wOptions    = 0;
    HRESULT hrResult    = S_OK;


    // Set option selection.
    pOptItem->pSel = m_pSel;

    // Get count of number of options.
    // NOTE: Some feature options have no counts.
    wOptions = GetCount();

    // Different OPTTYPE types require different number of OPTPARAMs.
    switch(m_cType)
    {
        // For up down arrow control, the OPTPARAMs need is 2.
        case TVOT_UDARROW:
            wParams = 2;
            break;

        // For combobox, the OPTPARAMs needed is on per options.
        case TVOT_COMBOBOX:
            wParams = wOptions;
            break;

        // The default is the option count.
        default:
            WARNING(DLLTEXT("COptions::InitOptItem() OPTTYPE type %d num of OPTPARAMs not handled. Default to option count of %d.\r\n"),
                            m_cType,
                            wOptions);
            wParams = wOptions;
            break;
    }

    // Only do OPTTYPEs if we have non-Zero number of OPTPARAMs.
    // Every OPTTYPE has at leas one OPTPARAM.
    if(0 < wParams)
    {
        // Allocate memory for feature options.
        pOptItem->pOptType = CreateOptType(hHeap, wParams);
        if(NULL == pOptItem->pOptType)
        {
            ERR(ERRORTEXT("COptions::InitOptItem() failed to allocate OPTTYPEs for OPTITEM %hs.\r\n"), 
                           m_pszFeature); 

            hrResult = E_OUTOFMEMORY;
            goto Exit;
        }

        // Set OPTTYPE.
        pOptItem->pOptType->Type = m_cType;

        // Different OPTTYPE types require different initialization.
        switch(m_cType)
        {
            // For up down arrow control, OPTPARAM[0] is used by the contrl.
            // pOptParam[0]->pData is the Units description string.
            // pOptParam[1].IconID is the min limit.
            // pOptParam[1].lParam is the max limit.
            case TVOT_UDARROW:
                assert(2 == wParams);
                pOptItem->pOptType->pOptParam[0].pData  = m_pszUnits;
                pOptItem->pOptType->pOptParam[1].IconID = m_ptRange.x;
                pOptItem->pOptType->pOptParam[1].lParam = m_ptRange.y;
                break;

            // For combobox, the pOptParam[n].pData is the display name of the option.
            case TVOT_COMBOBOX:
                for(WORD wIndex = 0; wIndex < wParams; ++wIndex)
                {
                    pOptItem->pOptType->pOptParam[wIndex].pData = const_cast<PWSTR>(GetName(wIndex));
                }
                break;

            default:
                ERR(ERRORTEXT("COptions::InitOptItem() OPTTYPE type %d OPTTYPE init not handled.\r\n"),
                              m_cType);
                break;
        }
    }


Exit:

    return hrResult;
}

// Refresh option selection.
HRESULT COptions::RefreshSelection(CUIHelper &Helper, POEMUIOBJ poemuiobj)
{
    HRESULT     hrResult = S_OK;


    // Method for getting option selection is based
    // on OPTTYPE type.
    switch(m_cType)
    {

        case TVOT_UDARROW:
            hrResult = GetOptionSelectionShort(Helper, poemuiobj);
            break;

        case TVOT_COMBOBOX:
            hrResult = GetOptionSelectionIndex(Helper, poemuiobj);
            break;

        default:
            ERR(ERRORTEXT("COptions::RefreshSelection() not handled for type %d OPTTYPE.\r\n"),
                           m_cType);
            break;
    }

    return hrResult;
}



////////////////////////////////////////////
//
//  CFeatures Methods
//

//
//  Private Methods
// 

// Initializes class
void CFeatures::Init()
{
    // Initialize data members.
    m_wFeatures         = 0;
    m_wDocFeatures      = 0;
    m_wPrintFeatures    = 0;
    m_pmszRaw           = NULL;
    m_ppszKeywords      = NULL;
    m_dwSize            = 0;
    m_hHeap             = NULL;
    m_pInfo             = NULL;
}

// Cleans up class and re-initialize it.
void CFeatures::Clear()
{
    // Free memory associated with data members.
    if(NULL != m_pmszRaw)       HeapFree(m_hHeap, 0, m_pmszRaw);
    if(NULL != m_ppszKeywords)  HeapFree(m_hHeap, 0, m_ppszKeywords);

    // Free feature info
    FreeFeatureInfo();

    // Re-initialize
    Init();
}

// Free feature info
void CFeatures::FreeFeatureInfo()
{
    // Validate parameters.
    if( (NULL == m_hHeap)
        ||
        (NULL == m_pInfo)
      )
    {
        return;
    }

    // Free memory associated with feature info.
    for(WORD wIndex = 0; wIndex < m_wFeatures; ++wIndex)
    {
        PWSTR   pszDisplay =  m_pInfo[wIndex].pszDisplayName;


        // Free display name.
        if( (NULL != pszDisplay)
            &&
            !IS_INTRESOURCE(pszDisplay)
          )
        {
            HeapFree(m_hHeap, 0, pszDisplay);
        }
    }

    // Free feature info array.
    // Feature Info array allocated with new so
    // that each of the constructors for COptions 
    // in fhte Feature Info array will be called.
    delete[] m_pInfo;
}

// Turns index for mode to modeless index, which
// is the real index to the feature.
WORD CFeatures::GetModelessIndex(WORD wIndex, DWORD dwMode) const
{
    WORD    wCount = 0;


    switch(dwMode)
    {
        // Number of features, all modes
        case 0:
            wCount = wIndex;
            break;

        // Find the nth feature that matches the mode
        case OEMCUIP_DOCPROP:
        case OEMCUIP_PRNPROP:
            // Walk the feature list looking for nth feature
            // with matching mode.
            for(wCount = 0; wCount < m_wFeatures; ++wCount)
            {
                // Count down to the feature we want.
                // Only count down for matching modes.
                if(dwMode == m_pInfo[wCount].dwMode)
                {
                    if(0 == wIndex)
                    {
                        break;
                    }
                    else
                    {
                        --wIndex;
                    }
                }
            }
            break;
    }

    return wCount;
}


//
//  Public Methods
// 

// Default constructor
CFeatures::CFeatures()
{
    Init();
}

// Destructor
CFeatures::~CFeatures()
{
    // Clean up class.
    Clear();
}

// Gets Core Driver Features, if not already retrieved.
HRESULT CFeatures::Acquire(HANDLE hHeap, 
                           CUIHelper &Helper, 
                           POEMUIOBJ poemuiobj
                          )
{
    WORD    wIndex      = 0;
    DWORD   dwNeeded    = 0;
    HRESULT hrResult    = S_OK;


    VERBOSE(DLLTEXT("CFeatures::Acquire(0x%p, Helper, 0x%p) entered.\r\n"),
            hHeap,
            poemuiobj);

    // Don't retreive the Features again if we already got them.
    if(0 < m_wFeatures)
    {
        VERBOSE(DLLTEXT("CFeatures::Acquire() features already enumerated.\r\n"));
        VERBOSE(DLLTEXT("CFeatures::Acquire() returning S_OK.\r\n"));

        return S_OK;
    }

    // Save the heap handle for use later, such as freeing memory at destruction.
    m_hHeap = hHeap;

    //
    // Enumerate features.
    //

    // To try to cut down on having to call EnumFeatures more than once, 
    // pre-allocate a buffer of reasonable size.
    m_dwSize = INITIAL_ENUM_FEATURES_SIZE;
    m_pmszRaw = (PSTR) HeapAlloc(m_hHeap, HEAP_ZERO_MEMORY, m_dwSize);
    if(NULL == m_pmszRaw)
    {
        ERR(ERRORTEXT("CFeatures::Acquire() alloc for feature list failed.\r\n")); 

        hrResult = E_OUTOFMEMORY;
        goto Exit;
    }


    // Try to get feature list with initial buffer.
    hrResult = Helper.EnumFeatures(poemuiobj, 0, m_pmszRaw, m_dwSize, &dwNeeded);
    if( (E_OUTOFMEMORY == hrResult) && (m_dwSize < dwNeeded))
    {
        PSTR    pTemp;


        // INVARIANT:  feature list multi-sz wasn't large enough.


        // Re-allocate the buffer and try again.
        pTemp = (PSTR) HeapReAlloc(m_hHeap, HEAP_ZERO_MEMORY, m_pmszRaw, dwNeeded);
        if(NULL == pTemp)
        {
            ERR(ERRORTEXT("CFeatures::Acquire() re-alloc for feature list failed.\r\n")); 

            hrResult = E_OUTOFMEMORY;
            goto Exit;
        }
        m_pmszRaw = pTemp;
        m_dwSize = dwNeeded;

        // Try again to get the feature list.
        hrResult = Helper.EnumFeatures(poemuiobj, 0, m_pmszRaw, m_dwSize, &dwNeeded);
        if(!SUCCEEDED(hrResult))
        {
            ERR(ERRORTEXT("CFeatures::Acquire() failed to EnumFeatures() after re-allocating buffer.\r\n")); 

            goto Exit;
        }
    }

    // Make sure we got the feature list.
    // Can't do anything more with out it.
    if(!SUCCEEDED(hrResult))
    {
        ERR(ERRORTEXT("CFeatures::Acquire() failed to enumerate features. (hrResult = 0x%x)\r\n"), hrResult); 

        goto Exit;
    }

    // INVARIANT:  successfully got feature keyword list.

    // Create array of string pointers to the feature keywords
    // in the multi-sz we got from EnumFreatures().
    hrResult = MakeStrPtrList(m_hHeap, m_pmszRaw, &m_ppszKeywords, &m_wFeatures);
    if(!SUCCEEDED(hrResult))
    {
        ERR(ERRORTEXT("CFeatures::Acquire() failed to create pointer list to keywords. (hrResult = 0x%x)\r\n"), hrResult); 

        goto Exit;
    }


    //
    //  Build Feature Information
    //


    // Allocate array to hold feature info
    // Use new for allocation so class 
    // constructors/destructors get called.
    m_pInfo = new FEATURE_INFO[m_wFeatures];
    if(NULL == m_pInfo)
    {
        ERR(ERRORTEXT("CFeatures::Acquire() failed to alloc feature info array.\r\n")); 

        hrResult = E_OUTOFMEMORY;
        goto Exit;
    }

    // For each feature, build/get feature info....
    for(wIndex = 0; wIndex < m_wFeatures; ++wIndex)
    {
        PFEATURE_INFO   pCurrent    = m_pInfo + wIndex;


        // Get or build a keyword mapping entry
        // that maps from keyword to usefully where to get info, such as 
        // display name, icon, option type, for keywords that may not be
        // able to get info for from Helper.
        pCurrent->pMapping = FindKeywordMapping(gkmFeatureMap, NUM_FEATURE_MAP, m_ppszKeywords[wIndex]);

        // Get display names for each of the featurs.
        // The function implements a heuristic for detemining the display name,
        // since can't get the display name from the UI Helper for all features.
        hrResult = DetermineFeatureDisplayName(m_hHeap, 
                                               Helper, 
                                               poemuiobj, 
                                               m_ppszKeywords[wIndex],
                                               pCurrent->pMapping,
                                               &pCurrent->pszDisplayName);
        if(!SUCCEEDED(hrResult))
        {
            ERR(ERRORTEXT("CFeatures::Acquire() failed to get display name for feature %hs. (hrResult = 0x%x)\r\n"), 
                          m_ppszKeywords[wIndex], 
                          hrResult); 

            goto Exit;
        }

        // Get options for each feature.
        // NOTE: some features don't have options; the HRESULT will be E_NOTIMPL for these.
        hrResult = pCurrent->Options.Acquire(hHeap,            
                                             Helper, 
                                             poemuiobj,
                                             m_ppszKeywords[wIndex]);
        if(!SUCCEEDED(hrResult) && (E_NOTIMPL != hrResult))
        {
            ERR(ERRORTEXT("CFeatures::Acquire() failed to get options for feature %hs. (hrResult = 0x%x)\r\n"), 
                          m_ppszKeywords[wIndex], 
                          hrResult); 

            goto Exit;
        }

        // Determine if feature is Printer or Document sticky.
        hrResult = DetermineStickiness(Helper, 
                                       poemuiobj, 
                                       m_ppszKeywords[wIndex],
                                       pCurrent->pMapping,
                                       &pCurrent->dwMode);
        // Don't propagate error if failure from unhandled driver feature.
        if( !SUCCEEDED(hrResult)
            &&
            !IS_DRIVER_FEATURE(m_ppszKeywords[wIndex])    
          )
        {
            ERR(ERRORTEXT("CFeatures::Acquire() failed to determine stickiness for feature %hs. (hrResult = 0x%x)\r\n"), 
                          m_ppszKeywords[wIndex], 
                          hrResult); 

            goto Exit;
        }

        // Keep track of mode counts.
        switch(pCurrent->dwMode)
        {
            case OEMCUIP_DOCPROP:
                ++m_wDocFeatures;
                break;

            case OEMCUIP_PRNPROP:
                ++m_wPrintFeatures;
                break;

            default:
                ERR(ERRORTEXT("CFeatures::Acquire() unknown stickiness for feature %hs.\r\n"), 
                              m_ppszKeywords[wIndex]); 
                break;
        }

    }

    // INVARIANT:  successfully build feature list.

    // Make sure that we always return success if we reach this point.
    hrResult = S_OK;


Exit:

    // Clean up if weren't successful.
    if(!SUCCEEDED(hrResult))
    {
        Clear();
    }


    VERBOSE(DLLTEXT("CFeatures::Acquire() returning HRESULT of 0x%x.\r\n"), hrResult);

    return hrResult;
}

// Returns number of features contained in class instance.
WORD CFeatures::GetCount(DWORD dwMode) const 
{
    WORD    wCount = 0;


    switch(dwMode)
    {
        // Number of features, all modes
        case 0:
            wCount = m_wFeatures;
            break;

        case OEMCUIP_DOCPROP:
            wCount = m_wDocFeatures;
            break;

        case OEMCUIP_PRNPROP:
            wCount = m_wPrintFeatures;
            break;

    }

    VERBOSE(DLLTEXT("CFeatures::GetCount() returning %d\r\n"), wCount);

    return wCount;
}

// Returns nth feature's keyword
PCSTR CFeatures::GetKeyword(WORD wIndex, DWORD dwMode) const
{
    // Validate parameters.
    if( (wIndex >= GetCount(dwMode))
        ||
        (NULL == m_ppszKeywords)
      )
    {
        return NULL;
    }

    // Get internal index.
    wIndex = GetModelessIndex(wIndex, dwMode);

    // Return keyword
    return m_ppszKeywords[wIndex];
}

// Return nth feature's Display Name.
PCWSTR CFeatures::GetName(WORD wIndex, DWORD dwMode) const
{
    // Validate parameters.
    if( (wIndex >= GetCount(dwMode))
        ||
        (NULL == m_pInfo)
      )
    {
        return NULL;
    }

    // Get internal index.
    wIndex = GetModelessIndex(wIndex, dwMode);

    // Return display name.
    return m_pInfo[wIndex].pszDisplayName;
}

// Returns pointer to option class for nth feature.
COptions* CFeatures::GetOptions(WORD wIndex, DWORD dwMode) const
{
    // Validate parameters.
    if( (wIndex >= GetCount(dwMode))
        ||
        (NULL == m_pInfo)
      )
    {
        return NULL;
    }

    // Get internal index.
    wIndex = GetModelessIndex(wIndex, dwMode);

    // Return options pointer.
    return &m_pInfo[wIndex].Options;
}

// Formats OPTITEM for specied feature.
HRESULT CFeatures::InitOptItem(HANDLE hHeap, POPTITEM pOptItem, WORD wIndex, DWORD dwMode)
{
    COptions            *pOptions   = NULL;
    HRESULT             hrResult    = S_OK;
    PFEATUREOPTITEMDATA pData       = NULL;


    // Validate parameters.
    if( (wIndex >= GetCount(dwMode))
        ||
        (NULL == m_pInfo)
        ||
        (NULL == pOptItem)
      )
    {
        return E_INVALIDARG;
    }

    // Map mode index to internal index.
    wIndex = GetModelessIndex(wIndex, dwMode);

    // Get name of feature.
    pOptItem->pName = const_cast<PWSTR>(GetName(wIndex));

    // Add feature OPTITEM data to OPTITEM to facilitate saving
    // selection changes.
    pData = (PFEATUREOPTITEMDATA) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(FEATUREOPTITEMDATA));
    if(NULL == pData)
    {
        ERR(ERRORTEXT("CFeatures::InitOptItem() failed to allocated memory for feature OPTITEM data."));

        hrResult = E_OUTOFMEMORY;
        goto Exit;
    }
    pData->dwSize               = sizeof(FEATUREOPTITEMDATA);
    pData->dwTag                = FEATURE_OPTITEM_TAG;
    pData->pszFeatureKeyword    = GetKeyword(wIndex);
    pData->pOptions             = GetOptions(wIndex);
    pOptItem->UserData          = (ULONG_PTR) pData;


    // Get pointer to options for this feature.
    // NOTE: some features do not have option list for various reasons.
    pOptions = GetOptions(wIndex);
    if(NULL != pOptions)
    {
        // Initialize COption parts of the OPTITEM 
        hrResult = pOptions->InitOptItem(hHeap, pOptItem);
    }

Exit:

    Dump(pOptItem);

    return hrResult;
}

//////////////////////////////////////////////////
//
//  Regular functions not part of class
//
//////////////////////////////////////////////////


// Maps feature keywords to display names for the features.
HRESULT DetermineFeatureDisplayName(HANDLE hHeap, 
                                    CUIHelper &Helper, 
                                    POEMUIOBJ poemuiobj, 
                                    PCSTR pszKeyword,
                                    const PKEYWORDMAP pMapping,
                                    PWSTR *ppszDisplayName)
{
    DWORD   dwDataType  = -1;
    DWORD   dwSize      = INITIAL_FEATURE_DISPLAY_NAME_SIZE;
    DWORD   dwNeeded    = 0;
    HRESULT hrResult    = S_OK;


    // Validate parameters.
    if( (NULL == hHeap)
        ||
        (NULL == pszKeyword)
        ||
        (NULL == ppszDisplayName)
      )
    {
        ERR(ERRORTEXT("DetermineFeatureDisplayName() invalid arguement.\r\n")); 

        hrResult = E_INVALIDARG;
        goto Exit;
    }

    //
    // Call the Helper function.
    // 

    // Helper will return Display Names for PPD Features, but
    // not for Driver Synthisized features (i.e. features prefixed with %).
    // Do it for Driver Synthisized features, just in case the helper
    // interface changes to support it.

    // Pre-allocate a buffer of reasonable size to try
    // to one have to call GetFeatureAttribute() once.
    *ppszDisplayName = (PWSTR) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwSize);
    if(NULL == *ppszDisplayName)
    {
        ERR(ERRORTEXT("DetermineFeatureDisplayName() alloc for feature display name failed.\r\n")); 

        hrResult = E_OUTOFMEMORY;
        goto Exit;
    }

    // Try to get diplay name for feature from Helper.
    hrResult = Helper.GetFeatureAttribute(poemuiobj, 
                                          0, 
                                          pszKeyword, 
                                          "DisplayName", 
                                          &dwDataType,
                                          (PBYTE) *ppszDisplayName, 
                                          dwSize, 
                                          &dwNeeded);
    if( (E_OUTOFMEMORY == hrResult) && (dwSize < dwNeeded))
    {
        PWSTR   pTemp;


        // INVARIANT: initial buffer wasn't large enough.

        // Re-alloc buffer and try again.
        pTemp = (PWSTR) HeapReAlloc(hHeap, HEAP_ZERO_MEMORY, *ppszDisplayName, dwNeeded);
        if(NULL == pTemp)
        {
            ERR(ERRORTEXT("DetermineFeatureDisplayName() re-alloc for feature display name failed.\r\n")); 

            hrResult = E_OUTOFMEMORY;
            goto Exit;
        }
        *ppszDisplayName = pTemp;

        // Try to get the display name from Helper, again.
        hrResult = Helper.GetFeatureAttribute(poemuiobj, 
                                              0, 
                                              pszKeyword, 
                                              "DisplayName", 
                                              &dwDataType,
                                              (PBYTE) *ppszDisplayName, 
                                              dwNeeded, 
                                              &dwNeeded);
    }

    if(SUCCEEDED(hrResult))
    {
        // INVARIANT:  Successfully got display name from Helper for feature.
        //             Don't need to do anything more.

        // Check the data type, it should be kADT_UNICODE.
        if(kADT_UNICODE != dwDataType) WARNING(DLLTEXT("DetermineFeatureDisplayName() feature attribute type not kADT_UNICODE. (dwDataType = %d)\r\n"), dwDataType);

        goto Exit;
    }

    // INVARIANT:  Did not get the display name from the Helper.

    // Free memory allocated for call to Helper.
    if(NULL != *ppszDisplayName) 
    {
        HeapFree(hHeap, 0, *ppszDisplayName);
        *ppszDisplayName = NULL;
    }

    // Try alternative methods for getting the display name other 
    // than from the Helper function.
    // If we have a mapping entry, then try to get resource string
    // for the display name.
    // Otherwise, covert the keyword to UNICODE and use that.
    if(NULL != pMapping)
    {
        //
        // Try mapping the keyword to resource string.
        //

        hrResult = GetDisplayNameFromMapping(hHeap, pMapping, ppszDisplayName);
    }
    else
    {
        //
        // Convert the keyword to UNICODE and use that.
        //

        // Convert ANSI keyword to Unicode string for display name.
        // Need to remove the % for Driver Synthisized features.
        // For debug version, add marker that shows that the display name was faked.
        PCSTR   pConvert = IS_DRIVER_FEATURE(pszKeyword) ? pszKeyword + 1 : pszKeyword;
    #if DBG
        CHAR    szTemp[256];
        wsprintfA(szTemp, "%s (Keyword)", pConvert);
        pConvert = szTemp;
    #endif
        *ppszDisplayName = MakeUnicodeString(hHeap, pConvert);
        if(NULL == *ppszDisplayName)
        {
            ERR(ERRORTEXT("DetermineFeatureDisplayName() alloc for feature display name failed.\r\n")); 

            hrResult = E_OUTOFMEMORY;
            goto Exit;
        }

        // Return success even though we faked a display name.
        hrResult = S_OK;
    }


Exit:

    // If failed, then return no string.
    if(!SUCCEEDED(hrResult))
    {
        if(NULL != *ppszDisplayName)
        {
            HeapFree(hHeap, 0, *ppszDisplayName);
            *ppszDisplayName = NULL;
        }
    }

    return hrResult;
}

// Maps option keywords to display names for the option.
HRESULT DetermineOptionDisplayName(HANDLE hHeap, 
                                   CUIHelper &Helper, 
                                   POEMUIOBJ poemuiobj, 
                                   PCSTR pszFeature,
                                   PCSTR pszOption,
                                   const PKEYWORDMAP pMapping,
                                   PWSTR *ppszDisplayName)
{
    DWORD   dwDataType  = -1;
    DWORD   dwSize      = INITIAL_OPTION_DISPLAY_NAME_SIZE;
    DWORD   dwNeeded    = 0;
    HRESULT hrResult    = S_OK;


    // Validate parameters.
    if( (NULL == hHeap)
        ||
        (NULL == pszFeature)
        ||
        (NULL == pszOption)
        ||
        (NULL == ppszDisplayName)
      )
    {
        ERR(ERRORTEXT("DetermineOptionDisplayName() invalid arguement.\r\n")); 

        hrResult = E_INVALIDARG;
        goto Exit;
    }

    //
    // Call the Helper function.
    // 

    // Helper will return Display Names for PPD Feature Options, but
    // not for Driver Synthisized features options (i.e. features prefixed with %).
    // Do it for all options, just in case the helper interface changes to support it.

    // Pre-allocate a buffer of reasonable size to try
    // to one have to call GetOptionAttribute() once.
    *ppszDisplayName = (PWSTR) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwSize);
    if(NULL == *ppszDisplayName)
    {
        ERR(ERRORTEXT("DetermineOptionDisplayName() alloc for feature display name failed.\r\n")); 

        hrResult = E_OUTOFMEMORY;
        goto Exit;
    }

    // Try to get diplay name for feature from Helper.
    hrResult = Helper.GetOptionAttribute(poemuiobj, 
                                         0, 
                                         pszFeature,
                                         pszOption,
                                         "DisplayName", 
                                         &dwDataType,
                                         (PBYTE) *ppszDisplayName, 
                                         dwSize, 
                                         &dwNeeded);
    if( (E_OUTOFMEMORY == hrResult) && (dwSize < dwNeeded))
    {
        PWSTR   pTemp;


        // INVARIANT: initial buffer wasn't large enough.

        // Re-alloc buffer and try again.
        pTemp = (PWSTR) HeapReAlloc(hHeap, HEAP_ZERO_MEMORY, *ppszDisplayName, dwNeeded);
        if(NULL == pTemp)
        {
            ERR(ERRORTEXT("GetOptionAttribute() re-alloc for feature display name failed.\r\n")); 

            hrResult = E_OUTOFMEMORY;
            goto Exit;
        }
        *ppszDisplayName = pTemp;

        // Try to get the display name from Helper, again.
        hrResult = Helper.GetOptionAttribute(poemuiobj, 
                                             0, 
                                             pszFeature,
                                             pszOption,
                                             "DisplayName", 
                                             &dwDataType,
                                             (PBYTE) *ppszDisplayName, 
                                             dwNeeded, 
                                             &dwNeeded);
    }

    if(SUCCEEDED(hrResult))
    {
        // INVARIANT:  Successfully got display name from Helper for feature.
        //             Don't need to do anything more.

        // Check the data type, it should be kADT_UNICODE.
        if(kADT_UNICODE != dwDataType) WARNING(DLLTEXT("DetermineOptionDisplayName() feature attribute type not kADT_UNICODE. (dwDataType = %d)\r\n"), dwDataType);

        goto Exit;
    }

    // INVARIANT:  Did not get the display name from the Helper.

    // Free memory allocated for call to Helper.
    if(NULL != *ppszDisplayName) 
    {
        HeapFree(hHeap, 0, *ppszDisplayName);
        *ppszDisplayName = NULL;
    }

    // Try alternative methods for getting the display name other 
    // than from the Helper function.
    // If we have a mapping entry, then try to get resource string
    // for the display name.
    // Otherwise, covert the keyword to UNICODE and use that.
    if(NULL != pMapping)
    {
        //
        // Try mapping the keyword to resource string.
        //

        hrResult = GetDisplayNameFromMapping(hHeap, pMapping, ppszDisplayName);
    }
    else
    {
        //
        // Convert the keyword to UNICODE and use that.
        //

        // Convert ANSI keyword to Unicode string for display name.
        // For debug version, add marker that shows that the display name was faked.
        PCSTR   pConvert    = pszOption;
    #if DBG
        CHAR    szTemp[256];
        wsprintfA(szTemp, "%s (Keyword)", pConvert);
        pConvert = szTemp;
    #endif
        *ppszDisplayName = MakeUnicodeString(hHeap, pConvert);
        if(NULL == *ppszDisplayName)
        {
            ERR(ERRORTEXT("DetermineOptionDisplayName() alloc for feature display name failed.\r\n")); 

            hrResult = E_OUTOFMEMORY;
            goto Exit;
        }

        // Return success even though we faked a display name.
        hrResult = S_OK;
    }


Exit:

    // If failed, then return no string.
    if(!SUCCEEDED(hrResult))
    {
        if(NULL != *ppszDisplayName)
        {
            HeapFree(hHeap, 0, *ppszDisplayName);
            *ppszDisplayName = NULL;
        }
    }

    return hrResult;
}

// Determines sticky mode for the feature.
HRESULT DetermineStickiness(CUIHelper &Helper,
                            POEMUIOBJ poemuiobj, 
                            PCSTR pszKeyword,
                            const PKEYWORDMAP pMapping,
                            PDWORD pdwMode)
{
    CHAR    szGroupType[32]     = {0};
    DWORD   dwType              = 0;
    DWORD   dwNeeded            = 0;
    HRESULT hrResult            = S_OK;


    // Use mapping to see what stickiness of the feature is.
    if(NULL != pMapping)
    {
        *pdwMode = pMapping->dwMode;
        goto Exit;
    }

    // By default make feature Document sticky, if we don't have mapping.
    *pdwMode = OEMCUIP_DOCPROP;

    // Try to use Helper to determine stickiness.
    hrResult = Helper.GetFeatureAttribute(poemuiobj, 
                                          0, 
                                          pszKeyword, 
                                          "OpenGroupType", 
                                          &dwType, 
                                          (PBYTE) szGroupType,
                                          sizeof(szGroupType), 
                                          &dwNeeded);
    if(SUCCEEDED(hrResult))
    {
        // INVARIANT:  found out if feature is an installable option.
        //             Installable options are the only PPD features
        //             that are Printer sticky.

        if(!lstrcmpA(szGroupType, "InstallableOptions"))
        {
            *pdwMode = OEMCUIP_PRNPROP;
        }
        goto Exit;
    }


Exit:

    return hrResult;
}

// Find the mapping entry from the keyword.
PKEYWORDMAP FindKeywordMapping(PKEYWORDMAP pKeywordMap, WORD wMapSize, PCSTR pszKeyword)
{
    BOOL        bFound      = FALSE;
    PKEYWORDMAP pMapping    = NULL;


    // Walk mapping array for matching keyword.
    for(WORD wIndex = 0; !bFound && (wIndex < wMapSize); ++wIndex)
    {
        bFound = !lstrcmpA(pszKeyword, pKeywordMap[wIndex].pszKeyword);
        if(bFound)
        {
            pMapping = pKeywordMap + wIndex;
        }
    }

    return pMapping;
}

// Get display name from mapping entry.
HRESULT GetDisplayNameFromMapping(HANDLE hHeap, PKEYWORDMAP pMapping, PWSTR *ppszDisplayName)
{
    HMODULE hModule     = NULL;
    HRESULT hrResult    = S_OK;


    // Validate parameters.
    if( (NULL == hHeap)
        ||
        (NULL == pMapping)
        ||
        (NULL == ppszDisplayName)
      )
    {
        hrResult = E_INVALIDARG;
        goto Exit;
    }

    // Check for simple case of returning INT resource.
    if( (NULL == pMapping->pwszModule) 
        || 
        IS_MAPPING_INT_RESOURCE(pMapping)
      )
    {
        // Just need to do MAKEINTRESOURCE on the resource ID and return.
        *ppszDisplayName = MAKEINTRESOURCE(pMapping->uDisplayNameID);
        goto Exit;
    }

    // We only need to get the module if we aren't loading the resource from
    // this module (i.e. if module name isn't NULL).
    // Also, as an optimization, we assume that the module has already been loaded, 
    // since the only cases currently are this module, driver ui, and Compstui.dll.
    hModule = GetModuleHandle(pMapping->pwszModule);
    if(NULL == hModule)
    {
        DWORD   dwError = GetLastError();


        ERR(ERRORTEXT("GetDisplayNameFromMapping() for failed to load module %s. (Error %d)\r\n"), 
                      pMapping->pwszModule, 
                      dwError); 

        hrResult = HRESULT_FROM_WIN32(dwError);
        goto Exit;
    }

    // INVARIANT:  have handle to module to load resource from or the
    //             resource is being loaded from this module.

    // Get the string resouce.
    hrResult = GetStringResource(hHeap, hModule, pMapping->uDisplayNameID, ppszDisplayName);
    if(!SUCCEEDED(hrResult))
    {
        ERR(ERRORTEXT("GetDisplayNameFromMapping() failed to load string. (hrResult = 0x%x)\r\n"), 
                      hrResult); 
        goto Exit;
    }


Exit:

    return hrResult;
}

// Test if an OPTITEM is an OPTITEM for a feature.
// Macro for testing if OPTITEM is feature OPTITEM
BOOL IsFeatureOptitem(POPTITEM pOptItem)
{
    BOOL                bRet    = FALSE;
    PFEATUREOPTITEMDATA pData   = NULL;


    // Make sure pointers are NULL.
    if( (NULL == pOptItem)
        ||
        (NULL == pOptItem->UserData)
       )
    {
        // INVARIANT:  can't be feature OPTITEM, since one of 
        //             the necessary pointer are NULL.

        return FALSE;
    }

    // For convienience, assign to pointer to feature OPTITEM data.
    pData = (PFEATUREOPTITEMDATA)(pOptItem->UserData);

    // Check size and tag.
    bRet = (sizeof(FEATUREOPTITEMDATA) == pData->dwSize) 
           &&
           (FEATURE_OPTITEM_TAG == pData->dwTag); 
        
    return bRet;
}



// Walks array of OPTITEMs saving each feature OPTITEM
// that has changed.
HRESULT SaveFeatureOptItems(HANDLE hHeap, 
                            CUIHelper *pHelper, 
                            POEMUIOBJ poemuiobj,
                            HWND hWnd,
                            POPTITEM pOptItem,
                            WORD wItems)
{
    PSTR        pmszPairs           = NULL;
    WORD        wPairs              = 0;
    WORD        wConflicts          = 0;
    WORD        wReasons            = 0;
    DWORD       dwSize              = 0;
    DWORD       dwResult            = 0;
    PCSTR       *ppszReasons        = NULL;
    PWSTR       pszConfilictFeature = NULL;
    PWSTR       pszConfilictOption  = NULL;
    PWSTR       pszCaption          = NULL;
    PWSTR       pszFormat           = NULL;
    PWSTR       pszMessage          = NULL;
    HRESULT     hrResult            = S_OK;


    // Validate parameters
    if( (NULL == hHeap)
        ||
        (NULL == pHelper)
        ||
        (NULL == pOptItem)
      )
    {
        ERR(ERRORTEXT("SaveFeatureOptItems() called with invalid parameters.\r\n"));

        hrResult = E_INVALIDARG;
        goto Exit;
    }

    // Get feature option pairs to save.
    hrResult = GetChangedFeatureOptions(hHeap, pOptItem, wItems, &pmszPairs, &wPairs, &dwSize);
    if(!SUCCEEDED(hrResult))
    {
        ERR(ERRORTEXT("SaveFeatureOptItems() failed to get changed feature option pairs. (hrResult = 0x%x)\r\n"),
                       hrResult);

        goto Exit;
    }

    // Don't need to do anything more if no feature options changed.
    if(0 == wPairs)
    {
        VERBOSE(DLLTEXT("SaveFeatureOptItems() no feature options that need to be set.\r\n"));

        goto Exit;
    }

    // Set the change feature options.
    // For the first SetOptions() call, don't have the
    // core driver UI resolve conflicts, so we can
    // prompt user for automatic resolution or let
    // them do the conflict resolving.
    hrResult = pHelper->SetOptions(poemuiobj, 
                                   SETOPTIONS_FLAG_KEEP_CONFLICT, 
                                   pmszPairs, 
                                   dwSize,
                                   &dwResult);
    if(!SUCCEEDED(hrResult))
    {
        ERR(ERRORTEXT("SaveFeatureOptItems() call to SetOptions() failed. (hrResult = 0x%x, dwResult = %d\r\n"),
                       hrResult,
                       dwResult);

        goto Exit;
    }

    // Check to see if we were able to save changed feature options,
    // or if there is a conflict that needs resolution.
    if(SETOPTIONS_RESULT_CONFLICT_REMAINED == dwResult)
    {
        int         nRet;
        DWORD       dwRet;
        CONFLICT    Conflict;
        PKEYWORDMAP pMapping    = NULL;


        // INVARIANT:  constraint conflict, options weren't saved.

        // Get list of all features that have conflict.
        hrResult = GetFirstConflictingFeature(hHeap, 
                                              pHelper, 
                                              poemuiobj, 
                                              pOptItem, 
                                              wItems, 
                                              &Conflict);
        if(!SUCCEEDED(hrResult))
        {
            goto Exit;
        }

        // Create string pointer list in to multi-sz of first conflict.
        hrResult = MakeStrPtrList(hHeap, Conflict.pmszReasons, &ppszReasons, &wReasons);
        if(!SUCCEEDED(hrResult))
        {
            ERR(ERRORTEXT("SaveFeatureOptItems() failed to make string list for conflict reasons. (hrResult = 0x%x)\r\n"), 
                           hrResult);

            goto Exit;
        }

        //
        // Get display versions of feature/option conflict reason.
        //

        // Get or build a keyword mapping entry
        // that maps from keyword to usefully where to get info, such as 
        // display name, icon, option type, for keywords that may not be
        // able to get info for from Helper.
        pMapping = FindKeywordMapping(gkmFeatureMap, NUM_FEATURE_MAP, ppszReasons[0]);

        // Get display names for each of the featurs.
        // The function implements a heuristic for detemining the display name,
        // since can't get the display name from the UI Helper for all features.
        hrResult = DetermineFeatureDisplayName(hHeap, 
                                               *pHelper, 
                                               poemuiobj, 
                                               ppszReasons[0],
                                               pMapping,
                                               &pszConfilictFeature);
        if(!SUCCEEDED(hrResult))
        {
            ERR(ERRORTEXT("SaveFeatureOptItems failed to get display name for feature %hs. (hrResult = 0x%x)\r\n"), 
                          ppszReasons[0], 
                          hrResult); 

            goto Exit;
        }

        // Get or build a keyword mapping entry
        // that maps from keyword to usefully where to get info, such as 
        // display name, icon, option type, for keywords that may not be
        // able to get info for from Helper.
        pMapping = FindKeywordMapping(gkmOptionMap, NUM_OPTION_MAP, ppszReasons[1]);

        // Get option display name.
        hrResult = DetermineOptionDisplayName(hHeap, 
                                              *pHelper, 
                                              poemuiobj, 
                                              ppszReasons[0],
                                              ppszReasons[1],
                                              pMapping,
                                              &pszConfilictOption);
        if(!SUCCEEDED(hrResult))
        {
            ERR(ERRORTEXT("SaveFeatureOptItems() failed to get display name for %hs of feature %hs. (hrResult = 0x%x)\r\n"), 
                          ppszReasons[1], 
                          ppszReasons[0],
                          hrResult); 

            goto Exit;
        }

        //
        // Prompt user about how to resolve conflict.
        //

        // Get caption name.
        hrResult = GetStringResource(hHeap, ghInstance, IDS_NAME, &pszCaption);
        if(!SUCCEEDED(hrResult))
        {
            ERR(ERRORTEXT("SaveFeatureOptItems() failed to get caption name. (hrResult = 0x%x)\r\n"),
                          hrResult); 
            goto Exit;
        }

        // Get message body format string.
        hrResult = GetStringResource(hHeap, ghInstance, IDS_CONSTRAINT_CONFLICT, &pszFormat);
        if(!SUCCEEDED(hrResult))
        {
            ERR(ERRORTEXT("SaveFeatureOptItems() failed to get constraint conflict format. (hrResult = 0x%x)\r\n"),
                          hrResult); 
            goto Exit;
        }


        // Get messsage body.
        PVOID   paArgs[4] = {pszConfilictFeature, 
                             pszConfilictOption,
                             const_cast<PWSTR>(Conflict.pszFeature),
                             Conflict.pszOption
                            };
        dwRet = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                              pszFormat,
                              0,
                              0,
                              (PWSTR) &pszMessage,
                              0,
                              (va_list *) paArgs);
        if(0 == dwRet)
        {
            DWORD   dwError = GetLastError();

            ERR(ERRORTEXT("SaveFeatureOptItems() failed to FormatMessage() for constraint conflict of feature %hs option %hs. (Last Error %d)\r\n"),
                          Conflict.pszFeatureKeyword,
                          Conflict.pszOptionKeyword,
                          dwError);

            hrResult = HRESULT_FROM_WIN32(dwError);
            goto Exit;
        }

        // Display simple message box with prompt.
        nRet = MessageBox(hWnd, pszMessage, pszCaption, MB_YESNO | MB_ICONWARNING);

        // Check to see how user wants to resolve conflict.
        if(IDYES == nRet)
        {
            // Let core driver resolve conflict resolution.
            hrResult = pHelper->SetOptions(poemuiobj, 
                                           SETOPTIONS_FLAG_RESOLVE_CONFLICT, 
                                           pmszPairs, 
                                           dwSize,
                                           &dwResult);

            // Conflict resolution requires refreshing current option
            // selection for each feature, since selection may have
            // changed because of conflict resolution.
            RefreshOptItemSelection(pHelper, poemuiobj, pOptItem, wItems);
        }

        // Return failure if there are still conflictts.
        if(SETOPTIONS_RESULT_CONFLICT_REMAINED == dwResult)
        {
            hrResult = E_FAIL;
        }
    }


Exit:

    // Clean up...

    // cleanup heap allocs.
    if(NULL != pmszPairs)       HeapFree(hHeap, 0, pmszPairs);
    if(NULL != ppszReasons)         HeapFree(hHeap, 0, ppszReasons);
    if(NULL != pszConfilictFeature) HeapFree(hHeap, 0, pszConfilictFeature);
    if(NULL != pszConfilictOption)  HeapFree(hHeap, 0, pszConfilictOption);
    if(NULL != pszCaption)          HeapFree(hHeap, 0, pszCaption);
    if(NULL != pszFormat)           HeapFree(hHeap, 0, pszFormat);
    if(NULL != pszMessage)          LocalFree(pszMessage);

    return hrResult;
}

// Allocates buffer, if needed, and calls IPrintCoreUI2::WhyConsrained
// to get reason for constraint.
HRESULT GetWhyConstrained(HANDLE hHeap, 
                          CUIHelper *pHelper, 
                          POEMUIOBJ poemuiobj,
                          PCSTR pszFeature,
                          PCSTR pszOption,
                          PSTR *ppmszReason,
                          PDWORD pdwSize)
{
    PSTR    pmszReasonList  = *ppmszReason;
    DWORD   dwNeeded        = 0;
    HRESULT hrResult        = S_OK;


    // If buffer wasn't passed in, then allocate one.
    if( (NULL == pmszReasonList) || (0 == *pdwSize) )
    {
        // If no size or size is smaller than default, then change to default
        // size.  We want to try to only allocate and call once.
        if(*pdwSize < INITIAL_GET_REASON_SIZE) 
        {
            *pdwSize = INITIAL_GET_REASON_SIZE;
        }

        // Alloc initial buffer for reason constrained.
        pmszReasonList = (PSTR) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, *pdwSize);
        if(NULL == pmszReasonList)
        {
            ERR(ERRORTEXT("GetWhyConstrained() failed to alloc buffer for constraint reasons for feature %hs and option %hs.\r\n"),
                           pszFeature,
                           pszOption);

            hrResult = E_OUTOFMEMORY;
            goto Exit;
        }
    }

    // Get reason for constraint.
    hrResult = pHelper->WhyConstrained(poemuiobj,
                                       0, 
                                       pszFeature, 
                                       pszOption, 
                                       pmszReasonList, 
                                       *pdwSize, 
                                       &dwNeeded);
    if( (E_OUTOFMEMORY == hrResult) 
        && 
        (*pdwSize < dwNeeded)
      )
    {
        PSTR    pTemp;


        // INVARIANT:  initial buffer not large enough.

        // Re-alloc buffer to needed size.
        pTemp = (PSTR) HeapReAlloc(hHeap, HEAP_ZERO_MEMORY, pmszReasonList, dwNeeded);
        if(NULL == pTemp)
        {
            ERR(ERRORTEXT("GetWhyConstrained() failed to re-allocate buffer for constraint reason for feature %hs and option %hs.\r\n"),
                           pszFeature,
                           pszOption);

            hrResult = E_OUTOFMEMORY;
            goto Exit;
        }
        pmszReasonList  = pTemp;
        *pdwSize        = dwNeeded;

        // Retry getting constaint reason.
        hrResult = pHelper->WhyConstrained(poemuiobj,
                                           0, 
                                           pszFeature, 
                                           pszOption, 
                                           pmszReasonList, 
                                           *pdwSize, 
                                           &dwNeeded);
    }


Exit:

    // On error, do clean up.
    if(!SUCCEEDED(hrResult))
    {
        // Free reason buffer.
        if(NULL != pmszReasonList) HeapFree(hHeap, 0, pmszReasonList);

        // Return NULL and zero size.
        *ppmszReason    = NULL;
        *pdwSize        = 0;
    }
    else
    {
        *ppmszReason = pmszReasonList;
    }

    return hrResult;
}

// Creates multi-sz list of feature option pairs that have changed.
HRESULT GetChangedFeatureOptions(HANDLE hHeap,
                                 POPTITEM pOptItem, 
                                 WORD wItems, 
                                 PSTR *ppmszPairs, 
                                 PWORD pwPairs,
                                 PDWORD pdwSize)
{
    WORD                wCount     = 0;
    WORD                wChanged   = 0;
    WORD                wPairs     = 0;
    DWORD               dwNeeded    = 2;
    PSTR                pmszPairs   = NULL;
    PSTR                pAdd        = NULL;
    HRESULT             hrResult    = S_OK;
    PFEATUREOPTITEMDATA pData       = NULL;


    // Walk OPTITEM array looking or changed options,
    // and calculating size needed for multi-sz buffer.
    for(wCount = 0; wCount < wItems; ++wCount)
    {
        PSTR    pszOption   = NULL;


        // Just go to next item if this OPTITEM hasn't 
        // changed or isn't a feature OPTITEM.
        if( !(OPTIF_CHANGEONCE & pOptItem[wCount].Flags) 
            ||
            !IsFeatureOptitem(pOptItem + wCount)
          )
        {
            continue;
        }

        // For convienience, assign to pointer to feature OPTITEM data.
        pData = (PFEATUREOPTITEMDATA)(pOptItem[wCount].UserData);

        // Increment options changed and size needed.
        pszOption = GetOptionKeywordFromOptItem(hHeap, pOptItem + wCount);
        if(NULL != pszOption)
        {
            ++wChanged;
            dwNeeded += lstrlenA(pData->pszFeatureKeyword) + lstrlenA(pszOption) + 2;

            // Need to free option keyword string copy
            // allocated in GetOptionKeywordFromOptItem().
            HeapFree(hHeap, 0, pszOption);
        }
    }

    // Don't need to do anything more if no feature options changed.
    if(0 == wChanged)
    {
        goto Exit;
    }

    // Allocate multi-sz buffer.
    pmszPairs = (PSTR) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwNeeded);
    if(NULL == pmszPairs)
    {
        ERR(ERRORTEXT("GetChangedFeatureOptions() failed to allocate multi-sz.\r\n"));

        hrResult = E_OUTOFMEMORY;
        goto Exit;
    }

    // Build mult-sz list of feature option pairs
    // that changed.
    pAdd = pmszPairs;
    for(wCount = 0, wPairs = 0; (wCount < wItems) && (wPairs < wChanged); ++wCount)
    {
        PSTR    pszOption   = NULL;


        // Just go to next item if this OPTITEM hasn't 
        // changed or isn't a feature OPTITEM.
        if( !(OPTIF_CHANGEONCE & pOptItem[wCount].Flags) 
            ||
            !IsFeatureOptitem(pOptItem + wCount)
          )
        {
            continue;
        }

        // For convienience, assign to pointer to feature OPTITEM data.
        pData = (PFEATUREOPTITEMDATA)(pOptItem[wCount].UserData);

        // Add feature option pair.
        pszOption = GetOptionKeywordFromOptItem(hHeap, pOptItem + wCount);
        if(NULL != pszOption)
        {
            lstrcpyA(pAdd, pData->pszFeatureKeyword);
            pAdd += lstrlenA(pData->pszFeatureKeyword) + 1;
            lstrcpyA(pAdd, pszOption);
            pAdd += lstrlenA(pszOption) + 1;

            // Keep track of number of pairs added, so
            // we are able to exit loop as soon as
            // we added all changed feature options.
            ++wPairs;

            // Need to free option keyword string copy
            // allocated in GetOptionKeywordFromOptItem().
            HeapFree(hHeap, 0, pszOption);
        }
    }


Exit:

    if(SUCCEEDED(hrResult))
    {
        // INVARIANT: either successfully build mutli-sz of changed
        //            feature option pairs, or there are no feature
        //            that options changed.

        // Return pairs and number of pairs.
        *pwPairs    = wPairs;
        *pdwSize    = dwNeeded;
        *ppmszPairs = pmszPairs;
    }
    else
    {
        // INVARINAT:   error.

        // Clean up.
        if(NULL == pmszPairs)    HeapFree(hHeap, 0, pmszPairs);

        // Return NULL and zero count.
        *pwPairs    = 0;
        *pdwSize    = 0;
        *ppmszPairs = NULL;
    }

    return hrResult;
}

// Returns pointer to option keyword for a feature OPTITEM.
PSTR GetOptionKeywordFromOptItem(HANDLE hHeap, POPTITEM pOptItem)
{
    char                szNumber[16]    = {0};
    PSTR                pszOption       = NULL;
    PFEATUREOPTITEMDATA pData           = NULL;


    // Validate parameter.
    if(!IsFeatureOptitem(pOptItem))
    {
        ERR(ERRORTEXT("GetOptionKeywordFromOptItem() invalid parameter.\r\n"));

        goto Exit;
    }

    // For convienience, assign to pointer to feature OPTITEM data.
    pData = (PFEATUREOPTITEMDATA)(pOptItem->UserData);

    // Option selection is based on type of OPTTYPE.
    switch(pOptItem->pOptType->Type)
    {
        // For up down arrow control, selection is just pOptItem->Sel
        // converted to string.
        case TVOT_UDARROW:
            _snprintf(szNumber, sizeof(szNumber), "%u", pOptItem->Sel);
            pszOption = MakeStringCopy(hHeap, szNumber);
            break;

        // For combobox, pOptItem->Sel is the index in to the
        // option array.
        case TVOT_COMBOBOX:
            pszOption = MakeStringCopy(hHeap, pData->pOptions->GetKeyword((WORD)pOptItem->Sel));
            break;

        // The default is the option count.
        default:
            ERR(ERRORTEXT("GetOptionKeywordFromOptItem() OPTTYPE type %d num of OPTPARAMs not handled.\r\n"),
                            pOptItem->pOptType->Type);

            goto Exit;
            break;
    }


Exit:

    return pszOption;
}

// Returns pointer to option display name for a feature OPTITEM.
PWSTR GetOptionDisplayNameFromOptItem(HANDLE hHeap, POPTITEM pOptItem)
{
    WCHAR               szNumber[16]    = {0};
    PWSTR               pszOption       = NULL;
    PFEATUREOPTITEMDATA pData           = NULL;


    // Validate parameter.
    if(!IsFeatureOptitem(pOptItem))
    {
        ERR(ERRORTEXT("GetOptionDisplayNameFromOptItem() invalid parameter.\r\n"));

        goto Exit;
    }

    // For convienience, assign to pointer to feature OPTITEM data.
    pData = (PFEATUREOPTITEMDATA)(pOptItem->UserData);

    // Option selection is based on type of OPTTYPE.
    switch(pOptItem->pOptType->Type)
    {
        // For up down arrow control, selection is just pOptItem->Sel
        // converted to string.
        case TVOT_UDARROW:
            _snwprintf(szNumber, sizeof(szNumber)/sizeof(WCHAR), L"%u", pOptItem->Sel);
            pszOption = MakeStringCopy(hHeap, szNumber);
            break;

        // For combobox, pOptItem->Sel is the index in to the
        // option array.
        case TVOT_COMBOBOX:
            pszOption = MakeStringCopy(hHeap, pOptItem->pOptType->pOptParam[pOptItem->Sel].pData);
            break;

        // The default is the option count.
        default:
            ERR(ERRORTEXT("GetOptionDisplayNameFromOptItem() OPTTYPE type %d num of OPTPARAMs not handled.\r\n"),
                            pOptItem->pOptType->Type);

            goto Exit;
            break;
    }


Exit:

    return pszOption;
}

// Refreshes option selection for each feature OPTITEM
HRESULT RefreshOptItemSelection(CUIHelper *pHelper, 
                                POEMUIOBJ poemuiobj, 
                                POPTITEM pOptItems, 
                                WORD wItems)
{
    HRESULT             hrResult    = S_OK;
    PFEATUREOPTITEMDATA pData       = NULL;


    // Walk OPTITEM array refreshing feature OPTITEMs.
    for(WORD wCount = 0; wCount < wItems; ++wCount)
    {
        // Just go to next item if this OPTITEM isn't a feature OPTITEM.
        if(!IsFeatureOptitem(pOptItems + wCount))
        {
            continue;
        }

        // For convienience, assign to pointer to feature OPTITEM data.
        pData = (PFEATUREOPTITEMDATA)(pOptItems[wCount].UserData);

        // Refresh COption selection.
        pData->pOptions->RefreshSelection(*pHelper, poemuiobj);

        // Assign COption selection to OPTITEM selection.
        pOptItems[wCount].pSel = pData->pOptions->GetSelection();

    }

    return hrResult;
}

// Creates array of conflict features.
HRESULT GetFirstConflictingFeature(HANDLE hHeap,
                                   CUIHelper *pHelper, 
                                   POEMUIOBJ poemuiobj, 
                                   POPTITEM pOptItem, 
                                   WORD wItems, 
                                   PCONFLICT pConflict)
{
    WORD                wCount      = 0;
    HRESULT             hrResult    = S_OK;
    PFEATUREOPTITEMDATA pData       = NULL;


    // Walk OPTITEM array looking or changed options that are in conflict.
    for(wCount = 0; wCount < wItems; ++wCount)
    {
        // Just go to next item if this OPTITEM hasn't 
        // changed or isn't a feature OPTITEM.
        if( !(OPTIF_CHANGEONCE & pOptItem[wCount].Flags) 
            ||
            !IsFeatureOptitem(pOptItem + wCount)
          )
        {
            continue;
        }

        // For convienience, assign to pointer to feature OPTITEM data.
        pData = (PFEATUREOPTITEMDATA)(pOptItem[wCount].UserData);

        // Init conflict record if this feature is in conflict.
        pConflict->pszOptionKeyword = GetOptionKeywordFromOptItem(hHeap, pOptItem + wCount);
        if(NULL != pConflict->pszOptionKeyword)
        {
            // Get reason for conflict
            // If the feature isn't in conflict,
            // then the pmszReasonList will start 
            // with NULL terminator.
            hrResult = GetWhyConstrained(hHeap,
                                         pHelper,
                                         poemuiobj,
                                         pData->pszFeatureKeyword, 
                                         pConflict->pszOptionKeyword, 
                                         &pConflict->pmszReasons, 
                                         &pConflict->dwReasonsSize);
            if(!SUCCEEDED(hrResult))
            {
                // NOTE: driver features aren't supported by WhyConstrained.
                if((E_INVALIDARG == hrResult) && IS_DRIVER_FEATURE(pData->pszFeatureKeyword))
                {
                    // Need to reset the result in case it is the last
                    // feature OPTITEM.
                    hrResult = S_OK;
                    continue;
                }

                ERR(ERRORTEXT("GetConflictingFeatures() failed to get reason for feature %hs option %hs constraint. (hrResult = 0x%x)\r\n"),
                               pData->pszFeatureKeyword,
                               pConflict->pszOptionKeyword,
                               hrResult);

                goto Exit;
            }

            // Record conflict if feature is in conflict.
            if( (NULL != pConflict->pmszReasons) 
                && 
                (pConflict->pmszReasons[0] != '\0')
              )
            {
                // Save pointer to feature keyword.
                pConflict->pszFeatureKeyword = pData->pszFeatureKeyword;
                pConflict->pszFeature        = pOptItem[wCount].pName;
                pConflict->pszOption         = GetOptionDisplayNameFromOptItem(hHeap, pOptItem + wCount);

                // Found first conflict.
                break;
            }
        }
    }


Exit:

    return hrResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\helper.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  2001  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Helper.cpp
//    
//
//  PURPOSE:  Implementation of wrapper class for Driver UI Helper interface.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP
//
//

#include "precomp.h"
#include <PRCOMOEM.H>
#include "Helper.h"




////////////////////////////////////////////////////////
//      Internal Macros
////////////////////////////////////////////////////////


// Macros for simplifying calling the Driver UI Helper interfaces correctly.

#define CALL_HELPER(MethodName, args)                                           \
    if (IsEqualGUID(&m_iidUIHelper, &IID_IPrintOemDriverUI))                    \
    {                                                                           \
        return static_cast<IPrintOemDriverUI *>(m_pUIHelper)->MethodName args;  \
    }                                                                           \
    else if (IsEqualGUID(&m_iidUIHelper, &IID_IPrintCoreUI2))                   \
    {                                                                           \
        return static_cast<IPrintCoreUI2 *>(m_pUIHelper)->MethodName args;      \
    }                                                                           \
    return E_NOINTERFACE;

#define CALL_HELPER2(MethodName, args)                                      \
    if (IsEqualGUID(&m_iidUIHelper, &IID_IPrintCoreUI2))                    \
    {                                                                       \
        return static_cast<IPrintCoreUI2 *>(m_pUIHelper)->MethodName args;  \
    }                                                                       \
    return E_NOINTERFACE;




/////////////////////////////////////////////////////////////
//
//  CUIHelper Class Methods
//

//
// Private Methods
//

// Clears or initializes data members.
void CUIHelper::Clear()
{
    // Clear stored interface
    m_pUIHelper     = NULL;
    m_iidUIHelper   = GUID_NULL;
}


//
// Public Methods
//

// Default contructor.
CUIHelper::CUIHelper()
{
    // Initialize the data members.
    Clear();
}

// Constructor with assignment.
CUIHelper::CUIHelper(const IID &HelperIID, PVOID pHelper)
{
    // Assign the interface.
    Assign(HelperIID, pHelper);
}

// Destructor
CUIHelper::~CUIHelper()
{
    // Release the interface reference.
    Release();
}

// Stores helper interface in helper entry structure.
void CUIHelper::Assign(const IID &HelperIID, PVOID pHelper)
{
    // If we already have a helper interface, release it. 
    if(IsValid())
    {
        Release();
    }

    // Store helper interface and IID for it.
    m_pUIHelper     = static_cast<IUnknown*>(pHelper);
    m_iidUIHelper   = HelperIID;
}

// Releases the helper interface and 
// our removes the references to it.
ULONG CUIHelper::Release() 
{ 
    ULONG   ulRef   = 0;


    if(IsValid())
    {
        // Release the interface.
        // Since IPrintCoreUI2 inherits from IPrintOemDriverUI,
        // it is safe to cast both types of helper interfaces
        // to IPrintOemDriverUI for purposes of calling a 
        // method implemented in IPrintOemDriverUI.
        // NOTE: can't cast to IUnknown since it just has pure virtual 
        //       calls for AddRef and Release.
        ulRef = static_cast<IPrintOemDriverUI *>(m_pUIHelper)->Release();

        // Clear the data members.
        Clear();
    }

    return ulRef;
}


//
// IPrintOemDriverUI methods
//

//
// Helper function to get driver settings. This function is only supported
// for UI plugins that do not fully replace core driver's standard UI.
//

HRESULT __stdcall CUIHelper::DrvGetDriverSetting(
                    PVOID   pci,
                    PCSTR   Feature,
                    PVOID   pOutput,
                    DWORD   cbSize,
                    PDWORD  pcbNeeded,
                    PDWORD  pdwOptionsReturned
                    )
{
    CALL_HELPER(DrvGetDriverSetting, 
                    (pci, 
                     Feature, 
                     pOutput, 
                     cbSize, 
                     pcbNeeded, 
                     pdwOptionsReturned
                    )
               );
}

//
// Helper function to allow OEM plugins upgrade private registry
// settings. This function is supported for any UI plugins and should be
// called only by OEM's UpgradePrinter.
//

HRESULT __stdcall CUIHelper::DrvUpgradeRegistrySetting(
                    HANDLE   hPrinter,
                    PCSTR    pFeature,
                    PCSTR    pOption
                    )
{
    CALL_HELPER(DrvUpgradeRegistrySetting, 
                    (hPrinter,
                     pFeature,
                     pOption
                    )
               );
}

//
// Helper function to allow OEM plugins to update the driver UI settings.
// This function is only supported for UI plugins that do not fully replace
// core driver's standard UI. It should be called only when the UI is present.
//

HRESULT __stdcall CUIHelper::DrvUpdateUISetting(
                    PVOID    pci,
                    PVOID    pOptItem,
                    DWORD    dwPreviousSelection,
                    DWORD    dwMode
                    )
{
    CALL_HELPER(DrvUpdateUISetting,
                    (pci,
                     pOptItem,
                     dwPreviousSelection,
                     dwMode
                    )
                );
}

//
// IPrintCoreUI2 new methods
//

//
// Following four helper functions are only supported for UI plugins that fully
// replace core driver's standard UI. They should only be called by the UI plugin's
// DocumentPropertySheets, DevicePropertySheets and their property sheet callback
// functions.
//
// Helper function to retrieve driver's current setting as a list of
// feature/option keyword pairs.
//

HRESULT __stdcall CUIHelper::GetOptions(
                       IN  POEMUIOBJ  poemuiobj,
                       IN  DWORD      dwFlags,
                       IN  PCSTR      pmszFeaturesRequested,
                       IN  DWORD      cbIn,
                       OUT PSTR       pmszFeatureOptionBuf,
                       IN  DWORD      cbSize,
                       OUT PDWORD     pcbNeeded)
{
    CALL_HELPER2(GetOptions,
                    (poemuiobj,
                     dwFlags,
                     pmszFeaturesRequested,
                     cbIn,
                     pmszFeatureOptionBuf,
                     cbSize,
                     pcbNeeded
                    )
                );
}

//
// Helper function to change driver's setting using a list of feature/option
// keyword pairs.
//

HRESULT __stdcall CUIHelper::SetOptions(
                       IN  POEMUIOBJ  poemuiobj,
                       IN  DWORD      dwFlags,
                       IN  PCSTR      pmszFeatureOptionBuf,
                       IN  DWORD      cbIn,
                       OUT PDWORD     pdwResult)
{
    CALL_HELPER2(SetOptions,
                    (poemuiobj,
                     dwFlags,
                     pmszFeatureOptionBuf,
                     cbIn,
                     pdwResult
                    )
                );
}

//
// Helper function to retrieve the option(s) of a given feature that are
// constrained in driver's current setting.
//

HRESULT __stdcall CUIHelper::EnumConstrainedOptions(
                                   IN  POEMUIOBJ  poemuiobj,
                                   IN  DWORD      dwFlags,
                                   IN  PCSTR      pszFeatureKeyword,
                                   OUT PSTR       pmszConstrainedOptionList,
                                   IN  DWORD      cbSize,
                                   OUT PDWORD     pcbNeeded)
{
    CALL_HELPER2(EnumConstrainedOptions,
                    (poemuiobj,
                     dwFlags,
                     pszFeatureKeyword,
                     pmszConstrainedOptionList,
                     cbSize,
                     pcbNeeded
                    )
                );
}

//
// Helper function to retrieve a list of feature/option keyword pairs from
// driver's current setting that conflict with the given feature/option pair.
//

HRESULT __stdcall CUIHelper::WhyConstrained(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pszFeatureKeyword,
                           IN  PCSTR      pszOptionKeyword,
                           OUT PSTR       pmszReasonList,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded)
{
    CALL_HELPER2(WhyConstrained,
                    (poemuiobj,
                     dwFlags,
                     pszFeatureKeyword,
                     pszOptionKeyword,
                     pmszReasonList,
                     cbSize,
                     pcbNeeded
                    )
                );
}

//
// Following five helper functions are supported for any UI plugins.
//
// Helper function to retrieve global attribute.
//

HRESULT __stdcall CUIHelper::GetGlobalAttribute(
                               IN  POEMUIOBJ  poemuiobj,
                               IN  DWORD      dwFlags,
                               IN  PCSTR      pszAttribute,
                               OUT PDWORD     pdwDataType,
                               OUT PBYTE      pbData,
                               IN  DWORD      cbSize,
                               OUT PDWORD     pcbNeeded)
{
    CALL_HELPER2(GetGlobalAttribute,
                    (poemuiobj,
                     dwFlags,
                     pszAttribute,
                     pdwDataType,
                     pbData,
                     cbSize,
                     pcbNeeded
                    )
                );
}


//
// Helper function to retrieve attribute of a given feature.
//

HRESULT __stdcall CUIHelper::GetFeatureAttribute(
                                IN  POEMUIOBJ  poemuiobj,
                                IN  DWORD      dwFlags,
                                IN  PCSTR      pszFeatureKeyword,
                                IN  PCSTR      pszAttribute,
                                OUT PDWORD     pdwDataType,
                                OUT PBYTE      pbData,
                                IN  DWORD      cbSize,
                                OUT PDWORD     pcbNeeded)
{
    CALL_HELPER2(GetFeatureAttribute,
                    (poemuiobj,
                     dwFlags,
                     pszFeatureKeyword,
                     pszAttribute,
                     pdwDataType,
                     pbData,
                     cbSize,
                     pcbNeeded
                    )
                );
}

//
// Helper function to retrieve attribute of a given feature/option selection.
//

HRESULT __stdcall CUIHelper::GetOptionAttribute(
                               IN  POEMUIOBJ  poemuiobj,
                               IN  DWORD      dwFlags,
                               IN  PCSTR      pszFeatureKeyword,
                               IN  PCSTR      pszOptionKeyword,
                               IN  PCSTR      pszAttribute,
                               OUT PDWORD     pdwDataType,
                               OUT PBYTE      pbData,
                               IN  DWORD      cbSize,
                               OUT PDWORD     pcbNeeded)
{
    CALL_HELPER2(GetOptionAttribute,
                    (poemuiobj,
                     dwFlags,
                     pszFeatureKeyword,
                     pszOptionKeyword,
                     pszAttribute,
                     pdwDataType,
                     pbData,
                     cbSize,
                     pcbNeeded
                    )
                );
}

//
// Helper function to retrieve the list of feature keyword.
//

HRESULT __stdcall CUIHelper::EnumFeatures(
                         IN  POEMUIOBJ  poemuiobj,
                         IN  DWORD      dwFlags,
                         OUT PSTR       pmszFeatureList,
                         IN  DWORD      cbSize,
                         OUT PDWORD     pcbNeeded)
{
    CALL_HELPER2(EnumFeatures,
                    (poemuiobj,
                     dwFlags,
                     pmszFeatureList,
                     cbSize,
                     pcbNeeded
                    )
                );
}

//
// Helper function to retrieve the list of options keyword of a given feature.
//

HRESULT __stdcall CUIHelper::EnumOptions(
                        IN  POEMUIOBJ  poemuiobj,
                        IN  DWORD      dwFlags,
                        IN  PCSTR      pszFeatureKeyword,
                        OUT PSTR       pmszOptionList,
                        IN  DWORD      cbSize,
                        OUT PDWORD     pcbNeeded)
{
    CALL_HELPER2(EnumOptions,
                    (poemuiobj,
                     dwFlags,
                     pszFeatureKeyword,
                     pmszOptionList,
                     cbSize,
                     pcbNeeded
                    )
                );
}

//
// Helper function to query system simulation support
//

HRESULT __stdcall CUIHelper::QuerySimulationSupport(
                                   IN  HANDLE  hPrinter,
                                   IN  DWORD   dwLevel,
                                   OUT PBYTE   pCaps,
                                   IN  DWORD   cbSize,
                                   OUT PDWORD  pcbNeeded)
{
    CALL_HELPER2(QuerySimulationSupport,
                    (hPrinter,
                     dwLevel,
                     pCaps,
                     cbSize,
                     pcbNeeded
                    )
                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\globals.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2001  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Globals.h
//    
//
//  PURPOSE:   Lists of globals declared in Globals.cpp.
//
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP
//
//
#ifndef _GLOBALS_H
#define _GLOBALS_H


///////////////////////////////////////
//          Globals
///////////////////////////////////////

// Module's Instance handle from DLLEntry of process.
extern HINSTANCE   ghInstance;




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\globals.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2001  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Globals.cpp
//    
//
//  PURPOSE:  File that contains all the globals.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP
//
//
#define _GLOBALS_H

#include "precomp.h"
#include "oemui.h"



///////////////////////////////////////
//          Globals
///////////////////////////////////////

// Module's Instance handle from DLLEntry of process.
HINSTANCE   ghInstance = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\intrface.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2001  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Intrface.cpp
//    
//
//  PURPOSE:  Header of interface for PScript4, PScript5, Unidrv4, 
//            Unidrv5 UI plug-ins.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP
//
//
#ifndef _INTRFACE_H
#define _INTRFACE_H


#include "precomp.h"
#include "helper.h"
#include "features.h"



////////////////////////////////////////////////////////////////////////////////
//
// IOemUI2
//
class IOemUI2: public IPrintOemUI2
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD  dwMode, PVOID  pBuffer, DWORD  cbSize,
                           PDWORD pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_  DWORD  dwMode, POEMDMPARAM pOemDMParam) ;

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

    //
    // OEMCommonUIProp
    //

    STDMETHOD(CommonUIProp) (THIS_  
            DWORD  dwMode, 
            POEMCUIPPARAM   pOemCUIPParam
            );

    //
    // OEMDocumentPropertySheets
    //

    STDMETHOD(DocumentPropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            );

    //
    // OEMDevicePropertySheets
    //

    STDMETHOD(DevicePropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            );


    //
    // OEMDevQueryPrintEx
    //

    STDMETHOD(DevQueryPrintEx) (THIS_
            POEMUIOBJ               poemuiobj,
            PDEVQUERYPRINT_INFO     pDQPInfo,
            PDEVMODE                pPublicDM,
            PVOID                   pOEMDM
            );

    //
    // OEMDeviceCapabilities
    //

    STDMETHOD(DeviceCapabilities) (THIS_
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult
            );

    //
    // OEMUpgradePrinter
    //

    STDMETHOD(UpgradePrinter) (THIS_
            DWORD   dwLevel,
            PBYTE   pDriverUpgradeInfo
            );

    //
    // OEMPrinterEvent
    //

    STDMETHOD(PrinterEvent) (THIS_
            PWSTR   pPrinterName,
            INT     iDriverEvent,
            DWORD   dwFlags,
            LPARAM  lParam
            );

    //
    // OEMDriverEvent
    //

    STDMETHOD(DriverEvent)(THIS_
            DWORD   dwDriverEvent,
            DWORD   dwLevel,
            LPBYTE  pDriverInfo,
            LPARAM  lParam
            );
 
    //
    // OEMQueryColorProfile
    //

    STDMETHOD( QueryColorProfile) (THIS_
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulReserved,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData);

    //
    // OEMFontInstallerDlgProc
    //

    STDMETHOD(FontInstallerDlgProc) (THIS_ 
            HWND    hWnd,
            UINT    usMsg,
            WPARAM  wParam,
            LPARAM  lParam
            );
    //
    // UpdateExternalFonts
    //

    STDMETHOD(UpdateExternalFonts) (THIS_
            HANDLE  hPrinter,
            HANDLE  hHeap,
            PWSTR   pwstrCartridges
            );

    //
    // IPrintOemUI2 methods
    //

    //
    // QueryJobAttributes
    //

    STDMETHOD(QueryJobAttributes)  (THIS_
            HANDLE      hPrinter,
            PDEVMODE    pDevmode,
            DWORD       dwLevel,
            LPBYTE      lpAttributeInfo
           );

    //
    // Hide Standard UI
    //

    STDMETHOD(HideStandardUI)  (THIS_
            DWORD       dwMode
           );

    //
    // DocumentEvent
    //

    STDMETHOD(DocumentEvent) (THIS_
            HANDLE      hPrinter,
            HDC         hdc,
            INT         iEsc,
            ULONG       cbIn,
            PVOID       pbIn,
            ULONG       cbOut,
            PVOID       pbOut,
            PINT        piResult
           );


    IOemUI2();
    virtual ~IOemUI2();

protected:
    LONG        m_cRef;                 // Reference count
    BOOL        m_bHidingStandardUI;    // Flag indicating if we are hiding the Standard UI.
                                        // NOTE: Not all Driver UI versions support hinding
                                        //       the Standard Driver UI.
    CUIHelper   m_Helper;               // Container for Driver UI Helper interface.
    CFeatures   m_Features;             // Core Driver features and feature options.
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\intrface.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2001  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Intrface.cpp
//    
//
//  PURPOSE:  Implementation of interface for WinXP PScript5 Standard 
//            UI Replacement plug-in.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP
//
//


#include "precomp.h"
#include <INITGUID.H>
#include <PRCOMOEM.H>

#include "oemui.h"
#include "debug.h"
#include "intrface.h"


////////////////////////////////////////////////////////
//      Internal Constants
////////////////////////////////////////////////////////

//
// List all of the supported Driver UI Helper interface IIDs from the
// latest to the oldest, that's the order we will query for the
// the Driver UI Helper interface to use.
//

const IID *Helper_IIDs[] = 
{
    &IID_IPrintCoreUI2,
    &IID_IPrintOemDriverUI,    
};
const NUM_HELPER_IIDs   = (sizeof(Helper_IIDs)/sizeof(Helper_IIDs[0]));


////////////////////////////////////////////////////////
//      Internal Globals
////////////////////////////////////////////////////////

static long g_cComponents   = 0 ;     // Count of active components
static long g_cServerLocks  = 0 ;    // Count of locks




////////////////////////////////////////////////////////////////////////////////
//
// IOemUI2 body
//
IOemUI2::IOemUI2() 
{ 
    VERBOSE(DLLTEXT("IOemUI2:IOemUI2() default constructor called.\r\n\r\n")); 

    // Init ref count to 1 on creation, since AddRef() is implied.
    m_cRef              = 1; 

    // The default for UI Hiding is FALSE, since HideStandardUI method
    // will only be called by Driver UIs that support it.
    // Older Driver UIs don't know about this method and won't call us.
    m_bHidingStandardUI = FALSE;

    // Increment component count.
    InterlockedIncrement(&g_cComponents);
}

IOemUI2::~IOemUI2()
{
    VERBOSE(DLLTEXT("IOemUI2:~IOemUI2() destructor called.\r\n\r\n")); 

    // If this instance of the object is being deleted, then the reference 
    // count should be zero.
    assert(0 == m_cRef);

    // Decrement component count.
    InterlockedDecrement(&g_cComponents);
}

HRESULT __stdcall IOemUI2::QueryInterface(const IID& iid, void** ppv)
{   
    VERBOSE(DLLTEXT("IOemUI2:QueryInterface entry.\r\n\r\n")); 

#if DBG    
    TCHAR szIID[80] = {0};
    StringFromGUID2(iid, szIID, COUNTOF(szIID)); // can not fail!
#endif

    // Determine what object to return, if any.
    if(iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
    }
    else if(iid == IID_IPrintOemUI2)
    {
        *ppv = static_cast<IPrintOemUI2*>(this);
    }
    else if(iid == IID_IPrintOemUI)
    {
        *ppv = static_cast<IPrintOemUI*>(this);
    }
    else
    {
        // Interface not supported.
#if DBG
        WARNING(DLLTEXT("IOemUI2::QueryInterface %s not supported.\r\n"), szIID); 
#endif

        *ppv = NULL ;
        return E_NOINTERFACE ;
    }

#if DBG
    VERBOSE(DLLTEXT("IOemUI2::QueryInterface returning pointer to %s.\r\n"), szIID); 
#endif

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemUI2::AddRef()
{
    VERBOSE(DLLTEXT("IOemUI2:AddRef entry.\r\n")); 
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemUI2::Release() 
{
    VERBOSE(DLLTEXT("IOemUI2:Release entry.\r\n")); 
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

HRESULT __stdcall IOemUI2::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    HRESULT hResult = S_OK;


    VERBOSE(DLLTEXT("IOemUI2:PublishDriverInterface entry.\r\n")); 

    // Core Driver UI shouldn't call us more than once if we were successful.
    // Thus, if m_Helper is already valid, we shouldn't be getting called.
    ASSERT(!m_Helper.IsValid());

    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (!m_Helper.IsValid())
    {
        PVOID   pHelper = NULL;


        // Try to get the newest version fo the Helper function
        // that Driver UI supports.
        hResult = E_FAIL;
        for(DWORD dwIndex = 0; !SUCCEEDED(hResult) && (dwIndex < NUM_HELPER_IIDs); ++dwIndex)
        {
            // Query Driver UI for Helper interface.
            hResult = pIUnknown->QueryInterface(*Helper_IIDs[dwIndex], &pHelper);
            if(SUCCEEDED(hResult))
            {
                // INVARIANT: we got a Helper interface.


                // Store Helper interface.
                m_Helper.Assign(*Helper_IIDs[dwIndex], pHelper);
            }
        }
    }

    return hResult;
}

HRESULT __stdcall IOemUI2::GetInfo(
    DWORD  dwMode,
    PVOID  pBuffer,
    DWORD  cbSize,
    PDWORD pcbNeeded)
{
    VERBOSE(DLLTEXT("IOemUI2::GetInfo(%d) entry.\r\r\n"), dwMode);

    // Validate parameters.
    if( (NULL == pcbNeeded)
        ||
        ( (OEMGI_GETSIGNATURE != dwMode)
          &&
          (OEMGI_GETVERSION != dwMode)
          &&
          (OEMGI_GETPUBLISHERINFO != dwMode)
        )
      )
    {
        WARNING(DLLTEXT("IOemUI2::GetInfo() exit pcbNeeded is NULL! ERROR_INVALID_PARAMETER\r\r\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    // Set expected buffer size and number of bytes written.
    *pcbNeeded = sizeof(DWORD);

    // Check buffer size is sufficient.
    if((cbSize < *pcbNeeded) || (NULL == pBuffer))
    {
        WARNING(DLLTEXT("IOemUI2::GetInfo() exit insufficient buffer!\r\r\n"));
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return E_FAIL;
    }

    switch(dwMode)
    {
        // OEM DLL Signature
        case OEMGI_GETSIGNATURE:
            *(PDWORD)pBuffer = OEM_SIGNATURE;
            break;

        // OEM DLL version
        case OEMGI_GETVERSION:
            *(PDWORD)pBuffer = OEM_VERSION;
            break;

        // dwMode not supported.
        default:
            // Set written bytes to zero since nothing was written.
            WARNING(DLLTEXT("IOemUI2::GetInfo() exit mode not supported.\r\r\n"));
            *pcbNeeded = 0;
            SetLastError(ERROR_NOT_SUPPORTED);
            return E_FAIL;
    }

    VERBOSE(DLLTEXT("IOemUI2::GetInfo() exit S_OK, (*pBuffer is %#x).\r\r\n"), *(PDWORD)pBuffer);
    return S_OK;
}

HRESULT __stdcall IOemUI2::DevMode(
    DWORD  dwMode,
    POEMDMPARAM pOemDMParam)
{   
    VERBOSE(DLLTEXT("IOemUI2:DevMode(%d, %#x) entry.\r\n"), dwMode, pOemDMParam); 

    return hrOEMDevMode(dwMode, pOemDMParam);
}

HRESULT __stdcall IOemUI2::CommonUIProp(
    DWORD  dwMode,
    POEMCUIPPARAM   pOemCUIPParam)
{
    VERBOSE(DLLTEXT("IOemUI2:CommonUIProp entry.\r\n")); 

    return hrOEMPropertyPage(dwMode, pOemCUIPParam);
}


HRESULT __stdcall IOemUI2::DocumentPropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam)
{
    VERBOSE(DLLTEXT("IOemUI2:DocumentPropertySheets entry.\r\n")); 

    return hrOEMDocumentPropertySheets(pPSUIInfo, 
                                       lParam, 
                                       m_Helper, 
                                       &m_Features, 
                                       m_bHidingStandardUI);
}

HRESULT __stdcall IOemUI2::DevicePropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam)
{
    VERBOSE(DLLTEXT("IOemUI2:DevicePropertySheets entry.\r\n")); 

    return hrOEMDevicePropertySheets(pPSUIInfo, 
                                     lParam, 
                                     m_Helper, 
                                     &m_Features, 
                                     m_bHidingStandardUI);
}

HRESULT __stdcall IOemUI2::DeviceCapabilities(
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult)
{
    VERBOSE(DLLTEXT("IOemUI2:DeviceCapabilities entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUI2::DevQueryPrintEx(
    POEMUIOBJ               poemuiobj,
    PDEVQUERYPRINT_INFO     pDQPInfo,
    PDEVMODE                pPublicDM,
    PVOID                   pOEMDM)
{
    VERBOSE(DLLTEXT("IOemUI2:DevQueryPrintEx entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUI2::UpgradePrinter(
    DWORD   dwLevel,
    PBYTE   pDriverUpgradeInfo)
{
    VERBOSE(DLLTEXT("IOemUI2:UpgradePrinter entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUI2::PrinterEvent(
    PWSTR   pPrinterName,
    INT     iDriverEvent,
    DWORD   dwFlags,
    LPARAM  lParam)
{
    VERBOSE(DLLTEXT("IOemUI2:PrinterEvent entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUI2::DriverEvent(
    DWORD   dwDriverEvent,
    DWORD   dwLevel,
    LPBYTE  pDriverInfo,
    LPARAM  lParam)
{
    VERBOSE(DLLTEXT("IOemUI2:DriverEvent entry.\r\n"));

    return E_NOTIMPL;
};


HRESULT __stdcall IOemUI2::QueryColorProfile(
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulQueryMode,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData)
{
    VERBOSE(DLLTEXT("IOemUI2:QueryColorProfile entry.\r\n"));
 
    return E_NOTIMPL;
};

HRESULT __stdcall IOemUI2::FontInstallerDlgProc(
        HWND    hWnd,
        UINT    usMsg,
        WPARAM  wParam,
        LPARAM  lParam) 
{
    VERBOSE(DLLTEXT("IOemUI2:FontInstallerDlgProc entry.\r\n"));

    return E_NOTIMPL;
};

HRESULT __stdcall IOemUI2::UpdateExternalFonts(
        HANDLE  hPrinter,
        HANDLE  hHeap,
        PWSTR   pwstrCartridges)
{
    VERBOSE(DLLTEXT("IOemUI2:UpdateExternalFonts entry.\r\n"));

    return E_NOTIMPL;
}

// *********** IPrintOEMUI2 FUNCTIONS ****************

//
// QueryJobAttribtues
// 

HRESULT __stdcall IOemUI2::QueryJobAttributes(
    HANDLE      hPrinter,
    PDEVMODE    pDevmode,
    DWORD       dwLevel,
    LPBYTE      lpAttributeInfo)
{
    TERSE(DLLTEXT("IOemUI2:QueryJobAttributes entry.\r\n"));

    return E_NOTIMPL;
}

//
// Hide Standard UI
//

HRESULT __stdcall IOemUI2::HideStandardUI(
    DWORD       dwMode)
{
    HRESULT hrReturn    = E_NOTIMPL;


    TERSE(DLLTEXT("IOemUI2:HideStandardUI entry.\r\n"));

    switch(dwMode)
    {
        // By returning S_OK for both OEMCUIP_DOCPROP and OEMCUIP_PRNPROP,
        // we will hide the Standard UI for both Document Properties,
        // and Device Properties.
        // To not hide one or both, return E_NOTIMPL instead of S_OK,
        case OEMCUIP_DOCPROP:
        case OEMCUIP_PRNPROP:
            // Flag that we are hiding the Standard UI.
            // This is so we can tell easily between Driver UI
            // that supports HideStandardUI (such as WinXP PS UI),
            // or ones that don't (such as Win2K PS or Unidrv UI).
            m_bHidingStandardUI = TRUE;

            hrReturn = S_OK;
            break;
    }

    return hrReturn;
}

//
// DocumentEvent
//

HRESULT __stdcall IOemUI2::DocumentEvent(
    HANDLE      hPrinter,
    HDC         hdc,
    INT         iEsc,
    ULONG       cbIn,
    PVOID       pbIn,
    ULONG       cbOut,
    PVOID       pbOut,
    PINT        piResult)
{
    return E_NOTIMPL;
}


////////////////////////////////////////////////////////////////////////////////
//
// oem class factory
//
class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this) ;
    }
    else
    {
#if DBG
        TCHAR szOutput[80] = {0};
        StringFromGUID2(iid, szOutput, COUNTOF(szOutput)); // can not fail!
        WARNING(DLLTEXT("IOemCF::QueryInterface %s not supported.\r\n"), szOutput); 
#endif

        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCF::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    //DbgPrint(DLLTEXT("Class factory:\t\tCreate component.")) ;

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IOemUI2* pOemCB = new IOemUI2 ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }
    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv) ;

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release() ;
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks) ;
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks) ;
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Exported functions
//


// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    VERBOSE(DLLTEXT("DllGetClassObject:Create class factory.\r\n"));

    // Can we create this component?
    if (clsid != CLSID_OEMUI)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv) ;
    pFontCF->Release() ;

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\helper.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  2001  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Helper.h
//    
//
//  PURPOSE:	Defines wrapper class for Driver UI Helper Interface.
//
//
//  PLATFORMS:
//    Windows 2000, Windows XP
//
//
#ifndef _HELPER_H
#define _HELPER_H

#include "precomp.h"



class CUIHelper
{
    private:
        IUnknown   *m_pUIHelper;         // pointer to Driver UI's Helper interface
        IID        m_iidUIHelper;       // Driver UI's Helper interface IID

    public:
        CUIHelper();
        CUIHelper(const IID &HelperIID, PVOID pHelper);
        virtual ~CUIHelper();

        inline BOOL IsValid() {return NULL != m_pUIHelper;}

        void Assign(const IID &HelperIID, PVOID pHelper);
        ULONG Release();

    //
    // IPrintOemDriverUI methods
    //

    //
    // Helper function to get driver settings. This function is only supported
    // for UI plugins that do not fully replace core driver's standard UI.
    //

    STDMETHOD(DrvGetDriverSetting) (THIS_
                        PVOID   pci,
                        PCSTR   Feature,
                        PVOID   pOutput,
                        DWORD   cbSize,
                        PDWORD  pcbNeeded,
                        PDWORD  pdwOptionsReturned
                        );

    //
    // Helper function to allow OEM plugins upgrade private registry
    // settings. This function is supported for any UI plugins and should be
    // called only by OEM's UpgradePrinter.
    //

    STDMETHOD(DrvUpgradeRegistrySetting) (THIS_
                        HANDLE   hPrinter,
                        PCSTR    pFeature,
                        PCSTR    pOption
                        );

    //
    // Helper function to allow OEM plugins to update the driver UI settings.
    // This function is only supported for UI plugins that do not fully replace
    // core driver's standard UI. It should be called only when the UI is present.
    //

    STDMETHOD(DrvUpdateUISetting) (THIS_
                        PVOID    pci,
                        PVOID    pOptItem,
                        DWORD    dwPreviousSelection,
                        DWORD    dwMode
                        );

    //
    // IPrintCoreUI2 new methods
    //

    //
    // Following four helper functions are only supported for UI plugins that fully
    // replace core driver's standard UI. They should only be called by the UI plugin's
    // DocumentPropertySheets, DevicePropertySheets and their property sheet callback
    // functions.
    //
    // Helper function to retrieve driver's current setting as a list of
    // feature/option keyword pairs.
    //

    STDMETHOD(GetOptions) (THIS_
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pmszFeaturesRequested,
                           IN  DWORD      cbIn,
                           OUT PSTR       pmszFeatureOptionBuf,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded);

    //
    // Helper function to change driver's setting using a list of feature/option
    // keyword pairs.
    //

    STDMETHOD(SetOptions) (THIS_
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pmszFeatureOptionBuf,
                           IN  DWORD      cbIn,
                           OUT PDWORD     pdwResult);

    //
    // Helper function to retrieve the option(s) of a given feature that are
    // constrained in driver's current setting.
    //

    STDMETHOD(EnumConstrainedOptions) (THIS_
                                       IN  POEMUIOBJ  poemuiobj,
                                       IN  DWORD      dwFlags,
                                       IN  PCSTR      pszFeatureKeyword,
                                       OUT PSTR       pmszConstrainedOptionList,
                                       IN  DWORD      cbSize,
                                       OUT PDWORD     pcbNeeded);

    //
    // Helper function to retrieve a list of feature/option keyword pairs from
    // driver's current setting that conflict with the given feature/option pair.
    //

    STDMETHOD(WhyConstrained) (THIS_
                               IN  POEMUIOBJ  poemuiobj,
                               IN  DWORD      dwFlags,
                               IN  PCSTR      pszFeatureKeyword,
                               IN  PCSTR      pszOptionKeyword,
                               OUT PSTR       pmszReasonList,
                               IN  DWORD      cbSize,
                               OUT PDWORD     pcbNeeded);

    //
    // Following five helper functions are supported for any UI plugins.
    //
    // Helper function to retrieve global attribute.
    //

    STDMETHOD(GetGlobalAttribute) (THIS_
                                   IN  POEMUIOBJ  poemuiobj,
                                   IN  DWORD      dwFlags,
                                   IN  PCSTR      pszAttribute,
                                   OUT PDWORD     pdwDataType,
                                   OUT PBYTE      pbData,
                                   IN  DWORD      cbSize,
                                   OUT PDWORD     pcbNeeded);


    //
    // Helper function to retrieve attribute of a given feature.
    //

    STDMETHOD(GetFeatureAttribute) (THIS_
                                    IN  POEMUIOBJ  poemuiobj,
                                    IN  DWORD      dwFlags,
                                    IN  PCSTR      pszFeatureKeyword,
                                    IN  PCSTR      pszAttribute,
                                    OUT PDWORD     pdwDataType,
                                    OUT PBYTE      pbData,
                                    IN  DWORD      cbSize,
                                    OUT PDWORD     pcbNeeded);

    //
    // Helper function to retrieve attribute of a given feature/option selection.
    //

    STDMETHOD(GetOptionAttribute) (THIS_
                                   IN  POEMUIOBJ  poemuiobj,
                                   IN  DWORD      dwFlags,
                                   IN  PCSTR      pszFeatureKeyword,
                                   IN  PCSTR      pszOptionKeyword,
                                   IN  PCSTR      pszAttribute,
                                   OUT PDWORD     pdwDataType,
                                   OUT PBYTE      pbData,
                                   IN  DWORD      cbSize,
                                   OUT PDWORD     pcbNeeded);

    //
    // Helper function to retrieve the list of feature keyword.
    //

    STDMETHOD(EnumFeatures) (THIS_
                             IN  POEMUIOBJ  poemuiobj,
                             IN  DWORD      dwFlags,
                             OUT PSTR       pmszFeatureList,
                             IN  DWORD      cbSize,
                             OUT PDWORD     pcbNeeded);

    //
    // Helper function to retrieve the list of options keyword of a given feature.
    //

    STDMETHOD(EnumOptions) (THIS_
                            IN  POEMUIOBJ  poemuiobj,
                            IN  DWORD      dwFlags,
                            IN  PCSTR      pszFeatureKeyword,
                            OUT PSTR       pmszOptionList,
                            IN  DWORD      cbSize,
                            OUT PDWORD     pcbNeeded);

    //
    // Helper function to query system simulation support
    //

    STDMETHOD(QuerySimulationSupport) (THIS_
                                       IN  HANDLE  hPrinter,
                                       IN  DWORD   dwLevel,
                                       OUT PBYTE   pCaps,
                                       IN  DWORD   cbSize,
                                       OUT PDWORD  pcbNeeded);

    private:
        void Clear();
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\syncset\debug.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.cpp
//    
//
//  PURPOSE:  Debug functions.
//
//
//	Functions:
//
//
//
//  PLATFORMS:	Windows NT, Windows 2000
//
//

#include "precomp.h"
#include "oem.h"
#include "debug.h"



////////////////////////////////////////////////////////
//      INTERNAL DEFINES
////////////////////////////////////////////////////////

#define DEBUG_BUFFER_SIZE       1024
#define PATH_SEPARATOR          '\\'



// Determine what level of debugging messages to eject. 
#ifdef VERBOSE_MSG
    #define DEBUG_LEVEL     DBG_VERBOSE
#elif TERSE_MSG
    #define DEBUG_LEVEL     DBG_TERSE
#elif WARNING_MSG
    #define DEBUG_LEVEL     DBG_WARNING
#elif ERROR_MSG
    #define DEBUG_LEVEL     DBG_ERROR
#elif RIP_MSG
    #define DEBUG_LEVEL     DBG_RIP
#elif NO_DBG_MSG
    #define DEBUG_LEVEL     DBG_NONE
#else
    #define DEBUG_LEVEL     DBG_WARNING
#endif



////////////////////////////////////////////////////////
//      EXTERNAL GLOBALS
////////////////////////////////////////////////////////

INT giDebugLevel = DEBUG_LEVEL;




////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist);
static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist);




//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist)
{
    DWORD   dwSize = DEBUG_BUFFER_SIZE;
    LPSTR   lpszMsgBuf = NULL;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    do
    {
        // Allocate memory for message buffer.
        if(NULL != lpszMsgBuf)
        {
            delete[] lpszMsgBuf;
            dwSize *= 2;
        }
        lpszMsgBuf = new CHAR[dwSize + 1];
        if(NULL == lpszMsgBuf)
            return FALSE;

    // Pass the variable parameters to wvsprintf to be formated.
    } while (_vsnprintf(lpszMsgBuf, dwSize, lpszMessage, arglist) < 0);

    // Dump string to Debug output.
    OutputDebugStringA(lpszMsgBuf);

    // Cleanup.
    delete[] lpszMsgBuf;

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist)
{
    LPWSTR     lpszMsgBuf;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    // Allocate memory for message buffer.
    lpszMsgBuf = new WCHAR[dwSize + 1];    
    if(NULL == lpszMsgBuf)
        return FALSE;

    // Pass the variable parameters to wvsprintf to be formated.
    vswprintf(lpszMsgBuf, lpszMessage, arglist);

    // Dump string to debug output.
    OutputDebugStringW(lpszMsgBuf);

    // Clean up.
    delete[] lpszMsgBuf;

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV for processing.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCWSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV to be processed.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(MAX_PATH, lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}

void Dump(PPUBLISHERINFO pPublisherInfo)
{
    VERBOSE(__TEXT("pPublisherInfo:\r\n"));
    VERBOSE(__TEXT("\tdwMode           =   %#x\r\n"), pPublisherInfo->dwMode);
    VERBOSE(__TEXT("\twMinoutlinePPEM  =   %d\r\n"), pPublisherInfo->wMinoutlinePPEM);
    VERBOSE(__TEXT("\twMaxbitmapPPEM   =   %d\r\n"), pPublisherInfo->wMaxbitmapPPEM);
}

void Dump(POEMDMPARAM pOemDMParam)
{
    VERBOSE(__TEXT("pOemDMParam:\r\n"));
    VERBOSE(__TEXT("\tcbSize = %d\r\n"), pOemDMParam->cbSize);
    VERBOSE(__TEXT("\tpdriverobj = %#x\r\n"), pOemDMParam->pdriverobj);
    VERBOSE(__TEXT("\thPrinter = %#x\r\n"), pOemDMParam->hPrinter);
    VERBOSE(__TEXT("\thModule = %#x\r\n"), pOemDMParam->hModule);
    VERBOSE(__TEXT("\tpPublicDMIn = %#x\r\n"), pOemDMParam->pPublicDMIn);
    VERBOSE(__TEXT("\tpPublicDMOut = %#x\r\n"), pOemDMParam->pPublicDMOut);
    VERBOSE(__TEXT("\tpOEMDMIn = %#x\r\n"), pOemDMParam->pOEMDMIn);
    VERBOSE(__TEXT("\tpOEMDMOut = %#x\r\n"), pOemDMParam->pOEMDMOut);
    VERBOSE(__TEXT("\tcbBufSize = %d\r\n"), pOemDMParam->cbBufSize);
}

void Dump(PPROPSHEETUI_INFO pPSUIInfo)
{
    VERBOSE(__TEXT("pPSUIInfo:\r\n"));
    VERBOSE(__TEXT("\tcbSize          = %d\r\n"), pPSUIInfo->cbSize);
    VERBOSE(__TEXT("\tVersion         = %#x\r\n"), pPSUIInfo->Version);
    VERBOSE(__TEXT("\tFlags           = %#x\r\n"), pPSUIInfo->Flags);
    VERBOSE(__TEXT("\tReason          = %d\r\n"), pPSUIInfo->Reason);
    VERBOSE(__TEXT("\thComPropSheet   = %#x\r\n"), pPSUIInfo->hComPropSheet);
    VERBOSE(__TEXT("\tpfnComPropSheet = %#x\r\n"), pPSUIInfo->pfnComPropSheet);
    VERBOSE(__TEXT("\tlParamInit      = %#x\r\n"), pPSUIInfo->lParamInit);
    VERBOSE(__TEXT("\tUserData        = %#x\r\n"), pPSUIInfo->UserData);
    VERBOSE(__TEXT("\tResult          = %#x\r\n"), pPSUIInfo->Result);
}



PCSTR
StripDirPrefixA(
    IN PCSTR    pstrFilename
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    PCSTR   pstr;

    if (pstr = strrchr(pstrFilename, PATH_SEPARATOR))
        return pstr + 1;

    return pstrFilename;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\oemui.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997 - 2001  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	OEMUI.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for OEMUI Test Module.
//
//  PLATFORMS:
//    Windows 2000, Windows XP
//
//
#ifndef _OEMUI_H
#define _OEMUI_H

#include "precomp.h"
#include <PRCOMOEM.H>

#include "oem.h"
#include "devmode.h"
#include "globals.h"
#include "helper.h"
#include "features.h"



////////////////////////////////////////////////////////
//      OEM UI Defines
////////////////////////////////////////////////////////


// OEM Signature and version.
#define PROP_TITLE      L"OEM PS UI Replacement Page"
#define DLLTEXT(s)      TEXT("PSUIREP:  ") TEXT(s)

// OEM UI Misc defines.
#define ERRORTEXT(s)    TEXT("ERROR ") DLLTEXT(s)


// Printer registry keys where OEM data is stored.
#define OEMUI_VALUE             TEXT("OEMUI_VALUE")
#define OEMUI_DEVICE_VALUE      TEXT("OEMUI_DEVICE_VALUE")




////////////////////////////////////////////////////////
//      Prototypes
////////////////////////////////////////////////////////

HRESULT hrOEMPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam);
HRESULT hrOEMDocumentPropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam, CUIHelper &Helper, CFeatures *pFeatures,
                                    BOOL bHidingStandardUI);
HRESULT hrOEMDevicePropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam, CUIHelper &Helper, CFeatures *pFeatures,
                                  BOOL bHidingStandardUI);

POPTITEM CreateOptItems(HANDLE hHeap, DWORD dwOptItems);
POPTTYPE CreateOptType(HANDLE hHeap, WORD wOptParams);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\syncset\debug.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debugging functions.
//
//  PLATFORMS:
//
//    Windows NT, Windows 2000
//
//
#ifndef _DEBUG_H
#define _DEBUG_H


// VC and Build use different debug defines.
// The following makes it so either will
// cause the inclusion of debugging code.
#if !defined(_DEBUG) && defined(DBG)
    #define _DEBUG      DBG
#elif defined(_DEBUG) && !defined(DBG)
    #define DBG         _DEBUG
#endif



/////////////////////////////////////////////////////////
//		Macros
/////////////////////////////////////////////////////////

//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// giDebugLevel
//  Global variable which set the current debug level to control
//  the amount of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ERR(msg)
//  Similiar to WARNING macro above - displays a message
//  if the current debug level is <= DBG_ERROR.
//
// ASSERT(cond)
//  Verify a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//  These macros require extra parantheses for the msg argument
//  example, ASSERTMSG(x > 0, ("x is less than 0\n"));
//           WARNING(("App passed NULL pointer, ignoring...\n"));
//

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_ERROR   4
#define DBG_RIP     5
#define DBG_NONE    6

#if DBG

    #define DebugMsg    DebugMessage

    //
    // Strip the directory prefix from a filename (ANSI version)
    //

    PCSTR
    StripDirPrefixA(
        IN PCSTR    pstrFilename
        );

    extern INT giDebugLevel;


    #define DBGMSG(level, prefix, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg("%s %s (%d): ", prefix, StripDirPrefixA(__FILE__), __LINE__); \
                    DebugMsg(msg); \
                } \
            }

    #define DBGPRINT(level, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg(msg); \
                } \
            }

    #define VERBOSE         if(giDebugLevel <= DBG_VERBOSE) DebugMsg
    #define TERSE           if(giDebugLevel <= DBG_TERSE) DebugMsg
    #define WARNING         if(giDebugLevel <= DBG_WARNING) DebugMsg
    #define ERR             if(giDebugLevel <= DBG_ERROR) DebugMsg

    #define ASSERT(cond) { \
                if (! (cond)) { \
                    RIP(("\n")); \
                } \
            }

    #define ASSERTMSG(cond, msg) { \
                if (! (cond)) { \
                    RIP(msg); \
                } \
            }

    #define RIP(msg) { \
                DBGMSG(DBG_RIP, "RIP", msg); \
                DebugBreak(); \
            }


#else // !DBG

    #define DebugMsg    NOP_FUNCTION

    #define VERBOSE     NOP_FUNCTION
    #define TERSE       NOP_FUNCTION
    #define WARNING     NOP_FUNCTION
    #define ERR         NOP_FUNCTION

    #define ASSERT(cond)

    #define ASSERTMSG(cond, msg)
    #define RIP(msg)
    #define DBGMSG(level, prefix, msg)
    #define DBGPRINT(level, msg)

#endif




/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR, ...);
BOOL DebugMessage(LPCWSTR, ...);
void Dump(PPUBLISHERINFO pPublisherInfo);
void Dump(POEMDMPARAM pOemDMParam);
void Dump(PPROPSHEETUI_INFO pPSUIInfo);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\oem.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997 - 2001  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debug.cpp.
//
//  PLATFORMS:
//    Windows 2000, Windows XP
//
//
#ifndef _OEM_H
#define _OEM_H



////////////////////////////////////////////////////////
//      OEM Defines
////////////////////////////////////////////////////////

#define OEM_SIGNATURE   'MSFT'
#define OEM_VERSION     0x00000001L



////////////////////////////////////////////////////////
//      OEM Type Definitions
////////////////////////////////////////////////////////



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\stringutils.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  2001  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Features.cpp
//    
//
//  PURPOSE:  Implementation wrapper class for WinXP PS Driver Features and Options.
//
//
//
//  PLATFORMS:    Windows XP
//
//

#include "precomp.h"
#include "debug.h"
#include "oemui.h"
#include "stringutils.h"





// Create a list of pointers to the strings
// in a multi-sz.
HRESULT MakeStrPtrList(HANDLE hHeap, PCSTR pmszMultiSz, PCSTR **pppszList, PWORD pwCount)
{
    PCSTR   *ppszList   = NULL;
    HRESULT hrResult    = S_OK;


    // Validate parameters
    if( (NULL == hHeap)
        ||
        (NULL == pmszMultiSz)
        ||
        (NULL == pppszList)
        ||
        (NULL == pwCount)
      )
    {
        return E_INVALIDARG;
    }

    // Get the count of strings in the multi-sz.
    *pwCount = mstrcount(pmszMultiSz);
    if(0 == *pwCount)
    {
        WARNING(DLLTEXT("MakeStrPtrList() pmszMultiSz contains no strings.\r\n")); 

        goto Exit;
    }

    // Allocate pointer list.
    *pppszList = (PCSTR *) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, (*pwCount) * sizeof(PCSTR));
    if(NULL == *pppszList)
    {
        ERR(ERRORTEXT("MakeStrPtrList() failed to allote array of PCSTR.\r\n")); 

        hrResult = E_OUTOFMEMORY;
        goto Exit;
    }
    ppszList = *pppszList; 

    // Walk multi-sz mapping string pointers.
    for(WORD wIndex = 0; wIndex < *pwCount; ++wIndex)
    {
        ppszList[wIndex] = pmszMultiSz;
        pmszMultiSz += lstrlenA(pmszMultiSz) + 1;
    }


Exit:

    return hrResult;
}


// Determine how many strings are in the multi-sz.
WORD mstrcount(PCSTR pmszMultiSz)
{
    WORD    wCount = 0;


    // NULL string pointers have no strings.
    if(NULL == pmszMultiSz)
    {
        return 0;
    }

    // Walk list of strings counting them.
    while(pmszMultiSz[0] != '\0')
    {
        ++wCount;
        pmszMultiSz += lstrlenA(pmszMultiSz) + 1;
    }

    return wCount;
}

// Allocates and converts ANSI string to Unicode.
PWSTR MakeUnicodeString(HANDLE hHeap, PCSTR pszAnsi)
{
    int     nSize       = 0;
    PWSTR   pszUnicode  = NULL;


    // Validate parameters
    if( (NULL == hHeap)
        ||
        (NULL == pszAnsi)
      )
    {
        return NULL;
    }

    // Get the size needed for UNICODE string.
    nSize = MultiByteToWideChar(CP_ACP, 0, pszAnsi, -1, NULL, 0);
    if(0 != nSize)
    {
        // Allocate unicode string.
        pszUnicode = (PWSTR) HeapAlloc(hHeap, 0, nSize * sizeof(WCHAR));
        if(NULL != pszUnicode)
        {
            // Convert ANSI to Unicode
            nSize = MultiByteToWideChar(CP_ACP, 0, pszAnsi, -1, pszUnicode, nSize);
            if(0 == nSize)
            {
                // INVARIANT:  failed to convert.

                // free buffer and return NULL.
                HeapFree(hHeap, 0, pszUnicode);
                pszUnicode = NULL;
            }
        }
    }

    return pszUnicode;
}

// Allocates and copies source string.
PWSTR MakeStringCopy(HANDLE hHeap, PCWSTR pszSource)
{
    PWSTR   pszCopy = NULL;

    // Validate parameters
    if( (NULL == hHeap)
        ||
        (NULL == pszSource)
      )
    {
        return NULL;
    }

    // Allocate memory for string duplication, and duplicate the string.
    pszCopy = (PWSTR) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, (wcslen(pszSource) + 1) * sizeof(WCHAR));
    if(NULL != pszCopy)
    {
        wcscpy(pszCopy, pszSource);
    }

    return pszCopy;
}

// Allocates and copies source string.
PSTR MakeStringCopy(HANDLE hHeap, PCSTR pszSource)
{
    PSTR   pszCopy = NULL;

    // Validate parameters
    if( (NULL == hHeap)
        ||
        (NULL == pszSource)
      )
    {
        return NULL;
    }

    // Allocate memory for string duplication, and duplicate the string.
    pszCopy = (PSTR) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, lstrlenA(pszSource) + sizeof(CHAR));
    if(NULL != pszCopy)
    {
        lstrcpyA(pszCopy, pszSource);
    }

    return pszCopy;
}

// Frees list of strings.
// NOTE: don't use this for string list made with MakeStrPtrList(), since
//       the strings pointed to be list made with MakeStrPtrList() will 
//       be freed when the multi-sz is freed.
void FreeStringList(HANDLE hHeap, PWSTR *ppszList, WORD wCount)
{
    // Validate parameters.
    if( (NULL == hHeap)
        ||
        (NULL == ppszList)
      )
    {
        return;
    }

    // Free each of the strings in the list.
    for(WORD wIndex = 0; wIndex < wCount; ++wIndex)
    {
        if(NULL != ppszList[wIndex]) HeapFree(hHeap, 0, ppszList[wIndex]);
    }

    // Free list.
    HeapFree(hHeap, 0, ppszList);
}


//  Retrieves pointer to a String resource.
HRESULT GetStringResource(HANDLE hHeap, HMODULE hModule, UINT uResource, PWSTR *ppszString)
{
    int     nResult;
    DWORD   dwSize      = MAX_PATH;
    PWSTR   pszString   = NULL;
    HRESULT hrResult    = S_OK;


    VERBOSE(DLLTEXT("GetStringResource(%#x, %#x, %d) entered.\r\n"), hHeap, hModule, uResource);

    // Validate parameters.
    if( (NULL == hHeap)
        ||
        (NULL == ppszString)
      )
    {
        return E_INVALIDARG;
    }

    // Allocate buffer for string resource from heap; let the driver clean it up.
    pszString = (PWSTR) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwSize * sizeof(WCHAR));
    if(NULL == pszString)
    {
        ERR(ERRORTEXT("GetStringResource() failed to allocate string buffer!\r\n"));

        hrResult = E_OUTOFMEMORY;
        goto Exit;
    }

    // Load string resource; resize after loading so as not to waste memory.
    nResult = LoadString(hModule, uResource, pszString, dwSize);
    if(nResult > 0)
    {
        PWSTR   pszTemp;


        VERBOSE(DLLTEXT("LoadString() returned %d!\r\n"), nResult);
        VERBOSE(DLLTEXT("String load was \"%s\".\r\n"), pszString);

        pszTemp = (PWSTR) HeapReAlloc(hHeap, HEAP_ZERO_MEMORY, pszString, (nResult + 1) * sizeof(WCHAR));
        if(NULL != pszTemp)
        {
            pszString = pszTemp;
        }
        else
        {
            WARNING(DLLTEXT("GetStringResource() HeapReAlloc() of string retrieved failed! (Last Error was %d)\r\n"), GetLastError());
        }
    }
    else
    {
        DWORD   dwError = GetLastError();


        ERR(ERRORTEXT("LoadString() returned %d! (Last Error was %d)\r\n"), nResult, GetLastError());
        ERR(ERRORTEXT("GetStringResource() failed to load string resource %d!\r\n"), uResource);

        HeapFree(hHeap, 0, pszString);
        pszString   = NULL;
        hrResult    = HRESULT_FROM_WIN32(dwError);
    }


Exit:

    // Save string pointer to caller.
    // NOTE: string pointer will be NULL on failure.
    *ppszString = pszString;

    return hrResult;
}

//  Retrieves pointer to a String resource.
HRESULT GetStringResource(HANDLE hHeap, HMODULE hModule, UINT uResource, PSTR *ppszString)
{
    int     nResult;
    DWORD   dwSize      = MAX_PATH;
    PSTR    pszString   = NULL;
    HRESULT hrResult    = S_OK;


    VERBOSE(DLLTEXT("GetStringResource(%#x, %#x, %d) entered.\r\n"), hHeap, hModule, uResource);

    // Validate parameters.
    if( (NULL == hHeap)
        ||
        (NULL == ppszString)
      )
    {
        return E_INVALIDARG;
    }

    // Allocate buffer for string resource from heap; let the driver clean it up.
    pszString = (PSTR) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwSize * sizeof(WCHAR));
    if(NULL == pszString)
    {
        ERR(ERRORTEXT("GetStringResource() failed to allocate string buffer!\r\n"));

        hrResult = E_OUTOFMEMORY;
        goto Exit;
    }

    // Load string resource; resize after loading so as not to waste memory.
    nResult = LoadStringA(hModule, uResource, pszString, dwSize);
    if(nResult > 0)
    {
        PSTR   pszTemp;


        VERBOSE(DLLTEXT("LoadString() returned %d!\r\n"), nResult);
        VERBOSE(DLLTEXT("String load was \"%hs\".\r\n"), pszString);

        pszTemp = (PSTR) HeapReAlloc(hHeap, HEAP_ZERO_MEMORY, pszString, nResult + 1);
        if(NULL != pszTemp)
        {
            pszString = pszTemp;
        }
        else
        {
            WARNING(DLLTEXT("GetStringResource() HeapReAlloc() of string retrieved failed! (Last Error was %d)\r\n"), GetLastError());
        }
    }
    else
    {
        DWORD   dwError = GetLastError();


        ERR(ERRORTEXT("LoadString() returned %d! (Last Error was %d)\r\n"), nResult, GetLastError());
        ERR(ERRORTEXT("GetStringResource() failed to load string resource %d!\r\n"), uResource);

        HeapFree(hHeap, 0, pszString);
        pszString   = NULL;
        hrResult    = HRESULT_FROM_WIN32(dwError);
    }


Exit:

    // Save string pointer to caller.
    // NOTE: string pointer will be NULL on failure.
    *ppszString = pszString;

    return hrResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by OEMUI.rc
//
#define IDS_SECTION                     1
#define IDS_CALIBRATED                  2
#define IDS_NAME                        3
#define IDS_DEVICE_SETTINGS_NAME        4
#define IDS_CONSTRAINT_CONFLICT         5
#define IDD_DEVICE_PROPPAGE             106
#define IDD_DOC_PROPPAGE                107
#define IDS_POSTSCRIPT_VM               400
#define IDS_KBYTES                      401
#define IDS_SECONDS                     402
#define IDS_PSTIMEOUTS                  403
#define IDS_JOBTIMEOUT                  404
#define IDS_WAITTIMEOUT                 405
#define IDS_PRINTER_DEFAULT             406
#define IDS_INSTALLABLE_OPTIONS         407
#define IDS_DOWNLOAD_AS_SOFTFONT        408
#define IDS_USE_DEVFONTS                409
#define IDS_FONTSUB_OPTION              410
#define IDS_FONTSUB_DEFAULT             411
#define IDS_FONTSUB_SLOW                412
#define IDS_FONTSUB_TABLE               413
#define IDS_DEFAULT_TRAY                414
#define IDS_DRAW_ONLY_FROM_SELECTED     415
#define IDS_RESTORE_DEFAULTS            417
#define IDS_PRINTER_FEATURES            418
#define IDS_METAFILE_SPOOLING           419
#define IDS_ENABLED                     420
#define IDS_DISABLED                    421
#define IDS_PSOPTIONS                   422
#define IDS_MIRROR                      423
#define IDS_NEGATIVE_PRINT              424
#define IDS_PAGEINDEP                   425
#define IDS_COMPRESSBMP                 426
#define IDS_CTRLD_BEFORE                427
#define IDS_CTRLD_AFTER                 428
#define IDS_JOB_CONTROL                 429
#define IDS_TEXT_ASGRX                  431
#define IDS_PAGE_PROTECTION             432
#define IDS_CANCEL_CONFLICT             433
#define IDS_IGNORE_CONFLICT             434
#define IDS_RESOLVE_CONFLICT            435
#define IDS_GETDATA_FAILED              436
#define IDS_DRIVERUI_COLORMODE          437
#define IDS_ENVELOPE                    438
#define IDS_ENV_PREFIX                  439
#define IDS_PSPROTOCOL                  440
#define IDS_PSPROTOCOL_ASCII            441
#define IDS_PSPROTOCOL_BCP              442
#define IDS_PSPROTOCOL_TBCP             443
#define IDS_PSPROTOCOL_BINARY           444
#define IDS_TRAY_FORMSOURCE             445
#define IDS_OEMERR_DLGTITLE             446
#define IDS_OEMERR_OPTITEM              447
#define IDS_OEMERR_PROPSHEET            448
#define IDS_CANCEL_CONFLICT_FINAL       449
#define IDS_PSERROR_HANDLER             450
#define IDS_PSMINOUTLINE                451
#define IDS_PSMAXBITMAP                 452
#define IDS_PIXELS                      453
#define IDS_PSOUTPUT_OPTION             454
#define IDS_PSOPT_SPEED                 455
#define IDS_PSOPT_PORTABILITY           456
#define IDS_PSOPT_EPS                   457
#define IDS_PSOPT_ARCHIVE               458
#define IDS_PSTT_DLFORMAT               459
#define IDS_TTDL_DEFAULT                460
#define IDS_TTDL_TYPE1                  461
#define IDS_TTDL_TYPE3                  462
#define IDS_TTDL_TYPE42                 463
#define IDS_PSLEVEL                     471
#define IDS_TRUE_GRAY_TEXT              507
#define IDS_TRUE_GRAY_GRAPH             508
#define IDS_ADD_EURO                    509
#define IDS_PSCRIPT_CUSTOMSIZE          600
#define IDC_CALIBRATE                   1001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\syncset\devmode.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Devmode.h
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for devmode functions.
//
//  PLATFORMS:
//
//    Windows NT
//
//
#ifndef _DEVMODE_H
#define _DEVMODE_H


////////////////////////////////////////////////////////
//      OEM Devmode Defines
////////////////////////////////////////////////////////




////////////////////////////////////////////////////////
//      OEM Devmode Type Definitions
////////////////////////////////////////////////////////

//
//Can add info to the private devmode bellow here.
//Note :
//		This structure must be prefixed by OEM_DMEXTRAHEADER
//		Your plug-in must implement the IPrintOemUI::DevMode method
//
typedef struct tagOEMDEV
{
    OEM_DMEXTRAHEADER   dmOEMExtra;
    BOOL                dwDriverData;
	//
	//Private DevMode Members
	//

} OEMDEV, *POEMDEV;

typedef const OEMDEV *PCOEMDEV;



/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

HRESULT hrOEMDevMode(DWORD dwMode, POEMDMPARAM pOemDMParam);
BOOL ConvertOEMDevmode(PCOEMDEV pOEMDevIn, POEMDEV pOEMDevOut);
BOOL MakeOEMDevmodeValid(POEMDEV pOEMDevmode);
void Dump(PCOEMDEV pOEMDevIn);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\precomp.h ===
//    
//
//  PURPOSE:	Header files that should be in the precompiled header.

//
//  PLATFORMS:
//    Windows 2000, Windows XP
//
//
#ifndef _PRECOMP_H
#define _PRECOMP_H


// Necessary for compiling under VC.
#if(!defined(WINVER) || (WINVER < 0x0500))
	#undef WINVER
	#define WINVER          0x0500
#endif
#if(!defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500))
	#undef _WIN32_WINNT
	#define _WIN32_WINNT    0x0500
#endif

// Polymorphic types for Win32/Win64
// These don't exist for NT4.
#ifdef WINNT_40
    #define ULONG_PTR   ULONG
    #define LONG_PTR    LONG
#endif


// Required header files that shouldn't change often.


#include <STDDEF.H>
#include <STDLIB.H>
#include <OBJBASE.H>
#include <STDARG.H>
#include <STDIO.H>
#include <LIMITS.H>
#include <WINDEF.H>
#include <WINERROR.H>
#include <WINBASE.H>
#include <WINGDI.H>
#include <WINDDI.H>
#include <WINSPOOL.H>
#include <TCHAR.H>
#include <EXCPT.H>
#include <ASSERT.H>
#include <PRSHT.H>
#include <COMPSTUI.H>
#include <WINDDIUI.H>
#include <PRINTOEM.H>

#define COUNTOF(p)  (sizeof(p)/sizeof(*(p)))



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\syncset\dllentry.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	dllentry.cpp
//    
//
//  PURPOSE:  Source module for DLL entry function(s).
//
//
//	Functions:
//
//		DllMain
//
//
//  PLATFORMS:	Windows NT
//
//

#include "precomp.h"
#include "oemui.h"
#include "debug.h"



// Need to export these functions as c declarations.
extern "C" {


///////////////////////////////////////////////////////////
//
// DLL entry point
//
BOOL WINAPI DllMain(HINSTANCE hInst, WORD wReason, LPVOID lpReserved)
{
	switch(wReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(DLLTEXT("Process attach.\r\n"));
            ghInstance = hInst;
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(DLLTEXT("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(DLLTEXT("Process detach.\r\n"));
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(DLLTEXT("Thread detach.\r\n"));
			break;
	}

	return TRUE;
}


}  // extern "C" closing bracket
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\oemui.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997 - 2001  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    OEMUI.cpp
//    
//
//  PURPOSE:  Main file for OEM UI test module.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP
//
//

#include "precomp.h"
#include "resource.h"
#include "debug.h"
#include "stringutils.h"
#include "oemui.h"



////////////////////////////////////////////////////////
//      INTERNAL MACROS and DEFINES
////////////////////////////////////////////////////////

typedef struct _tagCBUserData 
{
    HANDLE          hComPropSheet;
    HANDLE          hPropPage;
    POEMUIPSPARAM   pOEMUIParam;
    PFNCOMPROPSHEET pfnComPropSheet;
    CUIHelper       *pHelper;
    POEMUIOBJ       poemuiobj;
    BOOL            bPermission;
    BOOL            bHidingStandardUI;

} CBUSERDATA, *PCBUSERDATA;



////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static HRESULT hrDocumentPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam);
static HRESULT hrPrinterPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam);
LONG APIENTRY OEMPrinterUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam);
LONG APIENTRY OEMDocUIItemCallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam);
LONG APIENTRY OEMDocUICallBack(PCPSUICBPARAM pCallbackParam);
LONG APIENTRY OEMDevUICallBack(PCPSUICBPARAM pCallbackParam);
BOOL APIENTRY DevicePropPageProc(HWND hDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);
static void InitOptItems(POPTITEM pOptItems, DWORD dwOptItems);




////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems to display OEM device or document property UI.
//
HRESULT hrOEMPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
    HRESULT hResult = S_OK;


    VERBOSE(DLLTEXT("hrOEMPropertyPage(%d) entry.\r\n"), dwMode);

    // Validate parameters.
    if( (OEMCUIP_DOCPROP != dwMode)
        &&
        (OEMCUIP_PRNPROP != dwMode)        
      )
    {
        ERR(ERRORTEXT("hrOEMPropertyPage() ERROR_INVALID_PARAMETER.\r\n"));
        VERBOSE(DLLTEXT("\tdwMode = %d, pOEMUIParam = %#lx.\r\n"), dwMode, pOEMUIParam);

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    switch(dwMode)
    {
        case OEMCUIP_DOCPROP:
            hResult = hrDocumentPropertyPage(dwMode, pOEMUIParam);
            break;

        case OEMCUIP_PRNPROP:
            hResult = hrPrinterPropertyPage(dwMode, pOEMUIParam);
            break;

        default:
            // Should never reach this!
            ERR(ERRORTEXT("hrOEMPropertyPage() Invalid dwMode, %d"), dwMode);
            SetLastError(ERROR_INVALID_PARAMETER);
            hResult = E_FAIL;
            break;
    }

    return hResult;
}

////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems to display OEM document property UI.
//
static HRESULT hrDocumentPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
    HRESULT hrResult = S_OK;


    if(NULL == pOEMUIParam->pOEMOptItems)
    {
        // Fill in the number of OptItems to create for OEM document property UI.
        pOEMUIParam->cOEMOptItems = 1;

        VERBOSE(DLLTEXT("hrDocumentPropertyPage() requesting %d number of items.\r\n"), pOEMUIParam->cOEMOptItems);
    }
    else
    {
        POEMDEV pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;


        VERBOSE(DLLTEXT("hrDocumentPropertyPage() fill out %d items.\r\n"), pOEMUIParam->cOEMOptItems);

        // Init UI Callback reference.
        pOEMUIParam->OEMCUIPCallback = OEMDocUIItemCallBack;

        // Init OEMOptItmes.
        InitOptItems(pOEMUIParam->pOEMOptItems, pOEMUIParam->cOEMOptItems);

        // Fill out tree view items.

        // New section.
        pOEMUIParam->pOEMOptItems[0].Level = 1;
        pOEMUIParam->pOEMOptItems[0].Flags = OPTIF_COLLAPSE;
        pOEMUIParam->pOEMOptItems[0].Sel = pOEMDev->dwDriverData;

        hrResult = GetStringResource(pOEMUIParam->hOEMHeap, 
                                     (HMODULE) pOEMUIParam->hModule, 
                                     IDS_SECTION, 
                                     &pOEMUIParam->pOEMOptItems[0].pName);
        if(!SUCCEEDED(hrResult))
        {
            ERR(ERRORTEXT("hrDocumentPropertyPage() failed to get section name. (hrResult = 0x%x)\r\n"),
                          hrResult); 
            goto Exit;
        }

        pOEMUIParam->pOEMOptItems[0].pOptType = CreateOptType(pOEMUIParam->hOEMHeap, 2);

        pOEMUIParam->pOEMOptItems[0].pOptType->Type = TVOT_UDARROW;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].IconID = 0;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].lParam = 100;
    }


Exit:

    return hrResult;
}

////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems to display OEM printer property UI.
//
static HRESULT hrPrinterPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
    HRESULT hrResult = S_OK;


    if(NULL == pOEMUIParam->pOEMOptItems)
    {
        // Fill in the number of OptItems to create for OEM printer property UI.
        pOEMUIParam->cOEMOptItems = 1;

        VERBOSE(DLLTEXT("hrPrinterPropertyPage() requesting %d number of items.\r\n"), pOEMUIParam->cOEMOptItems);
    }
    else
    {
        DWORD   dwError;
        DWORD   dwDeviceValue;
        DWORD   dwType;
        DWORD   dwNeeded;


        VERBOSE(DLLTEXT("hrPrinterPropertyPage() fill out %d items.\r\n"), pOEMUIParam->cOEMOptItems);

        // Get device settings value from printer.
        dwError = GetPrinterData(pOEMUIParam->hPrinter, OEMUI_VALUE, &dwType, (PBYTE) &dwDeviceValue,
                                   sizeof(dwDeviceValue), &dwNeeded);
        if( (ERROR_SUCCESS != dwError)
            ||
            (dwDeviceValue > 100)
          )
        {
            // Failed to get the device value or value is invalid, just use the default.
            dwDeviceValue = 0;
        }

        // Init UI Callback reference.
        pOEMUIParam->OEMCUIPCallback = OEMPrinterUICallBack;

        // Init OEMOptItmes.
        InitOptItems(pOEMUIParam->pOEMOptItems, pOEMUIParam->cOEMOptItems);

        // Fill out tree view items.

        // New section.
        pOEMUIParam->pOEMOptItems[0].Level = 1;
        pOEMUIParam->pOEMOptItems[0].Flags = OPTIF_COLLAPSE;
        hrResult = GetStringResource(pOEMUIParam->hOEMHeap, 
                                     (HMODULE) pOEMUIParam->hModule, 
                                     IDS_SECTION,
                                     &pOEMUIParam->pOEMOptItems[0].pName);
        if(!SUCCEEDED(hrResult))
        {
            ERR(ERRORTEXT("hrPrinterPropertyPage() failed to get section name. (hrResult = 0x%x)\r\n"),
                          hrResult); 
            goto Exit;
        }

        pOEMUIParam->pOEMOptItems[0].Sel = dwDeviceValue;

        pOEMUIParam->pOEMOptItems[0].pOptType = CreateOptType(pOEMUIParam->hOEMHeap, 2);

        pOEMUIParam->pOEMOptItems[0].pOptType->Type = TVOT_UDARROW;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].IconID = 0;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].lParam = 100;
    }

Exit:

    return hrResult;
}


////////////////////////////////////////////////////////////////////////////////
//
// Adds property page to Document property sheet.
//
HRESULT hrOEMDocumentPropertySheets(PPROPSHEETUI_INFO pPSUIInfo, 
                                    LPARAM lParam, 
                                    CUIHelper &Helper,
                                    CFeatures *pFeatures,
                                    BOOL bHidingStandardUI)
{
    LONG_PTR    lResult;
    HRESULT     hrResult = S_OK;


    VERBOSE(DLLTEXT("OEMDocumentPropertySheets() entry.\r\n"));

    // Validate parameters.
    if( (NULL == pPSUIInfo)
        ||
        (PROPSHEETUI_INFO_VERSION != pPSUIInfo->Version)
      )
    {
        ERR(ERRORTEXT("OEMDocumentPropertySheets() ERROR_INVALID_PARAMETER.\r\n"));

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return  E_FAIL;
    }

    // Do action.
    switch(pPSUIInfo->Reason)
    {
        case PROPSHEETUI_REASON_INIT:
            {
                WORD            wFeatures       = 0;
                WORD            wIndex          = 0;
                DWORD           dwSheets        = 0;
                PCBUSERDATA     pUserData       = NULL;
                POEMUIPSPARAM   pOEMUIParam     = (POEMUIPSPARAM) pPSUIInfo->lParamInit;
                BOOL            bPermission     = ((pOEMUIParam->dwFlags & DPS_NOPERMISSION) == 0);
                HANDLE          hHeap           = pOEMUIParam->hOEMHeap;
                POEMDEV         pOEMDev         = (POEMDEV) pOEMUIParam->pOEMDM;
                COMPROPSHEETUI  Sheet;


                // Make sure that we have the Core Driver Features.
                // Only get features if we are hiding the standard
                // document property sheets.
                if(bHidingStandardUI)
                {
                    pFeatures->Acquire(hHeap, Helper, pOEMUIParam->poemuiobj);
                    wFeatures = pFeatures->GetCount(OEMCUIP_DOCPROP);
                }

                // Init property page.
                memset(&Sheet, 0, sizeof(COMPROPSHEETUI));
                Sheet.cbSize            = sizeof(COMPROPSHEETUI);
                Sheet.Flags             = bPermission ? CPSUIF_UPDATE_PERMISSION : 0;
                Sheet.hInstCaller       = ghInstance;
                Sheet.pHelpFile         = NULL;
                Sheet.pfnCallBack       = OEMDocUICallBack;
                Sheet.pDlgPage          = CPSUI_PDLGPAGE_TREEVIEWONLY;
                Sheet.cOptItem          = wFeatures + 1;
                Sheet.IconID            = IDI_CPSUI_PRINTER;
                Sheet.CallerVersion     = 0x100;
                Sheet.OptItemVersion    = 0x100;

                // Get Caller's name.
                hrResult = GetStringResource(hHeap, ghInstance, IDS_NAME, &Sheet.pCallerName);
                if(!SUCCEEDED(hrResult))
                {
                    ERR(ERRORTEXT("hrOEMDocumentPropertySheets() failed to get caller name. (hrResult = 0x%x)\r\n"),
                                  hrResult); 
                    goto Exit;
                }

                // Get section name.
                hrResult = GetStringResource(hHeap, ghInstance, IDS_SECTION, &Sheet.pOptItemName);
                if(!SUCCEEDED(hrResult))
                {
                    ERR(ERRORTEXT("hrOEMDocumentPropertySheets() failed to get section name. (hrResult = 0x%x)\r\n"),
                                  hrResult); 
                    goto Exit;
                }

                // Init user data.
                pUserData = (PCBUSERDATA) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(CBUSERDATA));
                if(NULL == pUserData)
                {
                    ERR(ERRORTEXT("hrOEMDocumentPropertySheets() failed to allocate user data.\r\n")); 

                    hrResult = E_OUTOFMEMORY;
                    goto Exit;
                }
                pUserData->hComPropSheet        = pPSUIInfo->hComPropSheet;
                pUserData->pfnComPropSheet      = pPSUIInfo->pfnComPropSheet;
                pUserData->pOEMUIParam          = pOEMUIParam;
                pUserData->pHelper              = &Helper;
                pUserData->poemuiobj            = pOEMUIParam->poemuiobj;
                pUserData->bPermission          = bPermission;
                pUserData->bHidingStandardUI    = bHidingStandardUI;
                Sheet.UserData                  = (ULONG_PTR) pUserData;

                // Create OptItems for page.
                Sheet.pOptItem = CreateOptItems(hHeap, Sheet.cOptItem);
                if(NULL == Sheet.pOptItem)
                {
                    ERR(ERRORTEXT("hrOEMDocumentPropertySheets() failed to allocate OPTITEMs.\r\n")); 

                    hrResult = E_OUTOFMEMORY;
                    goto Exit;
                }

                // Add Core Driver features.
                for(wIndex = 0; wIndex < wFeatures; ++wIndex)
                {
                    // Initialize level and basic state for feature.
                    Sheet.pOptItem[wIndex].Level   = 1;
                    Sheet.pOptItem[wIndex].Flags   = OPTIF_COLLAPSE;

                    // Get the OPTITEM for this feature.
                    hrResult = pFeatures->InitOptItem(hHeap, 
                                                      Sheet.pOptItem + wIndex, 
                                                      wIndex, 
                                                      OEMCUIP_DOCPROP);
                    if(!SUCCEEDED(hrResult))
                    {
                        ERR(ERRORTEXT("hrOEMDocumentPropertySheets() failed to get OPTITEM for feature %hs.\r\n"),
                                      pFeatures->GetKeyword(wIndex, OEMCUIP_DOCPROP)); 

                        goto Exit;
                    }
                }

                // Initialize Plug-in OptItems
                Sheet.pOptItem[wIndex].Level   = 1;
                Sheet.pOptItem[wIndex].Flags   = OPTIF_COLLAPSE;
                Sheet.pOptItem[wIndex].Sel     = pOEMDev->dwDriverData;

                // get optitem name.
                hrResult = GetStringResource(hHeap, ghInstance, IDS_SECTION, &Sheet.pOptItem[wIndex].pName);
                if(!SUCCEEDED(hrResult))
                {
                    ERR(ERRORTEXT("hrOEMDocumentPropertySheets() failed to get OptItem %d name. (hrResult = 0x%x)\r\n"),
                                  wIndex,
                                  hrResult); 
                    goto Exit;
                }

                Sheet.pOptItem[wIndex].pOptType = CreateOptType(hHeap, 2);

                Sheet.pOptItem[wIndex].pOptType->Type                  = TVOT_UDARROW;
                Sheet.pOptItem[wIndex].pOptType->pOptParam[1].IconID   = 0;
                Sheet.pOptItem[wIndex].pOptType->pOptParam[1].lParam   = 100;


                // Add property sheets.
                lResult = pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet, CPSFUNC_ADD_PCOMPROPSHEETUI, 
                                                     (LPARAM)&Sheet, (LPARAM)&dwSheets);
            }
            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:
            {
                PPROPSHEETUI_INFO_HEADER    pHeader = (PPROPSHEETUI_INFO_HEADER) lParam;

                pHeader->pTitle = (LPTSTR)PROP_TITLE;
                lResult = TRUE;
            }
            break;

        case PROPSHEETUI_REASON_GET_ICON:
            // No icon
            lResult = 0;
            break;

        case PROPSHEETUI_REASON_SET_RESULT:
            {
                PSETRESULT_INFO pInfo = (PSETRESULT_INFO) lParam;

                lResult = pInfo->Result;
            }
            break;

        case PROPSHEETUI_REASON_DESTROY:
            lResult = TRUE;
            break;
    }


Exit:

    pPSUIInfo->Result = lResult;
    return hrResult;
}


////////////////////////////////////////////////////////////////////////////////
//
// Adds property page to printer property sheet.
//
HRESULT hrOEMDevicePropertySheets(PPROPSHEETUI_INFO pPSUIInfo, 
                                  LPARAM lParam, 
                                  CUIHelper &Helper,
                                  CFeatures *pFeatures,
                                  BOOL bHidingStandardUI)
{
    LONG_PTR    lResult;
    HRESULT     hrResult = S_OK;


    VERBOSE(DLLTEXT("hrOEMDevicePropertySheets(%#x, %#x) entry\r\n"), pPSUIInfo, lParam);

    // Validate parameters.
    if( (NULL == pPSUIInfo)
        ||
        (PROPSHEETUI_INFO_VERSION != pPSUIInfo->Version)
      )
    {
        ERR(ERRORTEXT("hrOEMDevicePropertySheets() ERROR_INVALID_PARAMETER.\r\n"));

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    Dump(pPSUIInfo);

    // Do action.
    switch(pPSUIInfo->Reason)
    {
        case PROPSHEETUI_REASON_INIT:
            {
                PROPSHEETPAGE   Page;

                // If hiding standard UI, then
                // need to add Device Settings page, too.
                if(bHidingStandardUI)
                {
                    POEMUIPSPARAM   pOEMUIParam     = (POEMUIPSPARAM) pPSUIInfo->lParamInit;
                    BOOL            bPermission     = ((pOEMUIParam->dwFlags & DPS_NOPERMISSION) == 0);
                    HANDLE          hHeap           = pOEMUIParam->hOEMHeap;
                    POEMDEV         pOEMDev         = (POEMDEV) pOEMUIParam->pOEMDM;
                    WORD            wFeatures       = 0;
                    WORD            wIndex          = 0;
                    DWORD           dwSheets        = 0;
                    DLGPAGE         DlgPage;
                    PCBUSERDATA     pUserData       = NULL;
                    COMPROPSHEETUI  Sheet;


                    // Make sure that we have the Core Driver Features.
                    pFeatures->Acquire(hHeap, Helper, pOEMUIParam->poemuiobj);
                    wFeatures = pFeatures->GetCount(OEMCUIP_PRNPROP);

                    // Init DlgPage struct for Device Settings replacement page.
                    memset(&DlgPage, 0, sizeof(DLGPAGE));
                    DlgPage.cbSize          = sizeof(DLGPAGE);
                    DlgPage.DlgTemplateID   = DP_STD_TREEVIEWPAGE;

                    // Get Device Settings display name.
                    hrResult = GetStringResource(hHeap, ghInstance, IDS_DEVICE_SETTINGS_NAME, &DlgPage.pTabName);
                    if(!SUCCEEDED(hrResult))
                    {
                        ERR(ERRORTEXT("hrOEMDevicePropertySheets() failed to get Device Settings display name. (hrResult = 0x%x)\r\n"),
                                      hrResult); 
                        goto Exit;
                    }

                    // Init Device Settings replacement page.
                    memset(&Sheet, 0, sizeof(COMPROPSHEETUI));
                    Sheet.cbSize            = sizeof(COMPROPSHEETUI);
                    Sheet.Flags             = bPermission ? CPSUIF_UPDATE_PERMISSION : 0;
                    Sheet.hInstCaller       = ghInstance;
                    Sheet.pHelpFile         = NULL;
                    Sheet.pfnCallBack       = OEMDevUICallBack;
                    Sheet.pDlgPage          = &DlgPage; //CPSUI_PDLGPAGE_TREEVIEWONLY; 
                    Sheet.cOptItem          = wFeatures;
                    Sheet.cDlgPage          = 1;
                    Sheet.IconID            = IDI_CPSUI_PRINTER;
                    Sheet.CallerVersion     = 0x100;
                    Sheet.OptItemVersion    = 0x100;

                    // Get Caller's name.
                    hrResult = GetStringResource(hHeap, ghInstance, IDS_NAME, &Sheet.pCallerName);
                    if(!SUCCEEDED(hrResult))
                    {
                        ERR(ERRORTEXT("hrOEMDevicePropertySheets() failed to get caller name. (hrResult = 0x%x)\r\n"),
                                      hrResult); 
                        goto Exit;
                    }

                    // Get section name.
                    hrResult = GetStringResource(hHeap, ghInstance, IDS_SECTION, &Sheet.pOptItemName);
                    if(!SUCCEEDED(hrResult))
                    {
                        ERR(ERRORTEXT("hrOEMDevicePropertySheets() failed to get section name. (hrResult = 0x%x)\r\n"),
                                      hrResult); 
                        goto Exit;
                    }

                    // Allocate and init User data used in our callback for this page.
                    pUserData = (PCBUSERDATA) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(CBUSERDATA));
                    if(NULL == pUserData)
                    {
                        ERR(ERRORTEXT("hrOEMDevicePropertySheets() failed to allocate user data.\r\n")); 

                        hrResult = E_OUTOFMEMORY;
                        goto Exit;
                    }
                    pUserData->hComPropSheet        = pPSUIInfo->hComPropSheet;
                    pUserData->pfnComPropSheet      = pPSUIInfo->pfnComPropSheet;
                    pUserData->pOEMUIParam          = pOEMUIParam;
                    pUserData->pHelper              = &Helper;
                    pUserData->poemuiobj            = pOEMUIParam->poemuiobj;
                    pUserData->bPermission          = bPermission;
                    pUserData->bHidingStandardUI    = bHidingStandardUI;
                    Sheet.UserData                  = (ULONG_PTR) pUserData;

                    // Create OptItems for page.
                    Sheet.pOptItem = CreateOptItems(hHeap, Sheet.cOptItem);
                    if(NULL == Sheet.pOptItem)
                    {
                        ERR(ERRORTEXT("hrOEMDevicePropertySheets() failed to allocate OPTITEMs.\r\n")); 

                        hrResult = E_OUTOFMEMORY;
                        goto Exit;
                    }

                    // Add Core Driver features.
                    for(wIndex = 0; wIndex < wFeatures; ++wIndex)
                    {
                        // Initialize level and basic state for feature.
                        Sheet.pOptItem[wIndex].Level   = 1;
                        Sheet.pOptItem[wIndex].Flags   = OPTIF_COLLAPSE;

                        // Get the OPTITEM for this feature.
                        hrResult = pFeatures->InitOptItem(hHeap, 
                                                          Sheet.pOptItem + wIndex, 
                                                          wIndex, 
                                                          OEMCUIP_PRNPROP);
                        if(!SUCCEEDED(hrResult))
                        {
                            ERR(ERRORTEXT("hrOEMDevicePropertySheets() failed to get OPTITEM for feature %hs.\r\n"),
                                          pFeatures->GetKeyword(wIndex, OEMCUIP_PRNPROP)); 

                            goto Exit;
                        }
                    }

                    // Add property sheets.
                    lResult = pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet, CPSFUNC_ADD_PCOMPROPSHEETUI, 
                                                         (LPARAM)&Sheet, (LPARAM)&dwSheets);
                    if(!SUCCEEDED(lResult))
                    {
                        ERR(ERRORTEXT("hrOEMDevicePropertySheets() failed to add Device Settings replacement page. (lResult = 0x%x)\r\n"),
                                      lResult); 
                        goto Exit;
                    }
                }

                // Init our property page.
                memset(&Page, 0, sizeof(PROPSHEETPAGE));
                Page.dwSize         = sizeof(PROPSHEETPAGE);
                Page.dwFlags        = PSP_DEFAULT;
                Page.hInstance      = ghInstance;
                Page.pszTemplate    = MAKEINTRESOURCE(IDD_DEVICE_PROPPAGE);
                Page.pfnDlgProc     = (DLGPROC) DevicePropPageProc;

                // Add property sheets.
                lResult = pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet, CPSFUNC_ADD_PROPSHEETPAGE, (LPARAM)&Page, 0);
                if(!SUCCEEDED(lResult))
                {
                    ERR(ERRORTEXT("hrOEMDevicePropertySheets() failed to add our Device Property page. (lResult = 0x%x)\r\n"),
                                  lResult); 
                    goto Exit;
                }

                VERBOSE(DLLTEXT("hrOEMDevicePropertySheets() pfnComPropSheet returned %d.\r\n"), lResult);
            }
            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:
            {
                PPROPSHEETUI_INFO_HEADER    pHeader = (PPROPSHEETUI_INFO_HEADER) lParam;

                pHeader->pTitle = (LPTSTR)PROP_TITLE;
                lResult = TRUE;
            }
            break;

        case PROPSHEETUI_REASON_GET_ICON:
            // No icon
            lResult = 0;
            break;

        case PROPSHEETUI_REASON_SET_RESULT:
            {
                PSETRESULT_INFO pInfo = (PSETRESULT_INFO) lParam;

                lResult = pInfo->Result;
            }
            break;

        case PROPSHEETUI_REASON_DESTROY:
            lResult = TRUE;
            break;
    }


Exit:

    pPSUIInfo->Result = lResult;
    return hrResult;
}


////////////////////////////////////////////////////////////////////////////////
//
// OptItems call back for OEM printer property UI.
//
LONG APIENTRY OEMPrinterUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam)
{
    LONG    lReturn = CPSUICB_ACTION_NONE;
    POEMDEV pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;


    VERBOSE(DLLTEXT("OEMPrinterUICallBack() entry, Reason is %d.\r\n"), pCallbackParam->Reason);

    switch(pCallbackParam->Reason)
    {
        case CPSUICB_REASON_APPLYNOW:
            {
                DWORD   dwDriverValue = pOEMUIParam->pOEMOptItems[0].Sel;

                // Store OptItems state in printer data.
                SetPrinterData(pOEMUIParam->hPrinter, OEMUI_VALUE, REG_DWORD, (PBYTE) &dwDriverValue, sizeof(DWORD));
            }
            break;

        default:
            break;
    }

    return lReturn;
}


////////////////////////////////////////////////////////////////////////////////
//
// Call back for OEM device property UI.
//
BOOL APIENTRY DevicePropPageProc(HWND hDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uiMsg)
    {
        case WM_COMMAND:
            switch(HIWORD(wParam))
            {
                case BN_CLICKED:
                    switch(LOWORD(wParam))
                    {
                        case IDC_CALIBRATE:
                            // Just display a message that the printer is calibrated,
                            // since we don't acutally calibrate anything.
                            {
                                TCHAR   szName[MAX_PATH];
                                TCHAR   szCalibrated[MAX_PATH];


                                LoadString(ghInstance, IDS_NAME, szName, sizeof(szName)/sizeof(szName[0]));
                                LoadString(ghInstance, IDS_CALIBRATED, szCalibrated, sizeof(szCalibrated)/sizeof(szCalibrated[0]));
                                MessageBox(hDlg, szCalibrated, szName, MB_OK);
                            }
                            break;
                    }
                    break;

                default:
                    return FALSE;
            }
            return TRUE;

        case WM_NOTIFY:
            {
                switch (((LPNMHDR)lParam)->code)  // type of notification message
                {
                    case PSN_SETACTIVE:
                        break;
    
                    case PSN_KILLACTIVE:
                        break;

                    case PSN_APPLY:
                        break;

                    case PSN_RESET:
                        break;
                }
            }
            break;
    }

    return FALSE;
} 


////////////////////////////////////////////////////////////////////////////////
//
// OptItems call back for OEM document property UI.
//
LONG APIENTRY OEMDocUIItemCallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam)
{
    LONG    lReturn = CPSUICB_ACTION_NONE;
    POEMDEV pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;


    VERBOSE(DLLTEXT("OEMDocUIItemCallBack() entry, Reason is %d.\r\n"), pCallbackParam->Reason);

    switch(pCallbackParam->Reason)
    {
        case CPSUICB_REASON_APPLYNOW:
            // Store OptItems state in DEVMODE.
            pOEMDev->dwDriverData = pOEMUIParam->pOEMOptItems[0].Sel;
            break;

        case CPSUICB_REASON_KILLACTIVE:
            pOEMDev->dwDriverData = pOEMUIParam->pOEMOptItems[0].Sel;
            break;

        case CPSUICB_REASON_SETACTIVE:
            pOEMUIParam->pOEMOptItems[0].Sel    = pOEMDev->dwDriverData;
            pOEMUIParam->pOEMOptItems[0].Flags |= OPTIF_CHANGED;
            lReturn                             = CPSUICB_ACTION_OPTIF_CHANGED;
            break;

        default:
            break;
    }

    return lReturn;
}


LONG APIENTRY OEMDocUICallBack(PCPSUICBPARAM pCallbackParam)
{
    WORD            wItems      = pCallbackParam->cOptItem;
    LONG            lReturn     = CPSUICB_ACTION_NONE;
    POPTITEM        pOptItem    = pCallbackParam->pOptItem;
    PCBUSERDATA     pUserData   = (PCBUSERDATA) pCallbackParam->UserData;
    HANDLE          hHeap       = pUserData->pOEMUIParam->hOEMHeap;
    POEMDEV         pOEMDev     = (POEMDEV) pUserData->pOEMUIParam->pOEMDM;


    VERBOSE(DLLTEXT("OEMDocUICallBack() entry, Reason is %d.\r\n"), pCallbackParam->Reason);

    //
    // If user has no permission to change anything, then
    // simply return without taking any action.
    //

    if (!pUserData->bPermission && (pCallbackParam->Reason != CPSUICB_REASON_ABOUT))
        return CPSUICB_ACTION_NONE;

    switch(pCallbackParam->Reason)
    {
        case CPSUICB_REASON_APPLYNOW:
            if(wItems > 0)
            {
                // Save feature options if hidig standard UI.
                if(pUserData->bHidingStandardUI)
                {
                    HRESULT hrResult;


                    // Save feature OPTITEMs.
                    hrResult = SaveFeatureOptItems(hHeap, 
                                                   pUserData->pHelper,
                                                   pUserData->poemuiobj,
                                                   pCallbackParam->hDlg,
                                                   pOptItem,
                                                   wItems);
                    if(!SUCCEEDED(hrResult))
                    {
                        // Return that we didn't save changes.
                        // NOTE: it is up to SaveFeatureOptItems() to display
                        //       any UI for failure.
                        return CPSUICB_ACTION_NO_APPLY_EXIT;
                    }
                }

                // Save OPTITEM that we explicitly added.
                pOEMDev->dwDriverData = pOptItem[wItems - 1].Sel;
                pUserData->pfnComPropSheet(pUserData->hComPropSheet, CPSFUNC_SET_RESULT,
            	                           (LPARAM)pUserData->hPropPage,
               	                           (LPARAM)CPSUI_OK);

            }
            break;

        case CPSUICB_REASON_KILLACTIVE:
            if(wItems > 0)
            {
                // Update OPTITEM that we explicitly added.
                pOEMDev->dwDriverData = pOptItem[wItems - 1].Sel;
            }
            break;

        case CPSUICB_REASON_SETACTIVE:
            if(wItems > 0)
            {
                // Update OPTITEM that we explicitly added.
                pOptItem[wItems - 1].Sel     = pOEMDev->dwDriverData;
                pOptItem[wItems - 1].Flags  |= OPTIF_CHANGED;
            }
            lReturn = CPSUICB_ACTION_OPTIF_CHANGED;
            break;

        default:
            break;
    }

    return lReturn;
}

LONG APIENTRY OEMDevUICallBack(PCPSUICBPARAM pCallbackParam)
{
    WORD            wItems      = pCallbackParam->cOptItem;
    LONG            lReturn     = CPSUICB_ACTION_NONE;
    POPTITEM        pOptItem    = pCallbackParam->pOptItem;
    PCBUSERDATA     pUserData   = (PCBUSERDATA) pCallbackParam->UserData;
    HANDLE          hHeap       = pUserData->pOEMUIParam->hOEMHeap;


    VERBOSE(DLLTEXT("OEMDevUICallBack() entry, Reason is %d.\r\n"), pCallbackParam->Reason);

    //
    // If user has no permission to change anything, then
    // simply return without taking any action.
    //

    if (!pUserData->bPermission && (pCallbackParam->Reason != CPSUICB_REASON_ABOUT))
        return CPSUICB_ACTION_NONE;

    switch(pCallbackParam->Reason)
    {
        case CPSUICB_REASON_APPLYNOW:
            if(wItems > 0)
            {
                // Save feature options if hidig standard UI.
                if(pUserData->bHidingStandardUI)
                {
                    HRESULT hrResult;


                    // Save feature OPTITEMs.
                    hrResult = SaveFeatureOptItems(hHeap, 
                                                   pUserData->pHelper,
                                                   pUserData->poemuiobj,
                                                   pCallbackParam->hDlg,
                                                   pOptItem,
                                                   wItems);
                    if(!SUCCEEDED(hrResult))
                    {
                        // Return that we didn't save changes.
                        // NOTE: it is up to SaveFeatureOptItems() to display
                        //       any UI for failure.
                        return CPSUICB_ACTION_NO_APPLY_EXIT;
                    }
                }

                
                pUserData->pfnComPropSheet(pUserData->hComPropSheet, CPSFUNC_SET_RESULT,
            	                           (LPARAM)pUserData->hPropPage,
               	                           (LPARAM)CPSUI_OK);
            }
            break;

        case CPSUICB_REASON_KILLACTIVE:
            break;

        case CPSUICB_REASON_SETACTIVE:
            break;

        default:
            break;
    }

    return lReturn;
}



////////////////////////////////////////////////////////////////////////////////
//
// Creates and Initializes OptItems.
//
POPTITEM CreateOptItems(HANDLE hHeap, DWORD dwOptItems)
{
    POPTITEM    pOptItems = NULL;


    // Allocate memory for OptItems;
    pOptItems = (POPTITEM) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(OPTITEM) * dwOptItems);
    if(NULL != pOptItems)
    {
        InitOptItems(pOptItems, dwOptItems);
    }
    else
    {
        ERR(ERRORTEXT("CreateOptItems() failed to allocate memory for OPTITEMs!\r\n"));
    }

    return pOptItems;
}


////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems.
//
static void InitOptItems(POPTITEM pOptItems, DWORD dwOptItems)
{
    VERBOSE(DLLTEXT("InitOptItems() entry.\r\n"));

    // Zero out memory.
    memset(pOptItems, 0, sizeof(OPTITEM) * dwOptItems);

    // Set each OptItem's size, and Public DM ID.
    for(DWORD dwCount = 0; dwCount < dwOptItems; dwCount++)
    {
        pOptItems[dwCount].cbSize = sizeof(OPTITEM);
        pOptItems[dwCount].DMPubID = DMPUB_NONE;
    }
}


////////////////////////////////////////////////////////////////////////////////
//
// Allocates and initializes OptType for OptItem.
//
POPTTYPE CreateOptType(HANDLE hHeap, WORD wOptParams)
{
    POPTTYPE    pOptType = NULL;


    VERBOSE(DLLTEXT("CreateOptType() entry.\r\n"));

    // Allocate memory from the heap for the OPTTYPE; the driver will take care of clean up.
    pOptType = (POPTTYPE) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(OPTTYPE));
    if(NULL != pOptType)
    {
        // Initialize OPTTYPE.
        pOptType->cbSize = sizeof(OPTTYPE);
        pOptType->Count = wOptParams;

        // Allocate memory from the heap for the OPTPARAMs for the OPTTYPE.
        pOptType->pOptParam = (POPTPARAM) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, wOptParams * sizeof(OPTPARAM));
        if(NULL != pOptType->pOptParam)
        {
            // Initialize the OPTPARAMs.
            for(WORD wCount = 0; wCount < wOptParams; wCount++)
            {
                pOptType->pOptParam[wCount].cbSize = sizeof(OPTPARAM);
            }
        }
        else
        {
            ERR(ERRORTEXT("CreateOptType() failed to allocated memory for OPTPARAMs!\r\n"));

            // Free allocated memory and return NULL.
            HeapFree(hHeap, 0, pOptType);
            pOptType = NULL;
        }
    }
    else
    {
        ERR(ERRORTEXT("CreateOptType() failed to allocated memory for OPTTYPE!\r\n"));
    }

    return pOptType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\syncset\globals.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Globals.cpp
//    
//
//  PURPOSE:  File that contains all the globals.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows NT
//
//
#define _GLOBALS_H

#include "precomp.h"
#include "oemui.h"



///////////////////////////////////////
//          Globals
///////////////////////////////////////

// Module's Instance handle from DLLEntry of process.
HINSTANCE   ghInstance = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\syncset\globals.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Globals.h
//    
//
//  PURPOSE:   Lists of globals declared in Globals.cpp.
//
//
//  PLATFORMS:
//
//    Windows NT
//
//
#ifndef _GLOBALS_H
#define _GLOBALS_H


///////////////////////////////////////
//          Globals
///////////////////////////////////////

// Module's Instance handle from DLLEntry of process.
extern HINSTANCE   ghInstance;




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\syncset\oem.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997, 1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debug.cpp.
//
//  PLATFORMS:
//    Windows NT
//
//
#ifndef _OEM_H
#define _OEM_H



////////////////////////////////////////////////////////
//      OEM Defines
////////////////////////////////////////////////////////

#define OEM_SIGNATURE   'MSFT'
#define OEM_VERSION     0x00000001L



////////////////////////////////////////////////////////
//      OEM Type Definitions
////////////////////////////////////////////////////////



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\psuirep\stringutils.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  2001  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	StringUtils.h
//    
//
//  PURPOSE:  Header file for string utility routines.
//
//
//  PLATFORMS:
//    Windows 2000, Windows XP
//
//
#ifndef _STRINGUTILS_H
#define _STRINGUTILS_H

#include "precomp.h"




////////////////////////////////////////////////////////
//      Prototypes
////////////////////////////////////////////////////////

HRESULT MakeStrPtrList(HANDLE hHeap, PCSTR pmszMultiSz, PCSTR **pppszList, PWORD pwCount);
WORD mstrcount(PCSTR pmszMultiSz);
PWSTR MakeUnicodeString(HANDLE hHeap, PCSTR pszAnsi);
PWSTR MakeStringCopy(HANDLE hHeap, PCWSTR pszSource);
PSTR MakeStringCopy(HANDLE hHeap, PCSTR pszSource);
void FreeStringList(HANDLE hHeap, PWSTR *ppszList, WORD wCount);
HRESULT GetStringResource(HANDLE hHeap, HMODULE hModule, UINT uResource, PWSTR *ppszString);
HRESULT GetStringResource(HANDLE hHeap, HMODULE hModule, UINT uResource, PSTR *ppszString);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\syncset\precomp.h ===
//    
//
//  PURPOSE:	Header files that should be in the precompiled header.

//
//  PLATFORMS:
//    Windows NT
//
//
#ifndef _PRECOMP_H
#define _PRECOMP_H


// Necessary for compiling under VC.
#if(!defined(WINVER) || (WINVER < 0x0500))
	#undef WINVER
	#define WINVER          0x0500
#endif
#if(!defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500))
	#undef _WIN32_WINNT
	#define _WIN32_WINNT    0x0500
#endif


// Required header files that shouldn't change often.


#include <STDDEF.H>
#include <STDLIB.H>
#include <OBJBASE.H>
#include <STDARG.H>
#include <STDIO.H>
#include <WINDEF.H>
#include <WINERROR.H>
#include <WINBASE.H>
#include <WINGDI.H>
#include <WINDDI.H>
#include <WINSPOOL.H>
#include <TCHAR.H>
#include <EXCPT.H>
#include <ASSERT.H>
#include <PRSHT.H>
#include <COMPSTUI.H>
#include <WINDDIUI.H>
#include <PRINTOEM.H>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\syncset\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by customui.rc
//
#define IDS_SECTION                     1
#define IDS_CALIBRATED                  2
#define IDS_NAME                        3
#define IDS_HELPFILE                    4
#define IDD_DEVICE_PROPPAGE             106
#define IDD_DOC_PROPPAGE                107
#define IDC_CALIBRATE                   1001
#define IDC_RADIO3                      1004
#define IDC_CHECK_DUPLPEX               1008
#define IDC_CHECK_HDRIVE                1009
#define IDC_CHECK_ENVFEEDER             1010

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1011
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\syncset\devmode.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Devmode.cpp
//    
//
//  PURPOSE:  Implementation of Devmode functions shared with OEM UI and OEM rendering modules.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows NT
//
//

#include "precomp.h"
#include "oemui.h"
#include "debug.h"
#include "devmode.h"

//
//Performs operation on UI Plugins Private DevMode Members.
//Called via IOemUI::DevMode
//

HRESULT hrOEMDevMode(DWORD dwMode, POEMDMPARAM pOemDMParam)
{
    POEMDEV pOEMDevIn;
    POEMDEV pOEMDevOut;


    // Verify parameters.
    if( (NULL == pOemDMParam)
        ||
        ( (OEMDM_SIZE != dwMode)
          &&
          (OEMDM_DEFAULT != dwMode)
          &&
          (OEMDM_CONVERT != dwMode)
          &&
          (OEMDM_MERGE != dwMode)
        )
      )
    {
        ERR(ERRORTEXT("DevMode() ERROR_INVALID_PARAMETER.\r\n"));
        VERBOSE(DLLTEXT("\tdwMode = %d, pOemDMParam = %#lx.\r\n"), dwMode, pOemDMParam);

        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    // Cast generic (i.e. PVOID) to OEM private devomode pointer type.
    pOEMDevIn = (POEMDEV) pOemDMParam->pOEMDMIn;
    pOEMDevOut = (POEMDEV) pOemDMParam->pOEMDMOut;

    switch(dwMode)
    {
		//
		//The Method should return the size of the memory allocation needed to store the UI plugin Private DEVMODE.
		//
        case OEMDM_SIZE:
            pOemDMParam->cbBufSize = sizeof(OEMDEV);
            break;

		//
		//Should fill the Private DEVMODE with the default values.
		//
        case OEMDM_DEFAULT:
            VERBOSE(DLLTEXT("pOEMDevOut before setting default values:\r\n"));
            //Dump(pOEMDevOut);
			
			//
			//OEM_DMEXTRAHEADER Members
			//
            pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
            pOEMDevOut->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
            pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;

			//
			//Private members
			//
            pOEMDevOut->dwDriverData            = 0;
            break;
			
		//
		//The method should convert private DEVMODE members to the current version, if necessary.
		//
        case OEMDM_CONVERT:
            ConvertOEMDevmode(pOEMDevIn, pOEMDevOut);
            break;
		
		//
		//The method should validate the information contained in private DEVMODE members and merge validated values into a private DEVMODE structure containing default values
		//
        case OEMDM_MERGE:
            ConvertOEMDevmode(pOEMDevIn, pOEMDevOut);
            MakeOEMDevmodeValid(pOEMDevOut);
            break;
    }
    Dump(pOemDMParam);

    return S_OK;
}


BOOL ConvertOEMDevmode(PCOEMDEV pOEMDevIn, POEMDEV pOEMDevOut)
{
    if( (NULL == pOEMDevIn)
        ||
        (NULL == pOEMDevOut)
      )
    {
        ERR(ERRORTEXT("ConvertOEMDevmode() invalid parameters.\r\n"));
        return FALSE;
    }

    // Check OEM Signature, if it doesn't match ours,
    // then just assume DMIn is bad and use defaults.
    if(pOEMDevIn->dmOEMExtra.dwSignature == pOEMDevOut->dmOEMExtra.dwSignature)
    {
        VERBOSE(DLLTEXT("Converting private OEM Devmode.\r\n"));
        VERBOSE(DLLTEXT("pOEMDevIn:\r\n"));
        Dump(pOEMDevIn);

        // Set the devmode defaults so that anything the isn't copied over will
        // be set to the default value.
        pOEMDevOut->dwDriverData = 0;

        // Copy the old structure in to the new using which ever size is the smaller.
        // Devmode maybe from newer Devmode (not likely since there is only one), or
        // Devmode maybe a newer Devmode, in which case it maybe larger,
        // but the first part of the structure should be the same.

        // DESIGN ASSUMPTION: the private DEVMODE structure only gets added to;
        // the fields that are in the DEVMODE never change only new fields get added to the end.

        memcpy(pOEMDevOut, pOEMDevIn, __min(pOEMDevOut->dmOEMExtra.dwSize, pOEMDevIn->dmOEMExtra.dwSize));

        // Re-fill in the size and version fields to indicated 
        // that the DEVMODE is the current private DEVMODE version.
        pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
        pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
    }
    else
    {
        WARNING(DLLTEXT("Unknown DEVMODE signature, pOEMDMIn ignored.\r\n"));

        // Don't know what the input DEVMODE is, so just use defaults.
        pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
        pOEMDevOut->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
        pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
        pOEMDevOut->dwDriverData            = 0;
    }

    return TRUE;
}


BOOL MakeOEMDevmodeValid(POEMDEV pOEMDevmode)
{
    if(NULL == pOEMDevmode)
    {
        return FALSE;
    }

    // ASSUMPTION: pOEMDevmode is large enough to contain OEMDEV structure.

    // Make sure that dmOEMExtra indicates the current OEMDEV structure.
    pOEMDevmode->dmOEMExtra.dwSize       = sizeof(OEMDEV);
    pOEMDevmode->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
    pOEMDevmode->dmOEMExtra.dwVersion    = OEM_VERSION;

    // Set driver data, if not valid.
    if(pOEMDevmode->dwDriverData > 100)
    {
        pOEMDevmode->dwDriverData = 0;
    }

    return TRUE;
}


void Dump(PCOEMDEV pOEMDevmode)
{
    if( (NULL != pOEMDevmode)
        &&
        (pOEMDevmode->dmOEMExtra.dwSize >= sizeof(OEMDEV))
        &&
        (OEM_SIGNATURE == pOEMDevmode->dmOEMExtra.dwSignature)
      )
    {
        VERBOSE(__TEXT("\tdmOEMExtra.dwSize      = %d\r\n"), pOEMDevmode->dmOEMExtra.dwSize);
        VERBOSE(__TEXT("\tdmOEMExtra.dwSignature = %#x\r\n"), pOEMDevmode->dmOEMExtra.dwSignature);
        VERBOSE(__TEXT("\tdmOEMExtra.dwVersion   = %#x\r\n"), pOEMDevmode->dmOEMExtra.dwVersion);
        VERBOSE(__TEXT("\tdwDriverData           = %#x\r\n"), pOEMDevmode->dwDriverData);
    }
    else
    {
        ERR(ERRORTEXT("Dump(POEMDEV) unknown private OEM DEVMODE.\r\n"));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\themeui\debug.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 2001  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.cpp
//    
//
//  PURPOSE:  Debug functions.
//
//
//	Functions:
//
//
//
//  PLATFORMS:	Windows 2000, Windows XP
//
//

#include "precomp.h"
#include "oem.h"
#include "debug.h"



////////////////////////////////////////////////////////
//      INTERNAL DEFINES
////////////////////////////////////////////////////////

#define DEBUG_BUFFER_SIZE       1024
#define PATH_SEPARATOR          '\\'



// Determine what level of debugging messages to eject. 
#ifdef VERBOSE_MSG
    #define DEBUG_LEVEL     DBG_VERBOSE
#elif TERSE_MSG
    #define DEBUG_LEVEL     DBG_TERSE
#elif WARNING_MSG
    #define DEBUG_LEVEL     DBG_WARNING
#elif ERROR_MSG
    #define DEBUG_LEVEL     DBG_ERROR
#elif RIP_MSG
    #define DEBUG_LEVEL     DBG_RIP
#elif NO_DBG_MSG
    #define DEBUG_LEVEL     DBG_NONE
#else
    #define DEBUG_LEVEL     DBG_WARNING
#endif



////////////////////////////////////////////////////////
//      EXTERNAL GLOBALS
////////////////////////////////////////////////////////

INT giDebugLevel = DEBUG_LEVEL;




////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist);
static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist);




//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist)
{
    DWORD   dwSize = DEBUG_BUFFER_SIZE;
    LPSTR   lpszMsgBuf = NULL;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    do
    {
        // Allocate memory for message buffer.
        if(NULL != lpszMsgBuf)
        {
            delete[] lpszMsgBuf;
            dwSize *= 2;
        }
        lpszMsgBuf = new CHAR[dwSize + 1];
        if(NULL == lpszMsgBuf)
            return FALSE;

    // Pass the variable parameters to wvsprintf to be formated.
    } while (_vsnprintf(lpszMsgBuf, dwSize, lpszMessage, arglist) < 0);

    // Dump string to Debug output.
    OutputDebugStringA(lpszMsgBuf);

    // Cleanup.
    delete[] lpszMsgBuf;

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist)
{
    LPWSTR     lpszMsgBuf;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    // Allocate memory for message buffer.
    lpszMsgBuf = new WCHAR[dwSize + 1];    
    if(NULL == lpszMsgBuf)
        return FALSE;

    // Pass the variable parameters to wvsprintf to be formated.
    vswprintf(lpszMsgBuf, lpszMessage, arglist);

    // Dump string to debug output.
    OutputDebugStringW(lpszMsgBuf);

    // Clean up.
    delete[] lpszMsgBuf;

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV for processing.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCWSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV to be processed.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(MAX_PATH, lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}

void Dump(PPUBLISHERINFO pPublisherInfo)
{
    VERBOSE(__TEXT("pPublisherInfo:\r\n"));
    VERBOSE(__TEXT("\tdwMode           =   %#x\r\n"), pPublisherInfo->dwMode);
    VERBOSE(__TEXT("\twMinoutlinePPEM  =   %d\r\n"), pPublisherInfo->wMinoutlinePPEM);
    VERBOSE(__TEXT("\twMaxbitmapPPEM   =   %d\r\n"), pPublisherInfo->wMaxbitmapPPEM);
}

void Dump(POEMDMPARAM pOemDMParam)
{
    VERBOSE(__TEXT("pOemDMParam:\r\n"));
    VERBOSE(__TEXT("\tcbSize = %d\r\n"), pOemDMParam->cbSize);
    VERBOSE(__TEXT("\tpdriverobj = %#x\r\n"), pOemDMParam->pdriverobj);
    VERBOSE(__TEXT("\thPrinter = %#x\r\n"), pOemDMParam->hPrinter);
    VERBOSE(__TEXT("\thModule = %#x\r\n"), pOemDMParam->hModule);
    VERBOSE(__TEXT("\tpPublicDMIn = %#x\r\n"), pOemDMParam->pPublicDMIn);
    VERBOSE(__TEXT("\tpPublicDMOut = %#x\r\n"), pOemDMParam->pPublicDMOut);
    VERBOSE(__TEXT("\tpOEMDMIn = %#x\r\n"), pOemDMParam->pOEMDMIn);
    VERBOSE(__TEXT("\tpOEMDMOut = %#x\r\n"), pOemDMParam->pOEMDMOut);
    VERBOSE(__TEXT("\tcbBufSize = %d\r\n"), pOemDMParam->cbBufSize);
}

void Dump(PPROPSHEETUI_INFO pPSUIInfo)
{
    VERBOSE(__TEXT("pPSUIInfo:\r\n"));
    VERBOSE(__TEXT("\tcbSize          = %d\r\n"), pPSUIInfo->cbSize);
    VERBOSE(__TEXT("\tVersion         = %#x\r\n"), pPSUIInfo->Version);
    VERBOSE(__TEXT("\tFlags           = %#x\r\n"), pPSUIInfo->Flags);
    VERBOSE(__TEXT("\tReason          = %d\r\n"), pPSUIInfo->Reason);
    VERBOSE(__TEXT("\thComPropSheet   = %#x\r\n"), pPSUIInfo->hComPropSheet);
    VERBOSE(__TEXT("\tpfnComPropSheet = %#x\r\n"), pPSUIInfo->pfnComPropSheet);
    VERBOSE(__TEXT("\tlParamInit      = %#x\r\n"), pPSUIInfo->lParamInit);
    VERBOSE(__TEXT("\tUserData        = %#x\r\n"), pPSUIInfo->UserData);
    VERBOSE(__TEXT("\tResult          = %#x\r\n"), pPSUIInfo->Result);
}



PCSTR
StripDirPrefixA(
    IN PCSTR    pstrFilename
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    PCSTR   pstr;

    if (pstr = strrchr(pstrFilename, PATH_SEPARATOR))
        return pstr + 1;

    return pstrFilename;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\syncset\intrface.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

#include "precomp.h"
#include <INITGUID.H>
#include <PRCOMOEM.H>

#include "oemui.h"
#include "debug.h"
#include "intrface.h"



////////////////////////////////////////////////////////
//      Internal Globals
////////////////////////////////////////////////////////

static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks



////////////////////////////////////////////////////////////////////////////////
//
// IOemUI body
//
IOemUI::~IOemUI()
{
    // Make sure that helper interface is released.
    if(NULL != m_pOEMHelp)
    {
        m_pOEMHelp->Release();
        m_pOEMHelp = NULL;
    }

    // If this instance of the object is being deleted, then the reference 
    // count should be zero.
    assert(0 == m_cRef);
}

HRESULT __stdcall IOemUI::QueryInterface(const IID& iid, void** ppv)
{    
    VERBOSE(DLLTEXT("IOemUI:QueryInterface entry.\r\n\r\n")); 
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        VERBOSE(DLLTEXT("IOemUI:Return pointer to IUnknown.\r\n\r\n")); 
    }
    else if (iid == IID_IPrintOemUI)
    {
        *ppv = static_cast<IPrintOemUI*>(this) ;
        VERBOSE(DLLTEXT("IOemUI:Return pointer to IPrintOemUI.\r\n")); 
    }
    else
    {
        *ppv = NULL ;
        WARNING(DLLTEXT("IOemUI:No Interface. Return NULL.\r\n")); 
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemUI::AddRef()
{
    VERBOSE(DLLTEXT("IOemUI:AddRef entry.\r\n")); 
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemUI::Release() 
{
    VERBOSE(DLLTEXT("IOemUI:Release entry.\r\n")); 
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

//
//(Implamentation is required) Supplies a pointer to UNIDRIVE /PScript IPrintOemDriverUI
//
HRESULT __stdcall IOemUI::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE(DLLTEXT("IOemUI:PublishDriverInterface entry.\r\n")); 

    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (m_pOEMHelp == NULL)
    {
        HRESULT hResult;


        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUI, (void** ) &(m_pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            m_pOEMHelp = NULL;

            return E_FAIL;
        }
    }

    return S_OK;
}

//
//(Implamentation is required) Returns the UI Plugin's identification information
//
HRESULT __stdcall IOemUI::GetInfo(
    DWORD  dwMode,
    PVOID  pBuffer,
    DWORD  cbSize,
    PDWORD pcbNeeded)
{
    VERBOSE(DLLTEXT("IOemUI::GetInfo(%d) entry.\r\r\n"), dwMode);

    // Validate parameters.
    if( (NULL == pcbNeeded)
        ||
        ( (OEMGI_GETSIGNATURE != dwMode)
          &&
          (OEMGI_GETVERSION != dwMode)
          &&
          (OEMGI_GETPUBLISHERINFO != dwMode)
        )
      )
    {
        WARNING(DLLTEXT("IOemUI::GetInfo() exit pcbNeeded is NULL! ERROR_INVALID_PARAMETER\r\r\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    // Set expected buffer size and number of bytes written.
    *pcbNeeded = sizeof(DWORD);

    // Check buffer size is sufficient.
    if((cbSize < *pcbNeeded) || (NULL == pBuffer))
    {
        WARNING(DLLTEXT("IOemUI::GetInfo() exit insufficient buffer!\r\r\n"));
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return E_FAIL;
    }

    switch(dwMode)
    {
        // OEM DLL Signature
        case OEMGI_GETSIGNATURE:
            *(PDWORD)pBuffer = OEM_SIGNATURE;
            break;

        // OEM DLL version
        case OEMGI_GETVERSION:
            *(PDWORD)pBuffer = OEM_VERSION;
            break;

        // dwMode not supported.
        default:
            // Set written bytes to zero since nothing was written.
            WARNING(DLLTEXT("IOemUI::GetInfo() exit mode not supported.\r\r\n"));
            *pcbNeeded = 0;
            SetLastError(ERROR_NOT_SUPPORTED);
            return E_FAIL;
    }

    VERBOSE(DLLTEXT("IOemUI::GetInfo() exit S_OK, (*pBuffer is %#x).\r\r\n"), *(PDWORD)pBuffer);
    return S_OK;
}


//
//Performs operation on UI Plugins Private DevMode Members.
//
HRESULT __stdcall IOemUI::DevMode(
    DWORD  dwMode,
    POEMDMPARAM pOemDMParam)
{   
    VERBOSE(DLLTEXT("IOemUI:DevMode(%d, %#x) entry.\r\n"), dwMode, pOemDMParam); 

    return hrOEMDevMode(dwMode, pOemDMParam);
}


//
//Allows UI Plugin to Modifiy Existing printer porp sheet and document property sheet page..
//
HRESULT __stdcall IOemUI::CommonUIProp(
    DWORD  dwMode,
    POEMCUIPPARAM   pOemCUIPParam)
{
    VERBOSE(DLLTEXT("IOemUI:CommonUIProp entry.\r\n"));

	//
	//We want to keep this pointer so the we can modifie the data and OPTITEMS from the OEM plugin page.
	//
	m_OemSheetData.pOEMCUIParam = pOemCUIPParam;
	return hrOEMPropertyPage(dwMode, pOemCUIPParam);
}


//
//Adds a New page to the device Documment property sheet.
//

HRESULT __stdcall IOemUI::DocumentPropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam)
{
    VERBOSE(DLLTEXT("IOemUI:DocumentPropertySheets entry.\r\n")); 

    return hrOEMDocumentPropertySheets(pPSUIInfo, lParam, m_pOEMHelp);
}

//
//Adds a New page to the device printer property page.
//
HRESULT __stdcall IOemUI::DevicePropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam)
{
    VERBOSE(DLLTEXT("IOemUI:DevicePropertySheets entry.\r\n")); 

	//
	//Store the This pointer in the OEMSHEETDATA
	//
	m_OemSheetData.pOEMHelp = m_pOEMHelp;
    return hrOEMDevicePropertySheets(pPSUIInfo, lParam, &(m_OemSheetData));
}


//
//Allows the UI plugin to spec Customized device capabilaties (TODO)
//
HRESULT __stdcall IOemUI::DeviceCapabilities(
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult)
{
    VERBOSE(DLLTEXT("IOemUI:DeviceCapabilities entry.\r\n"));
	
    return E_NOTIMPL;
}


//
//Allows the UI plugin to help determine if a print Job is printable.
//
HRESULT __stdcall IOemUI::DevQueryPrintEx(
    POEMUIOBJ               poemuiobj,
    PDEVQUERYPRINT_INFO     pDQPInfo,
    PDEVMODE                pPublicDM,
    PVOID                   pOEMDM)
{
    VERBOSE(DLLTEXT("IOemUI:DevQueryPrintEx entry.\r\n"));

    return E_NOTIMPL;
}


//
//Allows the UI Plugin to upgrade its dev options stored in the registry.
//
HRESULT __stdcall IOemUI::UpgradePrinter(
    DWORD   dwLevel,
    PBYTE   pDriverUpgradeInfo)
{
    VERBOSE(DLLTEXT("IOemUI:UpgradePrinter entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUI::PrinterEvent(
    PWSTR   pPrinterName,
    INT     iDriverEvent,
    DWORD   dwFlags,
    LPARAM  lParam)
{
    VERBOSE(DLLTEXT("IOemUI:PrinterEvent entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUI::DriverEvent(
    DWORD   dwDriverEvent,
    DWORD   dwLevel,
    LPBYTE  pDriverInfo,
    LPARAM  lParam)
{
    VERBOSE(DLLTEXT("IOemUI:DriverEvent entry.\r\n"));

    return E_NOTIMPL;
};


#define PROFILE_NAME    L"OEMPROFILE.icm\0"

HRESULT __stdcall IOemUI::QueryColorProfile(
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulQueryMode,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData)
{
    HRESULT Result = E_FAIL;


    VERBOSE(DLLTEXT("IOemUI:QueryColorProfile entry.\r\n"));


    if(QCP_DEVICEPROFILE == ulQueryMode)
    {
        if(NULL == pvProfileData)
        {
            *pcbProfileData = sizeof(PROFILE_NAME);
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }
        else
        {
            if(*pcbProfileData < sizeof(PROFILE_NAME))
            {
                *pcbProfileData = sizeof(PROFILE_NAME);
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
            }
            else
            {
                lstrcpynW((LPWSTR)pvProfileData, PROFILE_NAME, *pcbProfileData);
                *pcbProfileData = sizeof(PROFILE_NAME);
                *pflProfileData = QCP_PROFILEDISK;

                Result = S_OK;
            }
        }
    }

    return Result;
};

HRESULT __stdcall IOemUI::FontInstallerDlgProc(
        HWND    hWnd,
        UINT    usMsg,
        WPARAM  wParam,
        LPARAM  lParam) 
{
    VERBOSE(DLLTEXT("IOemUI:FontInstallerDlgProc entry.\r\n"));

    return E_NOTIMPL;
};

HRESULT __stdcall IOemUI::UpdateExternalFonts(
        HANDLE  hPrinter,
        HANDLE  hHeap,
        PWSTR   pwstrCartridges)
{
    VERBOSE(DLLTEXT("IOemUI:UpdateExternalFonts entry.\r\n"));

    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// oem class factory
//
class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this) ;
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCF::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    //DbgPrint(DLLTEXT("Class factory:\t\tCreate component.")) ;

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IOemUI* pOemCB = new IOemUI ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }
    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv) ;

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release() ;
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks) ;
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks) ;
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Exported functions
//


// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    VERBOSE(DLLTEXT("DllGetClassObject:Create class factory.\r\n"));

    // Can we create this component?
    if (clsid != CLSID_OEMUI)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv) ;
    pFontCF->Release() ;

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\themeui\debug.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 2001  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debugging functions.
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP
//
//
#ifndef _DEBUG_H
#define _DEBUG_H


// VC and Build use different debug defines.
// The following makes it so either will
// cause the inclusion of debugging code.
#if !defined(_DEBUG) && defined(DBG)
    #define _DEBUG      DBG
#elif defined(_DEBUG) && !defined(DBG)
    #define DBG         _DEBUG
#endif



/////////////////////////////////////////////////////////
//		Macros
/////////////////////////////////////////////////////////

//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// giDebugLevel
//  Global variable which set the current debug level to control
//  the amount of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ERR(msg)
//  Similiar to WARNING macro above - displays a message
//  if the current debug level is <= DBG_ERROR.
//
// ASSERT(cond)
//  Verify a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//  These macros require extra parantheses for the msg argument
//  example, ASSERTMSG(x > 0, ("x is less than 0\n"));
//           WARNING(("App passed NULL pointer, ignoring...\n"));
//

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_ERROR   4
#define DBG_RIP     5
#define DBG_NONE    6

#if DBG

    #define DebugMsg    DebugMessage

    //
    // Strip the directory prefix from a filename (ANSI version)
    //

    PCSTR
    StripDirPrefixA(
        IN PCSTR    pstrFilename
        );

    extern INT giDebugLevel;


    #define DBGMSG(level, prefix, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg("%s %s (%d): ", prefix, StripDirPrefixA(__FILE__), __LINE__); \
                    DebugMsg(msg); \
                } \
            }

    #define DBGPRINT(level, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg(msg); \
                } \
            }

    #define VERBOSE         if(giDebugLevel <= DBG_VERBOSE) DebugMsg
    #define TERSE           if(giDebugLevel <= DBG_TERSE) DebugMsg
    #define WARNING         if(giDebugLevel <= DBG_WARNING) DebugMsg
    #define ERR             if(giDebugLevel <= DBG_ERROR) DebugMsg

    #define ASSERT(cond) { \
                if (! (cond)) { \
                    RIP(("\n")); \
                } \
            }

    #define ASSERTMSG(cond, msg) { \
                if (! (cond)) { \
                    RIP(msg); \
                } \
            }

    #define RIP(msg) { \
                DBGMSG(DBG_RIP, "RIP", msg); \
                DebugBreak(); \
            }


#else // !DBG

    #define DebugMsg    NOP_FUNCTION

    #define VERBOSE     NOP_FUNCTION
    #define TERSE       NOP_FUNCTION
    #define WARNING     NOP_FUNCTION
    #define ERR         NOP_FUNCTION

    #define ASSERT(cond)

    #define ASSERTMSG(cond, msg)
    #define RIP(msg)
    #define DBGMSG(level, prefix, msg)
    #define DBGPRINT(level, msg)

#endif




/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR, ...);
BOOL DebugMessage(LPCWSTR, ...);
void Dump(PPUBLISHERINFO pPublisherInfo);
void Dump(POEMDMPARAM pOemDMParam);
void Dump(PPROPSHEETUI_INFO pPSUIInfo);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\syncset\oemui.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    OEMUI.cpp
//    
//
//  PURPOSE:  Main file for OEM UI test module.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 95, Windows NT
//
//

#include "precomp.h"
#include "resource.h"
#include "debug.h"
#include "oemui.h"



////////////////////////////////////////////////////////
//      INTERNAL MACROS and DEFINES
////////////////////////////////////////////////////////

typedef struct _tagCBUserData 
{
    HANDLE          hComPropSheet;
    HANDLE          hPropPage;
    POEMUIPSPARAM   pOEMUIParam;
    PFNCOMPROPSHEET pfnComPropSheet;

} CBUSERDATA, *PCBUSERDATA;


////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static HRESULT hrDocumentPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam);
static HRESULT hrPrinterPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam);

LONG APIENTRY OEMPrinterUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam);
LONG APIENTRY OEMDocUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam);
LONG APIENTRY OEMDocUICallBack(PCPSUICBPARAM pCallbackParam);
BOOL APIENTRY DevicePropPageProc(HWND hDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);

void SetOEMUiState (HWND hDlg, POEMSHEETDATA pOEMSheetData);
void SetOEMCommonDataIntoOptItem (POEMSHEETDATA pOEMSheetData, PSTR PName, LONG Sel);
void ChangeOpItem (IPrintOemDriverUI *pIPrintOEMDrvUI,  POEMUIOBJ pOEMObj, POPTITEM pOptItem, int iSel);
POPTITEM FindDrvOptItem (POPTITEM pDrvOptItems, DWORD dwItemCount, PSTR pKeyWordName, BYTE dmPubID = DMPUB_NONE);

static POPTITEM CreateOptItems(HANDLE hHeap, DWORD dwOptItems);
static void InitOptItems(POPTITEM pOptItems, DWORD dwOptItems);
static POPTTYPE CreateOptType(HANDLE hHeap, WORD wOptParams);
static PTSTR GetStringResource(HANDLE hHeap, HANDLE hModule, UINT uResource);

////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems to display OEM device or document property UI.
// Called via IOemUI::CommonUIProp
//
HRESULT hrOEMPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
    HRESULT hResult = S_OK;


    VERBOSE(DLLTEXT("hrOEMPropertyPage(%d) entry.\r\n"), dwMode);

    // Validate parameters.
    if( (OEMCUIP_DOCPROP != dwMode)
        &&
        (OEMCUIP_PRNPROP != dwMode)        
      )
    {
        ERR(ERRORTEXT("hrOEMPropertyPage() ERROR_INVALID_PARAMETER.\r\n"));
        VERBOSE(DLLTEXT("\tdwMode = %d, pOEMUIParam = %#lx.\r\n"), dwMode, pOEMUIParam);

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    switch(dwMode)
    {
        case OEMCUIP_DOCPROP:
            hResult = hrDocumentPropertyPage(dwMode, pOEMUIParam);
            break;

        case OEMCUIP_PRNPROP:
            hResult = hrPrinterPropertyPage(dwMode, pOEMUIParam);
            break;

        default:
            // Should never reach this!
            ERR(ERRORTEXT("hrOEMPropertyPage() Invalid dwMode, %d"), dwMode);
            SetLastError(ERROR_INVALID_PARAMETER);
            hResult = E_FAIL;
            break;
    }

    return hResult;
}

////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems to display OEM document property UI.
//
static HRESULT hrDocumentPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
    if(NULL == pOEMUIParam->pOEMOptItems)
    {
        // Fill in the number of OptItems to create for OEM document property UI.
        pOEMUIParam->cOEMOptItems = 1;
        VERBOSE(DLLTEXT("hrDocumentPropertyPage() requesting %d number of items.\r\n"), pOEMUIParam->cOEMOptItems);
    }
    else
    {
        POEMDEV pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;


        VERBOSE(DLLTEXT("hrDocumentPropertyPage() fill out %d items.\r\n"), pOEMUIParam->cOEMOptItems);

        // Init UI Callback reference.
        pOEMUIParam->OEMCUIPCallback = OEMDocUICallBack;

        // Init OEMOptItmes.
        InitOptItems(pOEMUIParam->pOEMOptItems, pOEMUIParam->cOEMOptItems);

        // Fill out tree view items.

        // New section.
        pOEMUIParam->pOEMOptItems[0].Level = 1;
        pOEMUIParam->pOEMOptItems[0].Flags = OPTIF_COLLAPSE;
        pOEMUIParam->pOEMOptItems[0].pName = GetStringResource(pOEMUIParam->hOEMHeap, pOEMUIParam->hModule, IDS_SECTION);
        pOEMUIParam->pOEMOptItems[0].Sel = pOEMDev->dwDriverData;
        pOEMUIParam->pOEMOptItems[0].pOptType = CreateOptType(pOEMUIParam->hOEMHeap, 2);
		
		//
		//Setup the Optional Item
		//
        pOEMUIParam->pOEMOptItems[0].pOptType->Type = TVOT_UDARROW;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].IconID = 0;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].lParam = 100;
    }

    return S_OK;
}



////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems to display OEM printer property UI.
//
static HRESULT hrPrinterPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
	//
	//This is null the first time the interface is called.
	//
    if(NULL == pOEMUIParam->pOEMOptItems)
    {
        // Fill in the number of OptItems to create for OEM printer property UI.
        pOEMUIParam->cOEMOptItems = 1;
        VERBOSE(DLLTEXT("hrPrinterPropertyPage() requesting %d number of items.\r\n"), pOEMUIParam->cOEMOptItems);
    }
    else
    {
		//
		//This is the second time we are called Now setup the optional items.
		//
        DWORD   dwError;
        DWORD   dwDeviceValue;
        DWORD   dwType;
        DWORD   dwNeeded;

        VERBOSE(DLLTEXT("hrPrinterPropertyPage() fill out %d items.\r\n"), pOEMUIParam->cOEMOptItems);

		//
		//Add OEM Optitem to the Device
		//

        // Get device settings value from printer.
        dwError = GetPrinterData(pOEMUIParam->hPrinter, OEMUI_VALUE, &dwType, (PBYTE) &dwDeviceValue,
                                   sizeof(dwDeviceValue), &dwNeeded);
        if( (ERROR_SUCCESS != dwError)
            ||
            (dwDeviceValue > 100)
          )
        {
            // Failed to get the device value or value is invalid, just use the default.
            dwDeviceValue = 0;
        }

        // Init UI Callback reference.
        pOEMUIParam->OEMCUIPCallback = OEMPrinterUICallBack;

		
        // Init OEMOptItmes.
        InitOptItems(pOEMUIParam->pOEMOptItems, pOEMUIParam->cOEMOptItems);

        // Fill out tree view items.
        // New section.
        pOEMUIParam->pOEMOptItems[0].Level = 1;
        pOEMUIParam->pOEMOptItems[0].Flags = OPTIF_COLLAPSE;
        pOEMUIParam->pOEMOptItems[0].pName = GetStringResource(pOEMUIParam->hOEMHeap, pOEMUIParam->hModule, IDS_SECTION);
        pOEMUIParam->pOEMOptItems[0].Sel = dwDeviceValue;

        pOEMUIParam->pOEMOptItems[0].pOptType = CreateOptType(pOEMUIParam->hOEMHeap, 2);

		//
		//Setup the Optional Item
		//
	    pOEMUIParam->pOEMOptItems[0].pOptType->Type = TVOT_UDARROW;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].IconID = 0;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].lParam = 100;
				
		
    }
    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// Adds property page to Document property sheet. Called via IOemUI::DocumentPropertySheets
//
HRESULT hrOEMDocumentPropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam, 
                                    IPrintOemDriverUI*  pOEMHelp)
{
    LONG_PTR    lResult;


    VERBOSE(DLLTEXT("OEMDocumentPropertySheets() entry.\r\n"));

    // Validate parameters.
    if( (NULL == pPSUIInfo)
        ||
        (PROPSHEETUI_INFO_VERSION != pPSUIInfo->Version)
      )
    {
        ERR(ERRORTEXT("OEMDocumentPropertySheets() ERROR_INVALID_PARAMETER.\r\n"));

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return  E_FAIL;
    }

    // Do action.
    switch(pPSUIInfo->Reason)
    {
        case PROPSHEETUI_REASON_INIT:
            {
                DWORD           dwSheets = 0;
                PCBUSERDATA     pUserData;
                POEMUIPSPARAM   pOEMUIParam = (POEMUIPSPARAM) pPSUIInfo->lParamInit;
                HANDLE          hHeap = pOEMUIParam->hOEMHeap;
                POEMDEV         pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;
                COMPROPSHEETUI  Sheet;


                // Init property page.
                memset(&Sheet, 0, sizeof(COMPROPSHEETUI));
                Sheet.cbSize = sizeof(COMPROPSHEETUI);
                Sheet.Flags = CPSUIF_UPDATE_PERMISSION;
                Sheet.hInstCaller = ghInstance;
                Sheet.pCallerName = GetStringResource(hHeap, ghInstance, IDS_NAME);
                Sheet.pHelpFile = NULL;
                Sheet.pfnCallBack = OEMDocUICallBack;
                Sheet.pDlgPage = CPSUI_PDLGPAGE_TREEVIEWONLY;
                Sheet.cOptItem = 1;
                Sheet.IconID = IDI_CPSUI_PRINTER;
                Sheet.pOptItemName = GetStringResource(hHeap, ghInstance, IDS_SECTION);
                Sheet.CallerVersion = 0x100;
                Sheet.OptItemVersion = 0x100;

                // Init user data.
                pUserData = (PCBUSERDATA) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(CBUSERDATA));
                pUserData->hComPropSheet = pPSUIInfo->hComPropSheet;
                pUserData->pfnComPropSheet = pPSUIInfo->pfnComPropSheet;
                pUserData->pOEMUIParam = pOEMUIParam;
                Sheet.UserData = (ULONG_PTR) pUserData;

                // Create OptItems for page.
                Sheet.pOptItem = CreateOptItems(hHeap, Sheet.cOptItem);

                // Initialize OptItems
                Sheet.pOptItem[0].Level = 1;
                Sheet.pOptItem[0].Flags = OPTIF_COLLAPSE;
                Sheet.pOptItem[0].pName = GetStringResource(hHeap, ghInstance, IDS_SECTION);
                Sheet.pOptItem[0].Sel = pOEMDev->dwDriverData;
								
                Sheet.pOptItem[0].pOptType = CreateOptType(hHeap, 2);
				
				//
				//Set the UI prop of this OPTYPE item.
				//
				Sheet.pOptItem[0].pOptType->Type = TVOT_UDARROW;
                Sheet.pOptItem[0].pOptType->pOptParam[1].IconID = 0;
                Sheet.pOptItem[0].pOptType->pOptParam[1].lParam = 100;
                
                // Adds the  property sheets.
                lResult = pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet, CPSFUNC_ADD_PCOMPROPSHEETUI, 
                                                     (LPARAM)&Sheet, (LPARAM)&dwSheets);
            }
            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:
            {
                PPROPSHEETUI_INFO_HEADER    pHeader = (PPROPSHEETUI_INFO_HEADER) lParam;

                pHeader->pTitle = (LPTSTR)PROP_TITLE;
                lResult = TRUE;
            }
            break;

        case PROPSHEETUI_REASON_GET_ICON:
            // No icon
            lResult = 0;
            break;

        case PROPSHEETUI_REASON_SET_RESULT:
            {
                PSETRESULT_INFO pInfo = (PSETRESULT_INFO) lParam;

                lResult = pInfo->Result;
            }
            break;

        case PROPSHEETUI_REASON_DESTROY:
            lResult = TRUE;
            break;
    }

    pPSUIInfo->Result = lResult;
    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//
// Adds property page to printer property sheet. Called via IOemUI::DevicePropertySheets
//
HRESULT hrOEMDevicePropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam, POEMSHEETDATA pOemSheetData)
{
    LONG_PTR    lResult;


    VERBOSE(DLLTEXT("hrOEMDevicePropertySheets(%#x, %#x) entry\r\n"), pPSUIInfo, lParam);

    // Validate parameters.
    if( (NULL == pPSUIInfo)

        ||
        (PROPSHEETUI_INFO_VERSION != pPSUIInfo->Version)
      )
    {
        ERR(ERRORTEXT("hrOEMDevicePropertySheets() ERROR_INVALID_PARAMETER.\r\n"));

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    Dump(pPSUIInfo);


    // Do action.
    switch(pPSUIInfo->Reason)
    {
		
        case PROPSHEETUI_REASON_INIT:
            {
                PROPSHEETPAGE   Page;
				
                // Init property page.
                memset(&Page, 0, sizeof(PROPSHEETPAGE));
                Page.dwSize = sizeof(PROPSHEETPAGE);
                Page.dwFlags = PSP_DEFAULT;
                Page.hInstance = ghInstance;
                Page.pszTemplate = MAKEINTRESOURCE(IDD_DEVICE_PROPPAGE);
                Page.pfnDlgProc = (DLGPROC) DevicePropPageProc;

				//
				//This is the OEMPlugIN Sheets Shared Data. Use this Pointer to gain access to shared driver data
				//
				pOemSheetData->hComPropSheet = pPSUIInfo->hComPropSheet;
				pOemSheetData->pfnComPropSheet = pPSUIInfo->pfnComPropSheet;
				Page.lParam = (LPARAM)pOemSheetData;

                // Add property sheets.
                pOemSheetData->hmyPlugin = (HANDLE)(pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet, CPSFUNC_ADD_PROPSHEETPAGE, (LPARAM)&Page, 0));

                VERBOSE(DLLTEXT("hrOEMDevicePropertySheets() pfnComPropSheet returned %d.\r\n"), pOemSheetData->hmyPlugin);
            }
            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:
            {
                PPROPSHEETUI_INFO_HEADER    pHeader = (PPROPSHEETUI_INFO_HEADER) lParam;

                pHeader->pTitle = (LPTSTR)PROP_TITLE;
                lResult = TRUE;
            }
            break;

        case PROPSHEETUI_REASON_GET_ICON:
            // No icon
            lResult = 0;
            break;

        case PROPSHEETUI_REASON_SET_RESULT:
            {
                PSETRESULT_INFO pInfo = (PSETRESULT_INFO) lParam;

                lResult = pInfo->Result;
            }
            break;

        case PROPSHEETUI_REASON_DESTROY:
            lResult = TRUE;
            break;
    }

    pPSUIInfo->Result = lResult;
    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//
// OptItems call back for OEM printer property UI.
//
LONG APIENTRY OEMPrinterUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam)
{
    LONG    lReturn = CPSUICB_ACTION_NONE;
    POEMDEV pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;


    VERBOSE(DLLTEXT("OEMPrinterUICallBack() entry, Reason is %d.\r\n"), pCallbackParam->Reason);

    switch(pCallbackParam->Reason)
    {
        case CPSUICB_REASON_APPLYNOW:
            {
                DWORD   dwDriverValue = pOEMUIParam->pOEMOptItems[0].Sel;

				//
                // Store OptItems state in printer data. 
				//
                SetPrinterData(pOEMUIParam->hPrinter, OEMUI_VALUE, REG_DWORD, (PBYTE) &dwDriverValue, sizeof(DWORD));
            }
            break;
		
		//
		//Because the plugin page is changing items in this CPSUI page we need to rinitalise the data on the page.
		//
		case CPSUICB_REASON_SETACTIVE:
			return CPSUICB_ACTION_OPTIF_CHANGED;
			break;

        default:
            break;
    }

    return lReturn;
}



////////////////////////////////////////////////////////////////////////////////
//
// Call back for OEM device property UI.
// 
// This OEM plugin page is using the OPTITEMS in the Device tab to store data. (Installabale Options)
// If you hide these option in the device tab and only access them from your UI you dont have to worry about sync the views.
// If you want the Options in both tabs you need to have a CPSUICALLBACK function defined for the Device tab. (OEMPrinterUICallBack)
// OEMPrinterUICallBack will return CPSUICB_ACTION_OPTIF_CHANGED; to indicate that some of the controls have change. Resulting in CPSUI to refresh the view. 
//
BOOL APIENTRY DevicePropPageProc(HWND hDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
	
	VERBOSE(DLLTEXT("DevicePropPageProc() entry, Reason is %d.\r\n"), uiMsg);

	POEMSHEETDATA	pOEMSheetData	= NULL;
	LONG			lState			= 0;
	DWORD			fDataValid		= 0;
	WORD			dlgControl		= 0;
	PSTR			pControlName	= NULL;
	

	if ( uiMsg != WM_INITDIALOG )
	{	
		//
		//Retrieves Application data storded by the call to SetWindowLongPtr.
		//
		pOEMSheetData = (POEMSHEETDATA)GetWindowLongPtr( hDlg, DWLP_USER);
		

		if (!pOEMSheetData)
		{
			//
			//Failed to get the OEM Prop Page Data Pointer.
			//
			ERR(ERRORTEXT("DevicePropPageProc : GetWindowLongPtr Failed (%d)\r\n"), GetLastError());	
			return FALSE;
		}
	}

    switch (uiMsg)
    {
		case WM_INITDIALOG:
			//
			//PROPSHEETPAGE structure is passed to the dialog box procedure with a WM_INITDIALOG message. 
			//The lParam member is provided to allow you to pass application-specific information to the dialog box procedure
			//
			SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR)((LPPROPSHEETPAGE)lParam)->lParam);
			break;

        case WM_COMMAND:
            switch(HIWORD(wParam))
            {

                case BN_CLICKED:

					//
					//Change the UI to activate the apply button Send the prop dailog a change message.
					//
					PropSheet_Changed(GetParent(hDlg), hDlg);

                    switch(LOWORD(wParam))
                    {

						//
						//USER modified OEM Controls on the plugin page.
						//
						case IDC_CHECK_DUPLPEX:
							dlgControl = IDC_CHECK_DUPLPEX;
							fDataValid = TRUE;
							pControlName = (PSTR)DUPLEXUNIT;
							break;

						case IDC_CHECK_HDRIVE:
							dlgControl = IDC_CHECK_HDRIVE;
							fDataValid = TRUE;
							pControlName = (PSTR)PRINTERHDISK;
							break;

						case IDC_CHECK_ENVFEEDER:
							dlgControl = IDC_CHECK_ENVFEEDER;
							fDataValid = TRUE;
							pControlName = (PSTR)ENVFEEDER;
							break;

						default:
							fDataValid = 0;	
							break;

					}

					//
					//If the Control is valid Get the ctrl state and UPdate the OPTITEM.
					//
					if ( fDataValid )
					{
						lState = (LONG)(SendDlgItemMessage (hDlg, dlgControl, BM_GETSTATE, 0, 0) & 0x0003);
						VERBOSE(DLLTEXT("DevicePropPageProc  :  Clicked dlgControl (%d)\r\n"), lState);
						
						//
						//Saves the Data to the OPTITEMS in the device settings page.
						//
						SetOEMCommonDataIntoOptItem (pOEMSheetData, pControlName, lState);
					}
                    break;

						
                default:
                    return FALSE;
            }
            return TRUE;

		//
		//Dailog is going to paint set up the UI controls to match the relavent OPTITEMS Data.
		//
		case WM_CTLCOLORDLG:
			{
				VERBOSE(DLLTEXT("DevicePropPageProc : WM_CTLCOLORDLG \r\n"));
				SetOEMUiState (hDlg, pOEMSheetData);
			}
			return TRUE;


        case WM_NOTIFY:
            {
                switch (((LPNMHDR)lParam)->code)  // type of notification message
                {
                    case PSN_SETACTIVE:
						return TRUE;
                        break;
    
                    case PSN_KILLACTIVE:
						return TRUE;
                        break;

                    case PSN_APPLY:

						//
						//Calls ComPropSheet 
						//causes the ComPropSheet function to pass a specified result value to all PFNPROPSHEETUI-typed functions associated with a specified page and its parents
						//
						pOEMSheetData->pfnComPropSheet(pOEMSheetData->hComPropSheet, 
													   CPSFUNC_SET_RESULT, 
													   (LPARAM) pOEMSheetData->hmyPlugin, 
													   (LPARAM)CPSUI_OK);
											
						//
						//Accept the apply if the data was invalid and you are checking for this set PSNRET_INVALID | PSNRET_INVALID_NOCHANGEPAGE
						//Disables the APPLY button and saves the Data.
						//
						PropSheet_UnChanged(GetParent(hDlg), hDlg);
						SetWindowLongPtr(hDlg,DWLP_MSGRESULT,PSNRET_NOERROR);
						return TRUE;
                        break;

					//
					// Need To undo the changes
					//
                    case PSN_RESET:
						 break;
                }
            }
            break;
    }

    return FALSE;
} 

////////////////////////////////////////////////////////////////////////////////
//
// Update the OEM page controls to match the Device settings page
//

void SetOEMUiState (HWND hDlg, POEMSHEETDATA pOEMSheetData)
{
	LRESULT			lstate = 0;
	POEMCUIPPARAM	pOEMCUIParam = NULL;
	PUSERDATA		pUserData = NULL;
	POPTITEM		pOptItem = NULL;
	DWORD			cDrvOptItems = 0;

	
	if (pOEMSheetData->pOEMCUIParam)
	{
		pOEMCUIParam = pOEMSheetData->pOEMCUIParam;
		cDrvOptItems = pOEMCUIParam->cDrvOptItems;
	}
	
	//
	//loop down the OPITEMS and retrieve the data that is needed from the control
	//(all Optitesm are ref from DMPubID of the UserData->pKeyWordName)
	//
	for (DWORD i=0; i < cDrvOptItems; i++)
	{
		pOptItem = &(pOEMCUIParam->pDrvOptItems[i]);
		if (pOptItem->UserData)
		{
			pUserData = (PUSERDATA)(pOptItem->UserData);
			if ( pUserData->pKeyWordName )
			{
				//
				//Get the Selection of the OPITEM
				//
				if (pOptItem->Sel)
				{
					lstate = BST_CHECKED;
				}
				else
				{
					lstate = BST_UNCHECKED;
				}

				//
				//Update the Data in OEM Page to mactch the data in the Device Settings TAB.
				//Send a message to the Cntrol to update its State.
				//

				//Set the Duplex Option
				if ( strcmp(pUserData->pKeyWordName, DUPLEXUNIT ) == 0 )
				{
					SendDlgItemMessage (hDlg, IDC_CHECK_DUPLPEX, BM_SETCHECK, lstate, 0);
				}
				
				//Set HardDrive Option
				if ( strcmp (pUserData->pKeyWordName, PRINTERHDISK ) == 0 )
				{
					SendDlgItemMessage (hDlg, IDC_CHECK_HDRIVE, BM_SETCHECK, lstate, 0);
				}
					
				//Set the Env Feeder Option
				if ( strcmp (pUserData->pKeyWordName, ENVFEEDER ) == 0 )
				{
					SendDlgItemMessage (hDlg, IDC_CHECK_ENVFEEDER, BM_SETCHECK, lstate, 0);
				}
			}
		}
	}
}

////////////////////////////////////////////////////////////////////////////////
//
// Save the OEM change into the correct OPTITEM. 
// The UI data is been stored in the driver supplied OPTITEM
//
void SetOEMCommonDataIntoOptItem (POEMSHEETDATA pOEMSheetData, PSTR PName, LONG Sel)
{

	VERBOSE(DLLTEXT("SetOEMCommonDataIntoOptItem (%S) \r\n"), PName);
	
    POEMCUIPPARAM pOEMCUIParam = pOEMSheetData->pOEMCUIParam;
	POPTITEM pOptItem = NULL;
	
	//
	//Find the OPTITEM that needs to be Updated.
	//
	pOptItem = FindDrvOptItem (pOEMCUIParam->pDrvOptItems, 
							   pOEMCUIParam->cDrvOptItems,
							   PName, 
							   DMPUB_NONE);

	if (pOptItem)
	{
		ChangeOpItem (pOEMSheetData->pOEMHelp, 
					  pOEMCUIParam->poemuiobj, 
					  pOptItem, 
					  Sel);
	}
	else
	{
		ERR(ERRORTEXT("SetOEMCommonDataIntoOptItem Item Not Found OPTITEM(%S) \r\n"), PName);	
	}
}


////////////////////////////////////////////////////////////////////////////////
//
// Help Change the data set in the OPTITEM
//
void ChangeOpItem (IPrintOemDriverUI *pIPrintOEMDrvUI,  POEMUIOBJ pOEMUIObj, POPTITEM pOptItem, int iSel)
{
	HRESULT hRestult = S_OK; 
	
	//
	//Change the Item (Change which OPTPARAM is selected fot the required OPTTYPE)
	//
	pOptItem->Sel = iSel;

	//
	//Set the Flag indicating it is changed 
	//
	pOptItem->Flags |= OPTIF_CHANGED;
	
	//
	//Update the Driver UI. (this updates the UI but it does not cause CPSUI to update the its pages), 
	//Look at OEMPrinterUICallBack to see how CPSUI pages are updated
	//The IPrintOemDriverUI::DrvUpdateUISetting method is provided by the 
	//Unidrv and Pscript5 minidrivers so that user interface plug-ins can 
	//notify the driver of a modified user interface option.
	//
	hRestult = pIPrintOEMDrvUI->DrvUpdateUISetting((PVOID)pOEMUIObj, (PVOID)pOptItem, 0, OEMCUIP_PRNPROP);
	
	if (hRestult != S_OK)
	{
		ERR(ERRORTEXT("ChangeOpItem DrvUpdateUISetting FAILED \r\n") );
	}
	
}


////////////////////////////////////////////////////////////////////////////////
//
// Help Find a OPTITEM from the array based on USERDATA->pKeyWordName or DMPubID 
//
POPTITEM FindDrvOptItem (POPTITEM pDrvOptItems, DWORD dwItemCount, PSTR pKeyWordName, BYTE dmPubID )
{
	VERBOSE(DLLTEXT("FindDrvOptItem Looking (%S) (%d) \r\n"), pKeyWordName, dmPubID);
	
	POPTITEM  pOptItem  = NULL; 
	PUSERDATA pUserData = NULL;

	for (DWORD i=0; i < dwItemCount; i++)
	{
		//
		//OPTITEM has valid data compare these now (Search on DMPubID)
		//
		if (pKeyWordName == NULL)
		{
			if (dmPubID == pDrvOptItems[i].DMPubID)
			{
				pOptItem = &(pDrvOptItems[i]);
				break;
			}
		}
		else
		{
			//
			//(Search a printer freature pKeyWordName)
			//
			//For Common Printer Features the key name is set to a common non localised string
			//Note the these are only ansi strings ie PSTR
			//
			if (pDrvOptItems[i].UserData)
			{
				pUserData = (PUSERDATA)pDrvOptItems[i].UserData;
				if (pUserData->pKeyWordName)
				{
					//
					//OPTITEM has valid data compare these now
					//
					if ( strcmp (pUserData->pKeyWordName, pKeyWordName) == 0)
					{
						pOptItem = &(pDrvOptItems[i]);
						break;
					}
				}
			}
		}
	}

	if (!pOptItem) 
	{
		ERR(ERRORTEXT("FindDrvOptItem OPTITEM NOT Found \r\n") );
	}

	return pOptItem;
}


////////////////////////////////////////////////////////////////////////////////
//
// OptItems call back for OEM document property UI.
//
LONG APIENTRY OEMDocUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam)
{
    LONG    lReturn = CPSUICB_ACTION_NONE;
    POEMDEV pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;


    VERBOSE(DLLTEXT("OEMDocUICallBack() entry, Reason is %d.\r\n"), pCallbackParam->Reason);

    switch(pCallbackParam->Reason)
    {
        case CPSUICB_REASON_APPLYNOW:
            // Store OptItems state in DEVMODE.
            pOEMDev->dwDriverData = pOEMUIParam->pOEMOptItems[0].Sel;
            break;

        case CPSUICB_REASON_KILLACTIVE:
            pOEMDev->dwDriverData = pOEMUIParam->pOEMOptItems[0].Sel;
            break;

		//
		//Refress the Data in the view and tell CPUSI that the data has changed by ret CPSUICB_ACTION_OPTIF_CHANGED
		//
        case CPSUICB_REASON_SETACTIVE:
            pOEMUIParam->pOEMOptItems[0].Sel = pOEMDev->dwDriverData;
            pOEMUIParam->pOEMOptItems[0].Flags |= OPTIF_CHANGED;
            lReturn = CPSUICB_ACTION_OPTIF_CHANGED;
            break;

        default:
            break;
    }

    return lReturn;
}


LONG APIENTRY OEMDocUICallBack(PCPSUICBPARAM pCallbackParam)
{
    LONG            lReturn = CPSUICB_ACTION_NONE;
    PCBUSERDATA     pUserData = (PCBUSERDATA) pCallbackParam->UserData;
    POEMDEV         pOEMDev = (POEMDEV) pUserData->pOEMUIParam->pOEMDM;


    VERBOSE(DLLTEXT("OEMDocUICallBack() entry, Reason is %d.\r\n"), pCallbackParam->Reason);

    switch(pCallbackParam->Reason)
    {
        case CPSUICB_REASON_APPLYNOW:
            pOEMDev->dwDriverData = pCallbackParam->pOptItem[0].Sel;
            pUserData->pfnComPropSheet(pUserData->hComPropSheet, CPSFUNC_SET_RESULT,
            	                       (LPARAM)pUserData->hPropPage,
               	                       (LPARAM)CPSUI_OK);
            break;

        case CPSUICB_REASON_KILLACTIVE:
            pOEMDev->dwDriverData = pCallbackParam->pOptItem[0].Sel;
            break;

        case CPSUICB_REASON_SETACTIVE:
            pCallbackParam->pOptItem[0].Sel = pOEMDev->dwDriverData;
            pCallbackParam->pOptItem[0].Flags |= OPTIF_CHANGED;
            lReturn = CPSUICB_ACTION_OPTIF_CHANGED;
            break;

        default:
            break;
    }

    return lReturn;
}


////////////////////////////////////////////////////////////////////////////////
//
// Creates and Initializes OptItems.
//
static POPTITEM CreateOptItems(HANDLE hHeap, DWORD dwOptItems)
{
    POPTITEM    pOptItems = NULL;


    // Allocate memory for OptItems;
    pOptItems = (POPTITEM) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(OPTITEM) * dwOptItems);
    if(NULL != pOptItems)
    {
        InitOptItems(pOptItems, dwOptItems);
    }
    else
    {
        ERR(ERRORTEXT("CreateOptItems() failed to allocate memory for OPTITEMs!\r\n"));
    }

    return pOptItems;
}


////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems.
//
static void InitOptItems(POPTITEM pOptItems, DWORD dwOptItems)
{
    VERBOSE(DLLTEXT("InitOptItems() entry.\r\n"));

    // Zero out memory.
    memset(pOptItems, 0, sizeof(OPTITEM) * dwOptItems);

    // Set each OptItem's size, and Public DM ID.
    for(DWORD dwCount = 0; dwCount < dwOptItems; dwCount++)
    {
        pOptItems[dwCount].cbSize = sizeof(OPTITEM);
        pOptItems[dwCount].DMPubID = DMPUB_NONE;
    }
}


////////////////////////////////////////////////////////////////////////////////
//
// Allocates and initializes OptType for OptItem.
//
static POPTTYPE CreateOptType(HANDLE hHeap, WORD wOptParams)
{
    POPTTYPE    pOptType = NULL;


    VERBOSE(DLLTEXT("CreateOptType() entry.\r\n"));

    // Allocate memory from the heap for the OPTTYPE; the driver will take care of clean up.
    pOptType = (POPTTYPE) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(OPTTYPE));
    if(NULL != pOptType)
    {
        // Initialize OPTTYPE.
        pOptType->cbSize = sizeof(OPTTYPE);
        pOptType->Count = wOptParams;

        // Allocate memory from the heap for the OPTPARAMs for the OPTTYPE.
        pOptType->pOptParam = (POPTPARAM) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, wOptParams * sizeof(OPTPARAM));
        if(NULL != pOptType->pOptParam)
        {
            // Initialize the OPTPARAMs.
            for(WORD wCount = 0; wCount < wOptParams; wCount++)
            {
                pOptType->pOptParam[wCount].cbSize = sizeof(OPTPARAM);
            }
        }
        else
        {
            ERR(ERRORTEXT("CreateOptType() failed to allocated memory for OPTPARAMs!\r\n"));

            // Free allocated memory and return NULL.
            HeapFree(hHeap, 0, pOptType);
            pOptType = NULL;
        }
    }
    else
    {
        ERR(ERRORTEXT("CreateOptType() failed to allocated memory for OPTTYPE!\r\n"));
    }

    return pOptType;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  Retrieves pointer to a String resource.
//
static PTSTR GetStringResource(HANDLE hHeap, HANDLE hModule, UINT uResource)
{
    int     nResult;
    DWORD   dwSize = MAX_PATH;
    PTSTR   pszString = NULL;


    VERBOSE(DLLTEXT("GetStringResource(%#x, %#x, %d) entered.\r\n"), hHeap, hModule, uResource);

    // Allocate buffer for string resource from heap; let the driver clean it up.
    pszString = (PTSTR) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwSize * sizeof(TCHAR));
    if(NULL != pszString)
    {
        // Load string resource; resize after loading so as not to waste memory.
        nResult = LoadString((HMODULE)hModule, uResource, pszString, dwSize);
        if(nResult > 0)
        {
            PTSTR   pszTemp;


            VERBOSE(DLLTEXT("LoadString() returned %d!\r\n"), nResult);
            VERBOSE(DLLTEXT("String load was \"%s\".\r\n"), pszString);

            pszTemp = (PTSTR) HeapReAlloc(hHeap, HEAP_ZERO_MEMORY, pszString, (nResult + 1) * sizeof(TCHAR));
            if(NULL != pszTemp)
            {
                pszString = pszTemp;
            }
            else
            {
                ERR(ERRORTEXT("GetStringResource() HeapReAlloc() of string retrieved failed! (Last Error was %d)\r\n"), GetLastError());
            }
        }
        else
        {
            ERR(ERRORTEXT("LoadString() returned %d! (Last Error was %d)\r\n"), nResult, GetLastError());
            ERR(ERRORTEXT("GetStringResource() failed to load string resource %d!\r\n"), uResource);

            pszString = NULL;
        }
    }
    else
    {
        ERR(ERRORTEXT("GetStringResource() failed to allocate string buffer!\r\n"));
    }

    return pszString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\syncset\oemui.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	OEMUI.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for OEMUI Test Module.
//
//  PLATFORMS:
//    Windows 95, Windows NT
//
//
#ifndef _OEMUI_H
#define _OEMUI_H

#include <PRCOMOEM.H>

#include "OEM.H"
#include "DEVMODE.H"
#include "globals.h"



////////////////////////////////////////////////////////
//      OEM UI Defines
////////////////////////////////////////////////////////


// OEM Signature and version.
#define PROP_TITLE      L"OEM UI Page"
#define DLLTEXT(s)      __TEXT("UI:  ") __TEXT(s)

// OEM UI Misc defines.
#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)


// Printer registry keys where OEM data is stored.
#define OEMUI_VALUE             TEXT("OEMUI_VALUE")
#define OEMUI_DEVICE_VALUE      TEXT("OEMUI_DEVICE_VALUE")

//
//KeyWordNames for OPTITEMS (These are nonlocalised keywords assocaited with driver features. in the OPTITEMS)
//
const char DUPLEXUNIT[]		= "DuplexUnit";
const char ENVFEEDER[]		= "EnvFeeder";
const char PRINTERHDISK[]	= "PrinterHardDisk";

//
//This structure is used to link the common pages and the OEM plugin page.
//
typedef struct _OEMSHEETDATA {
	
	//
	//Any other OEM Data you may want to store.
	//

	
	//
	//Hold Pointers you may need.
	//
	HANDLE				hComPropSheet;		//Handle to the Prop Sheet Parent Page Used when calling ComPropSheet
	HANDLE				hmyPlugin;			//Handle to the OEM Plugin page. Page Used when calling ComPropSheet
	PFNCOMPROPSHEET		pfnComPropSheet;    //Is the Pointer to ComPropSheet This is needed when APPLY is clicked (CPSFUNC_SET_RESULT)

	POEMCUIPPARAM		pOEMCUIParam;		//Holds links to the DEVMODE and OPTITEMS needed.
	IPrintOemDriverUI*	pOEMHelp;

} OEMSHEETDATA, *POEMSHEETDATA;

////////////////////////////////////////////////////////
//      Prototypes
////////////////////////////////////////////////////////

HRESULT hrOEMPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam);
HRESULT hrOEMDocumentPropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam, IPrintOemDriverUI*  pOEMHelp);
HRESULT hrOEMDevicePropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam, POEMSHEETDATA pOemSheetData);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\syncset\intrface.h ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.h

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

////////////////////////////////////////////////////////////////////////////////
//
// IOemUI
//
class IOemUI: public IPrintOemUI
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD  dwMode, PVOID  pBuffer, DWORD  cbSize,
                           PDWORD pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_  DWORD  dwMode, POEMDMPARAM pOemDMParam) ;

    //
    // OEMCommonUIProp
    //

    STDMETHOD(CommonUIProp) (THIS_  
            DWORD  dwMode, 
            POEMCUIPPARAM   pOemCUIPParam
            );

    //
    // OEMDocumentPropertySheets
    //

    STDMETHOD(DocumentPropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            );

    //
    // OEMDevicePropertySheets
    //

    STDMETHOD(DevicePropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            );


    //
    // OEMDevQueryPrintEx
    //

    STDMETHOD(DevQueryPrintEx) (THIS_
            POEMUIOBJ               poemuiobj,
            PDEVQUERYPRINT_INFO     pDQPInfo,
            PDEVMODE                pPublicDM,
            PVOID                   pOEMDM
            );

    //
    // OEMDeviceCapabilities
    //

    STDMETHOD(DeviceCapabilities) (THIS_
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult
            );

    //
    // OEMUpgradePrinter
    //

    STDMETHOD(UpgradePrinter) (THIS_
            DWORD   dwLevel,
            PBYTE   pDriverUpgradeInfo
            );

    //
    // OEMPrinterEvent
    //

    STDMETHOD(PrinterEvent) (THIS_
            PWSTR   pPrinterName,
            INT     iDriverEvent,
            DWORD   dwFlags,
            LPARAM  lParam
            );

    //
    // OEMDriverEvent
    //

    STDMETHOD(DriverEvent)(THIS_
            DWORD   dwDriverEvent,
            DWORD   dwLevel,
            LPBYTE  pDriverInfo,
            LPARAM  lParam
            );
 
    //
    // OEMQueryColorProfile
    //

    STDMETHOD( QueryColorProfile) (THIS_
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulReserved,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData);

    //
    // OEMFontInstallerDlgProc
    //

    STDMETHOD(FontInstallerDlgProc) (THIS_ 
            HWND    hWnd,
            UINT    usMsg,
            WPARAM  wParam,
            LPARAM  lParam
            );
    //
    // UpdateExternalFonts
    //

    STDMETHOD(UpdateExternalFonts) (THIS_
            HANDLE  hPrinter,
            HANDLE  hHeap,
            PWSTR   pwstrCartridges
            );


    IOemUI() 
	{ 
		m_cRef = 1; 
		m_pOEMHelp = NULL; 
		m_OemSheetData.pfnComPropSheet = NULL; 
		m_OemSheetData.pOEMCUIParam=NULL;
		m_OemSheetData.hComPropSheet=INVALID_HANDLE_VALUE;
		m_OemSheetData.hmyPlugin=INVALID_HANDLE_VALUE;
	};

    ~IOemUI();

protected:
    LONG                m_cRef;
    IPrintOemDriverUI*  m_pOEMHelp;

	//
	//Used to link common ui in device settings tab and the OEM plugin tab.
	//
	OEMSHEETDATA		m_OemSheetData;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\themeui\fusutils.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2001
 *
 *  TITLE:       fusutils.cpp
 *
 *  VERSION:     1.0
 *
 *  DATE:        14-Feb-2001
 *
 *  DESCRIPTION: Fusion utilities
 *
 *****************************************************************************/
#pragma once

#include "precomp.h"
#include "globals.h"
#include "fusutils.h"



#define MAX_LOOP    10


HANDLE GetMyActivationContext()
{
    // Make sure we've created our activation context.
    CreateMyActivationContext();

    // Return the global.
    return ghActCtx;
}


BOOL CreateMyActivationContext()
{
    if(INVALID_HANDLE_VALUE != ghActCtx)
    {
        return TRUE;
    }

    ghActCtx = CreateActivationContextFromResource(ghInstance, MAKEINTRESOURCE(MANIFEST_RESOURCE));

    return (INVALID_HANDLE_VALUE != ghActCtx);
}



HANDLE CreateActivationContextFromResource(HMODULE hModule, LPCTSTR pszResourceName)
{
    DWORD   dwSize          = MAX_PATH;
    DWORD   dwUsed          = 0;
    DWORD   dwLoop;
    PTSTR   pszModuleName   = NULL;
    ACTCTX  act;
    HANDLE  hActCtx         = INVALID_HANDLE_VALUE;

    
    // Get the name for the module that contains the manifest resource
    // to create the Activation Context from.
    dwLoop = 0;
    do 
    {
        // May need to allocate or re-alloc buffer for module name.
        if(NULL != pszModuleName)
        {
            // Need to re-alloc bigger buffer.

            // First, delete old buffer.
            delete[] pszModuleName;

            // Second, increase buffer alloc size.
            dwSize <<= 1;
        }
        pszModuleName = new TCHAR[dwSize];
        if(NULL == pszModuleName)
        {
            goto Exit;
        }

        // Try to get the module name.
        dwUsed = GetModuleFileName(hModule, pszModuleName, dwSize);

        // Check to see if it failed.
        if(0 == dwUsed)
        {
            goto Exit;
        }

        // If dwUsed is equla to dwSize or larger,
        // the buffer passed in wasn't big enough.
    } while ( (dwUsed >= dwSize) && (++dwLoop < MAX_LOOP) );

    // Now let's try to create an activation context
    // from manifest resource.
    ::ZeroMemory(&act, sizeof(act));
    act.cbSize          = sizeof(act);
    act.dwFlags         = ACTCTX_FLAG_RESOURCE_NAME_VALID;
    act.lpResourceName  = pszResourceName;
    act.lpSource        = pszModuleName;

    hActCtx = CreateActCtx(&act);


Exit:

    //
    //  Clean up.
    //

    if(NULL != pszModuleName)
    {
        delete[] pszModuleName;
    }

    return hActCtx;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\themeui\devmode.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2001  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Devmode.h
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for devmode functions.
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP
//
//
#ifndef _DEVMODE_H
#define _DEVMODE_H


////////////////////////////////////////////////////////
//      OEM Devmode Defines
////////////////////////////////////////////////////////




////////////////////////////////////////////////////////
//      OEM Devmode Type Definitions
////////////////////////////////////////////////////////

typedef struct tagOEMDEV
{
    OEM_DMEXTRAHEADER   dmOEMExtra;
    BOOL                dwDriverData;

} OEMDEV, *POEMDEV;

typedef const OEMDEV *PCOEMDEV;



/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

HRESULT hrOEMDevMode(DWORD dwMode, POEMDMPARAM pOemDMParam);
BOOL ConvertOEMDevmode(PCOEMDEV pOEMDevIn, POEMDEV pOEMDevOut);
BOOL MakeOEMDevmodeValid(POEMDEV pOEMDevmode);
void Dump(PCOEMDEV pOEMDevIn);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\themeui\globals.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2001  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Globals.cpp
//    
//
//  PURPOSE:  File that contains all the globals.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP
//
//
#define _GLOBALS_H

#include "precomp.h"
#include "oemui.h"



///////////////////////////////////////
//          Globals
///////////////////////////////////////


// Module's Instance handle from DLLEntry of process.
HINSTANCE   ghInstance  = NULL; 

// Module's Activation Context from DLLEntry of process.
HANDLE      ghActCtx    = INVALID_HANDLE_VALUE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\themeui\devmode.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2001  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Devmode.cpp
//    
//
//  PURPOSE:  Implementation of Devmode functions shared with OEM UI and OEM rendering modules.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP
//
//

#include "precomp.h"
#include "oemui.h"
#include "debug.h"
#include "devmode.h"



HRESULT hrOEMDevMode(DWORD dwMode, POEMDMPARAM pOemDMParam)
{
    POEMDEV pOEMDevIn;
    POEMDEV pOEMDevOut;


    // Verify parameters.
    if( (NULL == pOemDMParam)
        ||
        ( (OEMDM_SIZE != dwMode)
          &&
          (OEMDM_DEFAULT != dwMode)
          &&
          (OEMDM_CONVERT != dwMode)
          &&
          (OEMDM_MERGE != dwMode)
        )
      )
    {
        ERR(ERRORTEXT("DevMode() ERROR_INVALID_PARAMETER.\r\n"));
        VERBOSE(DLLTEXT("\tdwMode = %d, pOemDMParam = %#lx.\r\n"), dwMode, pOemDMParam);

        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    // Cast generic (i.e. PVOID) to OEM private devomode pointer type.
    pOEMDevIn = (POEMDEV) pOemDMParam->pOEMDMIn;
    pOEMDevOut = (POEMDEV) pOemDMParam->pOEMDMOut;

    switch(dwMode)
    {
        case OEMDM_SIZE:
            pOemDMParam->cbBufSize = sizeof(OEMDEV);
            break;

        case OEMDM_DEFAULT:
            pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
            pOEMDevOut->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
            pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
            pOEMDevOut->dwDriverData            = 0;
            VERBOSE(DLLTEXT("pOEMDevOut after setting default values:\r\n"));
            Dump(pOEMDevOut);
            break;

        case OEMDM_CONVERT:
            ConvertOEMDevmode(pOEMDevIn, pOEMDevOut);
            break;

        case OEMDM_MERGE:
            ConvertOEMDevmode(pOEMDevIn, pOEMDevOut);
            MakeOEMDevmodeValid(pOEMDevOut);
            break;
    }
    Dump(pOemDMParam);

    return S_OK;
}


BOOL ConvertOEMDevmode(PCOEMDEV pOEMDevIn, POEMDEV pOEMDevOut)
{
    if( (NULL == pOEMDevIn)
        ||
        (NULL == pOEMDevOut)
      )
    {
        ERR(ERRORTEXT("ConvertOEMDevmode() invalid parameters.\r\n"));
        return FALSE;
    }

    // Check OEM Signature, if it doesn't match ours,
    // then just assume DMIn is bad and use defaults.
    if(pOEMDevIn->dmOEMExtra.dwSignature == pOEMDevOut->dmOEMExtra.dwSignature)
    {
        VERBOSE(DLLTEXT("Converting private OEM Devmode.\r\n"));
        VERBOSE(DLLTEXT("pOEMDevIn:\r\n"));
        Dump(pOEMDevIn);

        // Set the devmode defaults so that anything the isn't copied over will
        // be set to the default value.
        pOEMDevOut->dwDriverData = 0;

        // Copy the old structure in to the new using which ever size is the smaller.
        // Devmode maybe from newer Devmode (not likely since there is only one), or
        // Devmode maybe a newer Devmode, in which case it maybe larger,
        // but the first part of the structure should be the same.

        // DESIGN ASSUMPTION: the private DEVMODE structure only gets added to;
        // the fields that are in the DEVMODE never change only new fields get added to the end.

        memcpy(pOEMDevOut, pOEMDevIn, __min(pOEMDevOut->dmOEMExtra.dwSize, pOEMDevIn->dmOEMExtra.dwSize));

        // Re-fill in the size and version fields to indicated 
        // that the DEVMODE is the current private DEVMODE version.
        pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
        pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
    }
    else
    {
        WARNING(DLLTEXT("Unknown DEVMODE signature, pOEMDMIn ignored.\r\n"));

        // Don't know what the input DEVMODE is, so just use defaults.
        pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
        pOEMDevOut->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
        pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
        pOEMDevOut->dwDriverData            = 0;
    }

    return TRUE;
}


BOOL MakeOEMDevmodeValid(POEMDEV pOEMDevmode)
{
    if(NULL == pOEMDevmode)
    {
        return FALSE;
    }

    // ASSUMPTION: pOEMDevmode is large enough to contain OEMDEV structure.

    // Make sure that dmOEMExtra indicates the current OEMDEV structure.
    pOEMDevmode->dmOEMExtra.dwSize       = sizeof(OEMDEV);
    pOEMDevmode->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
    pOEMDevmode->dmOEMExtra.dwVersion    = OEM_VERSION;

    // Set driver data, if not valid.
    if(pOEMDevmode->dwDriverData > 100)
    {
        pOEMDevmode->dwDriverData = 0;
    }

    return TRUE;
}


void Dump(PCOEMDEV pOEMDevmode)
{
    if( (NULL != pOEMDevmode)
        &&
        (pOEMDevmode->dmOEMExtra.dwSize >= sizeof(OEMDEV))
        &&
        (OEM_SIGNATURE == pOEMDevmode->dmOEMExtra.dwSignature)
      )
    {
        VERBOSE(__TEXT("\tdmOEMExtra.dwSize      = %d\r\n"), pOEMDevmode->dmOEMExtra.dwSize);
        VERBOSE(__TEXT("\tdmOEMExtra.dwSignature = %#x\r\n"), pOEMDevmode->dmOEMExtra.dwSignature);
        VERBOSE(__TEXT("\tdmOEMExtra.dwVersion   = %#x\r\n"), pOEMDevmode->dmOEMExtra.dwVersion);
        VERBOSE(__TEXT("\tdwDriverData           = %#x\r\n"), pOEMDevmode->dwDriverData);
    }
    else
    {
        ERR(ERRORTEXT("Dump(POEMDEV) unknown private OEM DEVMODE.\r\n"));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\themeui\oem.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997, 1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debug.cpp.
//
//  PLATFORMS:
//    Windows NT
//
//
#ifndef _OEM_H
#define _OEM_H



////////////////////////////////////////////////////////
//      OEM Defines
////////////////////////////////////////////////////////

#define OEM_SIGNATURE   'MSFT'
#define OEM_VERSION     0x00000001L



////////////////////////////////////////////////////////
//      OEM Type Definitions
////////////////////////////////////////////////////////



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\themeui\fusutils.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       fusutils.h
 *
 *  VERSION:     1.0
 *
 *  DATE:        14-Feb-2001
 *
 *  DESCRIPTION: Fusion utilities
 *
 *****************************************************************************/

#ifndef _FUSUTILS_H
#define _FUSUTILS_H



HANDLE GetMyActivationContext();
BOOL CreateMyActivationContext();
HANDLE CreateActivationContextFromResource(HMODULE hModule, LPCTSTR pszResourceName);



#endif // endif _FUSUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\themeui\globals.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2001  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Globals.h
//    
//
//  PURPOSE:   Lists of globals declared in Globals.cpp.
//
//
//  PLATFORMS:
//
//    Windows 2000, Windows XP
//
//
#ifndef _GLOBALS_H
#define _GLOBALS_H


///////////////////////////////////////
//          Globals
///////////////////////////////////////

extern HINSTANCE   ghInstance;  // Module's Instance handle from DLLEntry of process.
extern HANDLE      ghActCtx;    // Module's Activation Context from DLLEntry of process.



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\themeui\dllentry.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2001  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	dllentry.cpp
//    
//
//  PURPOSE:  Source module for DLL entry function(s).
//
//
//	Functions:
//
//		DllMain
//
//
//  PLATFORMS:	Windows 2000, Windows XP
//
//

#include "precomp.h"
#include "oemui.h"
#include "fusutils.h"
#include "debug.h"



// Need to export these functions as c declarations.
extern "C" {


///////////////////////////////////////////////////////////
//
// DLL entry point
//
BOOL WINAPI DllMain(HINSTANCE hInst, WORD wReason, LPVOID lpReserved)
{
	switch(wReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(DLLTEXT("Process attach.\r\n"));

            // Store the module handle in case we need it later.
            ghInstance = hInst;

            // NOTE: We don't create an Activation Context on module load,
            //       but on need of an Avtivation Context; the first time
            //       GetMyActivationContext() or CreateMyActivationContext() is called.
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(DLLTEXT("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(DLLTEXT("Process detach.\r\n"));

            // Release the Activation Context if we created one somewhere
            // by calling GetMyActivationContext() or CreateMyActivationContext();
            if(INVALID_HANDLE_VALUE != ghActCtx)
            {
                ReleaseActCtx(ghActCtx);
                ghActCtx = INVALID_HANDLE_VALUE;
            }
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(DLLTEXT("Thread detach.\r\n"));
			break;
	}

	return TRUE;
}


}  // extern "C" closing bracket
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\themeui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by OEMUI.rc
//
#define IDS_SECTION                     1
#define IDS_CALIBRATED                  2
#define IDS_NAME                        3
#define IDD_DEVICE_PROPPAGE             106
#define IDD_DOC_PROPPAGE                107
#define IDC_CALIBRATE                   1001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\common\debug.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.cpp
//    
//
//  PURPOSE:  Debug functions.
//
//
//	Functions:
//
//
//
//  PLATFORMS:	Windows NT, Windows 2000
//
//

#include "precomp.h"
#include "oem.h"
#include "debug.h"
#include "kmode.h"



////////////////////////////////////////////////////////
//      INTERNAL DEFINES
////////////////////////////////////////////////////////

#define DEBUG_BUFFER_SIZE       1024
#define PATH_SEPARATOR          '\\'



// Determine what level of debugging messages to eject. 
#ifdef VERBOSE_MSG
    #define DEBUG_LEVEL     DBG_VERBOSE
#elif TERSE_MSG
    #define DEBUG_LEVEL     DBG_TERSE
#elif WARNING_MSG
    #define DEBUG_LEVEL     DBG_WARNING
#elif ERROR_MSG
    #define DEBUG_LEVEL     DBG_ERROR
#elif RIP_MSG
    #define DEBUG_LEVEL     DBG_RIP
#elif NO_DBG_MSG
    #define DEBUG_LEVEL     DBG_NONE
#else
    #define DEBUG_LEVEL     DBG_WARNING
#endif



////////////////////////////////////////////////////////
//      EXTERNAL GLOBALS
////////////////////////////////////////////////////////

INT giDebugLevel = DEBUG_LEVEL;




////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist);
static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist);




//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(LPCSTR lpszMessage, va_list arglist)
{
    DWORD   dwSize = DEBUG_BUFFER_SIZE;
    LPSTR   lpszMsgBuf = NULL;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    do
    {
        // Allocate memory for message buffer.
        if(NULL != lpszMsgBuf)
        {
            delete[] lpszMsgBuf;
            dwSize *= 2;
        }
        lpszMsgBuf = new CHAR[dwSize + 1];
        if(NULL == lpszMsgBuf)
            return FALSE;

    // Pass the variable parameters to wvsprintf to be formated.
    } while (_vsnprintf(lpszMsgBuf, dwSize, lpszMessage, arglist) < 0);

    // Dump string to Debug output.
    OutputDebugStringA(lpszMsgBuf);

    // Cleanup.
    delete[] lpszMsgBuf;

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessageV
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      dwSize          Size of temp buffer to hold formated string.
//
//      lpszMessage     Format string.
//
//      arglist         Variable argument list..
//    
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL DebugMessageV(DWORD dwSize, LPCWSTR lpszMessage, va_list arglist)
{
    LPWSTR     lpszMsgBuf;


    // Parameter checking.
    if( (NULL == lpszMessage)
        ||
        (0 == dwSize)
      )
    {
      return FALSE;
    }

    // Allocate memory for message buffer.
    lpszMsgBuf = new WCHAR[dwSize + 1];    
    if(NULL == lpszMsgBuf)
        return FALSE;

    // Pass the variable parameters to wvsprintf to be formated.
    vswprintf(lpszMsgBuf, lpszMessage, arglist);

    // Dump string to debug output.
    OutputDebugStringW(lpszMsgBuf);

    // Clean up.
    delete[] lpszMsgBuf;

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV for processing.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}


//////////////////////////////////////////////////////////////////////////
//  Function:	DebugMessage
//
//  Description:  Outputs variable argument debug string.
//    
//
//  Parameters:	
//
//      lpszMessage     Format string.
//
//
//  Returns:
//    
//
//  Comments:
//     
//
//  History:
//		12/18/96	APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL DebugMessage(LPCWSTR lpszMessage, ...)
{
    BOOL    bResult;
    va_list VAList;


    // Pass the variable parameters to DebugMessageV to be processed.
    va_start(VAList, lpszMessage);
    bResult = DebugMessageV(MAX_PATH, lpszMessage, VAList);
    va_end(VAList);

    return bResult;
}

void Dump(PPUBLISHERINFO pPublisherInfo)
{
    VERBOSE(__TEXT("pPublisherInfo:\r\n"));
    VERBOSE(__TEXT("\tdwMode           =   %#x\r\n"), pPublisherInfo->dwMode);
    VERBOSE(__TEXT("\twMinoutlinePPEM  =   %d\r\n"), pPublisherInfo->wMinoutlinePPEM);
    VERBOSE(__TEXT("\twMaxbitmapPPEM   =   %d\r\n"), pPublisherInfo->wMaxbitmapPPEM);
}

void Dump(POEMDMPARAM pOemDMParam)
{
    VERBOSE(__TEXT("pOemDMParam:\r\n"));
    VERBOSE(__TEXT("\tcbSize = %d\r\n"), pOemDMParam->cbSize);
    VERBOSE(__TEXT("\tpdriverobj = %#x\r\n"), pOemDMParam->pdriverobj);
    VERBOSE(__TEXT("\thPrinter = %#x\r\n"), pOemDMParam->hPrinter);
    VERBOSE(__TEXT("\thModule = %#x\r\n"), pOemDMParam->hModule);
    VERBOSE(__TEXT("\tpPublicDMIn = %#x\r\n"), pOemDMParam->pPublicDMIn);
    VERBOSE(__TEXT("\tpPublicDMOut = %#x\r\n"), pOemDMParam->pPublicDMOut);
    VERBOSE(__TEXT("\tpOEMDMIn = %#x\r\n"), pOemDMParam->pOEMDMIn);
    VERBOSE(__TEXT("\tpOEMDMOut = %#x\r\n"), pOemDMParam->pOEMDMOut);
    VERBOSE(__TEXT("\tcbBufSize = %d\r\n"), pOemDMParam->cbBufSize);
}



PCSTR
StripDirPrefixA(
    IN PCSTR    pstrFilename
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    PCSTR   pstr;

    if (pstr = strrchr(pstrFilename, PATH_SEPARATOR))
        return pstr + 1;

    return pstrFilename;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\common\debug.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debugging functions.
//
//  PLATFORMS:
//
//    Windows NT, Windows 2000
//
//
#ifndef _DEBUG_H
#define _DEBUG_H

#include "kmode.h"


// VC and Build use different debug defines.
// The following makes it so either will
// cause the inclusion of debugging code.
#if !defined(_DEBUG) && defined(DBG)
    #define _DEBUG      DBG
#elif defined(_DEBUG) && !defined(DBG)
    #define DBG         _DEBUG
#endif



/////////////////////////////////////////////////////////
//		Macros
/////////////////////////////////////////////////////////

//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// giDebugLevel
//  Global variable which set the current debug level to control
//  the amount of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ERR(msg)
//  Similiar to WARNING macro above - displays a message
//  if the current debug level is <= DBG_ERROR.
//
// ASSERT(cond)
//  Verify a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify a condition is true. If not, display a message and
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//  These macros require extra parantheses for the msg argument
//  example, ASSERTMSG(x > 0, ("x is less than 0\n"));
//           WARNING(("App passed NULL pointer, ignoring...\n"));
//

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_ERROR   4
#define DBG_RIP     5
#define DBG_NONE    6

#if DBG

    #define DebugMsg    DebugMessage

    //
    // Strip the directory prefix from a filename (ANSI version)
    //

    PCSTR
    StripDirPrefixA(
        IN PCSTR    pstrFilename
        );

    extern INT giDebugLevel;


    #define DBGMSG(level, prefix, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg("%s %s (%d): ", prefix, StripDirPrefixA(__FILE__), __LINE__); \
                    DebugMsg(msg); \
                } \
            }

    #define DBGPRINT(level, msg) { \
                if (giDebugLevel <= (level)) { \
                    DebugMsg(msg); \
                } \
            }

    #define VERBOSE         if(giDebugLevel <= DBG_VERBOSE) DebugMsg
    #define TERSE           if(giDebugLevel <= DBG_TERSE) DebugMsg
    #define WARNING         if(giDebugLevel <= DBG_WARNING) DebugMsg
    #define ERR             if(giDebugLevel <= DBG_ERROR) DebugMsg

    #define ASSERT(cond) { \
                if (! (cond)) { \
                    RIP(("\n")); \
                } \
            }

    #define ASSERTMSG(cond, msg) { \
                if (! (cond)) { \
                    RIP(msg); \
                } \
            }

    #define RIP(msg) { \
                DBGMSG(DBG_RIP, "RIP", msg); \
                DebugBreak(); \
            }


#else // !DBG

    #define DebugMsg    NOP_FUNCTION

    #define VERBOSE     NOP_FUNCTION
    #define TERSE       NOP_FUNCTION
    #define WARNING     NOP_FUNCTION
    #define ERR         NOP_FUNCTION

    #define ASSERT(cond)

    #define ASSERTMSG(cond, msg)
    #define RIP(msg)
    #define DBGMSG(level, prefix, msg)
    #define DBGPRINT(level, msg)

#endif




/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

BOOL DebugMessage(LPCSTR, ...);
BOOL DebugMessage(LPCWSTR, ...);
void Dump(PPUBLISHERINFO pPublisherInfo);
void Dump(POEMDMPARAM pOemDMParam);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\common\kmode.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:       KMode.h
//
//
//  PURPOSE:    Definitions and routines for compiling kernel mode instead of user mode.
//
//  PLATFORMS:
//    Windows NT
//
//

#ifndef _KMODE_H
#define _KMODE_H


// Define from ntdef.h in Win2K SDK.
// NT 4 may not have this defined
// in the public headers.
#ifndef NOP_FUNCTION
  #if (_MSC_VER >= 1210)
    #define NOP_FUNCTION __noop
  #else
    #define NOP_FUNCTION (void)0
  #endif
#endif



#ifdef USERMODE_DRIVER

//
// User mode difinitions to get rid of defines for kernel mode.
//

// Don't need critical section in user mode.

#define DECLARE_CRITICAL_SECTION    ;
#define INIT_CRITICAL_SECTION()     NOP_FUNCTION
#define DELETE_CRITICAL_SECTION()   NOP_FUNCTION
#define IS_VALID_CRITICAL_SECTION() (TRUE)


#else // !USERMODE_DRIVER


////////////////////////////////////////////////////////
//      Kernel Mode Defines
////////////////////////////////////////////////////////

extern HSEMAPHORE ghOEMSemaphore;

#define DECLARE_CRITICAL_SECTION    HSEMAPHORE ghOEMSemaphore = NULL;
#define INIT_CRITICAL_SECTION()     ghOEMSemaphore = EngCreateSemaphore()
#define ENTER_CRITICAL_SECTION()    EngAcquireSemaphore(ghOEMSemaphore)
#define LEAVE_CRITICAL_SECTION()    EngReleaseSemaphore(ghOEMSemaphore)
#define DELETE_CRITICAL_SECTION()   EngDeleteSemaphore(ghOEMSemaphore)
#define IS_VALID_CRITICAL_SECTION() (NULL != ghOEMSemaphore)
#define DebugBreak                  EngDebugBreak

// Pool tag marker for memory marking memory allocations.
#define DRV_MEM_POOL_TAG    'meoD'

// Debug prefix that is outputted in the debug messages.
#define DEBUG_PREFIX        "OEMDLL: "


// Remap user mode functions that don't have kernel mode
// equivalents to functions that we implement ourselves.

#define OutputDebugStringA(pszMsg)  (MyDebugPrint(DEBUG_PREFIX, "%hs", pszMsg))
#define OutputDebugStringW(pszMsg)  (MyDebugPrint(DEBUG_PREFIX, "%ls", pszMsg))

#if !defined(_M_ALPHA) && !defined(_M_IA64)
    #define InterlockedIncrement        DrvInterlockedIncrement
    #define InterlockedDecrement        DrvInterlockedDecrement
#endif


#define SetLastError                NOP_FUNCTION
#define GetLastError                NOP_FUNCTION



////////////////////////////////////////////////////////
//      Kernel Mode Functions
////////////////////////////////////////////////////////

//
// Implement inline functions to replace user mode 
// functions that don't have kernel mode equivalents.
//


inline int __cdecl _purecall (void)
{
#ifdef DEBUG
    EngDebugBreak();
#endif

    return E_FAIL;
}


inline LONG DrvInterlockedIncrement(PLONG pRef)
{
    ENTER_CRITICAL_SECTION();

        ++(*pRef);

    LEAVE_CRITICAL_SECTION();


    return (*pRef);
}


inline LONG DrvInterlockedDecrement(PLONG pRef)
{
    ENTER_CRITICAL_SECTION();

        --(*pRef);

    LEAVE_CRITICAL_SECTION();


    return (*pRef);
}


inline void* __cdecl operator new(size_t nSize)
{
    // return pointer to allocated memory
    return  EngAllocMem(0, nSize, DRV_MEM_POOL_TAG);
}


inline void __cdecl operator delete(void *pMem)
{
    if(pMem)
        EngFreeMem(pMem);
}


inline VOID MyDebugPrint(PCHAR pszPrefix, PCHAR pszFormat, ...)
{
    va_list VAList;

    va_start(VAList, pszFormat);
    EngDebugPrint(DEBUG_PREFIX, pszFormat, VAList);
    va_end(VAList);

    return;
}



#endif // USERMODE_DRIVER


#endif // _KMODE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\themeui\intrface.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2001  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Intrface.cpp
//    
//
//  PURPOSE:  Implementation of interface for PScript5 and Unidrv5 UI plug-in.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP
//
//

#include "precomp.h"
#include <INITGUID.H>
#include <PRCOMOEM.H>

#include "oemui.h"
#include "debug.h"
#include "intrface.h"



////////////////////////////////////////////////////////
//      Internal Globals
////////////////////////////////////////////////////////

static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks



////////////////////////////////////////////////////////////////////////////////
//
// IOemUI body
//
IOemUI::~IOemUI()
{
    // Make sure that helper interface is released.
    if(NULL != m_pOEMHelp)
    {
        m_pOEMHelp->Release();
        m_pOEMHelp = NULL;
    }

    // If this instance of the object is being deleted, then the reference 
    // count should be zero.
    assert(0 == m_cRef);
}

HRESULT __stdcall IOemUI::QueryInterface(const IID& iid, void** ppv)
{    
    VERBOSE(DLLTEXT("IOemUI:QueryInterface entry.\r\n\r\n")); 
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        VERBOSE(DLLTEXT("IOemUI:Return pointer to IUnknown.\r\n\r\n")); 
    }
    else if (iid == IID_IPrintOemUI)
    {
        *ppv = static_cast<IPrintOemUI*>(this) ;
        VERBOSE(DLLTEXT("IOemUI:Return pointer to IPrintOemUI.\r\n")); 
    }
    else
    {
#if DBG
        TCHAR szOutput[80] = {0};
        StringFromGUID2(iid, szOutput, COUNTOF(szOutput)); // can not fail!
        WARNING(DLLTEXT("IOemUI::QueryInterface %s not supported.\r\n"), szOutput); 
#endif

        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemUI::AddRef()
{
    VERBOSE(DLLTEXT("IOemUI:AddRef entry.\r\n")); 
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemUI::Release() 
{
    VERBOSE(DLLTEXT("IOemUI:Release entry.\r\n")); 
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

HRESULT __stdcall IOemUI::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE(DLLTEXT("IOemUI:PublishDriverInterface entry.\r\n")); 

    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (m_pOEMHelp == NULL)
    {
        HRESULT hResult;


        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUI, (void** ) &(m_pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            m_pOEMHelp = NULL;

            return E_FAIL;
        }
    }

    return S_OK;
}

HRESULT __stdcall IOemUI::GetInfo(
    DWORD  dwMode,
    PVOID  pBuffer,
    DWORD  cbSize,
    PDWORD pcbNeeded)
{
    VERBOSE(DLLTEXT("IOemUI::GetInfo(%d) entry.\r\r\n"), dwMode);

    // Validate parameters.
    if( (NULL == pcbNeeded)
        ||
        ( (OEMGI_GETSIGNATURE != dwMode)
          &&
          (OEMGI_GETVERSION != dwMode)
          &&
          (OEMGI_GETPUBLISHERINFO != dwMode)
        )
      )
    {
        WARNING(DLLTEXT("IOemUI::GetInfo() exit pcbNeeded is NULL! ERROR_INVALID_PARAMETER\r\r\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    // Set expected buffer size and number of bytes written.
    *pcbNeeded = sizeof(DWORD);

    // Check buffer size is sufficient.
    if((cbSize < *pcbNeeded) || (NULL == pBuffer))
    {
        WARNING(DLLTEXT("IOemUI::GetInfo() exit insufficient buffer!\r\r\n"));
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return E_FAIL;
    }

    switch(dwMode)
    {
        // OEM DLL Signature
        case OEMGI_GETSIGNATURE:
            *(PDWORD)pBuffer = OEM_SIGNATURE;
            break;

        // OEM DLL version
        case OEMGI_GETVERSION:
            *(PDWORD)pBuffer = OEM_VERSION;
            break;

        // dwMode not supported.
        default:
            // Set written bytes to zero since nothing was written.
            WARNING(DLLTEXT("IOemUI::GetInfo() exit mode not supported.\r\r\n"));
            *pcbNeeded = 0;
            SetLastError(ERROR_NOT_SUPPORTED);
            return E_FAIL;
    }

    VERBOSE(DLLTEXT("IOemUI::GetInfo() exit S_OK, (*pBuffer is %#x).\r\r\n"), *(PDWORD)pBuffer);
    return S_OK;
}

HRESULT __stdcall IOemUI::DevMode(
    DWORD  dwMode,
    POEMDMPARAM pOemDMParam)
{   
    VERBOSE(DLLTEXT("IOemUI:DevMode(%d, %#x) entry.\r\n"), dwMode, pOemDMParam); 

    return hrOEMDevMode(dwMode, pOemDMParam);
}

HRESULT __stdcall IOemUI::CommonUIProp(
    DWORD  dwMode,
    POEMCUIPPARAM   pOemCUIPParam)
{
    VERBOSE(DLLTEXT("IOemUI:CommonUIProp entry.\r\n")); 

    return hrOEMPropertyPage(dwMode, pOemCUIPParam);
}


HRESULT __stdcall IOemUI::DocumentPropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam)
{
    VERBOSE(DLLTEXT("IOemUI:DocumentPropertySheets entry.\r\n")); 

    return hrOEMDocumentPropertySheets(pPSUIInfo, lParam, m_pOEMHelp);
}

HRESULT __stdcall IOemUI::DevicePropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam)
{
    VERBOSE(DLLTEXT("IOemUI:DevicePropertySheets entry.\r\n")); 

    return hrOEMDevicePropertySheets(pPSUIInfo, lParam);
}

HRESULT __stdcall IOemUI::DeviceCapabilities(
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult)
{
    VERBOSE(DLLTEXT("IOemUI:DeviceCapabilities entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUI::DevQueryPrintEx(
    POEMUIOBJ               poemuiobj,
    PDEVQUERYPRINT_INFO     pDQPInfo,
    PDEVMODE                pPublicDM,
    PVOID                   pOEMDM)
{
    VERBOSE(DLLTEXT("IOemUI:DevQueryPrintEx entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUI::UpgradePrinter(
    DWORD   dwLevel,
    PBYTE   pDriverUpgradeInfo)
{
    VERBOSE(DLLTEXT("IOemUI:UpgradePrinter entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUI::PrinterEvent(
    PWSTR   pPrinterName,
    INT     iDriverEvent,
    DWORD   dwFlags,
    LPARAM  lParam)
{
    VERBOSE(DLLTEXT("IOemUI:PrinterEvent entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IOemUI::DriverEvent(
    DWORD   dwDriverEvent,
    DWORD   dwLevel,
    LPBYTE  pDriverInfo,
    LPARAM  lParam)
{
    VERBOSE(DLLTEXT("IOemUI:DriverEvent entry.\r\n"));

    return E_NOTIMPL;
};


#define PROFILE_NAME    L"OEMPROFILE.icm\0"

HRESULT __stdcall IOemUI::QueryColorProfile(
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulQueryMode,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData)
{
    HRESULT Result = E_FAIL;


    VERBOSE(DLLTEXT("IOemUI:QueryColorProfile entry.\r\n"));


    if(QCP_DEVICEPROFILE == ulQueryMode)
    {
        if(NULL == pvProfileData)
        {
            *pcbProfileData = sizeof(PROFILE_NAME);
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
        }
        else
        {
            if(*pcbProfileData < sizeof(PROFILE_NAME))
            {
                *pcbProfileData = sizeof(PROFILE_NAME);
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
            }
            else
            {
                lstrcpynW((LPWSTR)pvProfileData, PROFILE_NAME, *pcbProfileData);
                *pcbProfileData = sizeof(PROFILE_NAME);
                *pflProfileData = QCP_PROFILEDISK;

                Result = S_OK;
            }
        }
    }

    return Result;
};

HRESULT __stdcall IOemUI::FontInstallerDlgProc(
        HWND    hWnd,
        UINT    usMsg,
        WPARAM  wParam,
        LPARAM  lParam) 
{
    VERBOSE(DLLTEXT("IOemUI:FontInstallerDlgProc entry.\r\n"));

    return E_NOTIMPL;
};

HRESULT __stdcall IOemUI::UpdateExternalFonts(
        HANDLE  hPrinter,
        HANDLE  hHeap,
        PWSTR   pwstrCartridges)
{
    VERBOSE(DLLTEXT("IOemUI:UpdateExternalFonts entry.\r\n"));

    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// oem class factory
//
class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this) ;
    }
    else
    {
#if DBG && defined(USERMODE_DRIVER)
        TCHAR szOutput[80] = {0};
        StringFromGUID2(iid, szOutput, COUNTOF(szOutput)); // can not fail!
        WARNING(DLLTEXT("IOemCF::QueryInterface %s not supported.\r\n"), szOutput); 
#endif

        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCF::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    //DbgPrint(DLLTEXT("Class factory:\t\tCreate component.")) ;

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IOemUI* pOemCB = new IOemUI ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }
    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv) ;

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release() ;
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks) ;
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks) ;
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Exported functions
//


// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    VERBOSE(DLLTEXT("DllGetClassObject:Create class factory.\r\n"));

    // Can we create this component?
    if (clsid != CLSID_OEMUI)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv) ;
    pFontCF->Release() ;

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\common\oem.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997, 1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Debug.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debug.cpp.
//
//  PLATFORMS:
//    Windows NT
//
//
#ifndef _OEM_H
#define _OEM_H



////////////////////////////////////////////////////////
//      OEM Defines
////////////////////////////////////////////////////////

#define OEM_SIGNATURE   'MSFT'
#define OEM_VERSION     0x00000001L



////////////////////////////////////////////////////////
//      OEM Type Definitions
////////////////////////////////////////////////////////



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\themeui\precomp.h ===
//    
//
//  PURPOSE:	Header files that should be in the precompiled header.

//
//  PLATFORMS:
//    Windows NT
//
//
#ifndef _PRECOMP_H
#define _PRECOMP_H


// Necessary for compiling under VC.
#if(!defined(WINVER) || (WINVER < 0x0500))
	#undef WINVER
	#define WINVER          0x0500
#endif
#if(!defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500))
	#undef _WIN32_WINNT
	#define _WIN32_WINNT    0x0500
#endif

// Isolation define for using ComCtrl v6.
#ifndef ISOLATION_AWARE_ENABLED
    #define ISOLATION_AWARE_ENABLED
#endif


// Required header files that shouldn't change often.


#include <STDDEF.H>
#include <STDLIB.H>
#include <OBJBASE.H>
#include <STDARG.H>
#include <STDIO.H>
#include <WINDEF.H>
#include <WINERROR.H>
#include <WINBASE.H>
#include <WINGDI.H>
#include <WINDDI.H>
#include <WINSPOOL.H>
#include <TCHAR.H>
#include <EXCPT.H>
#include <ASSERT.H>
#include <PRSHT.H>
#include "COMPSTUI.H"
#include <WINDDIUI.H>
#include <PRINTOEM.H>
#include <COMMCTRL.H>


#define COUNTOF(p)  (sizeof(p)/sizeof(*(p)))


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkps\command.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997, 1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:  Command.h
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for OEM Command function(s).
//
//  PLATFORMS:
//
//    Windows NT
//
//
#ifndef _COMMAND_H
#define _COMMAND_H




/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

BOOL PSCommand(PDEVOBJ, DWORD, PVOID, DWORD, IPrintOemDriverPS*);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\themeui\oemui.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997 - 2001  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    OEMUI.cpp
//    
//
//  PURPOSE:  Main file for OEM UI test module.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP
//
//

#include "precomp.h"
#include "resource.h"
#include "debug.h"
#include "fusutils.h"
#include "oemui.h"



////////////////////////////////////////////////////////
//      INTERNAL MACROS and DEFINES
////////////////////////////////////////////////////////

typedef struct _tagCBUserData 
{
    HANDLE          hComPropSheet;
    HANDLE          hPropPage;
    POEMUIPSPARAM   pOEMUIParam;
    PFNCOMPROPSHEET pfnComPropSheet;

} CBUSERDATA, *PCBUSERDATA;



////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static HRESULT hrDocumentPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam);
static HRESULT hrPrinterPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam);
LONG APIENTRY OEMPrinterUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam);
LONG APIENTRY OEMDocUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam);
LONG APIENTRY OEMDocUICallBack(PCPSUICBPARAM pCallbackParam);
BOOL APIENTRY DevicePropPageProc(HWND hDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);
static POPTITEM CreateOptItems(HANDLE hHeap, DWORD dwOptItems);
static void InitOptItems(POPTITEM pOptItems, DWORD dwOptItems);
static POPTTYPE CreateOptType(HANDLE hHeap, WORD wOptParams);
static PTSTR GetStringResource(HANDLE hHeap, HANDLE hModule, UINT uResource);



////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems to display OEM device or document property UI.
//
HRESULT hrOEMPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
    HRESULT hResult = S_OK;


    VERBOSE(DLLTEXT("hrOEMPropertyPage(%d) entry.\r\n"), dwMode);

    // Validate parameters.
    if( (OEMCUIP_DOCPROP != dwMode)
        &&
        (OEMCUIP_PRNPROP != dwMode)        
      )
    {
        ERR(ERRORTEXT("hrOEMPropertyPage() ERROR_INVALID_PARAMETER.\r\n"));
        VERBOSE(DLLTEXT("\tdwMode = %d, pOEMUIParam = %#lx.\r\n"), dwMode, pOEMUIParam);

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    switch(dwMode)
    {
        case OEMCUIP_DOCPROP:
            hResult = hrDocumentPropertyPage(dwMode, pOEMUIParam);
            break;

        case OEMCUIP_PRNPROP:
            hResult = hrPrinterPropertyPage(dwMode, pOEMUIParam);
            break;

        default:
            // Should never reach this!
            ERR(ERRORTEXT("hrOEMPropertyPage() Invalid dwMode, %d"), dwMode);
            SetLastError(ERROR_INVALID_PARAMETER);
            hResult = E_FAIL;
            break;
    }

    return hResult;
}

////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems to display OEM document property UI.
//
static HRESULT hrDocumentPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
    if(NULL == pOEMUIParam->pOEMOptItems)
    {
        // Fill in the number of OptItems to create for OEM document property UI.
        pOEMUIParam->cOEMOptItems = 1;

        VERBOSE(DLLTEXT("hrDocumentPropertyPage() requesting %d number of items.\r\n"), pOEMUIParam->cOEMOptItems);
    }
    else
    {
        POEMDEV pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;


        VERBOSE(DLLTEXT("hrDocumentPropertyPage() fill out %d items.\r\n"), pOEMUIParam->cOEMOptItems);

        // Init UI Callback reference.
        pOEMUIParam->OEMCUIPCallback = OEMDocUICallBack;

        // Init OEMOptItmes.
        InitOptItems(pOEMUIParam->pOEMOptItems, pOEMUIParam->cOEMOptItems);

        // Fill out tree view items.

        // New section.
        pOEMUIParam->pOEMOptItems[0].Level  = 1;
        pOEMUIParam->pOEMOptItems[0].Flags  = OPTIF_COLLAPSE;
        pOEMUIParam->pOEMOptItems[0].pName  = GetStringResource(pOEMUIParam->hOEMHeap, pOEMUIParam->hModule, IDS_SECTION);
        pOEMUIParam->pOEMOptItems[0].Sel    = pOEMDev->dwDriverData;

        pOEMUIParam->pOEMOptItems[0].pOptType = CreateOptType(pOEMUIParam->hOEMHeap, 2);

        pOEMUIParam->pOEMOptItems[0].pOptType->Type                 = TVOT_UDARROW;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].IconID  = 0;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].lParam  = 100;
    }

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems to display OEM printer property UI.
//
static HRESULT hrPrinterPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
    if(NULL == pOEMUIParam->pOEMOptItems)
    {
        // Fill in the number of OptItems to create for OEM printer property UI.
        pOEMUIParam->cOEMOptItems = 1;

        VERBOSE(DLLTEXT("hrPrinterPropertyPage() requesting %d number of items.\r\n"), pOEMUIParam->cOEMOptItems);
    }
    else
    {
        DWORD   dwError;
        DWORD   dwDeviceValue;
        DWORD   dwType;
        DWORD   dwNeeded;


        VERBOSE(DLLTEXT("hrPrinterPropertyPage() fill out %d items.\r\n"), pOEMUIParam->cOEMOptItems);

        // Get device settings value from printer.
        dwError = GetPrinterData(pOEMUIParam->hPrinter, OEMUI_VALUE, &dwType, (PBYTE) &dwDeviceValue,
                                   sizeof(dwDeviceValue), &dwNeeded);
        if( (ERROR_SUCCESS != dwError)
            ||
            (dwDeviceValue > 100)
          )
        {
            // Failed to get the device value or value is invalid, just use the default.
            dwDeviceValue = 0;
        }

        // Init UI Callback reference.
        pOEMUIParam->OEMCUIPCallback = OEMPrinterUICallBack;

        // Init OEMOptItmes.
        InitOptItems(pOEMUIParam->pOEMOptItems, pOEMUIParam->cOEMOptItems);

        // Fill out tree view items.

        // New section.
        pOEMUIParam->pOEMOptItems[0].Level  = 1;
        pOEMUIParam->pOEMOptItems[0].Flags  = OPTIF_COLLAPSE;
        pOEMUIParam->pOEMOptItems[0].pName  = GetStringResource(pOEMUIParam->hOEMHeap, pOEMUIParam->hModule, IDS_SECTION);
        pOEMUIParam->pOEMOptItems[0].Sel    = dwDeviceValue;

        pOEMUIParam->pOEMOptItems[0].pOptType = CreateOptType(pOEMUIParam->hOEMHeap, 2);

        pOEMUIParam->pOEMOptItems[0].pOptType->Type                 = TVOT_UDARROW;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].IconID  = 0;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].lParam  = 100;
    }

    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//
// Adds property page to Document property sheet.
//
HRESULT hrOEMDocumentPropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam, 
                                    IPrintOemDriverUI*  pOEMHelp)
{
    LONG_PTR    lResult;


    VERBOSE(DLLTEXT("OEMDocumentPropertySheets() entry.\r\n"));

    // Validate parameters.
    if( (NULL == pPSUIInfo)
        ||
        (PROPSHEETUI_INFO_VERSION != pPSUIInfo->Version)
      )
    {
        ERR(ERRORTEXT("OEMDocumentPropertySheets() ERROR_INVALID_PARAMETER.\r\n"));

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return  E_FAIL;
    }

    // Do action.
    switch(pPSUIInfo->Reason)
    {
        case PROPSHEETUI_REASON_INIT:
            {
                DWORD           dwSheets        = 0;
                PCBUSERDATA     pUserData;
                POEMUIPSPARAM   pOEMUIParam     = (POEMUIPSPARAM) pPSUIInfo->lParamInit;
                HANDLE          hHeap           = pOEMUIParam->hOEMHeap;
                POEMDEV         pOEMDev         = (POEMDEV) pOEMUIParam->pOEMDM;
                COMPROPSHEETUI  Sheet;


                // Init property page.
                memset(&Sheet, 0, sizeof(COMPROPSHEETUI));
                Sheet.cbSize            = sizeof(COMPROPSHEETUI);
                Sheet.Flags             = CPSUIF_UPDATE_PERMISSION;
                Sheet.hInstCaller       = ghInstance;
                Sheet.pCallerName       = GetStringResource(hHeap, ghInstance, IDS_NAME);
                Sheet.pHelpFile         = NULL;
                Sheet.pfnCallBack       = OEMDocUICallBack;
                Sheet.pDlgPage          = CPSUI_PDLGPAGE_TREEVIEWONLY;
                Sheet.cOptItem          = 1;
                Sheet.IconID            = IDI_CPSUI_PRINTER;
                Sheet.pOptItemName      = GetStringResource(hHeap, ghInstance, IDS_SECTION);
                Sheet.CallerVersion     = 0x100;
                Sheet.OptItemVersion    = 0x100;

                // Init user data.
                pUserData = (PCBUSERDATA) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(CBUSERDATA));
                pUserData->hComPropSheet    = pPSUIInfo->hComPropSheet;
                pUserData->pfnComPropSheet  = pPSUIInfo->pfnComPropSheet;
                pUserData->pOEMUIParam      = pOEMUIParam;
                Sheet.UserData              = (ULONG_PTR) pUserData;

                // Create OptItems for page.
                Sheet.pOptItem = CreateOptItems(hHeap, Sheet.cOptItem);

                // Initialize OptItems
                Sheet.pOptItem[0].Level     = 1;
                Sheet.pOptItem[0].Flags     = OPTIF_COLLAPSE;
                Sheet.pOptItem[0].pName     = GetStringResource(hHeap, ghInstance, IDS_SECTION);
                Sheet.pOptItem[0].Sel       = pOEMDev->dwDriverData;

                Sheet.pOptItem[0].pOptType = CreateOptType(hHeap, 2);

                Sheet.pOptItem[0].pOptType->Type                    = TVOT_UDARROW;
                Sheet.pOptItem[0].pOptType->pOptParam[1].IconID     = 0;
                Sheet.pOptItem[0].pOptType->pOptParam[1].lParam     = 100;

                // NOTE: Don't need to do anything with Activation Contexts
                //       to get Themed UI, since Compstui will create this 
                //       page using it's Activation Context which specifies
                //       comctl v6.

                // Add property sheets.
                lResult = pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet, CPSFUNC_ADD_PCOMPROPSHEETUI, 
                                                     (LPARAM)&Sheet, (LPARAM)&dwSheets);
            }
            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:
            {
                PPROPSHEETUI_INFO_HEADER    pHeader = (PPROPSHEETUI_INFO_HEADER) lParam;

                pHeader->pTitle = (LPTSTR)PROP_TITLE;
                lResult = TRUE;
            }
            break;

        case PROPSHEETUI_REASON_GET_ICON:
            // No icon
            lResult = 0;
            break;

        case PROPSHEETUI_REASON_SET_RESULT:
            {
                PSETRESULT_INFO pInfo = (PSETRESULT_INFO) lParam;

                lResult = pInfo->Result;
            }
            break;

        case PROPSHEETUI_REASON_DESTROY:
            lResult = TRUE;
            break;
    }

    pPSUIInfo->Result = lResult;
    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//
// Adds property page to printer property sheet.
//
HRESULT hrOEMDevicePropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam)
{
    LONG_PTR    lResult;


    VERBOSE(DLLTEXT("hrOEMDevicePropertySheets(%#x, %#x) entry\r\n"), pPSUIInfo, lParam);

    // Validate parameters.
    if( (NULL == pPSUIInfo)
        ||
        (PROPSHEETUI_INFO_VERSION != pPSUIInfo->Version)
      )
    {
        ERR(ERRORTEXT("hrOEMDevicePropertySheets() ERROR_INVALID_PARAMETER.\r\n"));

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    Dump(pPSUIInfo);

    // Do action.
    switch(pPSUIInfo->Reason)
    {
        case PROPSHEETUI_REASON_INIT:
            {
                HANDLE          hActCtx;
                PROPSHEETPAGE   Page;

                // Init property page.
                memset(&Page, 0, sizeof(PROPSHEETPAGE));
                Page.dwSize         = sizeof(PROPSHEETPAGE);
                Page.dwFlags        = PSP_DEFAULT;
                Page.hInstance      = ghInstance;
                Page.pszTemplate    = MAKEINTRESOURCE(IDD_DEVICE_PROPPAGE);
                Page.pfnDlgProc     = (DLGPROC) DevicePropPageProc;
                Page.hActCtx        = GetMyActivationContext();

                // Set the flag to indicate that our PROPSHEETPAGE
                // has an Activation Context.
                // The Activation Context indicates with version of
                // comctl for Compstui to create our PROPSHEETPAGE
                // with. To get Themed UI we need to specify comctl v6.
                if( (NULL != Page.hActCtx) && (INVALID_HANDLE_VALUE != Page.hActCtx))
                {
                    Page.dwFlags |= PSP_USEFUSIONCONTEXT;
                }

                // Add property sheets.
                lResult = pPSUIInfo->pfnComPropSheet(pPSUIInfo->hComPropSheet, CPSFUNC_ADD_PROPSHEETPAGE, (LPARAM)&Page, 0);

                // NOTE: The Activation Context is released when the DLL is unloaded 
                //       during DLL_PROCESS_DETACH.

                VERBOSE(DLLTEXT("hrOEMDevicePropertySheets() pfnComPropSheet returned %d.\r\n"), lResult);
            }
            break;

        case PROPSHEETUI_REASON_GET_INFO_HEADER:
            {
                PPROPSHEETUI_INFO_HEADER    pHeader = (PPROPSHEETUI_INFO_HEADER) lParam;

                pHeader->pTitle = (LPTSTR)PROP_TITLE;
                lResult = TRUE;
            }
            break;

        case PROPSHEETUI_REASON_GET_ICON:
            // No icon
            lResult = 0;
            break;

        case PROPSHEETUI_REASON_SET_RESULT:
            {
                PSETRESULT_INFO pInfo = (PSETRESULT_INFO) lParam;

                lResult = pInfo->Result;
            }
            break;

        case PROPSHEETUI_REASON_DESTROY:
            lResult = TRUE;
            break;
    }

    pPSUIInfo->Result = lResult;
    return S_OK;
}


////////////////////////////////////////////////////////////////////////////////
//
// OptItems call back for OEM printer property UI.
//
LONG APIENTRY OEMPrinterUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam)
{
    LONG    lReturn = CPSUICB_ACTION_NONE;
    POEMDEV pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;


    VERBOSE(DLLTEXT("OEMPrinterUICallBack() entry, Reason is %d.\r\n"), pCallbackParam->Reason);

    switch(pCallbackParam->Reason)
    {
        case CPSUICB_REASON_APPLYNOW:
            {
                DWORD   dwDriverValue = pOEMUIParam->pOEMOptItems[0].Sel;

                // Store OptItems state in printer data.
                SetPrinterData(pOEMUIParam->hPrinter, OEMUI_VALUE, REG_DWORD, (PBYTE) &dwDriverValue, sizeof(DWORD));
            }
            break;

        default:
            break;
    }

    return lReturn;
}


////////////////////////////////////////////////////////////////////////////////
//
// Call back for OEM device property UI.
//
BOOL APIENTRY DevicePropPageProc(HWND hDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uiMsg)
    {
        case WM_COMMAND:
            switch(HIWORD(wParam))
            {
                case BN_CLICKED:
                    switch(LOWORD(wParam))
                    {
                        case IDC_CALIBRATE:
                            // Just display a message that the printer is calibrated,
                            // since we don't acutally calibrate anything.
                            {
                                TCHAR   szName[MAX_PATH];
                                TCHAR   szCalibrated[MAX_PATH];


                                LoadString(ghInstance, IDS_NAME, szName, sizeof(szName));
                                LoadString(ghInstance, IDS_CALIBRATED, szCalibrated, sizeof(szCalibrated));
                                MessageBox(hDlg, szCalibrated, szName, MB_OK);
                            }
                            break;
                    }
                    break;

                default:
                    return FALSE;
            }
            return TRUE;

        case WM_NOTIFY:
            {
                switch (((LPNMHDR)lParam)->code)  // type of notification message
                {
                    case PSN_SETACTIVE:
                        break;
    
                    case PSN_KILLACTIVE:
                        break;

                    case PSN_APPLY:
                        break;

                    case PSN_RESET:
                        break;
                }
            }
            break;
    }

    return FALSE;
} 


////////////////////////////////////////////////////////////////////////////////
//
// OptItems call back for OEM document property UI.
//
LONG APIENTRY OEMDocUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam)
{
    LONG    lReturn = CPSUICB_ACTION_NONE;
    POEMDEV pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;


    VERBOSE(DLLTEXT("OEMDocUICallBack() entry, Reason is %d.\r\n"), pCallbackParam->Reason);

    switch(pCallbackParam->Reason)
    {
        case CPSUICB_REASON_APPLYNOW:
            // Store OptItems state in DEVMODE.
            pOEMDev->dwDriverData = pOEMUIParam->pOEMOptItems[0].Sel;
            break;

        case CPSUICB_REASON_KILLACTIVE:
            pOEMDev->dwDriverData = pOEMUIParam->pOEMOptItems[0].Sel;
            break;

        case CPSUICB_REASON_SETACTIVE:
            pOEMUIParam->pOEMOptItems[0].Sel    = pOEMDev->dwDriverData;
            pOEMUIParam->pOEMOptItems[0].Flags |= OPTIF_CHANGED;
            lReturn                             = CPSUICB_ACTION_OPTIF_CHANGED;
            break;

        default:
            break;
    }

    return lReturn;
}


LONG APIENTRY OEMDocUICallBack(PCPSUICBPARAM pCallbackParam)
{
    LONG            lReturn = CPSUICB_ACTION_NONE;
    PCBUSERDATA     pUserData = (PCBUSERDATA) pCallbackParam->UserData;
    POEMDEV         pOEMDev = (POEMDEV) pUserData->pOEMUIParam->pOEMDM;


    VERBOSE(DLLTEXT("OEMDocUICallBack() entry, Reason is %d.\r\n"), pCallbackParam->Reason);

    switch(pCallbackParam->Reason)
    {
        case CPSUICB_REASON_APPLYNOW:
            pOEMDev->dwDriverData = pCallbackParam->pOptItem[0].Sel;
            pUserData->pfnComPropSheet(pUserData->hComPropSheet, CPSFUNC_SET_RESULT,
            	                       (LPARAM)pUserData->hPropPage,
               	                       (LPARAM)CPSUI_OK);
            break;

        case CPSUICB_REASON_KILLACTIVE:
            pOEMDev->dwDriverData = pCallbackParam->pOptItem[0].Sel;
            break;

        case CPSUICB_REASON_SETACTIVE:
            pCallbackParam->pOptItem[0].Sel     = pOEMDev->dwDriverData;
            pCallbackParam->pOptItem[0].Flags  |= OPTIF_CHANGED;
            lReturn                             = CPSUICB_ACTION_OPTIF_CHANGED;
            break;

        default:
            break;
    }

    return lReturn;
}


////////////////////////////////////////////////////////////////////////////////
//
// Creates and Initializes OptItems.
//
static POPTITEM CreateOptItems(HANDLE hHeap, DWORD dwOptItems)
{
    POPTITEM    pOptItems = NULL;


    // Allocate memory for OptItems;
    pOptItems = (POPTITEM) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(OPTITEM) * dwOptItems);
    if(NULL != pOptItems)
    {
        InitOptItems(pOptItems, dwOptItems);
    }
    else
    {
        ERR(ERRORTEXT("CreateOptItems() failed to allocate memory for OPTITEMs!\r\n"));
    }

    return pOptItems;
}


////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems.
//
static void InitOptItems(POPTITEM pOptItems, DWORD dwOptItems)
{
    VERBOSE(DLLTEXT("InitOptItems() entry.\r\n"));

    // Zero out memory.
    memset(pOptItems, 0, sizeof(OPTITEM) * dwOptItems);

    // Set each OptItem's size, and Public DM ID.
    for(DWORD dwCount = 0; dwCount < dwOptItems; dwCount++)
    {
        pOptItems[dwCount].cbSize   = sizeof(OPTITEM);
        pOptItems[dwCount].DMPubID  = DMPUB_NONE;
    }
}


////////////////////////////////////////////////////////////////////////////////
//
// Allocates and initializes OptType for OptItem.
//
static POPTTYPE CreateOptType(HANDLE hHeap, WORD wOptParams)
{
    POPTTYPE    pOptType = NULL;


    VERBOSE(DLLTEXT("CreateOptType() entry.\r\n"));

    // Allocate memory from the heap for the OPTTYPE; the driver will take care of clean up.
    pOptType = (POPTTYPE) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(OPTTYPE));
    if(NULL != pOptType)
    {
        // Initialize OPTTYPE.
        pOptType->cbSize    = sizeof(OPTTYPE);
        pOptType->Count     = wOptParams;

        // Allocate memory from the heap for the OPTPARAMs for the OPTTYPE.
        pOptType->pOptParam = (POPTPARAM) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, wOptParams * sizeof(OPTPARAM));
        if(NULL != pOptType->pOptParam)
        {
            // Initialize the OPTPARAMs.
            for(WORD wCount = 0; wCount < wOptParams; wCount++)
            {
                pOptType->pOptParam[wCount].cbSize = sizeof(OPTPARAM);
            }
        }
        else
        {
            ERR(ERRORTEXT("CreateOptType() failed to allocated memory for OPTPARAMs!\r\n"));

            // Free allocated memory and return NULL.
            HeapFree(hHeap, 0, pOptType);
            pOptType = NULL;
        }
    }
    else
    {
        ERR(ERRORTEXT("CreateOptType() failed to allocated memory for OPTTYPE!\r\n"));
    }

    return pOptType;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  Retrieves pointer to a String resource.
//
static PTSTR GetStringResource(HANDLE hHeap, HANDLE hModule, UINT uResource)
{
    int     nResult;
    DWORD   dwSize = MAX_PATH;
    PTSTR   pszString = NULL;


    VERBOSE(DLLTEXT("GetStringResource(%#x, %#x, %d) entered.\r\n"), hHeap, hModule, uResource);

    // Allocate buffer for string resource from heap; let the driver clean it up.
    pszString = (PTSTR) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwSize * sizeof(TCHAR));
    if(NULL != pszString)
    {
        // Load string resource; resize after loading so as not to waste memory.
        nResult = LoadString((HMODULE)hModule, uResource, pszString, dwSize);
        if(nResult > 0)
        {
            PTSTR   pszTemp;


            VERBOSE(DLLTEXT("LoadString() returned %d!\r\n"), nResult);
            VERBOSE(DLLTEXT("String load was \"%s\".\r\n"), pszString);

            pszTemp = (PTSTR) HeapReAlloc(hHeap, HEAP_ZERO_MEMORY, pszString, (nResult + 1) * sizeof(TCHAR));
            if(NULL != pszTemp)
            {
                pszString = pszTemp;
            }
            else
            {
                ERR(ERRORTEXT("GetStringResource() HeapReAlloc() of string retrieved failed! (Last Error was %d)\r\n"), GetLastError());
            }
        }
        else
        {
            ERR(ERRORTEXT("LoadString() returned %d! (Last Error was %d)\r\n"), nResult, GetLastError());
            ERR(ERRORTEXT("GetStringResource() failed to load string resource %d!\r\n"), uResource);

            pszString = NULL;
        }
    }
    else
    {
        ERR(ERRORTEXT("GetStringResource() failed to allocate string buffer!\r\n"));
    }

    return pszString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\common\devmode.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Devmode.cpp
//    
//
//  PURPOSE:  Implementation of Devmode functions shared with OEM UI and OEM rendering modules.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows NT
//
//

#include "debug.h"
#include "devmode.h"
#include "kmode.h"



HRESULT hrOEMDevMode(DWORD dwMode, POEMDMPARAM pOemDMParam)
{
    POEMDEV pOEMDevIn;
    POEMDEV pOEMDevOut;


    // Verify parameters.
    if( (NULL == pOemDMParam)
        ||
        ( (OEMDM_SIZE != dwMode)
          &&
          (OEMDM_DEFAULT != dwMode)
          &&
          (OEMDM_CONVERT != dwMode)
          &&
          (OEMDM_MERGE != dwMode)
        )
      )
    {
        ERR(ERRORTEXT("DevMode() ERROR_INVALID_PARAMETER.\r\n"));
        VERBOSE(DLLTEXT("\tdwMode = %d, pOemDMParam = %#lx.\r\n"), dwMode, pOemDMParam);

        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    // Cast generic (i.e. PVOID) to OEM private devomode pointer type.
    pOEMDevIn = (POEMDEV) pOemDMParam->pOEMDMIn;
    pOEMDevOut = (POEMDEV) pOemDMParam->pOEMDMOut;

    switch(dwMode)
    {
        case OEMDM_SIZE:
            pOemDMParam->cbBufSize = sizeof(OEMDEV);
            break;

        case OEMDM_DEFAULT:
            pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
            pOEMDevOut->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
            pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
            pOEMDevOut->bEnabled                = WATER_MARK_DEFAULT_ENABLED;
            pOEMDevOut->dfRotate                = WATER_MARK_DEFAULT_ROTATION;
            pOEMDevOut->dwFontSize              = WATER_MARK_DEFAULT_FONTSIZE;
            pOEMDevOut->crTextColor             = WATER_MARK_DEFAULT_COLOR;
            wcscpy(pOEMDevOut->szWaterMark, WATER_MARK_DEFAULT_TEXT);
            VERBOSE(DLLTEXT("pOEMDevOut after setting default values:\r\n"));
            Dump(pOEMDevOut);
            break;

        case OEMDM_CONVERT:
            ConvertOEMDevmode(pOEMDevIn, pOEMDevOut);
            break;

        case OEMDM_MERGE:
            ConvertOEMDevmode(pOEMDevIn, pOEMDevOut);
            MakeOEMDevmodeValid(pOEMDevOut);
            break;
    }
    Dump(pOemDMParam);

    return S_OK;
}


BOOL ConvertOEMDevmode(PCOEMDEV pOEMDevIn, POEMDEV pOEMDevOut)
{
    if( (NULL == pOEMDevIn)
        ||
        (NULL == pOEMDevOut)
      )
    {
        ERR(ERRORTEXT("ConvertOEMDevmode() invalid parameters.\r\n"));
        return FALSE;
    }

    // Check OEM Signature, if it doesn't match ours,
    // then just assume DMIn is bad and use defaults.
    if(pOEMDevIn->dmOEMExtra.dwSignature == pOEMDevOut->dmOEMExtra.dwSignature)
    {
        VERBOSE(DLLTEXT("Converting private OEM Devmode.\r\n"));
        VERBOSE(DLLTEXT("pOEMDevIn:\r\n"));
        Dump(pOEMDevIn);

        // Set the devmode defaults so that anything the isn't copied over will
        // be set to the default value.
        pOEMDevOut->bEnabled                = WATER_MARK_DEFAULT_ENABLED;
        pOEMDevOut->dfRotate                = WATER_MARK_DEFAULT_ROTATION;
        pOEMDevOut->dwFontSize              = WATER_MARK_DEFAULT_FONTSIZE;
        pOEMDevOut->crTextColor             = WATER_MARK_DEFAULT_COLOR;
        wcscpy(pOEMDevOut->szWaterMark, WATER_MARK_DEFAULT_TEXT);

        // Copy the old structure in to the new using which ever size is the smaller.
        // Devmode maybe from newer Devmode (not likely since there is only one), or
        // Devmode maybe a newer Devmode, in which case it maybe larger,
        // but the first part of the structure should be the same.

        // DESIGN ASSUMPTION: the private DEVMODE structure only gets added to;
        // the fields that are in the DEVMODE never change only new fields get added to the end.

        memcpy(pOEMDevOut, pOEMDevIn, __min(pOEMDevOut->dmOEMExtra.dwSize, pOEMDevIn->dmOEMExtra.dwSize));

        // Re-fill in the size and version fields to indicated 
        // that the DEVMODE is the current private DEVMODE version.
        pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
        pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
    }
    else
    {
        WARNING(DLLTEXT("Unknown DEVMODE signature, pOEMDMIn ignored.\r\n"));

        // Don't know what the input DEVMODE is, so just use defaults.
        pOEMDevOut->dmOEMExtra.dwSize       = sizeof(OEMDEV);
        pOEMDevOut->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
        pOEMDevOut->dmOEMExtra.dwVersion    = OEM_VERSION;
        pOEMDevOut->bEnabled                = WATER_MARK_DEFAULT_ENABLED;
        pOEMDevOut->dfRotate                = WATER_MARK_DEFAULT_ROTATION;
        pOEMDevOut->dwFontSize              = WATER_MARK_DEFAULT_FONTSIZE;
        pOEMDevOut->crTextColor             = WATER_MARK_DEFAULT_COLOR;
        wcscpy(pOEMDevOut->szWaterMark, WATER_MARK_DEFAULT_TEXT);
    }

    return TRUE;
}


BOOL MakeOEMDevmodeValid(POEMDEV pOEMDevmode)
{
    if(NULL == pOEMDevmode)
    {
        return FALSE;
    }

    // ASSUMPTION: pOEMDevmode is large enough to contain OEMDEV structure.

    // Make sure that dmOEMExtra indicates the current OEMDEV structure.
    pOEMDevmode->dmOEMExtra.dwSize       = sizeof(OEMDEV);
    pOEMDevmode->dmOEMExtra.dwSignature  = OEM_SIGNATURE;
    pOEMDevmode->dmOEMExtra.dwVersion    = OEM_VERSION;

    // bEnable should be either TRUE or FALSE.
    if( (TRUE != pOEMDevmode->bEnabled)
        &&
        (FALSE != pOEMDevmode->bEnabled)
      )
    {
        pOEMDevmode->bEnabled = WATER_MARK_DEFAULT_ENABLED;
    }

    // dfRotate should be between 0 and 360 inclusive.
    if( (0 > pOEMDevmode->dfRotate) 
        ||
        (360 < pOEMDevmode->dfRotate) 
      )
    {
        pOEMDevmode->dfRotate = WATER_MARK_DEFAULT_ROTATION;
    }

    // dwFontSize should be 8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, or 72.
    if(!IsValidFontSize(pOEMDevmode->dwFontSize))
    {
        pOEMDevmode->dwFontSize = WATER_MARK_DEFAULT_FONTSIZE;
    }

    // The high byte of the hi word should be zero.
    if(0 != HIBYTE(HIWORD(pOEMDevmode->crTextColor)))
    {
        pOEMDevmode->crTextColor = WATER_MARK_DEFAULT_COLOR;
    }

    // Make sure that water mark string is terminated.
    pOEMDevmode->szWaterMark[WATER_MARK_TEXT_SIZE - 1] = L'\0';

    return TRUE;
}


BOOL IsValidFontSize(DWORD dwFontSize)
{
    BOOL    bValid = FALSE;


    switch(dwFontSize)
    {
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 14:
        case 16:
        case 18:
        case 20:
        case 22:
        case 24:
        case 26:
        case 28:
        case 36:
        case 48:
        case 72:
            bValid = TRUE;
            break;

        default:
            ERR(ERRORTEXT("IsValidFontSize() found invalid font size %d\r\n"), dwFontSize);
            break;
    }

    return bValid;
}


void Dump(PCOEMDEV pOEMDevmode)
{
    if( (NULL != pOEMDevmode)
        &&
        (pOEMDevmode->dmOEMExtra.dwSize >= sizeof(OEMDEV))
        &&
        (OEM_SIGNATURE == pOEMDevmode->dmOEMExtra.dwSignature)
      )
    {
        VERBOSE(__TEXT("\tdmOEMExtra.dwSize      = %d\r\n"), pOEMDevmode->dmOEMExtra.dwSize);
        VERBOSE(__TEXT("\tdmOEMExtra.dwSignature = %#x\r\n"), pOEMDevmode->dmOEMExtra.dwSignature);
        VERBOSE(__TEXT("\tdmOEMExtra.dwVersion   = %#x\r\n"), pOEMDevmode->dmOEMExtra.dwVersion);
        VERBOSE(__TEXT("\tbEnabled               = %#x\r\n"), pOEMDevmode->bEnabled);
        VERBOSE(__TEXT("\tdfRotate               = %2.2f\r\n"), pOEMDevmode->dfRotate);
        VERBOSE(__TEXT("\tdwFontSize             = %d\r\n"), pOEMDevmode->dwFontSize);
        VERBOSE(__TEXT("\tcrTextColor            = RGB(%d, %d, %d)\r\n"), 
                 GetRValue(pOEMDevmode->crTextColor), 
                 GetGValue(pOEMDevmode->crTextColor),
                 GetBValue(pOEMDevmode->crTextColor));
        VERBOSE(__TEXT("\tszWaterMark            = \"%ls\"\r\n"), pOEMDevmode->szWaterMark);
    }
    else
    {
        ERR(ERRORTEXT("Dump(POEMDEV) unknown private OEM DEVMODE.\r\n"));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\themeui\oemui.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997 - 2001  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	OEMUI.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for OEMUI Test Module.
//
//  PLATFORMS:
//    Windows 2000, Windows XP
//
//

#ifndef _OEMUI_H
#define _OEMUI_H

#include <PRCOMOEM.H>

#include "OEM.H"
#include "DEVMODE.H"
#include "globals.h"


////////////////////////////////////////////////////////
//      OEM UI Defines
////////////////////////////////////////////////////////


// OEM Signature and version.
#define PROP_TITLE      L"OEM UI Page"
#define DLLTEXT(s)      __TEXT("UI:  ") __TEXT(s)

// OEM UI Misc defines.
#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)


// Printer registry keys where OEM data is stored.
#define OEMUI_VALUE             TEXT("OEMUI_VALUE")
#define OEMUI_DEVICE_VALUE      TEXT("OEMUI_DEVICE_VALUE")



////////////////////////////////////////////////////////
//      Prototypes
////////////////////////////////////////////////////////

HRESULT hrOEMPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam);
HRESULT hrOEMDocumentPropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam, IPrintOemDriverUI*  pOEMHelp);
HRESULT hrOEMDevicePropertySheets(PPROPSHEETUI_INFO pPSUIInfo, LPARAM lParam);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\themeui\intrface.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998 - 2001  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Intrface.h
//    
//
//  PURPOSE:  Header of interface for PScript5 and Unidrv5 UI plug-in.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 2000, Windows XP
//
//



////////////////////////////////////////////////////////////////////////////////
//
// IOemUI
//
class IOemUI: public IPrintOemUI
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD  dwMode, PVOID  pBuffer, DWORD  cbSize,
                           PDWORD pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_  DWORD  dwMode, POEMDMPARAM pOemDMParam) ;

    //
    // OEMCommonUIProp
    //

    STDMETHOD(CommonUIProp) (THIS_  
            DWORD  dwMode, 
            POEMCUIPPARAM   pOemCUIPParam
            );

    //
    // OEMDocumentPropertySheets
    //

    STDMETHOD(DocumentPropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            );

    //
    // OEMDevicePropertySheets
    //

    STDMETHOD(DevicePropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            );


    //
    // OEMDevQueryPrintEx
    //

    STDMETHOD(DevQueryPrintEx) (THIS_
            POEMUIOBJ               poemuiobj,
            PDEVQUERYPRINT_INFO     pDQPInfo,
            PDEVMODE                pPublicDM,
            PVOID                   pOEMDM
            );

    //
    // OEMDeviceCapabilities
    //

    STDMETHOD(DeviceCapabilities) (THIS_
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult
            );

    //
    // OEMUpgradePrinter
    //

    STDMETHOD(UpgradePrinter) (THIS_
            DWORD   dwLevel,
            PBYTE   pDriverUpgradeInfo
            );

    //
    // OEMPrinterEvent
    //

    STDMETHOD(PrinterEvent) (THIS_
            PWSTR   pPrinterName,
            INT     iDriverEvent,
            DWORD   dwFlags,
            LPARAM  lParam
            );

    //
    // OEMDriverEvent
    //

    STDMETHOD(DriverEvent)(THIS_
            DWORD   dwDriverEvent,
            DWORD   dwLevel,
            LPBYTE  pDriverInfo,
            LPARAM  lParam
            );
 
    //
    // OEMQueryColorProfile
    //

    STDMETHOD( QueryColorProfile) (THIS_
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulReserved,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData);

    //
    // OEMFontInstallerDlgProc
    //

    STDMETHOD(FontInstallerDlgProc) (THIS_ 
            HWND    hWnd,
            UINT    usMsg,
            WPARAM  wParam,
            LPARAM  lParam
            );
    //
    // UpdateExternalFonts
    //

    STDMETHOD(UpdateExternalFonts) (THIS_
            HANDLE  hPrinter,
            HANDLE  hHeap,
            PWSTR   pwstrCartridges
            );


    IOemUI() { m_cRef = 1; m_pOEMHelp = NULL; };
    ~IOemUI();

protected:
    LONG                m_cRef;
    IPrintOemDriverUI*  m_pOEMHelp;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\common\devmode.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Devmode.h
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for devmode functions.
//
//  PLATFORMS:
//
//    Windows NT
//
//
#ifndef _DEVMODE_H
#define _DEVMODE_H


////////////////////////////////////////////////////////
//      OEM Devmode Defines
////////////////////////////////////////////////////////

#define WATER_MARK_TEXT_SIZE            128
#define WATER_MARK_DEFAULT_ENABLED      TRUE
#define WATER_MARK_DEFAULT_ROTATION     30
#define WATER_MARK_DEFAULT_FONTSIZE     28
#define WATER_MARK_DEFAULT_COLOR        RGB(230, 230, 230)
#define WATER_MARK_DEFAULT_TEXT         L"WaterMark"



////////////////////////////////////////////////////////
//      OEM Devmode Type Definitions
////////////////////////////////////////////////////////

typedef struct tagOEMDEV
{
    OEM_DMEXTRAHEADER   dmOEMExtra;
    BOOL                bEnabled;
    DOUBLE              dfRotate;
    DWORD               dwFontSize;
    COLORREF            crTextColor;
    WCHAR               szWaterMark[WATER_MARK_TEXT_SIZE];

} OEMDEV, *POEMDEV;

typedef const OEMDEV *PCOEMDEV;



/////////////////////////////////////////////////////////
//		ProtoTypes
/////////////////////////////////////////////////////////

HRESULT hrOEMDevMode(DWORD dwMode, POEMDMPARAM pOemDMParam);
BOOL ConvertOEMDevmode(PCOEMDEV pOEMDevIn, POEMDEV pOEMDevOut);
BOOL MakeOEMDevmodeValid(POEMDEV pOEMDevmode);
BOOL IsValidFontSize(DWORD dwFontSize);
void Dump(PCOEMDEV pOEMDevIn);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkps\fdebug.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	fDebug.cpp
//    
//
//  PURPOSE:  Place holder for including debug functions.
//
//
//	Functions:
//
//		FormatLastError()
//      DebugMessage()
//      DebugMsg()
//
//
//  PLATFORMS:	Windows 95, Windows NT
//
//

#include "precomp.h"

#include <DEBUG.CPP>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkps\fdevmode.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	fDevmode.cpp
//    
//
//  PURPOSE:  Place holder file for devmode functions.
//
//
//	Functions:
//
//
//
//  PLATFORMS:	Windows NT
//
//

#include "precomp.h"
#include "wmarkps.h"
#include <DEVMODE.CPP>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkps\dllentry.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	dllentry.cpp
//    
//
//  PURPOSE:  Source module for DLL entry function(s).
//
//
//	Functions:
//
//		DllMain
//
//
//  PLATFORMS:	Windows NT
//
//

#include "precomp.h"
#include "wmarkps.h"
#include "debug.h"
#include "kmode.h"


// Used in kernel mode implementation to declare a critical section.
// Need to similate InterlockedIncrement and InterlockedDecrement
// by using a semaphore, since these functions don't
// exist in kernel mode.
DECLARE_CRITICAL_SECTION;



// Need to export these functions as c declarations.
extern "C" {


///////////////////////////////////////////////////////////
//
// DLL entry point
//

// DllMain isn't called/used for kernel mode version.
BOOL WINAPI DllMain(HINSTANCE hInst, WORD wReason, LPVOID lpReserved)
{
	switch(wReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(DLLTEXT("Process attach.\r\n"));
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(DLLTEXT("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(DLLTEXT("Process detach.\r\n"));
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(DLLTEXT("Thread detach.\r\n"));
			break;
	}

	return TRUE;
}


// DllInitialize isn't called/used for user mode version.
BOOL WINAPI DllInitialize(ULONG ulReason)
{
    BOOL    bRet = TRUE;

	switch(ulReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(DLLTEXT("Process attach.\r\n"));

            // In kernel mode version, initializes semaphore.
            INIT_CRITICAL_SECTION();
            bRet = IS_VALID_CRITICAL_SECTION();
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(DLLTEXT("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(DLLTEXT("Process detach.\r\n"));

            // In kernel mode version, deletes semaphore.
            DELETE_CRITICAL_SECTION();
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(DLLTEXT("Thread detach.\r\n"));
			break;
	}

	return bRet;
}



}  // extern "C" closing bracket
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkps\command.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	command.cpp
//    
//
//  PURPOSE:  Source module for OEM customized Command(s).
//
//
//	Functions:
//
//		
//
//
//  PLATFORMS:	Windows NT
//
//

#include "precomp.h"
#include <PRCOMOEM.H>
#include "wmarkps.h"
#include "debug.h"
#include "command.h"
#include "resource.h"
#include "kmode.h"




/////////////////////////////////////////////////////////
//		Internal Macros & Defines
/////////////////////////////////////////////////////////

// Macros to convert from Windows RGB to PostScript RGB
#define GetPS2Color(dw)     ((dw) / 255.0)
#define GetPS2RValue(cr)    (GetPS2Color(GetRValue(cr)))
#define GetPS2GValue(cr)    (GetPS2Color(GetGValue(cr)))
#define GetPS2BValue(cr)    (GetPS2Color(GetBValue(cr)))


// Initial buffer size
#define INITIAL_BUFFER_SIZE     16


// String format defines characters
#define FORMAT_DELIM            '!'
#define FORMAT_STRING_ANSI      's'
#define FORMAT_STRING_UNICODE   'S'
#define FORMAT_CHAR             '%'


// Loop limiter.
#define MAX_LOOP    10


/////////////////////////////////////////////////////////
//		Internal ProtoTypes
/////////////////////////////////////////////////////////

static PSTR GetPostScriptResource(HMODULE hModule, LPCTSTR pszResource, PDWORD pdwSize);
static PSTR CreateWaterMarkProlog(HMODULE hModule, PDWORD pdwSize, LPWSTR pszWaterMark, 
                                  DWORD dwFontSize, LPSTR pszColor, LPSTR pszAngle);
static PSTR DoWaterMarkProlog(HMODULE hModule, POEMDEV pOemDevmode, PDWORD pdwSize);
static DWORD FormatResource(LPSTR pszResource, LPSTR *ppszProlog, ...);
static DWORD FormatString(LPSTR pszBuffer, LPSTR pszFormat, PDWORD pdwSize, va_list vaList);
static DWORD CharSize(DWORD dwValue, DWORD dwBase = 10);



////////////////////////////////////////////////////////////////////////////////////
//    The PSCRIPT driver calls this OEM function at specific points during output
//    generation. This gives the OEM DLL an opportunity to insert code fragments
//    at specific injection points in the driver's code. It should use
//    DrvWriteSpoolBuf for generating any output it requires.

BOOL PSCommand(PDEVOBJ pdevobj, DWORD dwIndex, PVOID pData, DWORD cbSize, IPrintOemDriverPS* pOEMHelp)
{
    BOOL    bFreeProcedure = FALSE;
    PSTR    pProcedure = NULL;
    DWORD   dwLen = 0;
    DWORD   dwSize = 0;


    VERBOSE(DLLTEXT("Entering OEMCommand...\r\n"));

    switch (dwIndex)
    {
        case PSINJECT_BEGINPROLOG:
            {
                POEMDEV pOemDevmode = (POEMDEV) pdevobj->pOEMDM;


                VERBOSE(DLLTEXT("OEMCommand PSINJECT_BEGINPROLOG\r\n"));

                // Only do Water Mark PS prolog injection if Water Mark is enabled.
                if(pOemDevmode->bEnabled)
                {
                    pProcedure = DoWaterMarkProlog((HMODULE) pdevobj->hOEM, pOemDevmode, &dwSize);
                    bFreeProcedure = (NULL != pProcedure);
                }
            }
            break;

        case PSINJECT_BEGINPAGESETUP:
            {
                POEMDEV pOemDevmode = (POEMDEV) pdevobj->pOEMDM;


                VERBOSE(DLLTEXT("OEMCommand PSINJECT_BEGINPAGESETUP\r\n"));

                // Only do Water Mark PS page injection if Water Mark is enabled.
                if(pOemDevmode->bEnabled)
                {
                    pProcedure = GetPostScriptResource((HMODULE) pdevobj->hOEM, MAKEINTRESOURCE(IDR_WATERMARK_DRAW), &dwSize);
                }
            }
            break;

        default:
            VERBOSE(DLLTEXT("Entering No (PSCommand Default, command index %d)...\r\n"), dwIndex);
            return TRUE;
    }

    if(NULL != pProcedure)
    {
        // Write PostScript to spool file.
        dwLen = strlen(pProcedure);
        pOEMHelp->DrvWriteSpoolBuf(pdevobj, pProcedure, dwLen, &dwSize);

        // Dump DrvWriteSpoolBuf parameters.
        VERBOSE(DLLTEXT("dwLen  = %d\r\n"), dwLen);
        VERBOSE(DLLTEXT("dwSize = %d\r\n"), dwSize);
        //VERBOSE(DLLTEXT("pProcedure is:\r\n\t%hs\r\n"), pProcedure);

        if(bFreeProcedure)
        {
            // INVARIANT: pProcedure was created with 'new' and needs to be freed.
            delete pProcedure;
        }
    }
    else
    {
        ERR(DLLTEXT("PSCommand pProcedure is NULL!\r\n"));
    }

    // dwLen should always equal dwSize.
    assert(dwLen == dwSize);

    return (dwLen == dwSize);
}


////////////////////////////////////////////////////////////////////////////////////
//
//  Retrieves pointer to a PostScript resource.
//
static PSTR GetPostScriptResource(HMODULE hModule, LPCTSTR pszResource, PDWORD pdwSize)
{
    PSTR    pszPostScript = NULL;

#ifdef USERMODE_DRIVER

    HRSRC   hFind;
    HGLOBAL hResource;


    VERBOSE(DLLTEXT("GetPostScriptResource() entered.\r\n"));

    // pszResource and pdwSize Parameters should not be NULL.
    assert(NULL != pszResource);
    assert(NULL != pdwSize);

    // Load PostScript resource.
    hFind = FindResource(hModule, pszResource, MAKEINTRESOURCE(RC_PSCRIPT));
    //hFind = FindResource(hModule, pszResource, __TEXT("PSCRIPT"));    
    if(NULL != hFind)
    {
        hResource = LoadResource(hModule, hFind);
        if(NULL != hResource)
        {
            pszPostScript = (PSTR) LockResource(hResource);
            *pdwSize = SizeofResource(hModule, hFind);
        }
        else
        {
            ERR(DLLTEXT("ERROR:  Failed to load PSCRIPT resource %#x!\r\n"), hFind);
        }
    }
    else
    {
        ERR(DLLTEXT("ERROR:  Failed to find PSCRIPT resource %#x!\r\n"), pszResource);
    }

#else

    EngDebugBreak();
    pszPostScript = (PSTR) EngFindResource(EngLoadModule, (int) pszResource, RC_PSCRIPT, pdwSize);

    //pszPostScript = "%% EngFindResource called here!\r\n";

    VERBOSE(DLLTEXT("EngFindResource(%#x, %d, %d, %d) returned %#x!\r\n"), hModule, 
             (int) pszResource, RC_PSCRIPT, *pdwSize, pszPostScript);

#endif //USERMODE_DRIVER


    // Should have found the PScript resource.
    assert(NULL != pszPostScript);

    VERBOSE(DLLTEXT("GetPostScriptResource() returned %#x.\r\n"), pszPostScript);

    return pszPostScript;
}


////////////////////////////////////////////////////////////////////////////////////
//
//  Formats Water Mark prolog with parameter.
//
static PSTR CreateWaterMarkProlog(HMODULE hModule, PDWORD pdwSize, LPWSTR pszWaterMark, 
                                  DWORD dwFontSize, LPSTR pszColor, LPSTR pszAngle)
{
    PSTR    pszProlog = NULL;
    PSTR    pszResource;


    // Parameters that are pointers should not be NULL!
    assert(NULL != pdwSize);
    assert(NULL != pszWaterMark);
    assert(NULL != pszColor);
    assert(NULL != pszAngle);

    // Dump parameters.
    VERBOSE(DLLTEXT("CreateWaterMarkProlog() paramters:\r\n"));
    VERBOSE(_TEXT("\tpszWaterMark = \"%ls\"\r\n"), pszWaterMark);
    VERBOSE(_TEXT("\tdwFontSize   = %d\r\n"), dwFontSize);
    VERBOSE(_TEXT("\tpszColor     = \"%hs\"\r\n"), pszColor);
    VERBOSE(_TEXT("\tpszAngle     = \"%hs\"\r\n"), pszAngle);

    // Get Water Mark prolog resource.
    pszResource = GetPostScriptResource(hModule, MAKEINTRESOURCE(IDR_WATERMARK_PROLOGUE), pdwSize);
    assert(NULL != pszResource);

    // Allocate and format the Water Mark Prolog with the correct values.
    if(NULL != pszResource)
    {
        *pdwSize = FormatResource(pszResource, &pszProlog, pszWaterMark, dwFontSize, pszColor, pszAngle);
    }

    // Returned values should not be NULL.
    assert(0 != *pdwSize);
    assert(NULL != pszProlog);

    VERBOSE(_TEXT("\t*pdwSize     = %d\r\n"), *pdwSize);

    return pszProlog;
}


////////////////////////////////////////////////////////////////////////////////////
//
//  Does the pre-formating of parameters before calling the routine 
//  that creates the prolog.
//
static PSTR DoWaterMarkProlog(HMODULE hModule, POEMDEV pOemDevmode, PDWORD pdwSize)
{
    PSTR    pszProlog = NULL;


    // Parameters should not be NULL.
    assert(NULL != hModule);
    assert(NULL != pOemDevmode);
    assert(NULL != pdwSize);

    // Only do prolog if Water Mark is enabled.
    if(pOemDevmode->bEnabled)
    {
        CHAR    szColor[INITIAL_BUFFER_SIZE] = "\0";
        DWORD   dwAngleSize = INITIAL_BUFFER_SIZE;
        LPSTR   pszAngle = NULL;

        // Format angle as a string.
        do
        {
            if(NULL != pszAngle)
            {
                delete[] pszAngle;
                dwAngleSize *= 2;
            }
            pszAngle = new CHAR[dwAngleSize];

        } while( (NULL != pszAngle) 
                 &&
                 (dwAngleSize < 1024)
                 && 
                 (_snprintf(pszAngle, dwAngleSize, "%.1f", pOemDevmode->dfRotate) < 0) 
               );

        // pszAngle should only be NULL if we run out of memory.
        assert(NULL != pszAngle);

        if(NULL != pszAngle)
        {
            // Format text color as string.
            _snprintf(szColor, sizeof(szColor), "%1.2f %1.2f %1.2f", GetPS2RValue(pOemDevmode->crTextColor),
                      GetPS2GValue(pOemDevmode->crTextColor), GetPS2BValue(pOemDevmode->crTextColor));

            // Create Water Mark prolog.
            pszProlog = CreateWaterMarkProlog(hModule, pdwSize, pOemDevmode->szWaterMark, 
                                              pOemDevmode->dwFontSize, szColor, pszAngle);
            // Angle string is no longer needed.
            delete[] pszAngle;
        }
    }

    return pszProlog;
}


////////////////////////////////////////////////////////////////////////////////////
//
//  Formats Resource.
//
static DWORD FormatResource(LPSTR pszResource, LPSTR *ppszBuffer, ...)
{
    int     nCount;
    DWORD   dwSize  = strlen(pszResource) + MAX_PATH;
    DWORD   dwLoop  = 0;
    va_list vaList;


    va_start(vaList, ppszBuffer);

    // *ppszBuffer should be NULL when passed in.
    *ppszBuffer = NULL;

    // Allocate and format the string.
    do {

        if(NULL != *ppszBuffer)
        {
            delete[] *ppszBuffer;
        }
        *ppszBuffer = new CHAR[dwSize];
        if(NULL == *ppszBuffer)
        {
            nCount = 0;
            goto Cleanup;
        }

        nCount = _vsnprintf(*ppszBuffer, dwSize, pszResource, vaList);

        if(-1 == nCount)
        {
            dwSize *= 2;
        }

    } while ( (nCount != -1) && (dwLoop++ < MAX_LOOP));

Cleanup:

    // Check to see if we hit error.
    if(nCount <= 0)
    {
        nCount = 0;
        if(NULL != *ppszBuffer)
        {
            delete[] *ppszBuffer;
            *ppszBuffer = NULL;
        }
    }

    va_end(vaList);

    return (DWORD)nCount;
}


static DWORD FormatString(LPSTR pszBuffer, LPSTR pszFormat, PDWORD pdwSize, va_list vaList)
{
    BOOL    bFormat;
    DWORD   dwFormatSize;
    DWORD   dwBufferSize;
    DWORD   dwCount;


    VERBOSE(DLLTEXT("FormatString() entered\r\n"));

    // Validate parameters.
    if( (NULL == pdwSize)
        ||
        (NULL == pszFormat)
      )
    {
        WARNING(DLLTEXT("FormatString() leaving, INVALID PARAMETER.\r\n"));

        if(NULL != pdwSize)
        {
            *pdwSize = 0;
        }

        return FALSE;
    }

    // Get size of format string.
    // We need at least this bytes.
    dwFormatSize = strlen(pszFormat);

    // Setp through the format string looking 
    // for format charaters.
    // If pszBuffer isn't NULL, copy the bytes as we go.
    // If pszBuffer is NULL, then calculated the number of bytes needed.
    // May also need to calculate bytes needed if buffer not large enough.
    dwCount = 0;
    dwBufferSize = 0;
    bFormat = FALSE;
    while(dwCount < dwFormatSize) 
    {
        if(bFormat)
        {
            bFormat = FALSE;

            // Parse the format cammand.
            if(isdigit(pszFormat[dwCount]))
            {
                // The number specifies which parameter in vaList to use.
                // However, at the moment, we assume that the parameters
                // are used once and in order of the apparence in vaList, and
                // that number of parameters is less than 10.

                // Determine how the parameter in vaList should be used/inserted.
                // For this, we need to peek at the next charater(s).
                // Formats are encapsolated in exclamations.
                // If no exclamation, then we assume that the parameter type is PSTR.
                if( (dwCount + 3 >= dwFormatSize)
                    ||
                    (FORMAT_STRING_ANSI == pszFormat[dwCount + 2])
                    ||
                    (FORMAT_DELIM != pszFormat[dwCount + 1])
                    ||
                    (FORMAT_DELIM != pszFormat[dwCount + 3])
                  )
                {
                    PSTR    pszString;
                    DWORD   dwLen;


                    VERBOSE(DLLTEXT("FormatString() doing string format at %d.\r\n"), dwCount);
        
                    // Insert vaList parameter as string.
                    pszString = va_arg(vaList, PSTR);
                    dwLen =  strlen(pszString);
                    if( (NULL != pszBuffer)
                        &&
                        (dwBufferSize + dwLen < *pdwSize)
                      ) 
                    {
                        strcpy(pszBuffer + dwBufferSize, pszString);
                    }
                    dwBufferSize += dwLen;

                    // Fix up format counter.
                    if( (dwCount + 3 <= dwFormatSize)
                        &&
                        (FORMAT_DELIM == pszFormat[dwCount + 1])
                        &&
                        (FORMAT_DELIM == pszFormat[dwCount + 3])
                      )
                    {
                        dwCount += 3;
                    }
                }
                else
                {
                    // INVARIANT:  format is of form "%n!c!", where n is some number and c
                    //             is some character other than 'S'.

                    switch(pszFormat[dwCount + 2])
                    {
                        case 'd':
                        case 'D':
                            {
                                DWORD   dwLen;
                                DWORD   dwValue;


                                VERBOSE(DLLTEXT("FormatString() doing DWORD format at %d.\r\n"), dwCount);

                                // Treat vaList parameter as DWORD.
                                dwValue = va_arg(vaList, DWORD);
                                dwLen = CharSize(dwValue);
                                if( (NULL != pszBuffer)
                                    &&
                                    (dwBufferSize + dwLen < *pdwSize)
                                  )
                                {
                                    _ultoa(dwValue, pszBuffer + dwBufferSize, 10);
                                }
                                dwBufferSize += dwLen;
                            }
                            break;
                    }

                    // Fix up format counter.
                    dwCount += 3;
                }
            }
            else
            {
                // Just copy character and continue.
                if( (NULL != pszBuffer)
                    &&
                    (dwBufferSize + 1 < *pdwSize)
                  ) 
                {
                    pszBuffer[dwBufferSize] = pszFormat[dwCount];
                }
                ++dwBufferSize;
            }

        }
        else
        {
            // Copy characters while looking for format commands.
            if(FORMAT_CHAR == pszFormat[dwCount])
            {
                bFormat = TRUE;
            }
            else
            {
                if( (NULL != pszBuffer)
                    &&
                    (dwBufferSize + 1 < *pdwSize)
                  ) 
                {
                    pszBuffer[dwBufferSize] = pszFormat[dwCount];
                }
                ++dwBufferSize;
            }
        }

        ++dwCount;
    }

    // This is to account for NULL termination.
    if( (NULL == pszBuffer)
        ||
        (dwBufferSize + 1 > *pdwSize)
      )
    {
        ++dwBufferSize;
    }
    else
    {
        pszBuffer[dwBufferSize] = '\0';
    }

    // If buffer is NULL, or buffer not large enough,
    // return failure and size needed.
    if( (NULL == pszBuffer)
        ||
        (dwBufferSize > *pdwSize)
      )
    {
        *pdwSize = dwBufferSize;

        return FALSE;
    }

    // Return number of bytes written in buffer.
    return dwBufferSize;
}


DWORD CharSize(DWORD dwValue, DWORD dwBase)
{
    DWORD dwSize = 1;


    // Make sure taht base is more than 2.
    if(dwBase < 2)
    {
        return dwSize;
    }

    // Loop until dwValue is less than dwBase, 
    // dividing by dwBase each time.
    while(dwValue >= dwBase)
    {
        dwValue /= dwBase;
        ++dwSize;
    }

    return dwSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkps\precomp.h ===
//    
//
//  PURPOSE:	Header files that should be in the precompiled header.

//
//  PLATFORMS:
//    Windows NT
//
//
#ifndef _PRECOMP_H
#define _PRECOMP_H


// Necessary for compiling under VC.
#if(!defined(WINVER) || (WINVER < 0x0500))
	#undef WINVER
	#define WINVER          0x0500
#endif
#if(!defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500))
	#undef _WIN32_WINNT
	#define _WIN32_WINNT    0x0500
#endif


// Required header files that shouldn't change often.


#include <STDDEF.H>
#include <STDLIB.H>
#include <OBJBASE.H>
#include <STDARG.H>
#include <STDIO.H>
#include <WINDEF.H>
#include <WINERROR.H>
#include <WINBASE.H>
#include <WINGDI.H>
extern "C" 
{
    #include <WINDDI.H>
}
#include <TCHAR.H>
#include <EXCPT.H>
#include <ASSERT.H>
#include <PRINTOEM.H>


#define COUNTOF(p)  (sizeof(p)/sizeof(*(p)))


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkps\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by WMarkPS.rc
//
#define IDR_WATERMARK_PROLOGUE          1
#define IDR_WATERMARK_DRAW              2
#define RC_PSCRIPT                      0x5053

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkps\intrface.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Intrface.H
//    
//
//  PURPOSE:	Define COM interface for User Mode Printer Customization DLL.
//
//  PLATFORMS:
//
//    Windows NT
//
//
#ifndef _INTERFACE_H
#define _INTERFACE_H




////////////////////////////////////////////////////////////////////////////////
//
//  IWaterMarkPS
//
//  Interface for PostScript OEM sample rendering module
//
class IWaterMarkPS : public IPrintOemPS
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);


    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);
    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // OEMCommand - PSCRIPT only, return E_NOTIMPL on Unidrv
    //

    STDMETHOD(Command) (THIS_ PDEVOBJ     pdevobj,
                              DWORD       dwIndex,
                              PVOID       pData,
                              DWORD       cbSize,
                              OUT DWORD   *pdwResult);

    //

    IWaterMarkPS() { m_cRef = 1; m_pOEMHelp = NULL; };
    ~IWaterMarkPS();

protected:
    LONG                m_cRef;
    IPrintOemDriverPS*  m_pOEMHelp;
};





#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkui\globals.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Globals.h
//    
//
//  PURPOSE:   Lists of globals declared in Globals.cpp.
//
//
//  PLATFORMS:
//
//    Windows NT
//
//
#ifndef _GLOBALS_H
#define _GLOBALS_H


///////////////////////////////////////
//          Globals
///////////////////////////////////////

// Module's Instance handle from DLLEntry of process.
extern HINSTANCE   ghInstance;




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkps\intrface.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	Intrface.cpp
//    
//
//  PURPOSE:  Interface for User Mode COM Customization DLL.
//
//
//	Functions:
//
//		
//
//
//  PLATFORMS:	Windows NT
//
//

#include "precomp.h"
#include <INITGUID.H>
#include <PRCOMOEM.H>

#include "wmarkps.h"
#include "debug.h"
#include "command.h"
#include "intrface.h"
#include "kmode.h"    




////////////////////////////////////////////////////////
//      Internal Globals
////////////////////////////////////////////////////////

static long g_cComponents = 0;     // Count of active components
static long g_cServerLocks = 0;    // Count of locks






////////////////////////////////////////////////////////////////////////////////
//
// IWaterMarkPS body
//
IWaterMarkPS::~IWaterMarkPS()
{
    // Make sure that helper interface is released.
    if(NULL != m_pOEMHelp)
    {
        m_pOEMHelp->Release();
        m_pOEMHelp = NULL;
    }

    // If this instance of the object is being deleted, then the reference 
    // count should be zero.
    assert(0 == m_cRef);
}


HRESULT __stdcall IWaterMarkPS::QueryInterface(const IID& iid, void** ppv)
{    
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        VERBOSE(DLLTEXT("IWaterMarkPS::QueryInterface IUnknown.\r\n")); 
    }
    else if (iid == IID_IPrintOemPS)
    {
        *ppv = static_cast<IPrintOemPS*>(this);
        VERBOSE(DLLTEXT("IWaterMarkPS::QueryInterface IPrintOemPs.\r\n")); 
    }
    else
    {
#if DBG && defined(USERMODE_DRIVER)
        TCHAR szOutput[80] = {0};
        StringFromGUID2(iid, szOutput, COUNTOF(szOutput)); // can not fail!
        WARNING(DLLTEXT("IWaterMarkPS::QueryInterface %s not supported.\r\n"), szOutput); 
#endif
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

ULONG __stdcall IWaterMarkPS::AddRef()
{
    VERBOSE(DLLTEXT("IWaterMarkPS::AddRef() entry.\r\n"));
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IWaterMarkPS::Release() 
{
    VERBOSE(DLLTEXT("IWaterMarkPS::Release() entry.\r\n"));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}


HRESULT __stdcall IWaterMarkPS::GetInfo (
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE(DLLTEXT("IWaterMarkPS::GetInfo(%d) entry.\r\n"), dwMode);

    // Validate parameters.
    if( (NULL == pcbNeeded)
        ||
        ( (OEMGI_GETSIGNATURE != dwMode)
          &&
          (OEMGI_GETVERSION != dwMode)
          &&
          (OEMGI_GETPUBLISHERINFO != dwMode)
        )
      )
    {
        VERBOSE(DLLTEXT("IWaterMarkPS::GetInfo() exit pcbNeeded is NULL! ERROR_INVALID_PARAMETER\r\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    // Set expected buffer size.
    if(OEMGI_GETPUBLISHERINFO != dwMode)
    {
        *pcbNeeded = sizeof(DWORD);
    }
    else
    {
        *pcbNeeded = sizeof(PUBLISHERINFO);
        return E_FAIL;
    }

    // Check buffer size is sufficient.
    if((cbSize < *pcbNeeded) || (NULL == pBuffer))
    {
        WARNING(DLLTEXT("IWaterMarkPS::GetInfo() exit insufficient buffer!\r\n"));
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return E_FAIL;
    }

    switch(dwMode)
    {
        // OEM DLL Signature
        case OEMGI_GETSIGNATURE:
            *(PDWORD)pBuffer = OEM_SIGNATURE;
            break;

        // OEM DLL version
        case OEMGI_GETVERSION:
            *(PDWORD)pBuffer = OEM_VERSION;
            break;

        case OEMGI_GETPUBLISHERINFO:
            Dump((PPUBLISHERINFO)pBuffer);
            // Fall through to default case.

        // dwMode not supported.
        default:
            // Set written bytes to zero since nothing was written.
            WARNING(DLLTEXT("IWaterMarkPS::GetInfo() exit mode not supported.\r\n"));
            *pcbNeeded = 0;
            SetLastError(ERROR_NOT_SUPPORTED);
            return E_FAIL;
    }

    VERBOSE(DLLTEXT("IWaterMarkPS::GetInfo() exit S_OK, (*pBuffer is %#x).\r\n"), *(PDWORD)pBuffer);

    return S_OK;
}

HRESULT __stdcall IWaterMarkPS::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE(DLLTEXT("IWaterMarkPS::PublishDriverInterface() entry.\r\n"));

    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->m_pOEMHelp == NULL)
    {
        HRESULT hResult;


        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverPS, (void** ) &(this->m_pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->m_pOEMHelp = NULL;

            return E_FAIL;
        }
    }

    return S_OK;
}


HRESULT __stdcall IWaterMarkPS::EnableDriver(DWORD          dwDriverVersion,
                                    DWORD          cbSize,
                                    PDRVENABLEDATA pded)
{
    VERBOSE(DLLTEXT("IWaterMarkPS::EnableDriver() entry.\r\n"));

    // Need to return S_OK so that DisableDriver() will be called, which Releases
    // the reference to the Printer Driver's interface.
    return S_OK;
}

HRESULT __stdcall IWaterMarkPS::DisableDriver(VOID)
{
    VERBOSE(DLLTEXT("IWaterMarkPS::DisaleDriver() entry.\r\n"));

    // Release reference to Printer Driver's interface.
    if (this->m_pOEMHelp)
    {
        this->m_pOEMHelp->Release();
        this->m_pOEMHelp = NULL;
    }

    return S_OK;
}

HRESULT __stdcall IWaterMarkPS::DisablePDEV(
    PDEVOBJ         pdevobj)
{
    VERBOSE(DLLTEXT("IWaterMarkPS::DisablePDEV() entry.\r\n"));

    return E_NOTIMPL;
};

HRESULT __stdcall IWaterMarkPS::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
{
    VERBOSE(DLLTEXT("IWaterMarkPS::EnablePDEV() entry.\r\n"));

    return E_NOTIMPL;
}


HRESULT __stdcall IWaterMarkPS::ResetPDEV(
    PDEVOBJ         pdevobjOld,
    PDEVOBJ        pdevobjNew)
{
    VERBOSE(DLLTEXT("IWaterMarkPS::ResetPDEV() entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IWaterMarkPS::DevMode(
    DWORD  dwMode,
    POEMDMPARAM pOemDMParam)
{   
    VERBOSE(DLLTEXT("IWaterMarkPS:DevMode(%d, %#x) entry.\n"), dwMode, pOemDMParam); 
    return hrOEMDevMode(dwMode, pOemDMParam);
}

HRESULT __stdcall IWaterMarkPS::Command(
    PDEVOBJ     pdevobj,
    DWORD       dwIndex,
    PVOID       pData,
    DWORD       cbSize,
    OUT DWORD   *pdwResult)
{
    BOOL    bResult;


    VERBOSE(DLLTEXT("IWaterMarkPS::Command() entry.\r\n"));
    bResult = PSCommand(pdevobj, dwIndex, pData, cbSize, m_pOEMHelp);

    if(bResult)
    {
        *pdwResult = ERROR_SUCCESS;
        return S_OK;
    }

    *pdwResult = GetLastError();
    return S_FALSE;
}


////////////////////////////////////////////////////////////////////////////////
//
// oem class factory
//
class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);
   
    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{    
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this); 
    }
    else
    {
#if DBG && defined(USERMODE_DRIVER)
        TCHAR szOutput[80] = {0};
        StringFromGUID2(iid, szOutput, COUNTOF(szOutput)); // can not fail!
        WARNING(DLLTEXT("IOemCF::QueryInterface %s not supported.\r\n"), szOutput); 
#endif
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCF::Release() 
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv) 
{
    //VERBOSE(DLLTEXT("Class factory:\t\tCreate component."));

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION;
    }

    // Create component.
    IWaterMarkPS* pOemCP = new IWaterMarkPS;
    if (pOemCP == NULL)
    {
        return E_OUTOFMEMORY;
    }

    // Get the requested interface.
    HRESULT hr = pOemCP->QueryInterface(iid, ppv);

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCP->Release();
    return hr;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock) 
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks); 
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks);
    }
    return S_OK;
}


//
// Registration functions
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    VERBOSE(DLLTEXT("DllCanUnloadNow entered.\r\n"));

    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    VERBOSE(DLLTEXT("DllGetClassObject:\tCreate class factory.\r\n"));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkps\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.inc

    Abstract:

        This file specifies the target component being built and the list of
        sources files needed to build that component.  Also specifies optional
        compiler switches and libraries that are unique for the component being
        built.

!ENDIF

DLLBASE=0x70000000

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj


# To build version with debug output, add -DDEBUG to C_DEFINES line below
!if defined(WINNT_40)       # NT4 kernel-mode driver
C_DEFINES=$(C_DEFINES) -DKERNEL_MODE -D_UNICODE -DUNICODE -DWINNT_40 -DOEMCOM
!else                       # NT5 Drivers
C_DEFINES=$(C_DEFINES) -DKERNEL_MODE -D_UNICODE -DUNICODE -DOEMCOM
!endif


TARGETLIBS=  $(SDK_LIB_PATH)\uuid.lib


INCLUDES=..\..\common;..;$(SDK_INC_PATH)\MFC42

SOURCES= ..\dllentry.cpp    \
         ..\intrface.cpp    \
         ..\command.cpp     \
         ..\fdebug.cpp      \
         ..\fdevmode.cpp    \
         ..\wmarkps.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkps\wmarkps.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997, 1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	WMarkPS.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for debug.cpp.
//
//  PLATFORMS:
//    Windows NT
//
//
#ifndef _WMARKPS_H
#define _WMARKPS_H

#include <OEM.H>
#include <DEVMODE.H>


////////////////////////////////////////////////////////
//      OEM Defines
////////////////////////////////////////////////////////

#define DLLTEXT(s)      __TEXT("WMARKPS:  ") __TEXT(s)
#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkui\dllentry.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	dllentry.cpp
//    
//
//  PURPOSE:  Source module for DLL entry function(s).
//
//
//	Functions:
//
//		DllMain
//
//
//  PLATFORMS:	Windows NT
//
//

#include "precomp.h"
#include "wmarkui.h"
#include "debug.h"



// Need to export these functions as c declarations.
extern "C" {


///////////////////////////////////////////////////////////
//
// DLL entry point
//
BOOL WINAPI DllMain(HINSTANCE hInst, WORD wReason, LPVOID lpReserved)
{
	switch(wReason)
	{
		case DLL_PROCESS_ATTACH:
            VERBOSE(DLLTEXT("Process attach.\r\n"));
            ghInstance = hInst;
            break;

		case DLL_THREAD_ATTACH:
            VERBOSE(DLLTEXT("Thread attach.\r\n"));
			break;

		case DLL_PROCESS_DETACH:
            VERBOSE(DLLTEXT("Process detach.\r\n"));
			break;

		case DLL_THREAD_DETACH:
            VERBOSE(DLLTEXT("Thread detach.\r\n"));
			break;
	}

	return TRUE;
}


}  // extern "C" closing bracket
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkui\fdebug.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1996 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	fDebug.cpp
//    
//
//  PURPOSE:  Place holder file for debug functions.
//
//
//	Functions:
//
//		FormatLastError()
//      DebugMessage()
//      DebugMsg()
//
//
//  PLATFORMS:	Windows 95, Windows NT
//
//

#include "precomp.h"
#include <DEBUG.CPP>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkui\fdevmode.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	fDevmode.cpp
//    
//
//  PURPOSE:  Place holder file for devmode functions.
//
//
//	Functions:
//
//
//
//  PLATFORMS:	Windows NT
//
//

#include "precomp.h"
#include "wmarkui.h"
#include <DEVMODE.CPP>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkui\globals.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1998  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    Globals.cpp
//    
//
//  PURPOSE:  File that contains all the globals.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows NT
//
//
#define _GLOBALS_H

#include "precomp.h"
#include "wmarkui.h"



///////////////////////////////////////
//          Globals
///////////////////////////////////////

// Module's Instance handle from DLLEntry of process.
HINSTANCE   ghInstance = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkui\intrface.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

#include "precomp.h"
#include <INITGUID.H>
#include <PRCOMOEM.H>

#include "wmarkui.h"
#include "debug.h"
#include "intrface.h"



////////////////////////////////////////////////////////
//      Internal Globals
////////////////////////////////////////////////////////

static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks



////////////////////////////////////////////////////////////////////////////////
//
// IWaterMarkUI body
//
HRESULT __stdcall IWaterMarkUI::QueryInterface(const IID& iid, void** ppv)
{    
    VERBOSE(DLLTEXT("IWaterMarkUI:QueryInterface entry.\r\n\r\n")); 
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        VERBOSE(DLLTEXT("IWaterMarkUI:Return pointer to IUnknown.\r\n\r\n")); 
    }
    else if (iid == IID_IPrintOemUI)
    {
        *ppv = static_cast<IPrintOemUI*>(this) ;
        VERBOSE(DLLTEXT("IWaterMarkUI:Return pointer to IPrintOemUI.\r\n")); 
    }
    else
    {
#if DBG
        TCHAR szOutput[80] = {0};
        StringFromGUID2(iid, szOutput, COUNTOF(szOutput)); // can not fail!
        WARNING(DLLTEXT("IWaterMarkUI::QueryInterface %s not supported.\r\n"), szOutput); 
#endif
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IWaterMarkUI::AddRef()
{
    VERBOSE(DLLTEXT("IWaterMarkUI:AddRef entry.\r\n")); 
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IWaterMarkUI::Release() 
{
    VERBOSE(DLLTEXT("IWaterMarkUI:Release entry.\r\n")); 
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

HRESULT __stdcall IWaterMarkUI::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE(DLLTEXT("IWaterMarkUI:PublishDriverInterface entry.\r\n")); 

    // Don't use the DriverInterface, so don't store it.

    return S_OK;
}

HRESULT __stdcall IWaterMarkUI::GetInfo(
    DWORD  dwMode,
    PVOID  pBuffer,
    DWORD  cbSize,
    PDWORD pcbNeeded)
{
    VERBOSE(DLLTEXT("IWaterMarkUI::GetInfo(%d) entry.\r\r\n"), dwMode);

    // Validate parameters.
    if( (NULL == pcbNeeded)
        ||
        ( (OEMGI_GETSIGNATURE != dwMode)
          &&
          (OEMGI_GETVERSION != dwMode)
          &&
          (OEMGI_GETPUBLISHERINFO != dwMode)
        )
      )
    {
        VERBOSE(DLLTEXT("IWaterMarkUI::GetInfo() exit pcbNeeded is NULL!\r\r\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    // Set expected buffer size and number of bytes written.
    *pcbNeeded = sizeof(DWORD);

    // Check buffer size is sufficient.
    if((cbSize < *pcbNeeded) || (NULL == pBuffer))
    {
        WARNING(DLLTEXT("IWaterMarkUI::GetInfo() exit insufficient buffer!\r\r\n"));
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return E_FAIL;
    }

    switch(dwMode)
    {
        // OEM DLL Signature
        case OEMGI_GETSIGNATURE:
            *(PDWORD)pBuffer = OEM_SIGNATURE;
            break;

        // OEM DLL version
        case OEMGI_GETVERSION:
            *(PDWORD)pBuffer = OEM_VERSION;
            break;

        // dwMode not supported.
        default:
            // Set written bytes to zero since nothing was written.
            WARNING(DLLTEXT("IWaterMarkUI::GetInfo() exit mode not supported.\r\r\n"));
            *pcbNeeded = 0;
            SetLastError(ERROR_NOT_SUPPORTED);
            return E_FAIL;
    }

    VERBOSE(DLLTEXT("IWaterMarkUI::GetInfo() exit S_OK, (*pBuffer is %#x).\r\r\n"), *(PDWORD)pBuffer);
    return S_OK;
}

HRESULT __stdcall IWaterMarkUI::DevMode(
    DWORD  dwMode,
    POEMDMPARAM pOemDMParam)
{   
    VERBOSE(DLLTEXT("IWaterMarkUI:DevMode(%d, %#x) entry.\r\n"), dwMode, pOemDMParam); 

    return hrOEMDevMode(dwMode, pOemDMParam);
}

HRESULT __stdcall IWaterMarkUI::CommonUIProp(
    DWORD  dwMode,
    POEMCUIPPARAM   pOemCUIPParam)
{
    VERBOSE(DLLTEXT("IWaterMarkUI:CommonUIProp entry.\r\n")); 

    return hrOEMPropertyPage(dwMode, pOemCUIPParam);
}


HRESULT __stdcall IWaterMarkUI::DocumentPropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam)
{
    VERBOSE(DLLTEXT("IWaterMarkUI:DocumentPropertySheets entry.\r\n")); 

    return E_NOTIMPL;
}

HRESULT __stdcall IWaterMarkUI::DevicePropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam)
{
    VERBOSE(DLLTEXT("IWaterMarkUI:DevicePropertySheets entry.\r\n")); 

    return E_NOTIMPL;
}

HRESULT __stdcall IWaterMarkUI::DeviceCapabilities(
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult)
{
    VERBOSE(DLLTEXT("IWaterMarkUI:DeviceCapabilities entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IWaterMarkUI::DevQueryPrintEx(
    POEMUIOBJ               poemuiobj,
    PDEVQUERYPRINT_INFO     pDQPInfo,
    PDEVMODE                pPublicDM,
    PVOID                   pOEMDM)
{
    VERBOSE(DLLTEXT("IWaterMarkUI:DevQueryPrintEx entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IWaterMarkUI::UpgradePrinter(
    DWORD   dwLevel,
    PBYTE   pDriverUpgradeInfo)
{
    VERBOSE(DLLTEXT("IWaterMarkUI:UpgradePrinter entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IWaterMarkUI::PrinterEvent(
    PWSTR   pPrinterName,
    INT     iDriverEvent,
    DWORD   dwFlags,
    LPARAM  lParam)
{
    VERBOSE(DLLTEXT("IWaterMarkUI:PrinterEvent entry.\r\n"));

    return E_NOTIMPL;
}

HRESULT __stdcall IWaterMarkUI::DriverEvent(
    DWORD   dwDriverEvent,
    DWORD   dwLevel,
    LPBYTE  pDriverInfo,
    LPARAM  lParam)
{
    VERBOSE(DLLTEXT("IWaterMarkUI:DriverEvent entry.\r\n"));

    return E_NOTIMPL;
};


HRESULT __stdcall IWaterMarkUI::QueryColorProfile(
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulQueryMode,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData)
{ 
    VERBOSE(DLLTEXT("IWaterMarkUI:QueryColorProfile entry.\r\n"));

    return E_NOTIMPL;
};

HRESULT __stdcall IWaterMarkUI::FontInstallerDlgProc(
        HWND    hWnd,
        UINT    usMsg,
        WPARAM  wParam,
        LPARAM  lParam) 
{
    VERBOSE(DLLTEXT("IWaterMarkUI:FontInstallerDlgProc entry.\r\n"));

    return E_NOTIMPL;
};

HRESULT __stdcall IWaterMarkUI::UpdateExternalFonts(
        HANDLE  hPrinter,
        HANDLE  hHeap,
        PWSTR   pwstrCartridges)
{
    VERBOSE(DLLTEXT("IWaterMarkUI:UpdateExternalFonts entry.\r\n"));

    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////////////////
//
// oem class factory
//
class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this) ;
    }
    else
    {
#if DBG
        TCHAR szOutput[80] = {0};
        StringFromGUID2(iid, szOutput, COUNTOF(szOutput)); // can not fail!
        WARNING(DLLTEXT("IOemCF::QueryInterface %s not supported.\r\n"), szOutput); 
#endif
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef) ;
}

ULONG __stdcall IOemCF::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    //DbgPrint(DLLTEXT("Class factory:\t\tCreate component.")) ;

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IWaterMarkUI* pOemCB = new IWaterMarkUI ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }
    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv) ;

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release() ;
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks) ;
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks) ;
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Exported functions
//


// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    VERBOSE(DLLTEXT("DllGetClassObject:Create class factory.\r\n"));

    // Can we create this component?
    if (clsid != CLSID_OEMUI)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv) ;
    pFontCF->Release() ;

    return hr ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wmarkui.rc
//
#define IDS_WATERMARK                   1
#define IDS_TEXT                        2
#define IDS_FONTSIZE                    3
#define IDS_ANGLE                       4
#define IDS_COLOR                       5
#define IDS_GRAY                        6
#define IDS_RED                         7
#define IDS_GREEN                       8
#define IDS_BLUE                        9

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkui\precomp.h ===
//    
//
//  PURPOSE:	Header files that should be in the precompiled header.

//
//  PLATFORMS:
//    Windows NT
//
//
#ifndef _PRECOMP_H
#define _PRECOMP_H


// Necessary for compiling under VC.
#if(!defined(WINVER) || (WINVER < 0x0500))
	#undef WINVER
	#define WINVER          0x0500
#endif
#if(!defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500))
	#undef _WIN32_WINNT
	#define _WIN32_WINNT    0x0500
#endif

// Polymorphic types for Win32/Win64
// These don't exist for NT4.
#ifdef WINNT_40
    #define ULONG_PTR   ULONG
    #define LONG_PTR    LONG
#endif



// Required header files that shouldn't change often.


#include <STDDEF.H>
#include <STDLIB.H>
#include <OBJBASE.H>
#include <STDARG.H>
#include <STDIO.H>
#include <WINDEF.H>
#include <WINERROR.H>
#include <WINBASE.H>
#include <WINGDI.H>
#include <WINDDI.H>
#include <TCHAR.H>
#include <EXCPT.H>
#include <ASSERT.H>
#include <PRSHT.H>
#include <COMPSTUI.H>
#include "WINDDIUI.H"
#include <PRINTOEM.H>

// Define from ntdef.h in Win2K SDK.
// NT 4 may not have this defined
// in the public headers.
#ifndef NOP_FUNCTION
  #if (_MSC_VER >= 1210)
    #define NOP_FUNCTION __noop
  #else
    #define NOP_FUNCTION (void)0
  #endif
#endif

#define COUNTOF(p)  (sizeof(p)/sizeof(*(p)))


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkui\wmarkui.cpp ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:    WMarkUI.cpp
//    
//
//  PURPOSE:  Main file for OEM UI test module.
//
//
//    Functions:
//
//        
//
//
//  PLATFORMS:    Windows 95, Windows NT
//
//

#include "precomp.h"
#include "resource.h"
#include "debug.h"
#include "wmarkui.h"



////////////////////////////////////////////////////////
//      INTERNAL MACROS and DEFINES
////////////////////////////////////////////////////////



////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

LONG APIENTRY OEMUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam);
static HRESULT hrDocumentPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam);
static void InitOptItems(POPTITEM pOptItems, DWORD dwOptItems);
static POPTTYPE CreateOptType(HANDLE hHeap, WORD wOptParams);
static DWORD FontSizeToIndex(DWORD dwFontSize);
static DWORD FontIndexToSize(DWORD dwIndex);
static DWORD TextColorToIndex(COLORREF crTextColor);
static COLORREF IndexToTextColor(DWORD dwIndex);
static PTSTR GetStringResource(HANDLE hHeap, HMODULE hModule, UINT uResource);



////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems to display OEM device or document property UI.
//
HRESULT hrOEMPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
    HRESULT hResult = S_OK;


    VERBOSE(DLLTEXT("hrOEMPropertyPage(%d) entry.\r\n"), dwMode);

    // Validate parameters.
    if( (OEMCUIP_DOCPROP != dwMode)
        &&
        (OEMCUIP_PRNPROP != dwMode)        
      )
    {
        ERR(ERRORTEXT("hrOEMPropertyPage() ERROR_INVALID_PARAMETER.\r\n"));
        VERBOSE(DLLTEXT("\tdwMode = %d, pOEMUIParam = %#lx.\r\n"), dwMode, pOEMUIParam);

        // Return invalid parameter error.
        SetLastError(ERROR_INVALID_PARAMETER);
        return E_FAIL;
    }

    switch(dwMode)
    {
        case OEMCUIP_DOCPROP:
            hResult = hrDocumentPropertyPage(dwMode, pOEMUIParam);
            break;

        case OEMCUIP_PRNPROP:
            // Don't have any Printer Proptery UI.
            hResult = E_NOTIMPL;
            break;

        default:
            // Should never reach this!
            ERR(ERRORTEXT("hrOEMPropertyPage() Invalid dwMode, %d"), dwMode);
            SetLastError(ERROR_INVALID_PARAMETER);
            hResult = E_FAIL;
            break;
    }

    return hResult;
}

////////////////////////////////////////////////////////////////////////////////
//
// OptItems call back for OEM device or document property UI.
//
LONG APIENTRY OEMUICallBack(PCPSUICBPARAM pCallbackParam, POEMCUIPPARAM pOEMUIParam)
{
    LONG    lReturn = CPSUICB_ACTION_NONE;
    POEMDEV pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;


    VERBOSE(DLLTEXT("OEMUICallBack() entry, Reason is %d.\r\n"), pCallbackParam->Reason);

    switch(pCallbackParam->Reason)
    {
        case CPSUICB_REASON_APPLYNOW:
            // Store OptItems state in DEVMODE.
            pOEMDev->bEnabled = !pOEMUIParam->pOEMOptItems[0].Sel;
            lstrcpyW(pOEMDev->szWaterMark, (LPWSTR)pOEMUIParam->pOEMOptItems[1].pSel);
            pOEMDev->dwFontSize = FontIndexToSize(pOEMUIParam->pOEMOptItems[2].Sel);
            pOEMDev->dfRotate = (DOUBLE) pOEMUIParam->pOEMOptItems[3].Sel;
            pOEMDev->crTextColor = IndexToTextColor(pOEMUIParam->pOEMOptItems[4].Sel);
            break;

        default:
            break;
    }

    return lReturn;
}


////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems to display OEM document property UI.
//
static HRESULT hrDocumentPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam)
{
    if(NULL == pOEMUIParam->pOEMOptItems)
    {
        // Fill in the number of OptItems to create for OEM document property UI.
        pOEMUIParam->cOEMOptItems = 5;

        VERBOSE(DLLTEXT("hrDocumentPropertyPage() requesting %d number of items.\r\n"), pOEMUIParam->cOEMOptItems);
    }
    else if(dwMode == OEMCUIP_DOCPROP)
    {
        POEMDEV pOEMDev = (POEMDEV) pOEMUIParam->pOEMDM;


        VERBOSE(DLLTEXT("hrDocumentPropertyPage() fill out items.\r\n"), pOEMUIParam->cOEMOptItems);

        // Init UI Callback reference.
        pOEMUIParam->OEMCUIPCallback = OEMUICallBack;

        // Init OEMOptItmes.
        InitOptItems(pOEMUIParam->pOEMOptItems, pOEMUIParam->cOEMOptItems);

        // Fill out tree view items.

        // Water Mark Section Name.
        pOEMUIParam->pOEMOptItems[0].Level = 1;
        pOEMUIParam->pOEMOptItems[0].Flags = OPTIF_COLLAPSE;
        pOEMUIParam->pOEMOptItems[0].pName = GetStringResource(pOEMUIParam->hOEMHeap, ghInstance, IDS_WATERMARK);
        pOEMUIParam->pOEMOptItems[0].Sel = pOEMDev->bEnabled ? 0 : 1;

        pOEMUIParam->pOEMOptItems[0].pOptType = CreateOptType(pOEMUIParam->hOEMHeap, 2);

        pOEMUIParam->pOEMOptItems[0].pOptType->Type = TVOT_COMBOBOX;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[0].pData = L"Enabled";
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[0].IconID = IDI_CPSUI_ON;
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].pData = L"Disabled";
        pOEMUIParam->pOEMOptItems[0].pOptType->pOptParam[1].IconID = IDI_CPSUI_OFF;


        // WaterMark Text.
        pOEMUIParam->pOEMOptItems[1].Level = 2;
        pOEMUIParam->pOEMOptItems[1].Flags = 0;
        pOEMUIParam->pOEMOptItems[1].pName = GetStringResource(pOEMUIParam->hOEMHeap, ghInstance, IDS_TEXT);
        pOEMUIParam->pOEMOptItems[1].pSel = (LPTSTR) HeapAlloc(pOEMUIParam->hOEMHeap, HEAP_ZERO_MEMORY, MAX_PATH * sizeof(WCHAR));
        lstrcpyW((LPWSTR)pOEMUIParam->pOEMOptItems[1].pSel, pOEMDev->szWaterMark);

        pOEMUIParam->pOEMOptItems[1].pOptType = CreateOptType(pOEMUIParam->hOEMHeap, 2);

        pOEMUIParam->pOEMOptItems[1].pOptType->Type = TVOT_EDITBOX;
        pOEMUIParam->pOEMOptItems[1].pOptType->pOptParam[1].IconID = sizeof(((POEMDEV)NULL)->szWaterMark)/sizeof(WCHAR);


        // WaterMark Font Size.
        pOEMUIParam->pOEMOptItems[2].Level = 2;
        pOEMUIParam->pOEMOptItems[2].Flags = 0;
        pOEMUIParam->pOEMOptItems[2].pName = GetStringResource(pOEMUIParam->hOEMHeap, ghInstance, IDS_FONTSIZE);
        pOEMUIParam->pOEMOptItems[2].Sel = FontSizeToIndex(pOEMDev->dwFontSize);

        pOEMUIParam->pOEMOptItems[2].pOptType = CreateOptType(pOEMUIParam->hOEMHeap, 16);

        pOEMUIParam->pOEMOptItems[2].pOptType->Type = TVOT_COMBOBOX;
        pOEMUIParam->pOEMOptItems[2].pOptType->pOptParam[0].pData = L"8";
        pOEMUIParam->pOEMOptItems[2].pOptType->pOptParam[1].pData = L"9";
        pOEMUIParam->pOEMOptItems[2].pOptType->pOptParam[2].pData = L"10";
        pOEMUIParam->pOEMOptItems[2].pOptType->pOptParam[3].pData = L"11";
        pOEMUIParam->pOEMOptItems[2].pOptType->pOptParam[4].pData = L"12";
        pOEMUIParam->pOEMOptItems[2].pOptType->pOptParam[5].pData = L"14";
        pOEMUIParam->pOEMOptItems[2].pOptType->pOptParam[6].pData = L"16";
        pOEMUIParam->pOEMOptItems[2].pOptType->pOptParam[7].pData = L"18";
        pOEMUIParam->pOEMOptItems[2].pOptType->pOptParam[8].pData = L"20";
        pOEMUIParam->pOEMOptItems[2].pOptType->pOptParam[9].pData = L"22";
        pOEMUIParam->pOEMOptItems[2].pOptType->pOptParam[10].pData = L"24";
        pOEMUIParam->pOEMOptItems[2].pOptType->pOptParam[11].pData = L"26";
        pOEMUIParam->pOEMOptItems[2].pOptType->pOptParam[12].pData = L"28";
        pOEMUIParam->pOEMOptItems[2].pOptType->pOptParam[13].pData = L"36";
        pOEMUIParam->pOEMOptItems[2].pOptType->pOptParam[14].pData = L"48";
        pOEMUIParam->pOEMOptItems[2].pOptType->pOptParam[15].pData = L"72";


        // WaterMark Angle.
        pOEMUIParam->pOEMOptItems[3].Level = 2;
        pOEMUIParam->pOEMOptItems[3].Flags = 0;
        pOEMUIParam->pOEMOptItems[3].pName = GetStringResource(pOEMUIParam->hOEMHeap, ghInstance, IDS_ANGLE);
        pOEMUIParam->pOEMOptItems[3].Sel = (LONG) pOEMDev->dfRotate;

        pOEMUIParam->pOEMOptItems[3].pOptType = CreateOptType(pOEMUIParam->hOEMHeap, 2);

        pOEMUIParam->pOEMOptItems[3].pOptType->Type = TVOT_UDARROW;
        pOEMUIParam->pOEMOptItems[3].pOptType->pOptParam[1].IconID = 0;
        pOEMUIParam->pOEMOptItems[3].pOptType->pOptParam[1].lParam = 360;


        // WaterMark Color.
        pOEMUIParam->pOEMOptItems[4].Level = 2;
        pOEMUIParam->pOEMOptItems[4].Flags = 0;
        pOEMUIParam->pOEMOptItems[4].pName = GetStringResource(pOEMUIParam->hOEMHeap, ghInstance, IDS_COLOR);
        pOEMUIParam->pOEMOptItems[4].Sel = TextColorToIndex(pOEMDev->crTextColor);

        pOEMUIParam->pOEMOptItems[4].pOptType = CreateOptType(pOEMUIParam->hOEMHeap, 4);

        pOEMUIParam->pOEMOptItems[4].pOptType->Type = TVOT_COMBOBOX;
        pOEMUIParam->pOEMOptItems[4].pOptType->pOptParam[0].pData = GetStringResource(pOEMUIParam->hOEMHeap, ghInstance, IDS_GRAY);
        pOEMUIParam->pOEMOptItems[4].pOptType->pOptParam[1].pData = GetStringResource(pOEMUIParam->hOEMHeap, ghInstance, IDS_RED);
        pOEMUIParam->pOEMOptItems[4].pOptType->pOptParam[2].pData = GetStringResource(pOEMUIParam->hOEMHeap, ghInstance, IDS_GREEN);
        pOEMUIParam->pOEMOptItems[4].pOptType->pOptParam[3].pData = GetStringResource(pOEMUIParam->hOEMHeap, ghInstance, IDS_BLUE);
    }

    return S_OK;
}

////////////////////////////////////////////////////////////////////////////////
//
// Initializes OptItems.
//
static void InitOptItems(POPTITEM pOptItems, DWORD dwOptItems)
{
    VERBOSE(DLLTEXT("InitOptItems() entry.\r\n"));

    // Zero out memory.
    memset(pOptItems, 0, sizeof(OPTITEM) * dwOptItems);

    // Set each OptItem's size, and Public DM ID.
    for(DWORD dwCount = 0; dwCount < dwOptItems; dwCount++)
    {
        pOptItems[dwCount].cbSize = sizeof(OPTITEM);
        pOptItems[dwCount].DMPubID = DMPUB_NONE;
    }
}

////////////////////////////////////////////////////////////////////////////////
//
// Allocates and initializes OptType for OptItem.
//
static POPTTYPE CreateOptType(HANDLE hHeap, WORD wOptParams)
{
    POPTTYPE    pOptType = NULL;


    VERBOSE(DLLTEXT("CreateOptType() entry.\r\n"));

    // Allocate memory from the heap for the OPTTYPE; the driver will take care of clean up.
    pOptType = (POPTTYPE) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, sizeof(OPTTYPE));
    if(NULL != pOptType)
    {
        // Initialize OPTTYPE.
        pOptType->cbSize = sizeof(OPTTYPE);
        pOptType->Count = wOptParams;

        // Allocate memory from the heap for the OPTPARAMs for the OPTTYPE.
        pOptType->pOptParam = (POPTPARAM) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, wOptParams * sizeof(OPTPARAM));
        if(NULL != pOptType->pOptParam)
        {
            // Initialize the OPTPARAMs.
            for(WORD wCount = 0; wCount < wOptParams; wCount++)
            {
                pOptType->pOptParam[wCount].cbSize = sizeof(OPTPARAM);
            }
        }
        else
        {
            ERR(ERRORTEXT("CreateOptType() failed to allocated memory for OPTPARAMs!\r\n"));

            // Free allocated memory and return NULL.
            HeapFree(hHeap, 0, pOptType);
            pOptType = NULL;
        }
    }
    else
    {
        ERR(ERRORTEXT("CreateOptType() failed to allocated memory for OPTTYPE!\r\n"));
    }

    return pOptType;
}

////////////////////////////////////////////////////////////////////////////////
//
// Converts Font point size to index in combo box.
//
static DWORD FontSizeToIndex(DWORD dwFontSize)
{
    DWORD   dwIndex;


    switch(dwFontSize)
    {
        case 8:
            dwIndex = 0;
            break;

        case 9:
            dwIndex = 1;
            break;

        case 10:
            dwIndex = 2;
            break;

        case 11:
            dwIndex = 3;
            break;

        case 12:
            dwIndex = 4;
            break;

        case 14:
            dwIndex = 5;
            break;

        case 16:
            dwIndex = 6;
            break;

        case 18:
            dwIndex = 7;
            break;

        case 20:
            dwIndex = 8;
            break;

        case 22:
            dwIndex = 9;
            break;

        case 24:
            dwIndex = 10;
            break;

        case 26:
            dwIndex = 11;
            break;

        default:
        case 28:
            dwIndex = 12;
            break;

        case 36:
            dwIndex = 13;
            break;

        case 48:
            dwIndex = 14;
            break;

        case 72:
            dwIndex = 15;
            break;
    }


    return dwIndex;
}


////////////////////////////////////////////////////////////////////////////////
//
// Converts Font combo box index to font point size.
//
static DWORD FontIndexToSize(DWORD dwIndex)
{
    DWORD   dwFontSize;


    switch(dwIndex)
    {
        case 0:
            dwFontSize = 8;
            break;

        case 1:
            dwFontSize = 9;
            break;

        case 2:
            dwFontSize = 10;
            break;

        case 3:
            dwFontSize = 11;
            break;

        case 4:
            dwFontSize = 12;
            break;

        case 5:
            dwFontSize = 14;
            break;

        case 6:
            dwFontSize = 16;
            break;

        case 7:
            dwFontSize = 18;
            break;

        case 8:
            dwFontSize = 20;
            break;

        case 9:
            dwFontSize = 22;
            break;

        case 10:
            dwFontSize = 24;
            break;

        case 11:
            dwFontSize = 26;
            break;

        case 12:
            dwFontSize = 28;
            break;

        case 13:
            dwFontSize = 36;
            break;

        case 14:
            dwFontSize = 48;
            break;

        case 15:
            dwFontSize = 72;
            break;
    }

    return dwFontSize;
}


////////////////////////////////////////////////////////////////////////////////
//
// Converts text color to combo box index.
//
static DWORD TextColorToIndex(COLORREF crTextColor)
{
    DWORD   dwIndex;


    // The color is what ever color is dominate.  If none are, then it is gray.
    if( (GetRValue(crTextColor) > GetGValue(crTextColor))
        &&
        (GetGValue(crTextColor) >= GetBValue(crTextColor))
      )
    {
        // Set index to red.
        dwIndex = 1;
    }
    else if( (GetRValue(crTextColor) < GetGValue(crTextColor))
             &&
             (GetGValue(crTextColor) > GetBValue(crTextColor))
            )
    {
        // Set index to green.
        dwIndex = 2;
    }
    else if( (GetRValue(crTextColor) <= GetGValue(crTextColor))
             &&
             (GetGValue(crTextColor) < GetBValue(crTextColor))
            )
    {
        // Set index to blue.
        dwIndex = 3;
    }
    else
    {
        // Set index to gray.
        dwIndex = 0;
    }

    return dwIndex;
}

////////////////////////////////////////////////////////////////////////////////
//
// Converts text combo box index to text color.
//
static COLORREF IndexToTextColor(DWORD dwIndex)
{
    COLORREF    crTextColor;

    // Map index to desired text color.
    // We just support 4 colors in the UI: Red, Green, Blue, and gray.
    // The rendering module is capable of using any color for the Water Mark Text.
    switch(dwIndex)
    {
        case 1:
            // Color is red.
            crTextColor = RGB(255, 216, 216);
            break;

        case 2:
            // Color is green.
            crTextColor = RGB(216, 255, 216);
            break;

        case 3:
            // Color is blue.
            crTextColor = RGB(216, 216, 255);
            break;

        default:
        case 0:
            // Color is gray.
            crTextColor = WATER_MARK_DEFAULT_COLOR;
            break;
    }

    return crTextColor;
}

////////////////////////////////////////////////////////////////////////////////////
//
//  Retrieves pointer to a String resource.
//
static PTSTR GetStringResource(HANDLE hHeap, HMODULE hModule, UINT uResource)
{
    int     nResult;
    DWORD   dwSize = MAX_PATH;
    PTSTR   pszString = NULL;


    VERBOSE(DLLTEXT("GetStringResource() entered.\r\n"));

    // Allocate buffer for string resource from heap; let the driver clean it up.
    pszString = (PTSTR) HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwSize * sizeof(TCHAR));
    if(NULL != pszString)
    {
        // Load string resource; resize after loading so as not to waste memory.
        nResult = LoadString(hModule, uResource, pszString, dwSize);
        pszString = (PTSTR) HeapReAlloc(hHeap, HEAP_ZERO_MEMORY, pszString, (nResult + 1) * sizeof(TCHAR));
    }
    else
    {
        ERR(ERRORTEXT("GetStringResource() failed to allocate string buffer!\r\n"));
    }

    return pszString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkui\intrface.h ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.h

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

////////////////////////////////////////////////////////////////////////////////
//
// IWaterMarkUI
//
class IWaterMarkUI: public IPrintOemUI
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD  dwMode, PVOID  pBuffer, DWORD  cbSize,
                           PDWORD pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_  DWORD  dwMode, POEMDMPARAM pOemDMParam) ;

    //
    // OEMCommonUIProp
    //

    STDMETHOD(CommonUIProp) (THIS_  
            DWORD  dwMode, 
            POEMCUIPPARAM   pOemCUIPParam
            );

    //
    // OEMDocumentPropertySheets
    //

    STDMETHOD(DocumentPropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            );

    //
    // OEMDevicePropertySheets
    //

    STDMETHOD(DevicePropertySheets) (THIS_
            PPROPSHEETUI_INFO   pPSUIInfo,
            LPARAM              lParam
            );


    //
    // OEMDevQueryPrintEx
    //

    STDMETHOD(DevQueryPrintEx) (THIS_
            POEMUIOBJ               poemuiobj,
            PDEVQUERYPRINT_INFO     pDQPInfo,
            PDEVMODE                pPublicDM,
            PVOID                   pOEMDM
            );

    //
    // OEMDeviceCapabilities
    //

    STDMETHOD(DeviceCapabilities) (THIS_
            POEMUIOBJ   poemuiobj,
            HANDLE      hPrinter,
            PWSTR       pDeviceName,
            WORD        wCapability,
            PVOID       pOutput,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            DWORD       dwOld,
            DWORD       *dwResult
            );

    //
    // OEMUpgradePrinter
    //

    STDMETHOD(UpgradePrinter) (THIS_
            DWORD   dwLevel,
            PBYTE   pDriverUpgradeInfo
            );

    //
    // OEMPrinterEvent
    //

    STDMETHOD(PrinterEvent) (THIS_
            PWSTR   pPrinterName,
            INT     iDriverEvent,
            DWORD   dwFlags,
            LPARAM  lParam
            );

    //
    // OEMDriverEvent
    //

    STDMETHOD(DriverEvent)(THIS_
            DWORD   dwDriverEvent,
            DWORD   dwLevel,
            LPBYTE  pDriverInfo,
            LPARAM  lParam
            );
 
    //
    // OEMQueryColorProfile
    //

    STDMETHOD( QueryColorProfile) (THIS_
            HANDLE      hPrinter,
            POEMUIOBJ   poemuiobj,
            PDEVMODE    pPublicDM,
            PVOID       pOEMDM,
            ULONG       ulReserved,
            VOID       *pvProfileData,
            ULONG      *pcbProfileData,
            FLONG      *pflProfileData);

    //
    // OEMFontInstallerDlgProc
    //

    STDMETHOD(FontInstallerDlgProc) (THIS_ 
            HWND    hWnd,
            UINT    usMsg,
            WPARAM  wParam,
            LPARAM  lParam
            );
    //
    // UpdateExternalFonts
    //

    STDMETHOD(UpdateExternalFonts) (THIS_
            HANDLE  hPrinter,
            HANDLE  hHeap,
            PWSTR   pwstrCartridges
            );


    IWaterMarkUI() { m_cRef = 1; };
    ~IWaterMarkUI() { };

protected:
    LONG                m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\ddk\samples\oemdll\watermark\wmarkui\wmarkui.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1997  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:	WMarkUI.H
//    
//
//  PURPOSE:	Define common data types, and external function prototypes
//				for WaterMark UI.
//
//  PLATFORMS:
//    Windows NT
//
//
#ifndef _WMARKUI_H
#define _WMARKUI_H

#include <OEM.H>
#include <DEVMODE.H>
#include "globals.h"


////////////////////////////////////////////////////////
//      OEM UI Defines
////////////////////////////////////////////////////////


// OEM Signature and version.
#define PROP_TITLE      L"WaterMark UI Page"
#define DLLTEXT(s)      __TEXT("WMARKUI:  ") __TEXT(s)

// OEM UI Misc defines.
#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)


////////////////////////////////////////////////////////
//      Prototypes
////////////////////////////////////////////////////////

HRESULT hrOEMPropertyPage(DWORD dwMode, POEMCUIPPARAM pOEMUIParam);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\driverui\commonui.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    commonui.c

Abstract:

    This file contains all the functions related to preparing data for
    CPSUI.  This includes packing data items for printer property sheets and
    document property sheets.

Environment:

    Win32 subsystem, DriverUI module, user mode

Revision History:

    02/13/97 -davidx-
        Common function to handle well-known and generic printer features.

    02/10/97 -davidx-
        Consistent handling of common printer info.

    02/04/97 -davidx-
        Reorganize driver UI to separate ps and uni DLLs.

    09/12/96 -amandan-
        Created it.

--*/

#include "precomp.h"


PCOMPROPSHEETUI
PPrepareDataForCommonUI(
    IN OUT PUIDATA  pUiData,
    IN PDLGPAGE     pDlgPage
    )

/*++

Routine Description:

    Allocate memory and partially fill out the data structures required
    to call common UI routine. Once all information in pUiData are
    initialized properly, it calls PackDocumentPropertyItems() or
    PackPrinterPropertyItems() to pack the option items.

Arguments:

    pUiData - Pointer to our UIDATA structure
    pDlgPage - Pointer to dialog pages

Return Value:

    Pointer to a COMPROPSHEETUI structure, NULL if there is an error

--*/

{
    PCOMPROPSHEETUI pCompstui;
    DWORD           dwCount, dwIcon, dwOptItemCount, dwSize;
    PCOMMONINFO     pci = (PCOMMONINFO) pUiData;
    HANDLE          hHeap = pUiData->ci.hHeap;
    BOOL            (*pfnPackItemProc)(PUIDATA);
    POPTITEM        pOptItem;
    PBYTE           pUserData;

    //
    // Enumerate form names supported on the printer
    //

    dwCount = DwEnumPaperSizes(pci, NULL, NULL, NULL, NULL, UNUSED_PARAM);

    if (dwCount != GDI_ERROR && dwCount != 0)
    {
        pUiData->dwFormNames = dwCount;

        pUiData->pFormNames = HEAPALLOC(hHeap, dwCount * sizeof(WCHAR) * CCHPAPERNAME);
        pUiData->pwPapers = HEAPALLOC(hHeap, dwCount * sizeof(WORD));
        pUiData->pwPaperFeatures = HEAPALLOC(hHeap, dwCount * sizeof(WORD));
    }

    if (!pUiData->pFormNames || !pUiData->pwPapers || !pUiData->pwPaperFeatures)
        return NULL;

    (VOID) DwEnumPaperSizes(
                    pci,
                    pUiData->pFormNames,
                    pUiData->pwPapers,
                    NULL,
                    pUiData->pwPaperFeatures,
                    UNUSED_PARAM);

    #ifdef PSCRIPT

    //
    // We don't need to keep information about spooler forms
    // after this point. So dispose of it to free up memory.
    //

    MemFree(pUiData->ci.pSplForms);
    pUiData->ci.pSplForms = NULL;
    pUiData->ci.dwSplForms = 0;

    #endif

    //
    // Enumerate input bin names supported on the printer
    //

    dwCount = DwEnumBinNames(pci, NULL);

    if (dwCount != GDI_ERROR)
    {
        pUiData->dwBinNames = dwCount;
        pUiData->pBinNames = HEAPALLOC(hHeap, dwCount * sizeof(WCHAR) * CCHBINNAME);
    }

    if (! pUiData->pBinNames)
        return NULL;

    //
    // Don't need to check return here
    //

    DwEnumBinNames(pci, pUiData->pBinNames);

    //
    // Allocate memory to hold various data structures
    //

    if (! (pCompstui = HEAPALLOC(hHeap, sizeof(COMPROPSHEETUI))))
        return NULL;

    memset(pCompstui, 0, sizeof(COMPROPSHEETUI));

    //
    // Initialize COMPROPSHEETUI structure
    //

    pCompstui->cbSize = sizeof(COMPROPSHEETUI);
    pCompstui->UserData = (ULONG_PTR) pUiData;
    pCompstui->pDlgPage = pDlgPage;
    pCompstui->cDlgPage = 0;

    pCompstui->hInstCaller = ghInstance;
    pCompstui->pCallerName = _PwstrGetCallerName();
    pCompstui->pOptItemName = pUiData->ci.pDriverInfo3->pName;
    pCompstui->CallerVersion = gwDriverVersion;
    pCompstui->OptItemVersion = 0;

    dwIcon = pUiData->ci.pUIInfo->loPrinterIcon;

    if (dwIcon && (pCompstui->IconID = HLoadIconFromResourceDLL(&pUiData->ci, dwIcon)))
        pCompstui->Flags |= CPSUIF_ICONID_AS_HICON;
    else
        pCompstui->IconID = _DwGetPrinterIconID();

    if (HASPERMISSION(pUiData))
        pCompstui->Flags |= CPSUIF_UPDATE_PERMISSION;

    pCompstui->Flags |= CPSUIF_ABOUT_CALLBACK;


    pCompstui->pHelpFile = pUiData->ci.pDriverInfo3->pHelpFile;

    //
    // Call either PackDocumentPropertyItems or PackPrinterPropertyItems
    // to get the number of items and types.
    //

    pfnPackItemProc = (pUiData->iMode == MODE_DOCUMENT_STICKY) ?
                            BPackDocumentPropertyItems :
                            BPackPrinterPropertyItems;

    pUiData->dwOptItem = 0;
    pUiData->pOptItem = NULL;
    pUiData->dwOptType = 0;
    pUiData->pOptType = NULL;

    if (! pfnPackItemProc(pUiData))
    {
        ERR(("Error while packing OPTITEM's\n"));
        return NULL;
    }

    //
    // Allocate memory to hold OPTITEMs and OPTTYPEs
    //

    ASSERT(pUiData->dwOptItem > 0);
    VERBOSE(("Number of  OPTTYPE's: %d\n", pUiData->dwOptType));
    VERBOSE(("Number of OPTITEM's: %d\n", pUiData->dwOptItem));

    pUiData->pOptItem = HEAPALLOC(hHeap, sizeof(OPTITEM) * pUiData->dwOptItem);
    pUiData->pOptType = HEAPALLOC(hHeap, sizeof(OPTTYPE) * pUiData->dwOptType);
    pUserData = HEAPALLOC(hHeap, sizeof(USERDATA)* pUiData->dwOptItem);

    if (!pUiData->pOptItem || !pUiData->pOptType || !pUserData)
        return NULL;

    //
    // Initializes OPTITEM.USERDATA
    //

    pOptItem = pUiData->pOptItem;
    dwOptItemCount = pUiData->dwOptItem;
    dwSize = sizeof(USERDATA);

    while (dwOptItemCount--)
    {

        pOptItem->UserData = (ULONG_PTR)pUserData;

        SETUSERDATA_SIZE(pOptItem, dwSize);

        pUserData += sizeof(USERDATA);
        pOptItem++;

    }

    pUiData->pDrvOptItem = pUiData->pOptItem;
    pCompstui->pOptItem = pUiData->pDrvOptItem;
    pCompstui->cOptItem = (WORD) pUiData->dwOptItem;

    pUiData->dwOptItem = pUiData->dwOptType = 0;

    //
    // Call either PackDocumentPropertyItems or PackPrinterPropertyItems
    // to build the OPTITEMs list
    //

    if (! pfnPackItemProc(pUiData))
    {
        ERR(("Error while packing OPTITEM's\n"));
        return NULL;
    }

    return pCompstui;
}



VOID
VPackOptItemGroupHeader(
    IN OUT PUIDATA  pUiData,
    IN DWORD        dwTitleId,
    IN DWORD        dwIconId,
    IN DWORD        dwHelpIndex
    )

/*++

Routine Description:

    Fill out a OPTITEM to be used as a header for a group of items

Arguments:

    pUiData - Points to UIDATA structure
    dwTitleId - String resource ID for the item title
    dwIconId - Icon resource ID
    dwHelpIndex - Help index

Return Value:

    NONE

--*/

{
    if (pUiData->pOptItem)
    {
        pUiData->pOptItem->cbSize = sizeof(OPTITEM);
        pUiData->pOptItem->pOptType = NULL;
        pUiData->pOptItem->pName = (PWSTR)ULongToPtr(dwTitleId);
        pUiData->pOptItem->Level = TVITEM_LEVEL1;
        pUiData->pOptItem->DMPubID = DMPUB_NONE;
        pUiData->pOptItem->Sel = dwIconId;
        //pUiData->pOptItem->UserData = 0;
        pUiData->pOptItem->HelpIndex = dwHelpIndex;
        pUiData->pOptItem++;
    }

    pUiData->dwOptItem++;
}



BOOL
BPackOptItemTemplate(
    IN OUT PUIDATA  pUiData,
    IN CONST WORD   pwItemInfo[],
    IN DWORD        dwSelection,
    IN PFEATURE     pFeature
    )

/*++

Routine Description:

    Fill out an OPTITEM and an OPTTYPE structure using a template

Arguments:

    pUiData - Points to UIDATA structure
    pwItemInfo - Pointer to item template
    dwSelection - Current item selection
    pFeature - Pointer to FEATURE

Return Value:

    TRUE if successful, FALSE otherwise

Note:

    The item template is a variable size WORD array:
        0: String resource ID of the item title
        1: Item level in the tree view (TVITEM_LEVELx)
        2: Public devmode field ID (DMPUB_xxx)
        3: User data
        4: Help index
        5: Number of OPTPARAMs for this item
        6: Item type (TVOT_xxx)
        Three words for each OPTPARAM:
            Size of OPTPARAM
            String resource ID for parameter data
            Icon resource ID
        Last word must be ITEM_INFO_SIGNATURE

    Both OPTITEM and OPTTYPE structures are assumed to be zero-initialized.

--*/

{
    POPTITEM pOptItem;
    POPTPARAM pOptParam;
    WORD wOptParam;
    POPTTYPE pOptType = pUiData->pOptType;


    if ((pOptItem = pUiData->pOptItem) != NULL)
    {
        FILLOPTITEM(pOptItem,
                    pUiData->pOptType,
                    ULongToPtr(pwItemInfo[0]),
                    ULongToPtr(dwSelection),
                    (BYTE) pwItemInfo[1],
                    (BYTE) pwItemInfo[2],
                    pwItemInfo[3],
                    pwItemInfo[4]
                    );

        wOptParam = pwItemInfo[5];
        pOptParam = PFillOutOptType(pUiData->pOptType,
                                    pwItemInfo[6],
                                    wOptParam,
                                    pUiData->ci.hHeap);

        if (pOptParam == NULL)
            return FALSE;

        pwItemInfo += 7;
        while (wOptParam--)
        {
            pOptParam->cbSize = sizeof(OPTPARAM);
            pOptParam->pData = (PWSTR) *pwItemInfo++;
            pOptParam->IconID = *pwItemInfo++;
            pOptParam++;
        }

        ASSERT(*pwItemInfo == ITEM_INFO_SIGNATURE);

        if (pFeature)
        {
            SETUSERDATA_KEYWORDNAME(pUiData->ci, pOptItem, pFeature);

            #ifdef UNIDRV

            if (pUiData->ci.pUIInfo->loHelpFileName &&
                pFeature->iHelpIndex != UNUSED_ITEM )
            {
                //
                // Allocate memory for OIEXT
                //

                POIEXT  pOIExt = HEAPALLOC(pUiData->ci.hHeap, sizeof(OIEXT));

                if (pOIExt)
                {
                    pOIExt->cbSize = sizeof(OIEXT);
                    pOIExt->Flags = 0;
                    pOIExt->hInstCaller = NULL;
                    pOIExt->pHelpFile = OFFSET_TO_POINTER(pUiData->ci.pUIInfo->pubResourceData,
                                                          pUiData->ci.pUIInfo->loHelpFileName);
                    pOptItem->pOIExt = pOIExt;
                    pOptItem->HelpIndex = pFeature->iHelpIndex;
                    pOptItem->Flags |= OPTIF_HAS_POIEXT;
                }

            }
            #endif // UNIDRV
        }
        pUiData->pOptItem++;
        pUiData->pOptType++;
    }

    pUiData->dwOptItem++;
    pUiData->dwOptType++;

    return TRUE;
}



BOOL
BPackUDArrowItemTemplate(
    IN OUT PUIDATA  pUiData,
    IN CONST WORD   pwItemInfo[],
    IN DWORD        dwSelection,
    IN DWORD        dwMaxVal,
    IN PFEATURE     pFeature
    )

/*++

Routine Description:

    Pack an updown arrow item using the specified template

Arguments:

    pUiData, pwItemInfo, dwSelection - same as for BPackOptItemTemplate
    dwMaxVal - maximum value for the updown arrow item

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    POPTTYPE pOptType = pUiData->pOptType;

    if (! BPackOptItemTemplate(pUiData, pwItemInfo, dwSelection, pFeature))
        return FALSE;

    if (pOptType)
        pOptType->pOptParam[1].lParam = dwMaxVal;

    return TRUE;
}



POPTPARAM
PFillOutOptType(
    OUT POPTTYPE    pOptType,
    IN  DWORD       dwType,
    IN  DWORD       dwParams,
    IN  HANDLE      hHeap
    )

/*++

Routine Description:

    Fill out an OPTTYPE structure

Arguments:

    pOpttype - Pointer to OPTTYPE structure to be filled out
    wType - Value for OPTTYPE.Type field
    wParams - Number of OPTPARAM's
    hHeap - Handle to a heap from which to allocate

Return Value:

    Pointer to OPTPARAM array if successful, NULL otherwise

--*/

{
    POPTPARAM pOptParam;

    pOptType->cbSize = sizeof(OPTTYPE);
    pOptType->Count = (WORD) dwParams;
    pOptType->Type = (BYTE) dwType;

    pOptParam = HEAPALLOC(hHeap, sizeof(OPTPARAM) * dwParams);

    if (pOptParam != NULL)
        pOptType->pOptParam = pOptParam;
    else
        ERR(("Memory allocation failed\n"));

    return pOptParam;
}


BOOL
BShouldDisplayGenericFeature(
    IN PFEATURE     pFeature,
    IN BOOL         bPrinterSticky
    )

/*++

Routine Description:

    Determine whether a printer feature should be displayed
    as a generic feature

Arguments:

    pFeature - Points to a FEATURE structure
    pPrinterSticky - Whether the feature is printer-sticky or doc-sticky

Return Value:

    TRUE if the feature should be displayed as a generic feature
    FALSE if it should not be

--*/

{
    //
    // Check if the feature is specified marked as non-displayable
    // and make sure the feature type is appropriate
    //

    if ((pFeature->dwFlags & FEATURE_FLAG_NOUI) ||
        (bPrinterSticky &&
         pFeature->dwFeatureType != FEATURETYPE_PRINTERPROPERTY) ||
        (!bPrinterSticky &&
         pFeature->dwFeatureType != FEATURETYPE_DOCPROPERTY &&
         pFeature->dwFeatureType != FEATURETYPE_JOBPROPERTY))
    {
        return FALSE;
    }

    //
    // Exclude those features which are explicitly handled
    // and also those which don't have any options
    //

    return (pFeature->Options.dwCount >= MIN_OPTIONS_ALLOWED) &&
           (pFeature->dwFeatureID == GID_UNKNOWN ||
            pFeature->dwFeatureID == GID_OUTPUTBIN ||
            pFeature->dwFeatureID == GID_MEMOPTION);
}



DWORD
DwCountDisplayableGenericFeature(
    IN PUIDATA      pUiData,
    BOOL            bPrinterSticky
    )

/*++

Routine Description:

    Count the number of features which can be displayed
    as generic features

Arguments:

    pUiData - Points to UIDATA structure
    pPrinterSticky - Whether the feature is printer-sticky or doc-sticky

Return Value:

    Number of features which can be displayed as generic features

--*/

{
    PFEATURE pFeature;
    DWORD    dwFeature, dwCount = 0;

    pFeature = PGetIndexedFeature(pUiData->ci.pUIInfo, 0);
    dwFeature = pUiData->ci.pRawData->dwDocumentFeatures +
                pUiData->ci.pRawData->dwPrinterFeatures;

    if (pFeature && dwFeature)
    {
        for ( ; dwFeature--; pFeature++)
        {
            if (BShouldDisplayGenericFeature(pFeature, bPrinterSticky))
                dwCount++;
        }
    }

    return dwCount;
}



DWORD
DwGuessOptionIconID(
    PUIINFO     pUIInfo,
    PFEATURE    pFeature,
    POPTION     pOption
    )

/*++

Routine Description:

    Try to make an intelligent guess as to what icon
    to use for a generic printer feature option

Arguments:

    pUIInfo - Points to UIINFO structure
    pFeature - Points to the feature in question
    pOption - Points to the option in question

Return Value:

    Icon resource ID appropriate for the feature option

--*/

{
    DWORD   dwIconID, iRes;

    switch (pFeature->dwFeatureID)
    {
    case GID_RESOLUTION:

        iRes = max(((PRESOLUTION) pOption)->iXdpi, ((PRESOLUTION) pOption)->iYdpi);

        if (iRes <= 150)
            dwIconID = IDI_CPSUI_RES_DRAFT;
        else if (iRes <= 300)
            dwIconID = IDI_CPSUI_RES_LOW;
        else if (iRes <= 600)
            dwIconID = IDI_CPSUI_RES_MEDIUM;
        else if (iRes <= 900)
            dwIconID = IDI_CPSUI_RES_HIGH;
        else
            dwIconID = IDI_CPSUI_RES_PRESENTATION;

        break;

    case GID_DUPLEX:

        switch (((PDUPLEX) pOption)->dwDuplexID)
        {
        case DMDUP_VERTICAL:
            dwIconID = IDI_CPSUI_DUPLEX_VERT;
            break;

        case DMDUP_HORIZONTAL:
            dwIconID = IDI_CPSUI_DUPLEX_HORZ;
            break;

        default:
            dwIconID = IDI_CPSUI_DUPLEX_NONE;
            break;
        }
        break;

    case GID_ORIENTATION:

        switch (((PORIENTATION) pOption)->dwRotationAngle)
        {
        case ROTATE_270:
            dwIconID = IDI_CPSUI_LANDSCAPE;
            break;

        case ROTATE_90:
            dwIconID = IDI_CPSUI_ROT_LAND;
            break;

        default:
            dwIconID = IDI_CPSUI_PORTRAIT;
            break;
        }
        break;

    case GID_INPUTSLOT:
        dwIconID = IDI_CPSUI_PAPER_TRAY;
        break;

    case GID_PAGEPROTECTION:
        dwIconID = IDI_CPSUI_PAGE_PROTECT;
        break;

    default:
        dwIconID = IDI_CPSUI_GENERIC_OPTION;
        break;
    }

    return dwIconID;
}



BOOL
BPackItemPrinterFeature(
    PUIDATA     pUiData,
    PFEATURE    pFeature,
    DWORD       dwLevel,
    DWORD       dwPub,
    ULONG_PTR    dwUserData,
    DWORD       dwHelpIndex
    )

/*++

Routine Description:

    Pack a single printer feature item

Arguments:

    pUiData - Points to UIDATA structure
    pFeature - Points to the printer feature to be packed
    dwLevel - Treeview item level
    dwPub - DMPUB_ identifier
    dwUserData - User data to be associated with the item
    dwHelpIndex - Help index to be associated with the item

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD       dwCount, dwIndex;
    DWORD       dwFeature, dwSel;
    POPTION     pOption;
    POPTTYPE    pOptTypeHack;
    POPTPARAM   pOptParam;
    PCOMMONINFO pci;

    if (pFeature == NULL ||
        (pFeature->dwFlags & FEATURE_FLAG_NOUI) ||
        (dwCount = pFeature->Options.dwCount) < MIN_OPTIONS_ALLOWED)
        return TRUE;

    //
    // HACK: for Orientation and Duplex feature
    //  They must be of type TVOT_2STATES or TVOT_3STATES.
    //  If not, compstui will get confused.
    //

    if (dwPub == DMPUB_ORIENTATION || dwPub == DMPUB_DUPLEX)
    {
        if (dwCount != 2 && dwCount != 3)
        {
            WARNING(("Unexpected number of Orientation/Duplex options\n"));
            return TRUE;
        }

        pOptTypeHack = pUiData->pOptType;
    }
    else
        pOptTypeHack = NULL;

    pUiData->dwOptItem++;
    pUiData->dwOptType++;

    if (pUiData->pOptItem == NULL)
        return TRUE;

    //
    // Find out the current selection first
    // DCR: needs to support PICKMANY
    //

    pci = (PCOMMONINFO) pUiData;
    dwFeature = GET_INDEX_FROM_FEATURE(pci->pUIInfo, pFeature);
    dwSel = pci->pCombinedOptions[dwFeature].ubCurOptIndex;

    if (dwSel >= dwCount)
        dwSel = 0;

    //
    // If we are in this function, we must have already successfully
    // called function PFillUiData(), where the pci->hHeap is created.
    //

    ASSERT(pci->hHeap != NULL);

    //
    // Fill in the OPTITEM structure
    //

    FILLOPTITEM(pUiData->pOptItem,
                pUiData->pOptType,
                PGetReadOnlyDisplayName(pci, pFeature->loDisplayName),
                ULongToPtr(dwSel),
                dwLevel,
                dwPub,
                dwUserData,
                dwHelpIndex);

    #ifdef UNIDRV
    //
    // Supports OEM help file. If  helpfile and helpindex are defined,
    // we will use the help id specified by the GPD.  According to GPD spec,
    // zero loHelpFileName means no help file name specified.
    //

    if (pci->pUIInfo->loHelpFileName &&
        pFeature->iHelpIndex != UNUSED_ITEM )
    {
        //
        // Allocate memory for OIEXT
        //

        POIEXT  pOIExt = HEAPALLOC(pci->hHeap, sizeof(OIEXT));

        if (pOIExt)
        {
            pOIExt->cbSize = sizeof(OIEXT);
            pOIExt->Flags = 0;
            pOIExt->hInstCaller = NULL;
            pOIExt->pHelpFile = OFFSET_TO_POINTER(pci->pUIInfo->pubResourceData,
                                                  pci->pUIInfo->loHelpFileName);
            pUiData->pOptItem->pOIExt = pOIExt;
            pUiData->pOptItem->HelpIndex = pFeature->iHelpIndex;
            pUiData->pOptItem->Flags |= OPTIF_HAS_POIEXT;
        }

    }
    #endif // UNIDRV

    pOptParam = PFillOutOptType(pUiData->pOptType, TVOT_LISTBOX, dwCount, pci->hHeap);

    if (pOptParam == NULL)
        return FALSE;

    if (pOptTypeHack)
        pOptTypeHack->Type = (dwCount == 2) ? TVOT_2STATES : TVOT_3STATES;

    //
    // Get the list of options for this features
    //

    for (dwIndex=0; dwIndex < dwCount; dwIndex++, pOptParam++)
    {
        //
        // Fill in the options name
        //

        pOption = PGetIndexedOption(pci->pUIInfo, pFeature, dwIndex);
        ASSERT(pOption != NULL);

        pOptParam->cbSize = sizeof(OPTPARAM);
        pOptParam->pData = GET_OPTION_DISPLAY_NAME(pci, pOption);

        //
        // Try to figure out the appropriate icon to use
        //  If the icon comes from the resource DLL, we need to load
        //  it ourselves and give compstui an HICON. Otherwise,
        //  we try to figure out the appropriate icon resource ID.
        //

        if (pOption->loResourceIcon &&
            (pOptParam->IconID = HLoadIconFromResourceDLL(pci, pOption->loResourceIcon)))
        {
            pOptParam->Flags |= OPTPF_ICONID_AS_HICON;
        }
        else
            pOptParam->IconID = DwGuessOptionIconID(pci->pUIInfo, pFeature, pOption);
    }

    //
    // Set the Keyword name for pOptItem->UserData
    //

    SETUSERDATA_KEYWORDNAME(pUiData->ci, pUiData->pOptItem, pFeature);

    pUiData->pOptItem++;
    pUiData->pOptType++;
    return TRUE;
}



BOOL
BPackItemGenericOptions(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack generic printer features items (doc-sticky or printer-sticky)

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error.

--*/

{
    //
    // Extended push button for restoring to default feature selections
    //

    static EXTPUSH  ExtPush =
    {
        sizeof(EXTPUSH),
        EPF_NO_DOT_DOT_DOT,
        (PWSTR) IDS_RESTORE_DEFAULTS,
        NULL,
        0,
        0,
    };

    POPTITEM    pOptItem;
    DWORD       dwHelpIndex, dwIconId;
    PFEATURE    pFeatures;
    DWORD       dwFeatures;
    BOOL        bPrinterSticky;

    //
    // If there are no generic features to display, simply return success
    //

    bPrinterSticky = (pUiData->iMode == MODE_PRINTER_STICKY);

    if (DwCountDisplayableGenericFeature(pUiData, bPrinterSticky) == 0)
        return TRUE;

    //
    // Add the group header item
    //

    pOptItem = pUiData->pOptItem;

    if (bPrinterSticky)
    {
        VPackOptItemGroupHeader(
                pUiData,
                IDS_INSTALLABLE_OPTIONS,
                IDI_CPSUI_INSTALLABLE_OPTION,
                HELP_INDEX_INSTALLABLE_OPTIONS);
    }
    else
    {
        VPackOptItemGroupHeader(
                pUiData,
                IDS_PRINTER_FEATURES,
                IDI_CPSUI_PRINTER_FEATURE,
                HELP_INDEX_PRINTER_FEATURES);
    }

    if (pOptItem != NULL && !bPrinterSticky)
    {
        //
        // "Restore Defaults" button
        //

        pUiData->pFeatureHdrItem = pOptItem;
        pOptItem->Flags |= (OPTIF_EXT_IS_EXTPUSH|OPTIF_CALLBACK);
        pOptItem->pExtPush = &ExtPush;
    }

    pOptItem = pUiData->pOptItem;

    //
    // Figure out the correct help index and icon ID
    // depending on whether we're dealing with printer-sticky
    // features or document-sticky printer features
    //

    if (bPrinterSticky)
    {
        dwHelpIndex = HELP_INDEX_INSTALLABLE_OPTIONS;
        dwIconId = IDI_CPSUI_INSTALLABLE_OPTION;
    }
    else
    {
        dwHelpIndex = HELP_INDEX_PRINTER_FEATURES;
        dwIconId = IDI_CPSUI_PRINTER_FEATURE;
    }

    //
    // Go through each printer feature
    //

    pFeatures = PGetIndexedFeature(pUiData->ci.pUIInfo, 0);
    dwFeatures = pUiData->ci.pRawData->dwDocumentFeatures +
                 pUiData->ci.pRawData->dwPrinterFeatures;

    ASSERT(pFeatures != NULL);

    for ( ; dwFeatures--; pFeatures++)
    {
        //
        // Don't do anything if it's the feature has no options OR
        // If it's not a generic feature.
        //

        if (BShouldDisplayGenericFeature(pFeatures, bPrinterSticky) &&
            !BPackItemPrinterFeature(pUiData,
                                     pFeatures,
                                     TVITEM_LEVEL2,
                                     DMPUB_NONE,
                                     (ULONG_PTR) pFeatures,
                                     dwHelpIndex))
        {
            return FALSE;
        }
    }

    if (pOptItem != NULL)
    {
        pUiData->pFeatureItems = pOptItem;
        pUiData->dwFeatureItem = (DWORD)(pUiData->pOptItem - pOptItem);
    }

    return TRUE;
}



PFEATURE
PGetFeatureFromItem(
    IN      PUIINFO  pUIInfo,
    IN OUT  POPTITEM pOptItem,
    OUT     PDWORD   pdwFeatureIndex
    )

/*++

Routine Description:

    Get the feature index for a given pOptItem

Arguments:

    pUIInfo - pointer to UIINFO
    pOptItem - pointer to item to look for feature id
    pdwFeatureIndex - pointer to contain the value of returned index

Return Value:

    Pointer to FEATURE structure associated with the item
    NULL if no such feature exists.

--*/

{
    PFEATURE pFeature = NULL;

    //
    // Get the dwFeature, which is the index into pOptionsArray
    //

    if (ISPRINTERFEATUREITEM(pOptItem->UserData))
    {
        //
        // Note: Generic Features contains pointer to feature (pFeature)
        // in pOptItem->UserData
        //

        pFeature = (PFEATURE) GETUSERDATAITEM(pOptItem->UserData);
    }
    else
    {
        DWORD   dwFeatureId;

        switch (GETUSERDATAITEM(pOptItem->UserData))
        {
        case FORMNAME_ITEM:
            dwFeatureId = GID_PAGESIZE;
            break;

        case DUPLEX_ITEM:
            dwFeatureId = GID_DUPLEX;
            break;

        case RESOLUTION_ITEM:
            dwFeatureId = GID_RESOLUTION;
            break;

        case MEDIATYPE_ITEM:
            dwFeatureId = GID_MEDIATYPE;
            break;

        case INPUTSLOT_ITEM:
            dwFeatureId = GID_INPUTSLOT;
            break;

        case FORM_TRAY_ITEM:
            dwFeatureId = GID_INPUTSLOT;
            break;

        case COLORMODE_ITEM:
            dwFeatureId = GID_COLORMODE;
            break;

        case ORIENTATION_ITEM:
            dwFeatureId = GID_ORIENTATION;
            break;

        case PAGE_PROTECT_ITEM:
            dwFeatureId = GID_PAGEPROTECTION;
            break;

        case COPIES_COLLATE_ITEM:
            dwFeatureId = GID_COLLATE;
            break;

        case HALFTONING_ITEM:
            dwFeatureId = GID_HALFTONING;
            break;

        default:
            dwFeatureId = GID_UNKNOWN;
            break;
        }

        if (dwFeatureId != GID_UNKNOWN)
            pFeature = GET_PREDEFINED_FEATURE(pUIInfo, dwFeatureId);
    }

    if (pFeature && pdwFeatureIndex)
        *pdwFeatureIndex = GET_INDEX_FROM_FEATURE(pUIInfo, pFeature);

    return pFeature;
}



VOID
VUpdateOptionsArrayWithSelection(
    IN OUT PUIDATA  pUiData,
    IN POPTITEM     pOptItem
    )

/*++

Routine Description:

    Update the options array with the current selection

Arguments:

    pUiData - Points to UIDATA structure
    pOptItem - Specifies the item whose selection has changed

Return Value:

    NONE

--*/

{
    PFEATURE pFeature;
    DWORD    dwFeatureIndex;

    //
    // Get the feature associated with the current item
    //

    pFeature = PGetFeatureFromItem(pUiData->ci.pUIInfo, pOptItem, &dwFeatureIndex);
    if (pFeature == NULL)
        return;

    if (pOptItem->Sel < 0 || pOptItem->Sel >= (LONG) pFeature->Options.dwCount)
    {
        RIP(("Invalid selection for the current item\n"));
        return;
    }

    ZeroMemory(pUiData->abEnabledOptions, sizeof(pUiData->abEnabledOptions));
    pUiData->abEnabledOptions[pOptItem->Sel] = TRUE;

    ReconstructOptionArray(pUiData->ci.pRawData,
                           pUiData->ci.pCombinedOptions,
                           MAX_COMBINED_OPTIONS,
                           dwFeatureIndex,
                           pUiData->abEnabledOptions);
}



VOID
VMarkSelectionConstrained(
    IN OUT POPTITEM pOptItem,
    IN DWORD        dwIndex,
    IN BOOL         bEnable
    )

/*++

Routine Description:

    Indicate whether a selection is constrained or not

Arguments:

    pOptItem - Pointer to the OPTITEM in question
    pOptParam - Specifies the index of the OPTPARAM in question
    bEnable - Whether the selection is constrained or not
              Enable means not constrained!

Return Value:

    NONE

Note:

    bEnable is the returned value from EnumEnabledOptions,

    bEnable is FALSE if the option is contrained by some
    other feature, selections.

    bEnable is TRUE if the options is not constrained
    by other feature, selections.

--*/

{
    POPTPARAM pOptParam;

    //
    // This function only work on certain types of OPTTYPE
    //

    ASSERT(pOptItem->pOptType->Type == TVOT_2STATES ||
           pOptItem->pOptType->Type == TVOT_3STATES ||
           pOptItem->pOptType->Type == TVOT_LISTBOX ||
           pOptItem->pOptType->Type == TVOT_COMBOBOX);

    pOptParam = pOptItem->pOptType->pOptParam + dwIndex;

    //
    // Set the constrained flag or clear it depending on the latest
    // check with EnumEnabledOptions
    //

    if (!bEnable && ! (pOptParam->Flags & CONSTRAINED_FLAG))
    {
        pOptParam->Flags |= CONSTRAINED_FLAG;
        pOptItem->Flags |= OPTIF_CHANGED;
    }
    else if (bEnable && (pOptParam->Flags & CONSTRAINED_FLAG))
    {
        pOptParam->Flags &= ~CONSTRAINED_FLAG;
        pOptItem->Flags |= OPTIF_CHANGED;
    }

    pOptParam->lParam = (LONG) bEnable;
}



VOID
VPropShowConstraints(
    IN PUIDATA  pUiData,
    IN INT      iMode
    )

/*++

Routine Description:

    Indicate which items are constrained.
    General rule - Any features that has a coresponding an applicable GID or a
    Generic Feature Item, check for constrained.  Ignore all others
    because it's not applicable.

Arguments:

    pUiData - Pointer to our UIDATA structure
    iMode   - MODE_DOCANDPRINTER_STICKY, MODE_PRINTER_STICKY
Return Value:

    NONE
--*/

{
    POPTITEM    pOptItem;
    DWORD       dwOptItem;
    DWORD       dwFeature, dwOption, dwNumOptions, dwIndex;

    #ifdef PSCRIPT

    if (iMode != MODE_PRINTER_STICKY)
    {
        VSyncRevPrintAndOutputOrder(pUiData, NULL);
    }

    #endif // PSCRIPT

    //
    // Go through all the features in the treeview
    //

    pOptItem = pUiData->pDrvOptItem;
    dwOptItem = pUiData->dwDrvOptItem;

    for ( ; dwOptItem--; pOptItem++)
    {

        if (! ISCONSTRAINABLEITEM(pOptItem->UserData) ||
          ! PGetFeatureFromItem(pUiData->ci.pUIInfo, pOptItem, &dwFeature))
        {
            continue;
        }

        //
        // Call the parser to get which options to be disable, or contrained
        // for this feature , so need to gray it out.
        //

        ZeroMemory(pUiData->abEnabledOptions, sizeof(pUiData->abEnabledOptions));

        if (! EnumEnabledOptions(pUiData->ci.pRawData,
                                 pUiData->ci.pCombinedOptions,
                                 dwFeature,
                                 pUiData->abEnabledOptions,
                                 iMode))
        {
            VERBOSE(("EnumEnabledOptions failed\n"));
        }

        //
        // Loop through all options and mark the constraint
        //

        dwNumOptions = pOptItem->pOptType->Count;

        if (GETUSERDATAITEM(pOptItem->UserData) == FORMNAME_ITEM)
        {
            for (dwIndex = 0; dwIndex < dwNumOptions; dwIndex++)
            {
                dwOption = pUiData->pwPaperFeatures[dwIndex];

                if (dwOption == OPTION_INDEX_ANY)
                    continue;

                VMarkSelectionConstrained(pOptItem,
                                          dwIndex,
                                          pUiData->abEnabledOptions[dwOption]);
            }
        }
        else if (GETUSERDATAITEM(pOptItem->UserData) == FORM_TRAY_ITEM)
        {
            if (pOptItem == pUiData->pFormTrayItems)
            {
                POPTITEM pTrayItem;
                PBOOL    pbEnable;

                //
                // Update form-to-tray assignment table items
                //

                pbEnable = pUiData->abEnabledOptions;
                pTrayItem = pUiData->pFormTrayItems;
                dwIndex = pUiData->dwFormTrayItem;

                for ( ; dwIndex--; pTrayItem++, pbEnable++)
                {
                    if (pTrayItem->Flags & OPTIF_HIDE)
                        continue;

                    if (*pbEnable && (pTrayItem->Flags & OPTIF_DISABLED))
                    {
                        pTrayItem->Flags &= ~OPTIF_DISABLED;
                        pTrayItem->Flags |= OPTIF_CHANGED;
                    }
                    else if (!*pbEnable && !(pTrayItem->Flags & OPTIF_DISABLED))
                    {
                        pTrayItem->Flags |= (OPTIF_DISABLED|OPTIF_CHANGED);
                        pTrayItem->Sel = -1;
                    }
                }
            }
        }
        else
        {
            for (dwOption=0; dwOption < dwNumOptions; dwOption++)
            {
                VMarkSelectionConstrained(pOptItem,
                                          dwOption,
                                          pUiData->abEnabledOptions[dwOption]);
            }
        }
    }
}



INT_PTR CALLBACK
BConflictsDlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    Dialog procedure for handle "Conflicts" dialog

Arguments:

    hDlg - Handle to dialog window
    uMsg - Message
    wParam, lParam - Parameters

Return Value:

    TRUE or FALSE depending on whether message is processed

--*/

{
    PDLGPARAM       pDlgParam;
    POPTITEM        pOptItem;
    PFEATURE        pFeature;
    POPTION         pOption;
    DWORD           dwFeature, dwOption;
    PCWSTR          pDisplayName;
    WCHAR           awchBuf[MAX_DISPLAY_NAME];
    PCOMMONINFO     pci;
    CONFLICTPAIR    ConflictPair;


    switch (uMsg)
    {
    case WM_INITDIALOG:

        pDlgParam = (PDLGPARAM) lParam;
        ASSERT(pDlgParam != NULL);

        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pDlgParam);

        pci = (PCOMMONINFO) pDlgParam->pUiData;
        pOptItem = pDlgParam->pOptItem;

        if (GETUSERDATAITEM(pOptItem->UserData) == FORMNAME_ITEM)
            dwOption = pDlgParam->pUiData->pwPaperFeatures[pOptItem->Sel];
        else
            dwOption = pOptItem->Sel;

        //
        // Get the feature id for the current feature and selection
        //

        if (! PGetFeatureFromItem(pci->pUIInfo, pOptItem, &dwFeature))
            return FALSE;

        //
        // Get the first conflicting feature, option for the current pair
        //

        if (! EnumNewPickOneUIConflict(pci->pRawData,
                                       pci->pCombinedOptions,
                                       dwFeature,
                                       dwOption,
                                       &ConflictPair))
        {
            ERR(("No conflict found?\n"));
            return FALSE;
        }

        pFeature = PGetIndexedFeature(pci->pUIInfo, ConflictPair.dwFeatureIndex1);
        pOption = PGetIndexedOption(pci->pUIInfo, pFeature, ConflictPair.dwOptionIndex1);

        //
        // Display the current feature selection
        // Get feature name first
        //

        if (pDisplayName = PGetReadOnlyDisplayName(pci, pFeature->loDisplayName))
        {
            wcscpy(awchBuf, pDisplayName);
            wcscat(awchBuf, TEXT(" : "));
        }

        //
        // Kludgy fix for form - We show the form enumerated by
        // form database and map these logical forms to our supported physical
        // papersize.  So we have to notify the user with the logical form
        // selected and not the mapped physical form returned by EnumConflict
        //

        if (pFeature->dwFeatureID == GID_PAGESIZE)
            pDisplayName = pci->pdm->dmFormName;
        else if (pOption)
            pDisplayName = GET_OPTION_DISPLAY_NAME(pci, pOption);
        else
            pDisplayName = NULL;

        if (pDisplayName)
            wcscat(awchBuf, pDisplayName);

        SetDlgItemText(hDlg, IDC_FEATURE1, awchBuf);

        pFeature = PGetIndexedFeature(pci->pUIInfo, ConflictPair.dwFeatureIndex2);
        pOption = PGetIndexedOption(pci->pUIInfo, pFeature, ConflictPair.dwOptionIndex2);

        //
        // Display the current feature selection
        // Get feature name first
        //

        if (pDisplayName = PGetReadOnlyDisplayName(pci, pFeature->loDisplayName))
        {
            wcscpy(awchBuf, pDisplayName);
            wcscat(awchBuf, TEXT(" : "));
        }


        if (pFeature->dwFeatureID == GID_PAGESIZE)
            pDisplayName = pci->pdm->dmFormName;
        else if (pOption)
            pDisplayName = GET_OPTION_DISPLAY_NAME(pci, pOption);
        else
            pDisplayName = NULL;

        if (pDisplayName)
            wcscat(awchBuf, pDisplayName);

        SetDlgItemText(hDlg, IDC_FEATURE2, awchBuf);


        if (pDlgParam->bFinal)
        {
            //
            // If user is trying to exit the dialog
            //

            ShowWindow(GetDlgItem(hDlg, IDC_IGNORE), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDC_CANCEL), SW_HIDE);
            CheckRadioButton(hDlg, IDC_RESOLVE, IDC_CANCEL_FINAL, IDC_RESOLVE);
            pDlgParam->dwResult = CONFLICT_RESOLVE;

        }
        else
        {
            //
            // Hide the Resolve button
            //

            ShowWindow(GetDlgItem(hDlg, IDC_RESOLVE), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDC_CANCEL_FINAL), SW_HIDE);
            CheckRadioButton(hDlg, IDC_IGNORE, IDC_CANCEL, IDC_IGNORE);
            pDlgParam->dwResult = CONFLICT_IGNORE;

        }

        ShowWindow(hDlg, SW_SHOW);
        return TRUE;

    case WM_COMMAND:

        pDlgParam = (PDLGPARAM)GetWindowLongPtr(hDlg, DWLP_USER);

        switch (LOWORD(wParam))
        {
        case IDC_CANCEL:
        case IDC_CANCEL_FINAL:
            pDlgParam->dwResult = CONFLICT_CANCEL;
            break;

        case IDC_IGNORE:
            pDlgParam->dwResult = CONFLICT_IGNORE;
            break;

        case IDC_RESOLVE:
            pDlgParam->dwResult = CONFLICT_RESOLVE;
            break;

        case IDOK:
        case IDCANCEL:
            EndDialog(hDlg, LOWORD(wParam));
            return TRUE;
        }
    }

    return FALSE;
}



VOID
VUpdateOptItemList(
    IN OUT  PUIDATA     pUiData,
    IN      POPTSELECT  pOldCombinedOptions,
    IN      POPTSELECT  pNewCombinedOptions
    )

/*++

Routine Description:

    Ssync up OPTITEM list with the updated options array.

Arguments:

    pUiData - Pointer to our UIDATA structure
    pOldCombinedOptions - A copy of the pre-resolved options array,
    this should cut down the updating costs, only updated if it's changed
    pNewCombinedOptions - the current options array

Return Value:

    None

--*/

{
    DWORD       i, dwFeatures, dwDrvOptItem;
    PFEATURE    pFeature;
    PUIINFO     pUIInfo = pUiData->ci.pUIInfo;
    PCSTR       pKeywordName, pFeatureKeywordName;
    POPTITEM    pOptItem;

    if (pUiData->dwDrvOptItem == 0)
    {
        //
        // nothing to update
        //

        return;
    }

    dwFeatures = pUiData->ci.pRawData->dwDocumentFeatures +
                 pUiData->ci.pRawData->dwPrinterFeatures;

    for (i = 0; i < dwFeatures; i++)
    {
        if (pOldCombinedOptions[i].ubCurOptIndex != pNewCombinedOptions[i].ubCurOptIndex)
        {
            dwDrvOptItem = pUiData->dwDrvOptItem;
            pOptItem = pUiData->pDrvOptItem;

            pFeature = PGetIndexedFeature(pUIInfo, i);

            ASSERT(pFeature);

            while( dwDrvOptItem--)
            {
                pKeywordName = GETUSERDATAKEYWORDNAME(pOptItem->UserData);
                pFeatureKeywordName = OFFSET_TO_POINTER(pUIInfo->pubResourceData,
                                                        pFeature->loKeywordName);

                ASSERT(pFeatureKeywordName);

                if (pKeywordName && pFeatureKeywordName &&
                    (strcmp(pFeatureKeywordName, pKeywordName) == EQUAL_STRING))
                    break;

                pOptItem++;
            }

            pOptItem->Sel = pNewCombinedOptions[i].ubCurOptIndex;
            pOptItem->Flags |= OPTIF_CHANGED;


            //
            // This is necessary to ssync up the colormode changes with the color information
            //

            #ifdef UNIDRV
            if (GETUSERDATAITEM(pOptItem->UserData) == COLORMODE_ITEM)
                VSyncColorInformation(pUiData, pOptItem);
            #endif
        }
    }

    VPropShowConstraints(pUiData,
                         (pUiData->iMode == MODE_PRINTER_STICKY) ? pUiData->iMode : MODE_DOCANDPRINTER_STICKY);
}


INT
ICheckConstraintsDlg(
    IN OUT  PUIDATA     pUiData,
    IN OUT  POPTITEM    pOptItem,
    IN      DWORD       dwOptItem,
    IN      BOOL        bFinal
    )

/*++

Routine Description:

    Check if the user chose any constrained selection

Arguments:

    pUiData - Pointer to our UIDATA structure
    pOptItem - Pointer to an array of OPTITEMs
    dwOptItem - Number of items to be checked
    bFinal - Whether this is called when user tries to exit the dialog

Return Value:

    CONFLICT_NONE - no conflicts
    CONFLICT_RESOLVE - click RESOLVE to automatically resolve conflicts
    CONFLICT_CANCEL - click CANCEL to back out of changes
    CONFLICT_IGNORE - click IGNORE to ignore conflicts

--*/

{
    DLGPARAM    DlgParam;
    OPTSELECT   OldCombinedOptions[MAX_COMBINED_OPTIONS];


    DlgParam.pfnComPropSheet = pUiData->pfnComPropSheet;
    DlgParam.hComPropSheet = pUiData->hComPropSheet;
    DlgParam.pUiData = pUiData;
    DlgParam.bFinal = bFinal;
    DlgParam.dwResult = CONFLICT_NONE;

    for ( ; dwOptItem--; pOptItem++)
    {
        //
        // If the item is not constrainable, skip it.
        //

        if (! ISCONSTRAINABLEITEM(pOptItem->UserData))
            continue;

        //
        // If user has clicked IGNORE before, then don't bother
        // checking anymore until he tries to exit the dialog.
        //

        //if (pUiData->bIgnoreConflict && !bFinal)
        //    break;

        //
        // If there is a conflict, then display a warning message
        //

        if (IS_CONSTRAINED(pOptItem, pOptItem->Sel))
        {
            DlgParam.pOptItem = pOptItem;
            DlgParam.dwResult = CONFLICT_NONE;

            DialogBoxParam(ghInstance,
                        MAKEINTRESOURCE(IDD_CONFLICTS),
                        pUiData->hDlg,
                        (DLGPROC) BConflictsDlgProc,
                        (LPARAM) &DlgParam);

            //
            // Automatically resolve conflicts. We're being very
            // simple-minded here, i.e. picking the first selection
            // that's not constrained.
            //

            if (DlgParam.dwResult == CONFLICT_RESOLVE)
            {

                ASSERT((bFinal == TRUE));

                //
                // Save a copy the pre-resolve optionarray
                //

                CopyMemory(OldCombinedOptions,
                           pUiData->ci.pCombinedOptions,
                           MAX_COMBINED_OPTIONS * sizeof(OPTSELECT));

                //
                // Call the parsers to resolve the conflicts
                //
                // Note: If we're inside DrvDocumentPropertySheets,
                // we'll call the parser to resolve conflicts between
                // all printer features. Since all printer-sticky
                // features have higher priority than all doc-sticky
                // features, only doc-sticky option selections should
                // be affected.
                //

                ResolveUIConflicts(pUiData->ci.pRawData,
                                   pUiData->ci.pCombinedOptions,
                                   MAX_COMBINED_OPTIONS,
                                   (pUiData->iMode == MODE_PRINTER_STICKY) ?
                                        pUiData->iMode :
                                        MODE_DOCANDPRINTER_STICKY);

                //
                // Update the OPTITEM list to match the updated options array
                //

                VUpdateOptItemList(pUiData, OldCombinedOptions, pUiData->ci.pCombinedOptions);

            }
            else if (DlgParam.dwResult == CONFLICT_IGNORE)
            {
                //
                // Ignore any future conflicts until the
                // user tries to close the property sheet.
                //

                pUiData->bIgnoreConflict = TRUE;
            }

            break;
        }
    }

    return DlgParam.dwResult;
}



BOOL
BOptItemSelectionsChanged(
    IN POPTITEM pItems,
    IN DWORD    dwItems
    )

/*++

Routine Description:

    Check if any of the OPTITEM's was changed by the user

Arguments:

    pItems - Pointer to an array of OPTITEM's
    dwItems - Number of OPTITEM's

Return Value:

    TRUE if anything was changed, FALSE otherwise

--*/

{
    for ( ; dwItems--; pItems++)
    {
        if (pItems->Flags & OPTIF_CHANGEONCE)
            return TRUE;
    }

    return FALSE;
}



POPTITEM
PFindOptItem(
    IN PUIDATA  pUiData,
    IN DWORD    dwItemId
    )

/*++

Routine Description:

    Find an OPTITEM with the specified identifier

Arguments:

    pUiData - Points to UIDATA structure
    dwItemId - Specifies the interested item identifier

Return Value:

    Pointer to OPTITEM with the specified id,
    NULL if no such item is found

--*/

{
    POPTITEM    pOptItem = pUiData->pDrvOptItem;
    DWORD       dwOptItem = pUiData->dwDrvOptItem;

    for ( ; dwOptItem--; pOptItem++)
    {
        if (GETUSERDATAITEM(pOptItem->UserData) == dwItemId)
            return pOptItem;
    }

    return NULL;
}



INT
IDisplayErrorMessageBox(
    HWND    hwndParent,
    UINT    uType,
    INT     iTitleStrId,
    INT     iFormatStrId,
    ...
    )

/*++

Routine Description:

    Display an error message box

Arguments:

    hwndParent - Handle to the parent window
    uType - Type of message box to display
        if 0, the default value is MB_OK | MB_ICONERROR
    iTitleStrId - String resource ID for the message box title
    iFormatStrId - String resource ID for the message itself.
        This string can contain printf format specifications.
    ... - Optional arguments.

Return Value:

    Return value from MessageBox() call.

--*/

#define MAX_MBTITLE_LEN     128
#define MAX_MBFORMAT_LEN    512
#define MAX_MBMESSAGE_LEN   1024

{
    PWSTR   pwstrTitle, pwstrFormat, pwstrMessage;
    INT     iResult;
    va_list ap;

    pwstrTitle = pwstrFormat = pwstrMessage = NULL;

    if ((pwstrTitle = MemAllocZ(sizeof(WCHAR) * MAX_MBTITLE_LEN)) &&
        (pwstrFormat = MemAllocZ(sizeof(WCHAR) * MAX_MBFORMAT_LEN)) &&
        (pwstrMessage = MemAllocZ(sizeof(WCHAR) * MAX_MBMESSAGE_LEN)))
    {
        //
        // Load message box title and format string resources
        //

        LoadString(ghInstance, iTitleStrId, pwstrTitle, MAX_MBTITLE_LEN);
        LoadString(ghInstance, iFormatStrId, pwstrFormat, MAX_MBFORMAT_LEN);

        //
        // Compose the message string
        //

        va_start(ap, iFormatStrId);
        wvsprintf(pwstrMessage, pwstrFormat, ap);
        va_end(ap);

        //
        // Display the message box
        //

        if (uType == 0)
            uType = MB_OK | MB_ICONERROR;

        iResult = MessageBox(hwndParent, pwstrMessage, pwstrTitle, uType);
    }
    else
    {
        MessageBeep(MB_ICONERROR);
        iResult = 0;
    }

    MemFree(pwstrTitle);
    MemFree(pwstrFormat);
    MemFree(pwstrMessage);
    return iResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\driverui\devcaps.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    devcaps.c

Abstract:

    This file handles the DrvDeviceCapabilities spooler API.

Environment:

    Win32 subsystem, DriverUI module, user mode

Revision History:

    02/13/97 -davidx-
        Implement OEM plugin support.

    02/10/97 -davidx-
        Consistent handling of common printer info.

    02/04/97 -davidx-
        Reorganize driver UI to separate ps and uni DLLs.

    07/17/96 -amandan-
        Created it.

--*/

#include "precomp.h"



DWORD
DwDeviceCapabilities(
    HANDLE      hPrinter,
    PWSTR       pDeviceName,
    WORD        wCapability,
    PVOID       pOutput,
    DWORD       dwBufSize,
    PDEVMODE    pdmSrc
    )

/*++

Routine Description:

    This function support the querrying of device capabilities
    It gets the binary data (UIINFO) from the parser and return
    the requested capability to the caller.

Arguments:

    hPrinter    handle to printer object
    pDeviceName pointer to device name
    wCapability specifies the requested capability
    pOutput     pointer to output buffer
    dwBufSize   Size of output buffer in number of characters
    pdmSrc      pointer to input devmode


Return Value:
    The capabilities supported and relevant information in pOutput

--*/

{
    DWORD                       dwOld,dwDrv,dwRet = GDI_ERROR;
    PDEVMODE                    pdm;
    PCOMMONINFO                 pci;
    FORM_TRAY_TABLE             pFormTrayTable;
    PFN_OEMDeviceCapabilities   pfnOEMDeviceCapabilities;
    BOOL                        bEMFSpooling, bNup;

    //
    // Load basic printer info
    // Process devmode information: driver default + input devmode
    // Fix up options array with public devmode information
    // Get an updated printer description data instance
    //

    if (! (pci = PLoadCommonInfo(hPrinter, pDeviceName, 0)) ||

        #ifndef WINNT_40
        ! ( (wCapability != DC_PRINTERMEM &&
             wCapability != DC_DUPLEX &&
             wCapability != DC_COLLATE &&
             wCapability != DC_STAPLE)||
            (BFillCommonInfoPrinterData(pci)) ) ||
        #endif

        ! BFillCommonInfoDevmode(pci, NULL, pdmSrc) ||
        ! BCombineCommonInfoOptionsArray(pci))
    {
        goto devcaps_exit;
    }

    VFixOptionsArrayWithDevmode(pci);

    (VOID) ResolveUIConflicts(pci->pRawData,
                              pci->pCombinedOptions,
                              MAX_COMBINED_OPTIONS,
                              MODE_DOCUMENT_STICKY);

    VOptionsToDevmodeFields(pci, TRUE);

    if (! BUpdateUIInfo(pci))
        goto devcaps_exit;

    pdm = pci->pdm;

    //
    // Get spooler EMF cap so that we can report COLLATE and COPIES correctly
    //

    VGetSpoolerEmfCaps(pci->hPrinter, &bNup, &bEMFSpooling, 0, NULL);

    switch (wCapability)
    {
    case DC_VERSION:

        dwRet = pdm->dmSpecVersion;
        break;

    case DC_DRIVER:

        dwRet = pdm->dmDriverVersion;
        break;

    case DC_SIZE:

        dwRet = pdm->dmSize;
        break;

    case DC_EXTRA:

        dwRet = pdm->dmDriverExtra;
        break;

    case DC_FIELDS:

        dwRet = pdm->dmFields;
        break;

    case DC_FILEDEPENDENCIES:

        if (pOutput != NULL)
            *((PWSTR) pOutput) = NUL;
        dwRet = 0;
        break;

    case DC_COPIES:

        if (bEMFSpooling && ISSET_MFSPOOL_FLAG(pci->pdmPrivate))
            dwRet = max(MAX_COPIES, (SHORT)pci->pUIInfo->dwMaxCopies);
        else
            dwRet = pci->pUIInfo->dwMaxCopies;

        break;

    case DC_DUPLEX:

        dwRet = SUPPORTS_DUPLEX(pci) ? 1: 0;
        break;

    case DC_TRUETYPE:

        if (! (pdm->dmFields & DM_TTOPTION))
            dwRet = 0;
        else
            dwRet = _DwGetFontCap(pci->pUIInfo);
        break;

    case DC_ORIENTATION:

        dwRet = _DwGetOrientationAngle(pci->pUIInfo, pdm);
        break;

    case DC_PAPERNAMES:

        dwRet = DwEnumPaperSizes(pci, pOutput, NULL, NULL, NULL, dwBufSize);
        break;

    case DC_PAPERS:

        dwRet = DwEnumPaperSizes(pci, NULL, pOutput, NULL, NULL, dwBufSize);
        break;

    case DC_PAPERSIZE:

        dwRet = DwEnumPaperSizes(pci, NULL, NULL, pOutput, NULL, dwBufSize);
        break;

    case DC_MINEXTENT:
    case DC_MAXEXTENT:

        dwRet = DwCalcMinMaxExtent(pci, pOutput, wCapability);
        break;

    case DC_BINNAMES:

        dwRet = DwEnumBinNames(pci, pOutput);
        break;

    case DC_BINS:

        dwRet = DwEnumBins(pci, pOutput);
        break;

    case DC_ENUMRESOLUTIONS:

        dwRet = DwEnumResolutions( pci, pOutput);
        break;

    case DC_COLLATE:

        if (bEMFSpooling && ISSET_MFSPOOL_FLAG(pci->pdmPrivate))
            dwRet = DRIVER_SUPPORTS_COLLATE(pci);
        else
            dwRet = PRINTER_SUPPORTS_COLLATE(pci);

        break;

    //
    // Following device capabilities are not available on NT4
    //

    #ifndef WINNT_40

    case DC_COLORDEVICE:

        dwRet = IS_COLOR_DEVICE(pci->pUIInfo) ? 1 : 0;
        break;

    case DC_NUP:

        dwRet = DwEnumNupOptions(pci, pOutput);
        break;

    case DC_PERSONALITY:

        dwRet = _DwEnumPersonalities(pci, pOutput);
        break;

    case DC_PRINTRATE:

        if ((dwRet = pci->pUIInfo->dwPrintRate) == 0)
            dwRet = GDI_ERROR;

        break;

    case DC_PRINTRATEUNIT:

        if ((dwRet = pci->pUIInfo->dwPrintRateUnit) == 0)
            dwRet = GDI_ERROR;
        break;

    case DC_PRINTRATEPPM:

        if ((dwRet = pci->pUIInfo->dwPrintRatePPM) == 0)
            dwRet = GDI_ERROR;
        break;

    case DC_PRINTERMEM:

        dwRet = DwGetAvailablePrinterMem(pci);
        break;

    case DC_MEDIAREADY:

        //
        // Get current form-tray assignment table
        //

        if (pFormTrayTable = PGetFormTrayTable(pci->hPrinter, NULL))
        {
            PWSTR   pwstr;

            //
            // Get list of currently assigned forms.
            // Notice that DwEnumMediaReady returns currently
            // form names in place of the original form-tray table.
            //

            dwRet = DwEnumMediaReady(pFormTrayTable, NULL);

            if (dwRet > 0 && pOutput != NULL)
            {
                pwstr = pFormTrayTable;

                while (*pwstr)
                {
                    CopyString(pOutput, pwstr, CCHPAPERNAME);
                    pOutput = (PWSTR) pOutput + CCHPAPERNAME;
                    pwstr += wcslen(pwstr) + 1;
                }
            }

            MemFree(pFormTrayTable);
        }
        else
        {
            PCWSTR pwstrDefault = IsMetricCountry() ? A4_FORMNAME : LETTER_FORMNAME;
            dwRet = 1;

            if (pOutput)
                CopyString(pOutput, pwstrDefault, CCHPAPERNAME);
        }
        break;

    case DC_STAPLE:

        dwRet = _BSupportStapling(pci);
        break;

    case DC_MEDIATYPENAMES:

        dwRet = DwEnumMediaTypes(pci, pOutput, NULL);
        break;

    case DC_MEDIATYPES:

        dwRet = DwEnumMediaTypes(pci, NULL, pOutput);
        break;

    #endif // !WINNT_40

    default:

        SetLastError(ERROR_NOT_SUPPORTED);
        break;
    }

    //
    // Call OEMDeviceCapabilities entrypoint for each plugin.
    // If dwRet is GDI_ERROR at this point, it means the system driver
    // doesn't support the requested device capability or an error
    // prevented the system driver from handling it.
    //

    dwDrv = dwRet;

    FOREACH_OEMPLUGIN_LOOP(pci)


        dwOld = dwRet;

        if (HAS_COM_INTERFACE(pOemEntry))
        {
            if (HComOEMDeviceCapabilities(
                                pOemEntry,
                                &pci->oemuiobj,
                                hPrinter,
                                pDeviceName,
                                wCapability,
                                pOutput,
                                pdm,
                                pOemEntry->pOEMDM,
                                dwOld,
                                &dwRet) == E_NOTIMPL)
                continue;

        }
        else
        {
            if (pfnOEMDeviceCapabilities = GET_OEM_ENTRYPOINT(pOemEntry, OEMDeviceCapabilities))
            {

                dwRet = pfnOEMDeviceCapabilities(
                                &pci->oemuiobj,
                                hPrinter,
                                pDeviceName,
                                wCapability,
                                pOutput,
                                pdm,
                                pOemEntry->pOEMDM,
                                dwOld);
           }
        }

        if (dwRet == GDI_ERROR && dwOld != GDI_ERROR)
        {
            ERR(("OEMDeviceCapabilities failed for '%ws': %d\n",
                 CURRENT_OEM_MODULE_NAME(pOemEntry),
                 GetLastError()));
        }


    END_OEMPLUGIN_LOOP

    //
    // The flaw of this API is there is no size associated with the input buffer.
    // We have to assume that the app is doing the right thing and allocate enough
    // buffer to hold our values.  However, the values can change if the OEM plugins
    // choose to change the value.  We have no way of determine that.
    // To err on the safe side, we will always ask the app to allocate the larger
    // of the two values (Unidrv and OEM). When asked the second time to fill out
    // the buffer, OEM can return the correct values.
    //

    if ((pOutput == NULL &&  dwRet != GDI_ERROR &&
         dwDrv !=GDI_ERROR && dwRet < dwDrv) &&
        (wCapability == DC_PAPERNAMES || wCapability == DC_PAPERS   ||
         wCapability == DC_PAPERSIZE  || wCapability == DC_BINNAMES ||
         wCapability == DC_BINS ||

         #ifndef WINNT_40
         wCapability == DC_NUP  || wCapability == DC_PERSONALITY    ||
         wCapability == DC_MEDIAREADY || wCapability == DC_MEDIATYPENAMES ||
         wCapability == DC_MEDIATYPES ||
         #endif

         wCapability == DC_ENUMRESOLUTIONS) )
    {
        //
        // The size returned by OEM is smaller than what Unidrv needs, so modifies it
        //

        if (dwRet == 0)
            dwRet = GDI_ERROR;
        else
            dwRet = dwDrv;

    }

devcaps_exit:

    if (dwRet == GDI_ERROR)
        TERSE(("DrvDeviceCapabilities(%d) failed: %d\n", wCapability, GetLastError()));

    VFreeCommonInfo(pci);
    return dwRet;
}


DWORD
DrvSplDeviceCaps(
    HANDLE      hPrinter,
    PWSTR       pDeviceName,
    WORD        wCapability,
    PVOID       pOutput,
    DWORD       dwBufSize,
    PDEVMODE    pdmSrc
    )

/*++

Routine Description:

    This function support the querrying of device capabilities
    It gets the binary data (UIINFO) from the parser and return
    the requested capability to the caller.

Arguments:

    hPrinter    handle to printer object
    pDeviceName pointer to device name
    wCapability specifies the requested capability
    pOutput     pointer to output buffer
    pdmSrc      pointer to input devmode


Return Value:
    The capabilities supported and relevant information in pOutput

--*/

{

    switch (wCapability) {

    case DC_PAPERNAMES:
        return (DwDeviceCapabilities(hPrinter,
                                 pDeviceName,
                                 wCapability,
                                 pOutput,
                                 dwBufSize,
                                 pdmSrc));
    default:
        return GDI_ERROR;

    }

}


DWORD
DrvDeviceCapabilities(
    HANDLE      hPrinter,
    PWSTR       pDeviceName,
    WORD        wCapability,
    PVOID       pOutput,
    PDEVMODE    pdmSrc
    )

/*++

Routine Description:

    This function support the querrying of device capabilities
    It gets the binary data (UIINFO) from the parser and return
    the requested capability to the caller.

Arguments:

    hPrinter    handle to printer object
    pDeviceName pointer to device name
    wCapability specifies the requested capability
    pOutput     pointer to output buffer
    pdmSrc      pointer to input devmode


Return Value:
    The capabilities supported and relevant information in pOutput

--*/

{
    return (DwDeviceCapabilities(hPrinter,
                                 pDeviceName,
                                 wCapability,
                                 pOutput,
                                 UNUSED_PARAM,
                                 pdmSrc));

}
DWORD
DwEnumPaperSizes(
    PCOMMONINFO pci,
    PWSTR       pPaperNames,
    PWORD       pPapers,
    PPOINT      pPaperSizes,
    PWORD       pPaperFeatures,
    DWORD       dwPaperNamesBufSize
    )

/*++

Routine Description:

    This function retrieves a list of supported paper sizes

Arguments:

    pci - Points to basic printer information
    pForms - List of spooler forms
    dwForms - Number of spooler forms
    pPaperNames - Buffer for returning supported paper size names
    pPapers - Buffer for returning supported paper size indices
    pPaperSizes - Buffer for returning supported paper size dimensions
    pPaperFeatures - Buffer for returning supported paper size option indices
    dwPaperNamesBufSize - Size of buffer holding paper names in characters

Return Value:

    Number of paper sizes supported, GDI_ERROR if there is an error.

--*/

{
    PFORM_INFO_1    pForms;
    DWORD           dwCount, dwIndex, dwOptionIndex = 0;

    #ifdef UNIDRV
    PFEATURE        pFeature;
    PPAGESIZE       pPageSize;
    PPAGESIZEEX     pPageSizeEx;
    #endif


    //
    // Get the list of spooler forms if we haven't done so already
    //

    if (pci->pSplForms == NULL)
        pci->pSplForms = MyEnumForms(pci->hPrinter, 1, &pci->dwSplForms);

    if (pci->pSplForms == NULL)
    {
        ERR(("No spooler forms.\n"));
        return GDI_ERROR;
    }

    //
    // Go through each form in the forms database
    //

    dwCount = 0;
    pForms = pci->pSplForms;

    #ifdef UNIDRV
    pFeature = GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_PAGESIZE);
    #endif

    for (dwIndex=0; dwIndex < pci->dwSplForms; dwIndex++, pForms++)
    {
        //
        // If the form is supported on the printer, then
        // increment the paper size count and collect
        // requested information
        //

        if (! BFormSupportedOnPrinter(pci, pForms, &dwOptionIndex))
            continue;

        dwCount++;

        //
        // Return the size of the form in 0.1mm units.
        // The unit used in FORM_INFO_1 is 0.001mm.
        // Fill pPaperSizes with the form info supported by the printer
        //

        if (pPaperSizes)
        {
            pPaperSizes->x = pForms->Size.cx / DEVMODE_PAPER_UNIT;
            pPaperSizes->y = pForms->Size.cy / DEVMODE_PAPER_UNIT;

            #ifdef UNIDRV
            if (pFeature &&
                (pPageSize = PGetIndexedOption(pci->pUIInfo, pFeature, dwOptionIndex)) &&
                (pPageSizeEx = OFFSET_TO_POINTER(pci->pInfoHeader, pPageSize->GenericOption.loRenderOffset)) &&
                (pPageSizeEx->bRotateSize))
            {
               LONG lTemp;

               lTemp = pPaperSizes->x;
               pPaperSizes->x = pPaperSizes->y;
               pPaperSizes->y = lTemp;
            }
            #endif // UNIDRV

            pPaperSizes++;
        }

        //
        // Return the formname.
        //

        if (pPaperNames)
        {
            if (dwPaperNamesBufSize == UNUSED_PARAM)
            {
                CopyString(pPaperNames, pForms->pName, CCHPAPERNAME);
                pPaperNames += CCHPAPERNAME;
            }
            else if (dwPaperNamesBufSize >= CCHPAPERNAME)
            {
                CopyString(pPaperNames, pForms->pName, CCHPAPERNAME);
                pPaperNames += CCHPAPERNAME;
                dwPaperNamesBufSize -= CCHPAPERNAME;
            }
            else
            {
                dwCount--;
                break;
            }
        }

        //
        // Return one-based index of the form.
        //

        if (pPapers)
            *pPapers++ = (WORD) (dwIndex + DMPAPER_FIRST);

        //
        // Return page size feature index
        //

        if (pPaperFeatures)
            *pPaperFeatures++ = (WORD) dwOptionIndex;
    }

    #ifdef PSCRIPT

    {
        PPPDDATA    pPpdData;
        PPAGESIZE   pPageSize;

        pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER((PINFOHEADER) pci->pRawData);

        ASSERT(pPpdData != NULL);

        if (SUPPORT_FULL_CUSTOMSIZE_FEATURES(pci->pUIInfo, pPpdData) &&
            (pPageSize = PGetCustomPageSizeOption(pci->pUIInfo)))
        {
            ASSERT(pPageSize->dwPaperSizeID == DMPAPER_CUSTOMSIZE);
            dwCount++;

            if (pPaperSizes)
            {
                pPaperSizes->x = pci->pdmPrivate->csdata.dwX / DEVMODE_PAPER_UNIT;
                pPaperSizes->y = pci->pdmPrivate->csdata.dwY / DEVMODE_PAPER_UNIT;
                pPaperSizes++;
            }

            if (pPaperNames)
            {
                if (dwPaperNamesBufSize == UNUSED_PARAM)
                {
                    LOAD_STRING_PAGESIZE_NAME(pci, pPageSize, pPaperNames, CCHPAPERNAME);
                    pPaperNames += CCHPAPERNAME;
                }
                else if (dwPaperNamesBufSize >= CCHPAPERNAME)
                {
                    LOAD_STRING_PAGESIZE_NAME(pci, pPageSize, pPaperNames, CCHPAPERNAME);
                    pPaperNames += CCHPAPERNAME;
                    dwPaperNamesBufSize -= CCHPAPERNAME;
                }
                else
                    dwCount--;
            }

            if (pPapers)
                *pPapers++ = DMPAPER_CUSTOMSIZE;

            if (pPaperFeatures)
                *pPaperFeatures++ = (WORD) pci->pUIInfo->dwCustomSizeOptIndex;
        }
    }

    #endif // PSCRIPT

    return dwCount;
}



DWORD
DwCalcMinMaxExtent(
    PCOMMONINFO pci,
    PPOINT      pptOutput,
    WORD        wCapability
    )

/*++

Routine Description:

    This function retrieves the min and max paper size.

Arguments:

    pci - Points to basic printer information
    wCapability - What the caller is interested in:
        DC_MAXEXTENT or DC_MINEXTENT

Return Value:

    Number of paper sizes supported, GDI_ERROR if there is an error.

--*/

{
    PFORM_INFO_1    pForms;
    DWORD           dwCount, dwLoopCnt, dwOptionIndex;
    LONG            lMinX, lMinY, lMaxX, lMaxY, lcx, lcy;

    #ifdef UNIDRV
    PFEATURE        pFeature;
    PPAGESIZE       pPageSize;
    PPAGESIZEEX     pPageSizeEx;
    #endif

    //
    // Get the list of spooler forms if we haven't done so already
    //

    if (pci->pSplForms == NULL)
        pci->pSplForms = MyEnumForms(pci->hPrinter, 1, &pci->dwSplForms);

    if (pci->pSplForms == NULL)
    {
        ERR(("No spooler forms.\n"));
        return GDI_ERROR;
    }

    //
    // Go through each form in the forms database
    //

    lMinX = lMinY = MAX_LONG;
    lMaxX = lMaxY = 0;

    dwCount = 0;
    pForms = pci->pSplForms;
    dwLoopCnt = pci->dwSplForms;

    #ifdef UNIDRV
    pFeature = GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_PAGESIZE);
    #endif

    for ( ; dwLoopCnt--; pForms++)
    {
        //
        // If the form is supported on the printer, then
        // increment the paper size count and collect
        // requested information
        //

        if (! BFormSupportedOnPrinter(pci, pForms, &dwOptionIndex))
            continue;

        dwCount++;

        lcx = pForms->Size.cx;
        lcy = pForms->Size.cy;

        #ifdef UNIDRV

        //
        // Need to swap x, y as we do in DwEnumPaperSizes() if bRotateSize is True.
        //

        if (pFeature &&
            (pPageSize = PGetIndexedOption(pci->pUIInfo, pFeature, dwOptionIndex)) &&
            (pPageSizeEx = OFFSET_TO_POINTER(pci->pInfoHeader, pPageSize->GenericOption.loRenderOffset)) &&
            (pPageSizeEx->bRotateSize))
        {
           LONG lTemp;

           lTemp = lcx;
           lcx = lcy;
           lcy = lTemp;
        }

        #endif // UNIDRV

        if (lMinX > lcx)
            lMinX = lcx;

        if (lMinY > lcy)
            lMinY = lcy;

        if (lMaxX < lcx)
            lMaxX = lcx;

        if (lMaxY < lcy)
            lMaxY = lcy;
    }

    #ifdef PSCRIPT

    //
    // If the printer supports custom page size, we should
    // take that into consideration as well.
    //

    if (SUPPORT_CUSTOMSIZE(pci->pUIInfo))
    {
        PPPDDATA pPpdData;

        pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER((PINFOHEADER) pci->pRawData);

        ASSERT(pPpdData != NULL);

        if (lMinX > MINCUSTOMPARAM_WIDTH(pPpdData))
            lMinX = MINCUSTOMPARAM_WIDTH(pPpdData);

        if (lMinY > MINCUSTOMPARAM_HEIGHT(pPpdData))
            lMinY = MINCUSTOMPARAM_HEIGHT(pPpdData);

        if (lMaxX < MAXCUSTOMPARAM_WIDTH(pPpdData))
            lMaxX = MAXCUSTOMPARAM_WIDTH(pPpdData);

        if (lMaxY < MAXCUSTOMPARAM_HEIGHT(pPpdData))
            lMaxY = MAXCUSTOMPARAM_HEIGHT(pPpdData);
    }

    #endif // PSCRIPT

    //
    // Convert from micron to 0.1mm
    //

    lMinX /= DEVMODE_PAPER_UNIT;
    lMinY /= DEVMODE_PAPER_UNIT;
    lMaxX /= DEVMODE_PAPER_UNIT;
    lMaxY /= DEVMODE_PAPER_UNIT;

    //
    // Return the result as a POINTS structure
    //

    if (wCapability == DC_MINEXTENT)
    {
        lMinX = min(lMinX, 0x7fff);
        lMinY = min(lMinY, 0x7fff);

        return MAKELONG(lMinX, lMinY);
    }
    else
    {
        lMaxX = min(lMaxX, 0x7fff);
        lMaxY = min(lMaxY, 0x7fff);

        return MAKELONG(lMaxX, lMaxY);
    }
}



DWORD
DwEnumBinNames(
    PCOMMONINFO pci,
    PWSTR       pBinNames
    )

/*++

Routine Description:

    This function retrieves a list of supported paper bins

Arguments:

    pci - Points to basic printer information
    pBinNames - Buffer for returning paper bin names.
        It can be NULL if the caller is only interested
        the number of paper bins supported.

Return Value:

    Number of paper bins supported.

--*/

{
    PFEATURE    pFeature;
    PINPUTSLOT  pInputSlot;
    DWORD       dwIndex, dwCount = 0;

    //
    // Go through the list of input slots supported by the printer
    //

    pFeature = GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_INPUTSLOT);

    if ((pFeature != NULL) &&
        (dwCount = pFeature->Options.dwCount) > 0 &&
        (pBinNames != NULL))
    {
        for (dwIndex=0; dwIndex < dwCount; dwIndex++)
        {
            pInputSlot = PGetIndexedOption(pci->pUIInfo, pFeature, dwIndex);
            ASSERT(pInputSlot != NULL);

            //
            // If the first tray is "*UseFormTrayTable", change its
            // display name here to be consistent.
            //

            if (dwIndex == 0 && pInputSlot->dwPaperSourceID == DMBIN_FORMSOURCE)
            {
                LoadString(ghInstance, IDS_TRAY_FORMSOURCE, pBinNames, CCHBINNAME);
            }
            else
            {
                LOAD_STRING_OPTION_NAME(pci, pInputSlot, pBinNames, CCHBINNAME);
            }

            pBinNames += CCHBINNAME;
        }
    }

    return dwCount;
}



DWORD
DwEnumBins(
    PCOMMONINFO pci,
    PWORD       pBins
    )

/*++

Routine Description:

    This function retrieves the number of supported paper bins

Arguments:

    pci - Points to basic printer information
    pBins - Output buffer for returning paper bin indices.
        It can be NULL if the caller is only interested
        the number of paper bins supported.

Return Value:

    Number of paper bins supported.

--*/

{
    PFEATURE    pFeature;
    PINPUTSLOT  pInputSlot;
    DWORD       dwIndex, dwCount = 0;

    //
    // Go through the list of input slots supported by the printer
    //

    pFeature = GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_INPUTSLOT);

    if ((pFeature != NULL) &&
        (dwCount = pFeature->Options.dwCount) > 0 &&
        (pBins != NULL))
    {
        for (dwIndex=0; dwIndex < dwCount; dwIndex++)
        {
            pInputSlot = PGetIndexedOption(pci->pUIInfo, pFeature, dwIndex);
            ASSERT(pInputSlot != NULL);

            *pBins++ = (WORD)pInputSlot->dwPaperSourceID;
        }
    }

    return dwCount;
}



DWORD
DwEnumResolutions(
    PCOMMONINFO pci,
    PLONG       pResolutions
    )
/*++

Routine Description:

    This function retrieves a list of supported resolutions.

Arguments:

    pci - Points to basic printer information
    pResolutions - Returns information about supported resolutions.
        Two numbers are returned for each resolution option:
        one for horizontal and the other for vertical.
        Note that this can be NULL if the caller is only interested
        in the number of resolutions supported.

Return Value:

    Number of resolutions supported.

--*/

{
    DWORD       dwCount, dwIndex;
    PFEATURE    pFeature;
    PRESOLUTION pResOption;

    //
    // Go throught the list of resolutions supported by the printer
    //

    pFeature = GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_RESOLUTION);

    if (pFeature && pFeature->Options.dwCount > 0)
    {
        //
        // Enumerate all options of the resolution feature
        //

        dwCount = pFeature->Options.dwCount;

        for (dwIndex=0; dwIndex < dwCount; dwIndex++)
        {
            pResOption = PGetIndexedOption(pci->pUIInfo, pFeature, dwIndex);
            ASSERT(pResOption != NULL);

            if (pResolutions != NULL)
            {
                *pResolutions++ = pResOption->iXdpi;
                *pResolutions++ = pResOption->iYdpi;
            }
        }
    }
    else
    {
        //
        // If no resolution option is available,
        // return at least one default resolution
        //

        dwCount = 1;

        if (pResolutions != NULL)
        {
            pResolutions[0] =
            pResolutions[1] = _DwGetDefaultResolution();
        }
    }

    return dwCount;
}



DWORD
DwGetAvailablePrinterMem(
    PCOMMONINFO pci
    )

/*++

Routine Description:

    Find out how much memory is available in the printer

Arguments:

    pci - Points to base printer information

Return Value:

    Amount of memory available in the printer (in KBytes)

--*/

{
    DWORD   dwFreeMem;

    ASSERT(pci->pPrinterData && pci->pCombinedOptions);

    //
    // For PSCRIPT, the amount of free memory is stored in
    // PRINTERDATA.dwFreeMem field.
    //

    #ifdef PSCRIPT

    dwFreeMem = pci->pPrinterData->dwFreeMem;

    #endif

    //
    // For UNIDRV, we need to find out the currently selected
    // option for GID_MEMOPTION feature.
    //

    #ifdef UNIDRV

    {
        PFEATURE    pFeature;
        PMEMOPTION  pMemOption;
        DWORD       dwIndex;

        if (! (pFeature = GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_MEMOPTION)))
            return GDI_ERROR;

        dwIndex = GET_INDEX_FROM_FEATURE(pci->pUIInfo, pFeature);
        dwIndex = pci->pCombinedOptions[dwIndex].ubCurOptIndex;

        if (! (pMemOption = PGetIndexedOption(pci->pUIInfo, pFeature, dwIndex)))
            return GDI_ERROR;

        dwFreeMem = pMemOption->dwInstalledMem;
    }

    #endif

    return dwFreeMem / KBYTES;
}



DWORD
DwEnumMediaReady(
    FORM_TRAY_TABLE pFormTrayTable,
    PDWORD          pdwResultSize
    )

/*++

Routine Description:

    Find the list of forms currently available in the printer

Arguments:

    pFormTrayTable - Points to current form-tray assignment table
    pdwResultSize - Return the size of the resulting MULTI_SZ (in bytes)

Return Value:

    Number of forms currently available

Note:

    List of supported form names are returned in place of
    the original form-tray assignment table.

    Format for form-tray assignment table is:
        tray-name form-name
        ...
        NUL

    Returned form names are in the form of:
        form-name
        ...
        NUL

    Duplicate form names are filtered out.

--*/

{
    PWSTR   pwstrOutput, pwstrNext, pwstr;
    DWORD   dwCount, dwIndex, dwLen;

    dwCount = 0;
    pwstrNext = pwstrOutput = pFormTrayTable;

    //
    // Enumerate through each entry of form-tray assignment table
    //

    while (*pwstrNext)
    {
        //
        // skip tray name field
        //

        pwstrNext += wcslen(pwstrNext) + 1;

        //
        // make sure the form name is not a duplicate
        //

        pwstr = pFormTrayTable;

        for (dwIndex=0; dwIndex < dwCount; dwIndex++)
        {
            if (_wcsicmp(pwstr, pwstrNext) == EQUAL_STRING)
                break;

            pwstr += wcslen(pwstr) + 1;
        }

        dwLen = wcslen(pwstrNext) + 1;

        if (dwIndex == dwCount)
        {
            //
            // if the form name is not a duplicate, nor Not Available, count it
            //

            if (*pwstrNext != NUL && *pwstrNext != L'0' && dwLen > 1)
            {
                MoveMemory(pwstrOutput, pwstrNext, dwLen * sizeof(WCHAR));
                pwstrOutput += dwLen;
                dwCount++;
            }
        }

        //
        // go past the form name field
        //

        pwstrNext += dwLen;
    }

    *pwstrOutput++ = NUL;

    if (pdwResultSize != NULL)
        *pdwResultSize = (DWORD)(pwstrOutput - pFormTrayTable) * sizeof(WCHAR);

    return dwCount;
}



DWORD
DwEnumNupOptions(
    PCOMMONINFO pci,
    PDWORD      pdwOutput
    )

/*++

Routine Description:

    Enumerate the list of supported printer description languages

Arguments:

    pci - Points to common printer info
    pdwOutput - Points to output buffer

Return Value:

    Number of N-up options supported
    GDI_ERROR if there is an error

--*/

{
    static CONST DWORD adwNupOptions[] = { 1, 2, 4, 6, 9, 16 };

    if (pdwOutput)
        CopyMemory(pdwOutput, adwNupOptions, sizeof(adwNupOptions));

    return sizeof(adwNupOptions) / sizeof(DWORD);
}



DWORD
DwEnumMediaTypes(
    IN  PCOMMONINFO pci,
    OUT PTSTR       pMediaTypeNames,
    OUT PDWORD      pMediaTypes
    )

/*++

Routine Description:

    Retrieves the display names and indices of supported media types

Arguments:

    pci - points to common printer information
    pMediaTypeNames - output buffer for returning supported media type names
    pMediaTypes - output buffer for returning supported media type indices

    (Both pMediaTypeNames and pMediaTypes will be NULL if caller if only
    asking for the number of supported media types.)

Return Value:

    Number of media types supported.

--*/

{
    PFEATURE    pFeature;
    DWORD       dwIndex, dwCount;

    //
    // This function is used to support both DC_MEDIATYPENAMES and DC_MEDIATYPES.
    // pMediaTypeNames or pMediaTypes should not both be non-NULL.
    //

    ASSERT(pMediaTypeNames == NULL || pMediaTypes == NULL);

    //
    // Go through the list of media types supported by the printer
    //

    pFeature = GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_MEDIATYPE);

    if (pFeature == NULL)
    {
        //
        // Media type feature is not supported by the printer.
        //

        return 0;
    }

    if (pMediaTypeNames == NULL && pMediaTypes == NULL)
    {
        //
        // caller is only asking for the number of supported media types
        //

        return pFeature->Options.dwCount;
    }

    dwCount = 0;

    for (dwIndex = 0; dwIndex < pFeature->Options.dwCount; dwIndex++)
    {
        PMEDIATYPE  pMediaType;

        pMediaType = PGetIndexedOption(pci->pUIInfo, pFeature, dwIndex);
        ASSERT(pMediaType != NULL);

        if (pMediaTypeNames)
        {
            if (LOAD_STRING_OPTION_NAME(pci, pMediaType, pMediaTypeNames, CCHMEDIATYPENAME))
            {
                dwCount++;
                pMediaTypeNames += CCHMEDIATYPENAME;
            }
            else
            {
                ERR(("LOAD_STRING_OPTION_NAME failed for MediaType option %d\n", dwIndex));
            }
        }
        else if (pMediaTypes)
        {
            *pMediaTypes++ = pMediaType->dwMediaTypeID;
            dwCount++;
        }
    }

    return dwCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\driverui\dm.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dm.c

Abstract:

    Devmode related functions used by the driver UI.

Environment:

    Win32 subsystem, DriverUI module, user mode

Revision History:

    02/05/97 -davidx-
        Rewrote it to support OEM plugins among other things.

    07/17/96 -amandan-
        Created it.

--*/


#include "precomp.h"



//
// This is the devmode version 320 (DM_SPECVERSION)
//

#define DM_SPECVERSION320   0x0320
#define DM_SPECVERSION400   0x0400
#define DM_SPECVERSION401   0x0401
#define DM_SPECVER_BASE     DM_SPECVERSION320

#define CCHDEVICENAME320   32
#define CCHFORMNAME320     32

typedef struct _DEVMODE320 {

    WCHAR   dmDeviceName[CCHDEVICENAME320];
    WORD    dmSpecVersion;
    WORD    dmDriverVersion;
    WORD    dmSize;
    WORD    dmDriverExtra;
    DWORD   dmFields;
    short   dmOrientation;
    short   dmPaperSize;
    short   dmPaperLength;
    short   dmPaperWidth;
    short   dmScale;
    short   dmCopies;
    short   dmDefaultSource;
    short   dmPrintQuality;
    short   dmColor;
    short   dmDuplex;
    short   dmYResolution;
    short   dmTTOption;
    short   dmCollate;
    WCHAR   dmFormName[CCHFORMNAME320];
    WORD    dmLogPixels;
    DWORD   dmBitsPerPel;
    DWORD   dmPelsWidth;
    DWORD   dmPelsHeight;
    DWORD   dmDisplayFlags;
    DWORD   dmDisplayFrequency;

} DEVMODE320, *PDEVMODE320;

typedef struct _DMEXTRA400 {

    DWORD  dmICMMethod;
    DWORD  dmICMIntent;
    DWORD  dmMediaType;
    DWORD  dmDitherType;
    DWORD  dmICCManufacturer;
    DWORD  dmICCModel;

} DMEXTRA400;

typedef struct _DMEXTRA401 {

    DWORD  dmPanningWidth;
    DWORD  dmPanningHeight;

} DMEXTRA401;

#define DM_SIZE320  sizeof(DEVMODE320)
#define DM_SIZE400  (DM_SIZE320 + sizeof(DMEXTRA400))
#define DM_SIZE401  (DM_SIZE400 + sizeof(DMEXTRA401))


VOID
VPatchPublicDevmodeVersion(
    IN OUT PDEVMODE pdm
    )

/*++

Routine Description:

    Patch dmSpecVersion field of the input devmode
    based on its dmSize information

Arguments:

    pdm - Specifies a devmode to be version-checked

Return Value:

    NONE

--*/

{
    ASSERT(pdm != NULL);

    //
    // Check against known devmode sizes
    //

    switch (pdm->dmSize)
    {
    case DM_SIZE320:
        pdm->dmSpecVersion = DM_SPECVERSION320;
        break;

    case DM_SIZE400:
        pdm->dmSpecVersion = DM_SPECVERSION400;
        break;

    case DM_SIZE401:
        pdm->dmSpecVersion = DM_SPECVERSION401;
        break;
    }
}



VOID
VSimpleConvertDevmode(
    IN PDEVMODE     pdmIn,
    IN OUT PDEVMODE pdmOut
    )

/*++

Routine Description:

    Simple-minded devmode conversion function.

Arguments:

    pdmIn - Points to an input devmode
    pdmOut - Points to an initialized and valid output devmode

Return Value:

    NONE

Notes:

    This function only relies on values of these 4 fields in pdmOut:
      dmSpecVersion
      dmDriverVersion
      dmSize
      dmDriverExtra

    All other fields in pdmOut are ignored and zero-filled before
    any memory copy occurs.

--*/

{
    WORD    wSpecVersion, wDriverVersion;
    WORD    wSize, wDriverExtra;

    ASSERT(pdmIn != NULL && pdmOut != NULL);

    //
    // Copy public devmode fields
    //

    wSpecVersion = pdmOut->dmSpecVersion;
    wDriverVersion = pdmOut->dmDriverVersion;
    wSize = pdmOut->dmSize;
    wDriverExtra = pdmOut->dmDriverExtra;

    ZeroMemory(pdmOut, wSize+wDriverExtra);
    CopyMemory(pdmOut, pdmIn, min(wSize, pdmIn->dmSize));

    pdmOut->dmSpecVersion = wSpecVersion;
    pdmOut->dmDriverVersion = wDriverVersion;
    pdmOut->dmSize = wSize;
    pdmOut->dmDriverExtra = wDriverExtra;

    //
    // Copy private devmode fields
    //

    CopyMemory((PBYTE) pdmOut + pdmOut->dmSize,
               (PBYTE) pdmIn + pdmIn->dmSize,
               min(wDriverExtra, pdmIn->dmDriverExtra));

    VPatchPublicDevmodeVersion(pdmOut);
}


/*++

Routine Name:

    VSmartConvertDevmode

Routine Description:

    Smart devmode conversion function for CDM_CONVERT. It strictly obeys
    the pdmOut's devmode framework (public, fixed-size core private, each
    plugin devmode), and do the best to convert data from pdmIn into that
    framework. It guarantees that pdmIn's data from a certain section only
    goes into the same section in pdmOut, i.e. pdmIn's core private devmode
    data won't overrun into pdmOut's plugin devmode section.

    Compared with VSimpleConvertDevmode, this function doesn't change the
    size of any private devmode section in the original pdmOut. This includes
    the sizes of: fixed-size core private devmode and each individual OEM
    plugin devmode.

Arguments:

    pdmIn - Points to an input devmode
    pdmOut - Points to an initialized and valid output devmode

Return Value:

    NONE

Note:

   These size/version fields are preserved in pdmOut:

   dmSpecVersion
   dmDriverVersion
   dmSize
   dmDriverExtra
   wSize
   wOEMExtra
   wVer
   each individual OEM plugin's OEM_DMEXTRAHEADER
      dwSize
      dwSignature
      dwVersion

--*/
VOID
VSmartConvertDevmode(
    IN PDEVMODE     pdmIn,
    IN OUT PDEVMODE pdmOut
    )
{
    PDRIVEREXTRA  pdmPrivIn, pdmPrivOut;
    WORD    wSpecVersion, wDriverVersion;
    WORD    wSize, wDriverExtra;
    WORD    wCoreFixIn, wOEMExtraIn;
    WORD    wCoreFixOut, wOEMExtraOut, wVerOut;
    BOOL    bMSdm500In = FALSE, bMSdm500Out = FALSE;

    ASSERT(pdmIn != NULL && pdmOut != NULL);

    //
    // First let's determine the version of pdmIn/pdmOut.
    //
    pdmPrivIn = (PDRIVEREXTRA)GET_DRIVER_PRIVATE_DEVMODE(pdmIn);
    pdmPrivOut = (PDRIVEREXTRA)GET_DRIVER_PRIVATE_DEVMODE(pdmOut);

    if (pdmIn->dmDriverVersion >= gDriverDMInfo.dmDriverVersion500 &&
        pdmIn->dmDriverExtra >= gDriverDMInfo.dmDriverExtra500 &&
        pdmPrivIn->dwSignature == gdwDriverDMSignature)
    {
        wCoreFixIn = pdmPrivIn->wSize;
        wOEMExtraIn = pdmPrivIn->wOEMExtra;

        if ((wCoreFixIn >= gDriverDMInfo.dmDriverExtra500) &&
            ((wCoreFixIn + wOEMExtraIn) <= pdmIn->dmDriverExtra))
        {
            bMSdm500In = TRUE;
        }
    }

    if (pdmOut->dmDriverVersion >= gDriverDMInfo.dmDriverVersion500 &&
        pdmOut->dmDriverExtra >= gDriverDMInfo.dmDriverExtra500 &&
        pdmPrivOut->dwSignature == gdwDriverDMSignature)
    {
        wCoreFixOut = pdmPrivOut->wSize;
        wOEMExtraOut = pdmPrivOut->wOEMExtra;

        if ((wCoreFixOut >= gDriverDMInfo.dmDriverExtra500) &&
            ((wCoreFixOut + wOEMExtraOut) <= pdmOut->dmDriverExtra))
        {
            wVerOut = pdmPrivOut->wVer;
            bMSdm500Out = TRUE;
        }
    }

    if (!bMSdm500In || !bMSdm500Out)
    {
        //
        // For unknown devmode or MS pre-v5 devmode, there is no
        // complexity caused by plugin devmodes, so we will just
        // call the simple convert function.
        //
        VSimpleConvertDevmode(pdmIn, pdmOut);
        return;
    }

    //
    // Copy public devmode fields
    //
    wSpecVersion = pdmOut->dmSpecVersion;
    wDriverVersion = pdmOut->dmDriverVersion;
    wSize = pdmOut->dmSize;
    wDriverExtra = pdmOut->dmDriverExtra;

    ZeroMemory(pdmOut, wSize);
    CopyMemory(pdmOut, pdmIn, min(wSize, pdmIn->dmSize));

    pdmOut->dmSpecVersion = wSpecVersion;
    pdmOut->dmDriverVersion = wDriverVersion;
    pdmOut->dmSize = wSize;
    pdmOut->dmDriverExtra = wDriverExtra;

    VPatchPublicDevmodeVersion(pdmOut);

    //
    // Copy private devmode fields section by section
    //
    // 1. First copy the fixed-size core section
    //
    ZeroMemory(pdmPrivOut, wCoreFixOut);
    CopyMemory(pdmPrivOut, pdmPrivIn, min(wCoreFixIn, wCoreFixOut));

    //
    // Restore the size/version fields in core private devmode of pdmOut
    //
    pdmPrivOut->wSize = wCoreFixOut;
    pdmPrivOut->wOEMExtra = wOEMExtraOut;
    pdmPrivOut->wVer = wVerOut;

    //
    // 2. Then copy any OEM plugin devmodes
    //
    // If pdmOut has no plugin devmodes, then we have no room to copy pdmIn's.
    //
    // If pdmIn has no plugin devmode, then we have nothing to copy, so we will
    // just leave pdmOut's unchanged.
    //
    // So we only have work to do if both pdmIn and pdmOut have plugin devmodes.
    //
    if (wOEMExtraIn > 0 && wOEMExtraOut > 0)
    {
        POEM_DMEXTRAHEADER  pOemDMIn, pOemDMOut;

        pOemDMIn = (POEM_DMEXTRAHEADER) ((PBYTE)pdmPrivIn + wCoreFixIn);
        pOemDMOut = (POEM_DMEXTRAHEADER) ((PBYTE)pdmPrivOut + wCoreFixOut);

        //
        // Make sure both in and out plugin devmodes blocks are valid before
        // we do the conversion. Otherwise, we will leave pdmOut plugin devmodes
        // unchanged.
        //
        if (bIsValidPluginDevmodes(pOemDMIn, (LONG)wOEMExtraIn) &&
            bIsValidPluginDevmodes(pOemDMOut, (LONG)wOEMExtraOut))
        {
            LONG  cbInSize = (LONG)wOEMExtraIn;
            LONG  cbOutSize = (LONG)wOEMExtraOut;

            while (cbInSize > 0 && cbOutSize > 0)
            {
                OEM_DMEXTRAHEADER  OemDMHdrIn, OemDMHdrOut;

                //
                // Copy headers into local buffers
                //
                CopyMemory(&OemDMHdrIn, pOemDMIn, sizeof(OEM_DMEXTRAHEADER));
                CopyMemory(&OemDMHdrOut, pOemDMOut, sizeof(OEM_DMEXTRAHEADER));

                if (OemDMHdrIn.dwSize > sizeof(OEM_DMEXTRAHEADER) &&
                    OemDMHdrOut.dwSize > sizeof(OEM_DMEXTRAHEADER))
                {
                    //
                    // Zero-fill, then copy over the plugin devmode portion after
                    // the header structure. Notice that the header structure in
                    // pOemDMOut is unchanged.
                    //
                    ZeroMemory((PBYTE)pOemDMOut + sizeof(OEM_DMEXTRAHEADER),
                               OemDMHdrOut.dwSize - sizeof(OEM_DMEXTRAHEADER));

                    CopyMemory((PBYTE)pOemDMOut + sizeof(OEM_DMEXTRAHEADER),
                               (PBYTE)pOemDMIn + sizeof(OEM_DMEXTRAHEADER),
                               min(OemDMHdrOut.dwSize - sizeof(OEM_DMEXTRAHEADER),
                                   OemDMHdrIn.dwSize - sizeof(OEM_DMEXTRAHEADER)));
                }

                cbInSize -= OemDMHdrIn.dwSize;
                pOemDMIn = (POEM_DMEXTRAHEADER) ((PBYTE)pOemDMIn + OemDMHdrIn.dwSize);

                cbOutSize -= OemDMHdrOut.dwSize;
                pOemDMOut = (POEM_DMEXTRAHEADER) ((PBYTE)pOemDMOut + OemDMHdrOut.dwSize);
            }
        }
    }
}



BOOL
BConvertDevmodeOut(
    IN  PDEVMODE pdmSrc,
    IN  PDEVMODE pdmIn,
    OUT PDEVMODE pdmOut
    )

/*++

Routine Description:

    This function copy a source devmode to an output devmode buffer.
    It should be called by the driver just before the driver returns
    to the caller of DrvDocumentPropertySheets.

Arguments:

    pdmSrc - pointer to current version of src DEVMODE
    pdmIn - pointer to input devmode passed in by the app
    pdmOut - pointer to output buffer passed in by the app

Return Value:

    TRUE for success
    FALSE for failure.

Note:

    pdmOut is only the output buffer allocated by the application. It
    doesn't necessarily contain any valid devmode content, so we should
    not look at any of its fields.

--*/

{
    if (pdmOut == NULL)
    {
        RIP(("Output buffer is NULL.\n"));
        return FALSE;
    }

    //
    // Without an input devmode, we'll have to assume the output
    // devmode is big enough to hold our current devmode.
    //

    if (pdmIn == NULL)
    {
        CopyMemory(pdmOut, pdmSrc, pdmSrc->dmSize + pdmSrc->dmDriverExtra);
        return TRUE;
    }

    //
    // If an input devmode is provided, we make sure we don't copy
    // anything larger than the input devmode to the output devmode buffer.
    // So the private devmode size dmDriverExtra of pdmOut can only shrink
    // (when Src private devmode size is smaller), but it will never grow.
    //
    // This is really dumb because we may end up chopping off tail end of
    // public and private devmode fields. But it's neccesary to work with
    // ill-behaving apps out there.
    //

    if (pdmIn->dmSize < pdmSrc->dmSize)
    {
        pdmOut->dmSpecVersion = pdmIn->dmSpecVersion;
        pdmOut->dmSize        = pdmIn->dmSize;
    }
    else
    {
        pdmOut->dmSpecVersion = pdmSrc->dmSpecVersion;
        pdmOut->dmSize        = pdmSrc->dmSize;
    }

    if (pdmIn->dmDriverExtra < pdmSrc->dmDriverExtra)
    {
        pdmOut->dmDriverVersion = pdmIn->dmDriverVersion;
        pdmOut->dmDriverExtra   = pdmIn->dmDriverExtra;
    }
    else
    {
        pdmOut->dmDriverVersion = pdmSrc->dmDriverVersion;
        pdmOut->dmDriverExtra   = pdmSrc->dmDriverExtra;
    }

    VSimpleConvertDevmode(pdmSrc, pdmOut);
    return TRUE;
}



BOOL
DrvConvertDevMode(
    LPTSTR      pPrinterName,
    PDEVMODE    pdmIn,
    PDEVMODE    pdmOut,
    PLONG       pcbNeeded,
    DWORD       fMode
    )

/*++

Routine Description:

    This function convert the devmode from previous version.

Arguments:

    pPrinterName - pointer to printer name
    pdmIn - input devmode
    pdmOut - output devmode
    pcbNeeded - size of output buffer on input
                size of output devmode on output
    fMode - specifies functions to perform

Return Value:

    TRUE for success and FALSE for failure

--*/

{
    PCOMMONINFO pci;
    DWORD       dwSize, dwError;

    VERBOSE(("DrvConvertDevMode: fMode = 0x%x\n", fMode));

    //
    // Sanity check: make sure pcbNeeded parameter is not NULL
    //

    if (pcbNeeded == NULL)
    {
        RIP(("pcbNeeded is NULL.\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    switch (fMode)
    {
    case CDM_CONVERT:

        //
        // Convert input devmode to output devmode
        // Note: OEM plugins are not involved here because
        // they can only convert input devmode to current
        // version, not between any versions.
        //

        if (pdmIn == NULL || pdmOut == NULL ||
            *pcbNeeded < pdmOut->dmSize + pdmOut->dmDriverExtra)
        {
            break;
        }

        VSmartConvertDevmode(pdmIn, pdmOut);
        *pcbNeeded = pdmOut->dmSize + pdmOut->dmDriverExtra;
        return TRUE;

    case CDM_CONVERT351:

        //
        // Convert input devmode to 3.51 version devmode
        // First check if the caller provided buffer is large enough
        //

        dwSize = DM_SIZE320 + gDriverDMInfo.dmDriverExtra351;

        if (*pcbNeeded < (LONG) dwSize || pdmOut == NULL)
        {
            *pcbNeeded = dwSize;
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        //
        // Do the conversion from input devmode to 3.51 devmode
        //

        pdmOut->dmSpecVersion = DM_SPECVERSION320;
        pdmOut->dmSize = DM_SIZE320;
        pdmOut->dmDriverVersion = gDriverDMInfo.dmDriverVersion351;
        pdmOut->dmDriverExtra = gDriverDMInfo.dmDriverExtra351;

        VSimpleConvertDevmode(pdmIn, pdmOut);
        *pcbNeeded = dwSize;
        return TRUE;

    case CDM_DRIVER_DEFAULT:

        //
        // Get the driver default devmode.
        // We need to open a handle to the printer
        // and then load basic driver information.
        //

        dwError = ERROR_GEN_FAILURE;

        pci = PLoadCommonInfo(NULL,
                              pPrinterName,
                              FLAG_OPENPRINTER_NORMAL|FLAG_OPEN_CONDITIONAL);

        if (pci && BCalcTotalOEMDMSize(pci->hPrinter, pci->pOemPlugins, &dwSize))
        {
            dwSize += sizeof(DEVMODE) + gDriverDMInfo.dmDriverExtra;

            //
            // Check if the output buffer is big enough
            //

            if (*pcbNeeded < (LONG) dwSize || pdmOut == NULL)
                dwError = ERROR_INSUFFICIENT_BUFFER;
            else if (BFillCommonInfoDevmode(pci, NULL, NULL))
            {
                //
                // Get the driver default devmode and
                // copy it to the output buffer
                //

                CopyMemory(pdmOut, pci->pdm, dwSize);
                dwError = NO_ERROR;
            }

            *pcbNeeded = dwSize;
        }

        VFreeCommonInfo(pci);
        SetLastError(dwError);
        return (dwError == NO_ERROR);

    default:

        ERR(("Invalid fMode in DrvConvertDevMode: %d\n", fMode));
        break;
    }

    SetLastError(ERROR_INVALID_PARAMETER);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\driverui\driverui.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    driverui.h

Abstract:

    Header file for driverui.c

Environment:

    Win32 subsystem, DriverUI module, user mode

Revision History:

    02/09/97 -davidx-
        Consistent handling of common printer info (COMMONINFO)

    02/04/97 -davidx-
        Reorganize driver UI to separate ps and uni DLLs.

    07/17/96 -amandan-
        Created it.

--*/

#ifndef _DRIVERUI_H_
#define _DRIVERUI_H_

//
// Global critical section used when accessing shared data
//

extern CRITICAL_SECTION gCriticalSection;

#define ENTER_CRITICAL_SECTION() EnterCriticalSection(&gCriticalSection)
#define LEAVE_CRITICAL_SECTION() LeaveCriticalSection(&gCriticalSection)

//
// Allocate zero-filled memory from a heap
//

#define HEAPALLOC(hheap,size)   HeapAlloc(hheap, HEAP_ZERO_MEMORY, size)
#define HEAPREALLOC(hheap, pOrig, size) HeapReAlloc(hheap, HEAP_ZERO_MEMORY, pOrig, size)

//
// Various hardcoded limits
//

#define CCHBINNAME              24      // max length for bin names
#define CCHPAPERNAME            64      // max length for form names
#define CCHMEDIATYPENAME        64      // max length for mediatype names
#define CCHLANGNAME             32      // max length for language strings
#define MIN_OPTIONS_ALLOWED     2
#define UNUSED_PARAM            0xFFFFFFFF

//
// PostScript and UniDriver driver private devmode
//

#ifdef  PSCRIPT
#define PDRIVEREXTRA    PPSDRVEXTRA
#endif

#ifdef  UNIDRV
#define PDRIVEREXTRA    PUNIDRVEXTRA
typedef struct _WINRESDATA WINRESDATA;
#endif

#define PGetDevmodeOptionsArray(pdm) \
        (((PDRIVEREXTRA) GET_DRIVER_PRIVATE_DEVMODE(pdm))->aOptions)

#define GETUSERDATASIZE(UserData) \
    ( ((PUSERDATA)(UserData))->dwSize )

#define GETUSERDATAITEM(UserData) \
    ( ((PUSERDATA)(UserData))->dwItemID )

#define GETUSERDATAKEYWORDNAME(UserData) \
    ( ((PUSERDATA)(UserData))->pKeyWordName )

#define SETUSERDATAID(pOptItem, dwID) \
    ( ((PUSERDATA)((pOptItem)->UserData))->dwItemID = dwID)

#define SETUSERDATA_SIZE(pOptItem, dwSize) \
    ( ((PUSERDATA)((pOptItem)->UserData))->dwSize = dwSize)

#define SETUSERDATA_KEYWORDNAME(ci, pOptItem, pFeature) \
     ((PUSERDATA)((pOptItem)->UserData))->pKeyWordName = \
            OFFSET_TO_POINTER(ci.pUIInfo->pubResourceData, pFeature->loKeywordName)


//
// Common data structure which is needed whether UI comes up or not
//

typedef struct _COMMONINFO {

    OEMUIOBJ        oemuiobj;           // support info for OEM plugins
    PVOID           pvStartSign;        // signature
    PTSTR           pPrinterName;       // current printer name
    HANDLE          hPrinter;           // handle to current printer
    DWORD           dwFlags;            // miscellaneous flag bits
    PDRIVER_INFO_3  pDriverInfo3;       // driver info level 3
    PRAWBINARYDATA  pRawData;           // raw printer description data
    PINFOHEADER     pInfoHeader;        // current printer description data instance
    PUIINFO         pUIInfo;            // UIINFO structure inside above instance
    POEM_PLUGINS    pOemPlugins;        // OEM plugin information
    PDEVMODE        pdm;                // devmode information
    PDRIVEREXTRA    pdmPrivate;         // driver private devmode fields
    PPRINTERDATA    pPrinterData;       // printer-sticky property data
    POPTSELECT      pCombinedOptions;   // combined options array
    PFORM_INFO_1    pSplForms;          // spooler forms
    DWORD           dwSplForms;         // number of spooler forms
    HANDLE          hHeap;              // heap used to display UI

    #ifdef UNIDRV

    WINRESDATA      *pWinResData;

    #endif

} COMMONINFO, *PCOMMONINFO;

//
// Flag constants for COMMONINFO.dwFlags field
//

#define FLAG_OPENPRINTER_NORMAL     0x0001
#define FLAG_OPEN_CONDITIONAL       0x0002
#define FLAG_OPENPRINTER_ADMIN      0x0004
#define FLAG_INIT_PRINTER           0x0008
#define FLAG_ALLOCATE_UIDATA        0x0010
#define FLAG_PROCESS_INIFILE        0x0020
#define FLAG_REFRESH_PARSED_DATA    0x0040
#define FLAG_WITHIN_PLUGINCALL      0x0080
#define FLAG_APPLYNOW_CALLED        0x0100
#define FLAG_PLUGIN_CHANGED_OPTITEM 0x0200
#define FLAG_USER_CHANGED_FREEMEM   0x0400
#define FLAG_PROPSHEET_SESSION      0x0800
#define FLAG_UPGRADE_PRINTER        0x1000

#define IS_WITHIN_PROPSHEET_SESSION(pci) ((pci)->dwFlags & FLAG_PROPSHEET_SESSION)

//
// Special entry point for getting around EnumForm bug in spooler
//

DWORD
DrvSplDeviceCaps(
    HANDLE      hPrinter,
    PWSTR       pDeviceName,
    WORD        wCapability,
    PVOID       pOutput,
    DWORD       dwOutputSize,
    PDEVMODE    pdmSrc
    );


//
// Load basic information needed by the driver UI
//

PCOMMONINFO
PLoadCommonInfo(
    IN HANDLE       hPrinter,
    IN PTSTR        ptstrPrinterName,
    IN DWORD        dwFlags
    );

//
// Release common information used by the driver UI
//

VOID
VFreeCommonInfo(
    IN PCOMMONINFO  pci
    );

//
// Populate the devmode fields in the COMMONINFO structure
//

BOOL
BFillCommonInfoDevmode(
    IN OUT PCOMMONINFO  pci,
    IN PDEVMODE         pdmPrinter,
    IN PDEVMODE         pdmInput
    );

//
// Populate the printer-sticky property data field
//

BOOL
BFillCommonInfoPrinterData(
    IN OUT PCOMMONINFO  pci
    );

//
// Combined document-sticky feature selections and printer-sticky
// feature selection into a single options array
//

BOOL
BCombineCommonInfoOptionsArray(
    IN OUT PCOMMONINFO  pci
    );

//
// Get an updated printer description data instance
// using the combined options array
//

BOOL
BUpdateUIInfo(
    IN OUT PCOMMONINFO  pci
    );

//
// Fix up combined options array with information from public devmode fields
//

VOID
VFixOptionsArrayWithDevmode(
    IN OUT PCOMMONINFO  pci
    );

//
// Convert option array setting into public devmode fields
//

VOID
VOptionsToDevmodeFields(
    IN OUT PCOMMONINFO  pci,
    IN BOOL             bUpdateFormFields
    );

#ifndef WINNT_40
//
// Notify DS of update
//
VOID
VNotifyDSOfUpdate(
    IN  HANDLE  hPrinter
    );
#endif

//
// Get a read-only copy of a display name:
//  1)  if the display name is in the binary printer description data,
//      then we simply return a pointer to that data.
//  2)  otherwise, the display name is in the resource DLL.
//      we allocate memory out of the driver's heap and
//      load the string.
//
// Caller should NOT free the returned pointer. The memory
// will go away when the binary printer description data is unloaded
// or when the driver's heap is destroyed.
//
// Since PSCRIPT currently doesn't have any resource DLL,
// we define this as a macro to save a function call.
//

#ifdef PSCRIPT

#define PGetReadOnlyDisplayName(pci, loOffset) \
        OFFSET_TO_POINTER((pci)->pUIInfo->pubResourceData, (loOffset))

#else

PWSTR
PGetReadOnlyDisplayName(
    PCOMMONINFO pci,
    PTRREF      loOffset
    );

#endif

//
// This macro is defined as a convenience to get a read-only
// copy of the display name for an option.
//

#define GET_OPTION_DISPLAY_NAME(pci, pOption) \
        PGetReadOnlyDisplayName(pci, ((POPTION) (pOption))->loDisplayName)

//
// This function is similar to PGetReadOnlyDisplayName
// but the caller must provide the buffer for loading the string.
//

BOOL
BLoadDisplayNameString(
    PCOMMONINFO pci,
    PTRREF      loOffset,
    PWSTR       pwstrBuf,
    INT         iMaxChars
    );

BOOL
BLoadPageSizeNameString(
    PCOMMONINFO pci,
    PTRREF      loOffset,
    PWSTR       pwstrBuf,
    INT         iMaxChars,
    INT         iStdID
    );


//
// Convenience macro for loading the display name of an option
// into a caller-provided buffer.
//

#define LOAD_STRING_OPTION_NAME(pci, pOption, pwch, maxsize) \
        BLoadDisplayNameString(pci, ((POPTION) (pOption))->loDisplayName, pwch, maxsize)

#define LOAD_STRING_PAGESIZE_NAME(pci, pPageSize, pwch, maxsize) \
        BLoadPageSizeNameString(pci, (pPageSize)->GenericOption.loDisplayName, pwch, maxsize, (pPageSize)->dwPaperSizeID)


//
// Load icon resource from the resource DLL
//

ULONG_PTR
HLoadIconFromResourceDLL(
    PCOMMONINFO pci,
    DWORD       dwIconID
    );

//
// Data structure which is used only when UI is displayed
// IMPORTANT: The first field must be a COMMONINFO structure.
//

typedef struct _UIDATA {

    COMMONINFO      ci;
    INT             iMode;
    HWND            hDlg;
    BOOL            bPermission;
    BOOL            bIgnoreConflict;
    BOOL            bEMFSpooling;
    PFNCOMPROPSHEET pfnComPropSheet;
    HANDLE          hComPropSheet;
    PCOMPROPSHEETUI pCompstui;

    //
    // These fields are valid only when a dialog is presented
    //

    DWORD           dwFormNames;
    PWSTR           pFormNames;
    PWORD           pwPapers;
    PWORD           pwPaperFeatures;
    DWORD           dwBinNames;
    PWSTR           pBinNames;

    //
    // Used for helper functions
    //

    BOOL            abEnabledOptions[MAX_PRINTER_OPTIONS];

    //
    // Fields for keeping track of various option items
    //

    DWORD           dwDrvOptItem;
    POPTITEM        pDrvOptItem;

    DWORD           dwFormTrayItem;
    POPTITEM        pFormTrayItems;

    DWORD           dwTTFontItem;
    POPTITEM        pTTFontItems;

    DWORD           dwFeatureItem;
    POPTITEM        pFeatureItems;
    POPTITEM        pFeatureHdrItem;

    //
    // These fields are used for packing option items
    //

    DWORD           dwOptItem;
    POPTITEM        pOptItem;
    DWORD           dwOptType;
    POPTTYPE        pOptType;

    //
    // UniDriver specific fields
    //

    #ifdef UNIDRV

    //
    // Font Cart Table
    //

    DWORD           dwFontCart;
    POPTITEM        pFontCart;

    //
    // Device halftone setup info
    //

    PDEVHTINFO      pDevHTInfo;

    #endif // UNIDRV

    DWORD           dwHideFlags;
    PVOID           pvEndSign;

} UIDATA, *PUIDATA;

//
// Flag constants for UIDATA.dwHideFlags field
//

#define HIDEFLAG_HIDE_STD_DOCPROP     0x0001
#define HIDEFLAG_HIDE_STD_PRNPROP     0x0002

#define IS_HIDING_STD_UI(pUiData) \
    ((((pUiData)->iMode == MODE_DOCUMENT_STICKY) &&           \
      ((pUiData)->dwHideFlags & HIDEFLAG_HIDE_STD_DOCPROP)) ||  \
     (((pUiData)->iMode == MODE_PRINTER_STICKY) &&            \
      ((pUiData)->dwHideFlags & HIDEFLAG_HIDE_STD_PRNPROP)))

#define VALIDUIDATA(pUiData)    ((pUiData) && \
                                 (pUiData) == (pUiData)->ci.pvStartSign && \
                                 (pUiData) == (pUiData)->pvEndSign)

#define HASPERMISSION(pUiData)  ((pUiData)->bPermission)

//
// This function is called by DrvDocumentPropertySheets and
// DrvPrinterPropertySheets. It allocates and initializes
// a UIDATA structure that's used to display property pages.
//

PUIDATA
PFillUiData(
    IN HANDLE       hPrinter,
    IN PTSTR        pPrinterName,
    IN PDEVMODE     pdmInput,
    IN INT          iMode
    );

//
// Dispose of a UIDATA structure -
// Just disposed of the embedded COMMONINFO structure
//

#define VFreeUiData(pUiData)    VFreeCommonInfo((PCOMMONINFO) (pUiData))

//
// Data structure used to pass parameters to "Conflicts" dialog
//

typedef struct _DLGPARAM {

    PFNCOMPROPSHEET pfnComPropSheet;
    HANDLE          hComPropSheet;
    PUIDATA         pUiData;
    BOOL            bFinal;
    POPTITEM        pOptItem;
    DWORD           dwResult;

} DLGPARAM, *PDLGPARAM;

#define CONFLICT_NONE       IDOK
#define CONFLICT_RESOLVE    IDC_RESOLVE
#define CONFLICT_CANCEL     IDC_CANCEL
#define CONFLICT_IGNORE     IDC_IGNORE

//
// Functions used to implement DeviceCapabilities:
//  calculate minimum or maximum paper size extent
//  get list of supported paper size names, indices, and dimensions
//  get list of supported paper bin names and indices
//  get list of supported resolutions
//

DWORD
DwCalcMinMaxExtent(
    IN  PCOMMONINFO pci,
    OUT PPOINT      pptOutput,
    IN  WORD        wCapability
    );

DWORD
DwEnumPaperSizes(
    IN OUT PCOMMONINFO  pci,
    OUT PWSTR           pPaperNames,
    OUT PWORD           pPapers,
    OUT PPOINT          pPaperSizes,
    IN  PWORD           pPaperFeatures,
    IN  DWORD           dwPaperNamesBufSize
    );

DWORD
DwEnumBinNames(
    IN  PCOMMONINFO pci,
    OUT PWSTR       pBinNames
    );

DWORD
DwEnumBins(
    IN  PCOMMONINFO pci,
    OUT PWORD       pBins
    );

DWORD
DwEnumResolutions(
    IN  PCOMMONINFO pci,
    OUT PLONG       pResolutions
    );

DWORD
DwEnumNupOptions(
    PCOMMONINFO     pci,
    PDWORD          pdwOutput
    );

DWORD
DwGetAvailablePrinterMem(
    IN PCOMMONINFO  pci
    );

DWORD
DwEnumMediaReady(
    IN OUT FORM_TRAY_TABLE  pFormTrayTable,
    OUT PDWORD              pdwResultSize
    );

#ifndef WINNT_40

//
// DC_MEDIATYPENAMES and DC_MEDIATYPES are added in Whistler.
// We need to do following so the driver can also be built with
// Win2K SDK/DDK.
//

#ifndef DC_MEDIATYPENAMES
#define DC_MEDIATYPENAMES       34
#endif

#ifndef DC_MEDIATYPES
#define DC_MEDIATYPES           35
#endif

#endif // !WINNT_40

DWORD
DwEnumMediaTypes(
    IN  PCOMMONINFO pci,
    OUT PTSTR       pMediaTypeNames,
    OUT PDWORD      pMediaTypes
    );

//
// Functions for dealing with forms
//

BOOL
BFormSupportedOnPrinter(
    IN PCOMMONINFO  pci,
    IN PFORM_INFO_1 pFormInfo,
    OUT PDWORD      pdwOptionIndex
    );

BOOL
BPackItemFormTrayTable(
    IN OUT PUIDATA  pUiData
    );

BOOL
BUnpackItemFormTrayTable(
    IN OUT PUIDATA  pUiData
    );

VOID
VSetupFormTrayAssignments(
    IN PUIDATA  pUiData
    );

DWORD
DwFindFormNameIndex(
    IN  PUIDATA pUiData,
    IN  PWSTR   pFormName,
    OUT PBOOL   pbSupported
    );

ULONG_PTR
HLoadFormIconResource(
    PUIDATA pUiData,
    DWORD   dwIndex
    );

DWORD
DwGuessFormIconID(
    PWSTR   pFormName
    );

//
// Functions prototypes for commonui related items.
//

PCOMPROPSHEETUI
PPrepareDataForCommonUI(
    IN OUT PUIDATA  pUiData,
    IN PDLGPAGE     pDlgPage
    );

BOOL
BPackPrinterPropertyItems(
    IN OUT PUIDATA  pUiData
    );

BOOL
BPackDocumentPropertyItems(
    IN OUT PUIDATA  pUiData
    );

VOID
VPackOptItemGroupHeader(
    IN OUT PUIDATA  pUiData,
    IN DWORD        dwTitleId,
    IN DWORD        dwIconId,
    IN DWORD        dwHelpIndex
    );

BOOL
BPackOptItemTemplate(
    IN OUT PUIDATA  pUiData,
    IN CONST WORD   pwItemInfo[],
    IN DWORD        dwSelection,
    IN PFEATURE     pFeature
    );

#define ITEM_INFO_SIGNATURE 0xCAFE

BOOL
BPackUDArrowItemTemplate(
    IN OUT PUIDATA  pUiData,
    IN CONST WORD   pwItemInfo[],
    IN DWORD        dwSelection,
    IN DWORD        dwMaxVal,
    IN PFEATURE     pFeature
    );

POPTPARAM
PFillOutOptType(
    OUT POPTTYPE    pOptType,
    IN  DWORD       dwType,
    IN  DWORD       dwParams,
    IN  HANDLE      hHeap
    );

PFEATURE
PGetFeatureFromItem(
    IN      PUIINFO  pUIInfo,
    IN OUT  POPTITEM pOptItem,
    OUT     PDWORD   pdwFeatureIndex
    );

BOOL
BPackItemGenericOptions(
    IN OUT PUIDATA  pUiData
    );

BOOL
BPackItemPrinterFeature(
    IN OUT PUIDATA  pUiData,
    IN PFEATURE     pFeature,
    IN DWORD        dwLevel,
    IN DWORD        dwPub,
    IN ULONG_PTR    dwUserData,
    IN DWORD        dwHelpIndex
    );

DWORD
DwCountDisplayableGenericFeature(
    IN PUIDATA      pUiData,
    BOOL            bPrinterSticky
    );

BOOL
BShouldDisplayGenericFeature(
    IN PFEATURE     pFeature,
    IN BOOL         bPrinterSticky
    );

BOOL
BOptItemSelectionsChanged(
    IN OUT  POPTITEM pItems,
    IN     DWORD     dwItems
    );

POPTITEM
PFindOptItem(
    IN PUIDATA  pUiData,
    IN DWORD    dwItemId
    );

BOOL
BPackItemFontSubstTable(
    IN PUIDATA  pUiData
    );

BOOL
BUnpackItemFontSubstTable(
    IN PUIDATA  pUiData
    );

PTSTR
PtstrDuplicateStringFromHeap(
    IN PTSTR    ptstrSrc,
    IN HANDLE   hHeap
    );

VOID
VUpdateOptionsArrayWithSelection(
    IN OUT PUIDATA  pUiData,
    IN POPTITEM     pOptItem
    );

VOID
VUnpackDocumentPropertiesItems(
    IN  OUT PUIDATA     pUiData,
    IN  OUT POPTITEM    pOptItem,
    IN  DWORD           dwCound);

BOOL
BGetPageOrderFlag(
    IN PCOMMONINFO  pci
    );

VOID
VPropShowConstraints(
    IN PUIDATA  pUiData,
    IN INT      iMode
    );

INT
ICheckConstraintsDlg(
    IN OUT  PUIDATA     pUiData,
    IN OUT  POPTITEM    pOptItem,
    IN     DWORD        dwOptItem,
    IN      BOOL        bFinal
    );

#define CONSTRAINED_FLAG            OPTPF_OVERLAY_WARNING_ICON
#define IS_CONSTRAINED(pitem, sel) ((pitem)->pOptType->pOptParam[sel].Flags & CONSTRAINED_FLAG)

//
// This function copy a source devmode to an output devmode buffer.
// It should be called by the driver just before the driver returns
// to the caller of DrvDocumentPropertySheets.
//

BOOL
BConvertDevmodeOut(
    IN  PDEVMODE pdmSrc,
    IN  PDEVMODE pdmIn,
    OUT PDEVMODE pdmOut
    );

//
// Find the OPTITEM with UserData's pKeywordName matching given keyword name
//

POPTITEM
PFindOptItemWithKeyword(
    IN  PUIDATA pUiData,
    IN  PCSTR   pKeywordName
    );

//
// Find the OPTITEM containing the specified UserData value
//

POPTITEM
PFindOptItemWithUserData(
    IN  PUIDATA pUiData,
    IN  DWORD   UserData
    );

//
// Sync up OPTITEM list with the updated options array
//

VOID
VUpdateOptItemList(
    IN OUT  PUIDATA     pUiData,
    IN      POPTSELECT  pOldCombinedOptions,
    IN      POPTSELECT  pNewCombinedOptions
    );

//
// Display an error message box
//

INT
IDisplayErrorMessageBox(
    HWND    hwndParent,
    UINT    uType,
    INT     iTitleStrId,
    INT     iFormatStrId,
    ...
    );

BOOL
BPrepareForLoadingResource(
    PCOMMONINFO pci,
    BOOL        bNeedHeap
    );


//
// Fill out an OPTITEM structure
//

#define FILLOPTITEM(poptitem,popttype,name,sel,level,dmpub,userdata,help)   \
        (poptitem)->cbSize = sizeof(OPTITEM);                               \
        (poptitem)->Flags |= OPTIF_CALLBACK;                                \
        (poptitem)->pOptType = (popttype);                                  \
        (poptitem)->pName = (PWSTR) (name);                                 \
        (poptitem)->pSel = (PVOID) (sel);                                   \
        (poptitem)->Level = (BYTE) (level);                                 \
        (poptitem)->DMPubID = (BYTE) (dmpub);                               \
        SETUSERDATAID(poptitem, userdata);                                  \
        (poptitem)->HelpIndex = (help)

//
// Tree view item level
//

#define TVITEM_LEVEL1           1
#define TVITEM_LEVEL2           2
#define TVITEM_LEVEL3           3

enum {
    UNKNOWN_ITEM,

    FONT_SUBST_ITEM,
    FONTSLOT_ITEM,
    PRINTER_VM_ITEM,
    HALFTONE_SETUP_ITEM,
    IGNORE_DEVFONT_ITEM,
    PSPROTOCOL_ITEM,
    JOB_TIMEOUT_ITEM,
    WAIT_TIMEOUT_ITEM,

    COPIES_COLLATE_ITEM,
    SCALE_ITEM,
    COLOR_ITEM,
    ICMMETHOD_ITEM,
    ICMINTENT_ITEM,
    TTOPTION_ITEM,
    METASPOOL_ITEM,
    NUP_ITEM,
    REVPRINT_ITEM,
    MIRROR_ITEM,
    NEGATIVE_ITEM,
    COMPRESSBMP_ITEM,
    CTRLD_BEFORE_ITEM,
    CTRLD_AFTER_ITEM,
    TEXT_ASGRX_ITEM,
    PAGE_PROTECT_ITEM,
    PSOUTPUT_OPTION_ITEM,
    PSTT_DLFORMAT_ITEM,
    PSLEVEL_ITEM,
    PSERROR_HANDLER_ITEM,
    PSMINOUTLINE_ITEM,
    PSMAXBITMAP_ITEM,
    PSHALFTONE_FREQ_ITEM,
    PSHALFTONE_ANGLE_ITEM,
    QUALITY_SETTINGS_ITEM,
    SOFTFONT_SETTINGS_ITEM,

    TRUE_GRAY_TEXT_ITEM,
    TRUE_GRAY_GRAPH_ITEM,

    ADD_EURO_ITEM,

    //
    // !!! Only items whose UserData value is larger than
    // CONSTRAINABLE_ITEM can have constraints.
    //

    CONSTRAINABLE_ITEM = 0x8000,
    ORIENTATION_ITEM = CONSTRAINABLE_ITEM,
    DUPLEX_ITEM,
    RESOLUTION_ITEM,
    INPUTSLOT_ITEM,
    FORMNAME_ITEM,
    MEDIATYPE_ITEM,
    COLORMODE_ITEM,
    HALFTONING_ITEM,
    FORM_TRAY_ITEM,
};

//
// Interpretation of OPTITEM.UserData: If it's less than 0x10000
// then it's one of the constants defined above. Otherwise, it's
// a pointer to a FEATURE object.
//

#define DRIVERUI_MAX_ITEM               0x10000

#define ISPRINTERFEATUREITEM(userData)  (GETUSERDATAITEM(userData) >= DRIVERUI_MAX_ITEM)
#define ISCONSTRAINABLEITEM(userData)   (GETUSERDATAITEM(userData) >= CONSTRAINABLE_ITEM)
#define ISFORMTRAYITEM(userData)        (GETUSERDATAITEM(userData) == FORM_TRAY_ITEM)
#define ISFONTSUBSTITEM(userData)       (GETUSERDATAITEM(userData) == FONT_SUBST_ITEM)

//
// Determine whether certain features are supported on the printer
//

#ifdef UNIDRV
#define SUPPORTS_DUPLEX(pci) \
        ((!_BFeatureDisabled(pci, 0xFFFFFFFF, GID_DUPLEX)) && \
        (GET_PREDEFINED_FEATURE((pci)->pUIInfo, GID_DUPLEX) != NULL))
#else
#define SUPPORTS_DUPLEX(pci) \
        ((_BSupportFeature(pci, GID_DUPLEX, NULL)) && \
        (GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_DUPLEX) != NULL))
#endif // UNIDRV

#define SUPPORTS_PAGE_PROTECT(pUIInfo) \
        (GET_PREDEFINED_FEATURE(pUIInfo, GID_PAGEPROTECTION) != NULL)

#ifdef UNIDRV
#define PRINTER_SUPPORTS_COLLATE(pci) \
        ((!_BFeatureDisabled(pci, 0xFFFFFFFF, GID_COLLATE)) && \
        (GET_PREDEFINED_FEATURE((pci)->pUIInfo, GID_COLLATE) != NULL))
#else
#define PRINTER_SUPPORTS_COLLATE(pci) \
        ((_BSupportFeature(pci, GID_COLLATE, NULL)) && \
        (GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_COLLATE) != NULL))
#endif // UNIDRV

#ifdef WINNT_40
#define DRIVER_SUPPORTS_COLLATE(pci)    PRINTER_SUPPORTS_COLLATE(pci)
#else
#define DRIVER_SUPPORTS_COLLATE(pci)    TRUE
#endif


//
// Data structure containing information about cached driver files
//

typedef struct _CACHEDFILE {

    HANDLE  hRemoteFile;        // open handle to remote file on the server
    PWSTR   pRemoteDir;         // remote directory on the server
    PWSTR   pLocalDir;          // local directory
    PWSTR   pFilename;          // name of the cached file

} CACHEDFILE, *PCACHEDFILE;

//
// Functions for copying files over during point and print
//

BOOL _BPrepareToCopyCachedFile(HANDLE, PCACHEDFILE, PWSTR);
BOOL _BCopyCachedFile(PCOMMONINFO, PCACHEDFILE);
VOID _VDisposeCachedFileInfo(PCACHEDFILE);

//
// Driver specific functions (implemented in ps and uni subdirectories)
//

DWORD _DwEnumPersonalities(PCOMMONINFO, PWSTR);
DWORD _DwGetOrientationAngle(PUIINFO, PDEVMODE);
BOOL _BPackDocumentOptions(PUIDATA);
VOID _VUnpackDocumentOptions(POPTITEM, PDEVMODE);
BOOL _BPackPrinterOptions(PUIDATA);
BOOL _BPackOrientationItem(PUIDATA);
INT _IListDevFontNames(HDC, PWSTR, INT);
INT_PTR CALLBACK _AboutDlgProc(HWND, UINT, WPARAM, LPARAM);
#define FREE_DEFAULT_FONTSUB_TABLE(pTTSubstTable) MemFree(pTTSubstTable)

#ifdef PSCRIPT

#define _PwstrGetCallerName()               ((PWSTR) IDS_POSTSCRIPT)
#define _DwGetFontCap(pUIInfo)              (DCTT_DOWNLOAD | DCTT_SUBDEV)
#define _DwGetDefaultResolution()           DEFAULT_RESOLUTION
#define _DwGetPrinterIconID()               IDI_CPSUI_POSTSCRIPT
#define _BUnpackPrinterOptions(pUiData)     TRUE

BOOL _BSupportStapling(PCOMMONINFO);
VOID _VUnpackDriverPrnPropItem(PUIDATA, POPTITEM);
BOOL _BPackItemScale(PUIDATA);
BOOL _BPackFontSubstItems(PUIDATA);
BOOL _BSupportFeature(PCOMMONINFO, DWORD, PFEATURE);
BOOL BDisplayPSCustomPageSizeDialog(PUIDATA);
BOOL BUpdateModelNtfFilename(PCOMMONINFO);
VOID VSyncRevPrintAndOutputOrder(PUIDATA, POPTITEM);

#ifdef WINNT_40
BOOL BUpdateVMErrorMessageID(PCOMMONINFO);
#endif // WINNT_40

#define ISSET_MFSPOOL_FLAG(pdmExtra)    ((pdmExtra)->dwFlags & PSDEVMODE_METAFILE_SPOOL)
#define SET_MFSPOOL_FLAG(pdmExtra)      ((pdmExtra)->dwFlags |= PSDEVMODE_METAFILE_SPOOL)
#define CLEAR_MFSPOOL_FLAG(pdmExtra)    ((pdmExtra)->dwFlags &= ~PSDEVMODE_METAFILE_SPOOL)
#define NUPOPTION(pdmExtra)             ((pdmExtra)->iLayout)
#define REVPRINTOPTION(pdmExtra)        ((pdmExtra)->bReversePrint)
#define GET_DEFAULT_FONTSUB_TABLE(pci, pUIInfo) PtstrGetDefaultTTSubstTable(pUIInfo)
#define NOT_UNUSED_ITEM(bOrderReversed)  TRUE
#define ILOADSTRING(pci, id, wchbuf, size)  0

#endif // PSCRIPT

#ifdef UNIDRV

#define _PwstrGetCallerName()               ((PWSTR) IDS_UNIDRV)
#define _DwGetDefaultResolution()           300
#define _BPackItemScale(pUiData)            TRUE
#define _BPackFontSubstItems(pUiData)       BPackItemFontSubstTable(pUiData)
#define _DwGetPrinterIconID()               IDI_CPSUI_PRINTER2
#define BValidateDevmodeCustomPageSizeFields(pRawData, pUIInfo, pdm, prclImageArea) FALSE
#define _VUnpackDriverPrnPropItem(pUiData, pOptItem)

DWORD _DwGetFontCap(PUIINFO);
BOOL _BUnpackPrinterOptions(PUIDATA);
BOOL _BSupportStapling(PCOMMONINFO);
BOOL _BFeatureDisabled(PCOMMONINFO, DWORD, WORD);
VOID VSyncColorInformation(PUIDATA, POPTITEM);
VOID VMakeMacroSelections(PUIDATA, POPTITEM);
VOID VUpdateMacroSelection(PUIDATA, POPTITEM);
PTSTR PtstrUniGetDefaultTTSubstTable(PCOMMONINFO, PUIINFO);
BOOL BOkToChangeColorToMono(PCOMMONINFO, PDEVMODE, SHORT * , SHORT *);

#define ISSET_MFSPOOL_FLAG(pdmExtra)    (((pdmExtra)->dwFlags & DXF_NOEMFSPOOL) == 0)
#define SET_MFSPOOL_FLAG(pdmExtra)      ((pdmExtra)->dwFlags &= ~DXF_NOEMFSPOOL)
#define CLEAR_MFSPOOL_FLAG(pdmExtra)    ((pdmExtra)->dwFlags |= DXF_NOEMFSPOOL)
#define NUPOPTION(pdmExtra)             ((pdmExtra)->iLayout)
#define REVPRINTOPTION(pdmExtra)        ((pdmExtra)->bReversePrint)

#define GET_DEFAULT_FONTSUB_TABLE(pci, pUIInfo) PtstrUniGetDefaultTTSubstTable(pci, pUIInfo)
#define NOT_UNUSED_ITEM(bOrderReversed)  (bOrderReversed != UNUSED_ITEM)
#define ILOADSTRING(pci, id, wchbuf, size) \
    ILoadStringW(((pci)->pWinResData), id, wchbuf, size)

#endif // UNIDRV

#endif  //!_DRIVERUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\driverui\forms.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    forms.c

Abstract:

    Functions for dealing with paper and forms.

[Environment:]

    Win32 subsystem, PostScript driver

Revision History:

    02/10/97 -davidx-
        Consistent handling of common printer info.

    07/24/96 -amandan-
        Modified for common binary data and common UI module

    07/25/95 -davidx-
        Created it.

--*/

#include "precomp.h"


BOOL
BFormSupportedOnPrinter(
    IN PCOMMONINFO  pci,
    IN PFORM_INFO_1 pForm,
    OUT PDWORD      pdwOptionIndex
    )

/*++

Routine Description:

    Determine whether a form is supported on a printer

Arguments:
    pci - Points to basic printer information
    pForm - Pointer to information about the form in question
    pdwOptionIndex - Returns the paper size option index corresponding
        to the specified form if the form is supported.

Return Value:

    TRUE if the requested form is supported on the printer.
    FALSE otherwise.

--*/

{
    PRAWBINARYDATA  pRawData;
    PUIINFO         pUIInfo;
    PFEATURE        pFeature;
    DWORD           dwIndex;
    CHAR            chBuf[CCHPAPERNAME];
    WCHAR           wchBuf[CCHPAPERNAME];

    //
    // For a user-defined form, we only care about paper dimension.
    // Let the parser handle this case.
    //

    if (! (pForm->Flags & (FORM_BUILTIN|FORM_PRINTER)))
    {
        *pdwOptionIndex = MapToDeviceOptIndex(
                                pci->pInfoHeader,
                                GID_PAGESIZE,
                                pForm->Size.cx,
                                pForm->Size.cy,
                                NULL);

        return (*pdwOptionIndex != OPTION_INDEX_ANY);
    }

    //
    // For predefined or driver-defined form, we need exact name and size match
    //

    chBuf[0] = NUL;
    *pdwOptionIndex = OPTION_INDEX_ANY;

    if (! (pFeature = GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_PAGESIZE)))
        return FALSE;

    for (dwIndex = 0; dwIndex < pFeature->Options.dwCount; dwIndex++)
    {
        PPAGESIZE   pPageSize;
        PWSTR       pwstr;
        PSTR        pstr;
        BOOL        bNameMatch;
        LONG        x, y;

        pPageSize = PGetIndexedOption(pci->pUIInfo, pFeature, dwIndex);
        ASSERT(pPageSize != NULL);

        //
        // check if the size matches
        //

        x = MASTER_UNIT_TO_MICRON(pPageSize->szPaperSize.cx,
                                  pci->pUIInfo->ptMasterUnits.x);

        y = MASTER_UNIT_TO_MICRON(pPageSize->szPaperSize.cy,
                                  pci->pUIInfo->ptMasterUnits.y);

        if (abs(x - pForm->Size.cx) > 1000 ||
            abs(y - pForm->Size.cy) > 1000)
        {
            continue;
        }

        //
        // check if the name matches
        //

        LOAD_STRING_PAGESIZE_NAME(pci, pPageSize, wchBuf, CCHPAPERNAME);
        bNameMatch = (_tcsicmp(wchBuf, pForm->pName) == EQUAL_STRING);


        if (!bNameMatch && (pForm->Flags & FORM_BUILTIN))
        {
            PSTR    pstrKeyword;

            //
            // special klugy for predefined form:
            // if display name doesn't match, try to match the keyword string
            //

            if (chBuf[0] == NUL)
            {
                WideCharToMultiByte(1252, 0, pForm->pName, -1, chBuf, CCHPAPERNAME, NULL, NULL);
                chBuf[CCHPAPERNAME-1] = NUL;
            }
            pstrKeyword = OFFSET_TO_POINTER(pci->pUIInfo->pubResourceData, pPageSize->GenericOption.loKeywordName);

            ASSERT(pstrKeyword != NULL);

            bNameMatch = (_stricmp(chBuf, pstrKeyword) == EQUAL_STRING);
        }


        if (bNameMatch)
        {
             *pdwOptionIndex = dwIndex;
             return TRUE;
        }
    }

    return FALSE;
}



DWORD
DwGuessFormIconID(
    PWSTR   pFormName
    )

/*++

Routine Description:

    Figure out the icon ID corresponding to the named form

Arguments:

    pFormName - Pointer to the form name string

Return Value:

    Icon ID corresponding to the specified form name

Note:

    This is very klugy but I guess it's better than using the same icon
    for all forms. We try to differentiate envelopes from normal forms.
    We assume a form name refers an envelope if it contains word Envelope or Env.

--*/

#define MAXENVLEN 32

{
    static WCHAR wchPrefix[MAXENVLEN], wchEnvelope[MAXENVLEN];
    static INT   iPrefixLen = 0, iEnvelopeLen = 0;

    if (iPrefixLen <= 0 || iEnvelopeLen <= 0)
    {
        iPrefixLen = LoadString(ghInstance, IDS_ENV_PREFIX, wchPrefix, MAXENVLEN);
        iEnvelopeLen = LoadString(ghInstance, IDS_ENVELOPE, wchEnvelope, MAXENVLEN);
    }

    if (iPrefixLen <= 0 || iEnvelopeLen <= 0)
        return IDI_CPSUI_STD_FORM;

    while (*pFormName)
    {
        //
        // Do we have a word matching our description?
        //

        if (_wcsnicmp(pFormName, wchPrefix, iPrefixLen) == EQUAL_STRING &&
            (pFormName[iPrefixLen] == L' ' ||
             pFormName[iPrefixLen] == NUL ||
             _wcsnicmp(pFormName, wchEnvelope, iEnvelopeLen) == EQUAL_STRING))
        {
            return IDI_CPSUI_ENVELOPE;
        }

        //
        // Move on to the next word
        //

        while (*pFormName && *pFormName != L' ')
            pFormName++;

        while (*pFormName && *pFormName == L' ')
            pFormName++;
    }

    return IDI_CPSUI_STD_FORM;
}



ULONG_PTR
HLoadFormIconResource(
    PUIDATA pUiData,
    DWORD   dwIndex
    )

/*++

Routine Description:

    Load the icon resource corresponding to the specified form

Arguments:

    pUiData - Points to UIDATA structure
    dwIndex - Specifies the form index. It's used to index into
         pUiData->pwPaperFeatures to get the page size option index.

Return Value:

    Icon resource handle corresponding to the specified form (casted as DWORD)
    0 if the specified icon resource cannot be loaded

--*/

{
    PFEATURE    pFeature;
    POPTION     pOption;

    dwIndex = pUiData->pwPaperFeatures[dwIndex];

    if ((pFeature = GET_PREDEFINED_FEATURE(pUiData->ci.pUIInfo, GID_PAGESIZE)) &&
        (pOption = PGetIndexedOption(pUiData->ci.pUIInfo, pFeature, dwIndex)) &&
        (pOption->loResourceIcon != 0))
    {
        return HLoadIconFromResourceDLL(&pUiData->ci, pOption->loResourceIcon);
    }

    return 0;
}



POPTTYPE
BFillFormNameOptType(
    IN PUIDATA  pUiData
    )

/*++

Routine Description:

    Initialize an OPTTYPE structure to hold information
    about the list of forms supported by a printer

Arguments:

    pUiData - Pointer to UIDATA structure

Return Value:

    Pointer to an OPTTYPE structure, NULL if there is an error

--*/

{
    POPTTYPE    pOptType;
    POPTPARAM   pOptParam;
    DWORD       dwFormName, dwIndex;
    PWSTR       pFormName;
    PUIINFO     pUIInfo = pUiData->ci.pUIInfo;

    dwFormName = pUiData->dwFormNames;

    //
    // Allocate memory to hold OPTTYPE and OPTPARAM structures
    //

    pOptType = HEAPALLOC(pUiData->ci.hHeap, sizeof(OPTTYPE));
    pOptParam = HEAPALLOC(pUiData->ci.hHeap, sizeof(OPTPARAM) * dwFormName);

    if (!pOptType || !pOptParam)
    {
        ERR(("Memory allocation failed\n"));
        return NULL;
    }

    //
    // Initialize OPTTYPE structure
    //

    pOptType->cbSize = sizeof(OPTTYPE);
    pOptType->Count = (WORD) dwFormName;
    pOptType->Type = TVOT_LISTBOX;
    pOptType->pOptParam = pOptParam;
    pOptType->Style = OTS_LBCB_SORT | OTS_LBCB_INCL_ITEM_NONE;

    //
    // Enumerate the list of supported form names
    //

    pFormName = pUiData->pFormNames;

    for (dwIndex=0; dwIndex < dwFormName; dwIndex++, pOptParam++)
    {
        pOptParam->cbSize = sizeof(OPTPARAM);
        pOptParam->pData = pFormName;

        if (pOptParam->IconID = HLoadFormIconResource(pUiData, dwIndex))
            pOptParam->Flags |= OPTPF_ICONID_AS_HICON;
        else
            pOptParam->IconID = DwGuessFormIconID(pFormName);

        pFormName += CCHPAPERNAME;
    }

    return pOptType;
}



POPTTYPE
PAdjustFormNameOptType(
    IN PUIDATA  pUiData,
    IN POPTTYPE pOptType,
    IN DWORD    dwTraySelection
    )

/*++

Routine Description:

    Adjust the list of forms for each tray
    Check each form for support on printer tray

    Given a tray selected, go through all the forms selection
    and determines which one conflicts with the current tray selection

Arguments:

    pUiData - Pointer to our UIDATA structure
    pOptType - Pointer to OPTTYPE
    dwTraySelection - Tray index

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    POPTPARAM   pOptParam;
    DWORD       dwOptParam, dwFormIndex;
    DWORD       dwTrayFeatureIndex, dwFormFeatureIndex;
    PFEATURE    pTrayFeature, pFormFeature;
    PUIINFO     pUIInfo = pUiData->ci.pUIInfo;

    dwOptParam = pOptType->Count;

    //
    // Find the pointers to InputSlot and PageSize features
    //

    pTrayFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_INPUTSLOT);
    pFormFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_PAGESIZE);

    if (!pTrayFeature || !pFormFeature)
        return pOptType;

    dwTrayFeatureIndex = GET_INDEX_FROM_FEATURE(pUIInfo, pTrayFeature);
    dwFormFeatureIndex = GET_INDEX_FROM_FEATURE(pUIInfo, pFormFeature);

    //
    // Make a copy of the array of formname OPTPARAMs
    //

    if (dwTraySelection != 0)
    {
        POPTTYPE pNewType;

        pNewType = HEAPALLOC(pUiData->ci.hHeap, sizeof(OPTTYPE));
        pOptParam = HEAPALLOC(pUiData->ci.hHeap, sizeof(OPTPARAM) * dwOptParam);

        if (!pNewType || !pOptParam)
        {
            ERR(("Memory allocation failed\n"));
            return NULL;
        }

        CopyMemory(pNewType, pOptType, sizeof(OPTTYPE));
        CopyMemory(pOptParam, pOptType->pOptParam, sizeof(OPTPARAM) * dwOptParam);

        pNewType->pOptParam = pOptParam;
        pOptType = pNewType;
    }
    else
        pOptParam = pOptType->pOptParam;

    //
    // Go through each formname
    // Check whether the current form tray feature, index
    // conflicts with another form tray feature,index
    //

    for (dwFormIndex=0; dwFormIndex < dwOptParam; dwFormIndex++)
    {
        DWORD dwFormSelection = pUiData->pwPaperFeatures[dwFormIndex];

        #ifdef PSCRIPT

        //
        // Hide only the option "PostScript Custom Page Size" itself. For other
        // forms that are supported via PostScript Custom Page Size, we still
        // want to show them, same as Unidrv does.
        //

        if (pUiData->pwPapers[dwFormIndex] == DMPAPER_CUSTOMSIZE)
        {
            pOptParam[dwFormIndex].Flags |= (OPTPF_HIDE | CONSTRAINED_FLAG);
            continue;
        }

        #endif // PSCRIPT

        //
        // If the form conflicts with the tray, then don't display it.
        //

        if (dwFormSelection != OPTION_INDEX_ANY &&
            CheckFeatureOptionConflict(pUiData->ci.pRawData,
                                       dwTrayFeatureIndex,
                                       dwTraySelection,
                                       dwFormFeatureIndex,
                                       dwFormSelection))
        {
            pOptParam[dwFormIndex].Flags |= (OPTPF_HIDE | CONSTRAINED_FLAG);
        }
        else
        {
            pOptParam[dwFormIndex].Flags &= ~(OPTPF_HIDE | CONSTRAINED_FLAG);
        }
    }

    return pOptType;
}



BOOL
BPackItemFormTrayTable(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack form-to-tray assignment information into treeview item
    structures so that we can call common UI library.

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    POPTITEM    pOptItem;
    POPTTYPE    pOptType;
    DWORD       dwIndex, dwTrays;
    PWSTR       pTrayName;

    dwTrays = pUiData->dwBinNames;

    if (dwTrays == 0)
    {
        WARNING(("No paper bin available\n"));
        return TRUE;
    }

    //
    // Form-to-tray assignment table
    //     Tray <-> Form
    //     ...

    VPackOptItemGroupHeader(
            pUiData,
            IDS_CPSUI_FORMTRAYASSIGN,
            IDI_CPSUI_FORMTRAYASSIGN,
            HELP_INDEX_FORMTRAYASSIGN);

    pUiData->dwFormTrayItem = dwTrays;
    pUiData->dwOptItem += dwTrays;

    if (pUiData->pOptItem == NULL)
        return TRUE;

    pUiData->pFormTrayItems = pUiData->pOptItem;

    //
    // Generate the list of form names
    // Each OPTITEM(Tray) has a OPTTYPE.
    //

    pOptType = BFillFormNameOptType(pUiData);

    if (pOptType == NULL)
    {
        ERR(("BFillFormNameOptType failed\n"));
        return FALSE;
    }

    //
    // Create an OPTITEM for each tray
    //

    pTrayName = pUiData->pBinNames ;
    pOptItem = pUiData->pOptItem;

    for (dwIndex=0; dwIndex < dwTrays; dwIndex++)
    {
        //
        // The tray items cannot share OPTTYPE and OPTPARAMs because
        // each tray can contain a different list of forms.
        //

        pOptType = PAdjustFormNameOptType(pUiData, pOptType, dwIndex);

        if (pOptType == NULL)
        {
            ERR(("PAdjustFormNameOptParam failed\n"));
            return FALSE;
        }

        FILLOPTITEM(pOptItem,
                    pOptType,
                    pTrayName,
                    0,
                    TVITEM_LEVEL2,
                    DMPUB_NONE,
                    FORM_TRAY_ITEM,
                    HELP_INDEX_TRAY_ITEM);

        //
        // NOTE: hide the first tray if it's AutoSelect
        //

        if (dwIndex == 0)
        {
            PFEATURE    pFeature;
            PINPUTSLOT  pInputSlot;

            if ((pFeature = GET_PREDEFINED_FEATURE(pUiData->ci.pUIInfo, GID_INPUTSLOT)) &&
                (pInputSlot = PGetIndexedOption(pUiData->ci.pUIInfo, pFeature, 0)) &&
                (pInputSlot->dwPaperSourceID == DMBIN_FORMSOURCE))
            {
                pOptItem->Flags |= (OPTIF_HIDE|OPTIF_DISABLED);
            }
        }

        pOptItem++;
        pTrayName += CCHBINNAME;
    }

    pUiData->pOptItem = pOptItem;
    return TRUE;
}



VOID
VSetupFormTrayAssignments(
    IN PUIDATA  pUiData
    )

/*++

Routine Description:

    Update the current selection of tray items based on
    the specified form-to-tray assignment table

Arguments:

    pUiData - Pointer to our UIDATA structure

Return Value:

    NONE

Note:

    We assume the form-tray items are in their default states
    when this function is called.

--*/

{
    POPTITEM        pOptItem;
    POPTPARAM       pOptParam;
    FORM_TRAY_TABLE pFormTrayTable;
    FINDFORMTRAY    FindData;
    DWORD           dwTrayStartIndex, dwTrayIndex, dwFormIndex, dwTrays, dwOptParam;
    PCOMMONINFO     pci;
    PFEATURE        pFeature;
    PINPUTSLOT      pInputSlot;
    PPAGESIZE       pPageSize;

    if ((dwTrays = pUiData->dwFormTrayItem) == 0)
        return;

    pci = &pUiData->ci;

    pOptItem = pUiData->pFormTrayItems;
    pOptParam = pOptItem->pOptType->pOptParam;
    dwOptParam = pOptItem->pOptType->Count;

    //
    // Initialize the current selection for every tray to be
    //  "Not Available"
    //

    for (dwTrayIndex=0; dwTrayIndex < dwTrays; dwTrayIndex++)
        pOptItem[dwTrayIndex].Sel = -1;

    pFormTrayTable = PGetFormTrayTable(pUiData->ci.hPrinter, NULL);

    //
    // If the form-to-tray assignment information doesn't exist,
    // set up the default assignments
    //

    if (pFormTrayTable == NULL)
    {
        PWSTR  pwstrDefaultForm = NULL;
        WCHAR  awchBuf[CCHPAPERNAME];
        BOOL   bMetric = IsMetricCountry();

        //
        // Get the default formname (Letter or A4) and
        // convert it formname to a seleciton index.
        //

        if (bMetric && (pci->pUIInfo->dwFlags & FLAG_A4_SIZE_EXISTS))
        {
            pwstrDefaultForm = A4_FORMNAME;
        }
        else if (!bMetric && (pci->pUIInfo->dwFlags & FLAG_LETTER_SIZE_EXISTS))
        {
            pwstrDefaultForm = LETTER_FORMNAME;
        }
        else
        {
            if ((pFeature = GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_PAGESIZE)) &&
                (pPageSize = PGetIndexedOption(pci->pUIInfo, pFeature, pFeature->dwDefaultOptIndex)) &&
                LOAD_STRING_PAGESIZE_NAME(pci, pPageSize, awchBuf, CCHPAPERNAME))
            {
                pwstrDefaultForm = &(awchBuf[0]);
            }
        }

        //
        // If we can't find the default form name, we have to use the first option as the default.
        //

        dwFormIndex = pwstrDefaultForm ? DwFindFormNameIndex(pUiData, pwstrDefaultForm, NULL) : 0 ;

        ASSERT(dwFormIndex < dwOptParam);

        //
        // Set the default formname for each enabled tray
        //

        for (dwTrayIndex=0; dwTrayIndex < dwTrays; dwTrayIndex++)
        {
            if (! (pOptItem[dwTrayIndex].Flags & OPTIF_DISABLED) &&
                ! IS_CONSTRAINED(&pOptItem[dwTrayIndex], dwFormIndex))
            {
                pOptItem[dwTrayIndex].Sel = dwFormIndex;
            }
        }

        //
        // Save the default form-to-tray assignment table to registry.
        //

        if (HASPERMISSION(pUiData))
            BUnpackItemFormTrayTable(pUiData);

        return;
    }

    //
    // We are here means that the form to tray assignment does exits.
    // Iterate thru the form-to-tray assignment table one entry at
    // a time and update the current selection of tray items.
    //

    RESET_FINDFORMTRAY(pFormTrayTable, &FindData);

    //
    // If we have synthersized the first "AutoSelect" tray, we should skip it
    // in following searching through the form to tray assignment table.
    //
    // (refer to the logic in previous function BPackItemFormTrayTable)
    //

    dwTrayStartIndex = 0;

    if ((pFeature = GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_INPUTSLOT)) &&
        (pInputSlot = PGetIndexedOption(pci->pUIInfo, pFeature, 0)) &&
        (pInputSlot->dwPaperSourceID == DMBIN_FORMSOURCE))
    {
        dwTrayStartIndex = 1;
    }

    while (BSearchFormTrayTable(pFormTrayTable, NULL, NULL, &FindData))
    {
        //
        // Get the next entry in the form-to-tray assignment table
        //

        for (dwTrayIndex = dwTrayStartIndex; dwTrayIndex < dwTrays; dwTrayIndex++)
        {
            //
            // found matching tray?
            //

            if (_wcsicmp(FindData.ptstrTrayName, pOptItem[dwTrayIndex].pName) == EQUAL_STRING)
            {
                //
                // If the specified tray name is supported, then check
                // if the associated form name is supported.
                //

                for (dwFormIndex=0; dwFormIndex < dwOptParam; dwFormIndex++)
                {
                    if (_wcsicmp(FindData.ptstrFormName,
                                 pOptParam[dwFormIndex].pData) == EQUAL_STRING)
                    {
                        break;
                    }
                }

                if (dwFormIndex == dwOptParam)
                {
                    WARNING(("Unknown form name: %ws\n", FindData.ptstrFormName));
                }
                else if ((pOptItem[dwTrayIndex].Flags & OPTIF_DISABLED) ||
                         IS_CONSTRAINED(&pOptItem[dwTrayIndex], dwFormIndex))
                {
                    WARNING(("Conflicting form-tray assignment\n"));
                }
                else
                {
                    //
                    // If the associated form name is supported,
                    // then remember the form index.
                    //

                    pOptItem[dwTrayIndex].Sel = dwFormIndex;
                }

                break;
            }
        }

        if (dwTrayIndex == dwTrays)
            WARNING(("Unknown tray name: %ws\n", FindData.ptstrTrayName));
    }

    MemFree(pFormTrayTable);
}



DWORD
DwCollectFormTrayAssignments(
    IN PUIDATA  pUiData,
    OUT PWSTR   pwstrTable
    )

/*++

Routine Description:

    Collect the form-to-tray assignment information and save it to registry.

Arguments:

    pUiData - Pointer to our UIDATA structure
    pwstrTable - Pointer to memory buffer for storing the table
        NULL if the caller is only interested in the table size

Return Value:

    Size of the table bytes, 0 if there is an error.

--*/

{
    DWORD       dwChars = 0;
    INT         iLength;
    DWORD       dwIndex;
    POPTPARAM   pOptParam;
    DWORD       dwOptItem = pUiData->dwFormTrayItem;
    POPTITEM    pOptItem = pUiData->pFormTrayItems;

    for (dwIndex=0; dwIndex < dwOptItem; dwIndex++, pOptItem++)
    {
        ASSERT(ISFORMTRAYITEM(pOptItem->UserData));

        if ((pOptItem->Flags & OPTIF_DISABLED))
            continue;

        //
        // Get the Tray name
        //

        iLength = wcslen(pOptItem->pName) + 1;
        dwChars += iLength;

        if (pwstrTable != NULL)
        {
            CopyMemory(pwstrTable, pOptItem->pName, iLength * sizeof(WCHAR));
            pwstrTable += iLength;
        }

        //
        // Form name
        //

        if (pOptItem->Sel < 0 )
        {
            dwChars++;
            if (pwstrTable != NULL)
                *pwstrTable++ = NUL;

            continue;
        }

        pOptParam = pOptItem->pOptType->pOptParam + pOptItem->Sel;
        iLength = wcslen(pOptParam->pData) + 1;
        dwChars += iLength;

        if (pwstrTable != NULL)
        {
            CopyMemory(pwstrTable, pOptParam->pData, iLength * sizeof(WCHAR));
            pwstrTable += iLength;
        }
    }

    //
    // Append a NUL character at the end of the table
    //

    dwChars++;

    if (pwstrTable != NULL)
        *pwstrTable = NUL;

    //
    // Return the table size in bytes
    //

    return dwChars * sizeof(WCHAR);
}



BOOL
BUnpackItemFormTrayTable(
    IN PUIDATA  pUiData
    )

/*++

Routine Description:

    Extract form-to-tray assignment information from treeview items

Arguments:

    pUiData - Pointer to UIDATA structure

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    PWSTR   pwstrTable = NULL;
    DWORD   dwTableSize;

    //
    // Figure out how much memory we need to store the form-to-tray assignment table
    // Assemble the form-to-tray assignment table
    // Save the form-to-tray assignment table to registry
    //

    if ((dwTableSize = DwCollectFormTrayAssignments(pUiData, NULL)) == 0 ||
        (pwstrTable = MemAlloc(dwTableSize)) == NULL ||
        (dwTableSize != DwCollectFormTrayAssignments(pUiData, pwstrTable)) ||
        !BSaveFormTrayTable(pUiData->ci.hPrinter, pwstrTable, dwTableSize))
    {
        ERR(("Couldn't save form-to-tray assignment table\n"));
        MemFree(pwstrTable);
        return FALSE;
    }

    #ifndef WINNT_40

    //
    // Publish list of available forms in the directory service
    //

    VNotifyDSOfUpdate(pUiData->ci.hPrinter);

   #endif // !WINNT_40

    MemFree(pwstrTable);
    return TRUE;
}



DWORD
DwFindFormNameIndex(
    IN  PUIDATA  pUiData,
    IN  PWSTR    pFormName,
    OUT PBOOL    pbSupported
    )

/*++

Routine Description:

    Given a formname, find its index in the list of supported forms

Arguments:

    pUiData - Pointer to our UIDATA structure
    pFormName - Formname in question
    pbSupported - Whether or not the form is suppported

Return Value:

    Index of the specified formname in the list.

--*/

{
    DWORD       dwIndex;
    PWSTR       pName;
    FORM_INFO_1 *pForm;
    PFEATURE    pFeature;
    PPAGESIZE   pPageSize;
    WCHAR       awchBuf[CCHPAPERNAME];
    PCOMMONINFO pci;

    if (pbSupported)
        *pbSupported = TRUE;

    if (IS_EMPTY_STRING(pFormName))
        return 0;

    //
    // Check if the name appears in the list
    //

    pName = pUiData->pFormNames;

    for (dwIndex=0; dwIndex < pUiData->dwFormNames; dwIndex++)
    {
        if (_wcsicmp(pFormName, pName) == EQUAL_STRING)
            return dwIndex;

        pName += CCHPAPERNAME;
    }

    //
    // If the name is not in the list, try to match
    // the form to a printer page size
    //

    pci = (PCOMMONINFO) pUiData;

    if ((pForm = MyGetForm(pci->hPrinter, pFormName, 1)) &&
        BFormSupportedOnPrinter(pci, pForm, &dwIndex) &&
        (pFeature = GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_PAGESIZE)) &&
        (pPageSize = PGetIndexedOption(pci->pUIInfo, pFeature, dwIndex)) &&
        LOAD_STRING_PAGESIZE_NAME(pci, pPageSize, awchBuf, CCHPAPERNAME))
    {
        pName = pUiData->pFormNames;

        for (dwIndex = 0; dwIndex < pUiData->dwFormNames; dwIndex++)
        {
            if (_wcsicmp(awchBuf, pName) == EQUAL_STRING)
            {
                MemFree(pForm);
                return dwIndex;
            }

            pName += CCHPAPERNAME;
        }
    }

    MemFree(pForm);

    //
    // The specified form is not supported on the printer.
    // Select the first available form.
    //

    if (pbSupported)
        *pbSupported = FALSE;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\driverui\docprop.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    docprop.c

Abstract:

    This file handles the DrvDocumentProperties and
    DrvDocumentPropertySheets spooler API

Environment:

    Win32 subsystem, DriverUI module, user mode

Revision History:

    02/13/97 -davidx-
        Implement OEM plugin support.

    02/13/97 -davidx-
        Working only with options array internally.

    02/10/97 -davidx-
        Consistent handling of common printer info.

    02/04/97 -davidx-
        Reorganize driver UI to separate ps and uni DLLs.

    07/17/96 -amandan-
        Created it.

--*/

#include "precomp.h"

//
// Local and external function declarations
//

LONG LSimpleDocumentProperties( PDOCUMENTPROPERTYHEADER);
CPSUICALLBACK cpcbDocumentPropertyCallback(PCPSUICBPARAM);
BOOL BGetPageOrderFlag(PCOMMONINFO);
VOID VUpdateEmfFeatureItems(PUIDATA, BOOL);
VOID VUpdateBookletOption(PUIDATA , POPTITEM);

LONG
DrvDocumentPropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam
    )

/*++

Routine Description:

    This function is called to add the Document Property Page to the specified
    property sheets and/or to update the document properties.

    If pPSUIInfo is NULL, it performs the operation specified by the fMode flag of
    DOCUMENTPROPERTYHEADER.  Specifically, if flMode is zero or pDPHdr->pdmOut
    is NULL, return the size of DEVMODE.

    If pPSUInfo is not NULL: pPSUIInf->Reason

    REASON_INIT- fills PCOMPROPSHEETUI with document UI items
                 calls compstui to add the page.

    REASON_GET_INFO_HEADER - fills out PROPSHEETUI_INFO.

    REASON_SET_RESULT - saves devmode settings and copy the devmode into output buffer.

    REASON_DESTROY - Cleans up.

Arguments:

    pSUIInfo - pointer to PPROPSHEETUI_INFO
    lParam - varies depending on the reason this function is called


Return Value:

    > 0 success <= 0 for failure

--*/

{
    PDOCUMENTPROPERTYHEADER pDPHdr;
    PCOMPROPSHEETUI         pCompstui;
    PUIDATA                 pUiData;
    PDLGPAGE                pDlgPage;
    LONG                    lRet;
    BOOL                    bResult=FALSE;

    //
    // Validate input parameters
    //

    if (! (pDPHdr = (PDOCUMENTPROPERTYHEADER) (pPSUIInfo ? pPSUIInfo->lParamInit : lParam)))
    {
        RIP(("DrvDocumentPropertySheets: invalid parameters\n"));
        return -1;
    }

    //
    // pPSUIInfo = NULL, the caller is spooler so just handle the simple case,
    // no display is necessary.
    //

    if (pPSUIInfo == NULL)
        return LSimpleDocumentProperties(pDPHdr);

    //
    // Create a UIDATA structure if necessary
    //

    if (pPSUIInfo->Reason == PROPSHEETUI_REASON_INIT)
    {
        pUiData = PFillUiData(pDPHdr->hPrinter,
                              pDPHdr->pszPrinterName,
                              pDPHdr->pdmIn,
                              MODE_DOCUMENT_STICKY);
    }
    else
        pUiData = (PUIDATA) pPSUIInfo->UserData;

    //
    // Validate pUiData
    //

    if (pUiData == NULL)
    {
        ERR(("UIDATA is NULL\n"));
        return -1;
    }

    ASSERT(VALIDUIDATA(pUiData));

    //
    // Handle various cases for which this function might be called
    //

    switch (pPSUIInfo->Reason)
    {
    case PROPSHEETUI_REASON_INIT:

        //
        // Allocate memory and partially fill out various data
        // structures required to call common UI routine.
        //

        pDlgPage = (pDPHdr->fMode & DM_ADVANCED) ?
                        CPSUI_PDLGPAGE_ADVDOCPROP :
                        CPSUI_PDLGPAGE_DOCPROP;

        pUiData->bPermission = ((pDPHdr->fMode & DM_NOPERMISSION) == 0);

        #ifdef PSCRIPT

        FOREACH_OEMPLUGIN_LOOP((&(pUiData->ci)))

            if (HAS_COM_INTERFACE(pOemEntry))
            {
                HRESULT hr;

                hr = HComOEMHideStandardUI(pOemEntry,
                                           OEMCUIP_DOCPROP);

                //
                // In the case when multiple plugins are chained, it doesn't
                // make sense for one plugin to hide standard UI when another
                // one still wants to use the standard UI. So as long as one
                // plugin returns S_OK here, we will hide the standard UI.
                //

                if (bResult = SUCCEEDED(hr))
                    break;
            }

        END_OEMPLUGIN_LOOP

        #endif // PSCRIPT

        if (bResult)
        {
            //
            // Set the flag to indicate plugin is hiding our standard
            // document property sheet UI.
            //

            pUiData->dwHideFlags |= HIDEFLAG_HIDE_STD_DOCPROP;

            pUiData->pfnComPropSheet = pPSUIInfo->pfnComPropSheet;
            pUiData->hComPropSheet = pPSUIInfo->hComPropSheet;

            if (BAddOemPluginPages(pUiData, pDPHdr->fMode))
            {
                pPSUIInfo->UserData = (ULONG_PTR) pUiData;
                pPSUIInfo->Result = CPSUI_CANCEL;
                lRet = 1;
                break;
            }
        }
        else if (pCompstui = PPrepareDataForCommonUI(pUiData, pDlgPage))
        {
            #ifdef UNIDRV

                VMakeMacroSelections(pUiData, NULL);

            #endif

            pCompstui->pfnCallBack = cpcbDocumentPropertyCallback;
            pUiData->pfnComPropSheet = pPSUIInfo->pfnComPropSheet;
            pUiData->hComPropSheet = pPSUIInfo->hComPropSheet;
            pUiData->pCompstui = pCompstui;

            //
            // Indicate which items are constrained
            //

            VPropShowConstraints(pUiData, MODE_DOCANDPRINTER_STICKY);

            //
            // Call common UI library to add our pages
            //

            if (pUiData->pfnComPropSheet(pUiData->hComPropSheet,
                                         CPSFUNC_ADD_PCOMPROPSHEETUI,
                                         (LPARAM) pCompstui,
                                         (LPARAM) &lRet) &&
                BAddOemPluginPages(pUiData, pDPHdr->fMode))
            {
                pPSUIInfo->UserData = (ULONG_PTR) pUiData;
                pPSUIInfo->Result = CPSUI_CANCEL;
                lRet = 1;
                break;
            }
        }

        //
        // Clean up in the case of error
        //

        ERR(("Failed to initialize property sheets\n"));
        VFreeUiData(pUiData);
        return  -1;

    case PROPSHEETUI_REASON_GET_INFO_HEADER:
        {
            PPROPSHEETUI_INFO_HEADER pPSUIHdr;
            DWORD                    dwIcon;

            pPSUIHdr = (PPROPSHEETUI_INFO_HEADER) lParam;
            pPSUIHdr->Flags = PSUIHDRF_PROPTITLE | PSUIHDRF_NOAPPLYNOW;
            pPSUIHdr->pTitle = pUiData->ci.pPrinterName;
            pPSUIHdr->hInst = ghInstance;

            //
            // Use the Icon specified in the binary data as
            // the printer icon.
            //

            dwIcon = pUiData->ci.pUIInfo->loPrinterIcon;

            if (dwIcon && (pPSUIHdr->IconID = HLoadIconFromResourceDLL(&pUiData->ci, dwIcon)))
                pPSUIHdr->Flags |= PSUIHDRF_USEHICON;
            else
                pPSUIHdr->IconID = _DwGetPrinterIconID();
        }

        lRet = 1;
        break;

    case PROPSHEETUI_REASON_SET_RESULT:

        //
        // Copy the new devmode back into the output buffer provided by the caller
        // Always return the smaller of current and input devmode
        //

        {
            PSETRESULT_INFO pSRInfo = (PSETRESULT_INFO) lParam;

            if ((pSRInfo->Result == CPSUI_OK) &&
                (pDPHdr->pdmOut != NULL) &&
                (pDPHdr->fMode & (DM_COPY | DM_UPDATE)))
            {
                PCOMMONINFO pci = (PCOMMONINFO)pUiData;

                //
                // CPSUICB_REASON_APPLYNOW may not have been called. If so, we need
                // to perform tasks that are usually done by CPSUICB_REASON_APPLYNOW
                // case in our callback function cpcbDocumentPropertyCallback.
                //

                if (!(pci->dwFlags & FLAG_APPLYNOW_CALLED))
                {
                    OPTSELECT OldCombinedOptions[MAX_COMBINED_OPTIONS];

                    //
                    // Save a copy the pre-resolve option array
                    //

                    CopyMemory(OldCombinedOptions,
                               pci->pCombinedOptions,
                               MAX_COMBINED_OPTIONS * sizeof(OPTSELECT));

                    //
                    // Call the parsers to resolve any remaining conflicts.
                    //

                    ResolveUIConflicts(pci->pRawData,
                                       pci->pCombinedOptions,
                                       MAX_COMBINED_OPTIONS,
                                       MODE_DOCANDPRINTER_STICKY);

                    //
                    // Update the OPTITEM list to match the updated options array
                    //

                    VUpdateOptItemList(pUiData, OldCombinedOptions, pci->pCombinedOptions);

                    //
                    // Transfer information from options array to public devmode fields
                    //

                    VOptionsToDevmodeFields(&pUiData->ci, FALSE);

                    //
                    // Separate the doc-sticky options from the combined array
                    // and save it back to the private devmode aOptions array
                    //

                    SeparateOptionArray(
                            pci->pRawData,
                            pci->pCombinedOptions,
                            PGetDevmodeOptionsArray(pci->pdm),
                            MAX_PRINTER_OPTIONS,
                            MODE_DOCUMENT_STICKY);
                }

                BConvertDevmodeOut(pci->pdm,
                                   pDPHdr->pdmIn,
                                   pDPHdr->pdmOut);
            }

            pPSUIInfo->Result = pSRInfo->Result;
        }

        lRet = 1;
        break;

    case PROPSHEETUI_REASON_DESTROY:

        //
        // Clean up
        //

        VFreeUiData(pUiData);
        lRet = 1;

        break;

    default:

        ERR(("Unknown reason in DrvDocumentPropertySheets\n"));
        return -1;
    }

    return lRet;
}



LONG
LSimpleDocumentProperties(
    IN  OUT PDOCUMENTPROPERTYHEADER pDPHdr
    )

/*++

Routine Description:

    Handle simple "Document Properties" where we don't need to display
    a dialog and therefore don't have to have common UI library involved
    Mainly, devmode handling - update, merge, copy etc.

Arguments:

    pDPHdr - Points to a DOCUMENTPROPERTYHEADER structure

Return Value:

    > 0 if successful, <= 0 otherwise

--*/

{
    PCOMMONINFO     pci;
    DWORD           dwSize;
    PPRINTER_INFO_2 pPrinterInfo2;

    //
    // Load common printer info
    //

    pci = PLoadCommonInfo(pDPHdr->hPrinter, pDPHdr->pszPrinterName, 0);

    if (!pci || !BCalcTotalOEMDMSize(pci->hPrinter, pci->pOemPlugins, &dwSize))
    {
        VFreeCommonInfo(pci);
        return -1;
    }

    //
    // Check if the caller is interested in the size only
    //

    pDPHdr->cbOut = sizeof(DEVMODE) + gDriverDMInfo.dmDriverExtra + dwSize;

    if (pDPHdr->fMode == 0 || pDPHdr->pdmOut == NULL)
    {
        VFreeCommonInfo(pci);
        return pDPHdr->cbOut;
    }

    //
    // Merge the input devmode with the driver and system default devmodes
    //

    if (! (pPrinterInfo2 = MyGetPrinter(pci->hPrinter, 2)) ||
        ! BFillCommonInfoDevmode(pci, pPrinterInfo2->pDevMode, pDPHdr->pdmIn))
    {
        MemFree(pPrinterInfo2);
        VFreeCommonInfo(pci);
        return -1;
    }

    MemFree(pPrinterInfo2);

    //
    // Copy the devmode back into the output buffer provided by the caller
    // Always return the smaller of current and input devmode
    //

    if (pDPHdr->fMode & (DM_COPY | DM_UPDATE))
        (VOID) BConvertDevmodeOut(pci->pdm, pDPHdr->pdmIn, pDPHdr->pdmOut);

    //
    // Clean up before returning to caller
    //

    VFreeCommonInfo(pci);
    return 1;
}



VOID
VRestoreDefaultFeatureSelection(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Restore the printer feature selections to their default state

Arguments:

    pUiData - Points to our UIDATA structure

Return Value:

    NONE

--*/

{
    POPTSELECT  pOptionsArray;
    PFEATURE    pFeature;
    POPTITEM    pOptItem;
    DWORD       dwCount, dwFeatureIndex, dwDefault;
    PUIINFO     pUIInfo;

    //
    // Go through each printer feature item and check to see if
    // its current selection matches the default value
    //

    pUIInfo = pUiData->ci.pUIInfo;
    pOptionsArray = pUiData->ci.pCombinedOptions;
    pOptItem = pUiData->pFeatureItems;
    dwCount = pUiData->dwFeatureItem;

    for ( ; dwCount--; pOptItem++)
    {
        pFeature = (PFEATURE) GETUSERDATAITEM(pOptItem->UserData);
        dwFeatureIndex = GET_INDEX_FROM_FEATURE(pUIInfo, pFeature);
        dwDefault = pFeature->dwDefaultOptIndex;

        //
        // If the current selection doesn't match the default,
        // restore it to the default value.
        //

        if (pOptionsArray[dwFeatureIndex].ubCurOptIndex != dwDefault)
        {
            pOptionsArray[dwFeatureIndex].ubCurOptIndex = (BYTE) dwDefault;
            pOptItem->Flags |= OPTIF_CHANGED;
            pOptItem->Sel = (dwDefault == OPTION_INDEX_ANY) ? 0 : dwDefault;
        }
    }

    //
    // Update the display and indicate which items are constrained
    //

    VPropShowConstraints(pUiData, MODE_DOCANDPRINTER_STICKY);
}



VOID
VOptionsToDevmodeFields(
    IN OUT PCOMMONINFO  pci,
    IN BOOL             bUpdateFormFields
    )

/*++

Routine Description:

     Convert options in pUiData->pOptionsArray into public devmode fields

Arguments:

     pci - Points to basic printer info
     bUpdateFormFields - Whether or not to convert paper size option into devmode

Return Value:

     None

--*/
{
    PFEATURE    pFeature;
    POPTION     pOption;
    DWORD       dwGID, dwFeatureIndex, dwOptionIndex;
    PUIINFO     pUIInfo;
    PDEVMODE    pdm;

    //
    // Go through all predefine IDs and propage the option selection
    // into appropriate devmode fields
    //

    pUIInfo = pci->pUIInfo;
    pdm = pci->pdm;

    for (dwGID=0 ; dwGID < MAX_GID ; dwGID++)
    {
        //
        // Get the feature to get the options, and get the index
        // into the option array
        //

        if ((pFeature = GET_PREDEFINED_FEATURE(pUIInfo, dwGID)) == NULL)
            continue;

        dwFeatureIndex = GET_INDEX_FROM_FEATURE(pUIInfo, pFeature);
        dwOptionIndex = pci->pCombinedOptions[dwFeatureIndex].ubCurOptIndex;

        //
        // Get the pointer to the option array for the feature
        //

        if ((pOption = PGetIndexedOption(pUIInfo, pFeature, dwOptionIndex)) == NULL)
            continue;

        switch(dwGID)
        {
        case GID_RESOLUTION:
        {
            PRESOLUTION pRes = (PRESOLUTION)pOption;

            //
            // Get to the option selected
            //

            pdm->dmFields |= (DM_PRINTQUALITY|DM_YRESOLUTION);
            pdm->dmPrintQuality = GETQUALITY_X(pRes);
            pdm->dmYResolution = GETQUALITY_Y(pRes);

        }
            break;

        case GID_DUPLEX:

            //
            // Get to the option selected
            //

            pdm->dmFields |= DM_DUPLEX;
            pdm->dmDuplex = (SHORT) ((PDUPLEX) pOption)->dwDuplexID;
            break;

        case GID_INPUTSLOT:

            //
            // Get to the option selected
            //

            pdm->dmFields |= DM_DEFAULTSOURCE;
            pdm->dmDefaultSource = (SHORT) ((PINPUTSLOT) pOption)->dwPaperSourceID;
            break;

        case GID_MEDIATYPE:

            //
            // Get to the option selected
            //

            pdm->dmFields |= DM_MEDIATYPE;
            pdm->dmMediaType = (SHORT) ((PMEDIATYPE) pOption)->dwMediaTypeID;
            break;

        case GID_ORIENTATION:

            if (((PORIENTATION) pOption)->dwRotationAngle == ROTATE_NONE)
                pdm->dmOrientation = DMORIENT_PORTRAIT;
            else
                pdm->dmOrientation = DMORIENT_LANDSCAPE;

            pdm->dmFields |= DM_ORIENTATION;
            break;

            //
            // Fix #2822: VOptionsToDevmodeFields should be called after calling
            // VFixOptionsArrayWithDevmode and ResolveUIConflicts, which could
            // change option array to be out of sync with devmode.
            //

        case GID_COLLATE:

            pdm->dmFields |= DM_COLLATE;
            pdm->dmCollate = (SHORT) ((PCOLLATE) pOption)->dwCollateID;
            break;

        case GID_PAGESIZE:
            {
                PPAGESIZE  pPageSize = (PPAGESIZE)pOption;
                WCHAR      awchBuf[CCHPAPERNAME];

                //
                // Ignore the custom page size option. We don't add custom page size option to the
                // form database, see BAddOrUpgradePrinterForms(). Also see BQueryPrintForm() for
                // special handling of custom page size for DDI DevQueryPrintEx().
                //

                if (pPageSize->dwPaperSizeID == DMPAPER_USER ||
                    pPageSize->dwPaperSizeID == DMPAPER_CUSTOMSIZE)
                {
                    VERBOSE(("VOptionsToDevmodeFields: %d ignored\n", pPageSize->dwPaperSizeID));
                    break;
                }

                //
                // bUpdateFormFields should be FALSE if we don't want to overwrite devmode form
                // fields with our option array's page size setting. One case of this is when
                // user hits the doc-setting UI's OK buttion, at that time we need to propagate
                // our internal devmode to app's output devmode. See cpcbDocumentPropertyCallback().
                // That's because in option array we could have already mapped devmode's form request
                // to a paper size the printer supports (example: devmode requets Legal, we map
                // it to the printer's form OEM_Legal). So we don't want to overwrite output devmode
                // form fields with our internal option.
                //

                if (!bUpdateFormFields)
                    break;

                if (!LOAD_STRING_PAGESIZE_NAME(pci, pPageSize, awchBuf, CCHPAPERNAME))
                {
                    ERR(("VOptionsToDevmodeFields: cannot get paper name\n"));
                    break;
                }

                pdm->dmFields &= ~(DM_PAPERWIDTH|DM_PAPERLENGTH|DM_PAPERSIZE);
                pdm->dmFields |= DM_FORMNAME;

                CopyString(pdm->dmFormName, awchBuf, CCHFORMNAME);

                if (!BValidateDevmodeFormFields(
                        pci->hPrinter,
                        pdm,
                        NULL,
                        pci->pSplForms,
                        pci->dwSplForms))
                {
                    VDefaultDevmodeFormFields(pUIInfo, pdm, IsMetricCountry());
                }
            }

            break;
        }
    }
}



CPSUICALLBACK
cpcbDocumentPropertyCallback(
    IN  OUT PCPSUICBPARAM pCallbackParam
    )

/*++

Routine Description:

    Callback function provided to common UI DLL for handling
    document properties dialog.

Arguments:

    pCallbackParam - Pointer to CPSUICBPARAM structure

Return Value:

    CPSUICB_ACTION_NONE - no action needed
    CPSUICB_ACTION_OPTIF_CHANGED - items changed and should be refreshed

--*/

{
    PUIDATA     pUiData;
    POPTITEM    pCurItem, pOptItem;
    LONG        lRet;
    PFEATURE    pFeature;

    pUiData = (PUIDATA) pCallbackParam->UserData;
    ASSERT(pUiData != NULL);

    pUiData->hDlg = pCallbackParam->hDlg;
    pCurItem = pCallbackParam->pCurItem;
    lRet = CPSUICB_ACTION_NONE;

    //
    // If user has no permission to change anything, then
    // simply return without taking any action.
    //

    if (!HASPERMISSION(pUiData) && (pCallbackParam->Reason != CPSUICB_REASON_ABOUT))
        return lRet;

    switch (pCallbackParam->Reason)
    {
    case CPSUICB_REASON_SEL_CHANGED:
    case CPSUICB_REASON_ECB_CHANGED:

        if (! IS_DRIVER_OPTITEM(pUiData, pCurItem))
            break;

        //
        // Everytime the user make any changes, we update the
        // pOptionsArray.  These settings are not saved to the devmode
        // until the user hit OK.
        //
        // VUnpackDocumentPropertiesItems saves the settings to pUiData->pOptionsArray
        // and update the private devmode flags if applicable.
        // ICheckConstraintsDlg check if the user has selected a constrained option
        //

        VUnpackDocumentPropertiesItems(pUiData, pCurItem, 1);

        #ifdef UNIDRV

        VSyncColorInformation(pUiData, pCurItem);

        //
        // Quality Macro support
        //

        if (GETUSERDATAITEM(pCurItem->UserData) == QUALITY_SETTINGS_ITEM ||
            GETUSERDATAITEM(pCurItem->UserData) == COLOR_ITEM ||
            GETUSERDATAITEM(pCurItem->UserData) == MEDIATYPE_ITEM ||
            ((pFeature = PGetFeatureFromItem(pUiData->ci.pUIInfo, pCurItem, NULL))&&
             pFeature->dwFlags & FEATURE_FLAG_UPDATESNAPSHOT))
        {
            VMakeMacroSelections(pUiData, pCurItem);

            //
            // Needs to update the constraints since Macro selection might have
            // changed the constraints
            //

            VPropShowConstraints(pUiData, MODE_DOCANDPRINTER_STICKY);
            VUpdateMacroSelection(pUiData, pCurItem);

        }
        else
        {
            //
            // Check whether the current selection invalidates the macros
            // and update QUALITY_SETTINGS_ITEM.

            VUpdateMacroSelection(pUiData, pCurItem);
        }

        #endif   // UNIDRV

        #ifdef PSCRIPT

        if (GETUSERDATAITEM(pCurItem->UserData) == REVPRINT_ITEM)
        {
            VSyncRevPrintAndOutputOrder(pUiData, pCurItem);
        }

        #endif // PSCRIPT

        if (GETUSERDATAITEM(pCurItem->UserData) == METASPOOL_ITEM ||
            GETUSERDATAITEM(pCurItem->UserData) == NUP_ITEM ||
            GETUSERDATAITEM(pCurItem->UserData) == REVPRINT_ITEM ||
            GETUSERDATAITEM(pCurItem->UserData) == COPIES_COLLATE_ITEM ||
            ((pFeature = PGetFeatureFromItem(pUiData->ci.pUIInfo, pCurItem, NULL)) &&
             pFeature->dwFeatureID == GID_OUTPUTBIN))
        {
            VUpdateEmfFeatureItems(pUiData, GETUSERDATAITEM(pCurItem->UserData) != METASPOOL_ITEM);
        }

        #ifdef UNIDRV

        VSyncColorInformation(pUiData, pCurItem);

        #endif

        #ifdef PSCRIPT

        //
        // If the user has selected custom page size,
        // bring up the custom page size dialog now.
        //

        if (GETUSERDATAITEM(pCurItem->UserData) == FORMNAME_ITEM &&
            pCurItem->pExtPush != NULL)
        {
            if (pUiData->pwPapers[pCurItem->Sel] == DMPAPER_CUSTOMSIZE)
            {
                (VOID) BDisplayPSCustomPageSizeDialog(pUiData);
                pCurItem->Flags &= ~(OPTIF_EXT_HIDE | OPTIF_EXT_DISABLED);
            }
            else
                pCurItem->Flags |= (OPTIF_EXT_HIDE | OPTIF_EXT_DISABLED);

            pCurItem->Flags |= OPTIF_CHANGED;
        }

        #endif // PSCRIPT

        //
        // Update the display and indicate which items are constrained.
        //

        VPropShowConstraints(pUiData, MODE_DOCANDPRINTER_STICKY);

        lRet = CPSUICB_ACTION_REINIT_ITEMS;


        break;

    case CPSUICB_REASON_ITEMS_REVERTED:

        //
        // Unpack document properties treeview items
        //

        VUnpackDocumentPropertiesItems(pUiData,
                                       pUiData->pDrvOptItem,
                                       pUiData->dwDrvOptItem);

        //
        // Update the display and indicate which items are constrained
        //

        VPropShowConstraints(pUiData, MODE_DOCANDPRINTER_STICKY);

        lRet = CPSUICB_ACTION_OPTIF_CHANGED;
        break;

    case CPSUICB_REASON_EXTPUSH:

        #ifdef PSCRIPT

        if (GETUSERDATAITEM(pCurItem->UserData) == FORMNAME_ITEM)
        {
            //
            // Push button to bring up PostScript custom page size dialog
            //

            (VOID) BDisplayPSCustomPageSizeDialog(pUiData);
        }

        #endif // PSCRIPT

        if (pCurItem == pUiData->pFeatureHdrItem)
        {
            //
            // Push button for restoring all generic feature selections
            // to their default values
            //

            VRestoreDefaultFeatureSelection(pUiData);
            lRet = CPSUICB_ACTION_REINIT_ITEMS;
        }
        break;


    case CPSUICB_REASON_ABOUT:

        DialogBoxParam(ghInstance,
                       MAKEINTRESOURCE(IDD_ABOUT),
                       pUiData->hDlg,
                       (DLGPROC) _AboutDlgProc,
                       (LPARAM) pUiData);
        break;


    case CPSUICB_REASON_APPLYNOW:

        pUiData->ci.dwFlags |= FLAG_APPLYNOW_CALLED;

        //
        // Check if there are still any unresolved constraints left?
        // BOptItemSelectionsChanged returns TRUE or FALSE depending on
        // whether the user has made any changes to the options
        //

        if (((pUiData->ci.dwFlags & FLAG_PLUGIN_CHANGED_OPTITEM) ||
             BOptItemSelectionsChanged(pUiData->pDrvOptItem, pUiData->dwDrvOptItem)) &&
            ICheckConstraintsDlg(pUiData,
                                 pUiData->pDrvOptItem,
                                 pUiData->dwDrvOptItem,
                                 TRUE) == CONFLICT_CANCEL)
        {
            //
            // Conflicts found and user clicked CANCEL to
            // go back to the dialog without dismissing it.
            //

            lRet = CPSUICB_ACTION_NO_APPLY_EXIT;
            break;
        }

        //
        // Transfer information from options array to public devmode fields
        //

        VOptionsToDevmodeFields(&pUiData->ci, FALSE);

        //
        // Separate the doc-sticky options from the combined array
        // and save it back to the private devmode aOptions array
        //

        SeparateOptionArray(
                pUiData->ci.pRawData,
                pUiData->ci.pCombinedOptions,
                PGetDevmodeOptionsArray(pUiData->ci.pdm),
                MAX_PRINTER_OPTIONS,
                MODE_DOCUMENT_STICKY);

        pCallbackParam->Result = CPSUI_OK;
        lRet = CPSUICB_ACTION_ITEMS_APPLIED ;
        break;
    }

    return LInvokeOemPluginCallbacks(pUiData, pCallbackParam, lRet);
}



BOOL
BPackItemFormName(
    IN OUT PUIDATA  pUiData
    )
/*++

Routine Description:

    Pack Paper size options.

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error.

--*/

{
    //
    // Extended push button for bringing up PostScript custom page size dialog
    //

    PFEATURE    pFeature;

    static EXTPUSH ExtPush =
    {
        sizeof(EXTPUSH),
        EPF_NO_DOT_DOT_DOT,
        (PWSTR) IDS_EDIT_CUSTOMSIZE,
        NULL,
        0,
        0,
    };

    if (!(pFeature = GET_PREDEFINED_FEATURE(pUiData->ci.pUIInfo, GID_PAGESIZE)) ||
        pFeature->Options.dwCount < MIN_OPTIONS_ALLOWED ||
        pFeature->dwFlags & FEATURE_FLAG_NOUI)
        return TRUE;

    if (pUiData->pOptItem)
    {
        DWORD       dwFormNames, dwIndex, dwSel, dwPageSizeIndex, dwOption;
        PWSTR       pFormNames;
        POPTPARAM   pOptParam;
        PUIINFO     pUIInfo = pUiData->ci.pUIInfo;
        PFEATURE    pPageSizeFeature;
        BOOL        bSupported;

        dwFormNames = pUiData->dwFormNames;
        pFormNames = pUiData->pFormNames;

        //
        // Figure out the currently selected paper size option index
        //

        dwSel = DwFindFormNameIndex(pUiData, pUiData->ci.pdm->dmFormName, &bSupported);

        //
        // If the form is not supported on the printer, it could be the case
        // where the printer doesn't support a form with the same name, but
        // the printer can still support the requested form using exact or
        // closest paper size match.
        //
        // See function VFixOptionsArrayWithDevmode() and ChangeOptionsViaID().
        //

        if (!bSupported &&
            (pPageSizeFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_PAGESIZE)))
        {
            WCHAR      awchBuf[CCHPAPERNAME];
            PPAGESIZE  pPageSize;

            //
            // If we can't find a name match in the first DwFindFormNameIndex call,
            // the option array should already have the correct option index value
            // parser has decided to use to support the form. So now we only need
            // to load the option's display name and search in the form name list
            // again to get the paper size UI list index.
            //

            dwPageSizeIndex = GET_INDEX_FROM_FEATURE(pUIInfo, pPageSizeFeature);

            dwOption = pUiData->ci.pCombinedOptions[dwPageSizeIndex].ubCurOptIndex;

            if ((pPageSize = (PPAGESIZE)PGetIndexedOption(pUIInfo, pPageSizeFeature, dwOption)) &&
                LOAD_STRING_PAGESIZE_NAME(&(pUiData->ci), pPageSize, awchBuf, CCHPAPERNAME))
            {
                dwSel = DwFindFormNameIndex(pUiData, awchBuf, NULL);
            }
        }

        //
        // Fill out OPTITEM, OPTTYPE, and OPTPARAM structures
        //

        FILLOPTITEM(pUiData->pOptItem,
                    pUiData->pOptType,
                    ULongToPtr(IDS_CPSUI_FORMNAME),
                    ULongToPtr(dwSel),
                    TVITEM_LEVEL1,
                    DMPUB_FORMNAME,
                    FORMNAME_ITEM,
                    HELP_INDEX_FORMNAME);

        pUiData->pOptType->Style = OTS_LBCB_SORT;

        pOptParam = PFillOutOptType(pUiData->pOptType,
                                    TVOT_LISTBOX,
                                    dwFormNames,
                                    pUiData->ci.hHeap);

        if (pOptParam == NULL)
            return FALSE;

        for (dwIndex=0; dwIndex < dwFormNames; dwIndex++)
        {
            pOptParam->cbSize = sizeof(OPTPARAM);
            pOptParam->pData = pFormNames;

            if (pUiData->pwPapers[dwIndex] == DMPAPER_CUSTOMSIZE)
                pOptParam->IconID = IDI_CUSTOM_PAGESIZE;
            else if (pOptParam->IconID = HLoadFormIconResource(pUiData, dwIndex))
                pOptParam->Flags |= OPTPF_ICONID_AS_HICON;
            else
                pOptParam->IconID = DwGuessFormIconID(pFormNames);

            pOptParam++;
            pFormNames += CCHPAPERNAME;
        }

        //
        // Special case for PostScript custom page size
        //

        #ifdef PSCRIPT

        {
            PPPDDATA pPpdData;

            pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER((PINFOHEADER) pUiData->ci.pRawData);

            ASSERT(pPpdData != NULL);

            if (SUPPORT_CUSTOMSIZE(pUIInfo) &&
                SUPPORT_FULL_CUSTOMSIZE_FEATURES(pUIInfo, pPpdData))
            {
                pUiData->pOptItem->Flags |= (OPTIF_EXT_IS_EXTPUSH|OPTIF_CALLBACK);
                pUiData->pOptItem->pExtPush = &ExtPush;

                //
                // If PostScript custom page size is selected,
                // select the last item of form name list.
                //

                if (pUiData->ci.pdm->dmPaperSize == DMPAPER_CUSTOMSIZE)
                {
                    pUiData->pOptItem->Sel = pUiData->dwFormNames - 1;
                    pUiData->pOptItem->Flags &= ~(OPTIF_EXT_HIDE | OPTIF_EXT_DISABLED);
                }
                else
                    pUiData->pOptItem->Flags |= (OPTIF_EXT_HIDE | OPTIF_EXT_DISABLED);
            }
        }

        #endif // PSCRIPT

        #ifdef UNIDRV

        //
        // Supports OEM help file. If helpfile and helpindex are defined,
        // we will use the help id specified by the GPD.  According to GPD spec,
        // zero loHelpFileName means no help file name specified.
        //

        if (pUIInfo->loHelpFileName &&
            pFeature->iHelpIndex != UNUSED_ITEM)
        {
            POIEXT pOIExt = HEAPALLOC(pUiData->ci.hHeap, sizeof(OIEXT));

            if (pOIExt)
            {
                pOIExt->cbSize = sizeof(OIEXT);
                pOIExt->Flags = 0;
                pOIExt->hInstCaller = NULL;
                pOIExt->pHelpFile = OFFSET_TO_POINTER(pUIInfo->pubResourceData,
                                                      pUIInfo->loHelpFileName);
                pUiData->pOptItem->pOIExt = pOIExt;
                pUiData->pOptItem->HelpIndex = pFeature->iHelpIndex;
                pUiData->pOptItem->Flags |= OPTIF_HAS_POIEXT;
            }
        }

        #endif // UNIDRV

        //
        // Set the Keyword name for pOptItem->UserData
        //

        SETUSERDATA_KEYWORDNAME(pUiData->ci, pUiData->pOptItem, pFeature);

        pUiData->pOptItem++;
        pUiData->pOptType++;
    }

    pUiData->dwOptItem++;
    pUiData->dwOptType++;
    return TRUE;
}



BOOL
BPackItemInputSlot(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack paper source option.

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error.

--*/

{
    POPTTYPE    pOptType;
    PFEATURE    pFeature;
    PINPUTSLOT  pInputSlot;

    pFeature = GET_PREDEFINED_FEATURE(pUiData->ci.pUIInfo, GID_INPUTSLOT);
    pOptType = pUiData->pOptType;

    if (! BPackItemPrinterFeature(
                pUiData,
                pFeature,
                TVITEM_LEVEL1,
                DMPUB_DEFSOURCE,
                (ULONG_PTR)INPUTSLOT_ITEM,
                HELP_INDEX_INPUT_SLOT))
    {
        return FALSE;
    }

    //
    // NOTE: if the first input slot has dwPaperSourceID == DMBIN_FORMSOURCE,
    // then we'll change its display name to "Automatically Select".
    //

    if (pOptType != NULL && pOptType != pUiData->pOptType)
    {
        ASSERT(pFeature != NULL);

        pInputSlot = PGetIndexedOption(pUiData->ci.pUIInfo, pFeature, 0);
        ASSERT(pInputSlot != NULL);

        if (pInputSlot->dwPaperSourceID == DMBIN_FORMSOURCE)
            pOptType->pOptParam[0].pData = (PWSTR) IDS_TRAY_FORMSOURCE;
    }

    return TRUE;
}


BOOL
BPackItemMediaType(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack media type option.

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error.

--*/

{
    return BPackItemPrinterFeature(
                pUiData,
                GET_PREDEFINED_FEATURE(pUiData->ci.pUIInfo, GID_MEDIATYPE),
                TVITEM_LEVEL1,
                DMPUB_MEDIATYPE,
                (ULONG_PTR)MEDIATYPE_ITEM,
                HELP_INDEX_MEDIA_TYPE);
}



static CONST WORD CopiesCollateItemInfo[] =
{
    IDS_CPSUI_COPIES, TVITEM_LEVEL1, DMPUB_COPIES_COLLATE,
    COPIES_COLLATE_ITEM, HELP_INDEX_COPIES_COLLATE,
    2, TVOT_UDARROW,
    0, IDI_CPSUI_COPY,
    0, MIN_COPIES,
    ITEM_INFO_SIGNATURE
};


BOOL
BPackItemCopiesCollate(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack copies and collate option.

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error.

--*/

{
    POPTITEM    pOptItem = pUiData->pOptItem;
    PEXTCHKBOX  pExtCheckbox;
    PFEATURE    pFeature;
    SHORT       sCopies, sMaxCopies;

    if ((pFeature = GET_PREDEFINED_FEATURE(pUiData->ci.pUIInfo, GID_COLLATE)) &&
        pFeature->dwFlags & FEATURE_FLAG_NOUI)
        return TRUE;

    if (pUiData->bEMFSpooling)
    {
        sCopies = pUiData->ci.pdm->dmCopies;
        sMaxCopies =  max(MAX_COPIES, (SHORT)pUiData->ci.pUIInfo->dwMaxCopies);
    }
    else
    {
        sCopies = pUiData->ci.pdm->dmCopies > (SHORT)pUiData->ci.pUIInfo->dwMaxCopies ?
                  (SHORT)pUiData->ci.pUIInfo->dwMaxCopies : pUiData->ci.pdm->dmCopies;
        sMaxCopies = (SHORT)pUiData->ci.pUIInfo->dwMaxCopies;

    }
    if (! BPackUDArrowItemTemplate(
                pUiData,
                CopiesCollateItemInfo,
                sCopies,
                sMaxCopies,
                pFeature))
    {
        return FALSE;
    }

    if (pOptItem && DRIVER_SUPPORTS_COLLATE(((PCOMMONINFO)&pUiData->ci)))
    {
        pExtCheckbox = HEAPALLOC(pUiData->ci.hHeap, sizeof(EXTCHKBOX));

        if (pExtCheckbox == NULL)
        {
            ERR(("Memory allocation failed\n"));
            return FALSE;
        }

        pExtCheckbox->cbSize = sizeof(EXTCHKBOX);
        pExtCheckbox->pTitle = (PWSTR) IDS_CPSUI_COLLATE;
        pExtCheckbox->pCheckedName = (PWSTR) IDS_CPSUI_COLLATED;
        pExtCheckbox->IconID = IDI_CPSUI_COLLATE;
        pExtCheckbox->Flags = ECBF_CHECKNAME_ONLY_ENABLED;
        pExtCheckbox->pSeparator = (PWSTR)IDS_CPSUI_SLASH_SEP;

        pOptItem->pExtChkBox = pExtCheckbox;

        if ((pUiData->ci.pdm->dmFields & DM_COLLATE) &&
            (pUiData->ci.pdm->dmCollate == DMCOLLATE_TRUE))
        {
            pOptItem->Flags |= OPTIF_ECB_CHECKED;
        }
    }

    return TRUE;
}



BOOL
BPackItemResolution(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack resolution option.

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error.

--*/

{
    return BPackItemPrinterFeature(
                pUiData,
                GET_PREDEFINED_FEATURE(pUiData->ci.pUIInfo, GID_RESOLUTION),
                TVITEM_LEVEL1,
                DMPUB_PRINTQUALITY,
                (ULONG_PTR)RESOLUTION_ITEM,
                HELP_INDEX_RESOLUTION);
}



static CONST WORD ColorItemInfo[] =
{
    IDS_CPSUI_COLOR, TVITEM_LEVEL1, DMPUB_COLOR,
    COLOR_ITEM, HELP_INDEX_COLOR,
    2, TVOT_2STATES,
    IDS_CPSUI_MONOCHROME, IDI_CPSUI_MONO,
    IDS_CPSUI_COLOR, IDI_CPSUI_COLOR,
    ITEM_INFO_SIGNATURE
};

//
// ICM stuff is not available on NT4
//

#ifndef WINNT_40

static CONST WORD ICMMethodItemInfo[] =
{
    IDS_ICMMETHOD, TVITEM_LEVEL1,

    #ifdef WINNT_40
    DMPUB_NONE,
    #else
    DMPUB_ICMMETHOD,
    #endif

    ICMMETHOD_ITEM, HELP_INDEX_ICMMETHOD,
    #ifdef PSCRIPT
    4, TVOT_LISTBOX,
    #else
    3, TVOT_LISTBOX,
    #endif
    IDS_ICMMETHOD_NONE, IDI_ICMMETHOD_NONE,
    IDS_ICMMETHOD_SYSTEM, IDI_ICMMETHOD_SYSTEM,
    IDS_ICMMETHOD_DRIVER, IDI_ICMMETHOD_DRIVER,
    #ifdef PSCRIPT
    IDS_ICMMETHOD_DEVICE, IDI_ICMMETHOD_DEVICE,
    #endif
    ITEM_INFO_SIGNATURE
};

static CONST WORD ICMIntentItemInfo[] =
{
    IDS_ICMINTENT, TVITEM_LEVEL1,

    #ifdef WINNT_40
    DMPUB_NONE,
    #else
    DMPUB_ICMINTENT,
    #endif

    ICMINTENT_ITEM, HELP_INDEX_ICMINTENT,
    4, TVOT_LISTBOX,
    IDS_ICMINTENT_SATURATE, IDI_ICMINTENT_SATURATE,
    IDS_ICMINTENT_CONTRAST, IDI_ICMINTENT_CONTRAST,
    IDS_ICMINTENT_COLORIMETRIC, IDI_ICMINTENT_COLORIMETRIC,
    IDS_ICMINTENT_ABS_COLORIMETRIC, IDI_ICMINTENT_ABS_COLORIMETRIC,
    ITEM_INFO_SIGNATURE
};

#endif // !WINNT_40


BOOL
BPackItemColor(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack color mode option.

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error.

--*/

{
    PDEVMODE    pdm;
    INT         dwColorSel, dwICMMethodSel, dwICMIntentSel;

    //
    // For Adobe driver, they want to preserve the color information
    // even for b/w printers. So we always give user this choice.
    //

    #ifndef ADOBE

    if (! IS_COLOR_DEVICE(pUiData->ci.pUIInfo))
        return TRUE;

    #endif  // !ADOBE

    //
    // DCR - Some ICM methods and intents may need to be disabled
    // on some non-PostScript printers.
    //

    pdm = pUiData->ci.pdm;
    dwColorSel = dwICMMethodSel = dwICMIntentSel = 0;

    if ((pdm->dmFields & DM_COLOR) && (pdm->dmColor == DMCOLOR_COLOR))
        dwColorSel = 1;

    if (! BPackOptItemTemplate(pUiData, ColorItemInfo, dwColorSel, NULL))
        return FALSE;

    //
    // ICM stuff is not available on NT4
    //

    #ifndef WINNT_40

    if (pdm->dmFields & DM_ICMMETHOD)
    {
        switch (pdm->dmICMMethod)
        {
        case DMICMMETHOD_SYSTEM:
            dwICMMethodSel = 1;
            break;

        case DMICMMETHOD_DRIVER:
            dwICMMethodSel = 2;
            break;

        #ifdef PSCRIPT
        case DMICMMETHOD_DEVICE:
            dwICMMethodSel = 3;
            break;
        #endif

        case DMICMMETHOD_NONE:
        default:
            dwICMMethodSel = 0;
            break;
        }
    }

    if (pdm->dmFields & DM_ICMINTENT)
    {
        switch (pdm->dmICMIntent)
        {
        case DMICM_COLORIMETRIC:
            dwICMIntentSel = 2;
            break;

        case DMICM_ABS_COLORIMETRIC:
            dwICMIntentSel = 3;
            break;

        case DMICM_SATURATE:
            dwICMIntentSel = 0;
            break;

        case DMICM_CONTRAST:
        default:
            dwICMIntentSel = 1;
            break;


        }
    }

    if (! BPackOptItemTemplate(pUiData, ICMMethodItemInfo, dwICMMethodSel, NULL) ||
        ! BPackOptItemTemplate(pUiData, ICMIntentItemInfo, dwICMIntentSel, NULL))
    {
        return FALSE;
    }

    #endif // !WINNT_40

    return TRUE;
}



BOOL
BPackItemDuplex(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack duplexing option.

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error.

--*/

{
    POPTITEM    pOptItem = pUiData->pOptItem;
    PCOMMONINFO pci      = &pUiData->ci;
    PFEATURE    pFeature = GET_PREDEFINED_FEATURE(pUiData->ci.pUIInfo, GID_DUPLEX);
    BOOL        bRet;


    //
    // Don't display the duplex feature if duplex is constrained by an
    // installable feature such as duplex unit not installed
    //


    if (!SUPPORTS_DUPLEX(pci) ||
        (pFeature && pFeature->Options.dwCount < MIN_OPTIONS_ALLOWED))
        return TRUE;

    bRet = BPackItemPrinterFeature(
                pUiData,
                pFeature,
                TVITEM_LEVEL1,
                DMPUB_DUPLEX,
                (ULONG_PTR)DUPLEX_ITEM,
                HELP_INDEX_DUPLEX);

    #ifdef WINNT_40

    //
    // Use standard names for duplex options. Otherwise, the duplex option
    // names from the PPD/GPD file may be too long to fit into the space
    // on the friendly (Page Setup) tab.
    //
    // On NT5, this kluge is inside compstui.
    //

    if (bRet && pFeature && pOptItem)
    {
        DWORD   dwIndex;
        INT     StrRsrcId;
        PDUPLEX pDuplex;

        for (dwIndex=0; dwIndex < pOptItem->pOptType->Count; dwIndex++)
        {
            pDuplex = (PDUPLEX) PGetIndexedOption(pUiData->ci.pUIInfo, pFeature, dwIndex);
            ASSERT(pDuplex != NULL);

            switch (pDuplex->dwDuplexID)
            {
            case DMDUP_HORIZONTAL:
                StrRsrcId = IDS_CPSUI_SHORT_SIDE;
                break;

            case DMDUP_VERTICAL:
                StrRsrcId = IDS_CPSUI_LONG_SIDE;
                break;

            default:
                StrRsrcId = IDS_CPSUI_NONE;
                break;
            }

            pOptItem->pOptType->pOptParam[dwIndex].pData = (PWSTR) StrRsrcId;
        }
    }

    #endif // WINNT_40

    return bRet;
}



static CONST WORD TTOptionItemInfo[] =
{
    IDS_CPSUI_TTOPTION, TVITEM_LEVEL1, DMPUB_TTOPTION,
    TTOPTION_ITEM, HELP_INDEX_TTOPTION,
    2, TVOT_2STATES,
    IDS_CPSUI_TT_SUBDEV, IDI_CPSUI_TT_SUBDEV,
    IDS_CPSUI_TT_DOWNLOADSOFT, IDI_CPSUI_TT_DOWNLOADSOFT,
    ITEM_INFO_SIGNATURE
};


BOOL
BPackItemTTOptions(
    IN OUT PUIDATA  pUiData
    )
/*++

Routine Description:

    Pack TT options

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error.

--*/

{
    DWORD dwSel;


    //
    // If device fonts have been disabled or doesn't support
    // font substitution , then don't
    // show font substitution option
    //

    if (pUiData->ci.pPrinterData->dwFlags & PFLAGS_IGNORE_DEVFONT ||
        pUiData->ci.pUIInfo->dwFontSubCount == 0 )
    {
        pUiData->ci.pdm->dmTTOption = DMTT_DOWNLOAD;
        return TRUE;
    }

    dwSel = (pUiData->ci.pdm->dmTTOption == DMTT_SUBDEV) ? 0 : 1;
    return BPackOptItemTemplate(pUiData, TTOptionItemInfo, dwSel, NULL);
}



static CONST WORD ItemInfoMFSpool[] =
{
    IDS_METAFILE_SPOOLING, TVITEM_LEVEL1, DMPUB_NONE,
    METASPOOL_ITEM, HELP_INDEX_METAFILE_SPOOLING,
    2, TVOT_2STATES,
    IDS_ENABLED, IDI_CPSUI_ON,
    IDS_DISABLED, IDI_CPSUI_OFF,
    ITEM_INFO_SIGNATURE
};

static CONST WORD ItemInfoNupOption[] =
{
    IDS_NUPOPTION, TVITEM_LEVEL1, NUP_DMPUB,
    NUP_ITEM, HELP_INDEX_NUPOPTION,
    7, TVOT_LISTBOX,
    IDS_ONE_UP, IDI_ONE_UP,
    IDS_TWO_UP, IDI_TWO_UP,
    IDS_FOUR_UP, IDI_FOUR_UP,
    IDS_SIX_UP, IDI_SIX_UP,
    IDS_NINE_UP, IDI_NINE_UP,
    IDS_SIXTEEN_UP, IDI_SIXTEEN_UP,
    IDS_BOOKLET , IDI_BOOKLET,
    ITEM_INFO_SIGNATURE
};

static CONST WORD ItemInfoRevPrint[] =
{
    IDS_PAGEORDER, TVITEM_LEVEL1, PAGEORDER_DMPUB,
    REVPRINT_ITEM, HELP_INDEX_REVPRINT,
    2, TVOT_2STATES,
    IDS_PAGEORDER_NORMAL,  IDI_PAGEORDER_NORMAL,
    IDS_PAGEORDER_REVERSE, IDI_PAGEORDER_REVERSE,
    ITEM_INFO_SIGNATURE
};

BOOL
BPackItemEmfFeatures(
    PUIDATA pUiData
    )

/*++

Routine Description:

    Pack EMF related feature items:
        EMF spooling on/off
        N-up
        reverse-order printing

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error.

--*/

{
    PDRIVEREXTRA    pdmExtra = pUiData->ci.pdmPrivate;
    BOOL            bNupOption, bReversePrint;
    PCOMMONINFO     pci = &pUiData->ci;
    DWORD           dwSel;
    POPTITEM        pOptItem;

    //
    // Check if the spooler can do N-up and reverse-order printing
    // for the current printer
    //

    VGetSpoolerEmfCaps(pci->hPrinter, &bNupOption, &bReversePrint, 0, NULL);

    //
    // On Win2K and above, don't show the EMF spooling option in driver UI
    // if spooler cannot do EMF.
    // pUiData->bEMFSpooling is initialized at PFillUidata
    // 1. Determine if Reverse Print is possible
    // 2. Spooler can do EMF.
    //
    // On NT4, since spooler doesn't support the EMF capability query, we
    // have to keep the old NT4 driver behavior of always showing the EMF
    // spooling option in driver UI.
    //

    #ifndef WINNT_40
    if (pUiData->bEMFSpooling)
    {
    #endif

        dwSel = ISSET_MFSPOOL_FLAG(pdmExtra) ? 0 : 1;

        if (!BPackOptItemTemplate(pUiData, ItemInfoMFSpool, dwSel, NULL))
            return FALSE;

    #ifndef WINNT_40
    }
    #endif

    #ifdef PSCRIPT
        bNupOption = TRUE;
    #endif

    //
    // Pack N-up option item if necessary
    //

    if (bNupOption)
    {
        switch (NUPOPTION(pdmExtra))
        {
        case TWO_UP:
            dwSel = 1;
            break;

        case FOUR_UP:
            dwSel = 2;
            break;

        case SIX_UP:
            dwSel = 3;
            break;

        case NINE_UP:
            dwSel = 4;
            break;

        case SIXTEEN_UP:
            dwSel = 5;
            break;

        case BOOKLET_UP:
            dwSel = 6;
            break;

        case ONE_UP:
        default:
            dwSel = 0;
            break;
        }

        pOptItem = pUiData->pOptItem;

        if (!BPackOptItemTemplate(pUiData, ItemInfoNupOption, dwSel, NULL))
            return FALSE;


        //
        // Hide booklet option if duplex is constrained by an
        // installable feature such as duplex unit not installed or EMF is not
        // available.
        //

        if ( pOptItem &&
             (!pUiData->bEMFSpooling || !SUPPORTS_DUPLEX(pci)))
        {
            pOptItem->pOptType->pOptParam[BOOKLET_UP].Flags |= OPTPF_HIDE;

            if (NUPOPTION(pdmExtra) == BOOKLET_UP)
                pOptItem->Sel = 1;
        }
    }
    else
    {
        NUPOPTION(pdmExtra) = ONE_UP;
    }

    //
    // Pack Reverse-order printing option item if necessary
    //

    if (bReversePrint)
    {
        dwSel = REVPRINTOPTION(pdmExtra) ? 1 : 0;

        if (!BPackOptItemTemplate(pUiData, ItemInfoRevPrint, dwSel, NULL))
            return FALSE;
    }
    else
    {
        REVPRINTOPTION(pdmExtra) = FALSE;
    }

    if (pUiData->bEMFSpooling && pUiData->pOptItem)
        VUpdateEmfFeatureItems(pUiData, FALSE);

    return TRUE;
}



BOOL
BPackDocumentPropertyItems(
    IN  OUT PUIDATA pUiData
    )

/*++

Routine Description:

    Pack document property information into treeview items.

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error.

--*/
{
    return BPackItemFormName(pUiData)       &&
           BPackItemInputSlot(pUiData)      &&
           _BPackOrientationItem(pUiData)   &&
           BPackItemCopiesCollate(pUiData)  &&
           BPackItemResolution(pUiData)     &&
           BPackItemColor(pUiData)          &&
           _BPackItemScale(pUiData)         &&
           BPackItemDuplex(pUiData)         &&
           BPackItemMediaType(pUiData)      &&
           BPackItemTTOptions(pUiData)      &&
           BPackItemEmfFeatures(pUiData)    &&
           _BPackDocumentOptions(pUiData)   &&
           BPackItemGenericOptions(pUiData) &&
           BPackOemPluginItems(pUiData);
}



VOID
VUnpackDocumentPropertiesItems(
    PUIDATA     pUiData,
    POPTITEM    pOptItem,
    DWORD       dwOptItem
    )

/*++

Routine Description:

    Extract devmode information from an OPTITEM
    Stored it back into devmode.

Arguments:

    pUiData - Pointer to our UIDATA structure
    pOptItem - Pointer to an array of OPTITEMs
    dwOptItem - Number of OPTITEMs

Return Value:

    Printer feature index corresponding to the last item unpacked

--*/

{
    PUIINFO         pUIInfo = pUiData->ci.pUIInfo;
    PDEVMODE        pdm = pUiData->ci.pdm;
    PDRIVEREXTRA    pdmExtra = pUiData->ci.pdmPrivate;

    for ( ; dwOptItem > 0; dwOptItem--, pOptItem++)
    {
        //
        // Header items always have pOptType == NULL, see
        // VPackOptItemGroupHeader
        //

        if (pOptItem->pOptType == NULL)
            continue;

        //
        // To fix bug #90923, we should only allow hidden items to be processed when we are within
        // the UI helper function call BUpdateUISettingForOEM issued by OEM plguin.
        //
        // We don't do this for other cases because there are already UI plugins that hide our
        // standard items and show their own. For example, CNBJUI.DLL hides our ICMMETHOD_ITEM
        // and ICMINTENT_ITEM. It uses its own as replacement items. If we change the behavior here,
        // we could break those plugins when we process the hidden items and overwrite the devmode
        // plugin has already set based on user selection of their replacement items.
        //

        if (!(pUiData->ci.dwFlags & FLAG_WITHIN_PLUGINCALL) && (pOptItem->Flags & OPTIF_HIDE))
            continue;

        if (ISPRINTERFEATUREITEM(pOptItem->UserData))
        {
            //
            // Generic document-sticky printer features
            //

            VUpdateOptionsArrayWithSelection(pUiData, pOptItem);
        }
        else
        {
            //
            // Common items in public devmode
            //

            switch (GETUSERDATAITEM(pOptItem->UserData))
            {
            case ORIENTATION_ITEM:

                //
                // Orientation is a special case:
                //  for pscript, it's handled via _VUnpackDocumentOptions
                //  for unidrv, it's handled as a generic feature
                //

                #ifdef PSCRIPT

                break;

                #endif

            case DUPLEX_ITEM:
                VUpdateOptionsArrayWithSelection(pUiData, pOptItem);
                VUpdateBookletOption(pUiData, pOptItem);
                break;


            case RESOLUTION_ITEM:
            case INPUTSLOT_ITEM:
            case MEDIATYPE_ITEM:
            case COLORMODE_ITEM:
            case HALFTONING_ITEM:

                VUpdateOptionsArrayWithSelection(pUiData, pOptItem);
                break;

            case SCALE_ITEM:

                pdm->dmScale = (SHORT) pOptItem->Sel;
                break;

            case COPIES_COLLATE_ITEM:

                pdm->dmCopies = (SHORT) pOptItem->Sel;

                if (pOptItem->pExtChkBox)
                {
                    pdm->dmFields |= DM_COLLATE;
                    pdm->dmCollate = (pOptItem->Flags & OPTIF_ECB_CHECKED) ?
                                        DMCOLLATE_TRUE :
                                        DMCOLLATE_FALSE;

                    //
                    // Update Collate feature option index
                    //

                    ChangeOptionsViaID(
                           pUiData->ci.pInfoHeader,
                           pUiData->ci.pCombinedOptions,
                           GID_COLLATE,
                           pdm);
                }
                break;

            case COLOR_ITEM:

                pdm->dmFields |= DM_COLOR;
                pdm->dmColor = (pOptItem->Sel == 1) ?
                                    DMCOLOR_COLOR :
                                    DMCOLOR_MONOCHROME;
                break;

            case METASPOOL_ITEM:

                if (pOptItem->Sel == 0)
                {
                    SET_MFSPOOL_FLAG(pdmExtra);
                }
                else
                {
                    CLEAR_MFSPOOL_FLAG(pdmExtra);
                }
                break;

            case NUP_ITEM:

                switch (pOptItem->Sel)
                {
                case 1:
                    NUPOPTION(pdmExtra) = TWO_UP;
                    break;

                case 2:
                    NUPOPTION(pdmExtra) = FOUR_UP;
                    break;

                case 3:
                    NUPOPTION(pdmExtra) = SIX_UP;
                    break;

                case 4:
                    NUPOPTION(pdmExtra) = NINE_UP;
                    break;

                case 5:
                    NUPOPTION(pdmExtra) = SIXTEEN_UP;
                    break;

                case 6:
                    NUPOPTION(pdmExtra) = BOOKLET_UP;
                    VUpdateBookletOption(pUiData, pOptItem);
                    break;

                case 0:
                default:
                    NUPOPTION(pdmExtra) = ONE_UP;
                    break;
                }
                break;

            case REVPRINT_ITEM:

                REVPRINTOPTION(pdmExtra) = (pOptItem->Sel != 0);
                break;

            //
            // ICM stuff is not available on NT4
            //

            #ifndef WINNT_40

            case ICMMETHOD_ITEM:

                pdm->dmFields |= DM_ICMMETHOD;

                switch (pOptItem->Sel)
                {
                case 0:
                    pdm->dmICMMethod = DMICMMETHOD_NONE;
                    break;

                case 1:
                    pdm->dmICMMethod = DMICMMETHOD_SYSTEM;
                    break;

                case 2:
                    pdm->dmICMMethod = DMICMMETHOD_DRIVER;
                    break;

                #ifdef PSCRIPT
                case 3:
                    pdm->dmICMMethod = DMICMMETHOD_DEVICE;
                    break;
                #endif
                }
                break;

            case ICMINTENT_ITEM:

                pdm->dmFields |= DM_ICMINTENT;

                switch (pOptItem->Sel)
                {
                case 0:
                    pdm->dmICMIntent = DMICM_SATURATE;
                    break;

                case 1:
                    pdm->dmICMIntent = DMICM_CONTRAST;
                    break;

                case 2:
                    pdm->dmICMIntent = DMICM_COLORIMETRIC;
                    break;

                case 3:
                    pdm->dmICMIntent = DMICM_ABS_COLORIMETRIC;
                    break;
                }
                break;

            #endif // !WINNT_40

            case TTOPTION_ITEM:

                pdm->dmFields |= DM_TTOPTION;

                if (pOptItem->Sel == 0)
                    pdm->dmTTOption = DMTT_SUBDEV;
                else
                    pdm->dmTTOption = DMTT_DOWNLOAD;
                break;

            case FORMNAME_ITEM:

                pdm->dmFields &= ~(DM_PAPERLENGTH|DM_PAPERWIDTH);
                pdm->dmFields |= DM_PAPERSIZE;
                pdm->dmPaperSize = pUiData->pwPapers[pOptItem->Sel];

                if (pdm->dmPaperSize == DMPAPER_CUSTOMSIZE)
                    pdm->dmFields &= ~DM_FORMNAME;
                else
                    pdm->dmFields |= DM_FORMNAME;

                CopyString(pdm->dmFormName,
                           pOptItem->pOptType->pOptParam[pOptItem->Sel].pData,
                           CCHFORMNAME);

                //
                // Update PageSize feature option index
                //

                {
                    INT dwIndex;

                    if (PGetFeatureFromItem(pUiData->ci.pUIInfo, pOptItem, &dwIndex))
                    {
                        pUiData->ci.pCombinedOptions[dwIndex].ubCurOptIndex =
                            (BYTE) pUiData->pwPaperFeatures[pOptItem->Sel];
                    }
                }

                break;
            }

            //
            // Give drivers a chance to process their private items
            //

            _VUnpackDocumentOptions(pOptItem, pdm);
        }
    }
}



VOID
VUpdateEmfFeatureItems(
    PUIDATA pUiData,
    BOOL    bUpdateMFSpoolItem
    )

/*++

Routine Description:

    Handle the inter-dependency between EMF spooling, N-up, and
    reverse-printing items.

Arguments:

    pUiData - Points to UIDATA structure
    bUpdateMFSpoolItem - Whether to update EMF spooling or the other two items

Return Value:

    NONE

--*/

{
    POPTITEM        pMFSpoolItem, pNupItem, pRevPrintItem, pCopiesCollateItem;

    pMFSpoolItem = PFindOptItemWithUserData(pUiData, METASPOOL_ITEM);
    pNupItem = PFindOptItemWithUserData(pUiData, NUP_ITEM);
    pRevPrintItem = PFindOptItemWithUserData(pUiData, REVPRINT_ITEM);
    pCopiesCollateItem = PFindOptItemWithUserData(pUiData, COPIES_COLLATE_ITEM);

    if (pMFSpoolItem == NULL)
        return;

    if (bUpdateMFSpoolItem)
    {

        //
        // Force EMF spooling to be on if:
        //  N-up option is not ONE_UP (Unidrv only), or
        //  reverse-order printing is enabled or
        //  collate is not supported by the device or
        //  copies count is > than max count support by device
        //

        #ifdef UNIDRV

        if (pNupItem && pNupItem->Sel != 0)
            pMFSpoolItem->Sel = 0;

        #endif // UNIDRV

        if (pNupItem && pNupItem->Sel == BOOKLET_UP)
            pMFSpoolItem->Sel = 0;

        if (pRevPrintItem)
        {
            //
            // Turn on EMF if the user selects "Normal" and
            // the bin is "Reversed" OR user selects "Reversed"
            // and the bin is "Normal"
            //

            BOOL    bReversed = BGetPageOrderFlag(&pUiData->ci);
            if ( pRevPrintItem->Sel == 0 && bReversed ||
                 pRevPrintItem->Sel != 0 && !bReversed )
                pMFSpoolItem->Sel = 0;
        }

        if (pCopiesCollateItem)
        {
            if (((pCopiesCollateItem->Flags & OPTIF_ECB_CHECKED) &&
                 !PRINTER_SUPPORTS_COLLATE(((PCOMMONINFO)&pUiData->ci))) ||
                (pCopiesCollateItem->Sel > (LONG)pUiData->ci.pUIInfo->dwMaxCopies))
            {
                pMFSpoolItem->Sel = 0;
            }
        }

        pMFSpoolItem->Flags |= OPTIF_CHANGED;
        VUnpackDocumentPropertiesItems(pUiData, pMFSpoolItem, 1);
    }
    else
    {
        //
        // If EMF spooling is turned off, force:
        //  N-up option to be ONE_UP (Unidrv only), and
        //  collate to be off if the device doesn't support collation
        //  copies set to the max count handle by the device
        //

        if (pMFSpoolItem->Sel != 0)
        {
            #ifdef UNIDRV
            if (pNupItem)
            {
                pNupItem->Sel = 0;
                pNupItem->Flags |= OPTIF_CHANGED;
                VUnpackDocumentPropertiesItems(pUiData, pNupItem, 1);
            }
            #endif // UNIDRV

            if (pNupItem && pNupItem->Sel == BOOKLET_UP)
            {
                pNupItem->Sel = 0;
                pNupItem->Flags |= OPTIF_CHANGED;
                VUnpackDocumentPropertiesItems(pUiData, pNupItem, 1);
            }


            if (pCopiesCollateItem)
            {
                if ((pCopiesCollateItem->Flags & OPTIF_ECB_CHECKED) &&
                    !PRINTER_SUPPORTS_COLLATE(((PCOMMONINFO)&pUiData->ci)))
                {
                    pCopiesCollateItem->Flags &=~OPTIF_ECB_CHECKED;
                }

                if (pCopiesCollateItem->Sel > (LONG)pUiData->ci.pUIInfo->dwMaxCopies)
                    pCopiesCollateItem->Sel = (LONG)pUiData->ci.pUIInfo->dwMaxCopies;

                pCopiesCollateItem->Flags |= OPTIF_CHANGED;
                VUnpackDocumentPropertiesItems(pUiData, pCopiesCollateItem, 1);

            }

            //
            // EMF is OFF. Need to make the "Page Order" option consistent
            // with the current output bin. If bin is "Reversed" and user selects
            // "Normal", change it to "Reverse". If bin is "Normal" and user selects
            // "Reverse", change it to "Normal"
            //

            if (pRevPrintItem)
            {
                BOOL    bReversed = BGetPageOrderFlag(&pUiData->ci);
                if (pRevPrintItem->Sel == 0 && bReversed )
                    pRevPrintItem->Sel = 1;
                else if ( pRevPrintItem->Sel != 0 && !bReversed )
                    pRevPrintItem->Sel = 0;

                pRevPrintItem->Flags |= OPTIF_CHANGED;
                VUnpackDocumentPropertiesItems(pUiData, pRevPrintItem, 1);
            }
        }
    }
}


BOOL
BGetPageOrderFlag(
    PCOMMONINFO pci
    )

/*++

Routine Description:

    Get the page order flag for the specified output bin

Arguments:

    pci - Pointer to PCOMMONINFO

Return Value:

    TRUE if output bin is reverse. otherwise, FALSE

--*/

{
    PUIINFO    pUIInfo = pci->pUIInfo;
    PFEATURE   pFeature;
    POUTPUTBIN pOutputBin;
    DWORD      dwFeatureIndex, dwOptionIndex;
    BOOL       bRet = FALSE;

    #ifdef PSCRIPT

    {
        PPPDDATA   pPpdData;
        POPTION    pOption;
        PCSTR      pstrKeywordName;

        //
        // For PostScript driver, PPD could have "*OpenUI *OutputOrder", which enables user to
        // select "Normal" or "Reverse" output order. This should have higher priority than
        // current output bin's output order or what *DefaultOutputOrder specifies.
        //

        pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER((PINFOHEADER) pci->pRawData);

        ASSERT(pPpdData != NULL);

        if (pPpdData->dwOutputOrderIndex != INVALID_FEATURE_INDEX)
        {
            //
            // "OutputOrder" feature is available. Check it's current option selection.
            //

            pFeature = PGetIndexedFeature(pUIInfo, pPpdData->dwOutputOrderIndex);

            ASSERT(pFeature != NULL);

            dwOptionIndex = pci->pCombinedOptions[pPpdData->dwOutputOrderIndex].ubCurOptIndex;

            if ((pOption = PGetIndexedOption(pUIInfo, pFeature, dwOptionIndex)) &&
                (pstrKeywordName = OFFSET_TO_POINTER(pUIInfo->pubResourceData, pOption->loKeywordName)))
            {
                //
                // Valid *OutputOrder option keywords are "Reverse" or "Normal".
                //

                if (strcmp(pstrKeywordName, "Reverse") == EQUAL_STRING)
                    return TRUE;
                else if (strcmp(pstrKeywordName, "Normal") == EQUAL_STRING)
                    return FALSE;
            }

            //
            // If we are here, the PPD must have wrong information in *OpenUI *OutputOrder.
            // We just ignore "OutputOrder" feature and continue.
            //
        }
    }

    #endif // PSCRIPT

    //
    // If the output bin order is NORMAL or there is no output bin
    // feature defined, then the page order is the user's selection.
    //

    if ((pFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_OUTPUTBIN)))
    {
        dwFeatureIndex = GET_INDEX_FROM_FEATURE(pUIInfo, pFeature);
        dwOptionIndex = pci->pCombinedOptions[dwFeatureIndex].ubCurOptIndex;
        pOutputBin = (POUTPUTBIN)PGetIndexedOption(pUIInfo,
                                                   pFeature,
                                                   dwOptionIndex);

        if (pOutputBin &&
            pOutputBin->bOutputOrderReversed)
        {

            if (NOT_UNUSED_ITEM(pOutputBin->bOutputOrderReversed))
                bRet = TRUE;
            else
                bRet = pUIInfo->dwFlags & FLAG_REVERSE_PRINT;
        }
    }
    else if (pUIInfo->dwFlags & FLAG_REVERSE_PRINT)
       bRet = TRUE;

    return bRet;

}

DWORD
DwGetDrvCopies(
    PCOMMONINFO pci
    )

/*++

Routine Description:

    Get the printer copy count capability.  Also take into account the
    collating option.

Arguments:

    pci - Pointer to PCOMMONINFO

Return Value:

    The number of copies the printer can do, with collating taken into consideration


--*/

{
    DWORD dwRet;

    if ((pci->pdm->dmFields & DM_COLLATE) &&
        pci->pdm->dmCollate == DMCOLLATE_TRUE &&
        !PRINTER_SUPPORTS_COLLATE(pci))
        dwRet = 1;
    else
        dwRet = min(pci->pUIInfo->dwMaxCopies, (DWORD)pci->pdm->dmCopies);

    return dwRet;

}


BOOL
DrvQueryJobAttributes(
    HANDLE      hPrinter,
    PDEVMODE    pDevMode,
    DWORD       dwLevel,
    LPBYTE      lpAttributeInfo
    )

/*++

Routine Description:

    Negotiate EMF printing features (such as N-up and reverse-order printing)
    with the spooler

Arguments:

    hPrinter - Handle to the current printer
    pDevMode - Pointer to input devmode
    dwLevel - Specifies the structure level for lpAttributeInfo
    lpAttributeInfo - Output buffer for returning EMF printing features

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    #if !defined(WINNT_40)

    PCOMMONINFO         pci;
    PATTRIBUTE_INFO_1   pAttrInfo1;
    DWORD               dwVal;
    BOOL                bAppDoNup, bResult = FALSE;

    //
    // We can only handle AttributeInfo level 1
    //

    if ( dwLevel != 1 && dwLevel != 2  && dwLevel != 3)
    {
        ERR(("Invalid level for DrvQueryJobAttributes: %d\n", dwLevel));
        SetLastError(ERROR_INVALID_PARAMETER);
        return bResult;
    }

    //
    // Load basic printer information
    //

    if (! (pci = PLoadCommonInfo(hPrinter, NULL, 0)) ||
        ! BFillCommonInfoPrinterData(pci)  ||
        ! BFillCommonInfoDevmode(pci, NULL, pDevMode) ||
        ! BCombineCommonInfoOptionsArray(pci))
    {
        VFreeCommonInfo(pci);
        return bResult;
    }

    VFixOptionsArrayWithDevmode(pci);

    (VOID) ResolveUIConflicts(pci->pRawData,
                              pci->pCombinedOptions,
                              MAX_COMBINED_OPTIONS,
                              MODE_DOCUMENT_STICKY);

    VOptionsToDevmodeFields(pci, TRUE);

    if (! BUpdateUIInfo(pci))
    {
        VFreeCommonInfo(pci);
        return bResult;
    }

    pAttrInfo1 = (PATTRIBUTE_INFO_1) lpAttributeInfo;

    bAppDoNup = ( (pci->pdm->dmFields & DM_NUP) &&
                  (pci->pdm->dmNup == DMNUP_ONEUP) );

    if (bAppDoNup)
    {
        dwVal = 1;
    }
    else
    {
        switch (NUPOPTION(pci->pdmPrivate))
        {
        case TWO_UP:
            dwVal = 2;
            break;

        case FOUR_UP:
            dwVal = 4;
            break;

        case SIX_UP:
            dwVal = 6;
            break;

        case NINE_UP:
            dwVal = 9;
            break;

        case SIXTEEN_UP:
            dwVal = 16;
            break;

        case BOOKLET_UP:
            dwVal = 2;
            break;

        case ONE_UP:
        default:
            dwVal = 1;
            break;
        }
    }
    pAttrInfo1->dwDrvNumberOfPagesPerSide = pAttrInfo1->dwJobNumberOfPagesPerSide = dwVal;
    pAttrInfo1->dwNupBorderFlags = BORDER_PRINT;

    pAttrInfo1->dwJobPageOrderFlags =
        REVPRINTOPTION(pci->pdmPrivate) ? REVERSE_PRINT : NORMAL_PRINT;
    pAttrInfo1->dwDrvPageOrderFlags = BGetPageOrderFlag(pci) ? REVERSE_PRINT : NORMAL_PRINT;

    //
    // Check for booklet
    //

    if ((NUPOPTION(pci->pdmPrivate) == BOOKLET_UP) && !bAppDoNup)
    {
        pAttrInfo1->dwJobNumberOfPagesPerSide = 2;
        pAttrInfo1->dwDrvNumberOfPagesPerSide = 1;
        pAttrInfo1->dwDrvPageOrderFlags |= BOOKLET_PRINT;
    }

    pAttrInfo1->dwJobNumberOfCopies = pci->pdm->dmCopies;
    pAttrInfo1->dwDrvNumberOfCopies = DwGetDrvCopies(pci);

    #ifdef UNIDRV

    //
    // Unidrv doesn't support N-up option.
    //

    pAttrInfo1->dwDrvNumberOfPagesPerSide = 1;

    #endif

    //
    // Unidrv assumes that automatic switching to monochrome
    // mode on a color printer is allowed unless disabled in GPD
    //

    if (dwLevel == 3)
    {
    #ifdef UNIDRV

        SHORT dmPrintQuality, dmYResolution;

        if (pci->pUIInfo->bChangeColorModeOnDoc &&
            pci->pdm->dmColor == DMCOLOR_COLOR &&
            BOkToChangeColorToMono(pci, pci->pdm, &dmPrintQuality, &dmYResolution) &&
            GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_COLORMODE))
        {
            ((PATTRIBUTE_INFO_3)pAttrInfo1)->dwColorOptimization = COLOR_OPTIMIZATION;
            ((PATTRIBUTE_INFO_3)pAttrInfo1)->dmPrintQuality = dmPrintQuality;
            ((PATTRIBUTE_INFO_3)pAttrInfo1)->dmYResolution = dmYResolution;

        }
        else
    #endif
            ((PATTRIBUTE_INFO_3)pAttrInfo1)->dwColorOptimization = NO_COLOR_OPTIMIZATION;
    }

    bResult = TRUE;

    FOREACH_OEMPLUGIN_LOOP(pci)

        if (HAS_COM_INTERFACE(pOemEntry))
        {
            HRESULT hr;

            hr = HComOEMQueryJobAttributes(
                                pOemEntry,
                                hPrinter,
                                pDevMode,
                                dwLevel,
                                lpAttributeInfo);

            if (hr == E_NOTIMPL || hr == E_NOINTERFACE)
                continue;

            bResult = SUCCEEDED(hr);

        }

    END_OEMPLUGIN_LOOP

    VFreeCommonInfo(pci);
    return bResult;

    #else // WINNT_40

    return FALSE;

    #endif // WINNT_40
}

VOID
VUpdateBookletOption(
    PUIDATA     pUiData,
    POPTITEM    pCurItem
    )

/*++

Routine Description:

    Handle the dependencies between duplex, nup and booklet options

Arguments:

    pUiData - UIDATA
    pCurItem - OPTITEM to currently selected item

Return Value:

    None

--*/

{
    PDRIVEREXTRA  pdmExtra = pUiData->ci.pdmPrivate;
    DWORD         dwFeatureIndex, dwOptionIndex, dwCount;
    PDUPLEX       pDuplexOption = NULL;
    POPTITEM      pDuplexItem, pNupItem;
    PFEATURE      pDuplexFeature = NULL;

    pDuplexItem = pNupItem = NULL;

    //
    // 1. Booklet is enabled - turn duplex on
    // 3. Duplex is simplex, disable booklet, set to 1 up.
    //

    pDuplexFeature = GET_PREDEFINED_FEATURE(pUiData->ci.pUIInfo, GID_DUPLEX);
    pNupItem = PFindOptItemWithUserData(pUiData, NUP_ITEM);
    pDuplexItem = PFindOptItemWithUserData(pUiData, DUPLEX_ITEM);

    if (pDuplexFeature && pDuplexItem)
    {
        dwFeatureIndex = GET_INDEX_FROM_FEATURE(pUiData->ci.pUIInfo, pDuplexFeature);
        dwOptionIndex = pUiData->ci.pCombinedOptions[dwFeatureIndex].ubCurOptIndex;
        pDuplexOption = PGetIndexedOption(pUiData->ci.pUIInfo, pDuplexFeature, dwOptionIndex);
    }

    if ((GETUSERDATAITEM(pCurItem->UserData) == NUP_ITEM) &&
         pCurItem->Sel == BOOKLET_UP)
    {
        if (pDuplexOption && pDuplexOption->dwDuplexID == DMDUP_SIMPLEX)
        {
            pDuplexOption = PGetIndexedOption(pUiData->ci.pUIInfo, pDuplexFeature, 0);

            for (dwCount = 0 ; dwCount < pDuplexFeature->Options.dwCount; dwCount++)
            {
                if (pDuplexOption->dwDuplexID != DMDUP_SIMPLEX)
                {
                    pDuplexItem->Sel = dwCount;
                    pDuplexItem->Flags |= OPTIF_CHANGED;
                    VUpdateOptionsArrayWithSelection(pUiData, pDuplexItem);
                    break;
                }
                pDuplexOption++;
            }

        }
    }
    else if ((GETUSERDATAITEM(pCurItem->UserData) == DUPLEX_ITEM) &&
             pDuplexOption)
    {
        if (pDuplexOption->dwDuplexID == DMDUP_SIMPLEX &&
            pNupItem &&
            pNupItem->Sel == BOOKLET_UP)
        {
            pNupItem->Sel = TWO_UP;
            pNupItem->Flags |= OPTIF_CHANGED;
            NUPOPTION(pdmExtra) = TWO_UP;
        }
    }
}


#ifdef UNIDRV

VOID
VSyncColorInformation(
    PUIDATA     pUiData,
    POPTITEM    pCurItem
    )

/*++

Routine Description:

Arguments:


Return Value:


--*/

{
    POPTITEM    pOptItem;
    PFEATURE    pFeature;

    //
    // This is a hack to work around the fact that Unidrv has
    // two color options, color appearance and color mode option,
    // need to update the other once one is changed
    //

    pOptItem = (GETUSERDATAITEM(pCurItem->UserData) == COLOR_ITEM) ?
                    PFindOptItemWithUserData(pUiData, COLORMODE_ITEM) :
                    (GETUSERDATAITEM(pCurItem->UserData) == COLORMODE_ITEM) ?
                        PFindOptItemWithUserData(pUiData, COLOR_ITEM) : NULL;

    if ((pOptItem != NULL) &&
        (pFeature = GET_PREDEFINED_FEATURE(pUiData->ci.pUIInfo, GID_COLORMODE)))
    {
        DWORD    dwFeature = GET_INDEX_FROM_FEATURE(pUiData->ci.pUIInfo, pFeature);

        //
        // Find either color appearance or color mode option
        //

        if (GETUSERDATAITEM(pCurItem->UserData) == COLOR_ITEM)
        {
            ChangeOptionsViaID(
                    pUiData->ci.pInfoHeader,
                    pUiData->ci.pCombinedOptions,
                    GID_COLORMODE,
                    pUiData->ci.pdm);

            pOptItem->Sel = pUiData->ci.pCombinedOptions[dwFeature].ubCurOptIndex;
            pOptItem->Flags |= OPTIF_CHANGED;
        }
        else // COLORMODE_ITEM
        {
            POPTION pColorMode;
            PCOLORMODEEX pColorModeEx;

            pColorMode = PGetIndexedOption(
                                    pUiData->ci.pUIInfo,
                                    pFeature,
                                    pCurItem->Sel);

            if (pColorMode)
            {
                pColorModeEx = OFFSET_TO_POINTER(
                                    pUiData->ci.pInfoHeader,
                                    pColorMode->loRenderOffset);

                if (pColorModeEx)
                {
                    pOptItem->Sel = pColorModeEx->bColor ? 1: 0;

                    VUnpackDocumentPropertiesItems(pUiData, pOptItem, 1);

                    pOptItem->Flags |= OPTIF_CHANGED;
                }
                else
                {
                    ERR(("pColorModeEx is NULL\n"));
                }
            }
            else
            {
                ERR(("pColorMode is NULL\n"));
            }
        }
    }
}

DWORD
DwGetItemFromGID(
    PFEATURE    pFeature
    )

/*++

Routine Description:

Arguments:


Return Value:


--*/

{
    DWORD   dwItem = 0;

    switch (pFeature->dwFeatureID)
    {
    case GID_PAGESIZE:
        dwItem = FORMNAME_ITEM;
        break;

    case GID_DUPLEX:
        dwItem =  DUPLEX_ITEM;
        break;

    case GID_RESOLUTION:
        dwItem = RESOLUTION_ITEM;
        break;

    case GID_MEDIATYPE:
        dwItem = MEDIATYPE_ITEM;
        break;

    case GID_INPUTSLOT:
        dwItem = INPUTSLOT_ITEM;
        break;

    case GID_COLORMODE:
        dwItem = COLORMODE_ITEM;
        break;

    case GID_ORIENTATION:
        dwItem = ORIENTATION_ITEM;
        break;

    case GID_PAGEPROTECTION:
        dwItem = PAGE_PROTECT_ITEM;
        break;

    case GID_COLLATE:
        dwItem = COPIES_COLLATE_ITEM;
        break;

    case GID_HALFTONING:
        dwItem =  HALFTONING_ITEM;
        break;

    default:
        dwItem = UNKNOWN_ITEM;
        break;
    }

    return dwItem;
}


PLISTNODE
PGetMacroList(
    PUIDATA     pUiData,
    POPTITEM    pMacroItem,
    PGPDDRIVERINFO pDriverInfo
    )

/*++

Routine Description:

Arguments:


Return Value:


--*/

{

    PUIINFO         pUIInfo = pUiData->ci.pUIInfo;
    PLISTNODE       pListNode = NULL;
    LISTINDEX       liIndex;

    if (pMacroItem)
    {
        switch(pMacroItem->Sel)
        {
            case QS_BEST:
                liIndex = pUIInfo->liBestQualitySettings;
                break;

            case QS_DRAFT:
                liIndex = pUIInfo->liDraftQualitySettings;
                break;

            case QS_BETTER:
                liIndex = pUIInfo->liBetterQualitySettings;
                break;
        }

        pListNode = LISTNODEPTR(pDriverInfo, liIndex);

    }

    return pListNode;

}

VOID
VUpdateQualitySettingOptions(
    PUIINFO     pUIInfo,
    POPTITEM    pQualityItem
    )

/*++

Routine Description:

Arguments:


Return Value:


--*/
{
    POPTPARAM pParam;
    LISTINDEX liList;
    DWORD     i;

    pParam = pQualityItem->pOptType->pOptParam;

    for (i = QS_BEST; i < QS_BEST + MAX_QUALITY_SETTINGS; i++)
    {
        switch(i)
        {
            case QS_BEST:
                liList = pUIInfo->liBestQualitySettings;
                break;

            case QS_BETTER:
                liList = pUIInfo->liBetterQualitySettings;
                break;

            case QS_DRAFT:
                liList = pUIInfo->liDraftQualitySettings;
                break;

        }

        if (liList == END_OF_LIST)
        {
            pParam->Flags |= OPTPF_DISABLED;
            pParam->dwReserved[0] = TRUE;

        }
        else
        {
            pParam->Flags &= ~OPTPF_DISABLED;
            pParam->dwReserved[0] = FALSE;

        }
        pParam++;
    }
    pQualityItem->Flags |= OPTIF_CHANGED;
}


VOID
VMakeMacroSelections(
    PUIDATA     pUiData,
    POPTITEM    pCurItem
    )

/*++

Routine Description:

Arguments:


Return Value:


--*/
{
    DWORD       dwFeatureID, dwOptionID, dwItem, i;
    PUIINFO     pUIInfo;
    POPTITEM    pMacroItem, pOptItem;
    PFEATURE    pFeature;
    PLISTNODE   pListNode;
    PGPDDRIVERINFO  pDriverInfo;
    BOOL        bMatchFound = FALSE;

    //
    // Mark options array with the change to either
    // Macro selection, media type, color
    //
    // Update binary data
    // Make selection
    //

    if (pUiData->ci.pdmPrivate->dwFlags & DXF_CUSTOM_QUALITY)
        return;


    if (pCurItem)
        VUnpackDocumentPropertiesItems(pUiData, pCurItem, 1);

    pMacroItem = PFindOptItemWithUserData(pUiData, QUALITY_SETTINGS_ITEM);

    //
    // BUpdateUIInfo calls UpdateBinaryData to get new snapshot
    // for latest optionarray
    //

    if (pMacroItem == NULL || !BUpdateUIInfo(&pUiData->ci) )
        return;

    pUIInfo = pUiData->ci.pUIInfo;

    pDriverInfo = OFFSET_TO_POINTER(pUiData->ci.pInfoHeader,
                                    pUiData->ci.pInfoHeader->loDriverOffset);

    //
    // Update the macro selection to reflect the current default
    //

    if (pCurItem && GETUSERDATAITEM(pCurItem->UserData) != QUALITY_SETTINGS_ITEM)
    {
        ASSERT(pUIInfo->defaultQuality != END_OF_LIST);

        if (pUIInfo->defaultQuality == END_OF_LIST)
            return;

        pMacroItem->Sel = pUIInfo->defaultQuality;
        VUnpackDocumentPropertiesItems(pUiData, pMacroItem, 1);
        pMacroItem->Flags |= OPTIF_CHANGED;

    }

    //
    // Determine which item to gray out based on the
    // liBestQualitySettings, liBetterQualitySettings, liDraftQualitySettings
    //

    VUpdateQualitySettingOptions(pUIInfo, pMacroItem);

    pListNode = PGetMacroList(pUiData, pMacroItem, pDriverInfo);

    //
    // Make the selction of Feature.Option
    //

    while (pListNode)
    {
        //
        // Search thru our list of OPTITEM for the matching
        // Feature
        //

        pOptItem = pUiData->pDrvOptItem;
        dwFeatureID = ((PQUALNAME)(&pListNode->dwData))->wFeatureID;
        dwOptionID  = ((PQUALNAME)(&pListNode->dwData))->wOptionID;

        pFeature =  (PFEATURE)((PBYTE)pUIInfo->pInfoHeader + pUIInfo->loFeatureList) + dwFeatureID;
        dwItem = DwGetItemFromGID(pFeature);

        for (i = 0; i < pUiData->dwDrvOptItem; i++)
        {
            if (ISPRINTERFEATUREITEM(pOptItem->UserData))
            {
                PFEATURE pPrinterFeature = (PFEATURE)GETUSERDATAITEM(pOptItem->UserData);

                if (GET_INDEX_FROM_FEATURE(pUIInfo, pPrinterFeature) == dwFeatureID)
                    bMatchFound = TRUE;
            }
            else
            {
                if (dwItem != UNKNOWN_ITEM &&
                    dwItem == GETUSERDATAITEM(pOptItem->UserData))
                    bMatchFound = TRUE;
            }

            if (bMatchFound)
            {
                pOptItem->Sel = dwOptionID;
                pOptItem->Flags |= OPTIF_CHANGED;
                VUnpackDocumentPropertiesItems(pUiData, pOptItem, 1);
                bMatchFound = FALSE;
                break;
            }

            pOptItem++;
        }

        pListNode = LISTNODEPTR(pDriverInfo, pListNode->dwNextItem);
    }

}

VOID
VUpdateMacroSelection(
    PUIDATA     pUiData,
    POPTITEM    pCurItem
    )

/*++

Routine Description:

Arguments:


Return Value:


--*/

{

    DWORD           dwFeatureIndex;
    PFEATURE        pFeature = NULL;
    PLISTNODE       pListNode;
    POPTITEM        pMacroItem;
    PGPDDRIVERINFO  pDriverInfo;

    pMacroItem = PFindOptItemWithUserData(pUiData, QUALITY_SETTINGS_ITEM);

    if (pMacroItem == NULL)
        return;

    pDriverInfo = OFFSET_TO_POINTER(pUiData->ci.pInfoHeader,
                                    pUiData->ci.pInfoHeader->loDriverOffset);

    if (!(pFeature = PGetFeatureFromItem(pUiData->ci.pUIInfo, pCurItem, &dwFeatureIndex)))
        return;

    ASSERT(pDriverInfo);

    pListNode = PGetMacroList(pUiData, pMacroItem, pDriverInfo);

    while (pListNode)
    {
        if ( ((PQUALNAME)(&pListNode->dwData))->wFeatureID == (WORD)dwFeatureIndex)
        {
            pMacroItem->Flags |= OPTIF_ECB_CHECKED;
            _VUnpackDocumentOptions(pMacroItem, pUiData->ci.pdm);
            break;
        }

        pListNode = LISTNODEPTR(pDriverInfo, pListNode->dwNextItem);
    }
}

#endif //UNIDRV
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\driverui\driverui.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    driverui.c

Abstract:

    This file contains utility functions for the UI and the
    interface to the parser.

Environment:

    Win32 subsystem, DriverUI module, user mode

Revision History:

    02/09/97 -davidx-
        Rewrote it to consistently handle common printer info
        and to clean up parser interface code.

    02/04/97 -davidx-
        Reorganize driver UI to separate ps and uni DLLs.

    07/17/96 -amandan-
        Created it.

--*/

#include "precomp.h"

HANDLE HCreateHeapForCI();


PCOMMONINFO
PLoadCommonInfo(
    HANDLE      hPrinter,
    PTSTR       pPrinterName,
    DWORD       dwFlags
    )

/*++

Routine Description:

    Load basic information needed by the driver UI such as:
        printer driver info level 2
        load raw printer description data
        printer description data instance based on default settings
        get information about OEM plugins
        load OEM UI modules

Arguments:

    hPrinter - Handle to the current printer
    pPrinterName - Points to the current printer name
    dwFlags - One of the following combinations:
        0
        FLAG_ALLOCATE_UIDATA
        FLAG_OPENPRINTER_NORMAL [ | FLAG_OPEN_CONDITIONAL ]
        FLAG_OPENPRINTER_ADMIN [ | FLAG_INIT_PRINTER ]
        FLAG_OPENPRINTER_ADMIN [ | FLAG_PROCESS_INIFILE ]

Return Value:

    Pointer to an allocated COMMONINFO structure if successful
    NULL if there is an error

--*/

{
    static PRINTER_DEFAULTS PrinterDefaults = { NULL, NULL, PRINTER_ALL_ACCESS };
    PCOMMONINFO pci;
    DWORD       dwSize;

    //
    // Allocate memory for a COMMONINFO structure
    //

    dwSize = (dwFlags & FLAG_ALLOCATE_UIDATA) ?  sizeof(UIDATA) : sizeof(COMMONINFO);

    if (! (pci = MemAllocZ(dwSize)) ||
        ! (pci->pPrinterName = DuplicateString(pPrinterName ? pPrinterName : TEXT("NULL"))))
    {
        ERR(("Memory allocation failed\n"));
        VFreeCommonInfo(pci);
        return NULL;
    }

    pci->pvStartSign = pci;
    pci->dwFlags = dwFlags;

    //
    // Check if we should open a handle to the current printer
    //

    if (dwFlags & (FLAG_OPENPRINTER_NORMAL | FLAG_OPENPRINTER_ADMIN))
    {
        ASSERT(hPrinter == NULL && pPrinterName != NULL);

        //
        // Open a printer handle with the specified access right
        //

        if (! OpenPrinter(pPrinterName,
                          &hPrinter,
                          (dwFlags & FLAG_OPENPRINTER_ADMIN) ? &PrinterDefaults : NULL))
        {
            ERR(("OpenPrinter failed for '%ws': %d\n", pPrinterName, GetLastError()));
            VFreeCommonInfo(pci);
            return NULL;
        }

        pci->hPrinter = hPrinter;
    }
    else
    {
        ASSERT(hPrinter != NULL);
        pci->hPrinter = hPrinter;
    }

    //
    // If the caller requires that the printer to be initialized,
    // check to make sure it is. If not, return error.
    //

    if (dwFlags & FLAG_OPEN_CONDITIONAL)
    {
        PPRINTER_INFO_2 pPrinterInfo2;
        DWORD           dwInitData;

        //
        // NOTE: We're really like to use level 4 here. But due to bug in the
        // spooler, GetPrinter level 4 doesn't work for printer connections.
        //

        dwInitData = gwDriverVersion;

        #ifdef WINNT_40
            //
            // Hack around spooler bug where DrvConvertDevmode is called before
            // DrvPrinterEvent.Initialzed is called.
            //
            if (!BGetPrinterDataDWord(hPrinter, REGVAL_PRINTER_INITED, &dwInitData))
                DrvPrinterEvent(pPrinterName, PRINTER_EVENT_INITIALIZE, 0, 0);
        #endif

        if ((pPrinterInfo2 = MyGetPrinter(hPrinter, 2)) == NULL ||
            (pPrinterInfo2->pServerName == NULL) &&
            !BGetPrinterDataDWord(hPrinter, REGVAL_PRINTER_INITED, &dwInitData))
        {
            dwInitData = 0;
        }

        MemFree(pPrinterInfo2);

        if (dwInitData != gwDriverVersion)
        {
            TERSE(("Printer not fully initialized yet: %d\n", GetLastError()));
            VFreeCommonInfo(pci);
            return NULL;
        }
    }

    //
    // Get information about the printer driver
    //

    if ((pci->pDriverInfo3 = MyGetPrinterDriver(hPrinter, NULL, 3)) == NULL)
    {
        ERR(("Cannot get printer driver info: %d\n", GetLastError()));
        VFreeCommonInfo(pci);
        return NULL;
    }

    //
    // If FLAG_INIT_PRINTER is set, we should initialize the printer here.
    //

    if (dwFlags & (FLAG_INIT_PRINTER | FLAG_PROCESS_INIFILE))
    {
        //
        // Parse OEM plugin configuration file and
        // save the resulting info into registry
        //

        if (!BProcessPrinterIniFile(hPrinter, pci->pDriverInfo3, NULL,
                                    (dwFlags & FLAG_UPGRADE_PRINTER) ? FLAG_INIPROCESS_UPGRADE : 0))
        {
            VERBOSE(("BProcessPrinterIniFile failed\n"));
        }

        //
        // If printer was successfully initialized and caller is not asking to process
        // ini file only, save a flag in the registry to indicate the fact.
        //

        if (dwFlags & FLAG_INIT_PRINTER)
        {
            (VOID) BSetPrinterDataDWord(hPrinter, REGVAL_PRINTER_INITED, gwDriverVersion);
        }
    }

    //
    // fix 317359. In case some part of the driver has changed refresh the .bpd
    // to update driver-language-specific strings in the .bpd. "Manual Feed" is
    // written by the parser and therefore the .bpd depends on the language the
    // parser was localized for. Checking the language would have to be done every time
    // something is printed, therefore we just delete the .bpd, then the it gets reparsed
    // always has the same language as the driver.
    //
    #ifdef PSCRIPT
    if (dwFlags & FLAG_REFRESH_PARSED_DATA)
    {
        DeleteRawBinaryData(pci->pDriverInfo3->pDataFile);
    }
    #endif

    //
    // Load raw binary printer description data, and
    // Get a printer description data instance using the default settings
    //
    // Notice that this is done inside a critical section (because
    // GPD parsers has lots of globals).
    //

//    ENTER_CRITICAL_SECTION();

    pci->pRawData = LoadRawBinaryData(pci->pDriverInfo3->pDataFile);

    if (pci->pRawData)
        pci->pInfoHeader = InitBinaryData(pci->pRawData, NULL, NULL);

    if (pci->pInfoHeader)
        pci->pUIInfo = OFFSET_TO_POINTER(pci->pInfoHeader, pci->pInfoHeader->loUIInfoOffset);

//    LEAVE_CRITICAL_SECTION();

    if (!pci->pRawData || !pci->pInfoHeader || !pci->pUIInfo)
    {
        ERR(("Cannot load printer description data: %d\n", GetLastError()));
        VFreeCommonInfo(pci);
        return NULL;
    }

    //
    // Get information about OEM plugins and load them
    //

    if (! (pci->pOemPlugins = PGetOemPluginInfo(hPrinter,
                                                pci->pDriverInfo3->pConfigFile,
                                                pci->pDriverInfo3)) ||
        ! BLoadOEMPluginModules(pci->pOemPlugins))
    {
        ERR(("Cannot load OEM plugins: %d\n", GetLastError()));
        VFreeCommonInfo(pci);
        return NULL;
    }

    pci->oemuiobj.cbSize = sizeof(OEMUIOBJ);
    pci->oemuiobj.pOemUIProcs = (POEMUIPROCS) &OemUIHelperFuncs;
    pci->pOemPlugins->pdriverobj = &pci->oemuiobj;
    return pci;
}



VOID
VFreeCommonInfo(
    PCOMMONINFO pci
    )

/*++

Routine Description:

    Release common information used by the driver UI

Arguments:

    pci - Common driver information to be released

Return Value:

    NONE

--*/

{
    if (pci == NULL)
        return;

    //
    // Unload OEM UI modules and free OEM plugin info
    //

    if (pci->pOemPlugins)
        VFreeOemPluginInfo(pci->pOemPlugins);

    //
    // Unload raw binary printer description data
    // and/or any printer description data instance
    //

    if (pci->pInfoHeader)
        FreeBinaryData(pci->pInfoHeader);

    if (pci->pRawData)
        UnloadRawBinaryData(pci->pRawData);

    //
    // Close the printer handle if it was opened by us
    //

    if ((pci->dwFlags & (FLAG_OPENPRINTER_NORMAL|FLAG_OPENPRINTER_ADMIN)) &&
        (pci->hPrinter != NULL))
    {
        ClosePrinter(pci->hPrinter);
    }

    #ifdef UNIDRV
    if (pci->pWinResData)
    {
        VWinResClose(pci->pWinResData);
        MemFree(pci->pWinResData);
    }
    #endif

    if (pci->hHeap)
        HeapDestroy(pci->hHeap);

    MemFree(pci->pSplForms);
    MemFree(pci->pCombinedOptions);
    MemFree(pci->pPrinterData);
    MemFree(pci->pPrinterName);
    MemFree(pci->pDriverInfo3);
    MemFree(pci->pdm);
    MemFree(pci);
}



BOOL
BFillCommonInfoDevmode(
    PCOMMONINFO pci,
    PDEVMODE    pdmPrinter,
    PDEVMODE    pdmInput
    )

/*++

Routine Description:

    Populate the devmode fields in the COMMONINFO structure.
        start out with the driver default devmode, and
        merge it with the printer default devmode, and
        merge it with the input devmode

Arguments:

    pci - Points to a COMMONINFO structure
    pdmPrinter - Points to printer default devmode
    pdmInput - Points to input devmode

Return Value:

    TRUE if successful, FALSE if there is an error

Note:

    pdmPrinter and/or pdmInput can be NULL.

--*/

{
    //
    // Start with driver default devmode
    //

    ASSERT(pci->pdm == NULL);

    pci->pdm = PGetDefaultDevmodeWithOemPlugins(
                            pci->pPrinterName,
                            pci->pUIInfo,
                            pci->pRawData,
                            IsMetricCountry(),
                            pci->pOemPlugins,
                            pci->hPrinter);

    //
    // Merge with printer default and input devmode
    //

    if (! pci->pdm ||
        ! BValidateAndMergeDevmodeWithOemPlugins(
                        pci->pdm,
                        pci->pUIInfo,
                        pci->pRawData,
                        pdmPrinter,
                        pci->pOemPlugins,
                        pci->hPrinter) ||
        ! BValidateAndMergeDevmodeWithOemPlugins(
                        pci->pdm,
                        pci->pUIInfo,
                        pci->pRawData,
                        pdmInput,
                        pci->pOemPlugins,
                        pci->hPrinter))
    {
        ERR(("Cannot process devmode information: %d\n", GetLastError()));
        return FALSE;
    }

    pci->pdmPrivate = (PDRIVEREXTRA) GET_DRIVER_PRIVATE_DEVMODE(pci->pdm);
    return TRUE;
}



BOOL
BFillCommonInfoPrinterData(
    PCOMMONINFO pci
    )

/*++

Routine Description:

    Populate the printer-sticky property data field

Arguments:

    pci - Points to basic printer info

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    ASSERT(pci->pPrinterData == NULL);

    if (pci->pPrinterData = MemAllocZ(sizeof(PRINTERDATA)))
        return BGetPrinterProperties(pci->hPrinter, pci->pRawData, pci->pPrinterData);

    ERR(("Memory allocation failed\n"));
    return FALSE;
}



BOOL
BCombineCommonInfoOptionsArray(
    PCOMMONINFO pci
    )

/*++

Routine Description:

    Combined document-sticky feature selections and printer-sticky
    feature selection into a single options array

Arguments:

    pci - Points to basic printer info

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    POPTSELECT  pDocOptions, pPrinterOptions;

    #ifdef UNIDRV

    OPTSELECT   DocOptions[MAX_PRINTER_OPTIONS];
    OPTSELECT   PrinterOptions[MAX_PRINTER_OPTIONS];

    #endif

    //
    // Allocate enough memory for the combined options array
    //

    pci->pCombinedOptions = MemAllocZ(sizeof(OPTSELECT) * MAX_COMBINED_OPTIONS);

    if (pci->pCombinedOptions == NULL)
    {
        ERR(("Memory allocation failed\n"));
        return FALSE;
    }

    pDocOptions = pci->pdm ? PGetDevmodeOptionsArray(pci->pdm) : NULL;
    pPrinterOptions = pci->pPrinterData ? pci->pPrinterData->aOptions : NULL;

    #ifdef UNIDRV

    //
    // GPD parser doesn't follow the current parser interface spec.
    // It AVs if either doc- or printer-sticky options array is NULL.
    // So we have to call it first to get appropriate default options first.
    //

    if (pDocOptions == NULL)
    {
        if (! InitDefaultOptions(pci->pRawData,
                                 DocOptions,
                                 MAX_PRINTER_OPTIONS,
                                 MODE_DOCUMENT_STICKY))
        {
            return FALSE;
        }

        pDocOptions = DocOptions;
    }

    if (pPrinterOptions == NULL)
    {
        if (! InitDefaultOptions(pci->pRawData,
                                 PrinterOptions,
                                 MAX_PRINTER_OPTIONS,
                                 MODE_PRINTER_STICKY))
        {
            return FALSE;
        }

        pPrinterOptions = PrinterOptions;
    }

    #endif // UNIDRV

    return CombineOptionArray(pci->pRawData,
                              pci->pCombinedOptions,
                              MAX_COMBINED_OPTIONS,
                              pDocOptions,
                              pPrinterOptions);
}


VOID
VFixOptionsArrayWithPaperSizeID(
    PCOMMONINFO pci
    )

/*++

Routine Description:

    Fix up combined options array with paper size information from public devmode fields

Arguments:

    pci - Points to basic printer info

Return Value:

    NONE

--*/

{

    PFEATURE pFeature = GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_PAGESIZE);
    BOOL     abEnabledOptions[MAX_PRINTER_OPTIONS];
    PDWORD   pdwPaperIndex = (PDWORD)&abEnabledOptions;
    DWORD    dwCount, dwOptionIndex, i;
    WCHAR    awchBuf[CCHPAPERNAME];


    if (pFeature == NULL)
        return;

    dwCount = MapToDeviceOptIndex(pci->pInfoHeader,
                                  GID_PAGESIZE,
                                  pci->pdm->dmPaperWidth * DEVMODE_PAPER_UNIT,
                                  pci->pdm->dmPaperLength * DEVMODE_PAPER_UNIT,
                                  pdwPaperIndex);
    if (dwCount == 0 )
        return;

    if (dwCount > 1 )
    {
        PPAGESIZE pPageSize;

        for (i = 0; i < dwCount; i++)
        {
            if (pPageSize = (PPAGESIZE)PGetIndexedOption(pci->pUIInfo, pFeature, pdwPaperIndex[i]))
            {
                if ((LOAD_STRING_PAGESIZE_NAME(pci, pPageSize, awchBuf, CCHPAPERNAME)) &&
                    (_wcsicmp(pci->pdm->dmFormName, awchBuf) == EQUAL_STRING) )
                {
                    dwOptionIndex = pdwPaperIndex[i];
                    break;
                }
            }
        }

        if (i >= dwCount)
            dwOptionIndex = pdwPaperIndex[0];

    }
    else
        dwOptionIndex = pdwPaperIndex[0];

    ZeroMemory(abEnabledOptions, sizeof(abEnabledOptions));
    abEnabledOptions[dwOptionIndex] = TRUE;
    ReconstructOptionArray(pci->pRawData,
                           pci->pCombinedOptions,
                           MAX_COMBINED_OPTIONS,
                           GET_INDEX_FROM_FEATURE(pci->pUIInfo, pFeature),
                           abEnabledOptions);

}



VOID
VFixOptionsArrayWithDevmode(
    PCOMMONINFO pci
    )

/*++

Routine Description:

    Fix up combined options array with information from public devmode fields

Arguments:

    pci - Points to basic printer info

Return Value:

    NONE

--*/

{
    //
    // Mapping table from public devmode fields to GID indices
    // We assume that GID_COLORMODE corresponds to DM_COLR
    //

    static CONST struct _DMFIELDS_GID_MAPPING {
        DWORD   dwGid;
        DWORD   dwMask;
    } DMFieldsGIDMapping[] = {
        { GID_RESOLUTION,   DM_PRINTQUALITY|DM_YRESOLUTION },
        { GID_PAGESIZE,     DM_FORMNAME|DM_PAPERSIZE|DM_PAPERWIDTH|DM_PAPERLENGTH },
        { GID_DUPLEX,       DM_DUPLEX },
        { GID_INPUTSLOT,    DM_DEFAULTSOURCE },
        { GID_MEDIATYPE,    DM_MEDIATYPE },
        { GID_ORIENTATION,  DM_ORIENTATION },
        { GID_COLLATE,      DM_COLLATE },
        { GID_COLORMODE,    DM_COLOR },
    };

    INT     iIndex;
    BOOL    bConflict;

    //
    // Validate form-related devmode fields
    //

    if (pci->pSplForms == NULL)
        pci->pSplForms = MyEnumForms(pci->hPrinter, 1, &pci->dwSplForms);

    if (! BValidateDevmodeCustomPageSizeFields(
                pci->pRawData,
                pci->pUIInfo,
                pci->pdm,
                NULL) &&
        ! BValidateDevmodeFormFields(
                pci->hPrinter,
                pci->pdm,
                NULL,
                pci->pSplForms,
                pci->dwSplForms))
    {
        VDefaultDevmodeFormFields(pci->pUIInfo, pci->pdm, IsMetricCountry());
    }

    //
    // Fix up options array with information from public devmode fields
    //

    iIndex = sizeof(DMFieldsGIDMapping) / sizeof(struct _DMFIELDS_GID_MAPPING);

    while (iIndex-- > 0)
    {
        if (pci->pdm->dmFields & DMFieldsGIDMapping[iIndex].dwMask)
        {
           #if UNIDRV
                if (DMFieldsGIDMapping[iIndex].dwGid == GID_PAGESIZE)
                {
                    VFixOptionsArrayWithPaperSizeID(pci);
                }
                else
            #endif
                {
                    (VOID) ChangeOptionsViaID(pci->pInfoHeader,
                                            pci->pCombinedOptions,
                                            DMFieldsGIDMapping[iIndex].dwGid,
                                            pci->pdm);
                }
        }
    }
}



BOOL
BUpdateUIInfo(
    PCOMMONINFO pci
    )

/*++

Routine Description:

    Get an updated printer description data instance using the combined options array

Arguments:

    pci - Points to basic printer info

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PINFOHEADER pInfoHeader;

    //
    // Get an updated instance of printer description data
    //

    pInfoHeader = UpdateBinaryData(pci->pRawData,
                                   pci->pInfoHeader,
                                   pci->pCombinedOptions);


    if (pInfoHeader == NULL)
    {
        ERR(("UpdateBinaryData failed\n"));
        return FALSE;
    }

    //
    // Reset various points in COMMONINFO structure
    //

    pci->pInfoHeader = pInfoHeader;
    pci->pUIInfo = OFFSET_TO_POINTER(pInfoHeader, pInfoHeader->loUIInfoOffset);
    ASSERT(pci->pUIInfo != NULL);

    return (pci->pUIInfo != NULL);
}



BOOL
BPrepareForLoadingResource(
    PCOMMONINFO pci,
    BOOL        bNeedHeap
    )

/*++

Routine Description:

    Make sure a heap is created and the resource DLL has been loaded

Arguments:

    pci - Points to basic printer info
    bNeedHeap - Whether memory heap is necessary

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    BOOL bResult = FALSE;

    //
    // Create the memory heap if necessary
    //

    if (  bNeedHeap &&
        ! pci->hHeap &&
        ! (pci->hHeap = HCreateHeapForCI()))
    {
        return bResult;
    }

    #ifdef UNIDRV

    if (pci->pWinResData)
    {
        bResult = TRUE;
    }
    else
    {
        if ((pci->pWinResData = MemAllocZ(sizeof(WINRESDATA))) &&
            (BInitWinResData(pci->pWinResData,
                             pci->pDriverInfo3->pDriverPath,
                             pci->pUIInfo)))
            bResult = TRUE;
    }

    #endif

    return bResult;
}



#ifndef PSCRIPT

PWSTR
PGetReadOnlyDisplayName(
    PCOMMONINFO pci,
    PTRREF      loOffset
    )

/*++

Routine Description:

    Get a read-only copy of a display name:
    1)  if the display name is in the binary printer description data,
        then we simply return a pointer to that data.
    2)  otherwise, the display name is in the resource DLL.
        we allocate memory out of the driver's heap and
        load the string.

    Caller should NOT free the returned pointer. The memory
    will go away when the binary printer description data is unloaded
    or when the driver's heap is destroyed.

Arguments:

    pci - Points to basic printer info
    loOffset - Display name string offset

Return Value:

    Pointer to the requested display name string
    NULL if there is an error

--*/

{
    if (loOffset & GET_RESOURCE_FROM_DLL)
    {
        //
        // loOffset specifies a string resource ID
        // in the resource DLL
        //

        WCHAR   wchbuf[MAX_DISPLAY_NAME];
        INT     iLength;
        PWSTR   pwstr;
        HANDLE  hResDll;
        DWORD   dwResID = loOffset & ~GET_RESOURCE_FROM_DLL;

        //
        // First ensure the resource DLL has been loaded
        // and a heap has already been created
        //

        if (! BPrepareForLoadingResource(pci, TRUE))
            return NULL;

        //
        // Load string resource into a temporary buffer
        // and allocate enough memory to hold the string
        //

        iLength = ILOADSTRING(pci, dwResID, wchbuf, MAX_DISPLAY_NAME);

        pwstr = HEAPALLOC(pci->hHeap, (iLength+1) * sizeof(WCHAR));

        if (pwstr == NULL)
        {
            ERR(("Memory allocation failed\n"));
            return NULL;
        }

        //
        // Copy the string to allocated memory and
        // return a pointer to it.
        //

        CopyMemory(pwstr, wchbuf, iLength*sizeof(WCHAR));
        return pwstr;
    }
    else
    {
        //
        // loOffset is a byte offset from the beginning of
        // the resource data block
        //

        return OFFSET_TO_POINTER(pci->pUIInfo->pubResourceData, loOffset);
    }
}

#endif // !PSCRIPT



BOOL
BLoadDisplayNameString(
    PCOMMONINFO pci,
    PTRREF      loOffset,
    PWSTR       pwstrBuf,
    INT         iMaxChars
    )

/*++

Routine Description:

    This function is similar to PGetReadOnlyDisplayName
    but the caller must provide the buffer for loading the string.

Arguments:

    pci - Points to basic printer info
    loOffset - Display name string offset
    pwstrBuf - Points to buffer for storing loaded display name string
    iMaxChars - Size of output buffer in characters

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    ASSERT(pwstrBuf && iMaxChars > 0);
    pwstrBuf[0] = NUL;

    if (loOffset & GET_RESOURCE_FROM_DLL)
    {
        //
        // loOffset specifies a string resource ID
        // in the resource DLL
        //

        INT     iLength;
        HANDLE  hResDll;
        DWORD   dwResID = loOffset & ~GET_RESOURCE_FROM_DLL;

        //
        // First ensure the resource DLL has been loaded
        //

        if (! BPrepareForLoadingResource(pci, FALSE))
            return FALSE;

        //
        // Load string resource into the output buffer
        // and allocate enough memory to hold the string
        //

        iLength = ILOADSTRING(pci, dwResID, pwstrBuf, (WORD)iMaxChars);

        return (iLength > 0);
    }
    else
    {
        //
        // loOffset is a byte offset from the beginning of
        // the resource data block
        //

        PWSTR   pwstr;

        pwstr = OFFSET_TO_POINTER(pci->pUIInfo->pubResourceData, loOffset);

        if (pwstr == NULL)
            return FALSE;

        CopyString(pwstrBuf, pwstr, iMaxChars);
        return TRUE;
    }
}

BOOL
BLoadPageSizeNameString(
    PCOMMONINFO pci,
    PTRREF      loOffset,
    PWSTR       pwstrBuf,
    INT         iMaxChars,
    INT         iStdId
    )

/*++

Routine Description:

    This function is similar to PGetReadOnlyDisplayName
    but the caller must provide the buffer for loading the string.

Arguments:

    pci - Points to basic printer info
    loOffset - Display name string offset
    pwstrBuf - Points to buffer for storing loaded display name string
    iMaxChars - Size of output buffer in characters
    iStdId - Predefined standard ID for page size, e.g. DMPAPER_XXX

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{

    ASSERT(pwstrBuf && iMaxChars > 0);
    pwstrBuf[0] = NUL;

    if (loOffset == USE_SYSTEM_NAME)
    {
        PFORM_INFO_1 pForm;
        INT          iIndex = iStdId - DMPAPER_FIRST;

        //
        // iIndex is zero based.
        //

        if (pci->pSplForms == NULL ||
            (INT)pci->dwSplForms <= iIndex)
        {
            WARNING(("BLoadPageSizeName, use std name, pSplForms is NULL \n"));
            return FALSE;
        }

        pForm = pci->pSplForms + iIndex;
        CopyString(pwstrBuf, pForm->pName, iMaxChars);
        return (TRUE);

    }
    else
        return (BLoadDisplayNameString(pci, loOffset, pwstrBuf, iMaxChars));
}


ULONG_PTR
HLoadIconFromResourceDLL(
    PCOMMONINFO pci,
    DWORD       dwIconID
    )

/*++

Routine Description:

    Load icon resource from the resource DLL

Arguments:

    pci - Points to common printer info
    dwIconID - Specifies ID of the icon to be loaded

Return Value:

    Handle to the specified icon resource
    0 if the specified icon cannot be loaded

--*/

{
    //
    // First ensure the resource DLL has been loaded
    //
    #ifdef UNIDRV

    RES_ELEM    ResElem;
    ULONG_PTR   pRes;

    if (! BPrepareForLoadingResource(pci, FALSE))
        return 0;

    if (BGetWinRes(pci->pWinResData, (PQUALNAMEEX)&dwIconID, (INT)((ULONG_PTR)RT_ICON), &ResElem))
        return ((ULONG_PTR)(ResElem.pvResData));

    #endif

    return 0;
}



PUIDATA
PFillUiData(
    HANDLE      hPrinter,
    PTSTR       pPrinterName,
    PDEVMODE    pdmInput,
    INT         iMode
    )
/*++

Routine Description:

    This function is called by DrvDocumentPropertySheets and
    DrvPrinterPropertySheets. It allocates and initializes
    a UIDATA structure that's used to display property pages.

Arguments:

    hPrinter - Handle to the current printer
    pPrinterName - Name of the current printer
    pdmInput - Input devmode
    iMode - Identify the caller:
        MODE_DOCUMENT_STICKY - called from DrvDocumentPropertySheets
        MODE_PRINTER_STICY - called from DrvPrinterPropertySheets

Return Value:

    Pointer to a UIDATA structure, NULL if there is an error

--*/

{
    PUIDATA     pUiData;
    PCOMMONINFO pci;
    BOOL        bNupOption;
    PFEATURE    pFeature;
    DWORD       dwFeatureIndex, dwOptionIndexOld, dwOptionIndexNew;
    BOOL        bUpdateFormField;

    //
    // Allocate UIDATA structure and load common information
    //

    pUiData = (PUIDATA) PLoadCommonInfo(hPrinter, pPrinterName, FLAG_ALLOCATE_UIDATA);

    if (pUiData == NULL)
        goto fill_uidata_err;

    pUiData->pvEndSign = pUiData;
    pUiData->iMode = iMode;
    pci = &pUiData->ci;

    //
    // Create a memory heap
    //

    if ((pci->hHeap = HCreateHeapForCI()) == NULL)
        goto fill_uidata_err;

    //
    // Get printer-sticky property data
    //

    if (! BFillCommonInfoPrinterData(pci))
        goto fill_uidata_err;

    //
    // If called from DrvDocumentPropertySheets, then process
    // devmode information: driver default + printer default + input devmode
    //

    if (iMode == MODE_DOCUMENT_STICKY)
    {
        PPRINTER_INFO_2 pPrinterInfo2;

        if (! (pPrinterInfo2 = MyGetPrinter(hPrinter, 2)) ||
            ! BFillCommonInfoDevmode(pci, pPrinterInfo2->pDevMode, pdmInput))
        {
            MemFree(pPrinterInfo2);
            goto fill_uidata_err;
        }

        MemFree(pPrinterInfo2);
    }

    //
    // Merge doc-sticky and printer-sticky option selections
    //

    if (! BCombineCommonInfoOptionsArray(pci))
        goto fill_uidata_err;

    //
    // If called from DrvDocumentPropertySheets,
    // fix up combined options with public devmode information
    //

    if (iMode == MODE_DOCUMENT_STICKY)
    {
        VFixOptionsArrayWithDevmode(pci);

        //
        // Remember the paper size option parser picked to support the devmode form
        //

        if ((pFeature = GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_PAGESIZE)) == NULL)
        {
            ASSERT(FALSE);
            goto fill_uidata_err;
        }

        dwFeatureIndex = GET_INDEX_FROM_FEATURE(pci->pUIInfo, pFeature);
        dwOptionIndexOld = pci->pCombinedOptions[dwFeatureIndex].ubCurOptIndex;
    }

    VGetSpoolerEmfCaps(pci->hPrinter, &bNupOption, &pUiData->bEMFSpooling, 0, NULL);

    //
    // Resolve any conflicts between printer feature selections,
    // and get an updated printer description data instance
    // using the combined options array.
    //

    (VOID) ResolveUIConflicts(pci->pRawData,
                              pci->pCombinedOptions,
                              MAX_COMBINED_OPTIONS,
                              iMode == MODE_PRINTER_STICKY ?
                                  iMode :
                                  MODE_DOCANDPRINTER_STICKY);

    if (iMode == MODE_DOCUMENT_STICKY)
    {
        dwOptionIndexNew = pci->pCombinedOptions[dwFeatureIndex].ubCurOptIndex;

        bUpdateFormField = FALSE;

        if (dwOptionIndexNew != dwOptionIndexOld)
        {
            //
            // Constraint resolving has changed page size selection, so we need
            // to update devmode's form fields.
            //

            bUpdateFormField = TRUE;
        }
        else
        {
            FORM_INFO_1  *pForm = NULL;

            //
            // Unless the form requested by devmode is not supported on the printer,
            // we still want to show the original form name in upcoming doc-setting UI.
            // For example, if input devmode requested "Legal", parser maps it to option
            // "OEM Legal", but both "Legal" and "OEM Legal" will be shown as supported
            // forms on the printer, then we should still show "Legal" instead of "OEM Legal"
            // in UI's PageSize list. However, if input devmode requestd "8.5 x 12", which
            // won't be shown as a supportd form and it's mapped to "OEM Legal", then we should
            // show "OEM Legal".
            //

            //
            // pdm->dmFormName won't have a valid form name for custom page size (see
            // BValidateDevmodeFormFields()). VOptionsToDevmodeFields() knows to handle that.
            //

            if ((pci->pdm->dmFields & DM_FORMNAME) &&
                (pForm = MyGetForm(pci->hPrinter, pci->pdm->dmFormName, 1)) &&
                !BFormSupportedOnPrinter(pci, pForm, &dwOptionIndexNew))
            {
                bUpdateFormField = TRUE;
            }

            MemFree(pForm);
        }

        VOptionsToDevmodeFields(pci, bUpdateFormField);
    }

    if (BUpdateUIInfo(pci))
    {
        //
        // Set the flag to indicate we are within the property sheet session. This flag will
        // be used by new helper function interface to determine whether the helper function
        // is available or not.
        //

        pci->dwFlags |= FLAG_PROPSHEET_SESSION;

        return pUiData;
    }


fill_uidata_err:

    ERR(("PFillUiData failed: %d\n", GetLastError()));
    VFreeUiData(pUiData);
    return NULL;
}



PTSTR
PtstrDuplicateStringFromHeap(
    IN PTSTR    ptstrSrc,
    IN HANDLE   hHeap
    )

/*++

Routine Description:

    Duplicate a Unicode string

Arguments:

    pwstrUnicodeString - Pointer to the input Unicode string
    hHeap - Handle to a heap from which to allocate memory

Return Value:

    Pointer to the resulting Unicode string
    NULL if there is an error

--*/

{
    PTSTR   ptstrDest;
    INT     iSize;

    if (ptstrSrc == NULL)
        return NULL;

    iSize = SIZE_OF_STRING(ptstrSrc);

    if (ptstrDest = HEAPALLOC(hHeap, iSize))
        CopyMemory(ptstrDest, ptstrSrc, iSize);
    else
        ERR(("Couldn't duplicate string: %ws\n", ptstrSrc));

    return ptstrDest;
}



POPTITEM
PFindOptItemWithKeyword(
    IN  PUIDATA pUiData,
    IN  PCSTR   pKeywordName
    )

/*++

Routine Description:

    Find the OPTITEM with UserData's pKeywordName matching given keyword name

Arguments:

    pUiData - Points to UIDATA structure
    pKeywordName - Specifies the keyword name needs to be matched

Return Value:

    Pointer to the specified OPTITEM, NULL if no such item is found

--*/

{
    DWORD       dwCount;
    POPTITEM    pOptItem;

    ASSERT(VALIDUIDATA(pUiData));

    pOptItem = pUiData->pDrvOptItem;
    dwCount = pUiData->dwDrvOptItem;

    while (dwCount--)
    {
        if (((PUSERDATA)pOptItem->UserData)->pKeyWordName != NULL &&
            strcmp(((PUSERDATA)pOptItem->UserData)->pKeyWordName, pKeywordName) == EQUAL_STRING)
            return pOptItem;

        pOptItem++;
    }

    return NULL;
}




POPTITEM
PFindOptItemWithUserData(
    IN  PUIDATA pUiData,
    IN  DWORD   UserData
    )

/*++

Routine Description:

    Find the OPTITEM containing the specified UserData value

Arguments:

    pUiData - Points to UIDATA structure
    UserData - Specifies the interested UserData value

Return Value:

    Pointer to the specified OPTITEM, NULL if no such item is found

--*/

{
    DWORD       dwCount;
    POPTITEM    pOptItem;

    ASSERT(VALIDUIDATA(pUiData));

    pOptItem = pUiData->pDrvOptItem;
    dwCount = pUiData->dwDrvOptItem;

    while (dwCount--)
    {
        if (GETUSERDATAITEM(pOptItem->UserData) == UserData)
            return pOptItem;

        pOptItem++;
    }

    return NULL;
}

#ifndef WINNT_40

VOID
VNotifyDSOfUpdate(
    IN  HANDLE  hPrinter
    )

/*++

Routine Description:

    Call SetPrinter to notify the DS of the update of driver attribute

Arguments:

    hPrinter - Handle to the current printer

Return Value:

    NONE

--*/
{

    PRINTER_INFO_7  PrinterInfo7;

    ZeroMemory(&PrinterInfo7, sizeof(PrinterInfo7));
    PrinterInfo7.dwAction = DSPRINT_UPDATE;

    //
    // Comments from spooler DS developer:
    //
    // In the beginning, SetPrinter did not fail with ERROR_IO_PENDING.
    // Then it was modified and would occasionally fail with this error.
    // Finally, for performance reasons, it was modified again and now
    // almost always fails with this error (there are situations where
    // it will succeed).
    //

    if (!SetPrinter(hPrinter, 7, (PBYTE) &PrinterInfo7, 0) &&
        (GetLastError() != ERROR_IO_PENDING))
    {
        WARNING(("Couldn't publish printer info into DS\n"));
    }

}
#endif


HANDLE HCreateHeapForCI()
{
    HANDLE hHeap;

    if(!(hHeap = HeapCreate(0, 8192, 0)))
    {
        ERR(("CreateHeap failed: %d\n", GetLastError()));
    }

    return hHeap;
}


#ifndef WINNT_40
BOOL
DrvQueryColorProfile(
    HANDLE      hPrinter,
    PDEVMODEW   pdmSrc,
    ULONG       ulQueryMode,
    VOID       *pvProfileData,
    ULONG      *pcbProfileData,
    FLONG      *pflProfileData
    )

/*++

Routine Description:

   Call the OEM to let them determine the default color profile.

Arguments:

    hPrinter - Handle to printer
    pdmSrc - Input devmode
    ulQueryMode - query mode
    pvProfileData - Buffer for profile data
    pcbProfileData - Size of profile data buffer
    pflProfileData - other profile info

Return Value:

    TRUE for success and FALSE for failure

--*/

{
    PFN_OEMQueryColorProfile pfnQueryColorProfile;
    PCOMMONINFO              pci;
    BOOL                     bRc = FALSE;


    if (! (pci = PLoadCommonInfo(hPrinter, NULL, 0)) ||
        ! BFillCommonInfoDevmode(pci, NULL, pdmSrc) ||
        ! BCombineCommonInfoOptionsArray(pci))
    {
        WARNING(("Could not get PCI in DrvQueryColorProfile\n"));
        VFreeCommonInfo(pci);
        return FALSE;
    }

    VFixOptionsArrayWithDevmode(pci);

    (VOID) ResolveUIConflicts(pci->pRawData,
                              pci->pCombinedOptions,
                              MAX_COMBINED_OPTIONS,
                              MODE_DOCUMENT_STICKY);

    VOptionsToDevmodeFields(pci, TRUE);

    if (! BUpdateUIInfo(pci))
    {
        VFreeCommonInfo(pci);
        return FALSE;
    }

    //
    // If OEM plugin returns a profile, give it back, otherwise return FALSE
    //

    FOREACH_OEMPLUGIN_LOOP(pci)

        if (HAS_COM_INTERFACE(pOemEntry))
        {
            HRESULT hr;

            hr = HComOEMQUeryColorProfile(pOemEntry,
                                    hPrinter,
                                    &pci->oemuiobj,
                                    pci->pdm,
                                    pOemEntry->pOEMDM,
                                    ulQueryMode,
                                    pvProfileData,
                                    pcbProfileData,
                                    pflProfileData
                                    );

            if (hr == E_NOTIMPL)
                continue;

            bRc = SUCCEEDED(hr);
        }
        else
        {
            pfnQueryColorProfile = GET_OEM_ENTRYPOINT(pOemEntry, OEMQueryColorProfile);

            if (pfnQueryColorProfile)
            {
                bRc = (*pfnQueryColorProfile)(hPrinter,
                                    &pci->oemuiobj,
                                    pci->pdm,
                                    pOemEntry->pOEMDM,
                                    ulQueryMode,
                                    pvProfileData,
                                    pcbProfileData,
                                    pflProfileData
                                    );
            }
        }

        if (bRc)
            break;

    END_OEMPLUGIN_LOOP

    VFreeCommonInfo(pci);

    return bRc;
}

#else // ifndef WINNT_40
BOOL
DrvQueryColorProfile(
    HANDLE      hPrinter,
    PDEVMODEW   pdmSrc,
    ULONG       ulQueryMode,
    VOID       *pvProfileData,
    ULONG      *pcbProfileData,
    FLONG      *pflProfileData
    )

/*++

Routine Description:

   Call the OEM to let them determine the default color profile.

Arguments:

    hPrinter - Handle to printer
    pdmSrc - Input devmode
    ulQueryMode - query mode
    pvProfileData - Buffer for profile data
    pcbProfileData - Size of profile data buffer
    pflProfileData - other profile info

Return Value:

    TRUE for success and FALSE for failure

--*/

{
    return TRUE;
}
#endif // WINNT_40
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\driverui\initdll.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    intidll.c

Abstract:

    This file handles the DLLInitialize spooler API

Environment:

    Win32 subsystem, DriverUI module, user mode

Revision History:

    07/17/96 -amandan-
        Created it.

--*/


#include "precomp.h"

//
// Global instance handle and critical section
//

HINSTANCE ghInstance;
CRITICAL_SECTION gCriticalSection;


BOOL WINAPI
DllMain(
    HANDLE      hModule,
    ULONG       ulReason,
    PCONTEXT    pContext
    )

/*++

Routine Description:

    This function is called when the system loads/unloads the DriverUI module.
    At DLL_PROCESS_ATTACH, InitializeCriticalSection is called to initialize
    the critical section objects.
    At DLL_PROCESS_DETACH, DeleteCriticalSection is called to release the
    critical section objects.

Arguments:

    hModule     handle to DLL module
    ulReason    reason for the call
    pContext    pointer to context (not used by us)


Return Value:

    TRUE if DLL is initialized successfully, FALSE otherwise.

--*/

{
    WCHAR   wchDllName[MAX_PATH];
    BOOL    bKeepDllLoaded = FALSE;

    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:

        #if DBG

        if (GetEnvironmentVariable(TEXT("UnloadDriverUiDll"), NULL, 0))
            bKeepDllLoaded = FALSE;

        #endif

        //
        // Keep our driver UI dll always loaded in memory
        //

        if (bKeepDllLoaded && GetModuleFileName(hModule, wchDllName, MAX_PATH))
            LoadLibrary(wchDllName);

        ghInstance = hModule;
        InitializeCriticalSection(&gCriticalSection);
        break;

    case DLL_PROCESS_DETACH:

        DeleteCriticalSection(&gCriticalSection);
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\driverui\fontsub.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    fontsub.c

Abstract:

    Function for handling TrueType font substitution dialog

[Environment:]

    Win32 subsystem, PostScript driver UI

[Notes:]

Revision History:

    02/10/97 -davidx-
        Consistent handling of common printer info.

    09/18/96 - amandan-
        Modified for common binary data and UI

    08/29/95 -davidx-
        Created it.

--*/

#include "precomp.h"


VOID
VSetupTrueTypeFontMappings(
    IN PUIDATA  pUiData
    )

/*++

Routine Description:

    Initialize the font substitution items with the settings from
    current font substitution table.

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    NONE

--*/

{
    POPTITEM    pOptItem;
    POPTPARAM   pOptParam;
    DWORD       dwOptItem;
    PWSTR       pTTSubstTable;

    //
    // Get the current font substitution table
    //

    if ((pTTSubstTable = PGetTTSubstTable(pUiData->ci.hPrinter, NULL)) == NULL &&
        (pTTSubstTable = GET_DEFAULT_FONTSUB_TABLE(&pUiData->ci, pUiData->ci.pUIInfo)) == NULL)
    {
        WARNING(("Font substitution table is not available\n"));
        return;
    }

    //
    // For each TrueType font, check if there is a device font mapped to it.
    // If there is, find the index of the device font in the selection list.
    //

    pOptItem = pUiData->pTTFontItems;
    dwOptItem = pUiData->dwTTFontItem;

    while (dwOptItem--) 
    {
        DWORD   dwOptParam, dwIndex;
        LPCTSTR pDevFontName;

        ASSERT(ISFONTSUBSTITEM(pOptItem->UserData));

        pOptItem->Sel = 0;
        pDevFontName = PtstrSearchTTSubstTable(pTTSubstTable, pOptItem->pName);

        //
        // Check if we found a match
        //

        if (pDevFontName != NULL && *pDevFontName != NUL)
        {

            //
            // Get the total substitution font list
            //
            
            dwOptParam = pOptItem->pOptType->Count;
            pOptParam = pOptItem->pOptType->pOptParam;

            //
            // Skip the first device font name in the list
            // which should always be "Download as Soft Font".
            //

            for (dwIndex=1; dwIndex < dwOptParam; dwIndex++) 
            {
                if (_wcsicmp(pDevFontName, pOptParam[dwIndex].pData) == EQUAL_STRING)
                {
                    pOptItem->Sel = dwIndex;
                    break;
                }
            }
        }

        pOptItem++;
    }

    //
    // Remember to free the memory occupied by the substitution
    // table after we're done with it.
    //

    FREE_DEFAULT_FONTSUB_TABLE(pTTSubstTable);
}



int __cdecl
ICompareOptParam(
    const void *p1,
    const void *p2
    )

{
    return _wcsicmp(((POPTPARAM) p1)->pData, ((POPTPARAM) p2)->pData);
}


POPTTYPE
PFillDevFontOptType(
    IN PUIDATA  pUiData
    )

/*++

Routine Description:

    Initialize an OPTTYPE structure to hold information
    about the list of device fonts supported by a printer

Arguments:

    pUiData - Pointer to UIDATA structure

Return Value:

    Pointer to an OPTTYPE structure
    NULL if there is an error

--*/

{
    POPTTYPE    pOptType;
    POPTPARAM   pOptParam;
    HDC         hdc;
    DWORD       dwCount, dwIndex;
    INT         iSize;
    PWSTR       pwstrFontNames, pwstr;

    //
    // Get the list of printer device font names
    //

    dwCount = 0;

    if ((hdc = CreateIC(NULL, pUiData->ci.pPrinterName, NULL, NULL)) &&
        (iSize = _IListDevFontNames(hdc, NULL, 0)) > 0 &&
        (pwstrFontNames = HEAPALLOC(pUiData->ci.hHeap, iSize)) &&
        (iSize == _IListDevFontNames(hdc, pwstrFontNames, iSize)))
    {
        //
        // Count the number of device font names
        //

        for (pwstr=pwstrFontNames; *pwstr; pwstr += wcslen(pwstr)+1)
            dwCount++;
    }
    else
    {
        ERR(("Couldn't enumerate printer device fonts\n"));
    }

    if (hdc)
        DeleteDC(hdc);

    //
    // Generate an OPTTYPE structure for device font list
    //

    pOptType = HEAPALLOC(pUiData->ci.hHeap, sizeof(OPTTYPE));
    pOptParam = HEAPALLOC(pUiData->ci.hHeap, sizeof(OPTPARAM) * (dwCount+1));

    if (pOptType == NULL || pOptParam == NULL)
    {
        ERR(("Memory allocation failed\n"));
        return NULL;
    }

    pOptType->cbSize = sizeof(OPTTYPE);
    pOptType->Count = (WORD) (dwCount+1);
    pOptType->Type = TVOT_LISTBOX;
    pOptType->pOptParam = pOptParam;

    //
    // Initialize OPTPARAM structures.
    // The first item is always "Download as Soft Font".
    //

    for (dwIndex=0; dwIndex <= dwCount; dwIndex++)
        pOptParam[dwIndex].cbSize = sizeof(OPTPARAM);

    pOptParam->pData = (PWSTR) IDS_DOWNLOAD_AS_SOFTFONT;
    pOptParam++;

    // hack to get around a compiler bug

    dwCount++;
    dwCount--;

    for (dwIndex=0, pwstr=pwstrFontNames; dwIndex < dwCount; dwIndex++)
    {
        pOptParam[dwIndex].pData = pwstr;
        pwstr += wcslen(pwstr) + 1;
    }

    //
    // Sort device font names into alphabetical order;
    // Hide any duplicate device font names as well.
    //

    qsort(pOptParam, dwCount, sizeof(OPTPARAM), ICompareOptParam);

    for (dwIndex=1; dwIndex < dwCount; dwIndex++)
    {
        if (_wcsicmp(pOptParam[dwIndex].pData, pOptParam[dwIndex-1].pData) == EQUAL_STRING)
            pOptParam[dwIndex].Flags |= OPTPF_HIDE;
    }

    return pOptType;
}



//
// Data structures and functions for enumerating printer device fonts
//

typedef struct _ENUMTTFONT {

    DWORD       dwCount;
    POPTITEM    pOptItem;
    POPTTYPE    pOptType;
    HANDLE      hHeap;
    WCHAR       awchLastFontName[LF_FACESIZE];

} ENUMTTFONT, *PENUMTTFONT;

INT CALLBACK
EnumTTFontProc(
    ENUMLOGFONT    *pelf,
    NEWTEXTMETRIC  *pntm,
    INT             FontType,
    LPARAM          lParam
    )

{
    PENUMTTFONT pEnumData;
    PTSTR       pFontName;
    PTSTR       pFamilyName;

    //
    // We only care about the TrueType fonts.
    //

    if (! (FontType & TRUETYPE_FONTTYPE))
        return 1;

    pEnumData = (PENUMTTFONT) lParam;
    pFamilyName = pelf->elfLogFont.lfFaceName;

    if (_tcscmp(pFamilyName, pEnumData->awchLastFontName) == EQUAL_STRING)
        return 1;

    CopyString(pEnumData->awchLastFontName, pFamilyName, LF_FACESIZE);
    pEnumData->dwCount++;

    if (pEnumData->pOptItem)
    {
        pFontName = PtstrDuplicateStringFromHeap(pFamilyName, pEnumData->hHeap);

        if (pFontName == NULL)
            return 0;
        
        FILLOPTITEM(pEnumData->pOptItem,
                    pEnumData->pOptType,
                    pFontName,
                    0,
                    TVITEM_LEVEL2,
                    DMPUB_NONE,
                    FONT_SUBST_ITEM,
                    HELP_INDEX_TTTODEV);

        pEnumData->pOptItem++;
    }

    return 1;
}


int __cdecl
ICompareOptItem(
    const void *p1,
    const void *p2
    )

{
    return _wcsicmp(((POPTITEM) p1)->pName, ((POPTITEM) p2)->pName);
}


BOOL
BPackItemFontSubstTable(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack Font Substitution options

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error.

--*/

{
    ENUMTTFONT  EnumData;
    POPTITEM    pOptItem;
    HDC         hdc;
    INT         iResult;

    //
    // If the printer doesn't support font-substitution,
    // then simply return success here.
    //

    if (pUiData->ci.pUIInfo->dwFontSubCount == 0)
        return TRUE;

    //
    // Create a screen IC
    //

    if ((hdc = CreateIC(TEXT("DISPLAY"), NULL, NULL, NULL)) == NULL)
    {
        ERR(("Cannot create screen IC\n"));
        return FALSE;
    }

    //
    // Font substitution table
    //     TrueType font <-> Device font
    //     ....
    //
    // Group Header for Font Substitution Table
    //

    pOptItem = pUiData->pOptItem;

    VPackOptItemGroupHeader(
            pUiData,
            IDS_FONTSUB_TABLE,
            IDI_CPSUI_FONTSUB,
            HELP_INDEX_FONTSUB_TABLE);

    ZeroMemory(&EnumData, sizeof(EnumData));
    EnumData.hHeap = pUiData->ci.hHeap;

    if (pOptItem == NULL)
    {
        //
        // Count the number of TrueType fonts
        //

        iResult = EnumFontFamilies(hdc,
                                   NULL,
                                   (FONTENUMPROC) EnumTTFontProc,
                                   (LPARAM) &EnumData);
    }
    else
    {
        //
        // Collapse the group header
        //

        pOptItem->Flags |= OPTIF_COLLAPSE;

        pUiData->pTTFontItems = pUiData->pOptItem;
        EnumData.pOptItem = pUiData->pOptItem;

        //
        // Get the list of printer device fonts
        //

        EnumData.pOptType = PFillDevFontOptType(pUiData);

        if (EnumData.pOptType == NULL)
        {
            ERR(("PFillDevFontOptType failed\n"));
            iResult = 0;
        }
        else
        {
            //
            // Enumerate the list of TrueType fonts
            //

            iResult = EnumFontFamilies(hdc,
                                       NULL,
                                       (FONTENUMPROC) EnumTTFontProc,
                                       (LPARAM) &EnumData);

            if (iResult == 0 || EnumData.dwCount != pUiData->dwTTFontItem)
            {
                ERR(("Inconsistent number of TrueType fonts\n"));
                iResult = 0;
            }
            else
            {
                //
                // Sort the TrueType font items alphabetically
                //

                qsort(pUiData->pTTFontItems,
                      pUiData->dwTTFontItem,
                      sizeof(OPTITEM),
                      ICompareOptItem);
            }
        }
    }

    DeleteDC(hdc);

    if (iResult == 0)
    {
        ERR(("Failed to enumerate TrueType fonts\n"));
        return FALSE;
    }

    pUiData->dwTTFontItem = EnumData.dwCount;
    pUiData->dwOptItem += pUiData->dwTTFontItem;

    if (pUiData->pOptItem)
    {
        pUiData->pOptItem += pUiData->dwTTFontItem;
        VSetupTrueTypeFontMappings(pUiData);
    }

    return TRUE;
}



DWORD
DwCollectTrueTypeMappings(
    IN POPTITEM pOptItem,
    IN DWORD    dwOptItem,
    OUT PWSTR   pwstrTable
    )

/*++

Routine Description:

    Assemble TrueType to device font mappings into a table

Arguments:

    pOptItem - Pointer to an array of OPTITEMs
    cOptItem - Number of OPTITEMs
    pwstrTable - Pointer to memory buffer for storing the table.
        NULL if we're only interested in table size.

Return Value:

    Size of the table bytes, 0 if there is an error.

--*/

{
    DWORD       dwChars = 0;
    INT         iLength;
    POPTPARAM   pOptParam;

    while (dwOptItem--) 
    {
        ASSERT(ISFONTSUBSTITEM(pOptItem->UserData));

        if (pOptItem->Sel > 0) 
        {
            iLength = wcslen(pOptItem->pName) + 1;
            dwChars += iLength;
    
            if (pwstrTable != NULL) 
            {
                CopyMemory(pwstrTable, pOptItem->pName, iLength*sizeof(WCHAR));
                pwstrTable += iLength;
            }

            pOptParam = pOptItem->pOptType->pOptParam + pOptItem->Sel;

            iLength = wcslen(pOptParam->pData) + 1;
            dwChars += iLength;

            if (pwstrTable != NULL) 
            {
                CopyMemory(pwstrTable, pOptParam->pData, iLength*sizeof(WCHAR));
                pwstrTable += iLength;
            }
        }
        
        pOptItem++;
    }

    //
    // Append a NUL character at the end of the table
    //

    dwChars++;

    if (pwstrTable != NULL)
        *pwstrTable = NUL;

    //
    // Return the table size in bytes
    //

    return dwChars * sizeof(WCHAR);
}



BOOL
BUnpackItemFontSubstTable(
    IN PUIDATA  pUiData
    )

/*++

Routine Description:

    Extract substitution table from treeview items

Arguments:

    pUiData - Pointer to UIDATA structure

Return Value:

    TRUE if successful, FALSE otherwise

--*/

{
    DWORD       dwTableSize;
    PWSTR       pwstrTable = NULL;
    POPTITEM    pOptItem = pUiData->pTTFontItems;
    DWORD       dwOptItem = pUiData->dwTTFontItem;

    //
    // Check if any changes were made to font-substitution items
    //

    if (! BOptItemSelectionsChanged(pOptItem, dwOptItem))
        return TRUE;

    //
    // Figure out how much memory we need to save the font substitution table
    // Assemble the font substitution table
    // Save the TrueType font substitution table to registry
    //

    if ((dwTableSize = DwCollectTrueTypeMappings(pOptItem, dwOptItem, NULL)) == 0 ||
        (pwstrTable = MemAlloc(dwTableSize)) == NULL ||
        (dwTableSize != DwCollectTrueTypeMappings(pOptItem, dwOptItem, pwstrTable)) ||
        !BSaveTTSubstTable(pUiData->ci.hPrinter, pwstrTable, dwTableSize))
    {
        ERR(("Couldn't save font substitution table\n"));
        MemFree(pwstrTable);
        return FALSE;
    }

    MemFree(pwstrTable);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\driverui\intfui.cxx ===
/*++

Copyright (c) 1996-1997 Microsoft Corporation

Module Name:

    intfui.cpp

Abstract:

    Interface implementation of Windows NT driver UI OEM plugins

Environment:

    Windows NT driver UI

Revision History:


--*/

#define INITGUID
#include "precomp.h"

//
// List all of the supported OEM UI plugin interface IIDs from the
// latest to the oldest, that's the order our driver will QI OEM
// plugin for its supported interface.
//
// DON"T remove the last NULL terminator.
//

static const GUID *PrintOemUI_IIDs[] = {
    &IID_IPrintOemUI2,
    &IID_IPrintOemUI,
    NULL
};

#define CALL_INTERFACE(pOemEntry, MethodName, args) \
    if (IsEqualGUID(&(pOemEntry)->iidIntfOem, &IID_IPrintOemUI)) \
    { \
        return ((IPrintOemUI *)(pOemEntry)->pIntfOem)->MethodName args; \
    } \
    else if (IsEqualGUID(&(pOemEntry)->iidIntfOem, &IID_IPrintOemUI2)) \
    { \
        return ((IPrintOemUI2 *)(pOemEntry)->pIntfOem)->MethodName args; \
    } \
    return E_NOINTERFACE;

#define CALL_INTERFACE2(pOemEntry, MethodName, args) \
    if (IsEqualGUID(&(pOemEntry)->iidIntfOem, &IID_IPrintOemUI2)) \
    { \
        return ((IPrintOemUI2 *)(pOemEntry)->pIntfOem)->MethodName args; \
    } \
    return E_NOINTERFACE;

#ifdef PSCRIPT

#define VERIFY_OEMUIOBJ(poemuiobj) \
    if (!poemuiobj || (((PCOMMONINFO)poemuiobj)->pvStartSign != poemuiobj)) \
        return E_INVALIDARG;

#define VERIFY_UIDATA(poemuiobj) \
    if (!VALIDUIDATA((PUIDATA)poemuiobj)) \
        return E_INVALIDARG;

#endif // PSCRIPT

//
// Core driver helper function interfaces
//

//
// The first driver UI herlper interface has version number 1. Any new
// helper interface version number is 1 plus the previous version number.
// So we need to increase MAX_UI_HELPER_INTF_VER by 1 every time we introduce
// a new UI plugin helper interface.
//

#ifdef PSCRIPT

#define MAX_UI_HELPER_INTF_VER     2

#else

#define MAX_UI_HELPER_INTF_VER     1

#endif // PSCRIPT

//
// CPrintOemDriverUI is the object containing the UI helper functions
//

class CPrintOemDriverUI : public IPrintOemDriverUI
{
    //
    // IUnknown implementation
    //

    virtual STDMETHODIMP QueryInterface(const IID& iid, void** ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    //
    // Interface IPrintOemDriverUI implementation
    //

    virtual STDMETHODIMP DrvGetDriverSetting( PVOID   pci,
                                              PCSTR   pFeature,
                                              PVOID   pOutput,
                                              DWORD   cbSize,
                                              PDWORD  pcbNeeded,
                                              PDWORD  pdwOptionsReturned);

    virtual STDMETHODIMP DrvUpgradeRegistrySetting( HANDLE hPrinter,
                                                    PCSTR   pFeature,
                                                    PCSTR   pOption);


    virtual STDMETHODIMP DrvUpdateUISetting ( PVOID    pci,
                                              PVOID    pOptItem,
                                              DWORD    dwPreviousSelection,
                                              DWORD    dwMode);

public:

    //
    // Constructor
    //

    CPrintOemDriverUI() : m_cRef(0) {}

private:

    long m_cRef;
};


STDMETHODIMP CPrintOemDriverUI::QueryInterface(const IID& iid, void** ppv)
{
    if (iid == IID_IUnknown || iid == IID_IPrintOemDriverUI)
    {
        *ppv = static_cast<IPrintOemDriverUI *>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CPrintOemDriverUI::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CPrintOemDriverUI::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

STDMETHODIMP CPrintOemDriverUI::DrvGetDriverSetting(PVOID    pci,
                                                    PCSTR    pFeature,
                                                    PVOID    pOutput,
                                                    DWORD    cbSize,
                                                    PDWORD   pcbNeeded,
                                                    PDWORD   pdwOptionsReturned)
{
    if (BGetDriverSettingForOEM((PCOMMONINFO)pci,
                                pFeature,
                                pOutput,
                                cbSize,
                                pcbNeeded,
                                pdwOptionsReturned))
        return S_OK;

    return E_FAIL;
}

STDMETHODIMP  CPrintOemDriverUI::DrvUpgradeRegistrySetting(HANDLE hPrinter,
                                                           PCSTR  pFeature,
                                                           PCSTR  pOption)
{
    if (BUpgradeRegistrySettingForOEM(hPrinter,
                                     pFeature,
                                     pOption))
        return S_OK;

    return E_FAIL;
}

STDMETHODIMP CPrintOemDriverUI::DrvUpdateUISetting(PVOID pci,
                                                   PVOID pOptItem,
                                                   DWORD dwPreviousSelection,
                                                   DWORD dwMode)
{
    if (BUpdateUISettingForOEM((PCOMMONINFO)pci,
                                pOptItem,
                                dwPreviousSelection,
                                dwMode))
        return S_OK;

    return E_FAIL;
}

#ifdef PSCRIPT

//
// CPrintCoreUI2 is the object containing the new UI helper functions
//

class CPrintCoreUI2 : public IPrintCoreUI2
{
    //
    // IUnknown implementation
    //

    virtual STDMETHODIMP QueryInterface(const IID& iid, void** ppv);
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();

    //
    // IPrintOemDriverUI methods implementation
    //

    virtual STDMETHODIMP DrvGetDriverSetting(PVOID   pci,
                                             PCSTR   pFeature,
                                             PVOID   pOutput,
                                             DWORD   cbSize,
                                             PDWORD  pcbNeeded,
                                             PDWORD  pdwOptionsReturned);

    virtual STDMETHODIMP DrvUpgradeRegistrySetting(HANDLE  hPrinter,
                                                   PCSTR   pFeature,
                                                   PCSTR   pOption);


    virtual STDMETHODIMP DrvUpdateUISetting(PVOID  pci,
                                            PVOID  pOptItem,
                                            DWORD  dwPreviousSelection,
                                            DWORD  dwMode);
    //
    // IPrintCoreUI2 methods implementation
    //

    virtual STDMETHODIMP GetOptions(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pmszFeaturesRequested,
                           IN  DWORD      cbIn,
                           OUT PSTR       pmszFeatureOptionBuf,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded);

    virtual STDMETHODIMP SetOptions(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pmszFeatureOptionBuf,
                           IN  DWORD      cbIn,
                           OUT PDWORD     pdwResult);

    virtual STDMETHODIMP EnumConstrainedOptions(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pszFeatureKeyword,
                           OUT PSTR       pmszConstrainedOptionList,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded);

    virtual STDMETHODIMP WhyConstrained(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pszFeatureKeyword,
                           IN  PCSTR      pszOptionKeyword,
                           OUT PSTR       pmszReasonList,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded);

    virtual STDMETHODIMP GetGlobalAttribute(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pszAttribute,
                           OUT PDWORD     pdwDataType,
                           OUT PBYTE      pbData,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded);

    virtual STDMETHODIMP GetFeatureAttribute(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pszFeatureKeyword,
                           IN  PCSTR      pszAttribute,
                           OUT PDWORD     pdwDataType,
                           OUT PBYTE      pbData,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded);

    virtual STDMETHODIMP GetOptionAttribute(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pszFeatureKeyword,
                           IN  PCSTR      pszOptionKeyword,
                           IN  PCSTR      pszAttribute,
                           OUT PDWORD     pdwDataType,
                           OUT PBYTE      pbData,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded);

    virtual STDMETHODIMP EnumFeatures(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           OUT PSTR       pmszFeatureList,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded);

    virtual STDMETHODIMP EnumOptions(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pszFeatureKeyword,
                           OUT PSTR       pmszOptionList,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded);

    virtual STDMETHODIMP QuerySimulationSupport(
                           IN  HANDLE  hPrinter,
                           IN  DWORD   dwLevel,
                           OUT PBYTE   pCaps,
                           IN  DWORD   cbSize,
                           OUT PDWORD  pcbNeeded);

public:

    //
    // Constructor
    //

    CPrintCoreUI2() : m_cRef(0) {}

private:

    long m_cRef;
};


STDMETHODIMP CPrintCoreUI2::QueryInterface(const IID& iid, void** ppv)
{
    if (iid == IID_IUnknown || iid == IID_IPrintCoreUI2)
    {
        *ppv = static_cast<IPrintCoreUI2 *>(this);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CPrintCoreUI2::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}


STDMETHODIMP_(ULONG) CPrintCoreUI2::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}


STDMETHODIMP CPrintCoreUI2::DrvGetDriverSetting(PVOID   pci,
                                                PCSTR   pFeature,
                                                PVOID   pOutput,
                                                DWORD   cbSize,
                                                PDWORD  pcbNeeded,
                                                PDWORD  pdwOptionsReturned)
{
    VERIFY_OEMUIOBJ((POEMUIOBJ)pci)

    //
    // This function is only supported for UI plugins that DON'T fully replace
    // core driver's standard UI. It should only be called by the UI plugin's
    // DocumentPropertySheets, DevicePropertySheets and their property sheet
    // callback functions.
    //

    if (!IS_WITHIN_PROPSHEET_SESSION((PCOMMONINFO)pci))
    {
        ERR(("DrvGetDriverSetting called outside of property sheet session. E_NOTIMPL returned.\n"));
        return E_NOTIMPL;
    }

    VERIFY_UIDATA((POEMUIOBJ)pci)

    if (IS_HIDING_STD_UI((PUIDATA)pci))
    {
        ERR(("DrvGetDriverSetting called by full UI replacing plugin. E_NOTIMPL returned.\n"));
        return E_NOTIMPL;
    }

    if (BGetDriverSettingForOEM((PCOMMONINFO)pci,
                                pFeature,
                                pOutput,
                                cbSize,
                                pcbNeeded,
                                pdwOptionsReturned))
    {
        return S_OK;
    }

    return E_FAIL;
}


STDMETHODIMP CPrintCoreUI2::DrvUpgradeRegistrySetting(HANDLE hPrinter,
                                                      PCSTR  pFeature,
                                                      PCSTR  pOption)
{
    if (BUpgradeRegistrySettingForOEM(hPrinter,
                                     pFeature,
                                     pOption))
    {
        return S_OK;
    }

    return E_FAIL;
}


STDMETHODIMP CPrintCoreUI2::DrvUpdateUISetting(PVOID pci,
                                               PVOID pOptItem,
                                               DWORD dwPreviousSelection,
                                               DWORD dwMode)
{
    VERIFY_OEMUIOBJ((POEMUIOBJ)pci)

    //
    // This function is only supported for UI plugins that DON'T fully replace
    // core driver's standard UI. It should only be called by the UI plugin's
    // DocumentPropertySheets, DevicePropertySheets and their property sheet
    // callback functions.
    //

    if (!IS_WITHIN_PROPSHEET_SESSION((PCOMMONINFO)pci))
    {
        ERR(("DrvUpdateUISetting called outside of property sheet session. E_NOTIMPL returned.\n"));
        return E_NOTIMPL;
    }

    VERIFY_UIDATA((POEMUIOBJ)pci)

    if (IS_HIDING_STD_UI((PUIDATA)pci))
    {
        ERR(("DrvUpdateUISetting called by full UI replacing plugin. E_NOTIMPL returned.\n"));
        return E_NOTIMPL;
    }

    if (BUpdateUISettingForOEM((PCOMMONINFO)pci,
                                pOptItem,
                                dwPreviousSelection,
                                dwMode))
    {
        return S_OK;
    }

    return E_FAIL;
}

/*++

Routine Name:

    GetOptions

Routine Description:

    get current driver settings for PPD features and driver synthesized features

Arguments:

    poemuiobj - pointer to driver context object
    dwFlags - flags for the get operation
    pmszFeaturesRequested - MULTI_SZ ASCII string containing feature keyword names
    cbin - size in bytes of the pmszFeaturesRequested string
    pmszFeatureOptionBuf - pointer to output data buffer to store feature settings
    cbSize - size in bytes of pmszFeatureOptionBuf buffer
    pcbNeeded - buffer size in bytes needed to output the feature settings

Return Value:

    E_NOTIMPL       if called when not supported
    E_INVALIDARG    if poemuiobj is invalid, or see HGetOptions

    S_OK
    E_OUTOFMEMORY
    E_FAIL          see HGetOptions

Last Error:

    None

--*/
STDMETHODIMP CPrintCoreUI2::GetOptions(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pmszFeaturesRequested,
                           IN  DWORD      cbIn,
                           OUT PSTR       pmszFeatureOptionBuf,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded)
{
    PCOMMONINFO  pci;

    VERIFY_OEMUIOBJ(poemuiobj)

    //
    // This function is only supported for UI plugins that fully replace
    // core driver's standard UI. It should only be called by the UI plugin's
    // DocumentPropertySheets, DevicePropertySheets and their property sheet
    // callback functions.
    //

    pci = (PCOMMONINFO)poemuiobj;

    if (!IS_WITHIN_PROPSHEET_SESSION(pci))
    {
        ERR(("GetOptions called outside of property sheet session. E_NOTIMPL returned.\n"));
        return E_NOTIMPL;
    }

    VERIFY_UIDATA(poemuiobj)

    if (!IS_HIDING_STD_UI((PUIDATA)pci))
    {
        ERR(("GetOptions called by non-full UI replacing plugin. E_NOTIMPL returned.\n"));
        return E_NOTIMPL;
    }

    #ifdef PSCRIPT

    return HGetOptions(pci->hPrinter,
                       pci->pInfoHeader,
                       pci->pCombinedOptions,
                       pci->pdm,
                       pci->pPrinterData,
                       dwFlags,
                       pmszFeaturesRequested,
                       cbIn,
                       pmszFeatureOptionBuf,
                       cbSize,
                       pcbNeeded,
                       ((PUIDATA)pci)->iMode == MODE_PRINTER_STICKY ? TRUE : FALSE);

    #else

    return E_NOTIMPL;

    #endif // PSCRIPT
}

/*++

Routine Name:

    SetOptions

Routine Description:

    set new driver settings for PPD features and driver synthesized features

Arguments:

    poemuiobj - pointer to driver context object
    dwFlags - flags for the set operation. This should be one of following:

                  SETOPTIONS_FLAG_RESOLVE_CONFLICT
                  SETOPTIONS_FLAG_KEEP_CONFLICT

    pmszFeatureOptionBuf - MULTI_SZ ASCII string containing new settings'
                           feature/option keyword pairs
    cbin - size in bytes of the pmszFeatureOptionBuf string
    pdwResult - pointer to the DWORD that will store the result of set operation.
                The result will be one of following:

                  SETOPTIONS_RESULT_NO_CONFLICT
                  SETOPTIONS_RESULT_CONFLICT_RESOLVED
                  SETOPTIONS_RESULT_CONFLICT_REMAINED

Return Value:

    S_OK            if the set operation succeeds
    E_NOTIMPL       if called when not supported
    E_INVALIDARG    if poemuiobj is invalid, or see HSetOptions
    E_FAIL          see HSetOptions

Last Error:

    None

--*/
STDMETHODIMP CPrintCoreUI2::SetOptions(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pmszFeatureOptionBuf,
                           IN  DWORD      cbIn,
                           OUT PDWORD     pdwResult)
{
    VERIFY_OEMUIOBJ(poemuiobj)

    //
    // This function is only supported for UI plugins that fully replace
    // core driver's standard UI. It should only be called by the UI plugin's
    // DocumentPropertySheets, DevicePropertySheets and their property sheet
    // callback functions.
    //

    if (!IS_WITHIN_PROPSHEET_SESSION((PCOMMONINFO)poemuiobj))
    {
        ERR(("SetOptions called outside of property sheet session. E_NOTIMPL returned.\n"));
        return E_NOTIMPL;
    }

    VERIFY_UIDATA(poemuiobj)

    if (!IS_HIDING_STD_UI((PUIDATA)poemuiobj))
    {
        ERR(("SetOptions called by non-full UI replacing plugin. E_NOTIMPL returned.\n"));
        return E_NOTIMPL;
    }

    #ifdef PSCRIPT

    return HSetOptions(poemuiobj,
                       dwFlags,
                       pmszFeatureOptionBuf,
                       cbIn,
                       pdwResult);

    #else

    return E_NOTIMPL;

    #endif // PSCRIPT
}

/*++

Routine Name:

    EnumConstrainedOptions

Routine Description:

    enumerate the constrained option keyword name list in the specified feature

Arguments:

    poemuiobj - pointer to driver context object
    dwFlags - flags for the enumeration operation
    pszFeatureKeyword - feature keyword name
    pmszConstrainedOptionList - pointer to output data buffer
    cbSize - output data buffer size in bytes
    pcbNeeded - buffer size in bytes needed to store the output data

Return Value:

    E_NOTIMPL       if called when not supported
    E_INVALIDARG    if poemuiobj is invalid, or see HEnumConstrainedOptions

    S_OK
    E_OUTOFMEMORY
    E_FAIL          see HEnumConstrainedOptions

Last Error:

    None

--*/
STDMETHODIMP CPrintCoreUI2::EnumConstrainedOptions(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pszFeatureKeyword,
                           OUT PSTR       pmszConstrainedOptionList,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded)
{
    VERIFY_OEMUIOBJ(poemuiobj)

    //
    // This function is only supported for UI plugins that fully replace
    // core driver's standard UI. It should only be called by the UI plugin's
    // DocumentPropertySheets, DevicePropertySheets and their property sheet
    // callback functions.
    //

    if (!IS_WITHIN_PROPSHEET_SESSION((PCOMMONINFO)poemuiobj))
    {
        ERR(("EnumConstrainedOptions called outside of property sheet session. E_NOTIMPL returned.\n"));
        return E_NOTIMPL;
    }

    VERIFY_UIDATA(poemuiobj)

    if (!IS_HIDING_STD_UI((PUIDATA)poemuiobj))
    {
        ERR(("EnumConstrainedOptions called by non-full UI replacing plugin. E_NOTIMPL returned.\n"));
        return E_NOTIMPL;
    }

    #ifdef PSCRIPT

    return HEnumConstrainedOptions(poemuiobj,
                                   dwFlags,
                                   pszFeatureKeyword,
                                   pmszConstrainedOptionList,
                                   cbSize,
                                   pcbNeeded);

    #else

    return E_NOTIMPL;

    #endif // PSCRIPT
}

/*++

Routine Name:

    WhyConstrained

Routine Description:

    get feature/option keyword pair that constrains the given
    feature/option pair

Arguments:

    poemuiobj - pointer to driver context object
    dwFlags - flags for this operation
    pszFeatureKeyword - feature keyword name
    pszOptionKeyword - option keyword name
    pmszReasonList - pointer to output data buffer
    cbSize - output data buffer size in bytes
    pcbNeeded - buffer size in bytes needed to store the output data

Return Value:

    E_NOTIMPL       if called when not supported
    E_INVALIDARG    if poemuiobj is invalid, or see HWhyConstrained

    S_OK
    E_OUTOFMEMORY   see HWhyConstrained

Last Error:

    None

--*/
STDMETHODIMP CPrintCoreUI2::WhyConstrained(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pszFeatureKeyword,
                           IN  PCSTR      pszOptionKeyword,
                           OUT PSTR       pmszReasonList,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded)
{
    VERIFY_OEMUIOBJ(poemuiobj)

    //
    // This function is only supported for UI plugins that fully replace
    // core driver's standard UI. It should only be called by the UI plugin's
    // DocumentPropertySheets, DevicePropertySheets and their property sheet
    // callback functions.
    //

    if (!IS_WITHIN_PROPSHEET_SESSION((PCOMMONINFO)poemuiobj))
    {
        ERR(("WhyConstrained called outside of property sheet session. E_NOTIMPL returned.\n"));
        return E_NOTIMPL;
    }

    VERIFY_UIDATA(poemuiobj)

    if (!IS_HIDING_STD_UI((PUIDATA)poemuiobj))
    {
        ERR(("WhyConstrained called by non-full UI replacing plugin. E_NOTIMPL returned.\n"));
        return E_NOTIMPL;
    }

    #ifdef PSCRIPT

    return HWhyConstrained(poemuiobj,
                           dwFlags,
                           pszFeatureKeyword,
                           pszOptionKeyword,
                           pmszReasonList,
                           cbSize,
                           pcbNeeded);

    #else

    return E_NOTIMPL;

    #endif // PSCRIPT
}

/*++

Routine Name:

    GetGlobalAttribute

Routine Description:

    get PPD global attribute

Arguments:

    poemuiobj - pointer to driver context object
    dwFlags - flags for the attribute get operation
    pszAttribute - name of the global attribute
    pdwDataType - pointer to DWORD to store output data type
    pbData - pointer to output data buffer
    cbSize - output data buffer size in bytes
    pcbNeeded - buffer size in bytes needed to store the output data

Return Value:

    E_INVALIDARG    if poemuiobj is invalid, or see HGetGlobalAttribute

    S_OK
    E_OUTOFMEMORY   see HGetGlobalAttribute

Last Error:

    None

--*/
STDMETHODIMP CPrintCoreUI2::GetGlobalAttribute(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pszAttribute,
                           OUT PDWORD     pdwDataType,
                           OUT PBYTE      pbData,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded)
{
    VERIFY_OEMUIOBJ(poemuiobj)

    #ifdef PSCRIPT

    return HGetGlobalAttribute(((PCOMMONINFO)poemuiobj)->pInfoHeader,
                               dwFlags,
                               pszAttribute,
                               pdwDataType,
                               pbData,
                               cbSize,
                               pcbNeeded);

    #else

    return E_NOTIMPL;

    #endif // PSCRIPT
}

/*++

Routine Name:

    GetFeatureAttribute

Routine Description:

    get PPD feature attribute

Arguments:

    poemuiobj - pointer to driver context object
    dwFlags - flags for the attribute get operation
    pszFeatureKeyword - PPD feature keyword name
    pszAttribute - name of the feature attribute
    pdwDataType - pointer to DWORD to store output data type
    pbData - pointer to output data buffer
    cbSize - output data buffer size in bytes
    pcbNeeded - buffer size in bytes needed to store the output data

Return Value:

    E_INVALIDARG    if poemuiobj is invalid, or see HGetFeatureAttribute

    S_OK
    E_OUTOFMEMORY   see HGetFeatureAttribute

Last Error:

    None

--*/
STDMETHODIMP CPrintCoreUI2::GetFeatureAttribute(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pszFeatureKeyword,
                           IN  PCSTR      pszAttribute,
                           OUT PDWORD     pdwDataType,
                           OUT PBYTE      pbData,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded)
{
    VERIFY_OEMUIOBJ(poemuiobj)

    #ifdef PSCRIPT

    return HGetFeatureAttribute(((PCOMMONINFO)poemuiobj)->pInfoHeader,
                                dwFlags,
                                pszFeatureKeyword,
                                pszAttribute,
                                pdwDataType,
                                pbData,
                                cbSize,
                                pcbNeeded);

    #else

    return E_NOTIMPL;

    #endif // PSCRIPT
}

/*++

Routine Name:

    GetOptionAttribute

Routine Description:

    get option attribute of a PPD feature

Arguments:

    poemuiobj - pointer to driver context object
    dwFlags - flags for the attribute get operation
    pszFeatureKeyword - PPD feature keyword name
    pszOptionKeyword - option keyword name of the PPD feature
    pszAttribute - name of the feature attribute
    pdwDataType - pointer to DWORD to store output data type
    pbData - pointer to output data buffer
    cbSize - output data buffer size in bytes
    pcbNeeded - buffer size in bytes needed to store the output data

Return Value:

    E_INVALIDARG    if poemuiobj is invalid, or see HGetOptionAttribute

    S_OK
    E_OUTOFMEMORY   see HGetOptionAttribute

Last Error:

    None

--*/
STDMETHODIMP CPrintCoreUI2::GetOptionAttribute(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pszFeatureKeyword,
                           IN  PCSTR      pszOptionKeyword,
                           IN  PCSTR      pszAttribute,
                           OUT PDWORD     pdwDataType,
                           OUT PBYTE      pbData,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded)
{
    VERIFY_OEMUIOBJ(poemuiobj)

    #ifdef PSCRIPT

    return HGetOptionAttribute(((PCOMMONINFO)poemuiobj)->pInfoHeader,
                               dwFlags,
                               pszFeatureKeyword,
                               pszOptionKeyword,
                               pszAttribute,
                               pdwDataType,
                               pbData,
                               cbSize,
                               pcbNeeded);

    #else

    return E_NOTIMPL;

    #endif // PSCRIPT
}

/*++

Routine Name:

    EnumFeatures

Routine Description:

    enumerate PPD feature and supported driver feature keyword name list

Arguments:

    poemuiobj - pointer to driver context object
    dwFlags - flags for the enumeration operation
    pmszFeatureList - pointer to output data buffer
    cbSize - output data buffer size in bytes
    pcbNeeded - buffer size in bytes needed to store the output data

Return Value:

    E_INVALIDARG    if peomuiobj is invalid

    S_OK
    E_OUTOFMEMORY
    E_FAIL          see HEnumFeaturesOrOptions

Last Error:

    None

--*/
STDMETHODIMP CPrintCoreUI2::EnumFeatures(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           OUT PSTR       pmszFeatureList,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded)
{
    VERIFY_OEMUIOBJ(poemuiobj)

    #ifdef PSCRIPT

    return HEnumFeaturesOrOptions(((PCOMMONINFO)poemuiobj)->hPrinter,
                                  ((PCOMMONINFO)poemuiobj)->pInfoHeader,
                                  dwFlags,
                                  NULL,
                                  pmszFeatureList,
                                  cbSize,
                                  pcbNeeded);

    #else

    return E_NOTIMPL;

    #endif // PSCRIPT
}

/*++

Routine Name:

    EnumOptions

Routine Description:

    enumerate option keyword name list of the specified feature

Arguments:

    poemuiobj - pointer to driver context object
    dwFlags - flags for the enumeration operation
    pszFeatureKeyword - feature keyword name
    pmszOptionList - pointer to output data buffer
    cbSize - output data buffer size in bytes
    pcbNeeded - buffer size in bytes needed to store the output data

Return Value:

    E_INVALIDARG    if poemuiobj is invalid, or feature keyword name is invalid

    S_OK
    E_OUTOFMEMORY
    E_NOTIMPL
    E_FAIL          see HEnumFeaturesOrOptions

Last Error:

--*/
STDMETHODIMP CPrintCoreUI2::EnumOptions(
                           IN  POEMUIOBJ  poemuiobj,
                           IN  DWORD      dwFlags,
                           IN  PCSTR      pszFeatureKeyword,
                           OUT PSTR       pmszOptionList,
                           IN  DWORD      cbSize,
                           OUT PDWORD     pcbNeeded)
{
    VERIFY_OEMUIOBJ(poemuiobj)

    if (pszFeatureKeyword == NULL)
    {
        return E_INVALIDARG;
    }

    #ifdef PSCRIPT

    return HEnumFeaturesOrOptions(((PCOMMONINFO)poemuiobj)->hPrinter,
                                  ((PCOMMONINFO)poemuiobj)->pInfoHeader,
                                  dwFlags,
                                  pszFeatureKeyword,
                                  pmszOptionList,
                                  cbSize,
                                  pcbNeeded);

    #else

    return E_NOTIMPL;

    #endif // PSCRIPT
}

/*++

Routine Name:

    QuerySimulationSupport

Routine Description:

    get the spooler simulation capability info structure

Arguments:

    hPrinter - printer handle
    dwLevel - interested level of spooler simulation capability info structure
    pCaps - pointer to output buffer
    cbSize - size in bytes of output buffer
    pcbNeeded - buffer size in bytes needed to store the interested info structure

Return Value:

    E_NOTIMPL   if called on NT4, or see HQuerySimulationSupport

    S_OK
    E_OUTOFMEMORY
    E_NOTIMPL
    E_FAIL      see HQuerySimulationSupport

Last Error:

    None

--*/
STDMETHODIMP CPrintCoreUI2::QuerySimulationSupport(
                           IN  HANDLE  hPrinter,
                           IN  DWORD   dwLevel,
                           OUT PBYTE   pCaps,
                           IN  DWORD   cbSize,
                           OUT PDWORD  pcbNeeded)
{
    #ifndef WINNT_40

    return HQuerySimulationSupport(hPrinter,
                                   dwLevel,
                                   pCaps,
                                   cbSize,
                                   pcbNeeded);

    #else

    return E_NOTIMPL;

    #endif // !WINNT_40
}

#endif // PSCRIPT

//
// Creation function
//

extern "C" IUnknown* DriverCreateInstance(INT iHelperIntfVer)
{
    IUnknown *pI = NULL;

    switch (iHelperIntfVer)
    {
        case 1:
            pI = static_cast<IPrintOemDriverUI *>(new CPrintOemDriverUI);
            break;

        #ifdef PSCRIPT

        case 2:
            pI = static_cast<IPrintCoreUI2 *>(new CPrintCoreUI2);
            break;

        #endif // PSCRIPT

        default:
            ERR(("Unrecognized helper interface version: %d\n", iHelperIntfVer));
            break;
    }

    if (pI != NULL)
        pI->AddRef();

    return pI;
}

//
// Get OEM plugin interface and publish driver helper interface
//

extern "C" BOOL BGetOemInterface(POEM_PLUGIN_ENTRY pOemEntry)
{
    IUnknown  *pIDriverHelper = NULL;
    HRESULT   hr;
    INT       iHelperVer;

    //
    // QI to retrieve the latest interface OEM plugin supports
    //

    if (!BQILatestOemInterface(pOemEntry->hInstance,
                               CLSID_OEMUI,
                               PrintOemUI_IIDs,
                               &(pOemEntry->pIntfOem),
                               &(pOemEntry->iidIntfOem)))
    {
        ERR(("BQILatestOemInterface failed\n"));
        return FALSE;
    }

    //
    // If QI succeeded, pOemEntry->pIntfOem will have the OEM plugin
    // interface pointer with ref count 1.
    //

    //
    // Now publish driver's helper function interface (from latest to oldest).
    //

    for (iHelperVer = MAX_UI_HELPER_INTF_VER; iHelperVer > 0; iHelperVer--)
    {
        if ((pIDriverHelper = DriverCreateInstance(iHelperVer)) == NULL)
        {
            ERR(("DriverCreateInstance failed for version %d\n", iHelperVer));
            goto fail_cleanup;
        }

        //
        // As long as we define new OEM UI plugin interface by inheriting old ones,
        // we can always cast pIntfOem into pointer of the oldest plugin interface
        // (the base class) and call PublishDriverInterface method.
        //
        // Otherwise, this code needs to be modified when new interface is added.
        //

        hr = ((IPrintOemUI *)(pOemEntry->pIntfOem))->PublishDriverInterface(pIDriverHelper);

        //
        // OEM plugin should do QI in their PublishDriverInterface, so we need to release
        // our ref count of pIDriverHelper.
        //

        pIDriverHelper->Release();

        if (SUCCEEDED(hr))
        {
            VERBOSE(("PublishDriverInterface succeeded for version %d\n", iHelperVer));
            break;
        }
    }

    if (iHelperVer == 0)
    {
        ERR(("PublishDriverInterface failed\n"));
        goto fail_cleanup;
    }

    return TRUE;

    fail_cleanup:

    //
    // If failed, we need to release the ref count we hold on pOemEntry->pIntfOem,
    // and set pIntfOem to NULL to indicate no COM interface is available.
    //

    ((IUnknown *)(pOemEntry->pIntfOem))->Release();
    pOemEntry->pIntfOem = NULL;

    return FALSE;
}


extern "C" ULONG ReleaseOemInterface(POEM_PLUGIN_ENTRY    pOemEntry)
{
#ifdef WINNT_40

    if (IsEqualGUID(&pOemEntry->iidIntfOem, &IID_IPrintOemUI))
    {
        return ((IPrintOemUI *)(pOemEntry)->pIntfOem)->Release();
    }

#else

    CALL_INTERFACE(pOemEntry, Release,
                      ());
#endif

    return 0;
}


extern "C" HRESULT HComOEMGetInfo(POEM_PLUGIN_ENTRY    pOemEntry,
                                  DWORD                dwMode,
                                  PVOID                pBuffer,
                                  DWORD                cbSize,
                                  PDWORD               pcbNeeded)
{

    CALL_INTERFACE(pOemEntry, GetInfo,
                   (dwMode,
                    pBuffer,
                    cbSize,
                    pcbNeeded));
}

extern "C" HRESULT HComOEMDevMode(POEM_PLUGIN_ENTRY    pOemEntry,
                                  DWORD                dwMode,
                                  POEMDMPARAM          pOemDMParam)
{
    CALL_INTERFACE(pOemEntry, DevMode,
                   (dwMode,
                   pOemDMParam));
}

extern "C" HRESULT HComOEMCommonUIProp(POEM_PLUGIN_ENTRY   pOemEntry,
                                       DWORD               dwMode,
                                       POEMCUIPPARAM       pOemCUIPParam)
{

    CALL_INTERFACE(pOemEntry, CommonUIProp,
                    (dwMode, pOemCUIPParam));
}

extern "C" HRESULT HComOEMDocumentPropertySheets(POEM_PLUGIN_ENTRY pOemEntry,
                                                 PPROPSHEETUI_INFO pPSUIInfo,
                                                 LPARAM            lParam)
{

    CALL_INTERFACE(pOemEntry, DocumentPropertySheets,
                    (pPSUIInfo,
                     lParam));
}

extern "C" HRESULT HComOEMDevicePropertySheets(POEM_PLUGIN_ENTRY pOemEntry,
                                               PPROPSHEETUI_INFO pPSUIInfo,
                                               LPARAM            lParam)
{

    CALL_INTERFACE(pOemEntry,DevicePropertySheets,
                    (pPSUIInfo,
                     lParam));
}

extern "C" HRESULT HComOEMDevQueryPrintEx(POEM_PLUGIN_ENTRY    pOemEntry,
                                          POEMUIOBJ            poemuiobj,
                                          PDEVQUERYPRINT_INFO  pDQPInfo,
                                          PDEVMODE             pPublicDM,
                                          PVOID                pOEMDM)
{

    CALL_INTERFACE(pOemEntry, DevQueryPrintEx,
                    (poemuiobj,
                     pDQPInfo,
                     pPublicDM,
                     pOEMDM));

}

extern "C" HRESULT HComOEMDeviceCapabilities(POEM_PLUGIN_ENTRY    pOemEntry,
                                             POEMUIOBJ   poemuiobj,
                                             HANDLE      hPrinter,
                                             PWSTR       pDeviceName,
                                             WORD        wCapability,
                                             PVOID       pOutput,
                                             PDEVMODE    pPublicDM,
                                             PVOID       pOEMDM,
                                             DWORD       dwOld,
                                             DWORD       *pdwResult)
{

    CALL_INTERFACE(pOemEntry, DeviceCapabilities,
                    (poemuiobj,
                     hPrinter,
                     pDeviceName,
                     wCapability,
                     pOutput,
                     pPublicDM,
                     pOEMDM,
                     dwOld,
                     pdwResult));
}

extern "C" HRESULT HComOEMUpgradePrinter(POEM_PLUGIN_ENTRY    pOemEntry,
                                         DWORD                dwLevel,
                                         PBYTE                pDriverUpgradeInfo)
{
    CALL_INTERFACE(pOemEntry, UpgradePrinter,
                   (dwLevel,
                   pDriverUpgradeInfo));
}

extern "C" HRESULT HComOEMPrinterEvent(POEM_PLUGIN_ENTRY   pOemEntry,
                                       PWSTR              pPrinterName,
                                       INT                iDriverEvent,
                                       DWORD              dwFlags,
                                       LPARAM             lParam)
{

    CALL_INTERFACE(pOemEntry, PrinterEvent,
                   (pPrinterName,
                    iDriverEvent,
                    dwFlags,
                    lParam));
}

extern "C" HRESULT HComOEMDriverEvent(POEM_PLUGIN_ENTRY   pOemEntry,
                                      DWORD               dwDriverEvent,
                                      DWORD               dwLevel,
                                      LPBYTE              pDriverInfo,
                                      LPARAM              lParam)
{

    CALL_INTERFACE(pOemEntry, DriverEvent,
                   (dwDriverEvent,
                    dwLevel,
                    pDriverInfo,
                    lParam));
}

extern "C" HRESULT HComOEMQUeryColorProfile(POEM_PLUGIN_ENTRY  pOemEntry,
                                            HANDLE             hPrinter,
                                            POEMUIOBJ          poemuiobj,
                                            PDEVMODE           pPublicDM,
                                            PVOID              pOEMDM,
                                            ULONG              ulQueryMode,
                                            VOID               *pvProfileData,
                                            ULONG              *pcbProfileData,
                                            FLONG              *pflProfileData)

{
    CALL_INTERFACE(pOemEntry,QueryColorProfile,
                   (hPrinter,
                    poemuiobj,
                    pPublicDM,
                    pOEMDM,
                    ulQueryMode,
                    pvProfileData,
                    pcbProfileData,
                    pflProfileData));
}

extern "C" HRESULT HComOEMFontInstallerDlgProc(POEM_PLUGIN_ENTRY   pOemEntry,
                                               HWND                hWnd,
                                               UINT                usMsg,
                                               WPARAM              wParam,
                                               LPARAM              lParam)
{

    CALL_INTERFACE(pOemEntry, FontInstallerDlgProc,
                   (hWnd,
                    usMsg,
                    wParam,
                    lParam));
}

extern "C" HRESULT HComOEMUpdateExternalFonts(POEM_PLUGIN_ENTRY   pOemEntry,
                                              HANDLE  hPrinter,
                                              HANDLE  hHeap,
                                              PWSTR   pwstrCartridges)
{

    CALL_INTERFACE(pOemEntry, UpdateExternalFonts,
                   (hPrinter,
                    hHeap,
                    pwstrCartridges));
}

extern "C" HRESULT HComOEMQueryJobAttributes(POEM_PLUGIN_ENTRY   pOemEntry,
                                            HANDLE      hPrinter,
                                            PDEVMODE    pDevMode,
                                            DWORD       dwLevel,
                                            LPBYTE      lpAttributeInfo)
{

    CALL_INTERFACE2(pOemEntry, QueryJobAttributes,
                   (hPrinter,
                    pDevMode,
                    dwLevel,
                    lpAttributeInfo));
}

extern "C" HRESULT HComOEMHideStandardUI(POEM_PLUGIN_ENTRY   pOemEntry,
                                         DWORD               dwMode)
{

    CALL_INTERFACE2(pOemEntry, HideStandardUI,
                   (dwMode));
}

extern "C" HRESULT HComOEMDocumentEvent(POEM_PLUGIN_ENTRY  pOemEntry,
                                        HANDLE   hPrinter,
                                        HDC      hdc,
                                        INT      iEsc,
                                        ULONG    cbIn,
                                        PVOID    pbIn,
                                        ULONG    cbOut,
                                        PVOID    pbOut,
                                        PINT     piResult)
{
    CALL_INTERFACE2(pOemEntry, DocumentEvent,
                    (hPrinter,
                     hdc,
                     iEsc,
                     cbIn,
                     pbIn,
                     cbOut,
                     pbOut,
                     piResult));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\driverui\oemui.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    oemui.c

Abstract:

    Support for OEM plugin UI modules

Environment:

        Windows NT printer driver

Revision History:

        02/13/97 -davidx-
                Created it.

--*/

#include "precomp.h"

//
// User mode helper functions for OEM plugins
//

const OEMUIPROCS OemUIHelperFuncs = {
    (PFN_DrvGetDriverSetting) BGetDriverSettingForOEM,
    (PFN_DrvUpdateUISetting)  BUpdateUISettingForOEM,
};



BOOL
BPackOemPluginItems(
    PUIDATA pUiData
    )

/*++

Routine Description:

    Call OEM plugin UI modules to let them add their OPTITEMs

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PCOMMONINFO         pci;
    PFN_OEMCommonUIProp pfnOEMCommonUIProp;
    POEMCUIPPARAM       pOemCUIPParam;
    POPTITEM            pOptItem;
    DWORD               dwOptItem;

    //
    // Check if we're being called for the first time.
    // We assume all OEM plugin items are always packed at the end.
    //

    if (pUiData->pOptItem == NULL)
        pUiData->dwDrvOptItem = pUiData->dwOptItem;
    else if (pUiData->dwDrvOptItem != pUiData->dwOptItem)
    {
        RIP(("Inconsistent OPTITEM count for driver items\n"));
        return FALSE;
    }

    //
    // Quick exit for no OEM plugin case
    //

    pci = (PCOMMONINFO) pUiData;

    if (pci->pOemPlugins->dwCount == 0)
        return TRUE;

    pOptItem = pUiData->pOptItem;

    FOREACH_OEMPLUGIN_LOOP(pci)

        if (!HAS_COM_INTERFACE(pOemEntry) &&
            !(pfnOEMCommonUIProp = GET_OEM_ENTRYPOINT(pOemEntry, OEMCommonUIProp)))
                continue;

        //
        // Compose the input parameter for calling OEMCommonUI
        //

        pOemCUIPParam = pOemEntry->pParam;

        if (pOemCUIPParam == NULL)
        {
            //
            // Allocate memory for an OEMUI_PARAM structure
            // during the first pass
            //

            if (pOptItem != NULL)
                continue;

            if (! (pOemCUIPParam = HEAPALLOC(pci->hHeap, sizeof(OEMCUIPPARAM))))
            {
                ERR(("Memory allocation failed\n"));
                return FALSE;
            }

            pOemEntry->pParam = pOemCUIPParam;
            pOemCUIPParam->cbSize = sizeof(OEMCUIPPARAM);
            pOemCUIPParam->poemuiobj = pci->pOemPlugins->pdriverobj;
            pOemCUIPParam->hPrinter = pci->hPrinter;
            pOemCUIPParam->pPrinterName = pci->pPrinterName;
            pOemCUIPParam->hModule = pOemEntry->hInstance;
            pOemCUIPParam->hOEMHeap = pci->hHeap;
            pOemCUIPParam->pPublicDM = pci->pdm;
            pOemCUIPParam->pOEMDM = pOemEntry->pOEMDM;
        }

        pOemCUIPParam->pDrvOptItems = pUiData->pDrvOptItem;
        pOemCUIPParam->cDrvOptItems = pUiData->dwDrvOptItem;
        pOemCUIPParam->pOEMOptItems = pOptItem;
        dwOptItem = pOemCUIPParam->cOEMOptItems;

        //
        // Actually call OEMCommonUI entrypoint
        //

        if (HAS_COM_INTERFACE(pOemEntry))
        {
            HRESULT hr;

            hr = HComOEMCommonUIProp(
                    pOemEntry,
                    (pUiData->iMode == MODE_DOCUMENT_STICKY) ? OEMCUIP_DOCPROP : OEMCUIP_PRNPROP,
                    pOemCUIPParam);

            if (hr == E_NOTIMPL)
            {
                HeapFree(pci->hHeap, 0, pOemCUIPParam);
                pOemEntry->pParam = NULL;
                continue;
            }

            if (FAILED(hr))
            {
                ERR(("OEMCommonUI failed for '%ws': %d\n",
                    CURRENT_OEM_MODULE_NAME(pOemEntry),
                    GetLastError()));

                //
                // OEM failure during the first pass is recoverable:
                // we'll simply ignore OEM plugin items
                //

                if (pOptItem == NULL)
                {
                    HeapFree(pci->hHeap, 0, pOemCUIPParam);
                    pOemEntry->pParam = NULL;
                    continue;
                }
                return FALSE;
            }
        }
        else
        {
            if (!pfnOEMCommonUIProp(
                    (pUiData->iMode == MODE_DOCUMENT_STICKY) ? OEMCUIP_DOCPROP : OEMCUIP_PRNPROP,
                    pOemCUIPParam))
            {
                ERR(("OEMCommonUI failed for '%ws': %d\n",
                    CURRENT_OEM_MODULE_NAME(pOemEntry),
                    GetLastError()));
    #if 0
                (VOID) IDisplayErrorMessageBox(
                                NULL,
                                0,
                                IDS_OEMERR_DLGTITLE,
                                IDS_OEMERR_OPTITEM,
                                CURRENT_OEM_MODULE_NAME(pOemEntry));
    #endif
                //
                // OEM failure during the first pass is recoverable:
                // we'll simply ignore OEM plugin items
                //

                if (pOptItem == NULL)
                {
                    HeapFree(pci->hHeap, 0, pOemCUIPParam);
                    pOemEntry->pParam = NULL;
                    continue;
                }

                return FALSE;
            }
        }

        if (pOptItem != NULL)
        {
            //
            // second pass - ensure the number of items is consistent
            //

            if (dwOptItem != pOemCUIPParam->cOEMOptItems)
            {
                RIP(("Inconsistent OPTITEM count reported by OEM plugin: %ws\n",
                     CURRENT_OEM_MODULE_NAME(pOemEntry),
                     GetLastError()));

                return FALSE;
            }

            pOptItem += pOemCUIPParam->cOEMOptItems;
            pUiData->pOptItem += pOemCUIPParam->cOEMOptItems;
        }

        pUiData->dwOptItem += pOemCUIPParam->cOEMOptItems;

    END_OEMPLUGIN_LOOP

    return TRUE;
}



LONG
LInvokeOemPluginCallbacks(
    PUIDATA         pUiData,
    PCPSUICBPARAM   pCallbackParam,
    LONG            lRet
    )

/*++

Routine Description:

    Call OEM plugin module's callback function

Arguments:

    pUiData - Points to UIDATA structure
    pCallbackParam - Points to callback parameter from compstui
    lRet - Return value after the driver has processed the callback

Return Value:

    Return value for compstui

--*/

{
    PCOMMONINFO     pci = (PCOMMONINFO) pUiData;
    POEMCUIPPARAM   pOemCUIPParam;
    LONG            lNewResult;

    //
    // Quick exit for no OEM plugin case
    //

    if (pci->pOemPlugins->dwCount == 0)
        return lRet;

    //
    // Go through each OEM plugin UI module
    //

    FOREACH_OEMPLUGIN_LOOP(pci)

        //
        // Stop when anyone says don't exit
        //

        if (lRet == CPSUICB_ACTION_NO_APPLY_EXIT)
        {
            ASSERT(pCallbackParam->Reason == CPSUICB_REASON_APPLYNOW);
            break;
        }

        //
        // Get the address of OEM callback function and call it
        //

        pOemCUIPParam = pOemEntry->pParam;

        if (pOemCUIPParam == NULL || pOemCUIPParam->OEMCUIPCallback == NULL)
            continue;

        lNewResult = pOemCUIPParam->OEMCUIPCallback(pCallbackParam, pOemCUIPParam);

        //
        // Merge the new result with the existing result
        //

        switch (lNewResult)
        {
        case CPSUICB_ACTION_ITEMS_APPLIED:
        case CPSUICB_ACTION_NO_APPLY_EXIT:

            ASSERT(pCallbackParam->Reason == CPSUICB_REASON_APPLYNOW);
            lRet = lNewResult;
            break;

        case CPSUICB_ACTION_REINIT_ITEMS:

            ASSERT(pCallbackParam->Reason != CPSUICB_REASON_APPLYNOW);
            lRet = lNewResult;
            break;

        case CPSUICB_ACTION_OPTIF_CHANGED:

            ASSERT(pCallbackParam->Reason != CPSUICB_REASON_APPLYNOW);
            if (lRet == CPSUICB_ACTION_NONE)
                lRet = lNewResult;
            break;

        case CPSUICB_ACTION_NONE:
            break;

        default:

            RIP(("Invalid return value from OEM callback: '%ws'\n",
                 CURRENT_OEM_MODULE_NAME(pOemEntry),
                 GetLastError()));
            break;
        }

    END_OEMPLUGIN_LOOP

    return lRet;
}


LRESULT
OEMDocumentPropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam
    )
{
    HRESULT hr;

    POEM_PLUGIN_ENTRY pOemEntry;

    pOemEntry = ((POEMUIPSPARAM)(pPSUIInfo->lParamInit))->pOemEntry;

    hr = HComOEMDocumentPropertySheets(pOemEntry,
                                       pPSUIInfo,
                                       lParam);

    if (SUCCEEDED(hr))
        return 1;

    return -1;
}

LRESULT
OEMDevicePropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam
    )
{
    HRESULT hr;

    POEM_PLUGIN_ENTRY pOemEntry;

    pOemEntry = ((POEMUIPSPARAM)(pPSUIInfo->lParamInit))->pOemEntry;

    hr = HComOEMDevicePropertySheets(pOemEntry,
                                     pPSUIInfo,
                                     lParam);

    if (SUCCEEDED(hr))
        return 1;

    return -1;
}


BOOL
BAddOemPluginPages(
    PUIDATA pUiData,
    DWORD   dwFlags
    )

/*++

Routine Description:

    Call OEM plugin UI modules to let them add their own property sheet pages

Arguments:

    pUiData - Points to UIDATA structure
    dwFlags - Flags from DOCUMENTPROPERTYHEADER or DEVICEPROPERTYHEADER

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PCOMMONINFO     pci = (PCOMMONINFO) pUiData;
    FARPROC         pfnOEMPropertySheets;
    POEMUIPSPARAM   pOemUIPSParam;

    //
    // Quick exit for no OEM plugin case
    //

    if (pci->pOemPlugins->dwCount == 0)
        return TRUE;

    //
    // Add the property sheet for each OEM plugin UI module
    //

    FOREACH_OEMPLUGIN_LOOP(pci)

        //
        // get the address of appropriate OEM entrypoint
        //


        if (HAS_COM_INTERFACE(pOemEntry))
        {
            if (pUiData->iMode == MODE_DOCUMENT_STICKY)
                pfnOEMPropertySheets = (FARPROC)OEMDocumentPropertySheets;
            else
                pfnOEMPropertySheets = (FARPROC)OEMDevicePropertySheets;
        }
        else
        {
            if (pUiData->iMode == MODE_DOCUMENT_STICKY)
            {
                pfnOEMPropertySheets = (FARPROC)
                    GET_OEM_ENTRYPOINT(pOemEntry, OEMDocumentPropertySheets);
            }
            else
            {
                pfnOEMPropertySheets = (FARPROC)
                    GET_OEM_ENTRYPOINT(pOemEntry, OEMDevicePropertySheets);
            }

            if (pfnOEMPropertySheets == NULL)
                continue;
        }

        //
        // Collect input parameters to be passed to OEM plugin
        //

        if ((pOemUIPSParam = HEAPALLOC(pci->hHeap, sizeof(OEMUIPSPARAM))) == NULL)
        {
            ERR(("Memory allocation failed\n"));
            return FALSE;
        }

        pOemUIPSParam->cbSize = sizeof(OEMUIPSPARAM);
        pOemUIPSParam->poemuiobj = pci->pOemPlugins->pdriverobj;
        pOemUIPSParam->hPrinter = pci->hPrinter;
        pOemUIPSParam->pPrinterName = pci->pPrinterName;
        pOemUIPSParam->hModule = pOemEntry->hInstance;
        pOemUIPSParam->hOEMHeap = pci->hHeap;
        pOemUIPSParam->pPublicDM = pci->pdm;
        pOemUIPSParam->pOEMDM = pOemEntry->pOEMDM;
        pOemUIPSParam->dwFlags = dwFlags;
        pOemUIPSParam->pOemEntry = pOemEntry;

        //
        // call compstui to add the OEM plugin property sheets
        //

        if (pUiData->pfnComPropSheet(pUiData->hComPropSheet,
                                     CPSFUNC_ADD_PFNPROPSHEETUI,
                                     (LPARAM) pfnOEMPropertySheets,
                                     (LPARAM) pOemUIPSParam) <= 0)
        {
            VERBOSE(("Couldn't add property sheet pages for '%ws'\n",
                     CURRENT_OEM_MODULE_NAME(pOemEntry),
                     GetLastError()));
#if 0
            (VOID) IDisplayErrorMessageBox(
                            NULL,
                            0,
                            IDS_OEMERR_DLGTITLE,
                            IDS_OEMERR_PROPSHEET,
                            CURRENT_OEM_MODULE_NAME(pOemEntry));
#endif
        }

    END_OEMPLUGIN_LOOP

    return TRUE;
}



BOOL
APIENTRY
BGetDriverSettingForOEM(
    PCOMMONINFO pci,
    PCSTR       pFeatureKeyword,
    PVOID       pOutput,
    DWORD       cbSize,
    PDWORD      pcbNeeded,
    PDWORD      pdwOptionsReturned
    )

/*++

Routine Description:

    Provide OEM plugins access to driver private settings

Arguments:

    pci - Points to basic printer information
    pFeatureKeyword - Specifies the keyword the caller is interested in
    pOutput - Points to output buffer
    cbSize - Size of output buffer
    pcbNeeded - Returns the expected size of output buffer
    pdwOptionsReturned - Returns the number of options selected

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    ULONG_PTR dwIndex;
    BOOL     bResult;

    ASSERT(pci->pvStartSign == pci);

    //
    // This is not very portable: If the pointer value for pFeatureKeyword
    // is less than 0x10000, we assume that the pointer value actually
    // specifies a predefined index.
    //

    //
    // Following ASSERT is removed for Win64
    //
    // ASSERT(sizeof(pFeatureKeyword) == sizeof(DWORD));
    //

    dwIndex = (ULONG_PTR)pFeatureKeyword;

    if (dwIndex >= OEMGDS_MIN_DOCSTICKY && dwIndex < OEMGDS_MIN_PRINTERSTICKY)
    {
        if (pci->pdm == NULL)
            goto setting_not_available;

        bResult = BGetDevmodeSettingForOEM(
                        pci->pdm,
                        (DWORD)dwIndex,
                        pOutput,
                        cbSize,
                        pcbNeeded);

        if (bResult)
            *pdwOptionsReturned = 1;
    }
    else if (dwIndex >= OEMGDS_MIN_PRINTERSTICKY && dwIndex < OEMGDS_MAX)
    {
        if (pci->pPrinterData == NULL)
            goto setting_not_available;

        bResult = BGetPrinterDataSettingForOEM(
                        pci->pPrinterData,
                        (DWORD)dwIndex,
                        pOutput,
                        cbSize,
                        pcbNeeded);

        if (bResult)
            *pdwOptionsReturned = 1;
    }
    else
    {
        if (pci->pCombinedOptions == NULL)
            goto setting_not_available;

        bResult = BGetGenericOptionSettingForOEM(
                        pci->pUIInfo,
                        pci->pCombinedOptions,
                        pFeatureKeyword,
                        pOutput,
                        cbSize,
                        pcbNeeded,
                        pdwOptionsReturned);
    }

    return bResult;

setting_not_available:

    WARNING(("Requested driver setting not available: %d\n", pFeatureKeyword));
    SetLastError(ERROR_NOT_SUPPORTED);
    return FALSE;
}


BOOL
BUpdateUISettingForOEM(
    PCOMMONINFO pci,
    PVOID       pOptItem,
    DWORD       dwPreviousSelection,
    DWORD       dwMode
    )

/*++

Routine Description:

    Update the UI settings in optionsarray for OEM.

Arguments:

    pci - Points to basic printer information
    pOptItem - Points to the current OPTITEM

Return Value:

    TRUE if successful, FALSE if there is an error such as conflict and
    user wants to cancel.

--*/

{
    POPTITEM    pCurItem = pOptItem;
    PUIDATA     pUiData = (PUIDATA)pci;

    if (ICheckConstraintsDlg(pUiData, pCurItem, 1, FALSE) == CONFLICT_CANCEL)
    {
        //
        // If there is a conflict and the user clicked
        // CANCEL to restore the original selection.
        // CONFLICT_CANCEL, restore the old setting
        //

        return FALSE;
    }

    if (dwMode == OEMCUIP_DOCPROP)
    {
        //
        // We use FLAG_WITHIN_PLUGINCALL to indicate we are within the UI helper
        // function call issued by OEM plugin. This is needed to fix bug #90923.
        //

        pUiData->ci.dwFlags |= FLAG_WITHIN_PLUGINCALL;
        VUnpackDocumentPropertiesItems(pUiData, pCurItem, 1);
        pUiData->ci.dwFlags &= ~FLAG_WITHIN_PLUGINCALL;

        VPropShowConstraints(pUiData, MODE_DOCANDPRINTER_STICKY);
    }
    else
    {
        VUpdateOptionsArrayWithSelection(pUiData, pCurItem);
        VPropShowConstraints(pUiData, MODE_PRINTER_STICKY);
    }

    //
    // Record the fact that one of our OPTITEM selection has been changed by plugin's
    // call of helper function DrvUpdateUISetting. This is necessary so that at the
    // APPLYNOW time we know constraints could exist even though user hasn't touched
    // any of our OPTITEMs.
    //

    pUiData->ci.dwFlags |= FLAG_PLUGIN_CHANGED_OPTITEM;

    return TRUE;
}

BOOL
BUpgradeRegistrySettingForOEM(
    HANDLE      hPrinter,
    PCSTR       pFeatureKeyword,
    PCSTR       pOptionKeyword
    )

/*++

Routine Description:

    Set the Feature.Option request to our options array. OEM will only
    call this function at OEMUpgradeDriver to upgrade their registry setttings
    into our optionsarray saved in our PRINTERDATA

Arguments:

    hPrinter - Handle of the Printer
    pFeatureKeyword - Specifies the keyword the caller is interested in
    pOptionKeyword - Specifies the keyword the caller is interested in

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{

    PFEATURE    pFeature;
    POPTION     pOption;
    DWORD       dwFeatureCount, i, j;
    BOOL        bFeatureFound, bOptionFound, bResult = FALSE;
    PCSTR       pKeywordName;
    POPTSELECT      pOptionsArray = NULL;
    PDRIVER_INFO_3  pDriverInfo3 = NULL;
    PRAWBINARYDATA  pRawData = NULL;
    PINFOHEADER     pInfoHeader = NULL;
    PUIINFO         pUIInfo = NULL;
    PPRINTERDATA    pPrinterData = NULL;
    OPTSELECT       DocOptions[MAX_PRINTER_OPTIONS];

    //
    // Get information about the printer driver
    //

    bResult = bFeatureFound = bOptionFound = FALSE;

    if ((pDriverInfo3 = MyGetPrinterDriver(hPrinter, NULL, 3)) == NULL)
    {
        ERR(("Cannot get printer driver info: %d\n", GetLastError()));
        goto upgrade_registry_exit;
    }

//    ENTER_CRITICAL_SECTION();

    pRawData = LoadRawBinaryData(pDriverInfo3->pDataFile);

//    LEAVE_CRITICAL_SECTION();

    if (pRawData == NULL)
        goto upgrade_registry_exit;

    if (!(pPrinterData = MemAllocZ(sizeof(PRINTERDATA)))  ||
        !( BGetPrinterProperties(hPrinter, pRawData, pPrinterData)))
    {

        ERR(("Cannot get printer data info: %d\n", GetLastError()));
        goto upgrade_registry_exit;
    }

    //
    // Allocate memory for combined optionsarray
    //

    if (!(pOptionsArray = MemAllocZ(MAX_COMBINED_OPTIONS * sizeof (OPTSELECT))))
        goto upgrade_registry_exit;

    if (! InitDefaultOptions(pRawData,
                             DocOptions,
                             MAX_PRINTER_OPTIONS,
                             MODE_DOCUMENT_STICKY))
    {
        goto upgrade_registry_exit;
    }

    //
    // Combine doc sticky options with printer sticky items
    //

    CombineOptionArray(pRawData, pOptionsArray, MAX_COMBINED_OPTIONS, DocOptions, pPrinterData->aOptions);

    //
    // Get an updated instance of printer description data
    //

    pInfoHeader = InitBinaryData(pRawData,
                                 NULL,
                                 pOptionsArray);

    if (pInfoHeader == NULL)
    {
        ERR(("InitBinaryData failed\n"));
        goto upgrade_registry_exit;
    }

    if (!(pUIInfo = OFFSET_TO_POINTER(pInfoHeader, pInfoHeader->loUIInfoOffset)))
        goto upgrade_registry_exit;

    //
    // Look for feature.option index
    //

    pFeature = PGetIndexedFeature(pUIInfo, 0);
    dwFeatureCount = pRawData->dwDocumentFeatures + pRawData->dwPrinterFeatures;

    if (pFeature && dwFeatureCount)
    {
        for (i = 0; i < dwFeatureCount; i++)
        {
            pKeywordName = OFFSET_TO_POINTER(pUIInfo->pubResourceData, pFeature->loKeywordName);
            if (strcmp(pKeywordName, pFeatureKeyword) == EQUAL_STRING)
            {
                bFeatureFound = TRUE;
                break;
            }
            pFeature++;
        }
    }

    if (bFeatureFound)
    {
        pOption = PGetIndexedOption(pUIInfo, pFeature, 0);

        for (j = 0; j < pFeature->Options.dwCount; j++)
        {
            pKeywordName = OFFSET_TO_POINTER(pUIInfo->pubResourceData, pOption->loKeywordName);
            if (strcmp(pKeywordName, pOptionKeyword) == EQUAL_STRING)
            {
                bOptionFound = TRUE;
                break;
            }
            pOption++;
        }
    }

    if (bFeatureFound && bOptionFound)
    {
        pOptionsArray[i].ubCurOptIndex = (BYTE)j;

        //
        // Resolve conflicts
        //

        if (!ResolveUIConflicts( pRawData,
                                 pOptionsArray,
                                 MAX_COMBINED_OPTIONS,
                                 MODE_DOCANDPRINTER_STICKY))
        {
            VERBOSE(("Resolved conflicting printer feature selections.\n"));
        }


        SeparateOptionArray(pRawData,
                            pOptionsArray,
                            pPrinterData->aOptions,
                            MAX_PRINTER_OPTIONS,
                            MODE_PRINTER_STICKY
                           );

        if (!BSavePrinterProperties(hPrinter, pRawData, pPrinterData, sizeof(PRINTERDATA)))
        {
            ERR(("BSavePrinterProperties failed\n"));
            bResult = FALSE;
        }
        else
            bResult = TRUE;
    }

upgrade_registry_exit:

    if (pInfoHeader)
        FreeBinaryData(pInfoHeader);

    if (pRawData)
        UnloadRawBinaryData(pRawData);

    if (pPrinterData)
        MemFree(pPrinterData);

    if (pDriverInfo3)
        MemFree(pDriverInfo3);

    if (pOptionsArray)
        MemFree(pOptionsArray);

    return bResult;
}

#ifdef PSCRIPT

#ifndef WINNT_40


/*++

Routine Name:

    HQuerySimulationSupport

Routine Description:

    In the case of UI replacement, we allows IHV to query for print processor simulation
    support so they can provide simulated features on their UI.

    We won't enforce hooking out QueryJobAttribute w/o UI replacement here. We will do it
    at DrvQueryJobAttributes.

Arguments:

    hPrinter - printer handle
    dwLevel - interested level of spooler simulation capability info structure
    pCaps - pointer to output buffer
    cbSize - size in bytes of output buffer
    pcbNeeded - buffer size in bytes needed to store the interested info structure

Return Value:

    S_OK            if succeeded
    E_OUTOFMEMORY   if output buffer is not big enough
    E_NOTIMPL       if the interested level is not supported
    E_FAIL          if encountered other internal error

Last Error:

    None

--*/
HRESULT
HQuerySimulationSupport(
    IN  HANDLE  hPrinter,
    IN  DWORD   dwLevel,
    OUT PBYTE   pCaps,
    IN  DWORD   cbSize,
    OUT PDWORD  pcbNeeded
    )
{
    PRINTPROCESSOR_CAPS_1 SplCaps;
    PSIMULATE_CAPS_1      pSimCaps;
    DWORD cbNeeded;

    //
    // currently only Level 1 is supported
    //

    if (dwLevel != 1)
    {
        return E_NOTIMPL;
    }

    cbNeeded = sizeof(SIMULATE_CAPS_1);

    if (pcbNeeded)
    {
        *pcbNeeded = cbNeeded;
    }

    if (!pCaps || cbSize < cbNeeded)
    {
        return E_OUTOFMEMORY;
    }

    //
    // Since VGetSpoolerEmfCaps doesn't return error code, we
    // are using the dwLevel field to detect if the call succeeds.
    // If succeeds, dwLevel should be set as 1.
    //

    SplCaps.dwLevel = 0;

    VGetSpoolerEmfCaps(hPrinter,
                       NULL,
                       NULL,
                       sizeof(PRINTPROCESSOR_CAPS_1),
                       &SplCaps
                       );

    if (SplCaps.dwLevel != 1)
    {
        ERR(("VGetSpoolerEmfCaps failed\n"));
        return E_FAIL;
    }

    //
    // BUGBUG, we should get a new PRINTPROCESSOR_CAPS level to include all
    // these information instead of filling it out here. Need
    // new PRINTPROCESSOR_CAPS
    //

    pSimCaps = (PSIMULATE_CAPS_1)pCaps;

    pSimCaps->dwLevel = 1;
    pSimCaps->dwPageOrderFlags = SplCaps.dwPageOrderFlags;
    pSimCaps->dwNumberOfCopies = SplCaps.dwNumberOfCopies;
    pSimCaps->dwNupOptions = SplCaps.dwNupOptions;

    //
    // PRINTPROCESSOR_CAPS_1 is designed without an explicit field for
    // collate simulation. So before its CAPS_2 is introduced, we have
    // to assume that if reverse printing is supported, then collate
    // simulation is also supported.
    //

    if (SplCaps.dwPageOrderFlags & REVERSE_PRINT)
    {
        pSimCaps->dwCollate = 1;
    }
    else
    {
        pSimCaps->dwCollate = 0;
    }

    return S_OK;
}

#endif // !WINNT_40


/*++

Routine Name:

    HEnumConstrainedOptions

Routine Description:

    enumerate the constrained option keyword name list in the specified feature

Arguments:

    poemuiobj - pointer to driver context object
    dwFlags - flags for the enumeration operation
    pszFeatureKeyword - feature keyword name
    pmszConstrainedOptionList - pointer to output data buffer
    cbSize - output data buffer size in bytes
    pcbNeeded - buffer size in bytes needed to store the output data

Return Value:

    S_OK            if succeeds
    E_OUTOFMEMORY   if output data buffer size is not big enough
    E_INVALIDARG    if feature keyword name is not recognized, or the feature's
                    stickiness doesn't match current sticky-mode
    E_FAIL          if other internal failures are encountered

Last Error:

    None

--*/
HRESULT
HEnumConstrainedOptions(
    IN  POEMUIOBJ  poemuiobj,
    IN  DWORD      dwFlags,
    IN  PCSTR      pszFeatureKeyword,
    OUT PSTR       pmszConstrainedOptionList,
    IN  DWORD      cbSize,
    OUT PDWORD     pcbNeeded
    )
{
    PCOMMONINFO pci = (PCOMMONINFO)poemuiobj;
    PUIDATA     pUiData;
    PFEATURE    pFeature;
    POPTION     pOption;
    DWORD       dwFeatureIndex, dwIndex;
    PBOOL       pabEnabledOptions = NULL;
    PSTR        pCurrentOut;
    DWORD       cbNeeded;
    INT         cbRemain;
    HRESULT     hr;

    pUiData = (PUIDATA)pci;

    if (!pszFeatureKeyword ||
        (pFeature = PGetNamedFeature(pci->pUIInfo, pszFeatureKeyword, &dwFeatureIndex)) == NULL)
    {
        WARNING(("HEnumConstrainedOptions: invalid feature\n"));

        //
        // Even though we could return right here, we still use goto to maintain single exit point.
        //

        hr = E_INVALIDARG;
        goto exit;
    }

    //
    // pUiData->iMode can have 2 modes: MODE_DOCUMENT_STICKY and MODE_PRINTER_STICKY. See PFillUiData().
    // In MODE_DOCUMENT_STICKY mode, we only support doc-sticky features.
    // In MODE_PRINTER_STICKY mode, we only support printer-sticky features.
    //
    // This is because in function PFillUiData(), it only fills devmode in MODE_DOCUMENT_STICKY mode.
    // Then in BCombineCommonInfoOptionsArray(), if devmode option array is not available, the PPD parser
    // will use OPTION_INDEX_ANY for any doc-sticky features.
    //

    if ((pUiData->iMode == MODE_DOCUMENT_STICKY && pFeature->dwFeatureType == FEATURETYPE_PRINTERPROPERTY) ||
        (pUiData->iMode == MODE_PRINTER_STICKY && pFeature->dwFeatureType != FEATURETYPE_PRINTERPROPERTY))
    {
        VERBOSE(("HEnumConstrainedOptions: mismatch iMode=%d, dwFeatureType=%d\n",
                pUiData->iMode, pFeature->dwFeatureType)) ;

        hr = E_INVALIDARG;
        goto exit;
    }

    if (pFeature->Options.dwCount)
    {
        if ((pabEnabledOptions = MemAllocZ(pFeature->Options.dwCount * sizeof(BOOL))) == NULL)
        {
            ERR(("HEnumConstrainedOptions: memory alloc failed\n"));
            hr = E_FAIL;
            goto exit;
        }

        //
        // Get the feature's enabled option list.
        //
        // See VPropShowConstraints() in docprop.c and prnprop.c for using different
        // modes to call EnumEnabledOptions().
        //

        if (pUiData->iMode == MODE_DOCUMENT_STICKY)
        {
            EnumEnabledOptions(pci->pRawData, pci->pCombinedOptions, dwFeatureIndex,
                               pabEnabledOptions, MODE_DOCANDPRINTER_STICKY);
        }
        else
        {
            EnumEnabledOptions(pci->pRawData, pci->pCombinedOptions, dwFeatureIndex,
                               pabEnabledOptions, MODE_PRINTER_STICKY);
        }
    }
    else
    {
        RIP(("HEnumConstrainedOptions: feature %s has no options\n", pszFeatureKeyword));

        //
        // continue so we will output the empty string with only the NUL character
        //
    }

    pCurrentOut = pmszConstrainedOptionList;
    cbNeeded = 0;
    cbRemain = (INT)cbSize;

    pOption = OFFSET_TO_POINTER(pci->pInfoHeader, pFeature->Options.loOffset);

    ASSERT(pOption || pFeature->Options.dwCount == 0);

    if (pOption == NULL && pFeature->Options.dwCount != 0)
    {
        hr = E_FAIL;
        goto exit;
    }

    for (dwIndex = 0; dwIndex < pFeature->Options.dwCount; dwIndex++)
    {
        if (!pabEnabledOptions[dwIndex])
        {
            DWORD  dwNameSize;
            PSTR   pszKeywordName;

            pszKeywordName = OFFSET_TO_POINTER(pci->pUIInfo->pubResourceData, pOption->loKeywordName);

            ASSERT(pszKeywordName);

            if (pszKeywordName == NULL)
            {
                hr = E_FAIL;
                goto exit;
            }

            //
            // count in the NUL character between constrained option keywords
            //

            dwNameSize = strlen(pszKeywordName) + 1;

            if (pCurrentOut && cbRemain >= (INT)dwNameSize)
            {
                CopyMemory(pCurrentOut, pszKeywordName, dwNameSize);
                pCurrentOut += dwNameSize;
            }

            cbRemain -= dwNameSize;
            cbNeeded += dwNameSize;
        }

        pOption = (POPTION)((PBYTE)pOption + pFeature->dwOptionSize);
    }

    //
    // remember the last NUL terminator for the MULTI_SZ output string
    //

    cbNeeded++;

    if (pcbNeeded)
    {
        *pcbNeeded = cbNeeded;
    }

    if (!pCurrentOut || cbRemain < 1)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    *pCurrentOut = NUL;

    //
    // Succeeded
    //

    hr = S_OK;

    exit:

    MemFree(pabEnabledOptions);
    return hr;
}


/*++

Routine Name:

    HWhyConstrained

Routine Description:

    get feature/option keyword pair that constrains the given
    feature/option pair

Arguments:

    poemuiobj - pointer to driver context object
    dwFlags - flags for this operation
    pszFeatureKeyword - feature keyword name
    pszOptionKeyword - option keyword name
    pmszReasonList - pointer to output data buffer
    cbSize - output data buffer size in bytes
    pcbNeeded - buffer size in bytes needed to store the output data

Return Value:

    S_OK            if succeeds
    E_OUTOFMEMORY   if output data buffer size is not big enough
    E_INVALIDARG    if the feature keyword name or option keyword name
                    is not recognized, or the feature's stickiness
                    doesn't match current sticky-mode

Last Error:

    None

--*/
HRESULT
HWhyConstrained(
    IN  POEMUIOBJ  poemuiobj,
    IN  DWORD      dwFlags,
    IN  PCSTR      pszFeatureKeyword,
    IN  PCSTR      pszOptionKeyword,
    OUT PSTR       pmszReasonList,
    IN  DWORD      cbSize,
    OUT PDWORD     pcbNeeded
    )
{
    PCOMMONINFO   pci = (PCOMMONINFO)poemuiobj;
    PUIDATA       pUiData;
    PFEATURE      pFeature;
    POPTION       pOption;
    DWORD         dwFeatureIndex, dwOptionIndex;
    CONFLICTPAIR  ConflictPair;
    BOOL          bConflictFound;
    PSTR          pszConfFeatureName = NULL, pszConfOptionName = NULL;
    CHAR          emptyString[1] = {0};
    DWORD         cbConfFeatureKeySize = 0, cbConfOptionKeySize = 0;
    DWORD         cbNeeded = 0;

    pUiData = (PUIDATA)pci;

    if (!pszFeatureKeyword ||
        (pFeature = PGetNamedFeature(pci->pUIInfo, pszFeatureKeyword, &dwFeatureIndex)) == NULL)
    {
        WARNING(("HWhyConstrained: invalid feature\n"));
        return E_INVALIDARG;
    }

    if (!pszOptionKeyword ||
        (pOption = PGetNamedOption(pci->pUIInfo, pFeature, pszOptionKeyword, &dwOptionIndex)) == NULL)
    {
        WARNING(("HWhyConstrained: invalid option\n"));
        return E_INVALIDARG;
    }

    //
    // See comments in HEnumConstrainedOptions() for following stickiness mode check.
    //

    if ((pUiData->iMode == MODE_DOCUMENT_STICKY && pFeature->dwFeatureType == FEATURETYPE_PRINTERPROPERTY) ||
        (pUiData->iMode == MODE_PRINTER_STICKY && pFeature->dwFeatureType != FEATURETYPE_PRINTERPROPERTY))
    {
        VERBOSE(("HWhyConstrained: mismatch iMode=%d, dwFeatureType=%d\n",pUiData->iMode, pFeature->dwFeatureType));
        return E_INVALIDARG;
    }

    //
    // Get the feature/option pair that constrains the feature/option pair client is querying for.
    //

    bConflictFound = EnumNewPickOneUIConflict(pci->pRawData,
                                              pci->pCombinedOptions,
                                              dwFeatureIndex,
                                              dwOptionIndex,
                                              &ConflictPair);

    if (bConflictFound)
    {
        PFEATURE  pConfFeature;
        POPTION   pConfOption;
        DWORD     dwConfFeatureIndex, dwConfOptionIndex;

        //
        // ConflictPair has the feature with higher priority as dwFeatureIndex1.
        //

        if (dwFeatureIndex == ConflictPair.dwFeatureIndex1)
        {
            dwConfFeatureIndex = ConflictPair.dwFeatureIndex2;
            dwConfOptionIndex = ConflictPair.dwOptionIndex2;
        }
        else
        {
            dwConfFeatureIndex = ConflictPair.dwFeatureIndex1;
            dwConfOptionIndex = ConflictPair.dwOptionIndex1;
        }

        pConfFeature = PGetIndexedFeature(pci->pUIInfo, dwConfFeatureIndex);
        ASSERT(pConfFeature);

        pConfOption = PGetIndexedOption(pci->pUIInfo, pConfFeature, dwConfOptionIndex);

        //
        // We don't expect pConfOption to be NULL here. Use the ASSERT to catch cases we missed.
        //

        ASSERT(pConfOption);

        pszConfFeatureName = OFFSET_TO_POINTER(pci->pUIInfo->pubResourceData, pConfFeature->loKeywordName);
        ASSERT(pszConfFeatureName);

        if (pConfOption)
        {
            pszConfOptionName = OFFSET_TO_POINTER(pci->pUIInfo->pubResourceData, pConfOption->loKeywordName);
            ASSERT(pszConfOptionName);
        }
        else
        {
            pszConfOptionName = &(emptyString[0]);
        }

        //
        // count in the 2 NUL characters: one after feature name, one after option name.
        //

        cbConfFeatureKeySize = strlen(pszConfFeatureName) + 1;
        cbConfOptionKeySize = strlen(pszConfOptionName) + 1;
    }

    //
    // count in the last NUL characters at the end.
    //

    cbNeeded = cbConfFeatureKeySize + cbConfOptionKeySize + 1;

    if (pcbNeeded)
    {
        *pcbNeeded = cbNeeded;
    }

    if (!pmszReasonList || cbSize < cbNeeded)
    {
        return E_OUTOFMEMORY;
    }

    if (bConflictFound)
    {
        ASSERT(pszConfFeatureName && pszConfOptionName);

        CopyMemory(pmszReasonList, pszConfFeatureName, cbConfFeatureKeySize);
        pmszReasonList += cbConfFeatureKeySize;

        CopyMemory(pmszReasonList, pszConfOptionName, cbConfOptionKeySize);
        pmszReasonList += cbConfOptionKeySize;
    }

    //
    // Now the NUL at the end to finish the MULTI_SZ output string.
    //

    *pmszReasonList = NUL;

    return S_OK;
}

#endif // PSCRIPT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\driverui\oemui.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    oemui.h

Abstract:

    Header file to support OEM plugin UI

Environment:

    Windows NT printer drivers

Revision History:

    02/13/97 -davidx-
        Created it.

--*/

#ifndef _OEMUI_H_
#define _OEMUI_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// Macros used to loop through each OEM plugin
//

#define FOREACH_OEMPLUGIN_LOOP(pci) \
        { \
            DWORD _oemCount = (pci)->pOemPlugins->dwCount; \
            POEM_PLUGIN_ENTRY pOemEntry = (pci)->pOemPlugins->aPlugins; \
            for ( ; _oemCount--; pOemEntry++) \
            { \
                if (pOemEntry->hInstance == NULL) continue;

#define END_OEMPLUGIN_LOOP \
            } \
        }

//
// Call OEM plugin UI modules to let them add their OPTITEMs
//

BOOL
BPackOemPluginItems(
    PUIDATA pUiData
    );

//
// Call OEM plugin module's callback function
//

LONG
LInvokeOemPluginCallbacks(
    PUIDATA         pUiData,
    PCPSUICBPARAM   pCallbackParam,
    LONG            lRet
    );

//
// Call OEM plugin UI modules to let them add their own property sheet pages
//

BOOL
BAddOemPluginPages(
    PUIDATA pUiData,
    DWORD   dwFlags
    );

//
// Figure whether a particular item is belongs to the driver
// (instead of to one of the OEM plugin UI modules)
//

#define IS_DRIVER_OPTITEM(pUiData, pOptItem) \
        ((DWORD) ((pOptItem) - (pUiData)->pDrvOptItem) < (pUiData)->dwDrvOptItem)


//
// Provide OEM plugins access to driver private settings
//

BOOL
APIENTRY
BGetDriverSettingForOEM(
    PCOMMONINFO pci,
    PCSTR       pFeatureKeyword,
    PVOID       pOutput,
    DWORD       cbSize,
    PDWORD      pcbNeeded,
    PDWORD      pdwOptionsReturned
    );

BOOL
BUpdateUISettingForOEM(
    PCOMMONINFO pci,
    PVOID       pOptItem,
    DWORD       dwPreviousSelection,
    DWORD       dwMode
    );


BOOL
BUpgradeRegistrySettingForOEM(
    HANDLE      hPrinter,
    PCSTR       pFeatureKeyword,
    PCSTR       pOptionKeyword
    );


extern const OEMUIPROCS OemUIHelperFuncs;

HRESULT
HDriver_CoCreateInstance(
    IN REFCLSID     rclsid,
    IN LPUNKNOWN    pUnknownOuter,
    IN DWORD        dwClsContext,
    IN REFIID       riid,
    IN LPVOID      *ppv,
    IN HANDLE       hInstance
    );

//
// The following helper functions are only available to UI plugins
//

#ifdef PSCRIPT

#ifndef WINNT_40

HRESULT
HQuerySimulationSupport(
    IN  HANDLE  hPrinter,
    IN  DWORD   dwLevel,
    OUT PBYTE   pCaps,
    IN  DWORD   cbSize,
    OUT PDWORD  pcbNeeded
    );

#endif // !WINNT_40

HRESULT
HEnumConstrainedOptions(
    IN  POEMUIOBJ  poemuiobj,
    IN  DWORD      dwFlags,
    IN  PCSTR      pszFeatureKeyword,
    OUT PSTR       pmszConstrainedOptionList,
    IN  DWORD      cbSize,
    OUT PDWORD     pcbNeeded
    );

HRESULT
HWhyConstrained(
    IN  POEMUIOBJ  poemuiobj,
    IN  DWORD      dwFlags,
    IN  PCSTR      pszFeatureKeyword,
    IN  PCSTR      pszOptionKeyword,
    OUT PSTR       pmszReasonList,
    IN  DWORD      cbSize,
    OUT PDWORD     pcbNeeded
    );

HRESULT
HSetOptions(
    IN  POEMUIOBJ  poemuiobj,
    IN  DWORD      dwFlags,
    IN  PCSTR      pmszFeatureOptionBuf,
    IN  DWORD      cbIn,
    OUT PDWORD     pdwResult
    );

#endif // PSCRIPT

#ifdef __cplusplus
}
#endif

#endif  // !_OEMUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\driverui\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Sources file shared by PostScript and UniDriver UI

!ENDIF

!include $(PRNROOT)\print.inc

USE_MSVCRT=1

TARGETPATH=obj
TARGETTYPE=DYNLINK
TARGETLIBS=\
    $(PRNROOT)\lib\utils\um\$(O)\utils.lib  \
    $(PRNROOT)\lib\oemutil\um\$(O)\oemutil.lib  \
    $(PRNROOT)\lib\helper\um\$(O)\helper.lib  \
    $(SDK_LIB_PATH)\user32.lib   \
    $(SDK_LIB_PATH)\kernel32.lib \
    $(SDK_LIB_PATH)\winspool.lib \
    $(SDK_LIB_PATH)\gdi32.lib    \
    $(SDK_LIB_PATH)\shell32.lib  \
    $(SDK_LIB_PATH)\comctl32.lib \
    $(SDK_LIB_PATH)\ntdll.lib

DLLENTRY=_DllMainCRTStartup
NTPROFILEINPUT=yes

!if defined(WINNT_40)
INCLUDES=$(INCLUDES);.;..;$(BASEDIR)\private\windows\inc;$(PRNROOT)\parsers\ppd;$(PRNROOT)\unidrv2\inc
!else
INCLUDES=$(INCLUDES);.;..;$(PRNROOT)\parsers\ppd;$(PRNROOT)\unidrv2\inc; \
    $(WINDOWS_INC_PATH);
!endif

C_DEFINES=$(C_DEFINES) -DOEMCOM

SOURCES=\
    ..\intfui.cxx  \
    ..\initdll.c    \
    ..\fontsub.c    \
    ..\commonui.c   \
    ..\dm.c         \
    ..\driverui.c   \
    ..\devcaps.c    \
    ..\docprop.c    \
    ..\prnprop.c    \
    ..\prnevent.c   \
    ..\quryprnt.c   \
    ..\upgrade.c    \
    ..\forms.c      \
    ..\oemui.c      \
    ..\driverui.rc

PRECOMPILED_INCLUDE=precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\driverui\quryprnt.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    quryprnt.c

Abstract:

    This file handles the DrvQueryPrintEx spooler API

Environment:

    Win32 subsystem, DriverUI module, user mode

Revision History:

    02/13/97 -davidx-
        Implement OEM plugin support.

    02/08/97 -davidx-
        Rewrote it to use common data management functions.

    02/04/97 -davidx-
        Reorganize driver UI to separate ps and uni DLLs.

    07/17/96 -amandan-
        Created it.

--*/

#include "precomp.h"


//
// Forward declaration of local functions
//

BOOL BFormatDQPMessage(PDEVQUERYPRINT_INFO, INT, ...);
BOOL BQueryPrintDevmode(PDEVQUERYPRINT_INFO, PCOMMONINFO);
BOOL BQueryPrintForm(PDEVQUERYPRINT_INFO, PCOMMONINFO);


BOOL
DevQueryPrintEx(
    PDEVQUERYPRINT_INFO pDQPInfo
    )

/*++

Routine Description:

    This function checks whether the job can be printed with
    DEVMODE passed in.  This function will use the following
    criterias to determine whether the job is printable:
    - get basic printer information
    - verify input devmode
    - verify resolution is supported
    - verify there is no conflicts between printer feature selections
    - verify form-to-tray assignment

Arguments:

    pDQPInfo - Points to a DEVQUERYPRINT_INFO structure

Return Value:

    TRUE if the job can be printed with the given DEVMODE, otherwise FALSE

--*/

{
    PCOMMONINFO pci;
    BOOL        bResult;

    if (pDQPInfo == NULL || pDQPInfo->hPrinter == NULL)
        return BFormatDQPMessage(pDQPInfo, IDS_DQPERR_PARAM);

    if (pDQPInfo->pDevMode == NULL)
        return TRUE;

    if ((pci = PLoadCommonInfo(pDQPInfo->hPrinter, NULL, 0)) == NULL)
        return BFormatDQPMessage(pDQPInfo, IDS_DQPERR_COMMONINFO);

    bResult = BQueryPrintDevmode(pDQPInfo, pci) &&
              BQueryPrintForm(pDQPInfo, pci);

    if (bResult)
    {
        PFN_OEMDevQueryPrintEx pfnOEMDevQueryPrintEx;

        //
        // call OEMDevQueryPrintEx entrypoint for each plugin,
        // or until one of them returns FALSE.
        //

        FOREACH_OEMPLUGIN_LOOP(pci)

            if (HAS_COM_INTERFACE(pOemEntry))
            {
                HRESULT hr;

                hr = HComOEMDevQueryPrintEx(pOemEntry,
                                            &pci->oemuiobj,
                                            pDQPInfo,
                                            pci->pdm,
                                            pOemEntry->pOEMDM);
                if (hr == E_NOTIMPL)
                    continue;

                if (!(bResult = SUCCEEDED(hr)))
                    break;

            }
            else
            {
                if ((pfnOEMDevQueryPrintEx = GET_OEM_ENTRYPOINT(pOemEntry, OEMDevQueryPrintEx)) &&
                    !pfnOEMDevQueryPrintEx(&pci->oemuiobj, pDQPInfo, pci->pdm, pOemEntry->pOEMDM))
                {
                    ERR(("OEMDevQueryPrintEx failed for '%ws': %d\n",
                        CURRENT_OEM_MODULE_NAME(pOemEntry),
                        GetLastError()));

                    bResult = FALSE;
                    break;
                }
            }

        END_OEMPLUGIN_LOOP
    }

    VFreeCommonInfo(pci);
    return bResult;
}



BOOL
BFormatDQPMessage(
    PDEVQUERYPRINT_INFO pDQPInfo,
    INT                 iMsgResId,
    ...
    )

/*++

Routine Description:

    Format DevQueryPrintEx error message

Arguments:

    pDQPInfo - Points to a DEVQUERYPRINT_INFO structure
    iMsgResId - Error message format specifier (string resource ID)

Return Value:

    FALSE

--*/

#define MAX_FORMAT_STRING   256
#define MAX_DQP_MESSAGE     512

{
    TCHAR   awchFormat[MAX_FORMAT_STRING];
    TCHAR   awchMessage[MAX_DQP_MESSAGE];
    INT     iLength;
    va_list arglist;

    //
    // Load the format specifier string resource
    // and use swprintf to format the error message
    //

    va_start(arglist, iMsgResId);

    if (! LoadString(ghInstance, iMsgResId, awchFormat, MAX_FORMAT_STRING))
        awchFormat[0] = NUL;

    iLength = vswprintf(awchMessage, awchFormat, arglist);

    if (iLength <= 0)
    {
        wcscpy(awchMessage, L"Error");
        iLength = wcslen(awchMessage);
    }

    va_end(arglist);

    //
    // Copy the error message string to DQPInfo
    //

    iLength += 1;
    pDQPInfo->cchNeeded = iLength;

    if (iLength > (INT) pDQPInfo->cchErrorStr)
        iLength = pDQPInfo->cchErrorStr;

    if (pDQPInfo->pszErrorStr && iLength)
        CopyString(pDQPInfo->pszErrorStr, awchMessage, iLength);

    return FALSE;
}



BOOL
BQueryPrintDevmode(
    PDEVQUERYPRINT_INFO pDQPInfo,
    PCOMMONINFO         pci
    )

/*++

Routine Description:

    Validate devmode information

Arguments:

    pDQPInfo - Points to a DEVQUERYPRINT_INFO structure
    pci - Points to basic printer info

Return Value:

    TRUE if successful, FALSE if the job should be held

--*/

{
    INT       iRealizedRes, iResX, iResY;
    PFEATURE  pFeature;
    DWORD     dwFeatureIndex, dwOptionIndexOld, dwOptionIndexNew;
    BOOL      bUpdateFormField;

    //
    // Validate input devmode
    // Get printer-sticky properties
    // Merge doc- and printer-sticky printer feature selections
    // Fix up combined options array with public devmode info
    //

    if (! BFillCommonInfoDevmode(pci, NULL, pDQPInfo->pDevMode))
        return BFormatDQPMessage(pDQPInfo, IDS_DQPERR_DEVMODE);

    if (! BFillCommonInfoPrinterData(pci))
        return BFormatDQPMessage(pDQPInfo, IDS_DQPERR_PRINTERDATA);

    if (! BCombineCommonInfoOptionsArray(pci))
        return BFormatDQPMessage(pDQPInfo, IDS_DQPERR_MEMORY);

    VFixOptionsArrayWithDevmode(pci);

    //
    // Remember the paper size option parser picked to support the devmode form
    //

    if ((pFeature = GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_PAGESIZE)) == NULL)
    {
        ASSERT(FALSE);
        return BFormatDQPMessage(pDQPInfo, IDS_DQPERR_DEVMODE);
    }

    dwFeatureIndex = GET_INDEX_FROM_FEATURE(pci->pUIInfo, pFeature);
    dwOptionIndexOld = pci->pCombinedOptions[dwFeatureIndex].ubCurOptIndex;

    if (! ResolveUIConflicts(
                pci->pRawData,
                pci->pCombinedOptions,
                MAX_COMBINED_OPTIONS,
                MODE_DOCANDPRINTER_STICKY|DONT_RESOLVE_CONFLICT))
    {
        return BFormatDQPMessage(pDQPInfo, IDS_DQPERR_OPTSELECT);
    }

    dwOptionIndexNew = pci->pCombinedOptions[dwFeatureIndex].ubCurOptIndex;

    bUpdateFormField = FALSE;

    if (dwOptionIndexNew != dwOptionIndexOld)
    {
        //
        // Constraint resolving has changed page size selection, so we need
        // to update devmode's form fields.
        //

        bUpdateFormField = TRUE;
    }
    else
    {
        FORM_INFO_1  *pForm = NULL;

        //
        // Unless the form requested by devmode is not supported on the printer,
        // we still want to show the original form name in upcoming doc-setting UI.
        // For example, if input devmode requested "Legal", parser maps it to option
        // "OEM Legal", but both "Legal" and "OEM Legal" will be shown as supported
        // forms on the printer, then we should still show "Legal" instead of "OEM Legal"
        // in UI's PageSize list. However, if input devmode requestd "8.5 x 12", which
        // won't be shown as a supportd form and it's mapped to "OEM Legal", then we should
        // show "OEM Legal".
        //

        //
        // pdm->dmFormName won't have a valid form name for custom page size (see
        // BValidateDevmodeFormFields()). VOptionsToDevmodeFields() knows to handle that.
        //

        if ((pci->pdm->dmFields & DM_FORMNAME) &&
            (pForm = MyGetForm(pci->hPrinter, pci->pdm->dmFormName, 1)) &&
            !BFormSupportedOnPrinter(pci, pForm, &dwOptionIndexNew))
        {
            bUpdateFormField = TRUE;
        }

        MemFree(pForm);
    }

    VOptionsToDevmodeFields(pci, bUpdateFormField);

    if (! BUpdateUIInfo(pci))
        return BFormatDQPMessage(pDQPInfo, IDS_DQPERR_COMMONINFO);

    //
    // Check if the requested resolution is supported
    //

    iRealizedRes = max(pci->pdm->dmPrintQuality, pci->pdm->dmYResolution);
    iResX = iResY = 0;

    //
    // Kludze, there are some cases where apps set dmPrintQuality/dmYResolution
    // to be one of the DMRES values. We skip the checking for resolution
    // since Unidrv/Pscript will map them to one of the valid resolution options
    // at print time
    //

    if (pDQPInfo->pDevMode->dmFields & DM_PRINTQUALITY)
    {
        iResX = pDQPInfo->pDevMode->dmPrintQuality;

        if (iResX <= DMRES_DRAFT)
            return TRUE;
    }

    if (pDQPInfo->pDevMode->dmFields & DM_YRESOLUTION)
    {
        iResY = pDQPInfo->pDevMode->dmYResolution;

        if (iResY <= DMRES_DRAFT)
            return TRUE;
    }

    if (max(iResX, iResY) != iRealizedRes)
        return BFormatDQPMessage(pDQPInfo, IDS_DQPERR_RESOLUTION);

    return TRUE;
}



BOOL
BQueryPrintForm(
    PDEVQUERYPRINT_INFO pDQPInfo,
    PCOMMONINFO         pci
    )

/*++

Routine Description:

    Check if the requested form and/or tray is available

Arguments:

    pDQPInfo - Points to a DEVQUERYPRINT_INFO structure
    pci - Points to basic printer info

Return Value:

    TRUE if successful, FALSE if the job should be held

--*/

{
    PUIINFO         pUIInfo;
    PFEATURE        pFeature;
    PPAGESIZE       pPageSize;
    PWSTR           pwstrTrayName;
    FORM_TRAY_TABLE pFormTrayTable;
    FINDFORMTRAY    FindData;
    WCHAR           awchTrayName[CCHBINNAME];
    DWORD           dwFeatureIndex, dwOptionIndex;
    BOOL            bResult = FALSE;

    //
    // Skip it if form name is not specified
    //

    if ((pci->pdm->dmFields & DM_FORMNAME) == 0 ||
        pci->pdm->dmFormName[0] == NUL)
    {
        return TRUE;
    }

    pUIInfo = pci->pUIInfo;

    if ((pFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_PAGESIZE)) == NULL)
    {
        ASSERT(FALSE);
        return TRUE;
    }

    dwFeatureIndex = GET_INDEX_FROM_FEATURE(pUIInfo, pFeature);
    dwOptionIndex = pci->pCombinedOptions[dwFeatureIndex].ubCurOptIndex;

    if ((pPageSize = PGetIndexedOption(pUIInfo, pFeature, dwOptionIndex)) == NULL)
    {
        ASSERT(FALSE);
        return TRUE;
    }

    //
    // For custom page size option, we have left the devmode form fields unchanged.
    // See function VOptionToDevmodeFields().
    //

    //
    // We've only shown user forms supported by custom page size in Form-to-Tray table.
    //

    if (pPageSize->dwPaperSizeID == DMPAPER_USER ||
        pPageSize->dwPaperSizeID == DMPAPER_CUSTOMSIZE)
    {
        FORM_INFO_1  *pForm;

        //
        // We already verified the dmFormName field at the beginning.
        //

        if (pForm = MyGetForm(pci->hPrinter, pci->pdm->dmFormName, 1))
        {
            //
            // Built-in and printer forms supported by custom page size option won't show
            // up in either PageSize list or Form-to-Tray assignment table. So we only
            // continue to check the From-to-Tray assignment table for user forms supported
            // by custom page size option. See function BFormSupportedOnPrinter().
            //

            if (pForm->Flags != FORM_USER)
            {
                MemFree(pForm);
                return TRUE;
            }

            MemFree(pForm);
        }
    }

    //
    // Get the specified tray name, if any
    //

    pwstrTrayName = NULL;

    if (pFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_INPUTSLOT))
    {
        PINPUTSLOT  pInputSlot;

        dwFeatureIndex = GET_INDEX_FROM_FEATURE(pUIInfo, pFeature);
        dwOptionIndex = pci->pCombinedOptions[dwFeatureIndex].ubCurOptIndex;

        if ((pInputSlot = PGetIndexedOption(pUIInfo, pFeature, dwOptionIndex)) &&
            (pInputSlot->dwPaperSourceID != DMBIN_FORMSOURCE) &&
            LOAD_STRING_OPTION_NAME(pci, pInputSlot, awchTrayName, CCHBINNAME))
        {
            pwstrTrayName = awchTrayName;
        }
    }

    //
    // Find out if the requested form/tray pair is
    // listed in the form-to-tray assignment table.
    //

    if (pFormTrayTable = PGetFormTrayTable(pci->hPrinter, NULL))
    {
        RESET_FINDFORMTRAY(pFormTrayTable, &FindData);

        bResult = BSearchFormTrayTable(pFormTrayTable,
                                       pwstrTrayName,
                                       pci->pdm->dmFormName,
                                       &FindData);
        MemFree(pFormTrayTable);
    }

    if (! bResult)
    {
        if (pwstrTrayName != NULL)
        {
            return BFormatDQPMessage(pDQPInfo,
                                     IDS_DQPERR_FORMTRAY,
                                     pci->pdm->dmFormName,
                                     pwstrTrayName);
        }
        else
        {
            return BFormatDQPMessage(pDQPInfo,
                                     IDS_DQPERR_FORMTRAY_ANY,
                                     pci->pdm->dmFormName);
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\driverui\prnprop.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    prnprop.c

Abstract:

    This file handles the PrinterProperties and
    DrvDevicePropertySheets spooler API

Environment:

    Win32 subsystem, DriverUI module, user mode

Revision History:

    02/13/97 -davidx-
        Implement OEM plugin support.

    02/10/97 -davidx-
        Consistent handling of common printer info.

    02/04/97 -davidx-
        Reorganize driver UI to separate ps and uni DLLs.

    07/17/96 -amandan-
        Created it.

--*/


#include "precomp.h"

//
// Local functions prototypes
//

CPSUICALLBACK cpcbPrinterPropertyCallback(PCPSUICBPARAM);
LONG LPrnPropApplyNow(PUIDATA, PCPSUICBPARAM, BOOL);
LONG LPrnPropSelChange(PUIDATA, PCPSUICBPARAM);


LONG
DrvDevicePropertySheets(
    PPROPSHEETUI_INFO   pPSUIInfo,
    LPARAM              lParam
    )

/*++

Routine Description:

    This function adds the Device Property Page to the
    property sheets.

    This function performs the following operations:

        REASON_INIT- fills PCOMPROPSHEETUI with printer UI items
                    calls compstui to add the page.

        REASON_GET_INFO_HEADER - fills out PROPSHEETUI_INFO.

        REASON_SET_RESULT - saves printerdata settings in registry buffer.

        REASON_DESTROY - Cleans up.

Arguments:

    pSUIInfo - pointer to PPROPSHEETUI_INFO
    lParam - varies depending on the reason this function is called

Return Value:

    > 0 success <= 0 for failure

--*/

{
    PDEVICEPROPERTYHEADER   pDPHdr;
    PCOMPROPSHEETUI         pCompstui;
    PUIDATA                 pUiData;
    LONG                    lResult, lRet;
    BOOL                    bResult = FALSE;

    //
    // Validate input parameters
    //

    if (!pPSUIInfo || !(pDPHdr = (PDEVICEPROPERTYHEADER) pPSUIInfo->lParamInit))
    {
        RIP(("DrvDevicePropertySheet: invalid parameter\n"));
        return -1;
    }

    //
    // Create a UIDATA structure if necessary
    //

    if (pPSUIInfo->Reason == PROPSHEETUI_REASON_INIT)
    {
        pUiData = PFillUiData(pDPHdr->hPrinter,
                              pDPHdr->pszPrinterName,
                              NULL,
                              MODE_PRINTER_STICKY);
    }
    else
        pUiData = (PUIDATA)pPSUIInfo->UserData;

    //
    // Validate pUiData
    //

    if (pUiData == NULL)
    {
        ERR(("UIDATA is NULL\n"));
        return -1;
    }

    ASSERT(VALIDUIDATA(pUiData));

    //
    // Handle various cases for which this function might be called
    //

    switch (pPSUIInfo->Reason)
    {
    case PROPSHEETUI_REASON_INIT:

        //
        // Allocate memory and partially fill out various data
        // structures required to call common UI routine.
        //

        pUiData->bPermission = ((pDPHdr->Flags & DPS_NOPERMISSION) == 0);

        #ifdef PSCRIPT

        FOREACH_OEMPLUGIN_LOOP((&(pUiData->ci)))

            if (HAS_COM_INTERFACE(pOemEntry))
            {
                HRESULT hr;

                hr = HComOEMHideStandardUI(pOemEntry,
                                           OEMCUIP_PRNPROP);

                //
                // In the case when multiple plugins are chained, it doesn't
                // make sense for one plugin to hide standard UI when another
                // one still wants to use the standard UI. So as long as one
                // plugin returns S_OK here, we will hide the standard UI.
                //

                if (bResult = SUCCEEDED(hr))
                    break;
            }

        END_OEMPLUGIN_LOOP

        #endif // PSCRIPT

        if (bResult)
        {
            //
            // Set the flag to indicate plugin is hiding our standard
            // device property sheet UI.
            //

            pUiData->dwHideFlags |= HIDEFLAG_HIDE_STD_PRNPROP;

            pUiData->pfnComPropSheet = pPSUIInfo->pfnComPropSheet;
            pUiData->hComPropSheet = pPSUIInfo->hComPropSheet;

            if (BAddOemPluginPages(pUiData, pDPHdr->Flags))
            {
                pPSUIInfo->UserData = (ULONG_PTR) pUiData;
                pPSUIInfo->Result = CPSUI_CANCEL;
                lRet = 1;
                break;
            }
        }
        else if (pCompstui = PPrepareDataForCommonUI(pUiData, CPSUI_PDLGPAGE_PRINTERPROP))
        {
            pCompstui->pfnCallBack = cpcbPrinterPropertyCallback;
            pUiData->pfnComPropSheet = pPSUIInfo->pfnComPropSheet;
            pUiData->hComPropSheet = pPSUIInfo->hComPropSheet;
            pUiData->pCompstui = pCompstui;

            //
            // Show which items are constrained
            //

            VPropShowConstraints(pUiData, MODE_PRINTER_STICKY);

            //
            // Update the current selection of tray items based on
            // the form-to-tray assignment table.
            //

            VSetupFormTrayAssignments(pUiData);

            //
            // Call common UI library to add our pages
            //

            if (pUiData->pfnComPropSheet(pUiData->hComPropSheet,
                                         CPSFUNC_ADD_PCOMPROPSHEETUI,
                                         (LPARAM) pCompstui,
                                         (LPARAM) &lResult) &&
                BAddOemPluginPages(pUiData, pDPHdr->Flags))
            {
                pPSUIInfo->UserData = (ULONG_PTR) pUiData;
                pPSUIInfo->Result = CPSUI_CANCEL;

                lRet = 1;
                break;
            }
        }

        //
        // Clean up in the case of error
        //

        ERR(("Failed to initialize property sheets\n"));
        VFreeUiData(pUiData);
        return -1;


    case PROPSHEETUI_REASON_GET_INFO_HEADER:
        {
            PPROPSHEETUI_INFO_HEADER pPSUIHdr;
            DWORD                    dwIcon;

            pPSUIHdr = (PPROPSHEETUI_INFO_HEADER) lParam;
            pPSUIHdr->Flags = PSUIHDRF_PROPTITLE | PSUIHDRF_NOAPPLYNOW;
            pPSUIHdr->pTitle = pUiData->ci.pPrinterName;
            pPSUIHdr->hInst = ghInstance;

            //
            // Use the Icon specified in the binary data as
            // the printer icon.
            //

            dwIcon = pUiData->ci.pUIInfo->loPrinterIcon;

            if (dwIcon && (pPSUIHdr->IconID = HLoadIconFromResourceDLL(&pUiData->ci, dwIcon)))
                pPSUIHdr->Flags |= PSUIHDRF_USEHICON;
            else
                pPSUIHdr->IconID = _DwGetPrinterIconID();
        }
        lRet = 1;
        break;

    case PROPSHEETUI_REASON_SET_RESULT:

        {
            PSETRESULT_INFO pSRInfo = (PSETRESULT_INFO) lParam;
            PCOMMONINFO pci = (PCOMMONINFO)pUiData;

            //
            // CPSUICB_REASON_APPLYNOW may not have been called. If so, we need
            // to perform tasks that are usually done by CPSUICB_REASON_APPLYNOW
            // case in our callback function cpcbPrinterPropertyCallback.
            //

            if ((pSRInfo->Result == CPSUI_OK) &&
                !(pci->dwFlags & FLAG_APPLYNOW_CALLED))
            {
                OPTSELECT OldCombinedOptions[MAX_COMBINED_OPTIONS];

                //
                // Save a copy the pre-resolve option array
                //

                CopyMemory(OldCombinedOptions,
                           pci->pCombinedOptions,
                           MAX_COMBINED_OPTIONS * sizeof(OPTSELECT));

                //
                // Call the parsers to resolve any remaining conflicts.
                //

                ResolveUIConflicts(pci->pRawData,
                                   pci->pCombinedOptions,
                                   MAX_COMBINED_OPTIONS,
                                   MODE_PRINTER_STICKY);

                //
                // Update the OPTITEM list to match the updated options array
                //

                VUpdateOptItemList(pUiData, OldCombinedOptions, pci->pCombinedOptions);

                (VOID)LPrnPropApplyNow(pUiData, NULL, TRUE);
            }

            pPSUIInfo->Result = pSRInfo->Result;
        }

        lRet = 1;
        break;

    case PROPSHEETUI_REASON_DESTROY:

        //
        // Clean up
        //

        VFreeUiData(pUiData);
        lRet = 1;

        break;

    default:

        return -1;
    }

    return lRet;
}



CPSUICALLBACK
cpcbPrinterPropertyCallback(
    IN  PCPSUICBPARAM pCallbackParam
    )

/*++

Routine Description:

    Callback function provided to common UI DLL for handling
    printer properties dialog.

Arguments:

    pCallbackParam - Pointer to CPSUICBPARAM structure

Return Value:

    CPSUICB_ACTION_NONE - no action needed
    CPSUICB_ACTION_OPTIF_CHANGED - items changed and should be refreshed

--*/

{
    PUIDATA pUiData = (PUIDATA) pCallbackParam->UserData;
    LONG    lRet;

    ASSERT(VALIDUIDATA(pUiData));
    pUiData->hDlg = pCallbackParam->hDlg;

    //
    // If user has no permission to change anything, then
    // simply return without taking any action.
    //

    if (!HASPERMISSION(pUiData) && (pCallbackParam->Reason != CPSUICB_REASON_ABOUT))
        return CPSUICB_ACTION_NONE;

    switch (pCallbackParam->Reason)
    {
    case CPSUICB_REASON_SEL_CHANGED:
    case CPSUICB_REASON_ECB_CHANGED:

        lRet = LPrnPropSelChange(pUiData, pCallbackParam);
        break;

    case CPSUICB_REASON_ITEMS_REVERTED:

        {
            POPTITEM    pOptItem;
            DWORD       dwOptItem;

            //
            // This callback reason is used when user changed items
            // and decided to revert changes from the parent item in
            // the treeview.  The callback funciton is called after
            // all revertable items are reverted to its original.
            // Only deal with installable feature at this point
            //

            dwOptItem = pUiData->dwFeatureItem;
            pOptItem = pUiData->pFeatureItems;

            for ( ; dwOptItem--; pOptItem++)
                VUpdateOptionsArrayWithSelection(pUiData, pOptItem);

            //
            // Show which items are constrained
            //

            VPropShowConstraints(pUiData, MODE_PRINTER_STICKY);
        }

        lRet = CPSUICB_ACTION_REINIT_ITEMS;
        break;

    case CPSUICB_REASON_APPLYNOW:

        pUiData->ci.dwFlags |= FLAG_APPLYNOW_CALLED;

        lRet = LPrnPropApplyNow(pUiData, pCallbackParam, FALSE);
        break;


    case CPSUICB_REASON_ABOUT:

        DialogBoxParam(ghInstance,
                       MAKEINTRESOURCE(IDD_ABOUT),
                       pUiData->hDlg,
                       (DLGPROC) _AboutDlgProc,
                       (LPARAM) pUiData);
        break;

    #ifdef UNIDRV

    case CPSUICB_REASON_PUSHBUTTON:

        //
        // Call the font installer
        //

        if (GETUSERDATAITEM(pCallbackParam->pCurItem->UserData) == SOFTFONT_SETTINGS_ITEM)
        {
            BOOL bUseOurDlgProc = TRUE;
            OEMFONTINSTPARAM fip;
            PFN_OEMFontInstallerDlgProc pDlgProc = NULL;

            memset(&fip, 0, sizeof(OEMFONTINSTPARAM));
            fip.cbSize = sizeof(OEMFONTINSTPARAM);
            fip.hPrinter = pUiData->ci.hPrinter;
            fip.hModule = ghInstance;
            fip.hHeap = pUiData->ci.hHeap;
            if (HASPERMISSION(pUiData))
                fip.dwFlags = FG_CANCHANGE;


            FOREACH_OEMPLUGIN_LOOP(&pUiData->ci)

                if (HAS_COM_INTERFACE(pOemEntry))
                {

                    if (HComOEMFontInstallerDlgProc(pOemEntry,
                                                    NULL,
                                                    0,
                                                    0,
                                                    (LPARAM)&fip) != E_NOTIMPL)
                   {
                        HComOEMFontInstallerDlgProc(pOemEntry,
                                                    pUiData->hDlg,
                                                    0,
                                                    0,
                                                    (LPARAM)&fip);
                        bUseOurDlgProc = FALSE;
                        break;
                    }
                }
                else
                {
                    pDlgProc = GET_OEM_ENTRYPOINT(pOemEntry, OEMFontInstallerDlgProc);

                    if (pDlgProc)
                    {
                        (pDlgProc)(pUiData->hDlg, 0, 0, (LPARAM)&fip);
                        bUseOurDlgProc = FALSE;
                        break;
                    }
                }

            END_OEMPLUGIN_LOOP

            if (bUseOurDlgProc)
            {
                DialogBoxParam(ghInstance,
                               MAKEINTRESOURCE(FONTINST),
                               pUiData->hDlg,
                               (DLGPROC)FontInstProc,
                               (LPARAM)(&fip));
            }
        }

        break;

    #endif // UNIDRV

    default:

        lRet = CPSUICB_ACTION_NONE;
        break;
    }

    return LInvokeOemPluginCallbacks(pUiData, pCallbackParam, lRet);
}



LONG
LPrnPropSelChange(
    IN  PUIDATA       pUiData,
    IN  PCPSUICBPARAM pCallbackParam
    )
/*++

Routine Description:

    Handle the case where user changes the current selection of an item

Arguments:

    pUiData - Pointer to our UIDATA structure
    pCallbackParam - Callback parameter passed to us by common UI

Return Value:

    CPSUICB_ACTION_NONE - no action needed
    CPSUICB_ACTION_OPTIF_CHANGED - items changed and should be refreshed

--*/

{
    POPTITEM    pCurItem = pCallbackParam->pCurItem;
    PFEATURE    pFeature;

    if (! IS_DRIVER_OPTITEM(pUiData, pCurItem))
        return CPSUICB_ACTION_NONE;

    if (ISPRINTERFEATUREITEM(pCurItem->UserData))
    {
        //
        // Deal with generic printer features only here
        // All generic features have pFeature stored in UserData
        //

        pFeature = (PFEATURE) GETUSERDATAITEM(pCurItem->UserData);


        //
        // Update the pOptionsArray with the new selection
        //

        VUpdateOptionsArrayWithSelection(pUiData, pCurItem);

        //
        // PostScript specific hack to manually associate *InstalledMemory
        // printer feature with "Available PostScript Memory" option.
        //

        #ifdef PSCRIPT

        if (pFeature->dwFeatureID == GID_MEMOPTION)
        {
            POPTITEM    pVMOptItem;
            PMEMOPTION  pMemOption;

            if ((pVMOptItem = PFindOptItem(pUiData, PRINTER_VM_ITEM)) &&
                (pMemOption = PGetIndexedOption(pUiData->ci.pUIInfo, pFeature, pCurItem->Sel)))
            {
                PPRINTERDATA pPrinterData = pUiData->ci.pPrinterData;

                pVMOptItem->Flags |= OPTIF_CHANGED;
                pVMOptItem->Sel = pMemOption->dwFreeMem / KBYTES;

                pPrinterData->dwFreeMem = pMemOption->dwFreeMem;
                pUiData->ci.dwFlags &= ~FLAG_USER_CHANGED_FREEMEM;
            }
        }

        #endif // PSCRIPT

        //
        // Update the display and show which items are constrained
        //

        VPropShowConstraints(pUiData, MODE_PRINTER_STICKY);
        return CPSUICB_ACTION_REINIT_ITEMS;
    }

    #ifdef PSCRIPT

    if (GETUSERDATAITEM(pCurItem->UserData) == PRINTER_VM_ITEM)
    {
        //
        // remember the fact that current value of "Available PostScript Memory" is entered by user
        //

        pUiData->ci.dwFlags |= FLAG_USER_CHANGED_FREEMEM;
    }

    #endif // PSCRIPT

    return CPSUICB_ACTION_NONE;
}



VOID
VUnpackPrinterPropertiesItems(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Unpack printer properties treeview items

Arguments:

    pUiData - Pointer to our UIDATA structure

Return Value:

    NONE

Note:

    Only save the settings from driver built-in features, the
    generic features selection are saved in PrnPropSelChange directly
    to pUiData->pOptionsArray (in addition to formtray assignemtn and
    printer vm)

--*/

{
    PPRINTERDATA pPrinterData = pUiData->ci.pPrinterData;
    POPTITEM     pOptItem = pUiData->pDrvOptItem;
    DWORD        dwOptItem = pUiData->dwDrvOptItem;

    for ( ; dwOptItem > 0; dwOptItem--, pOptItem++)
    {
        switch (GETUSERDATAITEM(pOptItem->UserData))
        {
        case JOB_TIMEOUT_ITEM:

            pPrinterData->dwJobTimeout = pOptItem->Sel;
            break;

        case WAIT_TIMEOUT_ITEM:

            pPrinterData->dwWaitTimeout = pOptItem->Sel;
            break;

        case IGNORE_DEVFONT_ITEM:

            if (pOptItem->Sel == 0)
                pPrinterData->dwFlags &= ~PFLAGS_IGNORE_DEVFONT;
            else
                pPrinterData->dwFlags |= PFLAGS_IGNORE_DEVFONT;
            break;

        case PAGE_PROTECT_ITEM:
        {
            VUpdateOptionsArrayWithSelection(pUiData, pOptItem);

        }
            break;

        default:

            _VUnpackDriverPrnPropItem(pUiData, pOptItem);
            break;
        }
    }
}



LONG
LPrnPropApplyNow(
    PUIDATA         pUiData,
    PCPSUICBPARAM   pCallbackParam,
    BOOL            bFromSetResult
    )

/*++

Routine Description:

    Handle the case where user clicks OK to exit the dialog
    Need to save the printer sticky options in pUiData->pOptionsArray
    to printerdata.aOptions

Arguments:

    pUiData - Pointer to our UIDATA structure
    pCallbackParam - Callback parameter passed to us by common UI
    bFromSetResult - TRUE if called from PROPSHEETUI_REASON_SET_RESULT, FALSE otherwise.

Return Value:

    CPSUICB_ACTION_NONE - dismiss the dialog
    CPSUICB_ACTION_NO_APPLY_EXIT - don't dismiss the dialog

--*/

{
    PCOMMONINFO     pci;
    BOOL            bResult = TRUE;

    if (!bFromSetResult)
    {
        ASSERT(pCallbackParam);

        //
        // Check if there are still any unresolved constraints left?
        //

        if (((pUiData->ci.dwFlags & FLAG_PLUGIN_CHANGED_OPTITEM) ||
             BOptItemSelectionsChanged(pUiData->pDrvOptItem, pUiData->dwDrvOptItem)) &&
            ICheckConstraintsDlg(pUiData,
                                 pUiData->pFeatureItems,
                                 pUiData->dwFeatureItem,
                                 TRUE) == CONFLICT_CANCEL)
        {
            //
            // Conflicts found and user clicked CANCEL to
            // go back to the dialog without dismissing it.
            //

            return CPSUICB_ACTION_NO_APPLY_EXIT;
        }
    }

    //
    // Unpack printer properties treeview items
    //

    VUnpackPrinterPropertiesItems(pUiData);

    //
    // Save form-to-tray assignment table
    // Save font substitution table
    // Save any driver-specific properties
    //

    if (! BUnpackItemFormTrayTable(pUiData))
    {
        ERR(("BUnpackItemFormTrayTable failed\n"));
        bResult = FALSE;
    }

    if (! BUnpackItemFontSubstTable(pUiData))
    {
        ERR(("BUnpackItemFontSubstTable failed\n"));
        bResult = FALSE;
    }

    if (! _BUnpackPrinterOptions(pUiData))
    {
        ERR(("_BUnpackPrinterOptions failed\n"));
        bResult = FALSE;
    }

    //
    // Separate the printer sticky options from the combined option array
    // and save it to printerdata.aOptions
    //

    pci = (PCOMMONINFO) pUiData;

    SeparateOptionArray(
            pci->pRawData,
            pci->pCombinedOptions,
            pci->pPrinterData->aOptions,
            MAX_PRINTER_OPTIONS,
            MODE_PRINTER_STICKY);

    if (!BSavePrinterProperties(pci->hPrinter, pci->pRawData,
                                pci->pPrinterData, sizeof(PRINTERDATA)))
    {
        ERR(("BSavePrinterProperties failed\n"));
        bResult = FALSE;
    }

    #ifndef WINNT_40

    VNotifyDSOfUpdate(pci->hPrinter);

    #endif // !WINNT_40

    if (!bFromSetResult)
    {
        //
        // DCR: Should we display an error message if there is
        // an error while saving the printer-sticky properties?
        //

        pCallbackParam->Result = CPSUI_OK;
        return CPSUICB_ACTION_ITEMS_APPLIED;
    }
    else
    {
        return 1;
    }
}



BOOL
BPackPrinterPropertyItems(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack printer property information into treeview items.

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error.

--*/

{
    return
        BPackItemFormTrayTable(pUiData)     &&
        _BPackFontSubstItems(pUiData)       &&
        _BPackPrinterOptions(pUiData)       &&
        BPackItemGenericOptions(pUiData)    &&
        BPackOemPluginItems(pUiData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\driverui\prnevent.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    prnevent.c

Abstract:

    This file handles the DrvPrinterEvent spooler API.

Environment:

    Win32 subsystem, DriverUI module, user mode

Revision History:

    08/30/00 -fengy-
        Added DrvDocumentEvent support.

    02/13/97 -davidx-
        Implement OEM plugin support.

    02/06/97 -davidx-
        Rewrote it to use common data management functions.

    02/04/97 -davidx-
        Reorganize driver UI to separate ps and uni DLLs.

    07/17/96 -amandan-
        Modified for common UI and shared binary data

    05/20/96 -davidx-
        Created it.

--*/


#include "precomp.h"

//
// DOCUMENTEVENT_QUERYFILTER is introduced in Whistler.
// We need to define it if it's not defined (on Win2K)
// so our code can be built with Win2K DDK.
//

#ifndef DOCUMENTEVENT_QUERYFILTER

#define DOCUMENTEVENT_QUERYFILTER  14

#endif

//
// Private APIs exported by the spooler for printer drivers and port monitors.
// These must be kept in sync with winsplp.h.
//

typedef HANDLE (*LPREVERTTOPRINTERSELF)(VOID);
typedef BOOL (*LPIMPERSONATEPRINTERCLIENT)(HANDLE);

//
// Forward and external function declarations
//

BOOL BInitOrUpgradePrinterProperties(PCOMMONINFO);
VOID DeleteFontIntallerFile(HANDLE);

PTSTR
GetBinaryFileName(
    PTSTR   ptstrDataFileName
    )
/*++

Routine Description:

    This function generates a binary file name from the data file name.

Arguments:

    ptstrDataFileName   specifies the data file name

Return Value:

    TRUE for success and FALSE for failure

Note:

--*/

{

    INT iLen;
    PTSTR   ptstrFileName, ptstrExtension;
    PTSTR   ptstrBinaryExt, ptstrFileExt;

    ptstrFileName = ptstrExtension = NULL;

#ifdef UNIDRV

    ptstrBinaryExt = BUD_FILENAME_EXT;
    ptstrFileExt = GPD_FILENAME_EXT;

#else

    ptstrBinaryExt = BPD_FILENAME_EXT;
    ptstrFileExt = PPD_FILENAME_EXT;

#endif

    iLen = _tcslen(ptstrDataFileName);

    if ((ptstrExtension = _tcsrchr(ptstrDataFileName, TEXT('.'))) == NULL ||
        _tcsicmp(ptstrExtension, ptstrFileExt) != EQUAL_STRING)
    {
        ptstrExtension = ptstrDataFileName + iLen;
        iLen += _tcslen(ptstrBinaryExt);

    }

    if (ptstrFileName = MemAlloc((iLen + 1) * sizeof(TCHAR)))
    {
        _tcscpy(ptstrFileName, ptstrDataFileName);

        _tcscpy(ptstrFileName + (ptstrExtension - ptstrDataFileName), ptstrBinaryExt);
    }

    return ptstrFileName;
}

BOOL
DrvDriverEvent(
    DWORD   dwDriverEvent,
    DWORD   dwLevel,
    LPBYTE  pDriverInfo,
    LPARAM  lParam
    )
/*++

Routine Description:

    This function handles the DrvDriverEvent spooler API

Arguments:

    dwDriverEvent       specifies the event
    dwLevel             level of DRIVER_INFO_*
    pDriverInfo         pointer to DRIVER_INFO_*
    lParam              event specific parameters.

Return Value:

    TRUE for success and FALSE for failure

Note:

--*/

{
    BOOL           bResult      = TRUE;

#ifndef WINNT_40

    PDRIVER_INFO_3 pDriverInfo3 = (PDRIVER_INFO_3)pDriverInfo;
    PTSTR          ptstrFileName;

    if (pDriverInfo3 == NULL || pDriverInfo3->pDataFile == NULL)
        return FALSE;

    switch (dwDriverEvent)
    {
    case DRIVER_EVENT_INITIALIZE:
        break;

    case DRIVER_EVENT_DELETE:

        //
        // Need to delete the binary data generated by the parsers
        //

        ptstrFileName = GetBinaryFileName(pDriverInfo3->pDataFile);

        if (ptstrFileName)
        {
            DeleteFile(ptstrFileName);
            MemFree(ptstrFileName);
        }
    }

    //
    // Call the OEM to handle DrvDriverEvent
    //

    {
        PFN_OEMDriverEvent  pfnOEMDriverEvent;
        POEM_PLUGINS        pOemPlugins;
        POEM_PLUGIN_ENTRY   pOemEntry;
        DWORD               dwOemCount;

        if (! (pOemPlugins = PGetOemPluginInfo(NULL, pDriverInfo3->pConfigFile, pDriverInfo3)) ||
            ! BLoadOEMPluginModules(pOemPlugins))
        {
            ERR(("DrvDriverEvent, Cannot load OEM plugins: %d\n", GetLastError()));
            if (pOemPlugins)
            {
                VFreeOemPluginInfo(pOemPlugins);
            }

            return FALSE;
        }

        dwOemCount = pOemPlugins->dwCount;
        pOemEntry =  pOemPlugins->aPlugins;

        //
        // call OEMDriverEvent entrypoint for each plugin
        //

        for (; dwOemCount--; pOemEntry++)
        {
            if (pOemEntry->hInstance == NULL)
                continue;

            if (HAS_COM_INTERFACE(pOemEntry))
            {
                HRESULT hr;

                hr = HComOEMDriverEvent(pOemEntry,
                                        dwDriverEvent,
                                        dwLevel,
                                        pDriverInfo,
                                        lParam);

                if (hr == E_NOTIMPL)
                    continue;

                bResult = SUCCEEDED(hr);

            }
            else
            {
                if ((pfnOEMDriverEvent = GET_OEM_ENTRYPOINT(pOemEntry, OEMDriverEvent)) &&
                    !pfnOEMDriverEvent(dwDriverEvent, dwLevel, pDriverInfo, lParam))
                {
                    ERR(("OEMDriverEvent failed for '%ws': %d\n",
                        CURRENT_OEM_MODULE_NAME(pOemEntry),
                        GetLastError()));

                    bResult = FALSE;
                }
            }
        }

        if (pOemPlugins)
            VFreeOemPluginInfo(pOemPlugins);
    }

#endif  // WINNT_40

    return bResult;
}


/*++

Routine Name:

    DrvDocumentEvent

Routine Description:

    Handle certain events associated with printing a document.

    Although our core driver doesn't do anything for any events,
    this function allows OEM plugins to add their event handling.

Arguments:

    hPrinter - printer handle
    hdc - device contect handle
    iEsc - escape code identifying the event to be handled
    cbIn - size in bytes of the array pointed to by pbIn
    pbIn - pointer to a ULONG array, whose usage depends on iEsc
    cbOut - only used as cbOutput parameter for ExtEscape
    pbOut - pointer to an output buffer, whose usage depends on iEsc

Return Value:

    DOCUMENTEVENT_FAILURE - iEsc event is supported but a failure occurred
    DOCUMENTEVENT_SUCCESS - iEsc event is handled successfully
    DOCUMENTEVENT_UNSUPPORTED - iEsc event is not supported

Last Error:

    None

--*/
INT
DrvDocumentEvent(
    HANDLE  hPrinter,
    HDC     hdc,
    int     iEsc,
    ULONG   cbIn,

    #ifdef WINNT_40
    PULONG  pbIn,
    #else
    PVOID   pbIn,
    #endif

    ULONG   cbOut,

    #ifdef WINNT_40
    PULONG  pbOut
    #else
    PVOID   pbOut
    #endif
    )
{
    POEM_PLUGINS   pOemPlugins = NULL;
    PDRIVER_INFO_3 pDriverInfo3 = NULL;
    INT            iReturn;

    if ((pDriverInfo3 = MyGetPrinterDriver(hPrinter, NULL, 3)) == NULL)
    {
       ERR(("Cannot get printer driver info: %d\n", GetLastError()));
        iReturn = DOCUMENTEVENT_FAILURE;
        goto docevent_exit;
    }

    if (!(pOemPlugins = PGetOemPluginInfo(hPrinter,
                                          pDriverInfo3->pConfigFile,
                                          pDriverInfo3)) ||
        !BLoadOEMPluginModules(pOemPlugins))
    {
        //
        // Note that BLoadOEMPluginModules always returns TRUE, even in
        // the case when plugin(s) can't be loaded, which is treated
        // as there is no plugin(s).
        //

        ERR(("Cannot get OEM plugin info: %d\n", GetLastError()));
        iReturn = DOCUMENTEVENT_FAILURE;
        goto docevent_exit;
    }

    if (pOemPlugins->dwCount)
    {
        POEM_PLUGIN_ENTRY pOemEntry = pOemPlugins->aPlugins;
        DWORD cOemCount = pOemPlugins->dwCount;
        INT   iResult;
        BOOL  bOEMDocEventOK = FALSE;

        for ( ; cOemCount--; pOemEntry++)
        {
            HRESULT hr;

            if (pOemEntry->hInstance == NULL ||
                !HAS_COM_INTERFACE(pOemEntry))
            {
                continue;
            }

            hr = HComOEMDocumentEvent(pOemEntry,
                                      hPrinter,
                                      hdc,
                                      iEsc,
                                      cbIn,
                                      (PVOID)pbIn,
                                      cbOut,
                                      (PVOID)pbOut,
                                      &iResult);

            if (SUCCEEDED(hr))
            {
                bOEMDocEventOK = TRUE;

                #ifndef WINNT_40

                //
                // DOCUMENTEVENT_QUERYFILTER is introduced in Whistler.
                //

                if (iEsc == DOCUMENTEVENT_QUERYFILTER)
                {
                    //
                    // At most one plugin is allowed to handle the event
                    // DOCUMENTEVENT_QUERYFILTER, and the filter it specifies
                    // will be used by spooler.
                    //
                    // For all other events, we will call every plugin so
                    // each will have the chance to perform its tasks.
                    //

                    break;
                }

                #endif // !WINNT_40
            }
        }

        if (bOEMDocEventOK)
        {
            //
            // At least one plugin handled the event successfully, so
            // use the return value specified by the plugin(s).
            //

            iReturn = iResult;
        }
        else
        {
            //
            // None of the plugins handled the event successfully.
            //

            iReturn = DOCUMENTEVENT_UNSUPPORTED;
        }
    }
    else
    {
        //
        // There is no plugin.
        //

        iReturn = DOCUMENTEVENT_UNSUPPORTED;
    }

    docevent_exit:

    if (pDriverInfo3)
    {
        MemFree(pDriverInfo3);
    }

    if (pOemPlugins)
    {
        VFreeOemPluginInfo(pOemPlugins);
    }

    //
    // If there is no plugin, or none of the plugins handles DocumentEvent
    // successfully, we return DOCUMENTEVENT_UNSUPPORTED since our driver
    // doesn't do anything for DrvDocumentEvent. When spooler sees this
    // return value for DOCUMENTEVENT_CREATEDCPRE, it will decide not to
    // make any more event calls to the driver.
    //
    // If the event is handled successfully by the plugins, we will return
    // the return value specified by the plugin(s).
    //

    return iReturn;
}


BOOL
DrvPrinterEvent(
    LPWSTR  pPrinterName,
    INT     DriverEvent,
    DWORD   Flags,
    LPARAM  lParam
    )
/*++

Routine Description:

    This function handles the DrvPrinterEvent spooler API

Arguments:

    pPrinterName        name of device
    DriverEvent         specifies the event
    Flags               bits flag
    lParam              event specific parameters.

Return Value:

    TRUE for success and FALSE for failure

Note:

--*/

{
    LPREVERTTOPRINTERSELF       pRevertToPrinterSelf;
    LPIMPERSONATEPRINTERCLIENT  pImpersonatePrinterClient;
    HINSTANCE                   hSpoolss = NULL;
    HANDLE                      hToken = NULL;
    PCOMMONINFO                 pci = NULL;
    HANDLE                      hPrinter = NULL;
    BOOL                        bResult = TRUE;
    CACHEDFILE                  CachedFile;

    VERBOSE(("Entering DrvPrinterEvent: %d ...\n", DriverEvent));

    switch (DriverEvent)
    {
    case PRINTER_EVENT_CACHE_REFRESH:

        //
        // Open a handle to the printer connection
        //

        if (! OpenPrinter(pPrinterName, &hPrinter, NULL))
        {
            ERR(("OpenPrinter '%ws' failed: %d\n", pPrinterName, GetLastError()));
            hPrinter = NULL;
            break;
        }

        //
        // Prepare to copy cached driver files from the server, if any
        //

        #ifdef PSCRIPT
        _BPrepareToCopyCachedFile(hPrinter, &CachedFile, REGVAL_NTFFILENAME);
        #else
        _BPrepareToCopyCachedFile(hPrinter, &CachedFile, REGVAL_FONTFILENAME);
        #endif

        //
        // Load spoolss.dll and get address of functions:
        //  RevertToPrinterSelf - switch to spooler's security context
        //  ImpersonatePrinterClient - switch to current user's security context
        //

        if (! (hSpoolss = LoadLibrary(TEXT("spoolss.dll"))) ||
            ! (pRevertToPrinterSelf = (LPREVERTTOPRINTERSELF)
                    GetProcAddress(hSpoolss, "RevertToPrinterSelf")) ||
            ! (pImpersonatePrinterClient = (LPIMPERSONATEPRINTERCLIENT)
                    GetProcAddress(hSpoolss, "ImpersonatePrinterClient")))
        {
            ERR(("Couldn't load spoolss.dll: %d\n", GetLastError()));

            if (hSpoolss != NULL)
                FreeLibrary(hSpoolss);

            _VDisposeCachedFileInfo(&CachedFile);

            break;
        }

        //
        // Switch to spooler security context so that we can create
        // binary printer description data file in the driver directory
        //
        // When we call to load raw printer description data, the parser
        // will check its cache. If no binary data file exists or existing
        // binary data file is out of date, the parser will regenerate
        // an up-to-date binary data file.
        //

        hToken = pRevertToPrinterSelf();
        pci = PLoadCommonInfo(hPrinter, pPrinterName, 0);


        //
        // Copy cached driver file from the server
        //

        _BCopyCachedFile(pci, &CachedFile);
        _VDisposeCachedFileInfo(&CachedFile);

        if (hToken)
        {
            if (!(bResult = pImpersonatePrinterClient(hToken)))
            {
                ERR(("PrinterEvent-ImpersonatePrinterClient failed: %d\n", GetLastError()));
            }
        }

        FreeLibrary(hSpoolss);
        break;

    case PRINTER_EVENT_INITIALIZE:

        //
        // Open a printer with administrator privilege, and
        // process OEM plugin configuration information
        //

        pci = PLoadCommonInfo(NULL, pPrinterName, FLAG_OPENPRINTER_ADMIN|FLAG_INIT_PRINTER);

        if (pci == NULL)
            break;

        //
        // Initialize default printer-sticky properties in registry
        // Add printer forms to the spooler's forms database
        //

        (VOID) BInitOrUpgradePrinterProperties(pci);

        #ifndef WINNT_40

        VNotifyDSOfUpdate(pci->hPrinter);

        #endif // !WINNT_40


        break;

    case PRINTER_EVENT_ADD_CONNECTION:

        //
        // Fix the bug where when NT5 client connects to NT4 server, the server registry
        // doesn't have the REGVAL_INIDATA entry. Calling PLoadCommonInfo with
        // FLAG_PROCESS_INIFILE will write REGVAL_INIDATA to NT4 registry.
        //

        pci = PLoadCommonInfo(NULL, pPrinterName, FLAG_OPENPRINTER_ADMIN|FLAG_PROCESS_INIFILE);
        break;

    #ifdef UNIDRV

    case PRINTER_EVENT_DELETE:
    case PRINTER_EVENT_DELETE_CONNECTION:

        //
        // Delete font installer file
        //

        //
        // Open a handle to the printer
        //

        if (! OpenPrinter(pPrinterName, &hPrinter, NULL))
        {
            ERR(("OpenPrinter '%ws' failed: %d\n", pPrinterName, GetLastError()));
            hPrinter = NULL;
            break;
        }

        pci = PLoadCommonInfo(NULL, pPrinterName, FLAG_OPENPRINTER_NORMAL);

        DeleteFontIntallerFile(hPrinter);

        break;

    #endif

    default:

        pci = PLoadCommonInfo(NULL, pPrinterName, FLAG_OPENPRINTER_NORMAL);
        break;
    }

    if (pci != NULL)
    {
        if (bResult)
        {
            PFN_OEMPrinterEvent pfnOEMPrinterEvent;

            //
            // call OEMPrinterEvent entrypoint for each plugin
            //

            FOREACH_OEMPLUGIN_LOOP(pci)

                if (HAS_COM_INTERFACE(pOemEntry))
                {
                    HRESULT hr;

                    hr = HComOEMPrinterEvent(pOemEntry,
                                            pPrinterName,
                                            DriverEvent,
                                            Flags,
                                            lParam);

                    if (hr == E_NOTIMPL)
                        continue;

                    bResult = SUCCEEDED(hr);

                }
                else
                {
                    if ((pfnOEMPrinterEvent = GET_OEM_ENTRYPOINT(pOemEntry, OEMPrinterEvent)) &&
                        !pfnOEMPrinterEvent(pPrinterName, DriverEvent, Flags, lParam))
                    {
                        ERR(("OEMPrinterEvent failed for '%ws': %d\n",
                            CURRENT_OEM_MODULE_NAME(pOemEntry),
                            GetLastError()));

                        bResult = FALSE;
                    }
                }

           END_OEMPLUGIN_LOOP
        }
        VFreeCommonInfo(pci);
    }
    else
        bResult = FALSE;

    if (hPrinter != NULL)
        ClosePrinter(hPrinter);

    return (bResult);
}


BOOL
BUpgradePrivateFlags(
    PCOMMONINFO pci
    )

/*++

Routine Description:

    Upgrade pPrinterData->dwFlags if necessary

Arguments:

    pci - Points to basic printer info

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{

#if 0

    DWORD    dwFlag, dwIndex, dwSelection, dwFeatureIndex;
    PFEATURE pFeature;
    PPAGEPROTECT pPageProtect;

    //
    // UniDriver specific upgrade steps
    //

    if (BGetPrinterDataDWord(pci->hPrinter, REGVAL_PAGE_PROTECTION, &dwFlag) &&
        (pFeature = GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_PAGEPROTECTION)) &&
        BCombineCommonInfoOptionsArray(pci))
    {
        if (dwFlag & DXF_PAGEPROT)
            dwSelection = PAGEPRO_ON;
        else
            dwSelection = PAGEPRO_OFF;

        pPageProtect = PGetIndexedOption(pci->pUIInfo, pFeature, 0);

        for (dwIndex = 0; dwIndex < pFeature->Options.dwCount; dwIndex++, pPageProtect++)
        {
            if (dwSelection == pPageProtect->dwPageProtectID)
                break;
        }

        if (dwIndex == pFeature->Options.dwCount)
            dwIndex = pFeature->dwDefaultOptIndex;

        dwFeatureIndex = GET_INDEX_FROM_FEATURE(pci->pUIInfo, pFeature);

        pci->pCombinedOptions[dwFeatureIndex].ubCurOptIndex = (BYTE)dwIndex;

        SeparateOptionArray(pci->pRawData,
                            pci->pCombinedOptions,
                            pci->pPrinterData->aOptions,
                            MAX_PRINTER_OPTIONS,
                            MODE_PRINTER_STICKY
                            );

    }

#endif

    return TRUE;

}


BOOL
BInitOrUpgradePrinterData(
    PCOMMONINFO pci
    )

/*++

Routine Description:

    Initialize the driver's printer-sticky property data
    or upgrade it to current version if it already exists

Arguments:

    pci - Points to basic printer info

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD   dwSize;
    BOOL    bResult = TRUE;

    //
    // If the printer property data already exists in the registry
    // and it's at least as big as the current PRINTERDATA, then
    // we assume it's ok and there is no need to upgrade it.
    //

    if (!BGetPrinterDataDWord(pci->hPrinter, REGVAL_PRINTER_DATA_SIZE, &dwSize) ||
        dwSize < sizeof(PRINTERDATA))
    {
        //
        // Otherwise, upgrade the existing printer property data in the registry
        // or save a copy of the default printer property data to registry.
        //

        bResult = BFillCommonInfoPrinterData(pci) &&
                  BUpgradePrivateFlags(pci) &&
                  BSavePrinterProperties(pci->hPrinter, pci->pRawData,
                                         pci->pPrinterData, sizeof(PRINTERDATA));
    }

    return bResult;
}



BOOL
BAddOrUpgradePrinterForms(
    PCOMMONINFO pci
    )

/*++

Routine Description:

    Add printer specific forms to the spooler's forms database

Arguments:

    pci - Points to basic printer info

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    PPAGESIZE       pPageSize;
    FORM_INFO_1     FormInfo1;
    DWORD           dwIndex, dwChecksum32, dwForm;
    PFEATURE        pFeature;
    WCHAR           awchBuf[CCHPAPERNAME];

    //
    // If forms has already been added and printer description
    // data hasn't changed, we don't need to do anything
    //

    if (BGetPrinterDataDWord(pci->hPrinter, REGVAL_FORMS_ADDED, &dwChecksum32) &&
        dwChecksum32 == pci->pRawData->dwChecksum32)
    {
        return TRUE;
    }

    if (pci->pSplForms == NULL)
        pci->pSplForms = MyEnumForms(pci->hPrinter, 1, &pci->dwSplForms);

    //
    //  Get pointer to PageSize feature
    //

    if ((pFeature = GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_PAGESIZE)) == NULL)
    {
        WARNING(("No paper size supported\n"));
        return FALSE;
    }

    ZeroMemory(&FormInfo1, sizeof(FormInfo1));
    FormInfo1.Flags = FORM_PRINTER;
    FormInfo1.pName = awchBuf;

    //
    // Go through each printer form
    //

    for (dwIndex=0; dwIndex < pFeature->Options.dwCount; dwIndex++)
    {
        pPageSize = PGetIndexedOption(pci->pUIInfo, pFeature, dwIndex);
        ASSERT(pPageSize != NULL);

        //
        // Ignore the custom page size option
        //

        if (pPageSize->dwPaperSizeID == DMPAPER_USER ||
            pPageSize->dwPaperSizeID == DMPAPER_CUSTOMSIZE)
        {
            continue;
        }

        if (pPageSize->szPaperSize.cx <= 0 ||
            pPageSize->szPaperSize.cy <= 0)
        {
            ERR(("Paper size is too small\n"));
            continue;
        }

        if (! LOAD_STRING_PAGESIZE_NAME(pci, pPageSize, awchBuf, CCHPAPERNAME))
        {
            ERR(("Cannot get paper name\n"));
            continue;
        }

        //
        // Check if the paper name is already in the forms database.
        // If it's already in the database as a
        //

        for (dwForm=0; dwForm < pci->dwSplForms; dwForm++)
        {
            if (pci->pSplForms[dwForm].Flags == FORM_USER &&
                wcscmp(pci->pSplForms[dwForm].pName, awchBuf) == EQUAL_STRING)
            {
                VERBOSE(("Delete user/driver rdefined form: %ws\n", awchBuf));
                DeleteForm(pci->hPrinter, awchBuf);
            }
        }

        //
        // Page size:
        //  remember that FORM_INFO_1 uses micron units while
        //  PAGESIZE.szPaperSize are in Master units.
        //

        FormInfo1.Size.cx = MASTER_UNIT_TO_MICRON(pPageSize->szPaperSize.cx,
                                                  pci->pUIInfo->ptMasterUnits.x);

        FormInfo1.Size.cy = MASTER_UNIT_TO_MICRON(pPageSize->szPaperSize.cy,
                                                  pci->pUIInfo->ptMasterUnits.y);

        //
        // Imageable area:
        //  for driver-defined forms, all margins should be set to 0.
        //

        FormInfo1.ImageableArea.left =
        FormInfo1.ImageableArea.top = 0;
        FormInfo1.ImageableArea.right = FormInfo1.Size.cx;
        FormInfo1.ImageableArea.bottom = FormInfo1.Size.cy;

        //
        // We'll try to add the form first. If that fails,
        // we assume the form is already there and try to
        // update the form with the new info.
        //

        (VOID) AddForm(pci->hPrinter, 1, (PBYTE) &FormInfo1);
    }

    (VOID) BSetPrinterDataDWord(pci->hPrinter,
                                REGVAL_FORMS_ADDED,
                                pci->pRawData->dwChecksum32);

    return TRUE;
}



BOOL
BInitOrUpgradePrinterProperties(
    PCOMMONINFO pci
    )

/*++

Routine Description:

    Initialize or upgrade printer property information in the registry

Arguments:

    pci - Points to basic printer info

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    BOOL    bResult;

    //
    // Handle PRINTERDATA structure in registry
    //

    bResult = BInitOrUpgradePrinterData(pci);

    //
    // Handle driver-defined forms in the spooler's database
    //

    if (! BAddOrUpgradePrinterForms(pci))
        bResult = FALSE;

    #ifdef PSCRIPT

    //
    // pscript specific initializations
    //

    // Save model-specific NTF filename in registry for NT4 compatibility

    if (! BUpdateModelNtfFilename(pci))
        bResult = FALSE;

    #ifdef WINNT_40

    // Also save the current user locale too.

    if (! BUpdateVMErrorMessageID(pci))
        bResult = FALSE;

    #endif // WINNT_40

    #endif // PSCRIPT

    return bResult;
}



PWSTR
PGetFileDirectory(
    PWSTR   pServerName
    )

/*++

Routine Description:

    Get the name of the directory used by the font downloader
    to store NTF information about downloaded fonts

Arguments:

    pServerName - Name of the print server

Return Value:

    Pointer to the directory used for storing NTF information
    about downloaded fonts, NULL if there is an error

--*/

{
    PWSTR           p, pDir = NULL;
    DWORD           cbNeeded;
    static WCHAR    wszDir[] = FONTDIR;

    //
    // Get the printer driver directory path
    //

    if (GetPrinterDriverDirectory(pServerName, NULL, 1, NULL, 0, &cbNeeded) ||
        GetLastError() != ERROR_INSUFFICIENT_BUFFER ||
        (pDir = MemAlloc(cbNeeded + sizeof(wszDir))) == NULL ||
        !GetPrinterDriverDirectory(pServerName, NULL, 1, (PBYTE) pDir, cbNeeded, &cbNeeded))
    {
        ERR(("GetPrinterDriverDirectory failed: %d\n", GetLastError()));
        MemFree(pDir);
        return NULL;
    }

    //
    // Replace the last component of the directory path (which should be w32...)
    // with \psfont\
    //

    if (p = wcsrchr(pDir, TEXT(PATH_SEPARATOR)))
        wcscpy(p, wszDir);
    else
    {
        WARNING(("Driver directory is not fully-qualified: %ws\n", pDir));
        wcscat(pDir, wszDir);
    }

    return pDir;
}



PWSTR
PConcatFilename(
    PWSTR   pDir,
    PWSTR   pFilename
    )

{
    PWSTR   pBasename;

    //
    // Strip any directory prefix from the input filename
    //

    if (pBasename = wcsrchr(pFilename, TEXT(PATH_SEPARATOR)))
        pBasename++;
    else
        pBasename = pFilename;

    //
    // Concatenate the input directory with the base filename
    //

    if (! (pFilename = MemAlloc(SIZE_OF_STRING(pDir) + SIZE_OF_STRING(pBasename))))
    {
        ERR(("Memory allocation failed\n"));
        return NULL;
    }

    wcscpy(pFilename, pDir);
    wcscat(pFilename, pBasename);

    return pFilename;
}



BOOL
_BPrepareToCopyCachedFile(
    HANDLE      hPrinter,
    PCACHEDFILE pCachedFile,
    PWSTR       pRegKey
    )

/*++

Routine Description:

    Prepare to copy files from the server during a printer-connection
    cache refresh event

Arguments:

    hPrinter - Handle to the printer connection
    pCachedFile - Buffer to store information about cached file

Return Value:

    TRUE if successful, FALSE if there is an error

Note:

    We assume this function is called from within the spooler process
    and with current user's security context. Specifically, we must
    be able to access the server's print$ share at this point.

--*/

{
    PPRINTER_INFO_2 pPrinterInfo2 = NULL;
    PWSTR           pRemoteFilename;
    DWORD           dwSize;

    ZeroMemory(pCachedFile, sizeof(CACHEDFILE));
    pCachedFile->hRemoteFile = INVALID_HANDLE_VALUE;

    //
    // Find out the name of the file to copy
    //
#if !defined(PSCRIPT)
    pCachedFile->pFilename = PtstrGetPrinterDataString(hPrinter, pRegKey, &dwSize);
#else
    return TRUE;
#endif

    if (pCachedFile->pFilename == NULL || *pCachedFile->pFilename == NUL)
        return TRUE;

    //
    // Get the remote NTF filename on the server
    //
    // NOTE: We're really like to use level 4 here. But due to bug in the
    // spooler, GetPrinter level 4 doesn't work for printer connections.
    //

    if (! (pPrinterInfo2 = MyGetPrinter(hPrinter, 2)) ||
        ! pPrinterInfo2->pServerName ||
        ! (pCachedFile->pRemoteDir = PGetFileDirectory(pPrinterInfo2->pServerName)) ||
        ! (pCachedFile->pLocalDir = PGetFileDirectory(NULL)) ||
        ! (pRemoteFilename = PConcatFilename(pCachedFile->pRemoteDir, pCachedFile->pFilename)))
    {
        goto exit_prepare_copyfile;
    }

    pCachedFile->hRemoteFile = CreateFile(pRemoteFilename,
                                          GENERIC_READ,
                                          FILE_SHARE_READ,
                                          NULL,
                                          OPEN_EXISTING,
                                          FILE_FLAG_SEQUENTIAL_SCAN,
                                          NULL);

    MemFree(pRemoteFilename);

exit_prepare_copyfile:

    MemFree(pPrinterInfo2);

    if (pCachedFile->hRemoteFile == INVALID_HANDLE_VALUE)
    {
        ERR(("Couldn't open remote NTF/FontInfo file: %d\n", GetLastError()));
        _VDisposeCachedFileInfo(pCachedFile);
    }

    return (pCachedFile->hRemoteFile != INVALID_HANDLE_VALUE);
}



BOOL
_BCopyCachedFile(
    PCOMMONINFO pci,
    PCACHEDFILE pCachedFile
    )

/*++

Routine Description:

    Copy files from the server during printer-connection cache refresh event

Arguments:

    pci - Points to basic printer information
    pCachedFile - Points to information about cached file

Return Value:

    TRUE if successful, FALSE if there is an error

Note:

    We assume this function is called from within the spooler process
    and with system's security context. Specifically, we must
    be able to write into local machines' printer driver directory.

--*/

#define BUFFER_SIZE  4096

{
    HANDLE  hLocalFile;
    PWSTR   pLocalFilename = NULL;
    PVOID   pBuffer = NULL;
    BOOL    bResult = FALSE;
    DWORD   dwCount;

    //
    // We don't have any file to copy
    //

    if (pCachedFile->hRemoteFile == INVALID_HANDLE_VALUE)
        return TRUE;

    //
    // Get the name for the local copy of the NTF file
    // and allocate temporary buffer
    //

    ASSERT(BUFFER_SIZE >= MAX_PATH * sizeof(WCHAR));

    if (! (pLocalFilename = PConcatFilename(pCachedFile->pLocalDir, pCachedFile->pFilename)) ||
        ! (pBuffer = MemAlloc(BUFFER_SIZE)))
    {
        goto exit_copyfile;
    }

    // Make sure the local directory is created

    (VOID) CreateDirectory(pCachedFile->pLocalDir, NULL);

    for (dwCount=0; dwCount < 2; dwCount++)
    {
        hLocalFile = CreateFile(pLocalFilename,
                                GENERIC_WRITE,
                                0,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_FLAG_SEQUENTIAL_SCAN,
                                NULL);

        if (hLocalFile != INVALID_HANDLE_VALUE)
            break;

        if (dwCount == 0)
        {
            //
            // If this is our first try, then attempt to move
            // the existing file to a temporary file and set
            // it to be delete-on-reboot.
            //

            #ifdef PSCRIPT
            if (! GetTempFileName(pCachedFile->pLocalDir, L"NTF", 0, pBuffer) ||
            #else
            if (! GetTempFileName(pCachedFile->pLocalDir, L"FON", 0, pBuffer) ||
            #endif
                ! MoveFileEx(pLocalFilename, pBuffer, MOVEFILE_REPLACE_EXISTING) ||
                ! MoveFileEx(pBuffer, NULL, MOVEFILE_DELAY_UNTIL_REBOOT))
            {
                break;
            }
        }
    }

    if (hLocalFile != INVALID_HANDLE_VALUE)
    {
        while (ReadFile(pCachedFile->hRemoteFile, pBuffer, BUFFER_SIZE, &dwCount, NULL))
        {
            //
            // Have we reached end-of-file?
            //

            if (dwCount == 0)
            {
                bResult = TRUE;
                break;
            }

            if (! WriteFile(hLocalFile, pBuffer, dwCount, &dwCount, NULL))
                break;
        }

        CloseHandle(hLocalFile);

        //
        // If file copying failed, be sure to delete the temporary file
        //

        if (! bResult)
            DeleteFile(pLocalFilename);
    }

exit_copyfile:

    MemFree(pLocalFilename);
    MemFree(pBuffer);

    if (! bResult)
        ERR(("Couldn't copy remote NTF/FontInfo file: %d\n", GetLastError()));

    return bResult;
}



VOID
_VDisposeCachedFileInfo(
    PCACHEDFILE pCachedFile
    )

/*++

Routine Description:

    Clean up after copying files from the server
    during printer-connection cache refresh

Arguments:

    pCachedFile - Points to information about cached file

Return Value:

    NONE

--*/

{
    if (pCachedFile->hRemoteFile != INVALID_HANDLE_VALUE)
        CloseHandle(pCachedFile->hRemoteFile);

    MemFree(pCachedFile->pFilename);
    MemFree(pCachedFile->pRemoteDir);
    MemFree(pCachedFile->pLocalDir);

    ZeroMemory(pCachedFile, sizeof(CACHEDFILE));
    pCachedFile->hRemoteFile = INVALID_HANDLE_VALUE;
}




#ifdef UNIDRV

VOID
DeleteFontIntallerFile(
    HANDLE hPrinter
    )

/*++

Routine Description:

    Delete font installer file when printer is deleted

Arguments:

    hPrinter - Handle to printer

Return Value:

    NONE

--*/

{
    PWSTR pFilename;
    PWSTR pLocalDir;
    PWSTR pLocalFilename = NULL;

    pFilename = PtstrGetPrinterDataString(hPrinter, REGVAL_FONTFILENAME, NULL);

    if (!pFilename || !*pFilename)
        return;

    if (!(pLocalDir = PGetFileDirectory(NULL)))
        goto exit_deletefile;

    if (!(pLocalFilename = PConcatFilename(pLocalDir, pFilename)))
        goto exit_deletefile;

    DeleteFile(pLocalFilename);

exit_deletefile:

    MemFree(pFilename);
    MemFree(pLocalDir);
    MemFree(pLocalFilename);

    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\driverui\uihelp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    uihelp.h

Abstract:

    DriverUI driver help indices

[Environment:]

        Win32 subsystem, PostScript driver

Revision History:

        10/05/95 -davidx-
                Created it.

        dd-mm-yy -author-
                description

--*/


#ifndef _UIHELP_H_
#define _UIHELP_H_

////////////////////////////////////
// For document properties dialog //
////////////////////////////////////

// Select page orientation
//  Portrait
//  Landscape (90 degrees clockwise)
//  Rotated landscape (90 degrees counterclockwise)

#define HELP_INDEX_ORIENTATION          1001

// Select scale factor (1-1000%)

#define HELP_INDEX_SCALE                1002

// Select number of copies to print. Also decide whether to turn on
// collation if more than one copy is requested and the printer
// supports collation.

#define HELP_INDEX_COPIES_COLLATE       1003

// Select color or monochrome option

#define HELP_INDEX_COLOR                1004

// Bring up halftone color adjustment dialog

#define HELP_INDEX_HALFTONE_COLORADJ    1005

// Select duplex options
//  Simplex / None
//  Horizontal / Tumble
//  Vertical / NoTuble

#define HELP_INDEX_DUPLEX               1006

// Select output resolution

#define HELP_INDEX_RESOLUTION           1007

// Select input slot

#define HELP_INDEX_INPUT_SLOT           1008

// Select a form to use

#define HELP_INDEX_FORMNAME             1009

// Select TrueType font options
//  Substitute TrueType font with device font
//      (according to the font substitution table)
//  Download TrueType font to the printer as softfont

#define HELP_INDEX_TTOPTION             1010

// Enable/Disable metafile spooling

#define HELP_INDEX_METAFILE_SPOOLING    1011

// Select PostScript options

#define HELP_INDEX_PSOPTIONS            1012

// Whether the output is mirrored

#define HELP_INDEX_MIRROR               1013

// Whether the output is printed negative

#define HELP_INDEX_NEGATIVE             1014

// Whether to keep the output pages independent of each other.
// This is normally turned off when you're printing directly
// to a printer. But if you're generating PostScript output
// files and doing post-processing on it, you should turn on
// this option.

#define HELP_INDEX_PAGEINDEP            1015

// Whether to compress bitmaps (only available on level 2 printers)

#define HELP_INDEX_COMPRESSBMP          1016

// Whether to prepend a ^D character before each job

#define HELP_INDEX_CTRLD_BEFORE         1017

// Whether to append a ^D character after each job

#define HELP_INDEX_CTRLD_AFTER          1018

// Select printer-specific features

#define HELP_INDEX_PRINTER_FEATURES     1019

///////////////////////////////////
// For printer properties dialog //
///////////////////////////////////

// Set amount of PostScript virtual memory
//  This is different from the total amount of printer memory.
//  For example, a printer might have 4MB RAM, but the amount
//  allocated for printer VM could be 700KB.
//  Most of the time, you don't have to enter the number yourself.
//  PS driver can figure it out from the PPD file. Or if there
//  is an installable option for printer memory configurations,
//  choose it there and a correct number will be filled in.

#define HELP_INDEX_PRINTER_VM           1020

// Whether to do halftone on the host computer or do it inside
// the printer. For PostScript printers, this should always be
// left at the default setting, i.e. to let the printer do the
// halftone.

#define HELP_INDEX_HOST_HALFTONE        1021

// Bring up halftone setup dialog

#define HELP_INDEX_HALFTONE_SETUP       1022

// Ignore device fonts
//  This option is only available on non-1252 code page systems.
//  Since fonts on most printers used 1252 code page, you can't
//  use them with non-1252 systems.

#define HELP_INDEX_IGNORE_DEVFONT       1023

// Font substitution option
//  This option is only available on 1252 code page systems.
//  You should leave it at the default setting "Normal".
//  If you notice character spacing problems in your text output,
//  you can try to set it to "Slower but more accurate". This
//  will direct the driver to place each character invididually,
//  resulting in more accurate character positioning.

#define HELP_INDEX_FONTSUB_OPTION       1024

// Edit TrueType font substitution table

#define HELP_INDEX_FONTSUB_TABLE        1025

// Substitute a TrueType with a device font.

#define HELP_INDEX_TTTODEV              1026

// Edit form-to-tray assignment table

#define HELP_INDEX_FORMTRAYASSIGN       1027

// Assign a form to a tray. If "Draw selected form only from this tray"
// is checked, then any time the user requests for the selected form,
// it will be drawn from this tray.

#define HELP_INDEX_TRAY_ITEM            1028

// Set PostScript timeout values

#define HELP_INDEX_PSTIMEOUTS           1029

// Set PostScript job timeout value
//  Number of seconds a job is allowed to run on the printer
//  before it's automatically terminated. This is to prevent
//  run-away jobs from tying up the printer indefinitely.
//  Set it to 0 if jobs are allowed to run forever.

#define HELP_INDEX_JOB_TIMEOUT          1030

// Set PostScript wait timeout value
//  Number of seconds the printer will wait for data before it
//  considers a job is completed. This is intended for non-network
//  communication channels such as serial or parallel ports where
//  there is no job control protocol.

#define HELP_INDEX_WAIT_TIMEOUT         1031

// Configure printer installable options

#define HELP_INDEX_INSTALLABLE_OPTIONS  1032

// Whether to generate job control code in the output

#define HELP_INDEX_JOB_CONTROL          1033

// Text as Graphics
#define HELP_INDEX_TEXTASGRX            1034

// Page Protection
#define HELP_INDEX_PAGE_PROTECT         1035

// Media Type
#define HELP_INDEX_MEDIA_TYPE           1036

// Font cartridges
#define HELP_INDEX_FONTSLOT_TYPE        1037

// Color Mode
#define  HELP_INDEX_COLORMODE_TYPE      1038

// Halftoning
#define  HELP_INDEX_HALFTONING_TYPE     1039

// PostScript communication protocol

#define HELP_INDEX_PSPROTOCOL           1040


// Download PostScript error handler with each job

#define HELP_INDEX_PSERROR_HANDLER      1042

// Minimum font size to download as outline

#define HELP_INDEX_PSMINOUTLINE         1043

// Maximum font size to download as bitmap

#define HELP_INDEX_PSMAXBITMAP          1044

// PostScript output option

#define HELP_INDEX_PSOUTPUT_OPTION      1045

// PostScript TrueType download option

#define HELP_INDEX_PSTT_DLFORMAT        1046

// N-up option

#define HELP_INDEX_NUPOPTION            1047

// PostScript language level

#define HELP_INDEX_PSLEVEL              1048

// ICM methods

#define HELP_INDEX_ICMMETHOD            1049

// ICM intents

#define HELP_INDEX_ICMINTENT            1050

// Reverse-order printing option

#define HELP_INDEX_REVPRINT             1051

// Quality Macro settings

#define HELP_INDEX_QUALITY_SETTINGS     1052

// Soft font settings

#define HELP_INDEX_SOFTFONT_SETTINGS    1053

// Soft font dialog help

#define HELP_INDEX_SOFTFONT_DIALOG      1054

// Whether to detect TrueGray

#define HELP_INDEX_TRUE_GRAY_TEXT       1055
#define HELP_INDEX_TRUE_GRAY_GRAPH      1056

// Whether to augment device fonts with the Euro character

#define HELP_INDEX_ADD_EURO             1057

//
// Help indices for PostScript custom page size dialog
//

#define IDH_PSCUST_Width                2000
#define IDH_PSCUST_Height               2010
#define IDH_PSCUST_Unit_Inch            2020
#define IDH_PSCUST_Unit_Millimeter      2030
#define IDH_PSCUST_Unit_Point           2040
#define IDH_PSCUST_PaperFeed_Direction  2050
#define IDH_PSCUST_Paper_CutSheet       2060
#define IDH_PSCUST_Paper_RollFeed       2070
#define IDH_PSCUST_Offset_Perpendicular 2080
#define IDH_PSCUST_Offset_Parallel      2090
#define IDH_PSCUST_OK                   2100
#define IDH_PSCUST_Cancel               2110
#define IDH_PSCUST_Restore_Defaults     2120


//
// Help indices for Unidrv Font Installer dialog
//

#define IDH_SOFT_FONT_DIRECTORY         3000
#define IDH_SOFT_FONT_NEW_LIST          3010
#define IDH_SOFT_FONT_INSTALLED_LIST    3020
#define IDH_SOFT_FONT_OPEN_BTN          3030
#define IDH_SOFT_FONT_ADD_BTN           3040
#define IDH_SOFT_FONT_DELETE_BTN        3050

#endif  //!_UIHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\driverui\uires.h ===
//
// Copyright (c) 1997-1999 Microsoft Corporation
//

//
// DMPUB IDs
//

#ifdef WINNT_40
#define NUP_DMPUB                     DMPUB_NONE
#define PAGEORDER_DMPUB               DMPUB_NONE
#else
#define NUP_DMPUB                     DMPUB_NUP
#define PAGEORDER_DMPUB               DMPUB_PAGEORDER
#endif // WINNT_40

//
// Resource IDs for dialogs
//

#define IDD_CONFLICTS                   100
#define IDC_IGNORE                      101
#define IDC_FEATURE1                    102
#define IDC_OPTION1                     103
#define IDC_FEATURE2                    104
#define IDC_OPTION2                     105
#define IDC_RESOLVE                     106
#define IDC_CANCEL                      107
#define IDC_CANCEL_FINAL                108

//
// Font installer dialog
//

#define FONTINST                        300

#define IDD_ADD                         302
#define IDD_DELFONT                     303
#define IDD_FONTDIR                     304
#define IDD_NEWFONTS                    305
#define IDD_CURFONTS                    306
#define IDD_OPEN                        307

#define TID_FONTDIR                     308
#define TID_NEWFONTS                    309
#define TID_CURFONTS                    310

//
// String resource IDs
//

#define IDS_DQPERR_PARAM                101
#define IDS_DQPERR_COMMONINFO           102
#define IDS_DQPERR_DEVMODE              103
#define IDS_DQPERR_RESOLUTION           104
#define IDS_DQPERR_OPTSELECT            105
#define IDS_DQPERR_FORMTRAY_ANY         106
#define IDS_DQPERR_FORMTRAY             107
#define IDS_DQPERR_MEMORY               108
#define IDS_DQPERR_PRINTERDATA          109

#define IDS_POSTSCRIPT                  250
#define IDS_UNIDRV                      251

#define IDS_POSTSCRIPT_VM               400
#define IDS_KBYTES                      401
#define IDS_SECONDS                     402
#define IDS_PSTIMEOUTS                  403
#define IDS_JOBTIMEOUT                  404
#define IDS_WAITTIMEOUT                 405
#define IDS_PRINTER_DEFAULT             406
#define IDS_INSTALLABLE_OPTIONS         407
#define IDS_DOWNLOAD_AS_SOFTFONT        408
#define IDS_USE_DEVFONTS                409
#define IDS_FONTSUB_OPTION              410
#define IDS_FONTSUB_DEFAULT             411
#define IDS_FONTSUB_SLOW                412
#define IDS_FONTSUB_TABLE               413
#define IDS_DEFAULT_TRAY                414
#define IDS_DRAW_ONLY_FROM_SELECTED     415
#define IDS_RESTORE_DEFAULTS            417
#define IDS_PRINTER_FEATURES            418
#define IDS_METAFILE_SPOOLING           419
#define IDS_ENABLED                     420
#define IDS_DISABLED                    421
#define IDS_PSOPTIONS                   422
#define IDS_MIRROR                      423
#define IDS_NEGATIVE_PRINT              424
#define IDS_PAGEINDEP                   425
#define IDS_COMPRESSBMP                 426
#define IDS_CTRLD_BEFORE                427
#define IDS_CTRLD_AFTER                 428
#define IDS_JOB_CONTROL                 429
#define IDS_TEXT_ASGRX                  431
#define IDS_PAGE_PROTECTION             432
#define IDS_CANCEL_CONFLICT             433
#define IDS_IGNORE_CONFLICT             434
#define IDS_RESOLVE_CONFLICT            435
#define IDS_GETDATA_FAILED              436
#define IDS_DRIVERUI_COLORMODE          437
#define IDS_ENVELOPE                    438
#define IDS_ENV_PREFIX                  439
#define IDS_PSPROTOCOL                  440
#define IDS_PSPROTOCOL_ASCII            441
#define IDS_PSPROTOCOL_BCP              442
#define IDS_PSPROTOCOL_TBCP             443
#define IDS_PSPROTOCOL_BINARY           444
#define IDS_TRAY_FORMSOURCE             445
#define IDS_OEMERR_DLGTITLE             446
#define IDS_OEMERR_OPTITEM              447
#define IDS_OEMERR_PROPSHEET            448
#define IDS_CANCEL_CONFLICT_FINAL       449

#define IDS_PSERROR_HANDLER             450
#define IDS_PSMINOUTLINE                451
#define IDS_PSMAXBITMAP                 452
#define IDS_PIXELS                      453
#define IDS_PSOUTPUT_OPTION             454
#define IDS_PSOPT_SPEED                 455
#define IDS_PSOPT_PORTABILITY           456
#define IDS_PSOPT_EPS                   457
#define IDS_PSOPT_ARCHIVE               458
#define IDS_PSTT_DLFORMAT               459
#define IDS_TTDL_DEFAULT                460
#define IDS_TTDL_TYPE1                  461
#define IDS_TTDL_TYPE3                  462
#define IDS_TTDL_TYPE42                 463

#ifdef WINNT_40
#define IDS_NUPOPTION                   464
#define IDS_ONE_UP                      465
#define IDS_TWO_UP                      466
#define IDS_FOUR_UP                     467
#define IDS_SIX_UP                      468
#define IDS_NINE_UP                     469
#define IDS_SIXTEEN_UP                  470
#else
#define IDS_NUPOPTION                   IDS_CPSUI_NUP
#define IDS_ONE_UP                      IDS_CPSUI_NUP_NORMAL
#define IDS_TWO_UP                      IDS_CPSUI_NUP_TWOUP
#define IDS_FOUR_UP                     IDS_CPSUI_NUP_FOURUP
#define IDS_SIX_UP                      IDS_CPSUI_NUP_SIXUP
#define IDS_NINE_UP                     IDS_CPSUI_NUP_NINEUP
#define IDS_SIXTEEN_UP                  IDS_CPSUI_NUP_SIXTEENUP
#endif //WINNT_40

#define IDS_PSLEVEL                     471
#define IDS_ICMMETHOD                   475
#define IDS_ICMMETHOD_NONE              476
#define IDS_ICMMETHOD_SYSTEM            477
#define IDS_ICMMETHOD_DRIVER            478
#define IDS_ICMMETHOD_DEVICE            479
#define IDS_ICMINTENT                   480
#define IDS_ICMINTENT_SATURATE          481
#define IDS_ICMINTENT_CONTRAST          482
#define IDS_ICMINTENT_COLORIMETRIC      483
#define IDS_ICMINTENT_ABS_COLORIMETRIC  484
#define IDS_CUSTOMSIZE_ERROR            485
#define IDS_CUSTOMSIZEPARAM_ERROR       486
#define IDS_CUSTOMSIZE_UNRESOLVED       488

#define IDS_FEEDDIRECTION_BASE          489
#define IDS_FEED_LONGEDGEFIRST          (IDS_FEEDDIRECTION_BASE + LONGEDGEFIRST)
#define IDS_FEED_SHORTEDGEFIRST         (IDS_FEEDDIRECTION_BASE + SHORTEDGEFIRST)
#define IDS_FEED_LONGEDGEFIRST_FLIPPED  (IDS_FEEDDIRECTION_BASE + LONGEDGEFIRST_FLIPPED)
#define IDS_FEED_SHORTEDGEFIRST_FLIPPED (IDS_FEEDDIRECTION_BASE + SHORTEDGEFIRST_FLIPPED)

#define IDS_EDIT_CUSTOMSIZE             493

#ifdef WINNT_40
#define IDS_PAGEORDER                   494
#define IDS_PAGEORDER_NORMAL            495
#define IDS_PAGEORDER_REVERSE           496
#else
#define IDS_PAGEORDER                   IDS_CPSUI_PAGEORDER
#define IDS_PAGEORDER_NORMAL            IDS_CPSUI_FRONTTOBACK
#define IDS_PAGEORDER_REVERSE           IDS_CPSUI_BACKTOFRONT
#endif // WINNT_40

#define IDS_QUALITY_FIRST               500
#define IDS_QUALITY_BEST                IDS_QUALITY_FIRST
#define IDS_QUALITY_BETTER              501
#define IDS_QUALITY_DRAFT               502
#define IDS_QUALITY_SETTINGS            503
#define IDS_QUALITY_CUSTOM              504
#define IDS_PP_SOFTFONTS                505
#define IDS_BOOKLET                     506

#define IDS_TRUE_GRAY_TEXT              507
#define IDS_TRUE_GRAY_GRAPH             508

#define IDS_ADD_EURO                    509

#define IDS_FONTINST_DIRECTORYTOOLONG   510
#define IDS_FONTINST_FONTINSTALLER      511
#define IDS_FONTINST_INVALIDDIR         512
#define IDS_FONTINST_NOFONTFOUND        513
#define IDS_FONTINST_NODIRNAME          514
#define IDS_FONTINST_OUTOFMEMORY        515


// DCR - use appropriate icons

#define IDI_USE_DEFAULT                 0
#define IDI_PSPROTOCOL                  IDI_USE_DEFAULT
#define IDI_PSOPT_SPEED                 IDI_USE_DEFAULT
#define IDI_PSOPT_PORTABILITY           IDI_USE_DEFAULT
#define IDI_PSOPT_EPS                   IDI_USE_DEFAULT
#define IDI_PSOPT_ARCHIVE               IDI_USE_DEFAULT
#define IDI_ONE_UP                      IDI_USE_DEFAULT
#define IDI_TWO_UP                      IDI_USE_DEFAULT
#define IDI_FOUR_UP                     IDI_USE_DEFAULT
#define IDI_SIX_UP                      IDI_USE_DEFAULT
#define IDI_NINE_UP                     IDI_USE_DEFAULT
#define IDI_SIXTEEN_UP                  IDI_USE_DEFAULT
#define IDI_BOOKLET                     IDI_USE_DEFAULT
#define IDI_PSTT_DLFORMAT               IDI_USE_DEFAULT
#define IDI_PSLEVEL                     IDI_USE_DEFAULT
#define IDI_ICMMETHOD_NONE              IDI_CPSUI_ICM_METHOD
#define IDI_ICMMETHOD_SYSTEM            IDI_CPSUI_ICM_METHOD
#define IDI_ICMMETHOD_DRIVER            IDI_CPSUI_ICM_METHOD
#define IDI_ICMMETHOD_DEVICE            IDI_CPSUI_ICM_METHOD
#define IDI_ICMINTENT_SATURATE          IDI_CPSUI_ICM_INTENT
#define IDI_ICMINTENT_CONTRAST          IDI_CPSUI_ICM_INTENT
#define IDI_ICMINTENT_COLORIMETRIC      IDI_CPSUI_ICM_INTENT
#define IDI_ICMINTENT_ABS_COLORIMETRIC  IDI_CPSUI_ICM_INTENT
#define IDI_CUSTOM_PAGESIZE             IDI_USE_DEFAULT
#define IDI_PAGEORDER_NORMAL            IDI_USE_DEFAULT
#define IDI_PAGEORDER_REVERSE           IDI_USE_DEFAULT


//
// PostScript custom page size dialog resources
//

#ifdef PSCRIPT

#define IDD_PSCRIPT_CUSTOMSIZE          1000

#define IDS_PS_VERSION                  1002

#define IDC_RESTOREDEFAULTS             100
#define IDC_CS_INCH                     101
#define IDC_CS_MM                       102
#define IDC_CS_POINT                    103
#define IDC_CS_WIDTH                    104
#define IDC_CS_HEIGHT                   105
#define IDC_CS_WIDTHRANGE               106
#define IDC_CS_HEIGHTRANGE              107
#define IDC_CS_XOFFSET                  108
#define IDC_CS_YOFFSET                  109
#define IDC_CS_XOFFSETRANGE             110
#define IDC_CS_YOFFSETRANGE             111
#define IDC_CS_FEEDDIRECTION            112
#define IDC_CS_CUTSHEET                 113
#define IDC_CS_ROLLFED                  114

#define IDD_ABOUT                       1001
#define IDC_WINNT_VER                   100
#define IDC_MODELNAME                   101
#define IDC_PPD_FILENAME                102
#define IDC_PPD_FILEVER                 103

#define IDI_PSCRIPT                     1000

#endif // PSCRIPT

#ifdef UNIDRV

#define IDD_ABOUT                       1001
#define IDC_WINNT_VER                   100
#define IDC_MODELNAME                   101
#define IDC_GPD_FILENAME                102
#define IDC_GPD_FILEVER                 103

#define IDI_UNIDRV                      1000

#endif // UNIDRV

#define IDI_WARNING_ICON                2000

#ifdef WINNT_40

#define VER_54DRIVERVERSION_STR         "4.50"

#endif // WINNT_40
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\driverui\upgrade.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    upgrade.c

Abstract:

    This file handles the DrvUpgradePrinter spooler API

Environment:

    Win32 subsystem, DriverUI module, user mode

Revision History:

    02/13/97 -davidx-
        Implement OEM plugin support.

    02/06/97 -davidx-
        Rewrote it to use common data management functions.

    07/17/96 -amandan-
        Created it.

--*/

#include "precomp.h"

//
// Forward and external function declarations
//

BOOL BInitOrUpgradePrinterProperties(PCOMMONINFO);
BOOL BUpgradeFormTrayTable(PCOMMONINFO);
VOID VUpgradeDefaultDevmode(PCOMMONINFO);

#if defined(UNIDRV) && !defined(WINNT_40)
BOOL
BUpgradeSoftFonts(
    PCOMMONINFO             pci,
    PDRIVER_UPGRADE_INFO_2  pUpgradeInfo);
#endif //defined(UNIDRV) && !defined(WINNT_40)



BOOL
DrvUpgradePrinter(
    DWORD   dwLevel,
    LPBYTE  pDriverUpgradeInfo
    )
/*++

Routine Description:

    This function is called by the spooler everytime a new driver
    is copied to the system.  This function checks for appropriate
    registry keys in the registry.  If the new registry keys are not
    present, it will set the new keys with default values.  This function
    will handle the upgrading of information in the registry to the new driver format.

Arguments:

    dwLevel - version info for DRIVER_UPGRADE_INFO
    pDriverUpgradeInfo - pointer to DRIVER_UPGRADE_INFO_1

Return Value:

    TRUE for success and FALSE for failure

--*/

{
    PDRIVER_UPGRADE_INFO_1  pUpgradeInfo1 = (PDRIVER_UPGRADE_INFO_1) pDriverUpgradeInfo;
    PCOMMONINFO             pci;
    BOOL                    bResult = TRUE;
    DWORD                   dwSize, dwType = REG_SZ;
    PFN_OEMUpgradePrinter   pfnOEMUpgradePrinter;
    PFN_OEMUpgradeRegistry  pfnOEMUpgradeRegistry;

    //
    // Verify the validity of input parameters
    //


    if (pDriverUpgradeInfo == NULL)
    {
        ERR(("Invalid DrvUpgradePrinter parameters.\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    #if  defined(WINNT_40)
    if (dwLevel != 1 )
    {
        ERR(("DrvUpgradePrinter...dwLevel != 1\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    #else // NT 5.0
    if (dwLevel != 1 && dwLevel != 2)
    {
        WARNING(("Level is neither 1 nor 2.\n"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    #endif // defined(WINNT_40)


    //
    // Open the printer with administrator access
    // and load basic printer information
    //

    pci = PLoadCommonInfo(NULL,
                          pUpgradeInfo1->pPrinterName,
                          FLAG_OPENPRINTER_ADMIN |
                          FLAG_INIT_PRINTER |
                          FLAG_REFRESH_PARSED_DATA |
                          FLAG_UPGRADE_PRINTER);

    if (pci == NULL)
    {
        ERR(("DrvUpgradePrinter..pci==NULL.\n"));
        return FALSE;
    }

    //
    // Update printer properties information
    //

    (VOID) BInitOrUpgradePrinterProperties(pci);
    (VOID) BUpgradeFormTrayTable(pci);

    VUpgradeDefaultDevmode(pci);

    #ifndef WINNT_40

    VNotifyDSOfUpdate(pci->hPrinter);

    #endif // !WINNT_40


    #if defined(UNIDRV) && !defined(WINNT_40)

    //
    // NT 5.0 UniDriver specific upgrade steps
    //

    //
    // Make sure that the DRIVER_UPGRADE_INFO's level is 2.
    //

    if (dwLevel == 2)
    {
        BUpgradeSoftFonts(pci, (PDRIVER_UPGRADE_INFO_2)pUpgradeInfo1);
    }

    #endif //defined(UNIDRV) && !defined(WINNT_40)

    //
    // call OEMUpgradePrinter entrypoint for each plugin
    //

    FOREACH_OEMPLUGIN_LOOP(pci)

        if (HAS_COM_INTERFACE(pOemEntry))
        {
            //
            // If the OEM does not implement upgradeprinter, then they
            // cannot support upgraderegistry since you can only upgrade
            // registry if you support upgradeprinter.
            //

            HRESULT hr;

            hr = HComOEMUpgradePrinter(pOemEntry,
                                       dwLevel,
                                       pDriverUpgradeInfo) ;

            if (hr == E_NOTIMPL)
                continue;

            bResult = SUCCEEDED(hr);

        }
        else
        {

            if ((pfnOEMUpgradePrinter = GET_OEM_ENTRYPOINT(pOemEntry, OEMUpgradePrinter)) &&
                !pfnOEMUpgradePrinter(dwLevel, pDriverUpgradeInfo))
            {
                ERR(("OEMUpgradePrinter failed for '%ws': %d\n",
                    CURRENT_OEM_MODULE_NAME(pOemEntry),
                    GetLastError()));

                bResult = FALSE;
            }

            if ((pfnOEMUpgradeRegistry = GET_OEM_ENTRYPOINT(pOemEntry, OEMUpgradeRegistry)) &&
                !pfnOEMUpgradeRegistry(dwLevel, pDriverUpgradeInfo, BUpgradeRegistrySettingForOEM))
            {
                ERR(("OEMUpgradeRegistry failed for '%ws': %d\n",
                    CURRENT_OEM_MODULE_NAME(pOemEntry),
                    GetLastError()));

                bResult = FALSE;
            }

        }
    END_OEMPLUGIN_LOOP

    VFreeCommonInfo(pci);
    return bResult;
}



BOOL
BUpgradeFormTrayTable(
    PCOMMONINFO pci
    )

/*++

Routine Description:

    Upgrade the form-to-tray assignment table in the registry

Arguments:

    pci - Points to basic printer information

Return Value:

    TRUE if upgrade is successful, FALSE otherwise

--*/

{
    PWSTR   pFormTrayTable;
    DWORD   dwSize;
    BOOL    bResult;

    //
    // Get a copy of the current form-to-tray assignment table.
    // If new format data is not present but old format data is,
    // this will call the appropriate library function to convert
    // old format data to new format.
    //

    pFormTrayTable = PGetFormTrayTable(pci->hPrinter, &dwSize);

    if (pFormTrayTable == NULL)
        return TRUE;

    //
    // Save the form-to-tray assignment table back to registry
    //

    bResult = BSaveFormTrayTable(pci->hPrinter, pFormTrayTable, dwSize);
    MemFree(pFormTrayTable);

    return bResult;
}



VOID
VUpgradeDefaultDevmode(
    PCOMMONINFO pci
    )

/*++

Routine Description:

    Upgrade the default printer devmode, if necessary

Arguments:

    pci - Points to basic printer information

Return Value:

    NONE

--*/

{
    PPRINTER_INFO_2 pPrinterInfo2;
    PDEVMODE        pdm;

    if ((pPrinterInfo2 = MyGetPrinter(pci->hPrinter, 2)) &&
        (pdm = pPrinterInfo2->pDevMode) &&
        BFillCommonInfoDevmode(pci, pdm, NULL) &&
        (pci->pdm->dmSpecVersion != pdm->dmSpecVersion ||
         pci->pdm->dmDriverVersion != pdm->dmDriverVersion ||
         pci->pdm->dmSize != pdm->dmSize ||
         pci->pdm->dmDriverExtra != pdm->dmDriverExtra))
    {
        pPrinterInfo2->pDevMode = pci->pdm;
        SetPrinter(pci->hPrinter, 2, (PBYTE) pPrinterInfo2, 0);
    }

    MemFree(pPrinterInfo2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\driverui\ps\precomp.h ===
//
// Copyright (c) 1997-1998 Microsoft Corporation
//
#include "lib.h"
#include <commctrl.h>
#include <winddiui.h>
#include "ppd.h"
#include "oemutil.h"
#include "pslib.h"
#include "uires.h"
#include "uihelp.h"
#include "driverui.h"
#include "oemui.h"
#include <prcomoem.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\driverui\ps\custsize.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    custsize.c

Abstract:

    Display PostScript custom page size UI

Environment:

    Windows NT PostScript driver UI

Revision History:

    03/31/97 -davidx-
        Created it.

--*/

#include "precomp.h"
#include <windowsx.h>
#include <math.h>


//
// PostScript custom page size context-sensitive help IDs
//

static const DWORD PSCustSizeHelpIDs[] = {

    IDC_CS_WIDTH,           IDH_PSCUST_Width,
    IDC_CS_HEIGHT,          IDH_PSCUST_Height,
    IDC_CS_INCH,            IDH_PSCUST_Unit_Inch,
    IDC_CS_MM,              IDH_PSCUST_Unit_Millimeter,
    IDC_CS_POINT,           IDH_PSCUST_Unit_Point,
    IDC_CS_FEEDDIRECTION,   IDH_PSCUST_PaperFeed_Direction,
    IDC_CS_CUTSHEET,        IDH_PSCUST_Paper_CutSheet,
    IDC_CS_ROLLFED,         IDH_PSCUST_Paper_RollFeed,
    IDC_CS_XOFFSET,         IDH_PSCUST_Offset_Perpendicular,
    IDC_CS_YOFFSET,         IDH_PSCUST_Offset_Parallel,
    IDOK,                   IDH_PSCUST_OK,
    IDCANCEL,               IDH_PSCUST_Cancel,
    IDC_RESTOREDEFAULTS,    IDH_PSCUST_Restore_Defaults,

    0, 0
};

//
// Display units
// Note: These constants must be in the same order as dialog control IDs:
//  IDC_CS_INCH, IDC_CS_MM, IDC_CS_POINT
//

enum { CSUNIT_INCH, CSUNIT_MM, CSUNIT_POINT, CSUNIT_MAX };

static const double adCSUnitData[CSUNIT_MAX] =
{
    25400.0,            // microns per inch
    1000.0,             // microns per millimeter
    25400.0 / 72.0,     // microns per point
};

//
// Data structure used to pass information to custom page size dialog
//

typedef struct _CUSTOMSIZEDLG {

    CUSTOMSIZEDATA  csdata;     // custom page size data, must be the first field
    PUIDATA         pUiData;    // pointer to UIDATA structure
    PPPDDATA        pPpdData;   // pointer to PPDDATA structure
    BOOL            bMetric;    // whether we're on metric system
    INT             iUnit;      // current display unit
    BOOL            bSetText;   // we're calling SetDlgItemText
    BOOL            bOKPassed;  // user hit OK and setting passed validation/resolution

    // feed direction to combo box option mapping table (round up to 4-byte boundary)
    BYTE            aubFD2CBOptionMapping[(MAX_FEEDDIRECTION + 3) & ~3];

} CUSTOMSIZEDLG, *PCUSTOMSIZEDLG;

#define MAXDIGITLEN                16     // maximum number of digits for user-entered numbers
#define INVALID_CBOPTION_INDEX     0xFF   // invalid option index for the feeding direction combo box

#define CUSTSIZE_ROUNDUP(x)        (ceil((x) * 100.0) / 100.0 + 0.001)
#define CUSTSIZE_ROUNDDOWN(x)      (floor((x) * 100.0) / 100.0 + 0.001)


VOID
VUpdateCustomSizeTextField(
    HWND             hDlg,
    PCUSTOMSIZEDLG   pDlgData,
    INT              iCtrlID,
    PCUSTOMSIZERANGE pCSRange
    )

/*++

Routine Description:

    Update the custom size parameter text fields:
        width, height, and offsets

Arguments:

    hDlg - Handle to custom page size dialog window
    pDlgData - Points to custom page size dialog data
    iCtrlID - Specifies the interested text field control ID
    pCSRange - custom page size parameter ranges

Return Value:

    NONE

--*/

{
    TCHAR   tchBuf[MAX_DISPLAY_NAME];
    DWORD   dwVal;
    double  dMin, dMax;
    double  dNum;

    switch (iCtrlID)
    {
    case IDC_CS_WIDTH:
        dwVal = pDlgData->csdata.dwX;
        pCSRange += CUSTOMPARAM_WIDTH;
        break;

    case IDC_CS_HEIGHT:
        dwVal = pDlgData->csdata.dwY;
        pCSRange += CUSTOMPARAM_HEIGHT;
        break;

    case IDC_CS_XOFFSET:
        dwVal = pDlgData->csdata.dwWidthOffset;
        pCSRange += CUSTOMPARAM_WIDTHOFFSET;
        break;

    case IDC_CS_YOFFSET:
        dwVal = pDlgData->csdata.dwHeightOffset;
        pCSRange += CUSTOMPARAM_HEIGHTOFFSET;
        break;
    }

    //
    // The dMin/dMax algorithm here must be the same as in following function
    // VUpdateCustomSizeRangeField.
    //
    // We only show 2 digits after the decimal point. We round the min
    // number up (ceil) and round the max number down (floor). Also, in
    // order to correct double -> DWORD conversion error we saw in some
    // cases (ex. 39.000 is converted to DWROD 38 since the 39.000 is actually
    // 38.999999...), we add the extra 0.001.
    //

    dMin = (double) pCSRange->dwMin / adCSUnitData[pDlgData->iUnit];
    dMin = CUSTSIZE_ROUNDUP(dMin);

    dMax = (double) pCSRange->dwMax / adCSUnitData[pDlgData->iUnit];
    dMax = CUSTSIZE_ROUNDDOWN(dMax);

    // Fix bug Adobe #260379. 7/25/98  jjia
    // _stprintf(tchBuf, TEXT("%0.2f"), (double) dwVal / adCSUnitData[pDlgData->iUnit]);

    //
    // Fix MS #23733: PostScript custom page size dialog warns in border cases.
    //
    // Round the number first (2 digits after decimal point), then add 0.001 as explained above.
    //

    dNum = (double) dwVal / adCSUnitData[pDlgData->iUnit] + 0.005;
    dNum = CUSTSIZE_ROUNDDOWN(dNum);

    //
    // Make sure we don't show value outside of the range. This is to take care of rounding errors.
    //

    if (dNum < dMin)
    {
        dNum = dMin;
    }
    else if (dNum > dMax)
    {
        dNum = dMax;
    }

    _stprintf(tchBuf, TEXT("%ld.%0.2lu"),
    (DWORD)dNum, (DWORD)((dNum - (DWORD)dNum) * 100.0));

    SetDlgItemText(hDlg, iCtrlID, tchBuf);
}



VOID
VUpdateCustomSizeRangeField(
    HWND             hDlg,
    PCUSTOMSIZEDLG   pDlgData,
    INT              iCtrlID,
    PCUSTOMSIZERANGE pCSRange
    )

/*++

Routine Description:

    Update the custom size parameter range fields:
        width, height, and offsets

Arguments:

    hDlg - Handle to custom page size dialog window
    pDlgData - Points to custom page size dialog data
    iCtrlID - Specifies the interested range field control ID
    pCSRange - custom page size parameter ranges

Return Value:

    NONE

--*/

{
    TCHAR   tchBuf[MAX_DISPLAY_NAME];
    double  dMin, dMax;

    switch (iCtrlID)
    {
    case IDC_CS_WIDTHRANGE:
        pCSRange += CUSTOMPARAM_WIDTH;
        break;

    case IDC_CS_HEIGHTRANGE:
        pCSRange += CUSTOMPARAM_HEIGHT;
        break;

    case IDC_CS_XOFFSETRANGE:
        pCSRange += CUSTOMPARAM_WIDTHOFFSET;
        break;

    case IDC_CS_YOFFSETRANGE:
        pCSRange += CUSTOMPARAM_HEIGHTOFFSET;
        break;
    }

    // Fix bug Adobe #260379. 7/25/98  jjia
    // If we build the driver using public MSVC, MSTOOLS and DDK,
    // the text string will become garbage. So, Don't use '%0.2f'
    // to format numbers.
    //  _stprintf(tchBuf,
    //            TEXT("(%0.2f, %0.2f)"),
    //            (double) pCSRange->dwMin / adCSUnitData[pDlgData->iUnit],
    //            (double) pCSRange->dwMax / adCSUnitData[pDlgData->iUnit]);

    //
    // Fix MS #23733: PostScript custom page size dialog warns in border cases.
    //
    // We only show 2 digits after the decimal point. We round the min
    // number up (ceil) and round the max number down (floor). Also, in
    // order to correct double -> DWORD conversion error we saw in some
    // cases (ex. 39.000 is converted to DWROD 38 since the 39.000 is actually
    // 38.999999...), we add the extra 0.001.
    //

    dMin = (double) pCSRange->dwMin / adCSUnitData[pDlgData->iUnit];
    dMin = CUSTSIZE_ROUNDUP(dMin);

    dMax = (double) pCSRange->dwMax / adCSUnitData[pDlgData->iUnit];
    dMax = CUSTSIZE_ROUNDDOWN(dMax);

    _stprintf(tchBuf,
          TEXT("(%ld.%0.2lu, %ld.%0.2lu)"),
          (DWORD)dMin, (DWORD)((dMin - (DWORD)dMin) * 100.0),
          (DWORD)dMax, (DWORD)((dMax - (DWORD)dMax) * 100.0));

    SetDlgItemText(hDlg, iCtrlID, tchBuf);
}



VOID
VUpdateCustomSizeDlgFields(
    HWND            hDlg,
    PCUSTOMSIZEDLG  pDlgData,
    BOOL            bUpdateRangeOnly
    )

/*++

Routine Description:

    Update the custom page size dialog controls with
    the current custom page size parameter values

Arguments:

    hDlg - Handle to custom page size dialog window
    pDlgData - Points to custom page size dialog data
    bUpdateRangeOnly - Whether we need to update the range fields only

Return Value:

    NONE

--*/

{
    CUSTOMSIZERANGE csrange[4];

    VGetCustomSizeParamRange(pDlgData->pUiData->ci.pRawData, &pDlgData->csdata, csrange);

    if (! bUpdateRangeOnly)
    {
        //
        // Update the text fields
        //

        pDlgData->bSetText = TRUE;

        VUpdateCustomSizeTextField(hDlg, pDlgData, IDC_CS_WIDTH, csrange);
        VUpdateCustomSizeTextField(hDlg, pDlgData, IDC_CS_HEIGHT, csrange);
        VUpdateCustomSizeTextField(hDlg, pDlgData, IDC_CS_XOFFSET, csrange);
        VUpdateCustomSizeTextField(hDlg, pDlgData, IDC_CS_YOFFSET, csrange);

        pDlgData->bSetText = FALSE;

        //
        // Update the paper feed direction combo box
        //

        ASSERT(pDlgData->aubFD2CBOptionMapping[pDlgData->csdata.wFeedDirection] != INVALID_CBOPTION_INDEX);

        if (SendDlgItemMessage(hDlg,
                               IDC_CS_FEEDDIRECTION,
                               CB_SETCURSEL,
                               pDlgData->aubFD2CBOptionMapping[pDlgData->csdata.wFeedDirection],
                               0) == CB_ERR)
        {
            ERR(("CB_SETCURSEL failed: %d\n", GetLastError()));
        }

        //
        // Update cut-sheet vs. roll-fed radio buttons
        //

        CheckDlgButton(hDlg, IDC_CS_CUTSHEET, pDlgData->csdata.wCutSheet);
        CheckDlgButton(hDlg, IDC_CS_ROLLFED, !pDlgData->csdata.wCutSheet);
    }

    //
    // Update ranges for width, height, and offsets
    //

    VUpdateCustomSizeRangeField(hDlg, pDlgData, IDC_CS_WIDTHRANGE, csrange);
    VUpdateCustomSizeRangeField(hDlg, pDlgData, IDC_CS_HEIGHTRANGE, csrange);
    VUpdateCustomSizeRangeField(hDlg, pDlgData, IDC_CS_XOFFSETRANGE, csrange);
    VUpdateCustomSizeRangeField(hDlg, pDlgData, IDC_CS_YOFFSETRANGE, csrange);
}



BOOL
BGetWidthHeightOffsetVal(
    HWND            hDlg,
    PCUSTOMSIZEDLG  pDlgData,
    INT             iCtrlID,
    PDWORD          pdwVal
    )

/*++

Routine Description:

    Get the current width/height/offset value in the specified text field

Arguments:

    hDlg - Handle to custom page size dialog window
    pDlgData - Points to custom page size dialog data
    iCtrlID - Specifies the interested text field control ID
    pdwVal - Return the current value in the specified text field (in microns)

Return Value:

    TRUE if successful, FALSE if the text field doesn't contain
    valid floating-point number.

    Note that this function doesn't perform any range check.
    That's done in a later step.

--*/

{
    TCHAR   tchBuf[MAXDIGITLEN];
    double  d;
    PTSTR   ptstr;
    BOOL    bResult = FALSE;

    //
    // Get the current value in the speicified text field
    //

    if (GetDlgItemText(hDlg, iCtrlID, tchBuf, MAXDIGITLEN) > 0)
    {
        //
        // Treat the string as floating-point number
        // Make sure there are no non-space characters left
        //

        d = _tcstod(tchBuf, &ptstr);

        while (*ptstr != NUL)
        {
            if (! _istspace(*ptstr))
                break;

            ptstr++;
        }

        if (bResult = (*ptstr == NUL))
        {
            //
            // Convert from current unit to microns
            //

            d *= adCSUnitData[pDlgData->iUnit];

            if (d < 0 || d > MAX_LONG)
                bResult = FALSE;
            else
                *pdwVal = (DWORD) d;
        }
    }

    if (!bResult)
    {
        //
        // automatically correct user's invalid input to value 0.00
        //

        SetDlgItemText(hDlg, iCtrlID, TEXT("0.00"));

        *pdwVal = 0;
    }

    return TRUE;
}



BOOL
BGetFeedDirectionSel(
    HWND            hDlg,
    PCUSTOMSIZEDLG  pDlgData,
    INT             iCtrlID,
    PDWORD          pdwVal
    )

/*++

Routine Description:

    Get the currently selected paper direction value

Arguments:

    hDlg - Handle to custom page size dialog window
    pDlgData - Points to custom page size dialog data
    iCtrlID - Specifies the paper feed direction combo box control ID
    pdwVal - Return the selected paper feed direction value

Return Value:

    TRUE if successful, FALSE if the selected choice is constrained
    or if there is an error

--*/

{
    LRESULT    lIndex, lVal;

    //
    // Get the currently chosen paper feed direction index
    //

    if (((lIndex = SendDlgItemMessage(hDlg, iCtrlID, CB_GETCURSEL, 0, 0)) == CB_ERR) ||
        ((lVal = SendDlgItemMessage(hDlg, iCtrlID, CB_GETITEMDATA, (WPARAM)lIndex, 0)) == CB_ERR))
        return FALSE;

    *pdwVal = (DWORD)lVal;
    return TRUE;
}



BOOL
BChangeCustomSizeData(
    HWND            hDlg,
    PCUSTOMSIZEDLG  pDlgData,
    INT             iCtrlID,
    DWORD           dwVal
    )

/*++

Routine Description:

    Change the specified custom page size parameter

Arguments:

    hDlg - Handle to custom page size dialog window
    pDlgData - Points to custom page size dialog data
    iCtrlID - Control ID indicating which parameter should be changed
    dwVal - New value for the specified parameter

Return Value:

    TRUE

--*/

{
    PCUSTOMSIZEDATA pCSData;

    //
    // Update the appropriate custom page size parameter
    //

    pCSData = &pDlgData->csdata;

    switch (iCtrlID)
    {
    case IDC_CS_WIDTH:
        pCSData->dwX = dwVal;
        break;

    case IDC_CS_HEIGHT:
        pCSData->dwY = dwVal;
        break;

    case IDC_CS_XOFFSET:
        pCSData->dwWidthOffset = dwVal;
        break;

    case IDC_CS_YOFFSET:
        pCSData->dwHeightOffset = dwVal;
        break;

    case IDC_CS_FEEDDIRECTION:
        pCSData->wFeedDirection = (WORD)dwVal;
        break;

    case IDC_CS_CUTSHEET:
        pCSData->wCutSheet = TRUE;
        return TRUE;

    case IDC_CS_ROLLFED:
        pCSData->wCutSheet = FALSE;
        return TRUE;
    }

    VUpdateCustomSizeDlgFields(hDlg, pDlgData, TRUE);
    return TRUE;
}



VOID
VInitPaperFeedDirectionList(
    HWND            hwndList,
    PCUSTOMSIZEDLG  pDlgData
    )

/*++

Routine Description:

    Initialize the paper feed direction combo box

Arguments:

    hwndList - Window handle to the paper feed direction combo box
    pDlgData - Points to custom page size dialog data

Return Value:

    NONE

--*/

{
    PUIINFO    pUIInfo;
    PPPDDATA   pPpdData;
    DWORD      dwIndex;
    TCHAR      tchBuf[MAX_DISPLAY_NAME];
    LRESULT    lIndex;

    if (hwndList == NULL)
        return;

    ASSERT(pDlgData);

    pUIInfo = pDlgData->pUiData->ci.pUIInfo;
    pPpdData = pDlgData->pPpdData;

    ASSERT(pUIInfo && pPpdData);

    for (dwIndex=0; dwIndex < MAX_FEEDDIRECTION; dwIndex++)
    {
        //
        // First: initialize the mapping table
        //

        pDlgData->aubFD2CBOptionMapping[dwIndex] = INVALID_CBOPTION_INDEX;

        //
        // Don't show the feeding direction if device doesn't supported it.
        //

        if ((dwIndex == LONGEDGEFIRST || dwIndex == LONGEDGEFIRST_FLIPPED) &&
            !LONGEDGEFIRST_SUPPORTED(pUIInfo, pPpdData))
            continue;

        if ((dwIndex == SHORTEDGEFIRST || dwIndex == SHORTEDGEFIRST_FLIPPED) &&
            !SHORTEDGEFIRST_SUPPORTED(pUIInfo, pPpdData))
            continue;

        if ((dwIndex == LONGEDGEFIRST || dwIndex == SHORTEDGEFIRST) &&
            (MINCUSTOMPARAM_ORIENTATION(pPpdData) > 1))
            continue;

        if ((dwIndex == LONGEDGEFIRST_FLIPPED || dwIndex == SHORTEDGEFIRST_FLIPPED) &&
            (MAXCUSTOMPARAM_ORIENTATION(pPpdData) < 2))
            continue;

        if (LoadString(ghInstance,
                       IDS_FEEDDIRECTION_BASE + dwIndex,
                       tchBuf,
                       MAX_DISPLAY_NAME))
        {
            if (((lIndex = SendMessage(hwndList, CB_ADDSTRING, 0, (LPARAM) tchBuf)) == CB_ERR) ||
                (SendMessage(hwndList, CB_SETITEMDATA, (WPARAM)lIndex, (LPARAM)dwIndex) == CB_ERR))
            {
                if (lIndex != CB_ERR)
                {
                    SendMessage(hwndList, CB_DELETESTRING, (WPARAM)lIndex, 0);
                    ERR(("CB_SETITEMDATA failed: %d\n", GetLastError()));
                }
                else
                {
                    ERR(("CB_ADDSTRING failed: %d\n", GetLastError()));
                }
            }
            else
            {
                //
                // Record the mapping from feed direction to combo box option index.
                // Note that the combo box can NOT be sorted.
                //

                pDlgData->aubFD2CBOptionMapping[dwIndex] = (BYTE)lIndex;
            }
        }
    }
}



BOOL
BCheckCustomSizeData(
    HWND            hDlg,
    PCUSTOMSIZEDLG  pDlgData
    )

{
    CUSTOMSIZEDATA  csdata;
    INT             iCtrlID;

    //
    // If there is no inconsistency, return TRUE
    //

    csdata = pDlgData->csdata;

    if (BValidateCustomPageSizeData(pDlgData->pUiData->ci.pRawData, &csdata))
        return TRUE;

    //
    // Otherwise, indicate which field is invalid
    //

    if (hDlg != NULL)
    {
        if (csdata.dwX != pDlgData->csdata.dwX)
            iCtrlID = IDC_CS_WIDTH;
        else if (csdata.dwY != pDlgData->csdata.dwY)
            iCtrlID = IDC_CS_HEIGHT;
        else if (csdata.dwWidthOffset != pDlgData->csdata.dwWidthOffset)
            iCtrlID = IDC_CS_XOFFSET;
        else if (csdata.dwHeightOffset != pDlgData->csdata.dwHeightOffset)
            iCtrlID = IDC_CS_YOFFSET;
        else if (csdata.wFeedDirection != pDlgData->csdata.wFeedDirection)
            iCtrlID = IDC_CS_FEEDDIRECTION;
        else
            iCtrlID = IDC_CS_CUTSHEET;

        SetFocus(GetDlgItem(hDlg, iCtrlID));

        if (iCtrlID == IDC_CS_WIDTH ||
            iCtrlID == IDC_CS_HEIGHT ||
            iCtrlID == IDC_CS_XOFFSET ||
            iCtrlID == IDC_CS_YOFFSET)
        {
            SendDlgItemMessage(hDlg, iCtrlID, EM_SETSEL, 0, -1);
        }
    }

    return FALSE;
}


BOOL
BCheckCustomSizeFeature(
    HWND            hDlg,
    PCUSTOMSIZEDLG  pDlgData,
    DWORD           dwFeatureID
    )

{
    PUIINFO         pUIInfo;
    PPPDDATA        pPpdData;
    PFEATURE        pFeature;
    DWORD           dwFeatureIndex, dwOptionIndex;
    CONFLICTPAIR    ConflictPair;

    //
    // If the specified feature doesn't exist, simply return TRUE
    //

    pUIInfo = pDlgData->pUiData->ci.pUIInfo;

    if (! (pFeature = GET_PREDEFINED_FEATURE(pUIInfo, dwFeatureID)))
        return TRUE;

    dwFeatureIndex = GET_INDEX_FROM_FEATURE(pUIInfo, pFeature);
    pPpdData = pDlgData->pPpdData;

    if (dwFeatureID == GID_LEADINGEDGE)
    {
        if (SKIP_LEADINGEDGE_CHECK(pUIInfo, pPpdData))
            return TRUE;

        dwOptionIndex = (pDlgData->csdata.wFeedDirection == SHORTEDGEFIRST ||
                         pDlgData->csdata.wFeedDirection == SHORTEDGEFIRST_FLIPPED) ?
                                pPpdData->dwLeadingEdgeShort :
                                pPpdData->dwLeadingEdgeLong;

        if (dwOptionIndex == OPTION_INDEX_ANY)
        {
            goto error;
        }
    }
    else // (dwFeatureID == GID_USEHWMARGINS)
    {
        dwOptionIndex = pDlgData->csdata.wCutSheet ?
                                pPpdData->dwUseHWMarginsTrue :
                                pPpdData->dwUseHWMarginsFalse;
    }

    //
    // Return TRUE if there is no conflict. This is opposite of
    // EnumNewPickOneUIConflict which returns TRUE if there is a conflict.
    //

    if (! EnumNewPickOneUIConflict(
                    pDlgData->pUiData->ci.pRawData,
                    pDlgData->pUiData->ci.pCombinedOptions,
                    dwFeatureIndex,
                    dwOptionIndex,
                    &ConflictPair))
    {
        return TRUE;
    }

    error:

    if (hDlg != NULL)
    {
        SetFocus(GetDlgItem(hDlg,
                            dwFeatureID == GID_LEADINGEDGE ?
                                IDC_CS_FEEDDIRECTION :
                                IDC_CS_CUTSHEET));
    }

    return FALSE;
}


BOOL
BResolveCustomSizeData(
    HWND            hDlg,
    PCUSTOMSIZEDLG  pDlgData
    )

{
    PRAWBINARYDATA  pRawData;
    CUSTOMSIZEDATA  cssave;
    PCUSTOMSIZEDATA pCSData;

    pRawData = pDlgData->pUiData->ci.pRawData;
    cssave = pDlgData->csdata;
    pCSData = &pDlgData->csdata;

    //
    // Choose alternative wCutSheet and wFeedDirection
    // value if the current value is constrained.
    //

    if (! BCheckCustomSizeFeature(hDlg, pDlgData, GID_USEHWMARGINS))
        pCSData->wCutSheet = pCSData->wCutSheet ? FALSE : TRUE;

    if (! BCheckCustomSizeFeature(hDlg, pDlgData, GID_LEADINGEDGE))
    {
       pCSData->wFeedDirection =
            (pCSData->wFeedDirection == SHORTEDGEFIRST ||
             pCSData->wFeedDirection == SHORTEDGEFIRST_FLIPPED) ?
                LONGEDGEFIRST : SHORTEDGEFIRST;
    }

    //
    // Check to see if the specified custom page size parameters are consistent
    //

    (VOID) BValidateCustomPageSizeData(pRawData, pCSData);

    if (pCSData->dwX != cssave.dwX || pCSData->dwY != cssave.dwY)
    {
        CUSTOMSIZEDATA  cstemp;

        //
        // If the width or height parameter is adjusted,
        // try to adjust the feed direction parameter first
        //

        cstemp = *pCSData;
        *pCSData = cssave;
        pCSData->wCutSheet = cstemp.wCutSheet;

        pCSData->wFeedDirection =
            (cstemp.wFeedDirection == SHORTEDGEFIRST ||
             cstemp.wFeedDirection == SHORTEDGEFIRST_FLIPPED) ?
                LONGEDGEFIRST : SHORTEDGEFIRST;

        (VOID) BValidateCustomPageSizeData(pRawData, pCSData);

        if (pCSData->dwX != cssave.dwX ||
            pCSData->dwY != cssave.dwY ||
            !BCheckCustomSizeFeature(hDlg, pDlgData, GID_LEADINGEDGE))
        {
            *pCSData = cstemp;
        }
    }

    if ((hDlg != NULL) &&
        (!BCheckCustomSizeFeature(hDlg, pDlgData, GID_USEHWMARGINS) ||
         !BCheckCustomSizeFeature(hDlg, pDlgData, GID_LEADINGEDGE)))
    {
        *pCSData = cssave;
        return FALSE;
    }

    return TRUE;
}


BOOL
BCheckCustomSizeDataConflicts(
    HWND            hDlg,
    PCUSTOMSIZEDLG  pDlgData
    )

/*++

Routine Description:

    Resolve any conflicts involving *LeadingEdge and *UseHWMargins
    and any inconsistencies between custom page size parameters

Arguments:

    hDlg - Handle to custom page size dialog window
        NULL if the window is not displayed yet
    pDlgData - Points to custom page size dialog data

Return Value:

    FALSE if there are any unresolved conflicts or inconsistencies,
    TRUE otherwise

--*/

{
    BOOL bResult;

    //
    // Check if there is any inconsistency
    //

    bResult = BCheckCustomSizeFeature(hDlg, pDlgData, GID_LEADINGEDGE) &&
              BCheckCustomSizeFeature(hDlg, pDlgData, GID_USEHWMARGINS) &&
              BCheckCustomSizeData(hDlg, pDlgData);

    if (! bResult)
    {
        //
        // Display an error message and ask the user whether he wants
        // to let the system automatically resolve the inconsistency.
        //

        if (hDlg == NULL ||
            IDisplayErrorMessageBox(hDlg,
                                    MB_OKCANCEL | MB_ICONERROR,
                                    IDS_CUSTOMSIZE_ERROR,
                                    IDS_CUSTOMSIZEPARAM_ERROR) == IDOK)
        {
            bResult = BResolveCustomSizeData(hDlg, pDlgData);

            if (!bResult && hDlg != NULL)
            {
                (VOID) IDisplayErrorMessageBox(
                            hDlg,
                            0,
                            IDS_CUSTOMSIZE_ERROR,
                            IDS_CUSTOMSIZE_UNRESOLVED);
            }
        }
    }

    return bResult;
}



INT_PTR CALLBACK
BCustomSizeDlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )

/*++

Routine Description:

    Dialog procedure for custom page size dialog

Arguments:

    hDlg - Handle to dialog window
    uMsg - Message
    wParam, lParam - Parameters

Return Value:

    TRUE or FALSE depending on whether message is processed

--*/

{
    PCUSTOMSIZEDLG  pDlgData;
    INT             iCmd;
    DWORD           dwVal;

    switch (uMsg)
    {
    case WM_INITDIALOG:

        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)lParam);
        pDlgData = (PCUSTOMSIZEDLG) lParam;

        if (pDlgData == NULL)
        {
            RIP(("Dialog parameter is NULL\n"));
            EndDialog(hDlg, IDCANCEL);
            return FALSE;
        }

        SendDlgItemMessage(hDlg, IDC_CS_WIDTH, EM_SETLIMITTEXT, MAXDIGITLEN-1, 0);
        SendDlgItemMessage(hDlg, IDC_CS_HEIGHT, EM_SETLIMITTEXT, MAXDIGITLEN-1, 0);
        SendDlgItemMessage(hDlg, IDC_CS_XOFFSET, EM_SETLIMITTEXT, MAXDIGITLEN-1, 0);
        SendDlgItemMessage(hDlg, IDC_CS_YOFFSET, EM_SETLIMITTEXT, MAXDIGITLEN-1, 0);

        pDlgData->iUnit = pDlgData->bMetric ? CSUNIT_MM : CSUNIT_INCH;
        CheckRadioButton(hDlg, IDC_CS_INCH, IDC_CS_POINT, IDC_CS_INCH + pDlgData->iUnit);

        //
        // Determine which feed directions should be disabled
        //

        VInitPaperFeedDirectionList(GetDlgItem(hDlg, IDC_CS_FEEDDIRECTION), pDlgData);

        //
        // Set up the initial display
        //

        if (! (pDlgData->pPpdData->dwCustomSizeFlags & CUSTOMSIZE_CUTSHEET))
            EnableWindow(GetDlgItem(hDlg, IDC_CS_CUTSHEET), FALSE);

        if (! (pDlgData->pPpdData->dwCustomSizeFlags & CUSTOMSIZE_ROLLFED))
            EnableWindow(GetDlgItem(hDlg, IDC_CS_ROLLFED), FALSE);

        VUpdateCustomSizeDlgFields(hDlg, pDlgData, FALSE);
        ShowWindow(hDlg, SW_SHOW);
        break;

    case WM_COMMAND:

        pDlgData = (PCUSTOMSIZEDLG) GetWindowLongPtr(hDlg, DWLP_USER);

        if (pDlgData == NULL)
        {
            RIP(("Dialog parameter is NULL\n"));
            break;
        }

        iCmd = GET_WM_COMMAND_ID(wParam, lParam);

        switch (iCmd)
        {
        case IDOK:

            //
            // Check if the selected paper feed direction is constrained
            //

            if (BCheckCustomSizeDataConflicts(hDlg, pDlgData))
            {
                pDlgData->bOKPassed = TRUE;
                EndDialog(hDlg, IDOK);
            }

            return TRUE;

        case IDCANCEL:

            EndDialog(hDlg, IDCANCEL);
            return TRUE;

        case IDC_RESTOREDEFAULTS:

            //
            // Use default custom page size parameters
            //

            VFillDefaultCustomPageSizeData(
                    pDlgData->pUiData->ci.pRawData,
                    &pDlgData->csdata,
                    pDlgData->bMetric);

            VUpdateCustomSizeDlgFields(hDlg, pDlgData, FALSE);
            return TRUE;

        case IDC_CS_INCH:
        case IDC_CS_MM:
        case IDC_CS_POINT:

            //
            // Change display unit
            //

            pDlgData->iUnit = (iCmd == IDC_CS_INCH) ? CSUNIT_INCH :
                              (iCmd == IDC_CS_MM) ? CSUNIT_MM : CSUNIT_POINT;

            VUpdateCustomSizeDlgFields(hDlg, pDlgData, FALSE);
            return TRUE;

        case IDC_CS_WIDTH:
        case IDC_CS_HEIGHT:
        case IDC_CS_XOFFSET:
        case IDC_CS_YOFFSET:

            if (GET_WM_COMMAND_CMD(wParam, lParam) != EN_KILLFOCUS ||
                pDlgData->bSetText ||
                pDlgData->bOKPassed)
            {
                break;
            }

            if (! BGetWidthHeightOffsetVal(hDlg, pDlgData, iCmd, &dwVal) ||
                ! BChangeCustomSizeData(hDlg, pDlgData, iCmd, dwVal))
            {
                VUpdateCustomSizeDlgFields(hDlg, pDlgData, FALSE);
                SetFocus(GetDlgItem(hDlg, iCmd));
                SendDlgItemMessage(hDlg, iCmd, EM_SETSEL, 0, -1);
            }
            return TRUE;

        case IDC_CS_FEEDDIRECTION:

            if (GET_WM_COMMAND_CMD(wParam, lParam) != CBN_SELCHANGE)
                break;

            if (! BGetFeedDirectionSel(hDlg, pDlgData, iCmd, &dwVal) ||
                ! BChangeCustomSizeData(hDlg, pDlgData, iCmd, dwVal))
            {
                VUpdateCustomSizeDlgFields(hDlg, pDlgData, FALSE);
                SetFocus(GetDlgItem(hDlg, iCmd));
            }
            return TRUE;

        case IDC_CS_CUTSHEET:
        case IDC_CS_ROLLFED:

            BChangeCustomSizeData(hDlg, pDlgData, iCmd, 0);
            return TRUE;
        }
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:

        //
        // Sanity check
        //

        pDlgData = (PCUSTOMSIZEDLG) GetWindowLongPtr(hDlg, DWLP_USER);

        if (pDlgData == NULL ||
            pDlgData->pUiData->ci.pDriverInfo3->pHelpFile == NULL)
        {
            return FALSE;
        }

        if (uMsg == WM_HELP)
        {
            WinHelp(((LPHELPINFO) lParam)->hItemHandle,
                    pDlgData->pUiData->ci.pDriverInfo3->pHelpFile,
                    HELP_WM_HELP,
                    (ULONG_PTR)PSCustSizeHelpIDs);
        }
        else
        {
            WinHelp((HWND) wParam,
                    pDlgData->pUiData->ci.pDriverInfo3->pHelpFile,
                    HELP_CONTEXTMENU,
                    (ULONG_PTR)PSCustSizeHelpIDs);
        }

        return TRUE;
    }

    return FALSE;
}



BOOL
BDisplayPSCustomPageSizeDialog(
    PUIDATA pUiData
    )

/*++

Routine Description:

    Display PostScript custom page size dialog

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if user pressed OK, FALSE otherwise

--*/

{
    CUSTOMSIZEDLG   dlgdata;
    PPSDRVEXTRA     pdmPrivate;

    ZeroMemory(&dlgdata, sizeof(dlgdata));

    dlgdata.pUiData = pUiData;
    dlgdata.pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER((PINFOHEADER) pUiData->ci.pRawData);
    dlgdata.bMetric = IsMetricCountry();

    ASSERT(SUPPORT_CUSTOMSIZE(pUiData->ci.pUIInfo) &&
           SUPPORT_FULL_CUSTOMSIZE_FEATURES(pUiData->ci.pUIInfo, dlgdata.pPpdData));

    //
    // Make sure the custom page size devmode fields are validated
    //

    pdmPrivate = pUiData->ci.pdmPrivate;
    dlgdata.csdata = pdmPrivate->csdata;

    (VOID) BCheckCustomSizeDataConflicts(NULL, &dlgdata);

    pdmPrivate->csdata = dlgdata.csdata;

    //
    // Display the custom page size dialog.
    // If the user pressed OK, update the devmode fields again.
    //

    if (DialogBoxParam(ghInstance,
                       MAKEINTRESOURCE(IDD_PSCRIPT_CUSTOMSIZE),
                       pUiData->hDlg,
                       (DLGPROC) BCustomSizeDlgProc,
                       (LPARAM) &dlgdata) == IDOK)
    {
        pdmPrivate->csdata = dlgdata.csdata;
        return TRUE;
    }
    else
        return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\driverui\uni\osff.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    oldsfiff.h

Abstract:

    Data structures  used for reading the NT 4.0 font installer file format.
    Typically used by drivers during upgrade from NT 4.0 to 5.0.
    EnabldPDEV() time - at the time of writing!  Subject to change as the
    DDI/GDI change.

Environment:

    Windows NT Unidrv driver

Revision History:

    12/02/96 -ganeshp-
        Created

    dd-mm-yy -author-
        description

--*/

/*
 *   The following structure is returned from the FIOpenRead() function,
 * and contains the basic information needed to access the data in the
 * file once it is memory mapped.
 */

typedef  struct
{
    VOID  *hFile;               /* Font installer file, for downloaded part */
    BYTE  *pbBase;              /* Base address of data as mapped */
    void  *pvFix;               /* Fixed part at start of file */
    ULONG  ulFixSize;           /* Bytes in fixed data record */
    ULONG  ulVarOff;            /* File offset of data, relative file start */
    ULONG  ulVarSize;           /* Bytes in variable part */
}  FI_MEM;


/*
 *      Definitions used in the font file.  This is the file which holds
 *      information about cartridge and download fonts.  The file format
 *      is quite basic:  a header for verification; then an array of
 *      records,  each with a header.  These records contain FONTMAP
 *      information.  Cartridges have an array of these, one for each
 *      font.  Finally,  the tail of the file contains extra data, as
 *      required.  For download fonts,  this would be the download data.
 *
 */


/*
 *   The file header.   One of these is located at the beginning of the file.
 *  The ulVarData field is relative to the beginning of the file.  This
 *  makes it easier to regenerate the file when fonts are deleted.
 */

typedef  struct
{
    ULONG   ulID;               /* ID info - see value below */
    ULONG   ulVersion;          /* Version information - see below */
    ULONG   ulFixData;          /* Start of FF_REC_HEADER array */
    ULONG   ulFixSize;          /* Number of bytes in fixed section */
    ULONG   ulRecCount;         /* Number of records in fixed part */
    ULONG   ulVarData;          /* Start of variable data, rel to 0 */
    ULONG   ulVarSize;          /* Numbier of bytes in variable portion */
}  FF_HEADER;

/*
 *   Values for the ID and Version fields.
 */

#define FF_ID           0x6c666e66              /* "fnfl" - fOnTfIlE */
#define FF_VERSION      1                       /* Start at the bottom */

/*
 *   Each entry in the file starts with the following header.  Typically
 * there will be one of these for a softfont, and one per cartridge.
 * In the case of a cartridge,  there will be an array of these, within
 * the master entry.  Each sub-entry will be for one specific font.
 *
 *   Note that there is a dummy entry at the end.  This contains a 0
 * in the ulSize field - it is to mark the last one,  and makes it
 * easier to manipulate the file.
 */

typedef  struct
{
    ULONG   ulRID;              /* Record ID */
    ULONG   ulNextOff;          /* Offset from here to next record: 0 == end */
    ULONG   ulSize;             /* Bytes in this record */
    ULONG   ulVarOff;           /* Offset from start of variable data */
    ULONG   ulVarSize;          /* Number of bytes in variable part */
}  FF_REC_HEADER;

#define FR_ID           0x63657266              /* "frec" - fONT recORD */

/*
 *   Define the file extensions used.  The first is the name of the
 * font installer file;  the others are temporaries used during update
 * of the (possibly) existing file.
 */


#define  FILE_FONTS     L"fi_"           /* "Existing" single file */
#define  TFILE_FIX      L"fiX"           /* Fixed part of file */
#define  TFILE_VAR      L"fiV"           /* Variable (optional) portion */

#define FREEMODULE(hmodule) UnmapViewOfFile((PVOID) (hmodule))

/*
 * Upgrade related Function Declarations.
 */


INT
IFIOpenRead(
    FI_MEM  *pFIMem,
    PWSTR    pwstrName
    );
BOOL
BFINextRead(
    FI_MEM   *pFIMem
    );
INT
IFIRewind(
    FI_MEM   *pFIMem
    );
BOOL
BFICloseRead(
    FI_MEM  *pFIMem
    );

PVOID MapFile(
    PWSTR   pwstr
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\driverui\uni\fontinst.c ===
/****************************Module*Header******************************\
* Module Name: FONTINST.C
*
* Module Descripton:
*      Unidrv's built in font installer. Generously borrowed from Rasdd's
*      font installer code.
*
* Warnings:
*
* Issues:
*
* Created:  22 October 1997
* Author:   Srinivasan Chandrasekar    [srinivac]
*
* Copyright (c) 1996, 1997  Microsoft Corporation
\***********************************************************************/

#include "precomp.h"

//
// Global constants
//


static const DWORD FontInstallerHelpIDs[]=
{
    IDD_ADD,        IDH_SOFT_FONT_ADD_BTN,
    IDD_DELFONT,    IDH_SOFT_FONT_DELETE_BTN,
    IDD_FONTDIR,    IDH_SOFT_FONT_DIRECTORY,
    IDD_NEWFONTS,   IDH_SOFT_FONT_NEW_LIST,
    IDD_CURFONTS,   IDH_SOFT_FONT_INSTALLED_LIST,
    IDD_OPEN,       IDH_SOFT_FONT_OPEN_BTN,
    TID_FONTDIR,    IDH_SOFT_FONT_DIRECTORY,
    TID_NEWFONTS,   IDH_SOFT_FONT_NEW_LIST,
    TID_CURFONTS,   IDH_SOFT_FONT_INSTALLED_LIST,
    0, 0
};

//
// External functions
//

BOOL bSFontToFIData(FI_DATA *, HANDLE, BYTE *, DWORD);


//
// Structure used to remember state
//

typedef struct tagSFINFO
{
    HANDLE        hModule;              // Module handle of calling program
    HANDLE        hPrinter;             // Printer handle passed by caller
    HANDLE        hHeap;                // Handle to heap that we allocate memory from
    DWORD         dwFlags;              // Miscellaneous flags
    DWORD         cMaxFontNum;          // Maximum ID of of fonts already in the file
    DWORD         cFonts;               // Number of fonts added from font file
    DWORD         cCartridgeFonts;      // Number of cartridge fonts in file
    PFNTDAT       pFNTDATHead;          // Head of linked list of FNTDATs
    PFNTDAT       pFNTDATTail;          // The last of them
} SFINFO, *PSFINFO;


//
// Internal functions
//

void vFontInit(HWND, PSFINFO);
void vAddFont(HWND, PSFINFO);
void vDelFont(HWND, PSFINFO);
void vShowHelp(HWND, PSFINFO);
void vDelSel(HWND, int);
void vFontClean(PSFINFO);
BOOL bNewFontDir(HWND, PSFINFO);
BOOL bIsFileFont(PSFINFO, FI_DATA *, PWSTR);
BOOL bFontUpdate(HWND, PSFINFO);
BOOL InMultiSzSet(PWSTR, PWSTR);

/******************************************************************************
 *
 *                          FontInstProc
 *
 *  Function:
 *       Entry point for font installer dialog code.
 *
 *  Arguments:
 *       hWnd           - Handle to window
 *       usMsg          - Message code
 *       wParam         - wParam
 *       lParam         - lParam
 *
 *  Returns:
 *       TRUE on success, FALSE otherwise
 *
 ******************************************************************************/

INT_PTR CALLBACK
FontInstProc(
    HWND    hWnd,                   // The window of interest
    UINT    usMsg,                  // Message code
    WPARAM  wParam,                 // Depends on above, but message subcode
    LPARAM  lParam                  // Miscellaneous usage
    )
{
    POEMFONTINSTPARAM pfip;
    PSFINFO           pSFInfo;

    switch( usMsg )
    {

    case WM_INITDIALOG:

        //
        // Get the passed in parameter and set SFINFO as the window data
        //

        pfip =  (POEMFONTINSTPARAM)lParam;
        if (!(pSFInfo = HEAPALLOC(pfip->hHeap, sizeof(SFINFO))))
            return FALSE;

        memset(pSFInfo, 0, sizeof(SFINFO));
        pSFInfo->hModule = pfip->hModule;
        pSFInfo->hPrinter = pfip->hPrinter;
        pSFInfo->hHeap = pfip->hHeap;
        pSFInfo->dwFlags = pfip->dwFlags;

        SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)pSFInfo);

        //
        // Get list of installed fonts and show them
        //

        vFontInit(hWnd, pSFInfo);
        return TRUE;

    case WM_COMMAND:

        pSFInfo = (PSFINFO)GetWindowLongPtr(hWnd, GWLP_USERDATA);

        switch (LOWORD(wParam))
        {

        case IDD_OPEN:                  // User selects Open button
            return bNewFontDir(hWnd, pSFInfo);

        case IDD_NEWFONTS:              // New font list
            if( HIWORD( wParam ) != CBN_SELCHANGE )
                return FALSE;
            break;

        case IDD_CURFONTS:              // Existing font activity
            if (HIWORD (wParam) != CBN_SELCHANGE)
                return FALSE;
            break;

        case IDD_DELFONT:               // Delete the selected fonts
            vDelFont(hWnd, pSFInfo);

            return TRUE;

        case IDD_ADD:                   // Add the selected fonts
            vAddFont(hWnd, pSFInfo);
            return TRUE;

        case IDOK:

            //
            // Save the updated information
            //

            if (pSFInfo->dwFlags & FG_CANCHANGE)
                bFontUpdate(hWnd, pSFInfo);

            //
            // Fall thru
            //

        case IDCANCEL:
            EndDialog(hWnd, LOWORD(wParam) == IDOK ? TRUE : FALSE);
            return TRUE;

        default:
            return FALSE;
        }
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:
    {
       PDRIVER_INFO_3  pDriverInfo3;
       pSFInfo = (PSFINFO)GetWindowLongPtr(hWnd, GWLP_USERDATA);

        if (!pSFInfo ||
            !(pDriverInfo3 = MyGetPrinterDriver(pSFInfo->hPrinter, NULL, 3)))
        {
            return FALSE;
        }

        if (usMsg == WM_HELP)
        {
            WinHelp(((LPHELPINFO) lParam)->hItemHandle,
                    pDriverInfo3->pHelpFile,
                    HELP_WM_HELP,
                    (ULONG_PTR)FontInstallerHelpIDs);
        }
        else
        {
            WinHelp((HWND) wParam,
                    pDriverInfo3->pHelpFile,
                    HELP_CONTEXTMENU,
                    (ULONG_PTR)FontInstallerHelpIDs);
        }
    }
        break;

    case WM_DESTROY:

        pSFInfo = (PSFINFO)GetWindowLongPtr(hWnd, GWLP_USERDATA);

        vFontClean(pSFInfo);                 // Free what we consumed

        //
        // Free the SFINFO structure
        //

        HeapFree(pSFInfo->hHeap, 0, pSFInfo);

        return TRUE;

    default:
        return FALSE;                       // didn't process the message
    }

    return FALSE;
}


/******************************************************************************
 *
 *                          BInstallSoftFont
 *
 *  Function:
 *       This function installs a softfont for the given printer
 *
 *  Arguments:
 *       hPrinter       - Handle of printer to install fonts for
 *       hHeap          - Handle of heap to use to allocate memory
 *       pInBuf         - Pointer to PCL data buffer
 *       dwSize         - Size of buffer
 *
 *  Returns:
 *       TRUE on success, FALSE otherwise
 *
 ******************************************************************************/

BOOL APIENTRY
BInstallSoftFont(
    HANDLE      hPrinter,
    HANDLE      hHeap,
    PBYTE       pInBuf,
    DWORD       dwSize
    )
{
    FNTDAT   FntDat;
    HANDLE   hOldFile = NULL;
    HANDLE   hFontFile = NULL;
    DWORD    cFonts = 0, i;
    BOOL     bRc = FALSE;

    //
    // Parse the given PCL font
    //

    if (!bSFontToFIData(&FntDat.fid, hHeap, pInBuf, dwSize))
        return FALSE;

    FntDat.pVarData = pInBuf;
    FntDat.dwSize = dwSize;

    //
    // Open exisiting font file
    //

    if (hOldFile = FIOpenFontFile(hPrinter, hHeap))
    {
        cFonts = FIGetNumFonts(hOldFile);
    }

    //
    // Create a new font file
    //

    hFontFile = FICreateFontFile(hPrinter, hHeap, cFonts+1);
    if (!hFontFile)
    {
        WARNING(("Error creating a new font file\n"));
        goto EndInstallSoftFont;
    }

    //
    // Seek past header and font directory in new file
    //

    FIAlignedSeek(hFontFile, sizeof(UFF_FILEHEADER) + (cFonts + 1) * sizeof(UFF_FONTDIRECTORY));

    for (i=0; i<cFonts; i++)
    {
        if (!FICopyFontRecord(hFontFile, hOldFile, i, i))
        {
            WARNING(("Error copying font record %d\n", i));
            goto EndInstallSoftFont;
        }
    }

    //
    // Add new font record
    //

    if (!FIAddFontRecord(hFontFile, cFonts, &FntDat))
    {
        WARNING(("Error adding new font record\n"));
        goto EndInstallSoftFont;
    }

    //
    // Write out the font header and directory
    //

    if (!FIWriteFileHeader(hFontFile) ||
        !FIWriteFontDirectory(hFontFile))
    {
        WARNING(("Error writing font file header/directory of font file\n"))
        goto EndInstallSoftFont;
    }

    bRc = TRUE;

EndInstallSoftFont:

    (VOID)FIUpdateFontFile(hOldFile, hFontFile, bRc);

    return bRc;
}


/******************************************************************************
 *
 *                          BUpdateExternalFonts
 *
 *  Function:
 *       This function is called by the driver UI to update the font installer
 *       file if one or more cartridges are added or removed by the user.
 *
 *  Arguments:
 *       hPrinter        - Handle of printer
 *       hHeap           - Handle of heap to use to allocate memory
 *       pwstrCartridges - Pointer to MULTI_SZ string of cartridges currently
 *                         installed on the printer
 *
 *  Returns:
 *       TRUE on success, FALSE otherwise
 *
 ******************************************************************************/

BOOL APIENTRY
BUpdateExternalFonts(
    HANDLE      hPrinter,
    HANDLE      hHeap,
    PWSTR       pwstrCartridges
    )
{
    HANDLE hOldFile  = NULL;
    HANDLE hFontFile = NULL;
    HANDLE hCartFile = NULL;
    DWORD  cFonts = 0;
    DWORD  cCartFonts = 0;
    DWORD  cNewFonts = 0;
    DWORD  i, j;
    PWSTR  pwstrName;
    BOOL   bRc = FALSE;

    //
    // Open exisiting font file
    //

    if ((hOldFile = FIOpenFontFile(hPrinter, hHeap)) == NULL)
    {
        WARNING(("Error opening font file\n"));
        return FALSE;
    }

    cFonts = FIGetNumFonts(hOldFile);

    //
    // Find out number of non cartridge fonts
    //

    for (i=0; i<cFonts; i++)
    {
        if (FIGetFontCartridgeName(hOldFile, i) == NULL)
            cNewFonts++;
    }

    //
    // Open font cartridge file
    //

    if ((hCartFile = FIOpenCartridgeFile(hPrinter, hHeap)) == NULL &&
        pwstrCartridges != NULL)
    {
        WARNING(("Error opening cartridge file\n"));
        goto EndUpdateExternalFonts;
    }

    if (hCartFile)
    {
        //
        // Find number of fonts belonging to these cartridges
        //

        cCartFonts = FIGetNumFonts(hCartFile);

        for (i=0; i<cCartFonts; i++)
        {
            pwstrName = FIGetFontCartridgeName(hCartFile, i);
            ASSERT(pwstrName != NULL);

            if (InMultiSzSet(pwstrCartridges, pwstrName))
                cNewFonts++;
        }
    }

    //
    // Create a new font file
    //

    hFontFile = FICreateFontFile(hPrinter, hHeap, cNewFonts);
    if (!hFontFile)
    {
        WARNING(("Error creating a new font file\n"));
        goto EndUpdateExternalFonts;
    }

    //
    // Seek past header and font directory in new file
    //

    FIAlignedSeek(hFontFile, sizeof(UFF_FILEHEADER) + cNewFonts * sizeof(UFF_FONTDIRECTORY));

    //
    // Copy over all fonts from old font file that don't belong to any
    // cartridges
    //

    for (i=0, j=0; i<cFonts; i++)
    {
        if (FIGetFontCartridgeName(hOldFile, i) != NULL)
            continue;

        if (!FICopyFontRecord(hFontFile, hOldFile, j, i))
        {
            WARNING(("Error copying font record %d\n", i));
            goto EndUpdateExternalFonts;
        }
        j++;
    }


    //
    // NOTE: Do not change j - we continue to use it below
    //

    //
    // Copy over cartridge fonts that are curently selected
    //

    for (i=0; i<cCartFonts; i++)
    {
        pwstrName = FIGetFontCartridgeName(hCartFile, i);

        if (!InMultiSzSet(pwstrCartridges, pwstrName))
            continue;

        if (!FICopyFontRecord(hFontFile, hCartFile, j, i))
        {
            WARNING(("Error copying font record %d\n", i));
            goto EndUpdateExternalFonts;
        }
        j++;
    }

    //
    // Write out the font header and directory
    //

    if (!FIWriteFileHeader(hFontFile) ||
        !FIWriteFontDirectory(hFontFile))
    {
        WARNING(("Error writing font file header/directory of font file\n"))
        goto EndUpdateExternalFonts;
    }

    bRc = TRUE;

EndUpdateExternalFonts:

    (VOID)FIUpdateFontFile(hOldFile, hFontFile, bRc);

    (VOID)FICloseFontFile(hCartFile);

    return bRc;
}


/******************************************************************************
 *
 *                          BGetFontCartridgeFile
 *
 *  Function:
 *       This function is called by the driver UI to copy the font cartridge
 *       file from the server to the client
 *
 *  Arguments:
 *       hPrinter        - Handle of printer
 *       hHeap           - Handle of heap to use to allocate memory
 *
 *  Returns:
 *       TRUE on success, FALSE otherwise
 *
 ******************************************************************************/

BOOL
BGetFontCartridgeFile(
    HANDLE hPrinter,
    HANDLE hHeap
    )
{
    CACHEDFILE      CachedFile;
    PPRINTER_INFO_2 ppi2 = NULL;
    DWORD          dwSize;
    BOOL           bRc = FALSE;

    GetPrinterW(hPrinter, 2, NULL, 0, &dwSize);

    if ((dwSize == 0) ||
        !(ppi2 = HeapAlloc(hHeap, HEAP_ZERO_MEMORY, dwSize)) ||
        !(GetPrinterW(hPrinter, 2, (PBYTE)ppi2, dwSize, &dwSize)))
    {
        goto EndGetFCF;
    }

    if (!(ppi2->Attributes & PRINTER_ATTRIBUTE_LOCAL))
    {

        if (! _BPrepareToCopyCachedFile(hPrinter, &CachedFile, REGVAL_CARTRIDGEFILENAME) ||
            ! _BCopyCachedFile(NULL, &CachedFile))
            bRc = FALSE;
        else
            bRc = TRUE;

        _VDisposeCachedFileInfo(&CachedFile);

        goto EndGetFCF;
    }

    bRc = TRUE;

EndGetFCF:

    if (ppi2)
        HeapFree(hHeap, 0, ppi2);

    return bRc;
}

/******************************************************************************
 *                      Internal helper functions
 ******************************************************************************/

/******************************************************************************
 *
 *                             vShowHelp
 *
 *  Function:
 *      Get help information for External Font dialog
 *
 *  Arguments:
 *       hWnd           - Handle to window
 *       pSFInfo        - Pointer to structure that holds state information
 *
 *  Returns:
 *       Nothing
 *
 ******************************************************************************/
void
vShowHelp(
    HWND     hWnd,
    PSFINFO  pSFInfo
    )
{
    PDRIVER_INFO_3  pDriverInfo3;

    if (pDriverInfo3 = MyGetPrinterDriver(pSFInfo->hPrinter, NULL, 3))
    {
        WinHelp(hWnd,
                pDriverInfo3->pHelpFile,
                HELP_CONTEXT,
                HELP_INDEX_SOFTFONT_DIALOG);

        MemFree(pDriverInfo3);
    }

}

/******************************************************************************
 *
 *                             vFontInit
 *
 *  Function:
 *      Called to initialise the dialog before it is displayed to the
 *      user.  Requires making decisions about buttons based on any
 *      existing fonts.
 *
 *  Arguments:
 *       hWnd           - Handle to window
 *       pSFInfo        - Pointer to structure that holds state information
 *
 *  Returns:
 *       Nothing
 *
 ******************************************************************************/

void
vFontInit(
    HWND     hWnd,
    PSFINFO  pSFInfo
    )
{
    HANDLE    hFontFile;        // Handle to font file
    INT       iNum = 0;         // Number of entries
    INT       i;                // Loop parameter
    DWORD     cFonts = 0;       // Number of fonts

    //
    // If there is a font file associated with this printer, open it and
    // read the fonts
    //

    if (hFontFile = FIOpenFontFile(pSFInfo->hPrinter, pSFInfo->hHeap))
    {
        iNum = FIGetNumFonts(hFontFile);
    }

    for (i=0; i<iNum; i++)
    {
        LONG_PTR  iFont;
        PWSTR    pwstr;            // Font display name

        //
        // We do not display fonts that belong to font cartridges
        //

        pwstr = FIGetFontCartridgeName(hFontFile, i);
        if (pwstr)
        {
            pSFInfo->cCartridgeFonts++;
            continue;
        }

        pwstr = FIGetFontName(hFontFile, i);

        if (!pwstr)
            continue;           // Should not happen!

        //
        // Add font name to list of installed fonts
        //

        iFont = SendDlgItemMessage(hWnd, IDD_CURFONTS, LB_ADDSTRING, 0, (LPARAM)pwstr);

        //
        // Set the font number
        //

        SendDlgItemMessage(hWnd, IDD_CURFONTS, LB_SETITEMDATA, iFont, (LPARAM)i);

        cFonts++;               // Increment number of fonts
    }

    pSFInfo->cMaxFontNum = (DWORD)i;  // For separating new/old

    if (cFonts > 0)
    {
        //
        //  There are existing fonts, so we can enable the DELETE button
        //

        pSFInfo->cFonts = cFonts;         // Number of fonts added

        EnableWindow(GetDlgItem(hWnd, IDD_DELFONT), TRUE);
    }

    if (hFontFile)
    {
        FICloseFontFile(hFontFile);
    }

    if (pSFInfo->dwFlags & FG_CANCHANGE)
    {
        //
        // User has access to change stuff,  so place a default directory
        //

        SetDlgItemText(hWnd, IDD_FONTDIR, L"A:\\");
    }
    else
    {
        //
        // No permission to change things, so disable most of the dialog
        //

        EnableWindow( GetDlgItem( hWnd, IDD_FONTDIR ), FALSE );
        EnableWindow( GetDlgItem( hWnd, TID_FONTDIR ), FALSE );
        EnableWindow( GetDlgItem( hWnd, IDD_OPEN ), FALSE );
        EnableWindow( GetDlgItem( hWnd, IDD_ADD ), FALSE );
        EnableWindow( GetDlgItem( hWnd, IDD_DELFONT ), FALSE );
        EnableWindow( GetDlgItem( hWnd, IDD_NEWFONTS ), FALSE );
        EnableWindow( GetDlgItem( hWnd, TID_NEWFONTS ), FALSE );
    }

    return;
}


/******************************************************************************
 *
 *                             bNewFontDir
 *
 *  Function:
 *      Processes a new font directory. This means opening the
 *      directory and passing the file names to the screening function.
 *
 *  Arguments:
 *       hWnd           - Handle to window
 *       pSFInfo        - Pointer to structure that holds state information
 *
 *  Returns:
 *       TRUE on success, FALSE otherwise
 *
 ******************************************************************************/

BOOL
bNewFontDir(
    HWND    hWnd,
    PSFINFO pSFInfo
    )
{
    WIN32_FIND_DATA  ffd;               // Data about the file we find
    UINT             iErrMode;          // For manipulating error msgs
    INT              cOKFiles;          // Count the number of font files found
    HANDLE           hDir;              // FindFirstFile ... scanning
    HCURSOR          hCursor;           // Switch to wait symbol while reading
    INT              cDN;               // Length of directory name
    WCHAR            wchDirNm[MAX_PATH];// Font directory + file name

    //
    // GetDlgItemText's 4th parameter is the max number of characters, not bytes.
    //

    cDN = GetDlgItemTextW(hWnd, IDD_FONTDIR, wchDirNm, sizeof(wchDirNm) / sizeof(WCHAR));

    //
    //  Check to see if the name will be too long: the 5 below is the
    //  number of additional characters to add to the directory name:
    //  namely, L"\\*.*".
    //

    if (cDN >= (sizeof(wchDirNm) - 5))
    {
        IDisplayErrorMessageBox(hWnd,
                                MB_OK | MB_ICONERROR,
                                IDS_FONTINST_FONTINSTALLER,
                                IDS_FONTINST_DIRECTORYTOOLONG);
        return  FALSE;
    }

    if (cDN > 0)
    {

        if (wchDirNm[cDN - 1] != (WCHAR)'\\' )
        {
            wcscat(wchDirNm, L"\\");
            cDN++;                      // One more now!
        }

        wcscat(wchDirNm, L"*.*");

        //
        // Save error mode, and enable file open error box.
        //

        iErrMode = SetErrorMode(0);
        SetErrorMode(iErrMode & ~SEM_NOOPENFILEERRORBOX);

        hDir = FindFirstFile(wchDirNm, &ffd);

        SetErrorMode(iErrMode);                // Restore old mode

        cOKFiles = 0;

        if (hDir == INVALID_HANDLE_VALUE)
        {
            //
            //   Put up a dialog box to tell the user "no such directory".
            //

            if (GetLastError() == ERROR_PATH_NOT_FOUND)
            {
               IDisplayErrorMessageBox(hWnd,
                                       MB_OK | MB_ICONERROR,
                                       IDS_FONTINST_FONTINSTALLER,
                                       IDS_FONTINST_INVALIDDIR);
 
            }

            return  FALSE;
        }

        //
        //   Switch to the hourglass cursor while reading,  since the data
        // is probably coming from a SLOW floppy.  Also stop redrawing,
        // since the list box looks ugly during this time.
        //

        hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
        SendMessage(hWnd, WM_SETREDRAW, FALSE, 0L);

        do
        {
            //
            // Generate a file name which is passed to a function to determine
            // whether this file is understood by us. This function returns
            // FALSE if it does not understand the file;  otherwise it returns
            // TRUE, and also a string to display.  We display the string,
            // and remember the file name for future use.
            //

            LONG_PTR  iFont;             // List Box index
            FI_DATA  FD;                // Filled in by bIsFileFont
            PFNTDAT  pFNTDAT;           // For remembering it all

            wcscpy(&wchDirNm[cDN], ffd.cFileName);

            if (bIsFileFont(pSFInfo, &FD, wchDirNm))
            {
                //
                // Part of the data returned is a descriptive string
                // for the font.  We need to display this to the user.
                // We also allocate a structure we use to keep track of
                // all the data we have.  This includes the file name
                // that we have!
                //

                pFNTDAT = (PFNTDAT)HEAPALLOC(pSFInfo->hHeap, sizeof(FNTDAT));
                if (pFNTDAT == NULL)
                {
                    break;
                }

                if (pSFInfo->pFNTDATHead == NULL)
                {
                    //
                    // Starting a chain,  so remember the first.
                    // AND also enable the Add button in the dialog,
                    // now that we have something to add.
                    //

                    pSFInfo->pFNTDATHead = pFNTDAT;
                    EnableWindow(GetDlgItem(hWnd, IDD_ADD), TRUE);
                }

                if (pSFInfo->pFNTDATTail)
                    pSFInfo->pFNTDATTail->pNext = pFNTDAT;

                pSFInfo->pFNTDATTail = pFNTDAT;

                pFNTDAT->pNext = 0;
                pFNTDAT->pVarData = NULL;
                pFNTDAT->dwSize = 0;
                pFNTDAT->fid = FD;
                wcsncpy(pFNTDAT->wchFileName, wchDirNm, cDN);
                wcscat(pFNTDAT->wchFileName, ffd.cFileName);

                //
                // Display this message, and tag it with the address
                // of the data area we just allocated.
                //

                iFont = SendDlgItemMessage(hWnd,
                                           IDD_NEWFONTS,
                                           LB_ADDSTRING,
                                           0,
                                           (LPARAM)FD.dsIdentStr.pvData);

                SendDlgItemMessage(hWnd,
                                   IDD_NEWFONTS,
                                   LB_SETITEMDATA,
                                   iFont,
                                   (LPARAM)pFNTDAT);

                ++cOKFiles;         // One more to the list
            }

        } while (FindNextFile(hDir, &ffd));

        //
        // Now can redraw the box & return to the previous cursor
        //

        SendMessage(hWnd, WM_SETREDRAW, TRUE, 0L);
        InvalidateRect(hWnd, NULL, TRUE);

        SetCursor(hCursor);

        //
        //   Finished with the directory now, so close it up
        //

        FindClose(hDir);

        if (cOKFiles == 0)
        {
            //
            // Didn't find any files, so tell the user
            //
            IDisplayErrorMessageBox(hWnd,
                                    MB_OK | MB_ICONERROR,
                                    IDS_FONTINST_FONTINSTALLER,
                                    IDS_FONTINST_NOFONTFOUND);
        }
    }
    else
    {
        //
        // Empty font directory name!
        //

        IDisplayErrorMessageBox(hWnd,
                                MB_OK | MB_ICONERROR,
                                IDS_FONTINST_FONTINSTALLER,
                                IDS_FONTINST_NODIRNAME);
    }

    return  TRUE;
}


/******************************************************************************
 *
 *                             vAddFont
 *
 *  Function:
 *      Called to move the new selected fonts to the font list
 *
 *  Arguments:
 *       hWnd           - Handle to window
 *       pSFInfo        - Pointer to structure that holds state information
 *
 *  Returns:
 *       Nothing
 *
 ******************************************************************************/

void
vAddFont(
    HWND    hWnd,
    PSFINFO pSFInfo
    )
{
    LONG_PTR  cSel;                 // Number of entries selected
    LONG_PTR  *piSel;                // List of selected fonts
    INT      iI;                   // Loop index

    //
    // Find the selected items in the new font box and move them to the
    // Installed box.  Also set up the linked list of stuff to pass
    // to the common font installer code should the user decide to
    // update the list.
    //

    cSel = SendDlgItemMessage(hWnd, IDD_NEWFONTS, LB_GETSELCOUNT, 0, 0);

    piSel = (LONG_PTR *)HEAPALLOC(pSFInfo->hHeap, (DWORD)(cSel * sizeof(INT)));

    if (piSel == NULL )
    {
        IDisplayErrorMessageBox(hWnd,
                                MB_OK | MB_ICONERROR,
                                IDS_FONTINST_FONTINSTALLER,
                                IDS_FONTINST_OUTOFMEMORY);
 
        return;
    }

    //
    // Disable updates to reduce screen flicker
    //

    SendMessage(hWnd, WM_SETREDRAW, FALSE, 0L);

    SendDlgItemMessage(hWnd, IDD_NEWFONTS, LB_GETSELITEMS, cSel, (LPARAM)piSel);

    for (iI=0; iI<cSel; ++iI)
    {
        LONG_PTR iFont;         // Index in list box
        FNTDAT  *pFontData;     // Significant font info

        pFontData = (FNTDAT *)SendDlgItemMessage(hWnd,
                                                 IDD_NEWFONTS,
                                                 LB_GETITEMDATA,
                                                 piSel[iI],
                                                 0L);

        if ((LONG_PTR)pFontData == LB_ERR )
            continue;           // SHOULD NOT HAPPEN


        iFont = SendDlgItemMessage(hWnd,
                                   IDD_CURFONTS,
                                   LB_ADDSTRING,
                                   0,
                                   (LPARAM)pFontData->fid.dsIdentStr.pvData);

        SendDlgItemMessage(hWnd, IDD_CURFONTS, LB_SETITEMDATA, iFont, (LPARAM)pFontData);
    }

    if (iI > 0)
        EnableWindow(GetDlgItem(hWnd, IDD_DELFONT), TRUE);

    //
    // Can now delete the selected items: we no longer need them
    //

    vDelSel(hWnd, IDD_NEWFONTS);


    //
    // Re enable updates
    //

    SendMessage(hWnd, WM_SETREDRAW, TRUE, 0L);
    InvalidateRect(hWnd, NULL, TRUE);

    HeapFree(pSFInfo->hHeap, 0, (LPSTR)piSel);

    return;
}


/******************************************************************************
 *
 *                             vDelFont
 *
 *  Function:
 *      Called when the Delete button is clicked.  We discover which
 *      items in the Installed fonts list box are selected, and mark these
 *      for deletion. We do NOT delete them, simply remove them from
 *      display and mark for deletion later.
 *
 *  Arguments:
 *       hWnd           - Handle to window
 *       pSFInfo        - Pointer to structure that holds state information
 *
 *  Returns:
 *       Nothing
 *
 ******************************************************************************/

void
vDelFont(
    HWND    hWnd,
    PSFINFO pSFInfo
    )
{
    INT     iI;                 // Loop index
    LONG_PTR cSel;               // Number of selected items
    LONG_PTR *piSel;              // From heap, contains selected items list

    //
    //  Obtain the list of selected items in the Installed list box.
    //  Then place any existing fonts into the to delete list,  and
    //  move any new fonts back into the New fonts list.
    //

    cSel = SendDlgItemMessage(hWnd, IDD_CURFONTS, LB_GETSELCOUNT, 0, 0);

    piSel = (LONG_PTR *)HEAPALLOC(pSFInfo->hHeap, (DWORD)(cSel * sizeof(INT)));

    if (piSel == NULL)
    {
        IDisplayErrorMessageBox(hWnd,
                                MB_OK | MB_ICONERROR,
                                IDS_FONTINST_FONTINSTALLER,
                                IDS_FONTINST_OUTOFMEMORY);
        return;
    }

    //
    // Disable updates to reduce screen flicker
    //

    SendMessage(hWnd, WM_SETREDRAW, FALSE, 0L);

    SendDlgItemMessage(hWnd, IDD_CURFONTS, LB_GETSELITEMS, cSel, (LPARAM)piSel);

    for (iI=0; iI<cSel; ++iI)
    {
        LONG_PTR iVal;

        iVal = SendDlgItemMessage(hWnd, IDD_CURFONTS, LB_GETITEMDATA, piSel[iI], 0);

        if (iVal == LB_ERR)
            continue;                   // SHOULD NOT HAPPEN

        if (iVal >= (LONG_PTR)pSFInfo->cMaxFontNum)
        {
            //
            //  We are deleting a font that we just installed, so add it back
            // into the new fonts, so that it remains visible.
            //

            LONG_PTR iFont;               // New list box index
            WCHAR   awch[256];           // ???

            if (SendDlgItemMessage(hWnd, IDD_CURFONTS, LB_GETTEXT,
                                   piSel[iI], (LPARAM)awch) != LB_ERR)
            {
                //
                // Have the text and value, so back into the new list
                //

                iFont = SendDlgItemMessage(hWnd, IDD_NEWFONTS, LB_ADDSTRING, 0, (LPARAM)awch);

                SendDlgItemMessage(hWnd, IDD_NEWFONTS, LB_SETITEMDATA, iFont, (LPARAM)iVal);
            }
        }
    }

    //
    // Now delete them from the list
    //

    vDelSel(hWnd, IDD_CURFONTS);


    //
    // Disable the delete button if there are no fonts.
    //

    if (SendDlgItemMessage( hWnd, IDD_CURFONTS, LB_GETCOUNT, 0, 0L) == 0)
        EnableWindow(GetDlgItem(hWnd, IDD_DELFONT), FALSE);

    //
    /// Re-enable updates
    //

    SendMessage(hWnd, WM_SETREDRAW, TRUE, 0L);
    InvalidateRect(hWnd, NULL, TRUE);


    HeapFree(pSFInfo->hHeap, 0, (LPSTR)piSel);

    return;
}


/******************************************************************************
 *
 *                             vDelSel
 *
 *  Function:
 *      Delete all selected items in the specified list box.
 *
 *  Arguments:
 *       hWnd           - Handle to window
 *       iBox           - Identifies the list box
 *
 *  Returns:
 *       Nothing
 *
 ******************************************************************************/

void
vDelSel(
    HWND    hWnd,
    INT     iBox
    )
{
    INT   iSel;

    //
    //  Find how many items are selected, then retrieve their index
    //  one at a time until they are all deleted. This is needed because
    //  otherwise we delete the wrong ones! This is because the data is
    //  presented to us as an array of indices, and these are wrong when
    //  we start deleting them.
    //

    while (SendDlgItemMessage(hWnd, iBox, LB_GETSELITEMS, 1, (LPARAM)&iSel) > 0)
        SendDlgItemMessage(hWnd, iBox, LB_DELETESTRING, iSel, 0L);

    return;
}

/******************************************************************************
 *
 *                             vFontClean
 *
 *  Function:
 *      Clean up all the dangling bits & pieces we have left around.
 *
 *  Arguments:
 *       pSFInfo        - Pointer to structure that holds state information
 *
 *  Returns:
 *       Nothing
 *
 ******************************************************************************/

void
vFontClean(
    PSFINFO pSFInfo
    )
{
    //
    // Look at the storage addresses we allocate.  If non zero,
    // free them up and set to NULL to prevent a second freeing.
    //

    if (pSFInfo->pFNTDATHead)
    {
        //
        //  The details of each new font we found. These form a linked
        //  list, so we need to traverse the chain and free every entry.
        //

        FNTDAT *pFD0, *pFD1;

        for (pFD0 = pSFInfo->pFNTDATHead; pFD0; pFD0 = pFD1)
        {
            pFD1 = pFD0->pNext;                 // Next one, perhaps

            HeapFree(pSFInfo->hHeap, 0, (LPSTR)pFD0);
        }

        pSFInfo->pFNTDATHead = NULL;
        pSFInfo->pFNTDATTail = NULL;
    }

    return;
}


/******************************************************************************
 *
 *                             bIsFileFont
 *
 *  Function:
 *      Called with a file name and returns TRUE if this file is a font
 *      format we understand. Also returns a FONT_DATA structure.
 *
 *  Arguments:
 *       pSFInfo        - Pointer to structure that holds state information
 *       pFIDat         - Information about the font to fill if successful
 *       pwstr          - Name of file to check
 *
 *  Returns:
 *       TRUE on success, FALSE otherwise
 *
 ******************************************************************************/

BOOL
bIsFileFont(
    PSFINFO    pSFInfo,
    FI_DATA   *pFIDat,
    PWSTR      pwstr
    )
{
    HANDLE   hFile;
    BYTE    *pbFile;
    DWORD    dwSize;
    BOOL     bRet;

    hFile = CreateFile(pwstr, GENERIC_READ, FILE_SHARE_READ,
                       NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

    if (!MapFileIntoMemory(pwstr, &pbFile, NULL))
    {
        CloseHandle(hFile);
        return FALSE;
    }

    //
    // Want to find out how big the file is,  so now seek to the
    // end,  and see what address comes back!  There appears to be
    // no other way to do this.
    //

    dwSize = SetFilePointer(hFile, 0L, NULL, FILE_END);

    bRet = bSFontToFIData(pFIDat, pSFInfo->hHeap, pbFile, dwSize);

    UnmapFileFromMemory((HFILEMAP)pbFile);
    CloseHandle(hFile);

    return bRet;
}


/******************************************************************************
 *
 *                             bFontUpdate
 *
 *  Function:
 *      Update the font installer common file.  Called when the user
 *      has clicked on the OK button.
 *
 *  Arguments:
 *       hWnd           - Handle to window
 *       pSFInfo        - Pointer to structure that holds state information
 *
 *  Returns:
 *       TRUE on success, FALSE otherwise
 *
 ******************************************************************************/

BOOL
bFontUpdate(
    HWND    hWnd,
    PSFINFO pSFInfo
    )
{
    HANDLE    hOldFile = NULL;     // Handle to old font file
    HANDLE    hFontFile = NULL;    // Handle to new font file
    DWORD     cFonts;              // Final number of fonts selected
    DWORD     dwIndex;             // Index into current font file
    LRESULT   lrOldIndex;          // Index into old font file
    DWORD     i;                   // Loop index
    BOOL      bRc = FALSE;         // Return code

    //
    // Initialize some variables
    //

    hOldFile = hFontFile = NULL;

    //
    // Get number of fonts that have finally been added
    //

    cFonts = (DWORD)SendDlgItemMessage(hWnd, IDD_CURFONTS, LB_GETCOUNT, 0, 0);

    //
    // If no fonts have been added or deleted, we can skip doing anything.
    // Check for this case
    //

    if (cFonts == pSFInfo->cFonts)
    {
        BOOL   bNoChange = TRUE;

        for (i=0; i<cFonts; i++)
        {
            lrOldIndex = SendDlgItemMessage(hWnd, IDD_CURFONTS, LB_GETITEMDATA, i, 0);
            if (lrOldIndex >= (LONG)(pSFInfo->cMaxFontNum))
            {
                bNoChange = FALSE;
                break;
            }
        }

        if (bNoChange)
        {
            return TRUE;
        }
    }

    //
    // Open existing font file
    //

    hOldFile = FIOpenFontFile(pSFInfo->hPrinter, pSFInfo->hHeap);
    if (!hOldFile && pSFInfo->cMaxFontNum > 0)
    {
        WARNING(("Unable to open existing font file\n"));
        goto EndFontUpdate;
    }

    //
    // Create a new font file
    //

    hFontFile = FICreateFontFile(pSFInfo->hPrinter, pSFInfo->hHeap, cFonts+pSFInfo->cCartridgeFonts);
    if (!hFontFile)
    {
        WARNING(("Error creating new font file\n"));
        goto EndFontUpdate;
    }

    //
    // Seek past header and font directory in new file
    //

    FIAlignedSeek(hFontFile, sizeof(UFF_FILEHEADER) + (cFonts+pSFInfo->cCartridgeFonts) * sizeof(UFF_FONTDIRECTORY));

    for (dwIndex=0; dwIndex<cFonts; dwIndex++)
    {
        lrOldIndex = SendDlgItemMessage(hWnd, IDD_CURFONTS, LB_GETITEMDATA, dwIndex, 0);

        if (lrOldIndex < (LONG)(pSFInfo->cMaxFontNum))
        {
            //
            // This is an old font from existing font file
            //

            if (!FICopyFontRecord(hFontFile, hOldFile, dwIndex, (DWORD)lrOldIndex))
            {
                WARNING(("Error copying font record\n"));
                goto EndFontUpdate;
            }
        }
        else
        {
            //
            // This is a font being newly added
            //

            if (!FIAddFontRecord(hFontFile, dwIndex, (PFNTDAT)lrOldIndex))
            {
                WARNING(("Error creating new font record\n"));
                goto EndFontUpdate;
            }
        }
    }

    //
    // NOTE: Do not change dwIndex - we continue to use it below
    //

    if (pSFInfo->cCartridgeFonts > 0)
    {
        //
        // Copy cartridge fonts to new font file
        //

        cFonts = FIGetNumFonts(hOldFile);
        for (i=0; i<cFonts; i++)
        {
            PWSTR pwstr = FIGetFontCartridgeName(hOldFile, i);
            if (pwstr)
            {
                if (!FICopyFontRecord(hFontFile, hOldFile, dwIndex, i))
                {
                    WARNING(("Error copyinf font record\n"));
                    goto EndFontUpdate;
                }
                dwIndex++;
            }
        }
    }

    //
    // Write out the font header and directory
    //

    if (!FIWriteFileHeader(hFontFile) ||
        !FIWriteFontDirectory(hFontFile))
    {
        WARNING(("Error writing font header/directory of font file\n"))
        goto EndFontUpdate;
    }

    bRc = TRUE;

EndFontUpdate:

    (VOID)FIUpdateFontFile(hOldFile, hFontFile, bRc);

    return bRc;
}

BOOL
InMultiSzSet(
    PWSTR pwstrMultiSz,
    PWSTR pwstr
    )
{
    while (*pwstrMultiSz)
    {
        if (wcscmp(pwstrMultiSz, pwstr) == 0)
        {
            return TRUE;
        }

        pwstrMultiSz += wcslen(pwstrMultiSz) + 1;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\driverui\ps\psoemhlp.c ===
/*++

Copyright (c) 2000  Microsoft Corporation
All rights reserved.

Module Name:

    psoemhlp.c

Abstract:

    PostScript helper functions for OEM UI plugins

        HSetOptions

Author:

    Feng Yue (fengy)

    8/24/2000 fengy Completed with support of both PPD and driver features.
    7/21/2000 fengy Created it with function framework.

--*/

#include "precomp.h"

//
// PS driver's helper functions for OEM UI plugins
//


/*++

Routine Name:

    VUpdatePSF_EMFFeatures

Routine Description:

    change EMF features' settings to make sure they are in sync with each other

Arguments:

    pci - pointer to driver's COMMONINFO structure
    dwChangedItemID - ID to indicate which item has been changed

Return Value:

    None

Last Error:

    None

--*/
VOID
VUpdatePSF_EMFFeatures(
    IN  PCOMMONINFO  pci,
    IN  DWORD        dwChangedItemID
    )
{
    PDEVMODE    pdm = pci->pdm;
    PPSDRVEXTRA pdmPrivate = pci->pdmPrivate;

    //
    // (refer to VUpdateEmfFeatureItems and VUnpackDocumentPropertiesItems)
    //

    if (!((PUIDATA)pci)->bEMFSpooling)
    {
        ERR(("VUpdatePSF_EMFFeatures: spooler EMF disabled\n"));
        return;
    }

    if (dwChangedItemID != METASPOOL_ITEM)
    {
        if (!ISSET_MFSPOOL_FLAG(pdmPrivate))
        {
            //
            // need to turn driver EMF on to support the EMF feature
            //

            if (dwChangedItemID == NUP_ITEM)
            {
                //
                // booklet
                //

                if (NUPOPTION(pdmPrivate) == BOOKLET_UP)
                {
                    TERSE(("EMF turned on for BOOKLET_UP\n"));
                    SET_MFSPOOL_FLAG(pdmPrivate);
                }
            }
            else if (dwChangedItemID == REVPRINT_ITEM)
            {
                BOOL bReversed = BGetPageOrderFlag(pci);

                //
                // reverse printing
                //

                if ((!REVPRINTOPTION(pdmPrivate) && bReversed) ||
                    (REVPRINTOPTION(pdmPrivate) && !bReversed))
                {
                    TERSE(("EMF turned on for reverse order\n"));
                    SET_MFSPOOL_FLAG(pdmPrivate);
                }
            }
            else if (dwChangedItemID == COPIES_COLLATE_ITEM)
            {
                //
                // collate
                //

                if ((pdm->dmFields & DM_COLLATE) &&
                    (pdm->dmCollate == DMCOLLATE_TRUE) &&
                    !PRINTER_SUPPORTS_COLLATE(pci))
                {
                    TERSE(("EMF turned on for collate\n"));
                    SET_MFSPOOL_FLAG(pdmPrivate);
                }
            }
            else
            {
                RIP(("unknown dwChangedItemID: %d\n", dwChangedItemID));
            }
        }
    }
    else
    {
        //
        // driver EMF option has being changed
        //

        if (!ISSET_MFSPOOL_FLAG(pdmPrivate))
        {
            BOOL bReversed = BGetPageOrderFlag(pci);

            //
            // drier EMF option is turned off, need to handle several EMF features

            //
            // booklet
            //

            if (NUPOPTION(pdmPrivate) == BOOKLET_UP)
            {
                TERSE(("EMF off, so BOOKLET_UP to ONE_UP\n"));
                NUPOPTION(pdmPrivate) = ONE_UP;
            }

            //
            // collate
            //

            if ((pdm->dmFields & DM_COLLATE) &&
                (pdm->dmCollate == DMCOLLATE_TRUE) &&
                !PRINTER_SUPPORTS_COLLATE(pci))
            {
                TERSE(("EMF off, so collate off\n"));
                pdm->dmCollate = DMCOLLATE_FALSE;

                //
                // Update Collate feature option index
                //

                ChangeOptionsViaID(pci->pInfoHeader,
                                   pci->pCombinedOptions,
                                   GID_COLLATE,
                                   pdm);
            }

            //
            // reverse order printing
            //

            if ((!REVPRINTOPTION(pdmPrivate) && bReversed) ||
                (REVPRINTOPTION(pdmPrivate) && !bReversed))
            {
                TERSE(("EMF off, so reverse %d\n", bReversed));
                REVPRINTOPTION(pdmPrivate) = bReversed;
            }
        }
    }
}


/*++

Routine Name:

    BUpdatePSF_RevPrintAndOutputOrder

Routine Description:

    sync up settings between driver synthesized feature %PageOrder
    and PPD feature *OutputOrder to avoid spooler simulation

Arguments:

    pci - pointer to driver's COMMONINFO structure
    dwChangedItemID - ID to indicate which item has been changed

Return Value:

    TRUE      if the sync up succeeds
    FALSE     if there is no PPD feature "OutputOrder" or current
              setting for "OutputOrder" is invalid

Last Error:

    None

--*/
BOOL
BUpdatePSF_RevPrintAndOutputOrder(
    IN  PCOMMONINFO  pci,
    IN  DWORD        dwChangedItemID
    )
{
    PUIINFO   pUIInfo = pci->pUIInfo;
    PPPDDATA  pPpdData;
    PFEATURE  pFeature;

    pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER(pci->pInfoHeader);
    ASSERT(pPpdData != NULL && pPpdData->dwSizeOfStruct == sizeof(PPDDATA));

    //
    // refer to VSyncRevPrintAndOutputOrder
    //

    if (pPpdData &&
        pPpdData->dwOutputOrderIndex != INVALID_FEATURE_INDEX &&
        (pFeature = PGetIndexedFeature(pUIInfo, pPpdData->dwOutputOrderIndex)))
    {
        INT      iSelection;
        POPTION  pOption;
        PCSTR    pstrOptionName;
        BOOL     bReverse;

        //
        // "OutputOrder" feature is available. We only recognize the 2 standard options
        // "Normal" and "Reverse".
        //

        iSelection = pci->pCombinedOptions[pPpdData->dwOutputOrderIndex].ubCurOptIndex;

        if (iSelection < 2 &&
            (pOption = PGetIndexedOption(pUIInfo, pFeature, iSelection)) &&
            (pstrOptionName = OFFSET_TO_POINTER(pUIInfo->pubResourceData, pOption->loKeywordName)))
        {
            PPSDRVEXTRA pdmPrivate = pci->pdmPrivate;

            if (strcmp(pstrOptionName, "Reverse") == EQUAL_STRING)
                bReverse = TRUE;
            else
                bReverse = FALSE;

            if (dwChangedItemID == REVPRINT_ITEM)
            {
                //
                // reverse printing setting has just being changed. We should change
                // "OutputOrder" option if needed to match the requested output order.
                //

                if ((!REVPRINTOPTION(pdmPrivate) && bReverse) ||
                    (REVPRINTOPTION(pdmPrivate) && !bReverse))
                {
                    TERSE(("RevPrint change causes OutputOrder to be %d\n", 1 - iSelection));
                    pci->pCombinedOptions[pPpdData->dwOutputOrderIndex].ubCurOptIndex = (BYTE)(1 - iSelection);
                }
            }
            else
            {
                //
                // output order setting has just being changed. We should change reverse
                // printing option to match the request output order.
                //

                TERSE(("OutputOrder change causes RevPrint to be %d\n", bReverse));
                REVPRINTOPTION(pdmPrivate) = bReverse;
            }

            //
            // sync between reverse print and output order succeeeded
            //

            return TRUE;
        }
    }

    //
    // sync between reverse print and output order failed
    //

    return FALSE;
}


/*++

Routine Name:

    VUpdatePSF_BookletAndDuplex

Routine Description:

    sync up settings between driver synthesized feature %PagePerSheet
    and PPD feature *Duplex

Arguments:

    pci - pointer to driver's COMMONINFO structure
    dwChangedItemID - ID to indicate which item has been changed

Return Value:

    None

Last Error:

    None

--*/
VOID
VUpdatePSF_BookletAndDuplex(
    IN  PCOMMONINFO  pci,
    IN  DWORD        dwChangedItemID
    )
{
    PUIINFO     pUIInfo = pci->pUIInfo;
    PFEATURE    pDuplexFeature;

    //
    // refer to VUpdateBookletOption
    //

    if (pDuplexFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_DUPLEX))
    {
        PDUPLEX     pDuplexOption;
        DWORD       dwFeatureIndex, dwOptionIndex;
        PPSDRVEXTRA pdmPrivate = pci->pdmPrivate;

        dwFeatureIndex = GET_INDEX_FROM_FEATURE(pUIInfo, pDuplexFeature);
        dwOptionIndex = pci->pCombinedOptions[dwFeatureIndex].ubCurOptIndex;
        pDuplexOption = PGetIndexedOption(pUIInfo, pDuplexFeature, dwOptionIndex);

        if (pDuplexOption &&
            pDuplexOption->dwDuplexID == DMDUP_SIMPLEX &&
            NUPOPTION(pdmPrivate) == BOOKLET_UP)
        {
            ASSERT(((PUIDATA)pci)->bEMFSpooling);

            if (dwChangedItemID == NUP_ITEM)
            {
                DWORD  cIndex;

                //
                // Booklet is enabled - turn duplex on
                //

                pDuplexOption = PGetIndexedOption(pUIInfo, pDuplexFeature, 0);

                for (cIndex = 0 ; cIndex < pDuplexFeature->Options.dwCount; cIndex++)
                {
                    if (pDuplexOption->dwDuplexID != DMDUP_SIMPLEX)
                    {
                        TERSE(("Booklet change causes Duplex to be %d\n", cIndex));
                        pci->pCombinedOptions[dwFeatureIndex].ubCurOptIndex = (BYTE)cIndex;
                        break;
                    }

                    pDuplexOption++;
                }
            }
            else
            {
                ASSERT(dwChangedItemID == DUPLEX_ITEM);

                //
                // Duplex is turned off, so disable booklet and set to 2 up.
                //

                TERSE(("Simplex change causes Booklet to be 2up\n"));
                NUPOPTION(pdmPrivate) = TWO_UP;
            }
        }
    }
}


/*++

Routine Name:

    HSetOptions

Routine Description:

    set new driver settings for PPD features and driver synthesized features

Arguments:

    poemuiobj - pointer to driver context object
    dwFlags - flags for the set operation
    pmszFeatureOptionBuf - MULTI_SZ ASCII string containing new settings'
                           feature/option keyword pairs
    cbin - size in bytes of the pmszFeatureOptionBuf string
    pdwResult - pointer to the DWORD that will store the result of set operation

Return Value:

    S_OK           if the set operation succeeds
    E_INVALIDARG   if input pmszFeatureOptionBuf is not in valid MULTI_SZ format,
                   or flag for the set operation is not recognized
    E_FAIL         if the set operation fails

Last Error:

    None

--*/
HRESULT
HSetOptions(
    IN  POEMUIOBJ  poemuiobj,
    IN  DWORD      dwFlags,
    IN  PCSTR      pmszFeatureOptionBuf,
    IN  DWORD      cbIn,
    OUT PDWORD     pdwResult
    )
{
    PCOMMONINFO  pci = (PCOMMONINFO)poemuiobj;
    PDEVMODE     pdm;
    PPSDRVEXTRA  pdmPrivate;
    PUIINFO      pUIInfo;
    PPPDDATA     pPpdData;
    PCSTR        pszFeature, pszOption;
    BOOL         bPageSizeSet = FALSE, bPrinterSticky, bNoConflict;
    INT          iMode;
    LAYOUT       iOldLayout;

    //
    // do some validation on the input parameters
    //

    if (!BValidMultiSZString(pmszFeatureOptionBuf, cbIn, TRUE))
    {
        ERR(("Set: invalid MULTI_SZ input param\n"));
        return E_INVALIDARG;
    }

    if (!(dwFlags & SETOPTIONS_FLAG_RESOLVE_CONFLICT) &&
        !(dwFlags & SETOPTIONS_FLAG_KEEP_CONFLICT))
    {
        ERR(("Set: invalid dwFlags %d\n", dwFlags));
        return E_INVALIDARG;
    }

    pUIInfo = pci->pUIInfo;

    pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER(pci->pInfoHeader);
    ASSERT(pPpdData != NULL && pPpdData->dwSizeOfStruct == sizeof(PPDDATA));

    if (pPpdData == NULL)
    {
        return E_FAIL;
    }

    pdm = pci->pdm;

    bPrinterSticky = ((PUIDATA)pci)->iMode == MODE_PRINTER_STICKY ? TRUE : FALSE;

    if (!bPrinterSticky)
    {
        ASSERT(pdm);
        pdmPrivate = (PPSDRVEXTRA)GET_DRIVER_PRIVATE_DEVMODE(pdm);
        iOldLayout = NUPOPTION(pdmPrivate);

        //
        // First we need to propagate devmode settings (in case
        // plugin has changed it) into option array.
        //
        // devmode is only valid in non printer-sticky mode. Refer to comments
        // in HEnumConstrainedOptions().
        //

        VFixOptionsArrayWithDevmode(pci);
    }

    //
    // Then set each feature specified by plugin.
    //

    pszFeature = pmszFeatureOptionBuf;

    while (*pszFeature)
    {
        DWORD cbFeatureKeySize, cbOptionKeySize;

        cbFeatureKeySize = strlen(pszFeature) + 1;
        pszOption = pszFeature + cbFeatureKeySize;
        cbOptionKeySize = strlen(pszOption) + 1;

        //
        // Feature or option setting string can't be empty.
        //

        if (cbFeatureKeySize == 1 || cbOptionKeySize == 1)
        {
            ERR(("Set: empty feature or option keyword\n"));
            goto next_feature;
        }

        if (*pszFeature == PSFEATURE_PREFIX)
        {
            PPSFEATURE_ENTRY pEntry, pMatchEntry;

            //
            // synthesized PS driver feature
            //

            pMatchEntry = NULL;
            pEntry = (PPSFEATURE_ENTRY)(&kPSFeatureTable[0]);

            while (pEntry->pszPSFeatureName)
            {
                if ((*pszFeature == *(pEntry->pszPSFeatureName)) &&
                    (strcmp(pszFeature, pEntry->pszPSFeatureName) == EQUAL_STRING))
                {
                    pMatchEntry = pEntry;
                    break;
                }

                pEntry++;
            }

            //
            // See comments in HEnumConstrainedOptions for following stickiness mode check.
            //

            if (!pMatchEntry ||
                (bPrinterSticky && !pMatchEntry->bPrinterSticky) ||
                (!bPrinterSticky && pMatchEntry->bPrinterSticky))
            {
                VERBOSE(("Set: invalid or mode-mismatched feature %s\n", pszFeature));
                goto next_feature;
            }

            if (pMatchEntry->pfnPSProc)
            {
                BOOL  bResult;

                bResult = (pMatchEntry->pfnPSProc)(pci->hPrinter,
                                                   pUIInfo,
                                                   pPpdData,
                                                   pdm,
                                                   pci->pPrinterData,
                                                   pszFeature,
                                                   pszOption,
                                                   NULL,
                                                   0,
                                                   NULL,
                                                   PSFPROC_SETOPTION_MODE);

                if (bResult)
                {
                    //
                    // PS driver EMF features EMF, PageOrder, Nup need special postprocessing
                    // to synchronize among EMF features (refer to cpcbDocumentPropertyCallback).
                    //

                    if ((*pszFeature == kstrPSFEMF[0]) &&
                        (strcmp(pszFeature, kstrPSFEMF) == EQUAL_STRING))
                    {
                        ASSERT(!bPrinterSticky);

                        VUpdatePSF_EMFFeatures(pci, METASPOOL_ITEM);
                    }
                    else if ((*pszFeature == kstrPSFPageOrder[0]) &&
                            (strcmp(pszFeature, kstrPSFPageOrder) == EQUAL_STRING))
                    {
                        ASSERT(!bPrinterSticky);

                        //
                        // first try to sync between reverse print and output order feature
                        //

                        if (!BUpdatePSF_RevPrintAndOutputOrder(pci, REVPRINT_ITEM))
                        {
                            //
                            // if that failed, reverse print could force EMF on
                            //

                            VUpdatePSF_EMFFeatures(pci, REVPRINT_ITEM);
                        }
                    }
                    else if ((*pszFeature == kstrPSFNup[0]) &&
                            (strcmp(pszFeature, kstrPSFNup) == EQUAL_STRING))
                    {
                        ASSERT(!bPrinterSticky);

                        if (NUPOPTION(pdmPrivate) == BOOKLET_UP)
                        {
                            if (!((PUIDATA)pci)->bEMFSpooling || !SUPPORTS_DUPLEX(pci))
                            {
                                //
                                // booklet is not supported if duplex is constrained by an installable
                                // feature such as duplex unit not installed or spooler EMF is disabled
                                // (refer to BPackItemEmfFeatures)
                                //

                                ERR(("Set: BOOKLET_UP ignored for %s\n", pszFeature));
                                NUPOPTION(pdmPrivate) = iOldLayout;
                            }
                            else
                            {
                                //
                                // Booklet will force EMF on
                                //

                                VUpdatePSF_EMFFeatures(pci, NUP_ITEM);

                                //
                                // Booklet will also turn duplex on
                                //

                                VUpdatePSF_BookletAndDuplex(pci, NUP_ITEM);
                            }
                        }
                    }
                }
                else
                {
                    if (GetLastError() == ERROR_INVALID_PARAMETER)
                    {
                        ERR(("Set: %%-feature handler found invalid option %s for %s\n", pszOption, pszFeature));
                    }
                    else
                    {
                        ERR(("Set: %%-feature handler failed on %s-%s: %d\n", pszFeature, pszOption, GetLastError()));
                    }
                }
            }
        }
        else
        {
            PFEATURE   pFeature;
            POPTION    pOption;
            DWORD      dwFeatureIndex, dwOptionIndex;
            POPTSELECT pOptionsArray = pci->pCombinedOptions;

            //
            // PPD *OpenUI feature
            //

            pFeature = PGetNamedFeature(pUIInfo, pszFeature, &dwFeatureIndex);

            //
            // See comments in HEnumConstrainedOptions for following stickiness mode check.
            //

            if (!pFeature ||
                (bPrinterSticky && pFeature->dwFeatureType != FEATURETYPE_PRINTERPROPERTY) ||
                (!bPrinterSticky && pFeature->dwFeatureType == FEATURETYPE_PRINTERPROPERTY))
            {
                VERBOSE(("Set: invalid or mode-mismatched feature %s\n", pszFeature));
                goto next_feature;
            }

            //
            // Skip GID_LEADINGEDGE, GID_USEHWMARGINS. They are not real PPD *OpenUI features.
            // Also skip GID_PAGEREGION, it's only set internally. We don't allow user or plugin
            // to set it.
            //

            if (pFeature->dwFeatureID == GID_PAGEREGION ||
                pFeature->dwFeatureID == GID_LEADINGEDGE ||
                pFeature->dwFeatureID == GID_USEHWMARGINS)
            {
                ERR(("Set: skip feature %s\n", pszFeature));
                goto next_feature;
            }

            pOption = PGetNamedOption(pUIInfo, pFeature, pszOption, &dwOptionIndex);

            if (!pOption)
            {
                ERR(("Set: invalid input option %s for feature %s\n", pszOption, pszFeature));
                goto next_feature;
            }

            //
            // update the option selection
            //

            pOptionsArray[dwFeatureIndex].ubCurOptIndex = (BYTE)dwOptionIndex;

            //
            // We don't support pick-many yet.
            //

            ASSERT(pOptionsArray[dwFeatureIndex].ubNext == NULL_OPTSELECT);

            //
            // some special postprocessing after the option setting is changed
            //

            if (pFeature->dwFeatureID == GID_PAGESIZE)
            {
                PPAGESIZE  pPageSize = (PPAGESIZE)pOption;

                ASSERT(!bPrinterSticky);

                //
                // special handling of PS custom page size
                //
                // refer to VUnpackDocumentPropertiesItems case FORMNAME_ITEM in docprop.c
                //

                if (pPageSize->dwPaperSizeID == DMPAPER_CUSTOMSIZE)
                {
                    pdm->dmFields &= ~(DM_PAPERLENGTH|DM_PAPERWIDTH|DM_FORMNAME);
                    pdm->dmFields |= DM_PAPERSIZE;
                    pdm->dmPaperSize = DMPAPER_CUSTOMSIZE;

                    LOAD_STRING_PAGESIZE_NAME(pci,
                                              pPageSize,
                                              pdm->dmFormName,
                                              CCHFORMNAME);
                }

                bPageSizeSet = TRUE;
            }
            else if (pFeature->dwFeatureID == GID_OUTPUTBIN)
            {
                ASSERT(!bPrinterSticky);

                //
                // output bin change could force EMF on
                //

                VUpdatePSF_EMFFeatures(pci, REVPRINT_ITEM);
            }
            else if (pPpdData->dwOutputOrderIndex != INVALID_FEATURE_INDEX &&
                     dwFeatureIndex == pPpdData->dwOutputOrderIndex)
            {
                ASSERT(!bPrinterSticky);

                //
                // output order change causes reverse print change
                //

                if (!BUpdatePSF_RevPrintAndOutputOrder(pci, UNKNOWN_ITEM))
                {
                    ERR(("OutputOrder change syncs RevPrint failed\n"));
                }
            }
        }

        next_feature:

        pszFeature += cbFeatureKeySize + cbOptionKeySize;
    }

    iMode = bPrinterSticky ? MODE_PRINTER_STICKY : MODE_DOCANDPRINTER_STICKY;

    if (dwFlags & SETOPTIONS_FLAG_KEEP_CONFLICT)
    {
        iMode |= DONT_RESOLVE_CONFLICT;
    }

    //
    // If we're inside DrvDocumentPropertySheets,
    // we'll call the parser to resolve conflicts between
    // all printer features. Since all printer-sticky
    // features have higher priority than all doc-sticky
    // features, only doc-sticky option selections should
    // be affected.
    //

    bNoConflict = ResolveUIConflicts(pci->pRawData,
                                     pci->pCombinedOptions,
                                     MAX_COMBINED_OPTIONS,
                                     iMode);

    if (pdwResult)
    {
        if (dwFlags & SETOPTIONS_FLAG_RESOLVE_CONFLICT)
        {
            *pdwResult = bNoConflict ? SETOPTIONS_RESULT_NO_CONFLICT :
                                       SETOPTIONS_RESULT_CONFLICT_RESOLVED;
        }
        else
        {
            *pdwResult = bNoConflict ? SETOPTIONS_RESULT_NO_CONFLICT :
                                       SETOPTIONS_RESULT_CONFLICT_REMAINED;
        }
    }

    if (!bPrinterSticky)
    {
        //
        // Lastly we need to transfer options array settings back
        // to devmode so they are in sync.
        //

        VOptionsToDevmodeFields(pci, bPageSizeSet);

        //
        // A few more postprocessing here
        //
        // collate could force EMF on
        //

        VUpdatePSF_EMFFeatures(pci, COPIES_COLLATE_ITEM);

        //
        // simplex could change booklet setting
        //

        VUpdatePSF_BookletAndDuplex(pci, DUPLEX_ITEM);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\driverui\ps\ps.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ps.c

Abstract:

    This file handles Postscript specific UI options

Environment:

    Win32 subsystem, DriverUI module, user mode

Revision History:

    02/25/97 -davidx-
        Finish PS-specific items.

    02/04/97 -davidx-
        Reorganize driver UI to separate ps and uni DLLs.

        12/17/96 -amandan-
                Created it.

--*/

#include "precomp.h"
#include <ntverp.h>

BOOL BSearchConstraintList(PUIINFO, DWORD, DWORD, DWORD);

static CONST WORD ScaleItemInfo[] =
{
    IDS_CPSUI_SCALING, TVITEM_LEVEL1, DMPUB_SCALE,
    SCALE_ITEM, HELP_INDEX_SCALE,
    2, TVOT_UDARROW,
    IDS_CPSUI_PERCENT, IDI_CPSUI_SCALING,
    0, MIN_SCALE,
    ITEM_INFO_SIGNATURE
};


BOOL
_BPackItemScale(
    PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack scaling option.

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error.

--*/

{
    return BPackUDArrowItemTemplate(
                pUiData,
                ScaleItemInfo,
                pUiData->ci.pdm->dmScale,
                pUiData->ci.pUIInfo->dwMaxScale,
                NULL);
}


DWORD
_DwEnumPersonalities(
    PCOMMONINFO pci,
    PWSTR       pwstrOutput
    )

/*++

Routine Description:

    Enumerate the list of supported printer description languages

Arguments:

    pci - Points to common printer info
    pwstrOutput - Points to output buffer

Return Value:

    Number of personalities supported
    GDI_ERROR if there is an error

--*/

{
    if (pwstrOutput)
        CopyString(pwstrOutput, TEXT("PostScript"), CCHLANGNAME);

    return 1;
}



DWORD
_DwGetOrientationAngle(
    PUIINFO     pUIInfo,
    PDEVMODE    pdm
    )
/*++

Routine Description:

    Get the orienation angle requested by DrvDeviceCapabilities(DC_ORIENTATION)

Arguments:

    pUIInfo - Pointer to UIINFO
    pdm  - Pointer to DEVMODE

Return Value:

    The angle (90 or 270 or landscape rotation)

--*/

{
    DWORD       dwRet;
    PPSDRVEXTRA pdmPrivate;

    pdmPrivate = (PPSDRVEXTRA) GET_DRIVER_PRIVATE_DEVMODE(pdm);

    //
    // Normal landscape rotates counterclockwise
    // Rotated landscape rotates clockwise
    //

    if (pUIInfo->dwFlags & FLAG_ROTATE90)
        dwRet = (pdmPrivate->dwFlags & PSDEVMODE_LSROTATE) ? 270 : 90;
    else
        dwRet = (pdmPrivate->dwFlags & PSDEVMODE_LSROTATE) ? 90 : 270;

    return dwRet;
}


static CONST WORD PSOrientItemInfo[] =
{
    IDS_CPSUI_ORIENTATION, TVITEM_LEVEL1, DMPUB_ORIENTATION,
    ORIENTATION_ITEM, HELP_INDEX_ORIENTATION,
    3, TVOT_3STATES,
    IDS_CPSUI_PORTRAIT, IDI_CPSUI_PORTRAIT,
    IDS_CPSUI_LANDSCAPE, IDI_CPSUI_LANDSCAPE,
    IDS_CPSUI_ROT_LAND, IDI_CPSUI_ROT_LAND,
    ITEM_INFO_SIGNATURE
};


BOOL
_BPackOrientationItem(
    IN OUT PUIDATA pUiData
    )
/*++

Routine Description:

    Synthesize the orientation feature for Doc property sheet

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE for success and FALSE for failure

Note:

    Always synthesize orienation for PostScript

--*/

{
    PFEATURE    pFeature;
    DWORD       dwSelection;

    //
    // If there is no predefined orientation feature, we displays it ourselves.
    //

    if ((pUiData->ci.pdm->dmFields & DM_ORIENTATION) &&
        (pUiData->ci.pdm->dmOrientation == DMORIENT_LANDSCAPE))
    {
        PPSDRVEXTRA pdmPrivate;

        pdmPrivate = (PPSDRVEXTRA) GET_DRIVER_PRIVATE_DEVMODE(pUiData->ci.pdm);
        dwSelection = pdmPrivate->dwFlags &  PSDEVMODE_LSROTATE ?  2 : 1;
    }
    else
        dwSelection = 0;

    //
    // Synthesize the feature ourselves
    //

    return BPackOptItemTemplate(pUiData, PSOrientItemInfo, dwSelection, NULL);
}



static CONST WORD PSOutputOptionItemInfo[] =
{
    IDS_PSOUTPUT_OPTION, TVITEM_LEVEL2, DMPUB_NONE,
    PSOUTPUT_OPTION_ITEM, HELP_INDEX_PSOUTPUT_OPTION,
    4, TVOT_LISTBOX,
    IDS_PSOPT_SPEED, IDI_PSOPT_SPEED,
    IDS_PSOPT_PORTABILITY, IDI_PSOPT_PORTABILITY,
    IDS_PSOPT_EPS, IDI_PSOPT_EPS,
    IDS_PSOPT_ARCHIVE, IDI_PSOPT_ARCHIVE,
    ITEM_INFO_SIGNATURE
};


BOOL
BPackItemPSOutputOption(
    PUIDATA     pUiData,
    PPSDRVEXTRA pdmPrivate
    )

/*++

Routine Description:

    Pack PostScript output option item

Arguments:

    pUiData - Points to UIDATA structure
    pdmPrivate - Points to pscript private devmode

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD   dwSel;

    switch (pdmPrivate->iDialect)
    {
    case PORTABILITY:
        dwSel = 1;
        break;

    case EPS:
        dwSel = 2;
        break;

    case ARCHIVE:
        dwSel = 3;
        break;

    case SPEED:
    default:
        dwSel = 0;
        break;
    }

    return BPackOptItemTemplate(pUiData, PSOutputOptionItemInfo, dwSel, NULL);
}



static CONST WORD PSTTDLFormatItemInfo[] =
{
    IDS_PSTT_DLFORMAT, TVITEM_LEVEL2, DMPUB_NONE,
    PSTT_DLFORMAT_ITEM, HELP_INDEX_PSTT_DLFORMAT,
    4, TVOT_LISTBOX,
    IDS_TTDL_DEFAULT, IDI_PSTT_DLFORMAT,
    IDS_TTDL_TYPE1, IDI_PSTT_DLFORMAT,
    IDS_TTDL_TYPE3, IDI_PSTT_DLFORMAT,
    IDS_TTDL_TYPE42, IDI_PSTT_DLFORMAT,
    ITEM_INFO_SIGNATURE
};


BOOL
BPackItemTTDownloadFormat(
    PUIDATA     pUiData,
    PPSDRVEXTRA pdmPrivate
    )

/*++

Routine Description:

    Pack PostScript TrueType download option item

Arguments:

    pUiData - Points to UIDATA structure
    pdmPrivate - Points to pscript private devmode

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD       dwSel;
    BOOL        bSupportType42;
    POPTTYPE    pOptType = pUiData->pOptType;

    bSupportType42 = (pUiData->ci.pUIInfo->dwTTRasterizer == TTRAS_TYPE42);

    switch (pdmPrivate->iTTDLFmt)
    {
    case TYPE_1:
        dwSel = 1;
        break;

    case TYPE_3:
        dwSel = 2;
        break;

    case TYPE_42:

        dwSel = bSupportType42 ? 3 : 0;
        break;

    case TT_DEFAULT:
    default:
        dwSel = 0;
        break;
    }

    if (! BPackOptItemTemplate(pUiData, PSTTDLFormatItemInfo, dwSel, NULL))
        return FALSE;

    //
    // if printer doesn't support Type42, hide Type42 option
    //

    if (pOptType && !bSupportType42)
        pOptType->pOptParam[3].Flags |= OPTPF_HIDE;

    return TRUE;
}



static CONST WORD PSLevelItemInfo[] =
{
    IDS_PSLEVEL, TVITEM_LEVEL2, DMPUB_NONE,
    PSLEVEL_ITEM, HELP_INDEX_SCALE,
    2, TVOT_UDARROW,
    0, IDI_PSLEVEL,
    0,

    //
    // Adobe doesn't want to support level 1
    //

    #ifdef ADOBE
    2,
    #else
    1,
    #endif

    ITEM_INFO_SIGNATURE
};

BOOL
BPackItemPSLevel(
    PUIDATA     pUiData,
    PPSDRVEXTRA pdmPrivate
    )

/*++

Routine Description:

    Pack PostScript output option item

Arguments:

    pUiData - Points to UIDATA structure
    pdmPrivate - Points to pscript private devmode

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD       dwSel = pdmPrivate->iPSLevel;
    DWORD       dwLangLevel = pUiData->ci.pUIInfo->dwLangLevel;

    //
    // we don't expect language level to be higher than 4
    //

    if (dwLangLevel <= 1)
        return TRUE;

    if (dwLangLevel > 4)
        dwLangLevel = 4;

    //
    // make sure the current selection is sensible
    //

    if (dwSel == 0 || dwSel > dwLangLevel)
        dwSel = dwLangLevel;

    return BPackUDArrowItemTemplate(pUiData, PSLevelItemInfo, dwSel, dwLangLevel, NULL);
}



static CONST WORD EHandlerItemInfo[] =
{
    IDS_PSERROR_HANDLER, TVITEM_LEVEL2, DMPUB_NONE,
    PSERROR_HANDLER_ITEM, HELP_INDEX_PSERROR_HANDLER,
    2, TVOT_2STATES,
    IDS_CPSUI_YES, IDI_CPSUI_YES,
    IDS_CPSUI_NO, IDI_CPSUI_NO,
    ITEM_INFO_SIGNATURE
};

static CONST WORD MirrorItemInfo[] =
{
    IDS_MIRROR, TVITEM_LEVEL2, DMPUB_NONE,
    MIRROR_ITEM, HELP_INDEX_MIRROR,
    2, TVOT_2STATES,
    IDS_CPSUI_YES, IDI_CPSUI_YES,
    IDS_CPSUI_NO, IDI_CPSUI_NO,
    ITEM_INFO_SIGNATURE
};

static CONST WORD NegativeItemInfo[] =
{
    IDS_NEGATIVE_PRINT, TVITEM_LEVEL2, DMPUB_NONE,
    NEGATIVE_ITEM, HELP_INDEX_NEGATIVE,
    2, TVOT_2STATES,
    IDS_CPSUI_YES, IDI_CPSUI_YES,
    IDS_CPSUI_NO, IDI_CPSUI_NO,
    ITEM_INFO_SIGNATURE
};

static CONST WORD CompressBmpItemInfo[] =
{
    IDS_COMPRESSBMP, TVITEM_LEVEL2, DMPUB_NONE,
    COMPRESSBMP_ITEM, HELP_INDEX_COMPRESSBMP,
    2, TVOT_2STATES,
    IDS_CPSUI_YES, IDI_CPSUI_YES,
    IDS_CPSUI_NO, IDI_CPSUI_NO,
    ITEM_INFO_SIGNATURE
};

BOOL
_BPackDocumentOptions(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack PostScript specific options such as Job Control etc.

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE for success and FALSE for failure

--*/

{
    POPTITEM    pOptItem;
    PPSDRVEXTRA pdmPrivate;
    DWORD       dwFlags;

    pdmPrivate = pUiData->ci.pdmPrivate;
    dwFlags = pdmPrivate->dwFlags;
    pOptItem = pUiData->pOptItem;

    VPackOptItemGroupHeader(pUiData,
                            IDS_PSOPTIONS,
                            IDI_CPSUI_POSTSCRIPT,
                            HELP_INDEX_PSOPTIONS);

    if (pOptItem)
        pOptItem->Flags |= OPTIF_COLLAPSE;

    return BPackItemPSOutputOption(pUiData, pdmPrivate) &&
           BPackItemTTDownloadFormat(pUiData, pdmPrivate) &&
           BPackItemPSLevel(pUiData, pdmPrivate) &&
           BPackOptItemTemplate(
                    pUiData,
                    EHandlerItemInfo,
                    (dwFlags & PSDEVMODE_EHANDLER) ? 0 : 1, NULL) &&
           (pUiData->ci.pUIInfo->dwLangLevel > 1 ||
            BPackOptItemTemplate(
                    pUiData,
                    CompressBmpItemInfo,
                    (dwFlags & PSDEVMODE_COMPRESSBMP) ? 0 : 1, NULL)) &&
           BPackOptItemTemplate(
                    pUiData,
                    MirrorItemInfo,
                    (dwFlags & PSDEVMODE_MIRROR) ? 0 : 1, NULL) &&
           (IS_COLOR_DEVICE(pUiData->ci.pUIInfo) ||
            BPackOptItemTemplate(
                     pUiData,
                     NegativeItemInfo,
                     (dwFlags & PSDEVMODE_NEG) ? 0 : 1, NULL));
}


VOID
_VUnpackDocumentOptions(
    POPTITEM    pOptItem,
    PDEVMODE    pdm
    )

/*++

Routine Description:

    Extract Postscript devmode information from an OPTITEM
    Stored it back into Postscript devmode.

Arguments:

    pOptItem - Pointer to an OPTITEM
    pdm - Pointer to Postscript DEVMODE structure

Return Value:

    None

--*/

{
    PPSDRVEXTRA pdmPrivate;

    pdmPrivate = (PPSDRVEXTRA) GET_DRIVER_PRIVATE_DEVMODE(pdm);

    switch (GETUSERDATAITEM(pOptItem->UserData))
    {
    case ORIENTATION_ITEM:

        pdm->dmFields |= DM_ORIENTATION;
        pdm->dmOrientation = (pOptItem->Sel == 0) ?
                                    DMORIENT_PORTRAIT :
                                    DMORIENT_LANDSCAPE;

        if (pOptItem->Sel != 2)
            pdmPrivate->dwFlags &= ~PSDEVMODE_LSROTATE;
        else
            pdmPrivate->dwFlags |= PSDEVMODE_LSROTATE;

        break;

    case PSOUTPUT_OPTION_ITEM:

        switch (pOptItem->Sel)
        {
        case 1:
            pdmPrivate->iDialect = PORTABILITY;
            break;

        case 2:
            pdmPrivate->iDialect = EPS;
            break;

        case 3:
            pdmPrivate->iDialect = ARCHIVE;
            break;

        case 0:
        default:
            pdmPrivate->iDialect = SPEED;
            break;
        }
        break;

    case PSTT_DLFORMAT_ITEM:

        switch (pOptItem->Sel)
        {
        case 1:
            pdmPrivate->iTTDLFmt = TYPE_1;
            break;

        case 2:
            pdmPrivate->iTTDLFmt = TYPE_3;
            break;

        case 3:
            pdmPrivate->iTTDLFmt = TYPE_42;
            break;

        case 0:
        default:
            pdmPrivate->iTTDLFmt = TT_DEFAULT;
            break;
        }
        break;

    case PSLEVEL_ITEM:

        pdmPrivate->iPSLevel = pOptItem->Sel;
        break;

    case PSERROR_HANDLER_ITEM:

        if (pOptItem->Sel == 0)
            pdmPrivate->dwFlags |= PSDEVMODE_EHANDLER;
        else
            pdmPrivate->dwFlags &= ~PSDEVMODE_EHANDLER;
        break;

    case PSHALFTONE_FREQ_ITEM:
    case PSHALFTONE_ANGLE_ITEM:

        // DCR - not implemented yet
        break;

    case MIRROR_ITEM:

        if (pOptItem->Sel == 0)
            pdmPrivate->dwFlags |= PSDEVMODE_MIRROR;
        else
            pdmPrivate->dwFlags &= ~PSDEVMODE_MIRROR;
        break;

    case NEGATIVE_ITEM:

        if (pOptItem->Sel == 0)
            pdmPrivate->dwFlags |= PSDEVMODE_NEG;
        else
            pdmPrivate->dwFlags &= ~PSDEVMODE_NEG;
        break;

    case COMPRESSBMP_ITEM:

        if (pOptItem->Sel == 0)
            pdmPrivate->dwFlags |= PSDEVMODE_COMPRESSBMP;
        else
            pdmPrivate->dwFlags &= ~PSDEVMODE_COMPRESSBMP;
        break;
   }
}



static CONST WORD IgnoreDevFontItemInfo[] =
{
    IDS_USE_DEVFONTS, TVITEM_LEVEL1, DMPUB_NONE,
    IGNORE_DEVFONT_ITEM, HELP_INDEX_IGNORE_DEVFONT,
    2, TVOT_2STATES,
    IDS_CPSUI_YES, IDI_CPSUI_YES,
    IDS_CPSUI_NO, IDI_CPSUI_NO,
    ITEM_INFO_SIGNATURE
};


BOOL
_BPackFontSubstItems(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack font substitution related items (printer-sticky)

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    BOOL bNoDeviceFont;

    bNoDeviceFont = (pUiData->ci.pPrinterData->dwFlags & PFLAGS_IGNORE_DEVFONT);

    //
    // On non-1252 code page systems, gives user the option
    // to disable all device fonts
    //
    // Note: On non-1252 CodePage systems (Cs-Ct-Ja-Ko & Cyr-Grk-Tur, etc),
    // PScript NT4 had difficulty mapping printer font Encodings to GDI strings.
    // AdobePS5/PScript5 is supposed to handle these correctly. So Adobe wants
    // this choice to be suppressed on all code pages.
    //
    // Fix MS bug #121883, Adobe bug #235417
    //

    if (FALSE && GetACP() != 1252 &&
        !BPackOptItemTemplate(pUiData, IgnoreDevFontItemInfo, bNoDeviceFont ? 1 : 0, NULL))
    {
        return FALSE;
    }

    //
    // Don't display the font substitution table if device font is disabled
    //

    if (bNoDeviceFont)
        return TRUE;

    return BPackItemFontSubstTable(pUiData);
}



static CONST WORD ProtocolItemInfo[] =
{
    IDS_PSPROTOCOL, TVITEM_LEVEL1, DMPUB_NONE,
    PSPROTOCOL_ITEM, HELP_INDEX_PSPROTOCOL,
    4, TVOT_LISTBOX,
    IDS_PSPROTOCOL_ASCII, IDI_PSPROTOCOL,
    IDS_PSPROTOCOL_BCP, IDI_PSPROTOCOL,
    IDS_PSPROTOCOL_TBCP, IDI_PSPROTOCOL,
    IDS_PSPROTOCOL_BINARY, IDI_PSPROTOCOL,
    ITEM_INFO_SIGNATURE
};


BOOL
BPackPSProtocolItem(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack PostScript communication protocol item

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DWORD       dwSel;
    POPTITEM    pOptItem;
    POPTPARAM   pOptParam;
    PUIINFO     pUIInfo;

    pOptItem = pUiData->pOptItem;

    if (! BPackOptItemTemplate(pUiData, ProtocolItemInfo, 0, NULL))
        return FALSE;

    if (pOptItem)
    {
        //
        // Hide those selections which are not supported on the printer
        //

        pOptParam = pOptItem->pOptType->pOptParam;
        pUIInfo = pUiData->ci.pUIInfo;

        if (! (pUIInfo->dwProtocols & PROTOCOL_BCP))
            pOptParam[1].Flags |= OPTPF_HIDE;

        if (! (pUIInfo->dwProtocols & PROTOCOL_TBCP))
            pOptParam[2].Flags |= OPTPF_HIDE;

        if (! (pUIInfo->dwProtocols & PROTOCOL_BINARY))
            pOptParam[3].Flags |= OPTPF_HIDE;

        switch (pUiData->ci.pPrinterData->wProtocol)
        {
        case PROTOCOL_BCP:
            dwSel = 1;
            break;

        case PROTOCOL_TBCP:
            dwSel = 2;
            break;

        case PROTOCOL_BINARY:
            dwSel = 3;
            break;

        default:
            dwSel = 0;
            break;
        }

        if (pOptParam[dwSel].Flags & OPTPF_HIDE)
            pOptItem->Sel = 0;
        else
            pOptItem->Sel = dwSel;
    }

    return TRUE;
}

//
// We will use different lower limit for Printer VM
// based on printer level. The 10th element of this
// ItemInfo must be filled with correct lower limit
// number before begin used.
//

static WORD PrinterVMItemInfo[] =
{
    IDS_POSTSCRIPT_VM, TVITEM_LEVEL1, DMPUB_NONE,
    PRINTER_VM_ITEM, HELP_INDEX_PRINTER_VM,
    2, TVOT_UDARROW,
    IDS_KBYTES, IDI_CPSUI_MEM,
    0, 0,
    ITEM_INFO_SIGNATURE
};

static CONST WORD JobTimeoutItemInfo[] =
{
    IDS_JOBTIMEOUT, TVITEM_LEVEL1, DMPUB_NONE,
    JOB_TIMEOUT_ITEM, HELP_INDEX_JOB_TIMEOUT,
    2, TVOT_UDARROW,
    IDS_SECONDS, IDI_USE_DEFAULT,
    0, 0,
    ITEM_INFO_SIGNATURE
};

static CONST WORD WaitTimeoutItemInfo[] =
{
    IDS_WAITTIMEOUT, TVITEM_LEVEL1, DMPUB_NONE,
    WAIT_TIMEOUT_ITEM, HELP_INDEX_WAIT_TIMEOUT,
    2, TVOT_UDARROW,
    IDS_SECONDS, IDI_USE_DEFAULT,
    0, 0,
    ITEM_INFO_SIGNATURE
};

static CONST WORD CtrlDBeforeItemInfo[] =
{
    IDS_CTRLD_BEFORE, TVITEM_LEVEL1, DMPUB_NONE,
    CTRLD_BEFORE_ITEM, HELP_INDEX_CTRLD_BEFORE,
    2, TVOT_2STATES,
    IDS_CPSUI_YES, IDI_CPSUI_YES,
    IDS_CPSUI_NO, IDI_CPSUI_NO,
    ITEM_INFO_SIGNATURE
};

static CONST WORD CtrlDAfterItemInfo[] =
{
    IDS_CTRLD_AFTER, TVITEM_LEVEL1, DMPUB_NONE,
    CTRLD_AFTER_ITEM, HELP_INDEX_CTRLD_AFTER,
    2, TVOT_2STATES,
    IDS_CPSUI_YES, IDI_CPSUI_YES,
    IDS_CPSUI_NO, IDI_CPSUI_NO,
    ITEM_INFO_SIGNATURE
};

static CONST WORD TrueGrayTextItemInfo[] =
{
    IDS_TRUE_GRAY_TEXT, TVITEM_LEVEL1, DMPUB_NONE,
    TRUE_GRAY_TEXT_ITEM, HELP_INDEX_TRUE_GRAY_TEXT,
    2, TVOT_2STATES,
    IDS_CPSUI_YES, IDI_CPSUI_YES,
    IDS_CPSUI_NO, IDI_CPSUI_NO,
    ITEM_INFO_SIGNATURE
};

static CONST WORD TrueGrayGraphItemInfo[] =
{
    IDS_TRUE_GRAY_GRAPH, TVITEM_LEVEL1, DMPUB_NONE,
    TRUE_GRAY_GRAPH_ITEM, HELP_INDEX_TRUE_GRAY_GRAPH,
    2, TVOT_2STATES,
    IDS_CPSUI_YES, IDI_CPSUI_YES,
    IDS_CPSUI_NO, IDI_CPSUI_NO,
    ITEM_INFO_SIGNATURE
};

static CONST WORD AddEuroItemInfo[] =
{
    IDS_ADD_EURO, TVITEM_LEVEL1, DMPUB_NONE,
    ADD_EURO_ITEM, HELP_INDEX_ADD_EURO,
    2, TVOT_2STATES,
    IDS_CPSUI_YES, IDI_CPSUI_YES,
    IDS_CPSUI_NO, IDI_CPSUI_NO,
    ITEM_INFO_SIGNATURE
};

static CONST WORD MinOutlineItemInfo[] =
{
    IDS_PSMINOUTLINE, TVITEM_LEVEL1, DMPUB_NONE,
    PSMINOUTLINE_ITEM, HELP_INDEX_PSMINOUTLINE,
    2, TVOT_UDARROW,
    IDS_PIXELS, IDI_USE_DEFAULT,
    0, 0,
    ITEM_INFO_SIGNATURE
};

static CONST WORD MaxBitmapItemInfo[] =
{
    IDS_PSMAXBITMAP, TVITEM_LEVEL1, DMPUB_NONE,
    PSMAXBITMAP_ITEM, HELP_INDEX_PSMAXBITMAP,
    2, TVOT_UDARROW,
    IDS_PIXELS, IDI_USE_DEFAULT,
    0, 0,
    ITEM_INFO_SIGNATURE
};

BOOL
_BPackPrinterOptions(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack driver-specific options (printer-sticky)

Arguments:

    pUiData - Points to a UIDATA structure

Return Value:

    TRUE for success and FALSE for failure

--*/

{
    PPRINTERDATA pPrinterData = pUiData->ci.pPrinterData;
    BOOL rc;

    //
    // Fill in the lower limit number of PrinterVMItemInfo
    // based on printer level.
    //

    PrinterVMItemInfo[10] = (pUiData->ci.pUIInfo->dwLangLevel <= 1 ? MIN_FREEMEM_L1 : MIN_FREEMEM_L2) / KBYTES;

    rc = BPackUDArrowItemTemplate(
                    pUiData,
                    PrinterVMItemInfo,
                    pPrinterData->dwFreeMem / KBYTES,
                    0x7fff, NULL) &&
         BPackPSProtocolItem(pUiData) &&
         BPackOptItemTemplate(
                    pUiData,
                    CtrlDBeforeItemInfo,
                    (pPrinterData->dwFlags & PFLAGS_CTRLD_BEFORE) ? 0 : 1, NULL) &&
         BPackOptItemTemplate(
                    pUiData,
                    CtrlDAfterItemInfo,
                    (pPrinterData->dwFlags & PFLAGS_CTRLD_AFTER) ? 0 : 1, NULL) &&
         BPackOptItemTemplate(
                    pUiData,
                    TrueGrayTextItemInfo,
                    (pPrinterData->dwFlags & PFLAGS_TRUE_GRAY_TEXT) ? 0 : 1, NULL) &&
         BPackOptItemTemplate(
                    pUiData,
                    TrueGrayGraphItemInfo,
                    (pPrinterData->dwFlags & PFLAGS_TRUE_GRAY_GRAPH) ? 0 : 1, NULL);
    if (!rc)
         return FALSE;

    if (pUiData->ci.pUIInfo->dwLangLevel > 1)
    {
        rc = BPackOptItemTemplate(
                    pUiData,
                    AddEuroItemInfo,
                    (pPrinterData->dwFlags & PFLAGS_ADD_EURO) ? 0 : 1, NULL);
        if (!rc)
            return FALSE;
    }

    return BPackUDArrowItemTemplate(
                    pUiData,
                    JobTimeoutItemInfo,
                    pPrinterData->dwJobTimeout,
                    0x7fff, NULL) &&
           BPackUDArrowItemTemplate(
                    pUiData,
                    WaitTimeoutItemInfo,
                    pPrinterData->dwWaitTimeout,
                    0x7fff, NULL) &&
           BPackUDArrowItemTemplate(
                    pUiData,
                    MinOutlineItemInfo,
                    pPrinterData->wMinoutlinePPEM,
                    0x7fff, NULL) &&
           BPackUDArrowItemTemplate(
                    pUiData,
                    MaxBitmapItemInfo,
                    pPrinterData->wMaxbitmapPPEM,
                    0x7fff, NULL);
}



VOID
_VUnpackDriverPrnPropItem(
    PUIDATA     pUiData,
    POPTITEM    pOptItem
    )

/*++

Routine Description:

    Unpack driver-specific printer property items

Arguments:

    pUiData - Points to our UIDATA structure
    pOptItem - Specifies the OPTITEM to be unpacked

Return Value:

    NONE

--*/

{
    PPRINTERDATA pPrinterData = pUiData->ci.pPrinterData;

    switch (GETUSERDATAITEM(pOptItem->UserData))
    {
    case PRINTER_VM_ITEM:

        if (pUiData->ci.dwFlags & FLAG_USER_CHANGED_FREEMEM)
        {
            pPrinterData->dwFreeMem = pOptItem->Sel * KBYTES;
        }
        break;

    case PSPROTOCOL_ITEM:

        switch (pOptItem->Sel)
        {
        case 1:
            pPrinterData->wProtocol = PROTOCOL_BCP;
            break;

        case 2:
            pPrinterData->wProtocol = PROTOCOL_TBCP;
            break;

        case 3:
            pPrinterData->wProtocol = PROTOCOL_BINARY;
            break;

        default:
            pPrinterData->wProtocol = PROTOCOL_ASCII;
            break;
        }
        break;

    case CTRLD_BEFORE_ITEM:

        if (pOptItem->Sel == 0)
            pPrinterData->dwFlags |= PFLAGS_CTRLD_BEFORE;
        else
            pPrinterData->dwFlags &= ~PFLAGS_CTRLD_BEFORE;
        break;

    case CTRLD_AFTER_ITEM:

        if (pOptItem->Sel == 0)
            pPrinterData->dwFlags |= PFLAGS_CTRLD_AFTER;
        else
            pPrinterData->dwFlags &= ~PFLAGS_CTRLD_AFTER;
        break;


    case TRUE_GRAY_TEXT_ITEM:

        if (pOptItem->Sel == 0)
            pPrinterData->dwFlags |= PFLAGS_TRUE_GRAY_TEXT;
        else
            pPrinterData->dwFlags &= ~PFLAGS_TRUE_GRAY_TEXT;
        break;
    case TRUE_GRAY_GRAPH_ITEM:

        if (pOptItem->Sel == 0)
            pPrinterData->dwFlags |= PFLAGS_TRUE_GRAY_GRAPH;
        else
            pPrinterData->dwFlags &= ~PFLAGS_TRUE_GRAY_GRAPH;
        break;


    case ADD_EURO_ITEM:

        if (pOptItem->Sel == 0)
            pPrinterData->dwFlags |= PFLAGS_ADD_EURO;
        else
            pPrinterData->dwFlags &= ~PFLAGS_ADD_EURO;

        pPrinterData->dwFlags |= PFLAGS_EURO_SET;
        break;


    case PSMINOUTLINE_ITEM:

        pPrinterData->wMinoutlinePPEM = (WORD) pOptItem->Sel;
        break;

    case PSMAXBITMAP_ITEM:

        pPrinterData->wMaxbitmapPPEM = (WORD) pOptItem->Sel;
        break;
    }
}



BOOL
BUpdateModelNtfFilename(
    PCOMMONINFO pci
    )

/*++

Routine Description:

    Save model-specific NTF filename under PrinterDriverData registry key
    for compatibility with the new NT4 driver.

Arguments:

    pci - Points to basic printer information

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    //
    // Get the list of driver dependent files and
    // save it in registry for NT4 compatibility
    //

    PTSTR  ptstr, ptstrNext, ptstrDependentFiles, ptstrCopy, ptstrFileNamesWithoutPath;
    DWORD  dwCharCount = 0;
    BOOL   bResult;

    if ((ptstrDependentFiles = pci->pDriverInfo3->pDependentFiles) == NULL)
    {
        return BSetPrinterDataString(pci->hPrinter,
                                     REGVAL_DEPFILES,
                                     ptstrDependentFiles,
                                     REG_MULTI_SZ);
    }

    //
    // First pass of the MULTI_SZ string to get file names char count
    //

    while (*ptstrDependentFiles != NUL)
    {
        //
        // Go the end of current string
        //

        ptstr = ptstrDependentFiles + _tcslen(ptstrDependentFiles);
        ptstrNext = ptstr + 1;

        dwCharCount++;      // for the NUL char of current string

        //
        // Search backward for '\' path separator
        //

        while (--ptstr >= ptstrDependentFiles)
        {
            if (*ptstr == TEXT(PATH_SEPARATOR))
            {
                break;
            }

            dwCharCount++;
        }

        ptstrDependentFiles = ptstrNext;
    }

    dwCharCount++;      // for the last NUL of the MULTI_SZ string

    if ((ptstrFileNamesWithoutPath = MemAllocZ(dwCharCount * sizeof(TCHAR))) == NULL)
    {
        ERR(("Memory allocation failed\n"));
        return FALSE;
    }

    //
    // Second pass of the MULTI_SZ string to copy the file names
    //

    ptstrDependentFiles = pci->pDriverInfo3->pDependentFiles;
    ptstrCopy = ptstrFileNamesWithoutPath;

    while (*ptstrDependentFiles != NUL)
    {
        INT     iNameLen;

        //
        // Go the end of current string
        //

        ptstr = ptstrDependentFiles + _tcslen(ptstrDependentFiles);
        ptstrNext = ptstr + 1;

        //
        // Search backward for '\' path separator
        //

        while (--ptstr >= ptstrDependentFiles)
        {
            if (*ptstr == TEXT(PATH_SEPARATOR))
            {
                break;
            }
        }

        ptstr++;    // point to the char after '\'

        iNameLen = _tcslen(ptstr);

        CopyMemory(ptstrCopy, ptstr, iNameLen * sizeof(TCHAR));
        ptstrCopy += iNameLen + 1;

        ptstrDependentFiles = ptstrNext;
    }

    bResult = BSetPrinterDataString(pci->hPrinter,
                                    REGVAL_DEPFILES,
                                    ptstrFileNamesWithoutPath,
                                    REG_MULTI_SZ);

    MemFree(ptstrFileNamesWithoutPath);

    return bResult;
}



#ifdef WINNT_40

BOOL
BUpdateVMErrorMessageID(
        PCOMMONINFO pci
        )
/*++

Routine Description:

        Save the VM Error message ID calculated from the current user's locale
        under PrinterDriverData registry key.

Arguments:

        pci - Points to basic printer information

Return Value:

        TRUE if successful, FALSE if there is an error

--*/

{
        DWORD dwVMErrorMessageID = DWGetVMErrorMessageID();

        return BSetPrinterDataDWord(pci->hPrinter,
                                                                 REGVAL_VMERRORMESSAGEID,
                                                                 dwVMErrorMessageID);
}

#endif // WINNT_40


INT
_IListDevFontNames(
    HDC     hdc,
    PWSTR   pwstrBuf,
    INT     iSize
    )

{
    DWORD dwParam = QUERY_FAMILYNAME;

    //
    // Ask the driver graphics module for the list of permanant device fonts
    //

    return ExtEscape(hdc,
                     DRIVERESC_QUERY_DEVFONTS,
                     sizeof(dwParam),
                     (PCSTR) &dwParam,
                     iSize,
                     (PSTR) pwstrBuf);
}


INT_PTR CALLBACK
_AboutDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    Procedure for handling "Printer Properties" proerty sheet page

Arguments:

    hDlg - Identifies the property sheet page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    PUIDATA pUiData;
    PWSTR   pPpdFilename;
    CHAR    achBuf[64]  = {0};
    CHAR    achMsg[136] = {0};
    PPDDATA *pPpdData;

    switch (message)
    {
    case WM_INITDIALOG:

        //
        // Initialize the About dialog box
        //

        pUiData = (PUIDATA) lParam;
        ASSERT(VALIDUIDATA(pUiData));

        if (LoadStringA(ghInstance, IDS_PS_VERSION, achBuf, sizeof(achBuf) - 1))
        {
            #ifdef WINNT_40

            if (_snprintf(achMsg, sizeof(achMsg) - 1, "%s (" VER_54DRIVERVERSION_STR ")", achBuf) < 0)

            #else  // WINNT_40
            
            if (_snprintf(achMsg, sizeof(achMsg) - 1, "%s (" VER_PRODUCTVERSION_STR ")", achBuf) < 0)

            #endif  // WINNT_40
            {
                WARNING(("Device Settings About box version string truncated.\n"));
            }
        }
        else
        {
            WARNING(("Device Setting About box attempt to load version string failed.\n"));
        }

        SetDlgItemTextA(hDlg, IDC_WINNT_VER, achMsg);

        SetDlgItemText(hDlg, IDC_MODELNAME, pUiData->ci.pDriverInfo3->pName);

        if (pPpdFilename = pUiData->ci.pDriverInfo3->pDataFile)
        {
            if (pPpdFilename = wcsrchr(pPpdFilename, TEXT(PATH_SEPARATOR)))
                pPpdFilename++;
            else
                pPpdFilename = pUiData->ci.pDriverInfo3->pDataFile;

            SetDlgItemText(hDlg, IDC_PPD_FILENAME, pPpdFilename);

            pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER(pUiData->ci.pInfoHeader);

            ASSERT(pPpdData != NULL);

            sprintf(achBuf, "%d.%d", HIWORD(pPpdData->dwPpdFilever), LOWORD(pPpdData->dwPpdFilever));
            SetDlgItemTextA(hDlg, IDC_PPD_FILEVER, achBuf);
        }

        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
        case IDCANCEL:

            EndDialog(hDlg, LOWORD(wParam));
            return TRUE;
        }
        break;
    }

    return FALSE;
}




//
// Determine whether the printer supports stapling
//

BOOL
_BSupportStapling(
    PCOMMONINFO pci
    )

{
    PFEATURE pFeature, pFeatureY;
    DWORD    dwIndex;
    BOOL     bStapleFeatureExist = FALSE;

    //
    // Except for *StapleOrientation (whose None option doesn't mean stapling off),
    // if any of following stapling keywords appear in the PPD file, we check if that
    // feature is supported with current installable option selections.
    //
    // *StapleLocation
    // *StapleX
    // *StapleY
    // *StapleWhen
    //
    // PPD spec says that a PPD file can contain either *StapleLocation or
    // *StapleX and *StapleY but not both.
    //

    if (pFeature = PGetNamedFeature(pci->pUIInfo, "StapleLocation", &dwIndex))
    {
        bStapleFeatureExist = TRUE;

        if (!_BSupportFeature(pci, GID_UNKNOWN, pFeature))
        {
            return FALSE;
        }
    }
    else if ( (pFeature = PGetNamedFeature(pci->pUIInfo, "StapleX", &dwIndex)) &&
              (pFeatureY = PGetNamedFeature(pci->pUIInfo, "StapleY", &dwIndex)) )
    {
        bStapleFeatureExist = TRUE;

        if (!_BSupportFeature(pci, GID_UNKNOWN, pFeature) ||
            !_BSupportFeature(pci, GID_UNKNOWN, pFeatureY))
        {
            return FALSE;
        }
    }

    if (pFeature = PGetNamedFeature(pci->pUIInfo, "StapleWhen", &dwIndex))
    {
        bStapleFeatureExist = TRUE;

        if (!_BSupportFeature(pci, GID_UNKNOWN, pFeature))
        {
            return FALSE;
        }
    }

    //
    // We didn't find any constraints on the stapling features caused by installable options,
    // so we will assume the printer can support stapling if any of the standard PPD stapling
    // keywords are present.
    //

    return bStapleFeatureExist ||
           PGetNamedFeature(pci->pUIInfo, "StapleOrientation", &dwIndex) != NULL;
}




BOOL
BFeatureIsConstrained(
    PUIINFO  pUIInfo,
    PFEATURE pFeature,
    DWORD    dwFeatureIndex,
    DWORD    dwOptionCount,
    DWORD    dwConstraintList,
    PBYTE    aubConstrainedOption,
    DWORD    dwGid
    )

/*++

Routine Description:

    Determine whether the particular constraint list constrains feature options.

Arguments:

    pUIInfo - Points to a UIINFO structure
    pFeature - Points to feature structure to be checked whether constraint or not
    dwFeatureIndex - index for the  feature
    dwOptionCount - number of options for the feature
    dwConstraintList - Specifies the constraint list to be searched
    aubConstrainedOption - Byte array of option constrained flag
    dwGid - GID_DUPLEX, GID_COLLATE or GID_UNKNOWN to allow feature specific don't cares

Return Value:

    TRUE if the feature is constrained by the constraint list, FALSE otherwise.

--*/

{
    POPTION  pOption;
    DWORD    dwOptionIndex;

    ASSERT(dwOptionCount < MAX_PRINTER_OPTIONS);

    if (dwConstraintList == NULL_CONSTRAINT)
        return FALSE;

    for (dwOptionIndex = 0; dwOptionIndex < dwOptionCount; dwOptionIndex++)
    {
        pOption = PGetIndexedOption(pUIInfo, pFeature, dwOptionIndex);

        ASSERT(pOption != NULL);

        switch(dwGid)
        {
        case GID_COLLATE:

            //
            // don't care about constraints for no-collate
            //

            if (((PCOLLATE) pOption)->dwCollateID == DMCOLLATE_FALSE)
                continue;
            break;

        case GID_DUPLEX:

            //
            // don't care about constraints for non-duplex
            //

            if (((PDUPLEX) pOption)->dwDuplexID == DMDUP_SIMPLEX)
                continue;
            break;

        case GID_UNKNOWN:
        default:

            //
            // skip the check for None/False option
            //

            if (pFeature->dwNoneFalseOptIndex == dwOptionIndex)
                continue;
            break;
        }

        if (BSearchConstraintList(pUIInfo, dwConstraintList,
                                  dwFeatureIndex, dwOptionIndex))
        {
            aubConstrainedOption[dwOptionIndex] = 1;
        }

        //
        // If one option is unconstrained, the feature is not constrained by the
        // constraint list
        //
        if (!aubConstrainedOption[dwOptionIndex])
            return FALSE;
    }

    return TRUE;
}


BOOL
_BSupportFeature(
    PCOMMONINFO pci,
    DWORD       dwGid,
    PFEATURE    pFeatureIn
    )

/*++

Routine Description:

    Determine whether the printer supports a feature based on current printer-sticky
    feature selections.

Arguments:

    pci - Points to basic printer information
    dwGid - the GID of the feature to check for constraints. (currently only GID_COLLATE or GID_DUPLEX
            if pFeatureIn is NULL)
    pFeatureIn - pointer to the feature structure if the feature doesn't have predefined GID_xxx value

Return Value:

    TRUE if feature can be supported, FALSE otherwise.

--*/

{
    POPTSELECT pCombinedOptions = pci->pCombinedOptions;
    PUIINFO  pUIInfo = pci->pUIInfo;
    PFEATURE pCheckFeature, pFeature;
    POPTION  pOption;
    BYTE     aubConstrainedOption[MAX_PRINTER_OPTIONS];
    DWORD    dwCheckFeatureIndex, dwCheckOptionCount;
    DWORD    dwFeatureIndex;
    BYTE     ubCurOptIndex, ubNext;

    if (!pCombinedOptions)
        return FALSE;

    if (pFeatureIn)
    {
        //
        // If the input feature pointer is provided, dwGid should be GID_UNKNOWN.
        //

        ASSERT(dwGid == GID_UNKNOWN);

        pCheckFeature = pFeatureIn;
    }
    else
    {
        //
        // If no input feature pointer, use dwGid to find the feature. dwGid should be
        // either GID_DUPLEX or GID_COLLATE.
        //

        ASSERT((dwGid == GID_DUPLEX) || (dwGid == GID_COLLATE));

        if (!(pCheckFeature = GET_PREDEFINED_FEATURE(pUIInfo, dwGid)))
            return FALSE;
    }

    dwCheckFeatureIndex = GET_INDEX_FROM_FEATURE(pUIInfo, pCheckFeature);

    dwCheckOptionCount = pCheckFeature->Options.dwCount;

    //
    // Mark all options of the checked feature as non-constrained.
    //

    memset(aubConstrainedOption, 0, sizeof(aubConstrainedOption));

    //
    // Scan the feature list to check if it will be constrained by current selections
    //

    if (!(pFeature = OFFSET_TO_POINTER(pUIInfo->pInfoHeader, pUIInfo->loFeatureList)))
        return FALSE;

    //
    // We only care about printer-sticky features
    //

    pFeature += pUIInfo->dwDocumentFeatures;

    for (dwFeatureIndex = pUIInfo->dwDocumentFeatures;
         dwFeatureIndex < pUIInfo->dwDocumentFeatures + pUIInfo->dwPrinterFeatures;
         dwFeatureIndex++, pFeature++)
    {
         //
         // If the feature's current selection is not None/False, it may constrain the checked feature
         //

         if ((DWORD)pCombinedOptions[dwFeatureIndex].ubCurOptIndex != pFeature->dwNoneFalseOptIndex)
         {
             if (BFeatureIsConstrained(pUIInfo, pCheckFeature, dwCheckFeatureIndex, dwCheckOptionCount,
                                       pFeature->dwUIConstraintList, aubConstrainedOption, dwGid))
                 return FALSE;
         }

         ubNext = (BYTE)dwFeatureIndex;
         while (1)
         {
             ubCurOptIndex = pCombinedOptions[ubNext].ubCurOptIndex;
             pOption = PGetIndexedOption(pUIInfo, pFeature, ubCurOptIndex == OPTION_INDEX_ANY ? 0 : ubCurOptIndex);

             if (pOption && BFeatureIsConstrained(pUIInfo, pCheckFeature, dwCheckFeatureIndex, dwCheckOptionCount,
                                                  pOption->dwUIConstraintList, aubConstrainedOption, dwGid))
                 return FALSE;

             if ((ubNext = pCombinedOptions[ubNext].ubNext) == NULL_OPTSELECT)
                 break;
         }
    }

    //
    // No constraints found, so the feature can be supported.
    //

    return TRUE;
}


VOID
VSyncRevPrintAndOutputOrder(
    PUIDATA    pUiData,
    POPTITEM   pCurItem
    )

/*++

Routine Description:

    For PostScript driver, PPD could have "*OpenUI *OutputOrder", which enables user to
    select "Normal" or "Reverse" output order. In order to avoid spooler performing reverse
    printing simulation, we will ssync up option selections between REVPRINT_ITEM and
    "OutputOrder".

Arguments:

    pUiData - Pointer to UIDATA structure
    pCurItem - Pointer to currently selected option item. It will be non-NULL for
               REVPRINT_ITEM, and will be NULL otherwise.

Return Value:

    None.

--*/

{
    PUIINFO   pUIInfo;
    PPPDDATA  pPpdData;
    PFEATURE  pFeature;
    POPTION   pOption;
    PCSTR     pstrKeywordName;
    POPTITEM  pRevPrintItem, pOutputOrderItem;
    BOOL      bReverse;

    ASSERT(VALIDUIDATA(pUiData));

    pUIInfo = pUiData->ci.pUIInfo;

    pPpdData = GET_DRIVER_INFO_FROM_INFOHEADER((PINFOHEADER)pUiData->ci.pRawData);

    ASSERT(pPpdData != NULL);

    if (pPpdData->dwOutputOrderIndex != INVALID_FEATURE_INDEX &&
        (pOutputOrderItem = PFindOptItemWithKeyword(pUiData, "OutputOrder")) &&
        pOutputOrderItem->Sel < 2 &&
        (pFeature = PGetIndexedFeature(pUIInfo, pPpdData->dwOutputOrderIndex)) &&
        (pOption = PGetIndexedOption(pUIInfo, pFeature, pOutputOrderItem->Sel)) &&
        (pstrKeywordName = OFFSET_TO_POINTER(pUIInfo->pubResourceData, pOption->loKeywordName)))
    {
        //
        // "OutputOrder" feature is available.
        //

        if (strcmp(pstrKeywordName, "Reverse") == EQUAL_STRING)
            bReverse = TRUE;
        else
            bReverse = FALSE;

        if (pCurItem)
        {
            //
            // Currently selected item is REVPRINT_ITEM. We should change "OutputOrder" option
            // if needed to match the requested output order.
            //

            if ((pCurItem->Sel == 0 && bReverse) || (pCurItem->Sel == 1 && !bReverse))
            {
                pOutputOrderItem->Sel = 1 - pOutputOrderItem->Sel;
                pOutputOrderItem->Flags |= OPTIF_CHANGED;

                //
                // Save the new settings in the options array
                //

                VUnpackDocumentPropertiesItems(pUiData, pOutputOrderItem, 1);

                //
                // The change could trigger constraints.
                //

                if (ICheckConstraintsDlg(pUiData, pOutputOrderItem, 1, FALSE) == CONFLICT_CANCEL)
                {
                    //
                    // If there is a conflict and the user clicked CANCEL,
                    // we need to restore the origianl selection.
                    //

                    pCurItem->Sel = 1 - pCurItem->Sel;
                    pCurItem->Flags |= OPTIF_CHANGED;

                    VUnpackDocumentPropertiesItems(pUiData, pCurItem, 1);

                    pOutputOrderItem->Sel = 1 - pOutputOrderItem->Sel;
                    pOutputOrderItem->Flags |= OPTIF_CHANGED;

                    VUnpackDocumentPropertiesItems(pUiData, pOutputOrderItem, 1);
                }
            }
        }
        else
        {
            //
            // Sync up REVPRINT_ITEM selection based on "OutputOrder" selection.
            //

            if ((pRevPrintItem = PFindOptItemWithUserData(pUiData, REVPRINT_ITEM)) &&
                ((pRevPrintItem->Sel == 0 && bReverse) || (pRevPrintItem->Sel == 1 && !bReverse)))
            {
                pRevPrintItem->Sel = 1 - pRevPrintItem->Sel;
                pRevPrintItem->Flags |= OPTIF_CHANGED;

                //
                // Save the new settings in the options array
                //

                VUnpackDocumentPropertiesItems(pUiData, pRevPrintItem, 1);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\driverui\uni\precomp.h ===
#include "lib.h"
#include <commctrl.h>
#include <winddiui.h>
#include <printoem.h>
#include <prntfont.h>
#include "oemutil.h"
#include "unilib.h"
#include "gpd.h"
#include "uires.h"
#include "uihelp.h"
#include "driverui.h"
#include "oemui.h"
#include "fmoldfm.h"
#include "fontinst.h"
#include "softfont.h"
#include "osff.h"
#include "winres.h"
#include <prcomoem.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\driverui\uni\softfont.c ===
/****************************Module*Header******************************\
* Module Name: SOFTFONT.C
*
* Module Descripton:
 *      Functions associated with PCL softfonts.  These are fonts which are
 *      downloaded into the printer.  We read those files and interpre the
 *      information contained therein.  This happens during font installation
 *      time,  so that when in use,  this information is in the format
 *      required by the driver.
*
* Warnings:
*
* Issues:
*
* Copyright (c) 1996, 1997  Microsoft Corporation
\***********************************************************************/

#include "precomp.h"


/*
 *   A macro to swap the bytes around:  we then get them in little endian
 * order from the big endian 68000 format.
 */

#define SWAB( x )       ((WORD)(x) = (WORD)((((x) >> 8) & 0xff) | (((x) << 8) & 0xff00)))


#define BBITS   8               /* Bits in a byte */


/*
 *   Define the values returned from the header checking code.  The
 * function is called to see what is next in the file,  and so we
 * can determine that the file is in an order we understand.
 */

#define TYPE_INDEX      0       /* Character index record follows */
#define TYPE_HEADER     1       /* Character header */
#define TYPE_CONT       2       /* Continuation record */
#define TYPE_INVALID    3       /* Unexpected sequence */

/*
 *   The structure and data for matching symbol sets with translation tables.
 */

typedef  struct
{
    WORD    wSymSet;            /* Symbol set encoded in file */
    short   sCTT;               /* Translation table index */
} CTT_MAP;

/*
 *   Note about this table:  we do not include the generic7 ctt,  this simply
 * maps glyphs 128 - 255 to 0x7f. Since we only use the glyphs available
 * in the font,  and these we discover from the file, we have no need of
 * this type since we will map such chars because of the wcLastChar in
 * the IFIMETRICS!
 */

static   const  CTT_MAP  CttMap[] =
{
    { 277,  2 },                /* Roman 8 */
    { 269,  4 },                /* Math 8 */
    { 21,   5 },                /* US ASCII */
    { 14,  19 },                /* ECMA-94 */
    { 369, 20 },                /* Z1A - variety of ECMA-94, ss = 11Q */
};

#define NUM_CTTMAP      (sizeof( CttMap ) / sizeof( CttMap[ 0 ] ))


/*
 *   The bClass field mapping table:  maps from values in bClass parameter
 *  to bits in the dwSelBits field.
 */

static  const  DWORD  dwClassMap[] =
{
    FDH_BITMAP,         /* A bitmap font */
    FDH_COMPRESSED,     /* A compressed bitmap */
    FDH_CONTOUR,        /* A contour font (Intellifont special) */
    FDH_CONTOUR,        /* A compressed contour font: presume as above */
};

#define MAX_CLASS_MAP   (sizeof( dwClassMap ) / sizeof( dwClassMap[ 0 ] ))

/*
 *    Typeface to name index.   Comes from the LaserJet III technical manual.
 */

static const WCHAR  *pwcName[] =
{
    L"Line Printer",
    L"Pica",
    L"Elite",
    L"Courier",
    L"Helv" ,
    L"TmsRmn",
    L"Letter Gothic",
    L"Script",
    L"Prestige",
    L"Caslon",
    L"Orator",
    L"Presentations",
    L"Helv Cond",
    L"Serifa",
    L"Futura",
    L"Palatino",
    L"ITC Souvenir",
    L"Optima",
    L"Garamond",
    L"Cooper Black",
    L"Coronet Bold",
    L"Broadway",
    L"Bauer Bodoni Black Condensed",
    L"Century Schoolbook",
    L"University Roman",
    L"Helvetica Outline",
    L"Futura Condensed",
    L"ITC Korinna",
    L"Naskh",
    L"Cloister Black",
    L"ITC Galliard",
    L"ITC Avant Garde Gothic",
    L"Brush",
    L"Blippo",
    L"Hobo",
    L"Windsor",
    L"Helvetica Compressed",
    L"Helvetica Extra Compressed",
    L"Peignot",
    L"Baskerville",
    L"ITC Garamond Condensed",
    L"Trade Gothic",
    L"Goudy Old Style",
    L"ITC Zapf Chancery",
    L"Clarendon",
    L"ITC Zapf Dingbats",
    L"Cooper",
    L"ITC Bookman",
    L"Stick",
    L"HP-GL Drafting",
    L"HP-GL Spline",
    L"Gill Sans",
    L"Univers",
    L"Bodoni",
    L"Rockwell",
    L"Mellior",
    L"ITC Tiffany",
    L"ITC Clearface",
    L"Amelia",
    L"Park Avenue",
    L"Handel Gothic",
    L"Dom Casual",
    L"ITC Benguiat",
    L"ITC Cheltenham",
    L"Century Expanded",
    L"Franklin Gothic",
    L"Franklin Gothic Expressed",
    L"Frankiln Gothic Extra Condensed",
    L"Plantin",
    L"Trump Mediaeval",
    L"Futura Black",
};

#define NUM_TYPEFACE    (sizeof( pwcName ) / sizeof( pwcName[ 0 ] ))


BOOL   bWrite( HANDLE, void  *, int );

/*
 *    Local function prototypes.
 */


BYTE  *pbReadSFH( BYTE *, SF_HEADER * );
BYTE  *pbReadIndex( BYTE *, int * );
BYTE  *pbReadCHH( BYTE *, CH_HEADER *, BOOL );
int    iNextType( BYTE * );
PWSTR  strcpy2WChar( PWSTR, LPSTR );
DWORD  FICopy(HANDLE, HANDLE);
int   iWriteFDH( HANDLE, FI_DATA * );
BOOL   bWrite( HANDLE, void  *, int );

/*  SoftFont to NT conversion functions */

IFIMETRICS  *SfhToIFI( SF_HEADER *, HANDLE, PWSTR );


#if  PRINT_INFO
/*
 *    Print out the IFIMETRICS results!
 */
typedef VOID (*VPRINT) (char*,...);


VOID
vPrintIFIMETRICS(
    IFIMETRICS *pifi,
    VPRINT vPrint
    );

#endif

/****************************** Function Header ***************************
 * bSFontToFontMap
 *      Read in a PCL softfont file and generate all the fontmap details
 *      The file contains a header with general font information, followed
 *      by an array of entries, one per glyph, each of which contains a
 *      header with per glyph data such as char width.
 *
 * RETURNS:
 *      TRUE/FALSE,  TRUE for success.
 *
 * HISTORY:
 *  09:54 on Wed 19 Feb 1992    -by-    Lindsay Harris   [lindsayh]
 *      First incarnation.
 *
 ***************************************************************************/

BOOL
bSFontToFIData( pFIDat, hheap, pbFile, dwSize )
FI_DATA   *pFIDat;                 /* FI_DATA with all the important stuff! */
HANDLE     hheap;               /* For storage allocation */
BYTE      *pbFile;              /* Mmemory mapped file with the softfont */
DWORD      dwSize;              /* Number of bytes in the file */
{

    int        iVal;            /* Character code from file */
    int        iI;              /* Loop index */
    int        iType;           /* Record type that we have */

    int        iMaxWidth;       /* Widest glyph we found */
    int        iWidth;          /* For calculating the average width */
    int        cGlyphs;         /* For the above */

    SF_HEADER  sfh;             /* Header information */
    CH_HEADER  chh;             /* Per glyph information */

    BYTE      *pbEnd;

    WCHAR     *pwch;            /* Points to font name to display */

    IFIMETRICS *pIFI;

    WCHAR      awchTemp[ 128 ]; /* For building up the name to show user */



    pbEnd = pbFile + dwSize;                    /* Last byte + 1 */
    ZeroMemory( pFIDat, sizeof( FI_DATA ) );

    if( (pbFile = pbReadSFH( pbFile, &sfh )) == 0 )
        return  FALSE;          /* No go - presume wrong format */

    pFIDat->dsIFIMet.pvData = pIFI = SfhToIFI( &sfh, hheap, L"PCL_SF" );

    if( pIFI == 0 )
        return  FALSE;

    pFIDat->dsIFIMet.cBytes = pIFI->cjThis;

    if( sfh.bSpacing )
    {
        /*
         *   Allocate space for the width table,  if there is to be one.
         * Only proportionally spaced fonts have this luxury!
         */

        iI = (pIFI->chLastChar - pIFI->chFirstChar + 1) * sizeof( short );

        if( !(pFIDat->dsWidthTab.pvData = (short *)HEAPALLOC( hheap, iI )) )
        {
            HeapFree( hheap, 0, (LPSTR)pIFI );

            return  FALSE;
        }
        pFIDat->dsWidthTab.cBytes = iI;

        ZeroMemory( pFIDat->dsWidthTab.pvData, iI );   /* Zero the width table */
    }
    /*  Else clause not required,  since the structure is initialised to 0 */

    /*
     *    Generate an ID string for this font.  The ID string is displayed
     *  in UI components,  so we use the font name + point size.  The + 15 s
     *  allows for the string "%d Pt" at the end of the name.
     */


    /*
     *   If the typeface field gives us a name,  then we should display that
     *  one to the user.  We check to see if the value is within range,
     *  and use the pointer value if so.  Note that this pointer is NULL
     *  for an unknown name,  so we need to check that we end up pointing
     *  at something!
     */

    pwch = NULL;             /*  Means have not found one,  yet */

    if( sfh.bTypeface >= 0 && sfh.bTypeface < NUM_TYPEFACE )
    {
        /*    We have the "proper" name for this one!  */
        (const WCHAR *)pwch = pwcName[ sfh.bTypeface ];
    }

    if( pwch == NULL )
    {
        /*    Use the name supplied */
        pwch = (WCHAR *)((BYTE *)pIFI + pIFI->dpwszFaceName);
    }
    else
    {
        /*  Use the "standard" name we found above, and add StyleName  */
        wcscpy( awchTemp, pwch );              /* Standard name */
        pwch = (WCHAR *)((BYTE *)pIFI + pIFI->dpwszStyleName);
        if( *pwch )
        {
            wcscat( awchTemp, L" " );
            wcscat( awchTemp, pwch );
        }
        pwch = awchTemp;
    }

    /*   Allocate the storage we need */

    iI = (15 + wcslen( pwch )) * sizeof( WCHAR );

    if( !(pFIDat->dsIdentStr.pvData = HEAPALLOC( hheap, iI )) )
    {
        HeapFree( hheap, 0, (LPSTR)pIFI );
        HeapFree( hheap, 0, pFIDat->dsWidthTab.pvData );

        return  FALSE;
    }

    pFIDat->dsIdentStr.cBytes = iI;

    /*   Calculate point size,  to nearest quarter point */

    iI = 25 * (((pIFI->fwdWinAscender + pIFI->fwdWinDescender) * 72 * 4 + 150)
                                                                        / 300);

    wsprintf( pFIDat->dsIdentStr.pvData, L"%ws %d.%0d Pt", pwch, iI / 100,
                                                                  iI % 100 );

    /*
     *   Set the landscape/portrait selection bits.
     */

    pFIDat->dwSelBits |= sfh.bOrientation ? FDH_LANDSCAPE : FDH_PORTRAIT;

    /*
     *    Loop through the remainder of the file processing whatever
     *  glyphs we discover.  Process means read the header to determine
     *  widths etc.
     */


    iMaxWidth = 0;
    iWidth = 0;
    cGlyphs = 0;

    while( pbFile < pbEnd )
    {
        /*   First step is to find the character index for this glyph */

        short   sWidth;                        /* Width in integral pels */


        iType = iNextType( pbFile );

        if( iType == TYPE_INVALID )
            return  FALSE;                      /* Cannot use this one */

        if( iType == TYPE_INDEX )
        {
            if( !(pbFile = pbReadIndex( pbFile, &iVal )) )
                return   FALSE;

            if( iVal < 0 )
                break;                  /* Illegal value: assume EOF */

            continue;                   /* Onwards & upwards */
        }


        if( !(pbFile = pbReadCHH( pbFile, &chh, iType == TYPE_CONT )) )
            return  FALSE;

        if( iType == TYPE_CONT )
            continue;                   /* Nothing else to do! */

        if( chh.bFormat == CH_FM_RASTER )
            pFIDat->dwSelBits |= FDH_BITMAP;
        else
        {
            if( chh.bFormat == CH_FM_SCALE )
                pFIDat->dwSelBits |= FDH_SCALABLE;
        }

        if( chh.bClass >= 1 && chh.bClass <= MAX_CLASS_MAP )
        {
            pFIDat->dwSelBits |= dwClassMap[ chh.bClass - 1 ];
        }
        else
        {
            /*
             *  Not a format we understand - yet!
             */

#if PRINT_INFO
            DbgPrint( "...Not our format: Format = %d, Class = %d\n",
                                                 chh.bFormat, chh.bClass );
#endif
            HeapFree( hheap, 0, (LPSTR)pIFI );

            return  FALSE;
        }

        /*
         *   If this is a valid glyph,  then we may want to record its
         * width (if proportionally spaced) and we are also interested
         * in some of the cell dimensions too!
         */

        if( iVal >= (int)pIFI->chFirstChar && iVal <= (int)pIFI->chLastChar &&
            (sfh.bFontType != PCL_FT_8LIM || (iVal <= 127 || iVal >= 160)) )
        {
            /*  Is valid for this font,  so process it.  */

            sWidth = (chh.wDeltaX + 2) / 4;     /* PCL in quarter dots */

            if( pFIDat->dsWidthTab.pvData )
                *((short *)pFIDat->dsWidthTab.pvData + iVal - pIFI->chFirstChar) =
                                                                 sWidth;

            if( sWidth > (WORD)iMaxWidth )
                iMaxWidth = sWidth;     /* Bigger & better */

            /*   Accumulate the averages */
            iWidth += sWidth;
            cGlyphs++;
        }
    }
    /*
     *   Most softfonts do not include the space char!  SO, we check to
     * see if it's width is zero.  If so,  we use the wPitch field to
     * calculate the HMI (horizontal motion index) and hence the width
     * of the space char.
     */

    iVal = ' ' - pIFI->chFirstChar;     /* Offset of space in width array */

    if( pFIDat->dsWidthTab.pvData &&
        *((short *)pFIDat->dsWidthTab.pvData + iVal) == 0 )
    {
        /*
         *  Zero width space,  so fill it in now.  The HMI is determined
         * from the pitch in the font header,  so we use that to
         * evaluate the size.  The pitch is in 0.25 dot units, so
         * round it to the nearest numbr of dots.
         */
        *((short *)pFIDat->dsWidthTab.pvData + iVal) = (short)((sfh.wPitch + 2) / 4);
        cGlyphs++;
        iWidth += (sfh.wPitch + 2) / 4;
    }

    /*
     *   A slight amendment to the IFIMETRICS.  We calculate the average
     *  width,  given the character data we have read!
     */

    if( cGlyphs > 0 )
    {
        pIFI->fwdAveCharWidth = (iWidth + cGlyphs / 2) / cGlyphs;
    }

    if( iMaxWidth > 0 )
    {
        pIFI->fwdMaxCharInc = (short)iMaxWidth;
    }
#if PRINT_INFO
    /*
     *    Print out the IFIMETRICS for this font - debugging is easier!
     */

    vPrintIFIMETRICS( pIFI, (VPRINT)DbgPrint );

#endif
    /*
     *   Set up the relevant translation table.  This is based on the
     * symbol set of the font.  We use a lookup table to scan and match
     * the value from those we have.  If outside the range, set to no
     * translation.  Not much choice here.
     */


    for( iI = 0; iI < NUM_CTTMAP; ++iI )
    {
        if( CttMap[ iI ].wSymSet == sfh.wSymSet )
        {
            /*   Bingo!  */
            pFIDat->dsCTT.cBytes = CttMap[ iI ].sCTT;
            break;
        }
    }

    /*  The following are GROSS assumptions!! */

    pFIDat->wXRes = 300;
    pFIDat->wYRes = 300;


    return  TRUE;
}

/***************************** Function Header *****************************
 * pbReadSFH
 *      Read a PCL SoftFont header and fill in the structure passed to us.
 *      The file is presumed mapped into memory, and that it's address
 *      is passed to us.  We return the address of the first byte past
 *      the header we process.
 *
 * RETURNS:
 *      Address of next location if OK,  else 0 for failure (bad format).
 *
 * HISTORY:
 *  11:01 on Wed 19 Feb 1992    -by-    Lindsay Harris   [lindsayh]
 *      Numero uno.
 *
 ****************************************************************************/

BYTE  *
pbReadSFH( pbFile, psfh )
BYTE       *pbFile;             /* THE file */
SF_HEADER  *psfh;               /* Where the data goes */
{


    int     iSize;              /* Determine header size */


    /*
     *   The file should start off with \033)s...W   where ... is a decimal
     * ASCII count of the number of bytes following.  This may be larger
     * than the size of the SF_HEADER.
     */

    if( *pbFile++ != '\033' || *pbFile++ != ')' || *pbFile++ != 's' )
    {
#if PRINT_INFO
        DbgPrint( "Rasdd!pbReadSFH: bad file - first 2 bytes\n" );
#endif
        return   0;
    }

    /*  Now have a decimal byte count - convert it */

    iSize = 0;

    while( *pbFile >= '0' && *pbFile <= '9' )
        iSize = iSize * 10 + *pbFile++ - '0';



    if( *pbFile++ != 'W' )
    {
#if PRINT_INFO
        DbgPrint( "Rasdd!pbReadSFH: bad file: W missing\n" );
#endif

        return  0;
    }

    if( iSize < sizeof( SF_HEADER ) )
    {
#if PRINT_INFO
        DbgPrint( "Rasdd!pbReadSFH: Header size too small: %d vs %d\n", iSize,
                                                sizeof( SF_HEADER ) );
#endif

        return  0;

    }

    /*
     *   Now COPY the data into the structure passed in.  This IS NECESSARY
     * as the file data may not be aligned - the file contains no holes,
     * so we may have data with an incorrect offset.
     */

    CopyMemory( psfh, pbFile, sizeof( SF_HEADER ) );

    /*
     *   The big endian/little endian switch.
     */

    SWAB( psfh->wSize );
    SWAB( psfh->wBaseline );
    SWAB( psfh->wCellWide );
    SWAB( psfh->wCellHeight );
    SWAB( psfh->wSymSet );
    SWAB( psfh->wPitch );
    SWAB( psfh->wHeight );
    SWAB( psfh->wXHeight );
    SWAB( psfh->wTextHeight );
    SWAB( psfh->wTextWidth );

    return  pbFile + iSize;             /* Next part of the operation */
}

/**************************** Function Header *******************************
 * iNextType
 *      Read ahead to see what sort of record appears next.
 *
 * RETURNS:
 *      The type of record found.
 *
 * HISTORY:
 *  15:17 on Tue 03 Mar 1992    -by-    Lindsay Harris   [lindsayh]
 *      First version.
 *
 ****************************************************************************/

int
iNextType( pbFile )
BYTE  *pbFile;
{
    /*
     *   First character MUST be an escape!
     */

    CH_HEADER  *pCH;                    /* Character header: for continuation */



    if( *pbFile++ != '\033' )
        return  TYPE_INVALID;           /* No go */

    /*
     *   If the next two bytes are "*c", we have a character code command.
     *  Otherwise,  we can expect a "(s",  which indicates a font
     *  descriptor command.
     */


    if( *pbFile == '*' && *(pbFile + 1) == 'c' )
    {
        /*
         *   Verifu that this really is an index record: we should see
         * a numeric string and then a 'E'.
         */

        pbFile += 2;

        while( *pbFile >= '0' && *pbFile <= '9' )
                ++pbFile;


        return  *pbFile == 'E' ? TYPE_INDEX : TYPE_INVALID;
    }

    if( *pbFile != '(' || *(pbFile + 1) != 's' )
        return  TYPE_INVALID;

    /*
     *   Must now check to see if this is a continuation record or a
     * new record.  There is a byte in the header to indicate which
     * it is.   But first skip the byte count and trailing W.
     */

    pbFile += 2;
    while( *pbFile >= '0' && *pbFile <= '9' )
                pbFile++;

    if( *pbFile != 'W' )
        return  TYPE_INVALID;

    pCH = (CH_HEADER *)(pbFile + 1);

    /*
     *   Note that alignment is not a problem in the following
     * since we are dealing with a byte quantity.
     */

    return  pCH->bContinuation ? TYPE_CONT : TYPE_HEADER;
}


/**************************** Function Header *******************************
 * pbReadIndex
 *      Reads data from the pointer passed to us,  and attempts to interpret
 *      it as a PCL Character Code escape sequence.
 *
 * RETURNS:
 *      Pointer to byte past command,  else 0 for failure.
 *
 * HISTORY:
 *  16:21 on Wed 19 Feb 1992    -by-    Lindsay Harris   [lindsayh]
 *      Number one
 *
 *****************************************************************************/


BYTE *
pbReadIndex( pbFile, piCode )
BYTE    *pbFile;                /* Where to start looking */
int     *piCode;                /* Where the result is placed */
{
    /*
     *   Command sequence is "\033*c..E" - where ... is the ASCII decimal
     * representation of the character code for this glyph.  That is
     * the value returned in *piCode.
     */

    int  iVal;


    if( *pbFile == '\0' )
    {
        /*  EOF is not really an error: return an OK value and -1 index */

        *piCode = -1;

        return  pbFile;         /* Presume EOF */
    }

    if( *pbFile++ != '\033' || *pbFile++ != '*' || *pbFile++ != 'c' )
    {
#if PRINT_INFO
        DbgPrint( "Rasdd!pbReadIndex: invalid character code\n" );
#endif

        return  0;
    }

    iVal = 0;
    while( *pbFile >= '0' && *pbFile <= '9' )
        iVal = iVal * 10 + *pbFile++ - '0';

    *piCode = iVal;

    if( *pbFile++ != 'E' )
    {
#if PRINT_INFO
        DbgPrint( "Rasdd!pbReadIndex: Missing 'E' in character code escape\n" );
#endif

        return  0;
    }

    return  pbFile;
}

/**************************** Function Header *******************************
 * pbReadCHH
 *      Function to read the Character Header at the memory location
 *      pointed to by by pbFile,  return a filled in CH_HEADER structure,
 *      and advance the file address to the next header.
 *
 * RETURNS:
 *      Address of first byte past where we finish; else 0 for failure.
 *
 * HISTORY:
 *  11:23 on Thu 20 Feb 1992    -by-    Lindsay Harris   [lindsayh]
 *      Gotta start somewhere.
 *
 ****************************************************************************/

BYTE  *
pbReadCHH( pbFile, pchh, bCont )
BYTE       *pbFile;             /* File mapped into memory */
CH_HEADER  *pchh;               /* Structure to fill in */
BOOL        bCont;              /* TRUE if this is a continuation record */
{

    int    iSize;               /* Bytes of data to skip over */

    /*
     *   The entry starts with a string "\033(s..W" where .. is the ASCII
     * decimal count of the number of bytes following the W.  Since this
     * includes the download stuff,  we would expect more than the size
     * of the CH_HEADER.
     */


    if( *pbFile++ != '\033' || *pbFile++ != '(' || *pbFile++ != 's' )
    {
#if PRINT_INFO
        DbgPrint( "Rasdd!pbReadCHH: bad format, first 3 bytes\n" );
#endif

        return  0;
    }

    iSize = 0;
    while( *pbFile >= '0' && *pbFile <= '9' )
        iSize = iSize * 10 + *pbFile++ - '0';


    if( iSize < sizeof( CH_HEADER ) )
    {
#if PRINT_INFO
        DbgPrint( "Rasdd!pbReadCHH: size field (%ld) < header size\n", iSize );
#endif

        return  0;
    }

    if( *pbFile++ != 'W' )
    {
#if PRINT_INFO
        DbgPrint( "Rasdd!pbReadCHH: invalid escape sequence\n" );
#endif

        return  0;
    }

    /*
     *   If this is a continuation record,  there is no more to do but
     * return the address past this record.
     */
    if( bCont )
        return  pbFile + iSize;


    /*  Copy the data to the structure - may not be aligned in the file */
    CopyMemory( pchh, pbFile, sizeof( CH_HEADER ) );

    pbFile += iSize;            /* End of this record */


    SWAB( pchh->sLOff );
    SWAB( pchh->sTOff );
    SWAB( pchh->wChWidth );
    SWAB( pchh->wChHeight );
    SWAB( pchh->wDeltaX );


    /*
     *   If this glyph is in landscape,  we need to swap some data
     * around,  since the data format is designed for the printer's
     * convenience, and not ours!
     */

    if( pchh->bOrientation )
    {
        /*   Landscape,  so swap the entries around  */
        short  sSwap;
        WORD   wSwap;

        /* Left & Top offsets: see pages 10-19, 10-20 of LJ II manual */
        sSwap = pchh->sTOff;
        pchh->sTOff = -pchh->sLOff;
        pchh->sLOff = (short)(sSwap + 1 - pchh->wChHeight);

        /*  Delta X remains the same */

        /*  Height and Width are switched around */
        wSwap = pchh->wChWidth;
        pchh->wChWidth = pchh->wChHeight;
        pchh->wChHeight = wSwap;
    }


    /*
     *     pbFile is pointing at the correct location when we reach here.
     */
    return  pbFile;
}


/*************************** Function Header *******************************
 * SfhToIFI
 *      Generate IFIMETRICS data from the PCL softfont header.  There are
 *      some fields we are unable to evaluate,  e.g. first/last char,
 *      since these are obtained from the file.
 *
 * RETURNS:
 *      Pointer to IFIMETRICS,  allocated from heap; 0 on error.
 *
 * HISTORY:
 *  13:57 on Fri 18 Jun 1993    -by-    Lindsay Harris   [lindsayh]
 *      Assorted bug fixing for that infamous tax program
 *
 *  16:03 on Thu 11 Mar 1993    -by-    Lindsay Harris   [lindsayh]
 *      Correct conversion to Unicode - perhaps??
 *
 *  16:45 on Wed 03 Mar 1993    -by-    Lindsay Harris   [lindsayh]
 *      Update to libc wcs functions rather than printers\lib versions.
 *
 *  14:19 on Thu 20 Feb 1992    -by-    Lindsay Harris   [lindsayh]
 *      Fresh off the presses.
 *
 ****************************************************************************/

IFIMETRICS  *
SfhToIFI( psfh, hheap, pwstrUniqNm )
SF_HEADER  *psfh;               /* The data source */
HANDLE      hheap;              /* Source of memory */
PWSTR       pwstrUniqNm;        /* Unique name for IFIMETRICS */
{
    /*
     *   Several hard parts:  the hardest are the panose numbers.
     * It is messy, though not difficult to generate the variations
     * of the font name.
     */

    register  IFIMETRICS   *pIFI;


    int     iI;                 /* Loop index,  of course! */
    int     cWC;                /* Number of WCHARS to add */
    int     cbAlloc;            /* Number of bytes to allocate */
    int     cChars;             /* Number chars to convert to Unicode */
    WCHAR  *pwch;               /* For string manipulations */
    WCHAR  *pwchTypeface;       /* Name from typeface value */
    WCHAR  *pwchGeneric;        /* Generic windows name */

    char    ajName[ SFH_NM_SZ + 1 ];    /* Guaranteed null terminated name */
    WCHAR   awcName[ SFH_NM_SZ + 1 ];   /* Wide version of the above */

               /*  NOTE:  FOLLOWING 2 MUST BE 256 ENTRIES LONG!!! */
    WCHAR   awcAttrib[ 256 ];           /* For generating attributes */
    BYTE    ajANSI[ 256 ];              /* ANSI equivalent of above */


    /*
     *   First massage the font name.  We need to null terminate it, since
     * the softfont data need not be.  And we also need to truncate any
     * trailing blanks.
     *
     *   But we also calculate all the aliases we are going to add.  Apart
     * from the name in the file (which may not be useful), there is
     * the name based on the bTypeface field in the header, AND there
     * is the generic (SWISS/MODERN/ROMAN) type based on the font
     * characteristics.
     *
     *  NOTE: change of plans here:  we only use the font name from the
     *  file if the header's typeface index is for a font that we don't
     *  know about.  This causes the least problems for GDI and it's
     *  font mapper.
     */


    if( psfh->bTypeface >= 0 && psfh->bTypeface < NUM_TYPEFACE )
    {
        (const WCHAR *)pwchTypeface = pwcName[ psfh->bTypeface ];
    }
    else
    {

        FillMemory( ajName, SFH_NM_SZ, ' ' );

        strncpy( ajName, psfh->chName, SFH_NM_SZ );
        ajName[ SFH_NM_SZ ] = '\0';


        for( iI = strlen( ajName ) - 1; iI >= 0; --iI )
        {
            if( ajName[ iI ] != ' ' )
            {
                ajName[ iI + 1 ] = '\0';            /* Must be the end */
                break;
            }
        }
        strcpy2WChar( awcName, ajName );            /* Base name */
        pwchTypeface = awcName;                     /* For later use */
    }


    /*
     *    The generic name is based on 2 facts:  fixed or variable pitch,
     *  and variable pitch switches between serifed and non-serifed fonts.
     */

    if( psfh->bSpacing )
    {
        /*
         *    Proportional font,  so we need to look for serifs.
         */

        if( (psfh->bSerifStyle >= 2 && psfh->bSerifStyle <= 8) ||
            (psfh->bSerifStyle & 0xc0) == 0x80 )
        {
            /*   A font with serifs,  so set this as a Roman font */
            pwchGeneric = L"Roman";
        }
        else
            pwchGeneric = L"Swiss";         /* No serifs */
    }
    else
        pwchGeneric = L"Modern";



    /*
     *   Produce the desired attributes: Italic, Bold, Light etc.
     * This is largely guesswork,  and there should be a better method.
     */


    awcAttrib[ 0 ] = L'\0';
    awcAttrib[ 1 ] = L'\0';               /* Write out an empty string */

    if( psfh->bStyle )                  /* 0 normal, 1 italic */
        wcscat( awcAttrib, L" Italic" );

    if( psfh->sbStrokeW >= PCL_BOLD )           /* As per HP spec */
        wcscat( awcAttrib, L" Bold" );
    else
    {
        if( psfh->sbStrokeW <= PCL_LIGHT )
            wcscat( awcAttrib, L" Light" );
    }

    /*
     *    First step is to determine the length of the WCHAR strings
     *  that are placed at the end of the IFIMETRICS,  since we need
     *  to include these in our storage allocation.
     *
     *   The attribute string appears in 3 entries of IFIMETRICS,  so
     * calculate how much storage this will take.  NOTE THAT THE LEADING
     * CHAR IN awcAttrib is NOT placed in the style name field,  so we
     * subtract one in the following formula to account for this.
     */


    cWC = 3 * wcslen( pwchTypeface ) +         /* Base name */
          wcslen( pwchGeneric ) +              /* In the alias section */
          3 * wcslen( awcAttrib ) +            /* In most places */
          wcslen( pwstrUniqNm ) + 1 +          /* Printer name plus space */
          6;                                   /* Terminating nulls */

    cbAlloc = sizeof( IFIMETRICS ) + sizeof( WCHAR ) * cWC;

    pIFI = (IFIMETRICS *)HEAPALLOC( hheap, cbAlloc );

    if( !pIFI )
        return   NULL;                          /* Not very nice! */


    ZeroMemory( pIFI, cbAlloc );                /* In case we miss something */


    pIFI->cjThis = cbAlloc;                     /* Everything */

    pIFI->cjIfiExtra = 0;

    /*   The family name:  straight from the FaceName - no choice?? */

    pwch = (WCHAR *)(pIFI + 1);         /* At the end of the structure */
    pIFI->dpwszFamilyName = (PTRDIFF)((BYTE *)pwch - (BYTE *)pIFI);

    wcscpy( pwch, pwchTypeface );                       /* Base name */

    /*   Add the aliases too! */
    pwch += wcslen( pwch ) + 1;                         /* After the nul */
    wcscpy( pwch, pwchGeneric );                        /* Windows generic */


    pwch += wcslen( pwch ) + 2;         /* Skip what we just put in */


    /*   Now the face name:  we add bold, italic etc to family name */

    pIFI->dpwszFaceName = (PTRDIFF)((BYTE *)pwch - (BYTE *)pIFI);

    wcscpy( pwch, pwchTypeface );                       /* Base name */
    wcscat( pwch, awcAttrib );


    /*   Now the unique name - well, sort of, anyway */

    pwch += wcslen( pwch ) + 1;         /* Skip what we just put in */
    pIFI->dpwszUniqueName = (PTRDIFF)((BYTE *)pwch - (BYTE *)pIFI);

    wcscpy( pwch, pwstrUniqNm );
    wcscat( pwch, L" " );
    wcscat( pwch, (PWSTR)((BYTE *)pIFI + pIFI->dpwszFaceName) );

    /*  Onto the attributes only component */

    pwch += wcslen( pwch ) + 1;         /* Skip what we just put in */
    pIFI->dpwszStyleName = (PTRDIFF)((BYTE *)pwch - (BYTE *)pIFI);
    wcscat( pwch, &awcAttrib[ 1 ] );


#if DBG
    /*
     *    Check on a few memory sizes:  JUST IN CASE.....
     */

    if( (wcslen( awcAttrib ) * sizeof( WCHAR )) >= sizeof( awcAttrib ) )
    {
        DbgPrint( "Rasdd!SfhToIFI: STACK CORRUPTED BY awcAttrib" );

        HeapFree( hheap, 0, (LPSTR)pIFI );         /* No memory leaks */

        return  0;
    }


    if( ((BYTE *)(pwch + wcslen( pwch ) + 1)) > ((BYTE *)pIFI + cbAlloc) )
    {
        DbgPrint( "Rasdd!SfhToIFI: IFIMETRICS overflow: Wrote to 0x%lx, allocated to 0x%lx\n",
                ((BYTE *)(pwch + wcslen( pwch ) + 1)),
                ((BYTE *)pIFI + cbAlloc) );

        HeapFree( hheap, 0, (LPSTR)pIFI );         /* No memory leaks */

        return  0;

    }
#endif

    /*
     *   Change to use new IFIMETRICS.
     */

    pIFI->flInfo = FM_INFO_TECH_BITMAP | FM_INFO_1BPP |
                                 FM_INFO_RIGHT_HANDED | FM_INFO_FAMILY_EQUIV;


    pIFI->lEmbedId     = 0;
    pIFI->lItalicAngle = 0;
    pIFI->lCharBias    = 0;
    pIFI->dpCharSets   = 0; // no multiple charsets in rasdd fonts


    pIFI->fwdUnitsPerEm = psfh->wCellHeight;
    pIFI->fwdLowestPPEm = 1;                   /* Not important for us */

    pIFI->fwdWinAscender = psfh->wBaseline;
    pIFI->fwdWinDescender = psfh->wCellHeight - psfh->wBaseline;

    pIFI->fwdMacAscender =    pIFI->fwdWinAscender;
    pIFI->fwdMacDescender = - pIFI->fwdWinDescender;

    pIFI->fwdMacLineGap = 0;

    pIFI->fwdTypoAscender  = pIFI->fwdMacAscender;
    pIFI->fwdTypoDescender = pIFI->fwdMacDescender;
    pIFI->fwdTypoLineGap   = pIFI->fwdMacLineGap;

    pIFI->fwdAveCharWidth = (psfh->wTextWidth + 2) / 4;
    pIFI->fwdMaxCharInc = psfh->wCellWide;

    pIFI->fwdCapHeight = psfh->wBaseline;
    pIFI->fwdXHeight   = psfh->wBaseline;


    pIFI->fwdUnderscoreSize = psfh->bUHeight;
    pIFI->fwdUnderscorePosition = -(psfh->sbUDist - psfh->bUHeight / 2);

    pIFI->fwdStrikeoutSize = psfh->bUHeight;
    pIFI->fwdStrikeoutPosition = psfh->wBaseline / 3;

    pIFI->jWinCharSet = OEM_CHARSET;

    if( psfh->bSpacing )
    {
        /*
         *   Proportional,  so also look at the serif style.  Consult the
         *  LaserJet III Technical Reference Manual to see the following
         *  constants.  Basically,  the serif fonts have a value between
         *  2 and 8, or the top two bits have the value 64.
         */
        if( (psfh->bSerifStyle >= 2 && psfh->bSerifStyle <= 8) ||
            (psfh->bSerifStyle & 0xc0) == 0x80 )
         {
            pIFI->jWinPitchAndFamily = FF_ROMAN | VARIABLE_PITCH;
         }
         else
            pIFI->jWinPitchAndFamily = FF_SWISS | VARIABLE_PITCH;
    }
    else
    {
        /*  Fixed pitch,  so select FF_MODERN as the style */
        pIFI->jWinPitchAndFamily = FF_MODERN | FIXED_PITCH;
    }


    pIFI->usWinWeight = 400;                 /* Normal weight */
    pIFI->panose.bWeight = PAN_WEIGHT_MEDIUM;
    if( psfh->sbStrokeW >= PCL_BOLD )           /* As per HP spec */
    {
        /*  Set a bold value */
        pIFI->usWinWeight = 700;
        pIFI->panose.bWeight = PAN_WEIGHT_BOLD;
    }
    else
    {
        if( psfh->sbStrokeW <= PCL_LIGHT )
        {
            pIFI->usWinWeight = 200;
            pIFI->panose.bWeight = PAN_WEIGHT_LIGHT;
        }
    }

    pIFI->fsType = FM_NO_EMBEDDING;


    /*
     *   The first/last/break/default glyphs:  these are determined by the
     * type of the font.  ALL PCL fonts (according to HP documentation)
     * include the space character, so we use that.
     */

    if( psfh->bFontType != PCL_FT_PC8 )
        pIFI->chFirstChar = ' ';
    else
        pIFI->chFirstChar = 0;

    if( psfh->bFontType == PCL_FT_7BIT )
        pIFI->chLastChar = 127;
    else
        pIFI->chLastChar = 255;

    pIFI->chDefaultChar = '.' - pIFI->chFirstChar;
    pIFI->chBreakChar = ' ' - pIFI->chFirstChar;


    /*   Fill in the WCHAR versions of these values */

    cChars = pIFI->chLastChar - pIFI->chFirstChar + 1;
    for( iI = 0; iI < cChars; ++iI )
        ajANSI[ iI ] = (BYTE)(pIFI->chFirstChar + iI);

    MultiByteToWideChar( CP_ACP, 0, ajANSI, cChars, awcAttrib, cChars );


    pIFI->wcDefaultChar = awcAttrib[ pIFI->chDefaultChar ];
    pIFI->wcBreakChar = awcAttrib[ pIFI->chBreakChar ];

    pIFI->wcFirstChar = 0xffff;
    pIFI->wcLastChar = 0;


    /*   Scan for first and last */
    for( iI = 0; iI < cChars; ++iI )
    {
        if( awcAttrib[ iI ] > pIFI->wcLastChar )
            pIFI->wcLastChar = awcAttrib[ iI ];

        if( awcAttrib[ iI ] < pIFI->wcFirstChar )
            pIFI->wcFirstChar = awcAttrib[ iI ];
    }

    /*   StemDir:  either roman or italic */


    if( psfh->sbStrokeW >= PCL_BOLD )           /* As per HP spec */
        pIFI->fsSelection |= FM_SEL_BOLD;

    if( psfh->bStyle )
    {
        /*
         *   Tan (17.5 degrees) = .3153
         */
        pIFI->ptlCaret.x =  3153;
        pIFI->ptlCaret.y = 10000;
        pIFI->fsSelection |= FM_SEL_ITALIC;
    }
    else
    {
        pIFI->ptlCaret.x = 0;
        pIFI->ptlCaret.y = 1;
    }

    if( (pIFI->fsSelection & (FM_SEL_ITALIC | FM_SEL_BOLD)) == 0 )
        pIFI->fsSelection |= FM_SEL_REGULAR;

    if( !psfh->bSpacing )
        pIFI->flInfo |= FM_INFO_CONSTANT_WIDTH;

    pIFI->ptlBaseline.x = 1;
    pIFI->ptlBaseline.y = 0;

    pIFI->ptlAspect.x = pIFI->ptlAspect.y = 300;

    pIFI->fwdSubscriptXSize = (FWORD)(pIFI->fwdAveCharWidth / 4);
    pIFI->fwdSubscriptYSize = (FWORD)(pIFI->fwdWinAscender / 4);

    pIFI->fwdSubscriptXOffset = (FWORD)(3 * pIFI->fwdAveCharWidth / 4);
    pIFI->fwdSubscriptYOffset = (FWORD)(-pIFI->fwdWinAscender / 4);

    pIFI->fwdSuperscriptXSize = (FWORD)(pIFI->fwdAveCharWidth / 4);
    pIFI->fwdSuperscriptYSize = (FWORD)(pIFI->fwdWinAscender / 4);

    pIFI->fwdSuperscriptXOffset = (FWORD)(3 * pIFI->fwdAveCharWidth / 4);
    pIFI->fwdSuperscriptYOffset = (FWORD)(3 * pIFI->fwdWinAscender / 4);


    pIFI->rclFontBox.left = 0;
    pIFI->rclFontBox.top = pIFI->fwdWinAscender;
    pIFI->rclFontBox.right = pIFI->fwdMaxCharInc;
    pIFI->rclFontBox.bottom = -pIFI->fwdWinDescender;

    pIFI->achVendId[ 0 ] = 'U';
    pIFI->achVendId[ 1 ] = 'n';
    pIFI->achVendId[ 2 ] = 'k';
    pIFI->achVendId[ 3 ] = 'n';

    pIFI->cKerningPairs = 0;

    pIFI->ulPanoseCulture         = FM_PANOSE_CULTURE_LATIN;
    pIFI->panose.bFamilyType      = PAN_ANY;
    pIFI->panose.bSerifStyle      = PAN_ANY;
    pIFI->panose.bProportion      = PAN_ANY;
    pIFI->panose.bContrast        = PAN_ANY;
    pIFI->panose.bStrokeVariation = PAN_ANY;
    pIFI->panose.bArmStyle        = PAN_ANY;
    pIFI->panose.bLetterform      = PAN_ANY;
    pIFI->panose.bMidline         = PAN_ANY;
    pIFI->panose.bXHeight         = PAN_ANY;

    return  pIFI;
}


/************************* Function Header ********************************
 * strcpy2WChar
 *      Convert a char * string to a WCHAR string.  Basically this means
 *      converting each input character to 16 bits by zero extending it.
 *
 * RETURNS:
 *      Value of first parameter.
 *
 * HISTORY:
 *  12:35 on Thu 18 Mar 1993    -by-    Lindsay Harris   [lindsayh]
 *      Use the correct conversion method to Unicode.
 *
 *  09:36 on Thu 07 Mar 1991    -by-    Lindsay Harris   [lindsayh]
 *      Created it.
 *
 **************************************************************************/

PWSTR
strcpy2WChar( pWCHOut, lpstr )
PWSTR   pWCHOut;              /* Destination */
LPSTR   lpstr;                /* Source string */
{

    /*
     *   Put buffering around the NLS function that does all this stuff.
     */

    int     cchIn;             /* Number of input chars */


    cchIn = strlen( lpstr ) + 1;

    MultiByteToWideChar( CP_ACP, 0, lpstr, cchIn, pWCHOut, cchIn );


    return  pWCHOut;
}


/******************************************************************************
 *
 *                            FIWriteFix
 *
 *  Function:
 *      Write the IFIMETRICS fixed data to the output file
 *
 *  Returns:
 *       Number of bytes written
 *
 ******************************************************************************/

DWORD
FIWriteFix(
    HANDLE    hFile,
    WORD      wDataID,
    FI_DATA  *pFD           // Pointer to data to write
    )
{

    DATA_HEADER dh;
    DWORD       dwSize;

    //
    // Then write out the header, followed by the actual data
    //

    dh.dwSignature = DATA_IFI_SIG;
    dh.wSize       = (WORD)sizeof(DATA_HEADER);
    dh.wDataID     = wDataID;
    dh.dwDataSize  = sizeof(FI_DATA_HEADER) +
                     pFD->dsIFIMet.cBytes   +
                     pFD->dsWidthTab.cBytes +
                     pFD->dsSel.cBytes      +
                     pFD->dsDesel.cBytes    +
                     pFD->dsIdentStr.cBytes +
                     pFD->dsETM.cBytes;

    dh.dwReserved  = 0;

    WriteFile(hFile, (PVOID)&dh, sizeof(DATA_HEADER), &dwSize, NULL);

    return sizeof(DATA_HEADER) + iWriteFDH(hFile, pFD);
}


/******************************************************************************
 *
 *                            FIWriteVar
 *
 *  Function:
 *      Write the PCL variable data to the output file
 *
 *  Returns:
 *       Number of bytes written
 *
 ******************************************************************************/

DWORD
FIWriteVar(
    HANDLE   hFile,         // The file to which the data is written
    TCHAR   *ptchName       // File name containing the data
    )
{
    DATA_HEADER dh;
    HANDLE      hIn;
    DWORD       dwSize = 0;

    if (ptchName == 0 || *ptchName == (TCHAR)0)
        return   0;

    hIn = CreateFileW(ptchName,
                      GENERIC_READ,
                      FILE_SHARE_READ,
                      NULL,
                      OPEN_EXISTING,
                      0,
                      0);

    if (hIn == INVALID_HANDLE_VALUE)
    {
        WARNING(("Error %d opening file %ws\n", GetLastError(), ptchName));
        return  0;
    }

    //
    // First write out the header, followed by the actual data
    //

    dh.dwSignature = DATA_VAR_SIG;
    dh.wSize       = (WORD)sizeof(DATA_HEADER);
    dh.wDataID     = 0;
    dh.dwDataSize  = GetFileSize(hIn, NULL);
    dh.dwReserved  = 0;

    if (WriteFile(hFile, (PVOID)&dh, sizeof(DATA_HEADER), &dwSize, NULL))
    {
        dwSize += FICopy(hFile, hIn);
    }

    CloseHandle(hIn);

    return dwSize;
}


/******************************************************************************
 *
 *                            FIWriteRawVar
 *
 *  Function:
 *      Write the PCL variable data to the output file
 *
 *  Returns:
 *       Number of bytes written
 *
 ******************************************************************************/

DWORD
FIWriteRawVar(
    HANDLE   hFile,         // The file to which the data is written
    PBYTE    pRawVar,       // Buffer containing PCL data
    DWORD    dwSize         // Size of buffer
    )
{
    DATA_HEADER dh;
    DWORD       dwBytesWritten = 0;

    if (pRawVar == NULL || dwSize == 0)
        return   0;

    //
    // First write out the header, followed by the actual data
    //

    dh.dwSignature = DATA_VAR_SIG;
    dh.wSize       = (WORD)sizeof(DATA_HEADER);
    dh.wDataID     = 0;
    dh.dwDataSize  = dwSize;
    dh.dwReserved  = 0;

    if (! WriteFile(hFile, (PVOID)&dh, sizeof(DATA_HEADER), &dwBytesWritten, NULL) ||
        ! WriteFile(hFile, (PVOID)pRawVar, dwSize, &dwSize, NULL))
        return 0;

    return dwSize+dwBytesWritten;
}



/************************** Function Header ********************************
 * FICopy
 *      Copy the file contents of the input handle to that of the output
 *      handle.
 *
 * RETURNS:
 *      Number of bytes copied,  -1 on error, 0 is legitimate.
 *
 * HISTORY:
 *  18:06 on Mon 24 Feb 1992    -by-    Lindsay Harris   [lindsayh]
 *      Start
 *
 ***************************************************************************/


DWORD
FICopy(
    HANDLE   hOut,          /* Output file:  write to current position */
    HANDLE   hIn            /* Input file: copy from current position to EOF */
    )
{
    /*
     *   Simple read/write operations until EOF is reached on the input.
     * May also be errors,  so handle these too.  As we are dealing with
     * relatively small files (a few 10s of k), we use a stack buffer.
     */

#define CPBSZ   2048

    DWORD  dwSize;
    DWORD  dwGot;
    DWORD  dwTot;               /* Accumulate number of bytes copied */

    BYTE   ajBuf[ CPBSZ ];

    dwTot = 0;

    while (ReadFile(hIn, &ajBuf, CPBSZ, &dwGot, NULL))
    {
        /*  A read of zero means we have reached EOF  */

        if (dwGot == 0)
            return  dwTot;              /* However much so far */

        if (!WriteFile( hOut, &ajBuf, dwGot, &dwSize, NULL) ||
            dwSize != dwGot)
        {
            /*  Assume some serious problem */

            return  0;
        }

        dwTot += dwSize;
    }

    /*
     *   We only come here for an error,  so return the bad news.
     */

    return  0;
}

/******************************* Function Header *****************************
 * iWriteFDH
 *      Write the FI_DATA_HEADER data out to our file.  We do the conversion
 *      from addresses to offsets, and write out any data we find.
 *
 * RETURNS:
 *      The number of bytes actually written; -1 for error, 0 for nothing.
 *
 * HISTORY:
 *  16:58 on Thu 05 Mar 1992    -by-    Lindsay Harris   [lindsayh]
 *      Based on an experimental version first used in font installer.
 *
 *  17:11 on Fri 21 Feb 1992    -by-    Lindsay Harris   [lindsayh]
 *      First version.
 *
 *****************************************************************************/

int
iWriteFDH( hFile, pFD )
HANDLE    hFile;        /* File wherein to place the data */
FI_DATA  *pFD;          /* Pointer to FM to write out */
{
    /*
     *   Decide how many bytes will be written out.  We presume that the
     * file pointer is located at the correct position when we are called.
     */

    int  iSize;         /* Evaluate output size */


    FI_DATA_HEADER   fdh;       /* Header written to file */




    if( pFD == 0 )
        return  0;      /* Perhaps only deleting?  */

    memset( &fdh, 0, sizeof( fdh ) );           /* Zero for convenience */

    /*
     *  Set the miscellaneous flags etc.
     */

    fdh.cjThis = sizeof( fdh );

    fdh.fCaps = pFD->fCaps;
    fdh.wFontType= pFD->wFontType; /* Device Font Type */

    fdh.wXRes = pFD->wXRes;
    fdh.wYRes = pFD->wYRes;

    fdh.sYAdjust = pFD->sYAdjust;
    fdh.sYMoved = pFD->sYMoved;

    fdh.u.sCTTid = (short)pFD->dsCTT.cBytes;

    fdh.dwSelBits = pFD->dwSelBits;

    fdh.wPrivateData = pFD->wPrivateData;


    iSize = sizeof( fdh );              /* Our header already */
    fdh.dwIFIMet = iSize;               /* Location of IFIMETRICS */

    iSize += pFD->dsIFIMet.cBytes;              /* Bytes in struct */

    /*
     *   And there may be a width table too!  The pFD values are zero if none.
     */

    if( pFD->dsWidthTab.cBytes )
    {
        fdh.dwWidthTab = iSize;

        iSize += pFD->dsWidthTab.cBytes;
    }

    /*
     *  Finally are the select/deselect strings.
     */

    if( pFD->dsSel.cBytes )
    {
        fdh.dwCDSelect = iSize;
        iSize += pFD->dsSel.cBytes;
    }

    if( pFD->dsDesel.cBytes )
    {
        fdh.dwCDDeselect = iSize;
        iSize += pFD->dsDesel.cBytes;
    }

    /*
     *   There may also be some sort of identification string.
     */

    if( pFD->dsIdentStr.cBytes )
    {
        fdh.dwIdentStr = iSize;
        iSize += pFD->dsIdentStr.cBytes;
    }

    if( pFD->dsETM.cBytes )
    {
        fdh.dwETM = iSize;
        iSize += pFD->dsETM.cBytes;
    }


    /*
     *   Sizes all figured out,  so write the data!
     */

    if( !bWrite( hFile, &fdh, sizeof( fdh ) ) ||
        !bWrite( hFile, pFD->dsIFIMet.pvData, pFD->dsIFIMet.cBytes ) ||
        !bWrite( hFile, pFD->dsWidthTab.pvData, pFD->dsWidthTab.cBytes ) ||
        !bWrite( hFile, pFD->dsSel.pvData, pFD->dsSel.cBytes ) ||
        !bWrite( hFile, pFD->dsDesel.pvData, pFD->dsDesel.cBytes ) ||
        !bWrite( hFile, pFD->dsIdentStr.pvData, pFD->dsIdentStr.cBytes ) ||
        !bWrite( hFile, pFD->dsETM.pvData, pFD->dsETM.cBytes ) )
                return   0;


    return  iSize;                      /* Number of bytes written */

}

/************************* Function Header *********************************
 * bWrite
 *      Writes data out to a file handle.  Returns TRUE on success.
 *      Functions as a nop if the size request is zero.
 *
 * RETURNS:
 *      TRUE/FALSE,  TRUE for success.
 *
 * HISTORY:
 *  17:38 on Fri 21 Feb 1992    -by-    Lindsay Harris   [lindsayh]
 *      # 1
 *
 ****************************************************************************/

BOOL
bWrite( hFile, pvBuf, iSize )
HANDLE   hFile;         /* The file to which to write */
VOID    *pvBuf;         /* Data to write */
int      iSize;         /* Number of bytes to write */
{
    /*
     *   Simplify the ugly NT interface.  Returns TRUE if the WriteFile
     * call returns TRUE and the number of bytes written equals the
     * number of bytes desired.
     */


    BOOL   bRet;
    DWORD  dwSize;              /* Filled in by WriteFile */


    bRet = TRUE;

    if( iSize > 0 &&
        (!WriteFile( hFile, pvBuf, (DWORD)iSize, &dwSize, NULL ) ||
         (DWORD)iSize != dwSize) )
             bRet = FALSE;              /* Too bad */


    return  bRet;
}

#if  PRINT_INFO

/******************************Public*Routine******************************\
* vCheckIFIMETRICS
*
* This is where you put sanity checks on an incomming IFIMETRICS structure.
*
* History:
*  Sun 01-Nov-1992 22:55:31 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

VOID
vCheckIFIMETRICS(
    IFIMETRICS *pifi,
    VPRINT vPrint
    )
{
    BOOL bGoodPitch;

    BYTE jPitch =
        pifi->jWinPitchAndFamily & (DEFAULT_PITCH | FIXED_PITCH | VARIABLE_PITCH);


    if (pifi->flInfo & FM_INFO_CONSTANT_WIDTH)
    {
        bGoodPitch = (jPitch == FIXED_PITCH);
    }
    else
    {
        bGoodPitch = (jPitch == VARIABLE_PITCH);
    }
    if (!bGoodPitch)
    {
        vPrint("\n\n<INCONSISTENCY DETECTED>\n");
        vPrint(
            "    jWinPitchAndFamily = %-#2x, flInfo = %-#8lx\n\n",
            pifi->jWinPitchAndFamily,
            pifi->flInfo
            );
    }
}


/******************************Public*Routine******************************\
* vPrintIFIMETRICS
*
* Dumps the IFMETERICS to the screen
*
* History:
*  Wed 13-Jan-1993 10:14:21 by Kirk Olynyk [kirko]
* Updated it to conform to some changes to the IFIMETRICS structure
*
*  Thu 05-Nov-1992 12:43:06 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

VOID
vPrintIFIMETRICS(
    IFIMETRICS *pifi,
    VPRINT vPrint
    )
{
//
// Convenient pointer to Panose number
//
    PANOSE *ppan = &pifi->panose;

    PWSZ pwszFamilyName = (PWSZ)(((BYTE*) pifi) + pifi->dpwszFamilyName);
    PWSZ pwszStyleName  = (PWSZ)(((BYTE*) pifi) + pifi->dpwszStyleName );
    PWSZ pwszFaceName   = (PWSZ)(((BYTE*) pifi) + pifi->dpwszFaceName  );
    PWSZ pwszUniqueName = (PWSZ)(((BYTE*) pifi) + pifi->dpwszUniqueName);

    vPrint("    cjThis                 %-#8lx\n" , pifi->cjThis );
    vPrint("    cjIfiExtra             %-#8lx\n" , pifi->cjIfiExtra );
    vPrint("    pwszFamilyName         \"%ws\"\n", pwszFamilyName );

    if( pifi->flInfo & FM_INFO_FAMILY_EQUIV )
    {
        /*  Aliasing is in effect!  */

        while( *(pwszFamilyName += wcslen( pwszFamilyName ) + 1) )
            vPrint("                               \"%ws\"\n", pwszFamilyName );
    }

    vPrint("    pwszStyleName          \"%ws\"\n", pwszStyleName );
    vPrint("    pwszFaceName           \"%ws\"\n", pwszFaceName );
    vPrint("    pwszUniqueName         \"%ws\"\n", pwszUniqueName );
    vPrint("    dpFontSim              %-#8lx\n" , pifi->dpFontSim );
    vPrint("    lEmbedId               %d\n",      pifi->lEmbedId    );
    vPrint("    lItalicAngle           %d\n",      pifi->lItalicAngle);
    vPrint("    lCharBias              %d\n",      pifi->lCharBias   );
    vPrint("    lEmbedId               %d\n"     , pifi->lEmbedId);
    vPrint("    lItalicAngle           %d\n"     , pifi->lItalicAngle);
    vPrint("    lCharBias              %d\n"     , pifi->lCharBias);
    vPrint("    jWinCharSet            %04x\n"   , pifi->jWinCharSet );
    vPrint("    jWinPitchAndFamily     %04x\n"   , pifi->jWinPitchAndFamily );
    vPrint("    usWinWeight            %d\n"     , pifi->usWinWeight );
    vPrint("    flInfo                 %-#8lx\n" , pifi->flInfo );
    vPrint("    fsSelection            %-#6lx\n" , pifi->fsSelection );
    vPrint("    fsType                 %-#6lx\n" , pifi->fsType );
    vPrint("    fwdUnitsPerEm          %d\n"     , pifi->fwdUnitsPerEm );
    vPrint("    fwdLowestPPEm          %d\n"     , pifi->fwdLowestPPEm );
    vPrint("    fwdWinAscender         %d\n"     , pifi->fwdWinAscender );
    vPrint("    fwdWinDescender        %d\n"     , pifi->fwdWinDescender );
    vPrint("    fwdMacAscender         %d\n"     , pifi->fwdMacAscender );
    vPrint("    fwdMacDescender        %d\n"     , pifi->fwdMacDescender );
    vPrint("    fwdMacLineGap          %d\n"     , pifi->fwdMacLineGap );
    vPrint("    fwdTypoAscender        %d\n"     , pifi->fwdTypoAscender );
    vPrint("    fwdTypoDescender       %d\n"     , pifi->fwdTypoDescender );
    vPrint("    fwdTypoLineGap         %d\n"     , pifi->fwdTypoLineGap );
    vPrint("    fwdAveCharWidth        %d\n"     , pifi->fwdAveCharWidth );
    vPrint("    fwdMaxCharInc          %d\n"     , pifi->fwdMaxCharInc );
    vPrint("    fwdCapHeight           %d\n"     , pifi->fwdCapHeight );
    vPrint("    fwdXHeight             %d\n"     , pifi->fwdXHeight );
    vPrint("    fwdSubscriptXSize      %d\n"     , pifi->fwdSubscriptXSize );
    vPrint("    fwdSubscriptYSize      %d\n"     , pifi->fwdSubscriptYSize );
    vPrint("    fwdSubscriptXOffset    %d\n"     , pifi->fwdSubscriptXOffset );
    vPrint("    fwdSubscriptYOffset    %d\n"     , pifi->fwdSubscriptYOffset );
    vPrint("    fwdSuperscriptXSize    %d\n"     , pifi->fwdSuperscriptXSize );
    vPrint("    fwdSuperscriptYSize    %d\n"     , pifi->fwdSuperscriptYSize );
    vPrint("    fwdSuperscriptXOffset  %d\n"     , pifi->fwdSuperscriptXOffset);
    vPrint("    fwdSuperscriptYOffset  %d\n"     , pifi->fwdSuperscriptYOffset);
    vPrint("    fwdUnderscoreSize      %d\n"     , pifi->fwdUnderscoreSize );
    vPrint("    fwdUnderscorePosition  %d\n"     , pifi->fwdUnderscorePosition);
    vPrint("    fwdStrikeoutSize       %d\n"     , pifi->fwdStrikeoutSize );
    vPrint("    fwdStrikeoutPosition   %d\n"     , pifi->fwdStrikeoutPosition );
    vPrint("    chFirstChar            %-#4x\n"  , (int) (BYTE) pifi->chFirstChar );
    vPrint("    chLastChar             %-#4x\n"  , (int) (BYTE) pifi->chLastChar );
    vPrint("    chDefaultChar          %-#4x\n"  , (int) (BYTE) pifi->chDefaultChar );
    vPrint("    chBreakChar            %-#4x\n"  , (int) (BYTE) pifi->chBreakChar );
    vPrint("    wcFirsChar             %-#6x\n"  , pifi->wcFirstChar );
    vPrint("    wcLastChar             %-#6x\n"  , pifi->wcLastChar );
    vPrint("    wcDefaultChar          %-#6x\n"  , pifi->wcDefaultChar );
    vPrint("    wcBreakChar            %-#6x\n"  , pifi->wcBreakChar );
    vPrint("    ptlBaseline            {%d,%d}\n"  , pifi->ptlBaseline.x,
                                                   pifi->ptlBaseline.y );
    vPrint("    ptlAspect              {%d,%d}\n"  , pifi->ptlAspect.x,
                                                   pifi->ptlAspect.y );
    vPrint("    ptlCaret               {%d,%d}\n"  , pifi->ptlCaret.x,
                                                   pifi->ptlCaret.y );
    vPrint("    rclFontBox             {%d,%d,%d,%d}\n",pifi->rclFontBox.left,
                                                      pifi->rclFontBox.top,
                                                      pifi->rclFontBox.right,
                                                      pifi->rclFontBox.bottom );
    vPrint("    achVendId              \"%c%c%c%c\"\n",pifi->achVendId[0],
                                                   pifi->achVendId[1],
                                                   pifi->achVendId[2],
                                                   pifi->achVendId[3] );
    vPrint("    cKerningPairs          %d\n"     , pifi->cKerningPairs );
    vPrint("    ulPanoseCulture        %-#8lx\n" , pifi->ulPanoseCulture);
    vPrint(
           "    panose                 {%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x}\n"
                                                 , ppan->bFamilyType
                                                 , ppan->bSerifStyle
                                                 , ppan->bWeight
                                                 , ppan->bProportion
                                                 , ppan->bContrast
                                                 , ppan->bStrokeVariation
                                                 , ppan->bArmStyle
                                                 , ppan->bLetterform
                                                 , ppan->bMidline
                                                 , ppan->bXHeight );
    vCheckIFIMETRICS(pifi, vPrint);
}
#endif                /* PRINT_INFO */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\driverui\uni\sfupgrd.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

     sfupgrd.c

Abstract:

    Routines to upgrade the NT 4.0 SoftFont File format to NT 5.0 file format.

Environment:

    Windows NT Unidrv driver

Revision History:

    29/10/97 -ganeshp-
        Created

--*/
#include "precomp.h"

#ifndef WINNT_40 

// NT 5.0 only


//
// Internal helper function prototype
//

HANDLE HCreateHeapForCI();


BOOL
BSoftFontsAreInstalled(
    HANDLE   hPrinter
    )
/*++
Routine Description:

Arguments:
    Determine whether font installer keys are present in the registry or not.

Return Value:
    TRUE/FALSE,  TRUE meaning New keys are Present

Note:

    10/29/1997 -ganeshp-
        Created it.
--*/

{

    BOOL    bRet      = FALSE;
    DWORD   dwType    = REG_SZ ;
    DWORD   cbNeeded  = 0;
    DWORD   dwErrCode = 0;

    dwErrCode = GetPrinterData( hPrinter, REGVAL_FONTFILENAME, &dwType,
                                NULL,0, &cbNeeded );

    if ( cbNeeded &&
         ((dwErrCode == ERROR_MORE_DATA) ||
          (dwErrCode == ERROR_INSUFFICIENT_BUFFER))
       )
    {
        bRet = TRUE;
    }

    return bRet;
}

BOOL
BIsUNIDRV(
    PDRIVER_UPGRADE_INFO_2 pUpgradeInfo
    )
/*++

Routine Description:
    This routine checks if new driver is UNIDRV base GPD minidriver.

Arguments:

    pUpgradeInfo    Upgrade Info 2 structure.

Return Value:

    TRUE if it's UNIDRV, Otherwise FALSE.

Note:

--*/
{
    PWSTR pDriverName;     // Old Printer Driver data file name

    //
    // Search "UNIDRV" string in the pDriverPath. If there is, 
    // it is GPD base printer driver.
    // since the end of string must be "UNIDRV.DLL" in case of GPD minidriver.
    // Compare it with "unidrv.dll".
    //
    // Get the unqulaified driver name. Add +1 to point to first letter 
    // of driver name.
    //
    pDriverName = wcsrchr( pUpgradeInfo->pDriverPath, L'\\' ) + 1; 
    return (0 == _wcsicmp(pDriverName, L"unidrv.dll"));

}


BOOL
BUpgradeSoftFonts(
    PCOMMONINFO             pci,
    PDRIVER_UPGRADE_INFO_2  pUpgradeInfo
)

/*++

Routine Description:
    This routine upgrade the NT 4.0 soft font file to NT 5.0  format.

Arguments:

    pci             Structure containing all necessary information.
    pUpgradeInfo    Upgrade Info structure.

Return Value:

    TRUE for success, FALSE for failure.
Note:
    10/29/97: Created it -ganeshp-


--*/
{

    INT      iNum;              // Number of fonts
    INT      iI,iRet;           // Loop parameter
    FI_MEM   FIMem;             // For accessing installed fonts
    BOOL     bRet;
    LPTSTR   pOldDataFile;     // Old Printer Driver data file name

    bRet    = FALSE;
    pOldDataFile = NULL ;

    ASSERT(pci);

    //
    // Create heap if it is not allocated yet.
    //
    if (!pci->hHeap)
        pci->hHeap = HCreateHeapForCI();

    //
    // Check if any soft fonts are installed. If yes then we don't need to do
    // anything. return TRUE.
    //

    pOldDataFile = pUpgradeInfo->pDataFile;

    if ( pUpgradeInfo->pOldDriverDirectory &&
         !BIsUNIDRV(pUpgradeInfo) &&
         !BSoftFontsAreInstalled(pci->hPrinter) )
    {
        //
        // Initialize Old driver's datafile
        //

        if (iNum = IFIOpenRead( &FIMem, pOldDataFile) )
        {
            VERBOSE(( "UniFont!iXtraFonts: ++++ Got %ld EXTRA FONTS", iNum ));

            for( iRet = 0, iI = 0; iI < iNum; ++iI )
            {
                if( BFINextRead( &FIMem ) )
                {
                    PVOID pPCLData;

                    //
                    // Get the Pointer to PCL data
                    //
                    pPCLData = FIMem.pbBase + FIMem.ulVarOff;

                    //
                    // Now Call the fontinstaller to install the font.
                    //
                    if (BInstallSoftFont( pci->hPrinter, pci->hHeap, pPCLData, FIMem.ulVarSize) )
                        ++iRet;
                    else
                    {
                        ERR(("Unidrvui!BUpgradeSoftFonts:BInstallSoftFont Failed.\n"));
                        goto ErrorExit;
                    }
                }
                else
                    break;              /* Should not happen */
            }

            if( !BFICloseRead(&FIMem))
            {
                ERR(("\nUniFont!iXtraFonts: bFICloseRead() fails\n" ));
            }
        }
    }


    bRet = TRUE;

    //
    // Here means that there are no fonts OR that the HeapAlloc()
    // failed.  In either case,  return no fonts.
    //

    ErrorExit:

    return  bRet;
}
#endif //ifndef WINNT_40
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\driverui\uni\softfont.h ===
/***************************** MODULE HEADER ********************************
 *  sf_pcl.h
 *      Structures etc used to define PCL Softfont file format.
 *
 *  Copyright (C) 1992  Microsoft Corporation.
 *
 *****************************************************************************/

#ifndef SOFTFONT_H_

#define SOFTFONT_H_

/*
 *    A structure corresponding to the layout of Font Descriptor for a PCL
 *  soft font file.  The Font Descriptor is at the beginning of the file,
 *  and contains overall font info.
 *
 *    Note that there are several different versions of this structure;
 *  the first is the original (pre LJ4) format,  while the second is
 *  the LJ4 introduced variety that allows specifying the resolution
 *  at which the font was digitised.  This is used for downloading TT
 *  fonts etc. which are generated at the graphics resolution.
 *
 *    NOTE:  The data layout is designed for the 68000 family - which is
 *  big endian.  So,  an amount of shuffling is required for little
 *  endian machines like the x86.
 */

typedef  signed  char  SBYTE;

#define SFH_NM_SZ       16      /* Bytes allowed in name field */

typedef  struct
{
    WORD   wSize;               /* Number of bytes in here */
    BYTE   bFormat;             /* Format: original, TT, intellifont, etc */
    BYTE   bFontType;           /* 7, 8 or PC-8 style font */
    WORD   wRes1;               /* Reserved */
    WORD   wBaseline;           /* Baseline to cell top, PCL dots */
    WORD   wCellWide;           /* Cell width in dots */
    WORD   wCellHeight;         /* Cell height in dots */
    BYTE   bOrientation;        /* Orientation: 0 portrait, 1 Landscape */
    BYTE   bSpacing;            /* 0 fixed pitch, 1 proportional */
    WORD   wSymSet;             /* Symbol set, using HP encoding */
    WORD   wPitch;              /* Pitch in quarter dot units == HMI */
    WORD   wHeight;             /* Design height in quarter dot units */
    WORD   wXHeight;            /* Design height, quarter dots, of x */
    SBYTE  sbWidthType;         /* Relative width of glyphs */
    BYTE   bStyle;              /* 0 for regular, 1 for italic */
    SBYTE  sbStrokeW;           /* Stroke weight; -7 (thin) to +7 (thick) */
    BYTE   bTypeface;           /* Typeface ID - predefined types */
    BYTE   bRes2;
    BYTE   bSerifStyle;         /* Serif style; predefined values */
    WORD   wRes3;
    SBYTE  sbUDist;             /* Underline distance from baseline */
    BYTE   bUHeight;            /* Underline height */
    WORD   wTextHeight;         /* Quarter dot interline spacing */
    WORD   wTextWidth;          /* Quarter dot glyph increment */
    WORD   wRes4;
    WORD   wRes5;
    BYTE   bPitchExt;           /* Additional pitch resolution */
    BYTE   bHeightExt;          /* Ditto, for height */
    WORD   wRes6;
    WORD   wRes7;
    WORD   wRes8;
    char   chName[ SFH_NM_SZ ]; /* May not be null terminated! */
} SF_HEADER;


typedef  struct
{
    WORD   wSize;               /* Number of bytes in here */
    BYTE   bFormat;             /* Format: original, TT, intellifont, etc */
    BYTE   bFontType;           /* 7, 8 or PC-8 style font */
    WORD   wRes1;               /* Reserved */
    WORD   wBaseline;           /* Baseline to cell top, PCL dots */
    WORD   wCellWide;           /* Cell width in dots */
    WORD   wCellHeight;         /* Cell height in dots */
    BYTE   bOrientation;        /* Orientation: 0 portrait, 1 Landscape */
    BYTE   bSpacing;            /* 0 fixed pitch, 1 proportional */
    WORD   wSymSet;             /* Symbol set, using HP encoding */
    WORD   wPitch;              /* Pitch in quarter dot units == HMI */
    WORD   wHeight;             /* Design height in quarter dot units */
    WORD   wXHeight;            /* Design height, quarter dots, of x */
    SBYTE  sbWidthType;         /* Relative width of glyphs */
    BYTE   bStyle;              /* 0 for regular, 1 for italic */
    SBYTE  sbStrokeW;           /* Stroke weight; -7 (thin) to +7 (thick) */
    BYTE   bTypeface;           /* Typeface ID - predefined types */
    BYTE   bRes2;
    BYTE   bSerifStyle;         /* Serif style; predefined values */
    WORD   wRes3;
    SBYTE  sbUDist;             /* Underline distance from baseline */
    BYTE   bUHeight;            /* Underline height */
    WORD   wTextHeight;         /* Quarter dot interline spacing */
    WORD   wTextWidth;          /* Quarter dot glyph increment */
    WORD   wRes4;
    WORD   wRes5;
    BYTE   bPitchExt;           /* Additional pitch resolution */
    BYTE   bHeightExt;          /* Ditto, for height */
    WORD   wRes6;
    WORD   wRes7;
    WORD   wRes8;
    char   chName[ SFH_NM_SZ ]; /* May not be null terminated! */
    WORD   wXResn;              /* X resolution of font design */
    WORD   wYResn;              /* Y design resolution */
} SF_HEADER20;


/*
 *   Typical values used above to identify different types of fonts.
 */

#define PCL_FM_ORIGINAL     0     /* Bitmap font, digitised at 300 DPI */
#define PCL_FM_RESOLUTION  20     /* Bitmap font, includes digitised resn */
#define PCL_FM_TT          15     /* TT scalable, bound or unbound */


/*   bFontType values */

#define PCL_FT_7BIT     0       /* 7 bit: glyphs from 32 - 127 inc */
#define PCL_FT_8LIM     1       /* 8 bit, glyphs 32 - 127 & 160 - 255 */
#define PCL_FT_PC8      2       /* PC-8, glyphs 0 - 255, transparent too! */


/*   sbStrokeW values */

#define PCL_LIGHT       -3
#define PCL_BOLD         3



/*
 *   In addition,  each glyph in the font contains a Character Descriptor.
 *  So now define a structure for that too!
 */

typedef  struct
{
    BYTE    bFormat;            /* Format identifier: 4 for PCL 4 */
    BYTE    bContinuation;      /* Set if continuation of prior entry */
    BYTE    bDescSize;          /* Size of this structure */
    BYTE    bClass;             /* Format of data: 1 for PCL 4 */
    BYTE    bOrientation;       /* Zero == portrait; 1 == landscape */
    BYTE    bRes0;
    short   sLOff;              /* Dots from ref. to left side of char */
    short   sTOff;              /* Dots from ref. to top of char */
    WORD    wChWidth;           /* Char width in dots */
    WORD    wChHeight;          /* Char height in dots */
    WORD    wDeltaX;            /* Quarter dot position increment after print */
} CH_HEADER;

/*
 *   Character records can be continued due to the limit of 32767 bytes in
 * a PCL command sequence.  Continuation records have the following
 * format.  Really it is only the first two elements of the above
 * structure.
 */

typedef  struct
{
    BYTE    bFormat;            /* Format identifier; 4 for PCL 4 */
    BYTE    bContinuation;      /* TRUE if this is a continuation record */
}  CH_CONT_HDR;

/*
 *   Values for some of the fields in the above structs.
 */

/*  bFormat */
#define CH_FM_RASTER             4      /* Bitmap type */
#define CH_FM_SCALE             10      /* Intellifont scalable */

/*  bClass */
#define CH_CL_BITMAP            1       /* A bitmap font */
#define CH_CL_COMPBIT           2       /* Compressed bitmap */
#define CH_CL_CONTOUR           3       /* Intellifont scalable contour */
#define CH_CL_COMPCONT          4       /* Ditto, but compound contour */

#define EXP_SIZE        2

#define FDH_VER 0x100           /* 1.00 in BCD */

/*
 *  Flags bits.
 */
#define FDH_SOFT        0x0001  /* Softfont, thus needs downloading */
#define FDH_CART        0x0002  /* This is a cartridge font */
#define FDH_CART_MAIN   0x0004  /* Main (first) entry for this cartridge */

/*
 *  Selection criteria bits:  dwSelBits.  These bits are used as
 * follows.  During font installation,  the installer set the following
 * values as appropriate.  During initialisation,  the driver sets
 * up a mask of these bits,  depending upon the printer's abilities.
 * For example,  the FDH_SCALABLE bit is set only if the printer can
 * handle scalable fonts.   When the fonts are examined to see if
 * they are usable,  the following test is applied:
 *
 *      (font.dwSelBits & printer.dwSelBits) == font.dwSelBits
 *
 * If true,  the font is usable.
 */

#define FDH_LANDSCAPE   0x00000001      /* Font is landscape orientation */
#define FDH_PORTRAIT    0x00000002      /* Font is portrait */
#define FDH_OR_REVERSE  0x00000004      /* 180 degree rotation of above */
#define FDH_BITMAP      0x00000008      /* Bitmap font */
#define FDH_COMPRESSED  0x00000010      /* Data is compressed bitmap */
#define FDH_SCALABLE    0x00000020      /* Font is scalable */
#define FDH_CONTOUR     0x00000040      /* Intellifont contour */

#define FDH_ERROR       0x80000000      /* Set if some error condition */

#endif  // #ifndef SOFTFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\driverui\uni\osffread.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    osffread.c

Abstract:

    Functions to assist processing of the data of NT 4.0 soft font
    installer file format.

Environment:

    Windows NT Unidrv driver

Revision History:

    12/02/96 -ganeshp-
        Created

--*/

#include "precomp.h"

#ifndef WINNT_40

// NT 5.0 only


//
// Local function prototypes.
//

INT
IFIOpenRead(
    FI_MEM  *pFIMem,                /* Output goes here */
    PWSTR    pwstrName             /* Name of printer data file */
    )
/*++

Routine Description:

    Makes the font installer file accessible & memory mapped.  Called
    by a driver to gain access to the fonts in the font installer's
    output file.


Arguments:


    FI_MEM : Font Installer Header
    PWSTR  : Font file.

    Return Value:

    Number of records in the file;  0 for an empty/non-existant file.

Note:
    12-02-96: Created it -ganeshp-
--*/

{

    INT     iRet;
    DWORD   dwSize;             /* Size of buffer needed for file name */
    PWSTR   pwstrLocal;

    //
    // Initiazlie to ZERO.
    //
    iRet = 0;

    //
    // Initalize pFIMem
    //
    pFIMem->hFile =  NULL;      /* No data until we have it */
    pFIMem->pbBase = NULL;

    //
    // First map the file to memory.  However,we do need firstly to
    // generate the file name of interest.  This is based on the data
    // file name for this type of printer.
    // Allocate more storage than is indicated:  we MAY want to add
    // a prefix to the file name rather than replace the existing one.
    //

    //
    // Filename + ".fi_" + NULL
    //
    dwSize = sizeof( WCHAR ) * (wcslen( pwstrName ) + 4 + 1);

    if( pwstrLocal = (PWSTR)MemAllocZ( dwSize ) )
    {
        /*  Got the memory,  so fiddle the file name to our standard */

        int    iPtOff;             /* Location of '.' */
        DWORD  dwAttributes;

        wcscpy( pwstrLocal, pwstrName );

        //
        // Go looking for a '.' - if not found,  append to string.
        //

        iPtOff = wcslen( pwstrLocal );

        while( --iPtOff > 0 )
        {
            if( *(pwstrLocal + iPtOff) == (WCHAR)'.' )
                break;
        }

        if( iPtOff <= 0 )
        {
            iPtOff = wcslen( pwstrLocal );              /* Presume none! */
            *(pwstrLocal + iPtOff) = L'.';
        }
        ++iPtOff;               /* Skip the period */

        //
        // Generate the name and map the file
        //
        wcscpy( pwstrLocal + iPtOff, FILE_FONTS );

        //
        // Check the existence of soft font file.
        //
        dwAttributes = GetFileAttributes(pwstrLocal);

        //
        // If the function succeeds, open file. Otherwise return 0.
        //
        if (dwAttributes != 0xffffffff)
        {
            pFIMem->hFile = MapFile( pwstrLocal);

            if (pFIMem->hFile)
            {
                pFIMem->pbBase = pFIMem->hFile;

                iRet = IFIRewind( pFIMem );
            }
        }

        MemFree( pwstrLocal );        /* No longer needed */
    }

    return iRet;

}


BOOL
BFINextRead(
    FI_MEM   *pFIMem
    )
/*++

Routine Description:

    Updates pFIMem to the next entry in the font installer file.
    Returns TRUE if OK, and updates the pointers in pFIMem.

Arguments:

    FI_MEM : Font Installer Header

    Return Value:

    TRUE/FALSE.   FALSE for EOF,  otherwise pFIMem updated.

Note:
    12-02-96: Created it -ganeshp-
--*/

{
    FF_HEADER      *pFFH;               /* Overall file header */
    FF_REC_HEADER  *pFFRH;              /* Per record header */

    /*
     *  Validate that we have valid data.
     */


    if( pFIMem == 0 || pFIMem->hFile == NULL )
        return  FALSE;                          /* Empty file */


    pFFH = (FF_HEADER *)pFIMem->pbBase;

    if( pFFH->ulID != FF_ID )
    {
        ERR(( "UnidrvUI!bFINextRead: FF_HEADER has invalid ID\n" ));
        return  FALSE;
    }

    /*
     *   If pFIMem->pvFix == 0, we should return the data from the
     * first record.  Otherwise,  return the next record in the chain.
     * This is done to avoid the need to have a ReadFirst()/ReadNext()
     * pair of functions.
     */

    if( pFIMem->pvFix )
    {
        /*
         *   The header is located immediately before the data we last
         * returned for the fixed portion of the record.  SO,  we back
         * over it to get the header which then gives us the address
         * of the next header.
         */

        pFFRH = (FF_REC_HEADER *)((BYTE *)pFIMem->pvFix -
                                                 sizeof( FF_REC_HEADER ));

        if( pFFRH->ulRID != FR_ID )
        {
            ERR(( "UnidrvUI!bFINextRead: Invalid FF_REC_HEADER ID\n" ));
            return  FALSE;
        }

        /*
         *   We could check here for EOF on the existing structure, but this
         * is not required BECAUSE THE ulNextOff field will be 0, so when
         * it is added to our current address,  we don't move.  Hence, the
         * check for the NEW address is OK to detect EOF.
         */

        (BYTE *)pFFRH += pFFRH->ulNextOff;              /* Next entry */

    }
    else
    {
        /*   Point to the first record.  */
        pFFRH = (FF_REC_HEADER *)(pFIMem->pbBase + pFFH->ulFixData);
    }

    if( pFFRH->ulNextOff == 0 )
        return  FALSE;

    pFIMem->pvFix = (BYTE *)pFFRH + sizeof( FF_REC_HEADER );
    pFIMem->ulFixSize = pFFRH->ulSize;

    if( pFIMem->ulVarSize = pFFRH->ulVarSize )
        pFIMem->ulVarOff = pFFRH->ulVarOff + pFFH->ulVarData;
    else
        pFIMem->ulVarOff = 0;              /* None here */


    return  TRUE;

}


INT
IFIRewind(
    FI_MEM   *pFIMem               /* File of importance */
    )
/*++

Routine Description:

    Reset pFIMem to the first font in the file.

Arguments:

    FI_MEM : Font Installer Header

    Return Value:

    Number of entries in the file.

Note:
    12-02-96: Created it -ganeshp-
--*/

{
    /*
     *  Not hard!  The pFIMem contains the base address of the file, so we
     * use this to find the address of the first record,  and any variable
     * data that corresponds with it.
     */

    FF_HEADER      *pFFH;
    FF_REC_HEADER  *pFFRH;

    if( pFIMem == 0 || pFIMem->hFile == NULL )
        return  0;                              /* None! */


    /*
     *   The location of the first record is specified in the header.
     */

    pFFH = (FF_HEADER *)pFIMem->pbBase;
    if( pFFH->ulID != FF_ID )
    {
        ERR(( "UnidrvUI!iFIRewind: FF_HEADER has invalid ID\n" ));
        return  0;
    }

    pFFRH = (FF_REC_HEADER *)(pFIMem->pbBase + pFFH->ulFixData);

    if( pFFRH->ulRID != FR_ID )
    {
        ERR(( "UnidrvUI!iFIRewind: Invalid FF_REC_HEADER ID\n" ));
        return  0;
    }

    /*
     * Set the pvFix field in the header to 0.  This is used in bFINextRead
     * to mean that the data for the first record should be supplied.
     */
    pFIMem->pvFix = 0;          /* MEANS USE FIRST NEXT READ */
    pFIMem->ulFixSize = 0;
    pFIMem->ulVarOff = 0;       /* None here */

    return  pFFH->ulRecCount;

}


BOOL
BFICloseRead(
    FI_MEM  *pFIMem                /* File/memory we are finished with */
    )
/*++

Routine Description:

    Called when finished with this font file.

Arguments:

    FI_MEM : Font Installer Header
    PDEV:    Pointer to PDEV

    Return Value:

    TRUE for success and FALSE for failure.

Note:
    12-02-96: Created it -ganeshp-
--*/

{
    /*
     *   Easy!  All we need do is unmap the file.  We have the address too!
     */

    BOOL   bRet;                /* Return code */


    if( pFIMem == 0 || pFIMem->hFile == NULL )
        return  TRUE;           // Nothing there to Free.


    bRet =  FREEMODULE( pFIMem->hFile);
    pFIMem->hFile = NULL;       // Stops freeing more than once


    return  bRet;

}


PVOID
MapFile(
    PWSTR   pwstr
    )
/*++
Routine Description:
    Returns a pointer to the mapped file defined by pwstr.

Arguments:
    pwstr   UNICODE string containing fully qualified pathname of the
            file to map.

Return Value:
    Pointer to mapped memory if success, NULL if error.

Note:
    UnmapViewOfFile will have to be called by the user at some point to free up
    this allocation.Macro FREEMODULE can be used for this purpose.

    11/3/1997 -ganeshp-
        Created it.
--*/

{
    PVOID   pv;
    HANDLE  hFile, hFileMap;

    //
    // open the file we are interested in mapping.
    //

    pv = NULL;

    if ((hFile = CreateFileW(pwstr,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL))
        != INVALID_HANDLE_VALUE)
    {
        //
        // create the mapping object.
        //

        if (hFileMap = CreateFileMappingW(hFile,
                                          NULL,
	          PAGE_READONLY,
	          0,
	          0,
	          (PWSTR)NULL))
        {
            // 
            // get the pointer mapped to the desired file.
            //

            if (!(pv = (PVOID)MapViewOfFile(hFileMap, FILE_MAP_READ, 0, 0, 0)))
            {
                ERR(("Unidrvui!MapFile: MapViewOfFile failed.\n"));
            }

            //
            // now that we have our pointer, we can close the file and the
            // mapping object.
            //

            if (!CloseHandle(hFileMap))
                ERR(("Unidrvui!MapFile: CloseHandle(hFileMap) failed.\n"));
        }
        else
            ERR(("Unidrvui!MapFile:CreateFileMappingW failed: %s\n",pwstr));

        if (!CloseHandle(hFile))
            ERR(("Unidrvui!MapFile: CloseHandle(hFile) failed.\n"));
    }
    else
        ERR(("Unidrvui!Mapfile:CreateFileW failed for %s\n",pwstr));

    return(pv);
}

#endif //ifndef WINNT_40
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\driverui\uni\unidrv.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    unidrv.c

Abstract:

    This file handles Unidrv specific UI options

Environment:

    Win32 subsystem, DriverUI module, user mode

Revision History:

    12/17/96 -amandan-
        Created it.

--*/

#include "precomp.h"
#include <ntverp.h>


DWORD DwCollectFontCart(PUIDATA, PWSTR);
PWSTR PwstrGetFontCartSelections(HANDLE, HANDLE, PDWORD);
INT   IGetCurrentFontCartIndex(POPTTYPE, PWSTR);
PWSTR PwstrGetFontCartName( PCOMMONINFO, PUIINFO, FONTCART *, DWORD, HANDLE);
DWORD DwGetExternalCartridges(HANDLE, HANDLE, PWSTR *);


DWORD
_DwEnumPersonalities(
    PCOMMONINFO pci,
    PWSTR       pwstrOutput
    )

/*++

Routine Description:

    Enumerate the list of supported printer description languages

Arguments:

    pci - Points to common printer info
    pwstrOutput - Points to output buffer

Return Value:

    Number of personalities supported
    GDI_ERROR if there is an error

--*/

{

    PWSTR pwstrPersonality = PGetReadOnlyDisplayName(pci,
                                          pci->pUIInfo->loPersonality);

    if (pwstrPersonality == NULL)
    {
        SetLastError(ERROR_NOT_SUPPORTED);
        return GDI_ERROR;
    }

    if (pwstrOutput)
        CopyString(pwstrOutput, pwstrPersonality, CCHLANGNAME);

    return 1;
}



DWORD
_DwGetFontCap(
    PUIINFO     pUIInfo
    )

/*++

Routine Description:

    Get the font capability for DrvDeviceCapabilites (DC_TRUETYPE)

Arguments:

    pUIInfo - Pointer to UIINFO

Return Value:

    DWORD describing the TrueType cap for Unidrv

--*/

{
    DWORD dwRet;

    if (pUIInfo->dwFlags & FLAG_FONT_DOWNLOADABLE)
        dwRet = (DWORD) (DCTT_BITMAP | DCTT_DOWNLOAD);
    else
        dwRet = DCTT_BITMAP;

    return dwRet;
}

DWORD
_DwGetOrientationAngle(
    PUIINFO     pUIInfo,
    PDEVMODE    pdm
    )

/*++

Routine Description:

    Get the orienation angle requested by DrvDeviceCapabilities(DC_ORIENTATION)

Arguments:

    pUIInfo - Pointer to UIINFO
    pdm  - Pointer to DEVMODE

Return Value:

    The angle (90 or 270 or landscape rotation)

Note:

--*/

{
    DWORD        dwRet = GDI_ERROR;
    DWORD        dwIndex;
    PORIENTATION pOrientation;
    PFEATURE     pFeature;

    if (pFeature = GET_PREDEFINED_FEATURE(pUIInfo, GID_ORIENTATION))
    {
        //
        // Currently Unidrv only allows at most 2 options for feature "Orientation".
        // So when we see the first non-Portrait option, that's the Landscape option
        // we can use to get the orientation angle.
        //

        pOrientation = (PORIENTATION)PGetIndexedOption(pUIInfo, pFeature, 0);

        for (dwIndex = 0; dwIndex < pFeature->Options.dwCount; dwIndex++, pOrientation++)
        {
            if (pOrientation->dwRotationAngle == ROTATE_90)
            {
                return 90;
            }
            else if (pOrientation->dwRotationAngle == ROTATE_270)
            {
                return 270;
            }
        }

        //
        // If we are here, it means the printer doesn't support Landscape
        // orientation, so we return angle 0.
        //

        return 0;
    }

    return dwRet;
}

BOOL
_BPackOrientationItem(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack the orientation feature for Doc property sheet

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE for success and FALSE for failure

--*/

{
    return BPackItemPrinterFeature(
                pUiData,
                GET_PREDEFINED_FEATURE(pUiData->ci.pUIInfo, GID_ORIENTATION),
                TVITEM_LEVEL1,
                DMPUB_ORIENTATION,
                (ULONG_PTR)ORIENTATION_ITEM,
                HELP_INDEX_ORIENTATION);
}


BOOL
BPackHalftoneFeature(
    IN OUT PUIDATA  pUiData
    )
/*++

Routine Description:

    Pack the halfone feature

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE for success and FALSE for failure

Note:

--*/

{
    return BPackItemPrinterFeature(
                pUiData,
                GET_PREDEFINED_FEATURE(pUiData->ci.pUIInfo, GID_HALFTONING),
                TVITEM_LEVEL1,
                DMPUB_NONE,
                (ULONG_PTR)HALFTONING_ITEM,
                HELP_INDEX_HALFTONING_TYPE);
}

BOOL
BPackColorModeFeature(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack Color mode feature

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE for success and FALSE for failure

--*/

{
    return BPackItemPrinterFeature(
                pUiData,
                GET_PREDEFINED_FEATURE(pUiData->ci.pUIInfo, GID_COLORMODE),
                TVITEM_LEVEL1,
                DMPUB_NONE,
                (ULONG_PTR)COLORMODE_ITEM,
                HELP_INDEX_COLORMODE_TYPE);
}


BOOL
BPackQualityFeature(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack Quality Macro feature

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE for success and FALSE for failure

--*/

{
#ifndef WINNT_40
    INT i, iSelection, iParamCount = 0;
    PUIINFO pUIInfo = pUiData->ci.pUIInfo;
    POPTPARAM   pParam;
    PEXTCHKBOX  pExtCheckbox;
    INT         Quality[MAX_QUALITY_SETTINGS];

    memset(&Quality, -1, sizeof(INT)*MAX_QUALITY_SETTINGS);

    if (pUIInfo->liDraftQualitySettings != END_OF_LIST )
    {
        Quality[QS_DRAFT] = QS_DRAFT;
        iParamCount++;
    }

    if ( pUIInfo->liBetterQualitySettings != END_OF_LIST )
    {
        Quality[QS_BETTER] = QS_BETTER;
        iParamCount++;
    }

    if ( pUIInfo->liBestQualitySettings != END_OF_LIST)
    {
        Quality[QS_BEST] = QS_BEST;
        iParamCount++;
    }

    if (iParamCount < MIN_QUALITY_SETTINGS)
    {
        return TRUE;
    }

    if (pUiData->pOptItem)
    {
        pParam = PFillOutOptType(pUiData->pOptType,
                                 TVOT_3STATES,
                                 MAX_QUALITY_SETTINGS,
                                 pUiData->ci.hHeap);

        if (pParam == NULL)
            return FALSE;

        for (i = QS_BEST; i < QS_BEST + MAX_QUALITY_SETTINGS; i ++)
        {
            pParam->cbSize = sizeof(OPTPARAM);
            pParam->pData = (PWSTR)ULongToPtr(IDS_QUALITY_FIRST + i);
            pParam->IconID = IDI_USE_DEFAULT;
            pParam++;

        }

        // Look for the current selection in the private devmode
        //

        if (pUiData->ci.pdm->dmDitherType & DM_DITHERTYPE &&
            pUiData->ci.pdm->dmDitherType >= QUALITY_MACRO_START &&
            pUiData->ci.pdm->dmDitherType < QUALITY_MACRO_END)
        {
            iSelection = pUiData->ci.pdm->dmDitherType;
        }
        else if (Quality[pUiData->ci.pdmPrivate->iQuality] < 0)
            iSelection = pUiData->ci.pUIInfo->defaultQuality;
        else
            iSelection = pUiData->ci.pdmPrivate->iQuality;


        //
        // Fill out OPTITEM, OPTTYPE, and OPTPARAM structures
        //

        pExtCheckbox = HEAPALLOC(pUiData->ci.hHeap, sizeof(EXTCHKBOX));

        if (pExtCheckbox == NULL)
        {
            ERR(("Memory allocation failed\n"));
            return FALSE;
        }

        pExtCheckbox->cbSize = sizeof(EXTCHKBOX);
        pExtCheckbox->Flags = ECBF_CHECKNAME_ONLY;
        pExtCheckbox->pTitle = (PWSTR) IDS_QUALITY_CUSTOM;
        pExtCheckbox->pSeparator = NULL;
        pExtCheckbox->pCheckedName = (PWSTR) IDS_QUALITY_CUSTOM;
        pExtCheckbox->IconID = IDI_CPSUI_GENERIC_ITEM;

        pUiData->pOptItem->pExtChkBox = pExtCheckbox;

        if (pUiData->ci.pdmPrivate->dwFlags & DXF_CUSTOM_QUALITY)
            pUiData->pOptItem->Flags |= OPTIF_ECB_CHECKED;

        FILLOPTITEM(pUiData->pOptItem,
                    pUiData->pOptType,
                    ULongToPtr(IDS_QUALITY_SETTINGS),
                    IntToPtr(iSelection),
                    TVITEM_LEVEL1,
                    DMPUB_QUALITY,
                    QUALITY_SETTINGS_ITEM,
                    HELP_INDEX_QUALITY_SETTINGS);


           pUiData->pOptItem++;
           pUiData->pOptType++;

    }

    pUiData->dwOptItem++;
    pUiData->dwOptType++;

#endif // !WINNT_40

    return TRUE;

}



BOOL
BPackSoftFontFeature(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack Quality Macro feature

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE for success and FALSE for failure

--*/

{
    PUIINFO     pUIInfo = pUiData->ci.pUIInfo;
    PGPDDRIVERINFO  pDriverInfo;
    POPTPARAM   pParam;
    PWSTR       pwstr = NULL;
    DWORD       dwType, dwSize, dwFontFormat;
    OEMFONTINSTPARAM fip;

    pDriverInfo = OFFSET_TO_POINTER(pUiData->ci.pInfoHeader,
                                    pUiData->ci.pInfoHeader->loDriverOffset);

    ASSERT(pDriverInfo != NULL);

    //
    // If the model doesn't support download softfont. we don't add the feature
    //

    dwFontFormat = pDriverInfo->Globals.fontformat;

    if (!(dwFontFormat == FF_HPPCL || dwFontFormat == FF_HPPCL_OUTLINE || dwFontFormat == FF_HPPCL_RES))
        return TRUE;

    //
    // If there is an exe based font installer, we don't add
    // this feature
    //

    dwSize = 0;

    if (GetPrinterData(pUiData->ci.hPrinter, REGVAL_EXEFONTINSTALLER, &dwType, NULL, dwSize, &dwSize) == ERROR_MORE_DATA)
        return TRUE;

    if (pUiData->pOptItem)
    {
        PFN_OEMFontInstallerDlgProc pDlgProc = NULL;

        pParam = PFillOutOptType(pUiData->pOptType,
                                 TVOT_PUSHBUTTON,
                                 1,
                                 pUiData->ci.hHeap);

        if (pParam == NULL)
            return FALSE;

        //
        // Get the String for Soft Fonts
        //

        FOREACH_OEMPLUGIN_LOOP(&pUiData->ci)

            memset(&fip, 0, sizeof(OEMFONTINSTPARAM));
            fip.cbSize = sizeof(OEMFONTINSTPARAM);
            fip.hPrinter = pUiData->ci.hPrinter;
            fip.hModule = ghInstance;
            fip.hHeap = pUiData->ci.hHeap;


            if (HAS_COM_INTERFACE(pOemEntry))
            {
                if (HComOEMFontInstallerDlgProc(pOemEntry,
                                                NULL,
                                                0,
                                                0,
                                                (LPARAM)&fip) == E_NOTIMPL)
                    continue;

                pwstr = fip.pFontInstallerName;
                break;
            }
            else
            {

                if (pDlgProc = GET_OEM_ENTRYPOINT(pOemEntry, OEMFontInstallerDlgProc))
                {
                    (*pDlgProc)(NULL, 0, 0, (LPARAM)&fip);

                    pwstr = fip.pFontInstallerName;

                    break;
                }

            }

        END_OEMPLUGIN_LOOP

        //
        // If that didn't work out, put our string
        //

        if (!pwstr)
        {
            //
            // LoadString's 4th parameter is the max. number of characters to load,
            // so make sure we allocate enough bytes here.
            //

            if (!(pwstr = HEAPALLOC(pUiData->ci.hHeap, MAX_DISPLAY_NAME * sizeof(WCHAR))))
            {
                return FALSE;
            }

            if (!LoadString(ghInstance, IDS_PP_SOFTFONTS, pwstr, MAX_DISPLAY_NAME))
            {
                WARNING(("Soft Font string not found in Unidrv\n"));
                wcscpy(pwstr, L"Soft Fonts");
            }
        }

        pParam->cbSize = sizeof(OPTPARAM);
        pParam->Style = PUSHBUTTON_TYPE_CALLBACK;

        //
        // Fill out OPTITEM, OPTTYPE, and OPTPARAM structures
        //

        FILLOPTITEM(pUiData->pOptItem,
                    pUiData->pOptType,
                    pwstr,
                    NULL,
                    TVITEM_LEVEL1,
                    DMPUB_NONE,
                    SOFTFONT_SETTINGS_ITEM,
                    HELP_INDEX_SOFTFONT_SETTINGS);


           pUiData->pOptItem++;
           pUiData->pOptType++;

    }

    pUiData->dwOptItem++;
    pUiData->dwOptType++;

    return TRUE;

}



BOOL
_BPackDocumentOptions(
    IN OUT PUIDATA  pUiData
    )
/*++

Routine Description:

    Pack Unidrv specific options such are enabling Print text as graphics etc

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE for success and FALSE for failure

Note:

--*/
{
    static CONST WORD ItemInfoTxtAsGrx[] =
    {
        IDS_TEXT_ASGRX, TVITEM_LEVEL1, DMPUB_NONE,
        TEXT_ASGRX_ITEM, HELP_INDEX_TEXTASGRX,
        2, TVOT_2STATES,
        IDS_ENABLED, IDI_CPSUI_ON,
        IDS_DISABLED, IDI_CPSUI_OFF,
        ITEM_INFO_SIGNATURE
    };

    PUNIDRVEXTRA pdmPrivate;
    DWORD        dwSelTxt;
    BOOL         bDisplayTxtAsGrx;
    GPDDRIVERINFO *pDriverInfo;

    pDriverInfo = OFFSET_TO_POINTER(pUiData->ci.pInfoHeader,
                                    pUiData->ci.pInfoHeader->loDriverOffset);

    ASSERT(pDriverInfo != NULL);

    bDisplayTxtAsGrx = ((pUiData->ci.pUIInfo->dwFlags &
                        (FLAG_FONT_DEVICE | FLAG_FONT_DOWNLOADABLE)) &&
                        (pDriverInfo->Globals.printertype != PT_TTY));

    pdmPrivate = pUiData->ci.pdmPrivate;
    dwSelTxt  = (pdmPrivate->dwFlags & DXF_TEXTASGRAPHICS) ? 1 : 0;

    return (BPackColorModeFeature(pUiData) &&
            BPackQualityFeature(pUiData)   &&
            BPackHalftoneFeature(pUiData) &&
            (bDisplayTxtAsGrx ?
             BPackOptItemTemplate(pUiData, ItemInfoTxtAsGrx, dwSelTxt, NULL):TRUE));
}


VOID
_VUnpackDocumentOptions(
    POPTITEM    pOptItem,
    PDEVMODE    pdm
    )

/*++

Routine Description:

    Extract Unidrv devmode information from an OPTITEM
    Stored it back into Unidrv devmode.

Arguments:

    pOptItem - Pointer to an array of OPTITEMs
    pdm - Pointer to a DEVMODE structure

Return Value:

    None

--*/
{
    PUNIDRVEXTRA pdmPrivate;

    pdmPrivate = (PUNIDRVEXTRA) GET_DRIVER_PRIVATE_DEVMODE(pdm);

    switch (GETUSERDATAITEM(pOptItem->UserData))
    {
        case TEXT_ASGRX_ITEM:
            if (pOptItem->Sel == 1)
                pdmPrivate->dwFlags |= DXF_TEXTASGRAPHICS;
            else
                pdmPrivate->dwFlags &= ~DXF_TEXTASGRAPHICS;
            break;


        case QUALITY_SETTINGS_ITEM:
            if (pOptItem->Flags & OPTIF_ECB_CHECKED)
            {
                pdmPrivate->dwFlags |= DXF_CUSTOM_QUALITY;
                pdm->dmDitherType = QUALITY_MACRO_CUSTOM;
            }
            else
            {
                pdmPrivate->dwFlags &= ~DXF_CUSTOM_QUALITY;
                pdm->dmDitherType = QUALITY_MACRO_START + pOptItem->Sel;
            }

            pdm->dmFields |= DM_DITHERTYPE;
            pdmPrivate->iQuality = pOptItem->Sel;

    }
}

BOOL
BPackFontCartsOptions(
    IN OUT PUIDATA  pUiData
    )
/*++

Routine Description:

    Pack Font Cartridge options

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE for success and FALSE for failure

--*/

{

    PUIINFO pUIInfo = pUiData->ci.pUIInfo;
    DWORD   dwFontSlot, dwFontCartsAvailable, dwExtCartsAvailable, dwSize = 0;
    INT     iSelection = -1;
    POPTPARAM pParam;
    PWSTR   pwstrCurrentSelection, pwstrEndSelection, pwstrExtCartNames;


    VERBOSE(("\nUniPackFontCartsOptions:pUIInfo->dwCartridgeSlotCount = %d\n",pUIInfo->dwCartridgeSlotCount));

    if (pUIInfo->dwCartridgeSlotCount == 0)
        return TRUE;

    VPackOptItemGroupHeader(pUiData, IDS_CPSUI_INSTFONTCART,
        IDI_CPSUI_FONTCARTHDR, HELP_INDEX_FONTSLOT_TYPE);


    if (pUiData->pOptItem)
    {
        PFONTCART pFontCarts;

        //
        // Get the current selections for the slots from registry
        // Read the list of font cartridge selections out of registry
        //

        pwstrCurrentSelection = PwstrGetFontCartSelections(pUiData->ci.hPrinter, pUiData->ci.hHeap, &dwSize);
        pwstrEndSelection = pwstrCurrentSelection + (dwSize/2);


        pFontCarts = OFFSET_TO_POINTER( pUIInfo->pubResourceData,
                                        pUIInfo->CartridgeSlot.loOffset );

        ASSERT(pFontCarts);

        //
        // Save the slot count and OPTITEM for slots for unpacking later
        //

        pUiData->dwFontCart = pUIInfo->dwCartridgeSlotCount;
        pUiData->pFontCart = pUiData->pOptItem;

        for (dwFontSlot = 0; dwFontSlot < pUIInfo->dwCartridgeSlotCount; dwFontSlot++)
        {
            //
            // We'll distinguish between driver built in font cartridges and external
            // font cartridges. dwFontCartsAvailable refers to the count of built
            // in driver cartridges. To this we need to add any external cartridges.
            //

            dwFontCartsAvailable = pUIInfo->CartridgeSlot.dwCount;
            dwExtCartsAvailable = DwGetExternalCartridges(pUiData->ci.hPrinter, pUiData->ci.hHeap, &pwstrExtCartNames);

            //
            // Build a list of OPTPARAM
            //

            pParam = PFillOutOptType(pUiData->pOptType,
                                    TVOT_LISTBOX,
                                    (WORD)(dwFontCartsAvailable + dwExtCartsAvailable),
                                    pUiData->ci.hHeap);

            pUiData->pOptType->Style |= OTS_LBCB_INCL_ITEM_NONE;

            if (pParam == NULL)
                return FALSE;


            while (dwFontCartsAvailable)
            {
                pParam->cbSize = sizeof(OPTPARAM);
                pParam->pData = PwstrGetFontCartName(
                                    &pUiData->ci,
                                    pUIInfo,
                                    pFontCarts,
                                    pUIInfo->CartridgeSlot.dwCount - dwFontCartsAvailable,
                                    pUiData->ci.hHeap);

                pParam->IconID = IDI_CPSUI_FONTCART;
                dwFontCartsAvailable--;
                pParam++;
            }

            while (dwExtCartsAvailable)
            {
                pParam->cbSize = sizeof(OPTPARAM);
                pParam->pData = pwstrExtCartNames;

                pParam->IconID = IDI_CPSUI_FONTCART;
                dwExtCartsAvailable--;

                pwstrExtCartNames += wcslen(pwstrExtCartNames);
                pwstrExtCartNames++;

                pParam++;
            }

            //
            // Look for the current selection in the font cart table
            //

            if (pwstrCurrentSelection)
                iSelection = IGetCurrentFontCartIndex(pUiData->pOptType,
                                                      pwstrCurrentSelection);

            //
            // Fill out OPTITEM, OPTTYPE, and OPTPARAM structures
            //

            FILLOPTITEM(pUiData->pOptItem,
                        pUiData->pOptType,
                        ULongToPtr(IDS_CPSUI_SLOT1 + dwFontSlot),
                        IntToPtr(iSelection),
                        TVITEM_LEVEL2,
                        DMPUB_NONE,
                        (ULONG_PTR)FONTSLOT_ITEM,
                        HELP_INDEX_FONTSLOT_TYPE);


           if (pwstrCurrentSelection && pwstrCurrentSelection < pwstrEndSelection)
           {
                pwstrCurrentSelection += wcslen(pwstrCurrentSelection);
                pwstrCurrentSelection++;
           }

           pUiData->pOptItem++;
           pUiData->pOptType++;

        }
    }

    pUiData->dwOptItem += pUIInfo->dwCartridgeSlotCount;
    pUiData->dwOptType += pUIInfo->dwCartridgeSlotCount;


    return TRUE;
}


BOOL
BPackPageProtection(
    IN OUT PUIDATA  pUiData
    )
/*++

Routine Description:

    Pack the page protection feature

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE for success and FALSE for failure

--*/

{

    return BPackItemPrinterFeature(
                pUiData,
                GET_PREDEFINED_FEATURE(pUiData->ci.pUIInfo, GID_PAGEPROTECTION),
                TVITEM_LEVEL1,
                DMPUB_NONE,
                (ULONG_PTR)PAGE_PROTECT_ITEM,
                HELP_INDEX_PAGE_PROTECT);
}

BOOL
BPackHalftoneSetup(
    IN OUT PUIDATA  pUiData
    )
/*++

Routine Description:

    Do nothing, serves as common stubs

Arguments:

    pUiData - Points to UIDATA structure

Return Value:

    TRUE for success and FALSE for failure

--*/

{
    // DCR - not implemented
    return TRUE;
}


BOOL
_BPackPrinterOptions(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Pack driver-specific options (printer-sticky)

Arguments:

    pUiData - Points to a UIDATA structure

Return Value:

    TRUE for success and FALSE for failure

--*/

{
    return BPackHalftoneSetup(pUiData) &&
           BPackFontCartsOptions(pUiData) &&
           BPackPageProtection(pUiData) &&
           BPackSoftFontFeature(pUiData);
}


PWSTR
PwstrGetFontCartSelections(
    HANDLE   hPrinter,
    HANDLE   hHeap,
    PDWORD   pdwSize
    )
/*++

Routine Description:

    Read the font cart selections for the slots from the registry

Arguments:

    hPrinter - Handle to printer instance
    hHeap - Handle to UI heap
    pdwSize - Pointer to DWORD to hold the size of the MULTI_SZ

Return Value:

    Pointer to a MULTI-SZ containing the selections for the slots

--*/
{
    PWSTR   pwstrData, pFontCartSelections = NULL;
    DWORD   dwSize;

    pwstrData = PtstrGetFontCart(hPrinter, &dwSize);

    if (pwstrData == NULL || !BVerifyMultiSZ(pwstrData, dwSize))
    {
        MemFree(pwstrData);
        return NULL;
    }

    if (pFontCartSelections = HEAPALLOC(hHeap, dwSize))
    {
        CopyMemory(pFontCartSelections, pwstrData, dwSize);
    }

    MemFree(pwstrData);

    if (pdwSize)
        *pdwSize = dwSize;

    return pFontCartSelections;
}


PWSTR
PwstrGetFontCartName(
    PCOMMONINFO pci,
    PUIINFO     pUIInfo,
    FONTCART    *pFontCarts,
    DWORD       dwIndex,
    HANDLE      hHeap
    )
/*++

Routine Description:

    Get the font cart name associated with the index.

Arguments:

    pci - Pointer to COMMONINFO
    pUIInfo - Pointer to UIINFO
    pFontCarts  - Pointer to array of FONTCART for the slot
    dwIndex - Index of font cart
    hHeap - Handle to Heap

Return Value:

    Pointer to the Font Cart Name

--*/
{
    DWORD       dwLen;
    PWSTR       pwstrFontCartName;
    WCHAR       awchBuf[MAX_DISPLAY_NAME];

    pFontCarts += dwIndex;

    pwstrFontCartName = (PWSTR)OFFSET_TO_POINTER(pUIInfo->pubResourceData,
                                pFontCarts->strCartName.loOffset);

    if (!pwstrFontCartName)
    {
        if (! BPrepareForLoadingResource(pci, TRUE))
            return NULL;


        dwLen = ILOADSTRING(pci, pFontCarts->dwRCCartNameID,
                           awchBuf, MAX_DISPLAY_NAME);


        pwstrFontCartName = HEAPALLOC(pci->hHeap, (dwLen+1) * sizeof(WCHAR));

        if (pwstrFontCartName == NULL)
        {
            ERR(("Memory allocation failed\n"));
            return NULL;
        }

        //
        // Copy the string to allocated memory and
        // return a pointer to it.
        //

        CopyMemory(pwstrFontCartName, awchBuf, dwLen*sizeof(WCHAR));
        return pwstrFontCartName;


    }
    else
        return pwstrFontCartName;
}


INT
IGetCurrentFontCartIndex(
    POPTTYPE    pOptType,
    PWSTR       pCurrentSelection
    )
/*++

Routine Description:

    Find the matching font cart

Arguments:

    pOptType - Pointer to OPTTYPE containing the font carts options
    pCurrentSelection - The name of the cartridge selection for the slot

Return Value:

    Index to the options list

--*/
{

    INT iIndex;
    POPTPARAM pParam = pOptType->pOptParam;

    for (iIndex = 0 ; iIndex < pOptType->Count; iIndex++)
    {
        if (wcscmp(pCurrentSelection, pParam->pData) == EQUAL_STRING)
            return iIndex;

        pParam++;

    }
    return -1;
}


DWORD
DwCollectFontCart(
    PUIDATA     pUiData,
    PWSTR       pwstrTable
    )

/*++

Routine Description:

    Collect Font Cart assignment information

Arguments:

    pUiData - Pointer to our UIDATA structure
    pwstrTable - Pointer to memory buffer for storing the table
        NULL if the caller is only interested in the table size

Return Value:

    Size of the table bytes. 0 if there is an error.

--*/

{
    DWORD dwChars = 0;
    LONG lLength = 0;
    DWORD dwIndex;
    POPTPARAM pOptParam;
    DWORD dwOptItem = pUiData->dwFontCart;
    POPTITEM pOptItem = pUiData->pFontCart;

    for (dwIndex=0; dwIndex < dwOptItem; dwIndex++, pOptItem++)
    {

        if (pOptItem->Flags & OPTIF_DISABLED)
            continue;

        //
        // Get the Font Cart name for each slot (dwIndex)
        //

        if (pOptItem->Sel == -1)
        {
            lLength = wcslen(L"Not Available") + 1;

        }
        else
        {
            pOptParam = pOptItem->pOptType->pOptParam + pOptItem->Sel;
            lLength = wcslen(pOptParam->pData) + 1;
        }

        dwChars += lLength;

        if (pwstrTable != NULL)
        {
            if (pOptItem->Sel == -1)
                wcscpy(pwstrTable, L"Not Available");
            else
                wcscpy(pwstrTable, pOptParam->pData);

            pwstrTable += lLength;
        }
    }

    //
    // Append a NUL character at the end of the table
    //

    dwChars++;

    if (pwstrTable != NULL)
        *pwstrTable = NUL;

    //
    // Return the table size in bytes
    //

    return (dwChars * sizeof(WCHAR));
}


BOOL
BUnPackFontCart(
    PUIDATA     pUiData
    )
/*++

Routine Description:

    Save the Font Cart selection into registry

Arguments:

    pUiData - Pointer to UIDATA

Return Value:

    TRUE for success and FALSE for failure

Note:

--*/

{
    PFN_OEMUpdateExternalFonts pUpdateProc = NULL;
    PWSTR                      pwstrTable;
    DWORD                      dwTableSize;
    BOOL                       bHasOEMUpdateFn = FALSE;

    //
    // Figure out how much memory we need to store
    // the Font Cart table
    //

    dwTableSize = DwCollectFontCart(pUiData, NULL);

    if (dwTableSize == 0 || (pwstrTable = MemAllocZ(dwTableSize)) == NULL)
    {
        ERR(("DwCollectFontCart/MemAlloc"));
        return FALSE;
    }

    //
    // Assemble the font cartridge table to be saved in registry
    //

    if (dwTableSize != DwCollectFontCart(pUiData, pwstrTable))
    {
        ERR(("CollectFontCart"));
        MemFree(pwstrTable);
        return FALSE;
    }

    //
    // Save the font cart information to registry
    //

    if (! BSaveFontCart(pUiData->ci.hPrinter, pwstrTable))
    {
        ERR(("SaveFontCart"));
    }

    //
    // Inform font installer (if present) about font cartridge selection change
    //

    FOREACH_OEMPLUGIN_LOOP(&pUiData->ci)

        if (HAS_COM_INTERFACE(pOemEntry))
        {
            if (HComOEMUpdateExternalFonts(pOemEntry,
                                           pUiData->ci.hPrinter,
                                           pUiData->ci.hHeap,
                                           pwstrTable) == E_NOTIMPL)
                continue;

            bHasOEMUpdateFn = TRUE;
            break;

        }
        else
        {
            pUpdateProc = GET_OEM_ENTRYPOINT(pOemEntry, OEMUpdateExternalFonts);

            if (pUpdateProc)
            {
                bHasOEMUpdateFn = TRUE;
                pUpdateProc(pUiData->ci.hPrinter, pUiData->ci.hHeap, pwstrTable);
                break;
            }

        }

    END_OEMPLUGIN_LOOP

    if (!bHasOEMUpdateFn)
    {
        //
        // No OEM Dll wants to handle this, we'll handle it ourselves
        //

        BUpdateExternalFonts(pUiData->ci.hPrinter, pUiData->ci.hHeap, pwstrTable);
    }

    MemFree(pwstrTable);

    return TRUE;
}


DWORD
DwGetExternalCartridges(
    IN  HANDLE hPrinter,
    IN  HANDLE hHeap,
    OUT PWSTR  *ppwstrExtCartNames
    )
{
    PWSTR pwstrData;
    DWORD dwSize;

    *ppwstrExtCartNames = NULL;

    pwstrData = PtstrGetPrinterDataString(hPrinter, REGVAL_EXTFONTCART, &dwSize);

    if (pwstrData == NULL || !BVerifyMultiSZ(pwstrData, dwSize))
    {
        MemFree(pwstrData);
        return 0;
    }

    if (*ppwstrExtCartNames = HEAPALLOC(hHeap, dwSize))
    {
        CopyMemory(*ppwstrExtCartNames, pwstrData, dwSize);
    }

    MemFree(pwstrData);

    return DwCountStringsInMultiSZ(*ppwstrExtCartNames);
}


BOOL
BUnpackHalftoneSetup(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Unpack halftone setup information

Arguments:

    pUiData - Points to a UIDATA structure

Return Value:

    TRUE for success and FALSE for failure

--*/

{
    // DCR - not implemented
    return TRUE;
}


BOOL
_BUnpackPrinterOptions(
    IN OUT PUIDATA  pUiData
    )

/*++

Routine Description:

    Unpack driver-specific options (printer-sticky)

Arguments:

    pUiData - Points to a UIDATA structure

Return Value:

    TRUE for success and FALSE for failure

--*/

{
    return BUnpackHalftoneSetup(pUiData) &&
           BUnPackFontCart(pUiData);
}



//
// Data structures and functions for enumerating printer device fonts
//

typedef struct _ENUMDEVFONT {

    INT     iBufSize;
    INT     iCurSize;
    PWSTR   pwstrBuf;

} ENUMDEVFONT, *PENUMDEVFONT;

INT CALLBACK
EnumDevFontProc(
    ENUMLOGFONT    *pelf,
    NEWTEXTMETRIC  *pntm,
    INT             FontType,
    LPARAM          lParam
    )

{
    PENUMDEVFONT    pEnumData;
    PWSTR           pFamilyName;
    INT             iSize;

    //
    // We only care about printer device fonts.
    //

    if (!(FontType & DEVICE_FONTTYPE))
        return 1;

    //
    // For app compatibility, GDI sets FontType to be DEVICE_FONTTYPE
    // even for PS OpenType fonts and Type1 fonts. So we also need to
    // filter them out using Win2K+ only GDI flags.
    //

    #ifndef WINNT_40

    if ((pntm->ntmFlags & NTM_PS_OPENTYPE) ||
        (pntm->ntmFlags & NTM_TYPE1))
        return 1;

    #endif // WINNT_40

    pEnumData = (PENUMDEVFONT) lParam;
    pFamilyName = pelf->elfLogFont.lfFaceName;

    iSize = SIZE_OF_STRING(pFamilyName);
    pEnumData->iCurSize += iSize;

    if (pEnumData->pwstrBuf == NULL)
    {
        //
        // Calculating output buffer size only
        //
    }
    else if (pEnumData->iCurSize >= pEnumData->iBufSize)
    {
        //
        // Output buffer is too small
        //

        return 0;
    }
    else
    {
        CopyMemory(pEnumData->pwstrBuf, pFamilyName, iSize);
        pEnumData->pwstrBuf = (PWSTR) ((PBYTE) pEnumData->pwstrBuf + iSize);
    }

    return 1;
}


INT
_IListDevFontNames(
    HDC     hdc,
    PWSTR   pwstrBuf,
    INT     iSize
    )

{
    INT         iOldMode;
    ENUMDEVFONT EnumData;


    EnumData.iBufSize = iSize;
    EnumData.pwstrBuf = pwstrBuf;
    EnumData.iCurSize = 0;

    //
    // Enumerate device fonts
    //

    iOldMode = SetGraphicsMode(hdc, GM_ADVANCED);

    if (! EnumFontFamilies(
                    hdc,
                    NULL,
                    (FONTENUMPROC) EnumDevFontProc,
                    (LPARAM) &EnumData))
    {
        return 0;
    }

    SetGraphicsMode(hdc, iOldMode);

    //
    // Remember the list of device font names is in MULTI_SZ format;
    // Take the last NUL terminator into consideration
    //

    EnumData.iCurSize += sizeof(WCHAR);

    if (EnumData.pwstrBuf)
        *(EnumData.pwstrBuf) = NUL;

    return EnumData.iCurSize;
}


//
// Determine whether the printer supports stapling
//

BOOL
_BSupportStapling(
    PCOMMONINFO pci
    )

{
    DWORD   dwIndex;

    return (PGetNamedFeature(pci->pUIInfo, "Stapling", &dwIndex) &&
            !_BFeatureDisabled(pci, dwIndex, GID_UNKNOWN));
}



INT_PTR CALLBACK
_AboutDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    Dlg Proc for About button

Arguments:

    hDlg - Identifies the property sheet page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information

Return Value:

    Depends on the value of message parameter

--*/

{
    PUIDATA pUiData;
    PWSTR   pGpdFilename;
    PGPDDRIVERINFO  pDriverInfo;

    switch (message)
    {
    case WM_INITDIALOG:

        //
        // Initialize the About dialog box
        //

        pUiData = (PUIDATA) lParam;
        ASSERT(VALIDUIDATA(pUiData));

        #ifdef WINNT_40

        SetDlgItemTextA(hDlg, IDC_WINNT_VER, "Version " VER_54DRIVERVERSION_STR);

        #else

        SetDlgItemTextA(hDlg, IDC_WINNT_VER, "Version " VER_PRODUCTVERSION_STR);

        #endif // WINNT_40

        SetDlgItemText(hDlg, IDC_MODELNAME, pUiData->ci.pDriverInfo3->pName);

        pDriverInfo = OFFSET_TO_POINTER(pUiData->ci.pInfoHeader, pUiData->ci.pInfoHeader->loDriverOffset);

        ASSERT(pDriverInfo != NULL);

        if (pDriverInfo->Globals.pwstrGPDFileName)
            SetDlgItemText(hDlg, IDC_GPD_FILENAME, pDriverInfo->Globals.pwstrGPDFileName);
        else
            SetDlgItemText(hDlg, IDC_GPD_FILENAME, L"Not Available");

        if (pDriverInfo->Globals.pwstrGPDFileVersion)
            SetDlgItemTextA(hDlg, IDC_GPD_FILEVER, (PSTR)pDriverInfo->Globals.pwstrGPDFileVersion);
        else
            SetDlgItemText(hDlg, IDC_GPD_FILEVER,  L"Not Available");

        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
        case IDCANCEL:

            EndDialog(hDlg, LOWORD(wParam));
            return TRUE;
        }
        break;
    }

    return FALSE;
}

BOOL
BFoundInDisabledList(
    IN  PGPDDRIVERINFO  pDriverInfo,
    IN  POPTION         pOption,
    IN  DWORD           dwFeatureID
    )

/*++

Routine Description:

    Determines whether the feature indicated by dwFeatureID is found in the
    pOption->liDisabledFeatureList.

Arguments:


Return Value:

    TRUE for disabled feature, otherwise FALSE

--*/

{
    PLISTNODE       pListNode;

    pListNode = LISTNODEPTR(pDriverInfo, pOption->liDisabledFeatures);

    while (pListNode)
    {
        if ( ((PQUALNAME)(&pListNode->dwData))->wFeatureID == (WORD)dwFeatureID)
        {
            return TRUE;
        }

        pListNode = LISTNODEPTR(pDriverInfo, pListNode->dwNextItem);
    }

    return FALSE;
}


BOOL
_BFeatureDisabled(
    IN  PCOMMONINFO pci,
    IN  DWORD       dwFeatureIndex,
    IN  WORD        wGID
    )

/*++

Routine Description:

    Determines whether the feature indicated by wGID is disabled.
    For example, a device can support collate but only if the hard disk is
    installed.

Arguments:

    pci     - Points to COMMONINFO
    wGID    - GID_XXX

Return Value:

    TRUE for disabled feature, otherwise FALSE

--*/

{

    DWORD           dwFeatureID, dwIndex, dwFeatureCount;
    PFEATURE        pFeatureList, pFeature = NULL;
    PGPDDRIVERINFO  pDriverInfo;
    PUIINFO         pUIInfo = pci->pUIInfo;
    POPTSELECT      pCombinedOptions = pci->pCombinedOptions;
    BYTE            ubCurOptIndex, ubNext;
    POPTION         pOption;

    pDriverInfo = OFFSET_TO_POINTER(pUIInfo->pInfoHeader,
                                    pUIInfo->pInfoHeader->loDriverOffset);

    dwFeatureCount = pUIInfo->dwDocumentFeatures + pUIInfo->dwPrinterFeatures;

    if (pDriverInfo == NULL)
        return FALSE;

    if (dwFeatureIndex != 0xFFFFFFFF &&
        wGID == GID_UNKNOWN &&
        dwFeatureIndex <= dwFeatureCount)
    {
        dwFeatureID = dwFeatureIndex;
    }
    else
    {
        pFeature = GET_PREDEFINED_FEATURE(pUIInfo, wGID);

        if (pFeature == NULL)
            return FALSE;

        dwFeatureID =  GET_INDEX_FROM_FEATURE(pUIInfo, pFeature);
    }

    if (!(pFeatureList = OFFSET_TO_POINTER(pUIInfo->pInfoHeader, pUIInfo->loFeatureList)))
        return FALSE;

    for (dwIndex = 0;
         dwIndex < dwFeatureCount;
         dwIndex++, pFeatureList++)
    {
        //
        // Currently we only allow *DisabledFeatures to be used with PRINTER_PROPERTY features. This
        // is because the UI code won't be able to refresh the document settings correctly if you have
        // *DisabledFeatures on non-printer-sticky features.
        //
        // Example: if you put *DisabledFeatures: LIST(Collate) into a PaperSize option, then in the
        // document settings select that PaperSize option, you won't see EMF features refreshed
        // correctly unless you close and reopen the UI. This is because in cpcbDocumentPropertyCallback,
        // we only call VUpdateEmfFeatureItems when EMF-related feature settings are changed. Changing
        // PaperSize option won't trigger the calling of VUpdateEmfFeatureItems, therefore no refresh.
        //

        if (pFeatureList->dwFeatureType != FEATURETYPE_PRINTERPROPERTY)
           continue;

        ubNext = (BYTE)dwIndex;
        while (1)
        {
            ubCurOptIndex = pCombinedOptions[ubNext].ubCurOptIndex;
            pOption = PGetIndexedOption(pUIInfo, pFeatureList, ubCurOptIndex == OPTION_INDEX_ANY ? 0 : ubCurOptIndex);

            if (pOption && BFoundInDisabledList(pDriverInfo, pOption, dwFeatureID))
                return TRUE;

            if ((ubNext = pCombinedOptions[ubNext].ubNext) == NULL_OPTSELECT)
                break;
         }
    }

    return FALSE;
}

PTSTR
PtstrUniGetDefaultTTSubstTable(
    IN  PCOMMONINFO pci,
    IN  PUIINFO     pUIInfo
    )

/*++

Routine Description:

    Get the default font substitution table for Unidrv

Arguments:

    pci     - Points to COMMONINFO
    pUIInfo - Points to UIINFO

Return Value:

   Pointer to the font substituion table , otherwise NULL

--*/

{

#define     DEFAULT_FONTSUB_SIZE        (1024 * sizeof(WCHAR))

    PTTFONTSUBTABLE pDefaultTTFontSub, pCopyTTFS;
    PTSTR           ptstrTable, ptstrTableOrg;
    DWORD           dwCount, dwEntrySize, dwTTFontLen, dwDevFontLen, dwBuffSize, dwAvail;
    PWSTR           pTTFontName, pDevFontName;

    if (pUIInfo->dwFontSubCount)
    {
        if (!(pDefaultTTFontSub = OFFSET_TO_POINTER(pUIInfo->pubResourceData,
                                    pUIInfo->loFontSubstTable)))
        {
            ERR(("Default TT font sub table from GPD Parser is NULL \n"));
            return NULL;
        }

        dwBuffSize = sizeof(TTFONTSUBTABLE) * pUIInfo->dwFontSubCount;

        if (!(pCopyTTFS = HEAPALLOC(pci->hHeap,  dwBuffSize)))
        {
            ERR(("Fatal: unable to alloc requested memory: %d bytes.\n", dwBuffSize));
            return NULL;
        }

        //
        // Make a writable copy of the font substitution table
        // if arDevFontName.dwCount is zero,
        // move rcID into arDevFontName.loOffset like other
        // snapshot entries and set highbit.
        //

        CopyMemory((PBYTE)pCopyTTFS,
                   (PBYTE)pDefaultTTFontSub,
                   dwBuffSize);

        for (dwCount = 0 ; dwCount < pUIInfo->dwFontSubCount ; dwCount++)
        {
            if(!pCopyTTFS[dwCount].arTTFontName.dwCount)
            {
                pCopyTTFS[dwCount].arTTFontName.loOffset =
                    pCopyTTFS[dwCount].dwRcTTFontNameID | GET_RESOURCE_FROM_DLL ;
            }
            if(!pCopyTTFS[dwCount].arDevFontName.dwCount)
            {
                pCopyTTFS[dwCount].arDevFontName.loOffset =
                    pCopyTTFS[dwCount].dwRcDevFontNameID | GET_RESOURCE_FROM_DLL ;
            }
        }

        dwBuffSize = dwAvail = DEFAULT_FONTSUB_SIZE;

        if (!(ptstrTableOrg = ptstrTable = MemAlloc(dwBuffSize)))
        {
            ERR(("Fatal: unable to alloc requested memory: %d bytes.\n", dwBuffSize));
            return NULL;
        }

        for (dwCount = 0; dwCount < pUIInfo->dwFontSubCount; dwCount++, pCopyTTFS ++)
        {
            pTTFontName = PGetReadOnlyDisplayName( pci,
                                          pCopyTTFS->arTTFontName.loOffset );

            pDevFontName = PGetReadOnlyDisplayName( pci,
                                          pCopyTTFS->arDevFontName.loOffset );

            if (pTTFontName == NULL || pDevFontName == NULL)
                continue;

            dwTTFontLen = wcslen(pTTFontName) + 1;

            dwDevFontLen = wcslen( pDevFontName) + 1 ;

            dwEntrySize = (dwDevFontLen + dwTTFontLen + 1) * sizeof(WCHAR);

            if (dwAvail < dwEntrySize)
            {
                DWORD dwCurrOffset;

                //
                // Reallocate the Buffer
                //

                dwAvail = max(dwEntrySize, DEFAULT_FONTSUB_SIZE);
                dwBuffSize += dwAvail;
                dwCurrOffset =  (DWORD)(ptstrTable - ptstrTableOrg);

                if (!(ptstrTable = MemRealloc(ptstrTableOrg, dwCurrOffset * sizeof(WCHAR), dwBuffSize)))
                {
                       ERR(("Fatal: unable to realloac requested memory: %d bytes.\n", dwBuffSize));
                       MemFree(ptstrTableOrg);
                       return NULL;
                }

                ptstrTableOrg = ptstrTable;
                ptstrTable +=  dwCurrOffset;
                dwAvail = dwBuffSize - dwCurrOffset*sizeof(WCHAR);
            }

            dwAvail -= dwEntrySize;

            CopyString(ptstrTable, pTTFontName, dwTTFontLen);
            ptstrTable += dwTTFontLen;

            CopyString(ptstrTable, pDevFontName, dwDevFontLen);
            ptstrTable += dwDevFontLen;

        }
        *ptstrTable = NUL;
    }
    else
    {
        ptstrTableOrg = NULL;
    }

    return ptstrTableOrg;
}




BOOL
BOkToChangeColorToMono(
    IN  PCOMMONINFO pci,
    IN  PDEVMODE    pdm,
    OUT SHORT *     pPrintQuality,
    OUT SHORT *     pYResolution
    )

/*++

Routine Description:

    This function determines if the resolution can be left
    unchanged when switching from Color to Mono printing.
    This is implemented for switching between color and monochrome
    mode within a job for performance

Arguments:

    pci     - Points to COMMONINFO
    pdm     - Points to DEVMODE
    pPrintQuality, pYResolution - To contain the output resolution
    pUIInfo - Points to UIINFO

Return Value:

    Returns TRUE  if the same resolution used to print Color
    can also be used to print Mono.  If true, this resolution
    is placed in pptRes  for the spooler to use in place of
    negative values of print quality.
    otherwise return FALSE and pptRes is not initialized.


--*/

{

    PFEATURE   pFeatureColor, pFeatureRes;
    DWORD      dwColorModeIndex, dwCurOption, dwResIndex, dwNewResOption, dwCurResOption ;
    SHORT      sXres, sYres;
    POPTION    pColorMode;
    PCOLORMODEEX pColorModeEx;
    PRESOLUTION pResOption;
    PDEVMODE    pDevmode, pTmpDevmode;


    if ((pFeatureColor =  GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_COLORMODE))== NULL)
        return FALSE;

    dwColorModeIndex = GET_INDEX_FROM_FEATURE(pci->pUIInfo, pFeatureColor);

    pColorMode = (POPTION)PGetIndexedOption(pci->pUIInfo,
                                            pFeatureColor,
                                            pci->pCombinedOptions[dwColorModeIndex].ubCurOptIndex);

    if (pColorMode == NULL)
        return FALSE;

    pColorModeEx = OFFSET_TO_POINTER(
                        pci->pInfoHeader,
                        pColorMode->loRenderOffset);

    if(pColorModeEx == NULL || pColorModeEx->bColor == FALSE)
        return(FALSE);

    if ((pFeatureRes = GET_PREDEFINED_FEATURE(pci->pUIInfo, GID_RESOLUTION)) == NULL)
        return FALSE;

    dwResIndex = GET_INDEX_FROM_FEATURE(pci->pUIInfo, pFeatureRes);

    dwCurResOption = pci->pCombinedOptions[dwResIndex].ubCurOptIndex ;
    pResOption = (PRESOLUTION)PGetIndexedOption(pci->pUIInfo,
                                                pFeatureRes,
                                                dwCurResOption);
    if (pResOption == NULL)
        return FALSE;

    sXres = (SHORT)pResOption->iXdpi;
    sYres = (SHORT)pResOption->iYdpi;

    //
    // Make a copy of the public devmode
    //

    if ((pDevmode = MemAllocZ(sizeof(DEVMODE))) == NULL)
        return FALSE;

    CopyMemory(pDevmode, pdm, sizeof(DEVMODE));

    pDevmode->dmPrintQuality = sXres ;
    pDevmode->dmYResolution = sYres ;

    //
    //  Now ask to print in mono
    //

    pDevmode->dmColor = DMCOLOR_MONOCHROME ;

    //
    // This is a kludge to fix up the devmode in pci. I hope it works!
    //

    pTmpDevmode = pci->pdm;
    pci->pdm = pDevmode;

    VFixOptionsArrayWithDevmode(pci);

    (VOID)ResolveUIConflicts( pci->pRawData,
                                                pci->pCombinedOptions,
                                                MAX_COMBINED_OPTIONS,
                                                MODE_DOCANDPRINTER_STICKY);

    pci->pdm = pTmpDevmode;


    dwNewResOption = pci->pCombinedOptions[dwResIndex].ubCurOptIndex ;

    if(dwNewResOption != dwCurResOption)
    {
        //  gotta compare resolutions
        if ((pResOption = (PRESOLUTION)PGetIndexedOption(pci->pUIInfo,
                                                        pFeatureRes,
                                                        dwNewResOption)) == NULL)
        {
            MemFree(pDevmode);
            return FALSE;
        }

        if ((sXres != pResOption->iXdpi)  ||  (sYres != pResOption->iYdpi))
        {
            MemFree(pDevmode);
            return(FALSE);
        }
        else // Same dpi for Color and Monochrome.
        {
            //
            // For predefined negative user defined resolution don't replace
            // the values in dmPrintQuality and dmYResolution. This is needed
            // because user defined print quality may map to multiple settings
            // like Ink density.
            //
            if ( (pdm->dmFields & DM_PRINTQUALITY) &&
                 (pdm->dmPrintQuality >= DMRES_HIGH) &&
                 (pdm->dmPrintQuality <= DMRES_DRAFT) )
            {
                sXres = pdm->dmPrintQuality;
                sYres = pdm->dmYResolution;

            }

        }

    }
    else // Same resolution for Color and Monochrome.
    {
        //
        // For negative user defined resolution don't replace the values in
        // in dmPrintQuality and dmYResolution. This is needed because user
        // defined print quality may map to multiple settings like Ink density.
        //
        if ( (pdm->dmFields & DM_PRINTQUALITY) &&
             (pdm->dmPrintQuality < DMRES_HIGH) )
        {
            sXres = pdm->dmPrintQuality;
            sYres = pdm->dmYResolution;

        }

    }

    dwCurOption = pci->pCombinedOptions[dwColorModeIndex].ubCurOptIndex ;

    if ((pColorMode = (POPTION)PGetIndexedOption(pci->pUIInfo, pFeatureColor,dwCurOption)) == NULL ||
        (pColorModeEx = OFFSET_TO_POINTER(pci->pInfoHeader, pColorMode->loRenderOffset)) == NULL ||
        (pColorModeEx->bColor))
    {
        MemFree(pDevmode);
        return FALSE;
    }

    if (pPrintQuality)
        *pPrintQuality =  sXres ;

    if (pYResolution)
        *pYResolution = sYres ;

    //
    // Free the devmode.
    //
    if (pDevmode)
        MemFree(pDevmode);

    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\glyphset\mkgtt\dbcsconv.c ===
/*++

Copyright (c) 1996 - 1997  Microsoft Corporation

Module Name:

    dbcsconv.c

Abstract:

    Far East predefined Character Conversion functions.

Environment:

    Windows NT Unidrv driver

Revision History:

    02/10/96 -eigos-
        Created it.

--*/

#include <lib.h>
#include <win30def.h>
#include <uni16gpc.h>
#include <uni16res.h>
#include <fmnewfm.h>
#include <fmnewgly.h>
#include <unilib.h>
#include <mkgtt.h>


#define  XWT_INVALID    0xFF
#define  XWT_EXTENDED   0x00
#define  XWT_WANSUNG    0x01
#define  XWT_JUNJA      0x02
#define  XWT_HANJA      0x03
#define  XWT_UDC        0x04

static BYTE iXWType[8][3] =
   {
      XWT_EXTENDED, XWT_EXTENDED, XWT_EXTENDED,    // Lead = 0x81-0xA0
      XWT_EXTENDED, XWT_EXTENDED, XWT_JUNJA,       // Lead = 0xA1-0xAC
      XWT_EXTENDED, XWT_EXTENDED, XWT_INVALID,     // Lead = 0xAD-0xAF
      XWT_EXTENDED, XWT_EXTENDED, XWT_WANSUNG,     // Lead = 0xB0-0xC5
      XWT_EXTENDED, XWT_INVALID,  XWT_WANSUNG,     // Lead = 0xC6
      XWT_INVALID,  XWT_INVALID,  XWT_WANSUNG,     // Lead = 0xC7-0xC8
      XWT_INVALID,  XWT_INVALID,  XWT_UDC,         // Lead = 0xC9, 0xFE
      XWT_INVALID,  XWT_INVALID,  XWT_HANJA        // Lead = 0xCA-0xFD
   };
INT
GetXWType(
    WORD wXW )

/*++

Routine Description:

    Sub functions of KSCToISC

Arguments:

    wXW - Multi byte character

Return Value:

    XWType

--*/
{
   BYTE  bL = (BYTE) (( wXW >> 8 ) & 0xFF);
   BYTE  bT = (BYTE) (wXW & 0xFF);
   int   iLType = -1, iTType = -1;


   if ( ( bT >= 0x41 ) && ( bT <= 0xFE ) )
   {
      if ( bT <= 0x52 )
         iTType = 0;       // Tail Range 0x41-0x52
      else
      {
         if ( bT >= 0xA1 )
            iTType = 2;    // Tail Range 0xA1-0xFE
         else if ( ( bT <= 0x5A ) || ( bT >= 0x81 ) ||
                   ( ( bT >= 0x61 ) && ( bT <= 0x7A ) ) )
            iTType = 1;    // Tail Range 0x53-0x5A, 0x61-0x7A, 0x81-0xA0
      }
   }
   if ( iTType < 0 )  return( -1 );

   if ( ( bL >= 0x81 ) && ( bL <= 0xFE ) )
   {
      if ( bL < 0xB0 )
      {
         if ( bL <= 0xA0 )
            iLType = 0;       // Lead Range 0x81-0xA0
         else if ( bL <= 0xAC )
            iLType = 1;       // Lead Range 0xA1-0xAC
         else
            iLType = 2;       // Lead Range 0xAD-0xAF
      }
      else
      {
         if ( bL <= 0xC8 )
         {
            if ( bL < 0xC6 )
               iLType = 3;    // Lead Range 0xB0-0xC5
            else if ( bL == 0xC6 )
               iLType = 4;    // Lead Range 0xC6
            else
               iLType = 5;    // Lead Range 0xC7-0xC8
         }
         else
         {
            if ( ( bL == 0xC9 ) || ( bL == 0xFE ) )
               iLType = 6;    // Lead Range 0xC9, 0xFE
            else
               iLType = 7;    // Lead Range 0xCA-0xFD
         }
      }
   }

   return( ( iLType < 0 ) ? XWT_INVALID : iXWType[iLType][iTType] );
}


VOID
KSCToISC(
    TRANSTAB *lpctt,
    LPSTR   lpStrKSC,
    LPSTR   lpStrISC)

/*++

Routine Description:

    Korea Standard Code(KSC) to Industrial Standard Code(ISC) conversion
    Convert given string in KSC codeset to ISC code set
    VOID KSCToISC(lpctt, lpStrKSC, lpStrISC)
    lpctt points to selected CTT.

Arguments:

    lpctt - pointer to TRANSTAB
    lpStrKSC - pointer to KSC string
    lpStrISC - pointer to ISC string

Return Value:

--*/
{
   #define OFFSET_1  4
   #define OFFSET_2  158
   #define OFFSET_3  312
   #define OFFSET_4  337
   #define OFFSET_5  407
   #define OFFSET_6  432
   #define OFFSET_7  502
   LPWORD lpwTailFirst = (LPWORD)((LPSTR)lpctt + OFFSET_1);
   LPWORD lpwTailFirstX= (LPWORD)((LPSTR)lpctt + OFFSET_2);
   LPBYTE lpbLeadMap   = (LPBYTE)lpctt + OFFSET_3;
   LPBYTE lpbLeadMapX  = (LPBYTE)lpctt + OFFSET_4;
   LPBYTE lpbTailOff   = (LPBYTE)lpctt + OFFSET_5;
   LPBYTE lpbTailOffX  = (LPBYTE)lpctt + OFFSET_6;
   LPBYTE lpbTailTable = (LPBYTE)lpctt + OFFSET_7;
   WORD     wXW;
   LPWORD  lpTF;
   int   iTO;
   BYTE  bL, bT, bJS;

   wXW = (BYTE)(lpStrKSC[0]); 
   wXW <<= 8;
   wXW |= (BYTE)(lpStrKSC[1]);

   switch ( GetXWType( wXW ) )
   {
      case  XWT_INVALID :
         *lpStrISC = 0;
         return; 
      case  XWT_EXTENDED :
         bL = (BYTE) (( ( wXW >> 8 ) & 0xFF ) - 0x81);
         bT = (BYTE) (wXW & 0xFF);
         if ( ( bT -= 0x41 ) > 0x19 )
            if ( ( bT -= 6 ) > 0x33 )
               bT -= 6;
         iTO = bT + lpbTailOffX[bL];
         lpTF = lpwTailFirstX + ( bL = lpbLeadMapX[bL] );
         goto FindHangeul;
      case  XWT_WANSUNG :
         bL = (BYTE) (( ( wXW >> 8 ) & 0xFF ) - 0xB0);
         iTO = ( wXW & 0xFF ) - 0xA1 + lpbTailOff[bL];
         lpTF = lpwTailFirst + ( bL = lpbLeadMap[bL] );
         goto FindHangeul;
      case  XWT_JUNJA :
         wXW -= 0xA100;
         bJS = 0xD9;
         goto FindSymbol;
      case  XWT_HANJA :
         wXW -= 0xCA00;
         bJS = 0xE0;
         goto FindSymbol;
      case  XWT_UDC :
         if ( ( ( wXW -= 0xC900 ) & 0xFF00 ) != 0 )
            wXW -= ( 0xFE00 - 0xC900 - 0x100 );
         bJS = 0xD8;
         goto FindSymbol;
   }

FindHangeul:
   iTO += *lpTF++;
   while ( iTO >= *lpTF++ )  bL++;
   *(LPWORD)lpStrISC  = (WORD) lpbTailTable[iTO]  * 256 + ( bL + 0x88 );
   return;

FindSymbol:
   bL = (BYTE) (( wXW >> 8 ) & 0xFF);
   bT = (BYTE) (wXW & 0xFF);
   if ( ( bL & 1 ) == 0 )
      bT -= ( ( bT <= 0xEE ) ? 0x70 : 0x5E );
   bJS += ( bL / 2 );
   *(LPWORD)lpStrISC = (WORD) bT * 256 + bJS;
}




VOID SJisToJis(
    TRANSTAB *lpctt,
    LPSTR     lpStrSJis,
    LPSTR     lpStrJis)

/*++

Routine Description:

    Shift-JIS to JIS code conversion
    Convert given string in SHIFT-JIS codeset to JIS code set
    VOID SJisToJis(lpctt, lpStrSJis, lpStrJis)
    lpctt points to selected CTT.
    lpStrSJis points to a SINGLE character code in SHIFT-JIS
    lpStrJis points to a buffer to receive a SINGLE character code in JIS
    CTT contents (CPJIS78.ctt)
    uCode contains nothing.

Arguments:

    lpctt - pointer to TRANSTAB
    lpStrSJis - pointer to Shift JIS string
    lpStrJis - pointer to JIS string

Return Value:

--*/
{
    register  BYTE    x, y;
    x = lpStrSJis[0];
    y = lpStrSJis[1];

    //
    // Replace code values which cannot be mapped into 0x2121 - 0x7e7e
    // (94 x 94 character plane) with Japanese defult character, which
    // is KATAKANA MIDDLE DOT.
    //

    if (x >= 0xf0) {
        x = 0x81;
        y = 0x45;
    }

    x -= x >= (BYTE)0xa0 ? (BYTE)0xb0: (BYTE)0x70;
    if ( y >= 0x80)
        y--;
    x <<= 1;
    if ( y < 0x9e)
        x--;
    else
        y -= 0x5e;
    y -= 0x1f;
    lpStrJis[0] = x;
    lpStrJis[1] = y;
}

VOID AnkToJis(
    TRANSTAB *lpctt,
    LPSTR     lpStrAnk,
    LPSTR     lpStrJis)

/*++

Routine Description:

    ANK to JIS code conversion
    Convert given string in ANK codeset to JIS code set
    VOID AnkToJis(lpctt, lpStrAnk, lpStrJis)
    lpctt points to selected CTT.
    lpStrAnk points to a SINGLE character code in ANK
    lpStrJis points to a buffer to receive a SINGLE character code in JIS

    CTT contents (CPJIS83.ctt)
    uCode.psCode[0] = number of subtable     (==2)
    uCode.psCode[1] = offset from the CTT to subtable #1 (for 0x20 ~ 0x7F)
    uCode.psCode[2] = offset from the CTT to subtable #2 (for 0xA0 ~ 0xDF)
    Each entry in subtable contains shift-jis code (first byte:second byte)

Arguments:


Return Value:

    NONE

--*/
{
    LPSTR   lpStrSJis;
    register BYTE  bAnk;

    bAnk = *lpStrAnk;
    if ( bAnk < 0xA0)
        lpStrSJis = (LPSTR) lpctt + lpctt->uCode.psCode[1]
                             + (bAnk - 0x20) * 2;
    else
        lpStrSJis = (LPSTR) lpctt + lpctt->uCode.psCode[2]
                             + (bAnk - 0xA0) * 2;
   SJisToJis((TRANSTAB *)NULL, lpStrSJis, lpStrJis);
}

#ifdef JIS78 // Currently this is not enabled.

#define MAXADD  4
#define MAXCHG 22

VOID SysTo78(
TRANSTAB *lpctt,
LPSTR     lpStrSys,
LPSTR     lpStr78)
/*++

Routine Description:

    System JIS code to JIS78 code conversion
    Convert given string in System CodeSet(JIS83 or 90) to JIS78 CodeSet
    VOID SysTo78(lpctt, lpStrSys, lpStr78)
    lpctt points to selected CTT.
    lpStrSys points to a JIS character code in JIS90
    lpStr78 points to a buffer to receive a SINGLE character code in JIS78

    CTT contents (CPJIS78.ctt)
    uCode.psCode[0] = number of subtable     (==4)
    uCode.psCode[1] = offset from the CTT to subtable #1 (for 0x20 ~ 0x7F)
    uCode.psCode[2] = offset from the CTT to subtable #2 (for 0xA0 ~ 0xDF)
    Each entry in subtable contains shift-jis code (first byte:second byte)
    ( Previous 2 ,psCode[1] and psCode[2] are used at AnkToJis() )
    uCode.psCode[3] = offset from the CTT to subtable #3 (for 0x7421 ~ 0x7424)
    uCode.psCode[4] = offset from the CTT to subtable #4
    (Swap table: Level 1 Kanji <-> Level 2 Kanji)
    Each entry in subtable contains jis code (first byte:second byte)

    MAXADD is number of table psCode[3]'s elements.
    MAXCHG is number of table psCode[4]'s elements.

Arguments:

    pPDev           Pointer to PDEV

Return Value:

--*/
{
    register WORD  wSys;
    LPSTR lpCurrent;
    int i;

    wSys = *(LPWORD)lpStrSys;

    for(i = 0; i < MAXADD; ++i){
        lpCurrent = (LPSTR) lpctt + lpctt->uCode.psCode[3] + i * 4 + 2;
        if(wSys == *(LPWORD)(lpCurrent - 2)){
            lpStr78[0] = *lpCurrent;
            lpStr78[1] = *(lpCurrent + 1);
            return;
        }
    }

    if(LOBYTE(wSys) < 0x50)   // Convert Level 1 Kanji -> Level 2 Kanji
        for(i = 0; i < MAXCHG; ++i){
            lpCurrent = (LPSTR) lpctt + lpctt->uCode.psCode[4] + i * 4 + 2;
            if(wSys == *(LPWORD)(lpCurrent - 2)){
                lpStr78[0] = *lpCurrent;
                lpStr78[1] = *(lpCurrent + 1);
                return;
            }
        }
    else                      // Convert Level 2 Kanji -> Level 1 Kanji
        for(i = 0; i < MAXCHG; ++i){
            lpCurrent = (LPSTR) lpctt + lpctt->uCode.psCode[4] + i * 4;
            if(wSys == *(LPWORD)(lpCurrent + 2)){
                lpStr78[0] = *lpCurrent;
                lpStr78[1] = *(lpCurrent + 1);
                return;
            }
        }
    lpStr78[0] = lpStrSys[0];
    lpStr78[1] = lpStrSys[1];
}

#endif //JIS78

//
//  Big5ToNS86
//
//  Convert given string in Big-5 codeset to NS86 code set
//  VOID Big5ToNS86(lpctt, lpStrBig5, lpStrNS)
//  lpctt points to selected CTT.
//  lpStrBig5 points to a SINGLE character code in Big-5
//  lpStrNS points to a buffer to receive a SINGLE character code in NS
//
//  To understand the table structure, please refer to CPNS86.ASM
//
//  [Code range]
//  Big5 =
//  Leading byte:   0xA1 ~ 0xFE
//  Trailing byte:  0x40 ~ 0x7E, 0xA1 ~ 0xFE (157 candidates)
//  NS86 =
//  Leading byte:   0xA1 ~ 0xFE
//  Trailing byte:  0xA1 ~ 0xFE(face I) (94 candidates)
//                  0x21 ~ 0x7E(face II)(94 candidates)
//  CTT contents (CPNS86.ctt)
//  uCode.psCode[0] = nTables, number of sub tables  (==2)
//  uCode.psCode[1] = number of entries in search range sub table
//  uCode.psCode[2] = offset from CTT to the search ranges sub table
//  uCode.psCode[3] = number of entries in adjust sub table
//  uCode.psCode[4] = offset from CTT to the adjust sub table
//
//{
//    WORD    Big5Seq, wch, i;
//    LPWORD  lpw;
//    wch = MAKEWORD(lpStrBig5[1], lpStrBig5[0]);
//
//    if ( (wch < 0xA140 || wch > 0xF9D5) ||      // valid range :
//         (wch > 0xC67E && wch < 0xC940) )       // 0xA140 ~ 0xC67E &
//        goto  BTN_Exit;                         // 0xC940 ~ 0xF9D5
//
//    if (wch == 0xC94A)
//        {
//        wch = 0xC4C2;                // Special case #1, 0xC94A -> 0xC4C2;
//        goto BTN_Exitl
//        }
//    if (wch == 0xDDFC)
//        {                           // Special case #2, 0xDDFC -> 0xC176;
//        wch = 0xC176;
//        goto BTN_Exit;
//        }
//
//// Calculate Big-5 sequence code
//    Big5Seq = LOBYTE(wch) - 0x40;        // lower byte first
//    if (Big5Seq > 0x3E)                 // 0x40 ~ 0x7E => 0 ~ 0x3E
//        Big5Seq -= 0xA1 - (0x3F + 0x40);// 0xA1 ~ 0xFE => 0x3F ~ 0x9D
//    Big5Seq += (HIBYTE(wch) - 0xA1) * 157;
//
//    lpw = (LPSTR)lpctt + lpctt->uCode.psCode[2];    // range sub table address
//
//// Search which range we are in
//    for (i = 0; Big5Seq > lpw[i]; i++)
//        ;
//    lpw = (LPSTR) lpctt + lpctt->uCode.psCode[4];   // adjust sub table address
//    Big5Seq += lpw[i];
//
//    if (Big5Seq >= 6280)        // (0xC9 - 0xA1) * 157, Big-5 face II
//        {
//        wch = 0xA121;
//        Big5Seq -= 6280;        // offset from 0
//        }
//    else
//        {
//        wch = 0xA1A1;
//
//        if (Big5Seq >= 471)     // (0xA4 - 0xA1) * 157, Big-6 most common char
//            Big5Seq += 3290 - 471;    // (0x44 - 0x21)*94 - (0xA4 - 0xA1) * 157
//        }
//    wch += (Big5Seq / 94) << 8;
//    wch += Big5Seq % 94;
//
//  BTN_Exit:
//      lpStrNS[0] = LOBYTE(wch);
//      lpStrNS[1] = HIBYTE(wch);
//}
//---------------------------------------------------------------------------

VOID Big5ToNS86(
    TRANSTAB *lpctt,
    LPSTR     lpStrBig5,
    LPSTR     lpStrNS)
/*++

Routine Description:

    Convert given string in Big-5 codeset to NS86 code set

Arguments:

Return Value:

--*/
{

    WORD    Big5Seq, wch, i;
    LPWORD  lpw;

    wch = MAKEWORD(lpStrBig5[1], lpStrBig5[0]);

    if ( (wch < 0xA140 || wch > 0xF9D5) ||      // valid range :
         (wch > 0xC67E && wch < 0xC940) )       // 0xA140 ~ 0xC67E &
        goto  BTN_Exit;                         // 0xC940 ~ 0xF9D5

    if (wch == 0xC94A)
    {
        wch = 0xC4C2;                // Special case #1, 0xC94A -> 0xC4C2;
        goto BTN_Exit;
    }
    if (wch == 0xDDFC)
    {                                // Special case #2, 0xDDFC -> 0xC176;
        wch = 0xC176;
        goto BTN_Exit;
    }

    //
    // Calculate Big-5 sequence code
    //

    Big5Seq = LOBYTE(wch) - 0x40;        // lower byte first
    if (Big5Seq > 0x3E)                  // 0x40 ~ 0x7E => 0 ~ 0x3E
        Big5Seq -= 0xA1 - (0x3F + 0x40); // 0xA1 ~ 0xFE => 0x3F ~ 0x9D
    Big5Seq += (HIBYTE(wch) - 0xA1) * 157;

    lpw = (LPWORD)((LPSTR)lpctt + lpctt->uCode.psCode[2]);    // range sub table address

    //
    // Search which range we are in
    //

    for (i = 0; Big5Seq > lpw[i]; i++)
        ;
    lpw = (LPWORD)((LPSTR) lpctt + lpctt->uCode.psCode[4]);   // adjust sub table address
    Big5Seq += lpw[i];

    if (Big5Seq >= 6280)        // (0xC9 - 0xA1) * 157, Big-5 face II
    {
        wch = 0xA121;
        Big5Seq -= 6280;        // offset from 0
    }
    else
    {
        wch = 0xA1A1;

        if (Big5Seq >= 471)     // (0xA4 - 0xA1) * 157, Big-6 most common char
            Big5Seq += 3290 - 471;    // (0x44 - 0x21)*94 - (0xA4 - 0xA1) * 157
    }
    wch += (Big5Seq / 94) << 8;
    wch += Big5Seq % 94;

BTN_Exit:
//    lpStrNS[0] = LOBYTE(wch);
//    lpStrNS[1] = HIBYTE(wch);
    lpStrNS[0] = HIBYTE(wch);
    lpStrNS[1] = LOBYTE(wch); /* Modified by Weibing Zhan, 10/25/95
                                   when change a WORD to DBCS Charater, 
                                   Lead Byte maps to high btye of the WORD
                                   Trail Byte maps to the lower byte. 
                                */    
#if 0 //disabling for NT
    _asm
        {
            les     bx, lpStrBig5
            mov     ah, es:[bx]             ; ax = wch
            mov     al, es:[bx+1]           ;
            mov     cx, ax                  ; cx = ax = wch
            cmp     ax, 0A140h              ; legal range:
            jb      BTN_Exit                ; 0A140h <= x <= 0C67Eh
            cmp     ax, 0C67Eh              ;       or
            jbe     BTN_01                  ; 0C940h <= x <= 0F9D5h
            cmp     ax, 0C940h
            jb      BTN_Exit
            cmp     ax, 0F9D5h
            ja      BTN_Exit
BTN_01:
            mov     ax, 0C4C2h              ; Special case #1
            cmp     cx, 0C94Ah              ; 0C94Ah -> 0C4C2h
            je      BTN_Exit

            mov     ax, 0C176h              ; Special case #2
            cmp     cx, 0DDFCh              ; 0DDFCh -> 0C176h
            je      BTN_Exit
;; Convert to sequence number(code)
            sub     cl, 040h                ; 040h ~ 07Eh -> 0 ~ 03Eh
            cmp     cl, 07Fh - 040h
            jb      BTN_02
            sub     cl, 0A1h - (03Fh + 040h) ;0A1h ~ 0FEh -> 03Fh ~ 09Dh
BTN_02:
            sub     ch, 0A1h
            mov     al, 157         ;; 07Fh - 040h + 0FEh - 0A1h
            mul     ch
            xor     ch, ch
            add     ax, cx
            les     di, lpctt
            mov     cx, es:[di].uCode.psCode[2*2]   ; range table offset
            mov     dx, es:[di].uCode.psCode[4*2]   ; adjust table offset
            add     di, cx                          ;es:di -> range  table
            cld
BTN_03:
            scasw
            ja      BTN_03
            sub     di, cx                  ;
            add     di, dx                  ; points es:di to adjust table
            add     ax, es:[di-2]           ; add the adjustment value
;; AX has  adjusted sequence code
;; see CPCNS86.ASM for detail
            mov     cx, 0A1A1h
            cmp     ax, 471
            jb      BTN_04                  ; symbol
            add     ax, 3290 - 471          ; shouldn't overflow
            cmp     ax, 6280 + 3290 - 471
            jb      BTN_04                  ; most common chars

            mov     cx, 0A121h
            sub     ax, 6280 + 3290 - 471   ;less common char
BTN_04:
            mov     dl, 94
            div     dl
            add     al, ch
            add     ah, cl
            xchg    ah, al
BTN_Exit:
    ;; (AH) has leading byte ; (AL) has trailing byte
            les     bx, lpStrNS
            mov     es:[bx], ah             ;
            mov     es:[bx+1], al
        }
#endif //0

}

//
// Big5ToTCA
//
//  Convert given string in Big-5 codeset to TCA code set
//  VOID Big5ToTCA(lpctt, lpStrBig5, lpStrTCA)
//  lpctt points to selected CTT.
//  lpStrBig5 points to a SINGLE character code in Big-5
//  lpStrTCA points to a buffer to receive a SINGLE character code in TCA
//
//  CTT contents (CPTCA.ctt)
//  uCode.psCode[0] = nTables, number of sub tables  (==2)
//  uCode.psCode[1] = number of entries in search range sub table
//  uCode.psCode[2] = offset from CTT to the search ranges sub table
//  uCode.psCode[3] = number of entries in adjust sub table
//  uCode.psCode[4] = offset from CTT to the adjust sub table
//  [Code range]
//  Big5 =
//  Leading byte:   0xA1 ~ 0xFE
//  Trailing byte:  0x40 ~ 0x7E, 0xA1 ~ 0xFE (157 candidates)
//  TCA =
//  Leading byte:   0x81 ~ 0xFD
//  Trailing byte:  0x30 ~ 0x39     (10 candidates)
//                  0x41 ~ 0x5A     (26 candidates)
//                  0x61 ~ 0x7A     (26 candidates)
//                  0x80 ~ 0xFD     (126 candidates)
//                                  (188 candidates)    total
//{
//    WORD    Big5Seq, wch;
//    short   i;
//    LPWORD  lpw;
//    wch = MAKEWORD(lpStrBig5[1], lpStrBig5[0]);
//
//    if ( (wch < 0xA140 || wch > 0xF9D5) ||      // valid range :
//         (wch > 0xC67E && wch < 0xC940) )       // 0xA140 ~ 0xC67E &
//        goto  BTN_Exit;                         // 0xC940 ~ 0xF9D5
//
//    if (wch == 0xC94A)
//        {
//        wch = 0x92C1;                // Special case #1, 0xC94A -> 0x92C1;
//        goto BTT_Exitl
//        }
//    if (wch == 0xDDFC)
//        {                           // Special case #2, 0xDDFC -> 0xC097;
//        wch = 0xC097;
//        goto BTT_Exit;
//        }
//
//// Calculate Big-5 sequence code
//    Big5Seq = LOBYTE(wch) - 0x40;        // lower byte first
//    if (Big5Seq > 0x3E)                 // 0x40 ~ 0x7E => 0 ~ 0x3E
//        Big5Seq -= 0xA1 - (0x3F + 0x40);// 0xA1 ~ 0xFE => 0x3F ~ 0x9D
//    Big5Seq += (HIBYTE(wch) - 0xA1) * 157;
//
//    lpw = (LPSTR)lpctt + lpctt->uCode.psCode[2];    // range sub table address
//
//// Search which range we are in
//    for (i = 0; Big5Seq > lpw[i]; i++)
//        ;
//    lpw = (LPSTR) lpctt + lpctt->uCode.psCode[4];   // adjust sub table address
//    Big5Seq += lpw[i];
//
//    if (Big5Seq >= 6280)        // (0xC9 - 0xA1) * 157, Big-5 face II
//        {
//        wch = 0x0B000;
//        Big5Seq -= 6280;        // offset from 0
//        }
//    else
//        {
//        wch = 0x8100;
//        if (Big5Seq >= 471)     // (0xA4 - 0xA1) * 157, Big-6 most common char
//            Big5Seq += 3290 - 471;    // (0x44 - 0x21)*94 - (0xA4 - 0xA1) * 157
//        }
//      wch += (Big5Seq / 188) << 8;
//      Big5Seq %= 188;
//// TCA trailing byte range
//// 0x30~0x39,0x41~0x5A,0x61~0x7A,0x80~0xFD
//// 0~9   ,  10~35  ,  36~61  ,  62~125
//
//      if (Big5Seq > 61)
//        i = 0x80 + Big5Seq - 62;
//      else
//        if (Big5Seq > 35)
//            i =  0x61 + Big5Seq - 36;
//        else
//            if (Big5Seq > 9)
//                i = 0x41 + Big5Seq - 10;
//            else
//                i = 0x30 + Big5Seq;
//    wch += i;
//
// BTT_Exit:
//    lpStrTCA[0] = HIBYTE(wch);
//    lpStrTCA[1] = LOBYTE[wch);
//}
//

VOID Big5ToTCA(
TRANSTAB *lpctt,
LPSTR     lpStrBig5,
LPSTR     lpStrTCA)
/*++

Routine Description:

    Convert given string in Big-5 codeset to TCA code set

Arguments:

    pPDev           Pointer to PDEV

Return Value:

--*/
{

    WORD    Big5Seq, wch;
    short   i;
    LPWORD  lpw;
    wch = MAKEWORD(lpStrBig5[1], lpStrBig5[0]);

    if ( (wch < 0xA140 || wch > 0xF9D5) ||      // valid range :
         (wch > 0xC67E && wch < 0xC940) )       // 0xA140 ~ 0xC67E &
        goto  BTT_Exit;                         // 0xC940 ~ 0xF9D5

    if (wch == 0xC94A)
    {
        wch = 0x92C1;                // Special case #1, 0xC94A -> 0x92C1;
        goto BTT_Exit;
    }
    if (wch == 0xDDFC)
    {                                // Special case #2, 0xDDFC -> 0xC097;
        wch = 0xC097;
        goto BTT_Exit;
    }

    //
    // Calculate Big-5 sequence code
    //

    Big5Seq = LOBYTE(wch) - 0x40;        // lower byte first
    if (Big5Seq > 0x3E)                 // 0x40 ~ 0x7E => 0 ~ 0x3E
        Big5Seq -= 0xA1 - (0x3F + 0x40);// 0xA1 ~ 0xFE => 0x3F ~ 0x9D
    Big5Seq += (HIBYTE(wch) - 0xA1) * 157;

    lpw = (LPWORD)((LPSTR)lpctt + lpctt->uCode.psCode[2]);    // range sub table address

    //
    // Search which range we are in
    //

    for (i = 0; Big5Seq > lpw[i]; i++)
        ;
    lpw = (LPWORD)((LPSTR) lpctt + lpctt->uCode.psCode[4]);   // adjust sub table address
    Big5Seq += lpw[i];

    if (Big5Seq >= 6280)        // (0xC9 - 0xA1) * 157, Big-5 face II
    {
        wch = 0x0B000;
        Big5Seq -= 6280;        // offset from 0
    }
    else
    {
        wch = 0x8100;
        if (Big5Seq >= 471)     // (0xA4 - 0xA1) * 157, Big-6 most common char
            Big5Seq += 3290 - 471;    // (0x44 - 0x21)*94 - (0xA4 - 0xA1) * 157
    }
    wch += (Big5Seq / 188) << 8;
    Big5Seq %= 188;

    //
    // TCA trailing byte range
    // 0x30~0x39,0x41~0x5A,0x61~0x7A,0x80~0xFD
    // 0~9   ,  10~35  ,  36~61  ,  62~125
    //

    if (Big5Seq > 61)
        i = 0x80 + Big5Seq - 62;
    else
        if (Big5Seq > 35)
            i =  0x61 + Big5Seq - 36;
        else
            if (Big5Seq > 9)
                i = 0x41 + Big5Seq - 10;
            else
                i = 0x30 + Big5Seq;
    wch += i;

BTT_Exit:
    lpStrTCA[0] = HIBYTE(wch);
    lpStrTCA[1] = LOBYTE(wch);


#if 0 //disabling for NT
    _asm
        {
            les     bx, lpStrBig5
            mov     ah, es:[bx]             ; get big5 leading byte
            mov     al, es:[bx+1]           ; and trailing byte
            mov     cx, ax                  ; cx = ax = wch
            cmp     ax, 0A140h              ; legal range:
;?????????????????
            jb      BTT_Bridge              ; 0A140h <= x <= 0C67Eh
            cmp     ax, 0C67Eh              ;       or
            jbe     BTT_01

            cmp     ax, 0C940h
BTT_Bridge:
            jb      BTT_Exit               ; 0C940h <= x <= 0F9D5h
            cmp     ax, 0F9D5h
            ja      BTT_Exit
BTT_01:
            mov     ax, 092C1h              ; Special case #1
            cmp     cx, 0C94Ah              ; 0C94Ah -> 092C1h
            je      BTT_Exit

            mov     ax, 0C097h              ; Special case #2
            cmp     cx, 0DDFCh              ; 0DDFCh -> 0C097h
            je      BTT_Exit
;; Convert to sequence number(code)
            sub     cl, 040h                ; 040h ~ 07Eh -> 0 ~ 03Eh
            cmp     cl, 07Fh - 040h
            jb      BTT_02
            sub     cl, 0A1h - (03Fh + 040h) ;0A1h ~ 0FEh -> 03Fh ~ 09Dh
BTT_02:
            sub     ch, 0A1h
            mov     al, 157         ;; 07Fh - 040h + 0FEh - 0A1h
            mul     ch
            xor     ch, ch
            add     ax, cx
            les     di, lpctt
            mov     cx, es:[di].uCode.psCode[2*2]   ; range table offset
            mov     dx, es:[di].uCode.psCode[4*2]   ; adjust table offset
            add     di, cx                          ;es:di -> range  table
            cld
BTT_03:
            scasw
            ja      BTT_03
            sub     di, cx                  ;
            add     di, dx                  ; points es:di to adjust table
            add     ax, es:[di-2]           ; add the adjustment value
;; AX has  adjusted sequence code
;; see CPTCA.ASM for detail
            mov     ch, 081h
            cmp     ax, 471
            jb      BTT_04                  ; symbol
            add     ax, 3290 - 471          ; shouldn't overflow
            cmp     ax, 6280 + 3290 - 471
            jb      BTT_04                  ; most common chars

            mov     ch, 0B0h
            sub     ax, 6280 + 3290 - 471   ;less common char
BTT_04:
            mov     dl, 188                 ;30h~39h, 41h~5Ah, 61h~7Ah, 80h~0FDh
            div     dl
            add     al, ch                  ;leading byte
            mov     cl, 030h                ; 030h ~ 039h -> 0 ~ 9
            cmp     ah, 09h
            jbe     BTT_05
            mov     cl, 041h - 10           ; 041h ~ 05Ah -> 10 ~ 35
            cmp     ah, 35
            jbe     BTT_05
            mov     cl, 061h - 36           ; 061h ~ 07Ah -> 36 ~ 61
            cmp     ah, 61
            jbe     BTT_05
            mov     cl, 080h - 62           ; 080h ~ 0FDh -> 62 ~ 187
BTT_05:
            add     ah, cl                  ; traling byte
            xchg    ah, al
BTT_Exit:
;; (AH) has leading byte ; (AL) has trailing byte
            les     bx, lpStrTCA
            mov     es:[bx], ah
            mov     es:[bx+1], al
        }
#endif //0

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\alpsres\alpsres.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


typedef struct {
    INT iPaperSizeID;
    LONG iLogicalPageWidth;
    LONG iLogicalPageHeight;
    INT iTopMargin;
    INT iLeftMargin;
    INT iRightMargin;
    BOOL bAsfOk;
    /* Add new attributes here */
} PAPERSIZE;

typedef struct {

    int  iCurrentResolution; // current resolution
    int  iPaperQuality;      // paper quality
    int  iPaperSize;         // paper size
    int  iPaperSource;       // paper source
    int  iTextQuality;       // photo or business graphics or character or grayscale
    int  iModel;             // MD-2000, MD-2010 or MD-4000
    int  iDither;            // DITHER_HIGH or DITHER_LOW
    BOOL fRequestColor;      // 1: user selected color 0: user selected mono
    INT iUnitScale;
    INT iEmulState; // Current emulation status.
    BOOL bXflip; // TRUE if mirror output mode
    int  y;

    PAPERSIZE *pPaperSize;

    WORD wRasterOffset[4]; // Temp. counter used for Y move.
    WORD wRasterCount; // # or raster lines left in logical page.

    INT PlaneColor[4]; // Color ID for each plane 
    INT iCompMode[4];  // Current compression mode.  (arranged by YoshitaO)

    BYTE *pData; // Pointer for allocated memory
    BYTE *pData2; // Scratch buffer
    BYTE *pRaster[4]; // Raster data buffer for each plane
    BYTE *pRasterC; // Cyan raster data (pointer to pRaster[x])
    BYTE *pRasterM; // Magenta ( " )
    BYTE *pRasterY; // Yellow ( " )
    BYTE *pRasterK; // Black ( " )

    HANDLE TempFile[4]; // Temp. file handles
    TCHAR TempName[4][MAX_PATH]; // Temp. file names

    BYTE KuroTBL[256];
    BYTE UcrTBL[256];
    BYTE YellowUcr;
    int  RGB_Rx;
    int  RGB_Ry;
    int  RGB_Gx;
    int  RGB_Gy;
    int  RGB_Bx;
    int  RGB_By;
    int  RGB_Wx;
    int  RGB_Wy;
    int  RGB_Cx;
    int  RGB_Cy;
    int  RGB_Mx;
    int  RGB_My;
    int  RGB_Yx;
    int  RGB_Yy;
    int  CMY_Cx;
    int  CMY_Cy;
    int  CMY_Mx;
    int  CMY_My;
    int  CMY_Yx;
    int  CMY_Yy;
    int  CMY_Rx;
    int  CMY_Ry;
    int  CMY_Gx;
    int  CMY_Gy;
    int  CMY_Bx;
    int  CMY_By;
    int  CMY_Wx;
    int  CMY_Wy;
    int  CMY_Cd;
    int  CMY_Md;
    int  CMY_Yd;
    int  CMY_Rd;
    int  CMY_Gd;
    int  CMY_Bd;
    int  RedAdj;
    int  RedStart;
    int  GreenAdj;
    int  GreenStart;
    int  BlueAdj;
    int  BlueStart;
    BYTE RedHosei[256];
    BYTE GreenHosei[256];
    BYTE BlueHosei[256];
} CURRENTSTATUS, *PCURRENTSTATUS;

#define CMDID_PSIZE_FIRST             1
#define CMDID_PSIZE_A4                1
#define CMDID_PSIZE_B5                2
#define CMDID_PSIZE_EXECTIVE          3
#define CMDID_PSIZE_LEGAL             4
#define CMDID_PSIZE_LETTER            5
#define CMDID_PSIZE_POSTCARD          6
#define CMDID_PSIZE_POSTCARD_DOUBLE   7
#define CMDID_PSIZE_PHOTO_COLOR_LABEL 17
#define CMDID_PSIZE_GLOSSY_LABEL      18
#define CMDID_PSIZE_CD_MASTER         19
#define CMDID_PSIZE_VD_PHOTO_POSTCARD 22

#define CMDID_RESOLUTION_1200_MONO   10
#define CMDID_RESOLUTION_600         11
#define CMDID_RESOLUTION_300         12

#define CMDID_COLORMODE_MONO         15
#define CMDID_COLORMODE_COLOR        16

#define CMDID_CURSOR_RELATIVE        20

#define CMDID_TEXTQUALITY_PHOTO      30
#define CMDID_TEXTQUALITY_GRAPHIC    31
#define CMDID_TEXTQUALITY_CHARACTER  32
#define CMDID_TEXTQUALITY_GRAY       33

#define CMDID_PAPERQUALITY_FIRST            40
#define CMDID_PAPERQUALITY_PPC_NORMAL       40
#define CMDID_PAPERQUALITY_PPC_FINE         41
#define CMDID_PAPERQUALITY_OHP_NORMAL       42
#define CMDID_PAPERQUALITY_OHP_FINE         43
#define CMDID_PAPERQUALITY_OHP_EXCL_NORMAL  44
#define CMDID_PAPERQUALITY_OHP_EXCL_FINE    45
#define CMDID_PAPERQUALITY_IRON_PPC         46
#define CMDID_PAPERQUALITY_IRON_OHP         47
#define CMDID_PAPERQUALITY_THICK            48
#define CMDID_PAPERQUALITY_POSTCARD         49
#define CMDID_PAPERQUALITY_HIGRADE          50
#define CMDID_PAPERQUALITY_BACKPRINTFILM    51
#define CMDID_PAPERQUALITY_LABECA_SHEET     52
#define CMDID_PAPERQUALITY_CD_MASTER        53
#define CMDID_PAPERQUALITY_DYE_SUB_PAPER    54
#define CMDID_PAPERQUALITY_DYE_SUB_LABEL    55
#define CMDID_PAPERQUALITY_GLOSSY_PAPER     56
#define CMDID_PAPERQUALITY_VD_PHOTO_FILM    57
#define CMDID_PAPERQUALITY_VD_PHOTO_CARD    58

#define CMDID_BEGINDOC_FIRST      60
#define CMDID_BEGINDOC_MD2000     60
#define CMDID_BEGINDOC_MD2010     61
#define CMDID_BEGINDOC_MD5000     65
#define CMDID_BEGINPAGE           62
#define CMDID_ENDPAGE             63
#define CMDID_ENDDOC              64

#define CMDID_PAPERSOURCE_CSF     70
#define CMDID_PAPERSOURCE_MANUAL  71

#define CMDID_MIRROR_ON           80
#define CMDID_MIRROR_OFF          81

#define NONE                       0
#define YELLOW                     1
#define CYAN                       2
#define MAGENTA                    3
#define BLACK                      4

#define DPI1200                 1200
#define DPI600                   600
#define DPI300                   300

#define TEMP_NAME_PREFIX __TEXT("~AL")

// Macros to get current plane model.  We have following
// three types of the plane model:
//
//    K - 1 plane/composite, send order K.
//    MCY - 3 planes, send order M, C, Y.
//    YMC - 3 planes, send order Y, C, M.
//    CMYK - 4 planes, send order C, M, Y, K.
//

// ntbug9#24281: large bitmap does not printed on 1200dpi.
// Do not use black plane (K) on the 1200dpi with color mode.
#define bPlaneSendOrderCMY(p) \
    ((p)->fRequestColor && (p)->iCurrentResolution == DPI1200)

#define bPlaneSendOrderMCY(p) \
    (((p)->iPaperQuality == CMDID_PAPERQUALITY_OHP_EXCL_NORMAL) || \
    ((p)->iPaperQuality == CMDID_PAPERQUALITY_OHP_EXCL_FINE))

#define bPlaneSendOrderYMC(p) \
    (((p)->iPaperQuality == CMDID_PAPERQUALITY_DYE_SUB_PAPER) || \
    ((p)->iPaperQuality == CMDID_PAPERQUALITY_DYE_SUB_LABEL) || \
    ((p)->iPaperQuality == CMDID_PAPERQUALITY_GLOSSY_PAPER) || \
    ((p)->iPaperQuality == CMDID_PAPERQUALITY_IRON_OHP))

#define bPlaneSendOrderCMYK(p) \
    (!bPlaneSendOrderCMY(p) && !bPlaneSendOrderMCY(p) && !bPlaneSendOrderYMC(p))


//
// Printer emulation state.  MD-xxxx printers have three major
// state and what kind of printer commands can be issued at a time
// will be decided by in which emulation state currently the printer
// is at.
//

#define EMUL_IDLE               0
#define EMUL_RGL                1
#define EMUL_DATA_TRANSFER      2

//
// Compression modes.  
//

#define COMP_NONE       0
#define COMP_TIFF4      1

//
// The following switch is to force use of black ribbon whenever
// the data to print is black.  Originally, the dither algprithm
// is designed so that this mode is only used with text objects
// in the docouemnt (graphics images are output by using composite
// blacks).
//
// Unfortunately in Unidriver <-> Minidriver model the data is
// passed to Minidriver after rendering.  This means that Minidriver
// cannot distinguish between text objects and graphics objects.
// We may have some degree of quality degrade, however it is better
// than the customers claiming the printer wastes his/her color
// ribbons.
//

#define BLACK_RIBBON_HACK 1

//
// We cache each plane data in a temporary file.  We can omit
// caching the first plane (so that the data is send to the printer
// immediately) by setting following flag to 0.
//

#define CACHE_FIRST_PLANE 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\alpsres\alpsres.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


#include "pdev.h"
#include "alpsres.h"
#include "dither.h"

#include <stdio.h>

INT iCompTIFF( BYTE *, BYTE *, int );

BOOL bTextQuality(
PDEVOBJ     pdevobj);


BOOL IsAsfOkMedia(
PDEVOBJ     pdevobj);

BOOL
bDataSpool(
   PDEVOBJ    pdevobj,
   HANDLE hFile,
   LPSTR  pBuf,
   DWORD dwLen);

BOOL
bSpoolOut(
    PDEVOBJ pdevobj);

#define DATASPOOL(p, f, s, n) \
    if (TRUE != bDataSpool((p), (f), (s), (n))) \
        return FALSE;
#define SPOOLOUT(p) \
    if (TRUE != bSpoolOut(p)) \
        return FALSE;
//
// Decision table for media type/paper
// source selection.  To avoid hardware damage,
// we will select "manual feed" whenever ASF is
// not appropriate to specified media.
//

static struct {
    BOOL bAsfOk; // Can print on ASF
    // Add new attributes here
} gMediaType[] = {
    {1}, // PPC (Normal)
    {1}, // PPC (Fine)
    {1}, // OHP (Normal)
    {1}, // OHP (Fine)
    {1}, // ExcOHP (Normal)
    {1}, // ExcOHP (Fine)
    {0}, // Iron (PPC)
    {0}, // Iron (OHP)
    {0}, // Thick Paper
    {1}, // Postcard
    {1}, // High Grade Paper
    {0}, // Back Print Film
    {0}, // Labeca Sheet
    {0}, // CD Master
    {1}, // Dye-sub Paper
    {1}, // Dye-sub Label
    {0}, // Glossy Paper
    {1}, // VD Photo Film
    {1}, // VD Photo Postcard
    // Add new media type here
};

static
PAPERSIZE
gPaperSize[] = {
    {2, 4800 * 2, 5960 * 2, 0, 0, 0, 1}, // Letter
    {3, 4800 * 2, 7755 * 2, 0, 0, 0, 1}, // Legal
    {1, 4190 * 2, 5663 * 2, 0, 0, 0, 1}, // Exective
    {4, 4800 * 2, 6372 * 2, 0, 0, 0, 1}, // A4
    {5, 4138 * 2, 5430 * 2, 0, 0, 0, 1}, // B5
    {6, 2202 * 2, 2856 * 2, 0, 0, 0, 1}, // Postcard
    {6, 4564 * 2, 2856 * 2, 0, 0, 0, 1}, // Double Postcard
    {7, 2202 * 2, 3114 * 2, 0, 0, 0, 1}, // Photo Color Label
    {7, 2202 * 2, 2740 * 2, 0, 0, 0, 1}, // Glossy Label
    {0, 2030 * 2, 3164 * 2, 0, 0, 0, 1}, // CD Master
    {6, 2202 * 2, 3365 * 2, 0, 0, 0, 1}, // VD Photo Postcard
    /* Add new paper sizes here */
};

#define PAPER_SIZE_LETTER   0
#define PAPER_SIZE_LEGAL    1
#define PAPER_SIZE_EXECTIVE 2
#define PAPER_SIZE_A4       3
#define PAPER_SIZE_B5       4
#define PAPER_SIZE_POSTCARD 5
#define PAPER_SIZE_DOUBLE_POSTCARD 6
#define PAPER_PHOTO_COLOR_LABEL    7
#define PAPER_GLOSSY_LABEL  8
#define PAPER_CD_MASTER     9
#define PAPER_VD_PHOTO_POSTCARD   10
/* Add new paper sizes here */
#define PAPER_SIZE_MAX      (sizeof(gPapeSize)/sizeof(gPaperSize[0]) - 1)

//
// ---- F U N C T I O N S ----
//
//////////////////////////////////////////////////////////////////////////
//  Function:   OEMEnablePDEV
//
//  Description:  OEM callback for DrvEnablePDEV;
//                  allocate OEM specific memory block
//
//  Parameters:
//
//        pdevobj        Pointer to the DEVOBJ. pdevobj->pdevOEM is undefined.
//        pPrinterName    name of the current printer.
//        cPatterns, phsurfPatterns, cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo:
//                These parameters are identical to what's passed
//                into DrvEnablePDEV.
//        pded        points to a function table which contains the 
//                system driver's implementation of DDI entrypoints.
//
//  Returns:
//        Pointer to the PDEVOEM
//
//  Comments:
//        
//
//  History:
//
//////////////////////////////////////////////////////////////////////////

PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ pdevobj,
    PWSTR pPrinterName,
    ULONG cPatterns,
    HSURF *phsurfPatterns,
    ULONG cjGdiInfo,
    GDIINFO* pGdiInfo,
    ULONG cjDevInfo,
    DEVINFO* pDevInfo,
    DRVENABLEDATA *pded)
{
    PCURRENTSTATUS pTemp = NULL;

    VERBOSE((DLLTEXT("OEMEnablePDEV() entry.\n")));

    pdevobj->pdevOEM = NULL;

    // Allocate minidriver private PDEV block.

    pTemp = (PCURRENTSTATUS)MemAllocZ(sizeof(CURRENTSTATUS));
    if (NULL == pTemp) {
        ERR(("Memory allocation failure.\n"));
        goto FAIL_NO_MEMORY;
    }

#define MAX_RASTER_PIXELS 5100
// In worstcase, Photo color printing mode use 4 bits par pixel
#define MAX_RASTER_BYTES (MAX_RASTER_PIXELS + 1 / 2)
// Buffers for four plane rasters and one for the
// the scratch work enough for worstcase compression
// overhead.
// The 1st one byte is used for On/Off flag.
#define MAX_RASTER_BUFFER_BYTES \
    (4 + MAX_RASTER_BYTES * 5 + (MAX_RASTER_BYTES >> 4))

    pTemp->pData = (PBYTE)MemAllocZ(MAX_RASTER_BUFFER_BYTES);
    if (NULL == pTemp->pData) {
        ERR(("Memory allocation failure.\n"));
        goto FAIL_NO_MEMORY;
    }

    pTemp->pRaster[0] = pTemp->pData;
    pTemp->pRaster[1] = pTemp->pRaster[0] + (1 + MAX_RASTER_BYTES);
    pTemp->pRaster[2] = pTemp->pRaster[1] + (1 + MAX_RASTER_BYTES);
    pTemp->pRaster[3] = pTemp->pRaster[2] + (1 + MAX_RASTER_BYTES);
    pTemp->pData2 = pTemp->pRaster[3] + (1 + MAX_RASTER_BYTES);

    pTemp->pPaperSize = (PAPERSIZE *)MemAllocZ(
            sizeof (gPaperSize));
    if (NULL == pTemp->pPaperSize) {
        ERR(("Memory allocation failure.\n"));
        goto FAIL_NO_MEMORY;
    }
    CopyMemory(pTemp->pPaperSize, gPaperSize,
            sizeof (gPaperSize));

    // Set minidriver PDEV address.

    pdevobj->pdevOEM = (MINIDEV *)MemAllocZ(sizeof(MINIDEV));
    if (NULL == pdevobj->pdevOEM) {
        ERR(("Memory allocation failure.\n"));
        goto FAIL_NO_MEMORY;
    }

    MINIDEV_DATA(pdevobj) = pTemp;

    return pdevobj->pdevOEM;

FAIL_NO_MEMORY:
    if (NULL != pTemp) {
        if (NULL != pTemp->pData) {
            MemFree(pTemp->pData);
        }
        if (NULL != pTemp->pPaperSize) {
            MemFree(pTemp->pPaperSize);
        }
        MemFree(pTemp);
    }
    return NULL;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   OEMDisablePDEV
//
//  Description:  OEM callback for DrvDisablePDEV;
//                  free all allocated OEM specific memory block(s)
//
//  Parameters:
//
//        pdevobj            Pointer to the DEVOBJ.
//
//  Returns:
//        None
//
//  Comments:
//        
//
//  History:
//
//////////////////////////////////////////////////////////////////////////

VOID APIENTRY
OEMDisablePDEV(
    PDEVOBJ pdevobj)
{
    PCURRENTSTATUS pTemp;

    VERBOSE((DLLTEXT("OEMDisablePDEV() entry.\n")));

    if ( NULL != pdevobj->pdevOEM ) {

        PCURRENTSTATUS pTemp = (PCURRENTSTATUS)MINIDEV_DATA(pdevobj);

        if (NULL != pTemp) { 
            if (NULL != pTemp->pData) {
                MemFree(pTemp->pData);
            }
            if (NULL != pTemp->pPaperSize) {
                MemFree(pTemp->pPaperSize);
            }
            MemFree( pTemp );
        }

        MemFree( pdevobj->pdevOEM );
        pdevobj->pdevOEM = NULL;
    }
}


BOOL APIENTRY
OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew )
{
    PCURRENTSTATUS pTempOld, pTempNew;
    PBYTE pTemp;

    VERBOSE((DLLTEXT("OEMResetPDEV entry.\n")));

    // Do some verificatin on PDEV data passed in.
    pTempOld = (PCURRENTSTATUS)MINIDEV_DATA(pdevobjOld);
    pTempNew = (PCURRENTSTATUS)MINIDEV_DATA(pdevobjNew);

    // Copy mindiriver specific part of PDEV
    if (NULL != pTempNew && NULL != pTempOld) {
        // #279876: Should implement OEMResetPDEV().
        // See also: #249133: 2nd page is distorted with duplex...
        // This printer doesn't have duplex but we should copy them.
        pTempNew->iCurrentResolution = pTempOld->iCurrentResolution;
        pTempNew->iPaperQuality = pTempOld->iPaperQuality;
        pTempNew->iPaperSize = pTempOld->iPaperSize;
        pTempNew->iPaperSource = pTempOld->iPaperSource;
        pTempNew->iTextQuality = pTempOld->iTextQuality;
        pTempNew->iModel = pTempOld->iModel;
        pTempNew->iDither = pTempOld->iDither;
        pTempNew->fRequestColor = pTempOld->fRequestColor;
        pTempNew->iUnitScale = pTempOld->iUnitScale;
        pTempNew->iEmulState = pTempOld->iEmulState;
        pTempNew->bXflip = pTempOld->bXflip;
    }

    return TRUE;
}


VOID
XFlip(
    PDEVOBJ pdevobjOld,
    PCURRENTSTATUS pdevOEM,
    PBYTE pBuf,
    DWORD dwLen)
{
    INT i, j, k;
    BYTE jTemp, jTemp2;

#define SWAP_3BYTES(p, q) { \
    jTemp = *(PBYTE)(p); \
    *(PBYTE)(p) = *(PBYTE)(q); \
    *(PBYTE)(q) = jTemp; \
    jTemp = *((PBYTE)(p) + 1); \
    *((PBYTE)(p) + 1) = *((PBYTE)(q) + 1); \
    *((PBYTE)(q) + 1) = jTemp; \
    jTemp = *((PBYTE)(p) + 2); \
    *((PBYTE)(p) + 2) = *((PBYTE)(q) + 2); \
    *((PBYTE)(q) + 2) = jTemp; }

    if (pdevOEM->fRequestColor) {

        j = (dwLen / 3) * 3 - 3;
        for (i = 0; i < j; i += 3, j -= 3) {
            SWAP_3BYTES(pBuf + i, pBuf + j);
        }
    }
    else {

        j = dwLen - 1;

        for (i = 0; i < j; i++, j--) {

            jTemp = pBuf[j];
            jTemp2 = 0;

            for (k = 0; k < 8; k++) {
                if ((jTemp >> k) & 1) {
                    jTemp2 |= (1 << (7 - k));
                }
            }

            if (i == j) {
                pBuf[j] = jTemp2;
                continue;
            }
            jTemp = pBuf[i];
            pBuf[i] = jTemp2;
            jTemp2 = 0;

            for (k = 0; k < 8; k++) {
                if ((jTemp >> k) & 1) {
                    jTemp2 |= (1 << (7 - k));
                }
            }
            pBuf[j] = jTemp2;
        }
    }
}


BOOL APIENTRY
OEMFilterGraphics(
    PDEVOBJ pdevobj,
    PBYTE pBuf,
    DWORD dwLen)
{
    PCURRENTSTATUS lpnp;
    int            i, x;
    WORD           wByteLen, wLen, wDataSize;
    BYTE           bRed, bGreen, bBlue;
    BYTE           py, pm, pc, pk, rm;
    BYTE           by, bm, bc, bk;
    BYTE           pCmd[128];
    LONG           iTemp;
    INT iColor, iPlane;
    BYTE *pTemp;
    BOOL bLast = FALSE;
    WORD           wTemp;

#if 0
    // Enable this debug line if you really want it.
    VERBOSE((DLLTEXT("OEMFilerGraphics entry.\n")));
    VERBOSE((DLLTEXT("dwLen = %d.\n"), dwLen));
#endif

    lpnp = (PCURRENTSTATUS)MINIDEV_DATA(pdevobj);

    VERBOSE(("%d lines left in logical page.\n",
        lpnp->wRasterCount));

    // We clip off any raster lines exceeding the
    // harware margins since it will feed paper too
    // much and we cannot back feed the paper
    // for 2nd plane and aftter.  This result as
    // "only cyan (1st plane) image is printed on
    // paper."

    if (lpnp->wRasterCount <= 0) {
        WARNING(("Line beyond page length.\n"));
        // We discard this line silently.
        return TRUE;
    }
    else if (lpnp->wRasterCount <= 1) {
        // The last raster in logical page,
        // Need special handling.
        bLast = TRUE;
    }
    lpnp->wRasterCount--;

    // Do x-flip when requested.
    if (lpnp->bXflip) {
        XFlip(pdevobj, MINIDEV_DATA(pdevobj), pBuf, dwLen);
    }

    // Get resulting buffer length in bytes.
    if ( lpnp->fRequestColor ) {
        wByteLen = (WORD)(dwLen / 3);
        memset(lpnp->pRaster[0], 0, wByteLen);
        memset(lpnp->pRaster[1], 0, wByteLen);
        memset(lpnp->pRaster[2], 0, wByteLen);
        memset(lpnp->pRaster[3], 0, wByteLen);
    }
    else {
        wByteLen = (WORD)dwLen;
    }

    // Check if we have K ribbon
    if (NULL != lpnp->pRasterK) {
        lpnp->pRasterK[0] = 0;
    }

    if ( lpnp->fRequestColor ) {

        lpnp->pRasterC[0] = 0;
        lpnp->pRasterM[0] = 0;
        lpnp->pRasterY[0] = 0;

    for ( i = 0, x = 0; i < (INT)dwLen ; i+=3, x++ ) {

        bRed = pBuf[i];
        bGreen = pBuf[i+1];
        bBlue = pBuf[i+2];

        // RGB -> YMCK

        if (DITHER_OHP == lpnp->iDither) {
            bOHPConvert(pdevobj, bRed, bGreen, bBlue, &py, &pm, &pc, &pk,
            x, lpnp->y);
        }
        else {

        switch ( lpnp->iTextQuality ) {

        case CMDID_TEXTQUALITY_PHOTO:

            bPhotoConvert(pdevobj, bRed, bGreen, bBlue, &py, &pm, &pc, &pk);

            // Processing dither
            bDitherProcess(pdevobj, x, py, pm, pc, pk, &by, &bm, &bc, &bk);

            break;

        case CMDID_TEXTQUALITY_GRAPHIC:

            bBusinessConvert(pdevobj, bRed, bGreen, bBlue, &py, &pm, &pc, &pk);

            // Processing dither
            bDitherProcess(pdevobj, x, py, pm, pc, pk, &by, &bm, &bc, &bk);

            break;

        case CMDID_TEXTQUALITY_CHARACTER:

            bCharacterConvert(pdevobj, bRed, bGreen, bBlue, &py, &pm, &pc, &pk);

            // Processing dither
            bDitherProcess(pdevobj, x, py, pm, pc, pk, &by, &bm, &bc, &bk);

            break;

        //case CMDID_TEXTQUALITY_GRAY:
        //
        //    bMonoConvert(pdevobj, bRed, bGreen, bBlue, &pk);
        //
        //    // Processing dither
        //
        //    rm = M_NewTable[lpnp->y % M_MaxY][x % M_MaxX];
        //
        //    bk = ( pk <= rm ) ? 1 : 0;
        //
        //    break;
        }
        }

        if ((lpnp->iDither == DITHER_DYE) || (lpnp->iDither == DITHER_VD)) {

            if ( bc ) {
                lpnp->pRasterC[0] = 1;
                lpnp->pRasterC[1 + x / 2] |= (BYTE)(bc << ((x % 2) ? 0 : 4));
            }

            if ( bm ) {
                lpnp->pRasterM[0] = 1;
                lpnp->pRasterM[1 + x / 2] |= (BYTE)(bm << ((x % 2) ? 0 : 4));
            }

            if ( by ) {
                lpnp->pRasterY[0] = 1;
                lpnp->pRasterY[1 + x / 2] |= (BYTE)(by << ((x % 2) ? 0 : 4));
            }

            // K make sure we have K ribbon
            if ( bk && (lpnp->iDither == DITHER_VD) ) {
                lpnp->pRasterK[0] = 1;
                lpnp->pRasterK[1 + x / 2] |= (BYTE)(bk << ((x % 2) ? 0 : 4));
            }

        } else {

            if ( bc ) {
                lpnp->pRasterC[0] = 1;
                lpnp->pRasterC[1 + x / 8] |= (BYTE)(0x80 >> (x % 8));
            }

            if ( bm ) {
                lpnp->pRasterM[0] = 1;
                lpnp->pRasterM[1 + x / 8] |= (BYTE)(0x80 >> (x % 8));
            }

            if ( by ) {
                lpnp->pRasterY[0] = 1;
                lpnp->pRasterY[1 + x / 8] |= (BYTE)(0x80 >> (x % 8));
            }

            // K make sure we have K ribbon
            if ( bk && lpnp->pRasterK ) {
                lpnp->pRasterK[0] = 1;
                lpnp->pRasterK[1 + x / 8] |= (BYTE)(0x80 >> (x % 8));
            }
        }
    }

    }
    else {

        // Monochrome.

        pTemp = pBuf;
        for (i = 0; i < wByteLen; i++, pTemp++) {

            if (*pTemp) {
                lpnp->pRasterK[0] = 1;
                break;
            }
        }
    }


    // Loop process for each color start here.

    for ( iPlane = 0; iPlane < 4; iPlane++ ) {

        if (NONE == lpnp->PlaneColor[iPlane]) {

            // No more plane to process.
            break;
        }

        if (!lpnp->fRequestColor) {
            pTemp = pBuf;
        }
        else {
            // Color rasters
            pTemp = lpnp->pRaster[iPlane] + 1;
        }

        // If we do not have ink on this raster line,
        // skip this line, just move cursor to the next one.

        if (0 == lpnp->pRaster[iPlane][0]) {
            lpnp->wRasterOffset[iPlane]++;
            continue;
        }

        // We have ink, output data.

        iColor = lpnp->PlaneColor[iPlane];

        if (0 > iColor) {

            iColor *= -1;
            lpnp->PlaneColor[iPlane] = iColor;

            // Ink selection commands
            switch (iColor) {
            case CYAN:
                 DATASPOOL(pdevobj, lpnp->TempFile[iPlane],
                        "\x1B\x1A\x01\x00\x72", 5);
                break;
            case MAGENTA:
                DATASPOOL(pdevobj, lpnp->TempFile[iPlane],
                        "\x1B\x1A\x02\x00\x72", 5);
                break;
            case YELLOW:
                DATASPOOL(pdevobj, lpnp->TempFile[iPlane],
                        "\x1B\x1A\x03\x00\x72", 5);
                break;
            case BLACK:
                DATASPOOL(pdevobj, lpnp->TempFile[iPlane],
                        "\x1B\x1A\x00\x01\x72", 5);
                break;
            default:
                ERR((DLLTEXT("Invalid color or plane IDs (%d, %d).\n"),
                    lpnp->PlaneColor[iPlane], iPlane));
                return FALSE;
            }
        }

        
        // First we move cursor to the correct raster offset.

        if (0 < lpnp->wRasterOffset[iPlane]) {

#if 0 // Enable if you really  want to be verbose
            VERBOSE((DLLTEXT("Y move +%d (iPlane = %d)\n"),
                lpnp->wRasterOffset[iPlane], iPlane))
#endif

            // Send Y cursor move command

            sprintf( pCmd, "\x1B\x2A\x62%c%c\x59",
                LOBYTE(lpnp->wRasterOffset[iPlane]), 
                HIBYTE(lpnp->wRasterOffset[iPlane]));

            DATASPOOL(pdevobj, lpnp->TempFile[iPlane], pCmd, 6);

            // Reset Y position index.
            lpnp->wRasterOffset[iPlane] = 0;
        }

        // Decide if we want to do compress

        if ((lpnp->iDither == DITHER_DYE) || (lpnp->iDither == DITHER_VD))
            wDataSize = ( wByteLen + 1 ) / 2;  // 2 pixels par byte
        else
            wDataSize = ( wByteLen + 7 ) / 8;  // 8 pixels par byte


        if ((lpnp->iDither != DITHER_DYE) && (lpnp->iDither != DITHER_VD)) {

// ntbug9#24281: large bitmap does not printed on 1200dpi.
// Unnecessary data were sent to printer.
        wTemp = bPlaneSendOrderCMY(lpnp) ? wDataSize : wByteLen;
        if ((iTemp = iCompTIFF(lpnp->pData2, pTemp, wTemp)) > 0
                && iTemp < wTemp) {

            pTemp = lpnp->pData2;
            wDataSize = (WORD)iTemp;

            // Turn on compression mode.
            if (lpnp->iCompMode[iPlane] != COMP_TIFF4) {
                DATASPOOL(pdevobj, lpnp->TempFile[iPlane], "\x1B*b\x02\x00M", 6);
                lpnp->iCompMode[iPlane] = COMP_TIFF4;
            }
        }
        else if (lpnp->iCompMode[iPlane] != COMP_NONE) {

            // Turn off compression mode.
            DATASPOOL(pdevobj, lpnp->TempFile[iPlane], "\x1B*b\x00\x00M", 6);
            lpnp->iCompMode[iPlane] = COMP_NONE;
        }

        } // not DITHER_DYE

        //
        // a) ESC * xx V - one raster output, mo move.
        // b) ESC * xx W - one raster output, move to next raster.
        //
        // Use a) on the last raster to avoid page eject.  For the
        // other rasters use b).

        // Send one raster data
        wLen = (WORD)sprintf( pCmd, "\x1B\x2A\x62%c%c%c",
            LOBYTE(wDataSize), HIBYTE(wDataSize),
            (BYTE)(bLast ? 0x56 : 0x57));
        DATASPOOL(pdevobj, lpnp->TempFile[iPlane], pCmd, wLen);
        DATASPOOL(pdevobj, lpnp->TempFile[iPlane], pTemp, wDataSize);

    } // end of Color loop

    lpnp->y++;

    return dwLen;
}

INT
GetPlaneColor(
    PDEVOBJ pdevobj,
    PCURRENTSTATUS lpnp,
    INT iPlane)
{
    INT iColor;

    iColor = NONE;

    if (!lpnp->fRequestColor) {
        if (0 == iPlane) {
            iColor = BLACK;
        }
        return iColor;
    }

    // Color
// ntbug9#24281: large bitmap does not printed on 1200dpi.
// Do not use black plane (K) on the 1200dpi with color mode.
    if (bPlaneSendOrderCMY(lpnp)) {

        switch (iPlane) {
        case 0:
            iColor = CYAN;
            break;
        case 1:
            iColor = MAGENTA;
            break;
        case 2:
            iColor = YELLOW;
            break;
        }
    }
    else if (bPlaneSendOrderMCY(lpnp)) {

        switch (iPlane) {
        case 0:
            iColor = MAGENTA;
            break;
        case 1:
            iColor = CYAN;
            break;
        case 2:
            iColor = YELLOW;
            break;
        }
    }
    else if (bPlaneSendOrderYMC(lpnp)) {

        switch (iPlane) {
        case 0:
            iColor = YELLOW;
            break;
        case 1:
            iColor = MAGENTA;
            break;
        case 2:
            iColor = CYAN;
            break;
        }
    }
    else if (bPlaneSendOrderCMYK(lpnp)) {

        switch (iPlane) {
        case 0:
            iColor = CYAN;
            break;
        case 1:
            iColor = MAGENTA;
            break;
        case 2:
            iColor = YELLOW;
            break;
        case 3:
            iColor = BLACK;
            break;
        }
    }
    return iColor;
}

VOID
MDP_StartDoc(
    PDEVOBJ pdevobj,
    PCURRENTSTATUS pdevOEM
) {
    DWORD dwResult;
    VERBOSE(("MDP_StartDoc called.\n"));
    WRITESPOOLBUF(pdevobj, "\x1B\x65\x1B\x25\x80\x41", 6, &dwResult);
}

VOID
MDP_EndDoc(
    PDEVOBJ pdevobj,
    PCURRENTSTATUS pdevOEM
) {
    DWORD dwResult;
    WRITESPOOLBUF(pdevobj, "\x1B\x25\x00\x58", 4, &dwResult);
}

BOOL
MDP_CreateTempFile(
    PDEVOBJ pdevobj,
    PCURRENTSTATUS pdevOEM,
    INT iPlane)
{
    TCHAR TempDir[MAX_PATH + 1];
    INT iLength, iUniq;
    HANDLE hFile;

    if (0 == (iLength = GetTempPath(MAX_PATH, TempDir))) {
        ERR((DLLTEXT("GetTempPath failed (%d).\n"),
                GetLastError()))
        goto Error_Return;
    }
    TempDir[iLength] = __TEXT('\0');

    if (0 == (iUniq = GetTempFileName(TempDir,
            TEMP_NAME_PREFIX, 0, pdevOEM->TempName[iPlane]))) {
        ERR((DLLTEXT("GetTempFileName failed (%d).\n"),
                GetLastError()))
        goto Error_Return;
    }

#if DBG
    VERBOSE((DLLTEXT("Cache file unique ID %d.\nName - "), iUniq));
    if (giDebugLevel <= DBG_VERBOSE) {
        OutputDebugString(pdevOEM->TempName[iPlane]);
    }
    VERBOSE(("\n"));
#endif // DBG

    hFile = CreateFile(pdevOEM->TempName[iPlane],
            (GENERIC_READ | GENERIC_WRITE), 0, NULL,
            CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        ERR((DLLTEXT("CreateFile failed.\n")))
        DeleteFile(pdevOEM->TempName[iPlane]);
        goto Error_Return;
    }

    pdevOEM->TempFile[iPlane] = hFile;

    // Normal return
    return TRUE;

Error_Return:
    pdevOEM->TempName[iPlane][0] = __TEXT('\0');
    pdevOEM->TempFile[iPlane] = INVALID_HANDLE_VALUE;
    return FALSE;
} 

BOOL
MDP_StartPage(
    PDEVOBJ pdevobj,
    PCURRENTSTATUS pdevOEM
) {
    LONG iPageLength;
    INT iPaperSizeID;
    INT iLen;
    BYTE pCmd[128];
    INT iColor, iPlane;
    DWORD dwResult;
  
    // Set resolution

    switch (pdevOEM->iCurrentResolution) {

    case DPI1200:

        WRITESPOOLBUF(pdevobj, "\x1B\x2A\x74\x04\x52", 5, &dwResult);
        break;

    case DPI600:

        WRITESPOOLBUF(pdevobj, "\x1B\x2A\x74\x03\x52", 5, &dwResult);
        break;

    case DPI300:

        WRITESPOOLBUF(pdevobj, "\x1B\x2A\x74\x02\x52", 5, &dwResult);
        break;
    }

    // Set Paper Dimentions

    // Make sure top margin is 0 and we are at top.
    WRITESPOOLBUF(pdevobj, "\x1B\x26\x6C\x00\x00\x45", 6, &dwResult);
    WRITESPOOLBUF(pdevobj, "\x1B\x1A\x00\x00\x0C", 5, &dwResult);

    iPaperSizeID
        = pdevOEM->pPaperSize[pdevOEM->iPaperSize].iPaperSizeID;
    iLen = sprintf( pCmd, "\x1B\x26\x6C%c%c\x41",
            LOBYTE(iPaperSizeID), HIBYTE(iPaperSizeID));
    WRITESPOOLBUF(pdevobj, pCmd, iLen, &dwResult);

    iPageLength
        = pdevOEM->pPaperSize[pdevOEM->iPaperSize].iLogicalPageHeight;
    iPageLength /= pdevOEM->iUnitScale;
    iLen = sprintf( pCmd, "\x1B\x26\x6C%c%c\x50",
            LOBYTE(iPageLength), HIBYTE(iPageLength));
    WRITESPOOLBUF(pdevobj, pCmd, iLen, &dwResult);

    // # of raster lines in logical page.
    pdevOEM->wRasterCount = (WORD)iPageLength;

    // Determine dither methods.

    pdevOEM->iDither = DITHER_HIGH_DIV2;

    if (!(pdevOEM->fRequestColor)) {

        pdevOEM->iTextQuality = CMDID_TEXTQUALITY_GRAY;
    }
    else {

        if (!(bTextQuality(pdevobj))){

            ERR((DLLTEXT("bTextQuality failed\n")));
            return FALSE;
        }
    }

    // Initialize dither tables

    if (!(bInitialDither(pdevobj))){

        ERR((DLLTEXT("bInitialDither failed\n")));
        return FALSE;
    }

    // Pre-processing of color conversion. needed only photo.

    if (pdevOEM->iTextQuality == CMDID_TEXTQUALITY_PHOTO ) {

        if (!(bInitialColorConvert(pdevobj)) ){
            ERR((DLLTEXT("bInitialColorConvert failed\n")));
            return FALSE;
        }
    }

    // Start Raster Data Transfer
    WRITESPOOLBUF(pdevobj, "\x1B\x2A\x72\x00\x41", 5, &dwResult);

    if ( pdevOEM->fRequestColor ) {

        // Open temporary files.  One file per one plain.

        for (iPlane = 0; iPlane < 4; iPlane++) {

#if !CACHE_FIRST_PLANE
            // We do not spool 1st plane
            if (0 == iPlane) {
                pdevOEM->TempFile[iPlane] = INVALID_HANDLE_VALUE;
                continue;
            }
#endif // !CACHE_FIRST_PLANE

            if (TRUE != MDP_CreateTempFile(pdevobj,
                    MINIDEV_DATA(pdevobj), iPlane))
                return FALSE;
        }
    }
    else {

        for (iPlane = 0; iPlane < 4; iPlane++) {
            pdevOEM->TempFile[iPlane] = INVALID_HANDLE_VALUE;
        }
    }

    // Change printer emulation state.
    pdevOEM->iEmulState = EMUL_DATA_TRANSFER;
    pdevOEM->iCompMode[0] = pdevOEM->iCompMode[1] = pdevOEM->iCompMode[2]
            = pdevOEM->iCompMode[3] = COMP_NONE;

    // Misc setup.
    pdevOEM->y = 0;

    if (!pdevOEM->fRequestColor) {
        WRITESPOOLBUF(pdevobj, "\x1B\x1A\x00\x01\x72", 5, &dwResult);
    }

    pdevOEM->pRasterC = NULL;
    pdevOEM->pRasterM = NULL;
    pdevOEM->pRasterY = NULL;
    pdevOEM->pRasterK = NULL;

    for (iPlane = 0; iPlane < 4; iPlane++) {

        pdevOEM->wRasterOffset[iPlane] = 0;

        // Set color ID for each plane.
        // Negative value = Has no ink so do not have to ouput
        // Positive value = Has ink on the plane.  Have to output.
        //

        iColor = GetPlaneColor(pdevobj, pdevOEM, iPlane);
        pdevOEM->PlaneColor[iPlane] = (-iColor);

        switch (iColor) {
        case CYAN:
            pdevOEM->pRasterC = pdevOEM->pRaster[iPlane];
            break;
        case MAGENTA:
            pdevOEM->pRasterM = pdevOEM->pRaster[iPlane];
            break;
        case YELLOW:
            pdevOEM->pRasterY = pdevOEM->pRaster[iPlane];
            break;
        case BLACK:
            pdevOEM->pRasterK = pdevOEM->pRaster[iPlane];
            break;
        }
    }
    return TRUE;
}

BOOL
MDP_EndPage(
    PDEVOBJ pdevobj,
    PCURRENTSTATUS pdevOEM
) {
    INT i;
    DWORD dwResult;

    // Spooled data transfer
    if ( pdevOEM->fRequestColor )
        SPOOLOUT(pdevobj);

    // End Raster Transfer, FF.
    WRITESPOOLBUF(pdevobj, "\x1B\x2A\x72\x43\x0C", 5, &dwResult);

    // Change printer emulation state.
    pdevOEM->iEmulState = EMUL_RGL;

    // Close cache files.

    for (i = 0; i < 4; i++) {

        if (INVALID_HANDLE_VALUE != pdevOEM->TempFile[i]) {

            if (0 == CloseHandle(pdevOEM->TempFile[i])) {
                ERR((DLLTEXT("CloseHandle error %d\n"),
                        GetLastError()));
            }
            pdevOEM->TempFile[i] = INVALID_HANDLE_VALUE;

            if (0 == DeleteFile(pdevOEM->TempName[i])) {
                ERR((DLLTEXT("DeleteName error %d\n"),
                        GetLastError()));
                return FALSE;
            }
            pdevOEM->TempName[i][0] = __TEXT('\0');
        }
    }
    return TRUE;
}

INT APIENTRY
OEMCommandCallback(
    PDEVOBJ pdevobj,
    DWORD dwCmdCbID,
    DWORD dwCount,
    PDWORD pdwParams)
{

    PCURRENTSTATUS lpnp;
    WORD   len;
//    BYTE   ch[100];
    WORD   wPageLength;
    WORD   wVerticalOffset;
    WORD   wRealOffset;
    INT iRet;
    DWORD dwResult;

    VERBOSE((DLLTEXT("OEMCommandCallback(%d) entry.\n"),dwCmdCbID));

    lpnp = (PCURRENTSTATUS)MINIDEV_DATA(pdevobj);

    iRet = 0;

    switch ( dwCmdCbID ){

    case CMDID_PAPERSOURCE_CSF:
    // \x1B&l\x03\x00H
    lpnp->iPaperSource = CMDID_PAPERSOURCE_CSF;
    break;

    case CMDID_PAPERSOURCE_MANUAL:
    // \x1B&l\x02\x00H
    lpnp->iPaperSource = CMDID_PAPERSOURCE_MANUAL;
    break;

    case CMDID_PAPERQUALITY_PPC_NORMAL:
    case CMDID_PAPERQUALITY_PPC_FINE:
    case CMDID_PAPERQUALITY_OHP_NORMAL:
    case CMDID_PAPERQUALITY_OHP_FINE:
    case CMDID_PAPERQUALITY_OHP_EXCL_NORMAL:
    case CMDID_PAPERQUALITY_OHP_EXCL_FINE:
    case CMDID_PAPERQUALITY_IRON_PPC:
    case CMDID_PAPERQUALITY_IRON_OHP:
    case CMDID_PAPERQUALITY_THICK:
    case CMDID_PAPERQUALITY_POSTCARD:
    case CMDID_PAPERQUALITY_HIGRADE:
    case CMDID_PAPERQUALITY_BACKPRINTFILM:
    case CMDID_PAPERQUALITY_LABECA_SHEET:
    case CMDID_PAPERQUALITY_CD_MASTER:
    case CMDID_PAPERQUALITY_DYE_SUB_PAPER:
    case CMDID_PAPERQUALITY_DYE_SUB_LABEL:
    case CMDID_PAPERQUALITY_GLOSSY_PAPER:
    case CMDID_PAPERQUALITY_VD_PHOTO_FILM:
    case CMDID_PAPERQUALITY_VD_PHOTO_CARD:
    {

        switch ( dwCmdCbID ){

        case CMDID_PAPERQUALITY_PPC_NORMAL:
        WRITESPOOLBUF(pdevobj, "\x1B&l\x00\x00M", 6, &dwResult);
        lpnp->iPaperQuality = CMDID_PAPERQUALITY_PPC_NORMAL;
        break;

        case CMDID_PAPERQUALITY_PPC_FINE: // only mono color
        if( lpnp->fRequestColor ){
            // If user selects color, then we selects PPC NORMAL
            // because, PPC FINE is not accepted color
            WRITESPOOLBUF(pdevobj, "\x1B&l\x00\x00M", 6, &dwResult);
            lpnp->iPaperQuality = CMDID_PAPERQUALITY_PPC_NORMAL;
        }else{
            WRITESPOOLBUF(pdevobj, "\x1B&l\x00\x02M", 6, &dwResult);
            lpnp->iPaperQuality = CMDID_PAPERQUALITY_PPC_FINE;
        }
        break;

        case CMDID_PAPERQUALITY_OHP_NORMAL:
        WRITESPOOLBUF(pdevobj, "\x1B&l\x08\x01M", 6, &dwResult);
        lpnp->iPaperQuality = CMDID_PAPERQUALITY_OHP_NORMAL;
        break;

        case CMDID_PAPERQUALITY_OHP_FINE:
        WRITESPOOLBUF(pdevobj, "\x1B&l\x08\x02M", 6, &dwResult);
        lpnp->iPaperQuality = CMDID_PAPERQUALITY_OHP_FINE;
        break;

        case CMDID_PAPERQUALITY_OHP_EXCL_NORMAL:
        WRITESPOOLBUF(pdevobj, "\x1B&l\x01\x01M", 6, &dwResult);
        lpnp->iPaperQuality = CMDID_PAPERQUALITY_OHP_EXCL_NORMAL;
        break;

        case CMDID_PAPERQUALITY_OHP_EXCL_FINE:
        WRITESPOOLBUF(pdevobj, "\x1B&l\x01\x02M", 6, &dwResult);
        lpnp->iPaperQuality = CMDID_PAPERQUALITY_OHP_EXCL_FINE;
        break;

        case CMDID_PAPERQUALITY_IRON_PPC:
        WRITESPOOLBUF(pdevobj, "\x1B&l\x02\x02M", 6, &dwResult);
        lpnp->iPaperQuality = CMDID_PAPERQUALITY_IRON_PPC;
        break;

        case CMDID_PAPERQUALITY_IRON_OHP:
        WRITESPOOLBUF(pdevobj, "\x1B&l\x02\x01M", 6, &dwResult);
        lpnp->iPaperQuality = CMDID_PAPERQUALITY_IRON_OHP;
        break;

        case CMDID_PAPERQUALITY_THICK:
        WRITESPOOLBUF(pdevobj, "\x1B&l\x05\x00M", 6, &dwResult);
        lpnp->iPaperQuality = CMDID_PAPERQUALITY_THICK;
        break;

        case CMDID_PAPERQUALITY_POSTCARD:
        WRITESPOOLBUF(pdevobj, "\x1B&l\x06\x00M", 6, &dwResult);
        lpnp->iPaperQuality = CMDID_PAPERQUALITY_POSTCARD;
        break;

        case CMDID_PAPERQUALITY_HIGRADE:
        WRITESPOOLBUF(pdevobj, "\x1B&l\x07\x00M", 6, &dwResult);
        lpnp->iPaperQuality = CMDID_PAPERQUALITY_HIGRADE;
        break;

        case CMDID_PAPERQUALITY_BACKPRINTFILM:
        WRITESPOOLBUF(pdevobj, "\x1B&l\x09\x00M", 6, &dwResult);
        lpnp->iPaperQuality = CMDID_PAPERQUALITY_BACKPRINTFILM;
        break;

        case CMDID_PAPERQUALITY_LABECA_SHEET:
        WRITESPOOLBUF(pdevobj, "\x1B&l\x03\x00M", 6, &dwResult);
        lpnp->iPaperQuality = CMDID_PAPERQUALITY_LABECA_SHEET;
        break;

        case CMDID_PAPERQUALITY_CD_MASTER:
        WRITESPOOLBUF(pdevobj, "\x1B&l\x04\x01M", 6, &dwResult);
        lpnp->iPaperQuality = CMDID_PAPERQUALITY_CD_MASTER;
        break;

        case CMDID_PAPERQUALITY_DYE_SUB_PAPER:
        WRITESPOOLBUF(pdevobj, "\x1B&l\x0A\x00M", 6, &dwResult);
        lpnp->iPaperQuality = CMDID_PAPERQUALITY_DYE_SUB_PAPER;
        break;

        case CMDID_PAPERQUALITY_DYE_SUB_LABEL:
        WRITESPOOLBUF(pdevobj, "\x1B&l\x0C\x00M", 6, &dwResult);
        lpnp->iPaperQuality = CMDID_PAPERQUALITY_DYE_SUB_LABEL;
        break;

        case CMDID_PAPERQUALITY_GLOSSY_PAPER:
        WRITESPOOLBUF(pdevobj, "\x1B&l\x0F\x00M", 6, &dwResult);
        lpnp->iPaperQuality = CMDID_PAPERQUALITY_GLOSSY_PAPER;
        break;

        case CMDID_PAPERQUALITY_VD_PHOTO_FILM:
        WRITESPOOLBUF(pdevobj, "\x1B&l\x10\x00M", 6, &dwResult);
        lpnp->iPaperQuality = CMDID_PAPERQUALITY_VD_PHOTO_FILM;
        break;

        case CMDID_PAPERQUALITY_VD_PHOTO_CARD:
        WRITESPOOLBUF(pdevobj, "\x1B&l\x11\x00M", 6, &dwResult);
        lpnp->iPaperQuality = CMDID_PAPERQUALITY_VD_PHOTO_CARD;
        break;

        }

        if (lpnp->iPaperSource == CMDID_PAPERSOURCE_MANUAL){

            WRITESPOOLBUF(pdevobj, "\x1B&l\x02\x00H", 6, &dwResult);

        } else {
        // Check if this media ( PAPERQUALITY ) and this
        // paper size is printable on CSF.

            if (IsAsfOkMedia(pdevobj)){
                WRITESPOOLBUF(pdevobj, "\x1B&l\x03\x00H", 6, &dwResult);
            }else{
                WRITESPOOLBUF(pdevobj, "\x1B&l\x02\x00H", 6, &dwResult);
            }
        }

        if( lpnp->fRequestColor ){
        // YMCK Page Plane
            WRITESPOOLBUF(pdevobj, "\x1B\x2A\x72\x04\x55", 5, &dwResult);
        }else{
        // Black Raster Plane
            WRITESPOOLBUF( pdevobj, "\x1B\x2A\x72\x00\x55", 5, &dwResult);
        }

    }
    break;

    case CMDID_TEXTQUALITY_PHOTO:
    case CMDID_TEXTQUALITY_GRAPHIC:
    case CMDID_TEXTQUALITY_CHARACTER:

        lpnp->iTextQuality =  dwCmdCbID;
        break;

    // ####

    case CMDID_MIRROR_ON:
        lpnp->bXflip = TRUE;
        break;

    case CMDID_MIRROR_OFF:

        lpnp->bXflip = FALSE;
        break;

    case CMDID_CURSOR_RELATIVE:

        // this printer's linespacing cmd is influenced with current resolution.

        wVerticalOffset = (WORD)(pdwParams[0]);
        wVerticalOffset /= (WORD)lpnp->iUnitScale;

        lpnp->wRasterOffset[0] += wVerticalOffset;
        lpnp->wRasterOffset[1] += wVerticalOffset;
        lpnp->wRasterOffset[2] += wVerticalOffset;
        lpnp->wRasterOffset[3] += wVerticalOffset;

        lpnp->wRasterCount -= wVerticalOffset;

#if 0 // Enable if you really want to be verbose
        VERBOSE((DLLTEXT("Y move +%d\n"), wVerticalOffset));
#endif

        // Return offset change in device's units
        iRet = wVerticalOffset;
        break;

    case CMDID_RESOLUTION_1200_MONO:

        lpnp->iCurrentResolution = DPI1200;
        lpnp->iUnitScale = 2;
        break;

    case CMDID_RESOLUTION_600:

        lpnp->iCurrentResolution = DPI600;
        lpnp->iUnitScale = 2;
        break;

    case CMDID_RESOLUTION_300:

        lpnp->iCurrentResolution = DPI300;
        lpnp->iUnitScale = 4;
        break;

    case CMDID_PSIZE_LETTER:

        lpnp->iPaperSize = PAPER_SIZE_LETTER;
        break;

    case CMDID_PSIZE_LEGAL:

        lpnp->iPaperSize = PAPER_SIZE_LEGAL;
        break;

    case CMDID_PSIZE_EXECTIVE:

        lpnp->iPaperSize = PAPER_SIZE_EXECTIVE;
        break;

    case CMDID_PSIZE_A4:

        lpnp->iPaperSize = PAPER_SIZE_A4;
        break;

    case CMDID_PSIZE_B5:

        lpnp->iPaperSize = PAPER_SIZE_B5;
        break;

    case CMDID_PSIZE_POSTCARD:

        lpnp->iPaperSize = PAPER_SIZE_POSTCARD;
        break;

    case CMDID_PSIZE_POSTCARD_DOUBLE:

        lpnp->iPaperSize = PAPER_SIZE_DOUBLE_POSTCARD;
        break;

    case CMDID_PSIZE_PHOTO_COLOR_LABEL:

        lpnp->iPaperSize = PAPER_PHOTO_COLOR_LABEL;
        break;

    case CMDID_PSIZE_GLOSSY_LABEL:

        lpnp->iPaperSize = PAPER_GLOSSY_LABEL;
        break;

    case CMDID_PSIZE_CD_MASTER:

        lpnp->iPaperSize = PAPER_CD_MASTER;
        break;

    case CMDID_PSIZE_VD_PHOTO_POSTCARD:

        lpnp->iPaperSize = PAPER_VD_PHOTO_POSTCARD;
        break;

    case CMDID_COLORMODE_COLOR:
    case CMDID_COLORMODE_MONO:
        lpnp->fRequestColor = (dwCmdCbID == CMDID_COLORMODE_COLOR);
        break;

    case CMDID_BEGINDOC_MD5000: // Postcard printable area is expantioned on MD-5000

        lpnp->pPaperSize[PAPER_SIZE_POSTCARD].iLogicalPageHeight
            = 3082 * 2;
        lpnp->pPaperSize[PAPER_SIZE_DOUBLE_POSTCARD].iLogicalPageHeight
            = 3082 * 2;

    case CMDID_BEGINDOC_MD2000:
    case CMDID_BEGINDOC_MD2010:

        lpnp->iModel = dwCmdCbID;
        MDP_StartDoc(pdevobj, MINIDEV_DATA(pdevobj));
        break;

    case CMDID_ENDDOC:

        MDP_EndDoc(pdevobj, MINIDEV_DATA(pdevobj));
        break;

    case CMDID_BEGINPAGE:

        MDP_StartPage(pdevobj, MINIDEV_DATA(pdevobj));
        break;

    case CMDID_ENDPAGE:

        MDP_EndPage(pdevobj, MINIDEV_DATA(pdevobj));
        break;

    default:

        ERR((DLLTEXT("Unknown CallbackID = %d\n"), dwCmdCbID));
    }

    return iRet;
}

/*************************** Function Header *******************************
 *  IsAsfOkMedia
 *
 *  Check if the media and the paper size is printable on Cut Sheet Feeder.
 *
 * HISTORY:
 *  24 Sep 1996    -by-    Sueya Sugihara    [sueyas]
 *     Created.
 *
 ***************************************************************************/
BOOL IsAsfOkMedia(
PDEVOBJ     pdevobj)
{

    PCURRENTSTATUS lpnp;

    lpnp = (PCURRENTSTATUS)(MINIDEV_DATA(pdevobj));

    // ASF enabled only with ASF-allowed paper size AND
    // ASF-allowed media type

    if (gMediaType[lpnp->iPaperQuality - CMDID_PAPERQUALITY_FIRST].bAsfOk
            && lpnp->pPaperSize[lpnp->iPaperSize].bAsfOk) {
        return TRUE;
    }

    return FALSE;
}
/*************************** Function Header *******************************
 *  bTextQuality
 *
 *  Select dither table according to the paper quality(Media Type) and
 *  resolution and the requested halftoning type.
 *  If appropriate halftoning type is not selected, then this function
 *  selects halftoning type.
 *
 * HISTORY:
 *  24 Sep 1996    -by-    Sueya Sugihara    [sueyas]
 *     Created.
 *
 ***************************************************************************/
BOOL bTextQuality(
PDEVOBJ     pdevobj)
{

    PCURRENTSTATUS lpnp;

    lpnp = (PCURRENTSTATUS)(MINIDEV_DATA(pdevobj));

    switch ( lpnp->iPaperQuality ){

    case CMDID_PAPERQUALITY_PPC_NORMAL:
    case CMDID_PAPERQUALITY_OHP_NORMAL:
    case CMDID_PAPERQUALITY_OHP_EXCL_NORMAL:
    case CMDID_PAPERQUALITY_OHP_EXCL_FINE:
    case CMDID_PAPERQUALITY_IRON_PPC:
    case CMDID_PAPERQUALITY_IRON_OHP:
    case CMDID_PAPERQUALITY_THICK:
    case CMDID_PAPERQUALITY_POSTCARD:
    case CMDID_PAPERQUALITY_HIGRADE:
    case CMDID_PAPERQUALITY_BACKPRINTFILM:
    case CMDID_PAPERQUALITY_LABECA_SHEET:
    case CMDID_PAPERQUALITY_CD_MASTER:
    case CMDID_PAPERQUALITY_GLOSSY_PAPER:
    if ( lpnp->iTextQuality == CMDID_TEXTQUALITY_PHOTO ){
        lpnp->iDither = DITHER_HIGH; // 145LPI
    }else if ( lpnp->iTextQuality == CMDID_TEXTQUALITY_GRAPHIC ){
        lpnp->iDither = DITHER_LOW;  // 95LPI
    }else{
        lpnp->iDither = DITHER_HIGH_DIV2;  // 145/2LPI
    }
    break;

    case CMDID_PAPERQUALITY_DYE_SUB_PAPER:
    case CMDID_PAPERQUALITY_DYE_SUB_LABEL:
        lpnp->iDither = DITHER_DYE;  // Dye-sub Media dither
    break;

    case CMDID_PAPERQUALITY_VD_PHOTO_FILM:
    case CMDID_PAPERQUALITY_VD_PHOTO_CARD:
        lpnp->iDither = DITHER_VD;  // Dye-sub Media dither
    break;

    default:
    return FALSE;
    }

    return TRUE;
}

BOOL
bDataSpool(
    PDEVOBJ pdevobj,
    HANDLE hFile,
    LPSTR lpBuf,
    DWORD dwLen)
{
    DWORD dwTemp, dwTemp2;
    BYTE *pTemp;
    DWORD dwResult;

    if (hFile != INVALID_HANDLE_VALUE) {

        pTemp = lpBuf;
        dwTemp = dwLen;
        while (dwTemp > 0) {

            if (0 == WriteFile(hFile, pTemp, dwTemp, &dwTemp2, NULL)) {

                ERR((DLLTEXT("Writing cache faild, WriteFile() error %d.\n"),
                    GetLastError()));
                return FALSE;
            }
            pTemp += dwTemp2;
            dwTemp -= dwTemp2;
        }
       
    }
    else {
        WRITESPOOLBUF(pdevobj, lpBuf, dwLen, &dwResult);
    }
    return TRUE;
}

BOOL
bSpoolOut(
    PDEVOBJ pdevobj)
{
    PCURRENTSTATUS lpnp;
    DWORD dwResult;

    INT iPlane, iColor, iFile;
    DWORD dwSize, dwTemp, dwTemp2;
    HANDLE hFile;

#define    BUF_SIZE 1024
    BYTE  Buf[BUF_SIZE];

    lpnp = (PCURRENTSTATUS)(MINIDEV_DATA(pdevobj));

    VERBOSE((DLLTEXT("bSpoolOut entry.\n")));

    for (iPlane = 0; iPlane < 4; iPlane++) {

    // CMDID_PAPERQUALITY_OHP_EXCL_NORMAL : MCY
    // CMDID_PAPERQUALITY_OHP_EXCL_FINE   : MCY
    // CMDID_PAPERQUALITY_IRON_OHP        : YMC
    // Except above                       : CMYK

        VERBOSE((DLLTEXT("About to send plane %d.\n"), iPlane));

        // Check if we have ink in this plane.
        iColor = lpnp->PlaneColor[iPlane];

        // Exit loop if no remaining plane to print
        if (iColor == NONE) {
            VERBOSE((DLLTEXT("No remaining plane left.\n")));
            break;
        }
        else if (0 > iColor) {
            VERBOSE((DLLTEXT("No ink on this plane.\n")));
            continue;
        }

        // If it is 2nd plane and after, send Back Feed.
        if (0 < iPlane) {
            WRITESPOOLBUF(pdevobj, "\x1B\x1A\x00\x00\x0C", 5, &dwResult);
        }

        VERBOSE((DLLTEXT("Cached data Plane=%d Color=%d\n"),
                iPlane, iColor));

        // Get file handle.
        hFile = lpnp->TempFile[iPlane];
        if (INVALID_HANDLE_VALUE == hFile) {

#if CACHE_FIRST_PLANE
            ERR((DLLTEXT("file handle NULL in SendCachedData.\n")));
            return FALSE;
#endif // CACHE_FIRST_PLANE

            // Allow fp to be NULL for the case where we
            // immediately send data to printer.
            continue;
        }

        dwSize = SetFilePointer(hFile, 0L, NULL, FILE_CURRENT);
        if (0xffffffff == dwSize) {
            ERR((DLLTEXT("SetFilePointer failed %d\n"),
                GetLastError()));
            return FALSE;
        }

        // Output cached data.

        if (0L != SetFilePointer(hFile, 0L, NULL, FILE_BEGIN)) {

            ERR((DLLTEXT("SetFilePointer failed %d\n"),
                GetLastError()));
            return FALSE;
        }

        VERBOSE((DLLTEXT("Size of data to be read and sent = %ld\n"), dwSize));

        for ( ; dwSize > 0; dwSize -= dwTemp2) {

            dwTemp = ((BUF_SIZE < dwSize) ? BUF_SIZE : dwSize);

            if (0 == ReadFile(hFile, Buf, dwTemp, &dwTemp2, NULL)) {
                ERR((DLLTEXT("ReadFile error in SendCachedData.\n")));
                return FALSE;
            }

            if (dwTemp2 > 0) {
                WRITESPOOLBUF(pdevobj, Buf, dwTemp2, &dwResult);
            }
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\glyphset\mkgly\mkgly.c ===
/*++

Copyright (c) 1990-1996  Microsoft Corporation


Module Name:

    mkgly.c


Abstract:

    Construct FD_GLYPHSET structure in memory and dump it as binary
    data so that a printer driver can include it in its resource.
    The input data format is as following:

    <codepage>
    <multibyte code>\t<run length>
    <multibyte code>\t<run length>
    ...

    "codepage" is the codepage id to be used in multibyte to Unicode
    conversion.  "Multibyte code" and "run length" pairs describes
    which codepoints of multibyte codes are available on the device.

    mkgly will warn if there are multiple multibyte codepoints which
    are mapped to single Unicode codepoint.  The user is expected
    to fix this in the source, then re-run mkgly.

    Follogins are command line options recogized by mkgly:

    -e  Allow EUDC codepoints.  Default is not allow.
    -t  Output mapping table in text format also.
    -v  Verbose.

Author:

    08-Apr-1995 Sat 00:00:00 created -by- Takashi Matsuzawa (takashim)
    03-Mar-1996 Sat 00:00:00 updated -by- Takashi Matsuzawa (takashim)

Environment:

    GDI device drivers (printer)


Notes:


Revision History:



--*/

#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>

#include <windows.h>
#include <winddi.h>
#include <wingdi.h>

#define MIN_WCHAR_VALUE 0x0000
#define MAX_WCHAR_VALUE 0xfffd
#define INVALID_WCHAR_VALUE 0xffff
#define IS_COMMENT(c) \
    ((c) == ';' || (c) == '#' || (c) == '%' || (c) == '\n')
#define IS_EUDC_W(wc) \
    ((wc) >= 0xe000 && (wc) <= 0xf8ff)

WORD awMultiByteArray[0x10000];
BOOL bEudc, bTable, bGTTHandleBase;
INT iVerbose;

FD_GLYPHSET
*pvBuildGlyphSet(
    WORD *pwArray )

/*++

Routine Description:

    Build FD_GLYPHSET data on memory.

Arguments:


Return Value:

    None.

Author:


    08-Apr-1995 Sat 00:00:00 created -by- Takashi Matsuzawa (takashim)


Revision History:


--*/

{
    DWORD        cGlyphs;           // count of glyph handles.
    DWORD        cRuns;             // count of runs within FD_GLYPHSET.
    DWORD        cbTotalMem;        // count of bytes needed for FD_GLYPHSET.
    HGLYPH      *phg;	            // pointer to HGLYPH's.
    FD_GLYPHSET *pGlyphSet;
    WCRUN       *pWCRun;
    BOOL bFirst;
    WCHAR wcChar, wcPrev, wcGTTHandle;
    DWORD cEudc;
    DWORD        cRunsGlyphs = 0;

    cRuns = 0;
    cGlyphs = 0;
    cEudc = 0;

    bFirst = TRUE;

    for ( wcChar = MIN_WCHAR_VALUE; wcChar <= MAX_WCHAR_VALUE; wcChar++)
    {
        if (pwArray[wcChar] == INVALID_WCHAR_VALUE)
            continue;

        // GDI can't handle the value which cRunsGlyphs over 256. sueyas

        if (bFirst || (wcChar - wcPrev) > 1 || cRunsGlyphs++ > 255)
        {
            if (bFirst)
                bFirst = FALSE;

            cRuns++;
            cRunsGlyphs = 1;
        }

        if (IS_EUDC_W(wcChar))
            cEudc++;

        cGlyphs++;
        wcPrev = wcChar;
    }

    if (iVerbose > 1) {
        fprintf( stderr, "cGlyphs = %d, cRuns = %d\n", cGlyphs, cRuns );
    }

    // Allocate memory to build the FD_GLYPHSET structure in.  this
    // include space for the FD_GLYPHSET structure itself, as well
    // as space for all the glyph handles.
    // DWORD bound it.

    cbTotalMem = sizeof(FD_GLYPHSET) - sizeof(WCRUN)
        + cRuns * sizeof(WCRUN) + cGlyphs * sizeof(HGLYPH);
    cbTotalMem = (cbTotalMem + 3) & ~3;

    if ((phg = (PVOID)GlobalAlloc( 0, cbTotalMem )) == NULL) {

        fprintf( stderr, "Error alloating memory\n" );
        return NULL;
    }

    // fill in the FD_GLYPHSET structure.

    pGlyphSet = (FD_GLYPHSET *)phg;
    pGlyphSet->cjThis
        = sizeof(FD_GLYPHSET) - sizeof(WCRUN)
        + cRuns * sizeof(WCRUN);  // size excluding HGLYPH array.
    pGlyphSet->flAccel = 0;		// no accelerators for us.
    pGlyphSet->cGlyphsSupported = cGlyphs;
    pGlyphSet->cRuns = cRuns;

    // Now set the phg pointer to the first WCRUN structure.

    (PBYTE)phg += (sizeof(FD_GLYPHSET) - sizeof(WCRUN));
    pWCRun = (WCRUN *)phg;
    (PBYTE)phg += sizeof(WCRUN) * cRuns;

    if (bTable || iVerbose > 0)
    {
        fprintf(stdout, "; Number of glyphs = %ld\n", cGlyphs );
        fprintf(stdout, "; Number of eudc = %ld\n", cEudc);
    }

    bFirst = TRUE;
    cRunsGlyphs = 0;

    for ( wcGTTHandle = 1,wcChar = MIN_WCHAR_VALUE;
          wcChar <= MAX_WCHAR_VALUE;
          wcChar++)
    {
        if (pwArray[wcChar] == INVALID_WCHAR_VALUE)
            continue;

        // GDI can't handle the value which cRunsGlyphs over 256. sueyas

        if (bFirst || (wcChar - wcPrev) > 1 || cRunsGlyphs++ > 255)
        {
            if (bFirst)
                bFirst = FALSE;
            else
                pWCRun++;

            pWCRun->wcLow = wcChar;
            pWCRun->cGlyphs = 0;
            pWCRun->phg = phg;
            cRunsGlyphs = 1;
        }

        // Glyph handle needs to be stored anyway.

        *phg++ = (HGLYPH)wcGTTHandle++;
        pWCRun->cGlyphs++;
        wcPrev = wcChar;

        if (bTable)
        {
            fprintf(stdout, "%x\t%x\n", wcChar, pwArray[wcChar]);
        }
    }

    // Debug output

    if (iVerbose > 1) {

        INT i, j;

        fprintf( stderr, "FD_GLYPHSET\n" );
        fprintf( stderr, "->cjThis  = %d (%d + %d)\n", pGlyphSet->cjThis,
            sizeof (FD_GLYPHSET) - sizeof (WCRUN),
            pGlyphSet->cjThis - sizeof (FD_GLYPHSET) + sizeof (WCRUN) );
        fprintf( stderr, "->fdAccel = %08lx\n", pGlyphSet->flAccel );
        fprintf( stderr, "->cGlyphsSupported = %d\n",
            pGlyphSet->cGlyphsSupported );
        fprintf( stderr, "->cRuns = %d\n", pGlyphSet->cRuns );

        if (iVerbose > 2)
        {
            for ( i = 0; i < (INT)pGlyphSet->cRuns; i++ ) {
                fprintf( stderr, "awcrun[%d]->wcLow = %04x\n",
                    i, pGlyphSet->awcrun[i].wcLow );
                fprintf( stderr, "awcrun[%d]->cGlyphs = %d\n",
                    i, pGlyphSet->awcrun[i].cGlyphs );
                fprintf( stderr, "awcrun[%d]->phg = %lx\n",
                    i, pGlyphSet->awcrun[i].phg );
                if (iVerbose > 3)
                {
                    for ( j = 0; j < pGlyphSet->awcrun[i].cGlyphs; j++ )
                        fprintf( stderr, "%02x,",
                            pGlyphSet->awcrun[i].phg[j] );
                    fprintf( stderr, "\n" );
                } /* iVerbose > 3 */
            }
        } /* iVerbose > 2 */
    }

    return pGlyphSet;
}

BOOL
bWriteGlyphSet(
    FD_GLYPHSET *pGlyphSet,
    CHAR *pFileName )

/*++

Routine Description:

    Dump FD_GLYPHSET data into specified file.

Arguments:


Return Value:

    None.

Author:


    08-Apr-1995 Sat 00:00:00 created -by- Takashi Matsuzawa (takashim)


Revision History:


--*/

{
    HANDLE hFile;

    ULONG   iIndex;
    WCRUN  *pWcRun;
    HGLYPH *phg;
    DWORD dwTmp;
   
    if ((hFile = CreateFileA(
        pFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, 0))
            == INVALID_HANDLE_VALUE) {

        return FALSE;
    }

    // FD_GLYPHSET structure itself + WCRUN array

    if (!WriteFile( hFile, pGlyphSet, pGlyphSet->cjThis,
        &dwTmp, NULL )) {

        return FALSE;
    }

    // HGLYPH array

    if (!WriteFile( hFile, pGlyphSet->awcrun[0].phg,
            pGlyphSet->cGlyphsSupported * sizeof (HGLYPH),
        &dwTmp, NULL )) {

        return FALSE;
    }

    if (!CloseHandle( hFile )) {
        return FALSE;
    }

    return TRUE;
}

VOID
Usage()
{
    fprintf ( stderr, "\nUsage : mkgly [-etvv] outfile\n" );
    exit (EXIT_FAILURE);
}

BOOL
GetLine(
    BYTE *pjBuffer,
    INT cjSize)
{
    do
    {
        if(fgets(pjBuffer, cjSize, stdin) == NULL)
            return FALSE;
    } while (IS_COMMENT(*pjBuffer));

    return TRUE;
}

void __cdecl
main(
    int argc,
    char *argv[] )

/*++

Routine Description:

    Main routine for mkgly.exe

Arguments:

    Output filename.  Input data is read from standard input.

Return Value:

    None.

Author:


    08-Apr-1995 Sat 00:00:00 created -by- Takashi Matsuzawa (takashim)


Revision History:


--*/

{
    FD_GLYPHSET *pGlyphSet;
    CHAR *pFileName;
    INT iArg;
    CHAR *pStr;
    WORD wCodePage;
    WORD wMbChar, wMbRun, iMbLen, wMbChar2;
    WCHAR wcSysChar;
    BYTE ajMbChar[2];
    BYTE ajBuffer[256];

    bEudc = FALSE;
    bTable = FALSE;
    iVerbose = 0;
    pFileName = NULL;
    bGTTHandleBase = FALSE;

    while (--argc)
    {
        pStr = *(++argv);

        if (*pStr == '-')
        {
            for ( pStr++; *pStr; pStr++)
            {
                if (*pStr == 'e')
                    bEudc = TRUE;
                else if (*pStr == 't')
                    bTable = TRUE;
                else if (*pStr == 'v')
                    iVerbose++;
                else if (*pStr == 'g')
                    bGTTHandleBase = TRUE;
                else
                    Usage();
            }
         }
         else
         {
             pFileName = pStr;
             break;
         }
    }

    if (pFileName == NULL)
    {
        Usage();
    }

    // get the codepage id used for conversion

    if (!GetLine(ajBuffer, sizeof(ajBuffer)))
    {
        fprintf(stderr, "mkgly: unexpected end of file\n");
        exit(EXIT_FAILURE);
    }
    sscanf(ajBuffer, "%hd", &wCodePage );

    if (iVerbose)
    {
        fprintf(stderr, "mkgly: wCodePage = %d\n", wCodePage);
    }

    memset(awMultiByteArray, 0xff, sizeof(awMultiByteArray));

    while (1)
    {
        if (!GetLine(ajBuffer, sizeof(ajBuffer)))
            break;
        if ( sscanf (ajBuffer, "%hx%hd", &wMbChar, &wMbRun ) != 2 )
        {
            fprintf(stderr, "mkgly: unrecognized line - \"%s\"\n", ajBuffer);
            exit(EXIT_FAILURE);
        }

        if (iVerbose > 1)
        {
            fprintf(stderr, "mkgly: wMbChar = %x, wMbrun = %d\n",
                wMbChar, wMbRun);
        }

        for (; wMbRun--; wMbChar++)
        {
            iMbLen = 0;

            if (wMbChar & 0xff00)
            {
                ajMbChar[iMbLen++] = (BYTE)((wMbChar >> 8) & 0xff);
            }
            ajMbChar[iMbLen++] = (BYTE)(wMbChar & 0xff);

            if (MultiByteToWideChar(wCodePage, MB_ERR_INVALID_CHARS,
                    ajMbChar, iMbLen, &wcSysChar, 1) != 1)
            {
                fprintf(stderr, "mkgly: MultiByteToWideChar failed - %d\n",
                    GetLastError());
                exit(EXIT_FAILURE);
            }

            if ((iMbLen = WideCharToMultiByte(wCodePage, 0,
                &wcSysChar, 1, ajMbChar, sizeof(ajMbChar), NULL, NULL)) == FALSE)
            {
                fprintf(stderr, "mkgly: WideCharToMultiByte failed - %d\n",
                    GetLastError());
                exit(EXIT_FAILURE);
            }

            if (iMbLen == 2)
                wMbChar2 = (ajMbChar[0] << 8) + ajMbChar[1];
            else
                wMbChar2 = ajMbChar[0];

            if (wMbChar != wMbChar2)
            {
                fprintf(stderr, "mkgly: round-trip not achieved %x => %x => %x\n",
                    wMbChar, wcSysChar, wMbChar2 );
            }

            if (IS_EUDC_W(wcSysChar))
            {
                if (iVerbose > 1)
                {
                    fprintf(stderr, "mkgly: eudc character %x => %x%s\n",
                        wcSysChar, wMbChar, (bEudc ? "" : " ignored."));
                }

                if (!bEudc)
                    continue;
            }

            if (awMultiByteArray[wcSysChar] != INVALID_WCHAR_VALUE)
            {
                fprintf(stderr, "mkgly: duplicate mapping %x => %x overwritten by => %x\n",
                    wcSysChar, awMultiByteArray[wcSysChar], wMbChar);
            }
            awMultiByteArray[wcSysChar] = wMbChar;
        }
    }

    if ((pGlyphSet = pvBuildGlyphSet( awMultiByteArray )) == NULL) {
        fprintf( stderr, "Error creating FD_GLYPHSET structure.\n" );
        return;
    }

    bWriteGlyphSet( pGlyphSet, pFileName );
    GlobalFree( pGlyphSet );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\glyphset\mkgtt\mkgtt.c ===
/*++

Copyright (c) 1990-1996  Microsoft Corporation


Module Name:

    mkgtt.c


Abstract:

    Construct UNI_GLYPHSETDATA structure in memory and dump it as binary
    data so that a printer driver can include it in its resource.
    The input data format is as following:

    <codepage>
    <multibyte code>\t<run length>
    <multibyte code>\t<run length>
    ...

    "codepage" is the codepage id to be used in multibyte to Unicode
    conversion.  "Multibyte code" and "run length" pairs describes
    which codepoints of multibyte codes are available on the device.

    mkgtt will warn if there are multiple multibyte codepoints which
    are mapped to single Unicode codepoint.  The user is expected
    to fix this in the source, then re-run mkgtt.

    Follogins are command line options recogized by mkgtt:

    -e  Allow EUDC codepoints.  Default is not allow.
    -t  Output mapping table in text format also.
    -v  Verbose.

Author:

    08-Apr-1995 Sat 00:00:00 created -by- Takashi Matsuzawa (takashim)
    03-Mar-1996 Sat 00:00:00 updated -by- Takashi Matsuzawa (takashim)
    02-Feb-1997 Sat 00:00:00 ported  -by- Eigo Shimizu (eigos)

Environment:

    GDI device drivers (printer)


Notes:


Revision History:



--*/

#include <lib.h>
#include <win30def.h>
#include <uni16gpc.h>
#include <uni16res.h>
#include <fmnewfm.h>
#include <fmnewgly.h>
#include <unilib.h>
#include <fd_glyph.h>
#include <unirc.h>
#include <mkgtt.h>

//
// Macros
//

#define MIN_WCHAR_VALUE 0x0001
#define MAX_WCHAR_VALUE 0xfffd
#define INVALID_WCHAR_VALUE 0xffff
#define IS_COMMENT(c) \
    ((c) == ';' || (c) == '#' || (c) == '%' || (c) == '\n')
#define IS_EUDC_W(wc) \
    ((wc) >= 0xe000 && (wc) <= 0xf8ff)
#define SWAPW(x)                    (((WORD)(x)<<8) | ((WORD)(x)>>8))


//
// Globals
//

WORD awMultiByteArray[0x10000];
BOOL bEudc, bTable;
INT  iVerbose;

//
// Forward declaration
//

VOID
VPrintGTT(
     IN PUNI_GLYPHSETDATA pGly);

BOOL
BCreateSubFileName(
    IN CHAR *pDestFileName,
    IN CHAR *pSrcFileName,
    IN CHAR cAdd);

//
// Functions.
//

PUNI_GLYPHSETDATA
PBuildGTT(
    SHORT sMode,
    WORD  wCodepage,
    WORD  *pwArray )

/*++

Routine Description:

    Build UNI_GLYPHSETDATA on memory.

Arguments:


Return Value:

    None.

Author:



Revision History:


--*/

{
    DWORD        cGlyphs;           // count of glyph handles.
    DWORD        cRuns;             // count of runs within FD_GLYPHSET.
    DWORD        cbTotalMem;        // count of bytes needed for FD_GLYPHSET.
    DWORD        cEudc;
    DWORD        cRunsGlyphs = 0;
    WCHAR        wcChar, wcPrev, wcIndex, wcCommand;
    PBYTE        pBase;             // pointer to HGLYPH's.
    BYTE         aubChar[2];
    BOOL         bFirst, bInRun;

    PUNI_GLYPHSETDATA pGlyphSet;
    PUNI_CODEPAGEINFO pCodePageInfo;
    PGLYPHRUN         pGlyphRun, pGlyphRunTmp;
    PMAPTABLE         pMapTable;
    PTRANSDATA        pTrans;

    TRANSTAB         *lpctt;
    HMODULE           hModule;
    HRSRC             hRes;

    DBGMESSAGE(("sMode = %d, wCodepage = %d\n", sMode, wCodepage));

    cRuns = 0;
    cGlyphs = 0;
    cEudc = 0;

    bFirst = TRUE;

    for ( wcChar = MIN_WCHAR_VALUE; wcChar <= MAX_WCHAR_VALUE; wcChar++)
    {
        if (pwArray[wcChar] == INVALID_WCHAR_VALUE)
            continue;

        // GDI can't handle the value which cRunsGlyphs over 256. sueyas

        if (bFirst || (wcChar - wcPrev) > 1 || cRunsGlyphs++ > 255)
        {
            if (bFirst)
                bFirst = FALSE;

            cRuns++;
            cRunsGlyphs = 1;
        }

        if (IS_EUDC_W(wcChar))
            cEudc++;

        cGlyphs++;
        wcPrev = wcChar;
    }

    DBGMESSAGE(("cGlyphs = %d, cRuns = %d\n", cGlyphs, cRuns));

    // Allocate memory to build the UNI_GLYPHSET structure in.  this
    // include space for the FD_GLYPHSET structure itself, as well
    // as space for all the glyph handles.
    // DWORD bound it.

    cbTotalMem = sizeof(UNI_GLYPHSETDATA) +
                 sizeof(UNI_CODEPAGEINFO) +
                 cRuns * sizeof(GLYPHRUN) +
                 sizeof(MAPTABLE) +
                 (cGlyphs - 1) * sizeof(TRANSDATA);

    cbTotalMem = (cbTotalMem + 3) & ~3;

    if ((pBase = (PVOID)GlobalAlloc( 0, cbTotalMem )) == NULL) {

        fprintf( stderr, "Error alloating memory\n" );
        return NULL;
    }

    //
    // fill in the UNI_GLYPHSETDATA structure.
    //

    DBGMESSAGE(("fill in the UNI_GLYPHSETDATA structure.\n"));

    pGlyphSet                   = (PUNI_GLYPHSETDATA) pBase;
    pGlyphSet->dwSize           = cbTotalMem;
    pGlyphSet->dwVersion        = UNI_GLYPHSETDATA_VERSION_1_0;
    pGlyphSet->dwFlags          = 0;
    pGlyphSet->lPredefinedID    = CC_NOPRECNV;
    pGlyphSet->dwGlyphCount     = cGlyphs;
    pGlyphSet->dwRunCount       = cRuns;
    pGlyphSet->loRunOffset      = sizeof(UNI_GLYPHSETDATA);
    pGlyphSet->dwCodePageCount  = 1;
    pGlyphSet->loCodePageOffset = sizeof(UNI_GLYPHSETDATA) +
                                  sizeof(GLYPHRUN) * cRuns;
    pGlyphSet->loMapTableOffset = sizeof(UNI_GLYPHSETDATA) +
                                  sizeof(GLYPHRUN) * cRuns +
                                  sizeof(UNI_CODEPAGEINFO) ;

    pGlyphRun                   = (PGLYPHRUN)((PBYTE)pBase +
                                          pGlyphSet->loRunOffset);
    pCodePageInfo               = (PUNI_CODEPAGEINFO)((PBYTE)pBase +
                                          pGlyphSet->loCodePageOffset);
    pMapTable                   = (PMAPTABLE)((PBYTE)pBase +
                                          pGlyphSet->loMapTableOffset);
    pTrans                      = pMapTable->Trans;

    pCodePageInfo->dwCodePage                 = wCodepage;
    pCodePageInfo->SelectSymbolSet.dwCount    = 0;
    pCodePageInfo->SelectSymbolSet.loOffset   = (ULONG)NULL;
    pCodePageInfo->UnSelectSymbolSet.dwCount  = 0;
    pCodePageInfo->UnSelectSymbolSet.loOffset = (ULONG)NULL;

    DBGMESSAGE(("Load resource\n"));

    hModule = GetModuleHandle(TEXT("mkgtt.exe"));
    DBGMESSAGE(("hModule=0x%x\n", hModule));

    switch (sMode)
    {
    case CC_JIS:
    case CC_JIS_ANK:
        hRes = FindResource(hModule, TEXT("CC_JIS"), TEXT("RC_TRANSTAB"));
        DBGMESSAGE(("hRes=0x%x\n", hRes));
        lpctt = (TRANSTAB*)LoadResource(hModule, hRes);

        if (lpctt == NULL)
        {
            return FALSE;
        }
        break;

    case CC_ISC:
        hRes = FindResource(hModule, TEXT("CC_ISC"), TEXT("RC_TRANSTAB"));
        DBGMESSAGE(("hRes=0x%x\n", hRes));
        lpctt = (TRANSTAB*)LoadResource(hModule, hRes);

        if (lpctt == NULL)
        {
            return FALSE;
        }
        break;

    case CC_NS86:
        hRes = FindResource(hModule, TEXT("CC_NS86"), TEXT("RC_TRANSTAB"));
        DBGMESSAGE(("hRes=0x%x\n", hRes));
        lpctt = (TRANSTAB*)LoadResource(hModule, hRes);

        if (lpctt == NULL)
        {
            return FALSE;
        }
        break;

    case CC_TCA:
        hRes = FindResource(hModule, TEXT("CC_ISC"), TEXT("RC_TRANSTAB"));
        DBGMESSAGE(("hRes=0x%x\n", hRes));
        lpctt = (TRANSTAB*)LoadResource(hModule, hRes);

        if (lpctt == NULL)
        {
            return FALSE;
        }
        break;

    default:
        lpctt = NULL;

    }

    DBGMESSAGE(("Start to create GLYPHRUN.\n"));

    bInRun = FALSE;
    cRuns = 1;

    for ( wcIndex = 1, wcChar = MIN_WCHAR_VALUE;
          wcChar <= MAX_WCHAR_VALUE;
          wcChar++)
    {
        if (pwArray[wcChar] == INVALID_WCHAR_VALUE)
        {
            if (bInRun)
            {
                bInRun = FALSE;
                pGlyphRun ++;
                cRuns ++;
            }
        }
        else
        {
            //
            // GDI can't handle the value which cRunsGlyphs over 256. sueyas
            //

            if (!bInRun)
            {
                bInRun = TRUE;
                pGlyphRun->wcLow = wcChar;
                pGlyphRun->wGlyphCount = 1;
            }
            else
            {
                pGlyphRun->wGlyphCount++;
                if (pGlyphRun->wGlyphCount > 255)
                {
                    bInRun = FALSE;
                    pGlyphRun ++;
                    cRuns ++;
                }
            }

            pMapTable->Trans[wcIndex - 1].ubCodePageID = 0;
            switch (sMode)
            {
            case CC_JIS:
                if (HIBYTE(pwArray[wcChar]))
                {
                    aubChar[0] = HIBYTE(pwArray[wcChar]);
                    aubChar[1] = LOBYTE(pwArray[wcChar]);
                    SJisToJis(lpctt, (LPSTR)aubChar, (LPSTR)&wcCommand);
                    pMapTable->Trans[wcIndex - 1].ubType = MTYPE_DOUBLE |
                                                           MTYPE_PAIRED;
                    pMapTable->Trans[wcIndex - 1].uCode.ubPairs[0] =
                                                    LOBYTE(wcCommand);
                    pMapTable->Trans[wcIndex - 1].uCode.ubPairs[1] =
                                                    HIBYTE(wcCommand);
                }
                else
                {
                    AnkToJis(lpctt, (LPSTR)&pwArray[wcChar], (LPSTR)&wcCommand);
                    pMapTable->Trans[wcIndex - 1].ubType = MTYPE_SINGLE |
                                                           MTYPE_PAIRED;
                    pMapTable->Trans[wcIndex - 1].uCode.ubPairs[0] =
                                                    LOBYTE(wcCommand);
                    pMapTable->Trans[wcIndex - 1].uCode.ubPairs[1] =
                                                    HIBYTE(wcCommand);
                }
                DBGMESSAGE(("wcSJis=0x%4x, wcJis=0x%x\n", pwArray[wcChar], wcCommand));
                break;

            case CC_JIS_ANK:
                if (HIBYTE(pwArray[wcChar]))
                {
                    aubChar[0] = HIBYTE(pwArray[wcChar]);
                    aubChar[1] = LOBYTE(pwArray[wcChar]);
                    SJisToJis(lpctt, (LPSTR)aubChar, (LPSTR)&wcCommand);
                    pMapTable->Trans[wcIndex - 1].ubType = MTYPE_DOUBLE |
                                                           MTYPE_PAIRED;
                    pMapTable->Trans[wcIndex - 1].uCode.ubPairs[0] =
                                                    LOBYTE(wcCommand);
                    pMapTable->Trans[wcIndex - 1].uCode.ubPairs[1] =
                                                    HIBYTE(wcCommand);
                }
                else
                {
                    wcCommand = pwArray[wcChar];
                    pMapTable->Trans[wcIndex - 1].ubType = MTYPE_SINGLE |
                                                           MTYPE_PAIRED;
                    pMapTable->Trans[wcIndex - 1].uCode.ubPairs[0] = 0;
                    pMapTable->Trans[wcIndex - 1].uCode.ubPairs[1] =
                                                    LOBYTE(wcCommand);
                }
                DBGMESSAGE(("wcSJis=0x%4x, wcJis=0x%x\n", pwArray[wcChar], wcCommand));
                break;

            case CC_ISC:
                if (HIBYTE(pwArray[wcChar]))
                {
                    aubChar[0] = HIBYTE(pwArray[wcChar]);
                    aubChar[1] = LOBYTE(pwArray[wcChar]);
                    KSCToISC(lpctt, (LPSTR)aubChar, (LPSTR)&wcCommand);
                }
                else
                {
                    wcCommand = pwArray[wcChar];
                }
                goto SetTransData;

            case CC_NS86:
                if (HIBYTE(pwArray[wcChar]))
                {
                    aubChar[0] = HIBYTE(pwArray[wcChar]);
                    aubChar[1] = LOBYTE(pwArray[wcChar]);
                    Big5ToNS86(lpctt, (LPSTR)aubChar, (LPSTR)&wcCommand);
                }
                else
                {
                    wcCommand = pwArray[wcChar];
                }
                goto SetTransData;

            case CC_TCA:
                if (HIBYTE(pwArray[wcChar]))
                {
                    aubChar[0] = HIBYTE(pwArray[wcChar]);
                    aubChar[1] = LOBYTE(pwArray[wcChar]);
                    Big5ToTCA(lpctt, (LPSTR)aubChar, (LPSTR)&wcCommand);
                }
                else
                {
                    wcCommand = pwArray[wcChar];
                }
                goto SetTransData;

            default:
                wcCommand = pwArray[wcChar];

            SetTransData:
                if (!HIBYTE(wcCommand))
                {
                    pMapTable->Trans[wcIndex - 1].ubType = MTYPE_SINGLE |
                                                           MTYPE_DIRECT;
                    pMapTable->Trans[wcIndex - 1].uCode.ubCode =
                                                    LOBYTE(wcCommand);
                }
                else
                {
                    pMapTable->Trans[wcIndex - 1].ubType = MTYPE_DOUBLE |
                                                           MTYPE_PAIRED;
                    pMapTable->Trans[wcIndex - 1].uCode.ubPairs[0] =
                                                    HIBYTE(wcCommand);
                    pMapTable->Trans[wcIndex - 1].uCode.ubPairs[1] =
                                                    LOBYTE(wcCommand);
                }
                break;
            }


            DBGMESSAGE(("Valid char:0x%x, sMode=%d, Run=%d, GlyphHandle=%d, ubType=0x%x, Command=0x%x\n", wcChar, sMode, cRuns, wcIndex, pMapTable->Trans[wcIndex - 1].ubType, wcCommand));
            wcIndex ++;
        }
    }

    wcIndex --;
    pMapTable->dwSize = sizeof(MAPTABLE) + sizeof(TRANSDATA) * (wcIndex - 1);
    pMapTable->dwGlyphNum = wcIndex;

    if (hRes)
    {
        FreeResource(hRes);
    }

    DBG_VPRINTGTT(pGlyphSet);

    return pGlyphSet;
}

BOOL
bWriteGlyphSet(
    IN PUNI_GLYPHSETDATA  pGlyphSet,
    IN CHAR              *pFileName )

/*++

Routine Description:

    Dump FD_GLYPHSET data into specified file.

Arguments:


Return Value:

    None.

    08-Apr-1995 Sat 00:00:00 created -by- Takashi Matsuzawa (takashim)


Revision History:


--*/

{
    HANDLE hFile;

    ULONG   iIndex;
    WCRUN  *pWcRun;
    HGLYPH *phg;
    DWORD dwTmp;
   
    if ((hFile = CreateFileA(
        pFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, 0))
            == INVALID_HANDLE_VALUE) {

        return FALSE;
    }

    // FD_GLYPHSET structure itself + WCRUN array

    if (!WriteFile( hFile, pGlyphSet, pGlyphSet->dwSize, &dwTmp, NULL ))
    {
        return FALSE;
    }

    return TRUE;
}

VOID
Usage()
{
    fprintf ( stderr, "\nUsage : mkgtt [-etvv] outfile\n" );
    exit (EXIT_FAILURE);
}

BOOL
GetLine(
    BYTE *pjBuffer,
    INT cjSize)
{
    do
    {
        if(fgets(pjBuffer, cjSize, stdin) == NULL)
            return FALSE;
    } while (IS_COMMENT(*pjBuffer));

    return TRUE;
}

VOID __cdecl
main(
    int argc,
    char *argv[] )

/*++

Routine Description:

    Main routine for mkgtt.exe

Arguments:

    Output filename.  Input data is read from standard input.

Return Value:

    None.

Author:


    08-Apr-1995 Sat 00:00:00 created -by- Takashi Matsuzawa (takashim)


Revision History:


--*/

{
    PUNI_GLYPHSETDATA pGlyphSet;
    CHAR *pFileName;
    INT iArg;
    CHAR *pStr;
    WORD wCodePage;
    WORD wMbChar, wMbRun, iMbLen, wMbChar2;
    WCHAR wcSysChar;
    BYTE ajMbChar[2];
    BYTE ajBuffer[256];
    BYTE FileName[256];

    bEudc = FALSE;
    bTable = FALSE;
    iVerbose = 1;
    pFileName = NULL;

    while (--argc)
    {
        pStr = *(++argv);

        if (*pStr == '-')
        {
            for ( pStr++; *pStr; pStr++)
            {
                if (*pStr == 'e')
                    bEudc = TRUE;
                else if (*pStr == 't')
                    bTable = TRUE;
                else if (*pStr == 'v')
                    iVerbose++;
                else
                    Usage();
            }
         }
         else
         {
             pFileName = pStr;
             break;
         }
    }

    if (pFileName == NULL)
    {
        Usage();
    }

    // get the codepage id used for conversion

    if (!GetLine(ajBuffer, sizeof(ajBuffer)))
    {
        fprintf(stderr, "mkgtt: unexpected end of file\n");
        exit(EXIT_FAILURE);
    }
    sscanf(ajBuffer, "%hd", &wCodePage );

    DBGMESSAGE(("mkgtt: wCodePage = %d\n", wCodePage));

    memset(awMultiByteArray, 0xff, sizeof(awMultiByteArray));

    while (1)
    {
        if (!GetLine(ajBuffer, sizeof(ajBuffer)))
            break;
        if ( sscanf (ajBuffer, "%hx%hd", &wMbChar, &wMbRun ) != 2 )
        {
            fprintf(stderr, "mkgtt: unrecognized line - \"%s\"\n", ajBuffer);
            exit(EXIT_FAILURE);
        }

        DBGMESSAGE(("mkgtt: wMbChar = %x, wMbrun = %d\n", wMbChar, wMbRun));

        for (; wMbRun--; wMbChar++)
        {
            iMbLen = 0;

            if (wMbChar & 0xff00)
            {
                ajMbChar[iMbLen++] = (BYTE)((wMbChar >> 8) & 0xff);
            }
            ajMbChar[iMbLen++] = (BYTE)(wMbChar & 0xff);

            if (MultiByteToWideChar(wCodePage, MB_ERR_INVALID_CHARS,
                    ajMbChar, iMbLen, &wcSysChar, 1) != 1)
            {
                fprintf(stderr, "mkgtt: MultiByteToWideChar failed - %d\n",
                    GetLastError());
                exit(EXIT_FAILURE);
            }

            if ((iMbLen = WideCharToMultiByte(wCodePage, 0,
                &wcSysChar, 1, ajMbChar, sizeof(ajMbChar), NULL, NULL)) == FALSE)
            {
                fprintf(stderr, "mkgtt: WideCharToMultiByte failed - %d\n",
                    GetLastError());
                exit(EXIT_FAILURE);
            }

            if (iMbLen == 2)
                wMbChar2 = (ajMbChar[0] << 8) + ajMbChar[1];
            else
                wMbChar2 = ajMbChar[0];

            if (wMbChar != wMbChar2)
            {
                fprintf(stderr, "mkgtt: round-trip not achieved %x => %x => %x\n",
                    wMbChar, wcSysChar, wMbChar2 );
            }

            if (IS_EUDC_W(wcSysChar))
            {
                DBGMESSAGE(("mkgtt: eudc character %x => %x%s\n", wcSysChar, wMbChar, (bEudc ? "" : " ignored.")));

                if (!bEudc)
                    continue;
            }

            if (awMultiByteArray[wcSysChar] != INVALID_WCHAR_VALUE)
            {
                fprintf(stderr, "mkgtt: duplicate mapping %x => %x overwritten by => %x\n",
                    wcSysChar, awMultiByteArray[wcSysChar], wMbChar);
            }
            awMultiByteArray[wcSysChar] = wMbChar;
        }
    }

    DBGMESSAGE(("Call PBuildGTT\n"));

    switch (wCodePage)
    {
    case CP_SHIFTJIS_932:
        DBGMESSAGE(("Shiftjis\n"));

        if ((pGlyphSet = PBuildGTT(CC_SJIS, wCodePage, awMultiByteArray )) ==
            NULL)
        {
            fprintf( stderr, "Error creating FD_GLYPHSET structure.\n" );
            return;
        }

        bWriteGlyphSet( pGlyphSet, pFileName );
        GlobalFree( pGlyphSet );

        DBGMESSAGE(("Jis\n"));

        if ((pGlyphSet = PBuildGTT(CC_JIS, wCodePage, awMultiByteArray )) ==
            NULL)
        {
            fprintf( stderr, "Error creating FD_GLYPHSET structure.\n" );
            return;
        }

        BCreateSubFileName(FileName, pFileName, 'J');

        bWriteGlyphSet( pGlyphSet, FileName );
        GlobalFree( pGlyphSet );

        DBGMESSAGE(("Ank\n"));

        if ((pGlyphSet = PBuildGTT(CC_JIS_ANK, wCodePage, awMultiByteArray )) ==
            NULL)
        {
            fprintf( stderr, "Error creating FD_GLYPHSET structure.\n" );
            return;
        }

        BCreateSubFileName(FileName, pFileName, 'A');

        bWriteGlyphSet( pGlyphSet, FileName );
        GlobalFree( pGlyphSet );
        break;

    case CP_GB2312_936:
        if ((pGlyphSet = PBuildGTT(0, wCodePage, awMultiByteArray )) ==
            NULL)
        {
            fprintf( stderr, "Error creating FD_GLYPHSET structure.\n" );
            return;
        }

        bWriteGlyphSet( pGlyphSet, pFileName );
        GlobalFree( pGlyphSet );
        break;

    case CP_WANSUNG_949:
        if ((pGlyphSet = PBuildGTT(0, wCodePage, awMultiByteArray )) ==
            NULL)
        {
            fprintf( stderr, "Error creating FD_GLYPHSET structure.\n" );
            return;
        }

        bWriteGlyphSet( pGlyphSet, pFileName );
        GlobalFree( pGlyphSet );

        if ((pGlyphSet = PBuildGTT(CC_ISC, wCodePage, awMultiByteArray )) ==
            NULL)
        {
            fprintf( stderr, "Error creating FD_GLYPHSET structure.\n" );
            return;
        }

        BCreateSubFileName(FileName, pFileName, 'I');
        bWriteGlyphSet( pGlyphSet, FileName );
        GlobalFree( pGlyphSet );
        break;

    case CP_CHINESEBIG5_950:
        if ((pGlyphSet = PBuildGTT(CC_BIG5, wCodePage, awMultiByteArray )) ==
            NULL)
        {
            fprintf( stderr, "Error creating FD_GLYPHSET structure.\n" );
            return;
        }

        bWriteGlyphSet( pGlyphSet, pFileName );
        GlobalFree( pGlyphSet );

        if ((pGlyphSet = PBuildGTT(CC_TCA, wCodePage, awMultiByteArray )) ==
            NULL)
        {
            fprintf( stderr, "Error creating FD_GLYPHSET structure.\n" );
            return;
        }

        BCreateSubFileName(FileName, pFileName, 'T');
        bWriteGlyphSet( pGlyphSet, FileName );
        GlobalFree( pGlyphSet );

        if ((pGlyphSet = PBuildGTT(CC_NS86, wCodePage, awMultiByteArray )) ==
            NULL)
        {
            fprintf( stderr, "Error creating FD_GLYPHSET structure.\n" );
            return;
        }

        BCreateSubFileName(FileName, pFileName, 'N');
        bWriteGlyphSet( pGlyphSet, FileName );
        GlobalFree( pGlyphSet );

        break;
    }
}

VOID
VPrintGTT(
     IN PUNI_GLYPHSETDATA pGly)
{
    PUNI_CODEPAGEINFO pCP;
    PGLYPHRUN         pGlyphRun;
    PMAPTABLE         pMapTable;
    TRANSDATA        *pTrans;
    DWORD             dwI;
    WORD              wSize, wJ;
    PBYTE             pCommand;

    pCP       = (PUNI_CODEPAGEINFO)((PBYTE) pGly + pGly->loCodePageOffset);
    pGlyphRun = (PGLYPHRUN) ((PBYTE)pGly + pGly->loRunOffset);
    pMapTable = (PMAPTABLE) ((PBYTE)pGly + pGly->loMapTableOffset);
    pTrans    = pMapTable->Trans;

    printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    printf("G L Y P H S E T   D A T A   F I L E\n");
    printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    printf("GLYPHSETDATA\n");
    printf("GLYPHSETDATA.dwSize              : %d\n", pGly->dwSize);
    printf("             dwVersion           : %d.%d\n", (pGly->dwVersion) >>16,
                                                 0x0000ffff&pGly->dwVersion);
    printf("             dwFlags             : %d\n", pGly->dwFlags);
    printf("             lPredefinedID       : %d\n", pGly->lPredefinedID);
    printf("             dwGlyphCount        : %d\n", pGly->dwGlyphCount);
    printf("             dwRunCount          : %d\n", pGly->dwRunCount);
    printf("             loRunOffset         : 0x%x\n", pGly->loRunOffset);
    printf("             dwCodePageCount     : %d\n", pGly->dwCodePageCount);
    printf("             loCodePageOffset    : 0x%x\n", pGly->loCodePageOffset);
    printf("             loMapTableOffset    : 0x%x\n", pGly->loMapTableOffset);
    printf("\n");

    pCP = (PUNI_CODEPAGEINFO)((PBYTE) pGly + pGly->loCodePageOffset);

    printf("\n");
    printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    printf("CODEPAGEINFO\n");
    for (dwI = 0; dwI < pGly->dwCodePageCount; dwI ++)
    {
        printf ("UNI_CODEPAGEINFO[%d].dwCodePage                = %d\n",
            dwI, pCP->dwCodePage);
        printf ("UNI_CODEPAGEINFO[%d].SelectSymbolSet.dwCount   = %d\n",
            dwI, pCP->SelectSymbolSet.dwCount);
        printf ("UNI_CODEPAGEINFO[%d].SelectSymbolSet:Command   = %s\n",
            dwI, (PBYTE)pCP+pCP->SelectSymbolSet.loOffset);
        printf ("UNI_CODEPAGEINFO[%d].UnSelectSymbolSet.dwCount = %d\n",
            dwI, pCP->UnSelectSymbolSet.dwCount);
        printf ("UNI_CODEPAGEINFO[%d].UnSelectSymbolSet:Command = %s\n",
            dwI, (PBYTE)pCP+pCP->UnSelectSymbolSet.loOffset);
        pCP++;
    }

    pGlyphRun =
            (PGLYPHRUN) ((PBYTE)pGly + pGly->loRunOffset);

    printf("\n");
    printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    printf("GLYPHRUN\n");
    for (dwI = 0; dwI < pGly->dwRunCount; dwI ++)
    {
         printf("GLYPHRUN[%2d].wcLow       = 0x%-4x\n",
             dwI, pGlyphRun->wcLow);
         printf("GLYPHRUN[%2d].wGlyphCount = %d\n",
             dwI, pGlyphRun->wGlyphCount);
         pGlyphRun++;
    }

    pMapTable = (PMAPTABLE) ((PBYTE)pGly + pGly->loMapTableOffset);
    pTrans    = pMapTable->Trans;

    printf("\n");
    printf("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n");
    printf("MAPTABLE\n");
    printf("MAPTABLE.dwSize     = %d\n", pMapTable->dwSize);
    printf("MAPTABLE.dwGlyphNum = %d\n", pMapTable->dwGlyphNum);

    for (dwI = 0; dwI < pMapTable->dwGlyphNum; dwI ++)
    {
        printf("MAPTABLE.pTrans[%5d].ubCodePageID = %d\n",
            dwI, pTrans[dwI].ubCodePageID);
        printf("MAPTABLE.pTrans[%5d].ubType       = 0x%x\n",
            dwI, pTrans[dwI].ubType);
        switch(pTrans[dwI].ubType & MTYPE_FORMAT_MASK)
        {
        case MTYPE_DIRECT:
            printf("MAPTABLE.pTrans[%5d].ubCode       = 0x%02x\n",
                dwI, pTrans[dwI].uCode.ubCode);
            break;
        case MTYPE_PAIRED:
            printf("MAPTABLE.pTrans[%5d].ubPairs[0]   = 0x%02x\n",
                dwI, pTrans[dwI].uCode.ubPairs[0]);
            printf("MAPTABLE.pTrans[%5d].ubPairs[1]   = 0x%02x\n",
                dwI, pTrans[dwI].uCode.ubPairs[1]);
            break;
        case MTYPE_COMPOSE:
                printf("MAPTABLE.pTrans[%5d].sCode        = 0x%02x\n",
                    dwI, pTrans[dwI].uCode.sCode);
                pCommand = (PBYTE)pMapTable + pTrans[dwI].uCode.sCode;
                wSize = *(WORD*)pCommand;
                pCommand += 2;
                printf("Size                                = 0x%d\n", wSize);
                printf("Command                             = 0x");
                for (wJ = 0; wJ < wSize; wJ ++)
                {
                    printf("%02x",pCommand[wJ]);
                }
                printf("\n");
            break;
        }
    }
}


BOOL
BCreateSubFileName(
    IN CHAR *pDestFileName,
    IN CHAR *pSrcFileName,
    IN CHAR cAdd)
{
    INT iFileNameLen, iI;

    iFileNameLen = strlen(pSrcFileName);
    strcpy(pDestFileName, pSrcFileName);

    for (iI = 0; iI < iFileNameLen; iI ++)
    {
        if (pSrcFileName[iI] == '.')
        {
            break;
        }
    }

    pDestFileName[iI]     = cAdd;
    pDestFileName[iI + 1] = pSrcFileName[iI];
    pDestFileName[iI + 2] = pSrcFileName[iI + 1];
    pDestFileName[iI + 3] = pSrcFileName[iI + 2];
    pDestFileName[iI + 4] = pSrcFileName[iI + 3];
    pDestFileName[iI + 5] = (CHAR)NULL;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\glyphset\mkgtt\mkgtt.h ===
/*++

Copyright (c) 1996-1997  Microsoft Corporation

Module Name:

    mkgtt.h

Abstract:

    Predefined GTT generator

Environment:

    Windows NT printer drivers

Revision History:

    01/21/96 -eigos-
        Created it.

--*/

#ifndef _MKGTT_H_
#define _MKGTT_H_

//
// Macros
//

#define DBGMESSAGE(msg) \
    if (iVerbose > 1) { \
        printf msg; \
    } \

#define DBG_VPRINTGTT(pgtt) \
    if (iVerbose > 1) { \
        VPrintGTT(pgtt); \
    } \

//
// DBCS Conversion functions
//

VOID
KSCToISC(
    TRANSTAB *lpctt,
    LPSTR   lpStrKSC,
    LPSTR   lpStrISC);

VOID SJisToJis(
    TRANSTAB *lpctt,
    LPSTR     lpStrSJis,
    LPSTR     lpStrJis);

VOID AnkToJis(
    TRANSTAB *lpctt,
    LPSTR     lpStrAnk,
    LPSTR     lpStrJis);

#ifdef JIS78
VOID SysTo78(
    TRANSTAB *lpctt,
    LPSTR     lpStrSys,
    LPSTR     lpStr78);
#endif

VOID Big5ToNS86(
    TRANSTAB *lpctt,
    LPSTR     lpStrBig5,
    LPSTR     lpStrNS);

VOID Big5ToTCA(
    TRANSTAB *lpctt,
    LPSTR     lpStrBig5,
    LPSTR     lpStrTCA);

#endif // _MKGTT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\alpsres\compress.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

#include        <windows.h>

#define TIFF_MIN_RUN       4            /* Minimum repeats before use RLE */
#define TIFF_MAX_RUN     128            /* Maximum repeats */
#define TIFF_MAX_LITERAL 128            /* Maximum consecutive literal data */

int
iCompTIFF( pbOBuf, pbIBuf, cb )
BYTE  *pbOBuf;         /* Output buffer,  PRESUMED BIG ENOUGH: see above */
BYTE  *pbIBuf;         /* Raster data to send */
int    cb;             /* Number of bytes in the above */
{
    BYTE   *pbOut;        /* Output byte location */
    BYTE   *pbStart;      /* Start of current input stream */
    BYTE   *pb;           /* Miscellaneous usage */
    BYTE   *pbEnd;        /* The last byte of input */
    BYTE    jLast;        /* Last byte,  for match purposes */

    int     cSize;        /* Bytes in the current length */
    int     cSend;        /* Number to send in this command */


    pbOut = pbOBuf;
    pbStart = pbIBuf;
    pbEnd = pbIBuf + cb;         /* The last byte */

    jLast = *pbIBuf++;

    while( pbIBuf < pbEnd )
    {
        if( jLast == *pbIBuf )
        {
            /*  Find out how long this run is.  Then decide on using it */

            for( pb = pbIBuf; pb < pbEnd && *pb == jLast; ++pb )
                                   ;

            /*
             *   Note that pbIBuf points at the SECOND byte of the pattern!
             *  AND also that pb points at the first byte AFTER the run.
             */

            if( (pb - pbIBuf) >= (TIFF_MIN_RUN - 1) )
            {
                /*
                 *    Worth recording as a run,  so first set the literal
                 *  data which may have already been scanned before recording
                 *  this run.
                 */

                if( (cSize = (int)(pbIBuf - pbStart - 1)) > 0 )
                {
                    /*   There is literal data,  so record it now */
                    while( (cSend = min( cSize, TIFF_MAX_LITERAL )) > 0 )
                    {
                        *pbOut++ = cSend - 1;
                        CopyMemory( pbOut, pbStart, cSend );
                        pbOut += cSend;
                        pbStart += cSend;
                        cSize -= cSend;
                    }
                }

                /*
                 *   Now for the repeat pattern.  Same logic,  but only
                 * one byte is needed per entry.
                 */

                cSize = (int)(pb - pbIBuf + 1);

                while( (cSend = min( cSize, TIFF_MAX_RUN )) > 0 )
                {
                    *pbOut++ = 1 - cSend;        /* -ve indicates repeat */
                    *pbOut++ = jLast;
                    cSize -= cSend;
                }

                pbStart = pb;           /* Ready for the next one! */
            }
            pbIBuf = pb;                /* Start from this position! */
        }
        else
            jLast = *pbIBuf++;                   /* Onto the next byte */
 
    }

    if( pbStart < pbIBuf )
    {
        /*  Left some dangling.  This can only be literal data.   */

        cSize = (int)(pbIBuf - pbStart);

        while( (cSend = min( cSize, TIFF_MAX_LITERAL )) > 0 )
        {
            *pbOut++ = cSend - 1;
            CopyMemory( pbOut, pbStart, cSend );
            pbOut += cSend;
            pbStart += cSend;
            cSize -= cSend;
        }
    }

    return  (int)(pbOut - pbOBuf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\alpsres\dither.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


#define Yellow                     0
#define Cyan                       1
#define Magenta                    2
#define Black                      3

#define DITHER_HIGH                1
#define DITHER_LOW                 2
#define DITHER_OHP                 3
#define DITHER_HIGH_DIV2           4
#define DITHER_DYE                 5
#define DITHER_VD                  6

BOOL bOHPConvert(
PDEVOBJ pdevobj,
BYTE bRed,
BYTE bGreen,
BYTE bBlue,
BYTE *ppy,
BYTE *ppm,
BYTE *ppc,
BYTE *ppk,
INT x,
INT y);

BOOL bPhotoConvert(
PDEVOBJ pdevobj,
BYTE bRed,
BYTE bGreen,
BYTE bBlue,
BYTE *ppy,
BYTE *ppm,
BYTE *ppc,
BYTE *ppk);

BOOL bBusinessConvert(
PDEVOBJ pdevobj,
BYTE bRed,
BYTE bGreen,
BYTE bBlue,
BYTE *ppy,
BYTE *ppm,
BYTE *ppc,
BYTE *ppk);

BOOL bCharacterConvert(
PDEVOBJ pdevobj,
BYTE bRed,
BYTE bGreen,
BYTE bBlue,
BYTE *ppy,
BYTE *ppm,
BYTE *ppc,
BYTE *ppk);

BOOL bMonoConvert(
PDEVOBJ pdevobj,
BYTE bRed,
BYTE bGreen,
BYTE bBlue,
BYTE *ppk);

BOOL bDitherProcess(
PDEVOBJ pdevobj,
int  x,
BYTE py,
BYTE pm,
BYTE pc,
BYTE pk,
BYTE *pby,
BYTE *pbm,
BYTE *pbc,
BYTE *pbk);

BOOL bInitialDither(
PDEVOBJ     pdevobj);

BOOL bInitialColorConvert(
PDEVOBJ     pdevobj);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\alpsres\common.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
static BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE((DLLTEXT("OEMGetInfo(%s) entry.\n"), OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        VERBOSE((ERRORTEXT("OEMGetInfo() ERROR_INVALID_PARAMETER.\n")));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        VERBOSE((ERRORTEXT("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\n")));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    VERBOSE((DLLTEXT("OEMDevMode(), dwMode=%d\n"), dwMode));
//    VERBOSE((DLLTEXT("OEMDevMode(%s) entry.\n"), OEMDevMode_fMode[dwMode]));

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        VERBOSE((ERRORTEXT("OEMDevMode() ERROR_INVALID_PARAMETER.\n")));
        VDumpOEMDevModeParam(pOEMDevModeParam);

        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        VERBOSE((ERRORTEXT("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\n")));

        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            VERBOSE(("OEMUD OEMDevMode():  not valid OEM Extra Data.\n"));

            return FALSE;
        }
        break;
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{

    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

static BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
    if(pdmIn)
    {
        //
        // copy over the private fields, if they are valid
        //
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        VERBOSE(("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\n"));

        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        VERBOSE(("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        VERBOSE(("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        VERBOSE(("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        VERBOSE(("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        VERBOSE(("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\n"));

        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        VERBOSE(("\n\tOEM_DEVMODEPARAM dump:\n\n"));

        VERBOSE((("\tcbSize = %d.\n"), pOEMDevModeParam->cbSize));
        VERBOSE((("\thPrinter = %#lx.\n"), pOEMDevModeParam->hPrinter));
        VERBOSE((("\thModule = %#lx.\n"), pOEMDevModeParam->hModule));
        VERBOSE((("\tpPublicDMIn = %#lx.\n"), pOEMDevModeParam->pPublicDMIn));
        VERBOSE((("\tpPublicDMOut = %#lx.\n"), pOEMDevModeParam->pPublicDMOut));
        VERBOSE((("\tpOEMDMIn = %#lx.\n"), pOEMDevModeParam->pOEMDMIn));
        VERBOSE((("\tpOEMDMOut = %#lx.\n"), pOEMDevModeParam->pOEMDMOut));
        VERBOSE((("\tcbBufSize = %d.\n"), pOEMDevModeParam->cbBufSize));
    }
}


//
// Functions for outputting debug messages
//
#if 0
VOID DbgPrint(IN LPCTSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\alpsres\comoem.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:


Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUni
{
public:    
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid,
        void** ppv)
    {    
        VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
        }
        else
        {
            *ppv = NULL ;
            VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));

        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release() 
    {
        VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));

        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this;
            return 0;
        }
        return m_cRef;
    }

    //
    // IPrintOemCommon methods
    //

    STDMETHODIMP
        DevMode(
        DWORD dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

        if (OEMDevMode(dwMode, pOemDMParam)) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    }

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));

        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // IPrintOemEngine methods
    //

    STDMETHODIMP
    EnableDriver(
    DWORD dwDriverVersion,
    DWORD cbSize,
    PDRVENABLEDATA pded)
{
    VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// Sep.17.98 ->
    // Need to return S_OK so that DisableDriver() will be called, which Releases
    // the reference to the Printer Driver's interface.
    return S_OK;
// Sep.17.98 <-
}

//
// Function Name: DisableDriver
// Plug-in: Rendering module
// Driver: Any
// Type: Optional
//

    STDMETHODIMP
    DisableDriver(VOID)
{
    VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// Sep.17.98 ->
    // OEMDisableDriver();

    // Release reference to Printer Driver's interface.
    if (this->pOEMHelp)
    {
        this->pOEMHelp->Release();
        this->pOEMHelp = NULL;
    }
    return S_OK;
// Sep.17.98 <-
}

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
    {
        VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));

        PDEVOEM pTemp;

        pTemp = OEMEnablePDEV(pdevobj,
            pPrinterName, cPatterns, phsurfPatterns,
            cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);

        if (NULL == pTemp) {
            return E_FAIL;
        }

        //
        // Save necessary helpder function addresses.
        //

        ((MINIDEV *)pTemp)->pIntf = this->pOEMHelp;
        *pDevOem = pTemp;

        return S_OK;
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
    PDEVOBJ pdevobj)
    {
        VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));

        OEMDisablePDEV(pdevobj);
        return S_OK;
    }

//
// Function Name: ResetPDEV
// Plug-in: Rendering module
// Driver: Any
// Type: Optional
//

    STDMETHODIMP
    ResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
{
    VERBOSE((DLLTEXT("IOemCB::ResetPDEV() entry.\n")));

    if (OEMResetPDEV(pdevobjOld, pdevobjNew)) {
        return S_OK;
    }
    else {
        return E_FAIL;
    }
}

    //
    // IPrintOemUni methods
    //

    STDMETHODIMP
    PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
// Sep.8.98 ->
    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;

        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->pOEMHelp = NULL;

            return E_FAIL;
        }
    }
// Sep.8.98 <-
    return S_OK;
}

//
// Function Name: GetImplementationMethod
// Plug-in: Rendering module
// Driver: Any
// Type: Mandatory
//

static
int __cdecl
iCompNames(
    const void *p1,
    const void *p2) {

    return strcmp(
        *((char **)p1),
        *((char **)p2));
}

    STDMETHODIMP
    GetImplementedMethod(
    PSTR pMethodName)
{
    LONG lRet = E_NOTIMPL;
    PSTR pTemp;

    VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

    if (NULL != pMethodName) {

        pTemp = (PSTR)bsearch(
            &pMethodName,
            gMethodsSupported,
            (sizeof (gMethodsSupported) / sizeof (PSTR)),
            sizeof (PSTR),
            iCompNames);

        if (NULL != pTemp)
            lRet = S_OK;
    }

    VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

    return lRet;
}

//
// Function Name: DriverDMS
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

    STDMETHODIMP
    DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: CommandCallback
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

    STDMETHODIMP
    CommandCallback(
    PDEVOBJ pdevobj,
    DWORD dwCallbackID,
    DWORD dwCount,
    PDWORD pdwParams,
    OUT INT *piResult)
{
    VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));

    *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

    return S_OK;
}

//
// Function Name: ImageProcessing
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

    STDMETHODIMP
    ImageProcessing(
    PDEVOBJ             pdevobj,  
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
{
    VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: FilterGraphics
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

    STDMETHODIMP
    FilterGraphics(
    PDEVOBJ pdevobj,
    PBYTE pBuf,
    DWORD dwLen)
{
#if 0
    // Enable this debug line if you really want to be
    // verbose.
    VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));
#endif

    if (TRUE != OEMFilterGraphics(pdevobj, pBuf, dwLen)) {
        return E_FAIL;
    }
    return S_OK;
}

//
// Function Name: Compression
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

    STDMETHODIMP
    Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
{
    VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: HalftonePattern
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

    STDMETHODIMP
    HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
{
    VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: MemoryUsge
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

    STDMETHODIMP
    MemoryUsage(
    PDEVOBJ         pdevobj,   
    POEMMEMORYUSAGE pMemoryUsage)
{
    VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: TTYGetInfo
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

    STDMETHODIMP
    TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: DownloadFontHeader
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

    STDMETHODIMP
    DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: DownloadCharGlyph
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

    STDMETHODIMP
    DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: TTDonwloadMethod
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

    STDMETHODIMP
    TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: OutputCharStr
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

    STDMETHODIMP
    OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph) 
{
    VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: SendFontCmd
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

    STDMETHODIMP
    SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv) 
{
    VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));
    return E_NOTIMPL;
}

//
// Function Name: TextOutputAsBitmap
// Plug-in: Rendering module
// Driver: Unidrv
// Type: Optional
//

    STDMETHODIMP
    TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
{
    VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
    return E_NOTIMPL;
}

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

//
// Make the Unidrv helper functions (defined in C++)
// accesible to C.
//

extern "C" {

    //
    // DrvWriteSpoolBuf()
    //
    HRESULT
    XXXDrvWriteSpoolBuf(
        VOID *pIntf,
        PDEVOBJ pdevobj,
        PVOID pBuffer,
        DWORD cbSize,
        DWORD *pdwResult) {

            return ((IPrintOemDriverUni *)pIntf)->DrvWriteSpoolBuf(
                pdevobj,
                pBuffer,
                cbSize,
                pdwResult);
        }

}

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

///////////////////////////////////////////////////////////
//
// Class factory body
//
    STDMETHODIMP_(HRESULT)
    QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this);
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

    STDMETHODIMP_(ULONG)
    AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

    STDMETHODIMP_(ULONG)
    Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation

    STDMETHODIMP_(HRESULT)
    CreateInstance(
    IUnknown *pUnknownOuter,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

    // Cannot aggregate.
    if (NULL != pUnknownOuter) {

        return CLASS_E_NOAGGREGATION;
    }

    // Create component.
    IOemCB* pOemCB = new IOemCB;
    if (NULL == pOemCB) {

        return E_OUTOFMEMORY;
    }

    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv);

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release();
    return hr ;
}

// LockServer
    STDMETHODIMP_(HRESULT)
    LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks);
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks);
    }
    return S_OK ;
}

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

///////////////////////////////////////////////////////////
//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID);
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID);
}

///////////////////////////////////////////////////////////
//
// DLL module information
//

BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule ;
    }
        g_hModule = (HMODULE)hModule ;
    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\alpsres\dither.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


#include "pdev.h"
#include "alpsres.h"
#include "dither.h"
#include "dtable.h"

int Calc_degree(int x, int y);

/*************************** Function Header *******************************
 *  bInitialDither
 *
 *  Pre-processing of dither tables.
 *
 * HISTORY:
 *  24 Jun 1996    -by-    Sueya Sugihara    [sueyas]
 *     Created.
 *
 ***************************************************************************/
BOOL bInitialDither(
PDEVOBJ     pdevobj)
{

    PCURRENTSTATUS lpnp;

    lpnp = (PCURRENTSTATUS)MINIDEV_DATA(pdevobj);

    // Already created the NewTable[][][] by dither.exe.

    if( lpnp->iTextQuality != CMDID_TEXTQUALITY_GRAY ){

    int B_LOW;
    int B_R;
    int UCR;
    int YUCR;
    int B_GEN;
    int i;
//    FLOATOBJ  f1,f2;
    float  f1,f2;

    // initialize.

    if( lpnp->iTextQuality == CMDID_TEXTQUALITY_PHOTO ){

        B_LOW = 0;
        B_R   = 70;
        UCR   = 50;
        YUCR  = 4;
        B_GEN = 2;

    }else{

        B_LOW = 0;
        B_R   = 100;
        UCR   = 60;
        YUCR  = 4;
        B_GEN = 3;
    }

    // Create KuroTBL[] to get black from YMC.

    for( i=0; i< 256; i++){

        if( i < B_LOW )

        lpnp->KuroTBL[i] = 0;

        else{

        int       k;

        FLOATOBJ_SetLong(&f1, (i - B_LOW));
        FLOATOBJ_DivLong(&f1, (255 - B_LOW));

        f2 = f1;

        for(k=0; k<(B_GEN - 1); k++){

            FLOATOBJ_Mul(&f1, &f2);

        }

        FLOATOBJ_MulLong(&f1, 255);

        FLOATOBJ_MulLong(&f1, B_R);

        FLOATOBJ_DivLong(&f1, 100);

        FLOATOBJ_AddFloat(&f1,(FLOAT)0.5);

        lpnp->KuroTBL[i] = (unsigned char)FLOATOBJ_GetLong(&f1);

        }

    }

    // Create UcrTBL[] to reduce extracting black density from YMC

    for( i=0; i< 256; i++){

        if( i < B_LOW )

        lpnp->UcrTBL[i] = 0;

        else{

        FLOATOBJ_SetLong(&f1, (i - B_LOW));

        FLOATOBJ_MulLong(&f1, UCR);

        FLOATOBJ_DivLong(&f1, 100);

        lpnp->UcrTBL[i] = (unsigned char)FLOATOBJ_GetLong(&f1);

        }
    }


    lpnp->YellowUcr = (unsigned char)((unsigned int)(100 - YUCR) * 255 / 100);

    }

    return TRUE;
}

/*************************** Function Header *******************************
 *  bInitialColorConvert
 *
 *  Pre-processing of color conversion process.
 *
 * HISTORY:
 *  24 Jun 1996    -by-    Sueya Sugihara    [sueyas]
 *     Created.
 *
 ***************************************************************************/
BOOL bInitialColorConvert(
PDEVOBJ     pdevobj)
{

    PCURRENTSTATUS lpnp;
    int            i;
    BYTE          *RedHosei;
    BYTE          *GreenHosei;
    BYTE          *BlueHosei;

    lpnp = (PCURRENTSTATUS)MINIDEV_DATA(pdevobj);

    // Color definitions.

    lpnp->RGB_Rx = 6400;      // X value of Red 100% on monitor
    lpnp->RGB_Ry = 3300;      // Y value of Red 100% on monitor
    lpnp->RGB_Gx = 2900;      // X value of Green 100% on monitor
    lpnp->RGB_Gy = 6000;      // Y value of Green 100% on monitor
    lpnp->RGB_Bx = 1500;      // X value of Blue 100% on monitor
    lpnp->RGB_By =  600;      // Y value of Blue 100% on monitor
    lpnp->RGB_Wx = 3127;      // X value of White 100% on monitor
    lpnp->RGB_Wy = 3290;      // Y value of White 100% on monitor

    lpnp->CMY_Cx = 1726;      // X value of Cyan 100% on ribbon
    lpnp->CMY_Cy = 2248;      // Y value of Cyan 100% on ribbon
    lpnp->CMY_Mx = 3923;      // X value of Magenta 100% on ribbon
    lpnp->CMY_My = 2295;      // Y value of Magenta 100% on ribbon
    lpnp->CMY_Yx = 4600;      // X value of Yellow 100% on ribbon
    lpnp->CMY_Yy = 4600;      // Y value of Yellow 100% on ribbon
    lpnp->CMY_Rx = 6000;      // X value of Red (MY) 100% on ribbon
    lpnp->CMY_Ry = 3200;      // Y value of Red (MY) 100% on ribbon
    lpnp->CMY_Gx = 2362;      // X value of Green (CY) 100% on ribbon
    lpnp->CMY_Gy = 5024;      // Y value of Green (CY) 100% on ribbon
    lpnp->CMY_Bx = 2121;      // X value of Blue (CM) 100% on ribbon
    lpnp->CMY_By = 1552;      // Y value of Blue (CM) 100% on ribbon
    lpnp->CMY_Wx = 3148;      // X value of White on paper
    lpnp->CMY_Wy = 3317;      // Y value of White on paper

    lpnp->RedAdj     =   0;   // Param for density adjust
    lpnp->RedStart   =   0;   // Position of start for density adjust
    lpnp->GreenAdj   = 400;   // Param for density adjust
    lpnp->GreenStart =  50;   // Position of start for density adjust
    lpnp->BlueAdj    =   0;   // Param for density adjust
    lpnp->BlueStart  =   0;   // Position of start for density adjust


    // Calculation of density adjustment table.

    RedHosei = lpnp->RedHosei;
    GreenHosei = lpnp->GreenHosei;
    BlueHosei = lpnp->BlueHosei;

    for(i = 0; i < 256; i ++){

    RedHosei[i] = GreenHosei[i] = BlueHosei[i] = 0;
    }

    if( lpnp->RedAdj != 0 ){

    for(i = lpnp->RedStart; i < 255; i++)

        RedHosei[i] = (unsigned char)((255 - i) * (i - lpnp->RedStart) / lpnp->RedAdj);

    }

    if( lpnp->GreenAdj != 0 ){

    for(i = lpnp->GreenStart; i < 255; i++)

        GreenHosei[i] = (unsigned char)((255 - i) * (i - lpnp->GreenStart) / lpnp->GreenAdj);

    }

    if( lpnp->BlueAdj != 0 ){

    for(i = lpnp->BlueStart; i < 255; i++)

        BlueHosei[i] = (unsigned char)((255 - i) * (i - lpnp->BlueStart) / lpnp->BlueAdj);

    }

    // Calculation of color definition data.

    lpnp->RGB_Rx -= lpnp->RGB_Wx;        lpnp->RGB_Ry -= lpnp->RGB_Wy;
    lpnp->RGB_Gx -= lpnp->RGB_Wx;        lpnp->RGB_Gy -= lpnp->RGB_Wy;
    lpnp->RGB_Bx -= lpnp->RGB_Wx;        lpnp->RGB_By -= lpnp->RGB_Wy;

    lpnp->RGB_Cx = ( lpnp->RGB_Gx - lpnp->RGB_Bx ) / 2 + lpnp->RGB_Bx;
    lpnp->RGB_Cy = ( lpnp->RGB_Gy - lpnp->RGB_By ) / 2 + lpnp->RGB_By;
    lpnp->RGB_Mx = ( lpnp->RGB_Rx - lpnp->RGB_Bx ) / 2 + lpnp->RGB_Bx;
    lpnp->RGB_My = ( lpnp->RGB_Ry - lpnp->RGB_By ) / 2 + lpnp->RGB_By;
    lpnp->RGB_Yx = ( lpnp->RGB_Rx - lpnp->RGB_Gx ) / 2 + lpnp->RGB_Gx;
    lpnp->RGB_Yy = ( lpnp->RGB_Ry - lpnp->RGB_Gy ) / 2 + lpnp->RGB_Gy;

    lpnp->CMY_Cx -= lpnp->CMY_Wx;        lpnp->CMY_Cy -= lpnp->CMY_Wy;
    lpnp->CMY_Mx -= lpnp->CMY_Wx;        lpnp->CMY_My -= lpnp->CMY_Wy;
    lpnp->CMY_Yx -= lpnp->CMY_Wx;        lpnp->CMY_Yy -= lpnp->CMY_Wy;
    lpnp->CMY_Rx -= lpnp->CMY_Wx;        lpnp->CMY_Ry -= lpnp->CMY_Wy;
    lpnp->CMY_Gx -= lpnp->CMY_Wx;        lpnp->CMY_Gy -= lpnp->CMY_Wy;
    lpnp->CMY_Bx -= lpnp->CMY_Wx;        lpnp->CMY_By -= lpnp->CMY_Wy;

    // Calculation of data for color dimension judgement

    lpnp->CMY_Cd = Calc_degree( lpnp->CMY_Cx, lpnp->CMY_Cy );
    lpnp->CMY_Md = Calc_degree( lpnp->CMY_Mx, lpnp->CMY_My );
    lpnp->CMY_Yd = Calc_degree( lpnp->CMY_Yx, lpnp->CMY_Yy );
    lpnp->CMY_Rd = Calc_degree( lpnp->CMY_Rx, lpnp->CMY_Ry );
    lpnp->CMY_Gd = Calc_degree( lpnp->CMY_Gx, lpnp->CMY_Gy );
    lpnp->CMY_Bd = Calc_degree( lpnp->CMY_Bx, lpnp->CMY_By );

    return TRUE;
}

int Calc_degree( int x, int y)
{
    register int    val;

    if( x == 0 ){

    if( y == 0 )

        val = 0;

    else if( y > 0 )

        val = 30000;

    else

        val = -30000;

    }else{

    val = y / x;

    if( val > 300 )

        val = 30000;

    else if( val < -300 )

        val = -30000;

    else

        val = (y * 100) / x;

    }

    return val;

}


BOOL bOHPConvert(
PDEVOBJ pdevobj,
BYTE bRed,
BYTE bGreen,
BYTE bBlue,
BYTE *ppy,
BYTE *ppm,
BYTE *ppc,
BYTE *ppk,
INT x,
INT y)
{
    BYTE    rm;
    BYTE           by, bm, bc, bk;

    rm = OHP_NewTable[y % OHP_MaxY][x % OHP_MaxX];

    if( bBlue <= rm )
        by = 1;
    else
        by = 0;

    if( bGreen <= rm )
        bm = 1;
    else
        bm = 0;

    if( bRed <= rm )
        bc = 1;
    else
        bc = 0;

    if( by && bm && bc ) {
        bk = 1;
        by = bm = bc = 0;
    }
    else
        bk = 0;

    return TRUE;
}

/*************************** Function Header *******************************
 *  bPhotoConvert
 *
 *  Convert RGB to CMYK for photo graphics.
 *
 *
 * HISTORY:
 *  24 Jun 1996    -by-    Sueya Sugihara    [sueyas]
 *     Created.
 *
 ***************************************************************************/
BOOL bPhotoConvert(
PDEVOBJ pdevobj,
BYTE bRed,
BYTE bGreen,
BYTE bBlue,
BYTE *ppy,
BYTE *ppm,
BYTE *ppc,
BYTE *ppk)
{

    int  k, w, pk, r, g, b;
    int  Est_x, Est_y;
    int  p1, p2;
    int  deg, area;
    register int  val_a, val_b, val_c, val_d;
    register int  val1,  val2;
    BYTE hosei;
    int  py, pm, pc;
    PCURRENTSTATUS lpnp;

    lpnp = (PCURRENTSTATUS)MINIDEV_DATA(pdevobj);

    k = max( bRed, bGreen );
    k = max( k, bBlue );

    // Set black element

    pk = 255 - k;

    w = min( bRed, bGreen );
    w = min( w, bBlue );

    // Cut white element from each color

    r = bRed - w;
    g = bGreen - w;
    b = bBlue - w;

    // Get estimation for Est_x and Est_y

    if( r == 0 ){                       // G->C->B

    if(( g == 0 ) && ( b == 0 )){   // no color

        Est_x = 0;
        Est_y = 0;

    }
    else if( g >= b ){              // G->C dimension

        p1 = (lpnp->RGB_Gx * g) / 255;
        p2 = (lpnp->RGB_Cx * g) / 255;
        Est_x = ((p2 - p1) * b) / g + p1;
        p1 = (lpnp->RGB_Gy * g) / 255;
        p2 = (lpnp->RGB_Cy * g) / 255;
        Est_y = ((p2 - p1) * b) / g + p1;

    }
    else {                          // B->C dimension

        p1 = (lpnp->RGB_Bx * b) / 255;
        p2 = (lpnp->RGB_Cx * b) / 255;
        Est_x = ((p2 - p1) * g) / b + p1;
        p1 = (lpnp->RGB_By * b) / 255;
        p2 = (lpnp->RGB_Cy * b) / 255;
        Est_y = ((p2 - p1) * g) / b + p1;

    }

    }
    else if( g == 0 ){                  // B->M->R

    if( b >= r ){                   // B->M dimension

        p1 = (lpnp->RGB_Bx * b) / 255;
        p2 = (lpnp->RGB_Mx * b) / 255;
        Est_x = ((p2 - p1) * r) / b + p1;
        p1 = (lpnp->RGB_By * b) / 255;
        p2 = (lpnp->RGB_My * b) / 255;
        Est_y = ((p2 - p1) * r) / b + p1;

    }
    else{                           // R->M dimension

        p1 = (lpnp->RGB_Rx * r) / 255;
        p2 = (lpnp->RGB_Mx * r) / 255;
        Est_x = ((p2 - p1) * b) / r + p1;
        p1 = (lpnp->RGB_Ry * r) / 255;
        p2 = (lpnp->RGB_My * r) / 255;
        Est_y = ((p2 - p1) * b) / r + p1;

    }

    }
    else{                               // G->Y->R

    if( g >= r ){                   // G->Y dimension

        p1 = (lpnp->RGB_Gx * g) / 255;
        p2 = (lpnp->RGB_Yx * g) / 255;
        Est_x = ((p2 - p1) * r) / g + p1;
        p1 = (lpnp->RGB_Gy * g) / 255;
        p2 = (lpnp->RGB_Yy * g) / 255;
        Est_y = ((p2 - p1) * r) / g + p1;

    }
    else{                           // R->Y dimension

        p1 = (lpnp->RGB_Rx * r) / 255;
        p2 = (lpnp->RGB_Yx * r) / 255;
        Est_x = ((p2 - p1) * g) / r + p1;
        p1 = (lpnp->RGB_Ry * r) / 255;
        p2 = (lpnp->RGB_Yy * r) / 255;
        Est_y = ((p2 - p1) * g) / r + p1;

    }

    }

    // Convert origin of Est_x and Est_y to paper color

    Est_x += lpnp->RGB_Wx;
    Est_y += lpnp->RGB_Wy;
    Est_x = Est_x * lpnp->CMY_Wx / lpnp->RGB_Wx;
    Est_y = Est_y * lpnp->CMY_Wy / lpnp->RGB_Wy;
    Est_x -= lpnp->CMY_Wx;
    Est_y -= lpnp->CMY_Wy;

    pc = pm = py = 0;

    if( !((Est_x == 0) && (Est_y == 0)) ){

    // Get deg on CMY color dimension from Est_x and Est_y

    if( Est_x == 0 ){

        if( Est_y > 0 )

        deg = 30000;

        else

        deg = -30000;

    }
    else{

        deg = Est_y / Est_x;

        if( deg > 300 )

        deg = 30000;

        else if( deg  < -300 )

        deg = -30000;

        else

        deg = ( Est_y * 100 ) / Est_x;

    }


    if( Est_x >= 0 ){

        if( deg <= lpnp->CMY_Md )       // M->B dimension

        area = 1;

        else if( deg <= lpnp->CMY_Rd )  // M->R dimension

        area = 2;

        else if( deg <= lpnp->CMY_Yd )  // Y->R dimension

        area = 3;

        else                            // Y->G dimension

        area = 4;

    }
    else{

        if( deg <= lpnp->CMY_Gd )       // Y->G dimension

        area = 4;

        else if( deg <= lpnp->CMY_Cd )  // C->G dimension

        area = 5;

        else if( deg <= lpnp->CMY_Bd )  // C->B dimension

        area = 6;

        else                            // M->B dimension

        area = 1;

    }

    switch ( area ){

    case 1:                             // M->B dimension

        val_a = lpnp->CMY_Bx - lpnp->CMY_Mx;
        val_b = lpnp->CMY_By - lpnp->CMY_My;
        val_c = lpnp->CMY_Mx;
        val_d = lpnp->CMY_My;

        val1 = val_b * val_c - val_a * val_d;
        val2 = ( val_b * Est_x - val_a * Est_y ) * 255;

        pm = val2 / val1;

        if( pm < 0 )
        pm = 0;

        val1 = val_a * val_d - val_b * val_c;
        val2 = ( val_d * Est_x - val_c * Est_y ) * 255;

        pc = val2 / val1;

        if( pc < 0 )
        pc = 0;

        if( pc > 255 )
        pc = 255;

        hosei = lpnp->BlueHosei[pc];

        pc += hosei;
        pm += hosei;

        if( pc > 255 )
        pc = 255;

        if( pm > 255 )
        pm = 255;

        break;

    case 2:                             // M->R dimension

        val_a = lpnp->CMY_Rx - lpnp->CMY_Mx;
        val_b = lpnp->CMY_Ry - lpnp->CMY_My;
        val_c = lpnp->CMY_Mx;
        val_d = lpnp->CMY_My;

        val1 = val_b * val_c - val_a * val_d;
        val2 = ( val_b * Est_x - val_a * Est_y ) * 255;

        pm = val2 / val1;

        if( pm < 0 )
        pm = 0;

        val1 = val_a * val_d - val_b * val_c;
        val2 = ( val_d * Est_x - val_c * Est_y ) * 255;

        py = val2 / val1;

        if( py < 0 )
        py = 0;

        if( py > 255 )
        py = 255;

        hosei = lpnp->RedHosei[py];

        py += hosei;
        pm += hosei;

        if( pm > 255 )
        pm = 255;

        if( py > 255 )
        py = 255;

        break;

    case 3:                             // Y->R dimension

        val_a = lpnp->CMY_Rx - lpnp->CMY_Yx;
        val_b = lpnp->CMY_Ry - lpnp->CMY_Yy;
        val_c = lpnp->CMY_Yx;
        val_d = lpnp->CMY_Yy;

        val1 = val_b * val_c - val_a * val_d;
        val2 = ( val_b * Est_x - val_a * Est_y ) * 255;

        py = val2 / val1;

        if( py < 0 )
        py = 0;

        val1 = val_a * val_d - val_b * val_c;
        val2 = ( val_d * Est_x - val_c * Est_y ) * 255;

        pm = val2 / val1;

        if( pm < 0 )
        pm = 0;

        if( pm > 255 )
        pm = 255;

        hosei = lpnp->RedHosei[pm];

        py += hosei;
        pm += hosei;

        if( pm > 255 )
        pm = 255;

        if( py > 255 )
        py = 255;

        break;

    case 4:                             // Y->G dimension

        val_a = lpnp->CMY_Gx - lpnp->CMY_Yx;
        val_b = lpnp->CMY_Gy - lpnp->CMY_Yy;
        val_c = lpnp->CMY_Yx;
        val_d = lpnp->CMY_Yy;

        val1 = val_b * val_c - val_a * val_d;
        val2 = ( val_b * Est_x - val_a * Est_y ) * 255;

        py = val2 / val1;

        if( py < 0 )
        py = 0;

        val1 = val_a * val_d - val_b * val_c;
        val2 = ( val_d * Est_x - val_c * Est_y ) * 255;

        pc = val2 / val1;

        if( pc < 0 )
        pc = 0;

        if( pc > 255 )
        pc = 255;

        hosei = lpnp->GreenHosei[pc];

        py += hosei;
        pc += hosei;

        if( pc > 255 )
        pc = 255;

        if( py > 255 )
        py = 255;

        break;

    case 5:                             // C->G dimension

        val_a = lpnp->CMY_Gx - lpnp->CMY_Cx;
        val_b = lpnp->CMY_Gy - lpnp->CMY_Cy;
        val_c = lpnp->CMY_Cx;
        val_d = lpnp->CMY_Cy;

        val1 = val_b * val_c - val_a * val_d;
        val2 = ( val_b * Est_x - val_a * Est_y ) * 255;

        pc = val2 / val1;

        if( pc < 0 )
        pc = 0;

        val1 = val_a * val_d - val_b * val_c;
        val2 = ( val_d * Est_x - val_c * Est_y ) * 255;

        py = val2 / val1;

        if( py < 0 )
        py = 0;

        if( py > 255 )
        py = 255;

        // Dwnsity adjustment for green
        hosei = lpnp->GreenHosei[py];

        py += hosei;
        pc += hosei;

        if( pc > 255 )
        pc = 255;

        if( py > 255 )
        py = 255;

        break;

    case 6:                             // C->B dimension

        val_a = lpnp->CMY_Bx - lpnp->CMY_Cx;
        val_b = lpnp->CMY_By - lpnp->CMY_Cy;
        val_c = lpnp->CMY_Cx;
        val_d = lpnp->CMY_Cy;

        val1 = val_b * val_c - val_a * val_d;
        val2 = ( val_b * Est_x - val_a * Est_y ) * 255;

        pc = val2 / val1;

        if( pc < 0 )
        pc = 0;

        val1 = val_a * val_d - val_b * val_c;
        val2 = ( val_d * Est_x - val_c * Est_y ) * 255;

        pm = val2 / val1;

        if( pm < 0 )
        pm = 0;

        if( pm > 255 )
        pm = 255;

        hosei = lpnp->BlueHosei[pm];

        pc += hosei;
        pm += hosei;

        if( pc > 255 )
        pc = 255;

        if( pm > 255 )
        pm = 255;

    } // switch area

    }

    // Add pk to color

    k = pc;

    if( k < pm )
    k = pm;

    if( k < py )
    k = py;

    r = ( pk  + k > 255) ? 255 - k : pk;

    pk -= r;
    pc += r;
    pm += r;
    py += r;


    // Extract K and adjust to other color for its extracting value

    if (bPlaneSendOrderCMYK(lpnp)) {

    int min_p;
    BYTE ucr_sub, ucr_div;

    min_p = min( py, pm );
    min_p = min( min_p, pc );

#ifdef BLACK_RIBBON_HACK
    if( min_p == 255 ){
        pk = 255;
        pc = pm = py = 0;
    }
    else{
#endif // BLACK_RIBBOM_HACK

    pk += lpnp->KuroTBL[min_p];
    pk = ( pk > 255 ) ? 255 : pk;

    ucr_sub = lpnp->UcrTBL[min_p];
    ucr_div = 255 - ucr_sub;

    py = (BYTE)((UINT)(py - ucr_sub) * lpnp->YellowUcr / ucr_div);
    pm = (BYTE)((UINT)(pm - ucr_sub) * 255 / ucr_div);
    pc = (BYTE)((UINT)(pc - ucr_sub) * 255 / ucr_div);

#ifdef BLACK_RIBBON_HACK
    }
#endif // BLACK_RIBBON_HACK

    }

    py = 255 - py;
    pm = 255 - pm;
    pc = 255 - pc;
    pk = 255 - pk;

    *ppy = (BYTE)py;
    *ppm = (BYTE)pm;
    *ppc = (BYTE)pc;
    *ppk = (BYTE)pk;

    return TRUE;
}
/*************************** Function Header *******************************
 *  bBusinessConvert
 *
 *  Convert RGB to CMYK for business graphics.
 *
 *
 * HISTORY:
 *  24 Jun 1996    -by-    Sueya Sugihara    [sueyas]
 *     Created.
 *
 ***************************************************************************/
BOOL bBusinessConvert(
PDEVOBJ pdevobj,
BYTE bRed,
BYTE bGreen,
BYTE bBlue,
BYTE *ppy,
BYTE *ppm,
BYTE *ppc,
BYTE *ppk)
{
    int    py, pm, pc, pk;
    int    min_p;
    BYTE   ucr_sub, ucr_div;
    PCURRENTSTATUS lpnp;

    lpnp = (PCURRENTSTATUS)MINIDEV_DATA(pdevobj);

    // Simple convert RGB to CMY

    py = 255 - bBlue;
    pm = 255 - bGreen;
    pc = 255 - bRed;
    pk = 0;

    // Extract K and adjust to other color for its extracting value

    // Extract pk from py, pm and pc by using followings, and erase black element.

    // When this media is 3 plane type, we do not extract black.

    if (bPlaneSendOrderCMYK(lpnp)) {

    min_p = min( py, pm );
    min_p = min( min_p, pc );

#ifdef BLACK_RIBBON_HACK
    if( min_p == 255 ){
        pk = 255;
        pc = pm = py = 0;
    }
    else{
#endif // BLACK_RIBBON_HACK

    pk = lpnp->KuroTBL[min_p];

    ucr_sub = lpnp->UcrTBL[min_p];

    ucr_div = 255 - ucr_sub;

    py = (BYTE)((UINT)(py - ucr_sub) * lpnp->YellowUcr / ucr_div);
    pm = (BYTE)((UINT)(pm - ucr_sub) * 255 / ucr_div);
    pc = (BYTE)((UINT)(pc - ucr_sub) * 255 / ucr_div);

#ifdef BLACK_RIBBON_HACK
    }
#endif // BLACK_RIBBON_HACK

    }

    py = 255 - py;
    pm = 255 - pm;
    pc = 255 - pc;
    pk = 255 - pk;

    *ppy = (BYTE)py;
    *ppm = (BYTE)pm;
    *ppc = (BYTE)pc;
    *ppk = (BYTE)pk;

    return TRUE;
}

/*************************** Function Header *******************************
 *  bCharacterConvert
 *
 *  Convert RGB to CMYK for character graphics.
 *
 *
 * HISTORY:
 *  24 Jun 1996    -by-    Sueya Sugihara    [sueyas]
 *     Created.
 *
 ***************************************************************************/
BOOL bCharacterConvert(
PDEVOBJ pdevobj,
BYTE bRed,
BYTE bGreen,
BYTE bBlue,
BYTE *ppy,
BYTE *ppm,
BYTE *ppc,
BYTE *ppk)
{
    int    py, pm, pc, pk;
    int    min_p;
    BYTE   ucr_sub, ucr_div;
    PCURRENTSTATUS lpnp;

    lpnp = (PCURRENTSTATUS)MINIDEV_DATA(pdevobj);

    // Simple convert RGB to CMY

    py = 255 - bBlue;
    pm = 255 - bGreen;
    pc = 255 - bRed;
    pk = 0;

    // Extract K and adjust to other color for its extracting value

    // Extract pk from py, pm and pc by using followings, and erase black element.

    // When this media is 3 plane type, we do not extract black.

    if (bPlaneSendOrderCMYK(lpnp)) {

    min_p = min( py, pm );
    min_p = min( min_p, pc );

    if( min_p == 255 ){

        pk = 255;
        pc = pm = py = 0;

    }
    else{

        pk = lpnp->KuroTBL[min_p];

        ucr_sub = lpnp->UcrTBL[min_p];

        ucr_div = 255 - ucr_sub;

        py = (BYTE)((UINT)(py - ucr_sub) * lpnp->YellowUcr / ucr_div);
        pm = (BYTE)((UINT)(pm - ucr_sub) * 255 / ucr_div);
        pc = (BYTE)((UINT)(pc - ucr_sub) * 255 / ucr_div);

    }
    }

    py = 255 - py;
    pm = 255 - pm;
    pc = 255 - pc;
    pk = 255 - pk;

    *ppy = (BYTE)py;
    *ppm = (BYTE)pm;
    *ppc = (BYTE)pc;
    *ppk = (BYTE)pk;

    return TRUE;
}
/*************************** Function Header *******************************
 *  bMonoConvert
 *
 *  Convert RGB to Grayscale.
 *
 *
 * HISTORY:
 *  24 Jun 1996    -by-    Sueya Sugihara    [sueyas]
 *     Created.
 *
 ***************************************************************************/
BOOL bMonoConvert(
PDEVOBJ pdevobj,
BYTE bRed,
BYTE bGreen,
BYTE bBlue,
BYTE *ppk)
{
    int    mono;

    mono = ( 30 * bRed + 59 * bGreen + 11 * bBlue ) / 100;

    *ppk = 0xff - (BYTE)( mono & 0xff );


    return TRUE;

}


/*************************** Function Header *******************************
 *  cVDColorDither
 *
 *  VD Color Dither processing
 *
 *
 * HISTORY:
 *  11 Jan 1999    -by-    Yoshitaka Oku    [yoshitao]
 *     Created.
 *
 *    BYTE Color : Plane Color <Yellow, Cyan, Magenta, Black>
 *    BYTE c     : oliginal tone of the pixel
 *    int  x     : X position of the pixel
 *    int  y     : Y position of the pixel
 *
 ***************************************************************************/
cVDColorDither(
BYTE Color,
BYTE c,
int  x,
int  y)
{
    int   m, n;
    short Base;
    BYTE  Tone;
    BYTE  C_Thresh, Thresh;
    short AdjustedColor;
    BYTE  TempTone;
    BYTE  BaseTone;

    switch (Color) {
        case Yellow:
            Base = 112;
            m = n = 12;
            break;

        case Cyan:
        case Magenta:
            Base = 208;
            m = n = 40;
            break;

        case Black:
            Base = 96;
            m = n = 24;
            break;
    }

    Tone = 0;                   /* Clear Tone value */
    c = VD_ColorAdjustTable[Color][c];  /* Convert orignal color */ 
    if (c != 0) {
        C_Thresh = (VD_DitherTable[Color][y % m][x % n]);
        if ( C_Thresh < 16 )
            Thresh = 1;
        else {
            C_Thresh -= 16;
            Thresh = (C_Thresh >> 2) + 1;
        }
        AdjustedColor = VD_ExpandValueTable[Color][c] - 1;
        if ( AdjustedColor < Base )
            TempTone = ( AdjustedColor >> 4 ) + 1;
        else {
            AdjustedColor -= Base;
            TempTone = ( AdjustedColor >> 2 ) + ( Base >> 4 ) + 1;
        }
        BaseTone = VD_ToneOptimaizeTable[Color][TempTone].base;
        if ( BaseTone > Thresh ) {
            Tone = 15;
        } else {
            if ( BaseTone == Thresh ) {
                if ( BaseTone == 1 )  {
                    if (( AdjustedColor & 0x0f ) >= C_Thresh )
                        Tone = VD_ToneOptimaizeTable[Color][(( AdjustedColor >> 4) & 0x0f )+ 1 ].offset;
                    else
                        Tone = VD_ToneOptimaizeTable[Color][( AdjustedColor >> 4) & 0x0f ].offset ;	
                } else {
                    if ((AdjustedColor & 0x03) >= (C_Thresh & 0x03))
                        Tone = VD_ToneOptimaizeTable[Color][TempTone].offset;
                    else
                        if (VD_ToneOptimaizeTable[Color][TempTone -1].base == BaseTone)
                            Tone = VD_ToneOptimaizeTable[Color][TempTone -1].offset;
                }
            }
        }
    }
    return (Tone);
}





/*************************** Function Header *******************************
 *  bDitherProcess
 *
 *  Dither processing
 *
 *
 * HISTORY:
 *  24 Jun 1996    -by-    Sueya Sugihara    [sueyas]
 *     Created.
 *
 ***************************************************************************/
BOOL bDitherProcess(
PDEVOBJ pdevobj,
int  x,
BYTE py,
BYTE pm,
BYTE pc,
BYTE pk,
BYTE *pby,
BYTE *pbm,
BYTE *pbc,
BYTE *pbk)
{

    PCURRENTSTATUS lpnp;
    BYTE           rm;

    lpnp = (PCURRENTSTATUS)MINIDEV_DATA(pdevobj);


    if( lpnp->iDither == DITHER_VD ){

    // Yellow
    *pby = (BYTE)cVDColorDither(Yellow, (BYTE)(255 - py), x, lpnp->y);

    // Magenta
    *pbm = (BYTE)cVDColorDither(Magenta, (BYTE)(255 - pm), x, lpnp->y);

    // Cyan
    *pbc = (BYTE)cVDColorDither(Cyan, (BYTE)(255 - pc), x, lpnp->y);

    // Black
    *pbk = (BYTE)cVDColorDither(Black, (BYTE)(255 - pk), x, lpnp->y);

    }else if( lpnp->iDither == DITHER_DYE ){

    rm = DYE_NewTable[lpnp->y % DYE_MaxY][x % DYE_MaxX];

    // Yellow
    *pby = ( (255 - py) / kToneLevel ) + ( ( ( (255 - py) % kToneLevel ) > rm ) ? 1 : 0 );

    // Magenta
    *pbm = ( (255 - pm) / kToneLevel ) + ( ( ( (255 - pm) % kToneLevel ) > rm ) ? 1 : 0 );

    // Cyan
    *pbc = ( (255 - pc) / kToneLevel ) + ( ( ( (255 - pc) % kToneLevel ) > rm ) ? 1 : 0 );

    // Black
    *pbk = 0;

    }else if( lpnp->iDither == DITHER_HIGH ){

    // Yellow
    rm = H_NewTable[Yellow][lpnp->y % H_MaxY[Yellow]][x % H_MaxX[Yellow]];

    *pby = ( py <= rm ) ? 1 : 0;

    // Magenta
    rm = H_NewTable[Magenta][lpnp->y % H_MaxY[Magenta]][x % H_MaxX[Magenta]];

    *pbm = ( pm <= rm ) ? 1 : 0;

    // Cyan
    rm = H_NewTable[Cyan][lpnp->y % H_MaxY[Cyan]][x % H_MaxX[Cyan]];

    *pbc = ( pc <= rm ) ? 1 : 0;

    // Black
    rm = H_NewTable[Black][lpnp->y % H_MaxY[Black]][x % H_MaxX[Black]];

    if( lpnp->iTextQuality == CMDID_TEXTQUALITY_PHOTO )
        *pbk = ( pk < rm ) ? 1 : 0;
    else
        *pbk = ( pk <= rm ) ? 1 : 0;

    }else if( lpnp->iDither == DITHER_LOW ){

    // Yellow
    rm = L_NewTable[Yellow][lpnp->y % L_MaxY[Yellow]][x % L_MaxX[Yellow]];

    *pby = ( py <= rm ) ? 1 : 0;

    // Magenta
    rm = L_NewTable[Magenta][lpnp->y % L_MaxY[Magenta]][x % L_MaxX[Magenta]];

    *pbm = ( pm <= rm ) ? 1 : 0;

    // Cyan
    rm = L_NewTable[Cyan][lpnp->y % L_MaxY[Cyan]][x % L_MaxX[Cyan]];

    *pbc = ( pc <= rm ) ? 1 : 0;

    // Black
    rm = L_NewTable[Black][lpnp->y % L_MaxY[Black]][x % L_MaxX[Black]];

    if( lpnp->iTextQuality == CMDID_TEXTQUALITY_PHOTO )
        *pbk = ( pk < rm ) ? 1 : 0;
    else
        *pbk = ( pk <= rm ) ? 1 : 0;

    }else{ // DITHER_HIGH_DIV2

    // Yellow
    rm = H_NewTable[Yellow][(lpnp->y/2) % H_MaxY[Yellow]][(x/2) % H_MaxX[Yellow]];

    *pby = ( py <= rm ) ? 1 : 0;

    // Magenta
    rm = H_NewTable[Magenta][(lpnp->y/2) % H_MaxY[Magenta]][(x/2) % H_MaxX[Magenta]];

    *pbm = ( pm <= rm ) ? 1 : 0;

    // Cyan
    rm = H_NewTable[Cyan][(lpnp->y/2) % H_MaxY[Cyan]][(x/2) % H_MaxX[Cyan]];

    *pbc = ( pc <= rm ) ? 1 : 0;

    // Black
    rm = H_NewTable[Black][(lpnp->y/2) % H_MaxY[Black]][(x/2) % H_MaxX[Black]];

    if( lpnp->iTextQuality == CMDID_TEXTQUALITY_PHOTO )
        *pbk = ( pk < rm ) ? 1 : 0;
    else
        *pbk = ( pk <= rm ) ? 1 : 0;
    }


    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\alpsres\dtable.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/





static int H_MaxX[4] =
{
    15, 18, 68, 68        //YCMK
};
static int H_MaxY[4] =
{
    10, 12, 68, 68        //YCMK
};
static int L_MaxX[4] =
{
    12, 9, 20, 20         //YCMK
};
static int L_MaxY[4] =
{
    12, 9, 20, 20         //YCMK
};

#define M_MaxX   14
#define M_MaxY   14
#define OHP_MaxX  8
#define OHP_MaxY  8
#define DYE_MaxX  17
#define DYE_MaxY  17
#define kToneLevel 17

static unsigned char H_NewTable[4][68][68] =
{
 { // Yellow
  {1,42,77,39,1,1,19,52,16,1,1,29,62,26,1},
  {3,138,177,154,8,8,133,159,144,1,1,133,169,149,3},
  {85,200,253,230,95,80,195,235,220,90,82,197,243,225,93},
  {85,189,205,218,95,80,182,202,207,90,82,184,202,212,93},
  {1,103,133,110,1,1,98,118,105,1,1,100,128,108,1},
  {1,24,57,21,1,1,36,70,34,1,1,14,47,11,1},
  {1,133,164,146,1,1,136,174,151,6,6,133,156,141,1},
  {82,195,240,223,93,82,197,248,228,95,80,192,233,220,87},
  {82,182,202,210,93,82,187,202,215,95,80,179,200,205,87},
  {1,98,123,108,1,1,100,131,110,1,1,95,113,105,1}
 },
 { // Cyan
  {138,90,29,26,52,210,141,93,34,34,54,215,144,95,24,24,49,205},
  {105,1,1,26,238,159,108,16,16,34,243,161,110,6,6,24,233,159},
  {65,1,1,179,151,123,70,16,16,184,154,128,75,6,6,172,149,121},
  {44,59,223,146,100,47,47,62,228,149,103,39,39,57,218,144,98,44},
  {44,251,167,116,8,8,47,253,169,118,1,1,39,248,164,113,19,19},
  {197,156,133,82,8,8,202,156,136,87,1,1,192,154,131,77,19,19},
  {141,93,36,36,54,218,144,95,24,24,49,207,138,90,29,31,52,212},
  {108,14,14,36,246,161,110,3,3,24,235,159,105,1,1,31,240,159},
  {72,14,14,189,154,128,75,3,3,174,149,121,67,1,1,182,151,126},
  {47,62,230,149,103,39,39,57,220,144,98,42,42,59,225,146,100,47},
  {47,253,169,118,21,21,39,248,164,113,1,1,42,251,167,116,11,11},
  {205,156,136,87,21,21,195,154,131,80,1,1,200,156,133,85,11,11}
 },
 { // Magenta
  {19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19},
  {253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47},
  {182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189},
  {131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98},
  {1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70},
  {52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31},
  {195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207},
  {138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154},
  {77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98},
  {29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8},
  {205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220},
  {151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164},
  {95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110},
  {14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14},
  {223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246},
  {167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179},
  {113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126},
  {6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6},
  {233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57},
  {177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197},
  {123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141},
  {11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82},
  {42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21},
  {184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200},
  {133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144},
  {62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87},
  {39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19},
  {215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225},
  {159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172},
  {103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116},
  {1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1},
  {218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230},
  {161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174},
  {105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121},
  {16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16},
  {248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49},
  {182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192},
  {128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136},
  {3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72},
  {54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34},
  {197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210},
  {138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156},
  {80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100},
  {26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6},
  {205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220},
  {136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164},
  {93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108},
  {11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11},
  {223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243},
  {167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179},
  {113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126},
  {8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8},
  {238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59},
  {177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200},
  {123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141},
  {14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85},
  {44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24},
  {187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202},
  {133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146},
  {65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90},
  {36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16},
  {212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225},
  {156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169},
  {103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116},
  {3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174,161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3},
  {215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118,105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228},
  {161,144,133,126,113,98,77,16,16,16,36,57,233,220,205,189,182,172,159,141,123,110,95,72,3,3,3,21,42,243,223,207,195,174,161,146,133,126,113,100,80,19,19,19,39,59,238,220,205,192,182,169,156,141,123,108,93,70,1,1,1,24,44,246,223,210,197,174},
  {105,87,62,8,8,8,29,49,248,225,212,197,177,164,136,98,131,116,103,85,14,14,14,34,54,228,215,200,184,179,167,154,138,121,105,90,65,6,6,6,26,47,253,225,215,200,177,164,151,136,128,116,103,82,11,11,11,31,52,230,218,202,187,179,167,156,138,118}
 },
 { // Black
  {19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80},
  {184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105},
  {118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90},
  {3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3},
  {3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3},
  {238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174},
  {187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110},
  {136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16},
  {31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16},
  {233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251},
  {215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197},
  {128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159},
  {36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21},
  {77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220},
  {103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200},
  {85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121},
  {8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67},
  {8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82},
  {179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108},
  {113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100},
  {14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14},
  {14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14},
  {248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182},
  {195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116},
  {154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6},
  {24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6},
  {225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240},
  {205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192},
  {123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138},
  {47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26},
  {82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230},
  {105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210},
  {93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126},
  {16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44},
  {16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80},
  {184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105},
  {118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90},
  {1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1},
  {1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1},
  {235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172},
  {187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110},
  {133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19},
  {34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19},
  {233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253},
  {218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197},
  {131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167},
  {39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21},
  {77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223},
  {103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202},
  {87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121},
  {6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62},
  {6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82},
  {177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108},
  {113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98},
  {11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11},
  {11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11},
  {246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182},
  {195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116},
  {149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8},
  {24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8},
  {228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243},
  {207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192},
  {123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144},
  {52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29},
  {82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126,95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230},
  {108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42,19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212},
  {95,110,187,200,103,182,246,230,82,3,3,21,39,14,14,144,123,90,118,197,215,108,177,240,225,80,19,19,34,67,8,8,149,126,93,110,187,202,103,182,248,230,82,1,1,21,36,11,11,138,123,90,118,197,218,108,179,243,228,80,16,16,31,62,6,6,154,126},
  {19,19,133,121,85,116,195,210,105,174,238,223,77,14,14,29,52,1,1,159,128,98,113,192,205,105,184,253,233,82,8,8,24,44,16,16,136,121,87,116,195,212,108,172,235,220,77,11,11,26,47,3,3,167,131,100,113,192,207,105,184,251,233,82,6,6,24,42}
 }
};

static unsigned char L_NewTable[4][20][20] =
{
 { // Yellow
  {254,254,239,182,133,133,243,243,228,171,122,122},
  {239,239,224,182,118,118,228,228,213,171,107,107},
  {224,224,209,167,118,118,213,213,205,152,107,107},
  {201,201,186,167,103,103,190,190,186,152,92,92},
  {148,148,58,43,28,28,137,137,47,32,9,9},
  {88,84,58,43,24,24,65,62,47,32,5,5},
  {246,246,231,175,126,126,250,250,235,179,130,130},
  {231,231,216,175,111,111,235,235,220,179,114,114},
  {216,216,205,156,111,111,220,220,209,163,114,114},
  {194,194,186,156,96,96,197,197,186,160,99,99},
  {141,141,50,35,13,13,145,145,54,39,20,20},
  {73,69,50,35,1,1,81,77,54,39,16,16}
 },
 { // Cyan
  {34,27,23,199,247,247,217,93,78},
  {12,9,9,195,236,236,217,122,71},
  {12,1,1,133,188,181,140,129,64},
  {173,166,144,89,56,45,42,115,151},
  {232,228,214,86,38,31,31,107,210},
  {254,254,221,75,20,5,5,104,206},
  {239,239,221,67,16,1,1,100,195},
  {192,184,148,148,159,155,144,111,137},
  {49,53,60,203,225,225,214,96,82}
 },
 { // Magenta
  {13,253,253,219,182,137,137,223,223,208,163,118,118,152,144,114,107,54,39,13},
  {9,242,234,219,174,129,129,201,193,186,156,58,58,69,69,92,80,54,31,9},
  {137,227,227,212,167,122,122,148,140,110,103,50,24,5,5,246,246,216,178,133},
  {129,204,197,189,159,62,62,65,65,77,73,46,16,1,1,238,231,216,171,125},
  {122,152,144,114,107,54,39,13,13,253,253,219,182,137,137,223,223,208,163,118},
  {62,69,69,92,80,54,31,9,9,242,234,219,174,129,129,201,193,186,156,58},
  {39,5,5,246,246,216,178,133,133,227,227,212,167,122,122,148,140,110,103,50},
  {31,1,1,238,231,216,171,125,125,204,197,189,159,62,62,65,65,77,73,46},
  {182,137,137,223,223,208,163,118,118,152,144,114,107,54,39,13,13,253,253,219},
  {174,129,129,201,193,186,156,58,58,69,69,92,80,54,31,9,9,242,234,219},
  {167,122,122,148,140,110,103,50,24,5,5,246,246,216,178,133,133,227,227,212},
  {159,62,62,65,65,77,73,46,16,1,1,238,231,216,171,125,125,204,197,189},
  {107,54,39,13,13,253,253,219,182,137,137,223,223,208,163,118,118,152,144,114},
  {80,54,31,9,9,242,234,219,174,129,129,201,193,186,156,58,58,69,69,92},
  {246,216,178,133,133,227,227,212,167,122,122,148,140,110,103,50,24,5,5,246},
  {231,216,171,125,125,204,197,189,159,62,62,65,65,77,73,46,16,1,1,238},
  {223,208,163,118,118,152,144,114,107,54,39,5,5,253,253,219,182,137,137,223},
  {193,186,156,58,58,69,69,92,80,54,31,1,1,242,234,219,174,129,129,201},
  {140,110,103,50,24,5,5,246,246,216,178,133,133,227,227,212,167,122,122,148},
  {65,77,73,46,16,1,1,238,231,216,171,125,125,204,197,189,159,62,62,65}
 },
 { // Black
  {162,162,170,202,194,186,154,154,6,78,118,114,102,26,30,90,134,134,106,38},
  {22,74,66,54,46,14,146,146,182,230,234,242,246,254,30,82,122,122,106,38},
  {34,94,142,142,106,42,166,166,178,226,222,210,162,158,2,78,110,110,98,26},
  {34,86,130,126,106,42,18,70,62,50,46,10,150,150,174,218,214,238,242,250},
  {6,78,118,114,102,26,30,90,134,134,106,38,162,162,170,202,194,186,154,154},
  {182,230,234,242,246,254,30,82,122,122,106,38,22,74,66,54,46,14,146,146},
  {178,226,222,210,162,158,2,78,110,110,98,26,34,94,142,142,106,42,166,166},
  {62,50,46,10,150,150,174,218,214,238,242,250,34,86,130,126,106,42,18,70},
  {134,134,106,38,162,162,170,202,194,186,154,154,6,78,118,114,102,26,30,90},
  {122,122,106,38,22,74,66,54,46,14,146,146,182,230,234,242,246,254,30,82},
  {110,110,98,26,34,94,142,142,106,42,166,166,178,226,222,210,162,158,2,78},
  {214,238,242,250,34,86,130,126,106,42,18,70,62,50,46,10,150,150,174,218},
  {194,186,154,154,6,78,118,114,102,26,30,90,134,134,106,38,162,162,170,202},
  {46,14,146,146,182,230,234,242,246,254,30,82,122,122,106,38,22,74,66,54},
  {106,42,166,166,178,226,222,210,162,158,2,78,110,110,98,26,34,94,142,142},
  {106,42,18,70,62,50,46,10,150,150,174,218,214,238,242,250,34,86,130,126},
  {102,26,30,90,134,134,106,38,162,162,170,202,194,186,154,154,6,78,118,114},
  {246,254,30,82,122,122,106,38,22,74,66,54,46,14,146,146,182,230,234,242},
  {162,158,2,78,110,110,98,26,34,94,142,142,106,42,166,166,178,226,222,210},
  {150,150,174,218,214,238,242,250,34,86,130,126,106,42,18,70,62,50,46,10}
 }
};

static unsigned char M_NewTable[14][14] =
{
 {21,72,154,149,93,67,11,19,70,151,146,90,65,8},
 {77,159,200,195,144,138,62,75,156,197,192,141,136,59},
 {164,205,251,246,230,189,133,161,202,248,243,228,187,131},
 {169,210,240,235,225,184,128,167,207,238,233,223,182,126},
 {98,174,220,215,179,123,87,95,172,218,212,177,121,85},
 {36,103,108,113,118,82,31,34,100,105,110,116,80,29},
 {16,42,47,52,57,26,6,14,39,44,49,54,24,255},
 {19,70,151,146,90,65,8,21,72,154,149,93,67,11},
 {75,156,197,192,141,136,59,77,159,200,195,144,138,62},
 {161,202,248,243,228,187,131,164,205,251,246,230,189,133},
 {167,207,238,233,223,182,126,169,210,240,235,225,184,128},
 {95,172,218,212,177,121,85,98,174,220,215,179,123,87},
 {34,100,105,110,116,80,29,36,103,108,113,118,82,31},
 {14,39,44,49,54,24,1,16,42,47,52,57,26,3}
};

static unsigned char OHP_NewTable[8][8] =
{
 {110,94,102,126,146,162,154,130},
 {38,30,22,78,218,226,234,178},
 {46,6,14,86,210,250,242,170},
 {70,54,62,118,186,202,194,138},
 {150,166,158,134,106,90,98,122},
 {222,230,238,182,34,26,18,74},
 {214,254,246,174,42,2,10,82},
 {190,206,198,142,66,50,58,114}
};

static unsigned char DYE_NewTable[17][17] =
{
 {1,14,4,13,1,14,4,10,5,12,15,3,6,13,7,3,15},
 {12,7,16,6,12,5,12,2,14,4,8,13,9,1,17,10,6},
 {3,11,2,11,4,17,7,15,6,17,10,2,16,11,5,9,16},
 {13,5,17,7,14,8,2,9,11,1,6,14,7,3,14,2,10},
 {8,15,3,13,1,10,16,4,15,8,15,4,10,17,5,13,4},
 {1,10,9,5,15,6,11,9,3,13,2,12,8,1,11,8,17},
 {13,5,17,11,3,14,2,17,10,7,16,5,13,6,15,3,9},
 {3,12,2,6,12,7,13,5,12,4,9,14,4,16,10,6,15},
 {14,8,16,9,15,3,8,16,1,15,8,1,12,7,2,12,7},
 {10,4,10,1,6,17,10,5,11,6,11,17,5,15,8,17,1},
 {16,6,13,8,14,9,2,14,3,13,2,9,12,3,11,4,11},
 {3,14,2,16,3,7,13,7,17,5,15,4,10,16,5,15,8},
 {6,11,9,7,10,17,4,11,1,12,8,14,1,7,13,2,14},
 {17,1,15,4,12,1,14,6,16,9,3,9,17,11,5,12,7},
 {10,12,5,13,6,15,5,11,4,12,6,13,6,4,16,9,2},
 {7,3,16,2,10,3,13,2,15,8,17,2,9,14,1,8,16},
 {12,8,10,8,17,9,7,16,9,1,7,11,16,4,11,14,5}
};


static unsigned char VD_ColorAdjustTable[4][256] =
{
/*******************************************************/
/*           Start ColorAdjustTable            */
/*******************************************************/
 {  /* Yellow ColorAdjustTable (256 bytes) */
   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
  48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
  64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
  80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
  96, 97, 98, 99,100,101,102,103,104,105,106,107,108,109,110,111,
 112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,
 128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,
 144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,
 160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,
 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,
 192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,
 208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,
 224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,
 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255},

 {  /* Cyan ColorAdjustTable (256 bytes) */
   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
  48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
  64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
  80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
  96, 97, 98, 99,100,101,102,103,104,105,106,107,108,109,110,111,
 112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,
 128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,
 144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,
 160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,
 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,
 192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,
 208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,
 224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,
 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255},

 {  /* Magenta ColorAdjustTable (256 bytes) */
   0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
  48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
  64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
  80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
  96, 97, 98, 99,100,101,102,103,104,105,106,107,108,109,110,111,
 112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,
 128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,
 144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,
 160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,
 176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,
 192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,
 208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,
 224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,
 240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255},

 {  /* Black ColorAdjustTable (256 bytes) */
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
   0,  0,  0,  0,  0,  1,  1,  2,  3,  4,  5,  6,  8,  9, 11, 13,
  15, 18, 20, 23, 25, 28, 31, 34, 38, 41, 45, 48, 52, 56, 60, 64,
  69, 73, 77, 82, 87, 91, 96,101,106,111,116,121,126,131,136,141,
 146,151,156,161,166,170,175,180,185,189,194,198,202,206,211,214,
 218,222,225,229,232,235,238,240,243,245,247,249,251,253,254,255}
};


static unsigned char VD_DitherTable[4][40][40] =
{
/****************************************************/
/*             Start DitherTable             */
/****************************************************/
 {  /* Yellow DitherTable (144 byte ) */
  { 81,113,129, 93,125,141, 84,116,132, 96,128,144},
  { 33, 49, 97, 45, 61,109, 36, 52,100, 48, 64,112},
  {  1, 17, 65, 13, 29, 77,  4, 20, 68, 16, 32, 80},
  { 89,121,137, 85,117,133, 92,124,140, 88,120,136},
  { 41, 57,105, 37, 53,101, 44, 60,108, 40, 56,104},
  {  9, 25, 73,  5, 21, 69, 12, 28, 76,  8, 24, 72},
  { 83,115,131, 95,127,143, 82,114,130, 94,126,142},
  { 35, 51, 99, 47, 63,111, 34, 50, 98, 46, 62,110},
  {  3, 19, 67, 15, 31, 79,  2, 18, 66, 14, 30, 78},
  { 91,123,139, 87,119,135, 90,122,138, 86,118,134},
  { 43, 59,107, 39, 55,103, 42, 58,106, 38, 54,102},
  { 11, 27, 75,  7, 23, 71, 10, 26, 74,  6, 22, 70}
 },

 {  /* Cyan DitherTable (1600 bytes) */
  { 37, 41, 45, 49,  7, 18, 22, 27, 31, 35, 38, 42, 46, 50,  3, 17, 21, 28, 32, 36, 37, 41, 45, 49,  8, 18, 22, 27, 31, 35, 38, 42, 46, 50,  4, 17, 21, 28, 32, 36},
  { 25, 29, 33, 40, 44, 48, 52, 10, 19, 23, 26, 30, 34, 39, 43, 47, 51, 15, 20, 24, 25, 29, 33, 40, 44, 48, 52,  9, 19, 23, 26, 30, 34, 39, 43, 47, 51, 16, 20, 24},
  {  1, 17, 21, 28, 32, 36, 37, 41, 45, 49,  6, 18, 22, 27, 31, 35, 38, 42, 46, 50,  2, 17, 21, 28, 32, 36, 37, 41, 45, 49,  5, 18, 22, 27, 31, 35, 38, 42, 46, 50},
  { 43, 47, 51, 13, 20, 24, 25, 29, 33, 40, 44, 48, 52, 11, 19, 23, 26, 30, 34, 39, 43, 47, 51, 14, 20, 24, 25, 29, 33, 40, 44, 48, 52, 12, 19, 23, 26, 30, 34, 39},
  { 31, 35, 38, 42, 46, 50,  4, 17, 21, 28, 32, 36, 37, 41, 45, 49,  7, 18, 22, 27, 31, 35, 38, 42, 46, 50,  3, 17, 21, 28, 32, 36, 37, 41, 45, 49,  8, 18, 22, 27},
  { 19, 23, 26, 30, 34, 39, 43, 47, 51, 16, 20, 24, 25, 29, 33, 40, 44, 48, 52, 10, 19, 23, 26, 30, 34, 39, 43, 47, 51, 15, 20, 24, 25, 29, 33, 40, 44, 48, 52,  9},
  { 45, 49,  5, 18, 22, 27, 31, 35, 38, 42, 46, 50,  1, 17, 21, 28, 32, 36, 37, 41, 45, 49,  6, 18, 22, 27, 31, 35, 38, 42, 46, 50,  2, 17, 21, 28, 32, 36, 37, 41},
  { 33, 40, 44, 48, 52, 12, 19, 23, 26, 30, 34, 39, 43, 47, 51, 13, 20, 24, 25, 29, 33, 40, 44, 48, 52, 11, 19, 23, 26, 30, 34, 39, 43, 47, 51, 14, 20, 24, 25, 29},
  { 21, 28, 32, 36, 37, 41, 45, 49,  8, 18, 22, 27, 31, 35, 38, 42, 46, 50,  4, 17, 21, 28, 32, 36, 37, 41, 45, 49,  7, 18, 22, 27, 31, 35, 38, 42, 46, 50,  3, 17},
  { 51, 15, 20, 24, 25, 29, 33, 40, 44, 48, 52,  9, 19, 23, 26, 30, 34, 39, 43, 47, 51, 16, 20, 24, 25, 29, 33, 40, 44, 48, 52, 10, 19, 23, 26, 30, 34, 39, 43, 47},
  { 38, 42, 46, 50,  2, 17, 21, 28, 32, 36, 37, 41, 45, 49,  5, 18, 22, 27, 31, 35, 38, 42, 46, 50,  1, 17, 21, 28, 32, 36, 37, 41, 45, 49,  6, 18, 22, 27, 31, 35},
  { 26, 30, 34, 39, 43, 47, 51, 14, 20, 24, 25, 29, 33, 40, 44, 48, 52, 12, 19, 23, 26, 30, 34, 39, 43, 47, 51, 13, 20, 24, 25, 29, 33, 40, 44, 48, 52, 11, 19, 23},
  {  7, 18, 22, 27, 31, 35, 38, 42, 46, 50,  3, 17, 21, 28, 32, 36, 37, 41, 45, 49,  8, 18, 22, 27, 31, 35, 38, 42, 46, 50,  4, 17, 21, 28, 32, 36, 37, 41, 45, 49},
  { 44, 48, 52, 10, 19, 23, 26, 30, 34, 39, 43, 47, 51, 15, 20, 24, 25, 29, 33, 40, 44, 48, 52,  9, 19, 23, 26, 30, 34, 39, 43, 47, 51, 16, 20, 24, 25, 29, 33, 40},
  { 32, 36, 37, 41, 45, 49,  6, 18, 22, 27, 31, 35, 38, 42, 46, 50,  2, 17, 21, 28, 32, 36, 37, 41, 45, 49,  5, 18, 22, 27, 31, 35, 38, 42, 46, 50,  1, 17, 21, 28},
  { 20, 24, 25, 29, 33, 40, 44, 48, 52, 11, 19, 23, 26, 30, 34, 39, 43, 47, 51, 14, 20, 24, 25, 29, 33, 40, 44, 48, 52, 12, 19, 23, 26, 30, 34, 39, 43, 47, 51, 13},
  { 46, 50,  4, 17, 21, 28, 32, 36, 37, 41, 45, 49,  7, 18, 22, 27, 31, 35, 38, 42, 46, 50,  3, 17, 21, 28, 32, 36, 37, 41, 45, 49,  8, 18, 22, 27, 31, 35, 38, 42},
  { 34, 39, 43, 47, 51, 16, 20, 24, 25, 29, 33, 40, 44, 48, 52, 10, 19, 23, 26, 30, 34, 39, 43, 47, 51, 15, 20, 24, 25, 29, 33, 40, 44, 48, 52,  9, 19, 23, 26, 30},
  { 22, 27, 31, 35, 38, 42, 46, 50,  1, 17, 21, 28, 32, 36, 37, 41, 45, 49,  6, 18, 22, 27, 31, 35, 38, 42, 46, 50,  2, 17, 21, 28, 32, 36, 37, 41, 45, 49,  5, 18},
  { 52, 12, 19, 23, 26, 30, 34, 39, 43, 47, 51, 13, 20, 24, 25, 29, 33, 40, 44, 48, 52, 11, 19, 23, 26, 30, 34, 39, 43, 47, 51, 14, 20, 24, 25, 29, 33, 40, 44, 48},
  { 37, 41, 45, 49,  8, 18, 22, 27, 31, 35, 38, 42, 46, 50,  4, 17, 21, 28, 32, 36, 37, 41, 45, 49,  7, 18, 22, 27, 31, 35, 38, 42, 46, 50,  3, 17, 21, 28, 32, 36},
  { 25, 29, 33, 40, 44, 48, 52,  9, 19, 23, 26, 30, 34, 39, 43, 47, 51, 16, 20, 24, 25, 29, 33, 40, 44, 48, 52, 10, 19, 23, 26, 30, 34, 39, 43, 47, 51, 15, 20, 24},
  {  2, 17, 21, 28, 32, 36, 37, 41, 45, 49,  5, 18, 22, 27, 31, 35, 38, 42, 46, 50,  1, 17, 21, 28, 32, 36, 37, 41, 45, 49,  6, 18, 22, 27, 31, 35, 38, 42, 46, 50},
  { 43, 47, 51, 14, 20, 24, 25, 29, 33, 40, 44, 48, 52, 12, 19, 23, 26, 30, 34, 39, 43, 47, 51, 13, 20, 24, 25, 29, 33, 40, 44, 48, 52, 11, 19, 23, 26, 30, 34, 39},
  { 31, 35, 38, 42, 46, 50,  3, 17, 21, 28, 32, 36, 37, 41, 45, 49,  8, 18, 22, 27, 31, 35, 38, 42, 46, 50,  4, 17, 21, 28, 32, 36, 37, 41, 45, 49,  7, 18, 22, 27},
  { 19, 23, 26, 30, 34, 39, 43, 47, 51, 15, 20, 24, 25, 29, 33, 40, 44, 48, 52,  9, 19, 23, 26, 30, 34, 39, 43, 47, 51, 16, 20, 24, 25, 29, 33, 40, 44, 48, 52, 10},
  { 45, 49,  6, 18, 22, 27, 31, 35, 38, 42, 46, 50,  2, 17, 21, 28, 32, 36, 37, 41, 45, 49,  5, 18, 22, 27, 31, 35, 38, 42, 46, 50,  1, 17, 21, 28, 32, 36, 37, 41},
  { 33, 40, 44, 48, 52, 11, 19, 23, 26, 30, 34, 39, 43, 47, 51, 14, 20, 24, 25, 29, 33, 40, 44, 48, 52, 12, 19, 23, 26, 30, 34, 39, 43, 47, 51, 13, 20, 24, 25, 29},
  { 21, 28, 32, 36, 37, 41, 45, 49,  7, 18, 22, 27, 31, 35, 38, 42, 46, 50,  3, 17, 21, 28, 32, 36, 37, 41, 45, 49,  8, 18, 22, 27, 31, 35, 38, 42, 46, 50,  4, 17},
  { 51, 16, 20, 24, 25, 29, 33, 40, 44, 48, 52, 10, 19, 23, 26, 30, 34, 39, 43, 47, 51, 15, 20, 24, 25, 29, 33, 40, 44, 48, 52,  9, 19, 23, 26, 30, 34, 39, 43, 47},
  { 38, 42, 46, 50,  1, 17, 21, 28, 32, 36, 37, 41, 45, 49,  6, 18, 22, 27, 31, 35, 38, 42, 46, 50,  2, 17, 21, 28, 32, 36, 37, 41, 45, 49,  5, 18, 22, 27, 31, 35},
  { 26, 30, 34, 39, 43, 47, 51, 13, 20, 24, 25, 29, 33, 40, 44, 48, 52, 11, 19, 23, 26, 30, 34, 39, 43, 47, 51, 14, 20, 24, 25, 29, 33, 40, 44, 48, 52, 12, 19, 23},
  {  8, 18, 22, 27, 31, 35, 38, 42, 46, 50,  4, 17, 21, 28, 32, 36, 37, 41, 45, 49,  7, 18, 22, 27, 31, 35, 38, 42, 46, 50,  3, 17, 21, 28, 32, 36, 37, 41, 45, 49},
  { 44, 48, 52,  9, 19, 23, 26, 30, 34, 39, 43, 47, 51, 16, 20, 24, 25, 29, 33, 40, 44, 48, 52, 10, 19, 23, 26, 30, 34, 39, 43, 47, 51, 15, 20, 24, 25, 29, 33, 40},
  { 32, 36, 37, 41, 45, 49,  5, 18, 22, 27, 31, 35, 38, 42, 46, 50,  1, 17, 21, 28, 32, 36, 37, 41, 45, 49,  6, 18, 22, 27, 31, 35, 38, 42, 46, 50,  2, 17, 21, 28},
  { 20, 24, 25, 29, 33, 40, 44, 48, 52, 12, 19, 23, 26, 30, 34, 39, 43, 47, 51, 13, 20, 24, 25, 29, 33, 40, 44, 48, 52, 11, 19, 23, 26, 30, 34, 39, 43, 47, 51, 14},
  { 46, 50,  3, 17, 21, 28, 32, 36, 37, 41, 45, 49,  8, 18, 22, 27, 31, 35, 38, 42, 46, 50,  4, 17, 21, 28, 32, 36, 37, 41, 45, 49,  7, 18, 22, 27, 31, 35, 38, 42},
  { 34, 39, 43, 47, 51, 15, 20, 24, 25, 29, 33, 40, 44, 48, 52,  9, 19, 23, 26, 30, 34, 39, 43, 47, 51, 16, 20, 24, 25, 29, 33, 40, 44, 48, 52, 10, 19, 23, 26, 30},
  { 22, 27, 31, 35, 38, 42, 46, 50,  2, 17, 21, 28, 32, 36, 37, 41, 45, 49,  5, 18, 22, 27, 31, 35, 38, 42, 46, 50,  1, 17, 21, 28, 32, 36, 37, 41, 45, 49,  6, 18},
  { 52, 11, 19, 23, 26, 30, 34, 39, 43, 47, 51, 14, 20, 24, 25, 29, 33, 40, 44, 48, 52, 12, 19, 23, 26, 30, 34, 39, 43, 47, 51, 13, 20, 24, 25, 29, 33, 40, 44, 48}
 },

 {  /* Magenta DitherTable (1600 bytes) */
  { 49,  1, 17, 24, 28, 32, 33, 37, 41, 45, 50,  8, 18, 23, 27, 31, 34, 38, 42, 46, 49,  2, 17, 24, 28, 32, 33, 37, 41, 45, 50,  7, 18, 23, 27, 31, 34, 38, 42, 46},
  { 21, 25, 29, 36, 40, 44, 48, 51, 12, 19, 22, 26, 30, 35, 39, 43, 47, 52, 15, 20, 21, 25, 29, 36, 40, 44, 48, 51, 11, 19, 22, 26, 30, 35, 39, 43, 47, 52, 16, 20},
  { 33, 37, 41, 45, 50,  5, 18, 23, 27, 31, 34, 38, 42, 46, 49,  3, 17, 24, 28, 32, 33, 37, 41, 45, 50,  6, 18, 23, 27, 31, 34, 38, 42, 46, 49,  4, 17, 24, 28, 32},
  { 48, 51,  9, 19, 22, 26, 30, 35, 39, 43, 47, 52, 14, 20, 21, 25, 29, 36, 40, 44, 48, 51, 10, 19, 22, 26, 30, 35, 39, 43, 47, 52, 13, 20, 21, 25, 29, 36, 40, 44},
  { 18, 23, 27, 31, 34, 38, 42, 46, 49,  2, 17, 24, 28, 32, 33, 37, 41, 45, 50,  7, 18, 23, 27, 31, 34, 38, 42, 46, 49,  1, 17, 24, 28, 32, 33, 37, 41, 45, 50,  8},
  { 30, 35, 39, 43, 47, 52, 15, 20, 21, 25, 29, 36, 40, 44, 48, 51, 11, 19, 22, 26, 30, 35, 39, 43, 47, 52, 16, 20, 21, 25, 29, 36, 40, 44, 48, 51, 12, 19, 22, 26},
  { 42, 46, 49,  3, 17, 24, 28, 32, 33, 37, 41, 45, 50,  6, 18, 23, 27, 31, 34, 38, 42, 46, 49,  4, 17, 24, 28, 32, 33, 37, 41, 45, 50,  5, 18, 23, 27, 31, 34, 38},
  { 14, 20, 21, 25, 29, 36, 40, 44, 48, 51, 10, 19, 22, 26, 30, 35, 39, 43, 47, 52, 13, 20, 21, 25, 29, 36, 40, 44, 48, 51,  9, 19, 22, 26, 30, 35, 39, 43, 47, 52},
  { 28, 32, 33, 37, 41, 45, 50,  7, 18, 23, 27, 31, 34, 38, 42, 46, 49,  1, 17, 24, 28, 32, 33, 37, 41, 45, 50,  8, 18, 23, 27, 31, 34, 38, 42, 46, 49,  2, 17, 24},
  { 40, 44, 48, 51, 11, 19, 22, 26, 30, 35, 39, 43, 47, 52, 16, 20, 21, 25, 29, 36, 40, 44, 48, 51, 12, 19, 22, 26, 30, 35, 39, 43, 47, 52, 15, 20, 21, 25, 29, 36},
  { 50,  6, 18, 23, 27, 31, 34, 38, 42, 46, 49,  4, 17, 24, 28, 32, 33, 37, 41, 45, 50,  5, 18, 23, 27, 31, 34, 38, 42, 46, 49,  3, 17, 24, 28, 32, 33, 37, 41, 45},
  { 22, 26, 30, 35, 39, 43, 47, 52, 13, 20, 21, 25, 29, 36, 40, 44, 48, 51,  9, 19, 22, 26, 30, 35, 39, 43, 47, 52, 14, 20, 21, 25, 29, 36, 40, 44, 48, 51, 10, 19},
  { 34, 38, 42, 46, 49,  1, 17, 24, 28, 32, 33, 37, 41, 45, 50,  8, 18, 23, 27, 31, 34, 38, 42, 46, 49,  2, 17, 24, 28, 32, 33, 37, 41, 45, 50,  7, 18, 23, 27, 31},
  { 47, 52, 16, 20, 21, 25, 29, 36, 40, 44, 48, 51, 12, 19, 22, 26, 30, 35, 39, 43, 47, 52, 15, 20, 21, 25, 29, 36, 40, 44, 48, 51, 11, 19, 22, 26, 30, 35, 39, 43},
  { 17, 24, 28, 32, 33, 37, 41, 45, 50,  5, 18, 23, 27, 31, 34, 38, 42, 46, 49,  3, 17, 24, 28, 32, 33, 37, 41, 45, 50,  6, 18, 23, 27, 31, 34, 38, 42, 46, 49,  4},
  { 29, 36, 40, 44, 48, 51,  9, 19, 22, 26, 30, 35, 39, 43, 47, 52, 14, 20, 21, 25, 29, 36, 40, 44, 48, 51, 10, 19, 22, 26, 30, 35, 39, 43, 47, 52, 13, 20, 21, 25},
  { 41, 45, 50,  8, 18, 23, 27, 31, 34, 38, 42, 46, 49,  2, 17, 24, 28, 32, 33, 37, 41, 45, 50,  7, 18, 23, 27, 31, 34, 38, 42, 46, 49,  1, 17, 24, 28, 32, 33, 37},
  { 12, 19, 22, 26, 30, 35, 39, 43, 47, 52, 15, 20, 21, 25, 29, 36, 40, 44, 48, 51, 11, 19, 22, 26, 30, 35, 39, 43, 47, 52, 16, 20, 21, 25, 29, 36, 40, 44, 48, 51},
  { 27, 31, 34, 38, 42, 46, 49,  3, 17, 24, 28, 32, 33, 37, 41, 45, 50,  6, 18, 23, 27, 31, 34, 38, 42, 46, 49,  4, 17, 24, 28, 32, 33, 37, 41, 45, 50,  5, 18, 23},
  { 39, 43, 47, 52, 14, 20, 21, 25, 29, 36, 40, 44, 48, 51, 10, 19, 22, 26, 30, 35, 39, 43, 47, 52, 13, 20, 21, 25, 29, 36, 40, 44, 48, 51,  9, 19, 22, 26, 30, 35},
  { 49,  2, 17, 24, 28, 32, 33, 37, 41, 45, 50,  7, 18, 23, 27, 31, 34, 38, 42, 46, 49,  1, 17, 24, 28, 32, 33, 37, 41, 45, 50,  8, 18, 23, 27, 31, 34, 38, 42, 46},
  { 21, 25, 29, 36, 40, 44, 48, 51, 11, 19, 22, 26, 30, 35, 39, 43, 47, 52, 16, 20, 21, 25, 29, 36, 40, 44, 48, 51, 12, 19, 22, 26, 30, 35, 39, 43, 47, 52, 15, 20},
  { 33, 37, 41, 45, 50,  6, 18, 23, 27, 31, 34, 38, 42, 46, 49,  4, 17, 24, 28, 32, 33, 37, 41, 45, 50,  5, 18, 23, 27, 31, 34, 38, 42, 46, 49,  3, 17, 24, 28, 32},
  { 48, 51, 10, 19, 22, 26, 30, 35, 39, 43, 47, 52, 13, 20, 21, 25, 29, 36, 40, 44, 48, 51,  9, 19, 22, 26, 30, 35, 39, 43, 47, 52, 14, 20, 21, 25, 29, 36, 40, 44},
  { 18, 23, 27, 31, 34, 38, 42, 46, 49,  1, 17, 24, 28, 32, 33, 37, 41, 45, 50,  8, 18, 23, 27, 31, 34, 38, 42, 46, 49,  2, 17, 24, 28, 32, 33, 37, 41, 45, 50,  7},
  { 30, 35, 39, 43, 47, 52, 16, 20, 21, 25, 29, 36, 40, 44, 48, 51, 12, 19, 22, 26, 30, 35, 39, 43, 47, 52, 15, 20, 21, 25, 29, 36, 40, 44, 48, 51, 11, 19, 22, 26},
  { 42, 46, 49,  4, 17, 24, 28, 32, 33, 37, 41, 45, 50,  5, 18, 23, 27, 31, 34, 38, 42, 46, 49,  3, 17, 24, 28, 32, 33, 37, 41, 45, 50,  6, 18, 23, 27, 31, 34, 38},
  { 13, 20, 21, 25, 29, 36, 40, 44, 48, 51,  9, 19, 22, 26, 30, 35, 39, 43, 47, 52, 14, 20, 21, 25, 29, 36, 40, 44, 48, 51, 10, 19, 22, 26, 30, 35, 39, 43, 47, 52},
  { 28, 32, 33, 37, 41, 45, 50,  8, 18, 23, 27, 31, 34, 38, 42, 46, 49,  2, 17, 24, 28, 32, 33, 37, 41, 45, 50,  7, 18, 23, 27, 31, 34, 38, 42, 46, 49,  1, 17, 24},
  { 40, 44, 48, 51, 12, 19, 22, 26, 30, 35, 39, 43, 47, 52, 15, 20, 21, 25, 29, 36, 40, 44, 48, 51, 11, 19, 22, 26, 30, 35, 39, 43, 47, 52, 16, 20, 21, 25, 29, 36},
  { 50,  5, 18, 23, 27, 31, 34, 38, 42, 46, 49,  3, 17, 24, 28, 32, 33, 37, 41, 45, 50,  6, 18, 23, 27, 31, 34, 38, 42, 46, 49,  4, 17, 24, 28, 32, 33, 37, 41, 45},
  { 22, 26, 30, 35, 39, 43, 47, 52, 14, 20, 21, 25, 29, 36, 40, 44, 48, 51, 10, 19, 22, 26, 30, 35, 39, 43, 47, 52, 13, 20, 21, 25, 29, 36, 40, 44, 48, 51,  9, 19},
  { 34, 38, 42, 46, 49,  2, 17, 24, 28, 32, 33, 37, 41, 45, 50,  7, 18, 23, 27, 31, 34, 38, 42, 46, 49,  1, 17, 24, 28, 32, 33, 37, 41, 45, 50,  8, 18, 23, 27, 31},
  { 47, 52, 15, 20, 21, 25, 29, 36, 40, 44, 48, 51, 11, 19, 22, 26, 30, 35, 39, 43, 47, 52, 16, 20, 21, 25, 29, 36, 40, 44, 48, 51, 12, 19, 22, 26, 30, 35, 39, 43},
  { 17, 24, 28, 32, 33, 37, 41, 45, 50,  6, 18, 23, 27, 31, 34, 38, 42, 46, 49,  4, 17, 24, 28, 32, 33, 37, 41, 45, 50,  5, 18, 23, 27, 31, 34, 38, 42, 46, 49,  3},
  { 29, 36, 40, 44, 48, 51, 10, 19, 22, 26, 30, 35, 39, 43, 47, 52, 13, 20, 21, 25, 29, 36, 40, 44, 48, 51,  9, 19, 22, 26, 30, 35, 39, 43, 47, 52, 14, 20, 21, 25},
  { 41, 45, 50,  7, 18, 23, 27, 31, 34, 38, 42, 46, 49,  1, 17, 24, 28, 32, 33, 37, 41, 45, 50,  8, 18, 23, 27, 31, 34, 38, 42, 46, 49,  2, 17, 24, 28, 32, 33, 37},
  { 11, 19, 22, 26, 30, 35, 39, 43, 47, 52, 16, 20, 21, 25, 29, 36, 40, 44, 48, 51, 12, 19, 22, 26, 30, 35, 39, 43, 47, 52, 15, 20, 21, 25, 29, 36, 40, 44, 48, 51},
  { 27, 31, 34, 38, 42, 46, 49,  4, 17, 24, 28, 32, 33, 37, 41, 45, 50,  5, 18, 23, 27, 31, 34, 38, 42, 46, 49,  3, 17, 24, 28, 32, 33, 37, 41, 45, 50,  6, 18, 23},
  { 39, 43, 47, 52, 13, 20, 21, 25, 29, 36, 40, 44, 48, 51,  9, 19, 22, 26, 30, 35, 39, 43, 47, 52, 14, 20, 21, 25, 29, 36, 40, 44, 48, 51, 10, 19, 22, 26, 30, 35}
 },

 {  /* Black DitherTable (576 bytes) */
  { 61, 69, 77, 21, 25, 33, 64, 72, 80, 24, 28, 36, 61, 69, 77, 21, 25, 33, 64, 72, 80, 24, 28, 36},
  { 37, 45, 53, 41, 49, 57, 40, 48, 56, 44, 52, 60, 37, 45, 53, 41, 49, 57, 40, 48, 56, 44, 52, 60},
  {  1, 17, 29, 65, 73, 81,  9, 20, 32, 68, 76, 84,  2, 17, 29, 65, 73, 81, 10, 20, 32, 68, 76, 84},
  { 23, 27, 35, 62, 70, 78, 22, 26, 34, 63, 71, 79, 23, 27, 35, 62, 70, 78, 22, 26, 34, 63, 71, 79},
  { 43, 51, 59, 38, 46, 54, 42, 50, 58, 39, 47, 55, 43, 51, 59, 38, 46, 54, 42, 50, 58, 39, 47, 55},
  { 67, 75, 83, 13, 18, 30, 66, 74, 82,  6, 19, 31, 67, 75, 83, 14, 18, 30, 66, 74, 82,  5, 19, 31},
  { 64, 72, 80, 24, 28, 36, 61, 69, 77, 21, 25, 33, 64, 72, 80, 24, 28, 36, 61, 69, 77, 21, 25, 33},
  { 40, 48, 56, 44, 52, 60, 37, 45, 53, 41, 49, 57, 40, 48, 56, 44, 52, 60, 37, 45, 53, 41, 49, 57},
  { 12, 20, 32, 68, 76, 84,  3, 17, 29, 65, 73, 81, 11, 20, 32, 68, 76, 84,  4, 17, 29, 65, 73, 81},
  { 22, 26, 34, 63, 71, 79, 23, 27, 35, 62, 70, 78, 22, 26, 34, 63, 71, 79, 23, 27, 35, 62, 70, 78},
  { 42, 50, 58, 39, 47, 55, 43, 51, 59, 38, 46, 54, 42, 50, 58, 39, 47, 55, 43, 51, 59, 38, 46, 54},
  { 66, 74, 82,  7, 19, 31, 67, 75, 83, 15, 18, 30, 66, 74, 82,  8, 19, 31, 67, 75, 83, 16, 18, 30},
  { 61, 69, 77, 21, 25, 33, 64, 72, 80, 24, 28, 36, 61, 69, 77, 21, 25, 33, 64, 72, 80, 24, 28, 36},
  { 37, 45, 53, 41, 49, 57, 40, 48, 56, 44, 52, 60, 37, 45, 53, 41, 49, 57, 40, 48, 56, 44, 52, 60},
  {  2, 17, 29, 65, 73, 81, 10, 20, 32, 68, 76, 84,  1, 17, 29, 65, 73, 81,  9, 20, 32, 68, 76, 84},
  { 23, 27, 35, 62, 70, 78, 22, 26, 34, 63, 71, 79, 23, 27, 35, 62, 70, 78, 22, 26, 34, 63, 71, 79},
  { 43, 51, 59, 38, 46, 54, 42, 50, 58, 39, 47, 55, 43, 51, 59, 38, 46, 54, 42, 50, 58, 39, 47, 55},
  { 67, 75, 83, 14, 18, 30, 66, 74, 82,  5, 19, 31, 67, 75, 83, 13, 18, 30, 66, 74, 82,  6, 19, 31},
  { 64, 72, 80, 24, 28, 36, 61, 69, 77, 21, 25, 33, 64, 72, 80, 24, 28, 36, 61, 69, 77, 21, 25, 33},
  { 40, 48, 56, 44, 52, 60, 37, 45, 53, 41, 49, 57, 40, 48, 56, 44, 52, 60, 37, 45, 53, 41, 49, 57},
  { 11, 20, 32, 68, 76, 84,  4, 17, 29, 65, 73, 81, 12, 20, 32, 68, 76, 84,  3, 17, 29, 65, 73, 81},
  { 22, 26, 34, 63, 71, 79, 23, 27, 35, 62, 70, 78, 22, 26, 34, 63, 71, 79, 23, 27, 35, 62, 70, 78},
  { 42, 50, 58, 39, 47, 55, 43, 51, 59, 38, 46, 54, 42, 50, 58, 39, 47, 55, 43, 51, 59, 38, 46, 54},
  { 66, 74, 82,  8, 19, 31, 67, 75, 83, 16, 18, 30, 66, 74, 82,  7, 19, 31, 67, 75, 83, 15, 18, 30}
 }
};


static short VD_ExpandValueTable[4][256] =
{
/********************************************/
/*      Start ExpandValueTable       */
/********************************************/
 {  /* Yellow ExpandValueTable (256 words) */
   0,   2,   3,   5,   6,   8,   9,  11,  12,  14,  15,  17,  20,  22,  25,  27,
  30,  32,  35,  37,  40,  42,  45,  47,  49,  52,  54,  57,  59,  62,  64,  67,
  69,  72,  74,  77,  79,  82,  84,  87,  89,  92,  94,  97,  99, 102, 104, 106,
 109, 111, 115, 119, 122, 126, 130, 134, 137, 141, 145, 149, 152, 156, 160, 163,
 167, 171, 175, 178, 182, 186, 190, 193, 197, 201, 205, 208, 212, 216, 220, 223,
 227, 231, 234, 238, 242, 246, 250, 254, 258, 262, 266, 269, 273, 277, 281, 285,
 289, 293, 297, 301, 305, 309, 313, 316, 320, 324, 328, 332, 336, 340, 344, 348,
 352, 356, 360, 363, 367, 371, 375, 379, 383, 387, 391, 395, 399, 403, 407, 410,
 414, 418, 422, 426, 430, 434, 438, 442, 446, 450, 454, 457, 461, 465, 469, 473,
 477, 481, 487, 492, 497, 503, 508, 513, 518, 524, 529, 534, 540, 545, 550, 555,
 561, 566, 571, 577, 590, 602, 614, 626, 639, 651, 659, 663, 667, 672, 676, 680,
 684, 688, 690, 692, 693, 695, 697, 699, 700, 702, 704, 705, 707, 709, 710, 712,
 714, 716, 717, 719, 721, 722, 724, 726, 727, 729, 731, 733, 734, 736, 738, 739,
 741, 743, 745, 746, 748, 750, 751, 754, 756, 759, 762, 764, 767, 770, 772, 775,
 778, 780, 783, 786, 788, 791, 794, 796, 799, 802, 804, 807, 810, 812, 815, 818,
 820, 823, 826, 828, 831, 846, 867, 888, 908, 927, 946, 963, 974, 985, 997,1008},

 {  /* Cyan ExpandValueTable (256 words) */
   0,   1,   2,   3,   3,   4,   5,   6,   7,   8,   9,   9,  10,  11,  12,  13,
  14,  14,  15,  17,  21,  24,  28,  32,  36,  40,  43,  47,  51,  55,  59,  62,
  66,  70,  74,  78,  81,  85,  89,  93,  96, 100, 104, 108, 112, 115, 119, 123,
 127, 131, 134, 138, 142, 146, 150, 153, 157, 161, 165, 169, 172, 176, 180, 184,
 188, 191, 195, 199, 203, 207, 211, 215, 219, 224, 225, 226, 227, 228, 229, 230,
 231, 232, 233, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247,
 248, 249, 250, 251, 252, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264,
 265, 266, 267, 269, 271, 273, 275, 278, 280, 282, 284, 286, 287, 288, 289, 291,
 292, 293, 295, 296, 297, 298, 300, 301, 302, 304, 305, 306, 307, 309, 310, 311,
 313, 314, 316, 317, 319, 320, 322, 323, 325, 326, 328, 329, 331, 332, 334, 335,
 337, 338, 340, 341, 343, 344, 346, 347, 349, 351, 353, 355, 356, 358, 359, 360,
 361, 362, 363, 364, 365, 366, 367, 368, 370, 371, 372, 373, 374, 375, 376, 377,
 378, 379, 380, 381, 382, 383, 384, 386, 387, 388, 389, 390, 391, 392, 393, 393,
 394, 395, 396, 396, 397, 398, 399, 399, 400, 401, 402, 402, 403, 404, 406, 408,
 410, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 425, 426, 427,
 428, 429, 430, 431, 432, 434, 437, 440, 443, 445, 448, 451, 454, 457, 461, 468},

 {  /* Magenta ExpandValueTable (256 words) */
   0,   1,   2,   4,   5,   6,   7,   8,   9,  11,  12,  13,  14,  15,  18,  22,
  26,  31,  35,  39,  44,  48,  52,  56,  61,  65,  69,  74,  78,  82,  86,  91,
  95,  99, 104, 108, 112, 117, 121, 125, 129, 134, 138, 142, 147, 151, 155, 160,
 164, 168, 172, 177, 181, 185, 190, 194, 198, 202, 207, 211, 215, 219, 223, 225,
 226, 227, 228, 229, 230, 231, 232, 233, 235, 236, 237, 238, 239, 240, 241, 242,
 243, 244, 245, 246, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259,
 260, 262, 263, 264, 265, 266, 267, 268, 271, 274, 276, 279, 282, 284, 286, 287,
 289, 290, 291, 293, 294, 296, 297, 298, 300, 301, 302, 304, 305, 307, 308, 309,
 311, 313, 317, 321, 322, 324, 325, 327, 328, 330, 332, 333, 335, 336, 338, 340,
 341, 343, 344, 346, 347, 351, 354, 358, 360, 362, 363, 364, 365, 366, 367, 368,
 369, 370, 371, 372, 373, 374, 376, 378, 383, 385, 385, 386, 387, 388, 389, 390,
 390, 391, 392, 393, 394, 394, 395, 396, 397, 398, 399, 399, 400, 401, 402, 403,
 403, 405, 408, 409, 410, 411, 411, 412, 413, 414, 415, 416, 416, 417, 418, 419,
 420, 421, 421, 422, 423, 424, 425, 426, 427, 427, 428, 429, 430, 431, 432, 432,
 433, 433, 434, 434, 435, 435, 436, 437, 439, 441, 442, 444, 446, 448, 449, 451,
 452, 453, 453, 454, 454, 455, 455, 456, 457, 458, 460, 461, 463, 465, 466, 468},

 {  /* Black ExpandValueTable (256 words) */
   0,   2,   3,   5,   6,   8,   9,  11,  12,  14,  15,  20,  28,  36,  44,  52,
  60,  68,  76,  84,  92,  97,  99, 102, 104, 106, 108, 111, 113, 115, 117, 120,
 122, 125, 133, 142, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170,
 172, 174, 176, 178, 180, 182, 184, 188, 191, 194, 197, 200, 202, 203, 205, 207,
 208, 210, 211, 213, 215, 216, 218, 220, 221, 223, 225, 228, 230, 233, 235, 238,
 241, 246, 251, 256, 257, 259, 260, 262, 263, 264, 265, 266, 266, 267, 267, 268,
 269, 269, 270, 270, 271, 272, 272, 274, 275, 277, 278, 279, 281, 282, 283, 285,
 286, 287, 289, 290, 291, 294, 296, 299, 301, 304, 305, 305, 306, 306, 307, 307,
 308, 309, 309, 310, 310, 311, 312, 312, 314, 316, 317, 319, 321, 322, 324, 326,
 328, 329, 331, 332, 334, 335, 336, 337, 338, 339, 341, 342, 343, 344, 345, 346,
 347, 348, 349, 351, 352, 353, 354, 355, 356, 361, 362, 363, 364, 365, 367, 368,
 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 382, 383, 385, 387,
 388, 388, 388, 388, 389, 389, 389, 389, 389, 389, 389, 389, 390, 390, 390, 390,
 390, 390, 390, 390, 391, 391, 391, 391, 391, 391, 391, 391, 392, 392, 392, 392,
 392, 392, 392, 393, 393, 393, 393, 393, 394, 394, 394, 394, 394, 394, 395, 395,
 395, 395, 395, 395, 396, 396, 396, 396, 397, 397, 398, 398, 399, 399, 400, 404}
};

typedef struct {
        unsigned char base;
        unsigned char offset;
        } ToneOptimaizeTable;

static ToneOptimaizeTable VD_ToneOptimaizeTable[4][232] =
{
/***************************************************/
/*         Start ToneOptimaizeTabl         */
/***************************************************/
 {  /* Yellow ToneOptimaizeTabl (464 bytes)	*/
  { 0, 0},
  { 1, 9},{ 1,10},{ 1,11},{ 1,12},{ 1,13},{ 1,14},{ 1,15},
  { 2, 8},{ 2, 9},{ 2,10},{ 2,11},{ 2,12},{ 2,13},{ 2,14},{ 2,15},
  { 3, 8},{ 3, 9},{ 3,10},{ 3,11},{ 3,12},{ 3,13},{ 3,14},{ 3,15},
  { 4, 8},{ 4, 9},{ 4,10},{ 4,11},{ 4,12},{ 4,13},{ 4,14},{ 4,15},
  { 5, 8},{ 5, 9},{ 5,10},{ 5,11},{ 5,12},{ 5,13},{ 5,14},{ 5,15},
  { 6, 1},{ 6, 2},{ 6, 3},{ 6, 4},{ 6, 5},{ 6, 6},{ 6, 7},{ 6, 8},{ 6, 9},{ 6,10},{ 6,11},{ 6,12},{ 6,13},{ 6,14},{ 6,15},
  { 7, 1},{ 7, 2},{ 7, 3},{ 7, 4},{ 7, 5},{ 7, 6},{ 7, 7},{ 7, 8},{ 7, 9},{ 7,10},{ 7,11},{ 7,12},{ 7,13},{ 7,14},{ 7,15},
  { 8, 1},{ 8, 2},{ 8, 3},{ 8, 4},{ 8, 5},{ 8, 6},{ 8, 7},{ 8, 8},{ 8, 9},{ 8,10},{ 8,11},{ 8,12},{ 8,13},{ 8,14},{ 8,15},
  { 9, 1},{ 9, 2},{ 9, 3},{ 9, 4},{ 9, 5},{ 9, 6},{ 9, 7},{ 9, 8},{ 9, 9},{ 9,10},{ 9,11},{ 9,12},{ 9,13},{ 9,14},{ 9,15},
  {10,10},{10,11},{10,12},{10,13},{10,14},{10,15},
  {11,10},{11,11},{11,12},{11,13},{11,14},{11,15},
  {12,10},{12,11},{12,12},{12,13},{12,14},{12,15},
  {13,10},{13,11},{13,12},{13,13},{13,14},{13,15},
  {14,11},{14,12},{14,13},{14,14},{14,15},
  {15,11},{15,12},{15,13},{15,14},{15,15},
  {16,11},{16,12},{16,13},{16,14},{16,15},
  {17,11},{17,12},{17,13},{17,14},{17,15},
  {18, 5},{18, 6},{18, 7},{18, 8},{18, 9},{18,10},{18,11},{18,12},{18,13},{18,14},{18,15},
  {19, 5},{19, 6},{19, 7},{19, 8},{19, 9},{19,10},{19,11},{19,12},{19,13},{19,14},{19,15},
  {20, 5},{20, 6},{20, 7},{20, 8},{20, 9},{20,10},{20,11},{20,12},{20,13},{20,14},{20,15},
  {21, 5},{21, 6},{21, 7},{21, 8},{21, 9},{21,10},{21,11},{21,12},{21,13},{21,14},{21,15},
  {22,12},{22,13},{22,14},{22,15},
  {23,12},{23,13},{23,14},{23,15},
  {24,12},{24,13},{24,14},{24,15},
  {25,12},{25,13},{25,14},{25,15},
  {26,12},{26,13},{26,14},{26,15},
  {27,12},{27,13},{27,14},{27,15},
  {28,12},{28,13},{28,14},{28,15},
  {29,12},{29,13},{29,14},{29,15},
  {30,13},{30,14},{30,15},
  {31,13},{31,14},{31,15},
  {32,13},{32,14},{32,15},
  {33,13},{33,14},{33,15}
 },

 {  /* Cyan ToneOptimaizeTabl (158 bytes)	*/
  { 0, 0},
  { 1, 3},{ 1, 4},{ 1, 5},{ 1, 6},{ 1, 7},{ 1, 8},{ 1, 9},{ 1,10},{ 1,11},{ 1,12},{ 1,13},{ 1,14},{ 1,15},
  { 2, 1},{ 2, 2},{ 2, 3},{ 2, 4},{ 2, 5},{ 2, 6},{ 2, 7},{ 2, 8},{ 2, 9},{ 2,10},{ 2,11},{ 2,12},{ 2,13},{ 2,14},{ 2,15},
  { 3, 5},{ 3, 6},{ 3, 7},{ 3, 8},{ 3, 9},{ 3,10},{ 3,11},{ 3,12},{ 3,13},{ 3,14},{ 3,15},
  { 4, 7},{ 4, 8},{ 4, 9},{ 4,10},{ 4,11},{ 4,12},{ 4,13},{ 4,14},{ 4,15},
  { 5, 9},{ 5,10},{ 5,11},{ 5,12},{ 5,13},{ 5,14},{ 5,15},
  { 6, 9},{ 6,10},{ 6,11},{ 6,12},{ 6,13},{ 6,14},{ 6,15},
  { 7, 9},{ 7,10},{ 7,11},{ 7,12},{ 7,13},{ 7,14},{ 7,15},
  { 8,11},{ 8,12},{ 8,13},{ 8,14},{ 8,15},
  { 9,13},{ 9,14},{ 9,15},
  {10,15}
 },

 {  /* Magenat ToneOptimaizeTabl (158 bytes)	*/
  { 0, 0},
  { 1, 3},{ 1, 4},{ 1, 5},{ 1, 6},{ 1, 7},{ 1, 8},{ 1, 9},{ 1,10},{ 1,11},{ 1,12},{ 1,13},{ 1,14},{ 1,15},
  { 2, 1},{ 2, 2},{ 2, 3},{ 2, 4},{ 2, 5},{ 2, 6},{ 2, 7},{ 2, 8},{ 2, 9},{ 2,10},{ 2,11},{ 2,12},{ 2,13},{ 2,14},{ 2,15},
  { 3, 5},{ 3, 6},{ 3, 7},{ 3, 8},{ 3, 9},{ 3,10},{ 3,11},{ 3,12},{ 3,13},{ 3,14},{ 3,15},
  { 4, 7},{ 4, 8},{ 4, 9},{ 4,10},{ 4,11},{ 4,12},{ 4,13},{ 4,14},{ 4,15},
  { 5, 9},{ 5,10},{ 5,11},{ 5,12},{ 5,13},{ 5,14},{ 5,15},
  { 6, 9},{ 6,10},{ 6,11},{ 6,12},{ 6,13},{ 6,14},{ 6,15},
  { 7, 9},{ 7,10},{ 7,11},{ 7,12},{ 7,13},{ 7,14},{ 7,15},
  { 8,11},{ 8,12},{ 8,13},{ 8,14},{ 8,15},
  { 9,13},{ 9,14},{ 9,15},
  {10,15}
 },

 {  /* Black ToneOptimaizeTabl (168 bytes)	*/
  { 0, 0},
  { 1,10},{ 1,11},{ 1,12},{ 1,13},{ 1,14},{ 1,15},
  { 2, 9},{ 2,10},{ 2,11},{ 2,12},{ 2,13},{ 2,14},{ 2,15},
  { 3, 1},{ 3, 2},{ 3, 3},{ 3, 4},{ 3, 5},{ 3, 6},{ 3, 7},{ 3, 8},{ 3, 9},{ 3,10},{ 3,11},{ 3,12},{ 3,13},{ 3,14},{ 3,15},
  { 4,12},{ 4,13},{ 4,14},{ 4,15},
  { 5,10},{ 5,11},{ 5,12},{ 5,13},{ 5,14},{ 5,15},
  { 6,12},{ 6,13},{ 6,14},{ 6,15},
  { 7, 3},{ 7, 4},{ 7, 5},{ 7, 6},{ 7, 7},{ 7, 8},{ 7, 9},{ 7,10},{ 7,11},{ 7,12},{ 7,13},{ 7,14},{ 7,15},
  { 8, 6},{ 8, 7},{ 8, 8},{ 8, 9},{ 8,10},{ 8,11}, {8,12},{ 8,13},{ 8,14},{ 8,15},
  { 9,13},{ 9,14},{ 9,15},
  {10,13},{10,14},{10,15},
  {11,15},
  {12,14},{12,15},
  {13,13},{13,14},{13,15},
  {14,14},{14,15},
  {15,15},
  {16,15},
  {17,15},
  {18,15}
 }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\alpsres\sources.inc ===
!IF 0

Copyright (C) 1996 - 1999 Microsoft Corporation

Module Name:

    sources.

    Abstract:

        This file specifies the target component being built and the list of
        sources files needed to build that component.  Also specifies optional
        compiler switches and libraries that are unique for the component being
        built.

!ENDIF

!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

GPDDIR_AL=$(PRNROOT)\gpd\alps\usa
GPDDIR_AL_JPN=$(PRNROOT)\gpd\alps\jpn
GPDDIR_CT=$(PRNROOT)\gpd\citzn\usa

INCLUDES=$(PRNROOT)\inc

UMTYPE=windows

!if 0
DLLBASE=@$(COFFBASE_TXT_FILE),eprstres
!else
DLLBASE=0x8000000
!endif

MSC_WARNING_LEVEL=/W3 /WX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\alpsres\names.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
//     "Command",
    "CommandCallback",
//     "Compression",
//     "DeviceCapabilities",
    "DevMode",
//     "DevQueryPrintEx",
//     "DisableDriver",
    "DisablePDEV",
//     "DocumentPropertySheets",
//     "DownloadCharGlyph",
//     "DownloadFontHeader",
//     "DriverDMS",
//     "DriverEvent",
//     "DrvGetDriverSetting",
//     "DrvWriteSpoolBuf",
//     "EnableDriver",
    "EnablePDEV",
    "FilterGraphics",
//     "FontInstallerDlgProc",
//     "GetDDIHooks",
//     "GetDriverSetting",
    "GetImplementedMethod",
    "GetInfo",
//     "HalftonePattern",
//     "ImageProcessing",
//     "MemoryUsage",
//     "OutputCharStr",
//     "PrinterEvent",
//     "PropCommonUIProp",
    "PublishDriverInterface",
//     "QueryColorProfile",
    "ResetPDEV",
//     "SendFontCmd",
//     "SheetsDevicePropertySheets",
//     "TextOutAsBitmap",
//     "TTDownloadMethod",
//     "TTYGetInfo",
//     "UpdateUISetting",
//     "UpgradePrinter",
//     "UpgradeRegistry",
//     "UpgradeRegistrySetting",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\alpsres\pdev.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

#ifndef _PDEV_H
#define _PDEV_H

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>

////////////////////////////////////////////////////////
//      OEM UD Defines
////////////////////////////////////////////////////////

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

//
// ASSERT_VALID_PDEVOBJ can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
//
#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
#define ERRORTEXT(s)   "ERROR " DLLTEXT(s)

////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER  dmExtraHdr;
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'ALPS'      // ALPS MD Series
#define DLLTEXT(s)      "ALPSRES: " s
#define OEM_VERSION      0x00010000L

// ####

//
// Minidriver device data block which we maintain.
// Its address is saved in the DEVOBJ.pdevOEM of
// OEM customiztion I/F.
//

typedef struct {
    VOID *pData; // Minidriver private data.
    VOID *pIntf; // a.k.a. pOEMHelp
} MINIDEV;

//
// Easy access to the OEM data and the printer
// driver helper functions.
//

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

    extern
    HRESULT
    XXXDrvWriteSpoolBuf(
        VOID *pIntf,
        PDEVOBJ pDevobj,
        PVOID pBuffer,
        DWORD cbSize,
        DWORD *pdwResult);

#ifdef __cplusplus
}
#endif // __cplusplus

#define MINIDEV_DATA(p) \
    (((MINIDEV *)(p)->pdevOEM)->pData)

#define MINIDEV_INTF(p) \
    (((MINIDEV *)(p)->pdevOEM)->pIntf)

#define WRITESPOOLBUF(p, b, n, r) \
    XXXDrvWriteSpoolBuf(MINIDEV_INTF(p), (p), (b), (n), (r))

#endif  // _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\alpsres\dit\dither.c ===
/*************************** Module Header **********************************
 * dither
 *      Program to create actual dither tables from ALPS's original base 
 *      dither tables.
 *      
 *
 * Copyright (C) 1996-1999,  Microsoft Corporation
 * 1996/6/21 Created - Sueya Sugihara [sueyas] -
 *
 ****************************************************************************/

#include        <stddef.h>
#include        <windows.h>
#include        <winddi.h>

#include        <stdio.h>

#define Yellow   0
#define Cyan     1
#define Magenta  2
#define Kuro     3
#define Mono     4

static unsigned char H_OrgTable[4][68][68] = 
{
 { // Yellow
  {100,84,70,85,100,100,93,80,94,100,100,89,76,90,100},
  {99,46,31,40,97,97,48,38,44,100,100,48,34,42,99},
  {67,22,1,10,63,69,24,8,14,65,68,23,5,12,64},
  {67,26,20,15,63,69,29,21,19,65,68,28,21,17,64},
  {100,60,48,57,100,100,62,54,59,100,100,61,50,58,100},
  {100,91,78,92,100,100,86,73,87,100,100,95,82,96,100},
  {100,48,36,43,100,100,47,32,41,98,98,48,39,45,100},
  {68,24,6,13,64,68,23,3,11,63,69,25,9,14,66},
  {68,29,21,18,64,68,27,21,16,63,69,30,22,20,66},
  {100,62,52,58,100,100,61,49,57,100,100,63,56,59,100}
 },
 { // Cyan
  {46,65,89,90,80,18,45,64,87,87,79,16,44,63,91,91,81,20},
  {59,100,100,90,7,38,58,94,94,87,5,37,57,98,98,91,9,38},
  {75,100,100,30,41,52,73,94,94,28,40,50,71,98,98,33,42,53},
  {83,77,13,43,61,82,82,76,11,42,60,85,85,78,15,44,62,83},
  {83,2,35,55,97,97,82,1,34,54,100,100,85,3,36,56,93,93},
  {23,39,48,68,97,97,21,39,47,66,100,100,25,40,49,70,93,93},
  {45,64,86,86,79,15,44,63,91,91,81,19,46,65,89,88,80,17},
  {58,95,95,86,4,37,57,99,99,91,8,38,59,100,100,88,6,38},
  {72,95,95,26,40,50,71,99,99,32,42,53,74,100,100,29,41,51},
  {82,76,10,42,60,85,85,78,14,44,62,84,84,77,12,43,61,82},
  {82,1,34,54,92,92,85,3,36,56,100,100,84,2,35,55,96,96},
  {20,39,47,66,92,92,24,40,49,69,100,100,22,39,48,67,96,96}
 },
 { // Magenta
  {93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93},
  {1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82},
  {29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26},
  {49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62},
  {100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73},
  {80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88},
  {24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19},
  {46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40},
  {70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62},
  {89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97},
  {20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14},
  {41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36},
  {63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57},
  {95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95},
  {13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4},
  {35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30},
  {56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51},
  {98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98},
  {9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78},
  {31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23},
  {52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45},
  {96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68},
  {84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92},
  {28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22},
  {48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44},
  {76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66},
  {85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93},
  {16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12},
  {38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33},
  {60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55},
  {100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100},
  {15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10},
  {37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32},
  {59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53},
  {94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94},
  {3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81},
  {29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25},
  {50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47},
  {99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72},
  {79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87},
  {23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18},
  {46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39},
  {69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61},
  {90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98},
  {20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14},
  {47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36},
  {64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58},
  {96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96},
  {13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5},
  {35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30},
  {56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51},
  {97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97},
  {7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77},
  {31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22},
  {52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45},
  {95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67},
  {83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91},
  {27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21},
  {48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43},
  {75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65},
  {86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94},
  {17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12},
  {39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34},
  {60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55},
  {99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32,37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99},
  {16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54,59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11},
  {37,44,48,51,56,62,70,94,94,94,86,78,9,14,20,26,29,33,38,45,52,57,63,72,99,99,99,92,84,5,13,19,24,32,37,43,48,51,56,61,69,93,93,93,85,77,7,14,20,25,29,34,39,45,52,58,64,73,100,100,100,91,83,4,13,18,23,32},
  {59,66,76,97,97,97,89,81,3,12,17,23,31,36,47,62,49,55,60,67,95,95,95,87,79,11,16,22,28,30,35,40,46,53,59,65,75,98,98,98,90,82,1,12,16,22,31,36,41,47,50,55,60,68,96,96,96,88,80,10,15,21,27,30,35,39,46,54}
 },
 { // Kuro
  {93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69},
  {28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59},
  {54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65},
  {99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99},
  {99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99},
  {7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32},
  {27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57},
  {47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94},
  {88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94},
  {9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2},
  {16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23},
  {50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38},
  {86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92},
  {70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14},
  {60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22},
  {67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53},
  {97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74},
  {97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68},
  {30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58},
  {56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61},
  {95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95},
  {95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95},
  {3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29},
  {24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55},
  {40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98},
  {91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98},
  {12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6},
  {20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25},
  {52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46},
  {82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90},
  {68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10},
  {59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18},
  {64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51},
  {94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83},
  {94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69},
  {28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59},
  {54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65},
  {100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100},
  {100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100},
  {8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33},
  {27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57},
  {48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93},
  {87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93},
  {9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1},
  {15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23},
  {49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35},
  {85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92},
  {70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13},
  {60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21},
  {66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53},
  {98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76},
  {98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68},
  {31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58},
  {56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62},
  {96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96},
  {96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96},
  {4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29},
  {24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55},
  {42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97},
  {91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97},
  {11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5},
  {19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25},
  {52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44},
  {80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89},
  {68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51,63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10},
  {58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84,93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17},
  {63,57,27,22,60,29,4,10,68,99,99,92,85,95,95,44,52,65,54,23,16,58,31,6,12,69,93,93,87,74,97,97,42,51,64,57,27,21,60,29,3,10,68,100,100,92,86,96,96,46,52,65,54,23,15,58,30,5,11,69,94,94,88,76,98,98,40,51},
  {93,93,48,53,67,55,24,18,59,32,7,13,70,95,95,89,80,100,100,38,50,62,56,25,20,59,28,1,9,68,97,97,91,83,94,94,47,53,66,55,24,17,58,33,8,14,70,96,96,90,82,99,99,35,49,61,56,25,19,59,28,2,9,68,98,98,91,84}
 }
};

static unsigned char R_OrgTable[4][20][20] =
{
 { // Yellow
  { 1, 1, 5,20,33,33, 4, 4, 8,23,36,36},
  { 5, 5, 9,20,37,37, 8, 8,12,23,40,40},
  { 9, 9,13,24,37,37,12,12,14,28,40,40},
  {15,15,19,24,41,41,18,18,19,28,44,44},
  {29,29,53,57,61,61,32,32,56,60,66,66},
  {45,46,53,57,62,62,51,52,56,60,67,67},
  { 3, 3, 7,22,35,35, 2, 2, 6,21,34,34},
  { 7, 7,11,22,39,39, 6, 6,10,21,38,38},
  {11,11,14,27,39,39,10,10,13,25,38,38},
  {17,17,19,27,43,43,16,16,19,26,42,42},
  {31,31,55,59,65,65,30,30,54,58,63,63},
  {49,50,55,59,68,68,47,48,54,58,64,64}
 },
 { // Cyan
  {61,63,64,16, 3, 3,11,45,49},
  {67,68,68,17, 6, 6,11,37,51},
  {67,70,70,34,19,21,32,35,53},
  {23,25,31,46,55,58,59,39,29},
  { 7, 8,12,47,60,62,62,41,13},
  { 1, 1,10,50,65,69,69,42,14},
  { 5, 5,10,52,66,70,70,43,17},
  {18,20,30,30,27,28,31,40,33},
  {57,56,54,15, 9, 9,12,44,48}
 },
 { // Magenta
  {65, 1, 1,10,20,32,32, 9, 9,13,25,37,37,28,30,38,40,54,58,65},
  {66, 4, 6,10,22,34,34,15,17,19,27,53,53,50,50,44,47,54,60,66},
  {32, 8, 8,12,24,36,36,29,31,39,41,55,62,67,67, 3, 3,11,21,33},
  {34,14,16,18,26,52,52,51,51,48,49,56,64,68,68, 5, 7,11,23,35},
  {36,28,30,38,40,54,58,65,65, 1, 1,10,20,32,32, 9, 9,13,25,37},
  {52,50,50,44,47,54,60,66,66, 4, 6,10,22,34,34,15,17,19,27,53},
  {58,67,67, 3, 3,11,21,33,33, 8, 8,12,24,36,36,29,31,39,41,55},
  {60,68,68, 5, 7,11,23,35,35,14,16,18,26,52,52,51,51,48,49,56},
  {20,32,32, 9, 9,13,25,37,37,28,30,38,40,54,58,65,65, 1, 1,10},
  {22,34,34,15,17,19,27,53,53,50,50,44,47,54,60,66,66, 4, 6,10},
  {24,36,36,29,31,39,41,55,62,67,67, 3, 3,11,21,33,33, 8, 8,12},
  {26,52,52,51,51,48,49,56,64,68,68, 5, 7,11,23,35,35,14,16,18},
  {40,54,58,65,65, 1, 1,10,20,32,32, 9, 9,13,25,37,37,28,30,38},
  {47,54,60,66,66, 4, 6,10,22,34,34,15,17,19,27,53,53,50,50,44},
  { 3,11,21,33,33, 8, 8,12,24,36,36,29,31,39,41,55,62,67,67, 3},
  { 7,11,23,35,35,14,16,18,26,52,52,51,51,48,49,56,64,68,68, 5},
  { 9,13,25,37,37,28,30,38,40,54,58,67,67, 1, 1,10,20,32,32, 9},
  {17,19,27,53,53,50,50,44,47,54,60,68,68, 4, 6,10,22,34,34,15},
  {31,39,41,55,62,67,67, 3, 3,11,21,33,33, 8, 8,12,24,36,36,29},
  {51,48,49,56,64,68,68, 5, 7,11,23,35,35,14,16,18,26,52,52,51}
 },
 { // Kuro
  {60,60,58,50,52,54,62,62,35,17, 7, 8,11,30,29,14, 3, 3,10,27},
  {31,18,20,23,25,33,64,64,55,43,42,40,39,37,29,16, 6, 6,10,27},
  {28,13, 1, 1,10,26,59,59,56,44,45,48,60,61,36,17, 9, 9,12,30},
  {28,15, 4, 5,10,26,32,19,21,24,25,34,63,63,57,46,47,41,40,38},
  {35,17, 7, 8,11,30,29,14, 3, 3,10,27,60,60,58,50,52,54,62,62},
  {55,43,42,40,39,37,29,16, 6, 6,10,27,31,18,20,23,25,33,64,64},
  {56,44,45,48,60,61,36,17, 9, 9,12,30,28,13, 1, 1,10,26,59,59},
  {21,24,25,34,63,63,57,46,47,41,40,38,28,15, 4, 5,10,26,32,19},
  { 3, 3,10,27,60,60,58,50,52,54,62,62,35,17, 7, 8,11,30,29,14},
  { 6, 6,10,27,31,18,20,23,25,33,64,64,55,43,42,40,39,37,29,16},
  { 9, 9,12,30,28,13, 1, 1,10,26,59,59,56,44,45,48,60,61,36,17},
  {47,41,40,38,28,15, 4, 5,10,26,32,19,21,24,25,34,63,63,57,46},
  {52,54,62,62,35,17, 7, 8,11,30,29,14, 3, 3,10,27,60,60,58,50},
  {25,33,64,64,55,43,42,40,39,37,29,16, 6, 6,10,27,31,18,20,23},
  {10,26,59,59,56,44,45,48,60,61,36,17, 9, 9,12,30,28,13, 1, 1},
  {10,26,32,19,21,24,25,34,63,63,57,46,47,41,40,38,28,15, 4, 5},
  {11,30,29,14, 3, 3,10,27,60,60,58,50,52,54,62,62,35,17, 7, 8},
  {39,37,29,16, 6, 6,10,27,31,18,20,23,25,33,64,64,55,43,42,40},
  {60,61,36,17, 9, 9,12,30,28,13, 1, 1,10,26,59,59,56,44,45,48},
  {63,63,57,46,47,41,40,38,28,15, 4, 5,10,26,32,19,21,24,25,34}
 }
};

static unsigned char M_OrgTable[14][14] =
{
 {91,71,39,41,63,73,95,92,72,40,42,64,74,96},
 {69,37,21,23,43,45,75,70,38,22,24,44,46,76},
 {35,19,1,3,9,25,47,36,20,2,4,10,26,48},
 {33,17,5,7,11,27,49,34,18,6,8,12,28,50},
 {61,31,13,15,29,51,65,62,32,14,16,30,52,66},
 {85,59,57,55,53,67,87,86,60,58,56,54,68,88},
 {93,83,81,79,77,89,97,94,84,82,80,78,90,100},
 {92,72,40,42,64,74,96,91,71,39,41,63,73,95},
 {70,38,22,24,44,46,76,69,37,21,23,43,45,75},
 {36,20,2,4,10,26,48,35,19,1,3,9,25,47},
 {34,18,6,8,12,28,50,33,17,5,7,11,27,49},
 {62,32,14,16,30,52,66,61,31,13,15,29,51,65},
 {86,60,58,56,54,68,88,85,59,57,55,53,67,87},
 {94,84,82,80,78,90,99,93,83,81,79,77,89,98}
};

static unsigned char OHP_OrgTable[8][8] =
{
 {36, 40, 38, 32, 27, 23, 25, 31},
 {54, 56, 58, 44,  9,  7,  5, 19},
 {52, 62, 60, 42, 11,  1,  3, 21},
 {46, 50, 48, 34, 17, 13, 15, 29},
 {26, 22, 24, 30, 37, 41, 39, 33},
  {8,  6,  4, 18, 55, 57, 59, 45},
 {10,  0,  2, 20, 53, 63, 61, 43},
 {16, 12, 14, 28, 47, 51, 49, 35}
};

int _CRTAPI1
main( argc, argv )
int    argc;
char **argv;
{

    int H_MaxX[4], H_MaxY[4];
    int R_MaxX[4], R_MaxY[4];
    int M_MaxX,    M_MaxY;
    int OHP_MaxX,  OHP_MaxY;
    int x, y;
    int color;
    char szColor[10];
    FLOAT H_TableMax[4];
    FLOAT R_TableMax[4];
    FLOAT M_TableMax;
    FLOAT OHP_TableMax;
    FLOAT H_TableOffset[4];
    FLOAT R_TableOffset[4];
    FLOAT M_TableOffset;
    FLOAT OHP_TableOffset;


    H_MaxX[Yellow]  = 15; H_MaxY[Yellow]  = 10;
    H_MaxX[Cyan]    = 18; H_MaxY[Cyan]    = 12;
    H_MaxX[Magenta] = 68; H_MaxY[Magenta] = 68;
    H_MaxX[Kuro]    = 68; H_MaxY[Kuro]    = 68;

    R_MaxX[Yellow]  = 12; R_MaxY[Yellow]  = 12;
    R_MaxX[Cyan]    = 9;  R_MaxY[Cyan]    =  9;
    R_MaxX[Magenta] = 20; R_MaxY[Magenta] = 20;
    R_MaxX[Kuro]    = 20; R_MaxY[Kuro]    = 20;

    M_MaxX          = 14; M_MaxY          = 14;

    OHP_MaxX = 8;
    OHP_MaxY = 8;

    H_TableMax[Yellow] = 100.0;
    H_TableMax[Cyan] = 100.0;
    H_TableMax[Magenta] = 100.0;
    H_TableMax[Kuro] = 100.0;
    H_TableOffset[Yellow] = 2.55;
    H_TableOffset[Cyan] = 2.55;
    H_TableOffset[Magenta] = 2.55;
    H_TableOffset[Kuro] = 2.55;

    R_TableMax[Yellow] = 68.0;
    R_TableMax[Cyan] = 70.0;
    R_TableMax[Magenta] = 68.0;
    R_TableMax[Kuro] = 100.0;
    R_TableOffset[Yellow] = 3.77;
    R_TableOffset[Cyan] = 3.66;
    R_TableOffset[Magenta] = 3.76;
    R_TableOffset[Kuro] = 4.0;

    M_TableMax = 100.0;
    M_TableOffset = 2.55;

    OHP_TableMax = 63.0;
    OHP_TableOffset = 4.0;

    // HEIKATSU

    for( color=Yellow; color <= Kuro; color++){

        switch( color ){

        case Yellow:
            strcpy(szColor, "Yellow");
            break;
        case Cyan:
            strcpy(szColor, "Cyan");
            break;
        case Magenta:
            strcpy(szColor, "Magenta");
            break;
        case Kuro:
            strcpy(szColor, "Kuro");
            break;

        }

        printf("HEIKATSU NewTable[%s]\n", szColor);

        for( y=0; y < H_MaxY[color]; y++){


            for( x=0; x < H_MaxX[color]; x++){

                unsigned char ucOut;

                if( x != 0 )
                    printf(",");

                ucOut = (unsigned char)(( H_TableMax[color] - (H_OrgTable[color][y][x] - (FLOAT)0.5)) 
                                          * H_TableOffset[color] );

                printf("%d", ucOut);

            }
            printf("\n");
        }
        printf("\n");

    }

    // ROUGH

    for( color=Yellow; color <= Kuro; color++){

        switch( color ){

        case Yellow:
            strcpy(szColor, "Yellow");
            break;
        case Cyan:
            strcpy(szColor, "Cyan");
            break;
        case Magenta:
            strcpy(szColor, "Magenta");
            break;
        case Kuro:
            strcpy(szColor, "Kuro");
            break;

        }

        printf("ROUGH NewTable[%s]\n", szColor);

        for( y=0; y < R_MaxY[color]; y++){


            for( x=0; x < R_MaxX[color]; x++){

                unsigned char ucOut;

                if( x != 0 )
                    printf(",");

                ucOut = (unsigned char)(( R_TableMax[color] - (R_OrgTable[color][y][x] - (FLOAT)0.5))
                                          * R_TableOffset[color] );

                printf("%d", ucOut);

            }
            printf("\n");
        }
        printf("\n");

    }

    // MONO

    printf("MONO NewTable\n");

    for( y=0; y < M_MaxY; y++){


        for( x=0; x < M_MaxX; x++){

            unsigned char ucOut;

            if( x != 0 )
                printf(",");

            ucOut = (unsigned char)(( M_TableMax - (M_OrgTable[y][x] + (FLOAT)0.5))
                                      * M_TableOffset );

            printf("%d", ucOut);

        }
        printf("\n");
    }

    printf("\n");

    // OHP

    printf("OHP NewTable\n");

    for( y=0; y < OHP_MaxY; y++){


        for( x=0; x < OHP_MaxX; x++){

            unsigned char ucOut;

            if( x != 0 )
                printf(",");

            ucOut = (unsigned char)(( OHP_TableMax - (OHP_OrgTable[y][x] - (FLOAT)0.5))
                                      * OHP_TableOffset );

            printf("%d", ucOut);

        }
        printf("\n");
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\apdlres\common.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"

BOOL APIENTRY 
OEMGetInfo(
    DWORD dwInfo,
    PVOID pBuffer,
    DWORD cbSize,
    PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE(("OEMGetInfo(%s) entry.\n", OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        WARNING(("OEMGetInfo() ERROR_INVALID_PARAMETER.\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        WARNING(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\n"));
        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\apdlres\apdlres.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    cmdcb.c

Abstract:

    Implementation of GPD command callback for "test.gpd":
        OEMCommandCallback

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"

#include <stdio.h>
#ifdef wsprintf
#undef wsprintf
#endif // wsprintf
#define wsprintf sprintf

/*--------------------------------------------------------------------------*/
/*                           G L O B A L  V A L U E                         */
/*--------------------------------------------------------------------------*/
/*======================= P A P E R  S I Z E T A B L E =====================*/
const PHYSIZE phySize[12] = {
//      Width    Height        Physical paper size for 600dpi
       (0x1AAC),(0x2604),      // A3 1B66 x 26C4
       (0x12A5),(0x1AAC),      // A4 1362 x 1B66
       (0x0CEC),(0x12A4),      // A5
       (0x0000),(0x0000),      // A6 (Reserved)
       (0x16FA),(0x20DA),      // B4 17B8 x 2196
       (0x100F),(0x16FA),      // B5 10CE x 17B8
       (0x0000),(0x0000),      // B6 (Reserved)
       (0x087E),(0x0CEC),      // Post Card 93C x DAA (Origin is EE)
       (0x1330),(0x190C),      // Letter 13CE x 19C8
       (0x1330),(0x2014),      // Legal
       (0x0000),(0x0000),      // Executive (Reserved)
       (0x0000),(0x0000)       // Unfixed
};
/*==================== A / P D L  C O M M A N D  S T R I N G ===============*/
const BYTE CmdInAPDLMode[]    = {0x1B,0x7E,0x12,0x00,0x01,0x07};
const BYTE CmdOutAPDLMode[]   = {0x1B,0x7E,0x12,0x00,0x01,0x00};
const BYTE CmdAPDLStart[]     = {0x1C,0x01}; // A/PDL start
const BYTE CmdAPDLEnd[]       = {0x1C,0x02}; // A/PDL end
const BYTE CmdBeginPhysPage[] = {0x1C,0x03}; // Begin Physical Page
const BYTE CmdEndPhysPage[]   = {0x1C,0x04}; // End Physical Page
const BYTE CmdBeginLogPage[]  = {0x1C,0x05}; // Begin Logical page
const BYTE CmdEndLogPage[] = {0x1C,0x06}; // End Logical Page
const BYTE CmdEjectPhysPaper[] = {0x1C,0x0F};  // Print&Eject Phys Paper
//BYTE CmdMoveHoriPos[]   = {0x1C,0x21,0x00,0x00};      // Horizontal Relative
//BYTE CmdMoveVertPos[]   = {0x1C,0x22,0x00,0x00};      // Vertical Relative
const BYTE CmdGivenHoriPos[] = {0x1C,0x23,0x00,0x00}; // Horizontal Absolute
const BYTE CmdGivenVertPos[] = {0x1C,0x24,0x00,0x00}; // Vertical Absolute
const BYTE CmdSetGivenPos[] = {0x1C,0x40,0x00,0x00,0x00,0x00};
//BYTE CmdPrnStrCurrent[] = {0x1C,0xC3,0x00,0x00,0x03}; // Print String
const BYTE CmdBoldItalicOn[] = {
    0x1C,0xA5,0x08,0x04,0x06,0x02,0x30,0x00,0x00,0x00,0x00};
const BYTE CmdBoldOn[] = {
    0x1C,0xA5,0x04,0x04,0x02,0x02,0x20};
const BYTE CmdItalicOn[] = {
    0x1c,0xa5,0x08,0x04,0x06,0x02,0x10,0x00,0x00,0x00,0x00};
const BYTE CmdBoldItalicOff[] = {
    0x1c,0xa5,0x04,0x04,0x02,0x02,0x00};
//#287122
const BYTE CmdDelTTFont[]   = {0x1C,0x20,0xFF,0xFF};


// for vertical font x adjustment
const BYTE CmdSelectSingleByteMincho[] = {0x1C,0xA5,0x03,0x02,0x01,0x01};

//980212 #284407
//const BYTE CmdSelectDoubleByteMincho[] = {0x1C,0xA5,0x03,0x02,0x00,0x00};
const BYTE CmdSelectDoubleByteMincho[] = {0x1C,0xA5,0x03,0x02,0x01,0x00};

const BYTE CmdSelectSingleByteGothic[] = {0x1C,0xA5,0x03,0x02,0x03,0x03};

//980212 #284407
//const BYTE CmdSelectDoubleByteGothic[] = {0x1C,0xA5,0x03,0x02,0x02,0x02};
const BYTE CmdSelectDoubleByteGothic[] = {0x1C,0xA5,0x03,0x02,0x03,0x02};

#define CmdSetPhysPaper pOEM->ajCmdSetPhysPaper
#define CmdSetPhysPage pOEM->ajCmdSetPhysPage
#define CmdDefDrawArea pOEM->ajCmdDefDrawArea

const BYTE XXXCmdSetPhysPaper[]  = {0x1C,0xA0,         // Set Physical Paper
                           0x10,              // length
                           0x01,              // SubCmd Basic Characteristics
                           0x05,              // SubCmdLength
                           0x01,              // Paper Size
                           0x01,              // PaperTray
                           0x00,              // AutoTrayMode
                           00,                // Duplex Mode
                           0x01,              // Copy Count
                           0x02,              // SubCmd Set Unfixed Paper Size
                           0x07,              // SubCmdLength
                           00,                // UnitBase
                           00,00,             // Logical Unit
                           00,00,             // Width
                           00,00};            // Height

const BYTE XXXCmdSetPhysPage[]   = {0x1C,0xA1,         // Set Physical Page
                           0x0D,              // Length
                           0x01,              // SubCmd Resolution
                           0x03,              // SubCmdLength
                           00,                // Unit Base of 10
                           0x0B,0xB8,         // and Logical Unit Res of 3000
                           0x02,              // SubCmd Toner Save
                           0x01,              // SubCmdLength
                           00,                // Toner Save OFF
                           0x03,              // SubCmd N-Up
                           0x03,              // SubCmdLength 
                           00,00,00};         // N-Up off 

const BYTE XXXCmdDefDrawArea[]   = {0x1C,0xA2,         // Define Drawing Area
                           0x0D,              // length
                           0x01,              // SubCmd origin width,height
                           0x08,              // SubCmdLength
                           0x00,0x77,         // origin X
                           0x00,0x77,         // origin Y
                           00,00,             // width
                           00,00,             // height
                           0x02,              // SubCmd Media Origin
                           0x01,              // SubCmdLength
                           00};               // Portrait

/*****************************************************************************/
/*                                                                           */
/*  Module:         APDLRES.DLL                                              */
/*                                                                           */
/*  Function:       OEMEnablePDEV                                            */
/*                                                                           */
/*  Syntax:         PDEVOEM APIENTRY OEMEnablePDEV(                          */
/*                                      PDEVOBJ         pdevobj,             */
/*                                      PWSTR           pPrinterName,        */
/*                                      ULONG           cPatterns,           */
/*                                      HSURF          *phsurfPatterns,      */
/*                                      ULONG           cjGdiInfo,           */
/*                                      GDIINFO        *pGdiInfo,            */
/*                                      ULONG           cjDevInfo,           */
/*                                      DEVINFO        *pDevInfo,            */
/*                                      DRVENABLEDATA  *pded)                */
/*                                                                           */
/*  Description:    Allocate buffer of private data to pdevobj               */
/*                                                                           */
/*****************************************************************************/
PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded)
{
    PAPDLPDEV pOEM;

    if(!pdevobj->pdevOEM)
    {
        if(!(pdevobj->pdevOEM = MemAllocZ(sizeof(APDLPDEV))))
        {
            ERR(("Faild to allocate memory. (%d)\n",
                GetLastError()));
            return NULL;
        }
    }

    pOEM = (PAPDLPDEV)pdevobj->pdevOEM;

    CopyMemory(CmdSetPhysPaper, XXXCmdSetPhysPaper,
        sizeof(XXXCmdSetPhysPaper));
    CopyMemory(CmdSetPhysPage, XXXCmdSetPhysPage,
        sizeof(XXXCmdSetPhysPage));
    CopyMemory(CmdDefDrawArea, XXXCmdDefDrawArea,
        sizeof(XXXCmdDefDrawArea));

    return pdevobj->pdevOEM;
}

/*****************************************************************************/
/*                                                                           */
/*  Module:         APDLRES.DLL                                              */
/*                                                                           */
/*  Function:       OEMDisablePDEV                                           */
/*                                                                           */
/*  Syntax:         VOID APIENTRY OEMDisablePDEV(                            */
/*                                          PDEVOBJ     pdevobj)             */
/*                                                                           */
/*  Description:    Free buffer of private data                              */
/*                                                                           */
/*****************************************************************************/
VOID APIENTRY
OEMDisablePDEV(
    PDEVOBJ     pdevobj)
{
    PAPDLPDEV pOEM = (PAPDLPDEV)pdevobj->pdevOEM;

    if(pdevobj->pdevOEM)
    {
        if (NULL != pOEM->pjTempBuf) {
            MemFree(pOEM->pjTempBuf);
            pOEM->pjTempBuf = NULL;
            pOEM->dwTempBufLen = 0;
        }
        MemFree(pdevobj->pdevOEM);
        pdevobj->pdevOEM = NULL;
    }
    return;
}

BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
{
    PAPDLPDEV pOEMOld, pOEMNew;
    PBYTE pTemp;

    pOEMOld = (PAPDLPDEV)pdevobjOld->pdevOEM;
    pOEMNew = (PAPDLPDEV)pdevobjNew->pdevOEM;

    if (pOEMOld != NULL && pOEMNew != NULL) {
        pTemp = pOEMNew->pjTempBuf;
        *pOEMNew = *pOEMOld;
        pOEMNew->pjTempBuf = pTemp;
    }

    return TRUE;
}

/*****************************************************************************/
/*                                                                           */
/*  Module:    OEMFilterGraphics                                             */
/*                                                                           */
/*  Function:                                                                */
/*                                                                           */
/*  Syntax:    BOOL APIENTRY OEMFilterGraphics(PDEVOBJ, PBYTE, DWORD)        */
/*                                                                           */
/*  Input:     pdevobj     address of PDEVICE structure                      */
/*             pBuf        points to buffer of graphics data                 */
/*             dwLen       length of buffer in bytes                         */
/*                                                                           */
/*  Output:    BOOL                                                          */
/*                                                                           */
/*  Notice:    nFunction and Escape numbers are the same                     */
/*                                                                           */
/*****************************************************************************/

BOOL
APIENTRY
OEMFilterGraphics(
    PDEVOBJ pdevobj,
    PBYTE pBuf,
    DWORD dwLen)
{
    PAPDLPDEV           pOEM;
    ULONG               ulHorzPixel;

    BOOL bComp = TRUE;
    BYTE jTemp[15];
    DWORD dwOutLen;
    DWORD dwTemp;
    INT iTemp;
    DWORD dwPaddingCount;  /* #441427 */

    WORD wTmpHeight ;
    DWORD dwNewBufLen = 0 ;

    pOEM = (PAPDLPDEV)pdevobj->pdevOEM;

    //We have to make image hight multiple of 8
    if ( pOEM->wImgHeight % 8 != 0){

        VERBOSE(("Pad zeros to make multiple of 8\n"));

        wTmpHeight = ((pOEM->wImgHeight + 7) / 8) * 8; 
        dwNewBufLen = (DWORD)(wTmpHeight * pOEM->wImgWidth) / 8;
    }
    else{

        wTmpHeight = pOEM->wImgHeight;
        dwNewBufLen = dwLen;
    }

    if (NULL == pOEM->pjTempBuf ||
        dwNewBufLen > pOEM->dwTempBufLen) {

        if (NULL != pOEM->pjTempBuf) {
            MemFree(pOEM->pjTempBuf);
        }
        pOEM->pjTempBuf = (PBYTE)MemAlloc(dwNewBufLen);
        if (NULL == pOEM->pjTempBuf) {
            ERR(("Faild to allocate memory. (%d)\n",
                GetLastError()));

            // Still try to ouptut with no compression.
            bComp = FALSE;
        }
        pOEM->dwTempBufLen = dwNewBufLen;
    }

    dwOutLen = dwNewBufLen;

    if (bComp) {

        // try compression
        dwOutLen = BRL_ECmd(
            (PBYTE)pBuf,
            (PBYTE)pOEM->pjTempBuf,
            dwLen,
            dwNewBufLen);

        if (dwOutLen >= dwNewBufLen) {
            bComp = FALSE;
            dwOutLen = dwNewBufLen;
        }
    }

/* #441427: if bComp==FALSE, pjTempBuf == NULL */
//    if (!bComp) {
//        // Construct padding zeros.
//        ZeroMemory(pOEM->pjTempBuf, (dwOutLen - dwLen));
//    }

    iTemp = 0;
    jTemp[iTemp++] = 0x1c;
    jTemp[iTemp++] = 0xe1;

    // Set the LEN of the DrawBlockImage command
    dwTemp = dwOutLen + (bComp ? 9 : 5);
    jTemp[iTemp++] = (BYTE)((dwTemp >> 24) & 0xff);
    jTemp[iTemp++] = (BYTE)((dwTemp >> 16) & 0xff);
    jTemp[iTemp++] = (BYTE)((dwTemp >> 8) & 0xff);
    jTemp[iTemp++] = (BYTE)((dwTemp >> 0) & 0xff);

    jTemp[iTemp++] = (bComp ? 1 : 0);

    // Set the WIDTH parameter of the DrawBlockImage command
    jTemp[iTemp++] = HIBYTE(pOEM->wImgWidth);
    jTemp[iTemp++] = LOBYTE(pOEM->wImgWidth);

    // Set height parameters (9,10 byte)
    jTemp[iTemp++] = HIBYTE(wTmpHeight);
    jTemp[iTemp++] = LOBYTE(wTmpHeight);

    if (bComp) {
        // length of uncompressed data
        jTemp[iTemp++] = (BYTE)((dwNewBufLen >> 24) & 0xff);
        jTemp[iTemp++] = (BYTE)((dwNewBufLen >> 16) & 0xff);
        jTemp[iTemp++] = (BYTE)((dwNewBufLen >> 8) & 0xff);
        jTemp[iTemp++] = (BYTE)((dwNewBufLen >> 0) & 0xff);
    }

    // Draw Block Image at Current Position
    WRITESPOOLBUF(pdevobj, jTemp, iTemp);
    if (bComp) {
        // Output compressed data, which also contains
        // padding zeros.
        WRITESPOOLBUF(pdevobj, pOEM->pjTempBuf, dwOutLen);
    }
    else {
        // Output uncompressed data, with padding zeros.

        WRITESPOOLBUF(pdevobj, pBuf, dwLen);

        /* #441427: if bComp==FALSE, pjTempBuf == NULL */
        if ( (dwOutLen - dwLen) != 0 )
        {
            for ( dwPaddingCount = 0 ; dwPaddingCount < dwOutLen - dwLen ; dwPaddingCount++ )
            {
                WRITESPOOLBUF(pdevobj, "\x00", 1 );
            }
        }
        //WRITESPOOLBUF(pdevobj, pOEM->pjTempBuf,
        //   (dwOutLen - dwLen));
    }

    return TRUE;
}

/*****************************************************************************/
/*                                                                           */
/*  Module:    OEMCommandCallback                                            */
/*                                                                           */
/*  Function:                                                                */
/*                                                                           */
/*  Syntax:    INT APIENTRY OEMCommandCallback(PDEVOBJ,DWORD,DWORD,PDWORD)   */
/*                                                                           */
/*  Input:     pdevobj                                                       */
/*             dwCmdCbID                                                     */
/*             dwCount                                                       */
/*             pdwParams                                                     */
/*                                                                           */
/*  Output:    INT                                                           */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/
INT APIENTRY
OEMCommandCallback(
    PDEVOBJ pdevobj,    // Points to private data required by the Unidriver.dll
    DWORD   dwCmdCbID,  // Callback ID
    DWORD   dwCount,    // Counts of command parameter
    PDWORD  pdwParams ) // points to values of command params
{
    PAPDLPDEV       pOEM;
    WORD            wTemp;
    WORD            wPhysWidth;
    WORD            wPhysHeight;
    WORD            wXval;
    WORD            wYval;
// #278517: RectFill
    BYTE            CmdDrawLine[] =
                    { 0x1C,0x81,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 };

    pOEM = (PAPDLPDEV)pdevobj->pdevOEM;

    switch(dwCmdCbID)
    {
        case PAGECONTROL_BEGIN_JOB:
            //Move these command from PAGECONTROL_BEGIN_DOC

            /* Send Change Data Stream Command for Enter A/PDL mode */
            WRITESPOOLBUF(pdevobj, CmdInAPDLMode, 6);

            /* Send A/PLDL start Command */
            WRITESPOOLBUF(pdevobj, CmdAPDLStart, 2);

            /* Delete downloaded font */
            //#287122
            //To clean up downloaded font in the printer.
            //#304858
            //This command makes printer do FF, cause error of duplex.
            //and #287122 does not replo with this chenge.
            WRITESPOOLBUF(pdevobj, CmdDelTTFont, 4);

            break ;

        /*------------------------------------------------------*/
        /* A/PDL start now                                      */
        /*------------------------------------------------------*/
        case PAGECONTROL_BEGIN_DOC:
            /* reset flag of sent Set Physical Paper command */
            pOEM->fSendSetPhysPaper = FALSE;

            /* initialize flag */
            pOEM->fDuplex = FALSE;
            CmdSetPhysPage[10] = 0x00;

            break;

        /*------------------------------------------------------*/
        /* send Page Description command                        */
        /*------------------------------------------------------*/
        case PAGECONTROL_BEGIN_PAGE:
            pOEM->fGeneral |= (BIT_FONTSIM_RESET
                             | BIT_XMOVE_ABS
                             | BIT_YMOVE_ABS);
            pOEM->wXPosition = 0;
            pOEM->wYPosition = 0;
            pOEM->bCurByteMode = BYTE_BYTEMODE_RESET;

            /* reset duplex mode if fDuplex is FALSE */
            if(!pOEM->fDuplex)
                CmdSetPhysPaper[8] = 0x00;     // Duplex OFF

            /* send Set Physical Paper command */
            WRITESPOOLBUF(pdevobj,
                                CmdSetPhysPaper, sizeof(CmdSetPhysPaper));

            if(pOEM->ulHorzRes == 600)   // set unit base
            {
                CmdSetPhysPage[6] = 0x17;
                CmdSetPhysPage[7] = 0x70;
            } else {
                CmdSetPhysPage[6] = 0x0B;
                CmdSetPhysPage[7] = 0xB8;
            }

            // send Set Physical Page command
            WRITESPOOLBUF(pdevobj, CmdSetPhysPage, sizeof(CmdSetPhysPage));

            // send Begin Physical Page command
            WRITESPOOLBUF(pdevobj, 
                                CmdBeginPhysPage, sizeof(CmdBeginPhysPage));

            // send Begin Logical Page command
            WRITESPOOLBUF(pdevobj, CmdBeginLogPage, sizeof(CmdBeginLogPage));

            // send Define Drawing Area command
            WRITESPOOLBUF(pdevobj, CmdDefDrawArea, sizeof(CmdDefDrawArea));
            break;

        case PAGECONTROL_END_PAGE:
            if(pOEM->wCachedBytes)
                VOutputText(pdevobj);

            // send End Logical Page command
            WRITESPOOLBUF(pdevobj, CmdEndLogPage, sizeof(CmdEndLogPage));

            // send End Physical Page command
            WRITESPOOLBUF(pdevobj, CmdEndPhysPage, sizeof(CmdEndPhysPage));
            break;

        case PAGECONTROL_ABORT_DOC:
        case PAGECONTROL_END_DOC:
            if(pOEM->wCachedBytes)
                VOutputText(pdevobj);

            // Send delete DL char ID command
            if(pOEM->wNumDLChar)
            {
                WRITESPOOLBUF(pdevobj, "\x1c\x20\xff\xff", 4);
                pOEM->wNumDLChar = 0;
            }

            /* Delete downloaded font
            WRITESPOOLBUF(pdevobj, CmdDelTTFont, 4);

            // send A/PDL End command
            WRITESPOOLBUF(pdevobj, CmdAPDLEnd, sizeof(CmdAPDLEnd));

            // Send A/PDL Mode out command
            WRITESPOOLBUF(pdevobj, CmdOutAPDLMode, sizeof(CmdOutAPDLMode));

            break;

        /*------------------------------------------------------*/
        /* save print direction                                 */
        /*------------------------------------------------------*/
        case PAGECONTROL_POTRAIT:           // 36
            pOEM->fOrientation = TRUE;
            break;

        case PAGECONTROL_LANDSCAPE:         // 37
            pOEM->fOrientation = FALSE;
            break;

        /*------------------------------------------------------*/
        /* save resolution                                     */
        /*------------------------------------------------------*/
        case RESOLUTION_300:
            pOEM->ulHorzRes = 300;
            pOEM->ulVertRes = 300;
            break;

        case RESOLUTION_600:
            pOEM->ulHorzRes = 600;
            pOEM->ulVertRes = 600;
            break;

        case SEND_BLOCK_DATA:
            // for graphics printing, send cursor move command at here
            VSendCursorMoveCommand( pdevobj, FALSE );

            pOEM->wImgWidth = (WORD)(PARAM(pdwParams, 1) * 8);
            pOEM->wImgHeight = (WORD)PARAM(pdwParams, 2);
            break;

        /*------------------------------------------------------*/
        /* set Drawing Area into SetPhysPaperDesc command       */
        /*------------------------------------------------------*/
        case PHYS_PAPER_A3:                 // 50
        case PHYS_PAPER_A4:                 // 51
        case PHYS_PAPER_B4:                 // 54
        case PHYS_PAPER_LETTER:             // 57
        case PHYS_PAPER_LEGAL:              // 58
            pOEM->szlPhysSize.cx = PARAM(pdwParams, 0);
            pOEM->szlPhysSize.cy = PARAM(pdwParams, 1);
            CmdSetPhysPaper[5] = SetDrawArea(pdevobj, dwCmdCbID);
            break;

        case PHYS_PAPER_B5:                 // 55
        case PHYS_PAPER_A5:                 // 52
            pOEM->szlPhysSize.cx = PARAM(pdwParams, 0);
            pOEM->szlPhysSize.cy = PARAM(pdwParams, 1);
            CmdSetPhysPaper[5] = SetDrawArea(pdevobj, dwCmdCbID);

            /* even if Duplex is selected, it cancel */
            pOEM->fDuplex = FALSE;
            CmdSetPhysPaper[8] = 0x00;      // Duplex is off
            break;

        case PHYS_PAPER_POSTCARD:           // 59
            pOEM->szlPhysSize.cx = PARAM(pdwParams, 0);
            pOEM->szlPhysSize.cy = PARAM(pdwParams, 1);
            CmdSetPhysPaper[5] = SetDrawArea(pdevobj, dwCmdCbID);

            /* if paper is Postcard, papersource is always Front Tray */
            CmdSetPhysPaper[6] = 0x00;      // select Front Tray
            CmdSetPhysPaper[7] = 0x00;      // Auto Tray Select is OFF

            /* even if Duplex is selected, it cancel */
            pOEM->fDuplex = FALSE;
            CmdSetPhysPaper[8] = 0x00;      // Duplex is off
            break;

        case PHYS_PAPER_UNFIXED:            // 60
            pOEM->szlPhysSize.cx = PARAM(pdwParams, 0);
            pOEM->szlPhysSize.cy = PARAM(pdwParams, 1);

            /* if paper is Unfixed, papersource is always Front Tray */
            CmdSetPhysPaper[6] = 0x00;      // Select Front Tray
            CmdSetPhysPaper[7] = 0x00;      // Auto Tray Select is OFF

            /* even if Duplex is selected, it cancel */
            pOEM->fDuplex = FALSE;
            CmdSetPhysPaper[8] = 0x00;      // Duplex is off

            CmdSetPhysPaper[5] = SetDrawArea(pdevobj, dwCmdCbID);
            CmdSetPhysPaper[12] = 0x00;     // UnitBase : 10 inch

            if(pOEM->ulHorzRes == 600)      // set logical unit
            {
                CmdSetPhysPaper[13] = 0x17;
                CmdSetPhysPaper[14] = 0x70;
            } else {
                CmdSetPhysPaper[13] = 0x0B;
                CmdSetPhysPaper[14] = 0xB8;
            }

            wPhysWidth  = (WORD)pOEM->szlPhysSize.cx / (MASTER_UNIT / (WORD)pOEM->ulHorzRes);
            wPhysHeight = (WORD)pOEM->szlPhysSize.cy / (MASTER_UNIT / (WORD)pOEM->ulHorzRes);

            CmdSetPhysPaper[15] = HIBYTE(wPhysWidth);
            CmdSetPhysPaper[16] = LOBYTE(wPhysWidth);
            CmdSetPhysPaper[17] = HIBYTE(wPhysHeight);
            CmdSetPhysPaper[18] = LOBYTE(wPhysHeight);
            break;

        /*------------------------------------------------------*/
        /* set Paper Tray into SetPhysPaperDesc command         */
        /*------------------------------------------------------*/
        case PAPER_SRC_FTRAY:
            CmdSetPhysPaper[6] = 0x00;      // Select Front Tray
            CmdSetPhysPaper[7] = 0x00;      // Auto Tray Select is OFF
            break;

        case PAPER_SRC_CAS1:
            CmdSetPhysPaper[6] = 0x01;      // Select Cassette 1
            CmdSetPhysPaper[7] = 0x00;      // Auto Tray Select is OFF
            break;

        case PAPER_SRC_CAS2:
            CmdSetPhysPaper[6] = 0x02;      // Select Cassette 2
            CmdSetPhysPaper[7] = 0x00;      // Auto Tray Select is OFF
            break;

        case PAPER_SRC_CAS3:
            CmdSetPhysPaper[6] = 0x03;      // Select Cassette 3
            CmdSetPhysPaper[7] = 0x00;      // Auto Tray Select is OFF
            break;
        case PAPER_SRC_AUTO_SELECT:         //Auto Tray Select ON
            if(pOEM->fScaleToFit == TRUE){  //Select PAPER_DEST_SCALETOFIT_ON
                CmdSetPhysPaper[6] = 0x01;
                CmdSetPhysPaper[7] = 0x03;
            }
            else if(pOEM->fScaleToFit == FALSE){ 
                CmdSetPhysPaper[6] = 0x01;
                CmdSetPhysPaper[7] = 0x01;
            }
            break;


        /*------------------------------------------------------*/
        /* set Auto Tray Mode into SetPhysPaperDesc command     */
        /*------------------------------------------------------*/
        case PAPER_DEST_SCALETOFIT_ON:      // 25
            pOEM->fScaleToFit = TRUE;
            CmdSetPhysPaper[7] = 0x02;
            break;

        case PAPER_DEST_SCALETOFIT_OFF:     // 26
            pOEM->fScaleToFit = FALSE;
            CmdSetPhysPaper[7] = 0x00;
            break;

        /*------------------------------------------------------*/
        /* set Duplex Mode into SetPhysPaperDesc command        */
        /*------------------------------------------------------*/
        case PAGECONTROL_DUPLEX_UPDOWN:
            pOEM->fDuplex = TRUE;
            CmdSetPhysPaper[8] = 0x01;      // Up Side Down
            break;

        case PAGECONTROL_DUPLEX_RIGHTUP:
            pOEM->fDuplex = TRUE;
            CmdSetPhysPaper[8] = 0x02;      // Right Side Up
            break;

        case PAGECONTROL_DUPLEX_OFF:
            pOEM->fDuplex = FALSE;
            break;

        /*------------------------------------------------------*/
        /* set Toner Save into SetPhysPage command              */
        /*------------------------------------------------------*/
        case TONER_SAVE_OFF:                // 100
            CmdSetPhysPage[10] = 0x00;      // off
            break;

        case TONER_SAVE_DARK:               // 101
            CmdSetPhysPage[10] = 0x02;      // dark
            break;

        case TONER_SAVE_LIGHT:              // 102
            CmdSetPhysPage[10] = 0x01;      // right
            break;

        /*------------------------------------------------------*/
        /* set Copy Count to SetPhysPaperDesc command           */
        /*------------------------------------------------------*/
        case PAGECONTROL_MULTI_COPIES:
// @Aug/31/98 ->
           if(MAX_COPIES_VALUE < *pdwParams) {
               CmdSetPhysPaper[9] = MAX_COPIES_VALUE;
           }
           else if (1 > *pdwParams) {
               CmdSetPhysPaper[9] = 1;
           }
           else {
               CmdSetPhysPaper[9] = (BYTE)*pdwParams;
           }
// @Aug/31/98 <-
            break;

       /*------------------------------------------------------*/
        /* send Set Character Attribute with ornament           */
        /*------------------------------------------------------*/
        case BOLD_ON:
            if(!(pOEM->fGeneral & BIT_FONTSIM_BOLD))
            {
                if(pOEM->wCachedBytes)
                    VOutputText(pdevobj);

                pOEM->fGeneral |= BIT_FONTSIM_BOLD;
            }
            break;

        case ITALIC_ON:
            if(!(pOEM->fGeneral & BIT_FONTSIM_ITALIC))
            {
                if(pOEM->wCachedBytes)
                    VOutputText(pdevobj);

                pOEM->fGeneral |= BIT_FONTSIM_ITALIC;
            }
            break;

        case BOLD_OFF:
            if(pOEM->fGeneral & BIT_FONTSIM_BOLD)
            {
                if(pOEM->wCachedBytes)
                    VOutputText(pdevobj);

                pOEM->fGeneral &= ~BIT_FONTSIM_BOLD;
            }
            break;

        case ITALIC_OFF:
            if(pOEM->fGeneral & BIT_FONTSIM_ITALIC)
            {
                if(pOEM->wCachedBytes)
                    VOutputText(pdevobj);

                pOEM->fGeneral &= ~BIT_FONTSIM_ITALIC;
            }
            break;

        case SELECT_SINGLE_BYTE:
            if(ISVERTICALFONT(pOEM->bFontID))
            {
                if(pOEM->bCurByteMode == BYTE_DOUBLE_BYTE)
                {
                    if(pOEM->wCachedBytes)
                        VOutputText(pdevobj);
                    
                    if(pOEM->bFontID == MINCHO_VERT)
                        WRITESPOOLBUF(pdevobj, CmdSelectSingleByteMincho, 
                                            sizeof(CmdSelectSingleByteMincho));
                    else if(pOEM->bFontID == GOTHIC_VERT)
                        WRITESPOOLBUF(pdevobj, CmdSelectSingleByteGothic, 
                                            sizeof(CmdSelectSingleByteGothic));
                        
                }
                pOEM->bCurByteMode = BYTE_SINGLE_BYTE;
            }
            break;

        case SELECT_DOUBLE_BYTE:
            if(ISVERTICALFONT(pOEM->bFontID))
            {
                if(pOEM->bCurByteMode == BYTE_SINGLE_BYTE)
                {
                    if(pOEM->wCachedBytes)
                        VOutputText(pdevobj);

                    if(pOEM->bFontID == MINCHO_VERT)
                        WRITESPOOLBUF(pdevobj, CmdSelectDoubleByteMincho, 
                                            sizeof(CmdSelectDoubleByteMincho));
                    else if(pOEM->bFontID == GOTHIC_VERT)
                        WRITESPOOLBUF(pdevobj, CmdSelectDoubleByteGothic, 
                                            sizeof(CmdSelectDoubleByteGothic));
                        
                }
                pOEM->bCurByteMode = BYTE_DOUBLE_BYTE;
            }
            break;

        /*------------------------------------------------------*/
        /* Send 
        /*------------------------------------------------------*/
        case X_ABS_MOVE:
            if(pOEM->wCachedBytes)
                VOutputText(pdevobj);

            pOEM->wUpdateXPos = 0;
            wTemp = (WORD)*pdwParams / (MASTER_UNIT / (WORD)pOEM->ulHorzRes);
            pOEM->wXPosition = wTemp;
            pOEM->fGeneral |= BIT_XMOVE_ABS;
            return wTemp;

        case Y_ABS_MOVE:
            if(pOEM->wCachedBytes)
                VOutputText(pdevobj);

            //#332101 prob.4: wUpdateXPos is cleared only when X_ABS_MOVE and CR.
            //pOEM->wUpdateXPos = 0;
            wTemp = (WORD)*pdwParams / (MASTER_UNIT / (WORD)pOEM->ulVertRes);
            pOEM->wYPosition = wTemp;
            pOEM->fGeneral |= BIT_YMOVE_ABS;
            return wTemp;

        case CR_EMULATION:
            pOEM->wXPosition = 0;
            pOEM->wUpdateXPos = 0;
            pOEM->fGeneral |= BIT_XMOVE_ABS;
            break;

        case SET_CUR_GLYPHID:
            if(!pdwParams || dwCount != 1)
            {
                ERR(("OEMCommandCallback: parameter is invalid.\n"));
                return 0;
            }

            if(*pdwParams < MIN_GLYPH_ID || *pdwParams > MAX_GLYPH_ID)
            {
                ERR(("OEMCommandCallback: glyph id is out of range.\n"));
                return 0;
            }
            pOEM->wGlyphID = (WORD)*pdwParams;
            break;

// #278517: RectFill
        case RECT_SET_WIDTH:
            wTemp = (WORD)*pdwParams / (MASTER_UNIT / (WORD)pOEM->ulHorzRes);
            pOEM->wRectWidth = wTemp;
            break;

        case RECT_SET_HEIGHT:
            wTemp = (WORD)*pdwParams / (MASTER_UNIT / (WORD)pOEM->ulVertRes);
            pOEM->wRectHeight = wTemp;
            break;

        case RECT_FILL_BLACK:
            wTemp = pOEM->wXPosition;
            CmdDrawLine[2] = HIBYTE(wTemp);
            CmdDrawLine[3] = LOBYTE(wTemp);
            wTemp = pOEM->wYPosition;
            CmdDrawLine[4] = HIBYTE(wTemp);
            CmdDrawLine[5] = LOBYTE(wTemp);
            wTemp = pOEM->wRectWidth;
            CmdDrawLine[6] = HIBYTE(wTemp);
            CmdDrawLine[7] = LOBYTE(wTemp);
            wTemp = pOEM->wRectHeight;
            CmdDrawLine[8] = HIBYTE(wTemp);
            CmdDrawLine[9] = LOBYTE(wTemp);
            WRITESPOOLBUF(pdevobj, CmdDrawLine, sizeof(CmdDrawLine));
            break;

        default:
            break;
    }
    return 0;
}

/*****************************************************************************/
/*                                                                           */
/*  Module:    OEMOutputCharStr                                              */
/*                                                                           */
/*  Function:                                                                */
/*                                                                           */
/*  Syntax:    VOID APIENTRY OEMOutputCharStr(PDEVOBJ, PUNIFONTOBJ, DWORD,   */
/*                                                   DWORD, PVOID)           */
/*                                                                           */
/*  Input:     pdevobj     address of PDEVICE structure                      */
/*             pUFObj                                                        */
/*             dwType                                                        */
/*             dwCount                                                       */
/*             pGlyph                                                        */
/*                                                                           */
/*  Output:    VOID                                                          */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/
VOID APIENTRY
OEMOutputCharStr(
    PDEVOBJ pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD dwType,
    DWORD dwCount,
    PVOID pGlyph )
{
    GETINFO_GLYPHSTRING GStr;
    PAPDLPDEV           pOEM = (PAPDLPDEV)pdevobj->pdevOEM;
    PTRANSDATA          pTrans;
    DWORD               dwI;
    WORD                wLen = (WORD)dwCount;

    PBYTE               pbCommand;
    PDWORD              pdwGlyphID;
    WORD                wFontID;
    WORD                wCmdLen;

    if(!pUFObj)
    {
        ERR(("OEMOutputCharStr: pUFObj is NULL.\n"));
        return;
    }

    switch(dwType)
    {
        case TYPE_GLYPHHANDLE:
            // Send appropriate cursor move command
            VSendCursorMoveCommand( pdevobj, TRUE );

            // Set font simulation if needed
            VSetFontSimulation( pdevobj );

// #333653: Change I/F for GETINFO_GLYPHSTRING begin

            // Translate character code
            GStr.dwSize    = sizeof (GETINFO_GLYPHSTRING);
            GStr.dwCount   = dwCount;
            GStr.dwTypeIn  = TYPE_GLYPHHANDLE;
            GStr.pGlyphIn  = pGlyph;
            GStr.dwTypeOut = TYPE_TRANSDATA;
            GStr.pGlyphOut = NULL;
            GStr.dwGlyphOutSize = 0;        /* new member of GETINFO_GLYPHSTRING */

            /* Get TRANSDATA buffer size */
            if(pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL)
                 || !GStr.dwGlyphOutSize )
            {
                ERR(("Get Glyph String error\n"));
                return ;
            }

            // Alloc translation buffer
            if (NULL == pOEM->pjTempBuf ||
                pOEM->dwTempBufLen < GStr.dwGlyphOutSize)
            {
                if (NULL != pOEM->pjTempBuf) {
                    MemFree(pOEM->pjTempBuf);
                }
                pOEM->pjTempBuf = MemAllocZ(GStr.dwGlyphOutSize);
                if (NULL == pOEM->pjTempBuf)
                {
                    ERR(("Faild to allocate memory. (%d)\n",
                        GetLastError()));
                    return;
                }
                pOEM->dwTempBufLen = GStr.dwGlyphOutSize;
            }
            pTrans = (PTRANSDATA)pOEM->pjTempBuf;

            /* Get actual TRANSDATA */
            GStr.pGlyphOut = pTrans;
            if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL))
            {
                ERR(("GetInfo failed.\n"));
                return;
            }

// #333653: Change I/F for GETINFO_GLYPHSTRING end

            // Spooled device font characters
            for(dwI = 0; dwI < dwCount; dwI++, pTrans++)
            {
                if(pOEM->wCachedBytes + dwCount * 2 > 1024)
                    VOutputText(pdevobj);

                switch(pTrans->ubType & MTYPE_FORMAT_MASK)
                {
                    case MTYPE_DIRECT:
                        pOEM->bCharData[pOEM->wCachedBytes++] = 
                                                        pTrans->uCode.ubCode;
                        break;
                    
                    case MTYPE_PAIRED:
                        pOEM->bCharData[pOEM->wCachedBytes++] = 
                                                    pTrans->uCode.ubPairs[0];
                        pOEM->bCharData[pOEM->wCachedBytes++] = 
                                                    pTrans->uCode.ubPairs[1];
                        break;
                }
            }

            break;  //switch(dwType)

        case TYPE_GLYPHID:
            if(!pOEM->wNumDLChar || pOEM->wNumDLChar > MAX_DOWNLOAD_CHAR)
                return ;

            if (NULL == pOEM->pjTempBuf ||
                pOEM->dwTempBufLen < dwCount * 16) {

                if (NULL != pOEM->pjTempBuf) {
                    MemFree(pOEM->pjTempBuf);
                }
                pOEM->pjTempBuf = MemAllocZ((dwCount * 16));
                if(NULL == pOEM->pjTempBuf) {
                    ERR(("Faild to allocate memory. (%d)\n",
                        GetLastError()));
                    return;
                }
                pOEM->dwTempBufLen = dwCount * 16;
            }
            pbCommand = pOEM->pjTempBuf;
            wCmdLen = 0;
            wFontID = (WORD)(pUFObj->ulFontID - FONT_ID_DIFF);

            VSendCursorMoveCommand( pdevobj, FALSE );

            for (dwI = 0, pdwGlyphID = (PDWORD)pGlyph; 
                                        dwI < dwCount; dwI++, pdwGlyphID++)
            {
                BYTE    CmdPrintDLChar[] = "\x1C\xC1\x00\x04\x00\x00\x00\x00";
                WORD    wGlyphID = *(PWORD)pdwGlyphID;
                WORD    wDownloadedCharID;
                WORD    wXInc;
                WORD    wXAdjust;
                WORD    wYAdjust;

                if(wGlyphID > MAX_GLYPH_ID || wGlyphID < MIN_GLYPH_ID)
                {
                    ERR(("OEMOutputCharStr: GlyphID is invalid. GlyphID = %ld\n", wGlyphID));
                    return;
                }

                // set parameters each a character
                wDownloadedCharID = 
                                pOEM->DLCharID[wFontID][wGlyphID].wCharID;
                wXInc = pOEM->DLCharID[wFontID][wGlyphID].wXIncrement;
                wYAdjust= pOEM->DLCharID[wFontID][wGlyphID].wYAdjust;
                wXAdjust = pOEM->DLCharID[wFontID][wGlyphID].wXAdjust;

                // Position adjusting based on UPPERLEFT of font box
                pbCommand[wCmdLen++] = CmdGivenVertPos[0];
                pbCommand[wCmdLen++] = CmdGivenVertPos[1];
                pbCommand[wCmdLen++] = HIBYTE(pOEM->wYPosition - wYAdjust);
                pbCommand[wCmdLen++] = LOBYTE(pOEM->wYPosition - wYAdjust);

                if(wXAdjust)
                {
                    pbCommand[wCmdLen++] = CmdGivenHoriPos[0];
                    pbCommand[wCmdLen++] = CmdGivenHoriPos[1];
                    pbCommand[wCmdLen++] = HIBYTE(pOEM->wXPosition - wXAdjust);
                    pbCommand[wCmdLen++] = LOBYTE(pOEM->wXPosition - wXAdjust);
                    pOEM->wXPosition -= wXAdjust;
                }

                CmdPrintDLChar[4] = HIBYTE(wDownloadedCharID);
                CmdPrintDLChar[5] = LOBYTE(wDownloadedCharID);
                CmdPrintDLChar[6] = HIBYTE(wXInc);
                CmdPrintDLChar[7] = LOBYTE(wXInc);

                pOEM->wXPosition += wXInc;
                memcpy(pbCommand + wCmdLen, CmdPrintDLChar, 8);
                wCmdLen += 8;
            }
            WRITESPOOLBUF(pdevobj, pbCommand, wCmdLen);

            break;
    }
    return ;
}

/*****************************************************************************/
/*                                                                           */
/*  Module:    OEMSendFontCmd                                                */
/*                                                                           */
/*  Function:  send A/PDL-style font selection command.                      */
/*                                                                           */
/*  Syntax:    VOID APIENTRY OEMSendFontCmd(                                 */
/*                                    PDEVOBJ, PUNIFONTOBJ, PFINVOCATION)    */
/*                                                                           */
/*  Input:     pdevobj     address of PDEVICE structure                      */
/*             pUFObj      address of UNIFONTOBJ structure                   */
/*             pFInv       address of FINVOCATION                            */
/*                                                                           */
/*  Output:    VOID                                                          */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/
VOID APIENTRY 
OEMSendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv )
{
    PAPDLPDEV       pOEM;
    BYTE            rgcmd[CCHMAXCMDLEN];
    PGETINFO_STDVAR pSV;
    DWORD           dwStdVariable[STDVAR_BUFSIZE(2) / sizeof(DWORD)];
    DWORD           i, ocmd = 0;
    WORD            wHeight, wWidth;
//#305000
    WORD wDescend, wAscend ;


    pOEM = (PAPDLPDEV)pdevobj->pdevOEM;

    if(pOEM->wCachedBytes)
        VOutputText(pdevobj);

    pSV = (PGETINFO_STDVAR)dwStdVariable;
    pSV->dwSize = STDVAR_BUFSIZE(2);
    pSV->dwNumOfVariable = 2;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTMAXWIDTH;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV, 
                                                            pSV->dwSize, NULL))
    {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\n"));
        return;
    }

    wHeight = (WORD)pSV->StdVar[0].lStdVariable;
    wWidth = (WORD)pSV->StdVar[1].lStdVariable;

    if(pOEM->ulHorzRes == 300)
    {
        wHeight = (wHeight + 1) / 2;
        wWidth = (wWidth + 1) / 2;
    }

    pOEM->bFontID = (BYTE)pUFObj->ulFontID;

    if(pUFObj->ulFontID == 1 || pUFObj->ulFontID == 2)
    {
        // This font is vertical
        pOEM->wFontHeight = wWidth;
        pOEM->wWidths = wHeight;
    } else {
        // This font is horizontal.
        pOEM->wFontHeight = wHeight;
        pOEM->wWidths = wWidth;
    }

    //#305000: set to base line as a TT fonts.
    wAscend = pUFObj->pIFIMetrics->fwdWinAscender ;
    wDescend = pUFObj->pIFIMetrics->fwdWinDescender ;

    wDescend = pOEM->wFontHeight * wDescend / (wAscend + wDescend) ;
    pOEM->wFontHeight -= wDescend ;


    for (i = 0; i < pFInv->dwCount && ocmd < CCHMAXCMDLEN; )
    {
        if (pFInv->pubCommand[i] == '#' && pFInv->pubCommand[i+1] == 'H')
        {
            rgcmd[ocmd++] = HIBYTE(wHeight);
            rgcmd[ocmd++] = LOBYTE(wHeight);
            i += 2;
        }
        else if (pFInv->pubCommand[i] == '#' 
                                            && pFInv->pubCommand[i+1] == 'W')
        {
            rgcmd[ocmd++] = HIBYTE(wWidth);
            rgcmd[ocmd++] = LOBYTE(wWidth);

            i += 2;
        }
        else
            rgcmd[ocmd++] = pFInv->pubCommand[i++];
    }
    WRITESPOOLBUF(pdevobj, rgcmd, ocmd);

    return ;
}

/*****************************************************************************/
/*                                                                           */
/*  Module:    OEMTTDownloadMethod                                           */
/*                                                                           */
/*  Function:  Choose how to print TrueType font                             */
/*                                                                           */
/*  Syntax:    DWORD APIENTRY OEMTTDownloadMethod(                           */
/*                                    PDEVOBJ, PUNIFONTOBJ)                  */
/*                                                                           */
/*  Input:     pdevobj     address of PDEVICE structure                      */
/*             pUFObj      address of UNIFONTOBJ structure                   */
/*                                                                           */
/*  Output:    DWORD                                                         */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/
DWORD APIENTRY
OEMTTDownloadMethod(
    PDEVOBJ         pdevobj,
    PUNIFONTOBJ     pUFObj)
{
    PAPDLPDEV       pOEM;
    DWORD           dwReturn;

    pOEM = (PAPDLPDEV)pdevobj->pdevOEM;
    dwReturn = TTDOWNLOAD_GRAPHICS;

    if(pOEM->wNumDLChar <= MAX_DOWNLOAD_CHAR)
        dwReturn = TTDOWNLOAD_BITMAP;

    VERBOSE(("TTDownloadMethod: dwReturn=%ld\n", dwReturn));

    return dwReturn;
}

/*****************************************************************************/
/*                                                                           */
/*  Module:    OEMDownloadFontHeader                                         */
/*                                                                           */
/*  Function:  Download font header                                          */
/*                                                                           */
/*  Syntax:    DWORD APIENTRY OEMDownloadFontHeader(                         */
/*                                    PDEVOBJ, PUNIFONTOBJ)                  */
/*                                                                           */
/*  Input:     pdevobj     address of PDEVICE structure                      */
/*             pUFObj      address of UNIFONTOBJ structure                   */
/*                                                                           */
/*  Output:    DWORD                                                         */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/
DWORD APIENTRY
OEMDownloadFontHeader(
    PDEVOBJ         pdevobj, 
    PUNIFONTOBJ     pUFObj)
{
    // dummy support
    return (DWORD)100;
}

/*****************************************************************************/
/*                                                                           */
/*  Module:    OEMDownloadCharGlyph                                          */
/*                                                                           */
/*  Function:  send char glyph                                               */
/*                                                                           */
/*  Syntax:    DWORD APIENTRY OEMDownloadFontHeader(                         */
/*                                 PDEVOBJ, PUNIFONTOBJ, HGLYPH, PDWORD)     */
/*                                                                           */
/*  Input:     pdevobj     address of PDEVICE structure                      */
/*             pUFObj      address of UNIFONTOBJ structure                   */
/*             hGlyph      handle of glyph                                   */
/*             pdwWidth    address of glyph width                            */
/*                                                                           */
/*  Output:    DWORD                                                         */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/
DWORD APIENTRY
OEMDownloadCharGlyph(
    PDEVOBJ         pdevobj,
    PUNIFONTOBJ     pUFObj,
    HGLYPH          hGlyph,
    PDWORD          pdwWidth)
{
    PAPDLPDEV           pOEM = (PAPDLPDEV)pdevobj->pdevOEM;

    GETINFO_GLYPHBITMAP GD;
    GLYPHBITS          *pgb;

    WORD                wSrcGlyphWidth;
    WORD                wSrcGlyphHeight;
    WORD                wDstGlyphWidthBytes;
    WORD                wDstGlyphHeight;
    WORD                wDstGlyphBytes;

    WORD                wLeftMarginBytes;
    WORD                wShiftBits;

    PBYTE               pSrcGlyph;
    PBYTE               pDstGlyphSave;
    PBYTE               pDstGlyph;

    WORD                i, j;

    BYTE                CmdDownloadChar[] = 
                                "\x1c\xc0\x00\x00\x00\x00\x00\x00\x00\x00\x00";
    WORD                wGlyphID;
    WORD                wFontID;
    WORD                wXCharInc;

    if(!pUFObj)
    {
        ERR(("OEMDownloadCharGlyph: pUFObj is NULL.\n"));
        return 0;
    }

    wGlyphID = pOEM->wGlyphID;
    wFontID = (WORD)(pUFObj->ulFontID - FONT_ID_DIFF);

    if(wGlyphID > MAX_GLYPH_ID || wFontID > MAX_FONT_ID)
    {
        ERR(("Parameter is invalid.\n"));
        return 0;
    }

    // Get glyph bitmap
    GD.dwSize = sizeof(GETINFO_GLYPHBITMAP);
    GD.hGlyph = hGlyph;
    GD.pGlyphData = NULL;
    if(!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHBITMAP, &GD, 
                                                            GD.dwSize, NULL))
    {
        ERR(("UFO_GETINFO_GLYPHBITMAP failed.\n"));
        return 0;
    }

    // set parameters
    pgb = GD.pGlyphData->gdf.pgb;

    // set source glyph bitmap size
    wSrcGlyphWidth = (WORD)((pgb->sizlBitmap.cx + 7) / 8);
    wSrcGlyphHeight = (WORD)pgb->sizlBitmap.cy;

    // set dest. glyph bitmap size
    if(pgb->ptlOrigin.x >= 0)
    {
        wDstGlyphWidthBytes = (WORD)(((pgb->sizlBitmap.cx
                                         + pgb->ptlOrigin.x) + 7) / 8);

        wLeftMarginBytes = (WORD)(pgb->ptlOrigin.x / 8);
        pOEM->DLCharID[wFontID][wGlyphID].wXAdjust = 0;
        wShiftBits = (WORD)(pgb->ptlOrigin.x % 8);
    } else {
        wDstGlyphWidthBytes = (WORD)((pgb->sizlBitmap.cx + 7) / 8);
        wLeftMarginBytes = 0;
        pOEM->DLCharID[wFontID][wGlyphID].wXAdjust
                                                 = (WORD)ABS(pgb->ptlOrigin.x);
        wShiftBits = 0;
    }

    wDstGlyphHeight = wSrcGlyphHeight;
    wDstGlyphBytes = wDstGlyphWidthBytes * wDstGlyphHeight;

    if (wDstGlyphWidthBytes * 8 > MAXGLYPHWIDTH
            || wDstGlyphHeight > MAXGLYPHHEIGHT
            || wDstGlyphBytes > MAXGLYPHSIZE)
    {
        ERR(("No more glyph can be downloaded.\n"));
        return 0;
    }

    // set pointer of bitmap area
    if (NULL == pOEM->pjTempBuf ||
        pOEM->dwTempBufLen < wDstGlyphBytes) {

        if (NULL != pOEM->pjTempBuf) {
            MemFree(pOEM->pjTempBuf);
        }
        pOEM->pjTempBuf = MemAllocZ(wDstGlyphBytes);
        if (NULL == pOEM->pjTempBuf)
        {
            ERR(("Memory alloc failed.\n"));
            return 0;
        }
        pOEM->dwTempBufLen = wDstGlyphBytes;
    }
    pDstGlyph = pOEM->pjTempBuf;
    pSrcGlyph = pgb->aj;

    // create Dst Glyph
    for(i = 0; i < wSrcGlyphHeight && pSrcGlyph && pDstGlyph; i++)
    {
        if(wLeftMarginBytes)
        {
            memset(pDstGlyph, 0, wLeftMarginBytes);
            pDstGlyph += wLeftMarginBytes;
        }

        if(wShiftBits)
        {
            // First byte
            *pDstGlyph++ = (BYTE)((*pSrcGlyph++) >> wShiftBits);

            for(j = 0; j < wSrcGlyphWidth - 1; j++, pSrcGlyph++, pDstGlyph++)
            {
                WORD    wTemp1 = (WORD)*(pSrcGlyph - 1);
                WORD    wTemp2 = (WORD)*pSrcGlyph;

                wTemp1 <<= (8 - wShiftBits);
                wTemp2 >>= wShiftBits;
                *pDstGlyph = LOBYTE(wTemp1);
                *pDstGlyph |= LOBYTE(wTemp2);
            }

            // bounded last byte of src glyph
            if(((pgb->sizlBitmap.cx + wShiftBits + 7) >> 3) != wSrcGlyphWidth)
            {
                *pDstGlyph = *(pSrcGlyph - 1) << (8 - wShiftBits);
                pDstGlyph++;
            }
        } else {
            for(j = 0; j < wSrcGlyphWidth; j++, pSrcGlyph++, pDstGlyph++)
                *pDstGlyph = *pSrcGlyph;
        }
    }

    // set parameter at Download char table
    wXCharInc = wDstGlyphWidthBytes * 8;

    pOEM->wNumDLChar++;
    pOEM->DLCharID[wFontID][wGlyphID].wCharID = pOEM->wNumDLChar;
    pOEM->DLCharID[wFontID][wGlyphID].wXIncrement = 
                            (WORD)((GD.pGlyphData->ptqD.x.HighPart + 15) >> 4);
    pOEM->DLCharID[wFontID][wGlyphID].wYAdjust = (WORD)-pgb->ptlOrigin.y;

    //#305000 : Need to add 1 that was rounded off.
    if(pOEM->ulHorzRes == 300)
    {
        pOEM->DLCharID[wFontID][wGlyphID].wYAdjust += 1;
    }

    // send command
    // set LEN parameter
    CmdDownloadChar[2] = HIBYTE(7 + wDstGlyphBytes);
    CmdDownloadChar[3] = LOBYTE(7 + wDstGlyphBytes);
    
    // set ID parameter
    CmdDownloadChar[4] = HIBYTE(pOEM->wNumDLChar);
    CmdDownloadChar[5] = LOBYTE(pOEM->wNumDLChar);

    // set CW CH IW IH
    CmdDownloadChar[7] = CmdDownloadChar[9] = (BYTE)wXCharInc;
    CmdDownloadChar[8] = CmdDownloadChar[10] = (BYTE)wDstGlyphHeight;

    // send download char command and image
    WRITESPOOLBUF(pdevobj, (PBYTE)CmdDownloadChar, 11);
    WRITESPOOLBUF(pdevobj, (PBYTE)pOEM->pjTempBuf, wDstGlyphBytes);

    *pdwWidth = (DWORD)wXCharInc;

    return (DWORD)wDstGlyphBytes;
}

/*****************************************************************************/
/*                                                                           */
/*  Module:    SetDrawArea                                                   */
/*                                                                           */
/*  Function:                                                                */
/*                                                                           */
/*  Syntax:    BYTE SetDrawArea(PDEVOBJ, DWORD)                              */
/*                                                                           */
/*  Input:     pdevobj                                                       */
/*             dwCmdCbId                                                     */
/*                                                                           */
/*  Output:    BYTE                                                          */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/
BYTE SetDrawArea(
    PDEVOBJ pdevobj,
    DWORD   dwCmdCbId)
{
    PAPDLPDEV       pOEM;
    WORD            wWidth;
    WORD            wHeight;
    BYTE            bIndex;
    BYTE            bMargin;

    pOEM = (PAPDLPDEV)pdevobj->pdevOEM;

    if(dwCmdCbId != PHYS_PAPER_UNFIXED)
    {
        bIndex = (BYTE)(dwCmdCbId - PAPERSIZE_MAGIC);
        bMargin = 0x76;

        wWidth = (WORD)pOEM->szlPhysSize.cx - (0x76 * 2);
        wHeight = (WORD)pOEM->szlPhysSize.cy - (0x76 * 2);

        if(pOEM->ulHorzRes == 300)
        {
            wWidth /= 2;
            wHeight /= 2;
        }
    } else {
        bIndex = 0x7f;
        bMargin = 0x5e;

        wWidth = (WORD)pOEM->szlPhysSize.cx - (0x5e * 2);
        wHeight= (WORD)pOEM->szlPhysSize.cy - (0x5e * 2);

        if(pOEM->ulHorzRes == 300)
        {
            wWidth /= 2;
            wHeight /= 2;
        }
    }

    /* set value of width, height into DefineDrawingArea command */
    CmdDefDrawArea[9]  = HIBYTE(wWidth);
    CmdDefDrawArea[10] = LOBYTE(wWidth);
    CmdDefDrawArea[11] = HIBYTE(wHeight);
    CmdDefDrawArea[12] = LOBYTE(wHeight);

    /* set value of Origin-X, Y into DefineDrawingArea command */
    if(pOEM->ulHorzRes == 600)
    {
        CmdDefDrawArea[5] = CmdDefDrawArea[7] = 0x00;
        CmdDefDrawArea[6] = CmdDefDrawArea[8] = bMargin;
    } else {
        CmdDefDrawArea[5] = CmdDefDrawArea[7] = 0x00;
        CmdDefDrawArea[6] = CmdDefDrawArea[8] = bMargin / 2;
    }

    /* set Media Origin into DefineDrawingArea command */
    if(pOEM->fOrientation)      // portrait
        CmdDefDrawArea[15] = 0x00;
    else {                      // landscape
        CmdDefDrawArea[15] = 0x03;
    }

    return bIndex;
}
/*****************************************************************************/
/*                                                                           */
/*  Module:    BRL_Ecmd                                                      */
/*                                                                           */
/*  Function:  ByteRunLength(HBP) Compression Routine                        */
/*                                                                           */
/*  Syntax:    WORD BRL_Ecmd(PBYTE, PBYTE, PBYTE, DWORD)                     */
/*                                                                           */
/*  Input:     lpbSrc                                                        */
/*             lpbTgt                                                        */
/*             lpbTmp                                                        */
/*             len                                                           */
/*                                                                           */
/*  Output:    WORD                                                          */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/
DWORD
BRL_ECmd(
    PBYTE   lpbSrc,
    PBYTE   lpbTgt,
    DWORD   lenNoPad,
    DWORD   len)
{

    BYTE    bRCnt  = 1;                     // repeating byte counter
    BYTE    bNRCnt = 0;                     // non-repeating byte counter
    BYTE    bSaveRCnt;
    DWORD i = 0, j = 0, k = 0, l = 0;     // movement trackers
    char    Go4LastByte = TRUE;             // flag to get last byte

#define jSrcByte(i) \
    ((i < lenNoPad) ? lpbSrc[(i)] : 0)

    /* start compression routine - ByteRunLength Encoding */
    do {
        if(jSrcByte(i) != jSrcByte(i+1))      // non-repeating data?
        {
            while(((jSrcByte(i) != jSrcByte(i+1))
                               && (((DWORD)(i+1)) < len)) && (bNRCnt < NRPEAK))
            {
                bNRCnt++;                   // if so, how many?
                i++;
            }

            /* if at last element but less than NRPEAK value */
            if( (((DWORD)(i+1))==len) && (bNRCnt<NRPEAK) )
            {
                bNRCnt++;                       // inc count for last element
                Go4LastByte = FALSE;            // no need to go back
            } else
                /* if at last BYTE, but before that, 
                                            NRPEAK value has been reached */
                if((((DWORD)(i+1))==len) && ((bNRCnt)==NRPEAK))
                    Go4LastByte = TRUE;         // get the last BYTE

            /* Check Target's room to set data */ 
            if ( (j + bNRCnt + 2) > len )   /* 2 means [Counter] and what bNRCnt starts form 0 */
            {
                /* no room to set data, so return ASAP with the buffer size */
                /* not to use temporary buffer to output.                   */
				return (len);
            }

            /* assign the value for Number of Non-repeating bytes */
            lpbTgt[j] = bNRCnt-1;               // subtract one for WinP's case
            j++;                                // update tracker

            /* afterwards...write the Raw Data */
            for (l=0; l<bNRCnt;l++) 
            {
                lpbTgt[j] = jSrcByte(k);
                k++;
                j++;
            }

            /* reset counter */
            bNRCnt = 0;
        } else {                                // end of Non-repeating data
                                                // data is repeating
            while(((jSrcByte(i)==jSrcByte(i+1)) 
                                            && ( ((DWORD)(i+1)) < len)) 
                                            && (bRCnt<RPEAK))
            {
                bRCnt++;
                i++;
            }

            /* Convert to Two's Complement */
            bSaveRCnt   = bRCnt;                // save original value
            bRCnt = (BYTE) 0 - bRCnt;

            /* Check Target's room to set data */ 
            if ( j + 2 > len )              /* 2 means [Counter][Datum] */
            {
                /* no room to set data, so return ASAP with the buffer size */
                /* not to use temporary buffer to output.                   */
				return (len);
            }


            /* Write the Number of Repeating Data */
            lpbTgt[j] = bRCnt + 1;              // add one for WinP's case
            j++;                                // go to next element

            /* afterwards...write the Repeating data */
            lpbTgt[j] = jSrcByte(k);
            j++;

            /* update counters */
            k       += bSaveRCnt;
            bRCnt    = 1;
            i       += 1;

            /* check if last element has been reached */
            if (i==len)
                Go4LastByte=FALSE;              // if so, no need to go back
        }                                       // end of Repeating data
    } while (Go4LastByte);                      // end of Compression

    return ( j );
}

/*****************************************************************************/
/*                                                                           */
/*  Module:    VOutputText                                                   */
/*                                                                           */
/*  Function:  Send device font characters spooled from OEMOutputCharStr     */
/*                                                                           */
/*  Syntax:    VOID VOutputText( PDEVOBJ )                                   */
/*                                                                           */
/*  Input:     PDEVOBJ pdevobj    pointer to the PDEVOBJ structure           */
/*                                                                           */
/*  Output:    VOID                                                          */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/
VOID
VOutputText(
    PDEVOBJ     pdevobj)
{
    PBYTE       pCmd;
    WORD        wCmdLen = 0;
    PAPDLPDEV   pOEM = (PAPDLPDEV)pdevobj->pdevOEM;
    BYTE CmdPrnStrCurrent[] = {0x1C,0xC3,0x00,0x00,0x03}; // Print String
    BYTE CmdMoveHoriPos[] = {0x1C,0x21,0x00,0x00};      // Horizontal Relative
    BYTE fGeneralSave;

    // ensure Y position
    fGeneralSave = pOEM->fGeneral;
    pOEM->fGeneral |= BIT_YMOVE_ABS;
    pOEM->fGeneral &= ~BIT_XMOVE_ABS;
    VSendCursorMoveCommand( pdevobj, TRUE );
    pOEM->fGeneral = fGeneralSave;

    if(pOEM->wUpdateXPos)
    {
        CmdMoveHoriPos[2] = HIBYTE(pOEM->wUpdateXPos);
        CmdMoveHoriPos[3] = LOBYTE(pOEM->wUpdateXPos);
        WRITESPOOLBUF(pdevobj, CmdMoveHoriPos, sizeof(CmdMoveHoriPos));
    }

    CmdPrnStrCurrent[2] = HIBYTE((pOEM->wCachedBytes + 1));
    CmdPrnStrCurrent[3] = LOBYTE((pOEM->wCachedBytes + 1));

    WRITESPOOLBUF(pdevobj, CmdPrnStrCurrent, sizeof(CmdPrnStrCurrent));
    WRITESPOOLBUF(pdevobj, pOEM->bCharData, pOEM->wCachedBytes);

    //#332101 prob.4: Keep wUpdateXPos to accumulate
    pOEM->wUpdateXPos += pOEM->wWidths * (pOEM->wCachedBytes / 2);
    
    if(pOEM->wCachedBytes % 2)
        pOEM->wUpdateXPos += pOEM->wWidths / 2;

    ZeroMemory(pOEM->bCharData, 1024);
    pOEM->wCachedBytes = 0;
}

/*****************************************************************************/
/*                                                                           */
/*  Module:    VSetFontSimulation                                            */
/*                                                                           */
/*  Function:  Set attribute of device font characters if needed             */
/*                                                                           */
/*  Syntax:    VOID VSetFontSimulation( PDEVOBJ )                            */
/*                                                                           */
/*  Input:     PDEVOBJ pdevobj    pointer to the PDEVOBJ structure           */
/*                                                                           */
/*  Output:    VOID                                                          */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/
VOID 
VSetFontSimulation(
    PDEVOBJ     pdevobj)
{
    PAPDLPDEV       pOEM = (PAPDLPDEV)pdevobj->pdevOEM;
    BYTE            CmdFontSim[]       = {0x1C,0xA5,0x4,0x04,0x02,0x02,0x00,0x00,0x00,0x00,0x00};
    WORD            wCmdLen = 0;

    if((pOEM->fGeneral & FONTSIM_MASK) != pOEM->fCurFontSim || 
                                        (pOEM->fGeneral & BIT_FONTSIM_RESET) )
    {
        // Send Font simulation command
        if((pOEM->fGeneral & BIT_FONTSIM_RESET) && 
         (!(pOEM->fGeneral & BIT_FONTSIM_BOLD)) && 
         (!(pOEM->fGeneral & BIT_FONTSIM_ITALIC)) )
        {
            // Send Bold and Italic off
            CmdFontSim[6] = 0x00;   // Bold and Italic off
            wCmdLen = BYTE_WITHOUT_ITALIC;  // 7 bytes

            pOEM->fGeneral &= ~BIT_FONTSIM_RESET;
        } else {
            if(pOEM->fGeneral & BIT_FONTSIM_RESET)
                pOEM->fGeneral &= ~BIT_FONTSIM_RESET;

            CmdFontSim[6] = (pOEM->fGeneral & FONTSIM_MASK);
            wCmdLen = BYTE_WITHOUT_ITALIC;  // 7 bytes

            if(pOEM->fGeneral & BIT_FONTSIM_ITALIC)
            {
                CmdFontSim[2] = 0x08;   // Total length
                CmdFontSim[4] = 0x06;   // Ornament lengh
                wCmdLen = BYTE_WITH_ITALIC; // 11bytes
            }

            // update current font sim infomation
            pOEM->fCurFontSim = pOEM->fGeneral;
        }
        if(wCmdLen)
            WRITESPOOLBUF(pdevobj, CmdFontSim, wCmdLen);
    }
}

/*****************************************************************************/
/*                                                                           */
/*  Module:    VSendCursorMoveCommand                                        */
/*                                                                           */
/*  Function:  Send appropriate cursor move command                          */
/*                                                                           */
/*  Syntax:    VOID VSendCursorMoveCommand( PDEVOBJ, BOOL )                  */
/*                                                                           */
/*  Input:     PDEVOBJ pdevobj    pointer to the PDEVOBJ structure           */
/*             BOOL    bAdjust    adjusting y position flag                  */
/*                                                                           */
/*  Output:    VOID                                                          */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/
VOID
VSendCursorMoveCommand(
    PDEVOBJ     pdevobj,        // pointer to the PDEVOBJ structure
    BOOL        bYAdjust)       // adjusting y position if device font
{
    PAPDLPDEV       pOEM = (PAPDLPDEV)pdevobj->pdevOEM;
    BYTE            bCursorMoveCmd[6];

    WORD            wCmdLen = 0;
    WORD            wY = pOEM->wYPosition;

	WORD			wI;
    if(bYAdjust)
        wY -= pOEM->wFontHeight;

    // Set appropriate cursor move command
    if( (pOEM->fGeneral & BIT_XMOVE_ABS) && (pOEM->fGeneral & BIT_YMOVE_ABS) )
    {
        memcpy(bCursorMoveCmd, CmdSetGivenPos, BYTE_XY_ABS);
        wCmdLen = BYTE_XY_ABS;
        pOEM->fGeneral &= ~BIT_XMOVE_ABS;
        pOEM->fGeneral &= ~BIT_YMOVE_ABS;

        // Set parameters
        bCursorMoveCmd[2] = HIBYTE(pOEM->wXPosition);
        bCursorMoveCmd[3] = LOBYTE(pOEM->wXPosition);
        bCursorMoveCmd[4] = HIBYTE(wY);
        bCursorMoveCmd[5] = LOBYTE(wY);
    } else if((pOEM->fGeneral & BIT_XMOVE_ABS)
                                    && (!(pOEM->fGeneral & BIT_YMOVE_ABS)) ) {
        memcpy(bCursorMoveCmd, CmdGivenHoriPos, BYTE_SIMPLE_ABS);
        wCmdLen = BYTE_SIMPLE_ABS;
        pOEM->fGeneral &= ~BIT_XMOVE_ABS;

        // set parameter
        bCursorMoveCmd[2] = HIBYTE(pOEM->wXPosition);
        bCursorMoveCmd[3] = LOBYTE(pOEM->wXPosition);
    } else if((pOEM->fGeneral & BIT_YMOVE_ABS) 
                                    && (!(pOEM->fGeneral & BIT_XMOVE_ABS)) ) {
        memcpy(bCursorMoveCmd, CmdGivenVertPos, BYTE_SIMPLE_ABS);
        wCmdLen = BYTE_SIMPLE_ABS;
        pOEM->fGeneral &= ~BIT_YMOVE_ABS;

        // set parameter
        bCursorMoveCmd[2] = HIBYTE(wY);
        bCursorMoveCmd[3] = LOBYTE(wY);
    }

    if(wCmdLen)
        WRITESPOOLBUF(pdevobj, bCursorMoveCmd, wCmdLen);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\apdlres\debug.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>

#include <windef.h>
#include <winbase.h>
#include <wingdi.h>
#include <winddi.h>

//
// Functions for outputting debug messages
//

VOID
DbgPrint(IN LPCSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\apdlres\pdev.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/

#ifndef _PDEV_H
#define _PDEV_H

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
#define ERRORTEXT(s)    "ERROR " DLLTEXT(s)

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'APDL'
#define DLLTEXT(s)      "APDL: " s
#define OEM_VERSION      0x00010000L

/*--------------------------------------------------------------------------*/
/*                        D E F I N E  V A L U E                            */
/*--------------------------------------------------------------------------*/
#define PAPER_SRC_FTRAY                 20
#define PAPER_SRC_CAS1                  21
#define PAPER_SRC_CAS2                  22
#define PAPER_SRC_CAS3                  23
#define PAPER_SRC_AUTO                  24  //Not use by NT driver
#define PAPER_DEST_SCALETOFIT_ON        25
#define PAPER_DEST_SCALETOFIT_OFF       26
#define PAPER_SRC_AUTO_SELECT           27

#define PAGECONTROL_BEGIN_JOB           140
#define PAGECONTROL_BEGIN_DOC           30
#define PAGECONTROL_BEGIN_PAGE          31
#define PAGECONTROL_END_DOC             32
#define PAGECONTROL_END_PAGE            33
#define PAGECONTROL_DUPLEX_OFF          34
#define PAGECONTROL_ABORT_DOC           35
#define PAGECONTROL_POTRAIT             36
#define PAGECONTROL_LANDSCAPE           37
#define PAGECONTROL_MULTI_COPIES        38
#define PAGECONTROL_DUPLEX_UPDOWN       39
#define PAGECONTROL_DUPLEX_RIGHTUP      40

#define PAPERSIZE_MAGIC                 50 // this ID - 50 = Actual ID of A/PDL
#define PHYS_PAPER_A3                   50
#define PHYS_PAPER_A4                   51
#define PHYS_PAPER_A5                   52
#define PHYS_PAPER_A6                   53  // Reserved
#define PHYS_PAPER_B4                   54
#define PHYS_PAPER_B5                   55
#define PHYS_PAPER_B6                   56  // Reserved
#define PHYS_PAPER_LETTER               57
#define PHYS_PAPER_LEGAL                58
#define PHYS_PAPER_POSTCARD             59
#define PHYS_PAPER_EXECUTIVE            60  // Reserved
#define PHYS_PAPER_UNFIXED              61

#define X_ABS_MOVE                      70
#define Y_ABS_MOVE                      71
#define XY_ABS_MOVE                     78
#define X_REL_MOVE_RIGHT                110
#define Y_REL_MOVE_DOWN                 111

#define CR_EMULATION                    79
#define DUMMY_LF                        80
#define FF_EJECTPAGE                    81

#define BOLD_ON                         72
#define BOLD_OFF                        73
#define ITALIC_ON                       74
#define ITALIC_OFF                      75
#define SELECT_SINGLE_BYTE              120
#define SELECT_DOUBLE_BYTE              121

#define RESOLUTION_300                  76
#define RESOLUTION_600                  77
#define SEND_BLOCK_DATA                 82

#define TONER_SAVE_OFF                  100
#define TONER_SAVE_DARK                 101
#define TONER_SAVE_LIGHT                102

// #278517: RectFill
#define RECT_SET_WIDTH                  130
#define RECT_SET_HEIGHT                 131
#define RECT_FILL_BLACK                 132

#define MASTER_UNIT                     600
#define LINE_PER_BAND                   32
#define CCHMAXCMDLEN                    128
#define MAXIMGSIZE                      0xF000

#define NRPEAK                          0x7F
#define RPEAK                           0x80

// for download
#define SET_FONT_ID                     110
#define SELECT_FONT_ID                  111
#define SET_CUR_GLYPHID                 112
#define DELETE_FONT                     113

#define MAXGLYPHSIZE                    0x4000
#define MAXGLYPHWIDTH                   0x80
#define MAXGLYPHHEIGHT                  0x80

// Font ID definition in GPD -> Min 24  Max 48
#define FONT_ID_DIFF                    24

#define MAX_FONT_ID                     24
#define MAX_GLYPH_ID                    1024
#define MIN_GLYPH_ID                    32
#define MAX_DOWNLOAD_CHAR   MAX_FONT_ID * MAX_GLYPH_ID

// for fGeneral(font sim and X/Y move) flags
#define CURSORMOVE_MASK                 0x03    // 1 2 bit
#define FONTSIM_MASK                    0x30    // 5 6 bit

// Bit Flags
#define BIT_XMOVE_ABS                   0x01    // 1 Bit
#define BIT_YMOVE_ABS                   0x02    // 2 Bit
#define BIT_FONTSIM_ITALIC              0x10    // 5 Bit (Command spec)
#define BIT_FONTSIM_BOLD                0x20    // 6 Bit (Command spec)
#define BIT_FONTSIM_RESET               0x40    // 7 Bit

// Max num of spooled device font character
#define MAXDEVFONT                      1024

// Current text mode DBCS/SBCS
#define BYTE_BYTEMODE_RESET             0
#define BYTE_SINGLE_BYTE                1
#define BYTE_DOUBLE_BYTE                2

// Command length
#define BYTE_WITH_ITALIC                11
#define BYTE_WITHOUT_ITALIC             7
#define BYTE_XY_ABS                     6
#define BYTE_SIMPLE_ABS                 4

// device font face
#define MINCHO_HORI                     1
#define MINCHO_VERT                     2
#define GOTHIC_HORI                     3
#define GOTHIC_VERT                     4

// @Aug/31/98 ->
#define	MAX_COPIES_VALUE		255
// @Aug/31/98 <-

/*--------------------------------------------------------------------------*/
/*                       S T R U C T U R E  D E F I N E                     */
/*--------------------------------------------------------------------------*/
typedef struct tagPAPER {
    WORD    wWidth;
    WORD    wHeight;
} PHYSIZE, FAR * LPPHYSIZE;

typedef struct tag_TTDLCHAR {
    WORD    wCharID;        // Downloaded char ID for device
    WORD    wXIncrement;    // Increment value 
    WORD    wXAdjust;       // Adjust value for x
    WORD    wYAdjust;       // Adjust value for y
} DLCHAR, *PDLCHAR;

typedef struct tag_APDLPDEV {
    // Private extention
    ULONG   ulHorzRes;        // width of the physical surface
    ULONG   ulVertRes;        // height of the physical surface
    SIZEL   szlPhysSize;      // size of unwriteable margin
    POINTL  ptlPhysOffset;    // size of entire surface with unwriteable margin
    BOOL    fSendSetPhysPaper;// flag for sending set physical paper command
    BOOL    fDuplex;          // TRUE = duplex mode is selected
    BOOL    fScaleToFit;      // for set auto tray mode in Set Physical Paper
    BOOL    fOrientation;     // for set media origin in Define Drawing Area
    WORD    wWidths;          // move current position afer print device font

    BYTE    fGeneral;         // font sim and cursor move infomation
    BYTE    fCurFontSim;      // Currnet settings of font sim
    BYTE    bCurByteMode;     // for x position adjustment in vertical font

    WORD    wXPosition;       // Current X position
    WORD    wYPosition;       // Current Y position

    BYTE    bFontID;          // device font ID based on .rc file
    WORD    wUpdateXPos;      // for relative X move
    WORD    wCachedBytes;     // Bytes of cached device font character
    BYTE    bCharData[MAXDEVFONT];                  // Actual char data
    WORD    wFontHeight;                            // Device font height

    DLCHAR  DLCharID[MAX_FONT_ID][MAX_GLYPH_ID];    // Downloaded char data
    WORD    wNumDLChar;                             // Num of downloaded char
    WORD    wGlyphID;                               // Current GlyphID

    WORD    wImgWidth;
    WORD    wImgHeight;

    // Temp. buffer (dynamically allocated)
    // used for data compressoin work area, etc.
    PBYTE pjTempBuf;
    DWORD dwTempBufLen;

    // Command string buffers to keep status among
    // the Unidrv to minidriver callbacks.

    BYTE ajCmdSetPhysPaper[19];
    BYTE ajCmdSetPhysPage[16];
    BYTE ajCmdDefDrawArea[16];

// #278517: RectFill
    WORD    wRectWidth;
    WORD    wRectHeight;

} APDLPDEV, *PAPDLPDEV;

//+---------------------------------------------------------------------------+
//|                    F U N C T I O N  P R O T O T Y P E                     |
//+---------------------------------------------------------------------------+
BYTE  SetDrawArea(PDEVOBJ, DWORD);
DWORD BRL_ECmd(PBYTE, PBYTE, DWORD, DWORD);
VOID  VOutputText( PDEVOBJ );
VOID  VSetFontSimulation( PDEVOBJ );
VOID  VSendCursorMoveCommand( PDEVOBJ, BOOL );

/*--------------------------------------------------------------------------*/
/*                        D E F I N E  M A C R O                            */
/*--------------------------------------------------------------------------*/
#define WRITESPOOLBUF(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, (PBYTE)(s), (DWORD)(n)))

#define PARAM(p,n) \
    (*((p)+(n)))

#define ABS(n) \
    ((n) > 0 ? (n) : -(n))

#define STDVAR_BUFSIZE(n) \
    (sizeof (GETINFO_STDVAR) + sizeof(DWORD) * 2 * ((n) - 1))

#define ISVERTICALFONT(n) \
    ( (n == MINCHO_VERT || n == GOTHIC_VERT) ? TRUE : FALSE )

#endif  //_PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\apdlres\sources.inc ===
!IF 0

Copyright (C) 1997 - 1999 Microsoft Corporation

!ENDIF

!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR=$(PRNROOT)\gpd\apti\$(ALT_PROJECT)
SRCDIR=..

TARGETNAME=apdlres
TARGETPATH=obj
TARGETTYPE=DYNLINK

!if 0
DLLBASE=@$(COFFBASE_TXT_FILE),apdlres
!else
DLLBASE=0x8000000
!endif

INCLUDES=$(PRNROOT)\inc

RCCODEPAGE=932

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\apdlres.rc \
    $(SRCDIR)\common.c \
    $(SRCDIR)\apdlres.c

MISCFILES=\
    $(SRCDIR)\apdlres.ini \
    $(GPDDIR)\ate780j.gpd \
    $(GPDDIR)\ate840j.gpd
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\apdlres\names.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

--*/


//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
//     "Command",
    "CommandCallback",
//     "Compression",
//     "DeviceCapabilities",
//     "DevMode",
//     "DevQueryPrintEx",
    "DisableDriver",
    "DisablePDEV",
//     "DocumentPropertySheets",
    "DownloadCharGlyph",
    "DownloadFontHeader",
//     "DriverDMS",
//     "DriverEvent",
//     "DrvGetDriverSetting",
//     "DrvWriteSpoolBuf",
    "EnableDriver",
    "EnablePDEV",
    "FilterGraphics",
//     "FontInstallerDlgProc",
//     "GetDDIHooks",
//     "GetDriverSetting",
    "GetImplementedMethod",
    "GetInfo",
//     "HalftonePattern",
//     "ImageProcessing",
//     "MemoryUsage",
    "OutputCharStr",
//     "PrinterEvent",
//     "PropCommonUIProp",
    "PublishDriverInterface",
//     "QueryColorProfile",
    "ResetPDEV",
    "SendFontCmd",
//     "SheetsDevicePropertySheets",
//     "TextOutAsBitmap",
    "TTDownloadMethod",
//     "TTYGetInfo",
//     "UpdateUISetting",
//     "UpgradePrinter",
//     "UpgradeRegistry",
//     "UpgradeRegistrySetting",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\apdlres\comoem.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

         Implementation of OEMGetInfo and OEMDevMode.
         Shared by all Unidrv OEM test dll's.

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
//#include "name.h"
#include "names.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

#include "comoem.h"


////////////////////////////////////////////////////////////////////////////////
//
// IOemCB body
//
HRESULT __stdcall IOemCB::QueryInterface(const IID& iid, void** ppv)
{    
    VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this); 
        VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
    }
    else if (iid == IID_IPrintOemUni)
    {
        *ppv = static_cast<IPrintOemUni*>(this);
        VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
    }
    else
    {
        *ppv = NULL ;
        VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCB::AddRef()
{
    VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCB::Release() 
{
    VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

LONG __stdcall IOemCB::EnableDriver(DWORD          dwDriverVersion,
                                    DWORD          cbSize,
                                    PDRVENABLEDATA pded)
{
    VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// Sep.17.98 ->
    // OEMEnableDriver(dwDriverVersion, cbSize, pded);

    // Need to return S_OK so that DisableDriver() will be called, which Releases
    // the reference to the Printer Driver's interface.
    return S_OK;
// Sep.17.98 <-
}

LONG __stdcall IOemCB::DisableDriver(VOID)
{
    VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// Sep.17.98 ->
    // OEMDisableDriver();

    // Release reference to Printer Driver's interface.
    if (this->pOEMHelp)
    {
        this->pOEMHelp->Release();
        this->pOEMHelp = NULL;
    }
    return S_OK;
// Sep.17.98 <-
}

LONG __stdcall IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
{
    VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
// Sep.8.98 ->
    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;

        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->pOEMHelp = NULL;

            return E_FAIL;
        }
    }
// Sep.8.98 <-
    return S_OK;
}

LONG __stdcall IOemCB::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
{
    VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));

    *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName, cPatterns, phsurfPatterns,
                              cjGdiInfo, pGdiInfo, cjDevInfo, pDevInfo, pded);
    if (*pDevOem)
        return S_OK;
    else
        return S_FALSE;
}

LONG __stdcall IOemCB::ResetPDEV(
    PDEVOBJ         pdevobjOld,
    PDEVOBJ        pdevobjNew)
{
    if (OEMResetPDEV(pdevobjOld, pdevobjNew))
        return S_OK;
    else
        return S_FALSE;
}

LONG __stdcall IOemCB::DisablePDEV(
    PDEVOBJ         pdevobj)
{
    LONG lI;

    VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));

    OEMDisablePDEV(pdevobj);
    return S_OK;
}

LONG __stdcall IOemCB::GetInfo (
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));
    if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
        return S_OK;
    else
        return S_FALSE;
}

static
int __cdecl
iCompNames(
    const void *p1,
    const void *p2) {

    return strcmp(
        *((char **)p1),
        *((char **)p2));
};

LONG __stdcall IOemCB::GetImplementedMethod(
    PSTR pMethodName)
{
    LONG lRet = E_NOTIMPL;
    PSTR pTemp;

    VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

    if (NULL != pMethodName) {

        pTemp = (PSTR)bsearch(
            &pMethodName,
            gMethodsSupported,
            (sizeof (gMethodsSupported) / sizeof (PSTR)),
            sizeof (PSTR),
            iCompNames);

        if (NULL != pTemp)
            lRet = S_OK;
    }

    VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

    return lRet;
}

LONG __stdcall IOemCB::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam) 
{
    VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));
    //if (OEMDevMode(dwMode, pOemDMParam))
    //    return S_OK;
    //else
    //    return S_FALSE;
    return E_NOTIMPL;
}


LONG __stdcall IOemCB::CommandCallback(
    PDEVOBJ     pdevobj,
    DWORD       dwCallbackID,
    DWORD       dwCount,
    PDWORD      pdwParams,
    OUT INT     *piResult)
{
    VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));
    *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

    return S_OK;
}

LONG __stdcall IOemCB::ImageProcessing(
    PDEVOBJ             pdevobj,  
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
{
    VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
    // if (OEMImageProcessing(pdevobj, pSrcBitmap, pBitmapInfoHeader, pColorTable,
    //                     dwCallbackID, pIPParams))
    //     return S_OK;
    // else
    //     return S_FALSE;
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::FilterGraphics(
    PDEVOBJ     pdevobj,
    PBYTE       pBuf,
    DWORD       dwLen)
{
    DWORD dwResult;
    VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));
    // pOEMHelp->DrvWriteSpoolBuf(pdevobj, pBuf, dwLen, &dwResult);
    
    // if (dwResult == dwLen)
    //     return S_OK;
    // else
    //     return S_FALSE;

    if(OEMFilterGraphics(pdevobj, pBuf, dwLen))
        return S_OK;
    else
        return S_FALSE;
}

LONG __stdcall IOemCB::Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
{
    VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
    return E_NOTIMPL;
}


LONG __stdcall IOemCB::HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
{
    VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::MemoryUsage(
    PDEVOBJ         pdevobj,   
    POEMMEMORYUSAGE pMemoryUsage)
{
    VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));

    *pdwResult = OEMDownloadFontHeader(pdevobj, pUFObj);
    if(*pdwResult)
        return S_OK;
    else
        return S_FALSE;
}

LONG __stdcall IOemCB::DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));

    *pdwResult = OEMDownloadCharGlyph(pdevobj, pUFObj, hGlyph, pdwWidth);
    if(*pdwResult)
        return S_OK;
    else
        return S_FALSE;
}

LONG __stdcall IOemCB::TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult) 
{
    VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));

    *pdwResult = OEMTTDownloadMethod(pdevobj, pUFObj);
    if(*pdwResult <= TTDOWNLOAD_TTOUTLINE)
        return S_OK;
    else
        return S_FALSE;
}

LONG __stdcall IOemCB::OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph) 
{
    VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));
    OEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph);

    return S_OK;
}

LONG __stdcall IOemCB::SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv) 
{
    VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));
    OEMSendFontCmd(pdevobj, pUFObj, pFInv);
    return S_OK;
}

LONG __stdcall IOemCB::DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
{
    VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
    return E_NOTIMPL;
}

LONG __stdcall IOemCB::TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded)
{
    VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////
//
// Class factory body
//
HRESULT __stdcall IOemCF::QueryInterface(const IID& iid, void** ppv)
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this);
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK ;
}

ULONG __stdcall IOemCF::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG __stdcall IOemCF::Release()
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

// IClassFactory implementation
HRESULT __stdcall IOemCF::CreateInstance(IUnknown* pUnknownOuter,
                                           const IID& iid,
                                           void** ppv)
{
    //VERBOSE((DLLTEXT("Class factory:\t\tCreate component.")));

    // Cannot aggregate.
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    // Create component.
    IOemCB* pOemCB = new IOemCB ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get the requested interface.
    HRESULT hr = pOemCB->QueryInterface(iid, ppv);

    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    pOemCB->Release();
    return hr ;
}

// LockServer
HRESULT __stdcall IOemCF::LockServer(BOOL bLock)
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks);
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks);
    }
    return S_OK ;
}

///////////////////////////////////////////////////////////
//
// Export functions
//

#if 0

BOOL OEMCreateInstance(
    PVOID *pIntfOem)
{

    IOemCB* pOemCB = new IOemCB ;
    pOemCB->AddRef();

    *pIntfOem = (PVOID) pOemCB;

    return TRUE;
}

#endif

//
// Registration functions
// Testing purpose
//

//
// Can DLL unload now?
//
STDAPI DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

//
// Get class factory
//
STDAPI DllGetClassObject(const CLSID& clsid,
                         const IID& iid,
                         void** ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID);
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID);
}
#endif

///////////////////////////////////////////////////////////
//
// DLL module information
//
BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule ;
    }
        g_hModule = (HMODULE)hModule ;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\apdlres\comoem.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.h

Abstract:

    

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem Class Factory definition
//

class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem CallBack definition
//
class IOemCB:public IPrintOemUni
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

   //
   // Method for getting the implemented methods.
   // Returns S_OK if the given method is implemneted.
   // Returns S_FALSE if the given method is notimplemneted.
   //

   STDMETHOD(GetImplementedMethod)(THIS_ PSTR pMethodName);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);

    //
    // OEMDriverDMS - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(DriverDMS)(THIS_ PVOID   pDevObj,
                               PVOID   pBuffer,
                               DWORD   cbSize,
                               PDWORD  pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // OEMCommandCallback - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(CommandCallback)(THIS_ PDEVOBJ     pdevobj,
                                     DWORD       dwCallbackID,
                                     DWORD       dwCount,
                                     PDWORD      pdwParams,
                                     OUT INT     *piResult);

    //
    // OEMImageProcessing - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(ImageProcessing)(THIS_ PDEVOBJ             pdevobj,
                                     PBYTE               pSrcBitmap,
                                     PBITMAPINFOHEADER   pBitmapInfoHeader,
                                     PBYTE               pColorTable,
                                     DWORD               dwCallbackID,
                                     PIPPARAMS           pIPParams,
                                     OUT PBYTE           *ppbResult);

    //
    // OEMFilterGraphics - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen);
    //
    // OEMCompression - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult);

    //
    // OEMHalftone - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize);

    //
    // OEMMemoryUsage - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage);

    //
    // OEMTTYGetInfo - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded);

    //
    // OEMDownloadFontheader - UNIDRV only
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMDownloadCharGlyph - UNIDRV only
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult);

    //
    // OEMTTDownloadMethod - UNIDRV only
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMOutputCharStr - UNIDRV only
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph);

    //
    // OEMSendFontCmd - UNIDRV only
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv);

    //
    // OEMTextOutAsBitmap - UNIDRV only
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix);

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\apdlres\etc\code.c ===
/*****************************************************************************/
/* CODE.C                                                                    */
/*                                                                           */
/* The FE minidriver with Win95 style callbacks negotiates with the          */
/* Unidriver using a data block MINIDRVENABLEDATA. Minidriver exports a      */
/* callback function MiniDrvEnableDriver() to be recognized by the Unidriver */
/* (so that it can know the minidriver has Win95 style callbacks in it).     */
/*                                                                           */
/* Following files are used by only NT4.0 FE minidriver when driver use      */
/* callback function.                                                        */
/*                                                                           */
/*     gdidefs.inc     mdevice.h       print.h     mindrvrc.h                */
/*     minidriv.h      unidrv.h        udmdi.h     version.h                 */
/*     uniutil.c                                                             */
/*                                                                           */
/* Copyright (C) 1997-     Advanced Peripherals Technologies, Inc.           */
/*                                                                           */
/* <HISTORY>                                                                 */
/*                                                                           */
/*****************************************************************************/
//+---------------------------------------------------------------------------+
//|                         I N C L U D E  F I L E                            |
//+---------------------------------------------------------------------------+
char   *rgchModuleName = "APTiE840";
#include <print.h>
#include "mdevice.h"
#include "gdidefs.inc"

#include "mindrvrc.h"
#include "minidriv.h"
#include "unidrv.h"

#include "code.h"

#include <windows.h>
#include <windowsx.h>
/*****************************************************************************/
/*                                                                           */
/*  Module:    MiniDrvEnableDriver                                           */
/*                                                                           */
/*  Function:                                                                */
/*                                                                           */
/*  Syntax:    BOOL MiniDrvEnableDriver(MINIDRVENABLEDATA)                   */
/*                                                                           */
/*  Input:     *pEnableData                                                  */
/*                                                                           */
/*  Output:    BOOL                                                          */
/*                                                                           */
/*  Notice:    This callback routine is "for NT4.0 FE minidriver only".      */
/*                                                                           */
/*  History:   1997. 06.03 initial                                           */
/*                                                                           */
/*****************************************************************************/
BOOL MiniDrvEnableDriver(MINIDRVENABLEDATA *pEnableData)
{
   if (pEnableData == NULL)
       return FALSE;

   if (pEnableData->cbSize == 0) {
       pEnableData->cbSize = sizeof(MINIDRVENABLEDATA);
       return TRUE;
   }

   if ((pEnableData->cbSize < sizeof(MINIDRVENABLEDATA))
       || (HIBYTE(pEnableData->DriverVersion) < HIBYTE(MDI_DRIVER_VERSION)))
       return FALSE;       // Wrong size and/or version mismatch.

   // Load address of Unidriver provided function
   if (!bLoadUniDrvCallBack(pEnableData,INDEX_UniDrvWriteSpoolBuf,(PFN *)&WriteSpoolBuf)
     ||!bLoadUniDrvCallBack(pEnableData,INDEX_UniDrvAllocMem,(PFN *)&AllocMem)
     ||!bLoadUniDrvCallBack(pEnableData,INDEX_UniDrvFreeMem,(PFN *)&FreeMem))
   {
       // Failed to get Unidriver callback function address.
       return FALSE;
   }
   // Set minidriver's function table to MINIDRVENABLEDATA
   pEnableData->cMiniDrvFn = sizeof(MiniDrvFnTab)/sizeof(MiniDrvFnTab[0]);
   pEnableData->pMinDrvFn = MiniDrvFnTab;

   return TRUE;    // Now we are done.
}
/*****************************************************************************/
/*                                                                           */
/*  Module:    MiniDrvEnablePDEV                                             */
/*                                                                           */
/*  Function:                                                                */
/*                                                                           */
/*  Syntax:    BOOL PASCAL MiniDrvEnablePDEV(LPDV, PGDIINFO)                 */
/*                                                                           */
/*  Input:     lpdv                                                          */
/*             pdevcaps                                                      */
/*                                                                           */
/*  Output:    BOOL                                                          */
/*                                                                           */
/*  Notice:    This callback routine is "for NT4.0 FE minidriver only".      */
/*                                                                           */
/*  History:   1997. 06.03 initial                                           */
/*                                                                           */
/*****************************************************************************/
BOOL PASCAL MiniDrvEnablePDEV(LPDV lpdv, PGDIINFO pdevcaps)
{
LPAPDL    lpApdl;

   lpdv->fMdv = FALSE;

   /* allocate memory for A/PDL structure */
   if (!(lpApdl = lpdv->lpMdv = AllocMem(sizeof(APDL))))
       return FALSE;

   /* allocate buffer for image compression */
   if (!(lpApdl->lpCompBuf = AllocMem(MAXIMGSIZE)))
       return FALSE;

   /* allocate buffer for image compression */
   if (!(lpApdl->lpTempBuf = AllocMem(MAXIMGSIZE)))
       return FALSE;

   /* save current resolution */
   lpApdl->ulHorzRes = pdevcaps->ulAspectX;
   lpApdl->ulVertRes = pdevcaps->ulAspectY;

   /* save physical offset of the unwriteable margin */
   lpApdl->ptlPhysOffset.x = pdevcaps->ptlPhysOffset.x;
   lpApdl->ptlPhysOffset.y = pdevcaps->ptlPhysOffset.y;

   /* save physical Size of the entire surface, including unwriteable margin */
   lpApdl->szlPhysSize.cx = pdevcaps->szlPhysSize.cx;
   lpApdl->szlPhysSize.cy = pdevcaps->szlPhysSize.cy;

   lpdv->fMdv = TRUE;

   return TRUE;
}
/*****************************************************************************/
/*                                                                           */
/*  Module:    MiniDrvDisablePDEV                                            */
/*                                                                           */
/*  Function:                                                                */
/*                                                                           */
/*  Syntax:    BOOL PASCAL MiniDrvDisablePDEV(LPDV)                          */
/*                                                                           */
/*  Input:     lpdv                                                          */
/*                                                                           */
/*  Output:    BOOL                                                          */
/*                                                                           */
/*  Notice:    This callback routine is "for NT4.0 FE minidriver only".      */
/*                                                                           */
/*  History:   1997. 06.03 initial                                           */
/*                                                                           */
/*****************************************************************************/
BOOL PASCAL MiniDrvDisablePDEV(LPDV lpdv)
{
   if (lpdv->fMdv){
       FreeMem(((LPAPDL)(lpdv->lpMdv))->lpCompBuf);
       FreeMem(((LPAPDL)(lpdv->lpMdv))->lpTempBuf);
       FreeMem(lpdv->lpMdv);
       lpdv->fMdv = FALSE;
   }

   return TRUE;
}
/*****************************************************************************/
/*                                                                           */
/*  Module:    CBFilterGraphics                                              */
/*                                                                           */
/*  Function:                                                                */
/*                                                                           */
/*  Syntax:    WORD PASCAL CBFilterGraphics(LPDV, LPSTR, WORD)               */
/*                                                                           */
/*  Input:     lpdv        address of PDEVICE structure                      */
/*             lpBuf       points to buffer of graphics data                 */
/*             wLen        length of buffer in bytes                         */
/*                                                                           */
/*  Output:    WORD                                                          */
/*                                                                           */
/*  Notice:    nFunction and Escape numbers are the same                     */
/*                                                                           */
/*****************************************************************************/
WORD PASCAL CBFilterGraphics (LPDV lpdv, LPSTR lpBuf, WORD wLen)
{
LPAPDL lpApdl = lpdv->lpMdv;
ULONG  ulHorzPixel;
WORD   wCompLen;

LPSTR lpSrcImage;
LPSTR lpCompImage;
LPSTR lpTempImage;

   /*_ LPDV */
   lpSrcImage  = lpBuf;
   lpCompImage = lpApdl->lpCompBuf;
   lpTempImage = lpApdl->lpTempBuf;

   wCompLen = BRL_ECmd((LPBYTE)lpSrcImage,
                       (LPBYTE)lpCompImage,
                       (LPBYTE)lpTempImage,
                       wLen);

   // Set the LEN of the DrawBlockImage command
   CmdDrawImgCurrent[4] = (BYTE)((wCompLen + 9) >>8 & 0x00ff);
   CmdDrawImgCurrent[5] = (BYTE)((wCompLen + 9)     & 0x00ff);

   // Set the WIDTH parameter of the DrawBlockImage command
   ulHorzPixel = (ULONG)((wLen / LINE_PER_BAND) * 8); // in bits
   CmdDrawImgCurrent[7] = (BYTE)(ulHorzPixel >> 8 & 0x000000ffL);
   CmdDrawImgCurrent[8] = (BYTE)(ulHorzPixel      & 0x000000ffL);

   // Set the LEN of uncompressed data
   CmdDrawImgCurrent[13] = (BYTE)(wLen >> 8 & 0x000000ff);
   CmdDrawImgCurrent[14] = (BYTE)(wLen      & 0x000000ff);

   // Draw Block Image at Current Position
   WriteSpoolBuf((LPDV)lpdv, (LPSTR)CmdDrawImgCurrent, sizeof(CmdDrawImgCurrent));
   WriteSpoolBuf((LPDV)lpdv, lpCompImage, wCompLen);

   return wLen;
}
/*****************************************************************************/
/*                                                                           */
/*  Module:    OEMOutputCmd                                                  */
/*                                                                           */
/*  Function:                                                                */
/*                                                                           */
/*  Syntax:    VOID PASCAL OEMOutputCmd(LPDV, WORD, LPDWORD)                 */
/*                                                                           */
/*  Input:     lpdv                                                          */
/*             wCmdCbId                                                      */
/*             lpdwParams                                                    */
/*                                                                           */
/*  Output:    VOID                                                          */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/
// @Aug/31/98 ->
#define	MAX_COPIES_VALUE		255
// @Aug/31/98 <-
VOID PASCAL OEMOutputCmd(LPDV lpdv, WORD wCmdCbId, LPDWORD lpdwParams)
{
LPAPDL lpApdl = lpdv->lpMdv;
WORD   wTemp;
WORD   wPhysWidth;
WORD   wPhysHeight;
DWORD  dwXval;
DWORD  dwYval;

   switch(wCmdCbId)
   {
       /*------------------------------------------------------*/
       /* A/PDL start now                                      */
       /*------------------------------------------------------*/
       case PAGECONTROL_BEGIN_DOC:
           /* reset flag of sent Set Physical Paper command */
           lpApdl->fSendSetPhysPaper = FALSE;
           /* initialize flag */
           lpApdl->fBold   = FALSE;
           lpApdl->fItalic = FALSE;
           lpApdl->fDuplex = FALSE;
           CmdSetPhysPage[10] = 0x00;

           /* Send Change Data Stream Command for Enter A/PDL mode */
           WriteSpoolBuf((LPDV)lpdv, (LPSTR)CmdInAPDLMode, 6);
           /* Send A/PLDL start Command */
           WriteSpoolBuf((LPDV)lpdv, (LPSTR)CmdAPDLStart, 2);
           break;
       /*------------------------------------------------------*/
       /* send Page Description command                        */
       /*------------------------------------------------------*/
       case PAGECONTROL_BEGIN_PAGE:
           if(!lpApdl->fSendSetPhysPaper){     // if command has not sent yet

               /* reset duplex mode if fDuplex is FALSE */
               if(!lpApdl->fDuplex)
                   CmdSetPhysPaper[8] = 0x00;      // Duplex OFF

               /* send Set Physical Paper command */
               WriteSpoolBuf((LPDV)lpdv,
                           (LPSTR)CmdSetPhysPaper, sizeof(CmdSetPhysPaper));

               if(lpApdl->ulHorzRes == 600) {      // set unit base
                   CmdSetPhysPage[6] = 0x17;
                   CmdSetPhysPage[7] = 0x70;
               } else {
                   CmdSetPhysPage[6] = 0x0B;
                   CmdSetPhysPage[7] = 0xB8;
               }

               lpApdl->fSendSetPhysPaper = TRUE;   // already sent
           }

           // send Set Physical Page command
           WriteSpoolBuf((LPDV)lpdv, 
                           (LPSTR)CmdSetPhysPage, sizeof(CmdSetPhysPage));
           // send Begin Physical Page command
           WriteSpoolBuf((LPDV)lpdv, 
                           (LPSTR)CmdBeginPhysPage, sizeof(CmdBeginPhysPage));
           // send Begin Logical Page command
           WriteSpoolBuf((LPDV)lpdv, 
                           (LPSTR)CmdBeginLogPage, sizeof(CmdBeginLogPage));
           // send Define Drawing Area command
           WriteSpoolBuf((LPDV)lpdv, 
                           (LPSTR)CmdDefDrawArea, sizeof(CmdDefDrawArea));
           break;
       case PAGECONTROL_END_PAGE:
           // send End Logical Page command
           WriteSpoolBuf ((LPDV)lpdv,(LPSTR)CmdEndLogPage,  sizeof(CmdEndLogPage));
           // send End Physical Page command
           WriteSpoolBuf ((LPDV)lpdv,(LPSTR)CmdEndPhysPage, sizeof(CmdEndPhysPage));
           break;

       case PAGECONTROL_ABORT_DOC:
       case PAGECONTROL_END_DOC:
           // send A/PDL End command
           WriteSpoolBuf((LPDV)lpdv, (LPSTR)CmdAPDLEnd, sizeof(CmdAPDLEnd));
           break;
       /*------------------------------------------------------*/
       /* save print direction                                 */
       /*------------------------------------------------------*/
       case PAGECONTROL_POTRAIT:           // 36
           lpApdl->fOrientation = TRUE;
           break;
       case PAGECONTROL_LANDSCAPE:         // 37
           lpApdl->fOrientation = FALSE;
           break;
       /*------------------------------------------------------*/
       /* set Drawing Area into SetPhysPaperDesc command       */
       /*------------------------------------------------------*/
       case PHYS_PAPER_A3:                 // 50
       case PHYS_PAPER_A4:                 // 51
       case PHYS_PAPER_B4:                 // 54
       case PHYS_PAPER_LETTER:             // 57
       case PHYS_PAPER_LEGAL:              // 58
           CmdSetPhysPaper[5] = SetDrawArea(lpdv, wCmdCbId);
           break;

       case PHYS_PAPER_B5:                 // 55
       case PHYS_PAPER_A5:                 // 52
           CmdSetPhysPaper[5] = SetDrawArea(lpdv, wCmdCbId);
           /* even if Duplex is selected, it cancel */
           lpApdl->fDuplex = FALSE;
           CmdSetPhysPaper[8] = 0x00;      // Duplex is off
           break;

       case PHYS_PAPER_POSTCARD:           // 59
           CmdSetPhysPaper[5] = SetDrawArea(lpdv, wCmdCbId);
           /* if paper is Postcard, papersource is always Front Tray */
           CmdSetPhysPaper[6] = 0x00;      // select Front Tray
           CmdSetPhysPaper[7] = 0x00;      // Auto Tray Select is OFF

           /* even if Duplex is selected, it cancel */
           lpApdl->fDuplex = FALSE;
           CmdSetPhysPaper[8] = 0x00;      // Duplex is off
           break;

       case PHYS_PAPER_UNFIXED:            // 60
           /* if paper is Unfixed, papersource is always Front Tray */
           CmdSetPhysPaper[6] = 0x00;      // Select Front Tray
           CmdSetPhysPaper[7] = 0x00;      // Auto Tray Select is OFF

           /* even if Duplex is selected, it cancel */
           lpApdl->fDuplex = FALSE;
           CmdSetPhysPaper[8] = 0x00;      // Duplex is off

           CmdSetPhysPaper[5] = SetDrawArea(lpdv, wCmdCbId);
           CmdSetPhysPaper[12] = 0x00;     // UnitBase : 10 inch

           if(lpApdl->ulHorzRes == 600) {  // set logical unit
               CmdSetPhysPaper[13] = 0x17;
               CmdSetPhysPaper[14] = 0x70;
           } else {
               CmdSetPhysPaper[13] = 0x0B;
               CmdSetPhysPaper[14] = 0xB8;
           }

           if(lpApdl->fOrientation){    // portrait
               wPhysWidth  = (WORD)lpApdl->szlPhysSize.cx;
               wPhysHeight = (WORD)lpApdl->szlPhysSize.cy;
           } else {                     // landscape
               wPhysWidth  = (WORD)lpApdl->szlPhysSize.cy;
               wPhysHeight = (WORD)lpApdl->szlPhysSize.cx;
           }

           CmdSetPhysPaper[15] = (BYTE)(wPhysWidth  >> 8 & 0x00ff);
           CmdSetPhysPaper[16] = (BYTE)(wPhysWidth       & 0x00ff);
           CmdSetPhysPaper[17] = (BYTE)(wPhysHeight >> 8 & 0x00ff);
           CmdSetPhysPaper[18] = (BYTE)(wPhysHeight      & 0x00ff);

           break;
       /*------------------------------------------------------*/
       /* set Paper Tray into SetPhysPaperDesc command         */
       /*------------------------------------------------------*/
       case PAPER_SRC_FTRAY:
           CmdSetPhysPaper[6] = 0x00;      // Select Front Tray
           CmdSetPhysPaper[7] = 0x00;      // Auto Tray Select is OFF
           break;
       case PAPER_SRC_CAS1:
           CmdSetPhysPaper[6] = 0x01;      // Select Cassette 1
           CmdSetPhysPaper[7] = 0x00;      // Auto Tray Select is OFF
           break;
       case PAPER_SRC_CAS2:
           CmdSetPhysPaper[6] = 0x02;      // Select Cassette 2
           CmdSetPhysPaper[7] = 0x00;      // Auto Tray Select is OFF
           break;
       case PAPER_SRC_CAS3:
           CmdSetPhysPaper[6] = 0x03;      // Select Cassette 3
           CmdSetPhysPaper[7] = 0x00;      // Auto Tray Select is OFF
           break;
       /*------------------------------------------------------*/
       /* set Auto Tray Mode into SetPhysPaperDesc command     */
       /*------------------------------------------------------*/
       case PAPER_DEST_SCALETOFIT_ON:      // 25
           lpApdl->fScaleToFit = TRUE;
           CmdSetPhysPaper[7] = 0x02;
           break;
       case PAPER_DEST_SCALETOFIT_OFF:     // 26
           lpApdl->fScaleToFit = FALSE;
           CmdSetPhysPaper[7] = 0x00;
           break;
       /*------------------------------------------------------*/
       /* set Duplex Mode into SetPhysPaperDesc command        */
       /*------------------------------------------------------*/
       case PAGECONTROL_DUPLEX_UPDOWN:
           lpApdl->fDuplex = TRUE;
           CmdSetPhysPaper[8] = 0x01;      // Up Side Down
           break;
       case PAGECONTROL_DUPLEX_RIGHTUP:
           lpApdl->fDuplex = TRUE;
           CmdSetPhysPaper[8] = 0x02;      // Right Side Up
           break;
       case PAGECONTROL_DUPLEX_OFF:
           lpApdl->fDuplex = FALSE;
           break;
       /*------------------------------------------------------*/
       /* set Toner Save into SetPhysPage command              */
       /*------------------------------------------------------*/
       case TONER_SAVE_OFF:                // 100
           CmdSetPhysPage[10] = 0x00;      // off
           break;
       case TONER_SAVE_DARK:               // 101
           CmdSetPhysPage[10] = 0x02;      // dark
           break;
       case TONER_SAVE_LIGHT:              // 102
           CmdSetPhysPage[10] = 0x01;      // right
           break;
       /*------------------------------------------------------*/
       /* set Copy Count to SetPhysPaperDesc command           */
       /*------------------------------------------------------*/
       case PAGECONTROL_MULTI_COPIES:
// @Aug/31/98 ->
           if(MAX_COPIES_VALUE < *lpdwParams)
               CmdSetPhysPaper[9] = MAX_COPIES_VALUE;
           else if(1 > *lpdwParams)
               CmdSetPhysPaper[9] = 1;
           else
               CmdSetPhysPaper[9] = (BYTE)*lpdwParams;
// @Aug/31/98 <-
           break;
       /*------------------------------------------------------*/
       /* send Set Character Attribute with ornament           */
       /*------------------------------------------------------*/
       case BOLD_ON:
           if (!lpApdl->fItalic)   // bold only
               WriteSpoolBuf(lpdv, CmdBoldOn, sizeof(CmdBoldOn));
           else                    // bold and italic
               WriteSpoolBuf(lpdv, CmdBoldItalicOn, sizeof(CmdBoldItalicOn));

           lpApdl->fBold = TRUE;
           break;
       case ITALIC_ON:
           if (!lpApdl->fBold)     // italic only
               WriteSpoolBuf(lpdv, CmdItalicOn, sizeof(CmdItalicOn));
           else                    // italic and bold
               WriteSpoolBuf(lpdv, CmdBoldItalicOn, sizeof(CmdBoldItalicOn));

           lpApdl->fItalic = TRUE;
           break;
       case BOLD_OFF:
       case ITALIC_OFF:
           lpApdl->fItalic = lpApdl->fBold = FALSE;
           WriteSpoolBuf(lpdv, CmdBoldItalicOff, sizeof(CmdBoldItalicOff));
           break;
       /*------------------------------------------------------*/
       /*                                                      */
       /*------------------------------------------------------*/
       case X_ABS_MOVE:
           wTemp = (WORD)*lpdwParams / (MASTER_UNIT / (WORD)lpApdl->ulHorzRes);
           CmdGivenHoriPos[2] = (BYTE) (wTemp >> 8 & 0x00ff);
           CmdGivenHoriPos[3] = (BYTE) (wTemp & 0x00ff);
           /* Send SetGivenHorizontalPosition Command */
           WriteSpoolBuf(lpdv, CmdGivenHoriPos, sizeof(CmdGivenHoriPos));
           break;
       case Y_ABS_MOVE:
           wTemp = (WORD)*lpdwParams;
           CmdGivenVerPos[2] = (BYTE) (wTemp >> 8 & 0x00ff);
           CmdGivenVerPos[3] = (BYTE) (wTemp & 0x00ff);
           /* Send SetGivenVerticalPosition Command */
           WriteSpoolBuf(lpdv, CmdGivenVerPos, sizeof(CmdGivenVerPos));
           break;
       case CR_EMULATION:
           CmdGivenVerPos[2] = 0x00;
           CmdGivenVerPos[3] = 0x00;
           /* Send SetGivenVerticalPosition Command */
           WriteSpoolBuf(lpdv, CmdGivenVerPos, sizeof(CmdGivenVerPos));
           break;
       case XY_ABS_MOVE:
           if(lpApdl->ulHorzRes == 300) {
               dwXval = (DWORD) lpdwParams[0] / 2;
               dwYval = (DWORD) lpdwParams[1] / 2;
           } else {
               dwXval = (DWORD) lpdwParams[0];
               dwYval = (DWORD) lpdwParams[1];
           } /* endif */
           CmdSetGivenPos[2] = (BYTE)(dwXval >> 8 & 0x00ff);
           CmdSetGivenPos[3] = (BYTE)(dwXval      & 0x00ff);
           CmdSetGivenPos[4] = (BYTE)(dwYval >> 8 & 0x00ff);
           CmdSetGivenPos[5] = (BYTE)(dwYval      & 0x00ff);
           WriteSpoolBuf(lpdv, CmdSetGivenPos, sizeof(CmdSetGivenPos));
           break;
   }
}
/*****************************************************************************/
/*                                                                           */
/*  Module:    OEMOutputChar                                                 */
/*                                                                           */
/*  Function:                                                                */
/*                                                                           */
/*  Syntax:    VOID PASCAL OEMOutputChar(LPDV, LPSTR, WORD, SHORT)           */
/*                                                                           */
/*  Input:     lpdv        address of PDEVICE structure                      */
/*             lpstr                                                         */
/*             len                                                           */
/*             rcID                                                          */
/*                                                                           */
/*  Output:    short                                                         */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/
VOID PASCAL OEMOutputChar(LPDV lpdv, LPSTR lpstr, WORD len, SHORT rcID)
{
LPAPDL lpApdl = lpdv->lpMdv;

   if (rcID){  // "rc != 0" means font is device font.
       CmdPrnStrCurrent[2] = (BYTE)((len+1) >> 8 & 0x00ff);
       CmdPrnStrCurrent[3] = (BYTE)((len+1)      & 0x00ff);

       /* send Print Character String at Current Position command */
       WriteSpoolBuf(lpdv, (LPSTR)CmdPrnStrCurrent, sizeof(CmdPrnStrCurrent));
       WriteSpoolBuf(lpdv, lpstr, len);

       if(len <= 2) {
           /* send Move Position Horizontally command */
           CmdMoveHoriPos[2] = (BYTE)((lpApdl->wWidths * len) >> 8 & 0x00ff);
           CmdMoveHoriPos[3] = (BYTE)((lpApdl->wWidths * len)      & 0x00ff);
           WriteSpoolBuf(lpdv, (LPSTR)CmdMoveHoriPos, sizeof(CmdMoveHoriPos));
       }
   }
}
/*****************************************************************************/
/*                                                                           */
/*  Module:    OEMSendScalableFontCmd                                        */
/*                                                                           */
/*  Function:  send A/PDL-style font selection command.                      */
/*                                                                           */
/*  Syntax:    VOID PASCAL OEMSendScalableFontCmd(LPDV, LPCD, LPFONTINFO)    */
/*                                                                           */
/*  Input:     lpdv        address of PDEVICE structure                      */
/*             lpcd        offset to the command heap                        */
/*             lpFont      deveice font information                          */
/*                                                                           */
/*  Output:    VOID                                                          */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/
VOID PASCAL OEMSendScalableFontCmd(LPDV lpdv, LPCD lpcd, LPFONTINFO lpFont)
{
LPSTR  lpcmd;
short  ocmd;
WORD   wCount;
BYTE   rgcmd[CCHMAXCMDLEN];    // build command here
LPAPDL lpApdl = lpdv->lpMdv;
WORD   wHeight;
WORD   wWidth;

   if (!lpcd || !lpFont)
       return;

   // be careful about integer overflow.
   lpcmd = (LPSTR)(lpcd+1);
   ocmd = 0;

   for (wCount = 0; wCount < lpcd->wLength && ocmd < CCHMAXCMDLEN; )
       if (lpcmd[wCount] == '#' && lpcmd[wCount + 1] == 'H'){      // height
           wHeight = (lpFont->dfPixHeight - lpFont->dfInternalLeading);
           rgcmd[ocmd++] = HIBYTE(wHeight);
           rgcmd[ocmd++] = LOBYTE(wHeight);
           wCount += 2;
       }
       else {
           if (lpcmd[wCount] == '#' && lpcmd[wCount + 1] == 'W'){  // width
               if (lpFont->dfPixWidth > 0){
                   wWidth = lpFont->dfMaxWidth;
                   rgcmd[ocmd++] = HIBYTE(wWidth);
                   rgcmd[ocmd++] = LOBYTE(wWidth);

                   // move current position for device font in OEMOutputCHar
                   lpApdl->wWidths = lpFont->dfAvgWidth;
               }
               wCount += 2;
           }
           else
               rgcmd[ocmd++] = lpcmd[wCount++];
       }

   WriteSpoolBuf(lpdv, (LPSTR) rgcmd, ocmd);
}
/*****************************************************************************/
/*                                                                           */
/*  Module:    OEMScaleWidth                                                 */
/*                                                                           */
/*  Function:  return the scaled width which is calcualted based on the      */
/*             assumption that APDL assumes 72 points in one 1 inch.         */
/*                                                                           */
/*  Syntax:    SHORT PASCAL OEMScaleWidth(SHORT, SHORT, SHORT, SHORT, SHORT) */
/*                                                                           */
/*  Input:     width           in units specified by 'masterUnits'           */
/*             masterUnits                                                   */
/*             newHeight       in units specified by 'vRes'                  */
/*             vRes            height device units                           */
/*             hRes            width device units                            */
/*                                                                           */
/*  Output:    short                                                         */
/*                                                                           */
/*  Notice:    <extent> : <font units> = <base Width> : <hRes>               */
/*             <base width> : <etmMasterHeight> = <newWidth> : <newHeight>   */
/*             <etmMasterUnits> : <etmMasterHeight> = <font units> : <vRes>  */
/*             <newWidth> = (<extent> * <hRes> * <newHeight>) /              */
/*                                             (<etmMasterUnits> * <vRes>)   */
/*                                                                           */
/*****************************************************************************/
SHORT PASCAL OEMScaleWidth(SHORT width, 
                   SHORT masterUnits, SHORT newHeight, SHORT vRes, SHORT hRes)
{
DWORD  newWidth10;
short  newWidth;

   // assert that hRes == vRes to avoid overflow problem.
   if (vRes != hRes)
       return 0;

   newWidth10 = (DWORD)width * (DWORD)newHeight * 10;
   newWidth10 /= (DWORD)masterUnits;

   // we multiplied 10 first in order to maintain the precision of
   // the width calcution. Now convert it back and round to the
   // nearest integer.
   newWidth = (short)((newWidth10 + 5) / 10);

   return newWidth;
}
/*****************************************************************************/
/*                                                                           */
/*  Module:    SetDrawArea                                                   */
/*                                                                           */
/*  Function:                                                                */
/*                                                                           */
/*  Syntax:    BYTE PASCAL SetDrawArea(LPDV, WORD)                           */
/*                                                                           */
/*  Input:     lpdv                                                          */
/*             wCmdCbId                                                      */
/*                                                                           */
/*  Output:    BYTE                                                          */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/
BYTE PASCAL SetDrawArea(LPDV lpdv, WORD wCmdCbId)
{
LPAPDL    lpApdl = lpdv->lpMdv;
WORD       wWidth;
WORD       wHeight;
BYTE       bIndex;

   if(wCmdCbId != PHYS_PAPER_UNFIXED){
       bIndex = (BYTE)(wCmdCbId - PAPERSIZE_MAGIC);
       wWidth = phySize[bIndex].wWidth / (MASTER_UNIT / (WORD)lpApdl->ulHorzRes);
       wHeight= phySize[bIndex].wHeight / (MASTER_UNIT / (WORD)lpApdl->ulHorzRes);
   } else {
       bIndex = 0x7f;
       if(lpApdl->ulHorzRes == 600){
           if(lpApdl->fOrientation){   // portrait
               wWidth = (WORD)lpApdl->szlPhysSize.cx - (0x5e * 2);
               wHeight= (WORD)lpApdl->szlPhysSize.cy - (0x5e * 2);
           } else {                    // landscape
               wWidth = (WORD)lpApdl->szlPhysSize.cy - (0x5e * 2);
               wHeight= (WORD)lpApdl->szlPhysSize.cx - (0x5e * 2);
           }
       } else {
           if(lpApdl->fOrientation){   // portrait
               wWidth = (WORD)lpApdl->szlPhysSize.cx - (0x2f * 2);
               wHeight= (WORD)lpApdl->szlPhysSize.cy - (0x2f * 2);
           } else {                    // landscape
               wWidth = (WORD)lpApdl->szlPhysSize.cy - (0x2f * 2);
               wHeight= (WORD)lpApdl->szlPhysSize.cx - (0x2f * 2);
           }
       }
   }

   /* set value of width, height into DefineDrawingArea command */
   CmdDefDrawArea[9]  = (BYTE)(wWidth  >> 8 & 0x00ff);
   CmdDefDrawArea[10] = (BYTE)(wWidth       & 0x00ff);
   CmdDefDrawArea[11] = (BYTE)(wHeight >> 8 & 0x00ff);
   CmdDefDrawArea[12] = (BYTE)(wHeight      & 0x00ff);

   /* set value of Origin-X, Y into DefineDrawingArea command */
   if(lpApdl->ulHorzRes == 600){
       CmdDefDrawArea[5] = CmdDefDrawArea[7] = 0x00;
       CmdDefDrawArea[6] = CmdDefDrawArea[8] = 0x5e;
   } else {
       CmdDefDrawArea[5] = CmdDefDrawArea[7] = 0x00;
       CmdDefDrawArea[6] = CmdDefDrawArea[8] = 0x2f;
   }

   /* set Media Origin into DefineDrawingArea command */
   if(lpApdl->fOrientation)    // portrait
       CmdDefDrawArea[15] = 0x00;
   else {                      // landscape
       if( wCmdCbId==50 || wCmdCbId==54 || wCmdCbId==61)
           CmdDefDrawArea[15] = 0x01;  // A3 or B4 or Unfixed
       else
           CmdDefDrawArea[15] = 0x03;
   }

   return bIndex;
}
/*****************************************************************************/
/*                                                                           */
/*  Module:    BRL_Ecmd                                                      */
/*                                                                           */
/*  Function:  ByteRunLength(HBP) Compression Routine                        */
/*                                                                           */
/*  Syntax:    WORD PASCAL BRL_Ecmd(LPBYTE, LPBYTE, LPBYTE, WORD)            */
/*                                                                           */
/*  Input:     lpbSrc                                                        */
/*             lpbTgt                                                        */
/*             lpbTmp                                                        */
/*             len                                                           */
/*                                                                           */
/*  Output:    WORD                                                          */
/*                                                                           */
/*  Notice:                                                                  */
/*                                                                           */
/*****************************************************************************/
WORD PASCAL BRL_ECmd(LPBYTE lpbSrc, LPBYTE lpbTgt, LPBYTE lpbTmp, WORD len)
{

BYTE   bRCnt  = 1;                     // repeating byte counter
BYTE   bNRCnt = 0;                     // non-repeating byte counter
BYTE   bSaveRCnt;
WORD   i = 0, j = 0, k = 0, l = 0;     // movement trackers
char   Go4LastByte = TRUE;             // flag to get last byte

   /* initialize data */
   _fmemcpy(lpbTmp,(LPBYTE)lpbSrc,len);

   /* start compression routine - ByteRunLength Encoding */
   do {
       if(lpbSrc[i] != (lpbSrc[i+1])) {    // non-repeating data?
           while(((lpbTmp[i] != (lpbTmp[i+1]))
                               && ((i+1) < len)) && (bNRCnt < NRPEAK)) {
               bNRCnt++;                   // if so, how many?
               i++;
           }

           /* if at last element but less than NRPEAK value */
           if(((i+1)==len) && (bNRCnt<NRPEAK)) {
               bNRCnt++;                       // inc count for last element
               Go4LastByte = FALSE;            // no need to go back
           } else
               /* if at last BYTE, but before that, NRPEAK value has been reached */
               if(((i+1)==len) && ((bNRCnt)==NRPEAK))
                   Go4LastByte = TRUE;         // get the last BYTE

           /* assign the value for Number of Non-repeating bytes */
           lpbTgt[j] = bNRCnt-1;               // subtract one for WinP's case
           j++;                                // update tracker

           /* afterwards...write the Raw Data */
           for (l=0; l<bNRCnt;l++) {
               lpbTgt[j] = lpbSrc[k];
               k++;
               j++;
           }

           /* reset counter */
           bNRCnt = 0;
       } else {                                // end of Non-repeating data
                                               // data is repeating
           while(((lpbTmp[i]==(lpbTmp[i+1])) && ((i+1)<len)) && (bRCnt<RPEAK)) {
               bRCnt++;
               i++;
           }

           /* Convert to Two's Complement */
           bSaveRCnt   = bRCnt;                // save original value
           bRCnt = (BYTE) 0 - bRCnt;

           /* Write the Number of Repeating Data */
           lpbTgt[j] = bRCnt + 1;              // add one for WinP's case
           j++;                                // go to next element

           /* afterwards...write the Repeating data */
           lpbTgt[j] = lpbSrc[k];
           j++;

           /* update counters */
           k += bSaveRCnt;
           bRCnt  = 1;
           i     += 1;

           /* check if last element has been reached */
           if (i==len)
               Go4LastByte=FALSE;              // if so, no need to go back
       }                                       // end of Repeating data
   } while (Go4LastByte);                      // end of Compression

   return ( j );
}

/*****************************************************************************/
/*                                                                           */
/*  Module:    fnOEMGetFontCmd                                               */
/*                                                                           */
/*  Function:                                                                */
/*                                                                           */
/*  Syntax:    BOOL fnOEMGetFontCmd(LPDV, WORD, PVOID, BOOL, PBYTE, PWORD)   */
/*                                                                           */
/*  InputF    lpdv                                                          */
/*             wCmdCbId                                                      */
/*             lpFont                                                        */
/*             fSelect                                                       */
/*             lpBuf                                                         */
/*             lpwSize                                                       */
/*                                                                           */
/*  OutputF                                                                 */
/*                                                                           */
/*  NoticeF                                                                 */
/*                                                                           */
/*  HistoryF  1996.05.20  Ver 1.00                                          */
/*                                                                           */
/*****************************************************************************/
BOOL PASCAL OEMGetFontCmd(LPDV lpdv, WORD wCmdCbId, PVOID lpFont, 
                                   BOOL fSelect, PBYTE lpBuf, PWORD lpwSize)
{
return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\apdlres\etc\code.h ===
/*****************************************************************************/
/* CODE.H                                                                    */
/*                                                                           */
/* Copyright (C) 1997-     Advanced Peripherals Technologies, Inc.           */
/*                                                                           */
/* <HISTORY>                                                                 */
/*                                                                           */
/*****************************************************************************/
/*--------------------------------------------------------------------------*/
/*                        D E F I N E  V A L U E                            */
/*--------------------------------------------------------------------------*/
#define PAPER_SRC_FTRAY                20
#define PAPER_SRC_CAS1                 21
#define PAPER_SRC_CAS2                 22
#define PAPER_SRC_CAS3                 23
#define PAPER_SRC_AUTO                 24  //Not use by NT driver
#define PAPER_DEST_SCALETOFIT_ON       25
#define PAPER_DEST_SCALETOFIT_OFF      26

#define PAGECONTROL_BEGIN_DOC          30
#define PAGECONTROL_BEGIN_PAGE         31
#define PAGECONTROL_END_DOC            32
#define PAGECONTROL_END_PAGE           33
#define PAGECONTROL_DUPLEX_OFF         34
#define PAGECONTROL_ABORT_DOC          35
#define PAGECONTROL_POTRAIT            36
#define PAGECONTROL_LANDSCAPE          37
#define PAGECONTROL_MULTI_COPIES       38
#define PAGECONTROL_DUPLEX_UPDOWN      39
#define PAGECONTROL_DUPLEX_RIGHTUP     40

#define PAPERSIZE_MAGIC                50  // this ID - 50 = Actual ID of A/PDL
#define PHYS_PAPER_A3                  50
#define PHYS_PAPER_A4                  51
#define PHYS_PAPER_A5                  52
#define PHYS_PAPER_A6                  53  // Reserved
#define PHYS_PAPER_B4                  54
#define PHYS_PAPER_B5                  55
#define PHYS_PAPER_B6                  56  // Reserved
#define PHYS_PAPER_LETTER              57
#define PHYS_PAPER_LEGAL               58
#define PHYS_PAPER_POSTCARD            59
#define PHYS_PAPER_EXECUTIVE           60  // Reserved
#define PHYS_PAPER_UNFIXED             61

#define X_ABS_MOVE                     70
#define Y_ABS_MOVE                     71
#define XY_ABS_MOVE                    78
#define CR_EMULATION                   79

#define BOLD_ON                        72
#define BOLD_OFF                       73
#define ITALIC_ON                      74
#define ITALIC_OFF                     75

#define RESOLUTION_300                 76
#define RESOLUTION_600                 77

#define TONER_SAVE_OFF                 100
#define TONER_SAVE_DARK                101
#define TONER_SAVE_LIGHT               102

#define MASTER_UNIT                    600
#define LINE_PER_BAND                  32
#define CCHMAXCMDLEN                   128
#define MAXIMGSIZE                     0xF000

#define NRPEAK                         0x7F
#define RPEAK                          0x80
/*--------------------------------------------------------------------------*/
/*                       S T R U C T U R E  D E F I N E                     */
/*--------------------------------------------------------------------------*/
typedef struct tagAPDL {
   ULONG   ulHorzRes;          // width of the physical surface
   ULONG   ulVertRes;          // height of the physical surface
   SIZEL   szlPhysSize;        // size of unwriteable margin
   POINTL  ptlPhysOffset;      // size of entire surface with unwriteable margin
   LPSTR   lpCompBuf;          // buffer for compressed data  
   LPSTR   lpTempBuf;          // temp buffer for compression
   BOOL    fBold;              // TRUE = device font is bold
   BOOL    fItalic;            // TRUE = device font is italic
   BOOL    fSendSetPhysPaper;  // flag for sending set physical paper command
   WORD    wPageCount;         // for send Eject & Print physical paper command
   BOOL    fDuplex;            // TRUE = duplex mode is selected
   BOOL    fScaleToFit;        // for set auto tray mode in Set Physical Paper
   BOOL    fOrientation;       // for set media origin in Define Drawing Area
   WORD    wWidths;            // move current position afer print device font
} APDL, FAR * LPAPDL;

typedef struct tagPAPER {
   WORD    wWidth;
   WORD    wHeight;
} PHYSIZE, FAR * LPPHYSIZE;
//+---------------------------------------------------------------------------+
//|                    F U N C T I O N  P R O T O T Y P E                     |
//+---------------------------------------------------------------------------+
BOOL  PASCAL MiniDrvEnablePDEV(LPDV, PGDIINFO);
BOOL  PASCAL MiniDrvDisablePDEV(LPDV);
WORD  PASCAL CBFilterGraphics(LPDV, LPSTR, WORD);
VOID  PASCAL OEMOutputCmd(PVOID, WORD, PDWORD);
BOOL  PASCAL OEMGetFontCmd(PVOID, WORD, PVOID, BOOL, PBYTE, PWORD);
SHORT PASCAL OEMScaleWidth(SHORT, SHORT, SHORT, SHORT, SHORT);
VOID  PASCAL OEMSendScalableFontCmd(PVOID, LPCD, LPFONTINFO);
BYTE  PASCAL IsDBCSLeadBytePAGES(BYTE);
VOID  PASCAL OEMOutputChar(PVOID, PVOID, WORD, SHORT);
BYTE  PASCAL SetDrawArea(LPDV, WORD);
WORD  PASCAL BRL_ECmd(LPBYTE, LPBYTE, LPBYTE, WORD);
/*--------------------------------------------------------------------------*/
/*                           G L O B A L  V A L U E                         */
/*--------------------------------------------------------------------------*/
/*======================= P A P E R  S I Z E T A B L E =====================*/
PHYSIZE phySize[12] = {
//      Width    Height        Physical paper size for 600dpi
       (0x1AAC),(0x2604),      // A3 1B66 x 26C4
       (0x12A5),(0x1AAC),      // A4 1362 x 1B66
       (0x0CEC),(0x12A4),      // A5
       (0x0000),(0x0000),      // A6 (Reserved)
       (0x16FA),(0x20DA),      // B4 17B8 x 2196
       (0x100F),(0x16FA),      // B5 10CE x 17B8
       (0x0000),(0x0000),      // B6 (Reserved)
       (0x087E),(0x0CEC),      // Post Card 93C x DAA (Origin is EE)
       (0x1330),(0x190C),      // Letter 13CE x 19C8
       (0x1330),(0x2014),      // Legal
       (0x0000),(0x0000),      // Executive (Reserved)
       (0x0000),(0x0000)       // Unfixed
};
/*==================== A / P D L  C O M M A N D  S T R I N G ===============*/
BYTE CmdInAPDLMode[]    = {0x1B,0x7E,0x12,0x00,0x01,0x07};
BYTE CmdAPDLStart[]     = {0x1C,0x01};                 // A/PDL start
BYTE CmdAPDLEnd[]       = {0x1C,0x02};                 // A/PDL end
BYTE CmdBeginPhysPage[] = {0x1C,0x03};                 // Begin Physical Page
BYTE CmdEndPhysPage[]   = {0x1C,0x04};                 // End Physical Page
BYTE CmdBeginLogPage[]  = {0x1C,0x05};                 // Begin Logical page
BYTE CmdEndLogPage[]    = {0x1C,0x06};                 // End Logical Page
BYTE CmdEjectPhysPaper[]= {0x1C,0x0F};                 // Print&Eject Phys Paper
BYTE CmdMoveHoriPos[]   = {0x1C,0x21,0x00,0x00};       // Horizontal Relative
BYTE CmdGivenHoriPos[]  = {0x1C,0x23,0x00,0x00};       // Horizontal Absolute
BYTE CmdGivenVerPos[]   = {0x1C,0x24,0x00,0x00};       // Vertical Absolute
BYTE CmdSetGivenPos[]   = {0x1C,0x40,0x00,0x00,0x00,0x00};
BYTE CmdPrnStrCurrent[] = {0x1C,0xC3,0x00,0x00,0x03};  // Print String
BYTE CmdBoldItalicOn[]  = {0x1C,0xA5,0x08,0x04,0x06,0x02,0x30,0x00,0x00,0x00,0x00};
BYTE CmdBoldOn[]        = {0x1C,0xA5,0x04,0x04,0x02,0x02,0x20};
BYTE CmdItalicOn[]      = {0x1c,0xa5,0x08,0x04,0x06,0x02,0x10,0x00,0x00,0x00,0x00};
BYTE CmdBoldItalicOff[] = {0x1c,0xa5,0x04,0x04,0x02,0x02,0x00};

BYTE CmdSetPhysPaper[]  = {0x1C,0xA0,          // Set Physical Paper
                           0x10,               // length
                           0x01,               // SubCmd Basic Characteristics
                           0x05,               // SubCmdLength
                           0x01,               // Paper Size
                           0x01,               // PaperTray
                           0x00,               // AutoTrayMode
                           00,                 // Duplex Mode
                           0x01,               // Copy Count
                           0x02,               // SubCmd Set Unfixed Paper Size
                           0x07,               // SubCmdLength
                           00,                 // UnitBase
                           00,00,              // Logical Unit
                           00,00,              // Width
                           00,00};             // Height

BYTE CmdSetPhysPage[]   = {0x1C,0xA1,          // Set Physical Page
                           0x0D,               // Length
                           0x01,               // SubCmd Resolution
                           0x03,               // SubCmdLength
                           00,                 // Unit Base of 10
                           0x0B,0xB8,          // and Logical Unit Res of 3000
                           0x02,               // SubCmd Toner Save
                           0x01,               // SubCmdLength
                           00,                 // Toner Save OFF
                           0x03,               // SubCmd N-Up
                           0x03,               // SubCmdLength 
                           00,00,00};          // N-Up off 

BYTE CmdDefDrawArea[]   = {0x1C,0xA2,          // Define Drawing Area
                           0x0D,               // length
                           0x01,               // SubCmd origin width,height
                           0x08,               // SubCmdLength
                           0x00,0x77,          // origin X
                           0x00,0x77,          // origin Y
                           00,00,              // width
                           00,00,              // height
                           0x02,               // SubCmd Media Origin
                           0x01,               // SubCmdLength
                           00};                // Portrait

BYTE CmdDrawImgCurrent[]= {0x1C,0xE1,          // Draw Image at current position
                           00,00,00,00,        // length
                           01,                 // Compress method : 0x01 = BRL
                           00,00,              // actual width of image
                           00,LINE_PER_BAND,   // actual height of image
                           00,00,00,00};       // length of raw image

UNIDRVFN_WRITESPOOLBUF WriteSpoolBuf;
UNIDRVFN_ALLOCMEM      AllocMem;
UNIDRVFN_FREEMEM       FreeMem;

DRVFN MiniDrvFnTab[] =
{
   {INDEX_MiniDrvEnablePDEV,       (PFN)MiniDrvEnablePDEV},
   {INDEX_MiniDrvDisablePDEV,      (PFN)MiniDrvDisablePDEV},
   {INDEX_OEMWriteSpoolBuf,        (PFN)CBFilterGraphics},
   {INDEX_OEMOutputCmd,            (PFN)OEMOutputCmd},
   {INDEX_OEMGetFontCmd,           (PFN)OEMGetFontCmd},
   {INDEX_OEMOutputChar,           (PFN)OEMOutputChar},
   {INDEX_OEMSendScalableFontCmd,  (PFN)OEMSendScalableFontCmd},
   {INDEX_OEMScaleWidth1,          (PFN)OEMScaleWidth}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\capplres\capplid.h ===
#ifndef _CAPPLID_H
#define _CAPPLID_H

// Callback ID's
#define RES_SELECTRES_240        14
#define RES_SELECTRES_400        15

#define CM_XM_ABS                20
#define CM_YM_ABS                22

#define AUTOFEED                 30

#define PS_SEGMENT               40
#define PS_A3                    40
#define PS_B4                    41
#define PS_A4                    42
#define PS_B5                    43
#define PS_LETTER                44
#define PS_POSTCARD              45
#define PS_MPF                   46
#define PS_A5                    47
#define PS_FREE                  48

#define CBID_PORT                50
#define CBID_LAND                51

#define PRN_2000                 60
#define PRN_2000W                61
#define PRN_3000                 62

#endif // _CAPPLID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\capplres\capplres.c ===
// =========================================================================
//
//        CASIO PAGEPRESTO Universal Printer Driver for MS-Windows NT 5.0
//
// =========================================================================

//// CAPPLERES.C file for CASIO PAGEPRESTO CAPPL/Base Common DLL


#include "pdev.h"
#include "capplid.h"

#if DBG
#  include "mydbg.h"
#endif

#define CCHMAXCMDLEN 256

#define STR_SELECTRES_240_3K \
        "\x1B[1\x00\x03=5\x00\x1B[1\x00\x06=30240"
#define STR_SELECTRES_400_3K \
        "\x1B[1\x00\x03=5\x00\x1B[1\x00\x06=30400"

// ===== PaperSize =====
#define STR_LETTER_2000 \
        "\x1B@0\x05\x1B@A\x07\x1B@B\x07"
#define STR_LETTER_3000 \
        "\x1B[1\x00\x03@06\x1B[1\x00\x03@18"

#define STR_A3_3000 \
        "\x1B[1\x00\x03@00\x1B[1\x00\x03@10"

#define STR_A4_2000 \
        "\x1B@0\x03\x1B@A\x05\x1B@B\x05"
#define STR_A4_3000 \
        "\x1B[1\x00\x03@02\x1B[1\x00\x03@13"

#define STR_B4_2000 \
        "\x1B@0\x02\x1B@B\x04"
#define STR_B4_3000 \
        "\x1B[1\x00\x03@01\x1B[1\x00\x03@11"

#define STR_B5_2000 \
        "\x1B@0\x04\x1B@A\x06\x1B@B\x06"
#define STR_B5_3000 \
        "\x1B[1\x00\x03@04\x1B[1\x00\x03@14"

#define STR_A5_3000 \
        "\x1B[1\x00\x03@05\x1B[1\x00\x03@16"

#define STR_POSTCARD_2000 \
        "\x1B@0\x0C\x1B@A\x0E\x1B@B\x0E"
#define STR_POSTCARD_3000 \
        "\x1B[1\x00\x03@0;\x1B[1\x00\x03@1="

#define STR_FREE_2000 \
        "\x1B@0\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
        "\x1B@A\x03\x00\x00\x00\x00" \
        "\x1B@B\x03\x00\x00\x00\x00"
#define STR_FREE_3000 \
        "\x1B@0\x00\x00\x00\x00\x00\x00\x00\x00\x00" \
        "\x1B[1\x00\x06@2\x00\x00\x00\x00" \
        "\x1B[1\x00\x03@1\x3F"

// ===== MPF Setting =====
#define OPT_NOSET         "Option1"
#define OPT_A3            "Option2"
#define OPT_B4            "Option3"
#define OPT_A4            "Option4"
#define OPT_B5            "Option5"
#define OPT_LETTER        "Option6"
#define OPT_POSTCARD      "Option7"
#define OPT_A5            "Option8"


#define WRITESPOOLBUF(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))

#define DRVGETDRIVERSETTING(p, t, o, s, n, r) \
    ((p)->pDrvProcs->DrvGetDriverSetting(p, t, o, s, n, r))

#define PARAM(p,n) \
    (*((p)+(n)))

#define MASTER_UNIT 1200

// ===== AutoFeed =====
const
static BYTE AutoFeed_2000[] = {    /* Auto Select */
                    0x33,        /* A3 */
                    0x34,        /* B4 */
                    0x35,        /* A4 */
                    0x36,        /* B5 */
                    0x33,        /* Letter */
                    0x33,        /* PostCard */
                    0x33,        /* MPF */
                    0x33         /* A5 */
};

const
static BYTE AutoFeed_3000[] = {    /* Auto Select */
                    0x38,        /* A3 */
                    0x34,        /* B4 */
                    0x35,        /* A4 */
                    0x36,        /* B5 */
                    0x37,        /* Letter */
                    0x37,        /* PostCard */
                    0x37,        /* MPF */
                    0x3B         /* A5 */
};



BOOL
BInitOEMExtraData(
        POEMUD_EXTRADATA pOEMExtra
    )
{
    // Initialize OEM Extra data.

    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;
    return TRUE;
}


BOOL
BMergeOEMExtraData(
        POEMUD_EXTRADATA pdmIn,
        POEMUD_EXTRADATA pdmOut
    )
{
    return TRUE;
}

PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded)
{
    PMYPDEV pOEM;

    VERBOSE(("OEMEnablePDEV - %08x\n", pdevobj));

    if(!pdevobj->pdevOEM)
    {
        if(!(pdevobj->pdevOEM = MemAllocZ(sizeof(MYPDEV))))
        {
            ERR(("Faild to allocate memory. (%d)\n",
                GetLastError()));
            return NULL;
        }
    }

    pOEM = (PMYPDEV)pdevobj->pdevOEM;

    pOEM->sRes = MASTER_UNIT / 240; // Default to 240dpi
    pOEM->jFreePaper = 0;          // Default to No(0)
    // misc initializations, if any

    return pdevobj->pdevOEM;
}

VOID APIENTRY
OEMDisablePDEV(
    PDEVOBJ pdevobj)
{
    PMYPDEV pOEM = (PMYPDEV)pdevobj->pdevOEM;

    VERBOSE(("OEMDisablePDEV - %08x\n", pdevobj));

    if(pdevobj->pdevOEM)
    {
        MemFree(pdevobj->pdevOEM);
        pdevobj->pdevOEM = NULL;
    }
    return;
}

BOOL APIENTRY
OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
{
    PMYPDEV pOld, pNew;

    VERBOSE(("OEMResetPDEV - %08x, %08x\n", pdevobjOld, pdevobjNew));

    if (NULL == (pOld = (PMYPDEV)pdevobjOld->pdevOEM) ||
        NULL == (pNew = (PMYPDEV)pdevobjNew->pdevOEM)) {
        ERR(("Invalid PDEV\n"));
        return FALSE;
    }

    *pNew = *pOld;
    return TRUE;
}


static
VOID
EmitJobSetup(
    PDEVOBJ pdevobj,
    PMYPDEV pOEM
) {
    BYTE cmdbuf[CCHMAXCMDLEN];
    WORD wlen = 0;
    BYTE jOutput[64];
    DWORD dwNeeded;
    DWORD dwOptionsReturned;

    if (pOEM->dwGeneral & FG_HAS_EMUL) {
        // Alster emulation mode setting
        cmdbuf[wlen++] = 0x1B;
        cmdbuf[wlen++] = 'i';
        cmdbuf[wlen++] = 'w';
        cmdbuf[wlen++] = '0';
    }

    WRITESPOOLBUF(pdevobj, cmdbuf, wlen);

    if (!DRVGETDRIVERSETTING(
            pdevobj, "MPFSetting", jOutput,
            sizeof(BYTE) * 64, &dwNeeded, &dwOptionsReturned)) {
        WARNING(("DrvGetDriverSetting(1) Failed\n"));
        pOEM->jMPFSetting = MPF_NOSET;
    } else {
        if (!strcmp(jOutput, OPT_A3)) {
            pOEM->jMPFSetting = MPF_A3;
            VERBOSE(("MPF_A3\n"));
        } else if (!strcmp(jOutput, OPT_B4)) {
            pOEM->jMPFSetting = MPF_B4;
            VERBOSE(("MPF_B4\n"));
        } else if (!strcmp(jOutput, OPT_A4)) {
            pOEM->jMPFSetting = MPF_A4;
            VERBOSE(("MPF_A4\n"));
        } else if (!strcmp(jOutput, OPT_B5)) {
            pOEM->jMPFSetting = MPF_B5;
            VERBOSE(("MPF_B5\n"));
        } else if (!strcmp(jOutput, OPT_A5)) {
            pOEM->jMPFSetting = MPF_A5;
            VERBOSE(("MPF_A5\n"));
        } else if (!strcmp(jOutput, OPT_LETTER)) {
            pOEM->jMPFSetting = MPF_LETTER;
            VERBOSE(("MPF_LETTER\n"));
        } else if (!strcmp(jOutput, OPT_POSTCARD)) {
            pOEM->jMPFSetting = MPF_POSTCARD;
            VERBOSE(("MPF_POSTCARD\n"));
        } else {
            pOEM->jMPFSetting = MPF_NOSET;
            VERBOSE(("MPF_NOSET\n"));
        }
    }
}

static
VOID
LoadPaperSelectCmd(
    PDEVOBJ pdevobj,
    PMYPDEV pOEM,
    INT iPaperID
) {

    switch (iPaperID) {
    case PS_LETTER:
        if (pOEM->jModel == MD_CP2000) {
            if (pOEM->jMPFSetting == MPF_LETTER)
                pOEM->jAutoSelect = AutoFeed_2000[PS_MPF - PS_SEGMENT];
            else
                pOEM->jAutoSelect = AutoFeed_2000[iPaperID - PS_SEGMENT];

            pOEM->cmdPaperSize.cmd = STR_LETTER_2000;
            pOEM->cmdPaperSize.cmdlen = sizeof(STR_LETTER_2000) - 1;
        } else {
            if (pOEM->jMPFSetting == MPF_LETTER)
                pOEM->jAutoSelect = AutoFeed_3000[PS_MPF - PS_SEGMENT];
            else
                pOEM->jAutoSelect = AutoFeed_3000[iPaperID - PS_SEGMENT];

            pOEM->cmdPaperSize.cmd = STR_LETTER_3000;
            pOEM->cmdPaperSize.cmdlen = sizeof(STR_LETTER_3000) - 1;
        }

        break;

    case PS_A3:
        // CP-3000 Only

        if (pOEM->jMPFSetting == MPF_A3)
            pOEM->jAutoSelect = AutoFeed_3000[PS_MPF - PS_SEGMENT];
        else
            pOEM->jAutoSelect = AutoFeed_3000[iPaperID - PS_SEGMENT];

        pOEM->cmdPaperSize.cmd = STR_A3_3000;
        pOEM->cmdPaperSize.cmdlen = sizeof(STR_A3_3000) - 1;

        break;

    case PS_A4:
        if (pOEM->jModel == MD_CP2000) {
            if (pOEM->jMPFSetting == MPF_A4)
                pOEM->jAutoSelect = AutoFeed_2000[PS_MPF - PS_SEGMENT];
            else
                pOEM->jAutoSelect = AutoFeed_2000[iPaperID - PS_SEGMENT];

            pOEM->cmdPaperSize.cmd = STR_A4_2000;
            pOEM->cmdPaperSize.cmdlen = sizeof(STR_A4_2000) - 1;
        } else {
            if (pOEM->jMPFSetting == MPF_A4)
                pOEM->jAutoSelect = AutoFeed_3000[PS_MPF - PS_SEGMENT];
            else
                pOEM->jAutoSelect = AutoFeed_3000[iPaperID - PS_SEGMENT];

            pOEM->cmdPaperSize.cmd = STR_A4_3000;
            pOEM->cmdPaperSize.cmdlen = sizeof(STR_A4_3000) - 1;
        }

        break;

    case PS_B4:
        if (pOEM->jModel == MD_CP2000) {
            if (pOEM->jMPFSetting == MPF_B4)
                pOEM->jAutoSelect = AutoFeed_2000[PS_MPF - PS_SEGMENT];
            else
                pOEM->jAutoSelect = AutoFeed_2000[iPaperID - PS_SEGMENT];

            pOEM->cmdPaperSize.cmd = STR_B4_2000;
            pOEM->cmdPaperSize.cmdlen = sizeof(STR_B4_2000) - 1;
        } else {
            if (pOEM->jMPFSetting == MPF_B4)
                pOEM->jAutoSelect = AutoFeed_3000[PS_MPF - PS_SEGMENT];
            else
                pOEM->jAutoSelect = AutoFeed_3000[iPaperID - PS_SEGMENT];

            pOEM->cmdPaperSize.cmd = STR_B4_3000;
            pOEM->cmdPaperSize.cmdlen = sizeof(STR_B4_3000) - 1;
        }

        break;

    case PS_B5:
        if (pOEM->jModel == MD_CP2000) {
            if (pOEM->jMPFSetting == MPF_B5)
                pOEM->jAutoSelect = AutoFeed_2000[PS_MPF - PS_SEGMENT];
            else
                pOEM->jAutoSelect = AutoFeed_2000[iPaperID - PS_SEGMENT];

            pOEM->cmdPaperSize.cmd = STR_B5_2000;
            pOEM->cmdPaperSize.cmdlen = sizeof(STR_B5_2000) - 1;
        } else {
            if (pOEM->jMPFSetting == MPF_B5)
                pOEM->jAutoSelect = AutoFeed_3000[PS_MPF - PS_SEGMENT];
            else
                pOEM->jAutoSelect = AutoFeed_3000[iPaperID - PS_SEGMENT];

            pOEM->cmdPaperSize.cmd = STR_B5_3000;
            pOEM->cmdPaperSize.cmdlen = sizeof(STR_B5_3000) - 1;
        }

        break;

    case PS_A5:
        // CP-3000 Only

        if (pOEM->jMPFSetting == MPF_A5)
            pOEM->jAutoSelect = AutoFeed_3000[PS_MPF - PS_SEGMENT];
        else
            pOEM->jAutoSelect = AutoFeed_3000[iPaperID - PS_SEGMENT];

        pOEM->cmdPaperSize.cmd = STR_A5_3000;
        pOEM->cmdPaperSize.cmdlen = sizeof(STR_A5_3000) - 1;

        break;

    case PS_POSTCARD:
        if (pOEM->jModel == MD_CP2000) {
            if (pOEM->jMPFSetting == MPF_POSTCARD)
                pOEM->jAutoSelect = AutoFeed_2000[PS_MPF - PS_SEGMENT];
            else
                pOEM->jAutoSelect = AutoFeed_2000[iPaperID - PS_SEGMENT];

            pOEM->cmdPaperSize.cmd = STR_POSTCARD_2000;
            pOEM->cmdPaperSize.cmdlen = sizeof(STR_POSTCARD_2000) - 1;
        } else {
            if (pOEM->jMPFSetting == MPF_POSTCARD)
                pOEM->jAutoSelect = AutoFeed_3000[PS_MPF - PS_SEGMENT];
            else
                pOEM->jAutoSelect = AutoFeed_3000[iPaperID - PS_SEGMENT];

            pOEM->cmdPaperSize.cmd = STR_POSTCARD_3000;
            pOEM->cmdPaperSize.cmdlen = sizeof(STR_POSTCARD_3000) - 1;
        }
        break;
    }
}

INT APIENTRY
OEMCommandCallback(
        PDEVOBJ pdevobj,
        DWORD   dwCmdCbID,
        DWORD   dwCount,
        PDWORD  pdwParams
    )
{
    PMYPDEV pOEM;
    BYTE cmdbuf[CCHMAXCMDLEN];
    WORD wlen;
    WORD wTemp, i;
    WORD wDestX, wDestY;
    INT iRet = 0;
    DWORD dwTemp;
    WORD wVirPapX1;
    WORD wVirPapY1;
    WORD wVirPapX2;
    WORD wVirPapY2;
    WORD wPapLenX;
    WORD wPapLenY;

    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);

#if DBG
{
    int i, max;
    for (i = 0; i < (max = sizeof(MyCallbackID) / sizeof(MyCallbackID[0])); i++) {
        if (MyCallbackID[i].dwID == dwCmdCbID){
            VERBOSE(("%s PARAMS: %d\n", MyCallbackID[i].S, dwCount));
            break;
        }
    }
    if (i == max)
        WARNING(("%d is Invalid ID\n", dwCmdCbID));
}
#endif

    ASSERT(VALID_PDEVOBJ(pdevobj));

    wlen = 0;

    //
    // fill in printer commands
    //

    switch (dwCmdCbID) {

    case RES_SELECTRES_240:

        pOEM->wOldX = pOEM->wOldY = 0;
        pOEM->sRes = MASTER_UNIT / 240;
        WRITESPOOLBUF(pdevobj, STR_SELECTRES_240_3K,
                sizeof(STR_SELECTRES_240_3K) - 1);
        break;

    case RES_SELECTRES_400:

        pOEM->wOldX = pOEM->wOldY = 0;
        pOEM->sRes = MASTER_UNIT / 400;
        WRITESPOOLBUF(pdevobj, STR_SELECTRES_400_3K,
                sizeof(STR_SELECTRES_400_3K) - 1);
        break;

    case CM_XM_ABS:
    case CM_YM_ABS:
        switch (dwCmdCbID) {
        case CM_XM_ABS:
            wDestX = (WORD)(PARAM(pdwParams, 0) / pOEM->sRes);
            wDestY = pOEM->wOldY;
            pOEM->wOldX = wDestX;
            break;
        case CM_YM_ABS:
            wDestX = pOEM->wOldX;
            wDestY = (WORD)(PARAM(pdwParams, 1) / pOEM->sRes);
            pOEM->wOldY = wDestY;
            break;
        }

        // ESC '\' '9' XX YY

//        wDestX = (WORD)(PARAM(pdwParams, 0) / pOEM->sRes);
//        wDestY = (WORD)(PARAM(pdwParams, 1) / pOEM->sRes);

        VERBOSE(("(wDestX, wDestY): (%d, %d)\n", wDestX, wDestY));

        cmdbuf[wlen++] = 0x1b;
        cmdbuf[wlen++] = 0x5c;
        cmdbuf[wlen++] = 0x39;
        cmdbuf[wlen++] = (BYTE)((wDestX >> 8) | 0x80);
        cmdbuf[wlen++] = (BYTE)(wDestX);
        cmdbuf[wlen++] = (BYTE)(wDestY >> 8);
        cmdbuf[wlen++] = (BYTE)(wDestY);

        WRITESPOOLBUF(pdevobj, cmdbuf, wlen);

        // Set return value accordingly.  Unidrv expects
        // the values to be retuned in device's unit here.

        switch (dwCmdCbID) {
        case CM_XM_ABS:
            iRet = wDestX;
            break;
        case CM_YM_ABS:
            iRet = wDestY;
            break;
        }

        break;

    case PS_LETTER:
    case PS_A3:
    case PS_A4:
    case PS_B4:
    case PS_B5:
    case PS_A5:
    case PS_POSTCARD:
        pOEM->jFreePaper = 0;  // No(0)
        LoadPaperSelectCmd(pdevobj, pOEM, (INT)dwCmdCbID);
        break;

    case PS_FREE:
        pOEM->jFreePaper = 1;  // yes(1)

        if (pOEM->jModel == MD_CP2000) {
            pOEM->stFreePaperSize.wX = (WORD)(PARAM(pdwParams, 0) / pOEM->sRes);        // dot
            pOEM->stFreePaperSize.wY = (WORD)(PARAM(pdwParams, 1) / pOEM->sRes);
            pOEM->jAutoSelect = AutoFeed_2000[PS_MPF - PS_SEGMENT];                     // MPF
        } else {
            pOEM->stFreePaperSize.wX = (WORD)(PARAM(pdwParams, 0) / pOEM->sRes);        // dot
            pOEM->stFreePaperSize.wY = (WORD)(PARAM(pdwParams, 1) / pOEM->sRes);

            dwTemp = PARAM(pdwParams, 0);
// 2001/02/27 ->
//          dwTemp = (dwTemp * 254) / MASTER_UNIT;                                      // 0.1mm a unit
//          pOEM->stFreePaperSize.wXmm = (WORD)((dwTemp + 5) / 10);                     //   1mm a unit, round
            dwTemp = (dwTemp * 2540) / MASTER_UNIT;                                     // 0.01mm a unit
            pOEM->stFreePaperSize.wXmm = (WORD)((dwTemp + 99) / 100);                   //    1mm a unit, roundup
// 2001/02/27 <-

            dwTemp = PARAM(pdwParams, 1);
// 2001/02/27 ->
//          dwTemp = (dwTemp * 254) / MASTER_UNIT;                                      // 0.1mm a unit
//          pOEM->stFreePaperSize.wYmm = (WORD)((dwTemp + 5) / 10);                     //   1mm a unit, round
            dwTemp = (dwTemp * 2540) / MASTER_UNIT;                                     // 0.01mm a unit
            pOEM->stFreePaperSize.wYmm = (WORD)((dwTemp + 99) / 100);                   //    1mm a unit, roundup
// 2001/02/27 <-
            pOEM->jAutoSelect = AutoFeed_3000[PS_MPF - PS_SEGMENT];                     // MPF
        }

        break;

    case AUTOFEED:
        cmdbuf[wlen++] = 0x1B;
        cmdbuf[wlen++] = '@';
        cmdbuf[wlen++] = ')';
        cmdbuf[wlen++] = pOEM->jAutoSelect;

        WRITESPOOLBUF(pdevobj, cmdbuf, wlen);
        break;

    case CBID_PORT:
    case CBID_LAND:
        // Page Format
        cmdbuf[wlen++] = 0x1B;
        cmdbuf[wlen++] = '=';
        cmdbuf[wlen++] = '4';
        cmdbuf[wlen++] = 0x00;

        // Orientaion
        cmdbuf[wlen++] = 0x1B;
        cmdbuf[wlen++] = '@';
        if (dwCmdCbID == CBID_LAND)
            cmdbuf[wlen++] = '3';
        else
            cmdbuf[wlen++] = '2';

        WRITESPOOLBUF(pdevobj, cmdbuf, wlen);

        // PaperSize
        if (pOEM->jFreePaper == 0) {
            WRITESPOOLBUF(pdevobj, pOEM->cmdPaperSize.cmd, pOEM->cmdPaperSize.cmdlen);
        } else {
            if (pOEM->jModel == MD_CP2000) {
                if (dwCmdCbID == CBID_LAND) {
                    wVirPapX1 = 0;
                    wVirPapY1 = 0;
                    wVirPapX2 = pOEM->stFreePaperSize.wY - ((240 / pOEM->sRes) * 2);
                    wVirPapY2 = pOEM->stFreePaperSize.wX - ((400 / pOEM->sRes) * 2);
                    wPapLenX  = pOEM->stFreePaperSize.wY;
                    wPapLenY  = pOEM->stFreePaperSize.wX;
                } else {
                    wVirPapX1 = 0;
                    wVirPapY1 = 0;
                    wVirPapX2 = pOEM->stFreePaperSize.wX - ((400 / pOEM->sRes) * 2);
                    wVirPapY2 = pOEM->stFreePaperSize.wY - ((240 / pOEM->sRes) * 2);
                    wPapLenX  = pOEM->stFreePaperSize.wX;
                    wPapLenY  = pOEM->stFreePaperSize.wY;
                }

                wlen = 0;
                wlen = sizeof(STR_FREE_2000) - 1;
                memcpy(cmdbuf, STR_FREE_2000, wlen);

                // VirtualPaperSize
                cmdbuf[ 4] = HIBYTE(wVirPapX1);         // X1
                cmdbuf[ 5] = LOBYTE(wVirPapX1);
                cmdbuf[ 6] = HIBYTE(wVirPapY1);         // Y1
                cmdbuf[ 7] = LOBYTE(wVirPapY1);
                cmdbuf[ 8] = HIBYTE(wVirPapX2);         // X2
                cmdbuf[ 9] = LOBYTE(wVirPapX2);
                cmdbuf[10] = HIBYTE(wVirPapY2);         // Y2
                cmdbuf[11] = LOBYTE(wVirPapY2);
                
                // PaperSize (APF)
                cmdbuf[16] = HIBYTE(wPapLenX);          // X1
                cmdbuf[17] = LOBYTE(wPapLenX);
                cmdbuf[18] = HIBYTE(wPapLenY);          // Y1
                cmdbuf[19] = LOBYTE(wPapLenY);
                
                // MPF-PaperSize
                cmdbuf[24] = HIBYTE(wPapLenX);          // X1
                cmdbuf[25] = LOBYTE(wPapLenX);
                cmdbuf[26] = HIBYTE(wPapLenY);          // Y1
                cmdbuf[27] = LOBYTE(wPapLenY);
                
                WRITESPOOLBUF(pdevobj, cmdbuf, wlen);
            } else {

                if (dwCmdCbID == CBID_LAND) {
                    wVirPapX1 = 0;
                    wVirPapY1 = 0;
                    wVirPapX2 = pOEM->stFreePaperSize.wY - ((240 / pOEM->sRes) * 2);
                    wVirPapY2 = pOEM->stFreePaperSize.wX - ((240 / pOEM->sRes) * 2);
                    wPapLenX  = pOEM->stFreePaperSize.wYmm;
                    wPapLenY  = pOEM->stFreePaperSize.wXmm;
                } else {
                    wVirPapX1 = 0;
                    wVirPapY1 = 0;
                    wVirPapX2 = pOEM->stFreePaperSize.wX - ((240 / pOEM->sRes) * 2);
                    wVirPapY2 = pOEM->stFreePaperSize.wY - ((240 / pOEM->sRes) * 2);
                    wPapLenX  = pOEM->stFreePaperSize.wXmm;
                    wPapLenY  = pOEM->stFreePaperSize.wYmm;
                }
                
                wlen = sizeof(STR_FREE_3000) - 1;
                memcpy(cmdbuf, STR_FREE_3000, wlen);

                // VirtualPaperSize
                cmdbuf[ 4] = HIBYTE(wVirPapX1);         // X1
                cmdbuf[ 5] = LOBYTE(wVirPapX1);
                cmdbuf[ 6] = HIBYTE(wVirPapY1);         // Y1
                cmdbuf[ 7] = LOBYTE(wVirPapY1);
                cmdbuf[ 8] = HIBYTE(wVirPapX2);         // X2
                cmdbuf[ 9] = LOBYTE(wVirPapX2);
                cmdbuf[10] = HIBYTE(wVirPapY2);         // Y2
                cmdbuf[11] = LOBYTE(wVirPapY2);

                // MPF-PaperSize
                cmdbuf[19] = HIBYTE(wPapLenX);          // X
                cmdbuf[20] = LOBYTE(wPapLenX);
                cmdbuf[21] = HIBYTE(wPapLenY);          // Y
                cmdbuf[22] = LOBYTE(wPapLenY);

                WRITESPOOLBUF(pdevobj, cmdbuf, wlen);
            }
        }
        break;

    case PRN_2000:
        pOEM->jModel = MD_CP2000;
        pOEM->dwGeneral &= ~FG_HAS_EMUL;
        EmitJobSetup(pdevobj, pOEM);
        break;

    case PRN_2000W:
        pOEM->jModel = MD_CP2000;
        pOEM->dwGeneral |= FG_HAS_EMUL;
        EmitJobSetup(pdevobj, pOEM);
        break;

    case PRN_3000:
        pOEM->jModel = MD_CP3000;
        pOEM->dwGeneral |= FG_HAS_EMUL;
        EmitJobSetup(pdevobj, pOEM);
        break;
    }

    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\capplres\debug.c ===
#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>

#include <windef.h>
#include <winbase.h>
#include <wingdi.h>
#include <winddi.h>

//
// Functions for outputting debug messages
//

VOID
DbgPrint(IN LPCSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\capplres\common.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

//static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
//static BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);


BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE(("OEMGetInfo(%s) entry.\n", OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        ERR(("OEMGetInfo() ERROR_INVALID_PARAMETER.\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        ERR(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    VERBOSE(("OEMDevMode(%s) entry.\n", OEMDevMode_fMode[dwMode]));

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        ERR(("OEMDevMode() ERROR_INVALID_PARAMETER.\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);

        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        ERR(("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\n"));

        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            ERR(("OEMUD OEMDevMode():  not valid OEM Extra Data.\n"));

            return FALSE;
        }
        break;
    }

    return TRUE;
}


#if 0
//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{

    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;
    memcpy(pOEMExtra->cbTestString, TESTSTRING, sizeof(TESTSTRING));

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

static BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
    if(pdmIn)
    {
        //
        // copy over the private fields, if they are valid
        //
        memcmp(pdmOut->cbTestString, pdmIn->cbTestString, sizeof(TESTSTRING));
    }

    return TRUE;
}

#endif

//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\n"));
        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\n"));

        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\n"));
        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\n"));
        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\n"));
        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\n"));
        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        VERBOSE(("\n\tOEM_DEVMODEPARAM dump:\n\n"));

        VERBOSE(("\tcbSize = %d.\n", pOEMDevModeParam->cbSize));
        VERBOSE(("\thPrinter = %#lx.\n", pOEMDevModeParam->hPrinter));
        VERBOSE(("\thModule = %#lx.\n", pOEMDevModeParam->hModule));
        VERBOSE(("\tpPublicDMIn = %#lx.\n", pOEMDevModeParam->pPublicDMIn));
        VERBOSE(("\tpPublicDMOut = %#lx.\n", pOEMDevModeParam->pPublicDMOut));
        VERBOSE(("\tpOEMDMIn = %#lx.\n", pOEMDevModeParam->pOEMDMIn));
        VERBOSE(("\tpOEMDMOut = %#lx.\n", pOEMDevModeParam->pOEMDMOut));
        VERBOSE(("\tcbBufSize = %d.\n", pOEMDevModeParam->cbBufSize));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\capplres\comoem.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

        Necessary COM class definition to Unidrv
        OEM rendering module plug-in.

Environment:

        Windows NT Unidrv driver

Revision History:

        98/4/24 takashim:
        Written the original sample so that it is more C++.

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB: public IPrintOemUni
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {    
        VERBOSE((DLLTEXT("IOemCB: QueryInterface entry\n")));
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IUnknown.\n"))); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            VERBOSE((DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n"))); 
        }
        else
        {
            *ppv = NULL ;
            VERBOSE((DLLTEXT("IOemCB:Return NULL.\n"))); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE((DLLTEXT("IOemCB::AddRef() entry.\n")));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        VERBOSE((DLLTEXT("IOemCB::Release() entry.\n")));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::GetInfo() entry.\n")));

        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE((DLLTEXT("IOemCB::DevMode() entry.\n")));

        if (OEMDevMode(dwMode, pOemDMParam)) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    }

    //
    // IPrintOemEngine methods
    //

    //
    // Function Name: EnableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        VERBOSE((DLLTEXT("IOemCB::EnableDriver() entry.\n")));
// Sep.17.98 ->
        // Need to return S_OK so that DisableDriver() will be called, which Releases
        // the reference to the Printer Driver's interface.
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: DisableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisableDriver(VOID)
    {
        VERBOSE((DLLTEXT("IOemCB::DisaleDriver() entry.\n")));
// Sep.17.98 ->
        // Release reference to Printer Driver's interface.
        if (this->pOEMHelp)
        {
            this->pOEMHelp->Release();
            this->pOEMHelp = NULL;
        }
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ         pdevobj,
        PWSTR           pPrinterName,
        ULONG           cPatterns,
        HSURF          *phsurfPatterns,
        ULONG           cjGdiInfo,
        GDIINFO        *pGdiInfo,
        ULONG           cjDevInfo,
        DEVINFO        *pDevInfo,
        DRVENABLEDATA  *pded,
        OUT PDEVOEM    *pDevOem)
    {

        //VERBOSE((DLLTEXT("IOemCB::EnablePDEV() entry.\n")));

        *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName,
            cPatterns, phsurfPatterns, cjGdiInfo, pGdiInfo,
            cjDevInfo, pDevInfo, pded);

        if (*pDevOem)
            return S_OK;
        else
            return S_FALSE;
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        LONG lI;

        //VERBOSE((DLLTEXT("IOemCB::DisablePDEV() entry.\n")));

        OEMDisablePDEV(pdevobj);
        return S_OK;
    }

    //
    // Function Name: ResetPDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
        //VERBOSE((DLLTEXT("IOemCB::ResetPDEV() entry.\n")));

        if (OEMResetPDEV(pdevobjOld, pdevobjNew))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // IPrintOemUni methods
    //

    //
    // Function Name: PublishDriverInterface
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE((DLLTEXT("IOemCB::PublishDriverInterface() entry.\n")));
// Sep.8.98 ->
        // Need to store pointer to Driver Helper functions, if we already haven't.
        if (this->pOEMHelp == NULL)
        {
            HRESULT hResult;

            // Get Interface to Helper Functions.
            hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

            if(!SUCCEEDED(hResult))
            {
                // Make sure that interface pointer reflects interface query failure.
                this->pOEMHelp = NULL;

                return E_FAIL;
            }
        }
// Sep.8.98 <-
        return S_OK;
    }

    //
    // Function Name: GetImplementationMethod
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    //
    // Needed to be static so that it can be passed
    // to the bsearch() as a pointer to a functin.
    //

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

        return strcmp(
            *((char **)p1),
            *((char **)p2));
    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        LONG lRet = E_NOTIMPL;
        PSTR pTemp;


        VERBOSE((DLLTEXT("IOemCB::GetImplementedMethod() entry.\n")));

        if (NULL != pMethodName) {

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                lRet = S_OK;
        }

        VERBOSE((DLLTEXT("pMethodName = %s, lRet = %d\n"), pMethodName, lRet));

        return lRet;
    }

    //
    // Function Name: CommandCallback
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ pdevobj,
        DWORD dwCallbackID,
        DWORD dwCount,
        PDWORD pdwParams,
        OUT INT *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::CommandCallback() entry.\n")));

        *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

        return S_OK;
    }

    //
    // Function Name: ImageProcessing
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ             pdevobj,  
        PBYTE               pSrcBitmap,
        PBITMAPINFOHEADER   pBitmapInfoHeader,
        PBYTE               pColorTable,
        DWORD               dwCallbackID,
        PIPPARAMS           pIPParams,
        OUT PBYTE           *ppbResult)
    {
        VERBOSE((DLLTEXT("IOemCB::ImageProcessing() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: FilterGraphics
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        VERBOSE((DLLTEXT("IOemCB::FilterGraphis() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: Compression
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    Compression(
        PDEVOBJ     pdevobj,
        PBYTE       pInBuf,
        PBYTE       pOutBuf,
        DWORD       dwInLen,
        DWORD       dwOutLen,
        OUT INT     *piResult)
    {
        VERBOSE((DLLTEXT("IOemCB::Compression() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: HalftonePattern
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ     pdevobj,
        PBYTE       pHTPattern,
        DWORD       dwHTPatternX,
        DWORD       dwHTPatternY,
        DWORD       dwHTNumPatterns,
        DWORD       dwCallbackID,
        PBYTE       pResource,
        DWORD       dwResourceSize)
    {
        VERBOSE((DLLTEXT("IOemCB::HalftonePattern() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: MemoryUsge
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ         pdevobj,   
        POEMMEMORYUSAGE pMemoryUsage)
    {
        VERBOSE((DLLTEXT("IOemCB::MemoryUsage() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadFontHeader
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadFontHeader() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadCharGlyph
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH      hGlyph,
        PDWORD      pdwWidth,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::DownloadCharGlyph() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTDonwloadMethod
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE((DLLTEXT("IOemCB::TTDownloadMethod() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: OutputCharStr
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD       dwType,
        DWORD       dwCount,
        PVOID       pGlyph) 
    {
        VERBOSE((DLLTEXT("IOemCB::OutputCharStr() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: SendFontCmd
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ      pdevobj,
        PUNIFONTOBJ  pUFObj,
        PFINVOCATION pFInv) 
    {
        VERBOSE((DLLTEXT("IOemCB::SendFontCmd() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: DriverDMS
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DriverDMS(
        PVOID   pDevObj,
        PVOID   pBuffer,
        DWORD   cbSize,
        PDWORD  pcbNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::DriverDMS() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TextOutputAsBitmap
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TextOutAsBitmap(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix)
    {
        VERBOSE((DLLTEXT("IOemCB::TextOutAsBitmap() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTYGetInfo
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ     pdevobj,
        DWORD       dwInfoIndex,
        PVOID       pOutputBuf,
        DWORD       dwSize,
        DWORD       *pcbcNeeded)
    {
        VERBOSE((DLLTEXT("IOemCB::TTYGetInfo() entry.\n")));
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE((DLLTEXT("IOemCF::CreateInstance() called\n.")));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE((DLLTEXT("DllGetClassObject:\tCreate class factory.")));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID);
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID);
}

///////////////////////////////////////////////////////////
//
// DLL module information
//

BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule ;
    }
        g_hModule = (HMODULE)hModule ;
    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\capplres\sources.inc ===
!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR=$(PRNROOT)\gpd\casio\$(ALT_PROJECT)
UNIDIR=$(PRNROOT)\unidrv2
SRCDIR=..

TARGETNAME=capplres
TARGETPATH=obj
TARGETTYPE=DYNLINK

!IF 0
DLLBASE=@$(COFFBASE_TXT_FILE),capplres
!ELSE
DLLBASE=0x8000000
!ENDIF

INCLUDES=$(PRNROOT)\inc;$(UNIDIR)\inc

RCCODEPAGE=932

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\capplres.rc \
    $(SRCDIR)\common.c \
    $(SRCDIR)\capplres.c

MISCFILES=\
    $(SRCDIR)\capplres.ini \
    $(GPDDIR)\cscp210j.gpd \
    $(GPDDIR)\cscp212j.gpd \
    $(GPDDIR)\cscp215j.gpd \
    $(GPDDIR)\cscp220j.gpd \
    $(GPDDIR)\cscp22wj.gpd \
    $(GPDDIR)\cscp325j.gpd \
    $(GPDDIR)\cscp350j.gpd
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\capplres\mydbg.h ===
#if DBG
#ifndef MYDBG_H_INCLUDED
#define MYDBG_H_INCLUDED

typedef struct _tblCallbackID {
    char*   S;
    DWORD   dwID;
} tblCallbackID;

static tblCallbackID MyCallbackID[] = {
    {"RES_SELECTRES_240",  14},
    {"RES_SELECTRES_400",  15},
    {"CM_XM_ABS",          20},
    {"CM_YM_ABS",          22},
    {"AUTOFEED",           30},
    {"PS_A3",              40},
    {"PS_B4",              41},
    {"PS_A4",              42},
    {"PS_B5",              43},
    {"PS_LETTER",          44},
    {"PS_POSTCARD",        45},
    {"PS_MPF",             46},
    {"PS_A5",              47},
    {"CBID_PORT",          50},
    {"CBID_LAND",          51},
    {"PRN_2000",           60},
    {"PRN_2000W",          61},
    {"PRN_3000",           62}
};

#endif  // MYDBG_H_INCLUDED
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\capplres\pdev.h ===
#ifndef _PDEV_H
#define _PDEV_H

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>

//
// OEM Signature and version.
//

#define OEM_SIGNATURE   'CPPL'      // CASIO CAPPL/B
#define DLLTEXT(s)      "CPPL: " s
#define OEM_VERSION      0x00010000L


#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

//
// ASSERT_VALID_PDEVOBJ can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
//
#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
#define ERRORTEXT(s)    "ERROR " s

////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

// For Cappl/Bace
typedef struct tag_CPPL_EXTRADATA {
    OEM_DMEXTRAHEADER    dmExtraHdr;
} CPPL_EXTRADATA, *PCPPL_EXTRADATA;

typedef struct {
    DWORD dwGeneral;
    SHORT   sRes;
    BYTE    jModel;
    struct st_cmd {
        char    *cmd;
        WORD    cmdlen;
    } cmdPaperSize;
    BYTE    jFreePaper;         // Yes(1). No(0)
    struct st_fps {
        WORD    wX;
        WORD    wY;
        WORD    wXmm;
        WORD    wYmm;
    } stFreePaperSize;
    BYTE    jMPFSetting;
    BYTE    jAutoSelect;
    WORD    wOldX;
    WORD    wOldY;
} MYPDEV, *PMYPDEV;

#define FG_HAS_EMUL 0x00000001

#define MINIPDEV_DATA(p) ((p)->pdevOEM)

#define POEMUD_EXTRADATA PCPPL_EXTRADATA
#define OEMUD_EXTRADATA CPPL_EXTRADATA

// Value for byModel
#define MD_CP2000        0x00
#define MD_CP3000        0x01

// Value for byMPFSetting
#define MPF_NOSET        0x00
#define MPF_A3            0x01
#define MPF_B4            0x02
#define MPF_A4            0x03
#define MPF_B5            0x04
#define MPF_LETTER        0x05
#define MPF_POSTCARD    0x06
#define MPF_A5            0x07

extern BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
extern BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);

#endif    // _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\casn4res\debug.c ===
#include <stddef.h>
#include <stdlib.h>
#include <stdarg.h>

#include <windef.h>
#include <winbase.h>
#include <wingdi.h>
#include <winddi.h>

//
// Functions for outputting debug messages
//

VOID
DbgPrint(IN LPCSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\capplres\names.h ===
//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
//     "Command",
    "CommandCallback",
//     "Compression",
//     "DeviceCapabilities",
    "DevMode",
//     "DevQueryPrintEx",
     "DisableDriver",
     "DisablePDEV",
//     "DocumentPropertySheets",
//     "DownloadCharGlyph",
//     "DownloadFontHeader",
//     "DriverDMS",
//     "DriverEvent",
//     "DrvGetDriverSetting",
//     "DrvWriteSpoolBuf",
     "EnableDriver",
     "EnablePDEV",
//     "FilterGraphics",
//     "FontInstallerDlgProc",
//     "GetDDIHooks",
//     "GetDriverSetting",
    "GetImplementedMethod",
    "GetInfo",
//     "HalftonePattern",
//     "ImageProcessing",
//     "MemoryUsage",
//     "OutputCharStr",
//     "PrinterEvent",
//     "PropCommonUIProp",
//     "PublishDriverInterface",
//     "QueryColorProfile",
     "ResetPDEV",
//     "SendFontCmd",
//     "SheetsDevicePropertySheets",
//     "TextOutAsBitmap",
//     "TTDownloadMethod",
//     "TTYGetInfo",
//     "UpdateUISetting",
//     "UpgradePrinter",
//     "UpgradeRegistry",
//     "UpgradeRegistrySetting",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\casn4res\common.c ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

DWORD gdwDrvMemPoolTag = 'meoD';    // lib.h requires this global var, for debugging

////////////////////////////////////////////////////////
//      INTERNAL PROTOTYPES
////////////////////////////////////////////////////////

//static BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
//static BOOL BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);
static BOOL BIsValidOEMDevModeParam(DWORD dwMode, POEMDMPARAM pOEMDevModeParam);
static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam);

BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPCSTR OEM_INFO[] = {   "Bad Index",
                            "OEMGI_GETSIGNATURE",
                            "OEMGI_GETINTERFACEVERSION",
                            "OEMGI_GETVERSION",
                        };

    VERBOSE(("OEMGetInfo(%s) entry.\n", OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        ERR(("OEMGetInfo() ERROR_INVALID_PARAMETER.\n"));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        ERR(("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\n"));
        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}


BOOL APIENTRY OEMDevMode(
        DWORD dwMode,
        POEMDMPARAM pOEMDevModeParam)
{
    LPCSTR OEMDevMode_fMode[] = {   "NULL",
                                    "OEMDM_SIZE",
                                    "OEMDM_DEFAULT",
                                    "OEMDM_CONVERT",
                                    "OEMDM_MERGE",
                                };

    VERBOSE(("OEMDevMode(%s) entry.\n", OEMDevMode_fMode[dwMode]));

    // Validate parameters.
    if(!BIsValidOEMDevModeParam(dwMode, pOEMDevModeParam))
    {
        ERR(("OEMDevMode() ERROR_INVALID_PARAMETER.\n"));
        VDumpOEMDevModeParam(pOEMDevModeParam);
        return FALSE;
    }

    // Verify OEM extra data size.
    if( (dwMode != OEMDM_SIZE) &&
        sizeof(OEMUD_EXTRADATA) > pOEMDevModeParam->cbBufSize )
    {
        ERR(("OEMDevMode() ERROR_INSUFFICIENT_BUFFER.\n"));
        return FALSE;
    }

    // Handle dwMode.
    switch(dwMode)
    {
    case OEMDM_SIZE:
        pOEMDevModeParam->cbBufSize = sizeof(OEMUD_EXTRADATA);
        break;

    case OEMDM_DEFAULT:
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_CONVERT:
        // nothing to convert for this private devmode. So just initialize it.
        return BInitOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut);

    case OEMDM_MERGE:
        if(!BMergeOEMExtraData((POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMIn,
                               (POEMUD_EXTRADATA)pOEMDevModeParam->pOEMDMOut) )
        {
            ERR(("OEMUD OEMDevMode():  not valid OEM Extra Data.\n"));
            return FALSE;
        }
        break;
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BInitOEMExtraData
//
//  Description:  Initializes OEM Extra data.
//
//
//  Parameters:
//
//      pOEMExtra    Pointer to a OEM Extra data.
//
//      dwSize       Size of OEM extra data.
//
//
//  Returns:  TRUE if successful; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra)
{
    // Initialize OEM Extra data.
    pOEMExtra->dmExtraHdr.dwSize = sizeof(OEMUD_EXTRADATA);
    pOEMExtra->dmExtraHdr.dwSignature = OEM_SIGNATURE;
    pOEMExtra->dmExtraHdr.dwVersion = OEM_VERSION;

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   BMergeOEMExtraData
//
//  Description:  Validates and merges OEM Extra data.
//
//
//  Parameters:
//
//      pdmIn   pointer to an input OEM private devmode containing the settings
//              to be validated and merged. Its size is current.
//
//      pdmOut  pointer to the output OEM private devmode containing the
//              default settings.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//          02/11/97        APresley Created.
//          04/08/97        ZhanW    Modified the interface
//
//////////////////////////////////////////////////////////////////////////

BOOL BMergeOEMExtraData(
    POEMUD_EXTRADATA pdmIn,
    POEMUD_EXTRADATA pdmOut
    )
{
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:   BIsValidOEMDevModeParam
//
//  Description:  Validates OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      dwMode               calling mode
//      pOEMDevModeParam     Pointer to a OEMDEVMODEPARAM structure.
//
//
//  Returns:  TRUE if valid; FALSE otherwise.
//
//
//  Comments:
//
//
//  History:
//              02/11/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static BOOL BIsValidOEMDevModeParam(
    DWORD       dwMode,
    POEMDMPARAM pOEMDevModeParam)
{
    BOOL    bValid = TRUE;


    if(NULL == pOEMDevModeParam)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDevModeParam is NULL.\n"));
        return FALSE;
    }

    if(sizeof(OEMDMPARAM) > pOEMDevModeParam->cbSize)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  cbSize is smaller than sizeof(OEM_DEVMODEPARAM).\n"));
        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hPrinter)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  hPrinter is NULL.\n"));
        bValid = FALSE;
    }

    if(NULL == pOEMDevModeParam->hModule)
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  hModule is NULL.\n"));

        bValid = FALSE;
    }

    if( (0 != pOEMDevModeParam->cbBufSize) &&
        (NULL == pOEMDevModeParam->pOEMDMOut)
      )
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDMOut is NULL when it should not be.\n"));
        bValid = FALSE;
    }

    if( (OEMDM_MERGE == dwMode) && (NULL == pOEMDevModeParam->pOEMDMIn) )
    {
        ERR(("OEMUD IsValidOEMDevModeParam():  pOEMDMIn is NULL when it should not be.\n"));
        bValid = FALSE;
    }

    return bValid;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   VDumpOEMDevModeParam
//
//  Description:  Debug dump of OEM_DEVMODEPARAM structure.
//
//
//  Parameters:
//
//      pOEMDevModeParam     Pointer to an OEM DevMode param structure.
//
//
//  Returns:  N/A.
//
//
//  Comments:
//
//
//  History:
//              02/18/97        APresley Created.
//
//////////////////////////////////////////////////////////////////////////

static void VDumpOEMDevModeParam(POEMDMPARAM pOEMDevModeParam)
{
    // Can't dump if pOEMDevModeParam NULL.
    if(NULL != pOEMDevModeParam)
    {
        VERBOSE(("\n\tOEM_DEVMODEPARAM dump:\n\n"));

        VERBOSE(("\tcbSize = %d.\n", pOEMDevModeParam->cbSize));
        VERBOSE(("\thPrinter = %#lx.\n", pOEMDevModeParam->hPrinter));
        VERBOSE(("\thModule = %#lx.\n", pOEMDevModeParam->hModule));
        VERBOSE(("\tpPublicDMIn = %#lx.\n", pOEMDevModeParam->pPublicDMIn));
        VERBOSE(("\tpPublicDMOut = %#lx.\n", pOEMDevModeParam->pPublicDMOut));
        VERBOSE(("\tpOEMDMIn = %#lx.\n", pOEMDevModeParam->pOEMDMIn));
        VERBOSE(("\tpOEMDMOut = %#lx.\n", pOEMDevModeParam->pOEMDMOut));
        VERBOSE(("\tcbBufSize = %d.\n", pOEMDevModeParam->cbBufSize));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\casn4res\casn4res.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    casn4res.c

Abstract:

    Implementation of GPD command callback for "csn4j.gpd":
        OEMCommandCallback

Environment:

    Windows NT Unidrv driver

Revision History:

    09/10/97
        Created it.

--*/

#include "pdev.h"
#include <stdio.h>

//
// For debugging.
//

//#define DL_VERBOSE WARNING
#define DL_VERBOSE VERBOSE
//#define SC_VERBOSE WARNING
#define SC_VERBOSE VERBOSE

//
// Misc definitions and declarations.
//
#define BUFFLEN                     256

#ifdef wsprintf
#undef wsprintf
#endif // wsprintf
#define wsprintf sprintf

#define SWAPW(x) \
    ((WORD)(((WORD)(x))<<8)|(WORD)(((WORD)(x))>>8))

#define FONT_HEADER_SIZE            0x86            // format type 2
#define SIZE_SYMBOLSET              28
#define FONT_MIN_ID                 512
#define FONT_MAX_ID                 535
#define SJISCHR                     0x2000

#define IsValidDLFontID(x) \
    ((x) >= FONT_MIN_ID && (x) <= FONT_MAX_ID)

LONG
LGetPointSize100(
    LONG height,
    LONG vertRes);

LONG
LConvertFontSizeToStr(
    LONG  size,
    PSTR  pStr);

//
// Command callback ID's
//
#define TEXT_FS_SINGLE_BYTE     21
#define TEXT_FS_DOUBLE_BYTE     22

#define DOWNLOAD_SET_FONT_ID    23
#define DOWNLOAD_SELECT_FONT_ID 24
#define DOWNLOAD_SET_CHAR_CODE  25
#define DOWNLOAD_DELETE_FONT    26

#define FS_BOLD_ON              27
#define FS_BOLD_OFF             28
#define FS_ITALIC_ON            29
#define FS_ITALIC_OFF           30

#define RES_SELECTRES_300       70
#define RES_SELECTRES_600       71
#define RES_SELECTRES_300_COLOR 72

#define PC_BEGINDOC             82
#define PC_ENDDOC               83

#define PC_DUPLEX_NONE          90
#define PC_DUPLEX_VERT          91
#define PC_DUPLEX_HORZ          92
#define PC_PORTRAIT             93
#define PC_LANDSCAPE            94

#define PSRC_SELECT_CASETTE_1   100
#define PSRC_SELECT_CASETTE_2   101
#define PSRC_SELECT_CASETTE_3   102
#define PSRC_SELECT_MPF         103
#define PSRC_SELECT_AUTO        104

#define XXXX_TONER_SAVE_NONE    110
#define XXXX_TONER_SAVE_1       111
#define XXXX_TONER_SAVE_2       112
#define XXXX_TONER_SAVE_3       113
#define SMOOTHING_ON            120
#define SMOOTHING_OFF           121
#define JAMRECOVERY_ON          130
#define JAMRECOVERY_OFF         131
#define MediaType_1             140
#define MediaType_2             141
#define MediaType_3             142    //+CP-E8000

#define RECT_FILL_WIDTH         150
#define RECT_FILL_HEIGHT        151
#define RECT_FILL_GRAY          152
#define RECT_FILL_WHITE         153
#define RECT_FILL_BLACK         154

#if 0   /* OEM doesn't want to fix minidriver */
/* Below is def. for hack code to fix #412276 */
#define COLOR_SELECT_BLACK      160
#define COLOR_SELECT_RED        161
#define COLOR_SELECT_GREEN      162
#define COLOR_SELECT_BLUE       163
#define COLOR_SELECT_YELLOW     164
#define COLOR_SELECT_MAGENTA    165
#define COLOR_SELECT_CYAN       166
#define COLOR_SELECT_WHITE      167

#define DUMP_RASTER_CYAN        170
#define DUMP_RASTER_MAGENTA     171
#define DUMP_RASTER_YELLOW      172
#define DUMP_RASTER_BLACK       173

/* End of hack code */
#endif /* OEM doesn't want to fix minidriver */

//+CP-E8000 Begin
#define OUTBIN_SELECT_EXIT_1    190
#define OUTBIN_SELECT_EXIT_2    191
#define OUTBIN_SELECT_EXIT_3    192
#define OUTBIN_SELECT_EXIT_4    193
#define OUTBIN_SELECT_EXIT_5    194
#define OUTBIN_SELECT_EXIT_6    195
//+CP-E8000 End

//
// ---- S T R U C T U R E  D E F I N E ----
//
typedef BYTE * LPDIBITS;

typedef struct {
   WORD Integer;
   WORD Fraction;
} FRAC;

typedef struct {
    BYTE bFormat;
    BYTE bDataDir;
    WORD wCharCode;
    WORD wBitmapWidth;
    WORD wBitmapHeight;
    WORD wLeftOffset;
    WORD wAscent;
    FRAC CharWidth;
} ESCPAGECHAR;

typedef struct {
   WORD wFormatType;
   WORD wDataSize;
   WORD wSymbolSet;
   WORD wCharSpace;
   FRAC CharWidth;
   FRAC CharHeight;
   WORD wFontID;
   WORD wWeight;
   WORD wEscapement;
   WORD wItalic;
   WORD wLast;
   WORD wFirst;
   WORD wUnderline;
   WORD wUnderlineWidth;
   WORD wOverline;
   WORD wOverlineWidth;
   WORD wStrikeOut;
   WORD wStrikeOutWidth;
   WORD wCellWidth;
   WORD wCellHeight;
   WORD wCellLeftOffset;
   WORD wCellAscender;
   FRAC FixPitchWidth;
} ESCPAGEHEADER, FAR * LPESCPAGEHEADER;

//
// Static data to be used by this minidriver.
//

BYTE bit_mask[] = {0, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe};

#define BYTE_LENGTH(s) (sizeof (s) - 1)

BYTE BEGINDOC_EJL_BEGIN[] =
    "\x1bz\x00\x80"
    "\x1b\x01@EJL \x0a"
    "@EJL SET";
BYTE BEGINDOC_EJL_END[] =
    " ERRORCODE=ON"
    "\x0a"
    "@EJL EN LA=ESC/PAGE\x0a";
BYTE BEGINDOC_EPG_END[] =
    "\x1DrhE\x1D\x32\x34ifF\x1D\x31\x34isE"
    "\x1D\x32iaF\x1D\x31\x30ifF"
    "\x1D\x31ipP"
    "\x1B\x7A\xD0\x01\x43\x61\x2A\x1B\x7A\x00\x01"
    "\x1D\x30pmP";
// CASIO 00/09/16 ->
//BYTE ENDDOC_EJL_RESET[] = "\x1d\rhE"
BYTE ENDDOC_EJL_RESET[] = "\x1drhE"
// CASIO 00/09/16 <-
    "\x1b\x01@EJL \x0a"
    "\x1b\x01@EJL \x0a"
    "\x1bz\xb0\x00";

char SET_FONT_ID[]        = "\x1D%d;%ddh{F";
char DLI_SELECT_FONT_ID[] = "\x1D%ddcF\x1D\x30;-%dcoP";
char DLI_DELETE_FONT[]    = "\x1D%dddcF";
char SET_SINGLE_BMP[]     = "\x1D%d;%dsc{F";
char SET_DOUBLE_BMP[]     = "\x1D%d;%d;%dsc{F";
char SET_WIDTH_TBL[]      = "\x1D%d;%dcw{F";

char FS_SINGLE_BYTE[]     = "\x1D\x31;0mcF";
char FS_DOUBLE_BYTE[]     = "\x1D\x31;1mcF";
char PRN_DIRECTION[]      = "\x1D%droF";
char SET_CHAR_OFFSET[]    = "\x1D\x30;%dcoP";
char SET_CHAR_OFFSET_XY[] = "\x1D%d;%dcoP";
char VERT_FONT_SET[]      = "\x1D%dvpC";
char BOLD_SET[]           = "\x1D%dweF";
char ITALIC_SET[]         = "\x1D%dslF";

BYTE RECT_FILL[] = 
    "\x1D" "1owE"
    "\x1D" "1tsE"
    "\x1D" "0;0;%dspE"
    "\x1D" "1dmG"
    "\x1D" "%d;%d;%d;%d;0rG"
// do not turn overwrite mode off since it
// has bad effect over white-on-black texts
//    "\x1D" "0owE"
    "\x1D" "0tsE";

#define PSRC_CASETTE_1  0
#define PSRC_CASETTE_2  1
#define PSRC_CASETTE_3  2
#define PSRC_MPF        3
#define PSRC_AUTO       4

// CASIO 00/09/13 ->
BYTE *EJL_SelectPsrc[] = {
//   " PU=1", " PU=2", " PU=3", " PU=4", " PU=AU" };
   " PU=1", " PU=2", " PU=255", " PU=4", " PU=AU" };
// CASIO 00/09/13 <-

BYTE *EJL_SelectOrient[] = {
   " ORIENTATION=PORTRAIT", " ORIENTATION=LANDSCAPE" };

#define RES_300DPI      0
#define RES_600DPI      1
BYTE *EJL_SelectRes[] = {
   " ##RZ=OFF",  " ##RZ=ON" };
BYTE *EPg_SelectRes[] = {
    "\x1D" "0;300;300drE\x1D" "1;300;300drE\x1D" "2;240;240drE",
    "\x1D" "0;600;600drE\x1D" "1;600;600drE\x1D" "2;240;240drE" };

#define DUPLEX_NONE   0
#define DUPLEX_SIDE   1
#define DUPLEX_UP     2
BYTE *EJL_SetDuplex[] = {
   " ##DC=OFF", " ##DC=DUPON", " ##DC=DUPUP" };

#define XX_TONER_NORMAL 0
#define XX_TONER_SAVE_1 1
#define XX_TONER_SAVE_2 2
#define XX_TONER_SAVE_3 3
BYTE *EJL_SetTonerSave[] = {
    " ##TS=NORMAL", " ##TS=1", " ##TS=2", " ##TS=3" };

BYTE *EJL_SetColorMode[] = {
    " ##CM=OFF", " ##CM=ON" };

#define XX_SMOOTHING_OFF 0
#define XX_SMOOTHING_ON  1
BYTE *EJL_SetSmoohing[] = {
    " RI=OFF", " RI=ON" };

#define XX_JAMRECOVERY_OFF 0
#define XX_JAMRECOVERY_ON  1
BYTE *EJL_SetJamRecovery[] = {
    " ##JC=OFF", " ##JC=ON" };

#define XX_MediaType_1 1
#define XX_MediaType_2 2
//+CP-E8000 Begin
#define XX_MediaType_3 3
BYTE *EJL_SetMediaType[] = {
    " PK=NM", " PK=OS", " PK=TH" };
//+CP-E8000 End

//+CP-E8000 Begin
#define OUTBIN_EXIT_1 1
#define OUTBIN_EXIT_2 2
#define OUTBIN_EXIT_3 3
#define OUTBIN_EXIT_4 4
#define OUTBIN_EXIT_5 5
#define OUTBIN_EXIT_6 6
BYTE *EJL_SelectOutbin[] = {
   " ##ET=1", " ##ET=3", " ##ET=4", " ##ET=5", " ##ET=6", " ##ET=7"  };

#define JOBSHIFT_OFF 0
#define JOBSHIFT_ON  1
BYTE *EJL_JobShift[] = {
   " ##JO=OFF", " ##JO=ON"  };
//+CP-E8000 End

#if 0    /* OEM doesn't want to fix minidriver */
/* Below is def. for hack code to fix #412276 */
BYTE *COLOR_SELECT_COMMAND[] = {
    "\x1Bz\xD0\x01\x43\x63,0,0,0,255*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",    /* Black   */
    "\x1Bz\xD0\x01\x43\x62,255,0,0*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",      /* Red     */
    "\x1Bz\xD0\x01\x43\x62,0,255,0*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",      /* Green   */
    "\x1Bz\xD0\x01\x43\x62,0,0,255*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",      /* Blue    */
    "\x1Bz\xD0\x01\x43\x63,0,0,255,0*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",    /* Yellow  */
    "\x1Bz\xD0\x01\x43\x63,0,255,0,0*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",    /* Magenta */
    "\x1Bz\xD0\x01\x43\x63,255,0,0,0*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE",    /* Cyan    */
    "\x1Bz\xD0\x01\x43\x63,0,0,0,0*\x1Bz\x00\x01\x1D\x31owE\x1D\x31tsE\x1D\x31;0;100spE"       /* White   */
};
DWORD COLOR_SELECT_COMMAND_LEN[] = { 42, 39, 39, 39, 42, 42, 42, 39 };

BYTE *DUMP_RASTER_COMMAND[] = {
    "\x1Bz\xD0\x01\x43\x63,255,0,0,0*\x1Bz\x00\x01\x1D\x30owE\x1D\x30tsE",      /* Cyan    */
    "\x1Bz\xD0\x01\x43\x63,0,255,0,0*\x1Bz\x00\x01\x1D\x30owE\x1D\x30tsE",      /* Magenta */
    "\x1Bz\xD0\x01\x43\x63,0,0,255,0*\x1Bz\x00\x01\x1D\x30owE\x1D\x30tsE",      /* Yellow  */
    "\x1Bz\xD0\x01\x43\x63,0,0,0,255*\x1Bz\x00\x01\x1D\x30owE\x1D\x30tsE"       /* Black   */
};
#define DUMP_RASTER_COMMAND_LEN  31

/* End of hack code */
#endif  /* OEM doesn't want to fix minidriver */

#define MasterToDevice(p, i) \
     ((i) / ((PMYPDEV)(p))->iUnitFactor)

VOID
VSetSelectDLFont(
    PDEVOBJ pdevobj,
    DWORD dwFontID)
{
    PMYPDEV pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);
    BYTE Cmd[BUFFLEN];
    WORD wlen = 0;

    wlen += (WORD)wsprintf(Cmd, DLI_SELECT_FONT_ID, 
        (dwFontID - FONT_MIN_ID), 0);

//    if(pOEM->fGeneral & FG_VERT) {
//        wlen += wsprintf(&Cmd[wlen], VERT_FONT_SET, 0);
//        pOEM->fGeneral &= ~FG_VERT;
//
//    }

    WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);

    pOEM->dwDLFontID = dwFontID;

    DL_VERBOSE(("Set/Select: dwFontID=%x\n", dwFontID));
}


PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded)
{
    PMYPDEV pOEM;

    if(!pdevobj->pdevOEM)
    {
        if(!(pdevobj->pdevOEM = MemAllocZ(sizeof(MYPDEV))))
        {
            ERR(("Faild to allocate memory. (%d)\n",
                GetLastError()));
            return NULL;
        }
    }

    pOEM = (PMYPDEV)pdevobj->pdevOEM;

    pOEM->fGeneral = 0;
    pOEM->iEscapement = 0;
    pOEM->iDevCharOffset = 0;
    pOEM->iPaperSource = 0;
    pOEM->iDuplex = 0;
    pOEM->iTonerSave = 0;
    pOEM->iOrientation = 0;
    pOEM->iResolution = 0; 
    pOEM->iColor = 0;
    pOEM->iSmoothing = 0;
    pOEM->iJamRecovery = 0;
    pOEM->iMediaType = 0;
//+CP-E8000 Begin
    pOEM->iOutBin = 0;
//+CP-E8000 End

    pOEM->dwDLFontID = UNKNOWN_DLFONT_ID;
    pOEM->dwDLSelectFontID = UNKNOWN_DLFONT_ID;
    pOEM->dwDLSetFontID = UNKNOWN_DLFONT_ID;
    pOEM->wCharCode = 0;
    pOEM->iUnitFactor = 1;
    return pdevobj->pdevOEM;
}

VOID APIENTRY
OEMDisablePDEV(
    PDEVOBJ     pdevobj)
{
    if(pdevobj->pdevOEM)
    {
        MemFree(pdevobj->pdevOEM);
        pdevobj->pdevOEM = NULL;
    }
    return;
}

BOOL APIENTRY OEMResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
{
    PMYPDEV pOEMOld, pOEMNew;

    pOEMOld = (PMYPDEV)pdevobjOld->pdevOEM;
    pOEMNew = (PMYPDEV)pdevobjNew->pdevOEM;

    if (pOEMOld != NULL && pOEMNew != NULL)
        *pOEMNew = *pOEMOld;

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMCommandCallback
//////////////////////////////////////////////////////////////////////////

INT
APIENTRY
OEMCommandCallback(
    PDEVOBJ pdevobj,
    DWORD   dwCmdCbID,
    DWORD   dwCount,
    PDWORD  pdwParams
    )
{
    INT              iRet = 0;
    BYTE             *bp;
    BYTE             Cmd[BUFFLEN];
    PMYPDEV pOEM;
    WORD wlen;
    WORD wGray;
    DWORD dwTempX, dwTempY;

    VERBOSE(("OEMCommandCallback() entry.\n"));

    //
    // verify pdevobj okay
    //
    ASSERT(VALID_PDEVOBJ(pdevobj));

    //
    // fill in printer commands
    //
    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);

    switch (dwCmdCbID) {
    case FS_BOLD_ON:
    case FS_BOLD_OFF:
        if(pdwParams[0])
            pOEM->fGeneral |=  FG_BOLD;
        else
            pOEM->fGeneral &=  ~FG_BOLD;

        wlen = (WORD)wsprintf(Cmd,BOLD_SET, (pOEM->fGeneral & FG_BOLD)?15:0);
        WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);
        break;

    case FS_ITALIC_ON:
    case FS_ITALIC_OFF:
        if(pdwParams[0])
            pOEM->fGeneral |=  FG_ITALIC;
        else
            pOEM->fGeneral &=  ~FG_ITALIC;

        wlen = (WORD)wsprintf(Cmd,ITALIC_SET, (pOEM->fGeneral & FG_ITALIC)?346:0);
        WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);
        break;

    case TEXT_FS_SINGLE_BYTE:
        strcpy(Cmd,FS_SINGLE_BYTE);
        wlen = (WORD)strlen( Cmd );
        wlen += (WORD)wsprintf(&Cmd[wlen],PRN_DIRECTION,pOEM->iEscapement);
        if (pOEM->fGeneral & FG_VERT)
        {
            wlen += (WORD)wsprintf(&Cmd[wlen], VERT_FONT_SET, 0);
        }
        pOEM->fGeneral &= ~FG_DOUBLE;
        wlen += (WORD)wsprintf(&Cmd[wlen],BOLD_SET, 
                         (pOEM->fGeneral & FG_BOLD)?15:0);
        wlen += (WORD)wsprintf(&Cmd[wlen],ITALIC_SET,
                         (pOEM->fGeneral & FG_ITALIC)?346:0);
        WRITESPOOLBUF(pdevobj, Cmd, wlen);
        break;

    case TEXT_FS_DOUBLE_BYTE:
        strcpy(Cmd,FS_DOUBLE_BYTE);
        wlen = (WORD)strlen( Cmd );
        wlen += (WORD)wsprintf(&Cmd[wlen],PRN_DIRECTION,pOEM->iEscapement);
        if (pOEM->fGeneral & FG_VERT)
        {
            wlen += (WORD)wsprintf(&Cmd[wlen], VERT_FONT_SET, 1);
        }
        pOEM->fGeneral |= FG_DOUBLE;
        wlen += (WORD)wsprintf(&Cmd[wlen],BOLD_SET, 
                         (pOEM->fGeneral & FG_BOLD)?15:0);
        wlen += (WORD)wsprintf(&Cmd[wlen],ITALIC_SET, 
                         (pOEM->fGeneral & FG_ITALIC)?346:0);
        WRITESPOOLBUF(pdevobj, Cmd, wlen);
        break;

    case RES_SELECTRES_300:
        pOEM->iResolution = RES_300DPI;
        pOEM->iColor = 0;
        pOEM->iUnitFactor = MASTER_UNIT / 300;
        break;

    case RES_SELECTRES_600:
        pOEM->iResolution = RES_600DPI;
        pOEM->iColor = 0;
        pOEM->iUnitFactor = MASTER_UNIT / 600;
        break;

    case RES_SELECTRES_300_COLOR:
        pOEM->iResolution = RES_300DPI;
        pOEM->iColor = 2;
        pOEM->iUnitFactor = MASTER_UNIT / 300;
        break;

    case PC_PORTRAIT:
        pOEM->iOrientation = 0;
        break;

    case PC_LANDSCAPE:
        pOEM->iOrientation = 1;
        break;

    case PC_DUPLEX_NONE:
        pOEM->iDuplex = (DUPLEX_NONE + 1);
        break;

    case PC_DUPLEX_VERT:
        pOEM->iDuplex =
                (pOEM->iOrientation ?
                (DUPLEX_UP + 1) : (DUPLEX_SIDE + 1));
        break;

    case PC_DUPLEX_HORZ:
        pOEM->iDuplex =
                (pOEM->iOrientation ?
                (DUPLEX_SIDE + 1) : (DUPLEX_UP + 1));
        break;

    case PSRC_SELECT_MPF:
        pOEM->iPaperSource = PSRC_MPF;
        break;

    case PSRC_SELECT_CASETTE_1:
        pOEM->iPaperSource = PSRC_CASETTE_1;
        break;

    case PSRC_SELECT_CASETTE_2:
        pOEM->iPaperSource = PSRC_CASETTE_2;
        break;

    case PSRC_SELECT_CASETTE_3:
        pOEM->iPaperSource = PSRC_CASETTE_3;
        break;

    case PSRC_SELECT_AUTO:
        pOEM->iPaperSource = PSRC_AUTO;
        break; 

    case PC_BEGINDOC:

        // EJL commands
        WRITESPOOLBUF(pdevobj,
            BEGINDOC_EJL_BEGIN,
            BYTE_LENGTH(BEGINDOC_EJL_BEGIN));

        wlen = 0;
        strcpy( &Cmd[wlen],  EJL_SelectPsrc[pOEM->iPaperSource] );
        wlen += (WORD)strlen( &Cmd[wlen] );
        strcpy( &Cmd[wlen], EJL_SelectOrient[pOEM->iOrientation] );
        wlen += (WORD)strlen( &Cmd[wlen] );

        // CASIO extention

        strcpy( &Cmd[wlen],  EJL_SelectRes[pOEM->iResolution] );
        wlen += (WORD)strlen( &Cmd[wlen] );
        if (pOEM->iColor > 0) {
            strcpy( &Cmd[wlen],  EJL_SetColorMode[pOEM->iColor - 1] );
            wlen += (WORD)strlen( &Cmd[wlen] );
        }
        if (pOEM->iDuplex > 0) {
            strcpy( &Cmd[wlen],  EJL_SetDuplex[pOEM->iDuplex - 1] );
            wlen += (WORD)strlen( &Cmd[wlen] );
        }
        strcpy( &Cmd[wlen],  EJL_SetTonerSave[pOEM->iTonerSave] );
        wlen += (WORD)strlen( &Cmd[wlen] );

        strcpy( &Cmd[wlen],  EJL_SetSmoohing[pOEM->iSmoothing] );
        wlen += (WORD)strlen( &Cmd[wlen] );

        strcpy( &Cmd[wlen],  EJL_SetJamRecovery[pOEM->iJamRecovery] );
        wlen += (WORD)strlen( &Cmd[wlen] );

        if (pOEM->iMediaType > 0) {
            strcpy( &Cmd[wlen],  EJL_SetMediaType[pOEM->iMediaType - 1] );
            wlen += (WORD)strlen( &Cmd[wlen] );
        }
//+CP-E8000 Begin
        if (pOEM->iOutBin > 0) {
            strcpy( &Cmd[wlen],  EJL_SelectOutbin[pOEM->iOutBin - 1] );
            wlen += (WORD)strlen( &Cmd[wlen] );

            if (pOEM->iOutBin == OUTBIN_EXIT_2) {
                strcpy( &Cmd[wlen],  EJL_JobShift[JOBSHIFT_ON] );
                wlen += (WORD)strlen( &Cmd[wlen] );
            }
        }
//+CP-E8000 End

        WRITESPOOLBUF(pdevobj, Cmd, wlen );

        WRITESPOOLBUF(pdevobj,
            BEGINDOC_EJL_END,
            BYTE_LENGTH(BEGINDOC_EJL_END));
        WRITESPOOLBUF(pdevobj,
            BEGINDOC_EPG_END,
            BYTE_LENGTH(BEGINDOC_EPG_END));

        if(pOEM->iResolution == RES_300DPI)
            WRITESPOOLBUF(pdevobj, "\x1D\x30;0.24muE", 10);
        else
            WRITESPOOLBUF(pdevobj, "\x1D\x30;0.12muE", 10);

        // ESC/Page commands
        wlen = 0;
        strcpy( &Cmd[wlen],  EPg_SelectRes[pOEM->iResolution] );
        wlen += (WORD)strlen( &Cmd[wlen] );
        WRITESPOOLBUF(pdevobj, Cmd, wlen );
        // 99/09/28 ->
        // break;
        // 99/09/28 <-

        // Clear dwDLFontID
        // (There are data that contains a plural pages and
        //  also each page has different color mode.
        //  When page is changed, STARTDOC commands are spooled.
        //  It means that new DL font is set.
        //  That is why dwDLFontID got to be claer.)
        pOEM->dwDLFontID = UNKNOWN_DLFONT_ID;
        break;

    case PC_ENDDOC:
        WRITESPOOLBUF(pdevobj,
            ENDDOC_EJL_RESET,
            BYTE_LENGTH(ENDDOC_EJL_RESET));
        break;

    case XXXX_TONER_SAVE_NONE:
        pOEM->iTonerSave = XX_TONER_NORMAL;
        break;

    case XXXX_TONER_SAVE_1:
        pOEM->iTonerSave = XX_TONER_SAVE_1;
        break;

    case XXXX_TONER_SAVE_2:
        pOEM->iTonerSave = XX_TONER_SAVE_2;
        break;

    case XXXX_TONER_SAVE_3:
        pOEM->iTonerSave = XX_TONER_SAVE_3;
        break;

    case SMOOTHING_ON:
        pOEM->iSmoothing = XX_SMOOTHING_ON;
        break;

    case SMOOTHING_OFF:
        pOEM->iSmoothing = XX_SMOOTHING_OFF;
        break;

    case JAMRECOVERY_ON:
        pOEM->iJamRecovery = XX_JAMRECOVERY_ON;
        break;

    case JAMRECOVERY_OFF:
        pOEM->iJamRecovery = XX_JAMRECOVERY_OFF;
        break;

    case MediaType_1:
        pOEM->iMediaType = XX_MediaType_1;
        break;

    case MediaType_2:
        pOEM->iMediaType = XX_MediaType_2;
        break;

//+CP-E8000 Begin
    case MediaType_3:
        pOEM->iMediaType = XX_MediaType_3;
        break;

    case OUTBIN_SELECT_EXIT_1:
        pOEM->iOutBin = OUTBIN_EXIT_1;
        break;

    case OUTBIN_SELECT_EXIT_2:
        pOEM->iOutBin = OUTBIN_EXIT_2;
        break;

    case OUTBIN_SELECT_EXIT_3:
        pOEM->iOutBin = OUTBIN_EXIT_3;
        break;

    case OUTBIN_SELECT_EXIT_4:
        pOEM->iOutBin = OUTBIN_EXIT_4;
        break;

    case OUTBIN_SELECT_EXIT_5:
        pOEM->iOutBin = OUTBIN_EXIT_5;
        break;

    case OUTBIN_SELECT_EXIT_6:
        pOEM->iOutBin = OUTBIN_EXIT_6;
        break;

//+CP-E8000 End
    case DOWNLOAD_SET_FONT_ID:

        if (!IsValidDLFontID(pdwParams[0])) {

            // Must not happen!!
            ERR(("DLSetFontID: Soft font ID %x invalid.\n",
                pdwParams[0]));
            break;
        }

        // Actual printer command is sent
        // within DownloadCharGlyph.
        pOEM->dwDLSetFontID = pdwParams[0];

        DL_VERBOSE(("SetFontID: dwDLSetFontID=%x\n",
            pOEM->dwDLSetFontID));
        break;

    case DOWNLOAD_SELECT_FONT_ID:

        if (!IsValidDLFontID(pdwParams[0])) {

            // Must not happen!!
            ERR(("DLSelectFontID: Soft font ID %x invalid.\n",
                pdwParams[0]));
            break;
        }

        pOEM->dwDLSelectFontID = pdwParams[0];

        DL_VERBOSE(("SelectFontID: dwDLSelectFontID=%x\n",
            pOEM->dwDLSelectFontID));

        if (pOEM->dwDLFontID != pOEM->dwDLSelectFontID)
            VSetSelectDLFont(pdevobj, pOEM->dwDLSelectFontID);
        break;

    case DOWNLOAD_SET_CHAR_CODE:
        pOEM->wCharCode=(WORD)pdwParams[0];
        break;

    case DOWNLOAD_DELETE_FONT:

        DL_VERBOSE(("DLDeleteFont: dwDLFontID=%x, %x\n",
            pOEM->dwDLFontID, pdwParams[0]));

        wlen = (WORD)wsprintf(Cmd, DLI_DELETE_FONT, (WORD)pdwParams[0]-FONT_MIN_ID);
        WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);
        pOEM->dwDLFontID = UNKNOWN_DLFONT_ID;
        break;

    case RECT_FILL_WIDTH:
        pOEM->wRectWidth =
            (WORD)MasterToDevice(pOEM, pdwParams[0]);
        break;

    case RECT_FILL_HEIGHT:
        pOEM->wRectHeight =
            (WORD)MasterToDevice(pOEM, pdwParams[0]);
        break;

    case RECT_FILL_GRAY:
    case RECT_FILL_WHITE:
    case RECT_FILL_BLACK:
        if (RECT_FILL_GRAY == dwCmdCbID)
            wGray = (WORD)pdwParams[2];
        else if (RECT_FILL_WHITE == dwCmdCbID)
            wGray = 0;
        else
            wGray = 100;

        dwTempX = MasterToDevice(pOEM, pdwParams[0]);
        dwTempY = MasterToDevice(pOEM, pdwParams[1]);

        VERBOSE(("RectFill:%d,x=%d,y=%d,w=%d,h=%d\n",
            wGray,
            (WORD)dwTempX,
            (WORD)dwTempY,
            pOEM->wRectWidth,
            pOEM->wRectHeight));

        wlen = (WORD)wsprintf(Cmd, RECT_FILL,
            wGray,
            (WORD)dwTempX,
            (WORD)dwTempY,
            (WORD)(dwTempX + pOEM->wRectWidth - 1),
            (WORD)(dwTempY + pOEM->wRectHeight - 1));
        WRITESPOOLBUF(pdevobj, (LPSTR)Cmd, wlen);
        break;

#if 0   /* OEM doesn't want to fix minidriver */
    /* Below is hack code to fix #412276 */
    case COLOR_SELECT_BLACK:
    case COLOR_SELECT_RED:
    case COLOR_SELECT_GREEN:
    case COLOR_SELECT_BLUE:
    case COLOR_SELECT_YELLOW:
    case COLOR_SELECT_MAGENTA:
    case COLOR_SELECT_CYAN:
    case COLOR_SELECT_WHITE:
        /* Remember what color is select */
        pOEM->dwSelectedColor = dwCmdCbID;
        pOEM->iColorMayChange = 0;         /* Reset flag */

        /* Output Color Select Command */
        /* The logic supposes COLOR_SELECT_xxx starts with COLOR_SELECT_BLACK */
        /* and increases one by one                                           */
        WRITESPOOLBUF(pdevobj, (LPSTR)COLOR_SELECT_COMMAND[dwCmdCbID - COLOR_SELECT_BLACK],
                       COLOR_SELECT_COMMAND_LEN[dwCmdCbID - COLOR_SELECT_BLACK] );
        break;

    case DUMP_RASTER_CYAN:
    case DUMP_RASTER_MAGENTA:
    case DUMP_RASTER_YELLOW:
    case DUMP_RASTER_BLACK:
        /* Remember what color may change */
        pOEM->iColorMayChange = 1;         /* Set flag */

        /* Output Dump Raster Command */
        /* The logic supposes DUMP_RASTER_xxx starts with DUMP_RASTER_CYAN */
        /* and increases one by one                                           */
        WRITESPOOLBUF(pdevobj, (LPSTR)DUMP_RASTER_COMMAND[dwCmdCbID - DUMP_RASTER_CYAN],
                       DUMP_RASTER_COMMAND_LEN );
        break;

    /* End of hack code */
#endif  /* OEM doesn't want to fix minidriver */

    default:
        ERR(("Unknown callback ID = %d.\n", dwCmdCbID));
    }
    return iRet;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMSendFontCmdk
//////////////////////////////////////////////////////////////////////////

VOID
APIENTRY
OEMSendFontCmd(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    PFINVOCATION    pFInv)
{
    PGETINFO_STDVAR pSV;
    DWORD       adwStdVariable[2+2*4];
    DWORD       dwIn, dwOut;
    PBYTE       pubCmd;
    BYTE        aubCmd[128];
    PIFIMETRICS pIFI;
    DWORD       height, width, charoff;
    PMYPDEV pOEM;
    BYTE    Cmd[128];
    WORD    wlen;
    DWORD   dwNeeded;
    DWORD dwTemp;

    SC_VERBOSE(("OEMSendFontCmd() entry.\n"));

    pubCmd = pFInv->pubCommand;
    pIFI = pUFObj->pIFIMetrics;
    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);

    //
    // Get standard variables.
    //
    pSV = (PGETINFO_STDVAR)adwStdVariable;
    pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (4 - 1);
    pSV->dwNumOfVariable = 4;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    pSV->StdVar[2].dwStdVarID = FNT_INFO_TEXTYRES;
    pSV->StdVar[3].dwStdVarID = FNT_INFO_TEXTXRES;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE, pSV, pSV->dwSize, &dwNeeded)) {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\n"));
        return;
    }

    SC_VERBOSE(("ulFontID=%x\n", pUFObj->ulFontID));
    SC_VERBOSE(("FONTHEIGHT=%d\n", pSV->StdVar[0].lStdVariable));
    SC_VERBOSE(("FONTWIDTH=%d\n", pSV->StdVar[1].lStdVariable));

    // Initialize pOEM
    if (pIFI->jWinCharSet == 0x80)
        pOEM->fGeneral |= FG_DOUBLE;
    else
        pOEM->fGeneral &= ~FG_DOUBLE;
    pOEM->fGeneral &=  ~FG_BOLD;
    pOEM->fGeneral &=  ~FG_ITALIC;

    if('@' == *((LPSTR)pIFI+pIFI->dpwszFaceName))
        pOEM->fGeneral |= FG_VERT;
    else
        pOEM->fGeneral &= ~FG_VERT;

    if (pIFI->jWinPitchAndFamily & 0x01)
        pOEM->fGeneral &= ~FG_PROP;
    else
        pOEM->fGeneral |= FG_PROP;

    dwOut = 0;
    pOEM->fGeneral &= ~FG_DBCS;

    for( dwIn = 0; dwIn < pFInv->dwCount;) {
        if (pubCmd[dwIn] == '#' && pubCmd[dwIn+1] == 'V') {
            // Specify font height in device unit (current
            // output resolution).  Note Unidrv gives us
            // font-height in master units
            height = pSV->StdVar[0].lStdVariable * 100;
            height = MasterToDevice(pOEM, height);
            SC_VERBOSE(("Height=%d\n", height));
            dwOut += LConvertFontSizeToStr(height, &aubCmd[dwOut]);
            dwIn += 2;
        } else if (pubCmd[dwIn] == '#' && pubCmd[dwIn+1] == 'H') {
            if (pubCmd[dwIn+2] == 'S') {
                SC_VERBOSE(("HS: "));
                width = pSV->StdVar[1].lStdVariable;
                dwIn += 3;
                pOEM->fGeneral |= FG_DBCS;
            } else if (pubCmd[dwIn+2] == 'D') {
                SC_VERBOSE(("HD: "));
                width = pSV->StdVar[1].lStdVariable * 2;
                dwIn += 3;
                pOEM->fGeneral |= FG_DBCS;
            } else {
                SC_VERBOSE(("H: "));
                if (pSV->StdVar[1].lStdVariable)
                    width = pSV->StdVar[1].lStdVariable;
                else
                    width = pIFI->fwdAveCharWidth;
                dwIn += 2;
            }
            // Specify font width in CPI.
            width = (MASTER_UNIT * 100L) / width;
            SC_VERBOSE(("Width=%d\n", width));
            dwOut += LConvertFontSizeToStr(width, &aubCmd[dwOut]);
        } else {
            aubCmd[dwOut++] = pubCmd[dwIn++];
        }
    }

    WRITESPOOLBUF(pdevobj, aubCmd, dwOut);

#if 0 //MSKK 98/12/22
    pOEM->iDevCharOffset = (pIFI->fwdWinDescender * pSV->StdVar[0].lStdVariable * 72)
                          / (pIFI->fwdUnitsPerEm * pSV->StdVar[2].lStdVariable / pOEM->sHeightDiv);
#else
    // Unidrv gives us raw IFIMETRICS block so we need to
    // translate its members into meaningful values.  n.b.
    // we assume font height passed from Unidrv = em value.
    dwTemp = MasterToDevice(pOEM, pSV->StdVar[0].lStdVariable)
        * pIFI->fwdWinDescender;
    dwTemp /= pIFI->fwdUnitsPerEm;
    pOEM->iDevCharOffset = (short)dwTemp;
#endif

    VERBOSE(("Descender=%d\n", pOEM->iDevCharOffset));

    wlen = (WORD)wsprintf(Cmd, SET_CHAR_OFFSET,
        (pOEM->fGeneral & FG_DBCS)?pOEM->iDevCharOffset:0);

    if (pOEM->fGeneral & FG_VERT)
    {
        wlen += (WORD)wsprintf(&Cmd[wlen], VERT_FONT_SET, 1);
    }
    WRITESPOOLBUF(pdevobj, Cmd, wlen);

    // DL font will be unselectd
    pOEM->dwDLFontID = UNKNOWN_DLFONT_ID;
}

LONG
LGetPointSize100(
    LONG height,
    LONG vertRes)
{
    LONG tmp = ((LONG)height * (LONG)7200) / (LONG)vertRes;

    //
    // round to the nearest quarter point.
    //
    return 25 * ((tmp + 12) / (LONG)25);
}

LONG
LConvertFontSizeToStr(
    LONG  size,
    PSTR  pStr)
{
    register long count;

        count = (long)strlen(_ltoa(size / 100, pStr, 10));
        pStr[count++] = '.';
        count += (long)strlen(_ltoa(size % 100, &pStr[count], 10));

    return count;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMOutputCharStr
//////////////////////////////////////////////////////////////////////////

VOID APIENTRY
OEMOutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph)
{
    GETINFO_GLYPHSTRING GStr;
    PTRANSDATA pTrans;
    PTRANSDATA pTransOrg;
    WORD   id;
    DWORD  dwI;
    DWORD  dwNeeded;
    PMYPDEV pOEM;
    PIFIMETRICS pIFI;

    WORD wLen;
    BYTE *pTemp;
    BOOL bRet;

    pIFI = pUFObj->pIFIMetrics;
    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);
    pTrans = NULL;
    pTransOrg = NULL;

    VERBOSE(("OEMOutputCharStr() entry.\n"));

#if 0   /* OEM doesn't want to fix minidriver */
    /* Below is hack code to fix #412276 */
    if ( pOEM->iColorMayChange == 1 )
    {
        /* Output Color Select Command */
        /* The logic supposes COLOR_SELECT_xxx starts with COLOR_SELECT_BLACK */
        /* and increases one by one                                           */
        WRITESPOOLBUF(pdevobj, (LPSTR)COLOR_SELECT_COMMAND[pOEM->dwSelectedColor - COLOR_SELECT_BLACK],
                       COLOR_SELECT_COMMAND_LEN[pOEM->dwSelectedColor - COLOR_SELECT_BLACK] );

        /* Reset flag, for ensuring color */
        pOEM->iColorMayChange = 0;
    }
    /* End of hack code */
#endif  /* OEM doesn't want to fix minidriver */

    switch (dwType)
    {
    case TYPE_GLYPHHANDLE:

        GStr.dwSize    = sizeof (GETINFO_GLYPHSTRING);
        GStr.dwCount   = dwCount;
        GStr.dwTypeIn  = TYPE_GLYPHHANDLE;
        GStr.pGlyphIn  = pGlyph;
        GStr.dwTypeOut = TYPE_TRANSDATA;
        GStr.pGlyphOut = NULL;
        GStr.dwGlyphOutSize = 0;

        if ((FALSE != (bRet = pUFObj->pfnGetInfo(pUFObj,
                UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL)))
            || 0 == GStr.dwGlyphOutSize)
        {
            ERR(("UFO_GETINFO_GRYPHSTRING faild - %d, %d.\n",
                bRet, GStr.dwGlyphOutSize));
            return;
        }

        pTrans = (TRANSDATA *)MemAlloc(GStr.dwGlyphOutSize);
        if (NULL == pTrans)
        {
            ERR(("MemAlloc faild.\n"));
            return;
        }
        pTransOrg = pTrans;
        GStr.pGlyphOut = pTrans;

        // convert glyph string to TRANSDATA
        if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHSTRING, &GStr, 0, NULL))
        {
            ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHSTRING failed.\r\n"));
            return;
        }

        for (dwI = 0; dwI < dwCount; dwI ++, pTrans++)
        {
            VERBOSE(("TYPE_TRANSDATA:ubCodePageID:0x%x\n",
                pTrans->ubCodePageID));
            VERBOSE(("TYPE_TRANSDATA:ubType:0x%x\n",
                pTrans->ubType));

            switch (pTrans->ubType & MTYPE_DOUBLEBYTECHAR_MASK)
            {
            case MTYPE_SINGLE: 
                if(pOEM->fGeneral & FG_DOUBLE){
                    OEMCommandCallback(pdevobj, TEXT_FS_SINGLE_BYTE, 0, NULL );
                }
                break;
            case MTYPE_DOUBLE:
                if(!(pOEM->fGeneral & FG_DOUBLE)){
                    OEMCommandCallback(pdevobj, TEXT_FS_DOUBLE_BYTE, 0, NULL );
                }
                break;
            }

            switch (pTrans->ubType & MTYPE_FORMAT_MASK)
            {
            case MTYPE_DIRECT: 
                VERBOSE(("TYPE_TRANSDATA:ubCode:0x%x\n",
                    pTrans->uCode.ubCode));

                pTemp = (BYTE *)&pTrans->uCode.ubCode;
                wLen = 1;
                break;

            case MTYPE_PAIRED: 
                VERBOSE(("TYPE_TRANSDATA:ubPairs:0x%x\n",
                    *(PWORD)(pTrans->uCode.ubPairs)));

                pTemp = (BYTE *)&(pTrans->uCode.ubPairs);
                wLen = 2;
                break;

            case MTYPE_COMPOSE:
                // ntbug9#398026: garbage print out when chars are high ansi.
                pTemp = (BYTE *)(pTransOrg) + pTrans->uCode.sCode;

                // first two bytes are the length of the string
                wLen = *pTemp + (*(pTemp + 1) << 8);
                pTemp += 2;
                break;

            default:
                WARNING(("Unsupported MTYPE %d ignored\n",
                    (pTrans->ubType & MTYPE_FORMAT_MASK)));
                wLen = 0; // 392057: PREFIX
            }

            if (wLen > 0)
            {
                WRITESPOOLBUF(pdevobj, pTemp, wLen);
            }
        }
        break;

    case TYPE_GLYPHID:

        DL_VERBOSE(("CharStr: dwDLFontID=%x, dwDLSelectFontID=%x\n",
            pOEM->dwDLFontID, pOEM->dwDLSelectFontID));

        // Make sure correct soft font is chosen
        if (pOEM->dwDLFontID != pOEM->dwDLSelectFontID)
            VSetSelectDLFont(pdevobj, pOEM->dwDLSelectFontID);

        for (dwI = 0; dwI < dwCount; dwI ++, ((PDWORD)pGlyph)++)
        {

            DL_VERBOSE(("Glyph: %x\n", (*(PDWORD)pGlyph)));

            VERBOSE(("TYPE_GLYPHID:0x%x\n", *(PDWORD)pGlyph));

// CASIO 98/11/24 ->
//            if( pIFI->jWinCharSet == SHIFTJIS_CHARSET ){
//                id = SWAPW( *(PDWORD)pGlyph + SJISCHR);
//                WRITESPOOLBUF(pdevobj, &id, 2);
//            }else{
                WRITESPOOLBUF(pdevobj, (PBYTE)pGlyph, 1);
//            }
// CASIO 98/11/24 <-
        }
        break;
    }

    if (NULL != pTransOrg)
    {
        MemFree(pTransOrg);
    }
}

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMDownloadFontHeader
//////////////////////////////////////////////////////////////////////////

DWORD APIENTRY
OEMDownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj
    )
{

    PGETINFO_STDVAR pSV;
    DWORD adwStdVariable[2+4*2];
    PMYPDEV pOEM;
    PIFIMETRICS pIFI;
    ESCPAGEHEADER FontHeader;
    BYTE sFontName[54];
    BYTE Buff[32];
    int iSizeOfBuf,iSizeFontName;
    WORD id;
    DWORD dwNeeded;

    INT iCellLeftOffset, iTemp;
    WORD wCellHeight, wCellWidth;
    WORD wFontPitch;

    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);
    pIFI = pUFObj->pIFIMetrics;

    VERBOSE(("OEMDownloadFontHeader() entry.\n"));

    VERBOSE(("TT Font:\n"));
    VERBOSE(("flInfo=%08x\n", pIFI->flInfo));
    VERBOSE(("fwdMaxCharInc=%d\n", pIFI->fwdMaxCharInc));
    VERBOSE(("fwdAveCharWidth=%d\n", pIFI->fwdAveCharWidth));
    VERBOSE(("jWinCharSet=%d\n", pIFI->jWinCharSet));
    VERBOSE(("rclFontBox=%d,%d,%d,%d\n",
        pIFI->rclFontBox.left, pIFI->rclFontBox.top,
        pIFI->rclFontBox.right, pIFI->rclFontBox.bottom));

//    if(pIFI->jWinPitchAndFamily & 0x01)
    if(pIFI->flInfo & FM_INFO_CONSTANT_WIDTH)
        pOEM->fGeneral &= ~FG_PROP;
    else
        pOEM->fGeneral |= FG_PROP;

//    id = (WORD)pUFObj->ulFontID;
    id = (WORD)pOEM->dwDLSetFontID;

    if(id > FONT_MAX_ID) return 0;
    if(pOEM->iResolution) return 0;

    //
    // Get standard variables.
    //
    pSV = (PGETINFO_STDVAR)adwStdVariable;
    pSV->dwSize = sizeof(GETINFO_STDVAR) + 2 * sizeof(DWORD) * (4 - 1);
    pSV->dwNumOfVariable = 4;
    pSV->StdVar[0].dwStdVarID = FNT_INFO_FONTHEIGHT;
    pSV->StdVar[1].dwStdVarID = FNT_INFO_FONTWIDTH;
    pSV->StdVar[2].dwStdVarID = FNT_INFO_TEXTYRES;
    pSV->StdVar[3].dwStdVarID = FNT_INFO_TEXTXRES;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_STDVARIABLE,
            pSV, pSV->dwSize, &dwNeeded)) {
        ERR(("UFO_GETINFO_STDVARIABLE failed.\n"));
        return 0;
    }
    VERBOSE(("FONTHEIGHT=%d\n", pSV->StdVar[0].lStdVariable));
    VERBOSE(("FONTWIDTH=%d\n", pSV->StdVar[1].lStdVariable));
    VERBOSE(("TEXTXRES=%d\n", pSV->StdVar[2].lStdVariable));
    VERBOSE(("TEXTYRES=%d\n", pSV->StdVar[3].lStdVariable));

    wCellHeight = (WORD)pSV->StdVar[0].lStdVariable;
    wCellWidth = (WORD)pSV->StdVar[1].lStdVariable;

// CASIO 98/11/20 ->
     if( MasterToDevice(pOEM,wCellHeight) > 64 ) return 0;
// CASIO 98/11/20 <-

    //
    // rclFontBox.left may not be 0
    //

    iTemp = max(pIFI->rclFontBox.right -
        pIFI->rclFontBox.left + 1,
        pIFI->fwdAveCharWidth);

    iCellLeftOffset = (-pIFI->rclFontBox.left)
        * wCellWidth / iTemp;
    wFontPitch = pIFI->fwdAveCharWidth
        * wCellWidth / iTemp;

    FontHeader.wFormatType     = SWAPW(0x0002);
    FontHeader.wDataSize       = SWAPW(0x0086);
// CASIO 98/11/24 ->
//    if( pIFI->jWinCharSet == SHIFTJIS_CHARSET ){
//        FontHeader.wSymbolSet  = SWAPW(id-FONT_MIN_ID+0x4000+0x8000); //id-FONT_MIN_ID + 4000h + 8000h
//        FontHeader.wLast       = (WORD)SWAPW (0x23ff);
//        FontHeader.wFirst      = (WORD)SWAPW (0x2020);
//    }else{
        FontHeader.wSymbolSet  = SWAPW(id-FONT_MIN_ID+0x4000); //id-FONT_MIN_ID + 4000h
        FontHeader.wLast       = SWAPW (0xff);
        FontHeader.wFirst      = SWAPW (0x20);
//    }
// CASIO 98/11/24 <-

    if (pOEM->fGeneral & FG_PROP)
    {
        FontHeader.wCharSpace         = SWAPW(1);
        FontHeader.CharWidth.Integer = (WORD)SWAPW(0x0100);
        FontHeader.CharWidth.Fraction = 0;
    }
    else
    {
        FontHeader.wCharSpace         = 0;
        FontHeader.CharWidth.Integer
            = SWAPW(MasterToDevice(pOEM, wCellWidth));
        FontHeader.CharWidth.Fraction = 0;      
    }
    FontHeader.CharHeight.Integer
            = SWAPW(MasterToDevice(pOEM, wCellHeight));
    FontHeader.CharHeight.Fraction = 0;
    // in the range 128 - 255
    FontHeader.wFontID = SWAPW( id - FONT_MIN_ID + ( id < 0x80 ? 0x80 : 0x00));
    FontHeader.wWeight         = 0;
    FontHeader.wEscapement     = 0;
    FontHeader.wItalic         = 0;
    FontHeader.wUnderline      = 0;
    FontHeader.wUnderlineWidth = SWAPW(10);
    FontHeader.wOverline       = 0;
    FontHeader.wOverlineWidth  = 0;
    FontHeader.wStrikeOut      = 0;
    FontHeader.wStrikeOutWidth = 0;
    FontHeader.wCellWidth
        = SWAPW(MasterToDevice(pOEM, wCellWidth));
    FontHeader.wCellHeight
        = SWAPW(MasterToDevice(pOEM, wCellHeight));
    FontHeader.wCellLeftOffset = SWAPW(iCellLeftOffset);
    FontHeader.wCellAscender
        = SWAPW((pIFI->fwdWinAscender
        * MasterToDevice(pOEM, wCellHeight)));
    FontHeader.FixPitchWidth.Integer
        = SWAPW(MasterToDevice(pOEM, wFontPitch));
    FontHeader.FixPitchWidth.Fraction = 0;

    iSizeFontName = wsprintf(sFontName,
       "________________________EPSON_ESC_PAGE_DOWNLOAD_FONT%02d",id-FONT_MIN_ID);
    iSizeOfBuf = wsprintf(Buff,SET_FONT_ID,FONT_HEADER_SIZE,id-FONT_MIN_ID);
    WRITESPOOLBUF(pdevobj, Buff, iSizeOfBuf);
    WRITESPOOLBUF(pdevobj, (LPSTR)&FontHeader,sizeof(ESCPAGEHEADER));
    WRITESPOOLBUF(pdevobj, sFontName,iSizeFontName);
    WRITESPOOLBUF(pdevobj, "EPC_PAGE_DOWNLOAD_FONT_INDEX", SIZE_SYMBOLSET);

//    iSizeOfBuf = wsprintf(Buff,DLI_SELECT_FONT_ID,id-FONT_MIN_ID,0);
//    WRITESPOOLBUF(pdevobj, Buff, iSizeOfBuf);
//
    DL_VERBOSE(("DLFontHeader: ulFontID=%x, dwDLSetFontID=%x\n",
        pUFObj->ulFontID, pOEM->dwDLSetFontID));

    VERBOSE(("FontHeader:\n"));
    VERBOSE(("wFormatType=%d\n", SWAPW(FontHeader.wFormatType)));
    VERBOSE(("wDataSize=%d\n", SWAPW(FontHeader.wDataSize)));
    VERBOSE(("wSymbolSet=%d\n", SWAPW(FontHeader.wSymbolSet)));
    VERBOSE(("wCharSpace=%d\n", SWAPW(FontHeader.wCharSpace)));
    VERBOSE(("CharWidth=%d.%d\n",
        SWAPW(FontHeader.CharWidth.Integer),
        FontHeader.CharWidth.Fraction));
    VERBOSE(("CharHeight=%d.%d\n",
        SWAPW(FontHeader.CharHeight.Integer),
        FontHeader.CharHeight.Fraction));
    VERBOSE(("wFontID=%d\n", SWAPW(FontHeader.wFontID)));
    VERBOSE(("wWeight=%d\n", SWAPW(FontHeader.wWeight)));
    VERBOSE(("wEscapement=%d\n", SWAPW(FontHeader.wEscapement)));
    VERBOSE(("wItalic=%d\n", SWAPW(FontHeader.wItalic)));
    VERBOSE(("wLast=%d\n", SWAPW(FontHeader.wLast)));
    VERBOSE(("wFirst=%d\n", SWAPW(FontHeader.wFirst)));
    VERBOSE(("wUnderline=%d\n", SWAPW(FontHeader.wUnderline)));
    VERBOSE(("wUnderlineWidth=%d\n", SWAPW(FontHeader.wUnderlineWidth)));
    VERBOSE(("wOverline=%d\n", SWAPW(FontHeader.wOverline)));
    VERBOSE(("wOverlineWidth=%d\n", SWAPW(FontHeader.wOverlineWidth)));
    VERBOSE(("wStrikeOut=%d\n", SWAPW(FontHeader.wStrikeOut)));
    VERBOSE(("wStrikeOutWidth=%d\n", SWAPW(FontHeader.wStrikeOutWidth)));
    VERBOSE(("wCellWidth=%d\n", SWAPW(FontHeader.wCellWidth)));
    VERBOSE(("wCellHeight=%d\n", SWAPW(FontHeader.wCellHeight)));
    VERBOSE(("wCellLeftOffset=%d\n", SWAPW(FontHeader.wCellLeftOffset)));
    VERBOSE(("wCellAscender=%d\n", SWAPW(FontHeader.wCellAscender)));
    VERBOSE(("FixPitchWidth=%d.%d\n",
        SWAPW(FontHeader.FixPitchWidth.Integer),
        FontHeader.FixPitchWidth.Fraction));
    VERBOSE(("FontName=%s\n", sFontName));

    return FONT_HEADER_SIZE;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMDownloadCharGlyph
//////////////////////////////////////////////////////////////////////////

DWORD APIENTRY
OEMDownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth
    )
{
    GETINFO_GLYPHBITMAP GBmp;
    GLYPHDATA *pGdata;
    GLYPHBITS *pbit;
    DWORD  dwNeeded;
    WORD cp;
    ESCPAGECHAR ESCPageChar;
    WORD wWidth, Width, Hight;
    LPDIBITS lpSrc;
    BYTE mask;
    int iSizeOfBuf, i;
    DWORD dwSize, dwCellSize, dwAirSize;
    BYTE Buff[32];
    PMYPDEV pOEM;
    PIFIMETRICS pIFI;

    pIFI = pUFObj->pIFIMetrics;
    pOEM = (PMYPDEV)MINIPDEV_DATA(pdevobj);
    VERBOSE(("OEMDownloadCharGlyph() entry.\n"));

    cp = (WORD)pOEM->wCharCode;

    GBmp.dwSize    = sizeof (GETINFO_GLYPHBITMAP);
    GBmp.hGlyph    = hGlyph;
    GBmp.pGlyphData = NULL;
    if (!pUFObj->pfnGetInfo(pUFObj, UFO_GETINFO_GLYPHBITMAP, &GBmp, GBmp.dwSize, &dwNeeded))
    {
        ERR(("UNIFONTOBJ_GetInfo:UFO_GETINFO_GLYPHBITMAP failed.\n"));
        return 0;
    }

    pGdata = GBmp.pGlyphData;
    pbit = pGdata->gdf.pgb;

    DL_VERBOSE(("DLCharGlyph: dwDLFont=%x, dwDLSetFont=%x, wCharCode=%x\n",
        pOEM->dwDLFontID, pOEM->dwDLSetFontID, pOEM->wCharCode));

    // Set font id if not already
    if (pOEM->dwDLFontID != pOEM->dwDLSetFontID)
        VSetSelectDLFont(pdevobj, pOEM->dwDLSetFontID);

    // fill in the charcter header information.
    ESCPageChar.bFormat       = 0x01;
    ESCPageChar.bDataDir      = 0x10;
// CASIO 98/11/24 ->
//    if( pIFI->jWinCharSet == SHIFTJIS_CHARSET ){
//        cp += SJISCHR;
//        ESCPageChar.wCharCode     = SWAPW(cp);
//    }else{
        ESCPageChar.wCharCode     = LOBYTE(cp);
//    }
// CASIO 98/11/24 <-

    ESCPageChar.wBitmapWidth       = SWAPW(pbit->sizlBitmap.cx);
    ESCPageChar.wBitmapHeight      = SWAPW(pbit->sizlBitmap.cy);

// MSKK 98/04/06 ->
//    ESCPageChar.wLeftOffset        = SWAPW(pbit->ptlOrigin.x);
//    ESCPageChar.wAscent            = SWAPW(pbit->ptlOrigin.y * -1);
    ESCPageChar.wLeftOffset = (pbit->ptlOrigin.x > 0 ? 
                                                SWAPW(pbit->ptlOrigin.x) : 0);
    ESCPageChar.wAscent     = (pbit->ptlOrigin.y < 0 ?
                                            SWAPW(pbit->ptlOrigin.y * -1) : 0);
// MSKK 98/04/06 <-

    ESCPageChar.CharWidth.Integer  = SWAPW(pGdata->fxD / 16);
    ESCPageChar.CharWidth.Fraction = 0;
    *pdwWidth = ESCPageChar.CharWidth.Integer;

    Width = LOWORD(pbit->sizlBitmap.cx);
    wWidth = (LOWORD(pbit->sizlBitmap.cx) + 7) >> 3;
    Hight = LOWORD(pbit->sizlBitmap.cy);

    // not multiple of 8, need to mask out unused last byte
    // This is done so that we do not advance beyond segment bound
    // which can happen if lpBitmap is just under 64K and adding
    // width to it will cause invalid segment register to be loaded.
    if (mask = bit_mask[LOWORD(Width) & 0x7])
    {
        lpSrc = pbit->aj + wWidth - 1;
        i = LOWORD(Hight);
        while (TRUE)
        {
            (*lpSrc) &= mask;
            i--;
            if (i > 0)
                lpSrc += wWidth;
            else
                break;
        }
    }

    dwCellSize = (DWORD)pbit->sizlBitmap.cy * wWidth;
    dwSize = (DWORD)(LOWORD(Hight)) * wWidth;

// CASIO 98/11/24 ->
//    if( pIFI->jWinCharSet == SHIFTJIS_CHARSET ){
//        iSizeOfBuf = wsprintf(Buff,SET_DOUBLE_BMP,dwCellSize + sizeof(ESCPAGECHAR),HIBYTE(cp),LOBYTE(cp));
//    }else{
        iSizeOfBuf = wsprintf(Buff,SET_SINGLE_BMP,dwCellSize + sizeof(ESCPAGECHAR),LOBYTE(cp));
//    }
// CASIO 98/11/24 <-
    WRITESPOOLBUF(pdevobj, Buff, iSizeOfBuf);

    WRITESPOOLBUF(pdevobj, (LPSTR)&ESCPageChar, sizeof(ESCPAGECHAR));

    for (lpSrc = pbit->aj; dwSize; lpSrc += wWidth)
    {
        if ( dwSize > 0x4000 )
            wWidth = 0x4000;
        else
            wWidth = LOWORD(dwSize);

        dwSize -= wWidth;

        WRITESPOOLBUF(pdevobj, (LPSTR)lpSrc, (WORD)wWidth);
    }

    VERBOSE(("ESCPageChar:\n"));
    VERBOSE(("bFormat=%d\n", ESCPageChar.bFormat));
    VERBOSE(("bDataDir=%d\n", ESCPageChar.bDataDir));
    VERBOSE(("wCharCode=%d\n", SWAPW(ESCPageChar.wCharCode)));
    VERBOSE(("wBitmapWidth=%d\n", SWAPW(ESCPageChar.wBitmapWidth)));
    VERBOSE(("wBitmapHeight=%d\n", SWAPW(ESCPageChar.wBitmapHeight)));
    VERBOSE(("wLeftOffset=%d\n", SWAPW(ESCPageChar.wLeftOffset)));
    VERBOSE(("wAscent=%d\n", SWAPW(ESCPageChar.wAscent)));
    VERBOSE(("CharWidth=%d.%d\n", SWAPW(ESCPageChar.CharWidth.Integer),
        ESCPageChar.CharWidth.Fraction));

    return sizeof(ESCPAGECHAR) + dwCellSize;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   OEMTTDownloadMethod
//////////////////////////////////////////////////////////////////////////
DWORD APIENTRY
OEMTTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj
    )
{
    DWORD dwRet;

    // Default is to download.
    dwRet = TTDOWNLOAD_BITMAP;

    VERBOSE(("TTDLMethod: dwRet=%d\n", dwRet));

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\casn4res\sources.inc ===
!ifndef PRNROOT
PRNROOT=$(PROJECT_ROOT)\print\drivers\usermode
!endif

!include $(PRNROOT)\print.inc

ALT_PROJECT=JPN
ALT_PROJECT_TARGET=$(ALT_PROJECT)

GPDDIR=$(PRNROOT)\gpd\casio\$(ALT_PROJECT)
SRCDIR=..

TARGETNAME=casn4res
TARGETPATH=obj
TARGETTYPE=DYNLINK

!IF 0
DLLBASE=@$(COFFBASE_TXT_FILE),casn4res
!ELSE
DLLBASE=0x8000000
!ENDIF

INCLUDES=$(PRNROOT)\inc

RCCODEPAGE=932

UMTYPE=windows

SOURCES=\
    $(SRCDIR)\casn4res.rc \
    $(SRCDIR)\casn4res.c \
    $(SRCDIR)\common.c

MISCFILES=\
    $(SRCDIR)\casn4res.ini \
    $(SRCDIR)\icm\csn4001.icm \
    $(SRCDIR)\icm\csn4002.icm \
    $(SRCDIR)\icm\csn4003.icm \
    $(GPDDIR)\cscp710j.gpd \
    $(GPDDIR)\cscp720j.gpd \
    $(GPDDIR)\cscp725j.gpd \
    $(GPDDIR)\cscp730j.gpd \
    $(GPDDIR)\cscp740j.gpd \
    $(GPDDIR)\cscp750j.gpd \
    $(GPDDIR)\csn4j.gpd \
    $(GPDDIR)\cscpe80j.gpd \
    $(GPDDIR)\cscpb10j.gpd
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\casn4res\pdev.h ===
#ifndef _PDEV_H
#define _PDEV_H

//
// Files necessary for OEM plug-in.
//

#include <minidrv.h>
#include <stdio.h>
#include <prcomoem.h>

//
// Misc definitions follows.
//

#define DOWNLOADFONT 1
//#define DOWNLOADFONT 0

#define WRITESPOOLBUF(p, s, n) \
    ((p)->pDrvProcs->DrvWriteSpoolBuf(p, s, n))

#define MINIPDEV_DATA(p) ((p)->pdevOEM)

#define MASTER_UNIT 1200

////////////////////////////////////////////////////////
//      OEM UD Defines
////////////////////////////////////////////////////////

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

//
// ASSERT_VALID_PDEVOBJ can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
//

#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
#define ERRORTEXT(s)    "ERROR " s

////////////////////////////////////////////////////////
//      OEM UD Prototypes
////////////////////////////////////////////////////////
//VOID DbgPrint(IN LPCTSTR pstrFormat,  ...);

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'CSN4'      // EPSON ESC/Page printers
#define OEM_VERSION      0x00010000L


////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER dmExtraHdr;
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

typedef struct {
    DWORD fGeneral;
    int  iEscapement;
    short iDevCharOffset;
    BYTE iPaperSource;
    BYTE iDuplex;
    BYTE iTonerSave;
    BYTE iOrientation;
    BYTE iResolution; 
    BYTE iColor;
    BYTE iSmoothing;
    BYTE iJamRecovery;
    BYTE iMediaType;
    BYTE iOutBin;             //+CP-E8000

#define UNKNOWN_DLFONT_ID (~0)

    DWORD dwDLFontID;         // device's current font ID
    DWORD dwDLSelectFontID;   // "SelectFont" font ID 
    DWORD dwDLSetFontID;      // "SetFont" font ID
    WORD wCharCode;

    BYTE iUnitFactor; // master vs device scale factor
    WORD wRectWidth, wRectHeight;

#if 0   /* OEM doesn't want to fix minidriver */
    /* Below is hack code to fix #412276 */
    DWORD dwSelectedColor;     // Latest selected color descirbe as COLOR_SELECT_xxx
    BYTE iColorMayChange;    // 1 means called block data callback that may change color
    /* End of hack code */
#endif  /* OEM doesn't want to fix minidriver */

} MYPDEV, *PMYPDEV;

// Flags for fGeneral
#define FG_DBCS     0x00000001
#define FG_VERT     0x00000002
#define FG_PROP     0x00000004
#define FG_DOUBLE   0x00000008
#define FG_NULL_PEN 0x00000010
#define FG_BOLD     0x00000020
#define FG_ITALIC   0x00000040

extern BOOL BInitOEMExtraData(POEMUD_EXTRADATA pOEMExtra);
extern BMergeOEMExtraData(POEMUD_EXTRADATA pdmIn, POEMUD_EXTRADATA pdmOut);

#endif  // _PDEV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\casn4res\comoem.cpp ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

     comoem.cpp

     Abstract:

        Necessary COM class definition to Unidrv
        OEM rendering module plug-in.

Environment:

        Windows NT Unidrv driver

Revision History:

        98/4/24 takashim:
        Written the original sample so that it is more C++.

--*/

#define INITGUID // for GUID one-time initialization

#include "pdev.h"
#include "names.h"

// Globals
static HMODULE g_hModule = NULL ;   // DLL module handle
static long g_cComponents = 0 ;     // Count of active components
static long g_cServerLocks = 0 ;    // Count of locks

//
// IOemCB Definition
//

class IOemCB : public IPrintOemUni
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(
        const IID& iid, void** ppv)
    {    
        VERBOSE(("IOemCB: QueryInterface entry\n"));
        if (iid == IID_IUnknown)
        {
            *ppv = static_cast<IUnknown*>(this); 
            VERBOSE(("IOemCB:Return pointer to IUnknown.\n")); 
        }
        else if (iid == IID_IPrintOemUni)
        {
            *ppv = static_cast<IPrintOemUni*>(this);
            VERBOSE(("IOemCB:Return pointer to IPrintOemUni.\n")); 
            }
            else
            {
                *ppv = NULL ;
            VERBOSE(("IOemCB:Return NULL.\n")); 
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        VERBOSE(("IOemCB::AddRef() entry.\n"));
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        VERBOSE(("IOemCB::Release() entry.\n"));
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IPrintOemCommon methods
    //

    // Function Name: GetInfo
    // Plug-in: Any
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    GetInfo(
        DWORD dwMode,
        PVOID pBuffer,
        DWORD cbSize,
        PDWORD pcbNeeded)
    {
        VERBOSE(("IOemCB::GetInfo() entry.\n"));

        if (OEMGetInfo(dwMode, pBuffer, cbSize, pcbNeeded))
            return S_OK;
        else
            return E_FAIL;
    }

    //
    // Function Name: DevMode
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DevMode(
        DWORD       dwMode,
        POEMDMPARAM pOemDMParam) 
    {
        VERBOSE(("IOemCB::DevMode() entry.\n"));

        if (OEMDevMode(dwMode, pOemDMParam)) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
    }

    //
    // IPrintOemEngine methods
    //

    //
    // Function Name: EnableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnableDriver(
        DWORD dwDriverVersion,
        DWORD cbSize,
        PDRVENABLEDATA pded)
    {
        VERBOSE(("IOemCB::EnableDriver() entry.\n"));
// Sep.17.98 ->
        // Need to return S_OK so that DisableDriver() will be called, which Releases
        // the reference to the Printer Driver's interface.
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: DisableDriver
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisableDriver(VOID)
    {
        VERBOSE(("IOemCB::DisaleDriver() entry.\n"));
// Sep.17.98 ->
        // Release reference to Printer Driver's interface.
        if (this->pOEMHelp)
        {
            this->pOEMHelp->Release();
            this->pOEMHelp = NULL;
        }
        return S_OK;
// Sep.17.98 <-
    }

    //
    // Function Name: EnablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    EnablePDEV(
        PDEVOBJ         pdevobj,
        PWSTR           pPrinterName,
        ULONG           cPatterns,
        HSURF          *phsurfPatterns,
        ULONG           cjGdiInfo,
        GDIINFO        *pGdiInfo,
        ULONG           cjDevInfo,
        DEVINFO        *pDevInfo,
        DRVENABLEDATA  *pded,
        OUT PDEVOEM    *pDevOem)
    {
        VERBOSE(("IOemCB::EnablePDEV() entry.\n"));

        *pDevOem = OEMEnablePDEV(pdevobj, pPrinterName,
            cPatterns, phsurfPatterns, cjGdiInfo, pGdiInfo,
            cjDevInfo, pDevInfo, pded);

        if (*pDevOem)
            return S_OK;
        else
            return S_FALSE;
    }

    //
    // Function Name: DisablePDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    DisablePDEV(
        PDEVOBJ pdevobj)
    {
        LONG lI;

        VERBOSE(("IOemCB::DisablePDEV() entry.\n"));

        OEMDisablePDEV(pdevobj);

        return S_OK;
    }

    //
    // Function Name: ResetPDEV
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Optional
    //

    STDMETHODIMP
    ResetPDEV(
        PDEVOBJ pdevobjOld,
        PDEVOBJ pdevobjNew)
    {
//      VERBOSE(("IOemCB::ResetPDEV() entry.\n"));
//      return E_NOTIMPL;
        if (OEMResetPDEV(pdevobjOld, pdevobjNew))
            return S_OK;
        else
            return S_FALSE;
    }

    //
    // IPrintOemUni methods
    //

    //
    // Function Name: PublishDriverInterface
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    STDMETHODIMP
    PublishDriverInterface(
        IUnknown *pIUnknown)
    {
        VERBOSE(("IOemCB::PublishDriverInterface() entry.\n"));
// Sep.8.98 ->
        // Need to store pointer to Driver Helper functions, if we already haven't.
        if (this->pOEMHelp == NULL)
        {
            HRESULT hResult;

            // Get Interface to Helper Functions.
            hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** )&(this->pOEMHelp));

            if(!SUCCEEDED(hResult))
            {
                // Make sure that interface pointer reflects interface query failure.
                this->pOEMHelp = NULL;

                return E_FAIL;
            }
        }
// Sep.8.98 <-
        return S_OK;
    }

    //
    // Function Name: GetImplementationMethod
    // Plug-in: Rendering module
    // Driver: Any
    // Type: Mandatory
    //

    //
    // Needed to be static so that it can be passed
    // to the bsearch() as a pointer to a functin.
    //

    static
    int __cdecl
    iCompNames(
        const void *p1,
        const void *p2) {

        return strcmp(
            *((char **)p1),
            *((char **)p2));
    }

    STDMETHODIMP
    GetImplementedMethod(
        PSTR pMethodName)
    {
        LONG lRet = E_NOTIMPL;
        PSTR pTemp;


        VERBOSE(("IOemCB::GetImplementedMethod() entry.\n"));

        if (NULL != pMethodName) {

            pTemp = (PSTR)bsearch(
                &pMethodName,
                gMethodsSupported,
                (sizeof (gMethodsSupported) / sizeof (PSTR)),
                sizeof (PSTR),
                iCompNames);

            if (NULL != pTemp)
                lRet = S_OK;
        }

        VERBOSE(("pMethodName = %s, lRet = %d\n", pMethodName, lRet));

        return lRet;
    }

    //
    // Function Name: CommandCallback
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    CommandCallback(
        PDEVOBJ pdevobj,
        DWORD dwCallbackID,
        DWORD dwCount,
        PDWORD pdwParams,
        OUT INT *piResult)
    {
        VERBOSE(("IOemCB::CommandCallback() entry.\n"));

        *piResult = OEMCommandCallback(pdevobj, dwCallbackID, dwCount, pdwParams);

        return S_OK;
    }

    //
    // Function Name: ImageProcessing
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    ImageProcessing(
        PDEVOBJ             pdevobj,  
        PBYTE               pSrcBitmap,
        PBITMAPINFOHEADER   pBitmapInfoHeader,
        PBYTE               pColorTable,
        DWORD               dwCallbackID,
        PIPPARAMS           pIPParams,
        OUT PBYTE           *ppbResult)
    {
        VERBOSE(("IOemCB::ImageProcessing() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Function Name: FilterGraphics
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    FilterGraphics(
        PDEVOBJ pdevobj,
        PBYTE pBuf,
        DWORD dwLen)
    {
        VERBOSE(("IOemCB::FilterGraphis() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Function Name: Compression
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    Compression(
        PDEVOBJ     pdevobj,
        PBYTE       pInBuf,
        PBYTE       pOutBuf,
        DWORD       dwInLen,
        DWORD       dwOutLen,
        OUT INT     *piResult)
    {
        VERBOSE(("IOemCB::Compression() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Function Name: HalftonePattern
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    HalftonePattern(
        PDEVOBJ     pdevobj,
        PBYTE       pHTPattern,
        DWORD       dwHTPatternX,
        DWORD       dwHTPatternY,
        DWORD       dwHTNumPatterns,
        DWORD       dwCallbackID,
        PBYTE       pResource,
        DWORD       dwResourceSize)
    {
        VERBOSE(("IOemCB::HalftonePattern() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Function Name: MemoryUsge
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    MemoryUsage(
        PDEVOBJ         pdevobj,   
        POEMMEMORYUSAGE pMemoryUsage)
    {
        VERBOSE(("IOemCB::MemoryUsage() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Function Name: DownloadFontHeader
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadFontHeader(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE(("IOemCB::DownloadFontHeader() entry.\n"));

#if DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadFontHeader(pdevobj, pUFObj))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
#else // DOWNLOADFONT
        return E_NOTIMPL;
#endif // DOWNLOADFONT

    }

    //
    // Function Name: DownloadCharGlyph
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DownloadCharGlyph(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        HGLYPH      hGlyph,
        PDWORD      pdwWidth,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE(("IOemCB::DownloadCharGlyph() entry.\n"));

#if DOWNLOADFONT
        if (0 < (*pdwResult = OEMDownloadCharGlyph(pdevobj, pUFObj,
                hGlyph, pdwWidth))) {
            return S_OK;
        }
        else {
            return E_FAIL;
        }
#else // DOWNLOADFONT
        return E_NOTIMPL;
#endif // DOWNLOADFONT

    }

    //
    // Function Name: TTDonwloadMethod
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTDownloadMethod(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        OUT DWORD   *pdwResult) 
    {
        VERBOSE(("IOemCB::TTDownloadMethod() entry.\n"));
#if DOWNLOADFONT
        *pdwResult = OEMTTDownloadMethod(pdevobj, pUFObj);
        return S_OK;
#else // DOWNLOADFONT
        return E_NOTIMPL;
#endif // DOWNLOADFONT
    }

    //
    // Function Name: OutputCharStr
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    OutputCharStr(
        PDEVOBJ     pdevobj,
        PUNIFONTOBJ pUFObj,
        DWORD       dwType,
        DWORD       dwCount,
        PVOID       pGlyph) 
    {
        VERBOSE(("IOemCB::OutputCharStr() entry.\n"));

        OEMOutputCharStr(pdevobj, pUFObj, dwType, dwCount, pGlyph);
        return S_OK;
    }

    //
    // Function Name: SendFontCmd
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    SendFontCmd(
        PDEVOBJ      pdevobj,
        PUNIFONTOBJ  pUFObj,
        PFINVOCATION pFInv) 
    {
        VERBOSE(("IOemCB::SendFontCmd() entry.\n"));

        OEMSendFontCmd(pdevobj, pUFObj, pFInv);
        return S_OK;
    }

    //
    // Function Name: DriverDMS
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    DriverDMS(
        PVOID   pDevObj,
        PVOID   pBuffer,
        DWORD   cbSize,
        PDWORD  pcbNeeded)
    {
        VERBOSE(("IOemCB::DriverDMS() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Function Name: TextOutputAsBitmap
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TextOutAsBitmap(
        SURFOBJ    *pso,
        STROBJ     *pstro,
        FONTOBJ    *pfo,
        CLIPOBJ    *pco,
        RECTL      *prclExtra,
        RECTL      *prclOpaque,
        BRUSHOBJ   *pboFore,
        BRUSHOBJ   *pboOpaque,
        POINTL     *pptlOrg,
        MIX         mix)
    {
        VERBOSE(("IOemCB::TextOutAsBitmap() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Function Name: TTYGetInfo
    // Plug-in: Rendering module
    // Driver: Unidrv
    // Type: Optional
    //

    STDMETHODIMP
    TTYGetInfo(
        PDEVOBJ     pdevobj,
        DWORD       dwInfoIndex,
        PVOID       pOutputBuf,
        DWORD       dwSize,
        DWORD       *pcbcNeeded)
    {
        VERBOSE(("IOemCB::TTYGetInfo() entry.\n"));
        return E_NOTIMPL;
    }

    //
    // Constructors
    //

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB() { };

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};

//
// Class factory definition
//

class IOemCF : public IClassFactory
{
public:
    //
    // IUnknown methods
    //

    STDMETHODIMP
    QueryInterface(const IID& iid, void** ppv)
    {
        if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
        {
            *ppv = static_cast<IOemCF*>(this);
        }
        else
        {
            *ppv = NULL ;
            return E_NOINTERFACE ;
        }
        reinterpret_cast<IUnknown*>(*ppv)->AddRef();
        return S_OK ;
    }

    STDMETHODIMP_(ULONG)
    AddRef()
    {
        return InterlockedIncrement(&m_cRef);
    }

    STDMETHODIMP_(ULONG)
    Release()
    {
        if (InterlockedDecrement(&m_cRef) == 0)
        {
            delete this ;
            return 0 ;
        }
        return m_cRef ;
    }

    //
    // IClassFactory methods
    //

    STDMETHODIMP
    CreateInstance(
        IUnknown *pUnknownOuter,
        const IID &iid,
        void **ppv)
    {
        //VERBOSE(("IOemCF::CreateInstance() called\n."));

        // Cannot aggregate.
        if (NULL != pUnknownOuter) {

            return CLASS_E_NOAGGREGATION;
        }

        // Create component.
        IOemCB* pOemCB = new IOemCB;
        if (NULL == pOemCB) {

            return E_OUTOFMEMORY;
        }

        // Get the requested interface.
        HRESULT hr = pOemCB->QueryInterface(iid, ppv);

        // Release the IUnknown pointer.
        // (If QueryInterface failed, component will delete itself.)
        pOemCB->Release();
        return hr ;
    }

    // LockServer
    STDMETHODIMP
    LockServer(BOOL bLock)
    {
        if (bLock)
        {
            InterlockedIncrement(&g_cServerLocks);
        }
        else
        {
            InterlockedDecrement(&g_cServerLocks);
        }
        return S_OK ;
    }

    //
    // Constructor
    //

    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;
};

//
// Export functions
//

//
// Get class factory
//

STDAPI
DllGetClassObject(
    const CLSID &clsid,
    const IID &iid,
    void **ppv)
{
    //VERBOSE(("DllGetClassObject:\tCreate class factory."));

    // Can we create this component?
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    // Create class factory.
    IOemCF* pFontCF = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pFontCF == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    // Get requested interface.
    HRESULT hr = pFontCF->QueryInterface(iid, ppv);
    pFontCF->Release();

    return hr ;
}

//
//
// Can DLL unload now?
//

STDAPI
DllCanUnloadNow()
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK;
    }
    else
    {
        return E_FAIL;
    }
}

#if 0
//
// Server registration
//
STDAPI DllRegisterServer()
{
    return RegisterServer(g_hModule,
                          CLSID_OEMRENDER,
                          g_szFriendlyName,
                          g_szVerIndProgID,
                          g_szProgID);
}


//
// Server unregistration
//
STDAPI DllUnregisterServer()
{
    return UnregisterServer(CLSID_OEMRENDER,
                            g_szVerIndProgID,
                            g_szProgID);
}

///////////////////////////////////////////////////////////
//
// DLL module information
//

BOOL APIENTRY DllMain(HANDLE hModule,
                      DWORD dwReason,
                      void* lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hModule = (HMODULE)hModule ;
    }
        g_hModule = (HMODULE)hModule ;
    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\citohres\common.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Implementation of OEMGetInfo and OEMDevMode.
    Shared by all Unidrv OEM test dll's.

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#include "pdev.h"       // defined in sub-directory such as DDICMDCB, FONTCB, etc.

BOOL APIENTRY OEMGetInfo(DWORD dwInfo, PVOID pBuffer, DWORD cbSize, PDWORD pcbNeeded)
{
    LPTSTR OEM_INFO[] = {   __TEXT("Bad Index"),
                            __TEXT("OEMGI_GETSIGNATURE"),
                            __TEXT("OEMGI_GETINTERFACEVERSION"),
                            __TEXT("OEMGI_GETVERSION"),
                        };

    OEMDBGP((DLLTEXT("OEMGetInfo(%s) entry.\r\n"), OEM_INFO[dwInfo]));

    // Validate parameters.
    if( ( (OEMGI_GETSIGNATURE != dwInfo) &&
          (OEMGI_GETINTERFACEVERSION != dwInfo) &&
          (OEMGI_GETVERSION != dwInfo) ) ||
        (NULL == pcbNeeded)
      )
    {
        OEMDBGP((ERRORTEXT("OEMGetInfo() ERROR_INVALID_PARAMETER.\r\n")));

        // Did not write any bytes.
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return FALSE;
    }

    // Need/wrote 4 bytes.
    *pcbNeeded = 4;

    // Validate buffer size.  Minimum size is four bytes.
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        OEMDBGP((ERRORTEXT("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\r\n")));

        return FALSE;
    }

    // Write information to buffer.
    switch(dwInfo)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return TRUE;
}

#ifndef USERMODE_DRIVER
//
// Functions for outputting debug messages
//

VOID DbgPrint(IN LPCTSTR pstrFormat,  ...)
{
    va_list ap;

    va_start(ap, pstrFormat);
    EngDebugPrint("", (PCHAR) pstrFormat, ap);
    va_end(ap);
}
#endif //USERMODE_DRIVER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\casn4res\names.h ===
//
// The name table used by IOemCB::GetImplementedMethod().
// Remove comments of names which are implemented in your
// IOemCB plug-ins.
//
// Note: The name table must be sorted.  When you are
// inserting a new entry in this table, please mae sure
// the sort order being not broken.
// 

CONST PSTR
gMethodsSupported[] = {
//     "Command",
    "CommandCallback",
//     "Compression",
//     "DeviceCapabilities",
    "DevMode",
//     "DevQueryPrintEx",
//     "DisableDriver",
    "DisablePDEV",
//     "DocumentPropertySheets",
    "DownloadCharGlyph",
    "DownloadFontHeader",
//     "DriverDMS",
//     "DriverEvent",
//     "DrvGetDriverSetting",
//     "DrvWriteSpoolBuf",
//     "EnableDriver",
    "EnablePDEV",
//     "FilterGraphics",
//     "FontInstallerDlgProc",
//     "GetDDIHooks",
//     "GetDriverSetting",
    "GetImplementedMethod",
    "GetInfo",
//     "HalftonePattern",
//     "ImageProcessing",
//     "MemoryUsage",
    "OutputCharStr",
//     "PrinterEvent",
//     "PropCommonUIProp",
    "PublishDriverInterface",
//     "QueryColorProfile",
//     "ResetPDEV",
    "SendFontCmd",
//     "SheetsDevicePropertySheets",
//     "TextOutAsBitmap",
    "TTDownloadMethod",
//     "TTYGetInfo",
//     "UpdateUISetting",
//     "UpgradePrinter",
//     "UpgradeRegistry",
//     "UpgradeRegistrySetting",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\citohres\code.c ===
/*++

Copyright (C) 1997 - 1999 Microsoft Corporation

--*/

//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

char *rgchModuleName = "CITOHRES";


#include "pdev.h"

static const BYTE  FlipTable[ 256 ] =
{

#include	"fliptab.h"

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\citohres\comoem.cpp ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    comoem.cpp

Abstract:

    Windows NT Universal Printer Driver OEM Plug-in Sample

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/


#include "pdev.h"
#include "name.h"
#include <initguid.h>
#include <prcomoem.h>
#include "comoem.h"
#include <assert.h>
#include "code.c"

///////////////////////////////////////////////////////////
//
// Globals
//

static HANDLE ghInstance = NULL ;
static long g_cComponents = 0 ;
static long g_cServerLocks = 0 ;

///////////////////////////////////////////////////////////
//
// Export functions
//

BOOL APIENTRY
DllMain(
    HANDLE hInst,
    DWORD dwReason,
    void* lpReserved)
/*++

Routine Description:

    Dll entry point for initializatoin.

Arguments:

    hInst      - Dll instance handle
    wReason    - The reason DllMain was called.
                 Initialization or termination, for a process or a thread.
    lpreserved - Reserved for the system's use

Return Value:

    TRUE if successful, FALSE if there is an error

Note:


--*/
{

    switch(dwReason)
    {
        case DLL_PROCESS_ATTACH:
            DebugMsg(DLLTEXT("DLLMain: Process attach.\r\n"));

            //
            // Save DLL instance for use later.
            //
            ghInstance = hInst;
            break;

        case DLL_THREAD_ATTACH:
            DebugMsg(DLLTEXT("DLLMain: Thread attach.\r\n"));
            break;

        case DLL_PROCESS_DETACH:
            DebugMsg(DLLTEXT("DLLMain: Process detach.\r\n"));
            break;

        case DLL_THREAD_DETACH:
            DebugMsg(DLLTEXT("DLLMain: Thread detach.\r\n"));
            break;
    }

    return TRUE;
}


STDAPI
DllCanUnloadNow()
/*++

Routine Description:

    Function to return the status that this dll can be unloaded.

Arguments:


Return Value:

    S_OK if it's ok to unload it, S_FALSE if it is used.

Note:


--*/
{
    if ((g_cComponents == 0) && (g_cServerLocks == 0))
    {
        return S_OK ;
    }
    else
    {
        return S_FALSE ;
    }
}

STDAPI
DllGetClassObject(
    const CLSID& clsid,
    const IID& iid,
    void** ppv)
/*++

Routine Description:

    Function to return class factory object

Arguments:

    clsid - CLSID for the class object
    iid   - Reference to the identifier of the interface that communic
    ppv   - Indirect pointer to the communicating interface

Note:

--*/
{
    DebugMsg(DLLTEXT("DllGetClassObject:\tCreate class factory.")) ;

    //
    // Can we create this component?
    //
    if (clsid != CLSID_OEMRENDER)
    {
        return CLASS_E_CLASSNOTAVAILABLE ;
    }

    //
    // Create class factory.
    //
    IOemCF* pClassFactory = new IOemCF ;  // Reference count set to 1
                                         // in constructor
    if (pClassFactory == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    //
    // Get requested interface.
    //
    HRESULT hr = pClassFactory->QueryInterface(iid, ppv) ;
    pClassFactory->Release() ;

    return hr ;
}


////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem CallBack (IPrintOemUNI) body
//

STDMETHODIMP
IOemCB::QueryInterface(
    const IID& iid,
    void** ppv)
/*++

Routine Description:

    IUnknow QueryInterface

Arguments:

    iid   - Reference to the identifier of the interface that communic
    ppv   - Indirect pointer to the communicating interface

Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB: QueryInterface entry\n"));

    if (iid == IID_IUnknown)
    {
        *ppv = static_cast<IUnknown*>(this);
        DebugMsg(DLLTEXT("IOemCB:Return pointer to IUnknown.\n")) ;
    }
    else if (iid == IID_IPrintOemUni)
    {
        *ppv = static_cast<IPrintOemUni*>(this) ;
        DebugMsg(DLLTEXT("IOemCB:Return pointer to IPrintOemUni.\n")) ;
    }
    else
    {
        *ppv = NULL ;
        DebugMsg(DLLTEXT("IOemCB:Return NULL.\n")) ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

STDMETHODIMP_(ULONG)
IOemCB::AddRef()
/*++

Routine Description:

    IUnknow AddRef interface

Arguments:

    Increment a reference count

Return Value:

    Reference count

Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::AddRef() entry.\r\n"));
    return InterlockedIncrement(&m_cRef) ;
}

STDMETHODIMP_(ULONG)
IOemCB::Release()
/*++

Routine Description:

    IUnknown Release interface

Arguments:

    Decrement a reference count

Return Value:

    Reference count

Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::Release() entry.\r\n"));
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

STDMETHODIMP
IOemCB::EnableDriver(
    DWORD          dwDriverVersion,
    DWORD          cbSize,
    PDRVENABLEDATA pded)
/*++

Routine Description:


Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::EnableDriver() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::DisableDriver(VOID)
/*++

Routine Description:

    IPrintOemUni DisableDriver interface
    Free all resources, and get prepared to be unloaded.

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::DisaleDriver() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::PublishDriverInterface(
    IUnknown *pIUnknown)
/*++

Routine Description:

    IPrintOemUni PublishDriverInterface interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::PublishDriverInterface() entry.\r\n"));

    // Need to store pointer to Driver Helper functions, if we already haven't.
    if (this->pOEMHelp == NULL)
    {
        HRESULT hResult;


        // Get Interface to Helper Functions.
        hResult = pIUnknown->QueryInterface(IID_IPrintOemDriverUni, (void** ) &(this->pOEMHelp));

        if(!SUCCEEDED(hResult))
        {
            // Make sure that interface pointer reflects interface query failure.
            this->pOEMHelp = NULL;

            return E_FAIL;
        }
    }

    return S_OK;
}

STDMETHODIMP
IOemCB::EnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded,
    OUT PDEVOEM    *pDevOem)
/*++

Routine Description:

    IPrintOemUni EnablePDEV interface
    Construct its own PDEV. At this time, the driver also passes a function
    table which contains its own implementation of DDI entrypoints

Arguments:

    pdevobj        - pointer to a DEVOBJ structure. pdevobj->pdevOEM is undefined.
    pPrinterName   - name of the current printer.
    Cpatterns      -
    phsurfPatterns -
    cjGdiInfo      - size of GDIINFO
    pGdiInfo       - a pointer to GDIINFO
    cjDevInfo      - size of DEVINFO
    pDevInfo       - These parameters are identical to what39s passed into DrvEnablePDEV.
    pded: points to a function table which contains the system driver39s
    implementation of DDI entrypoints.


Return Value:


--*/
{


    DebugMsg(DLLTEXT("IOemCB::EnablePDEV() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::ResetPDEV(
    PDEVOBJ pdevobjOld,
    PDEVOBJ pdevobjNew)
/*++

Routine Description:

    IPrintOemUni ResetPDEV interface
    OEMResetPDEV transfers the state of the driver from the old PDEVOBJ to the
    new PDEVOBJ when an application calls ResetDC.

Arguments:

pdevobjOld - pdevobj containing Old PDEV
pdevobjNew - pdevobj containing New PDEV

Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::ResetPDEV entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::DisablePDEV(
    PDEVOBJ         pdevobj)
/*++

Routine Description:

    IPrintOemUni DisablePDEV interface
    Free resources allocated for the PDEV.

Arguments:

    pdevobj -

Return Value:


Note:


--*/
{

    DebugMsg(DLLTEXT("IOemCB::DisablePDEV() entry.\r\n"));
    return E_NOTIMPL;
};

STDMETHODIMP
IOemCB::GetInfo (
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
/*++

Routine Description:

    IPrintOemUni GetInfo interface

Arguments:


Return Value:


Note:


--*/
{
    LPTSTR OEM_INFO[] = {   __TEXT("Bad Index"),
                            __TEXT("OEMGI_GETSIGNATURE"),
                            __TEXT("OEMGI_GETINTERFACEVERSION"),
                            __TEXT("OEMGI_GETVERSION"),
                        };

    DebugMsg(DLLTEXT("IOemCB::GetInfo(%s) entry.\r\n"), OEM_INFO[dwMode]);

    //
    // Validate parameters.
    //
    if( ( (OEMGI_GETSIGNATURE != dwMode) &&
          (OEMGI_GETINTERFACEVERSION != dwMode) &&
          (OEMGI_GETVERSION != dwMode) ) ||
        (NULL == pcbNeeded)
      )
    {
        DebugMsg(ERRORTEXT("OEMGetInfo() ERROR_INVALID_PARAMETER.\r\n"));

        //
        // Did not write any bytes.
        //
        if(NULL != pcbNeeded)
                *pcbNeeded = 0;

        return S_FALSE;
    }

    //
    // Need/wrote 4 bytes.
    //
    *pcbNeeded = 4;

    //
    // Validate buffer size.  Minimum size is four bytes.
    //
    if( (NULL == pBuffer) || (4 > cbSize) )
    {
        DebugMsg(ERRORTEXT("OEMGetInfo() ERROR_INSUFFICIENT_BUFFER.\r\n"));

        return S_FALSE;
    }

    //
    // Write information to buffer.
    //
    switch(dwMode)
    {
    case OEMGI_GETSIGNATURE:
        *(LPDWORD)pBuffer = OEM_SIGNATURE;
        break;

    case OEMGI_GETINTERFACEVERSION:
        *(LPDWORD)pBuffer = PRINTER_OEMINTF_VERSION;
        break;

    case OEMGI_GETVERSION:
        *(LPDWORD)pBuffer = OEM_VERSION;
        break;
    }

    return S_OK;
}


STDMETHODIMP
IOemCB::GetImplementedMethod(
    PSTR pMethodName)
/*++

Routine Description:

    IPrintOemUni GetImplementedMethod interface

Arguments:


Return Value:


Note:


--*/
{

    LONG lReturn;
    DebugMsg(DLLTEXT("IOemCB::GetImplementedMethod() entry.\r\n"));
    DebugMsg(DLLTEXT("        Function:%s:"),pMethodName);

    lReturn = FALSE;
    if (pMethodName != NULL)
    {
        switch (*pMethodName)
        {
            case (WCHAR)'F':
                if (!strcmp(pstrFilterGraphics, pMethodName))
                    lReturn = TRUE;
                break;

            case (WCHAR)'G':
                if (!strcmp(pstrGetInfo, pMethodName))
                    lReturn = TRUE;
                break;
        }
    }

    if (lReturn)
    {
        DebugMsg(__TEXT("Supported\r\n"));
        return S_OK;
    }
    else
    {
        DebugMsg(__TEXT("NOT supported\r\n"));
        return S_FALSE;
    }
}

STDMETHODIMP
IOemCB::DevMode(
    DWORD       dwMode,
    POEMDMPARAM pOemDMParam)
/*++

Routine Description:

    IPrintOemUni DevMode interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::DevMode() entry.\r\n"));
    return E_NOTIMPL;
}


STDMETHODIMP
IOemCB::CommandCallback(
    PDEVOBJ     pdevobj,
    DWORD       dwCallbackID,
    DWORD       dwCount,
    PDWORD      pdwParams,
    OUT INT     *piResult)
/*++

Routine Description:

    IPrintOemUni CommandCallback interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::CommandCallback() entry.\r\n"));
    DebugMsg(DLLTEXT("        dwCallbackID = %d\r\n"), dwCallbackID);
    DebugMsg(DLLTEXT("        dwCount      = %d\r\n"), dwCount);

    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::ImageProcessing(
    PDEVOBJ             pdevobj,
    PBYTE               pSrcBitmap,
    PBITMAPINFOHEADER   pBitmapInfoHeader,
    PBYTE               pColorTable,
    DWORD               dwCallbackID,
    PIPPARAMS           pIPParams,
    OUT PBYTE           *ppbResult)
/*++

Routine Description:

    IPrintOemUni ImageProcessing interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::ImageProcessing() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::FilterGraphics(
    PDEVOBJ     pdevobj,
    PBYTE       pBuf,
    DWORD       dwLen)
/*++

Routine Description:

    IPrintOemUni FilterGraphics interface

Arguments:


Return Value:


Note:


--*/
{
    DWORD dwResult;
    DebugMsg(DLLTEXT("IOemCB::FilterGraphis() entry.\r\n"));


    /*
     *    Easy to do - translate the input using FlipTable,  then call the
     *  Unidrv function DrvWriteSpoolBuf.
     */

    BYTE  *pb;
    DWORD   i;

    for( pb = pBuf, i = 0; i < dwLen; i++, pb++ )
	{	
	    *pb = FlipTable[ *pb ];
	}


    if(!SUCCEEDED(pOEMHelp->DrvWriteSpoolBuf( pdevobj, pBuf, dwLen, &dwResult )) || dwResult != dwLen)
	return E_FAIL;
    else	
        return S_OK;


}

STDMETHODIMP
IOemCB::Compression(
    PDEVOBJ     pdevobj,
    PBYTE       pInBuf,
    PBYTE       pOutBuf,
    DWORD       dwInLen,
    DWORD       dwOutLen,
    OUT INT     *piResult)
/*++

Routine Description:

    IPrintOemUni Compression interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::Compression() entry.\r\n"));
    return E_NOTIMPL;
}


STDMETHODIMP
IOemCB::HalftonePattern(
    PDEVOBJ     pdevobj,
    PBYTE       pHTPattern,
    DWORD       dwHTPatternX,
    DWORD       dwHTPatternY,
    DWORD       dwHTNumPatterns,
    DWORD       dwCallbackID,
    PBYTE       pResource,
    DWORD       dwResourceSize)
/*++

Routine Description:

    IPrintOemUni HalftonePattern interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::HalftonePattern() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::MemoryUsage(
    PDEVOBJ         pdevobj,
    POEMMEMORYUSAGE pMemoryUsage)
/*++

Routine Description:

    IPrintOemUni MemoryUsage interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::MemoryUsage() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::DownloadFontHeader(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult)
/*++

Routine Description:

    IPrintOemUni DownloadFontHeader interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::DownloadFontHeader() entry.\r\n"));

    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::DownloadCharGlyph(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    HGLYPH      hGlyph,
    PDWORD      pdwWidth,
    OUT DWORD   *pdwResult)
/*++

Routine Description:

    IPrintOemUni DownloadCharGlyph interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::DownloadCharGlyph() entry.\r\n"));

    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::TTDownloadMethod(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    OUT DWORD   *pdwResult)
/*++

Routine Description:

    IPrintOemUni TTDownloadMethod interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::TTDownloadMethod() entry.\r\n"));

    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::OutputCharStr(
    PDEVOBJ     pdevobj,
    PUNIFONTOBJ pUFObj,
    DWORD       dwType,
    DWORD       dwCount,
    PVOID       pGlyph)
/*++

Routine Description:

    IPrintOemUni OutputCharStr interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::OutputCharStr() entry.\r\n"));

    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::SendFontCmd(
    PDEVOBJ      pdevobj,
    PUNIFONTOBJ  pUFObj,
    PFINVOCATION pFInv)
/*++

Routine Description:

    IPrintOemUni SendFontCmd interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::SendFontCmd() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::DriverDMS(
    PVOID   pDevObj,
    PVOID   pBuffer,
    DWORD   cbSize,
    PDWORD  pcbNeeded)
/*++

Routine Description:

    IPrintOemUni DriverDMS interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::DriverDMS() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::TextOutAsBitmap(
    SURFOBJ    *pso,
    STROBJ     *pstro,
    FONTOBJ    *pfo,
    CLIPOBJ    *pco,
    RECTL      *prclExtra,
    RECTL      *prclOpaque,
    BRUSHOBJ   *pboFore,
    BRUSHOBJ   *pboOpaque,
    POINTL     *pptlOrg,
    MIX         mix)
/*++

Routine Description:

    IPrintOemUni TextOutAsBitmap interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::TextOutAsBitmap() entry.\r\n"));
    return E_NOTIMPL;
}

STDMETHODIMP
IOemCB::TTYGetInfo(
    PDEVOBJ     pdevobj,
    DWORD       dwInfoIndex,
    PVOID       pOutputBuf,
    DWORD       dwSize,
    DWORD       *pcbcNeeded)
/*++

Routine Description:

    IPrintOemUni TTYGetInfo interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("IOemCB::TTYGetInfo() entry.\r\n"));
    return E_NOTIMPL;
}


///////////////////////////////////////////////////////////
//
// Interface Oem Class factory body
//
STDMETHODIMP
IOemCF::QueryInterface(
    const IID& iid,
    void** ppv)
/*++

Routine Description:

    Class Factory QueryInterface interface

Arguments:


Return Value:


Note:


--*/
{
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        *ppv = static_cast<IOemCF*>(this) ;
    }
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
    reinterpret_cast<IUnknown*>(*ppv)->AddRef() ;
    return S_OK ;
}

STDMETHODIMP_(ULONG)
    IOemCF::AddRef()
/*++

Routine Description:

    IPrintOemUni AddRef interface

Arguments:


Return Value:


Note:


--*/
{
    return InterlockedIncrement(&m_cRef) ;
}

STDMETHODIMP_(ULONG)
IOemCF::Release()
/*++

Routine Description:

    IPrintOemUni Release interface

Arguments:


Return Value:


Note:


--*/
{
    if (InterlockedDecrement(&m_cRef) == 0)
    {
        delete this ;
        return 0 ;
    }
    return m_cRef ;
}

STDMETHODIMP
IOemCF::CreateInstance(
    IUnknown* pUnknownOuter,
    const IID& iid,
    void** ppv)
/*++

Routine Description:

    IPrintOemUni CreateInstance interface

Arguments:


Return Value:


Note:


--*/
{
    DebugMsg(DLLTEXT("Class factory:\t\tCreate component.")) ;

    //
    // Cannot aggregate.
    //
    if (pUnknownOuter != NULL)
    {
        return CLASS_E_NOAGGREGATION ;
    }

    //
    // Create component.
    //
    IOemCB* pOemCB = new IOemCB ;
    if (pOemCB == NULL)
    {
        return E_OUTOFMEMORY ;
    }

    //
    // Get the requested interface.
    //
    HRESULT hr = pOemCB->QueryInterface(iid, ppv) ;

    //
    // Release the IUnknown pointer.
    // (If QueryInterface failed, component will delete itself.)
    //
    pOemCB->Release() ;
    return hr ;
}

STDMETHODIMP
IOemCF::LockServer(
    BOOL bLock)
/*++

Routine Description:

    Class Factory LockServer interface

Arguments:


Return Value:


Note:


--*/
{
    if (bLock)
    {
        InterlockedIncrement(&g_cServerLocks) ;
    }
    else
    {
        InterlockedDecrement(&g_cServerLocks) ;
    }
    return S_OK ;
}

IOemCB::~IOemCB()
{
    // Make sure that driver's helper function interface is released.
    if(NULL != pOEMHelp)
    {
        pOEMHelp->Release();
        pOEMHelp = NULL;
    }

    // If this instance of the object is being deleted, then the reference
    // count should be zero.
    assert(0 == m_cRef);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\citohres\pdev.h ===
/*++

Copyright (C) 1997 - 1999 Microsoft Corporation

--*/

#ifndef _PDEV_H
#define _PDEV_H

#include <minidrv.h>

//
// Debug text.
//
#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)
#define TESTSTRING      "Callback for C-Itoh printers."

typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER  dmExtraHdr;
    BYTE               cbTestString[sizeof(TESTSTRING)];
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

//
// OEM Signature and version.
//
#define OEM_SIGNATURE   'CITH'      // Declaser series dll
#define DLLTEXT(s)      __TEXT("CITOHRES:  ") __TEXT(s)
#define OEM_VERSION      0x00010000L

//
// Memory allocation
//
#define MemAlloc(size)      ((PVOID) LocalAlloc(LMEM_FIXED, (size)))
#define MemAllocZ(size)     ((PVOID) LocalAlloc(LPTR, (size)))
#define MemFree(p)          { if (p) LocalFree((HLOCAL) (p)); }

#ifdef DBG
#define DebugMsg
#else
#define DebugMsg
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\citohres\fliptab.h ===
0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 
    0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0, 
    0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8, 
    0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8, 
    0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4, 
    0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4, 
    0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec, 
    0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc, 
    0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2, 
    0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2, 
    0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea, 
    0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa, 
    0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6, 
    0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6, 
    0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee, 
    0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe, 
    0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1, 
    0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1, 
    0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9, 
    0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9, 
    0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5, 
    0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5, 
    0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed, 
    0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd, 
    0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3, 
    0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3, 
    0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb, 
    0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb, 
    0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7, 
    0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7, 
    0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef, 
    0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff,
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\citohres\name.h ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    name.h

Abstract:

    Interface Function name strings for PublishInterface

--*/
CONST CHAR pstrGetInfo[]                = "GetInfo";
CONST CHAR pstrFilterGraphics[]         = "FilterGraphics";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\citohres\oemud.h ===
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
//  PARTICULAR PURPOSE.
//
//  Copyright  1999  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:       OEMUD.H
//
//
//  PURPOSE:    Define common data types, and external function prototypes
//                              for OEMUD Test Module.
//
//  PLATFORMS:
//    Windows NT 5.0
//
//
#ifndef _OEMUD_H
#define _OEMUD_H


#include <lib.h>

#include <PRINTOEM.H>



////////////////////////////////////////////////////////
//      OEM UD Defines
////////////////////////////////////////////////////////

#define VALID_PDEVOBJ(pdevobj) \
        ((pdevobj) && (pdevobj)->dwSize >= sizeof(DEVOBJ) && \
         (pdevobj)->hEngine && (pdevobj)->hPrinter && \
         (pdevobj)->pPublicDM && (pdevobj)->pDrvProcs )

//
// ASSERT_VALID_PDEVOBJ can be used to verify the passed in "pdevobj". However,
// it does NOT check "pdevOEM" and "pOEMDM" fields since not all OEM DLL's create
// their own pdevice structure or need their own private devmode. If a particular
// OEM DLL does need them, additional checks should be added. For example, if
// an OEM DLL needs a private pdevice structure, then it should use
// ASSERT(VALID_PDEVOBJ(pdevobj) && pdevobj->pdevOEM && ...)
//
#define ASSERT_VALID_PDEVOBJ(pdevobj) ASSERT(VALID_PDEVOBJ(pdevobj))

// Debug text.
#define ERRORTEXT(s)    __TEXT("ERROR ") DLLTEXT(s)


#if 0
////////////////////////////////////////////////////////
//      OEM UD Type Defines
////////////////////////////////////////////////////////

#define TESTSTRING      "This is a Unidrv KM test."

typedef struct tag_OEMUD_EXTRADATA {
    OEM_DMEXTRAHEADER  dmExtraHdr;
    BYTE               cbTestString[sizeof(TESTSTRING)];
} OEMUD_EXTRADATA, *POEMUD_EXTRADATA;

#endif // 0

////////////////////////////////////////////////////////
//      OEM UD Prototypes
////////////////////////////////////////////////////////

#if DBG // For Check Build

#define OEMDBGP(msg)    DbgPrint msg;

#ifndef USERMODE_DRIVER
VOID DbgPrint(IN LPCTSTR pstrFormat,  ...);
#else
extern ULONG _cdecl DbgPrint(PCSTR, ...);
#endif //USERMODE_DRIVER

#else // Free Build

#define OEMDBGP(msg)

#endif //DBG



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\citohres\comoem.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

     comoem.h

Abstract:

    

Environment:

         Windows NT Unidrv driver

Revision History:

              Created it.

--*/


////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem Class Factory definition
//

class IOemCF : public IClassFactory
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_
                               LPUNKNOWN pUnkOuter,
                               REFIID riid,
                               LPVOID FAR* ppvObject);
    STDMETHOD(LockServer)     (THIS_ BOOL bLock);


    // Constructor
    IOemCF(): m_cRef(1) { };
    ~IOemCF() { };

protected:
    LONG m_cRef;

};

////////////////////////////////////////////////////////////////////////////////
//
// Interface Oem CallBack definition
//
class IOemCB:public IPrintOemUni
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)  (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    //
    // Method for publishing Driver interface.
    //
    STDMETHOD(PublishDriverInterface)(THIS_ IUnknown *pIUnknown);

   //
   // Method for getting the implemented methods.
   // Returns S_OK if the given method is implemneted.
   // Returns S_FALSE if the given method is notimplemneted.
   //

   STDMETHOD(GetImplementedMethod)(THIS_ PSTR pMethodName);

    //
    // Method for OEM to specify DDI hook out
    //

    STDMETHOD(EnableDriver)  (THIS_ DWORD           DriverVersion,
                                    DWORD           cbSize,
                                    PDRVENABLEDATA  pded);

    //
    // Method to notify OEM plugin that it is no longer required
    //

    STDMETHOD(DisableDriver) (THIS);

    //
    // Method for OEM to contruct its own PDEV
    //

    STDMETHOD(EnablePDEV)    (THIS_ PDEVOBJ         pdevobj,
                                    PWSTR           pPrinterName,
                                    ULONG           cPatterns,
                                    HSURF          *phsurfPatterns,
                                    ULONG           cjGdiInfo,
                                    GDIINFO        *pGdiInfo,
                                    ULONG           cjDevInfo,
                                    DEVINFO        *pDevInfo,
                                    DRVENABLEDATA  *pded,
                                    OUT PDEVOEM    *pDevOem);

    //
    // Method for OEM to free any resource associated with its PDEV
    //

    STDMETHOD(DisablePDEV)   (THIS_ PDEVOBJ         pdevobj);

    //
    // Method for OEM to transfer from old PDEV to new PDEV
    //

    STDMETHOD(ResetPDEV)     (THIS_ PDEVOBJ         pdevobjOld,
                                    PDEVOBJ        pdevobjNew);

    //
    // Get OEM dll related information
    //

    STDMETHOD(GetInfo) (THIS_ DWORD   dwMode,
                              PVOID   pBuffer,
                              DWORD   cbSize,
                              PDWORD  pcbNeeded);

    //
    // OEMDriverDMS - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(DriverDMS)(THIS_ PVOID   pDevObj,
                               PVOID   pBuffer,
                               DWORD   cbSize,
                               PDWORD  pcbNeeded);

    //
    // OEMDevMode
    //

    STDMETHOD(DevMode) (THIS_ DWORD       dwMode,
                              POEMDMPARAM pOemDMParam);

    //
    // OEMCommandCallback - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(CommandCallback)(THIS_ PDEVOBJ     pdevobj,
                                     DWORD       dwCallbackID,
                                     DWORD       dwCount,
                                     PDWORD      pdwParams,
                                     OUT INT     *piResult);

    //
    // OEMImageProcessing - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(ImageProcessing)(THIS_ PDEVOBJ             pdevobj,
                                     PBYTE               pSrcBitmap,
                                     PBITMAPINFOHEADER   pBitmapInfoHeader,
                                     PBYTE               pColorTable,
                                     DWORD               dwCallbackID,
                                     PIPPARAMS           pIPParams,
                                     OUT PBYTE           *ppbResult);

    //
    // OEMFilterGraphics - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(FilterGraphics) (THIS_    PDEVOBJ     pdevobj,
                                        PBYTE       pBuf,
                                        DWORD       dwLen);
    //
    // OEMCompression - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(Compression)(THIS_    PDEVOBJ     pdevobj,
                                    PBYTE       pInBuf,
                                    PBYTE       pOutBuf,
                                    DWORD       dwInLen,
                                    DWORD       dwOutLen,
                                    OUT INT     *piResult);

    //
    // OEMHalftone - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(HalftonePattern) (THIS_   PDEVOBJ     pdevobj,
                                        PBYTE       pHTPattern,
                                        DWORD       dwHTPatternX,
                                        DWORD       dwHTPatternY,
                                        DWORD       dwHTNumPatterns,
                                        DWORD       dwCallbackID,
                                        PBYTE       pResource,
                                        DWORD       dwResourceSize);

    //
    // OEMMemoryUsage - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(MemoryUsage) (THIS_   PDEVOBJ         pdevobj,
                                    POEMMEMORYUSAGE pMemoryUsage);

    //
    // OEMTTYGetInfo - UNIDRV only, return E_NOTIMPL on Pscript
    //

    STDMETHOD(TTYGetInfo)(THIS_     PDEVOBJ     pdevobj,
                                    DWORD       dwInfoIndex,
                                    PVOID       pOutputBuf,
                                    DWORD       dwSize,
                                    DWORD       *pcbcNeeded);

    //
    // OEMDownloadFontheader - UNIDRV only
    //

    STDMETHOD(DownloadFontHeader)(THIS_     PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMDownloadCharGlyph - UNIDRV only
    //

    STDMETHOD(DownloadCharGlyph)(THIS_      PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            HGLYPH      hGlyph,
                                            PDWORD      pdwWidth,
                                            OUT DWORD   *pdwResult);

    //
    // OEMTTDownloadMethod - UNIDRV only
    //

    STDMETHOD(TTDownloadMethod)(THIS_       PDEVOBJ     pdevobj,
                                            PUNIFONTOBJ pUFObj,
                                            OUT DWORD   *pdwResult);

    //
    // OEMOutputCharStr - UNIDRV only
    //

    STDMETHOD(OutputCharStr)(THIS_      PDEVOBJ     pdevobj,
                                        PUNIFONTOBJ pUFObj,
                                        DWORD       dwType,
                                        DWORD       dwCount,
                                        PVOID       pGlyph);

    //
    // OEMSendFontCmd - UNIDRV only
    //


    STDMETHOD(SendFontCmd)(THIS_    PDEVOBJ      pdevobj,
                                    PUNIFONTOBJ  pUFObj,
                                    PFINVOCATION pFInv);

    //
    // OEMTextOutAsBitmap - UNIDRV only
    //

    STDMETHOD(TextOutAsBitmap)(THIS_        SURFOBJ    *pso,
                                            STROBJ     *pstro,
                                            FONTOBJ    *pfo,
                                            CLIPOBJ    *pco,
                                            RECTL      *prclExtra,
                                            RECTL      *prclOpaque,
                                            BRUSHOBJ   *pboFore,
                                            BRUSHOBJ   *pboOpaque,
                                            POINTL     *pptlOrg,
                                            MIX         mix);

    IOemCB() { m_cRef = 1; pOEMHelp = NULL; };
    ~IOemCB();

protected:
    IPrintOemDriverUni* pOEMHelp;
    LONG m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\cnepkres\etc\canonch.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------
char *rgchModuleName = "CANONCH";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\print\drivers\usermode\gpdres\cnl4jres\cnl4jres.c ===
//-----------------------------------------------------------------------------
// This files contains the module name for this mini driver.  Each mini driver
// must have a unique module name.  The module name is used to obtain the
// module handle of this Mini Driver.  The module handle is used by the
// generic library to load in tables from the Mini Driver.
//-----------------------------------------------------------------------------

/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    cmdcb.c

Abstract:

    Implementation of GPD command callback for "test.gpd":
        OEMCommandCallback

Environment:

    Windows NT Unidrv driver

Revision History:

    04/07/97 -zhanw-
        Created it.

--*/

#define LIPS4_DRIVER
#include "pdev.h"

LONG
LGetPointSize100(
    LONG height,
    LONG vertRes);

LONG
LConvertFontSizeToStr(
    LONG  size,
    PSTR  pStr);

#define CCHMAXCMDLEN 256
#define SWAPW(x)    (((WORD)(x)<<8) | ((WORD)(x)>>8))
#define ABS(x)      (x > 0?x:-x)

#define WRITESPOOLBUF(pdevobj, cmd, len) \
	(pdevobj)->pDrvProcs->DrvWriteSpoolBuf(pdevobj, cmd, len)

#ifdef wsprintf
#undef wsprintf
#endif // wsprintf
#define wsprintf sprintf

// #289908: pOEMDM -> pdevOEM
PDEVOEM APIENTRY
OEMEnablePDEV(
    PDEVOBJ         pdevobj,
    PWSTR           pPrinterName,
    ULONG           cPatterns,
    HSURF          *phsurfPatterns,
    ULONG           cjGdiInfo,
    GDIINFO        *pGdiInfo,
    ULONG           cjDevInfo,
    DEVINFO        *pDevInfo,
    DRVENABLEDATA  *pded)
{
    PLIPSPDEV pOEM;

    if(!pdevobj->pdevOEM)
    {
        if(!(pdevobj->pdevOEM = MemAllocZ(sizeof(LIPSPDEV))))
        {
        //  ERR(("Faild to allocate memory. (%d)\n",
        //      GetLastError()));
            return NULL;
        }
    }

    pOEM = (PLIPSPDEV)pdevobj->pdevOEM;

    // Flags
    pOEM->fbold = FALSE; // uses Ornamented Character
    pOEM->fitalic = FALSE; // uses Char Orientatoin
    pOEM->fwhitetext = FALSE; // White Text mode
    pOEM->fdoublebyte = FALSE; // DBCS char mode
    pOEM->fvertical = FALSE; // Vertical writing mode
    pOEM->funderline = FALSE;
    pOEM->fstrikesthu = FALSE;
    pOEM->fpitch = FIXED;
    pOEM->flpdx = FALSE;
    pOEM->fcompress = 0x30; // default is non compress
    // Lips4 features
    pOEM->fduplex  = FALSE;
    pOEM->fduplextype  = VERT;
    pOEM->nxpages      = DEVICESETTING;
    pOEM->fsmoothing   = DEVICESETTING;
    pOEM->fecono       = DEVICESETTING;
    pOEM->fdithering   = DEVICESETTING;

    // Variables
    pOEM->ptCurrent.x  = pOEM->ptCurrent.y = 0;
    pOEM->ptInLine.x   = pOEM->ptInLine.y  = 0;
    pOEM->bLogicStyle  = INIT;
    pOEM->savechar     = -1;
    pOEM->printedchars = 0;
    pOEM->firstchar    = 0;
    pOEM->lastchar     = 0;
    pOEM->stringwidth  = 0;

    pOEM->curFontGrxIds[0] = pOEM->curFo